RY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\t30ext\t30propsheetext.cpp ===
// T30PropSheetExt.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f T30PropSheetExtps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "T30PropSheetExt.h"

#include "T30Prop_i.c"
#include "T30Config.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_T30Config, CT30Config)
OBJECT_ENTRY(CLSID_T30ConfigAbout, CT30ConfigAbout)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_T30PROPSHEETEXTLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\uilib\addressdlg.h ===
#ifndef _FAX_ADDRESS_DIALOG_H_
#define _FAX_ADDRESS_DIALOG_H_

#include <windows.h>
#include <windowsx.h>

#include <fxsapip.h>
#include <faxutil.h>
#include <faxuiconstants.h>

#include "AddressDlgRes.h"

#ifdef __cplusplus
extern "C" {
#endif

INT_PTR 
DoModalAddressDlg(
	HINSTANCE hResourceInstance, 
	HWND hWndParent, 
	PFAX_PERSONAL_PROFILE pUserInfo
);

#ifdef __cplusplus
}
#endif

#endif // _FAX_ADDRESS_DIALOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\t30ext\t30config.cpp ===
#include "stdafx.h"
#include "T30PropSheetExt.h"
#include "T30Config.h"
#include <t30ext.h>
#include <faxutil.h>
#include <faxreg.h>
#include <faxres.h>
/////////////////////////////////////////////////////////////////////////////
// CT30ConfigComponentData
static const GUID CT30ConfigExtGUID_NODETYPE = FAXSRV_DEVICE_NODETYPE_GUID;

//{ 0x3115a19a, 0x6251, 0x46ac, { 0x94, 0x25, 0x14, 0x78, 0x28, 0x58, 0xb8, 0xc9 } };
const GUID*  CT30ConfigExtData::m_NODETYPE = &CT30ConfigExtGUID_NODETYPE;
const OLECHAR* CT30ConfigExtData::m_SZNODETYPE = FAXSRV_DEVICE_NODETYPE_GUID_STR; 
//OLESTR("3115A19A-6251-46ac-9425-14782858B8C9");
const OLECHAR* CT30ConfigExtData::m_SZDISPLAY_NAME = OLESTR("T30Config");
const CLSID* CT30ConfigExtData::m_SNAPIN_CLASSID = &CLSID_T30Config;


void DisplayRpcErrorMessage(DWORD ec, HWND hWnd);
void DisplayErrorMessage(UINT uMsgId, HWND hWnd, BOOL bCommon = FALSE);

HRESULT GetDWORDFromDataObject(
    IDataObject * lpDataObject, 
    CLIPFORMAT uFormat,
    LPDWORD lpdwValue
    );

HRESULT GetStringFromDataObject(
    IDataObject * lpDataObject, 
    CLIPFORMAT uFormat,
    LPWSTR lpwstrBuf, 
    DWORD dwBufLen
    );


HRESULT CT30ConfigExtData::QueryPagesFor(DATA_OBJECT_TYPES type)

{
    DEBUG_FUNCTION_NAME(TEXT("CT30ConfigExtData::QueryPagesFor"));


	if (type == CCT_SCOPE || type == CCT_RESULT)
    {
        WCHAR szFSPGuid[FAXSRV_MAX_GUID_LEN + 1];
        HRESULT hr;

        hr = GetStringFromDataObject(m_pDataObject,m_CCF_FSP_GUID, szFSPGuid,sizeof(szFSPGuid)/sizeof(WCHAR));
        if (FAILED(hr))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("GetFSPGUIDFromDataObject failed. hr = 0x%08X"),
                hr);
            return hr;
        }
    
        if (!lstrcmpi(szFSPGuid,REGVAL_T30_PROVIDER_GUID_STRING))
        {
            return S_OK;
        }
        else
        {
            return S_FALSE;
        }

    }
	
	return S_FALSE;
}

HRESULT CT30ConfigExtData::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
    LONG_PTR handle, 
	IUnknown* pUnk,
	DATA_OBJECT_TYPES type)
{
    DEBUG_FUNCTION_NAME(TEXT("CT30ConfigExtData::CreatePropertyPages"));

    WCHAR szFSPGuid[FAXSRV_MAX_GUID_LEN + 1];
    WCHAR szServer[FAXSRV_MAX_SERVER_NAME + 1];

    DWORD dwDeviceId;
    HRESULT hr;

    hr = GetStringFromDataObject(m_pDataObject,m_CCF_FSP_GUID, szFSPGuid,sizeof(szFSPGuid)/sizeof(WCHAR));
    if (FAILED(hr))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetFSPGUIDFromDataObject for m_CCF_FSP_GUID failed. hr = 0x%08X"),
            hr);
        return hr;
    }
    
    if (lstrcmpi(szFSPGuid,REGVAL_T30_PROVIDER_GUID_STRING))
    {
        return E_UNEXPECTED;
    }

    hr = GetStringFromDataObject(m_pDataObject,m_CCF_SERVER_NAME, szServer,sizeof(szServer)/sizeof(WCHAR));
    if (FAILED(hr))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetFSPGUIDFromDataObject for m_CCF_SERVER_NAME failed. hr = 0x%08X"),
            hr);
        return hr;
    }
    

    hr = GetDWORDFromDataObject(m_pDataObject,m_CCF_FSP_DEVICE_ID,&dwDeviceId);

    if (FAILED(hr))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetDeviceIdFromDataObject failed. hr = 0x%08X"),
            hr);
        return hr;
    }

    CComBSTR bstrPageTitle;
    bstrPageTitle.LoadString(IDS_T30PAGE_TITLE);
    if (!bstrPageTitle)
    {
        return E_UNEXPECTED;
    }
	CT30ConfigPage* pPage = new CT30ConfigPage(handle, true, bstrPageTitle); // true = only one page
    if (!pPage)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to allocate CT30ConfigPage")
            );
        return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    }

	hr = pPage->Init(szServer, dwDeviceId);
    if (SUCCEEDED(hr))
    {
        lpProvider->AddPage(pPage->Create());
    }
    else
    {
        return E_UNEXPECTED;
    }
	
	return S_OK;

	
}



HRESULT CT30ConfigPage::Init(LPCTSTR lpctstrServerName, DWORD dwDeviceId)
{
    DEBUG_FUNCTION_NAME(TEXT("CT30ConfigPage::Init"));
    
    LPT30_EXTENSION_DATA lpExtData = NULL;
    DWORD dwDataSize = 0;
    DWORD ec = ERROR_SUCCESS;

    m_dwDeviceId = dwDeviceId;

    m_bstrServerName = lpctstrServerName;
    if (!m_bstrServerName)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Out of memory while copying server name (ec: %ld)")
        );
        ec = ERROR_NOT_ENOUGH_MEMORY;
        DisplayRpcErrorMessage(ERROR_NOT_ENOUGH_MEMORY, m_hWnd);
        goto exit;
    }

    if (!FaxConnectFaxServer(lpctstrServerName,&m_hFax))
    {
        DWORD ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FaxConnectFaxServer failed (ec: %ld)"),
            ec);
        DisplayRpcErrorMessage(ec, m_hWnd);
        goto exit;
    }

    if(!FaxGetExtensionData(
            m_hFax,
            m_dwDeviceId,
            GUID_T30_EXTENSION_DATA,
            (PVOID *)&lpExtData,
            &dwDataSize
        ))
    {
        DWORD ec = GetLastError();
        

        lpExtData = NULL;
        if (ERROR_FILE_NOT_FOUND == ec)
        {
            DebugPrintEx(
            DEBUG_ERR,
            TEXT("T30 Data not found. Device: 0x%08X, GUID: %s"),
            m_dwDeviceId,
            GUID_T30_EXTENSION_DATA);
            ec = ERROR_SUCCESS;
            m_bAdaptiveAnsweringEnabled = FALSE;
        }
        else
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("T30 FaxGetExtensionData() failed. GUID = %s (ec: %ld)"),
                GUID_T30_EXTENSION_DATA,
                ec);
            DisplayRpcErrorMessage(ec, m_hWnd);
        }

        goto exit;
    }

    if (dwDataSize != sizeof(T30_EXTENSION_DATA))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("T30 FaxGetExtensionData() returned mismatched data size (%ld)"),
            dwDataSize);
        ec = ERROR_BAD_FORMAT;
        DisplayErrorMessage(IDS_ERR_BAD_T30_CONFIGURATION, m_hWnd);
        goto exit;
    }

    m_bAdaptiveAnsweringEnabled = lpExtData->bAdaptiveAnsweringEnabled;

    Assert(ERROR_SUCCESS == ec);
    

exit:

    if ((ERROR_SUCCESS != ec) && m_hFax)
    {

        if (!FaxClose(m_hFax))
        {
            DWORD ec = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("FaxClose() failed on fax handle (0x%08X : %s). (ec: %ld)"),
                m_hFax,
                m_bstrServerName,
                ec);
        }
        m_hFax = NULL;
    }

    if (lpExtData)
    {
        FaxFreeBuffer(lpExtData);
        lpExtData = NULL;
    }
    

    return HRESULT_FROM_WIN32(ec);
}

LRESULT CT30ConfigPage::OnInitDialog( 
            UINT uiMsg, 
            WPARAM wParam, 
            LPARAM lParam, 
            BOOL& fHandled )
{
    DEBUG_FUNCTION_NAME( _T("CT30ConfigPage::OnInitDialog"));

    m_btnAdaptiveEnabled.Attach(GetDlgItem(IDC_ADAPTIVE_ANSWERING));
    m_btnAdaptiveEnabled.SetCheck(m_bAdaptiveAnsweringEnabled ? BST_CHECKED : BST_UNCHECKED);

    return 1;
}


BOOL CT30ConfigPage::OnApply()
{

    DEBUG_FUNCTION_NAME(TEXT("CT30ConfigPage::OnApply"));

    BOOL bRet = FALSE;


    T30_EXTENSION_DATA ExtData;
    
    memset(&ExtData,0,sizeof(ExtData));
    ExtData.bAdaptiveAnsweringEnabled = (BST_CHECKED == m_btnAdaptiveEnabled.GetCheck());


    if(!FaxSetExtensionData(
            m_hFax,
            m_dwDeviceId,
            GUID_T30_EXTENSION_DATA,
            (LPVOID)&ExtData,
            sizeof(ExtData)
        ))
    {
        DWORD ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("T30 FaxGetExtensionData() failed. GUID = %s (ec: %ld)"),
            GUID_T30_EXTENSION_DATA,
            ec);
        DisplayRpcErrorMessage(ec, m_hWnd);
    }
    else
    {
        bRet = TRUE;
    }
 
    return bRet;
}

HRESULT GetDWORDFromDataObject(
    IDataObject * lpDataObject, 
    CLIPFORMAT uFormat,
    LPDWORD lpdwValue
    )
{
    DEBUG_FUNCTION_NAME(TEXT("GetDWORDFromDataObject"));

    Assert(lpdwValue);
    Assert(0 != uFormat);

    STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
	FORMATETC formatetc = { 
        uFormat, 
		NULL, 
		DVASPECT_CONTENT, 
		-1, 
		TYMED_HGLOBAL 
	};

	stgmedium.hGlobal = GlobalAlloc(0, sizeof(DWORD));
	if (stgmedium.hGlobal == NULL)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GlobalAlloc() failed. (ec: %ld)"),
            GetLastError());
		return E_OUTOFMEMORY;
    }

	HRESULT hr = lpDataObject->GetDataHere(&formatetc, &stgmedium);
	if (SUCCEEDED(hr))
	{
        *lpdwValue = *((LPDWORD)stgmedium.hGlobal);
	}
    else
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetDataHere() failed. (hr = 0x%08X)"),
            hr);
    }
	
	GlobalFree(stgmedium.hGlobal);

    return hr;
}



HRESULT GetStringFromDataObject(
    IDataObject * lpDataObject, 
    CLIPFORMAT uFormat,
    LPWSTR lpwstrBuf, 
    DWORD dwBufLen
    )
{
    DEBUG_FUNCTION_NAME(TEXT("GetStringFromDataObject"));
    Assert(lpDataObject);
    Assert(lpwstrBuf);
    Assert(dwBufLen>0);

    STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
	FORMATETC formatetc = 
        {   
            uFormat, 
		    NULL, 
		    DVASPECT_CONTENT, 
		    -1, 
		    TYMED_HGLOBAL 
	    };

	stgmedium.hGlobal = GlobalAlloc(0, dwBufLen*sizeof(WCHAR));
	if (stgmedium.hGlobal == NULL)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GlobalAlloc() failed. (ec: %ld)"),
            GetLastError());
		return E_OUTOFMEMORY;
    }

	HRESULT hr = lpDataObject->GetDataHere(&formatetc, &stgmedium);
	if (SUCCEEDED(hr))
	{
        lstrcpyn(lpwstrBuf,(LPWSTR)stgmedium.hGlobal,dwBufLen);
        lpwstrBuf[dwBufLen-1]=L'\0';
	}
    else
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetDataHere() failed. (hr = 0x%08X)"),
            hr);
    }
	
	GlobalFree(stgmedium.hGlobal);
    return hr;
}

void DisplayRpcErrorMessage(DWORD ec, HWND hWnd)
{
    
    UINT uMsgId;
    uMsgId = GetRpcErrorStringId(ec);
    DisplayErrorMessage(uMsgId, hWnd, TRUE); // use the common error messages DLL
}

void DisplayErrorMessage(UINT uMsgId, HWND hWnd, BOOL bCommon)
{
    static HINSTANCE hInst = NULL;
    static CComBSTR bstrCaption = TEXT("");
    
    CComBSTR bstrMsg;
    
    if (!hInst && bCommon)
    {
        hInst = GetResInstance();
    }

    if (!lstrcmp(bstrCaption.m_str,TEXT("")))
    {
        bstrCaption.LoadString(IDS_T30PAGE_TITLE);
        if (!bstrCaption)
        {
            bstrCaption = TEXT("");
            return;
        }
    }
    
    if (bCommon) 
    {
        bstrMsg.LoadString(hInst,uMsgId);
    }
    else
    {
        bstrMsg.LoadString(uMsgId);
    }

    if (bstrMsg)
    {
        AlignedMessageBox(hWnd, bstrMsg, bstrCaption, MB_OK|MB_ICONEXCLAMATION);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\uilib\sources.inc ===
!include ..\..\..\faxsrc.inc

TARGETNAME=faxuilib
TARGETPATH=obj
TARGETTYPE=LIBRARY

INCLUDES = $(INCLUDES);

SOURCES=AddressDlg.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\uilib\addressdlgres.h ===
// AddressDlgRes.h
// resource file of Address dialog

#ifndef _FAX_ADDRESS_DIALOG_RES_H_
#define _FAX_ADDRESS_DIALOG_RES_H_

#define IDD_ADDRESS_DLG	   		    10101
#define IDC_STREET_TITLE            10102
#define IDC_SENDER_STREET           10103
#define IDCSTATIC_CITY              10104
#define IDC_SENDER_CITY             10105
#define IDCSTATIC_STATE             10106
#define IDC_SENDER_STATE            10107
#define IDCSTATIC_COUNTRY           10108
#define IDC_SENDER_COUNTRY          10109
#define IDCSTATIC_ZIPCODE           10110
#define IDC_SENDER_ZIPCODE          10111
#define IDC_ADDRESS_DETAILS         10112

#endif // _FAX_ADDRESS_DIALOG_RES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\admin\uilib\addressdlg.c ===
#include "AddressDlg.h"

typedef LONG (WINAPI *PFN_LINE_GET_COUNTRY)(DWORD, DWORD, LPLINECOUNTRYLIST);

VOID
AddrLimitTextFields(
    HWND    hDlg,
    INT    *pLimitInfo
    )

/*++

Routine Description:

    Limit the maximum length for a number of text fields

Arguments:

    hDlg - Specifies the handle to the dialog window
    pLimitInfo - Array of text field control IDs and their maximum length
        ID for the 1st text field, maximum length for the 1st text field
        ID for the 2nd text field, maximum length for the 2nd text field
        ...
        0
        Note: The maximum length counts the NUL-terminator.

Return Value:

    NONE

--*/

{
    while (*pLimitInfo != 0) {

        SendDlgItemMessage(hDlg, pLimitInfo[0], EM_SETLIMITTEXT, pLimitInfo[1]-1, 0);
        pLimitInfo += 2;
    }
}


DWORD 
FillInCountryCombo(
    HWND    hDlg
)
/*++

Routine name : FillInCountryCombo

Routine description:

	fill in combo box with countries names from TAPI

Arguments:

	hDlg - Handle to the User Info property sheet page

Return Value:

    Standard Win32 error code

--*/
{
    HWND        hControl;
    DWORD       dwRes = ERROR_SUCCESS;
    HINSTANCE   hInstTapi;
	DWORD       dw;
	LRESULT     lResult;
	TCHAR       *szCountryName;
	LONG        lRes;
	BYTE        *pBuffer;
	DWORD       dwBuffSize = 22*1024;
	DWORD       dwVersion = TAPI_CURRENT_VERSION;

	LINECOUNTRYLIST     *pLineCountryList = NULL;
	LINECOUNTRYENTRY    *pCountryEntry = NULL;

    PFN_LINE_GET_COUNTRY pfnLineGetCountry = NULL;

    DEBUG_FUNCTION_NAME(TEXT("FillInCountryCombo()"));

    hControl = GetDlgItem(hDlg, IDC_SENDER_COUNTRY);

	//
	// load TAPI32.DLL
	//
	hInstTapi = LoadLibrary(TEXT("TAPI32.DLL"));
	if(NULL == hInstTapi)
	{
		dwRes = GetLastError();
        DebugPrintEx(DEBUG_ERR, TEXT("LoadLibrary(\"TAPI32.DLL\") failed, ec = %d.\n"), dwRes);
		return dwRes;
	}

	//
	// get appropriate lineGetCountry function address
	//
#ifdef UNICODE
	pfnLineGetCountry = (PFN_LINE_GET_COUNTRY)GetProcAddress(hInstTapi, "lineGetCountryW");
#else
	pfnLineGetCountry = (PFN_LINE_GET_COUNTRY)GetProcAddress(hInstTapi, "lineGetCountryA");
	if (NULL == pfnLineGetCountry)
	{
		//
		// we assume that the TAPI version is 1.4
		// in TAPI version 0x00010004 there is only lineGetCountry function
		//
		dwVersion = 0x00010004;
		pfnLineGetCountry = (PFN_LINE_GET_COUNTRY)GetProcAddress(hInstTapi, "lineGetCountry");
	}
#endif
	if (NULL == pfnLineGetCountry)
	{
		dwRes = GetLastError();
        DebugPrintEx(DEBUG_ERR, TEXT("GetProcAddress(\"lineGetCountry\") failed, ec = %d.\n"), dwRes);
		goto exit;
	}
	
	while(TRUE)
	{
		//
		// allocate a buffer for country list
		//
		pBuffer = (BYTE*)MemAlloc(dwBuffSize);

        if(!pBuffer)
        {
			dwRes = ERROR_NOT_ENOUGH_MEMORY;
			DebugPrintEx(DEBUG_ERR, TEXT("Not enough memory.\n"));
			return dwRes;
		}

		pLineCountryList = (LINECOUNTRYLIST*)pBuffer;
		pLineCountryList->dwTotalSize = dwBuffSize;

		//
		// get TAPI country list
		//
		lRes = pfnLineGetCountry((DWORD)0, dwVersion, pLineCountryList);
		if((pLineCountryList->dwNeededSize > dwBuffSize) &&
		   (0 == lRes || LINEERR_STRUCTURETOOSMALL == lRes))
		{
			//
			// need more memory
			//
			dwBuffSize = pLineCountryList->dwNeededSize + 1;
			MemFree(pBuffer);
			continue;
		}
				
		if(0 != lRes)
		{
			dwRes = ERROR_CAN_NOT_COMPLETE;
			DebugPrintEx(DEBUG_ERR, TEXT("lineGetCountry failed, ec = %d.\n"), dwRes);
			goto exit;
		}

		//
		// success
		//
		break;				
	}

	pCountryEntry = (LINECOUNTRYENTRY*)(pBuffer + pLineCountryList->dwCountryListOffset);

	//
	// iterate into country list and fill in the combo box
	//
	for(dw=0; dw < pLineCountryList->dwNumCountries; ++dw)
	{
		szCountryName = (TCHAR*)(pBuffer + pCountryEntry[dw].dwCountryNameOffset);

		lResult = (DWORD)SendMessage(hControl, CB_ADDSTRING, 0, (LPARAM)szCountryName);
		if(CB_ERR == lResult)
		{
			dwRes = ERROR_CAN_NOT_COMPLETE;
	        DebugPrintEx(DEBUG_ERR, TEXT("Combo box addstring failed, ec = %d"), dwRes); 
			break;
		}
		if(CB_ERRSPACE == lResult)
		{
			dwRes = ERROR_NOT_ENOUGH_MEMORY;
	        DebugPrintEx(DEBUG_ERR, TEXT("Combo box addstring failed, no enough space.\n"));
			break;
		}
	}

exit:
	MemFree(pBuffer);

	if(!FreeLibrary(hInstTapi))
	{
		dwRes = GetLastError();
		DebugPrintEx(DEBUG_ERR, TEXT("FreeLibrary (TAPI32.DLL) failed, ec = %d.\n"), dwRes);
	}

	return dwRes;

} // FillInCountryCombo

#define InitUserInfoTextField(id, str) SetDlgItemText(hDlg, id, (str) ? str : TEXT(""));

#define SaveUserInfoTextField(id, str)									\
		{																\
			if (! GetDlgItemText(hDlg, id, szBuffer, MAX_PATH))			\
			{															\
                szBuffer[0] = 0;										\
			}															\
            MemFree(str);												\
            str = StringDup(szBuffer);									\
			if(!str)													\
			{															\
				DebugPrintEx(DEBUG_ERR, TEXT("StringDup failed.\n") );	\
				return FALSE;											\
			}															\
        }																\


INT_PTR CALLBACK 
AddressDetailDlgProc (
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
)
/*++

Routine Description:

    Procedure for handling the "Address Detail" tab

Arguments:

    hDlg - Identifies the property sheet page
    uMsg - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information

Return Value:

    Depends on the value of message parameter

--*/

{
    // Retrieve the shared user data from GWL_USERDATA
    PFAX_PERSONAL_PROFILE pUserInfo = (PFAX_PERSONAL_PROFILE) GetWindowLongPtr(hDlg, GWLP_USERDATA);

    switch (uMsg)
    {
    case WM_INITDIALOG :
        { 
            //
            // Maximum length for various text fields in the dialog
            //

            static INT textLimits[] = {

                IDC_SENDER_STREET,     MAX_USERINFO_STREET,
                IDC_SENDER_CITY,       MAX_USERINFO_CITY,
                IDC_SENDER_STATE,      MAX_USERINFO_STATE,
                IDC_SENDER_ZIPCODE,    MAX_USERINFO_ZIP_CODE,
                0,
            };

            AddrLimitTextFields(hDlg, textLimits);

            // Get the shared data from PROPSHEETPAGE lParam value
            // and load it into GWL_USERDATA

            pUserInfo = (PFAX_PERSONAL_PROFILE)lParam;

            SetWindowLongPtr(hDlg, GWLP_USERDATA, (DWORD_PTR) pUserInfo);

            //
            // Fill in the edit text fields
            //

            // macro is defined in DoInitUserInfo()
            InitUserInfoTextField(IDC_SENDER_STREET, pUserInfo->lptstrStreetAddress);
            InitUserInfoTextField(IDC_SENDER_CITY, pUserInfo->lptstrCity);
            InitUserInfoTextField(IDC_SENDER_STATE, pUserInfo->lptstrState);
            InitUserInfoTextField(IDC_SENDER_ZIPCODE, pUserInfo->lptstrZip);

            FillInCountryCombo(hDlg);
            SendMessage(GetDlgItem(hDlg, IDC_SENDER_COUNTRY), 
				        CB_SELECTSTRING, 
						(WPARAM)-1, 
						(LPARAM)pUserInfo->lptstrCountry);

            // disable the "ok" button if no info is changed
            EnableWindow(GetDlgItem(hDlg, IDOK), FALSE);

            return TRUE;
        }

    case WM_COMMAND:
    {
        switch(LOWORD(wParam))
        {
            case IDOK:
                if (BN_CLICKED == HIWORD(wParam))
                {
                    HWND    hControl;
                    INT     iItem;
                    TCHAR   szBuffer[MAX_PATH];
				    DEBUG_FUNCTION_NAME(TEXT("AddressDetailDlgProc(IDOK)"));

                    // macro is defined in DoSaveUserInfo()
                    SaveUserInfoTextField(IDC_SENDER_STREET, pUserInfo->lptstrStreetAddress);
                    SaveUserInfoTextField(IDC_SENDER_CITY, pUserInfo->lptstrCity);
                    SaveUserInfoTextField(IDC_SENDER_STATE, pUserInfo->lptstrState);
                    SaveUserInfoTextField(IDC_SENDER_ZIPCODE, pUserInfo->lptstrZip);

                    hControl = GetDlgItem(hDlg, IDC_SENDER_COUNTRY);
                    iItem = (INT)SendMessage(hControl, CB_GETCURSEL, 0, 0L);
                    if(iItem == CB_ERR)
                    {
                        szBuffer[0] = '\0';
                    }
                    else
                    {
                        SendMessage(hControl, CB_GETLBTEXT, (WPARAM)iItem, (LPARAM)szBuffer);
                    }
                    MemFree(pUserInfo->lptstrCountry);
                    pUserInfo->lptstrCountry = StringDup(szBuffer);
				    if(!pUserInfo->lptstrCountry)
				    {
					    DebugPrintEx(DEBUG_ERR, TEXT("StringDup failed.\n") );
				    }

                    EndDialog(hDlg, TRUE);
                    return TRUE;
                }
                break;

            case IDCANCEL:
                if (BN_CLICKED == HIWORD(wParam))
                {
                    EndDialog(hDlg, FALSE);
                    return TRUE;
                }
                break;

            case IDC_SENDER_STREET:
            case IDC_SENDER_CITY:
            case IDC_SENDER_STATE:
            case IDC_SENDER_ZIPCODE:

                if(HIWORD(wParam) == EN_CHANGE)
                {
                    EnableWindow(GetDlgItem(hDlg, IDOK), TRUE);
                }
                break;

            case IDC_SENDER_COUNTRY:

                if(HIWORD(wParam) == CBN_SELCHANGE)
                {
                    EnableWindow(GetDlgItem(hDlg, IDOK), TRUE);
                }
                break;

            default:
                break;
        }

        break;
    }

    case WM_HELP:
        WinHelpContextPopup(((LPHELPINFO)lParam)->dwContextId, hDlg);
        return TRUE;
    case WM_CONTEXTMENU:
        WinHelpContextPopup(GetWindowContextHelpId((HWND)wParam), hDlg);
        return TRUE;

    default:
        return FALSE;
    } ;

    return FALSE;
}

INT_PTR 
DoModalAddressDlg(
	HINSTANCE hResourceInstance, 
	HWND hWndParent, 
	PFAX_PERSONAL_PROFILE pUserInfo
)
/*++

Routine name : DoModalAddressDlg

Routine description:

	opens sender address dialog

Arguments:

	hInstance  - application instance
	hWndParent - parent window handle
	pUserInfo  - pointer to FAX_PERSONAL_PROFILE structure

Return Value:

    DialogBoxParam() result

--*/
{
	INT_PTR res;
	res =  DialogBoxParam(hResourceInstance, 
					      MAKEINTRESOURCE(IDD_ADDRESS_DLG), 
					      hWndParent, 
					      AddressDetailDlgProc,
                          (LPARAM)pUserInfo);
	if(res <= 0)
	{
		DEBUG_FUNCTION_NAME(TEXT("AddressDetailDlgProc(IDOK)"));
		DebugPrintEx(DEBUG_ERR, TEXT("DialogBoxParam failed: error=%d\n"), GetLastError());
	}

	return res;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\build\cvernum.h ===
#ifndef FAX_VERNUM_H_INCLUDED
#define FAX_VERNUM_H_INCLUDED

#include "FaxVer.h"
// common Fax RC definitions


#define FAX_VER_COMPANYNAME_STR     "Microsoft Corporation"
#define FAX_VER_LEGALCOPYRIGHT_STR  "\251 Microsoft Corporation. All rights reserved."
#define FAX_VER_PRODUCTNAME_STR     "Microsoft\256 Fax Server"


#ifndef VER_PRODUCTBUILD_QFE
#define VER_PRODUCTBUILD_QFE        0
#endif


#define BUILD                       1776
#define VERMAJOR                    rmj
#define VERMINOR                    rmm


// HOT FIX # field as part of fax build # 
// (should be manually updated!!!)
#define FAX_HOTFIX_NUM              rup


// FaxConfigurationVersion - this is an internal upgrade code for schema
// changes upgrade
#define CCV                           1

                                        
#endif // FAX_VERNUM_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\build\faxver.h ===
#define rmj		5
#define rmm		2
#define rup		1023
#define szVerName	""
#define szVerUser	"WHIS-X86"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\clientconsoleview.cpp ===
// ClientConsoleView.cpp : implementation of the CClientConsoleView class
//

//
// This view is used when the following nodes are selected in the 
// left (tree) view:
//    - Root of tree
//    - A server (not a folder in the server)
//
#include "stdafx.h"
#define __FILE_ID__     3

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CClientConsoleView

IMPLEMENT_DYNCREATE(CClientConsoleView, CListView)

BEGIN_MESSAGE_MAP(CClientConsoleView, CListView)
    //{{AFX_MSG_MAP(CClientConsoleView)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CClientConsoleView construction/destruction

CClientConsoleView::CClientConsoleView()
{}

CClientConsoleView::~CClientConsoleView()
{}

BOOL CClientConsoleView::PreCreateWindow(CREATESTRUCT& cs)
{
    return CListView::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CClientConsoleView drawing

void CClientConsoleView::OnDraw(CDC* pDC)
{
    CListView::OnDraw (pDC);
}

void CClientConsoleView::OnInitialUpdate()
{
    CListView::OnInitialUpdate();

    CListCtrl& refCtrl = GetListCtrl();
    refCtrl.SetExtendedStyle (LVS_EX_FULLROWSELECT |  // Entire row is selected
                              LVS_EX_INFOTIP);        // Allow tooltips
    ModifyStyle(LVS_TYPEMASK, LVS_REPORT);
}

/////////////////////////////////////////////////////////////////////////////
// CClientConsoleView diagnostics

#ifdef _DEBUG
void CClientConsoleView::AssertValid() const
{
    CListView::AssertValid();
}

void CClientConsoleView::Dump(CDumpContext& dc) const
{
    CListView::Dump(dc);
}

CClientConsoleDoc* CClientConsoleView::GetDocument() // non-debug version is inline
{
    ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CClientConsoleDoc)));
    return (CClientConsoleDoc*)m_pDocument;
}

#endif //_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\clientconsoleview.h ===
// ClientConsoleView.h : interface of the CClientConsoleView class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_CLIENTCONSOLEVIEW_H__5AE93A9F_044B_4796_97C1_2371233702C8__INCLUDED_)
#define AFX_CLIENTCONSOLEVIEW_H__5AE93A9F_044B_4796_97C1_2371233702C8__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CClientConsoleView : public CListView
{
public: // create from serialization only
    CClientConsoleView();
    DECLARE_DYNCREATE(CClientConsoleView)

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CClientConsoleView)
    public:
    virtual void OnDraw(CDC* pDC);  // overridden to draw this view
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
    protected:
    virtual void OnInitialUpdate(); // called first time after construct
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CClientConsoleView();
    CClientConsoleDoc* GetDocument();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
    //{{AFX_MSG(CClientConsoleView)
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

#ifndef _DEBUG  // debug version in ClientConsoleView.cpp
inline CClientConsoleDoc* CClientConsoleView::GetDocument()
   { return (CClientConsoleDoc*)m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CLIENTCONSOLEVIEW_H__5AE93A9F_044B_4796_97C1_2371233702C8__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\clientconsole.h ===
// ClientConsole.h : main header file for the CLIENTCONSOLE application
//

#if !defined(AFX_CLIENTCONSOLE_H__5B27AC67_C003_40F4_A688_721D5534C391__INCLUDED_)
#define AFX_CLIENTCONSOLE_H__5B27AC67_C003_40F4_A688_721D5534C391__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
    #error include 'stdafx.h' before including this file for PCH
#endif


#define CLIENT_CONSOLE_CLASS        TEXT("7a56577c-6143-43d9-bdcb-bcf234d86e98")

/////////////////////////////////////////////////////////////////////////////
// CClientConsoleApp:
// See ClientConsole.cpp for the implementation of this class
//

class CClientConsoleApp : public CWinApp
{
public:
    CClientConsoleApp();

	DWORD SendMail(CString& cstrFile);
	BOOL  IsMapiEnable() 
		{ return  NULL != m_hInstMail ? TRUE : FALSE; }

    CMainFrame* GetMainFrame() { return (CMainFrame*)m_pMainWnd; } 
    CClientConsoleDoc* GetDocument() 
    {
        CMainFrame* pFrame = GetMainFrame();
        return (NULL != pFrame) ? (CClientConsoleDoc*)pFrame->GetActiveDocument() : NULL;
    }            

    BOOL IsCmdLineOpenFolder() { return m_cmdLineInfo.IsOpenFolder(); }
    FolderType GetCmdLineFolderType() { return m_cmdLineInfo.GetFolderType(); }
    DWORDLONG GetMessageIdToSelect()  { return m_cmdLineInfo.GetMessageIdToSelect(); }

    BOOL IsCmdLineSingleServer() { return m_cmdLineInfo.IsSingleServer(); }
    CString& GetCmdLineSingleServerName() { return m_cmdLineInfo.GetSingleServerName(); }

    BOOL LaunchConfigWizard(BOOL bExplicit);
    void LaunchFaxMonitor();
    void InboxViewed();
    void OutboxViewed();

    BOOL IsRTLUI() { return m_bRTLUI; }

    VOID PrepareForModal();
    VOID ReturnFromModal();

    CString &GetClassName()     { return m_PrivateClassName; }

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CClientConsoleApp)
    public:
    virtual BOOL InitInstance();
	virtual int ExitInstance();
    //}}AFX_VIRTUAL

// Implementation
    //{{AFX_MSG(CClientConsoleApp)
    afx_msg void OnAppAbout();
        // NOTE - the ClassWizard will add and remove member functions here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:

    BOOL FirstInstance ();
    BOOL m_bClassRegistered;

    HINSTANCE m_hInstMail;       // handle to MAPI32.DLL

    CCmdLineInfo m_cmdLineInfo;

    CString      m_PrivateClassName;    // Name of the main frame window class. 
                                        // Composed of CLIENT_CONSOLE_CLASS + m_cmdLineInfo.GetSingleServerName()

    BOOL m_bRTLUI;

};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CLIENTCONSOLE_H__5B27AC67_C003_40F4_A688_721D5534C391__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\clientconsoledoc.cpp ===
// ClientConsoleDoc.cpp : implementation of the CClientConsoleDoc class
//

#include "stdafx.h"
#define __FILE_ID__     2

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern CClientConsoleApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CClientConsoleDoc

IMPLEMENT_DYNCREATE(CClientConsoleDoc, CDocument)

BEGIN_MESSAGE_MAP(CClientConsoleDoc, CDocument)
    //{{AFX_MSG_MAP(CClientConsoleDoc)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //    DO NOT EDIT what you see in these blocks of generated code!
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CClientConsoleDoc construction/destruction

//
// Static members:
//
HANDLE   CClientConsoleDoc::m_hShutdownEvent = NULL;
BOOL     CClientConsoleDoc::m_bShuttingDown = FALSE;


CClientConsoleDoc::CClientConsoleDoc() :
    m_bRefreshingServers (FALSE),
    m_bWin9xPrinterFormat(FALSE)
{}

CClientConsoleDoc::~CClientConsoleDoc()
{
    ClearServersList ();
    if (m_hShutdownEvent)
    {
        CloseHandle (m_hShutdownEvent);
        m_hShutdownEvent = NULL;
    }
}

DWORD
CClientConsoleDoc::Init ()
/*++

Routine name : CClientConsoleDoc::Init

Routine description:

    Initializes document events and maps

Author:

    Eran Yariv (EranY), Feb, 2000

Arguments:


Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CClientConsoleDoc::Init"), dwRes);

    //
    // Create the shutdown event. This event will be signaled when the app is
    // about to quit.
    //
    ASSERTION (NULL == m_hShutdownEvent);
    m_hShutdownEvent = CreateEvent (NULL,       // No security
                                    TRUE,       // Manual reset
                                    FALSE,      // Starts clear
                                    NULL);      // Unnamed
    if (NULL == m_hShutdownEvent)
    {
        DWORD dwRes = GetLastError ();
        CALL_FAIL (STARTUP_ERR, TEXT("CreateEvent"), dwRes);
        PopupError (dwRes);
        return dwRes;
    }
    //
    // Init the map of notification messages from the servers
    //
    dwRes = CServerNode::InitMsgsMap ();
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (MEM_ERR, TEXT("CServerNode::InitMsgsMap"), dwRes);
        PopupError (dwRes);
        return dwRes;
    }

    ASSERTION (ERROR_SUCCESS == dwRes);
    return dwRes;
}   // CClientConsoleDoc::Init

BOOL CClientConsoleDoc::OnNewDocument()
{
    BOOL bRes = FALSE;
    DBG_ENTER(TEXT("CClientConsoleDoc::OnNewDocument"), bRes);

    if (!CDocument::OnNewDocument())
    {
        return bRes;
    }

    if(theApp.IsCmdLineSingleServer())
    {
        //
        // get command line server name
        //
        try
        {
            m_cstrSingleServer = theApp.GetCmdLineSingleServerName();
        }
        catch (...)
        {
            CALL_FAIL (MEM_ERR, TEXT("CString::operator ="), ERROR_NOT_ENOUGH_MEMORY);
            PopupError (ERROR_NOT_ENOUGH_MEMORY);
            return bRes;
        }
    }

    DWORD dwRes = Init ();
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("CClientConsoleDoc::Init"), dwRes);
        return bRes;
    }

    bRes = TRUE;
    return bRes;
}


/////////////////////////////////////////////////////////////////////////////
// CClientConsoleDoc serialization

void CClientConsoleDoc::Serialize(CArchive& ar)
{
    if (ar.IsStoring())
    {
        // TODO: add storing code here
    }
    else
    {
        // TODO: add loading code here
    }
}

/////////////////////////////////////////////////////////////////////////////
// CClientConsoleDoc diagnostics

#ifdef _DEBUG
void CClientConsoleDoc::AssertValid() const
{
    CDocument::AssertValid();
}

void CClientConsoleDoc::Dump(CDumpContext& dc) const
{
    CDocument::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CClientConsoleDoc commands

DWORD
CClientConsoleDoc::AddServerNode (
    LPCTSTR lpctstrServer
)
/*++

Routine name : CClientConsoleDoc::AddServerNode

Routine description:

    Adds a new server node to the servers list and initializes it

Author:

    Eran Yariv (EranY), Feb, 2000

Arguments:

    lpctstrServer      [in]     - Server name

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CClientConsoleDoc::AddServerNode"), dwRes, TEXT("%s"), lpctstrServer);

    CServerNode    *pServerNode = NULL;
    //
    // Create the new server node
    //
    try
    {
        pServerNode = new CServerNode;
    }
    catch (...)
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        CALL_FAIL (MEM_ERR, TEXT ("new CServerNode"), dwRes);
        PopupError (dwRes);
        return dwRes;
    }
    //
    // Init the server
    //
    dwRes = pServerNode->Init (lpctstrServer);
    if (ERROR_SUCCESS != dwRes)
    {
        pServerNode->Destroy ();
        PopupError (dwRes);
        return dwRes;
    }
    //
    // Enter the (initialized) node at the end of the list
    //
    try
    {
        m_ServersList.push_back (pServerNode);
    }
    catch (...)
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        CALL_FAIL (MEM_ERR, TEXT("list::push_back"), dwRes);
        PopupError (dwRes);
        pServerNode->Destroy ();
        return dwRes;
    }

    pServerNode->AttachFoldersToViews();
    pServerNode->RefreshState();


    CMainFrame *pFrm = GetFrm();
    if (!pFrm)
    {
        //
        // Shutdown in progress
        //
        return dwRes;
    }

    CLeftView* pLeftView = pFrm->GetLeftView();
    ASSERTION(pLeftView);

    CFolderListView* pListView = pLeftView->GetCurrentView();
    if(NULL != pListView)
    {
        //
        // refresh current folder
        //
        FolderType type = pListView->GetType();
        CFolder* pFolder = pServerNode->GetFolder(type);
        ASSERTION(pFolder);

        pFolder->SetVisible();
    }

    return dwRes;
}   // CClientConsoleDoc::AddServerNode

DWORD 
CClientConsoleDoc::RefreshServersList()
/*++

Routine name : CClientConsoleDoc::RefreshServersList

Routine description:

    Refreshes the list of servers

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    None.

Return Value:

    Standard Win32 error code

--*/
{
    DWORD           dwRes = ERROR_SUCCESS;
    DWORD           dwIndex;
    PRINTER_INFO_2 *pPrinterInfo2 = NULL;
    DWORD           dwNumPrinters;
    CServerNode*    pServerNode;

    DBG_ENTER(TEXT("CClientConsoleDoc::RefreshServersList"), dwRes);
    //
    // Prevent a new servers refresh request
    //
    if(m_bRefreshingServers )
    {
        return dwRes;
    }

    m_bRefreshingServers = TRUE;

    if (m_cstrSingleServer.IsEmpty ())
    {
        SetAllServersInvalid();

        //
        // Working in a multiple-servers mode (normal mode)
        // Enumerate the list of printers available on the system
        //
        dwRes = GetPrintersInfo(pPrinterInfo2, dwNumPrinters);
        if(ERROR_SUCCESS != dwRes)
        {
            CALL_FAIL (GENERAL_ERR, TEXT("GetPrintersInfo"), dwRes);
            goto exit;
        }

        //
        // Iterate the printers
        //
        for (dwIndex=0; dwIndex < dwNumPrinters; dwIndex++) 
        {
            if(pPrinterInfo2[dwIndex].pDriverName)
            {
                if (_tcscmp(pPrinterInfo2[dwIndex].pDriverName, FAX_DRIVER_NAME))
                {
                    //
                    // This printer does not use the Fax Server driver
                    //
                    continue;
                }
            }
            //
            // Init the node's share and server name
            //
            if( (NULL == pPrinterInfo2[dwIndex].pShareName || 
                    0 == _tcslen(pPrinterInfo2[dwIndex].pShareName)) &&
                (NULL == pPrinterInfo2[dwIndex].pServerName || 
                    0 == _tcslen(pPrinterInfo2[dwIndex].pServerName)))
            {
                //
                // On Win9x machine, the share name and server name are NULL 
                // or empty string but the
                // port is valid and composed of \\servername\sharename
                //
                m_bWin9xPrinterFormat = TRUE;

                if ((_tcsclen(pPrinterInfo2[dwIndex].pPortName) >= 5) &&
                    (_tcsncmp(pPrinterInfo2[dwIndex].pPortName, TEXT("\\\\"), 2) == 0))
                {
                    //
                    // Port name is long enough and starts with "\\"
                    //
                    TCHAR* pServerStart = _tcsninc(pPrinterInfo2[dwIndex].pPortName,2);
                    TCHAR* pShareStart = _tcschr (pServerStart, TEXT('\\'));
                    if (pShareStart)
                    {
                        //
                        // Share was found after the server name.
                        // Seperate server from share and advance share name
                        //
                        TCHAR* ptcTmp = pShareStart;
                        pShareStart = _tcsinc(pShareStart);
                        *ptcTmp = TEXT('\0');
                        pPrinterInfo2[dwIndex].pShareName = pShareStart;
                        pPrinterInfo2[dwIndex].pServerName = pServerStart;
                    }
                }
            }

            pServerNode = FindServerByName(pPrinterInfo2[dwIndex].pServerName);
            if(NULL == pServerNode)
            {
                //
                // Create new server node
                //
                dwRes = AddServerNode (pPrinterInfo2[dwIndex].pServerName);
                if (ERROR_SUCCESS != dwRes)
                {
                    CALL_FAIL (GENERAL_ERR, TEXT("AddServerNode"), dwRes);
                    goto exit;
                }
            }
            else
            {
                //
                // the server node already exists
                //
                pServerNode->SetValid(TRUE);
            }

        }   // End of printers loop

        dwRes = RemoveAllInvalidServers();
        if (ERROR_SUCCESS != dwRes)
        {
            CALL_FAIL (GENERAL_ERR, TEXT("RemoveAllInvalidServers"), dwRes);
            goto exit;
        }
    }
    else
    {
        //
        // Working in a single server mode (server name in m_cstrSingleServer).
        // Create new server node.
        //
        int nSize = m_ServersList.size();
        ASSERTION(0 == nSize || 1 == nSize);

        if(0 == nSize)
        {
            dwRes = AddServerNode (m_cstrSingleServer);
            if (ERROR_SUCCESS != dwRes)
            {
                CALL_FAIL (GENERAL_ERR, TEXT("AddServerNode"), dwRes);
                goto exit;
            }
        }
        else
        {
            ASSERTION(FindServerByName(m_cstrSingleServer));
        }
    }    


    ASSERTION (ERROR_SUCCESS == dwRes);

exit:
    SAFE_DELETE_ARRAY (pPrinterInfo2);

    //
    // Enable a new servers refresh request
    //
    m_bRefreshingServers = FALSE;
    return dwRes;
}   // CClientConsoleDoc::RefreshServersList


void CClientConsoleDoc::OnCloseDocument() 
{
    DBG_ENTER(TEXT("CClientConsoleDoc::OnCloseDocument"));
    //
    // Shutdown the map of notification messages from the servers
    //
    DWORD dwRes = CServerNode::ShutdownMsgsMap();
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (MEM_ERR, TEXT("CServerNode::ShutdownMsgsMap"), dwRes);
    }
    //
    // Signal the event telling all our thread the app. is shutting down
    //
    SetEvent (m_hShutdownEvent);
    m_bShuttingDown = TRUE;
    CDocument::OnCloseDocument();
}

void 
CClientConsoleDoc::ClearServersList()
/*++

Routine name : CClientConsoleDoc::ClearServersList

Routine description:

    Clears the list of servers

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:


Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CClientConsoleDoc::ClearServersList"));

    for (SERVERS_LIST::iterator it = m_ServersList.begin(); it != m_ServersList.end(); ++it)
    {
        CServerNode *pServerNode = *it;
        pServerNode->Destroy ();
    }
    m_ServersList.clear ();

}   // CClientConsoleDoc::ClearServersList


void  
CClientConsoleDoc::SetAllServersInvalid()
{
    DBG_ENTER(TEXT("CClientConsoleDoc::SetAllServersInvalid"));

    CServerNode *pServerNode;
    for (SERVERS_LIST::iterator it = m_ServersList.begin(); it != m_ServersList.end(); ++it)
    {
        pServerNode = *it;
        pServerNode->SetValid(FALSE);
    }
}


DWORD 
CClientConsoleDoc::RemoveServerNode(
    CServerNode* pServer
)
/*++

Routine name : CClientConsoleDoc::RemoveServerNode

Routine description:

    remove the server from the servers list and from the tree view

Author:

    Alexander Malysh (AlexMay), Mar, 2000

Arguments:

    pServer                       [in]     - server node

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CClientConsoleDoc::RemoveServerNode"), dwRes);
    ASSERTION(pServer);

    dwRes = pServer->InvalidateSubFolders(TRUE);
    if(ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("CServerNode::InvalidateSubFolders"), dwRes);
        return dwRes;
    }

    //
    // remove the server node from the list
    //
    try
    {
        m_ServersList.remove(pServer);
    }
    catch(...)
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        CALL_FAIL (MEM_ERR, TEXT("list::remove"), dwRes);
        return dwRes;
    }

    //
    // delete the server node object
    //
    pServer->Destroy();

    return dwRes;
}

DWORD 
CClientConsoleDoc::RemoveAllInvalidServers()
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CClientConsoleDoc::RemoveAllInvalidServers"), dwRes);

    BOOL bSrvFound;
    CServerNode *pServerNode;

    while(TRUE)
    {
        //
        // find invalid server node
        //
        bSrvFound = FALSE;
        for (SERVERS_LIST::iterator it = m_ServersList.begin(); it != m_ServersList.end(); ++it)
        {
            pServerNode = *it;
            if(!pServerNode->IsValid())
            {
                bSrvFound = TRUE;
                break;
            }
        }

        if(bSrvFound)
        {
            //
            // remove invalid server node
            //
            dwRes = RemoveServerNode(pServerNode);
            if(ERROR_SUCCESS != dwRes)
            {
                CALL_FAIL (GENERAL_ERR, TEXT("RemoveServerNode"), dwRes);
                break;
            }
        }
        else
        {
            break;
        }
    } 

    return dwRes;
}

CServerNode* 
CClientConsoleDoc::FindServerByName(
    LPCTSTR lpctstrServer
)
/*++

Routine name : CClientConsoleDoc::FindServerByName

Routine description:

    find CServerNode by machine name

Author:

    Alexander Malysh (AlexMay), Mar, 2000

Arguments:

    lpctstrServer                 [in] - machine name

Return Value:

    CServerNode*

--*/
{
    CServerNode *pServerNode = NULL;
    CServerNode *pResultNode = NULL;
    for (SERVERS_LIST::iterator it = m_ServersList.begin(); it != m_ServersList.end(); ++it)
    {
        pServerNode = *it;
        if(pServerNode->Machine().Compare(lpctstrServer ? lpctstrServer : TEXT("")) == 0)
        {
            pResultNode = pServerNode;
            break;
        }
    }

    return pResultNode;
}


void
CClientConsoleDoc::SetInvalidFolder(
    FolderType type
)
/*++

Routine name : CClientConsoleDoc::InvalidateFolder

Routine description:

    invalidate specific folder content

Author:

    Alexander Malysh (AlexMay), Apr, 2000

Arguments:

    type                          [in]     - folder type

Return Value:


--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CClientConsoleDoc::InvalidateFolder"));

    CFolder*     pFolder;
    CServerNode* pServerNode;
    for (SERVERS_LIST::iterator it = m_ServersList.begin(); it != m_ServersList.end(); ++it)
    {
        pServerNode = *it;
        pFolder = pServerNode->GetFolder(type);
        ASSERTION(pFolder);

        if (pFolder)
        {
            pFolder->SetInvalid();
        }
    }
}

void 
CClientConsoleDoc::ViewFolder(
    FolderType type
)
/*++

Routine name : CClientConsoleDoc::ViewFolder

Routine description:

    refresh specific folder in all servers

Author:

    Alexander Malysh (AlexMay), Apr, 2000

Arguments:

    type                          [in]     - folder type

Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CClientConsoleDoc::ViewFolder"));


    CFolder*     pFolder;
    CServerNode *pServerNode;
    for (SERVERS_LIST::iterator it = m_ServersList.begin(); it != m_ServersList.end(); ++it)
    {
        pServerNode = *it;
        pFolder = pServerNode->GetFolder(type);
        ASSERTION(pFolder);

        pFolder->SetVisible();
    }
}

BOOL
CClientConsoleDoc::CanReceiveNow ()
/*++

Routine name : CClientConsoleDoc::CanReceiveNow

Routine description:

    Can the user apply the 'Recieve now' option?

Author:

    Eran Yariv (EranY), Mar, 2001

Arguments:


Return Value:

    TRUE if the user apply the 'Recieve now' option, FALSE otherwise.

--*/
{
    BOOL bEnable = FALSE;
    
    //
    // Locate the local fax server node
    //
    CServerNode* pServerNode = FindServerByName (NULL);
    if (pServerNode)
    {
        if(pServerNode->IsOnline() && pServerNode->CanReceiveNow())
        {
            bEnable = TRUE;
        }
    }
    return bEnable;
}   // CClientConsoleDoc::CanReceiveNow


BOOL 
CClientConsoleDoc::IsSendFaxEnable()
/*++

Routine name : CClientConsoleDoc::IsSendFaxEnable

Routine description:

    does user anable to send fax

Author:

    Alexander Malysh (AlexMay), Apr, 2000

Arguments:


Return Value:

    TRUE if anable send fax, FALSE otherwise.

--*/
{
    BOOL bEnable = FALSE;
    CServerNode* pServerNode;
    for (SERVERS_LIST::iterator it = m_ServersList.begin(); it != m_ServersList.end(); ++it)
    {
        pServerNode = *it;
        if(pServerNode->IsOnline() && pServerNode->CanSendFax())
        {
            bEnable = TRUE;
            break;
        }
    }

    return bEnable;
}

int 
CClientConsoleDoc::GetFolderDataCount(
    FolderType type
)
/*++

Routine name : CClientConsoleDoc::GetFolderDataCount

Routine description:

    get total message number in specific folder from all servers

Author:

    Alexander Malysh (AlexMay), Apr, 2000

Arguments:

    type                          [in]    - folder type

Return Value:

    message number

--*/
{
    int nCount=0;
    CFolder*     pFolder;
    CServerNode* pServerNode;
    for (SERVERS_LIST::iterator it = m_ServersList.begin(); it != m_ServersList.end(); ++it)
    {
        pServerNode = *it;
        pFolder = pServerNode->GetFolder(type);
        nCount += pFolder->GetDataCount();
    }
    return nCount;
}

BOOL 
CClientConsoleDoc::IsFolderRefreshing(
    FolderType type
)
/*++

Routine name : CClientConsoleDoc::IsFolderRefreshing

Routine description:

    if one of specific folders is refreshing

Author:

    Alexander Malysh (AlexMay), Apr, 2000

Arguments:

    type                          [TBD]    - folder type

Return Value:

    TRUE if one of specific folders is refreshing, FALSE otherwise.

--*/
{
    CFolder*     pFolder;
    CServerNode* pServerNode;
    for (SERVERS_LIST::iterator it = m_ServersList.begin(); it != m_ServersList.end(); ++it)
    {
        pServerNode = *it;
        pFolder = pServerNode->GetFolder(type);
        if (!pFolder)
        {
            DBG_ENTER(TEXT("CClientConsoleDoc::IsFolderRefreshing"));
            ASSERTION_FAILURE;
        }
        if(pFolder->IsRefreshing())
        {
            return TRUE;
        }
    }
    
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\clientconsole.cpp ===
// ClientConsole.cpp : Defines the class behaviors for the application.
//


#include "stdafx.h"
#include "..\admin\cfgwzrd\FaxCfgWzExp.h"

#define __FILE_ID__     1

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CClientConsoleApp

BEGIN_MESSAGE_MAP(CClientConsoleApp, CWinApp)
    //{{AFX_MSG_MAP(CClientConsoleApp)
    ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //    DO NOT EDIT what you see in these blocks of generated code!
    //}}AFX_MSG_MAP
    // Standard file based document commands
    ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
    ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CClientConsoleApp construction

CClientConsoleApp::CClientConsoleApp(): 
    m_hInstMail(NULL),
    m_bRTLUI(FALSE),
    m_bClassRegistered(FALSE)
{
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CClientConsoleApp object

CClientConsoleApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CClientConsoleApp initialization

BOOL CClientConsoleApp::InitInstance()
{
    MODIFY_FORMAT_MASK(DBG_PRNT_THREAD_ID,0);

    BOOL bRes = FALSE;
    DBG_ENTER (TEXT("CClientConsoleApp::InitInstance"), bRes);

    if(IsRTLUILanguage())
    {
        //
        // Set Right-to-Left layout for RTL languages
        //
        m_bRTLUI = TRUE;
        if(!SetProcessDefaultLayout(LAYOUT_RTL))
        {
            CALL_FAIL (GENERAL_ERR, TEXT("SetProcessDefaultLayout"), GetLastError());
        }
    }
    //
    // Parse command line for standard shell commands, DDE, file open
    //
    ParseCommandLine(m_cmdLineInfo);
    //
    // See if we need to active previous instance
    //
    try
    {
        m_PrivateClassName = CLIENT_CONSOLE_CLASS;
        if (m_cmdLineInfo.IsSingleServer())
        {
            //
            // Append server name to window class name
            //
            m_PrivateClassName += m_cmdLineInfo.GetSingleServerName();
        }
    }
    catch (...)
    {
        CALL_FAIL (MEM_ERR, TEXT("CString exception"), ERROR_NOT_ENOUGH_MEMORY);
        return bRes;
    }
    if (!m_cmdLineInfo.ForceNewInstance())
    {
        //
        // User did not force a new instance- check for previous instance
        //
        if(!FirstInstance())
        {
            //
            // Other instance located and activated
            //
            return bRes;
        }
    }
    //
    // Implicit launch of fax configuration wizard
    //
    if (!LaunchConfigWizard(FALSE))
    {
        //
        // User refused to enter a dialing location - stop the client console.
        //
        VERBOSE (DBG_MSG, TEXT("User refused to enter a dialing location - stop the client console."));
        return bRes;
    }
    //
    // Register our unique class name that you wish to use
    //

    WNDCLASS wndcls = {0};

    wndcls.style = CS_DBLCLKS | CS_HREDRAW | CS_VREDRAW;
    wndcls.lpfnWndProc = ::DefWindowProc;
    wndcls.hInstance = AfxGetInstanceHandle();
    wndcls.hIcon = LoadIcon(IDR_MAINFRAME); 
    wndcls.hCursor = LoadCursor(IDC_ARROW);
    wndcls.hbrBackground = (HBRUSH) (COLOR_WINDOW + 1);
    wndcls.lpszMenuName = NULL;
    wndcls.lpszClassName = m_PrivateClassName;
    //
    // Register the new class and exit if it fails
    //
    if(!AfxRegisterClass(&wndcls))
    {
        CALL_FAIL (GENERAL_ERR, TEXT("AfxRegisterClass"), GetLastError());
        return bRes;
    }
    m_bClassRegistered = TRUE;
            
    //
    // Standard initialization
    // If you are not using these features and wish to reduce the size
    // of your final executable, you should remove from the following
    // the specific initialization routines you do not need.
    //
#ifdef _AFXDLL
    Enable3dControls();         // Call this when using MFC in a shared DLL
#else
    Enable3dControlsStatic();   // Call this when linking to MFC statically
#endif
    //
    // Change the app's resource to our resource DLL.
    //
    AfxSetResourceHandle (GetResourceHandle());
    //
    // Generate a really random seed
    //
    srand( (unsigned)time( NULL ) );
    //
    // Set the registry location or the app.
    //
    SetRegistryKey (REGKEY_CLIENT);
    //
    // Set application name
    //
    CString cstrAppName;
    DWORD dwRes = LoadResourceString (cstrAppName, AFX_IDS_APP_TITLE);
    if (ERROR_SUCCESS != dwRes)
    {
        return bRes;
    }
    ASSERTION (m_pszAppName);   // Loaded from exe name
    free((void*)m_pszAppName);
    m_pszAppName = _tcsdup(cstrAppName);
    //
    // Check for minimal version of ComCtl32.dll
    //
    #define COM_CTL_VERSION_4_70 PACKVERSION(4,70)

    DWORD dwComCtl32Version = GetDllVersion(TEXT("comctl32.dll"));
    VERBOSE (DBG_MSG, TEXT("COMCTL32.DLL Version is : 0x%08X"), dwComCtl32Version);
    if (dwComCtl32Version < COM_CTL_VERSION_4_70)
    {
        AlignedAfxMessageBox (IDS_BAD_COMCTL32, MB_OK | MB_ICONHAND); 
        return bRes;
    }
    //
    // Register the application's document templates.  Document templates
    // serve as the connection between documents, frame windows and views.
    //
    CSingleDocTemplate* pDocTemplate;
    try
    {
        pDocTemplate = new CSingleDocTemplate(
            IDR_MAINFRAME,
            RUNTIME_CLASS(CClientConsoleDoc),
            RUNTIME_CLASS(CMainFrame),       // main SDI frame window
            RUNTIME_CLASS(CLeftView));
    }
    catch (...)
    {
        CALL_FAIL (MEM_ERR, TEXT("new CSingleDocTemplate"), ERROR_NOT_ENOUGH_MEMORY);
        PopupError (ERROR_NOT_ENOUGH_MEMORY);
        return bRes;
    }

    AddDocTemplate(pDocTemplate);


    //
    // Read the initial settings
    //
    CMessageFolder::ReadConfiguration ();

    //
    // Load MAPI library
    //
    if (1 == ::GetProfileInt (TEXT("Mail"), TEXT("MAPI"), 0))
    {
        //
        // If there's an entry in WIN.INI under the [Mail] section saying MAPI=1, then 
        // and only then, MAPI is available to us.
        // Search MSDN for "Initializing a Simple MAPI Client" and read for yourself if
        // you don't believe me.
        //
        m_hInstMail = ::LoadLibrary(TEXT("MAPI32.DLL"));
        if(NULL == m_hInstMail)
        {
            dwRes = GetLastError();
            CALL_FAIL (GENERAL_ERR, TEXT("LoadLibrary(\"MAPI32.DLL\")"), dwRes);
        }
    }

    OnFileNew();

    // The one and only window has been initialized, so show and update it.
    m_pMainWnd->ShowWindow(SW_SHOW);
    m_pMainWnd->UpdateWindow();
    
    bRes = TRUE;

    return bRes;
}   // CClientConsoleApp::InitInstance

int 
CClientConsoleApp::ExitInstance() 
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER (TEXT("CClientConsoleApp::ExitInstance"));
    
    if(NULL != m_hInstMail)
    {
        if(!FreeLibrary(m_hInstMail))
        {
            dwRes = GetLastError();
            CALL_FAIL (GENERAL_ERR, TEXT("FreeLibrary (MAPI32.DLL)"), dwRes);
        }
    }
    //
    // Remove left of temp preview files
    //
    DeleteTempPreviewFiles (NULL, TRUE);
    if(m_bClassRegistered)
    {
        //
        // Unregister our class
        //
        ::UnregisterClass(m_PrivateClassName, AfxGetInstanceHandle());
        m_bClassRegistered = FALSE;
    }
    return CWinApp::ExitInstance();
}


BOOL 
CClientConsoleApp::LaunchConfigWizard(
    BOOL bExplicit
)
/*++

Routine name : CClientConsoleApp::LaunchConfigWizard

Routine description:

    launch Fax Configuration Wizard for Windows XP platform only

Arguments:

    bExplicit     [in] - TRUE if it's explicit launch

Return Value:

    TRUE if the client console should continue.
    If FALSE, the user failed to set a dialing location and the client console should quit.

--*/
{
    DBG_ENTER(TEXT("CClientConsoleApp::LaunchConfigWizard"));

    if(!IsWinXPOS())
    {
        return TRUE;
    }

    HMODULE hConfigWizModule = LoadLibrary(FAX_CONFIG_WIZARD_DLL);
    if(hConfigWizModule)
    {
        FAX_CONFIG_WIZARD fpFaxConfigWiz;
        BOOL bAbort = FALSE;
        fpFaxConfigWiz = (FAX_CONFIG_WIZARD)GetProcAddress(hConfigWizModule, 
                                                           FAX_CONFIG_WIZARD_PROC);
        if(fpFaxConfigWiz)
        {
            if(!fpFaxConfigWiz(bExplicit, &bAbort))
            {
                CALL_FAIL (GENERAL_ERR, TEXT("FaxConfigWizard"), GetLastError());
            }
        }
        else
        {
            CALL_FAIL (GENERAL_ERR, TEXT("GetProcAddress(FaxConfigWizard)"), GetLastError());
        }

        if(!FreeLibrary(hConfigWizModule))
        {
            CALL_FAIL (GENERAL_ERR, TEXT("FreeLibrary(FxsCgfWz.dll)"), GetLastError());
        }
        if (bAbort)
        {
            //
            // User refused to enter a dialing location - stop the client console.
            //
            return FALSE;
        }
    }
    else
    {
        CALL_FAIL (GENERAL_ERR, TEXT("LoadLibrary(FxsCgfWz.dll)"), GetLastError());
    }
    return TRUE;
}

void 
CClientConsoleApp::InboxViewed()
/*++

Routine name : CClientConsoleApp::InboxViewed

Routine description:

    Report to the Fax Monitor that the Inbox folder has been viewed

Return Value:

    none

--*/
{
    DBG_ENTER(TEXT("CClientConsoleApp::InboxViewed"));

    if(!IsWinXPOS())
    {
        return;
    }

    HWND hWndFaxMon = FindWindow(FAXSTAT_WINCLASS, NULL);
    if (hWndFaxMon) 
    {
        PostMessage(hWndFaxMon, WM_FAXSTAT_INBOX_VIEWED, 0, 0);
    }
}

void 
CClientConsoleApp::OutboxViewed()
/*++

Routine name : CClientConsoleApp::OutboxViewed

Routine description:

    Report to the Fax Monitor that the Outbox folder has been viewed

Return Value:

    none

--*/
{
    DBG_ENTER(TEXT("CClientConsoleApp::InboxViewed"));

    if(!IsWinXPOS())
    {
        return;
    }

    HWND hWndFaxMon = FindWindow(FAXSTAT_WINCLASS, NULL);
    if (hWndFaxMon) 
    {
        PostMessage(hWndFaxMon, WM_FAXSTAT_OUTBOX_VIEWED, 0, 0);
    }
}


VOID
CClientConsoleApp::PrepareForModal ()
/*++

Routine name : CClientConsoleApp::PrepareForModal

Routine description:

	Prepares for a modal dialog box.
    Call this function before displaying another process window or a modeless dialog that you wish
    to appear modal.

    You must call ReturnFromModal() right after the process / modeless dialog returns. 

Author:

	Eran Yariv (EranY),	Apr, 2001

Arguments:


Return Value:

    None.

--*/
{
    EnableModeless(FALSE);
    //
    // Some extra precautions are required to use MAPISendMail as it
    // tends to enable the parent window in between dialogs (after
    // the login dialog, but before the send note dialog).
    //
    m_pMainWnd->EnableWindow(FALSE);
    m_pMainWnd->SetCapture();
    ::SetFocus(NULL);
    m_pMainWnd->m_nFlags |= WF_STAYDISABLED;
}   // CClientConsoleApp::PrepareForModal

VOID
CClientConsoleApp::ReturnFromModal ()
/*++

Routine name : CClientConsoleApp::ReturnFromModal

Routine description:

	Reverts back from the PrepareForModal function.

Author:

	Eran Yariv (EranY),	Apr, 2001

Arguments:


Return Value:

    None.

--*/
{
    //
    // After returning from the process / modeless dialog, the window must
    // be re-enabled and focus returned to the frame to undo the workaround
    // done before at PrepareForModal().
    //
    ::ReleaseCapture();
    m_pMainWnd->m_nFlags &= ~WF_STAYDISABLED;

    m_pMainWnd->EnableWindow(TRUE);
    ::SetActiveWindow(NULL);
    m_pMainWnd->SetActiveWindow();
    m_pMainWnd->SetFocus();
    ::EnableWindow(m_pMainWnd->m_hWnd, TRUE);
    EnableModeless(TRUE);
    //
    // Return the Main Frame to the foreground
    //
    ::SetWindowPos(m_pMainWnd->m_hWnd, 
                   HWND_TOPMOST, 
                   0, 
                   0, 
                   0, 
                   0, 
                   SWP_SHOWWINDOW | SWP_NOMOVE | SWP_NOSIZE);

    ::SetWindowPos(m_pMainWnd->m_hWnd, 
                   HWND_NOTOPMOST, 
                   0, 
                   0, 
                   0, 
                   0, 
                   SWP_SHOWWINDOW | SWP_NOMOVE | SWP_NOSIZE);
}   // CClientConsoleApp::ReturnFromModal


DWORD 
CClientConsoleApp::SendMail(
    CString& cstrFile
)
/*++

Routine name : CClientConsoleApp::SendMail

Routine description:

    create a new mail message with attached file

Author:

    Alexander Malysh (AlexMay), Mar, 2000

Arguments:

    cstrFile                      [in]     - file name for attach

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER (TEXT("CClientConsoleApp::SendMail"), dwRes);

    ASSERTION(m_hInstMail);

    CWaitCursor wait;

    MAPISENDMAIL    *pfnMAPISendMail;
    pfnMAPISendMail = (MAPISENDMAIL *)GetProcAddress(m_hInstMail, "MAPISendMail");
    if (!pfnMAPISendMail)
    {
        AlignedAfxMessageBox(AFX_IDP_INVALID_MAPI_DLL);
        dwRes = GetLastError ();
        return dwRes;
    }
    //
    // Prepare the file description (for the attachment)
    //
    MapiFileDesc fileDesc = {0};
    fileDesc.nPosition = (ULONG)-1;

    char szFileName[MAX_PATH+1];
#ifdef _UNICODE
    _wcstombsz(szFileName, cstrFile, MAX_PATH);
#else
    strncpy(szFileName, cstrFile, MAX_PATH);
#endif
    fileDesc.lpszPathName = szFileName;
    //
    // Prepare the message (empty with 1 attachment)
    //
    MapiMessage message = {0};
    message.nFileCount = 1;
    message.lpFiles = &fileDesc;

    PrepareForModal();
    //
    // Try to send the message
    //
    dwRes = pfnMAPISendMail(   0, 
                               (ULONG_PTR)m_pMainWnd->m_hWnd,
                               &message, 
                               MAPI_LOGON_UI | MAPI_DIALOG,
                               0
                           );
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("MAPISendMail"), dwRes);
        if ( dwRes != SUCCESS_SUCCESS && 
             dwRes != MAPI_USER_ABORT &&  
             dwRes != MAPI_E_LOGIN_FAILURE)
        {
            AlignedAfxMessageBox(AFX_IDP_FAILED_MAPI_SEND);
        }
		dwRes = ERROR_SUCCESS;
    }
    ReturnFromModal();
    return dwRes;
} // CClientConsoleApp::SendMail

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
    CAboutDlg();

    CString m_cstrVersion;

// Dialog Data
    //{{AFX_DATA(CAboutDlg)
    enum { IDD = IDD_ABOUTBOX };
    //}}AFX_DATA

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAboutDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    //{{AFX_MSG(CAboutDlg)
        // No message handlers
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
    //{{AFX_DATA_INIT(CAboutDlg)
    //}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAboutDlg)
    DDX_Text(pDX, IDC_ABOUT_VERSION, m_cstrVersion);
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
    //{{AFX_MSG_MAP(CAboutDlg)
        // No message handlers
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

// App command to run the dialog
void CClientConsoleApp::OnAppAbout()
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER (TEXT("CClientConsoleApp::OnAppAbout"));

    if(!m_pMainWnd)
    {
        ASSERTION_FAILURE;
        return;
    }

    HICON hIcon = LoadIcon(IDR_MAINFRAME);
    if(!hIcon)
    {
        dwRes = GetLastError();
        CALL_FAIL (GENERAL_ERR, TEXT("LoadIcon"), dwRes);
        PopupError(dwRes);
        return;
    }

    if(!::ShellAbout(m_pMainWnd->m_hWnd, m_pszAppName, TEXT(""), hIcon))
    {
        dwRes = ERROR_CAN_NOT_COMPLETE;
        CALL_FAIL (GENERAL_ERR, TEXT("ShellAbout"), dwRes);
        PopupError(dwRes);
    }
}

BOOL 
CClientConsoleApp::FirstInstance ()
/*++

Routine name : CClientConsoleApp::FirstInstance

Routine description:

	Checks if this is the first instance of the client console.
    If not, activates the other instance (first found) and optionally posts messages
    to it with the parsed command line parameters.

Author:

	Eran Yariv (EranY),	May, 2001

Arguments:


Return Value:

    TRUE if this is the first instance of the client console, FALSE otherwise.

--*/
{
    DBG_ENTER (TEXT("CClientConsoleApp::FirstInstance"));
    CWnd *pWndPrev;     // Previous Client console mainframe window
    CWnd *pWndChild;    // Previous Client console top-most window
    //
    // Determine if another window with your class name exists...
    //
    if (pWndPrev = CWnd::FindWindow(m_PrivateClassName, NULL))
    {
        DWORDLONG dwlStartupMsg;
        //
        // If so, does it have any popups?
        //
        pWndChild = pWndPrev->GetLastActivePopup();
        //
        // If iconic, restore the main window
        //
        if (pWndPrev->IsIconic())
        {
            pWndPrev->ShowWindow(SW_RESTORE);
        }
        //
        // Bring the main window or its popup to the foreground
        //
        pWndChild->SetForegroundWindow();
        if (m_cmdLineInfo.IsOpenFolder())
        {
            //
            // The user specified a specific startup folder.
            // Post a private message to the previous instance, telling it to switch to the requested folder.
            //
            pWndPrev->PostMessage (WM_CONSOLE_SET_ACTIVE_FOLDER, WPARAM(m_cmdLineInfo.GetFolderType()), 0);
        }
        dwlStartupMsg = m_cmdLineInfo.GetMessageIdToSelect();
        if (dwlStartupMsg)
        {
            //
            // The user specified a specific startup message to select.
            // Post a private message to the previous instance, telling it to select to the requested message.
            //
            ULARGE_INTEGER uli;
            uli.QuadPart = dwlStartupMsg;
            pWndPrev->PostMessage (WM_CONSOLE_SELECT_ITEM, WPARAM(uli.LowPart), LPARAM(uli.HighPart));
        }
        //
        // And we're done activating the previous instance
        //
        return FALSE;
    }
    //
    // First instance. Proceed as normal.
    //
    return TRUE;
}   // CClientConsoleApp::FirstInstance

/////////////////////////////////////////////////////////////////////////////
// CClientConsoleApp message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\clientconsoledoc.h ===
// ClientConsoleDoc.h : interface of the CClientConsoleDoc class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_CLIENTCONSOLEDOC_H__6E33CFA1_C99A_4691_9F91_00451692D3DB__INCLUDED_)
#define AFX_CLIENTCONSOLEDOC_H__6E33CFA1_C99A_4691_9F91_00451692D3DB__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

typedef list<CServerNode *> SERVERS_LIST, *PSERVERS_LIST;

class CClientConsoleDoc : public CDocument
{
protected: // create from serialization only
    CClientConsoleDoc();
    DECLARE_DYNCREATE(CClientConsoleDoc)

// Attributes
public:
    virtual ~CClientConsoleDoc();

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CClientConsoleDoc)
    public:
    virtual BOOL OnNewDocument();
    virtual void Serialize(CArchive& ar);
    virtual void OnCloseDocument();
    //}}AFX_VIRTUAL

// Implementation
public:
    const SERVERS_LIST& GetServersList() const { return m_ServersList; }
    DWORD GetServerCount() { return m_ServersList.size(); }

    static const HANDLE GetShutdownEvent ()     { return m_hShutdownEvent; }
    static const BOOL   ShuttingDown ()         { return m_bShuttingDown;  }

    BOOL IsSendFaxEnable();
    BOOL CanReceiveNow();

    DWORD RefreshServersList ();

    BOOL IsFolderRefreshing(FolderType type);
    int GetFolderDataCount(FolderType type);
    void SetInvalidFolder(FolderType type);
    void ViewFolder(FolderType type);
    CString& GetSingleServerName() { return m_cstrSingleServer; }

	CServerNode* FindServerByName(LPCTSTR lpctstrServer);

#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
    //{{AFX_MSG(CClientConsoleDoc)
        // NOTE - the ClassWizard will add and remove member functions here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
private:

	void  SetAllServersInvalid();
	DWORD RemoveAllInvalidServers();
	DWORD RemoveServerNode(CServerNode* pServer);

    void ClearServersList ();
    DWORD Init ();
    DWORD AddServerNode (LPCTSTR lpctstrServer);

    BOOL  m_bWin9xPrinterFormat; // EnumPrinters() fills PRINTER_INFO_2 in Win9x style
                                 // pShareName and pServerName aren't valid  

    SERVERS_LIST    m_ServersList;          // List of servers
    static HANDLE   m_hShutdownEvent;       // Set when the app. shuts down.
    static BOOL     m_bShuttingDown;        // Are we shutting down?
    BOOL            m_bRefreshingServers;   // Are we refreshing the server's list?
    CString         m_cstrSingleServer;     // Name of single server. Empty if we're in normal mode.

};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CLIENTCONSOLEDOC_H__6E33CFA1_C99A_4691_9F91_00451692D3DB__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\cmdlineinfo.cpp ===
// CmdLineInfo.cpp: implementation of the CCmdLineInfo class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#define __FILE_ID__     81

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

void 
CCmdLineInfo::ParseParam( 
    LPCTSTR lpszParam, 
    BOOL bFlag, 
    BOOL bLast 
)
/*++

Routine name : CCmdLineInfo::ParseParam

Routine description:

	parse/interpret individual parameters from the command line

Author:

	Alexander Malysh (AlexMay),	Apr, 2000

Arguments:

	lpszParam                     [in]    - parameter or flag
	bFlag                         [in]    - Indicates whether lpszParam is a parameter or a flag
	bLast                         [in]    - Indicates if this is the last parameter or flag on the command line

Return Value:

    None.

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CCmdLineInfo::ParseParam"));

    if(bFlag)
    {
        //
        // lpszParam is a flag
        //
        if(_tcsicmp(lpszParam, CONSOLE_CMD_FLAG_STR_FOLDER) == 0)
        {
            //
            // User asked for startup folder.
            // Next param is expected to be folder name.
            //
            m_cmdLastFlag = CMD_FLAG_FOLDER;
        }
        else if(_tcsicmp(lpszParam, CONSOLE_CMD_FLAG_STR_MESSAGE_ID) == 0)
        {
            //
            // User asked for startup message.
            // Next param is expected to be message id.
            //
            m_cmdLastFlag = CMD_FLAG_MESSAGE_ID;
        }
        else if(_tcsicmp(lpszParam, CONSOLE_CMD_FLAG_STR_NEW) == 0)
        {
            //
            // User asked for new instance.
            // No further params required.
            //
            m_bForceNewInstace = TRUE;
            m_cmdLastFlag = CMD_FLAG_NONE;
        }
        else
        {
            //
            // No flag
            //
            m_cmdLastFlag = CMD_FLAG_NONE;
        }
    }
    else
    {
        //
        // lpszParam is a parameter.
        // Let's see what was the last flag specified.
        //
        switch(m_cmdLastFlag)
        {
            case CMD_FLAG_FOLDER:
                if(_tcsicmp(lpszParam, CONSOLE_CMD_PRM_STR_OUTBOX) == 0)
                {
                    m_FolderType = FOLDER_TYPE_OUTBOX;
                }
                else if(_tcsicmp(lpszParam, CONSOLE_CMD_PRM_STR_INCOMING) == 0)
                {
                    m_FolderType = FOLDER_TYPE_INCOMING;
                }
                else if(_tcsicmp(lpszParam, CONSOLE_CMD_PRM_STR_INBOX) == 0)
                {
                    m_FolderType = FOLDER_TYPE_INBOX;
                }
                else if(_tcsicmp(lpszParam, CONSOLE_CMD_PRM_STR_SENT_ITEMS) == 0)
                {
                    m_FolderType = FOLDER_TYPE_SENT_ITEMS;
                }

                m_cmdLastFlag = CMD_FLAG_NONE;
                break;

            case CMD_FLAG_MESSAGE_ID:
                //
                // Try to parse the message to select
                //
                if (1 != _stscanf (lpszParam, TEXT("%I64x"), &m_dwlMessageId))
                {
                        //
                        // Can't read 64-bits message id from string
                        //
                        CALL_FAIL (GENERAL_ERR, 
                                   TEXT("Can't read 64-bits message id from input string"), 
                                   ERROR_INVALID_PARAMETER);
                        m_dwlMessageId = 0;
                }
                m_cmdLastFlag = CMD_FLAG_NONE;
                break;

            case CMD_FLAG_NONE:
                try
                {
                    m_cstrServerName = lpszParam;
                }
                catch (...)
                {
                    CALL_FAIL (MEM_ERR, TEXT("CString::operator ="), ERROR_NOT_ENOUGH_MEMORY);
                    return;
                }
                break;

            default:
                break;
        }
    }
}   // CCmdLineInfo::ParseParam
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\cmdlineinfo.h ===
// CmdLineInfo.h: interface for the CCmdLineInfo class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_CMDLINEINFO_H__505B2DF0_17E3_4E13_8BDE_34D3FF703482__INCLUDED_)
#define AFX_CMDLINEINFO_H__505B2DF0_17E3_4E13_8BDE_34D3FF703482__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CCmdLineInfo : public CCommandLineInfo  
{
public:

    enum CmdLineFlags
    {
        CMD_FLAG_FOLDER,        // Folder specified
        CMD_FLAG_MESSAGE_ID,    // Message ID specified
        CMD_FLAG_NONE           // No flag specified    
    };

    CCmdLineInfo():
        m_cmdLastFlag(CMD_FLAG_NONE),
        m_FolderType(FOLDER_TYPE_INBOX),     // Default folder on startup is 'Inbox'
        m_dwlMessageId(0),                   // Do not select any message on startup,
        m_bForceNewInstace (FALSE)           // By default, previous instances are used
        {}

    virtual ~CCmdLineInfo() {}

    void ParseParam( LPCTSTR lpszParam, BOOL bFlag, BOOL bLast );

    DWORDLONG GetMessageIdToSelect () const { return m_dwlMessageId; }

    BOOL IsOpenFolder() { return m_FolderType < FOLDER_TYPE_MAX; }
    FolderType GetFolderType() 
        { ASSERT(IsOpenFolder()); return m_FolderType; }

    BOOL IsSingleServer() {return !m_cstrServerName.IsEmpty(); }
    CString& GetSingleServerName()
        { ASSERT(IsSingleServer()); return m_cstrServerName; }

    BOOL ForceNewInstance ()    { return m_bForceNewInstace; }

private:

    CmdLineFlags    m_cmdLastFlag;
    FolderType      m_FolderType;       // Folder to open on startup    
    DWORDLONG       m_dwlMessageId;     // Message id to select on startup
    BOOL            m_bForceNewInstace; // Do we force a new instance (/new) ?

    CString m_cstrServerName;

};

#endif // !defined(AFX_CMDLINEINFO_H__505B2DF0_17E3_4E13_8BDE_34D3FF703482__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\columnselectdlg.cpp ===
// ColumnSelectDlg.cpp : implementation file
//

#include "stdafx.h"

#define __FILE_ID__     35

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CColumnSelectDlg dialog


CColumnSelectDlg::CColumnSelectDlg
(
    const CString* pcstrTitles, 
    int* pnOrderedItems, 
    DWORD dwListSize,
    DWORD& dwSelectedItems,
    CWnd* pParent /*=NULL*/
):
/*++

Routine name : CColumnSelectDlg::CColumnSelectDlg

Routine description:

    Select dialog constructor

Author:

    Alexander Malysh (AlexMay), Jan, 2000

Arguments:

    pcstrTitles                   [in]     - titles array
    pnOrderedItems                [in/out] - array of ordered indexes
    dwListSize                    [in]     - size of these arrays
    dwSelectedItems               [in/out] - number of selected items
    pParent                       [in]     - parent window

Return Value:

    None.

--*/
    CFaxClientDlg(CColumnSelectDlg::IDD, pParent),
    m_pcstrTitles(pcstrTitles), 
    m_pnOrderedItems(pnOrderedItems),
    m_dwListSize(dwListSize),
    m_rdwSelectedItems(dwSelectedItems),
    m_nCaptionId(-1),
    m_nAvailableId(-1),
    m_nDisplayedId(-1)
{
    DBG_ENTER(TEXT("CColumnSelectDlg::CColumnSelectDlg"));

    ASSERTION(NULL != m_pcstrTitles);
    ASSERTION(NULL != m_pnOrderedItems);
    ASSERTION(0 < m_dwListSize);
    ASSERTION(m_rdwSelectedItems <= m_dwListSize);
    
    //{{AFX_DATA_INIT(CColumnSelectDlg)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
}   // CColumnSelectDlg::CColumnSelectDlg

void 
CColumnSelectDlg::DoDataExchange(CDataExchange* pDX)
{
    CFaxClientDlg::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CColumnSelectDlg)
    DDX_Control(pDX, IDOK, m_butOk);
    DDX_Control(pDX, IDC_STATIC_DISPLAYED, m_groupDisplayed);
    DDX_Control(pDX, IDC_STATIC_AVAILABLE, m_groupAvailable);
    DDX_Control(pDX, IDC_BUT_ADD, m_butAdd);
    DDX_Control(pDX, IDC_BUT_REMOVE, m_butRemove);
    DDX_Control(pDX, IDC_BUT_UP, m_butUp);
    DDX_Control(pDX, IDC_BUT_DOWN, m_butDown);
    DDX_Control(pDX, IDC_LIST_DISPLAYED, m_ListCtrlDisplayed);
    DDX_Control(pDX, IDC_LIST_AVAILABLE, m_ListCtrlAvailable);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CColumnSelectDlg, CFaxClientDlg)
    //{{AFX_MSG_MAP(CColumnSelectDlg)
    ON_BN_CLICKED(IDC_BUT_DOWN, OnButDown)
    ON_BN_CLICKED(IDC_BUT_UP, OnButUp)
    ON_BN_CLICKED(IDC_BUT_REMOVE, OnButRemove)
    ON_BN_CLICKED(IDC_BUT_ADD, OnButAdd)
    ON_LBN_SELCHANGE(IDC_LIST_AVAILABLE, OnSelChangeListAvailable)
    ON_LBN_SELCHANGE(IDC_LIST_DISPLAYED, OnSelChangeListDisplayed)
    ON_LBN_DBLCLK(IDC_LIST_AVAILABLE, OnDblclkListAvailable)
    ON_LBN_DBLCLK(IDC_LIST_DISPLAYED, OnDblclkListDisplayed)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CColumnSelectDlg message handlers


BOOL 
CColumnSelectDlg::OnInitDialog() 
/*++

Routine name : CColumnSelectDlg::OnInitDialog

Routine description:

    Init Dialog message handler

Author:

    Alexander Malysh (AlexMay), Jan, 2000

Arguments:


Return Value:

    TRUE if successful initialization, FALSE otherwise.

--*/
{
    BOOL bRes=TRUE;
    DBG_ENTER(TEXT("CColumnSelectDlg::OnInitDialog"), bRes);

    CFaxClientDlg::OnInitDialog();

    if(!InputValidate())
    {
        bRes = FALSE;
        CALL_FAIL (GENERAL_ERR, TEXT("InputValidate"), bRes);
        goto exit;
    }

    DWORD dwColumnId, i;    
    CListBox* pListBox;

    for (i=0; i < m_dwListSize; ++i)
    {
        dwColumnId = m_pnOrderedItems[i];

        pListBox = (i < m_rdwSelectedItems) ? &m_ListCtrlDisplayed : &m_ListCtrlAvailable;

        if(!AddStrToList(*pListBox, dwColumnId))
        {
            bRes = FALSE;
            CALL_FAIL (GENERAL_ERR, TEXT("AddStrToList"), bRes);
            goto exit;
        }
    }

    SetWndCaption(this, m_nCaptionId);
    SetWndCaption(&m_groupAvailable, m_nAvailableId);
    SetWndCaption(&m_groupDisplayed, m_nDisplayedId);

    CalcButtonsState();
    
exit:

    if(!bRes)
    {
        EndDialog(IDABORT);
    }

    return bRes; 
}   // CColumnSelectDlg::OnInitDialog

void 
CColumnSelectDlg::OnOK() 
/*++

Routine name : CColumnSelectDlg::OnOK

Routine description:

    OK button message handler
    save slected item IDs to m_pnOrderedItems array

Author:

    Alexander Malysh (AlexMay), Jan, 2000

Arguments:


Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CColumnSelectDlg::OnOK"));

    DWORD dwDisplayCount = m_ListCtrlDisplayed.GetCount();
    if(LB_ERR == dwDisplayCount)
    {
        CALL_FAIL (WINDOW_ERR, TEXT("CListBox::GetCount"), 0);
        EndDialog(IDABORT);
        return;
    }
    ASSERTION(dwDisplayCount <= m_dwListSize);

    //
    // compare slected item IDs to m_pnOrderedItems array
    //
    DWORD dwId;
    BOOL bModified = FALSE;
    for (DWORD i=0; i < dwDisplayCount; ++i)
    {
        dwId = m_ListCtrlDisplayed.GetItemData(i);
        if(LB_ERR == dwId)
        {
            CALL_FAIL (WINDOW_ERR, TEXT("CListBox::GetItemData"), 0);
            EndDialog(IDABORT);
            return;
        }

        if(m_pnOrderedItems[i] != (int)dwId)
        {
            bModified = TRUE;
            m_pnOrderedItems[i] = dwId;
        }
    }

    //
    // check m_pnOrderedItems[dwCount] element
    //
    if(dwDisplayCount != m_rdwSelectedItems)
    {
        bModified = TRUE;
        m_rdwSelectedItems = dwDisplayCount;
    }

    if(!bModified)
    {
        //
        // OK pressed, but nothing changed
        //
        EndDialog(IDCANCEL);
        return;
    }


    DWORD dwAvailCount = m_ListCtrlAvailable.GetCount();
    if(LB_ERR == dwAvailCount)
    {
        CALL_FAIL (WINDOW_ERR, TEXT("CListBox::GetCount"), 0);
        EndDialog(IDABORT);
        return;
    }

    //
    // save slected item IDs to m_pnOrderedItems array
    //
    for (i=0; i < dwAvailCount; ++i)
    {
        dwId = m_ListCtrlAvailable.GetItemData(i);
        if(LB_ERR == dwId)
        {
            CALL_FAIL (WINDOW_ERR, TEXT("CListBox::GetItemData"), 0);
            EndDialog(IDABORT);
            return;
        }

        ASSERTION(dwId < m_dwListSize);
        ASSERTION(dwDisplayCount + i < m_dwListSize);

        m_pnOrderedItems[dwDisplayCount + i] = dwId;
    }
    
    EndDialog(IDOK);
}   // CColumnSelectDlg::OnOK


void 
CColumnSelectDlg::OnButDown() 
/*++

Routine name : CColumnSelectDlg::OnButDown

Routine description:

    Move Down button message handler
    move down selected item of m_ListCtrlDisplayed

Author:

    Alexander Malysh (AlexMay), Jan, 2000

Arguments:


Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CColumnSelectDlg::OnButDown"));

    MoveItemVertical(1);
}

void 
CColumnSelectDlg::OnButUp() 
/*++

Routine name : CColumnSelectDlg::OnButUp

Routine description:

    Move Up button message handler
    move up selected item of m_ListCtrlDisplayed

Author:

    Alexander Malysh (AlexMay), Jan, 2000

Arguments:


Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CColumnSelectDlg::OnButUp"));

    MoveItemVertical(-1);
}

void 
CColumnSelectDlg::OnButAdd() 
/*++

Routine name : CColumnSelectDlg::OnButAdd

Routine description:

    Add button message handler
    move selected items from Available to Displayed list box

Author:

    Alexander Malysh (AlexMay), Jan, 2000

Arguments:


Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CColumnSelectDlg::OnButAdd"));

    MoveSelectedItems(m_ListCtrlAvailable, m_ListCtrlDisplayed);
}


void 
CColumnSelectDlg::OnButRemove() 
/*++

Routine name : CColumnSelectDlg::OnButRemove

Routine description:

    Remove button message handler
    move selected item from Displayed to Available list box

Author:

    Alexander Malysh (AlexMay), Jan, 2000

Arguments:


Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CColumnSelectDlg::OnButRemove"));

    MoveSelectedItems(m_ListCtrlDisplayed, m_ListCtrlAvailable);
}

void 
CColumnSelectDlg::OnSelChangeListAvailable() 
/*++

Routine name : CColumnSelectDlg::OnSelChangeListAvailable

Routine description:

    Selection Change of Available List message handler
    
Author:

    Alexander Malysh (AlexMay), Jan, 2000

Arguments:


Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CColumnSelectDlg::OnSelChangeListAvailable"));

    CalcButtonsState();
}

void 
CColumnSelectDlg::OnSelChangeListDisplayed() 
/*++

Routine name : CColumnSelectDlg::OnSelChangeListDisplayed

Routine description:

    Selection Change of Displayed List message handler
    
Author:

    Alexander Malysh (AlexMay), Jan, 2000

Arguments:


Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CColumnSelectDlg::OnSelChangeListDisplayed"));

    CalcButtonsState();
}

void 
CColumnSelectDlg::OnDblclkListAvailable() 
/*++

Routine name : CColumnSelectDlg::OnDblclkListAvailable

Routine description:

    Double click in Available List message handler
    add item if selected

Author:

    Alexander Malysh (AlexMay), Jan, 2000

Arguments:


Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CColumnSelectDlg::OnDblclkListAvailable"));
    
    int nSelCount = m_ListCtrlAvailable.GetSelCount();
    if(LB_ERR == nSelCount)
    {
        CALL_FAIL (WINDOW_ERR, TEXT("CListBox::GetSelCount"), 0);
        EndDialog(IDABORT);
        return;
    }

    if(0 < nSelCount)
    {
        MoveSelectedItems(m_ListCtrlAvailable, m_ListCtrlDisplayed);
    }   
}

void 
CColumnSelectDlg::OnDblclkListDisplayed() 
/*++

Routine name : CColumnSelectDlg::OnDblclkListDisplayed

Routine description:

    Double click in Displayed List message handler
    remove item if selected

Author:

    Alexander Malysh (AlexMay), Jan, 2000

Arguments:


Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CColumnSelectDlg::OnDblclkListDisplayed"));
    
    int nSelCount = m_ListCtrlDisplayed.GetSelCount();
    if(LB_ERR == nSelCount)
    {
        CALL_FAIL (WINDOW_ERR, TEXT("CListBox::GetSelCount"), 0);
        EndDialog(IDABORT);
        return;
    }

    if(0 < nSelCount)
    {
        MoveSelectedItems(m_ListCtrlDisplayed, m_ListCtrlAvailable);
    }   
}


/////////////////////////////////////////////////////////////////////////////
// CColumnSelectDlg private functions

// 
// add item to list box
//
BOOL 
CColumnSelectDlg::AddStrToList(
    CListBox& listBox, 
    DWORD dwItemId      
) 
/*++

Routine name : CColumnSelectDlg::AddStrToList

Routine description:

    Adds item to listBox

Author:

    Alexander Malysh (AlexMay), Jan, 2000

Arguments:

    listBox                       [in]     - CListBox
    dwItemId                      [in]     - index of item in m_pcstrTitles array

Return Value:

    TRUE if success, FALSE otherwise.

--*/
{
    BOOL bRes=TRUE;
    DBG_ENTER(TEXT("CColumnSelectDlg::AddStrToList"), bRes);

    ASSERTION(dwItemId < m_dwListSize);

    DWORD dwIndex = listBox.AddString(m_pcstrTitles[dwItemId]);
    if(LB_ERR == dwIndex)
    {
        bRes = FALSE;
        CALL_FAIL (WINDOW_ERR, TEXT("CListBox::AddString"), bRes);
        EndDialog(IDABORT);
        return bRes;
    }
    if(LB_ERRSPACE == dwIndex)
    {
        bRes = FALSE;
        CALL_FAIL (MEM_ERR, TEXT ("CListBox::AddString"), bRes);
        EndDialog(IDABORT);
        return bRes;
    }

    int nRes = listBox.SetItemData(dwIndex, dwItemId);
    if(LB_ERR == nRes)
    {
        bRes = FALSE;
        CALL_FAIL (WINDOW_ERR, TEXT("CListBox::SetItemData"), bRes);
        EndDialog(IDABORT);
        return bRes;
    }

    return bRes;
}

void 
CColumnSelectDlg::MoveItemVertical(
    int nStep
)
/*++

Routine name : CColumnSelectDlg::MoveItemVertical

Routine description:

    Moves selected item in Displayes ListBox up or down

Author:

    Alexander Malysh (AlexMay), Jan, 2000

Arguments:

    nStep                         [in]     - offset from current position

Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CColumnSelectDlg::MoveItemVertical"));

    //
    // get Displayed list count
    //
    int nCount = m_ListCtrlDisplayed.GetCount();
    if(LB_ERR == nCount)
    {
        CALL_FAIL (WINDOW_ERR, TEXT("CListBox::GetCount"), 0);
        EndDialog(IDABORT);
        return;
    }

    ASSERTION(1 < nCount);

    //
    // get current selection count of Displayed list
    //
    int nSelCount = m_ListCtrlDisplayed.GetSelCount();
    if(LB_ERR == nSelCount)
    {
        CALL_FAIL (WINDOW_ERR, TEXT("CListBox::GetSelCount"), 0);
        EndDialog(IDABORT);
        return;
    }
    ASSERTION(1 == nSelCount);

    //
    // get selected item of Displayed list
    //
    int nIndex, nRes;
    nRes = m_ListCtrlDisplayed.GetSelItems(1, &nIndex) ;
    if(LB_ERR == nRes)
    {
        CALL_FAIL (WINDOW_ERR, TEXT("CListBox::GetSelItems"), 0);
        EndDialog(IDABORT);
        return;
    }
    int nNewIndex = nIndex + nStep;
    ASSERTION(0 <= nNewIndex && nCount > nNewIndex);

    //
    // get item data
    //
    DWORD dwId = m_ListCtrlDisplayed.GetItemData(nIndex);
    if(dwId == LB_ERR)
    {
        CALL_FAIL (WINDOW_ERR, TEXT("CListBox::GetItemData"), 0);
        EndDialog(IDABORT);
        return;
    }
    ASSERTION(dwId < m_dwListSize);

    //
    // delete selected item
    //
    nRes = m_ListCtrlDisplayed.DeleteString(nIndex);
    if(LB_ERR == nRes)
    {
        CALL_FAIL (WINDOW_ERR, TEXT("CListBox::DeleteString"), 0);
        EndDialog(IDABORT);
        return;
    }   

    //
    // insert item into new location
    //
    nRes = m_ListCtrlDisplayed.InsertString(nNewIndex, m_pcstrTitles[dwId]);
    if(LB_ERR == nRes)
    {
        CALL_FAIL (WINDOW_ERR, TEXT("CListBox::InsertString"), 0);
        EndDialog(IDABORT);
        return;
    }
    if(LB_ERRSPACE == nRes)
    {
        CALL_FAIL (MEM_ERR, TEXT("CListBox::InsertString"), 0);
        EndDialog(IDABORT);
        return;
    }

    nRes = m_ListCtrlDisplayed.SetItemData(nNewIndex, dwId );
    if(LB_ERR == nRes)
    {
        CALL_FAIL (WINDOW_ERR, TEXT("CListBox::SetItemData"), 0);
        EndDialog(IDABORT);
        return;
    }

    //
    // set selection    
    //
    nRes = m_ListCtrlDisplayed.SetSel(nNewIndex);
    if(LB_ERR == nRes)
    {
        CALL_FAIL (WINDOW_ERR, TEXT("CListBox::SetSel"), 0);
        EndDialog(IDABORT);
        return;
    }

    CalcButtonsState();
}

void CColumnSelectDlg::MoveSelectedItems(
    CListBox& listFrom, 
    CListBox& listTo
)
/*++

Routine name : CColumnSelectDlg::MoveSelectedItems

Routine description:

    moves selected items from one CListBox to another

Author:

    Alexander Malysh (AlexMay), Jan, 2000

Arguments:

    listFrom                      [in/out] - source CListBox
    listTo                        [in/out] - destination CListBox

Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CColumnSelectDlg::MoveSelectedItems"));

    //
    // get current selection count
    //
    int nSelCount = listFrom.GetSelCount();
    if(LB_ERR == nSelCount)
    {
        CALL_FAIL (WINDOW_ERR, TEXT("CListBox::GetSelCount"), 0);
        EndDialog(IDABORT);
        return;
    }

    ASSERTION(0 < nSelCount);
    
    DWORD dwId;
    int nRes, nIndex;
    for(int i=0; i < nSelCount; ++i)
    {
        //
        // get one selected item
        //
        nRes = listFrom.GetSelItems(1, &nIndex) ;
        if(LB_ERR == nRes)
        {
            CALL_FAIL (WINDOW_ERR, TEXT("CListBox::GetSelItems"), 0);
            EndDialog(IDABORT);
            return;
        }

        //
        // get item data
        //
        dwId = listFrom.GetItemData(nIndex);
        if(LB_ERR == dwId)
        {
            CALL_FAIL (WINDOW_ERR, TEXT("CListBox::GetItemData"), 0);
            EndDialog(IDABORT);
            return;
        }

        //
        // delete selected item
        //
        nRes = listFrom.DeleteString(nIndex);
        if(LB_ERR == nRes)
        {
            CALL_FAIL (WINDOW_ERR, TEXT("CListBox::DeleteString"), 0);
            EndDialog(IDABORT);
            return;
        }   

        //
        // add item to another list
        //
        if(!AddStrToList(listTo, dwId))
        {
            CALL_FAIL (GENERAL_ERR, TEXT("AddStrToList"), 0);
            EndDialog(IDABORT);
            return;
        }
    }

    CalcButtonsState();
}


void 
CColumnSelectDlg::CalcButtonsState()
{
    DBG_ENTER(TEXT("CColumnSelectDlg::CalcButtonsState"));
    
    //
    // get current selection of Available list
    // calculate Add button state
    //
    int nSelCount = m_ListCtrlAvailable.GetSelCount();
    if(LB_ERR == nSelCount)
    {
        CALL_FAIL (WINDOW_ERR, TEXT("CListBox::GetSelCount"), 0);
        EndDialog(IDABORT);
        return;
    }
    m_butAdd.EnableWindow(nSelCount > 0);

    //
    // get Displayed list count
    // calculate OK button state
    //
    int nCount = m_ListCtrlDisplayed.GetCount();
    if(LB_ERR == nCount)
    {
        CALL_FAIL (WINDOW_ERR, TEXT("CListBox::GetCount"), 0);
        EndDialog(IDABORT);
        return;
    }
    m_butOk.EnableWindow(nCount > 0);

    //
    // get current selection count of Displayed list
    // calculate Remove button state
    //
    nSelCount = m_ListCtrlDisplayed.GetSelCount();
    if(LB_ERR == nSelCount)
    {
        CALL_FAIL (WINDOW_ERR, TEXT("CListBox::GetSelCount"), 0);
        EndDialog(IDABORT);
        return;
    }
    m_butRemove.EnableWindow(nSelCount > 0);

    //
    // get selected item of Displayed list
    // calculate Up and Down buttons state
    //
    int nIndex, nRes;
    if(1 == nSelCount && 1 < nCount)
    {
        nRes = m_ListCtrlDisplayed.GetSelItems(1, &nIndex) ;
        if(LB_ERR == nRes)
        {
            CALL_FAIL (WINDOW_ERR, TEXT("CListBox::GetSelItems"), 0);
            EndDialog(IDABORT);
            return;
        }
        m_butUp.EnableWindow(nIndex > 0);
        m_butDown.EnableWindow(nIndex < nCount-1);
    }
    else
    {
        m_butUp.EnableWindow(FALSE);
        m_butDown.EnableWindow(FALSE);
    }
}


BOOL
CColumnSelectDlg::SetWndCaption (
    CWnd* pWnd,
    int   nResId
)
/*++

Routine name : CColumnSelectDlg::SetWndCaption

Routine description:

    Change window caption

Author:

    Alexander Malysh (AlexMay), Jan, 2000

Arguments:

    pWnd                          [in/out] - CWnd pointer
    nResId                        [in]     - string resource ID

Return Value:

    TRUE if success, FALSE otherwise.

--*/
{
    BOOL bRes=TRUE;
    DBG_ENTER(TEXT("CColumnSelectDlg::SetWndCaption"), bRes);

    if(0 > nResId)
    {
        return bRes;
    }

    ASSERTION(NULL != pWnd);

    CString cstrText;

    //
    // load resource string
    //
    DWORD dwRes = LoadResourceString (cstrText, nResId);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (RESOURCE_ERR, TEXT("LoadResourceString"), dwRes);
        EndDialog(IDABORT);
    }
    //
    // set window caption
    //
    pWnd->SetWindowText(cstrText);

    return bRes;
} 

BOOL 
CColumnSelectDlg::InputValidate()
/*++

Routine name : CColumnSelectDlg::InputValidate

Routine description:

    checks consistency of order array

Author:

    Alexander Malysh (AlexMay), Jan, 2000

Arguments:


Return Value:

    TRUE if input is valid, FALSE otherwise.

--*/
{
    BOOL bRes=TRUE;
    DBG_ENTER(TEXT("CColumnSelectDlg::InputValidate"), bRes);

    if(m_rdwSelectedItems > m_dwListSize)
    {
        bRes = FALSE;
        return bRes;
    }

    //
    // init temporary array
    //
    int* pnOrderCheck;
    try
    {
        pnOrderCheck = new int[m_dwListSize];
    }
    catch (...)
    {
        bRes = FALSE;
        CALL_FAIL (MEM_ERR, TEXT ("pnOrderCheck = new int[m_dwListSize]"), bRes);
        return bRes;
    }
    
    for(DWORD dw=0; dw < m_dwListSize; ++dw)
    {
        pnOrderCheck[dw] = -1;
    }

    //
    // sign indexes
    //
    int nIndex;
    for(dw=0; dw < m_dwListSize; ++dw)
    {
        nIndex = m_pnOrderedItems[dw];
        ASSERTION(nIndex >= 0 && nIndex < m_dwListSize);

        pnOrderCheck[nIndex] = dw;
    }

    for(dw=0; dw < m_dwListSize; ++dw)
    {
        if(pnOrderCheck[dw] < 0)
        {
            bRes = FALSE;
            break;
        }
    }

    delete[] pnOrderCheck;

    return bRes;

} // CColumnSelectDlg::InputValidate
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\errordlg.cpp ===
// ErrorDlg.cpp : implementation file
//

#include "stdafx.h"
#define __FILE_ID__     8

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CErrorDlg dialog

CErrorDlg::CErrorDlg(
    DWORD   dwWin32ErrCode,
    DWORD   dwFileId,
    int     iLineNumber
)
    : CDialog(CErrorDlg::IDD, NULL),
      m_iLineNumber (iLineNumber),
      m_dwFileId (dwFileId),
      m_dwWin32ErrCode (dwWin32ErrCode)
{
    //{{AFX_DATA_INIT(CErrorDlg)
    m_bDetails = FALSE;
    m_cstrDetails = _T("");
    m_cstrErrorText = _T("");
    //}}AFX_DATA_INIT
}


void CErrorDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CErrorDlg)
    DDX_Control(pDX, IDC_SEPERATOR, m_staticSeperator);
    DDX_Check(pDX, IDC_DETAILS, m_bDetails);
    DDX_Text(pDX, IDC_DETAILS_DATA, m_cstrDetails);
    DDX_Text(pDX, IDC_ERROR_TEXT, m_cstrErrorText);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CErrorDlg, CDialog)
    //{{AFX_MSG_MAP(CErrorDlg)
    ON_BN_CLICKED(IDC_DETAILS, OnDetails)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CErrorDlg message handlers

BOOL CErrorDlg::OnInitDialog() 
{
    CDialog::OnInitDialog();

    GetWindowRect (&m_rcBig);
    CRect rcSeperator;

    GetDlgItem(IDC_SEPERATOR)->GetWindowRect (&rcSeperator);
    m_rcSmall = m_rcBig;
    m_rcSmall.bottom = rcSeperator.top;
    //
    //  Shrink down to small size (initially)
    //
    OnDetails ();
    //
    // Fill in the error data
    //
    FillErrorText ();
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void
CErrorDlg::FillErrorText ()
/*++

Routine name : CErrorDlg::FillErrorText

Routine description:

    Fills the text controls with a description of the error

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:


Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CErrorDlg::FillErrorText"));

    ASSERTION (m_dwWin32ErrCode);

    DWORD dwRes;
    CString cstrError;

    int iErrorId   = IDS_ERR_CANT_COMPLETE_OPERATION;
    int iDetailsId = 0;
    switch (m_dwWin32ErrCode)
    {
        case RPC_S_INVALID_BINDING:
        case EPT_S_CANT_PERFORM_OP:
        case RPC_S_ADDRESS_ERROR:
        case RPC_S_CALL_CANCELLED:
        case RPC_S_CALL_FAILED:
        case RPC_S_CALL_FAILED_DNE:
        case RPC_S_COMM_FAILURE:
        case RPC_S_NO_BINDINGS:
        case RPC_S_SERVER_TOO_BUSY:
        case RPC_S_SERVER_UNAVAILABLE:
            iErrorId = IDS_ERR_CONNECTION_FAILED;
            break;
        case ERROR_NOT_ENOUGH_MEMORY:
            iErrorId = IDS_ERR_NO_MEMORY;           
            break;
        case ERROR_ACCESS_DENIED:
            iErrorId = IDS_ERR_ACCESS_DENIED;    
            break;
        case FAX_ERR_SRV_OUTOFMEMORY:
            iDetailsId = IDS_ERR_SRV_OUTOFMEMORY;   
            break;
        case FAX_ERR_FILE_ACCESS_DENIED:
            iDetailsId = IDS_ERR_FILE_ACCESS_DENIED;
            break;
        case FAX_ERR_MESSAGE_NOT_FOUND:
            iDetailsId = IDS_ERR_MESSAGE_NOT_FOUND;
            break;
    }

    try
    {
        if(iDetailsId)
        {
            dwRes = LoadResourceString (cstrError, iDetailsId);
            if (ERROR_SUCCESS != dwRes)
            {
                CALL_FAIL (MEM_ERR, TEXT("LoadResourceString"), dwRes);
            }
        }
        else
        {
            cstrError = Win32Error2String (m_dwWin32ErrCode);
        }

        m_cstrDetails.Format (TEXT("%s(%ld, %02ld%08ld)"), 
                              cstrError, 
                              m_dwWin32ErrCode,
                              m_dwFileId,
                              m_iLineNumber);
    }
    catch (CException &ex)
    {
        TCHAR wszCause[1024];

        ex.GetErrorMessage (wszCause, 1024);
        VERBOSE (EXCEPTION_ERR,
                 TEXT("CString caused exception : %s"), 
                 wszCause);
    }

    dwRes = LoadResourceString (m_cstrErrorText, iErrorId);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (MEM_ERR, TEXT("LoadResourceString"), dwRes);
    }
    if (!UpdateData (FALSE))
    {
        CALL_FAIL (GENERAL_ERR, TEXT("UpdateData"), ERROR_GEN_FAILURE);
    }
}   // CErrorDlg::FillErrorText


void CErrorDlg::OnDetails() 
{   // The "Details" button was just pressed
    if (!UpdateData())
    {
        return;
    }
    CRect &rc = m_bDetails ? m_rcBig : m_rcSmall;
    SetWindowPos (NULL, rc.left, rc.top, rc.Width(), rc.Height(), SWP_NOOWNERZORDER);
}

void CErrorDlg::OnOK() 
{
    CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\coverpagesdlg.h ===
#if !defined(AFX_COVERPAGESDLG_H__621F98B6_B494_4FAB_AFDC_C38A144D4504__INCLUDED_)
#define AFX_COVERPAGESDLG_H__621F98B6_B494_4FAB_AFDC_C38A144D4504__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// CoverPagesDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CCoverPagesDlg dialog

#define WM_CP_EDITOR_CLOSED     WM_APP + 1

class CCoverPagesDlg : public CFaxClientDlg
{
// Construction
public:
	CCoverPagesDlg(CWnd* pParent = NULL);   // standard constructor
    ~CCoverPagesDlg();

    DWORD GetLastDlgError() { return m_dwLastError; }

// Dialog Data
	//{{AFX_DATA(CCoverPagesDlg)
	enum { IDD = IDD_COVER_PAGES };
	CButton	m_butDelete;
	CButton	m_butRename;
	CButton	m_butOpen;
	CListCtrl	m_cpList;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CCoverPagesDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CCoverPagesDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnCpNew();
	afx_msg void OnCpOpen();
	afx_msg void OnCpRename();
	afx_msg void OnCpDelete();
	afx_msg void OnCpAdd();
	afx_msg void OnItemchangedListCp(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnEndLabelEditListCp(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDblclkListCp(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnKeydownListCp(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg LRESULT OnCpEditorClosed(WPARAM, LPARAM);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:

    DWORD RefreshFolder();
    void  CalcButtonsState(); 
    DWORD CopyPage(const CString& cstrPath, const CString& cstrName);
    DWORD StartEditor(LPCTSTR lpFile);

    static HWND   m_hDialog;
    static HANDLE m_hEditorThread;

    static DWORD WINAPI StartEditorThreadProc(LPVOID lpFile);
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_COVERPAGESDLG_H__621F98B6_B494_4FAB_AFDC_C38A144D4504__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\errordlg.h ===
#if !defined(AFX_ERRORDLG_H__E6A84A73_2471_4E02_848B_2263C157998A__INCLUDED_)
#define AFX_ERRORDLG_H__E6A84A73_2471_4E02_848B_2263C157998A__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ErrorDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CErrorDlg dialog

class CErrorDlg : public CDialog
{
// Construction
public:
    CErrorDlg(
        DWORD   dwWin32ErrCode,
        DWORD   dwFileId,
        int     iLineNumber
        );

// Dialog Data
    //{{AFX_DATA(CErrorDlg)
    enum { IDD = IDD_ERROR };
    CStatic m_staticSeperator;
    BOOL    m_bDetails;
    CString m_cstrDetails;
    CString m_cstrErrorText;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CErrorDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CErrorDlg)
    afx_msg void OnDetails();
    virtual void OnOK();
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:

    void FillErrorText ();

    CRect           m_rcBig;
    CRect           m_rcSmall;

    DWORD           m_dwWin32ErrCode;
    int             m_iLineNumber;
    DWORD           m_dwFileId;
};

#define PopupError(err)     {   CMainFrame *pFrm = GetFrm();                    \
                                if (pFrm)                                       \
                                    pFrm->PostMessage (WM_POPUP_ERROR,          \
                                           WPARAM(err),                         \
                                           MAKELPARAM(__LINE__, __FILE_ID__)); };


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ERRORDLG_H__E6A84A73_2471_4E02_848B_2263C157998A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\coverpagesdlg.cpp ===
// CoverPagesDlg.cpp : implementation file
//

#include "stdafx.h"
#define __FILE_ID__     90

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CCoverPagesDlg dialog

extern CClientConsoleApp theApp;

HWND   CCoverPagesDlg::m_hDialog = NULL;
HANDLE CCoverPagesDlg::m_hEditorThread = NULL;

struct TColimnInfo
{
    DWORD dwStrRes;    // column header string
    DWORD dwAlignment; // column alignment
};

static TColimnInfo s_colInfo[] = 
{
    IDS_COV_COLUMN_NAME,        LVCFMT_LEFT,
    IDS_COV_COLUMN_MODIFIED,    LVCFMT_LEFT,
    IDS_COV_COLUMN_SIZE,        LVCFMT_RIGHT
};


CCoverPagesDlg::CCoverPagesDlg(CWnd* pParent /*=NULL*/)
	: CFaxClientDlg(CCoverPagesDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CCoverPagesDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CCoverPagesDlg::~CCoverPagesDlg()
{
    m_hDialog = NULL;
}

void 
CCoverPagesDlg::DoDataExchange(CDataExchange* pDX)
{
	CFaxClientDlg::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CCoverPagesDlg)
	DDX_Control(pDX, IDC_CP_DELETE, m_butDelete);
	DDX_Control(pDX, IDC_CP_RENAME, m_butRename);
	DDX_Control(pDX, IDC_CP_OPEN,   m_butOpen);
	DDX_Control(pDX, IDC_LIST_CP,   m_cpList);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CCoverPagesDlg, CFaxClientDlg)
	//{{AFX_MSG_MAP(CCoverPagesDlg)
    ON_MESSAGE (WM_CP_EDITOR_CLOSED, OnCpEditorClosed)
	ON_BN_CLICKED(IDC_CP_NEW,    OnCpNew)
	ON_BN_CLICKED(IDC_CP_OPEN,   OnCpOpen)
	ON_BN_CLICKED(IDC_CP_RENAME, OnCpRename)
	ON_BN_CLICKED(IDC_CP_DELETE, OnCpDelete)
	ON_BN_CLICKED(IDC_CP_ADD,    OnCpAdd)
	ON_NOTIFY(LVN_ITEMCHANGED,   IDC_LIST_CP, OnItemchangedListCp)
	ON_NOTIFY(LVN_ENDLABELEDIT,  IDC_LIST_CP, OnEndLabelEditListCp)
	ON_NOTIFY(NM_DBLCLK,         IDC_LIST_CP, OnDblclkListCp)
	ON_NOTIFY(LVN_KEYDOWN,       IDC_LIST_CP, OnKeydownListCp)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCoverPagesDlg message handlers

BOOL 
CCoverPagesDlg::OnInitDialog() 
{
    DBG_ENTER(TEXT("CCoverPagesDlg::OnInitDialog"));

	CFaxClientDlg::OnInitDialog();

    m_hDialog = m_hWnd;

    TCHAR tszCovDir[MAX_PATH+1];
    if(!GetClientCpDir(tszCovDir, sizeof(tszCovDir) / sizeof(tszCovDir[0])))
	{
		CString cstrCoverPageDirSuffix;
		m_dwLastError = LoadResourceString (cstrCoverPageDirSuffix, IDS_PERSONAL_CP_DIR);
		if(ERROR_SUCCESS != m_dwLastError)
		{
			CALL_FAIL (RESOURCE_ERR, TEXT ("LoadResourceString"), m_dwLastError);
			EndDialog(IDABORT);
			return FALSE;
		}

		if(!SetClientCpDir((TCHAR*)(LPCTSTR)cstrCoverPageDirSuffix))
		{
			CALL_FAIL (GENERAL_ERR, TEXT ("SetClientCpDir"), 0);
			ASSERTION_FAILURE;
		}
    }

	CSize size;
    CDC* pHdrDc = m_cpList.GetHeaderCtrl()->GetDC();
    ASSERTION(pHdrDc);

    //
    // init CListCtrl
    //
    m_cpList.SetExtendedStyle (LVS_EX_FULLROWSELECT |    // Entire row is selected
                               LVS_EX_INFOTIP       |    // Allow tooltips
                               LVS_EX_ONECLICKACTIVATE); // Hover cursor effect

    m_cpList.SetImageList (&CFolderListView::m_sReportIcons, LVSIL_SMALL);

    int nRes;
    CString cstrHeader;
    DWORD nCols = sizeof(s_colInfo)/sizeof(s_colInfo[0]);

    //
    // init column
    //
    for(int i=0; i < nCols; ++i)
    {
        m_dwLastError = LoadResourceString (cstrHeader, s_colInfo[i].dwStrRes);
        if(ERROR_SUCCESS != m_dwLastError)
        {
            CALL_FAIL (RESOURCE_ERR, TEXT ("LoadResourceString"), m_dwLastError);
            EndDialog(IDABORT);
            return FALSE;
        }

        size = pHdrDc->GetTextExtent(cstrHeader);
        nRes = m_cpList.InsertColumn(i, cstrHeader, s_colInfo[i].dwAlignment, size.cx * 2.5);
        if(nRes != i)
        {
            m_dwLastError = GetLastError();
            CALL_FAIL (WINDOW_ERR, TEXT ("CListView::InsertColumn"), m_dwLastError);
            EndDialog(IDABORT);
            return FALSE;
        }
    }

    //
    // fill list control with cover pages
    //
    m_dwLastError = RefreshFolder();
    if(ERROR_SUCCESS != m_dwLastError)
    {
        CALL_FAIL (GENERAL_ERR, TEXT ("RefreshFolder"), m_dwLastError);
        EndDialog(IDABORT);
        return FALSE;
    }
	
	CalcButtonsState();

	return TRUE; 
}

LRESULT 
CCoverPagesDlg::OnCpEditorClosed(
    WPARAM wParam, 
    LPARAM lParam
)
{ 
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CCoverPagesDlg::OnCpEditorClosed"), dwRes);

    CloseHandle(m_hEditorThread);
    m_hEditorThread = NULL;

    CalcButtonsState();

    dwRes = RefreshFolder();
    if(ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT ("RefreshFolder"), dwRes);
    }
	
    return 0;
}


DWORD 
CCoverPagesDlg::RefreshFolder()
/*++

Routine name : CCoverPagesDlg::RefreshFolder

Routine description:

	fill list control with cover pages

Author:

	Alexander Malysh (AlexMay),	Apr, 2000

Arguments:


Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CCoverPagesDlg::RefreshFolder"), dwRes);

    if(!m_cpList.DeleteAllItems())
    {
        dwRes = ERROR_CAN_NOT_COMPLETE;
        CALL_FAIL (WINDOW_ERR, TEXT ("CListView::DeleteAllItems"), dwRes);
        return dwRes;
    }

    //
    // get cover pages location
    //
    DWORD dwError;
    TCHAR tszCovDir[MAX_PATH+1];
    if(!GetClientCpDir(tszCovDir, sizeof(tszCovDir) / sizeof(tszCovDir[0])))
    {
        dwError = GetLastError();
        CALL_FAIL (GENERAL_ERR, TEXT("GetClientCpDir"), dwError);
        return dwRes;
    }

    DWORD  dwDirLen = _tcslen(tszCovDir);
    TCHAR* pPathEnd = _tcschr(tszCovDir, '\0');

    CString cstrPagesPath;
    try
    {
        cstrPagesPath.Format(TEXT("%s%s"), tszCovDir, FAX_COVER_PAGE_MASK);
    }
    catch(...)
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        CALL_FAIL (MEM_ERR, TEXT("CString::Format"), dwRes);
        return dwRes;
    }

    //
    // Find First File
    //
    WIN32_FIND_DATA findData;
    HANDLE hFile = FindFirstFile(cstrPagesPath, &findData);
    if(INVALID_HANDLE_VALUE == hFile)
    {
        dwError = GetLastError();
        if(ERROR_FILE_NOT_FOUND != dwError)
        {
            dwRes = dwError;
            CALL_FAIL (FILE_ERR, TEXT("FindFirstFile"), dwRes);
        }
        return dwRes;
    }

    int nItem, nRes;
    BOOL bFindRes = TRUE;
    CString cstrText;
    ULARGE_INTEGER  ulSize; 
    while(bFindRes)
    {
        _tcsncpy(pPathEnd, findData.cFileName, MAX_PATH - dwDirLen);
        if(!IsValidCoverPage(tszCovDir))
        {
            goto next;
        }                

        nItem = m_cpList.GetItemCount();

        //
        // file name
        //
        nRes = m_cpList.InsertItem(nItem, findData.cFileName, LIST_IMAGE_COVERPAGE);
        if(nRes < 0)
        {
            dwRes = ERROR_CAN_NOT_COMPLETE;
            CALL_FAIL (WINDOW_ERR, TEXT ("CListView::InsertItem"), dwRes);
            goto exit;
        }

        //
        // last modified
        //
        {
            CFaxTime tmModified(findData.ftLastWriteTime);
            try
            {
                cstrText = tmModified.FormatByUserLocale(TRUE);
            }
            catch(...)
            {
                dwRes = ERROR_NOT_ENOUGH_MEMORY; 
                CALL_FAIL (MEM_ERR, TEXT ("CString::operator="), dwRes);
                goto exit;
            }
        }

        nRes = m_cpList.SetItemText(nItem, 1, cstrText);
        if(!nRes)
        {
            dwRes = ERROR_CAN_NOT_COMPLETE;
            CALL_FAIL (WINDOW_ERR, TEXT ("CListView::SetItemText"), dwRes);
            goto exit;
        }

        //
        // file size
        //
        ulSize.LowPart  = findData.nFileSizeLow;
        ulSize.HighPart = findData.nFileSizeHigh;
        dwRes = FaxSizeFormat(ulSize.QuadPart, cstrText);
        if(ERROR_SUCCESS != dwRes)
        {
            CALL_FAIL (GENERAL_ERR, TEXT("FaxSizeFormat"), dwRes);
            goto exit;
        }

        nRes = m_cpList.SetItemText(nItem, 2, cstrText);
        if(!nRes)
        {
            dwRes = ERROR_CAN_NOT_COMPLETE;
            CALL_FAIL (WINDOW_ERR, TEXT ("CListView::SetItemText"), dwRes);
            goto exit;
        }

        //
        // Find Next File
        //
next:
        bFindRes = FindNextFile(hFile, &findData);
        if(!bFindRes)
        {
            dwError = GetLastError();
            if(ERROR_NO_MORE_FILES != dwError)
            {
                dwRes = dwError;
                CALL_FAIL (FILE_ERR, TEXT("FindNextFile"), dwRes);
            }
            break;
        }
    }

exit:
    if(INVALID_HANDLE_VALUE != hFile)
    {
        if(!FindClose(hFile))
        {
            CALL_FAIL (GENERAL_ERR, TEXT("FindClose"), GetLastError());
        }
    }

    CalcButtonsState();

    return dwRes;
}

void 
CCoverPagesDlg::OnItemchangedListCp(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

    CalcButtonsState();
    
	*pResult = 0;
}


void 
CCoverPagesDlg::OnDblclkListCp(NMHDR* pNMHDR, LRESULT* pResult) 
{
    OnCpOpen();

	*pResult = 0;
}

void 
CCoverPagesDlg::OnKeydownListCp(NMHDR* pNMHDR, LRESULT* pResult) 
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CCoverPagesDlg::OnKeydownListCp"));

    LV_KEYDOWN* pLVKeyDow = (LV_KEYDOWN*)pNMHDR;

    switch(pLVKeyDow->wVKey)
    {
    case VK_F5:
        dwRes = RefreshFolder();
        if(ERROR_SUCCESS != dwRes)
        {
            CALL_FAIL (GENERAL_ERR, TEXT ("RefreshFolder"), dwRes);
        }
        break;

    case VK_DELETE:
        OnCpDelete();
        break;

    case VK_RETURN:
        OnCpOpen();
        break;
    }
    
	*pResult = 0;
}

void 
CCoverPagesDlg::OnCpNew() 
/*++

Routine name : CCoverPagesDlg::OnCpNew

Routine description:

	create new cover page

Author:

	Alexander Malysh (AlexMay),	Apr, 2000

Arguments:


Return Value:

    None.

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CCoverPagesDlg::OnCpNew"));

    dwRes = StartEditor(NULL);
    if(ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT ("StartEditor"), dwRes);
        PopupError(dwRes);
    }

    dwRes = RefreshFolder();
    if(ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT ("RefreshFolder"), dwRes);
        PopupError(dwRes);
    }
}

void 
CCoverPagesDlg::OnCpOpen() 
/*++

Routine name : CCoverPagesDlg::OnCpOpen

Routine description:

	open selected cover page in editor

Author:

	Alexander Malysh (AlexMay),	Apr, 2000

Arguments:


Return Value:

    None.

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CCoverPagesDlg::OnCpOpen"));

    DWORD dwSelected = m_cpList.GetSelectedCount();
    if(1 != dwSelected)
    {
        return;
    }

    int nIndex = m_cpList.GetNextItem (-1, LVNI_SELECTED);
    ASSERTION (0 <= nIndex);

    TCHAR  tszFileName[MAX_PATH+5];
    TCHAR* tszPtr = tszFileName;

    //
    // add quotation to file name
    //
    _tcscpy(tszPtr, TEXT("\""));
    tszPtr = _tcsinc(tszPtr);

    m_cpList.GetItemText(nIndex, 0, tszPtr, MAX_PATH); 

    _tcscat(tszPtr, TEXT("\""));

    dwRes = StartEditor(tszFileName);
    if(ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT ("StartEditor"), dwRes);
        PopupError(dwRes);
    }

    dwRes = RefreshFolder();
    if(ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT ("RefreshFolder"), dwRes);
        PopupError(dwRes);
    }
}

void 
CCoverPagesDlg::OnCpRename() 
/*++

Routine name : CCoverPagesDlg::OnCpRename

Routine description:

	start renaming a file name

Author:

	Alexander Malysh (AlexMay),	Apr, 2000

Arguments:


Return Value:

    None.

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CCoverPagesDlg::OnCpRename"));

    int nIndex = m_cpList.GetNextItem (-1, LVNI_SELECTED);
    if(nIndex < 0)
    {
        return;
    }

    m_cpList.SetFocus();
    m_cpList.EditLabel(nIndex);
}

void 
CCoverPagesDlg::OnEndLabelEditListCp(NMHDR* pNMHDR, LRESULT* pResult) 
/*++

Routine name : CCoverPagesDlg::OnCpRename

Routine description:

	end of file renaming

Author:

	Alexander Malysh (AlexMay),	Apr, 2000

Arguments:


Return Value:

    None.

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CCoverPagesDlg::OnEndLabelEditListCp"));

    *pResult = 0;

    LV_DISPINFO* pDispInfo = (LV_DISPINFO*)pNMHDR;

    int nIndex = pDispInfo->item.iItem;

    TCHAR tszOldName[MAX_PATH+1];
    m_cpList.GetItemText(nIndex, 0, tszOldName, MAX_PATH); 
    
    if(NULL == pDispInfo->item.pszText || 
       _tcscmp(tszOldName, pDispInfo->item.pszText) == 0)
    {
        return;
    }

    //
    // get old and new file names
    //
    TCHAR tszCovDir[MAX_PATH+1];
    if(!GetClientCpDir(tszCovDir, sizeof(tszCovDir) / sizeof(tszCovDir[0])))
    {
        dwRes = GetLastError();
        CALL_FAIL (GENERAL_ERR, TEXT("GetClientCpDir"), dwRes);
        PopupError(dwRes);
        return;
    }

    CString cstrOldFullName;
    CString cstrNewFullName;
    try
    {
        cstrOldFullName.Format(TEXT("%s\\%s"), tszCovDir, tszOldName);
        cstrNewFullName.Format(TEXT("%s\\%s"), tszCovDir, pDispInfo->item.pszText);
    }
    catch(...)
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        CALL_FAIL (MEM_ERR, TEXT("CString::Format"), dwRes);
        PopupError(dwRes);
        return;
    }

    //
    // rename the file
    //
    if(!MoveFile(cstrOldFullName, cstrNewFullName))
    {
        dwRes = GetLastError();
        CALL_FAIL (FILE_ERR, TEXT("MoveFile"), dwRes);
        PopupError(dwRes);
        return;
    }

    *pResult = TRUE;
}

void 
CCoverPagesDlg::OnCpDelete() 
/*++

Routine name : CCoverPagesDlg::OnCpDelete

Routine description:

	delete selected cover page

Author:

	Alexander Malysh (AlexMay),	Apr, 2000

Arguments:


Return Value:

    None.

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CCoverPagesDlg::OnCpDelete"));
	
    DWORD dwSelected = m_cpList.GetSelectedCount();
    if(1 != dwSelected)
    {
        return;
    }

    if(theApp.GetProfileInt(CLIENT_CONFIRM_SEC, CLIENT_CONFIRM_ITEM_DEL, 1))
    {     
        //
        // we should ask to confirm 
        //
        CString cstrMsg;
        dwRes = LoadResourceString(cstrMsg, IDS_SURE_DELETE_ONE);
        if (ERROR_SUCCESS != dwRes)
        {
            CALL_FAIL (RESOURCE_ERR, TEXT("LoadResourceString"), dwRes);
            PopupError(dwRes);
            return;
        }

        //
        // are you sure ?
        //
        if(AlignedAfxMessageBox(cstrMsg, MB_YESNO | MB_ICONQUESTION) != IDYES)
        {
            return;
        }
    }


    int nIndex = m_cpList.GetNextItem (-1, LVNI_SELECTED);
    ASSERTION (0 <= nIndex);

    //
    // get file name
    //
    TCHAR tszFileName[MAX_PATH+1];
    m_cpList.GetItemText(nIndex, 0, tszFileName, MAX_PATH); 

    TCHAR tszCovDir[MAX_PATH+1];
    if(!GetClientCpDir(tszCovDir, sizeof(tszCovDir) / sizeof(tszCovDir[0])))
    {
        dwRes = GetLastError();
        CALL_FAIL (GENERAL_ERR, TEXT("GetClientCpDir"), dwRes);
        PopupError(dwRes);
        return;
    }

    CString cstrFullFileName;
    try
    {
        cstrFullFileName.Format(TEXT("%s\\%s"), tszCovDir, tszFileName);
    }
    catch(...)
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        CALL_FAIL (MEM_ERR, TEXT("CString::Format"), dwRes);
        PopupError (dwRes);
        return;
    }

    //
    // delete the file
    //
    if(!DeleteFile(cstrFullFileName))
    {
        dwRes = GetLastError();
        CALL_FAIL (FILE_ERR, TEXT("DeleteFile"), dwRes);
        PopupError(dwRes);
        return;
    }

    if(!m_cpList.DeleteItem(nIndex))
    {
        PopupError (ERROR_CAN_NOT_COMPLETE);
        return;
    }
}

void 
CCoverPagesDlg::OnCpAdd() 
/*++

Routine name : CCoverPagesView::OnCpAdd

Routine description:

	open file dialog for choosing file

Author:

	Alexander Malysh (AlexMay),	Feb, 2000

Arguments:


Return Value:

    None.

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CCoverPagesDlg::OnCpAdd"));

    TCHAR szFile[MAX_PATH] = {0};
    TCHAR szFilter[MAX_PATH] = {0};
    TCHAR szInitialDir[MAX_PATH * 2] = {0};
    OPENFILENAME ofn = {0};

    CString cstrFilterFormat;
    dwRes = LoadResourceString(cstrFilterFormat, IDS_CP_ADD_FILTER_FORMAT);
    if (ERROR_SUCCESS != dwRes)
    {
        ASSERTION_FAILURE;
        CALL_FAIL (RESOURCE_ERR, TEXT("LoadResourceString"), dwRes);
        return;
    }

    _stprintf(szFilter, cstrFilterFormat, FAX_COVER_PAGE_MASK, 0, FAX_COVER_PAGE_MASK, 0);

    CString cstrTitle;
    dwRes = LoadResourceString(cstrTitle, IDS_COPY_CP_TITLE);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (RESOURCE_ERR, TEXT("LoadResourceString"), dwRes);
    }
    else
    {
        //
        // Set open file dialog title
        //
        ofn.lpstrTitle = cstrTitle;
    }

    //
    // Attempt to read path of server (e.g. common) CP folder as initial path
    //
    if (GetServerCpDir (NULL, szInitialDir, ARR_SIZE(szInitialDir)))
    {
        ofn.lpstrInitialDir = szInitialDir;
    }
        

    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner   = m_hWnd;
    ofn.lpstrFilter = szFilter;
    ofn.lpstrFile   = szFile;
    ofn.nMaxFile    = ARR_SIZE(szFile);
    ofn.lpstrDefExt = FAX_COVER_PAGE_EXT_LETTERS;
    ofn.Flags       = OFN_EXPLORER | OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT | OFN_FILEMUSTEXIST;

    if(!GetOpenFileName(&ofn))
    {
        return;
    }

    dwRes = CopyPage(szFile, &(szFile[ofn.nFileOffset]) );
    if(ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("CopyPage"), dwRes);
    }    
}


void 
CCoverPagesDlg::CalcButtonsState()
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CCoverPagesDlg::CalcButtonsState"), dwRes);

    DWORD dwControls[] = 
    {
        IDC_LIST_CP,
        IDC_CP_NEW,
        IDC_CP_OPEN,
        IDC_CP_ADD,
        IDC_CP_RENAME,
        IDC_CP_DELETE,
        IDCANCEL
    };

    CWnd* pWnd = NULL;
    DWORD dwControlNum = sizeof(dwControls)/sizeof(dwControls[0]);

    //
    // if the Cover Page Editor is open disable all controls
    //
    for(DWORD dw=0; dw < dwControlNum; ++dw)
    {
        pWnd = GetDlgItem(dwControls[dw]);
        if(NULL == pWnd)
        {
            CALL_FAIL (WINDOW_ERR, TEXT("CWnd::GetDlgItem"), ERROR_INVALID_HANDLE);
            ASSERTION_FAILURE;
            continue;
        }
        pWnd->EnableWindow(!m_hEditorThread);
    }

    if(m_hEditorThread)
    {
        return;
    }

    DWORD dwSelCount = m_cpList.GetSelectedCount();

    m_butOpen.EnableWindow(1 == dwSelCount);
    m_butRename.EnableWindow(1 == dwSelCount);
    m_butDelete.EnableWindow(0 < dwSelCount);
}

DWORD 
CCoverPagesDlg::CopyPage(
    const CString& cstrPath, 
    const CString& cstrName
)
/*++

Routine name : CCoverPagesDlg::CopyPage

Routine description:

	copy file to the personal folder

Author:

	Alexander Malysh (AlexMay),	Feb, 2000

Arguments:

	cstrPath                      [in]     - full path
	cstrName                      [in]     - file name

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CCoverPagesDlg::CopyPage"), dwRes);

    LVFINDINFO findInfo = {0};
    findInfo.flags = LVFI_STRING;
    findInfo.psz = cstrName;

    CString cstrMsg;
    int nIndex = m_cpList.FindItem(&findInfo);
    if(nIndex >= 0)
    {
        //
        // file with this name already exists
        //
        try
        {
            AfxFormatString1(cstrMsg, IDS_COVER_PAGE_EXISTS, cstrName);
        }
        catch(...)
        {
            dwRes = ERROR_NOT_ENOUGH_MEMORY;
            CALL_FAIL (MEM_ERR, TEXT("AfxFormatString1"), dwRes);
            return dwRes;
        }

        //
        // ask for overwrite
        //
        if(IDYES != AlignedAfxMessageBox(cstrMsg, MB_YESNO | MB_ICONQUESTION))
        {
            return dwRes;
        }
    }


    //
    // prepare a string with new file location
    //
    TCHAR tszCovDir[MAX_PATH+1];
    if(!GetClientCpDir(tszCovDir, sizeof(tszCovDir) / sizeof(tszCovDir[0])))
    {
        dwRes = GetLastError();
        CALL_FAIL (GENERAL_ERR, TEXT("GetClientCpDir"), dwRes);
        return dwRes;
    }

    CString cstrNewFileName;
    try
    {
        cstrNewFileName.Format(TEXT("%s\\%s"), tszCovDir, cstrName);
    }
    catch(...)
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        CALL_FAIL (MEM_ERR, TEXT("CString::Format"), dwRes);
        return dwRes;
    }

    //
    // copy file
    //
    BOOL bFailIfExists = FALSE;
    if(!CopyFile(cstrPath, cstrNewFileName, bFailIfExists))
    {
        dwRes = GetLastError();
        CALL_FAIL (FILE_ERR, TEXT("CopyFile"), dwRes);
        return dwRes;
    }

    dwRes = RefreshFolder();
    if(ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT ("RefreshFolder"), dwRes);
        return dwRes;
    }

    return dwRes;
}

DWORD 
CCoverPagesDlg::StartEditor(
    LPCTSTR lpFile
)
/*++

Routine name : CCoverPagesDlg::StartEditor

Routine description:

    start cover pages editor

Author:

    Alexander Malysh (AlexMay), Feb, 2000

Arguments:

    lpFile                        [in]     - file name

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CCoverPagesDlg::StartEditor"), dwRes);

    TCHAR* tszParam = NULL;

    if(lpFile)
    {
        tszParam = StringDup(lpFile);
        if(!tszParam)
        {
            dwRes = ERROR_NOT_ENOUGH_MEMORY;
            CALL_FAIL (MEM_ERR, TEXT("StringDup"), dwRes);
            return dwRes;
        }
    }

    DWORD dwThreadId;
    m_hEditorThread = CreateThread(
                                   NULL,                 // SD
                                   0,                    // initial stack size
                                   StartEditorThreadProc,// thread function
                                   (LPVOID)tszParam,     // thread argument
                                   0,                    // creation option
                                   &dwThreadId           // thread identifier
                                  );
    if(!m_hEditorThread)
    {
        dwRes = GetLastError();
        CALL_FAIL (GENERAL_ERR, TEXT("CreateThread"), dwRes);        
        if(tszParam)
        {
            MemFree(tszParam);
        }
        return dwRes;
    }

    CalcButtonsState();

    return dwRes;
} // CCoverPagesDlg::StartEditor


DWORD 
WINAPI 
CCoverPagesDlg::StartEditorThreadProc(
    LPVOID lpFile
)
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CCoverPagesDlg::StartEditorThreadProc"), dwRes);

    TCHAR tszCovDir[MAX_PATH+1] = {0};
  	SHELLEXECUTEINFO executeInfo = {0};

    //
    // get cover pages editor location
    //
    CString cstrCovEditor;
    dwRes = GetAppLoadPath(cstrCovEditor);
    if(ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("GetAppLoadPath"), dwRes);
        goto exit;
    }

    try
    {
        cstrCovEditor += FAX_COVER_IMAGE_NAME;
    }
    catch(...)
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        CALL_FAIL (MEM_ERR, TEXT("CString::operator+"), dwRes);
        goto exit;
    }

    //
    // get cover pages directory
    //
    if(!GetClientCpDir(tszCovDir, sizeof(tszCovDir) / sizeof(tszCovDir[0])))
    {
        dwRes = GetLastError();
        CALL_FAIL (GENERAL_ERR, TEXT("GetClientCpDir"), dwRes);
        goto exit;
    }
    
	//
	// prepare SHELLEXECUTEINFO struct for ShellExecuteEx function
	//
	executeInfo.cbSize = sizeof(executeInfo);
	executeInfo.fMask  = SEE_MASK_NOCLOSEPROCESS;
	executeInfo.lpVerb = TEXT("open");
	executeInfo.lpFile = cstrCovEditor;
    executeInfo.lpParameters = (TCHAR*)lpFile;
    executeInfo.lpDirectory  = tszCovDir;
	executeInfo.nShow  = SW_RESTORE;

	//
	// Execute an aplication
	//
	if(!ShellExecuteEx(&executeInfo))
	{
		dwRes = GetLastError();
        CALL_FAIL (GENERAL_ERR, TEXT("ShellExecuteEx"), dwRes);
		goto exit;
	}

    DWORD dwWaitRes;    
    dwWaitRes = WaitForSingleObject(executeInfo.hProcess, INFINITE);

    switch(dwWaitRes)
    {
    case WAIT_OBJECT_0:
        //
        // cover pages editor is dead
        //
        break;

    default:
        dwRes = dwWaitRes;
        ASSERTION_FAILURE
        break;
    }

    if(!CloseHandle(executeInfo.hProcess))
    {
		dwRes = GetLastError();
        CALL_FAIL (GENERAL_ERR, TEXT("CloseHandle"), dwRes);
    }

exit:
    if(lpFile)
    {
        MemFree(lpFile);
    }

    ASSERTION(CCoverPagesDlg::m_hDialog);
    ::SendMessage(CCoverPagesDlg::m_hDialog, WM_CP_EDITOR_CLOSED, 0, NULL);

    return dwRes;
} // CCoverPagesDlg::StartEditorThreadProc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\columnselectdlg.h ===
#if !defined(AFX_COLUMNSELECTDLG_H__12FC80A8_741C_4589_AC4B_01F72CBAECE9__INCLUDED_)
#define AFX_COLUMNSELECTDLG_H__12FC80A8_741C_4589_AC4B_01F72CBAECE9__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ColumnSelectDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CColumnSelectDlg dialog


class CColumnSelectDlg : public CFaxClientDlg
{
// Construction
public:
	CColumnSelectDlg(const CString* pcstrTitles, int* pnOrderedItems, 
			DWORD dwListSize, DWORD& dwSelectedItems, CWnd* pParent = NULL);
	// 
	// set resource string resource IDs
	//
	void SetStrings
	(
		int nCaptionId,			// dialog caption resource ID
		int nAvailableId = -1,  // Available box title resource ID
		int nDisplayedId = -1   // Displayed box title resource ID
	)
	{
		m_nCaptionId = nCaptionId;
		m_nAvailableId = nAvailableId;
		m_nDisplayedId = nDisplayedId;	
	}

// Dialog Data
	//{{AFX_DATA(CColumnSelectDlg)
	enum { IDD = IDD_COLUMN_SELECT };
	CButton	m_butOk;
	CButton	m_groupAvailable;
	CButton	m_groupDisplayed;
	CButton	m_butAdd;
	CButton	m_butRemove;	
	CButton	m_butUp;
	CButton	m_butDown;
	CListBox	m_ListCtrlDisplayed;
	CListBox	m_ListCtrlAvailable;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CColumnSelectDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CColumnSelectDlg)
	virtual void OnOK();
	afx_msg void OnButDown();
	afx_msg void OnButUp();
	afx_msg void OnButRemove();
	afx_msg void OnButAdd();
	virtual BOOL OnInitDialog();
	afx_msg void OnSelChangeListAvailable();
	afx_msg void OnSelChangeListDisplayed();
	afx_msg void OnDblclkListAvailable();
	afx_msg void OnDblclkListDisplayed();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	const CString* m_pcstrTitles;
	int* m_pnOrderedItems;
	const DWORD m_dwListSize;
	DWORD& m_rdwSelectedItems;

	int m_nCaptionId;
	int m_nAvailableId;
	int m_nDisplayedId;

private:
	BOOL InputValidate();
	void MoveSelectedItems(CListBox& listFrom, CListBox& listTo);
	void MoveItemVertical(int nStep);
	BOOL AddStrToList(CListBox& listBox, DWORD dwItemId);
	BOOL SetWndCaption(CWnd* pWnd, int nResId);
	void CalcButtonsState();
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_COLUMNSELECTDLG_H__12FC80A8_741C_4589_AC4B_01F72CBAECE9__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\faxclientdlg.cpp ===
// FaxClientDlg.cpp : implementation file
//

#include "stdafx.h"
#define __FILE_ID__     72


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CFaxClientDlg dialog


CFaxClientDlg::CFaxClientDlg(DWORD dwDlgId, CWnd* pParent /*=NULL*/)
    : CDialog(dwDlgId, pParent),
    m_dwLastError(ERROR_SUCCESS)
{
    //{{AFX_DATA_INIT(CFaxClientDlg)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
}


void CFaxClientDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CFaxClientDlg)
        // NOTE: the ClassWizard will add DDX and DDV calls here
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CFaxClientDlg, CDialog)
    //{{AFX_MSG_MAP(CFaxClientDlg)
    ON_MESSAGE(WM_HELP, OnHelp)
    ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFaxClientDlg message handlers

LONG
CFaxClientDlg::OnHelp(
    WPARAM wParam,
    LPARAM lParam
)
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CFaxClientDlg::OnHelp"));

    dwRes = WinHelpContextPopup(((LPHELPINFO)lParam)->dwContextId, m_hWnd);
    if(ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("WinHelpContextPopup"),dwRes);
    }

    return TRUE;
}

void
CFaxClientDlg::OnContextMenu(
    CWnd* pWnd,
    CPoint point
)
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CFaxClientDlg::OnContextMenu"));

    dwRes = WinHelpContextPopup(pWnd->GetWindowContextHelpId(), m_hWnd);
    if(ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("WinHelpContextPopup"),dwRes);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\faxclientdlg.h ===
#if !defined(AFX_FAXCLIENTDLG_H__9AF54B29_2711_4752_8832_27D9F6F616FC__INCLUDED_)
#define AFX_FAXCLIENTDLG_H__9AF54B29_2711_4752_8832_27D9F6F616FC__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// FaxClientDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CFaxClientDlg dialog

class CFaxClientDlg : public CDialog
{
// Construction
public:
    CFaxClientDlg(DWORD dwDlgId, CWnd* pParent = NULL);   // standard constructor

    DWORD GetLastDlgError() { return m_dwLastError; }

// Dialog Data
    //{{AFX_DATA(CFaxClientDlg)
        // NOTE: the ClassWizard will add data members here
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CFaxClientDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    DWORD m_dwLastError;

    // Generated message map functions
    //{{AFX_MSG(CFaxClientDlg)
    afx_msg LONG OnHelp(WPARAM wParam, LPARAM lParam);
    afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_FAXCLIENTDLG_H__9AF54B29_2711_4752_8832_27D9F6F616FC__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\faxclientpg.cpp ===
// FaxClientPg.cpp : implementation file
//

#include "stdafx.h"
#define __FILE_ID__     74

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

/////////////////////////////////////////////////////////////////////////////
// CFaxClientPg property page

IMPLEMENT_DYNCREATE(CFaxClientPg, CPropertyPage)

CFaxClientPg::CFaxClientPg(
    UINT nIDTemplate,
    UINT nIDCaption
)   :CPropertyPage(nIDTemplate, nIDCaption)
{
    //
    // hide the Help button
    //
    m_psp.dwFlags &= ~PSP_HASHELP;
}

CFaxClientPg::~CFaxClientPg()
{
}

void CFaxClientPg::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CFaxClientPg)
        // NOTE: the ClassWizard will add DDX and DDV calls here
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CFaxClientPg, CPropertyPage)
    //{{AFX_MSG_MAP(CFaxClientPg)
    ON_MESSAGE(WM_HELP, OnHelp)
    ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFaxClientPg message handlers

LONG
CFaxClientPg::OnHelp(
    WPARAM wParam,
    LPARAM lParam
)
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CFaxClientPg::OnHelp"));

    dwRes = WinHelpContextPopup(((LPHELPINFO)lParam)->dwContextId, m_hWnd);
    if(ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("WinHelpContextPopup"),dwRes);
    }

    return TRUE;
}

void
CFaxClientPg::OnContextMenu(
    CWnd* pWnd,
    CPoint point
)
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CFaxClientPg::OnContextMenu"));

    dwRes = WinHelpContextPopup(pWnd->GetWindowContextHelpId(), m_hWnd);
    if(ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("WinHelpContextPopup"),dwRes);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\faxclientpg.h ===
#if !defined(AFX_FAXCLIENTPG_H__C9851773_AF2E_4C0B_B2F2_30E2E8FACF93__INCLUDED_)
#define AFX_FAXCLIENTPG_H__C9851773_AF2E_4C0B_B2F2_30E2E8FACF93__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// FaxClientPg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CFaxClientPg dialog

class CFaxClientPg : public CPropertyPage
{
    DECLARE_DYNCREATE(CFaxClientPg)

// Construction
public:
    CFaxClientPg(UINT nIDTemplate, UINT nIDCaption=0);
    ~CFaxClientPg();


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CFaxClientPg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    CFaxClientPg() {}

    // Generated message map functions
    //{{AFX_MSG(CFaxClientPg)
    afx_msg LONG OnHelp(WPARAM wParam, LPARAM lParam);
    afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_FAXCLIENTPG_H__C9851773_AF2E_4C0B_B2F2_30E2E8FACF93__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\faxtime.h ===
// FaxTime.h: interface for the CFaxTime class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_FAXTIME_H__00A7FD8D_0FBC_4CA3_8187_836431261D07__INCLUDED_)
#define AFX_FAXTIME_H__00A7FD8D_0FBC_4CA3_8187_836431261D07__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CFaxDuration : public CTimeSpan
{
public:
    CFaxDuration () : CTimeSpan () {}
    CFaxDuration (time_t time) : CTimeSpan (time) {}

    virtual ~CFaxDuration () {}

    CString FormatByUserLocale () const;
    int Compare(const CFaxDuration & other) const
        { return (other == *this) ? 0 : ((*this < other) ? -1 : 1); }

    void Zero()
        { *this = CFaxDuration (0); }

};

class CFaxTime : public CTime  
{
public:
    CFaxTime() : CTime () {}
    CFaxTime( const CFaxTime& timeSrc ) : CTime (timeSrc) {}
    CFaxTime( time_t time ) : CTime (time) {}
    CFaxTime( int nYear, int nMonth, int nDay, int nHour, int nMin, int nSec, int nDST = -1 ) :
        CTime (nYear, nMonth, nDay, nHour, nMin, nSec, nDST)
        {}
    CFaxTime( WORD wDosDate, WORD wDosTime, int nDST = -1 ) : CTime (wDosDate, wDosTime, nDST)
        {}
    CFaxTime( const SYSTEMTIME& sysTime, int nDST = -1 ) : CTime (sysTime, nDST) {}
    CFaxTime( const FILETIME& fileTime, int nDST = -1 ) : CTime (fileTime, nDST) {}

    virtual ~CFaxTime() {}

    CString FormatByUserLocale (BOOL bLocal = FALSE) const;

    const CFaxTime &operator = (const SYSTEMTIME &SysTime)
        { *this = CFaxTime (SysTime); return *this; }

    CFaxDuration operator -( CFaxTime rhs ) const
        { return CFaxDuration(GetTime() - rhs.GetTime ()); }

    int Compare(const CFaxTime & other) const
        { return (other == *this) ? 0 : ((*this < other) ? -1 : 1); }

    void Zero()
        { *this = CFaxTime (0); }
};

#endif // !defined(AFX_FAXTIME_H__00A7FD8D_0FBC_4CA3_8187_836431261D07__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\folder.cpp ===
// Folder.cpp: implementation of the CFolder class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#define __FILE_ID__     21

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNAMIC(CFolder, CTreeNode)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

void
CFolder::PreDestruct ()
{
    DBG_ENTER(TEXT("CFolder::PreDestruct"), TEXT("Type=%d"), m_Type);
    //
    // Stop the build thread - and wait for its death
    //
    DWORD dwRes = StopBuildThread ();
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("CFolder::StopBuildThread"), dwRes);
    }
    //
    // Clear the map of items
    //
    dwRes = InvalidateContents(FALSE);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("CFolder::InvalidateContents"), dwRes);
    }
}   // CFolder::PreDestruct

CFolder::~CFolder()
{
    DBG_ENTER(TEXT("CFolder::~CFolder"), TEXT("Type=%d"), m_Type);
    //
    // Destroy data critical section
    //
    if (m_bCsDataInitialized)
    {
        DeleteCriticalSection (&m_CsData);
    }
}   // CFolder::~CFolder


CFaxMsg*
CFolder::FindMessage (
    DWORDLONG dwlMsgId
)
{
    DBG_ENTER(TEXT("CFolder::FindMessage"));

    MSGS_MAP::iterator it = m_Msgs.find (dwlMsgId);
    if (m_Msgs.end() == it)
    {
        //
        // Not found
        //
        return NULL;
    }
    else
    {
        return (*it).second;
    }
}   // CFolder::FindMessage

void CFolder::AssertValid() const
{
    CTreeNode::AssertValid();
}

void
CFolder::SetServer ( 
    CServerNode *pServer
)
{
    DBG_ENTER(TEXT("CFolder::SetServer"));
    ASSERTION (NULL != pServer);
    m_pServer = pServer;

    VERBOSE (DBG_MSG,
             TEXT ("Folder on server %s, Type=%d"), 
             m_pServer->Machine(),
             m_Type);
}

DWORD
CFolder::Init ()
/*++

Routine name : CFolder::Init

Routine description:

    Init a folder

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CFolder::Init"), dwRes);

    //
    // Init the build thread critical section
    //
    try
    {
        InitializeCriticalSection (&m_CsData);
    }
    catch (...)
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        CALL_FAIL (MEM_ERR, TEXT ("InitializeCriticalSection"), dwRes);
        return dwRes;
    }
    m_bCsDataInitialized = TRUE;

    return dwRes;
}   // CFolder::Init


void 
CFolder::AttachView()
{
	DBG_ENTER(TEXT("CFolder::AttachView"));

    CMainFrame *pFrm = GetFrm();
    if (!pFrm)
    {
        //
        //  Shutdown in progress
        //
        return;
    }

	//
    // Attach the right view to the folder
	//
    switch (m_Type)
    {
        case FOLDER_TYPE_INBOX:
            m_pAssignedView = pFrm->GetInboxView ();
            break;

        case FOLDER_TYPE_INCOMING:
            m_pAssignedView = pFrm->GetIncomingView ();
            break;

        case FOLDER_TYPE_OUTBOX:
            m_pAssignedView = pFrm->GetOutboxView ();
            break;

        case FOLDER_TYPE_SENT_ITEMS:
            m_pAssignedView = pFrm->GetSentItemsView ();
            break;


        default:
            ASSERTION_FAILURE;
    }
	ASSERTION(m_pAssignedView);

} //CFolder::AttachView


void
CFolder::SetVisible()
/*++

Routine name : CFolder::SetVisible

Routine description:

    Sets the visiblity of a folder

Author:

    Eran Yariv (EranY), Jan, 2000

Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CFolder::SetVisible"), 
              TEXT("Server = %s, Type=%d"), 
              m_pServer ? m_pServer->Machine() : TEXT("None"),
              m_Type); 


    //
    // This folder's tree node was just selected
    //
    m_bVisible = TRUE;

    if (!m_bValidList && !m_bRefreshing)
    {
        //
        // The items list is invalid and there's not thread currently creating it.
        //
        // This is the 1st time this node is being selected for display
        // (since its creation) - build the list of jobs / messages now
        // 
        // NOTICE: RebuildContents() calls StopBuildThread() which waits for
        //         the previous thread to die WHILE DEQUEUEING WINDOWS MESSAGES.
        //         This may causes a seconds call to this function BEFORE 
        //         RebuildContents() returned.
        // 
        DWORD dwRes = RebuildContents ();
        if (ERROR_SUCCESS != dwRes)
        {
            CALL_FAIL (GENERAL_ERR, TEXT ("CFolder::RebuildContents"), dwRes);
        }
    }

}   // CFolder::SetVisible



DWORD   
CFolder::InvalidateContents (
    BOOL bClearView                             
)
/*++

Routine name : CFolder::InvalidateContents

Routine description:

    Clears the contents of a folder (and the view if attached)

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    bClearView   [in] - Should we clear attached view ?


Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CFolder::InvalidateContents"), dwRes, TEXT("Type=%d"), m_Type);

    CFaxMsg* pMsg;

    EnterData ();
    for (MSGS_MAP::iterator it = m_Msgs.begin(); it != m_Msgs.end(); ++it)
    {
        pMsg = (*it).second;

        if(bClearView && m_pAssignedView)
        {
           m_pAssignedView->OnUpdate (NULL, UPDATE_HINT_REMOVE_ITEM, pMsg);
        }

        SAFE_DELETE (pMsg);
    }
    m_Msgs.clear();
    LeaveData ();

    //
    // Mark list as invalid
    //
    m_bValidList = FALSE;
    return dwRes;
}   // CFolder::InvalidateContents

DWORD            
CFolder::RebuildContents ()
/*++

Routine name : CFolder::RebuildContents

Routine description:

    Rebuilds the contents of a folder (by creating a worker thread)

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:


Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CFolder::RebuildContents"), dwRes, TEXT("Type=%d"), m_Type);

    ASSERTION(!m_bRefreshing);

    m_bRefreshing = TRUE;

    //
    // Stop the current (if any) build thread and make sure it's dead
    //
    m_bRefreshFailed = FALSE;
    DWORD dwThreadId;

    dwRes = StopBuildThread ();
    EnterCriticalSection (&m_CsData);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (RESOURCE_ERR, TEXT("CFolder::StopBuildThread"), dwRes);
        m_bRefreshing = FALSE;
        goto exit;
    }
    //
    // Lock the folder, so that notifications will not add jobs / messages
    // to the map and list view.
    //
    m_bLocked = TRUE;
    //
    // Clear our list and our view (list control)
    //
    dwRes = InvalidateContents(FALSE);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (RPC_ERR, TEXT("CFolder::InvalidateContents"), dwRes);
        m_bLocked = FALSE;
        m_bRefreshing = FALSE;
        goto exit;
    }
    //
    // Start the thread that will fill the data (in the background)
    //
    m_bStopRefresh = FALSE;
    m_hBuildThread = CreateThread (  
                        NULL,           // No security
                        0,              // Default stack size
                        BuildThreadProc,// Thread procedure
                        (LPVOID)this,   // Parameter
                        0,              // Normal creation
                        &dwThreadId     // We must have a thread id for win9x
                     );
    if (NULL == m_hBuildThread)
    {
        dwRes = GetLastError ();
        CALL_FAIL (RESOURCE_ERR, TEXT("CreateThread"), dwRes);
        PopupError (dwRes);
        m_bLocked = FALSE;
        m_bRefreshing = FALSE;
    }
exit:
    LeaveCriticalSection (&m_CsData);
    return dwRes;
}   // CFolder::RebuildContents


DWORD            
CFolder::StopBuildThread (BOOL bWaitForDeath)
/*++

Routine name : CFolder::StopBuildThread

Routine description:

    Stops the contents-building worker thread.

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    bWaitForDeath   [in] - Should we wait until the therad actually dies?

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CFolder::StopBuildThread"), dwRes, TEXT("Type=%d"), m_Type);

    m_bStopRefresh = TRUE;
    if (!bWaitForDeath)
    {
        return dwRes;
    }
    if (NULL == m_hBuildThread)
    {
        //
        // Background build thread is already dead
        //
        return dwRes;
    }
    dwRes = WaitForThreadDeathOrShutdown (m_hBuildThread);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("WaitForThreadDeathOrShutdown"), dwRes);
    }
    CloseHandle (m_hBuildThread);
    m_hBuildThread = NULL;
    return dwRes;
}   // CFolder::StopBuildThread

        

DWORD 
WINAPI 
CFolder::BuildThreadProc (
    LPVOID lpParameter
)
/*++

Routine name : CFolder::BuildThreadProc

Routine description:

    Static thread entry point.

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    lpParameter   [in] - Pointer to the CFolder instance that created the thread.

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CFolder::BuildThreadProc"), dwRes);

    CFolder *pFolder = (CFolder *)lpParameter;
    ASSERT (pFolder);

    const CServerNode* pServer = pFolder->GetServer();
    if(NULL != pServer)
    {
        VERBOSE (DBG_MSG,
                TEXT ("Folder on server %s"), 
                pServer->Machine());
    }
    //
    // Call the refresh function for the right folder
    //
    dwRes = pFolder->Refresh ();
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("CFolder::Refresh"), dwRes);
        pFolder->InvalidateContents(TRUE);
        pFolder->m_bRefreshFailed = TRUE;
    }
    else
    {
        //
        // Refresh thread succeeded, there's a point in updating the view
        //
        pFolder->m_bValidList = TRUE;

        if (pFolder->m_pAssignedView)
        {
            //
            // Folder has a view attached
            //
            pFolder->m_pAssignedView->SendMessage (
                           WM_FOLDER_REFRESH_ENDED,
                           WPARAM (dwRes), 
                           LPARAM (pFolder));
        }
    }
    pFolder->EnterData ();
    //
    // Unlock the folder - notifications can now be processed
    //
    pFolder->m_bLocked = FALSE;
    pFolder->LeaveData ();
    pFolder->m_bRefreshing = FALSE;
        
    CMainFrame *pFrm = GetFrm();
    if (!pFrm)
    {
        //
        //  Shutdown in progress
        //
    }
    else
    {
        pFrm->RefreshStatusBar ();
    }

    //
    // That's it, return the result
    //
    return dwRes;
}   // CFolder::BuildThreadProc


int 
CFolder::GetActivityStringResource() const
/*++

Routine name : CFolder::GetActivityStringResource

Routine description:

	Returns the resource id of a string identifying the activity of the folder

Author:

	Eran Yariv (EranY),	Jan, 2000

Arguments:


Return Value:

    Activity string resource id

--*/
{
    if (m_bRefreshFailed)
    {
        //
        // Last refresh failed
        //
        return IDS_FOLDER_REFRESH_FAILED;
    }
    if (m_pAssignedView && m_pAssignedView->Sorting())
    {
        //
        // Folder has a view and the view is currently sorting    
        //
        return IDS_FOLDER_SORTING;
    }
    if (IsRefreshing())
    {
        //
        // Folder is busy building up its data
        //
        return IDS_FOLDER_REFRESHING;
    }
    //
    // Folder is doing nothing
    //
    return IDS_FOLDER_IDLE;
}   // CFolder::GetActivityStringResource

DWORD  
CFolder::OnJobRemoved (
    DWORDLONG dwlMsgId,
    CFaxMsg*  pMsg /* = NULL */
)
/*++

Routine name : CFolder::OnJobRemoved

Routine description:

	Handles notification of a message removed from the archive

Author:

	Eran Yariv (EranY),	Feb, 2000

Arguments:

	dwlMsgId   [in]     - Message unique id
    pMsg       [in]     - Optional pointer to message to remove (for optimization)

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CFolder::OnJobRemoved"), 
              dwRes, 
              TEXT("MsgId=0x%016I64x, Type=%d"), 
              dwlMsgId,
              Type());

    EnterData ();
    
    if (!pMsg)
    {
        //
        // No message pointer was supplied - search for it
        //
        pMsg = FindMessage (dwlMsgId);
    }
    if (!pMsg)
    {
        //
        // This message is already not in the archive
        //
        VERBOSE (DBG_MSG, TEXT("Message is already gone"));
        goto exit;
    }

    if (m_pAssignedView)
    {
        //
        // If this folder is alive - tell our view to remove the message
        //
       m_pAssignedView->OnUpdate (NULL, UPDATE_HINT_REMOVE_ITEM, pMsg);
    }

    //
    // Remove the message from the map
    //
    try
    {
        m_Msgs.erase (dwlMsgId);
    }
    catch (...)
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        CALL_FAIL (MEM_ERR, TEXT("map::erase"), dwRes);
        delete pMsg;
        goto exit;
    }
    //
    // Delete message 
    //
    delete pMsg;

    ASSERTION (ERROR_SUCCESS == dwRes);

exit:
    LeaveData ();
    return dwRes;

}   // CFolder::OnJobRemoved
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\faxtime.cpp ===
// FaxTime.cpp: implementation of the CFaxTime class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#define __FILE_ID__     9

CString 
CFaxDuration::FormatByUserLocale () const
/*++

Routine name : CFaxDuration::FormatByUserLocale

Routine description:

    Formats the duration according to the locale of the current user

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:


Return Value:

    String of result duration

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CFaxDuration::FormatByUserLocale"));

    TCHAR szTimeSep[20];    
    //
    // Make sure the duration is less than 24Hrs
    //
    if (GetDays ())
    {
        ASSERTION_FAILURE;
        AfxThrowUserException ();
    }
    //
    // Get the string (MSDN says its up to 4 characters) seperating time units
    //
    if (!GetLocaleInfo (LOCALE_USER_DEFAULT,
                        LOCALE_STIME,
                        szTimeSep,
                        sizeof (szTimeSep) / sizeof (szTimeSep[0])))
    {
        dwRes = GetLastError ();
        CALL_FAIL (RESOURCE_ERR, TEXT("GetLocaleInfo"), dwRes);
        PopupError (dwRes);
        AfxThrowResourceException ();
    }
    //                       
    // Create a string specifying the duration
    //
    CString cstrResult;
    cstrResult.Format (TEXT("%d%s%02d%s%02d"), 
                       GetHours (),
                       szTimeSep,
                       GetMinutes (),
                       szTimeSep,
                       GetSeconds ());
    return cstrResult;
}   // CFaxDuration::FormatByUserLocale


CString 
CFaxTime::FormatByUserLocale (BOOL bLocal) const
/*++

Routine name : CFaxTime::FormatByUserLocale

Routine description:

    Formats the date and time according to the locale of the current user

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

  bLocal   [in] - if TRUE no need to convert from UTC to a local time

Return Value:

    String of result date and time

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CFaxTime::FormatByUserLocale"));

    CString cstrRes;
    TCHAR szTimeBuf[40];
    TCHAR szDateBuf[120];

    SYSTEMTIME sysTime;
	FILETIME fileSysTime, fileLocalTime;

    if(!GetAsSystemTime (sysTime))
	{
        dwRes = GetLastError ();
        CALL_FAIL (RESOURCE_ERR, TEXT("CTime::GetAsSystemTime"), dwRes);
        PopupError (dwRes);
        AfxThrowResourceException ();
	}

    if(!bLocal)
    {
        //
	    // convert the time from UTC to a local time
	    //
	    if(!SystemTimeToFileTime(&sysTime, &fileSysTime))
	    {
            dwRes = GetLastError ();
            CALL_FAIL (RESOURCE_ERR, TEXT("SystemTimeToFileTime"), dwRes);
            PopupError (dwRes);
            AfxThrowResourceException ();
	    }

	    if(!FileTimeToLocalFileTime(&fileSysTime, &fileLocalTime))
	    {
            dwRes = GetLastError ();
            CALL_FAIL (RESOURCE_ERR, TEXT("FileTimeToLocalFileTime"), dwRes);
            PopupError (dwRes);
            AfxThrowResourceException ();
	    }

	    if(!FileTimeToSystemTime(&fileLocalTime, &sysTime))
	    {
            dwRes = GetLastError ();
            CALL_FAIL (RESOURCE_ERR, TEXT("FileTimeToSystemTime"), dwRes);
            PopupError (dwRes);
            AfxThrowResourceException ();
	    }
    }

    //
    // Create a string specifying the date
    //
    if (!GetY2KCompliantDate(LOCALE_USER_DEFAULT,                   // Get user's locale
                        DATE_SHORTDATE,                             // Short date format
                        &sysTime,                                   // Source date/time
                        szDateBuf,                                  // Output buffer
                        sizeof(szDateBuf) / sizeof(szDateBuf[0])    // Output buffer size
                       ))
    {
        dwRes = GetLastError ();
        CALL_FAIL (RESOURCE_ERR, TEXT("GetY2KCompliantDate()"), dwRes);
        PopupError (dwRes);
        AfxThrowResourceException ();
    }
    //
    // Create a string specifying the time
    //
    if (!FaxTimeFormat (LOCALE_USER_DEFAULT,                        // Get user's locale
                        0,                                          // No special format
                        &sysTime,                                   // Source date/time
                        NULL,                                       // Use format from locale
                        szTimeBuf,                                  // Output buffer
                        sizeof(szTimeBuf) / sizeof(szTimeBuf[0])    // Output buffer size
                       ))
    {
        dwRes = GetLastError ();
        CALL_FAIL (RESOURCE_ERR, TEXT("FaxTimeFormat"), dwRes);
        PopupError (dwRes);
        AfxThrowResourceException ();
    }
    //
    // Append time after date with a seperating space character
    //

    cstrRes.Format (TEXT("%s %s"), szDateBuf, szTimeBuf);

    return cstrRes;
}   // CFaxTime::FormatByUserLocale
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\faxmsg.h ===
// FaxMsg.h: interface for the CFaxMsg class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_FAXMSG_H__3B753848_4860_4DC5_AC1E_F3514CE4E839__INCLUDED_)
#define AFX_FAXMSG_H__3B753848_4860_4DC5_AC1E_F3514CE4E839__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//
// Enumeration of all job types:
//
typedef enum
{
    JOB_STAT_PENDING,
    JOB_STAT_INPROGRESS,
    JOB_STAT_DELETING,
    JOB_STAT_PAUSED,
    JOB_STAT_RETRYING,
    JOB_STAT_RETRIES_EXCEEDED,
    JOB_STAT_COMPLETED,
    JOB_STAT_CANCELED,
    JOB_STAT_CANCELING,
    JOB_STAT_ROUTING,
    JOB_STAT_ROUTING_RETRY,
    JOB_STAT_ROUTING_INPROGRESS,
    JOB_STAT_ROUTING_FAILED,
    NUM_JOB_STATUS
} JobStatusType;

class CFaxMsg : public CObject  
{
public:

    CFaxMsg() : 
        m_pServer(NULL),
        m_bValid (FALSE), 
        m_dwValidityMask(0),
        m_dwPossibleOperations(0)
        {}
    virtual ~CFaxMsg() {}


    CServerNode* GetServer() const
        { ASSERT (m_bValid);  return m_pServer; }

    //
    // Operation query:
    //
    DWORD GetPossibleOperations () const
        { ASSERT (m_bValid); return m_dwPossibleOperations; }

    const DWORD GetValidityMask() const
        { ASSERT (m_bValid); return m_dwValidityMask; }

    //
    // Item retrival:
    //
    const DWORDLONG GetId () const              
        { ASSERT (m_bValid); return m_dwlMessageId; }

    const DWORDLONG GetBroadcastId () const              
        { ASSERT (m_bValid); return m_dwlBroadcastId; }
    
    const CString &GetServerName () const 
        { ASSERT (m_bValid); return m_cstrServerName; }

    const DWORD GetExtendedStatus () const   
        { ASSERT (m_bValid); return m_dwExtendedStatus; }

    const CString &GetCSID () const            
        { ASSERT (m_bValid); return m_cstrCsid; }

    const CString &GetTSID () const            
        { ASSERT (m_bValid); return m_cstrTsid; }

    const DWORD GetSize () const            
        { ASSERT (m_bValid); return m_dwSize; }

    const CString &GetDevice () const          
        { ASSERT (m_bValid); return m_cstrDeviceName; }

    const DWORD GetRetries () const         
        { ASSERT (m_bValid); return m_dwRetries; }

    const CString &GetCallerId () const        
        { ASSERT (m_bValid); return m_cstrCallerID; }

    const CString &GetRoutingInfo () const     
        { ASSERT (m_bValid); return m_cstrRoutingInfo; }

    const CString &GetDocName () const         
        { ASSERT (m_bValid); return m_cstrDocumentName; }

    const CString &GetSubject () const         
        { ASSERT (m_bValid); return m_cstrSubject; }

    const CString &GetRecipientName () const   
        { ASSERT (m_bValid); return m_cstrRecipientName; }

    const CString &GetRecipientNumber () const 
        { ASSERT (m_bValid); return m_cstrRecipientNumber; }

    const CString &GetUser () const 
        { ASSERT (m_bValid); return m_cstrSenderUserName; }

    const CString &GetBilling () const 
        { ASSERT (m_bValid); return m_cstrBillingCode; }

    const DWORD GetType () const
        { ASSERT (m_bValid); return m_dwJobType; }

    const CFaxTime &GetOrigTime () const        
        { ASSERT (m_bValid); return m_tmOriginalScheduleTime;}

    const CFaxTime &GetSubmissionTime () const      
        { ASSERT (m_bValid); return m_tmSubmissionTime; }

    const CFaxTime &GetTransmissionStartTime () const
        { ASSERT (m_bValid); return m_tmTransmissionStartTime; }

    const CFaxTime &GetTransmissionEndTime () const
        { ASSERT(m_bValid); return m_tmTransmissionEndTime;}

    const DWORD GetNumPages () const        
        { ASSERT (m_bValid); return m_dwPageCount; }

    const FAX_ENUM_PRIORITY_TYPE GetPriority () const        
        { ASSERT (m_bValid); return m_Priority; }

    virtual DWORD GetTiff (CString &cstrTiffLocation) const=0;
    virtual DWORD Delete ()=0;

    //
    // Message specific
    //
    virtual const CString &GetSenderName () const
        { ASSERT(FALSE); return *((CString*)NULL);}

    virtual const CString &GetSenderNumber () const
        { ASSERT(FALSE); return *((CString*)NULL);}

    virtual const CFaxDuration &GetTransmissionDuration () const
        { ASSERT(FALSE); return *((CFaxDuration*)NULL);}


    //
    // Job specific
    //
    virtual DWORD Pause  ()
        { ASSERT(FALSE); return 0;}

    virtual DWORD Resume ()
        { ASSERT(FALSE); return 0;}

    virtual DWORD Restart()
        { ASSERT(FALSE); return 0;}

    virtual const JobStatusType GetStatus() const
        { ASSERT(FALSE); return JOB_STAT_COMPLETED;}

    virtual const CString &GetExtendedStatusString() const
        { ASSERT(FALSE); return *((CString*)NULL);}

    virtual const DWORD GetCurrentPage () const
        { ASSERT(FALSE); return 0;}

    virtual const CFaxTime &GetScheduleTime () const
        { ASSERT(FALSE); return *((CFaxTime*)NULL);}

protected:

    CServerNode* m_pServer;

    BOOL       m_bValid;

    DWORDLONG  m_dwlMessageId;
    DWORDLONG  m_dwlBroadcastId;

    DWORD      m_dwPossibleOperations;
    DWORD      m_dwValidityMask;
    DWORD      m_dwJobOnlyValidityMask; // Validity mask (not status)
    DWORD      m_dwJobID;
    DWORD      m_dwJobType;
    DWORD      m_dwQueueStatus;
    DWORD      m_dwExtendedStatus;
    DWORD      m_dwSize;
    DWORD      m_dwPageCount;
    DWORD      m_dwDeviceID;
    DWORD      m_dwRetries;

    CString    m_cstrRecipientNumber;
    CString    m_cstrRecipientName;
    CString    m_cstrSenderUserName;
    CString    m_cstrBillingCode;
    CString    m_cstrDocumentName;
    CString    m_cstrSubject;
    CString    m_cstrTsid;
    CString    m_cstrCsid;
    CString    m_cstrDeviceName;
    CString    m_cstrCallerID;
    CString    m_cstrRoutingInfo;
    CString    m_cstrServerName;

    CFaxTime   m_tmOriginalScheduleTime;
    CFaxTime   m_tmSubmissionTime;
    CFaxTime   m_tmTransmissionStartTime; 
    CFaxTime   m_tmTransmissionEndTime; 

    FAX_ENUM_PRIORITY_TYPE  m_Priority;
};

#endif // !defined(AFX_FAXMSG_H__3B753848_4860_4DC5_AC1E_F3514CE4E839__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\folderdialog.cpp ===
// FolderDialog.cpp: implementation of the CFolderDialog class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#define __FILE_ID__     70

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern CClientConsoleApp theApp;

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

DWORD 
CFolderDialog::Init(
    LPCTSTR tszInitialDir, // = NULL
    UINT nTitleResId       // = 0
)
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CFolderDialog::Init"), dwRes);

    //
    // copy an initial folder name
    //
    DWORD dwLen;
    if(NULL != tszInitialDir && (dwLen = _tcslen(tszInitialDir)) > 0)
    {
        ASSERTION(dwLen < MAX_PATH);
        _tcscpy(m_tszInitialDir, tszInitialDir);
    }

    //
    // load a title resource string
    //
    if(0 != nTitleResId)
    {
        dwRes = LoadResourceString (m_cstrTitle, nTitleResId);
        if(ERROR_SUCCESS != dwRes)
        {
            CALL_FAIL (RESOURCE_ERR, TEXT ("LoadResourceString"), dwRes);
            return dwRes;
        }
    }

    return dwRes;

} // CFolderDialog::Init

int 
CALLBACK
CFolderDialog::BrowseCallbackProc(
    HWND hwnd,
    UINT uMsg,
    LPARAM lp, 
    LPARAM pData
) 
{
    DBG_ENTER(TEXT("CFolderDialog::BrowseCallbackProc"));

    CFolderDialog* pFolderDlg = (CFolderDialog*)pData;
    ASSERTION(pFolderDlg);

    switch (uMsg)
    {
        case BFFM_SELCHANGED:
        {
            BOOL bFolderIsOK = FALSE;
            TCHAR szPath [MAX_PATH + 1];

            if (SHGetPathFromIDList ((LPITEMIDLIST) lp, szPath)) 
            {
                DWORD dwFileAttr = GetFileAttributes(szPath);
                if (-1 != dwFileAttr && (dwFileAttr & FILE_ATTRIBUTE_DIRECTORY))
                {
                    //
                    // The directory exists - enable the 'Ok' button
                    //
                    bFolderIsOK = TRUE;
                }
            }
            //
            // Enable / disable the 'ok' button
            //
            SendMessage(hwnd, BFFM_ENABLEOK , 0, (LPARAM)bFolderIsOK);
            break;
        }

        case BFFM_INITIALIZED:
            if(_tcslen(pFolderDlg->m_tszInitialDir) > 0) 
            {
                //
                // WParam is TRUE since you are passing a path.
                // It would be FALSE if you were passing a pidl.
                //
                SendMessage(hwnd, BFFM_SETSELECTION, TRUE, (LPARAM)pFolderDlg->m_tszInitialDir);
            }
            break;

        case BFFM_VALIDATEFAILED:
            //
            // The folder name is invalid.
            // Do not close the dialog.
            //
            MessageBeep(MB_OK);
            return 1;
    }
    return 0;
} // CFolderDialog::BrowseCallbackProc


UINT 
CFolderDialog::DoModal(
    DWORD dwFlags /* =0 */)
{
    DBG_ENTER(TEXT("CFolderDialog::DoModal"));

    BROWSEINFO browseInfo = {0};
    browseInfo.hwndOwner  = theApp.m_pMainWnd->m_hWnd;
    browseInfo.pidlRoot   = NULL;
    browseInfo.pszDisplayName = 0;
    browseInfo.lpszTitle  = (m_cstrTitle.GetLength() != 0) ? (LPCTSTR)m_cstrTitle : NULL;
    browseInfo.ulFlags    = dwFlags | BIF_RETURNONLYFSDIRS | BIF_RETURNFSANCESTORS | BIF_USENEWUI | BIF_VALIDATE;
    browseInfo.lpfn       = BrowseCallbackProc;
    browseInfo.lParam     = (LPARAM)this;

    //
    // Need OLE for a new style of the BrowseForFolder dialog
    //
    OleInitialize(NULL);
    LPITEMIDLIST pItemIdList = ::SHBrowseForFolder(&browseInfo);

    if(NULL == pItemIdList)
    {
        //
        // Cancel
        //
        OleUninitialize();
        return IDCANCEL;
    }

    OleUninitialize();
    //
    // get path from pItemIdList
    //
    if(!SHGetPathFromIDList(pItemIdList, (TCHAR*)&m_tszSelectedDir))
    {
        m_dwLastError = ERROR_CAN_NOT_COMPLETE;
        CALL_FAIL (GENERAL_ERR, TEXT("SHGetPathFromIDList"), m_dwLastError);
        return IDABORT;
    }
     //
    // free pItemIdList
    //
    LPMALLOC pMalloc;
    HRESULT hRes = SHGetMalloc(&pMalloc);
    if(E_FAIL == hRes)
    {
        m_dwLastError = ERROR_CAN_NOT_COMPLETE;
        CALL_FAIL (GENERAL_ERR, TEXT("SHGetMalloc"), m_dwLastError);
        return IDABORT;
    }

    pMalloc->Free(pItemIdList);
    pMalloc->Release();

    return IDOK;

} // CFolderDialog::DoModal
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\folder.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    Folder.h

Abstract:

    Interface for the CFolder class.
    This abstract class is the base class for all 4 types of folders.

    It manages it's own view internally.

Author:

    Eran Yariv (EranY)  Dec, 1999

Revision History:

--*/

#if !defined(AFX_FOLDER_H__80DEDFB5_FF48_41BC_95DC_04A4060CF5FD__INCLUDED_)
#define AFX_FOLDER_H__80DEDFB5_FF48_41BC_95DC_04A4060CF5FD__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

typedef map<DWORDLONG, CFaxMsg*> MSGS_MAP;

class CFolder : public CTreeNode  
{
public:
    CFolder(FolderType type) :
        CTreeNode (type),
        m_pAssignedView(NULL),
        m_bVisible(FALSE),
        m_pServer (NULL),
        m_bValidList (FALSE),
        m_hBuildThread (NULL),
        m_bCsDataInitialized (FALSE),
        m_bRefreshFailed (FALSE),
        m_bRefreshing(FALSE),
        m_bLocked (FALSE)
    {
        DBG_ENTER (TEXT("CFolder::CFolder"));
    }

    virtual ~CFolder();

    DECLARE_DYNAMIC(CFolder)

    virtual DWORD Init ();

	void AttachView();
    CFolderListView* GetView() const  { return m_pAssignedView; }

    void SetVisible ();
    void SetInvalid() { m_bValidList = FALSE; }
    BOOL IsValid() { return m_bValidList; }

    void  SetServer (CServerNode *pServer) ;
    const CServerNode* GetServer () const   { return m_pServer; }

    virtual void AssertValid( ) const;

    DWORD   InvalidateContents (BOOL bClearView);
    DWORD   RebuildContents ();

    MSGS_MAP &GetData ()     { return m_Msgs; }

    DWORD GetDataCount ()
        { 
            EnterData();
            int iSize = m_Msgs.size();
            LeaveData();
            return iSize;
        }

    CFaxMsg* FindMessage (DWORDLONG dwlMsgId);

    void    EnterData()
        { 
            if(!m_bCsDataInitialized)
            {
                ASSERT (FALSE); 
                return;
            }
            EnterCriticalSection (&m_CsData); 
        }

    void    LeaveData()
        { 
            if(!m_bCsDataInitialized)
            {
                ASSERT (FALSE); 
                return;
            }
            LeaveCriticalSection (&m_CsData); 
        }

    BOOL IsRefreshing () const  { return m_bRefreshing; }

    DWORD OnJobRemoved (DWORDLONG dwlMsgId, CFaxMsg* pMsg = NULL);
    virtual DWORD OnJobAdded (DWORDLONG dwlMsgId) = 0;
    virtual DWORD OnJobUpdated (DWORDLONG dwlMsgId, PFAX_JOB_STATUS pNewStatus) = 0;

    int GetActivityStringResource() const;

    BOOL Locked()       { return m_bLocked; }

    DWORD  StopBuildThread (BOOL bWaitForDeath = TRUE);

protected:

    MSGS_MAP  m_Msgs;     // Map of message id to CFaxMsg pointer.
 
    CFolderListView* m_pAssignedView; // Points to the view assigned to this node.
    BOOL             m_bVisible;      // Is this node currently visible?

    CServerNode     *m_pServer;         // Points to the server's node
    BOOL             m_bStopRefresh;    // Should we abort the refresh operation?
    BOOL             m_bValidList;      // Is the list of jobs / message valid?

    virtual DWORD Refresh () = 0;

    void PreDestruct ();    // Call on sons dtor

private:

    HANDLE           m_hBuildThread;    // Handle of background contents building thread
    BOOL             m_bCsDataInitialized; // Did we init the m_CsData member?
    CRITICAL_SECTION m_CsData;          // Critical section to protect the data

    static DWORD WINAPI BuildThreadProc (LPVOID lpParameter);

    BOOL  m_bRefreshFailed;  // Was the refresh a failure?
    BOOL  m_bRefreshing;    
    BOOL  m_bLocked;         // If TRUE, do not process server notifications
};

#endif // !defined(AFX_FOLDER_H__80DEDFB5_FF48_41BC_95DC_04A4060CF5FD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\folderdialog.h ===
// FolderDialog.h: interface for the CFolderDialog class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_FOLDERDIALOG_H__7C3137EF_7248_477F_ABEA_85F33AB2E0EF__INCLUDED_)
#define AFX_FOLDERDIALOG_H__7C3137EF_7248_477F_ABEA_85F33AB2E0EF__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CFolderDialog  
{
public:
	CFolderDialog() : 
		m_dwLastError(ERROR_SUCCESS)
		{
            m_tszInitialDir[0] = TEXT('\0');
            m_tszSelectedDir[0] = TEXT('\0');
		}

	virtual ~CFolderDialog() {}

	DWORD Init(LPCTSTR tszInitialDir=NULL, UINT nTitleResId=0);
	UINT DoModal(DWORD dwFlags = 0);

	TCHAR* GetSelectedFolder() {return m_tszSelectedDir; } 
	DWORD  GetLastError() { return m_dwLastError; }

private:
	TCHAR   m_tszInitialDir[MAX_PATH+1];
	TCHAR   m_tszSelectedDir[MAX_PATH+1];
	CString m_cstrTitle;
	DWORD   m_dwLastError;

	static int CALLBACK BrowseCallbackProc(HWND hwnd, UINT uMsg, LPARAM lp, LPARAM pData);
};

#endif // !defined(AFX_FOLDERDIALOG_H__7C3137EF_7248_477F_ABEA_85F33AB2E0EF__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\inboxdetailspg.cpp ===
// InboxDetailsPg.cpp : implementation file
//

#include "stdafx.h"

#define __FILE_ID__     50

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// this array maps CViewRow items to 
// dialog control IDs
//
static TMsgPageInfo s_PageInfo[] = 
{
    MSG_VIEW_ITEM_CSID,                     IDC_CSID_VALUE,
    MSG_VIEW_ITEM_TSID,                     IDC_TSID_VALUE,
    MSG_VIEW_ITEM_DEVICE,                   IDC_DEVICE_VALUE,
    MSG_VIEW_ITEM_ID,                       IDC_JOB_ID_VALUE,
    MSG_VIEW_ITEM_CALLER_ID,                IDC_CALLER_ID_VALUE,
    MSG_VIEW_ITEM_ROUTING_INFO,             IDC_ROUTING_INFO_VALUE
};

/////////////////////////////////////////////////////////////////////////////
// CInboxDetailsPg property page

IMPLEMENT_DYNCREATE(CInboxDetailsPg, CMsgPropertyPg)

CInboxDetailsPg::CInboxDetailsPg(
    CFaxMsg* pMsg     // pointer to CArchiveMsg
): 
    CMsgPropertyPg(CInboxDetailsPg::IDD, pMsg)
{
}

CInboxDetailsPg::~CInboxDetailsPg()
{
}

void CInboxDetailsPg::DoDataExchange(CDataExchange* pDX)
{
	CMsgPropertyPg::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CInboxDetailsPg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CInboxDetailsPg, CMsgPropertyPg)
	//{{AFX_MESSAGE_MAP(CInboxDetailsPg)
	//}}AFX_MESSAGE_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CInboxDetailsPg message handlers

BOOL 
CInboxDetailsPg::OnInitDialog() 
{
    DBG_ENTER(TEXT("CInboxDetailsPg::OnInitDialog"));

    CMsgPropertyPg::OnInitDialog();

    Refresh(s_PageInfo, sizeof(s_PageInfo)/sizeof(s_PageInfo[0]));
	
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\folderlistview.cpp ===
// FolderListView.cpp : implementation file
//

#include "stdafx.h"
#define __FILE_ID__     22

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include <dlgprnt2.cpp>

extern CClientConsoleApp theApp;

//
// MAX_ITEMS_TO_DELETE_WITH_REFRESH defines the maximal number of items we can delete 
// and keep the view in auto-refresh mode.
// If we delete more items, we need to SetRefresh(FALSE), delete-all, SetRefresh(TRUE) + Invalidate
// for better performance.
//
#define MAX_ITEMS_TO_DELETE_WITH_REFRESH        3

//
// Static members:
//
CFolderListView * CFolderListView::m_psCurrentViewBeingSorted = NULL;
CImageList CFolderListView::m_sImgListDocIcon;
CImageList CFolderListView::m_sReportIcons; 

/////////////////////////////////////////////////////////////////////////////
// CFolderListView

IMPLEMENT_DYNCREATE(CFolderListView, CListView)


BEGIN_MESSAGE_MAP(CFolderListView, CListView)
    //{{AFX_MSG_MAP(CFolderListView)
    ON_NOTIFY_REFLECT(LVN_COLUMNCLICK,   OnColumnClick)
    ON_WM_SETCURSOR()
    ON_MESSAGE (WM_FOLDER_REFRESH_ENDED, OnFolderRefreshEnded)
    ON_MESSAGE (WM_FOLDER_ADD_CHUNK,     OnFolderAddChunk)
    ON_NOTIFY_REFLECT(NM_RCLICK,         OnItemRightClick)
    ON_WM_CONTEXTMENU()
    ON_NOTIFY_REFLECT(LVN_ITEMCHANGED,   OnItemChanged)
    ON_WM_SETCURSOR()
    ON_WM_CHAR()
    //}}AFX_MSG_MAP
    ON_UPDATE_COMMAND_UI(ID_SELECT_ALL,             OnUpdateSelectAll)    
    ON_UPDATE_COMMAND_UI(ID_SELECT_NONE,            OnUpdateSelectNone)    
    ON_UPDATE_COMMAND_UI(ID_SELECT_INVERT,          OnUpdateSelectInvert)  
    ON_UPDATE_COMMAND_UI(ID_FOLDER_ITEM_VIEW,       OnUpdateFolderItemView)
    ON_UPDATE_COMMAND_UI(ID_FOLDER_ITEM_PRINT,      OnUpdateFolderItemPrint)
    ON_UPDATE_COMMAND_UI(ID_FOLDER_ITEM_COPY,       OnUpdateFolderItemCopy)      
    ON_UPDATE_COMMAND_UI(ID_FOLDER_ITEM_MAIL_TO,    OnUpdateFolderItemSendMail)   
    ON_UPDATE_COMMAND_UI(ID_FOLDER_ITEM_PROPERTIES, OnUpdateFolderItemProperties)
    ON_UPDATE_COMMAND_UI(ID_FOLDER_ITEM_DELETE,     OnUpdateFolderItemDelete)    
    ON_UPDATE_COMMAND_UI(ID_FOLDER_ITEM_PAUSE,      OnUpdateFolderItemPause)     
    ON_UPDATE_COMMAND_UI(ID_FOLDER_ITEM_RESUME,     OnUpdateFolderItemResume)    
    ON_UPDATE_COMMAND_UI(ID_FOLDER_ITEM_RESTART,    OnUpdateFolderItemRestart)   
    ON_COMMAND(ID_SELECT_ALL,             OnSelectAll)
    ON_COMMAND(ID_SELECT_NONE,            OnSelectNone)
    ON_COMMAND(ID_SELECT_INVERT,          OnSelectInvert)
    ON_COMMAND(ID_FOLDER_ITEM_VIEW,       OnFolderItemView)
    ON_COMMAND(ID_FOLDER_ITEM_PRINT,      OnFolderItemPrint)
    ON_COMMAND(ID_FOLDER_ITEM_COPY,       OnFolderItemCopy)
    ON_COMMAND(ID_FOLDER_ITEM_MAIL_TO,    OnFolderItemMail)
    ON_COMMAND(ID_FOLDER_ITEM_PRINT,      OnFolderItemPrint)
    ON_COMMAND(ID_FOLDER_ITEM_PROPERTIES, OnFolderItemProperties)
    ON_COMMAND(ID_FOLDER_ITEM_DELETE,     OnFolderItemDelete)
    ON_COMMAND(ID_FOLDER_ITEM_PAUSE,      OnFolderItemPause)
    ON_COMMAND(ID_FOLDER_ITEM_RESUME,     OnFolderItemResume)
    ON_COMMAND(ID_FOLDER_ITEM_RESTART,    OnFolderItemRestart)
    ON_NOTIFY_REFLECT(NM_DBLCLK,          OnDblClk)
END_MESSAGE_MAP()

BOOL CFolderListView::PreCreateWindow(CREATESTRUCT& cs)
{
    return CListView::PreCreateWindow(cs);
}

BOOL 
CFolderListView::OnSetCursor(
    CWnd* pWnd, 
    UINT nHitTest, 
    UINT message
)
{
    if (m_bInMultiItemsOperation || m_bSorting)
    {
        ::SetCursor(AfxGetApp()->LoadStandardCursor(IDC_WAIT));
        return TRUE;
    }

    CClientConsoleDoc* pDoc = GetDocument();
    if (pDoc && pDoc->IsFolderRefreshing(m_Type))
    {
        ::SetCursor(AfxGetApp()->LoadStandardCursor(IDC_APPSTARTING));
        return TRUE;
    }
    else        
    {
        return CView::OnSetCursor(pWnd, nHitTest, message);
    }       
}   // CFolderListView::OnSetCursor


BOOL 
CFolderListView::IsSelected (
    int iItem
)
/*++

Routine name : CFolderListView::IsSelected

Routine description:

    Checks if an item is selected in the list

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    iItem                         [in]     - Item index

Return Value:

    TRUE if item is selected in the list, FALSE otherwise.

--*/
{
    BOOL bRes = FALSE;
    DBG_ENTER(TEXT("CFolderListView::IsSelected"), bRes);

    CListCtrl &refCtrl = GetListCtrl();
    ASSERTION (refCtrl.GetItemCount() > iItem);

    DWORD dwState = refCtrl.GetItemState (iItem , LVIS_SELECTED);
    if (LVIS_SELECTED & dwState)
    {
        bRes = TRUE;
    }
    return bRes;
}

void 
CFolderListView::Select (
    int iItem, 
    BOOL bSelect
)
/*++

Routine name : CFolderListView::Select

Routine description:

    Selects / unselects an item in the list

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    iItem                         [in]     - Item index
    bSelect                       [in]     - TRUE if select, FALSE unselect

Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CFolderListView::Select"), TEXT("%d"), bSelect);

    CListCtrl &refCtrl = GetListCtrl();
    ASSERTION (refCtrl.GetItemCount() > iItem);

    refCtrl.SetItemState (iItem, 
                          bSelect ? (LVIS_SELECTED | LVIS_FOCUSED) : 0,
                          LVIS_SELECTED | LVIS_FOCUSED);
}

void 
CFolderListView::OnSelectAll ()
/*++

Routine name : CFolderListView::OnSelectAll

Routine description:

    Select all list items

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:


Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CFolderListView::OnSelectAll"),
              TEXT("Type=%d"),
              m_Type);
    LV_ITEM lvItem;

    CListCtrl &refCtrl = GetListCtrl();
    ASSERTION (refCtrl.GetItemCount() > refCtrl.GetSelectedCount());

    lvItem.mask     = LVIF_STATE;
    lvItem.iItem    = -1;   // Specifies "All items"
    lvItem.iSubItem = 0;
    lvItem.state    = LVIS_SELECTED;
    lvItem.stateMask= LVIS_SELECTED;
    refCtrl.SetItemState(-1, &lvItem);
}   // CFolderListView::OnSelectAll

void 
CFolderListView::OnSelectNone ()
/*++

Routine name : CFolderListView::OnSelectNone

Routine description:

    Unselect all list items

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:


Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CFolderListView::OnSelectNone"),
              TEXT("Type=%d"),
              m_Type);

    LV_ITEM lvItem;

    CListCtrl &refCtrl = GetListCtrl();
    lvItem.mask     = LVIF_STATE;
    lvItem.iItem    = -1;   // Specifies "All items"
    lvItem.iSubItem = 0;
    lvItem.state    = 0;
    lvItem.stateMask= LVIS_SELECTED;
    refCtrl.SetItemState(-1, &lvItem);
}   // CFolderListView::OnSelectNone

void 
CFolderListView::OnSelectInvert ()
/*++

Routine name : CFolderListView::OnSelectInvert

Routine description:

    Invert list items selection

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:


Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CFolderListView::OnSelectInvert"),
              TEXT("Type=%d"),
              m_Type);

    CListCtrl &refCtrl = GetListCtrl();
    DWORD dwItemsCount = refCtrl.GetItemCount();

    for (DWORD dw = 0; dw < dwItemsCount; dw++)
    {
        Select (dw, !IsSelected (dw));
    }
}   // CFolderListView::OnSelectInvert


void CFolderListView::OnDraw(CDC* pDC)
{
    CListView::OnDraw (pDC);
}

void CFolderListView::OnInitialUpdate()
{
    //
    // Refresh the image list (only if they are empty)
    //
    RefreshImageLists(FALSE);
    CListView::OnInitialUpdate();
}

/////////////////////////////////////////////////////////////////////////////
// CFolderListView diagnostics

#ifdef _DEBUG
void CFolderListView::AssertValid() const
{
    CListView::AssertValid();
}

void CFolderListView::Dump(CDumpContext& dc) const
{
    CListView::Dump(dc);
}

CClientConsoleDoc* CFolderListView::GetDocument() // non-debug version is inline
{
    ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CClientConsoleDoc)));
    return (CClientConsoleDoc*)m_pDocument;
}

#endif //_DEBUG



/////////////////////////////////////////////////////////////////////////////
// CFolderListView message handlers

DWORD 
CFolderListView::InitColumns (
    int   *pColumnsUsed,
    DWORD dwDefaultColNum
)
/*++

Routine name : CFolderListView::InitColumns

Routine description:

    Inits the columns of the view.

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    pColumnsUsed    [in] - Pointer to the list of ids to place in the columns.
                          Must be a statically allocated list.
    dwDefaultColNum [in] - default column number

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CFolderListView::InitColumns"), dwRes);

    if (m_bColumnsInitialized)
    {
        return dwRes;
    }

    m_dwDefaultColNum = dwDefaultColNum;

    //
    // Count the number of columns provided
    //
    CountColumns (pColumnsUsed);

    int nItemIndex, nRes;
    CString cstrColumnText;
    DWORD dwCount = GetLogicalColumnsCount();   
    for (DWORD dw = 0; dw < dwCount; ++dw)
    {        
        nItemIndex = ItemIndexFromLogicalColumnIndex(dw);

        if(IsItemIcon(nItemIndex))
        {
            //
            // Init icon column - insert an empty string
            //
            nRes = GetListCtrl().InsertColumn (dw, TEXT(""), LVCFMT_LEFT);
            if (nRes < 0)
            {
                dwRes = ERROR_GEN_FAILURE;
                CALL_FAIL (WINDOW_ERR, TEXT("CListCtrl::InsertColumn"), dwRes);
                return dwRes;
            }
            //
            // Set the header control's bitmap
            //
            CHeaderCtrl *pHeader = GetListCtrl().GetHeaderCtrl();
            HDITEM hdItem;
            hdItem.mask = HDI_IMAGE | HDI_FORMAT;
            hdItem.fmt = HDF_LEFT | HDF_IMAGE;
            hdItem.iImage = 0;  // Use first (and only) image from image list
            if (!pHeader->SetItem (dw, &hdItem))
            {
                dwRes = ERROR_GEN_FAILURE;
                CALL_FAIL (WINDOW_ERR, TEXT("CHeaderCtrl::SetItem"), dwRes);
                return dwRes;
            }
        }
        else
        {
            //
            // init string column
            //
            dwRes = GetColumnHeaderString (cstrColumnText, nItemIndex);
            if (ERROR_SUCCESS != dwRes)
            { return dwRes; }
            nRes = GetListCtrl().InsertColumn (dw, 
                                               cstrColumnText,
                                               GetColumnHeaderAlignment (nItemIndex));
        }

        if (nRes < 0)
        {
            dwRes = ERROR_GEN_FAILURE;
            CALL_FAIL (WINDOW_ERR, TEXT("CListCtrl::InsertColumn"), dwRes);
            return dwRes;
        }
    }        

    m_bColumnsInitialized = TRUE;
    return dwRes;

}   // CFolderListView::InitColumns

void
CFolderListView::AutoFitColumns ()
/*++

Routine name : CFolderListView::AutoFitColumns

Routine description:

    Sets the column width to fit the contents of the column and the header

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:


Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CFolderListView::AutoFitColumns"));

    CHeaderCtrl *pHeader = GetListCtrl().GetHeaderCtrl ();
    ASSERTION (pHeader);
    DWORD dwCount = pHeader->GetItemCount();
    for (DWORD dwCol = 0; dwCol <= dwCount; dwCol++) 
    {
        GetListCtrl().SetColumnWidth (dwCol, LVSCW_AUTOSIZE);
        int wc1 = GetListCtrl().GetColumnWidth (dwCol);
        GetListCtrl().SetColumnWidth (dwCol, LVSCW_AUTOSIZE_USEHEADER);
        int wc2 = GetListCtrl().GetColumnWidth (dwCol);
        int wc = max(20,max(wc1,wc2));
        GetListCtrl().SetColumnWidth (dwCol, wc);
    }
}   // CFolderListView::AutoFitColumns

DWORD 
CFolderListView::UpdateLineTextAndIcon (
    DWORD dwLineIndex,
    CViewRow &row    
)
/*++

Routine name : CFolderListView::UpdateLineTextAndIcon

Routine description:

    Updates the icon and text in each column of a line item in the list

Author:

    Eran Yariv (EranY), Feb, 2000

Arguments:

    dwLineIndex        [in]     - Line index
    row                [in]     - Display information

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CFolderListView::UpdateLineTextAndIcon"), dwRes);

    //
    // Start by setting the icon
    //
    LVITEM lvItem = {0};
    lvItem.mask = LVIF_IMAGE;
    lvItem.iItem = dwLineIndex;
    lvItem.iSubItem = 0;
    lvItem.state = 0;
    lvItem.stateMask = 0;
    lvItem.pszText = NULL;
    lvItem.cchTextMax = 0;
    lvItem.lParam = NULL;
    lvItem.iImage = row.GetIcon();
    lvItem.iIndent = 0;
    CListCtrl &refCtrl = GetListCtrl();
    if (!refCtrl.SetItem (&lvItem))
    {
        dwRes = ERROR_GEN_FAILURE;
        CALL_FAIL (WINDOW_ERR, TEXT("CListCtrl::SetItem"), dwRes);
        return dwRes;
    }
    //
    // Set columns text
    //
    DWORD dwItemIndex;
    DWORD dwCount = GetLogicalColumnsCount();
    for (DWORD dwCol = 0; dwCol < dwCount; ++dwCol)
    {
        dwItemIndex = ItemIndexFromLogicalColumnIndex (dwCol);
        if(IsItemIcon(dwItemIndex))
        { 
            continue; 
        }
        //
        // Get text from column 
        //
        const CString &cstrColumn = row.GetItemString (dwItemIndex);

        //
        // Set the text in the control
        //
        if (!refCtrl.SetItemText (dwLineIndex, dwCol, cstrColumn))
        {
            dwRes = ERROR_GEN_FAILURE;
            CALL_FAIL (WINDOW_ERR, TEXT("ListCtrl::SetItemText"), dwRes);
            return dwRes;
        }
    }
    ASSERTION (ERROR_SUCCESS == dwRes);
    return dwRes;   
}   // CFolderListView::UpdateLineTextAndIcon

DWORD 
CFolderListView::AddItem (
    DWORD dwLineIndex,
    CViewRow &row,
    LPARAM lparamItemData,
    PINT pintItemIndex
)
/*++

Routine name : CFolderListView::AddItem

Routine description:

    Adds an item to the list

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    dwLineIndex     [in]  - Index of addition
    row             [in]  - Row of item view information
    lparamItemData  [in]  - Item associated data
    pintItemIndex   [out] - Item index in the list

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CFolderListView::AddItem"), dwRes, TEXT("%ld"), dwLineIndex);
    //
    // Insert the item: only state, indention and lParam are set.
    //
    LVITEM lvItem = {0};
    lvItem.mask = LVIF_PARAM | LVIF_STATE | LVIF_INDENT;
    lvItem.iItem = dwLineIndex;
    lvItem.iSubItem = 0;
    lvItem.state = 0;
    lvItem.stateMask = 0;
    lvItem.pszText = NULL;
    lvItem.cchTextMax = 0;
    lvItem.lParam = lparamItemData;
    lvItem.iImage = 0;
    lvItem.iIndent = 0;

    *pintItemIndex = ListView_InsertItem (GetListCtrl().m_hWnd, &lvItem);
    if (-1 == *pintItemIndex)
    {
        dwRes = ERROR_GEN_FAILURE;
        CALL_FAIL (WINDOW_ERR, TEXT("CListCtrl::InsertItem"), dwRes);
        return dwRes;
    }
    dwRes = UpdateLineTextAndIcon (*pintItemIndex, row);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("UpdateLineTextAndIcon"), dwRes);
        return dwRes;
    }
    ASSERTION (ERROR_SUCCESS == dwRes);
    return dwRes;
}   // CFolderListView::AddItem


LRESULT 
CFolderListView::OnFolderAddChunk(
    WPARAM wParam,  // Error code
    LPARAM lParam   // MSGS_MAP pointer 
)
/*++

Routine name : CFolderListView::OnFolderAddChunk

Routine description:

    Called when a background folder thread brings a chunk of messages

Arguments:

    wParam         [in] - Thread error code
    lParam         [in] - Pointer to MSGS_MAP.

Return Value:

    Standard result code

--*/
{
    DBG_ENTER(TEXT("CFolderListView::OnFolderAddChunk"));
    DWORD dwRes = (DWORD) wParam;    
    CObject* pObj = (CObject*)lParam;

    if (ERROR_SUCCESS == dwRes)
    {
        OnUpdate (NULL, UPDATE_HINT_ADD_CHUNK, pObj); 
    }
    else
    {
        PopupError (dwRes);
    }
    return 0;
}

LRESULT 
CFolderListView::OnFolderRefreshEnded (
    WPARAM wParam,  // Error code
    LPARAM lParam   // CFolder pointer 
)
/*++

Routine name : CFolderListView::OnFolderRefreshEnded

Routine description:

    Called when a background folder thread finishes its work.

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    wParam         [in] - Thread error code
    lParam         [in] - Pointer to CFolder that started the thread.

Return Value:

    Standard result code

--*/
{ 
    DBG_ENTER(TEXT("CFolderListView::OnFolderRefreshEnded"));
    DWORD dwRes = (DWORD) wParam;
    CFolder *pFolder = (CFolder *) lParam;

    if (ERROR_SUCCESS == dwRes)
    {
        CListCtrl &refCtrl = GetListCtrl();
        m_HeaderCtrl.SetListControl (refCtrl.m_hWnd);

        DoSort();

        if(refCtrl.GetItemCount() > 0)
        {
            int iIndex = refCtrl.GetNextItem (-1, LVNI_SELECTED);
            if (-1 == iIndex)
            {
                //
                // If there is no selection, set focus on the first item.
                //
                refCtrl.SetItemState (0, LVIS_FOCUSED, LVIS_FOCUSED);
            }
            else
            {
                //
                // After sort, ensure the first selected item is visible
                //
                refCtrl.EnsureVisible (iIndex, FALSE);
            }
        }
    }
    else
    {
        PopupError (dwRes);
    }
    return 0;
}   // CFolderListView::OnFolderRefreshEnded


/***********************************
*                                  *
*      Columns sort support        *
*                                  *
***********************************/

int 
CFolderListView::CompareListItems (
    CFaxMsg* pFaxMsg1, 
    CFaxMsg* pFaxMsg2
)
/*++

Routine name : CFolderListView::CompareListItems

Routine description:

    Compares two items in the list (callback)

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    pFaxMsg1                       [in]     - Item 1
    pFaxMsg2                       [in]     - Item 2

Return Value:

    -1 if item1 is smaler than item2
    0 if identical
    +1 if item1 is bigger than item2

--*/
{
    DBG_ENTER(TEXT("CFolderListView::CompareListItems"));

    //
    // Make sure the we're sorting a valid column here
    //
    ASSERTION (m_nSortedCol >= 0);
    ASSERTION (m_nSortedCol <= GetLogicalColumnsCount());

    //
    // Get item index to sort by
    //
    DWORD dwItemIndex = ItemIndexFromLogicalColumnIndex (m_nSortedCol);

    //
    // Get comparison result
    //
    int iRes = m_bSortAscending ? CompareItems (pFaxMsg1, pFaxMsg2, dwItemIndex) :
                                  CompareItems (pFaxMsg2, pFaxMsg1, dwItemIndex);

    return iRes;
}

void CFolderListView::OnColumnClick(
    NMHDR* pNMHDR, 
    LRESULT* pResult
) 
/*++

Routine name : CFolderListView::OnColumnClick

Routine description:

    Handle mouse click on list header column (sort)

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    pNMHDR                        [in]     - Header column information
    pResult                       [out]    - Result

Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CFolderListView::OnColumnClick"),
              TEXT("Type=%d"),
              m_Type);

    NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

    DWORD dwItemIndex = ItemIndexFromLogicalColumnIndex (pNMListView->iSubItem);
    if(IsItemIcon(dwItemIndex))
    { 
        //
        // no sort by icon
        //
        return;
    }

    if( pNMListView->iSubItem == m_nSortedCol )
    {
        m_bSortAscending = !m_bSortAscending;
    }
    else
    {
        m_bSortAscending = TRUE;
    }
    m_nSortedCol = pNMListView->iSubItem;
    DoSort();
    *pResult = 0;
}   // CFolderListView::OnColumnClick

    
int 
CALLBACK 
CFolderListView::ListViewItemsCompareProc (
    LPARAM lParam1, 
    LPARAM lParam2, 
    LPARAM lParamSort
)
{
    DBG_ENTER(TEXT("CFolderListView::ListViewItemsCompareProc"));
    ASSERTION(m_psCurrentViewBeingSorted);
    ASSERTION(lParam1);
    ASSERTION(lParam2);

    CFaxMsg* pFaxMsg1 = (CFaxMsg*)lParam1;
    CFaxMsg* pFaxMsg2 = (CFaxMsg*)lParam2;

    DWORDLONG dwlId;
    try
    {
        dwlId = pFaxMsg1->GetId();
        dwlId = pFaxMsg2->GetId();
    }
    catch(...)
    {
        //
        // The list control has invalid item
        //
        VERBOSE (DBG_MSG, TEXT("List control has invalid item"));
        ASSERTION(FALSE);
        return 0;
    }

    return m_psCurrentViewBeingSorted->CompareListItems (pFaxMsg1, pFaxMsg2);
}


DWORD 
CFolderListView::RefreshImageLists (
    BOOL bForce
)
/*++

Routine name : CFolderListView::RefreshImageLists

Routine description:

    Loads the static list of images (icons) for the list control

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    bForce - [in] If TRUE, any existing image list is destroyed and replaced with new ones.
                  If FALSE, existing image lists remain unchanged.    

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CFolderListView::RefreshImageLists"), dwRes);

    CListCtrl& refCtrl = GetListCtrl();

    if (bForce || (NULL == m_sReportIcons.m_hImageList))
    {
        //
        // Load image list of list view icons - 256 colors, pixel at 0,0 is mapped to background color during load
        //
        ImageList_Destroy(m_sReportIcons.Detach());
        HIMAGELIST himl = ImageList_LoadImage(
                                   AfxGetResourceHandle(), 
                                   MAKEINTRESOURCE(IDB_LIST_IMAGES), 
                                   16, 
                                   0,
                                   RGB(0, 255, 0), 
                                   IMAGE_BITMAP, 
                                   LR_LOADTRANSPARENT | LR_CREATEDIBSECTION);
        if (NULL == himl)
        {
            dwRes = GetLastError();
            CALL_FAIL (RESOURCE_ERR, TEXT("ImageList_LoadImage"), dwRes);
            PopupError (dwRes);
            return dwRes;
        }
        m_sReportIcons.Attach (himl);
    }  
    if (bForce || (NULL == m_sImgListDocIcon.m_hImageList))
    {
        //
        // Load the image list for the icons column and the up/down sort images - 16 colors.
        //
        ImageList_Destroy(m_sImgListDocIcon.Detach());
        dwRes = LoadDIBImageList (m_sImgListDocIcon,
                                  IDB_DOC_ICON,
                                  16,
                                  RGB (214, 214, 214));
        if (ERROR_SUCCESS != dwRes)
        {
            CALL_FAIL (RESOURCE_ERR, TEXT("LoadDIBImageList"), dwRes);
            PopupError (dwRes);
            return dwRes;
        }
    }
    refCtrl.SetExtendedStyle (LVS_EX_FULLROWSELECT |    // Entire row is selected
                              LVS_EX_INFOTIP);

    refCtrl.SetImageList (&m_sReportIcons, LVSIL_SMALL);
    //
    // Attach our custom header-control to the window of the list's header.
    //
    m_HeaderCtrl.SubclassWindow(refCtrl.GetHeaderCtrl()->m_hWnd);
    m_HeaderCtrl.SetImageList (&m_sImgListDocIcon);
    m_HeaderCtrl.SetListControl (refCtrl.m_hWnd);
    COLORREF crBkColor = ::GetSysColor(COLOR_WINDOW);
    refCtrl.SetBkColor(crBkColor);
    return dwRes;
}   // CFolderListView::RefreshImageLists



void 
CFolderListView::OnItemRightClick(
    NMHDR* pNMHDR, 
    LRESULT* pResult
) 
/*++

Routine name : CFolderListView::OnItemRightClick

Routine description:

    Handle mouse right-click on list items (popup context sensitive menu)

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    pNMHDR                        [in]     - Item information
    pResult                       [out]    - Result

Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CFolderListView::OnItemRightClick"),
              TEXT("Type=%d"),
              m_Type);
    //
    // Send WM_CONTEXTMENU to self
    //
    SendMessage(WM_CONTEXTMENU, (WPARAM) m_hWnd, GetMessagePos());
    //
    // Mark message as handled and suppress default handling
    //
    *pResult = 1;
}   // CFolderListView::OnItemRightClick

DWORD 
CFolderListView::GetServerPossibleOperations (
    CFaxMsg* pMsg
)
/*++

Routine name : CFolderListView::GetServerPossibleOperations

Routine description:

    Retrieves operations possible on items according to server's security configuration.

Author:

    Eran Yariv (EranY), Feb, 2000

Arguments:


Return Value:

    Possible operations (JOB_OP*)

--*/
{
    DWORD dwRes = FAX_JOB_OP_ALL;
    DBG_ENTER(TEXT("CFolderListView::GetServerPossibleOperations"), dwRes);
    ASSERTION(pMsg);

    CServerNode* pServer = pMsg->GetServer();
    ASSERTION (pServer);

    switch (m_Type)
    {
        case FOLDER_TYPE_INBOX:
            if (!pServer->CanManageInbox())
            {
                //
                // User cannot perform operations on the inbox
                //
                dwRes &= ~FAX_JOB_OP_DELETE;
            }
            break;

        case FOLDER_TYPE_INCOMING:
            if (!pServer->CanManageAllJobs ())
            {
                //
                // User cannot perform operations on the incoming queue folder
                //
                dwRes &= ~(FAX_JOB_OP_DELETE | FAX_JOB_OP_PAUSE | 
                           FAX_JOB_OP_RESUME | FAX_JOB_OP_RESTART);
            }
            break;

        case FOLDER_TYPE_OUTBOX:
        case FOLDER_TYPE_SENT_ITEMS:
            //
            // User can do anything here
            //
            break;

        default:
            ASSERTION_FAILURE;
            dwRes = 0;
    }
    return dwRes;
}   // CFolderListView::GetServerPossibleOperations



void CFolderListView::OnItemChanged(
    NMHDR* pNMHDR, 
    LRESULT* pResult
) 
/*++

Routine name : CFolderListView::OnItemChanged

Routine description:

    Handle selection changes of on list items

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    pNMHDR                        [in]     - Item information
    pResult                       [out]    - Result

Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CFolderListView::OnItemChanged"),
              TEXT("Type=%d"),
              m_Type);

    NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

    *pResult = 0;
    //
    // Find out if a new item is selected or unselected.
    //
    if (pNMListView->iItem < 0)
    {
        //
        // No item reported
        //
        return;
    }
    if (!(LVIF_STATE & (pNMListView->uChanged)))
    {
        //
        // This is not a selection change report
        //
        return;
    }
    if ( ((pNMListView->uNewState) & LVIS_SELECTED) && 
        !((pNMListView->uOldState) & LVIS_SELECTED))
    {
        //
        // Item changed from not-selected to selected.
        // Change the possible operations the user can perform on selected items.
        //

        if (1 == GetListCtrl().GetSelectedCount())
        {
            //
            // A single item is selected - use it's operations
            //
            m_dwPossibleOperationsOnSelectedItems = 
                        GetServerPossibleOperations((CFaxMsg*)pNMListView->lParam) & 
                        GetItemOperations (pNMListView->lParam);
        }
        else
        {
            //
            // More than one item is selected
            //
            m_dwPossibleOperationsOnSelectedItems &= GetItemOperations (pNMListView->lParam);
            //
            // If more than one item is selected, disable view and properties.
            //
            m_dwPossibleOperationsOnSelectedItems &= ~(FAX_JOB_OP_VIEW | FAX_JOB_OP_PROPERTIES);
        }            

        //
        // If the folder is still refreshing and a command line argument asks for a specific 
        // message to be selected in this folder, then we mark that message in m_dwlMsgToSelect.
        // Since the user just performed a manual selection of items, we no longer have to select anything for him.
        //
        m_dwlMsgToSelect = 0;
    }
    else if (!((pNMListView->uNewState) & LVIS_SELECTED) && 
              ((pNMListView->uOldState) & LVIS_SELECTED))
    {
        //
        // Item changed from selected to not-selected
        // Recalculate the possible operations the user can do on selected item.
        RecalcPossibleOperations ();
        //
        // If the folder is still refreshing and a command line argument asks for a specific 
        // message to be selected in this folder, then we mark that message in m_dwlMsgToSelect.
        // Since the user just performed a manual selection of items, we no longer have to select anything for him.
        //
        m_dwlMsgToSelect = 0;
    }
}   // CFolderListView::OnItemChanged

void
CFolderListView::RecalcPossibleOperations ()
/*++

Routine name : CFolderListView::RecalcPossibleOperations

Routine description:

    Recalculates the possible operation on the set of currently selected items.

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:


Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CFolderListView::RecalcPossibleOperations"));
    CListCtrl &refCtrl = GetListCtrl();
    int iInd = -1;
    DWORD dwSelectedCount = refCtrl.GetSelectedCount ();
    if (!dwSelectedCount)
    {
        //
        // No item selected
        //
        m_dwPossibleOperationsOnSelectedItems = 0;
        return;
    }
    m_dwPossibleOperationsOnSelectedItems = 0xFFFF;
    for (DWORD dwItems = 0; dwItems < dwSelectedCount; dwItems++)
    {
        iInd = refCtrl.GetNextItem (iInd, LVNI_SELECTED);
        ASSERTION (0 <= iInd);
        LPARAM lparam = (LPARAM) refCtrl.GetItemData (iInd);

        m_dwPossibleOperationsOnSelectedItems &= GetServerPossibleOperations((CFaxMsg*)lparam);
        m_dwPossibleOperationsOnSelectedItems &= GetItemOperations (lparam);
    }
    if (dwSelectedCount > 1)
    {
        //
        // If more than one item is selected, disable view and properties.
        //
        m_dwPossibleOperationsOnSelectedItems &= ~(FAX_JOB_OP_VIEW | FAX_JOB_OP_PROPERTIES);
    }            
}   // CFolderListView::RecalcPossibleOperations

DWORD 
ViewFile (
    LPCTSTR lpctstrFile
)
/*++

Routine Description:

    Launches the application associated with a given file to view it.
    We first attempt to use the "open" verb.
    If that fails, we try the NULL (default) verb.
    
Arguments:

    lpctstrFile [in]  - File name

Return Value:

    Standard Win32 error code
    
--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    SHELLEXECUTEINFO executeInfo = {0};

    DEBUG_FUNCTION_NAME(TEXT("ViewFile"));

    executeInfo.cbSize = sizeof(executeInfo);
    executeInfo.fMask  = SEE_MASK_FLAG_NO_UI | SEE_MASK_INVOKEIDLIST | SEE_MASK_FLAG_DDEWAIT;
    executeInfo.lpVerb = TEXT("open");
    executeInfo.lpFile = lpctstrFile;
    executeInfo.nShow  = SW_SHOWNORMAL;
    //
    // Execute the associated application with the "open" verb
    //
    if(!ShellExecuteEx(&executeInfo))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("ShellExecuteEx(open) failed (ec: %ld)"),
            GetLastError());
        //
        // "open" verb is not supported. Try the NULL (default) verb.
        //
        executeInfo.lpVerb = NULL;
        if(!ShellExecuteEx(&executeInfo))
        {
            dwRes = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("ShellExecuteEx(NULL) failed (ec: %ld)"),
                dwRes);
        }
    }
    return dwRes;
}   // ViewFile    



void 
CFolderListView::OnFolderItemView ()
/*++

Routine name : CFolderListView::OnFolderItemView

Routine description:

    Handles message view commands

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:


Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CFolderListView::OnFolderItemView"),
              TEXT("Type=%d"),
              m_Type);

    if(!(m_dwPossibleOperationsOnSelectedItems & FAX_JOB_OP_VIEW))
    {
        //
        // there is no TIF associated application
        //
        return;
    }

    CString cstrTiff;
    DWORD dwRes = FetchTiff (cstrTiff);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("CFolderListView::FetchTiff"), dwRes);
        PopupError (dwRes);
        return;
    }
    
    //
    // Open the TIFF with associated application.
    // All preview files are automatically removed once the application is shut down.
    //
    dwRes = ViewFile(cstrTiff);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("ViewFile"), dwRes);

        if(ERROR_NO_ASSOCIATION == dwRes)
        {
            AlignedAfxMessageBox(IDS_NO_OPEN_ASSOCIATION, MB_ICONSTOP);
        }
        else
        {
            PopupError (dwRes);
        }
    } 
    else
    {
        if(FOLDER_TYPE_INBOX == m_Type)
        {
            theApp.InboxViewed();
        }
    }
}   // CFolderListView::OnFolderItemView


void 
CFolderListView::OnFolderItemPrint ()
/*++

Routine name : CFolderListView::OnFolderItemPrint

Routine description:

    Handles message print commands

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:


Return Value:

    None.

--*/
{
    DWORD dwRes;
    DBG_ENTER(TEXT("CFolderListView::OnFolderItemPrint"),
              TEXT("Type=%d"),
              m_Type);

    HDC hPrinter;
    if (IsWinXPOS())
    {   
        //
        // Use new look of printer selection dialog
        //
        C_PrintDialogEx prnDlg(FALSE, 
                               PD_ALLPAGES                  | 
                               PD_USEDEVMODECOPIES          |
                               PD_NOPAGENUMS                |
                               PD_NOSELECTION               |
                               PD_RETURNDC);         
        if(IDOK != prnDlg.DoModal())
        {
            CALL_FAIL (GENERAL_ERR, TEXT("C_PrintDialogEx::DoModal"), CommDlgExtendedError());
            return;
        }
        hPrinter = prnDlg.GetPrinterDC();
        if(!hPrinter)
        {
            dwRes = ERROR_CAN_NOT_COMPLETE;
            CALL_FAIL (GENERAL_ERR, TEXT("C_PrintDialogEx::GetPrinterDC"), dwRes);
            return;
        }
    }
    else
    {
        //
        // Use legacy printer selection dialog
        //
        CPrintDialog prnDlg(FALSE);         
        if(IDOK != prnDlg.DoModal())
        {
            return;
        }
        hPrinter = prnDlg.GetPrinterDC();
        if(!hPrinter)
        {
            dwRes = ERROR_CAN_NOT_COMPLETE;
            CALL_FAIL (GENERAL_ERR, TEXT("CPrintDialog::GetPrinterDC"), dwRes);
            return;
        }
    }

    CString cstrTiff;
    dwRes = FetchTiff (cstrTiff);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("CFolderListView::FetchTiff"), dwRes);
        PopupError (dwRes);
        return;
    }

    if(!TiffPrintDC(cstrTiff, hPrinter))
    {
        dwRes = GetLastError();
        CALL_FAIL (GENERAL_ERR, TEXT("TiffPrintDC"), dwRes);
        goto exit;
    }

exit:
    if(hPrinter)
    {
        CDC::FromHandle(hPrinter)->DeleteDC();
    }

    if (!DeleteFile (cstrTiff))
    {
        dwRes = GetLastError ();
        CALL_FAIL (FILE_ERR, TEXT("DeleteFile"), dwRes);
    }
}   // CFolderListView::OnFolderItemPrint

void 
CFolderListView::OnFolderItemCopy ()
/*++

Routine name : CFolderListView::OnFolderItemCopy

Routine description:

    Handles message copy commands

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:


Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CFolderListView::OnFolderItemCopy"),
              TEXT("Type=%d"),
              m_Type);

    CString cstrTiff;
    DWORD dwRes = FetchTiff (cstrTiff);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("CFolderListView::FetchTiff"), dwRes);
        PopupError (dwRes);
        return;
    }

    CString cstrFileName;
    CString cstrFilterFormat;

    TCHAR szFile[MAX_PATH] = {0};
    TCHAR szFilter[MAX_PATH] = {0};
    OPENFILENAME ofn = {0};
    
    //
    // get tif file name
    //
    int nFileNamePos = cstrTiff.ReverseFind(TEXT('\\'));
    ASSERTION(nFileNamePos > 0);
    nFileNamePos++;

    try
    {
        cstrFileName = cstrTiff.Right(cstrTiff.GetLength() - nFileNamePos);
    }
    catch(...)
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        CALL_FAIL (MEM_ERR, TEXT("CString::operator="), dwRes);
        PopupError (dwRes);
        goto del_file;
    }

    _tcscpy(szFile, cstrFileName);

    dwRes = LoadResourceString(cstrFilterFormat, IDS_SAVE_AS_FILTER_FORMAT);
    if (ERROR_SUCCESS != dwRes)
    {
        ASSERTION_FAILURE;
        CALL_FAIL (RESOURCE_ERR, TEXT("LoadResourceString"), dwRes);
        goto del_file;
    }

    _stprintf(szFilter, cstrFilterFormat, FAX_TIF_FILE_MASK, 0, FAX_TIF_FILE_MASK, 0);

    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner   = m_hWnd;
    ofn.lpstrFilter = szFilter;
    ofn.lpstrFile   = szFile;
    ofn.nMaxFile    = ARR_SIZE(szFile);
    ofn.lpstrDefExt = FAX_TIF_FILE_EXT;
    ofn.Flags       = OFN_EXPLORER | OFN_PATHMUSTEXIST | OFN_ENABLEHOOK;
    ofn.lpfnHook    = OFNHookProc;

    if(!GetSaveFileName(&ofn))
    {
        goto del_file;
    }

    {
        //
        // SHFILEOPSTRUCT::pFrom should ends with double NULL
        //
        TCHAR tszSrcFile[MAX_PATH+1] = {0};
        _tcsncpy(tszSrcFile, cstrTiff, MAX_PATH);

        //
        // move the file
        //
        SHFILEOPSTRUCT shFileOpStruct = {0};

        shFileOpStruct.wFunc  = FO_MOVE;
        shFileOpStruct.fFlags = FOF_SILENT; // Don't display file move progress dialog
        shFileOpStruct.pFrom  = tszSrcFile;
        shFileOpStruct.pTo    = szFile;

        if(!SHFileOperation(&shFileOpStruct))
        {
            //
            // success
            //
            return;
        }
        else
        {
            dwRes = ERROR_CAN_NOT_COMPLETE;
            CALL_FAIL (GENERAL_ERR, TEXT("SHFileOperation"), dwRes);
            goto del_file;
        }
    }

del_file:
    if (!DeleteFile (cstrTiff))
    {
        dwRes = GetLastError ();
        CALL_FAIL (FILE_ERR, TEXT("DeleteFile"), dwRes);
    }

}   // CFolderListView::OnFolderItemCopy


void 
CFolderListView::OnUpdateFolderItemSendMail(
    CCmdUI* pCmdUI
)
{ 
    pCmdUI->Enable( (m_dwPossibleOperationsOnSelectedItems & FAX_JOB_OP_VIEW)       &&
                    (m_dwPossibleOperationsOnSelectedItems & FAX_JOB_OP_PROPERTIES) &&
                    theApp.IsMapiEnable());
}

void 
CFolderListView::OnUpdateFolderItemView(
    CCmdUI* pCmdUI
)
{
    OnUpdateFolderItemPrint(pCmdUI);
}

void 
CFolderListView::OnUpdateFolderItemPrint(
    CCmdUI* pCmdUI
)
{
    pCmdUI->Enable( (m_dwPossibleOperationsOnSelectedItems & FAX_JOB_OP_VIEW) &&
                    (m_dwPossibleOperationsOnSelectedItems & FAX_JOB_OP_PROPERTIES));
}

void 
CFolderListView::OnUpdateFolderItemCopy(
    CCmdUI* pCmdUI
)
{
    pCmdUI->Enable( (m_dwPossibleOperationsOnSelectedItems & FAX_JOB_OP_VIEW) &&
                    (m_dwPossibleOperationsOnSelectedItems & FAX_JOB_OP_PROPERTIES));
}


void 
CFolderListView::OnFolderItemMail ()
/*++

Routine name : CFolderListView::OnFolderItemMail

Routine description:

    Handles message mail commands

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:


Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CFolderListView::OnFolderItemMail"),
              TEXT("Type=%d"),
              m_Type);

    CString cstrTiff;
    DWORD dwRes = FetchTiff (cstrTiff);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("CFolderListView::FetchTiff"), dwRes);
        PopupError (dwRes);
        return;
    }

    //
    // create a new mail message with tif file attached
    //
    dwRes = theApp.SendMail(cstrTiff);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("CClientConsoleApp::SendMail"), dwRes);
        PopupError (dwRes);
    }

    if (!DeleteFile (cstrTiff))
    {
        dwRes = GetLastError ();
        CALL_FAIL (FILE_ERR, TEXT("DeleteFile"), dwRes);
    }
}   // CFolderListView::OnFolderItemMail


void 
CFolderListView::OnFolderItemProperties ()
/*++

Routine name : CFolderListView::OnFolderItemProperties

Routine description:

    Handles message properties commands

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:


Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CFolderListView::OnFolderItemProperties"),
              TEXT("Type=%d"),
              m_Type);

    //
    // Make sure there's exaclty one elemented selected
    //
    CListCtrl &refCtrl = GetListCtrl();
    ASSERTION (1 == refCtrl.GetSelectedCount());
    int iInd = refCtrl.GetNextItem (-1, LVNI_SELECTED);
    ASSERTION (0 <= iInd);
    CFaxMsg* pMsg = (CFaxMsg*)(refCtrl.GetItemData (iInd));
    ASSERTION (pMsg);

    CServerNode* pServer = pMsg->GetServer();
    ASSERTION (pServer);

    CItemPropSheet propSheet(IDS_PROPERTIES_SHEET_CAPTION);
    DWORD dwRes = propSheet.Init(pServer->GetFolder(m_Type), pMsg);
    
    if(ERROR_SUCCESS != dwRes)
    {
        PopupError (dwRes);
        return;
    }

    dwRes = propSheet.DoModal();
    if(IDABORT == dwRes)
    {
        PopupError (propSheet.GetLastError());
    }

}   // CFolderListView::OnFolderItemProperties


DWORD
CFolderListView::OpenSelectColumnsDlg() 
/*++

Routine name : CFolderListView::OpenSelectColumnsDlg

Routine description:

    opens column select dialog and reorders the columns

Author:

    Alexander Malysh (AlexMay), Jan, 2000

Arguments:


Return Value:

    Error code

--*/
{   
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CFolderListView::OpenSelectColumnsDlg"),
              TEXT("Type=%d"),
              m_Type);

    ASSERTION(NULL != m_pnColumnsOrder);
    ASSERTION(NULL != m_pViewColumnInfo);

    DWORD dwCount = GetLogicalColumnsCount();

    //
    // init header string array
    //
    CString* pcstrHeaders;
    try
    {
        pcstrHeaders = new CString[dwCount];
    }
    catch (...)
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        CALL_FAIL (MEM_ERR, TEXT ("new CString[dwCount]"), dwRes);
        return dwRes;
    }

    int nItemIndex;
    for (DWORD dw = 0; dw < dwCount; ++dw)
    {        
        nItemIndex = ItemIndexFromLogicalColumnIndex(dw);
        dwRes = GetColumnHeaderString (pcstrHeaders[dw], nItemIndex);
        if (ERROR_SUCCESS != dwRes)
        {
            CALL_FAIL (GENERAL_ERR, TEXT("GetColumnHeaderString"), dwRes);
            delete[] pcstrHeaders;
            return dwRes;
        }
    }

    //
    // save width
    //
    int nIndex;
    for (dw = 0; dw < m_dwDisplayedColumns; ++dw) 
    {
        nIndex = m_pnColumnsOrder[dw];
        ASSERTION(nIndex >= 0 && nIndex < dwCount);

        m_pViewColumnInfo[nIndex].nWidth = GetListCtrl().GetColumnWidth(nIndex);
    }

    //
    // start column select dialog
    //
    CColumnSelectDlg dlg(pcstrHeaders, m_pnColumnsOrder, dwCount, m_dwDisplayedColumns);
    if(IDOK == dlg.DoModal())
    {
        for (dw = 0; dw < dwCount; ++dw) 
        {
            nIndex = m_pnColumnsOrder[dw];
            ASSERTION(nIndex >= 0 && nIndex < dwCount);

            m_pViewColumnInfo[nIndex].dwOrder = dw;
            m_pViewColumnInfo[nIndex].bShow = (dw < m_dwDisplayedColumns);
        }

        //
        // if sorted column is hidden then no sort
        //
        if(m_nSortedCol >= 0)
        {
            ASSERTION(m_nSortedCol < dwCount);
            if(!m_pViewColumnInfo[m_nSortedCol].bShow)
            {
                m_nSortedCol = -1;
            }
        }
      
        ColumnsToLayout();
    }

    delete[] pcstrHeaders;

    return dwRes;

} // CFolderListView::OpenSelectColumnsDlg


DWORD 
CFolderListView::ColumnsToLayout()
/*++

Routine name : CFolderListView::ColumnsToLayout

Routine description:

    reorders columns according to saved layout

Author:

    Alexander Malysh (AlexMay), Jan, 2000

Arguments:


Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CFolderListView::ColumnsToLayout"), dwRes);

    ASSERTION(NULL != m_pnColumnsOrder);
    ASSERTION(NULL != m_pViewColumnInfo);

    CListCtrl &refCtrl = GetListCtrl();
    DWORD dwCount = GetLogicalColumnsCount();   
    
    CSize size;
    CDC* pHdrDc = refCtrl.GetHeaderCtrl()->GetDC();

    //
    // set column order
    //
    if(!refCtrl.SetColumnOrderArray(dwCount, m_pnColumnsOrder))
    {
        dwRes = ERROR_GEN_FAILURE;
        CALL_FAIL (WINDOW_ERR, TEXT("CListCtrl::SetColumnOrderArray"), dwRes);
        return dwRes;
    }

    //
    // set column width
    //
    DWORD dwItemIndex;
    CString cstrColumnText;
    for (DWORD dwCol = 0; dwCol < dwCount; ++dwCol) 
    {
        if(m_pViewColumnInfo[dwCol].bShow)
        {
            if(m_pViewColumnInfo[dwCol].nWidth < 0)
            {
                dwItemIndex = ItemIndexFromLogicalColumnIndex(dwCol);
                dwRes = GetColumnHeaderString (cstrColumnText, dwItemIndex);
                if(ERROR_SUCCESS != dwRes)
                {
                    CALL_FAIL (GENERAL_ERR, TEXT("GetColumnHeaderString"), dwRes);
                    return dwRes;
                }

                size = pHdrDc->GetTextExtent(cstrColumnText);
                refCtrl.SetColumnWidth (dwCol, size.cx * 1.5);
            }
            else
            {
                refCtrl.SetColumnWidth (dwCol, m_pViewColumnInfo[dwCol].nWidth);
            }
        }
        else
        {
            refCtrl.SetColumnWidth (dwCol, 0);
        }
    }

    Invalidate();

    return dwRes;

} // CFolderListView::ColumnsToLayout


DWORD
CFolderListView::ReadLayout(
    LPCTSTR lpszViewName
)
/*++

Routine name : CFolderListView::ReadLayout

Routine description:

    reads column layout from registry

Author:

    Alexander Malysh (AlexMay), Jan, 2000

Arguments:

    lpszSection                   [in]    - registry section

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CFolderListView::ReadLayout"), 
              dwRes,
              TEXT("Type=%d"),
              m_Type);

    ASSERTION(NULL == m_pnColumnsOrder);
    ASSERTION(NULL == m_pViewColumnInfo);

    //
    // columns order array allocation
    //
    DWORD dwCount = GetLogicalColumnsCount();   
    try
    {
        m_pnColumnsOrder = new int[dwCount];
    }
    catch (...)
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        CALL_FAIL (MEM_ERR, TEXT ("m_pdwColumnsOrder = new int[dwCount]"), dwRes);
        return dwRes;
    }
    
    for(DWORD dw=0; dw < dwCount; ++dw)
    {
        m_pnColumnsOrder[dw] = -1;
    }
    //
    // columns info array allocation
    //
    try
    {
        m_pViewColumnInfo = new TViewColumnInfo[dwCount];
    }
    catch (...)
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        CALL_FAIL (MEM_ERR, TEXT ("new CString[dwCount]"), dwRes);
        return dwRes;
    }

    //
    // reads columns layout from registry
    //
    CString cstrSection;
    m_dwDisplayedColumns = 0;
    for(dw=0; dw < dwCount; ++dw)
    {
        try
        {
            cstrSection.Format(TEXT("%s\\%s\\%02d"), lpszViewName, CLIENT_VIEW_COLUMNS, dw);
        }
        catch(...)
        {
            dwRes = ERROR_NOT_ENOUGH_MEMORY;
            CALL_FAIL (MEM_ERR, TEXT("CString::Format"), dwRes);
            return dwRes;
        }

        m_pViewColumnInfo[dw].bShow = theApp.GetProfileInt(cstrSection, 
                                                           CLIENT_VIEW_COL_SHOW, 
                                                           (dw < m_dwDefaultColNum) ? 1 : 0);
        if(m_pViewColumnInfo[dw].bShow)
        {
            ++m_dwDisplayedColumns;
        }

        m_pViewColumnInfo[dw].nWidth = theApp.GetProfileInt(cstrSection, 
                                                            CLIENT_VIEW_COL_WIDTH, -1);
        m_pViewColumnInfo[dw].dwOrder = theApp.GetProfileInt(cstrSection, 
                                                            CLIENT_VIEW_COL_ORDER, dw);
        ASSERTION(m_pViewColumnInfo[dw].dwOrder < dwCount);

        m_pnColumnsOrder[m_pViewColumnInfo[dw].dwOrder] = dw;
    }

    //
    // check column order consistence
    //
    for(dw=0; dw < dwCount; ++dw)
    {
        ASSERTION(m_pnColumnsOrder[dw] >= 0);
    }
    //
    // read sort parameters
    //
    m_bSortAscending = theApp.GetProfileInt(lpszViewName, CLIENT_VIEW_SORT_ASCENDING, 1);
    m_nSortedCol = theApp.GetProfileInt(lpszViewName, CLIENT_VIEW_SORT_COLUMN, 1);
    if(m_nSortedCol >= dwCount)
    {
        m_nSortedCol = 0;
    }

    return dwRes;

} // CFolderListView::ReadLayout


DWORD
CFolderListView::SaveLayout(
    LPCTSTR lpszViewName
)
/*++

Routine name : CFolderListView::SaveLayout

Routine description:

    saves column layout to registry

Author:

    Alexander Malysh (AlexMay), Jan, 2000

Arguments:

    lpszSection                   [in]    - registry section

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CFolderListView::SaveLayout"), 
              dwRes,
              TEXT("Type=%d"),
              m_Type);
    
    if(!m_bColumnsInitialized)
    {
        return dwRes;
    }

    ASSERTION(m_pViewColumnInfo != NULL);

    //
    // save column layout to registry
    //
    BOOL bRes;
    DWORD dwWidth;
    CString cstrSection;
    DWORD dwCount = GetLogicalColumnsCount();   
    
    for(DWORD dw=0; dw < dwCount; ++dw)
    {
        try
        {
            cstrSection.Format(TEXT("%s\\%s\\%02d"), lpszViewName, CLIENT_VIEW_COLUMNS, dw);
        }
        catch(...)
        {
            dwRes = ERROR_NOT_ENOUGH_MEMORY;
            CALL_FAIL (MEM_ERR, TEXT("CString::Format"), dwRes);
            return dwRes;
        }

        bRes = theApp.WriteProfileInt(cstrSection, CLIENT_VIEW_COL_SHOW, 
                                                m_pViewColumnInfo[dw].bShow);
        bRes = theApp.WriteProfileInt(cstrSection, CLIENT_VIEW_COL_ORDER, 
                                                m_pViewColumnInfo[dw].dwOrder);
        dwWidth = m_pViewColumnInfo[dw].bShow ? GetListCtrl().GetColumnWidth(dw) : -1;
        bRes = theApp.WriteProfileInt(cstrSection, CLIENT_VIEW_COL_WIDTH, dwWidth);
    }

    //
    // save sort parameters
    //
    bRes = theApp.WriteProfileInt(lpszViewName, CLIENT_VIEW_SORT_ASCENDING, m_bSortAscending);
    bRes = theApp.WriteProfileInt(lpszViewName, CLIENT_VIEW_SORT_COLUMN, m_nSortedCol);    

    return dwRes;

} // CFolderListView::SaveLayout


BOOL 
CFolderListView::OnNotify( 
    WPARAM wParam, 
    LPARAM lParam, 
    LRESULT* pResult
)
/*++

Routine name : CFolderListView::OnNotify

Routine description:

    disables resizing of hidden columns

Author:

    Alexander Malysh (AlexMay), Jan, 2000

Arguments:

    wParam                        [in]    - Identifies the control that sends the message
    lParam                        [in]    - NMHEADER*
    pResult                       [out]   - result

Return Value:

    TRUE if message processed, FALSE otherwise.

--*/
{   
    int i=0;
    switch (((NMHEADER*)lParam)->hdr.code)
    {
        case HDN_BEGINTRACKA:
        case HDN_BEGINTRACKW:       
        case HDN_DIVIDERDBLCLICKA:
        case HDN_DIVIDERDBLCLICKW:
            DBG_ENTER(TEXT("CFolderListView::OnNotify"));

            //
            // get column index
            //
            DWORD dwIndex = ((NMHEADER*)lParam)->iItem;
            ASSERTION(NULL != m_pViewColumnInfo);
            ASSERTION(dwIndex < GetLogicalColumnsCount());

            //
            // ignore if hidden column 
            //
            if(!m_pViewColumnInfo[dwIndex].bShow )
            {
                *pResult = TRUE;
                return TRUE;
            }
    }

    return CListView::OnNotify(wParam, lParam, pResult );

} // CFolderListView::OnNotify


void 
CFolderListView::DoSort()
{
    if (m_bSorting || m_nSortedCol < 0)
    {
        //
        // Already sorting or no sorting column
        //
        return;
    }

    CWaitCursor waitCursor;

    m_bSorting = TRUE;

    CMainFrame *pFrm = GetFrm();
    if (!pFrm)
    {
        //
        //  Shutdown in progress
        //
    }
    else
    {
        pFrm->RefreshStatusBar ();
    }

    m_psCurrentViewBeingSorted = this;
    GetListCtrl().SortItems (ListViewItemsCompareProc, 0);                
    m_HeaderCtrl.SetSortImage( m_nSortedCol, m_bSortAscending );
    m_bSorting = FALSE;
}

DWORD 
CFolderListView::RemoveItem (
    LPARAM lparam,
    int    iIndex /* = -1 */
)
/*++

Routine name : CFolderListView::RemoveItem

Routine description:

    Removes an item from the list by its message / job pointer

Author:

    Eran Yariv (EranY), Feb, 2000

Arguments:

    lparam    [in]     - Message / Job pointer
    iIndex    [in]     - Optional item index in the control (for optimization)

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CFolderListView::RemoveItem"), 
              dwRes,
              TEXT("Type=%d"),
              m_Type);

    CListCtrl &refCtrl = GetListCtrl();
    if (-1 == iIndex)
    {
        //
        // Item index no supplied - search for it
        //
        LVFINDINFO lvfi;
        lvfi.flags = LVFI_PARAM;
        lvfi.lParam = lparam;
        iIndex = refCtrl.FindItem (&lvfi);
    }
    if (-1 == iIndex)
    {
        //
        // item already removed
        //
        CALL_FAIL (RESOURCE_ERR, TEXT("CListCtrl::FindItem"), dwRes);
        return dwRes;
    }
    BOOL bItemSelected = IsSelected (iIndex);
    //
    // Now erase the item
    //
    if (!refCtrl.DeleteItem (iIndex))
    {
        //
        // Failed to delete the item
        //
        dwRes = ERROR_GEN_FAILURE;
        CALL_FAIL (RESOURCE_ERR, TEXT("CListCtrl::DeleteItem"), dwRes);
        return dwRes;
    }

    if (bItemSelected)
    {
        //
        // If the item that we just removed was selected, we have to re-compute
        // the possible operations on the rest of the selected items.
        //
        if (!m_bInMultiItemsOperation)
        {
            //
            // Only recalc if we operate on few items.
            //
            RecalcPossibleOperations ();
        }
    }
    ASSERTION (ERROR_SUCCESS == dwRes);
    return dwRes;
}   // CFolderListView::RemoveItem

DWORD 
CFolderListView::FindInsertionIndex (
    LPARAM lparamItemData,
    DWORD &dwResultIndex
)
/*++

Routine name : CFolderListView::FindInsertionIndex

Routine description:

    Finds an insertion index for a new item to the list, according to sort settings.

    This function must be called when the data critical section is held.

Author:

    Eran Yariv (EranY), Feb, 2000

Arguments:

    lparamItemData  [in]     - Pointer to item
    dwResultIndex   [out]    - Insertion index

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CFolderListView::FindInsertionIndex"), 
              dwRes,
              TEXT("Type=%d"),
              m_Type);

    CListCtrl &refCtrl = GetListCtrl();
    DWORD dwNumItems = refCtrl.GetItemCount ();
    if (!dwNumItems  || (-1 == m_nSortedCol))
    {
        //
        // List is not sorted or is empty, always add at the end
        //
        VERBOSE (DBG_MSG, TEXT("Insertion point at index %ld"), dwResultIndex);
        dwResultIndex = dwNumItems;
        return dwRes;
    }
    //
    // Get item index to sort by
    //
    DWORD dwItemIndex = ItemIndexFromLogicalColumnIndex (m_nSortedCol);

    //
    // Check if item can be placed in beginning of list (no search required)
    //
    LPARAM lparamTop = refCtrl.GetItemData (0); // Pointer to item in top index
    LPARAM lparamBottom = refCtrl.GetItemData (dwNumItems - 1); // Pointer to item in bottom index
    ASSERTION (lparamTop && lparamBottom);
    //
    // Get comparison result against top index
    //
    int iRes = CompareItems ((CFaxMsg*)lparamItemData, (CFaxMsg*)lparamTop, dwItemIndex);
    ASSERTION ((-1 <= iRes) && (+1 >= iRes));
    if (!m_bSortAscending)
    {
        iRes *= -1;
    }
    switch (iRes)
    {
        case -1:    // Item is smaller than top
        case  0:    // Item is identical to top
            //
            // Insert new item before top index
            //
            dwResultIndex = 0;
            VERBOSE (DBG_MSG, TEXT("Insertion point at index %ld"), dwResultIndex);
            return dwRes;

        default:    // Item is bigger than top
            //
            // Do nothing
            //
            break;
    }
    //
    // Check if item can be placed in bottom of list (no search required)
    //

    //
    // Get comparison result against bottom index
    //
    iRes = CompareItems ((CFaxMsg*)lparamItemData, (CFaxMsg*)lparamBottom, dwItemIndex);
    ASSERTION ((-1 <= iRes) && (+1 >= iRes));
    if (!m_bSortAscending)
    {
        iRes *= -1;
    }
    switch (iRes)
    {
        case +1:    // Item is bigger than bottom
        case  0:    // Item is identical to bottom
            //
            // Insert new item at the bottom index
            //
            dwResultIndex = dwNumItems;
            VERBOSE (DBG_MSG, TEXT("Insertion point at index %ld"), dwResultIndex);
            return dwRes;

        default:    // Item is smaller than bottom
            //
            // Do nothing
            //
            break;
    }
    //
    // Search for insertion point
    //
    dwRes = BooleanSearchInsertionPoint (0, 
                                         dwNumItems - 1, 
                                         lparamItemData, 
                                         dwItemIndex, 
                                         dwResultIndex);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("BooleanSearchInsertionPoint"), dwRes);
        return dwRes;
    }
    return dwRes;
}   // CFolderListView::FindInsertionIndex 

DWORD
CFolderListView::BooleanSearchInsertionPoint (
    DWORD dwTopIndex,
    DWORD dwBottomIndex,
    LPARAM lparamItemData,
    DWORD dwItemIndex,
    DWORD &dwResultIndex
)
/*++

Routine name : CFolderListView::BooleanSearchInsertionPoint

Routine description:

    Recursively searches an insertion point for a list item.
    Performs a boolean search.

    This function must be called when the data critical section is held.

Author:

    Eran Yariv (EranY), Feb, 2000

Arguments:

    dwTopIndex      [in]     - Top list index
    dwBottomIndex   [in]     - Bottom list index
    lparamItemData  [in]     - Pointer to item
    dwItemIndex     [in]     - Logical column item to compare by
    dwResultIndex   [out]    - Insertion index

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CFolderListView::BooleanSearchInsertionPoint"), dwRes);

    ASSERTION (dwTopIndex <= dwBottomIndex);

    if ((dwTopIndex == dwBottomIndex) || (dwTopIndex + 1 == dwBottomIndex))
    {
        dwResultIndex = dwBottomIndex;
        VERBOSE (DBG_MSG, TEXT("Insertion point at index %ld"), dwResultIndex);
        return dwRes;
    }
    DWORD dwMiddleIndex = dwTopIndex + (dwBottomIndex - dwTopIndex) / 2;
    ASSERTION ((dwMiddleIndex != dwBottomIndex) && (dwMiddleIndex != dwTopIndex));

    CListCtrl &refCtrl = GetListCtrl();

    LPARAM lparamMiddle = refCtrl.GetItemData (dwMiddleIndex); // Pointer to item in middle index
    ASSERTION (lparamMiddle);
    //
    // Get comparison result against middle index
    //
    int iRes = CompareItems ((CFaxMsg*)lparamItemData, (CFaxMsg*)lparamMiddle, dwItemIndex);
    ASSERTION ((-1 <= iRes) && (+1 >= iRes));
    if (!m_bSortAscending)
    {
        iRes *= -1;
    }
    switch (iRes)
    {
        case -1:    // Item is smaller than middle
        case  0:    // Item is identical to middle
            //
            // Search between top and middle
            //
            dwRes = BooleanSearchInsertionPoint (dwTopIndex, 
                                                 dwMiddleIndex, 
                                                 lparamItemData, 
                                                 dwItemIndex, 
                                                 dwResultIndex);
            break;

        default:    // Item is bigger than middle
            //
            // Search between middle and bottom
            //
            dwRes = BooleanSearchInsertionPoint (dwMiddleIndex, 
                                                 dwBottomIndex, 
                                                 lparamItemData, 
                                                 dwItemIndex, 
                                                 dwResultIndex);
            break;
    }
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("BooleanSearchInsertionPoint"), dwRes);
    }
    return dwRes;
}   // CFolderListView::BooleanSearchInsertionPoint

DWORD 
CFolderListView::AddSortedItem (
    CViewRow &row, 
    LPARAM lparamItemData
)
/*++

Routine name : CFolderListView::AddSortedItem

Routine description:

    Adds an item to the list, preserving list sort order.

    This function must be called when the data critical section is held.

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    row             [in] - Row of item view information
    lparamItemData  [in] - Item associated data

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CFolderListView::AddSortedItem"), 
              dwRes,
              TEXT("Type=%d"),
              m_Type);

    DWORD dwResultIndex;
    //
    // Find insertion index according to sort order
    //
    dwRes = FindInsertionIndex (lparamItemData, dwResultIndex);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("FindInsertionIndex"), dwRes);
        return dwRes;
    }
    //
    // Add new item in insertion index
    //
    int iItemIndex;
    dwRes = AddItem (dwResultIndex, row, lparamItemData, &iItemIndex);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("AddItem"), dwRes);
        return dwRes;
    }

    ASSERTION (ERROR_SUCCESS == dwRes);
    return dwRes;
}   // CFolderListView::AddSortedItem

DWORD 
CFolderListView::UpdateSortedItem (
    CViewRow &row, 
    LPARAM lparamItemData
)
/*++

Routine name : CFolderListView::UpdateSortedItem

Routine description:

    Updates an item in the list, preserving list sort order.

    This function must be called when the data critical section is held.

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    row             [in] - Row of item view information
    lparamItemData  [in] - Item associated data

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CFolderListView::UpdateSortedItem"), 
              dwRes,
              TEXT("Type=%d"),
              m_Type);

    //
    // Find the item in the list
    //
    CListCtrl &refCtrl = GetListCtrl();
    LVFINDINFO lvfi;
    lvfi.flags = LVFI_PARAM;
    lvfi.lParam = lparamItemData;
    int iCurIndex = refCtrl.FindItem (&lvfi);
    if (-1 == iCurIndex)
    {
        dwRes = ERROR_NOT_FOUND;
        CALL_FAIL (RESOURCE_ERR, TEXT("CListCtrl::FindItem"), dwRes);
        return dwRes;
    }
#ifdef _DEBUG
    LPARAM lparamCurrentItem = refCtrl.GetItemData (iCurIndex);
    ASSERTION (lparamCurrentItem == lparamItemData);
#endif

    BOOL bJustUpdate = TRUE;   // If TRUE, we don't move the item in the list
    if (0 <= m_nSortedCol)
    {
        //
        // List is sorted.
        // See if the displayed text is different than the updated text
        //
        CString cstrDisplayedCell;
        try
        {
            cstrDisplayedCell = refCtrl.GetItemText (iCurIndex, m_nSortedCol);
        }
        catch (...)
        {
            dwRes = ERROR_NOT_ENOUGH_MEMORY;
            CALL_FAIL (MEM_ERR, TEXT ("CString::operator ="), dwRes);
            return dwRes;
        }
        //
        // Get item index to sort by
        //
        DWORD dwItemIndex = ItemIndexFromLogicalColumnIndex (m_nSortedCol);
        const CString &cstrUpdatedString =  row.GetItemString(dwItemIndex);
        if (cstrUpdatedString.Compare (cstrDisplayedCell))
        {
            //
            // Text in the sorted column is about to change.
            // Sorry, but we must:
            //    1. Remove old item from list
            //    2. Insert new item (sorted)
            //
            bJustUpdate = FALSE;
        }
    }
    if (bJustUpdate)
    {
        //
        // All we need to do is update the text of the list item (all sub items) and its icon
        //
        dwRes = UpdateLineTextAndIcon (iCurIndex, row);
        if (ERROR_SUCCESS != dwRes)
        {
            CALL_FAIL (RESOURCE_ERR, TEXT("UpdateLineTextAndIcon"), dwRes);
            return dwRes;
        }
    }
    else
    {
        //
        // Since the text in the sorted column is different than the new text,
        // we must remove the current item and insert a new (sorted) item.
        //
        BOOL bItemSelected = IsSelected (iCurIndex);
        refCtrl.SetRedraw (FALSE);
        if (!refCtrl.DeleteItem (iCurIndex))
        {
            //
            // Failed to delete the item
            //
            dwRes = ERROR_GEN_FAILURE;
            refCtrl.SetRedraw (TRUE);
            CALL_FAIL (RESOURCE_ERR, TEXT("CListCtrl::DeleteItem"), dwRes);
            return dwRes;
        }
        dwRes = AddSortedItem (row, lparamItemData);
        if (ERROR_SUCCESS != dwRes)
        {
            CALL_FAIL (RESOURCE_ERR, TEXT("AddSortedItem"), dwRes);
            refCtrl.SetRedraw (TRUE);
            return dwRes;
        }
        if (bItemSelected)
        {
            //
            // Since the item we removed was selected, we must also selected the new item
            // we just added.
            // Recalculate the possible operations the user can do on selected item.
            //
            Select (iCurIndex, TRUE);
            RecalcPossibleOperations ();
        }
        refCtrl.SetRedraw (TRUE);
    }

    ASSERTION (ERROR_SUCCESS == dwRes);
    return dwRes;
}   // CFolderListView::UpdateSortedItem


DWORD 
CFolderListView::ConfirmItemDelete(
    BOOL& bConfirm
)
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CFolderListView::ConfirmItemDelete"), dwRes);

    //
    // do we should ask to confirm ?
    //
    BOOL bAsk = theApp.GetProfileInt(CLIENT_CONFIRM_SEC, CLIENT_CONFIRM_ITEM_DEL, 1);
    if(!bAsk)
    {
        bConfirm = TRUE;
        return dwRes;
    }

    CListCtrl &refCtrl = GetListCtrl();
    DWORD dwSelected = refCtrl.GetSelectedCount();
    ASSERTION (dwSelected > 0);

    //
    // prepare message string
    //
    CString cstrMsg;
    if(1 == dwSelected)
    {
        dwRes = LoadResourceString(cstrMsg, IDS_SURE_DELETE_ONE);
        if (ERROR_SUCCESS != dwRes)
        {
            CALL_FAIL (RESOURCE_ERR, TEXT("LoadResourceString"), dwRes);
            return dwRes;
        }
    }
    else 
    {
        //
        // more then 1 selected
        //
        CString cstrCount;
        try
        {
            cstrCount.Format(TEXT("%d"), dwSelected);
        }
        catch(...)
        {
            dwRes = ERROR_NOT_ENOUGH_MEMORY;
            CALL_FAIL (MEM_ERR, TEXT("CString::Format"), dwRes);
            return dwRes;
        }

        try
        {
            AfxFormatString1(cstrMsg, IDS_SURE_DELETE_MANY, cstrCount);
        }
        catch(...)
        {
            dwRes = ERROR_NOT_ENOUGH_MEMORY;
            CALL_FAIL (MEM_ERR, TEXT("AfxFormatString1"), dwRes);
            return dwRes;
        }
    }

    //
    // are you sure ?
    //
    DWORD dwAskRes = AlignedAfxMessageBox(cstrMsg, MB_YESNO | MB_ICONQUESTION); 
    bConfirm = (IDYES == dwAskRes);

    return dwRes;

} // CFolderListView::ConfirmItemDelete


void 
CFolderListView::OnDblClk(
    NMHDR* pNMHDR, 
    LRESULT* pResult
) 
{
    DWORD nItem = ((NM_LISTVIEW*)pNMHDR)->iItem;

    CListCtrl &refCtrl = GetListCtrl();
    DWORD dwSelected = refCtrl.GetSelectedCount();
    DWORD dwSelItem  = refCtrl.GetNextItem (-1, LVNI_SELECTED);
    
    if(1 == dwSelected && dwSelItem == nItem)
    {
        OnFolderItemView();
    }

    *pResult = 0;
}


DWORD 
CFolderListView::FetchTiff (
    CString &cstrTiff
)
/*++

Routine name : CFolderListView::FetchTiff

Routine description:

    Fetches the TIFF image of the selected list item

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    cstrTiff  [out]    - Name of local TIFF file

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CFolderListView::FetchTiff"), dwRes);
    //
    // Make sure there's exaclty one elemented selected
    //
    CListCtrl &refCtrl = GetListCtrl();
    if (1 != refCtrl.GetSelectedCount())
	{
		return ERROR_CANTOPEN;
	}

    int iInd = refCtrl.GetNextItem (-1, LVNI_SELECTED);
    if (0 > iInd)
	{
		return ERROR_CANTOPEN;
	}

    CFaxMsg *pMsg = (CFaxMsg *) refCtrl.GetItemData (iInd);
	if (pMsg == NULL)
	{
		return ERROR_CANTOPEN;
	}

    //
    // Ask message to fetch the TIFF
    //
    dwRes = pMsg->GetTiff (cstrTiff);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (RPC_ERR, TEXT("CFaxMsg::GetTIFF"), dwRes);
    }
    return dwRes;

}   // CFolderListView::FetchTiff

void 
CFolderListView::OnFolderItemDelete ()
/*++

Routine name : CFolderListView::OnFolderItemDelete

Routine description:

    Handles message delete commands

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:


Return Value:

    None.

--*/
{
    BOOL bSomethingWasDeletedFromView = FALSE;
    DBG_ENTER(TEXT("CFolderListView::OnFolderItemDelete"),
              TEXT("Type=%d"),
              m_Type);

    //
    // are you sure ?
    //
    BOOL bConfirm;
    DWORD dwRes = ConfirmItemDelete(bConfirm);
    if (ERROR_SUCCESS != dwRes)
    {
        PopupError (dwRes);
        CALL_FAIL (GENERAL_ERR, TEXT("ConfirmItemDelete"), dwRes);
        return;
    }

    if(!bConfirm)
    {
        //
        // not sure.
        //
        return;
    }

    CWaitCursor waitCursor;
  
    CClientConsoleDoc* pDoc = GetDocument();
    ASSERTION (pDoc);

    CServerNode* pServer = NULL;
    CFolder*     pFolder = NULL;

    //
    // Iterate set of selected messages, deleting each message in the set
    //
    CListCtrl &refCtrl = GetListCtrl();
    DWORD dwSelected = refCtrl.GetSelectedCount();
    if(0 == dwSelected)
    {
        return;
    }

    if (dwSelected > MAX_ITEMS_TO_DELETE_WITH_REFRESH)
    {
        //
        // Disable refresh while deleting
        //
        refCtrl.SetRedraw (FALSE);
        //
        // Prevent costy re-calc on every deletion
        //
        m_bInMultiItemsOperation = TRUE;
    }
    int iInd;
    CFaxMsg* pMsg;
    DWORDLONG dwlMsgId;
    for (DWORD dwItem = 0; dwItem < dwSelected; dwItem++)
    {
        iInd = refCtrl.GetNextItem (-1, LVNI_SELECTED);
        ASSERTION (0 <= iInd);
        
        pMsg = (CFaxMsg *) refCtrl.GetItemData (iInd);
        ASSERTION (pMsg);

        dwlMsgId = pMsg->GetId();
        //
        // Ask message to delete
        //
        dwRes = pMsg->Delete ();
        if (ERROR_SUCCESS != dwRes)
        {
            PopupError (dwRes);
            CALL_FAIL (RPC_ERR, TEXT("CArchiveMsg::Delete"), dwRes);
            //
            // We exit upon first error
            //
            goto exit;
        }
        //
        // delete a message from the data map and from the view
        //
        pServer = pMsg->GetServer();
        ASSERTION (pServer);

        pFolder = pServer->GetFolder(m_Type);
        ASSERTION (pFolder);

        dwRes = pFolder->OnJobRemoved(dwlMsgId, pMsg);
        if (ERROR_SUCCESS != dwRes)
        {
            PopupError (dwRes);
            CALL_FAIL (RPC_ERR, TEXT("CMessageFolder::OnJobRemoved"), dwRes);
            goto exit;
        }
        bSomethingWasDeletedFromView = TRUE;
    }

exit:
    if (dwSelected > MAX_ITEMS_TO_DELETE_WITH_REFRESH)
    {
        //
        // Re-enable redraw
        //
        refCtrl.SetRedraw (TRUE);
        if (bSomethingWasDeletedFromView)
        {
            //
            // Ask for visual refresh of view
            //
            refCtrl.Invalidate ();
        }
        m_bInMultiItemsOperation = FALSE;
        RecalcPossibleOperations ();    
    }
    if(FOLDER_TYPE_INBOX == m_Type)
    {
        theApp.InboxViewed();
    }

}   // CFolderListView::OnFolderItemDelete

void 
CFolderListView::CountColumns (
    int *lpItems
)
/*++

Routine name : CFolderListView::CountColumns

Routine description:

    Sets the items to be seen in the view.

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    lpItems         [in] - List of items. ends with MSG_VIEW_ITEM_END

Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CFolderListView::CountColumns"));
    m_dwAvailableColumnsNum = 0;
    MsgViewItemType *pItems = (MsgViewItemType *)lpItems;
    m_pAvailableColumns = pItems;
    while (MSG_VIEW_ITEM_END != *pItems)
    {
        ASSERTION (*pItems < MSG_VIEW_ITEM_END);
        ++m_dwAvailableColumnsNum;
        ++pItems;
    }
    ASSERTION (m_dwAvailableColumnsNum);
}   // CFolderListView::CountColumns

int 
CFolderListView::CompareItems (
    CFaxMsg* pFaxMsg1, 
    CFaxMsg* pFaxMsg2,
    DWORD dwItemIndex
) const
/*++

Routine name : CFolderListView::CompareItems

Routine description:

    Compares two archive items

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    pFaxMsg1        [in] - Pointer to 1st message
    pFaxMsg2        [in] - Pointer to 2nd message
    dwItemIndex     [in] - Item (in the message) to comapre by

Return Value:

    -1 if message1 < message2, 0 if identical, +1 if message1 > message2

--*/
{
    DBG_ENTER(TEXT("CFolderListView::CompareItems"));

    ASSERTION (dwItemIndex < MSG_VIEW_ITEM_END);
    static CViewRow rowView1;
    static CViewRow rowView2;
    DWORD dwRes = rowView1.AttachToMsg (pFaxMsg1, FALSE);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("CViewRow::AttachToMsg"), dwRes);
        return 0;
    }
    dwRes = rowView2.AttachToMsg (pFaxMsg2, FALSE);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("CViewRow::AttachToMsg"), dwRes);
        return 0;
    }

    return rowView1.CompareByItem (rowView2, dwItemIndex);
}

DWORD 
CFolderListView::AddMsgMapToView(
    MSGS_MAP* pMap
)
/*++

Routine name : CFolderListView::AddMsgMapToView

Routine description:

    Add messages from the map to the view

Arguments:

    pMap        [in] - masage map

Return Value:

    error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CFolderListView::AddMsgMapToView"));

    ASSERTION(pMap);
    
    CListCtrl &listCtrl = GetListCtrl();
    DWORD dwCount = listCtrl.GetItemCount();

    listCtrl.SetRedraw (FALSE);

    CFaxMsg* pMsg;
    CViewRow viewRow;
    int iIndexToSelect = -1;
    for (MSGS_MAP::iterator it = pMap->begin(); it != pMap->end(); ++it)
    {
        int iItemIndex;

        pMsg = (*it).second;
        dwRes = viewRow.AttachToMsg (pMsg);
        if (ERROR_SUCCESS != dwRes)
        {
            CALL_FAIL (GENERAL_ERR, TEXT("CViewRow::AttachToMsg"), dwRes);
            break;
        }
        dwRes = AddItem (dwCount++, viewRow, (LPARAM)pMsg, &iItemIndex);
        if (ERROR_SUCCESS != dwRes)
        {
            CALL_FAIL (GENERAL_ERR, TEXT("CFolderListView::AddItem"), dwRes);
            break;
        }
        if ((-1 == iIndexToSelect)    &&            // No item selected yet and
            m_dwlMsgToSelect          &&            // We should keep our eyes open for an item to select and
            (pMsg->GetId () == m_dwlMsgToSelect))   // Match found !!
        {
            //
            // This is the startup selected item.
            // Save the item index
            //
            iIndexToSelect = iItemIndex;
        }    
    }
    if (-1 != iIndexToSelect)
    {
        //
        // We have the user-specified-item-to-select in the list now
        //
        SelectItemByIndex (iIndexToSelect);
    }
    listCtrl.SetRedraw ();
    return dwRes;
} // CFolderListView::AddMsgMapToView

void 
CFolderListView::OnUpdate (
    CView* pSender, 
    LPARAM lHint, 
    CObject* pHint 
)
/*++

Routine name : CFolderListView::OnUpdate

Routine description:

    Receives a notification that the view should update itself

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    pSender         [in] - Unused
    lHint           [in] - Hint of update operation
    pHint           [in] - If lHint is UPDATE_HINT_CLEAR_VIEW or UPDATE_HINT_FILL_VIEW
                           then pHint is a pointer to the folder that requested an update.

                           If lHint is UPDATE_HINT_REMOVE_ITEM, UPDATE_HINT_ADD_ITEM, or 
                           UPDATE_HINT_UPDATE_ITEM,
                           then pHint is a pointer to the job to remove / add / update.

                           Otherwise, pHint is undefined.

Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CFolderListView::OnUpdate"), 
              TEXT("Hint=%ld, Type=%d"), 
              lHint,
              m_Type);

    OnUpdateHintType hint = (OnUpdateHintType) lHint;

    DWORD dwRes;
    CListCtrl &listCtrl = GetListCtrl();
    switch (hint)
    {
        case UPDATE_HINT_CREATION:
            //
            // Do nothing
            //
            break;

        case UPDATE_HINT_CLEAR_VIEW:
            //
            // Clear the entire list control now
            //
            if (!listCtrl.DeleteAllItems ())
            {
                CALL_FAIL (WINDOW_ERR, TEXT("CListCtrl::DeleteAllItems"), ERROR_GEN_FAILURE);
            }
            ClearPossibleOperations ();
            break;

        case UPDATE_HINT_ADD_CHUNK:
            {
                ASSERTION (pHint);
                MSGS_MAP* pMap = (MSGS_MAP*) pHint;

                dwRes = AddMsgMapToView(pMap);
                if (ERROR_SUCCESS != dwRes)
                {
                    CALL_FAIL (GENERAL_ERR, TEXT("CFolderListView::AddMsgMapToView"), dwRes);
                }
            }
            break;

        case UPDATE_HINT_FILL_VIEW:
            //
            // Fill the list control with my parents data
            //
            {
                ASSERTION (pHint);
                CFolder *pFolder = (CFolder *) pHint;

                pFolder->EnterData ();
                MSGS_MAP &ParentMap = pFolder->GetData ();

                dwRes = AddMsgMapToView(&ParentMap);
                if (ERROR_SUCCESS != dwRes)
                {
                    CALL_FAIL (GENERAL_ERR, TEXT("CFolderListView::AddMsgMapToView"), dwRes);
                }

                pFolder->LeaveData ();
            }
            break;

        case UPDATE_HINT_REMOVE_ITEM:
            //
            // The data critical section must be held.
            //
            {
                CFaxMsg* pMsg = (CFaxMsg*)pHint;
                ASSERTION(pMsg);

                dwRes = RemoveItem ((LPARAM)pMsg);
                if (ERROR_SUCCESS != dwRes)
                {
                    //
                    // Failed to remove item from list
                    //
                    CALL_FAIL (GENERAL_ERR, TEXT("CFolderListView::RemoveItem"), dwRes);
                    ASSERTION_FAILURE;
                }
            }
            break;

        case UPDATE_HINT_ADD_ITEM:
            //
            // The data critical section must be held.
            //
            {
                CFaxMsg* pMsg = (CFaxMsg*)pHint;
                ASSERTION(pMsg);

                CViewRow viewRow;
                dwRes = viewRow.AttachToMsg (pMsg);
                if (ERROR_SUCCESS != dwRes)
                {
                    CALL_FAIL (GENERAL_ERR, TEXT("CViewRow::AttachToMsg"), dwRes);
                    return;
                }
                dwRes = AddSortedItem (viewRow, (LPARAM)pMsg);
                if (ERROR_SUCCESS != dwRes)
                {
                    CALL_FAIL (GENERAL_ERR, TEXT("CFolderListView::AddSortedItem"), dwRes);
                    return;
                }
            }
            break;

        case UPDATE_HINT_UPDATE_ITEM:
            //
            // The data critical section must be held.
            //
            {
                CFaxMsg* pMsg = (CFaxMsg*)pHint;
                ASSERTION(pMsg);

                CViewRow viewRow;
                dwRes = viewRow.AttachToMsg (pMsg);
                if (ERROR_SUCCESS != dwRes)
                {
                    CALL_FAIL (GENERAL_ERR, TEXT("CViewRow::AttachToMsg"), dwRes);
                    return;
                }
                dwRes = UpdateSortedItem (viewRow, (LPARAM)pMsg);
                if (ERROR_SUCCESS != dwRes)
                {
                    CALL_FAIL (GENERAL_ERR, TEXT("CFolderListView::UpdateSortedItem"), dwRes);
                    return;
                }
            }
            break;

        default:
            //
            // Unsupported hint
            //
            ASSERTION_FAILURE;
    }

    RecalcPossibleOperations ();

    CMainFrame *pFrm = GetFrm();
    if (!pFrm)
    {
        //
        //  Shutdown in progress
        //
    }
    else
    {
        pFrm->RefreshStatusBar ();
    }

}   // CFolderListView::OnUpdate

int 
CFolderListView::GetPopupMenuResource () const
{
    DBG_ENTER(TEXT("CFolderListView::GetPopupMenuResource"));

    int nMenuRes=0;

    switch(m_Type)
    {
    case FOLDER_TYPE_INCOMING:
        nMenuRes = IDM_INCOMING;
        break;
    case FOLDER_TYPE_INBOX:
        nMenuRes = IDM_INBOX;
        break;
    case FOLDER_TYPE_SENT_ITEMS:
        nMenuRes = IDM_SENTITEMS;
        break;
    case FOLDER_TYPE_OUTBOX:
        nMenuRes = IDM_OUTBOX;
        break;
    default:
        ASSERTION_FAILURE
        break;
    }

    return nMenuRes;
}

void 
CFolderListView::OnFolderItemPause ()
/*++

Routine name : CFolderListView::OnFolderItemPause

Routine description:

    Handles job pause commands

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:


Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CFolderListView::OnFolderItemPause"),
              TEXT("Type=%d"),
              m_Type);

    //
    // Iterate set of selected jobs, pausing each job in the set
    //
    CListCtrl &refCtrl = GetListCtrl();
    DWORD dwSelected = refCtrl.GetSelectedCount();
    ASSERTION (dwSelected);

    int iInd = -1;
    for (DWORD dwItem = 0; dwItem < dwSelected; dwItem++)
    {
        iInd = refCtrl.GetNextItem (iInd, LVNI_SELECTED);
        ASSERTION (0 <= iInd);
        CFaxMsg* pJob = (CFaxMsg*) refCtrl.GetItemData (iInd);
        ASSERT_KINDOF(CJob, pJob);
        //
        // Ask job to pause
        //
        DWORD dwRes = pJob->Pause ();
        if (ERROR_SUCCESS != dwRes)
        {
            PopupError (dwRes);
            CALL_FAIL (RPC_ERR, TEXT("CJob::Pause"), dwRes);
            //
            // We exit upon first error
            //
            return;
        }
        else
        {
            //
            // TODO: Update new job state without waiting for a notification
            //
        }
    }
}   // CFolderListView::OnFolderItemPause

void CFolderListView::OnFolderItemResume ()
/*++

Routine name : CFolderListView::OnFolderItemResume

Routine description:

    Handles job resume commands

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:


Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CFolderListView::OnFolderItemResume"),
              TEXT("Type=%d"),
              m_Type);

    //
    // Iterate set of selected jobs, resuming each job in the set
    //
    CListCtrl &refCtrl = GetListCtrl();
    DWORD dwSelected = refCtrl.GetSelectedCount();
    ASSERTION (dwSelected);
    int iInd = -1;
    for (DWORD dwItem = 0; dwItem < dwSelected; dwItem++)
    {
        iInd = refCtrl.GetNextItem (iInd, LVNI_SELECTED);
        ASSERTION (0 <= iInd);
        CFaxMsg* pJob = (CFaxMsg*) refCtrl.GetItemData (iInd);
        ASSERT_KINDOF(CJob, pJob);
        //
        // Ask job to resume
        //
        DWORD dwRes = pJob->Resume ();
        if (ERROR_SUCCESS != dwRes)
        {
            PopupError (dwRes);
            CALL_FAIL (RPC_ERR, TEXT("CJob::Resume"), dwRes);
            //
            // We exit upon first error
            //
            return;
        }
        else
        {
            //
            // TODO: Update new job state without waiting for a notification
            //
        }
    }
}   // CFolderListView::OnFolderItemResume

void 
CFolderListView::OnFolderItemRestart ()
/*++

Routine name : CFolderListView::OnFolderItemRestart

Routine description:

    Handles job restart commands

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:


Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CFolderListView::OnFolderItemRestart"),
              TEXT("Type=%d"),
              m_Type);

    //
    // Iterate set of selected jobs, restarting each job in the set
    //
    CListCtrl &refCtrl = GetListCtrl();
    DWORD dwSelected = refCtrl.GetSelectedCount();
    ASSERTION (dwSelected);
    int iInd = -1;
    for (DWORD dwItem = 0; dwItem < dwSelected; dwItem++)
    {
        iInd = refCtrl.GetNextItem (iInd, LVNI_SELECTED);
        ASSERTION (0 <= iInd);
        CFaxMsg* pJob = (CFaxMsg*) refCtrl.GetItemData (iInd);
        ASSERT_KINDOF(CJob, pJob);
        //
        // Ask job to restart
        //
        DWORD dwRes = pJob->Restart ();
        if (ERROR_SUCCESS != dwRes)
        {
            PopupError (dwRes);
            CALL_FAIL (RPC_ERR, TEXT("CJob::Restart"), dwRes);
            //
            // We exit upon first error
            //
            return;
        }
        else
        {
            //
            // TODO: Update new job state without waiting for a notification
            //
        }
    }
}   // CFolderListView::OnFolderItemRestart


void 
CFolderListView::OnChar( 
    UINT nChar, 
    UINT nRepCnt, 
    UINT nFlags 
)
/*++

Routine name : CFolderListView::OnChar

Routine description:

    The framework calls this member function when a keystroke translates 
    to a nonsystem character

Arguments:

  nChar     [in] - Contains the character code value of the key.
  nRepCnt   [in] - Contains the repeat count
  nFlags    [in] - Contains the scan code

Return Value:

    None.

--*/
{
    if(VK_TAB == nChar)
    {
        CMainFrame *pFrm = GetFrm();
        if (!pFrm)
        {
            //
            //  Shutdown in progress
            //
            return;
        }

        CLeftView* pLeftView = pFrm->GetLeftView();
        if(pLeftView)
        {
            pLeftView->SetFocus();
        }
    }
    else
    {
        CListView::OnChar(nChar, nRepCnt, nFlags);
    }
}

afx_msg void 
CFolderListView::OnContextMenu(
    CWnd *pWnd, 
    CPoint pos
)
{
    DBG_ENTER(TEXT("CFolderListView::OnContextMenu"),
              TEXT("Type=%d"),
              m_Type);

    CListCtrl &refCtrl = GetListCtrl();
    DWORD dwSelected = refCtrl.GetSelectedCount();

    if (!dwSelected)
    {
        //
        // If no item is selected, this is equivalent to right-clicking an empty area in the list view
        // which does nothing.
        //
        return;
    }

    if (pos.x == -1 && pos.y == -1)
    {
        //
        // Keyboard (VK_APP or Shift + F10)
        //
        //
        // Pop the context menu near the mouse cursor
        //
        pos = (CPoint) GetMessagePos();
    }

    int iMenuResource = GetPopupMenuResource ();
    if(0 == iMenuResource)
    {
        ASSERTION_FAILURE;
        return;
    }

    ScreenToClient(&pos);

    CMenu mnuContainer;
    if (!mnuContainer.LoadMenu (iMenuResource))
    {
        CALL_FAIL (RESOURCE_ERR, TEXT("CMenu::LoadMenu"), ERROR_GEN_FAILURE);
        return;
    }
    CMenu *pmnuPopup = mnuContainer.GetSubMenu (0);
    ASSERTION (pmnuPopup);

    ClientToScreen(&pos);
    if (!pmnuPopup->TrackPopupMenu (TPM_LEFTALIGN, 
                                    pos.x, 
                                    pos.y, 
                                    theApp.m_pMainWnd))
    {
        CALL_FAIL (RESOURCE_ERR, TEXT("CMenu::TrackPopupMenu"), ERROR_GEN_FAILURE);
    }
}   // CFolderListView::OnContextMenu

void 
CFolderListView::SelectItemById (
    DWORDLONG dwlMsgId
)
/*++

Routine name : CFolderListView::SelectItemById

Routine description:

	Selects an item in the list control, by its message id

Author:

	Eran Yariv (EranY),	May, 2001

Arguments:

	dwlMsgId       [in]     - Message id

Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CFolderListView::SelectItemById"),
              TEXT("Message id=%0xI64d"),
              dwlMsgId);

    ASSERTION (dwlMsgId);

    int iMsgIndex = FindItemIndexFromID (dwlMsgId);
    if (-1 == iMsgIndex)
    {
        //
        // Message could not be found in the list.
        // This usually happens when we handle a WM_CONSOLE_SELECT_ITEM message sent to the main frame
        // but the folder is in the middle of refresh and the requested message might not be there yet.
        //
        // By setting m_dwlMsgToSelect = dwlMsgId we signal the OnFolderRefreshEnded() funtion to call us again
        // once refresh has ended.
        //
        VERBOSE (DBG_MSG, TEXT("Item not found - doing nothing"));
        m_dwlMsgToSelect = dwlMsgId;
        return;
    }
    SelectItemByIndex (iMsgIndex);
}   // CFolderListView::SelectItemById

void 
CFolderListView::SelectItemByIndex (
    int iMsgIndex
)
/*++

Routine name : CFolderListView::SelectItemByIndex

Routine description:

	Selects an item in the list control, by its list item index

Author:

	Eran Yariv (EranY),	May, 2001

Arguments:

	dwlMsgId       [in]     - List item index

Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CFolderListView::SelectItemByIndex"),
              TEXT("Index = %ld"),
              iMsgIndex);


    CListCtrl &refCtrl = GetListCtrl();
    ASSERTION (iMsgIndex >= 0 && iMsgIndex < refCtrl.GetItemCount());

    OnSelectNone();
    refCtrl.SetItemState (iMsgIndex, 
                          LVIS_SELECTED | LVIS_FOCUSED,
                          LVIS_SELECTED | LVIS_FOCUSED);
    refCtrl.EnsureVisible (iMsgIndex, FALSE);
    refCtrl.SetFocus();
    //
    // Make sure this item won't be selected again
    //
    m_dwlMsgToSelect = 0;
}   // CFolderListView::SelectItemByIndex

int  
CFolderListView::FindItemIndexFromID (
    DWORDLONG dwlMsgId
)
/*++

Routine name : CFolderListView::FindItemIndexFromID

Routine description:

	Finds the list view item index of a message by a message id

Author:

	Eran Yariv (EranY),	May, 2001

Arguments:

	dwlMsgId     [in]     - Message id

Return Value:

    Item index. -1 if not found

--*/
{
    DBG_ENTER(TEXT("CFolderListView::FindItemIndexFromID"),
              TEXT("Message id=%0xI64d"),
              dwlMsgId);

    CListCtrl &refCtrl = GetListCtrl();
    int iItemCount = refCtrl.GetItemCount();
    //
    // We must traverse the entire list and look for the message that matches the id.
    //
    for (int iIndex = 0; iIndex < iItemCount; iIndex++)
    {
        CFaxMsg *pMsg = (CFaxMsg*)refCtrl.GetItemData (iIndex);
        if (dwlMsgId == pMsg->GetId())
        {
            //
            // Found it
            //
            return iIndex;
        }
    }
    return -1;
}   // CFolderListView::FindItemIndexFromID
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\inboxdetailspg.h ===
#if !defined(AFX_INBOXDETAILSPG_H__B7AA6069_11CD_4BE2_AFC5_A9C5E9B79CE5__INCLUDED_)
#define AFX_INBOXDETAILSPG_H__B7AA6069_11CD_4BE2_AFC5_A9C5E9B79CE5__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// InboxDetailsPg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CInboxDetailsPg dialog

class CInboxDetailsPg : public CMsgPropertyPg
{
	DECLARE_DYNCREATE(CInboxDetailsPg)

// Construction
public:
	CInboxDetailsPg(CFaxMsg* pMsg);
	~CInboxDetailsPg();

// Dialog Data
	//{{AFX_DATA(CInboxDetailsPg)
	enum { IDD = IDD_INBOX_DETAILS };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CInboxDetailsPg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
private:
    CInboxDetailsPg() {}

protected:
	// Generated message map functions
	//{{AFX_MSG(CInboxDetailsPg)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_INBOXDETAILSPG_H__B7AA6069_11CD_4BE2_AFC5_A9C5E9B79CE5__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\inboxgeneralpg.cpp ===
// InboxGeneralPg.cpp : implementation file
//

#include "stdafx.h"

#define __FILE_ID__     40

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// this array maps CViewRow items to 
// dialog control IDs
//
static TMsgPageInfo s_PageInfo[] = 
{
    MSG_VIEW_ITEM_STATUS,                   IDC_STATUS_VALUE,
    MSG_VIEW_ITEM_NUM_PAGES,                IDC_PAGES_VALUE,
    MSG_VIEW_ITEM_SIZE,                     IDC_SIZE_VALUE,
    MSG_VIEW_ITEM_TRANSMISSION_START_TIME,  IDC_START_TIME_VALUE,
    MSG_VIEW_ITEM_TRANSMISSION_END_TIME,    IDC_END_TIME_VALUE,
    MSG_VIEW_ITEM_TRANSMISSION_DURATION,    IDC_DURATION_VALUE
};

/////////////////////////////////////////////////////////////////////////////
// CInboxGeneralPg property page

IMPLEMENT_DYNCREATE(CInboxGeneralPg, CMsgPropertyPg)

CInboxGeneralPg::CInboxGeneralPg(
    CFaxMsg* pMsg     // pointer to CArchiveMsg
): 
    CMsgPropertyPg(CInboxGeneralPg::IDD, pMsg)
{
}

CInboxGeneralPg::~CInboxGeneralPg()
{
}

void CInboxGeneralPg::DoDataExchange(CDataExchange* pDX)
{
	CMsgPropertyPg::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CInboxGeneralPg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CInboxGeneralPg, CMsgPropertyPg)
	//{{AFX_MSG_MAP(CInboxGeneralPg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CInboxGeneralPg message handlers

BOOL 
CInboxGeneralPg::OnInitDialog() 
{
    DBG_ENTER(TEXT("CInboxGeneralPg::OnInitDialog"));

    CMsgPropertyPg::OnInitDialog();

    Refresh(s_PageInfo, sizeof(s_PageInfo)/sizeof(s_PageInfo[0]));
	
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\folderlistview.h ===
#if !defined(AFX_FOLDERLISTVIEW_H__D4D73C95_2B20_4A68_8B87_9DA4512F77C9__INCLUDED_)
#define AFX_FOLDERLISTVIEW_H__D4D73C95_2B20_4A68_8B87_9DA4512F77C9__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// FolderListView.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CFolderListView view

typedef enum
{
    UPDATE_HINT_CREATION,       // Sent by the framework upon creation
    UPDATE_HINT_CLEAR_VIEW,     // Clear entire list in view
    UPDATE_HINT_FILL_VIEW,      // Repopulate entire list in view
    UPDATE_HINT_REMOVE_ITEM,    // Remove a single item from the view.
                                // The item to remove is pointed by pHint
    UPDATE_HINT_ADD_ITEM,       // Add a single item from the view.
                                // The item to add is pointed by pHint
    UPDATE_HINT_UPDATE_ITEM,    // Update text for a single item from the view.
                                // The item to update is pointed by pHint
    UPDATE_HINT_ADD_CHUNK       // Add a chunk of messages to the view
} OnUpdateHintType;


struct TViewColumnInfo
{
	BOOL  bShow;	// FALSE if column hidden
	int   nWidth;	// column width
	DWORD dwOrder;	// column number in list control
};

//
// The WM_FOLDER_REFRESH_ENDED is sent by the thread in CFolder when it
// finishes to rebuild the list of items in the folder and wishes to 
// update the dislpay.
//
// lParam = Pointer to the CFolder that sent the message.
// wParam = Last Win32 error code returnd by the enumeration thread.
//
#define WM_FOLDER_REFRESH_ENDED         WM_APP + 1
#define WM_FOLDER_ADD_CHUNK             WM_APP + 2

extern CClientConsoleApp theApp;

class CFolderListView : public CListView
{
public:
    CFolderListView () : 
        m_bSorting(FALSE),
        m_dwPossibleOperationsOnSelectedItems (0),
        m_bColumnsInitialized (FALSE),
        m_nSortedCol (-1),   // Start unsorted
		m_dwDisplayedColumns(0),
		m_pViewColumnInfo(NULL),
		m_pnColumnsOrder(NULL),
        m_Type((FolderType)-1),
        m_bInMultiItemsOperation(FALSE),
        m_dwDefaultColNum(8),
        m_dwlMsgToSelect (theApp.GetMessageIdToSelect())
    {}

    void SetType(FolderType type) { m_Type = type; }
    FolderType GetType() { return m_Type; }

    void SelectItemById (DWORDLONG dwlMsgId);
    void SelectItemByIndex (int iMsgIndex);

    int  FindItemIndexFromID (DWORDLONG dwlMsgId);

    CClientConsoleDoc* GetDocument();

    DECLARE_DYNCREATE(CFolderListView)

    BOOL Sorting() const  { return m_bSorting; }

    DWORD RefreshImageLists (BOOL bForce);

    DWORD InitColumns (int *pColumnsUsed, DWORD dwDefaultColNum); 
    void  AutoFitColumns ();

	void DoSort();

	DWORD ReadLayout(LPCTSTR lpszViewName);
	DWORD SaveLayout(LPCTSTR lpszViewName);
	DWORD ColumnsToLayout();

	DWORD OpenSelectColumnsDlg();

    BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);

    void OnUpdate (CView* pSender, LPARAM lHint, CObject* pHint );

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CClientConsoleView)
	public:
	void OnDraw(CDC* pDC);  // overridden to draw this view
	BOOL PreCreateWindow(CREATESTRUCT& cs);
	protected:
	void OnInitialUpdate(); // called first time after construct
	BOOL OnNotify( WPARAM wParam, LPARAM lParam, LRESULT* pResult );
	//}}AFX_VIRTUAL

// Implementation

protected:
	virtual ~CFolderListView() 
	{
		SAFE_DELETE_ARRAY(m_pViewColumnInfo);
		SAFE_DELETE_ARRAY(m_pnColumnsOrder);
	}

#ifdef _DEBUG
    void AssertValid() const;
    void Dump(CDumpContext& dc) const;
#endif

    DWORD RemoveItem (LPARAM lparam, int iItem = -1);
    DWORD AddItem (DWORD dwLineIndex, CViewRow &row, LPARAM lparamItemData, PINT);
    DWORD UpdateLineTextAndIcon (DWORD dwLineIndex, CViewRow &row);
    DWORD AddSortedItem (CViewRow &row, LPARAM lparamItemData);
    DWORD UpdateSortedItem (CViewRow &row, LPARAM lparamItemData);

    // Generated message map functions
protected:
    //{{AFX_MSG(CFolderListView)
    afx_msg void OnColumnClick(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnItemRightClick(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnItemChanged(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnContextMenu(CWnd *pWnd, CPoint pos);
    afx_msg void OnUpdateSelectAll (CCmdUI* pCmdUI)
        { 
            CListCtrl &refCtrl = GetListCtrl();
            pCmdUI->Enable (refCtrl.GetSelectedCount () < refCtrl.GetItemCount()); 
        }

    afx_msg void OnUpdateSelectNone (CCmdUI* pCmdUI)
        { pCmdUI->Enable (GetListCtrl().GetSelectedCount () > 0); }

    afx_msg void OnUpdateSelectInvert (CCmdUI* pCmdUI)
        { pCmdUI->Enable (GetListCtrl().GetItemCount() > 0); }

    afx_msg void OnSelectAll ();
    afx_msg void OnSelectNone ();
    afx_msg void OnSelectInvert ();

    afx_msg void OnFolderItemView ();
    afx_msg void OnFolderItemPrint ();
    afx_msg void OnFolderItemCopy ();
    afx_msg void OnFolderItemMail ();
    afx_msg void OnFolderItemProperties ();

    afx_msg void OnFolderItemPause ();
    afx_msg void OnFolderItemResume ();
    afx_msg void OnFolderItemRestart ();

	afx_msg void OnFolderItemDelete();
  	afx_msg void OnDblClk(NMHDR* pNMHDR, LRESULT* pResult);

    afx_msg void OnUpdateFolderItemView (CCmdUI* pCmdUI);
	afx_msg void OnUpdateFolderItemSendMail(CCmdUI* pCmdUI);
	afx_msg void OnUpdateFolderItemPrint(CCmdUI* pCmdUI);
	afx_msg void OnUpdateFolderItemCopy(CCmdUI* pCmdUI);

    afx_msg void OnChar(UINT nChar, UINT nRepCnt, UINT nFlags);
    afx_msg void OnUpdateFolderItemProperties (CCmdUI* pCmdUI)
        { pCmdUI->Enable (m_dwPossibleOperationsOnSelectedItems & FAX_JOB_OP_PROPERTIES); }

    afx_msg void OnUpdateFolderItemDelete (CCmdUI* pCmdUI)
        { pCmdUI->Enable (m_dwPossibleOperationsOnSelectedItems & FAX_JOB_OP_DELETE); }

    afx_msg void OnUpdateFolderItemPause (CCmdUI* pCmdUI)
        { pCmdUI->Enable (m_dwPossibleOperationsOnSelectedItems & FAX_JOB_OP_PAUSE); }

    afx_msg void OnUpdateFolderItemResume (CCmdUI* pCmdUI)
        { pCmdUI->Enable (m_dwPossibleOperationsOnSelectedItems & FAX_JOB_OP_RESUME); }

    afx_msg void OnUpdateFolderItemRestart (CCmdUI* pCmdUI)
        { pCmdUI->Enable (m_dwPossibleOperationsOnSelectedItems & FAX_JOB_OP_RESTART); }

    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    void RecalcPossibleOperations ();

protected:

    FolderType m_Type;          // Type of this folder

    DWORD     m_dwPossibleOperationsOnSelectedItems;  // Operation available on 
                                                      // the set of selected items

    MsgViewItemType* m_pAvailableColumns;    // List of columns to use 
    DWORD  m_dwAvailableColumnsNum;  // Size of the m_pAvailableColumns list

    
    //
    // The following functions should be overriden by derived classes
    //
    DWORD ItemIndexFromLogicalColumnIndex(DWORD dwColIndex) const
        {
            ASSERT (dwColIndex < GetLogicalColumnsCount ());
            return m_pAvailableColumns[dwColIndex];
        }

    DWORD GetColumnHeaderString (CString &cstrRes, DWORD dwItemIndex) const
        {
            ASSERT (dwItemIndex < MSG_VIEW_ITEM_END);
            return CViewRow::GetItemTitle (dwItemIndex, cstrRes);
        }

    int GetColumnHeaderAlignment (DWORD dwItemIndex) const
        {
            ASSERT (dwItemIndex < MSG_VIEW_ITEM_END);
            return CViewRow::GetItemAlignment (dwItemIndex);
        }

    DWORD GetLogicalColumnsCount () const
        { 
            ASSERT (m_dwAvailableColumnsNum); 
            return m_dwAvailableColumnsNum; 
        }

    DWORD GetItemOperations (LPARAM lp) const
        {
            ASSERT (lp);
            return ((CFaxMsg*)(lp))->GetPossibleOperations ();
        }

    BOOL  IsItemIcon(DWORD dwItemIndex) const
        {
            ASSERT (dwItemIndex < MSG_VIEW_ITEM_END);
            return CViewRow::IsItemIcon (dwItemIndex);
        }

    int GetPopupMenuResource () const;

    void  CountColumns (int *pColumnsUsed);
    DWORD FetchTiff (CString &cstrTiff);

    int GetEmptyAreaPopupMenuRes() { return 0; }

    DWORD ConfirmItemDelete(BOOL& bConfirm);

    afx_msg LRESULT OnFolderRefreshEnded (WPARAM, LPARAM);
    afx_msg LRESULT OnFolderAddChunk (WPARAM, LPARAM);

    void ClearPossibleOperations ()
        { m_dwPossibleOperationsOnSelectedItems = 0; }

private:

    BOOL            m_bSorting;             // Are we sorting now?

    BOOL            m_bColumnsInitialized;  // Did we init the columns?
    CSortHeader     m_HeaderCtrl;           // Our custom header control
    int             m_nSortedCol;           // Column to sort by
    BOOL            m_bSortAscending;       // Sort order

    static CFolderListView    *m_psCurrentViewBeingSorted;  // Pointer to view that gets sorted.
	DWORD			m_dwDisplayedColumns;

	TViewColumnInfo*	m_pViewColumnInfo;
	int*				m_pnColumnsOrder;

    static int CALLBACK ListViewItemsCompareProc (
        LPARAM lParam1, 
        LPARAM lParam2, 
        LPARAM lParamSort);

    int CompareListItems (CFaxMsg* pFaxMsg1, CFaxMsg* pFaxMsg2);
    int CompareItems (CFaxMsg* pFaxMsg1, CFaxMsg* pFaxMsg2, DWORD dwItemIndex) const;

    DWORD FindInsertionIndex (LPARAM lparamItemData, DWORD &dwResultIndex);
    DWORD BooleanSearchInsertionPoint (
        DWORD dwTopIndex,
        DWORD dwBottomIndex,
        LPARAM lparamItemData,
        DWORD dwItemIndex,
        DWORD &dwResultIndex
    );

    //
    // List items selection
    //
    BOOL IsSelected (int iItem);
    void Select     (int iItem, BOOL bSelect);

    DWORD GetServerPossibleOperations (CFaxMsg* pMsg);// Get operations possible on items according 
                                                      // to server's security configuration.

    DWORD AddMsgMapToView(MSGS_MAP* pMap);

    BOOL  m_bInMultiItemsOperation;                   // Are we performing a long operation on many items?

    DWORD m_dwDefaultColNum;                          // Default column number

    DWORDLONG m_dwlMsgToSelect;                       // Message id to select when the folder refresh has ended

public:
    static CImageList m_sReportIcons;   // The list of images that act as icons
                                        // in the right pane (report views).
                                        // This image list is shared among all views.

    static CImageList m_sImgListDocIcon;  // Image list (with only one image) for the icon in the header control (icon column)
};

#ifndef _DEBUG  // debug version in ClientConsoleView.cpp
inline CClientConsoleDoc* CFolderListView::GetDocument()
   { return (CClientConsoleDoc*)m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_FOLDERLISTVIEW_H__D4D73C95_2B20_4A68_8B87_9DA4512F77C9__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\inboxgeneralpg.h ===
#if !defined(AFX_INBOXGENERALPG_H__B7AA6069_11CD_4BE2_AFC5_A9C5E9B79CE5__INCLUDED_)
#define AFX_INBOXGENERALPG_H__B7AA6069_11CD_4BE2_AFC5_A9C5E9B79CE5__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// InboxGeneralPg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CInboxGeneralPg dialog

class CInboxGeneralPg : public CMsgPropertyPg
{
	DECLARE_DYNCREATE(CInboxGeneralPg)

// Construction
public:
	CInboxGeneralPg(CFaxMsg* pMsg);
	~CInboxGeneralPg();

// Dialog Data
	//{{AFX_DATA(CInboxGeneralPg)
	enum { IDD = IDD_INBOX_GENERAL };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CInboxGeneralPg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
private:
    CInboxGeneralPg() {}

protected:
	// Generated message map functions
	//{{AFX_MSG(CInboxGeneralPg)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_INBOXGENERALPG_H__B7AA6069_11CD_4BE2_AFC5_A9C5E9B79CE5__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\import.cpp ===
//////////////////////////////////////////////////////////////////////////////////////
// W2K TIF files import support
//

#include "stdafx.h"
#include <tiff.h>
#include <Sddl.h>
#include <shlobjp.h> // LinkWindow control

#define __FILE_ID__     75

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#ifdef UNICODE

#define WM_IMPORT_PROGRESS_INC     WM_APP + 3 // Increment Import progress bar
#define WM_IMPORT_SET_FILE_COUNT   WM_APP + 4 // Set the file number to import

extern CClientConsoleApp theApp;

//
// Structure passed to the ImportArchiveFolder thread
//
struct ImportFolderParam
{
    LPCWSTR cszImportFolder; // Import folder name
    BOOL    bSentItems;      // TRUE if the folder contains outbound faxes
    HWND    hImportDlg;      // Handle to the Import progress dialog
    BOOL    bCancel;         // TRUE if the Cancel button has been pressed
};


DWORD 
ImportArchiveFile(
    LPCWSTR    pszFile, 
    LPWSTR     pszArchiveFolder, 
    BOOL       bSentItems,
    WCHAR*     pszUserSid,
    DWORDLONG* pdwlUniqueId
)
/*++

Routine name : ImportArchiveFile

Routine description:

    Imports pszFile file to the pszArchiveFolder folder.
    The pszFile should be generated by W2K MS Fax

Arguments:

    pszFile            - [in]  Imported file name
    pszArchiveFolder   - [in]  MS Fax archive folder name
    bSentItems         - [in]  TRUE if the file from the sent archive, FALSE if it from receive one
    pszUserSid         - [in]  The user string SID, can be NULL if(bSentItems == FALSE)
    pdwlUniqueId       - [out] Unique id for the file

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("ImportArchive"), dwRes);

    WCHAR* pszFileExt = FAX_TIF_FILE_EXT;
    WCHAR  szArchFile[MAX_PATH] = {0};

    MS_TAG_INFO  msTags = {0};

    //
    // Generate unique file name in the archive folder
    // 
    *pdwlUniqueId = GenerateUniqueFileName(pszArchiveFolder, 
                                           pszFileExt, 
                                           szArchFile, 
                                           ARR_SIZE(szArchFile));
    if(*pdwlUniqueId == 0)
    {
        dwRes = GetLastError();
        CALL_FAIL (GENERAL_ERR, TEXT ("GenerateUniqueFileName"), dwRes);
        goto exit;
    }

    if(bSentItems)
    {
        //
        // Add user user SID to the file name for the outbound archive
        //
        // Delete generated file without the user SID in the name
        //
        if(!DeleteFile(szArchFile))
        {
            CALL_FAIL (GENERAL_ERR, TEXT ("DeleteFile"), GetLastError());
        }

        //
        // Add the user SID to the file name
        //
        if (_sntprintf(szArchFile,
                       ARR_SIZE(szArchFile),
                       TEXT("%s\\%s$%I64X%s"),
                       pszArchiveFolder,
                       pszUserSid,
                       *pdwlUniqueId,
                       FAX_TIF_FILE_DOT_EXT) < 0)
        {
            dwRes = ERROR_BUFFER_OVERFLOW;
            CALL_FAIL (GENERAL_ERR, TEXT ("Insufficient szArchFile buffer"), dwRes);
            goto exit;
        }
    }

    if(!CopyFile(pszFile, szArchFile, FALSE))
    {
        dwRes = GetLastError();
        CALL_FAIL (GENERAL_ERR, TEXT ("CopyFile"), dwRes);
        goto exit;
    }

    //
    // Read W2K MS TIF tags from the file
    //
    dwRes = GetW2kMsTiffTags(szArchFile, &msTags, bSentItems);
    if(ERROR_SUCCESS == dwRes)
    {
        //
        // Add new (XP) MS TIF tags to the file
        //
        if(!TiffAddMsTags(szArchFile, &msTags, bSentItems))
        {
            dwRes = GetLastError();
            CALL_FAIL (GENERAL_ERR, TEXT ("TiffAddMsTags"), dwRes);

            if(!DeleteFile(szArchFile))
            {
                CALL_FAIL (GENERAL_ERR, TEXT ("DeleteFile"), GetLastError());
            }
            goto exit;
        }
    }
    else if(ERROR_XP_TIF_FILE_FORMAT == dwRes)
    {
        //
        // The TIF file already has new (XP) TIF tags
        //
        dwRes = ERROR_SUCCESS;
    }
    else
    {
        //
        // The tiff file was not created by MS fax
        //
        if(!DeleteFile(szArchFile))
        {
            CALL_FAIL (GENERAL_ERR, TEXT ("DeleteFile"), GetLastError());
        }
    }

exit:    

    FreeMsTagInfo(&msTags);

    return dwRes;

} // ImportArchiveFile


DWORD 
WINAPI 
ImportArchiveFolder(
    LPVOID lpParameter   // thread data
)
/*++

Routine name : ImportArchiveFolder

Routine description:

    Imports fax (tif) files from the cstrImportFolder folder to the MS Fax archive.
    Returns ERROR_FILE_NOT_FOUND if the folder does not contain TIF files

Arguments:

    lpParameter   - [in] pointer to ImportFolderParam structure

Return Value:

    Standard Win32 error code

--*/
{
    ImportFolderParam* pParam = (ImportFolderParam*)lpParameter;

    DWORD dwRes = ERROR_SUCCESS;
    DWORD dwError;
    int   nRes;
    WCHAR szFindMask[MAX_PATH] = {0};
    WCHAR szImportFile[MAX_PATH] = {0};
    WIN32_FIND_DATA findData = {0};
    HANDLE hFile = INVALID_HANDLE_VALUE;

    HANDLE hFax = NULL;
    PFAX_ARCHIVE_CONFIG pArchiveCfg = NULL;

    PSID   pUserSid   = NULL;
    WCHAR* pszUserSid = NULL;

    DWORDLONG dwlUniqueId;
    DWORD     dwFileCount = 0;
    DWORD     dwNotifyMsgID = 0; // Windows message id used for notification


    DBG_ENTER(TEXT("ImportFolderThread"), dwRes);

    //
    // Compose find mask: path\*.tif
    //
    _snwprintf(szFindMask, MAX_PATH-1, TEXT("%s\\%s"), pParam->cszImportFolder, FAX_TIF_FILE_MASK);

    //
    // Count TIF files in the pParam->cszImportFolder folder
    //
    // Find the first tif file in the cstrImportFolder
    //
    hFile = FindFirstFile(szFindMask, &findData);
    if(INVALID_HANDLE_VALUE == hFile)
    {
        dwRes = GetLastError();
        CALL_FAIL (GENERAL_ERR, TEXT ("FindFirstFile"), dwRes);
        goto exit;
    }

    dwFileCount = 1;
    for(;;)
    {
        //
        // Find Next File
        //
        if(!FindNextFile(hFile, &findData))
        {
            dwError = GetLastError();
            if(ERROR_NO_MORE_FILES != dwError)
            {
                dwRes = dwError;
                CALL_FAIL (GENERAL_ERR, TEXT ("FindNextFile"), dwRes);
            }
            break;
        }
        dwFileCount += 1;
    }

    if(INVALID_HANDLE_VALUE != hFile)
    {
        FindClose(hFile);
    }

    if(pParam->hImportDlg)
    {
        //
        // Set progress bar range
        //
        SendMessage(pParam->hImportDlg, WM_IMPORT_SET_FILE_COUNT, dwFileCount, 0);
    }


    //
    // Find the first tif file in the cstrImportFolder
    //
    hFile = FindFirstFile(szFindMask, &findData);
    if(INVALID_HANDLE_VALUE == hFile)
    {
        dwRes = GetLastError();
        CALL_FAIL (GENERAL_ERR, TEXT ("FindFirstFile"), dwRes);
        goto exit;
    }

    //
    // Get fax server archive configuration
    //
    if(!FaxConnectFaxServer(NULL, &hFax))
    {
        dwRes = GetLastError();
        CALL_FAIL (RPC_ERR, TEXT ("FaxConnectFaxServer"), dwRes);
        goto exit;
    }

    //
    // Get pointer to the Client Console archive folder
    //
    if(theApp.m_pMainWnd)
    {   
        CClientConsoleDoc* pDoc = NULL;
        pDoc = (CClientConsoleDoc*)((CFrameWnd*)theApp.m_pMainWnd)->GetActiveDocument();
        if(pDoc)
        {
            //
            // find local fax server
            //
            CServerNode* pServer = NULL;
            pServer = pDoc->FindServerByName(NULL);
            if(pServer)
            {
                //
                // Get archive folder
                //
                CFolder* pFolder = NULL;
                pFolder = pServer->GetFolder(pParam->bSentItems ? FOLDER_TYPE_SENT_ITEMS : FOLDER_TYPE_INBOX);
                if(pFolder && pFolder->IsValid())
                {
                    dwNotifyMsgID = pServer->GetNotifyMsgID();
                }
            }
        }
    }

    //
    // Access check
    //
    DWORD dwAccessRights;
    if (!FaxAccessCheckEx(hFax, 
                          pParam->bSentItems ? FAX_ACCESS_MANAGE_OUT_ARCHIVE : FAX_ACCESS_MANAGE_IN_ARCHIVE, 
                          &dwAccessRights))
    {
        dwRes = GetLastError();
        CALL_FAIL (RPC_ERR, TEXT ("FaxAccessCheckEx"), dwRes);

        AlignedAfxMessageBox(IDS_IMPORT_NO_ACCESS, MB_OK | MB_ICONSTOP | MB_APPLMODAL);

        goto exit;
    }

    if(!FaxGetArchiveConfiguration(hFax, 
                                   pParam->bSentItems ? FAX_MESSAGE_FOLDER_SENTITEMS : FAX_MESSAGE_FOLDER_INBOX,
                                   &pArchiveCfg))
    {
        dwRes = GetLastError();
        CALL_FAIL (RPC_ERR, TEXT ("FaxGetArchiveConfiguration"), dwRes);
        goto exit;
    }

    if(pParam->bSentItems)
    {
        //
        // Get the user string SID for the outbound archive
        //
        pUserSid = GetCurrentThreadSID();
        if (!pUserSid)
        {
            dwRes = GetLastError ();
            CALL_FAIL (GENERAL_ERR, TEXT ("GetCurrentThreadSID"), dwRes);
            goto exit;
        }

        if (!ConvertSidToStringSid(pUserSid, &pszUserSid))
        {
            dwRes = GetLastError ();
            CALL_FAIL (GENERAL_ERR, TEXT ("ConvertSidToStringSid"), dwRes);
            goto exit;
        }
    }

    while(!pParam->bCancel)
    {
        //
        // Compose full path 
        //
        _snwprintf(szImportFile, MAX_PATH-1, TEXT("%s\\%s\0"), pParam->cszImportFolder, findData.cFileName);

        nRes = IDOK;
        do
        {
            //
            // Import the file
            //
            dwError = ImportArchiveFile(szImportFile, 
                                        pArchiveCfg->lpcstrFolder, 
                                        pParam->bSentItems, 
                                        pszUserSid, 
                                        &dwlUniqueId);
            if(ERROR_SUCCESS != dwError)
            {
                CALL_FAIL (GENERAL_ERR, TEXT ("ImportArchiveFile"), dwRes);

                //
                // Popup "Cancel, Try Again, Continue" dialog
                //
                DWORD dwResId = IDS_IMPORT_ERROR; 
                WCHAR szFormat[MAX_PATH] = {0};
                WCHAR szMsg[MAX_PATH] = {0};

                if(ERROR_BAD_FORMAT == dwError)
                {
                    dwResId = IDS_IMPORT_BAD_FORMAT;
                }

                if(LoadString(GetResourceHandle(), 
                              dwResId,
                              szFormat, 
                              ARR_SIZE(szFormat)))
                {
                    _snwprintf(szMsg, MAX_PATH-1, szFormat, findData.cFileName);

                    nRes = AlignedAfxMessageBox(szMsg, MB_CANCELTRYCONTINUE | MB_ICONSTOP | MB_APPLMODAL);  

                    if(IDCANCEL == nRes)
                    {
                        pParam->bCancel = TRUE;
                    }
                }
                else
                {
                    CALL_FAIL (GENERAL_ERR, TEXT ("LoadString(IDS_IMPORT_ERROR)"), GetLastError());
                }
            }
        }
        while(nRes == IDTRYAGAIN);

        if(dwNotifyMsgID)
        {
            //
            // Add the message to the archive folder
            // We simulate the server notification handled by the application main thread
            // The notification handler should free the event data
            //
            FAX_EVENT_EX* pEvent = (FAX_EVENT_EX*)MemAlloc(sizeof(FAX_EVENT_EX));
            if(!pEvent)
            {
                dwRes = ERROR_NOT_ENOUGH_MEMORY;
                CALL_FAIL (GENERAL_ERR, TEXT ("MemAlloc"), dwRes);
                goto exit;
            }
            ZeroMemory(pEvent, sizeof(FAX_EVENT_EX));

            pEvent->dwSizeOfStruct = sizeof(FAX_EVENT_EX);
            pEvent->EventType = pParam->bSentItems ? FAX_EVENT_TYPE_OUT_ARCHIVE : FAX_EVENT_TYPE_IN_ARCHIVE;
            pEvent->EventInfo.JobInfo.Type = FAX_JOB_EVENT_TYPE_ADDED;
            pEvent->EventInfo.JobInfo.dwlMessageId = dwlUniqueId;

            theApp.m_pMainWnd->SendMessage(dwNotifyMsgID, 0, (LPARAM)pEvent);
        }

        if(pParam->hImportDlg)
        {
            //
            // Increment progress bar
            //
            SendMessage(pParam->hImportDlg, WM_IMPORT_PROGRESS_INC, 0, 0);
        }

        //
        // Find Next File
        //
        if(!FindNextFile(hFile, &findData))
        {
            dwError = GetLastError();
            if(ERROR_NO_MORE_FILES != dwError)
            {
                dwRes = dwError;
                CALL_FAIL (GENERAL_ERR, TEXT ("FindNextFile"), dwRes);
            }
            break;
        }
    } // while

    //
    // Notify the fax service
    //
    if(!FaxRefreshArchive(hFax, 
                          pParam->bSentItems ? FAX_MESSAGE_FOLDER_SENTITEMS : FAX_MESSAGE_FOLDER_INBOX))
    {
        dwRes = GetLastError();
        CALL_FAIL (GENERAL_ERR, TEXT ("FaxArchiveMessageAdded"), dwRes);
    }


exit:

    if(pParam->hImportDlg)
    {
        //
        // Close the Progress dialog
        //
        SendMessage(pParam->hImportDlg, WM_CLOSE, 0, 0);
    }

    if(0 == dwFileCount)
    {
        //
        // The folder does not contain faxes
        //
        AlignedAfxMessageBox(IDS_IMPORT_EMPTY_FOLDER, MB_OK | MB_ICONEXCLAMATION | MB_APPLMODAL);
    }

    if(INVALID_HANDLE_VALUE != hFile)
    {
        FindClose(hFile);
    }

    if(pArchiveCfg)
    {
        FaxFreeBuffer(pArchiveCfg);
    }

    if(hFax)
    {
        FaxClose(hFax);
    }

    if(pUserSid)
    {
        MemFree(pUserSid);
    }

    if(pszUserSid)
    {
        LocalFree(pszUserSid);
    }

    return dwRes;

} // ImportArchiveFolder


INT_PTR 
CALLBACK 
ImportDlgProc(
  HWND hwndDlg,  // handle to dialog box
  UINT uMsg,     // message
  WPARAM wParam, // first message parameter
  LPARAM lParam  // second message parameter
)
/*++

Routine description:

    Import fax dialog procedure

Arguments:

  HWND hwndDlg,  // handle to dialog box
  UINT uMsg,     // message
  WPARAM wParam, // first message parameter
  LPARAM lParam  // second message parameter

Return Value:

    return TRUE if it processed the message

--*/

{
    static ImportFolderParam* pIpmParam = NULL;
    static DWORD dwFileCount;   // The number of the files to import
    static DWORD dwCurrentFile; // The number of the currently imported file

    switch ( uMsg )
    {
        case WM_INITDIALOG:
            {
                HANDLE hImportThread = NULL;
                pIpmParam = (ImportFolderParam*)lParam;
                TCHAR szFolder[MAX_PATH] = {0};

                DBG_ENTER(TEXT("ImportDlgProc(WM_INITDIALOG)"));


                dwFileCount = 0;
                dwCurrentFile = 0;

                //
                // Set import folder name
                //
                if(LoadString(GetResourceHandle(), 
                              pIpmParam->bSentItems ? IDS_IMPORT_TO_SENT_ITEMS : IDS_IMPORT_TO_INBOX,
                              szFolder, 
                              ARR_SIZE(szFolder)))
                {
                    SetDlgItemText(hwndDlg, IDC_IMPORT_FOLDER, szFolder);
                }
                else
                {
                    CALL_FAIL (GENERAL_ERR, TEXT ("LoadString() for IDC_IMPORT_FOLDER"), GetLastError());
                }

                pIpmParam->hImportDlg   = hwndDlg;

                hImportThread = CreateThread(NULL,                // SD
                                             0,                   // initial stack size
                                             ImportArchiveFolder, // thread function
                                             (LPVOID)pIpmParam,   // thread argument
                                             0,                   // creation option
                                             NULL);               // thread identifier
                if(!hImportThread)
                {
                    CALL_FAIL (GENERAL_ERR, TEXT ("CreateThread"), GetLastError());
                }
                else
                {
                    CloseHandle(hImportThread);
                }
                return TRUE;
            }

        case WM_IMPORT_PROGRESS_INC:
            {
                //
                // Increment progress bar
                //
                SendDlgItemMessage(hwndDlg, IDC_IMPORT_PROGRESS_BAR, PBM_STEPIT, 0, 0);

                //
                // Compose and set currently imported fax number
                //
                ++dwCurrentFile;

                TCHAR szFormat[MAX_PATH] = {0};
                TCHAR szText[MAX_PATH] = {0};
                DWORD dwParam[2];

                DBG_ENTER(TEXT("ImportDlgProc(WM_IMPORT_PROGRESS_INC)"));


                dwParam[0] = dwCurrentFile;
                dwParam[1] = dwFileCount;

                if(!LoadString(GetResourceHandle(), 
                               IDS_IMPORT_NUMBER,
                               szFormat, 
                               ARR_SIZE(szFormat)))
                {
                    CALL_FAIL (GENERAL_ERR, TEXT ("LoadString(IDS_IMPORT_NUMBER)"), GetLastError());
                    return TRUE;
                }

                if(FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                (LPCVOID)szFormat,
                                0,
                                0,
                                szText,
                                ARR_SIZE(szText),
                                (va_list*)dwParam))
                {
                    SetDlgItemText(hwndDlg, IDC_PROGRESS_NUMBER, szText);
                }

                return TRUE;
            }
        case WM_IMPORT_SET_FILE_COUNT:
            //
            // Set the pange and step of the proggress bar
            //
            dwFileCount = wParam;
            dwCurrentFile = 1;

            SendDlgItemMessage(hwndDlg, IDC_IMPORT_PROGRESS_BAR, PBM_SETRANGE32, 0, dwFileCount);
            SendDlgItemMessage(hwndDlg, IDC_IMPORT_PROGRESS_BAR, PBM_SETSTEP, 1, 0);
            return TRUE;

        case WM_CLOSE:

            EndDialog(hwndDlg, IDCANCEL);

            return TRUE;

        case WM_COMMAND:
            switch(LOWORD(wParam))
            {
                case IDCANCEL:
                        
                    //
                    // Mark cancel, don't close the dialog
                    //
                    pIpmParam->bCancel = TRUE;
                    EnableWindow(GetDlgItem(hwndDlg, IDCANCEL), FALSE);

                    return TRUE;
            } 

            break;


    } // switch ( uMsg )

    return FALSE;

} // ImportDlgProc


DWORD 
ImportArchiveFolderUI(
    LPCWSTR cstrImportFolder, 
    BOOL    bSentItems,
    HWND    hWnd
)
/*++

Routine name : ImportArchiveFolderUI

Routine description:

    Opens the Import Progress dialog

Arguments:

    cstrImportFolder   - [in]  Import folder name
    bSentItems         - [in]  TRUE if the folder is the sent archive, FALSE if it is receive one
    hWnd               - [in]  Parent window

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;

    ImportFolderParam impParam = {0};
    impParam.cszImportFolder   = cstrImportFolder;
    impParam.bSentItems        = bSentItems;

    DBG_ENTER(TEXT("ImportArchiveFolderUI"), dwRes);

    DialogBoxParam(GetResourceHandle(),          // handle to module
                   MAKEINTRESOURCE(IDD_IMPORT),  // dialog box template
                   hWnd,                         // handle to owner window
                   ImportDlgProc,                // dialog box procedure
                   (LPARAM)&impParam);           // initialization value

    return dwRes;

} // ImportArchiveFolderUI


BOOL
IsFaxArchive(
    WCHAR* szFolder
)
/*++

Routine name : IsFaxArchive

Routine description:

    Determine if the folder contains at least one TIF file

Arguments:

    szFolder   - [in]  folder name

Return Value:

    TRUE if if the folder contains at least one TIF file
    FALSE otherwise

--*/
{
    WCHAR szFindMask[MAX_PATH] = {0};
    WIN32_FIND_DATA findData = {0};
    HANDLE hFile = INVALID_HANDLE_VALUE;

    DBG_ENTER(TEXT("IsFaxArchive"));

    //
    // Compose find mask: path\*.tif
    //
    _snwprintf(szFindMask, MAX_PATH-1, TEXT("%s\\%s"), szFolder, FAX_TIF_FILE_MASK);

    //
    // Find the first tif file in the cstrImportFolder
    //
    hFile = FindFirstFile(szFindMask, &findData);
    if(INVALID_HANDLE_VALUE == hFile)
    {
        CALL_FAIL (GENERAL_ERR, TEXT ("FindFirstFile"), GetLastError());
        return FALSE;
    }

    FindClose(hFile);
    return TRUE;
}

INT_PTR 
CALLBACK 
ImportInfoDlgProc(
  HWND hwndDlg,  // handle to dialog box
  UINT uMsg,     // message
  WPARAM wParam, // first message parameter
  LPARAM lParam  // second message parameter
)
/*++

Routine description:

    Import inforamtion fax dialog procedure

Arguments:

  HWND hwndDlg,  // handle to dialog box
  UINT uMsg,     // message
  WPARAM wParam, // first message parameter
  LPARAM lParam  // second message parameter

Return Value:

    return TRUE if it processed the message

--*/

{
    switch (uMsg)
    {
        case WM_INITDIALOG:
            //
            // Set focus on the OK button
            //
            SetFocus(GetDlgItem(hwndDlg, IDOK));
            return FALSE;

        case WM_NOTIFY :
            {
                LPNMHDR lpnm = (LPNMHDR) lParam;
                if(lpnm->code   == NM_CLICK  && 
                   lpnm->idFrom == IDC_IMPORT_HELP_LINK)
                {
                    //
                    // Display import help
                    //
                    HtmlHelpTopic(hwndDlg, FAX_HELP_IMPORT);
                    return TRUE;
                }
            }
            break;

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDOK:
                case IDCANCEL:
                    EndDialog(hwndDlg, IDOK);
                    return TRUE;
            }                
            break;
    }
    return FALSE;
} // ImportInfoDlgProc

DWORD 
DetectImportFiles()
/*++

Routine name : DetectImportFiles

Routine description:

    Determine if the system has W2K fax archives.
    If yes warning dialog will be displayed for the first time.

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    HKEY  hRegKey;
    DWORD dwImportWrn = 0; // 1 if the import warning has been displayed

    WCHAR* pszInbox = NULL;
    WCHAR* pszSentItems = NULL;
    DWORD  dwSize = 0;
    BOOL   bHaveFax = FALSE; // TRUE if the archives contain at least one TIF file

    DBG_ENTER(TEXT("DetectImportFiles"), dwRes);

    if(!IsWinXPOS())
    {
        return dwRes;
    }

    //
    // Check if the Import warning has been displayed
    //
    if ((hRegKey = OpenRegistryKey(HKEY_CURRENT_USER, REGKEY_FAX_SETUP, TRUE, KEY_ALL_ACCESS)))
    {
        dwImportWrn = GetRegistryDword(hRegKey, REGVAL_IMPORT_INFO);

        if(!dwImportWrn)
        {
            SetRegistryDword(hRegKey, REGVAL_IMPORT_INFO, TRUE);
        }
            
        RegCloseKey(hRegKey);
    }
    else
    {
        CALL_FAIL (GENERAL_ERR, TEXT ("OpenRegistryKey"), GetLastError());
    }

    if(dwImportWrn)
    {
        //
        // Import warning has been displayed
        //
        return dwRes;
    }

    //
    // Read W2K archives location
    //
    if (!(hRegKey = OpenRegistryKey(HKEY_LOCAL_MACHINE, REGKEY_FAX_SETUP, TRUE, KEY_QUERY_VALUE)))
    {
        CALL_FAIL (GENERAL_ERR, TEXT ("OpenRegistryKey"), GetLastError());
        return dwRes;
    }

    pszInbox = GetRegistryStringMultiSz(hRegKey, REGVAL_W2K_INBOX, NULL, &dwSize);
    pszSentItems = GetRegistryString(hRegKey, REGVAL_W2K_SENT_ITEMS, NULL);
        
    RegCloseKey(hRegKey);

    //
    // Determine if the archives have at least one TIF file
    //
    bHaveFax = IsFaxArchive(pszSentItems);

    WCHAR* pszFolder = pszInbox;
    while(!bHaveFax && pszFolder && *pszFolder)
    {
        //
        // Walk though the multiline pszInbox string
        //
        bHaveFax = IsFaxArchive(pszFolder);

        pszFolder = _wcsninc(pszFolder, wcslen(pszFolder)+1);
    }

    MemFree(pszInbox);
    MemFree(pszSentItems);

    if(bHaveFax)
    {
        if(!LinkWindow_RegisterClass())
        {
            dwRes = ERROR_CAN_NOT_COMPLETE;
            CALL_FAIL (GENERAL_ERR, TEXT ("LinkWindow_RegisterClass"), dwRes);
            return dwRes;
        }

        DialogBoxParam(GetResourceHandle(),               // handle to module
                       MAKEINTRESOURCE(IDD_IMPORT_INFO),  // dialog box template
                       theApp.m_pMainWnd->m_hWnd,         // handle to owner window
                       ImportInfoDlgProc,                 // dialog box procedure
                       NULL);                             // initialization value

        LinkWindow_UnregisterClass(theApp.m_hInstance);
    }

    return dwRes;
}

#endif //UNICODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\incominggeneralpg.cpp ===
// IncomingGeneralPg.cpp : implementation file
//

#include "stdafx.h"

#define __FILE_ID__     41

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//
// this array maps CViewRow items to 
// dialog control IDs
//
static TMsgPageInfo s_PageInfo[] = 
{
    MSG_VIEW_ITEM_NUM_PAGES,               IDC_PAGES_VALUE,
    MSG_VIEW_ITEM_TRANSMISSION_START_TIME, IDC_START_TIME_VALUE,
    MSG_VIEW_ITEM_SIZE,                    IDC_SIZE_VALUE,
    MSG_VIEW_ITEM_STATUS,                  IDC_STATUS_VALUE,
    MSG_VIEW_ITEM_EXTENDED_STATUS,         IDC_EXTENDED_STATUS_VALUE,
    MSG_VIEW_ITEM_CURRENT_PAGE,            IDC_CURRENT_PAGE_VALUE
};

/////////////////////////////////////////////////////////////////////////////
// CIncomingGeneralPg property page

IMPLEMENT_DYNCREATE(CIncomingGeneralPg, CMsgPropertyPg)

CIncomingGeneralPg::CIncomingGeneralPg(
    CFaxMsg* pMsg     // pointer to CJob
) : 
    CMsgPropertyPg(CIncomingGeneralPg::IDD, pMsg)
{
}

CIncomingGeneralPg::~CIncomingGeneralPg()
{
}

void CIncomingGeneralPg::DoDataExchange(CDataExchange* pDX)
{
	CMsgPropertyPg::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CIncomingGeneralPg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CIncomingGeneralPg, CMsgPropertyPg)
	//{{AFX_MSG_MAP(CIncomingGeneralPg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CIncomingGeneralPg message handlers

BOOL 
CIncomingGeneralPg::OnInitDialog() 
{
    DBG_ENTER(TEXT("CIncomingGeneralPg::OnInitDialog"));

    CMsgPropertyPg::OnInitDialog();

    Refresh(s_PageInfo, sizeof(s_PageInfo)/sizeof(s_PageInfo[0]));

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\itempropsheet.h ===
#if !defined(AFX_ITEMPROPSHEET_H__CCF76858_9A54_4AB7_8DBF_BD9815F06F53__INCLUDED_)
#define AFX_ITEMPROPSHEET_H__CCF76858_9A54_4AB7_8DBF_BD9815F06F53__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ItemPropSheet.h : header file
//

struct TMsgPageInfo
{
    MsgViewItemType itemType;       // job type
    DWORD           dwValueResId;   // item value control id
};

#define WM_SET_SHEET_FOCUS WM_APP+4


/////////////////////////////////////////////////////////////////////////////
// CItemPropSheet

class CItemPropSheet : public CPropertySheet
{
	DECLARE_DYNAMIC(CItemPropSheet)

// Construction
public:
	CItemPropSheet(UINT nIDCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);

    DWORD Init(CFolder* pFolder, CFaxMsg* pMsg);

    DWORD GetLastError() { return m_dwLastError; }
    void  SetLastError(DWORD dwError) { m_dwLastError = dwError; }

// Attributes
private:

    #define PROP_SHEET_PAGES_NUM  4

    CPropertyPage* m_pPages[PROP_SHEET_PAGES_NUM];

    DWORD m_dwLastError;

    CFaxMsg* m_pMsg;

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CItemPropSheet)
	public:
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CItemPropSheet();

	// Generated message map functions

protected:
	//{{AFX_MSG(CItemPropSheet)
	afx_msg void OnActivate(UINT nState, CWnd* pWndOther, BOOL bMinimized);
    afx_msg LONG OnSetSheetFocus(UINT wParam, LONG lParam);
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg LONG OnHelp(UINT wParam, LONG lParam);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ITEMPROPSHEET_H__CCF76858_9A54_4AB7_8DBF_BD9815F06F53__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\incomingdetailspg.cpp ===
// IncomingDetailsPg.cpp : implementation file
//

#include "stdafx.h"

#define __FILE_ID__     51

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//
// this array maps CViewRow items to 
// dialog control IDs
//
static TMsgPageInfo s_PageInfo[] = 
{
    MSG_VIEW_ITEM_CALLER_ID,               IDC_CALLER_ID_VALUE,
    MSG_VIEW_ITEM_ROUTING_INFO,            IDC_ROUTING_INFO_VALUE,
    MSG_VIEW_ITEM_RETRIES,                 IDC_RETRIES_VALUE,
    MSG_VIEW_ITEM_CSID,                    IDC_CSID_VALUE,
    MSG_VIEW_ITEM_TSID,                    IDC_TSID_VALUE,
    MSG_VIEW_ITEM_DEVICE,                  IDC_DEVICE_VALUE,
    MSG_VIEW_ITEM_ID,                      IDC_JOB_ID_VALUE,
    MSG_VIEW_ITEM_TRANSMISSION_END_TIME,   IDC_END_TIME_VALUE,
    MSG_VIEW_ITEM_SEND_TIME,               IDC_TRANSMISSION_TIME_VALUE
};

/////////////////////////////////////////////////////////////////////////////
// CIncomingDetailsPg property page

IMPLEMENT_DYNCREATE(CIncomingDetailsPg, CMsgPropertyPg)

CIncomingDetailsPg::CIncomingDetailsPg(
    CFaxMsg* pMsg     // pointer to CJob
) : 
    CMsgPropertyPg(CIncomingDetailsPg::IDD, pMsg)
{
}

CIncomingDetailsPg::~CIncomingDetailsPg()
{
}

void CIncomingDetailsPg::DoDataExchange(CDataExchange* pDX)
{
	CMsgPropertyPg::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CIncomingDetailsPg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CIncomingDetailsPg, CMsgPropertyPg)
	//{{AFX_MSG_MAP(CIncomingDetailsPg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CIncomingDetailsPg message handlers

BOOL 
CIncomingDetailsPg::OnInitDialog() 
{
    DBG_ENTER(TEXT("CIncomingDetailsPg::OnInitDialog"));

    CMsgPropertyPg::OnInitDialog();

    Refresh(s_PageInfo, sizeof(s_PageInfo)/sizeof(s_PageInfo[0]));

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\incominggeneralpg.h ===
#if !defined(AFX_INCOMINGGENERALPG_H__FC84E35A_631F_4AA1_985D_327E0A14B36E__INCLUDED_)
#define AFX_INCOMINGGENERALPG_H__FC84E35A_631F_4AA1_985D_327E0A14B36E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// IncomingGeneralPg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CIncomingGeneralPg dialog

class CIncomingGeneralPg : public CMsgPropertyPg
{
	DECLARE_DYNCREATE(CIncomingGeneralPg)

// Construction
public:
	CIncomingGeneralPg(CFaxMsg* pMsg);
	~CIncomingGeneralPg();

// Dialog Data
	//{{AFX_DATA(CIncomingGeneralPg)
	enum { IDD = IDD_INCOMING_GENERAL };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CIncomingGeneralPg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
private:
    CIncomingGeneralPg() {}

protected:
	// Generated message map functions
	//{{AFX_MSG(CIncomingGeneralPg)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_INCOMINGGENERALPG_H__FC84E35A_631F_4AA1_985D_327E0A14B36E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\incomingdetailspg.h ===
#if !defined(AFX_INCOMINGDETAILSPG_H__FC84E35A_631F_4AA1_985D_327E0A14B36E__INCLUDED_)
#define AFX_INCOMINGDETAILSPG_H__FC84E35A_631F_4AA1_985D_327E0A14B36E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// IncomingDetailsPg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CIncomingDetailsPg dialog

class CIncomingDetailsPg : public CMsgPropertyPg
{
	DECLARE_DYNCREATE(CIncomingDetailsPg)

// Construction
public:
	CIncomingDetailsPg(CFaxMsg* pMsg);
	~CIncomingDetailsPg();

// Dialog Data
	//{{AFX_DATA(CIncomingDetailsPg)
	enum { IDD = IDD_INCOMING_DETAILS };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CIncomingDetailsPg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
private:
    CIncomingDetailsPg() {}

protected:
	// Generated message map functions
	//{{AFX_MSG(CIncomingDetailsPg)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_INCOMINGDETAILSPG_H__FC84E35A_631F_4AA1_985D_327E0A14B36E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\itempropsheet.cpp ===
// ItemPropSheet.cpp : implementation file
//

#include "stdafx.h"

#define __FILE_ID__     42

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CItemPropSheet

IMPLEMENT_DYNAMIC(CItemPropSheet, CPropertySheet)


CItemPropSheet::CItemPropSheet(
    UINT nIDCaption,    // sheet caption id
    CWnd* pParentWnd,   // parent window
    UINT iSelectPage    // initialy selected page
):
    CPropertySheet(nIDCaption, pParentWnd, iSelectPage),
    m_dwLastError(ERROR_SUCCESS),
    m_pMsg(NULL)
{
    //
    // no Help button
    //
    m_psh.dwFlags &= ~PSH_HASHELP;
    //
    // no Apply button
    //
    m_psh.dwFlags |= PSH_NOAPPLYNOW;
}


DWORD
CItemPropSheet::Init(
    CFolder* pFolder,   // folder
    CFaxMsg* pMsg       // pointer to CJob or CArchiveMsg
)
{
    m_dwLastError = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CItemPropSheet::Init"), m_dwLastError);

    ASSERTION(pFolder);
    ASSERTION(pMsg);

    //
    // init page array
    //
    for(DWORD dw=0; dw < PROP_SHEET_PAGES_NUM; ++dw)
    {
        m_pPages[dw] = NULL;
    }


    //
    // create pages according to FolderType
    //
    FolderType type =  pFolder->Type();
    BOOL bCreatePersonalInfo = TRUE;

    if(pMsg->IsKindOf(RUNTIME_CLASS(CArchiveMsg)))
    {
        try
        {
            m_pMsg = new CArchiveMsg;
        }
        catch(...)
        {
            m_dwLastError = ERROR_NOT_ENOUGH_MEMORY;
            CALL_FAIL (MEM_ERR, TEXT ("new CArchiveMsg"), m_dwLastError);
            goto exit;
        }

        m_dwLastError = ((CArchiveMsg*)m_pMsg)->Copy(*((CArchiveMsg*)pMsg));
        if(ERROR_SUCCESS != m_dwLastError)
        {
            return m_dwLastError;
        }
    }
    else if(pMsg->IsKindOf(RUNTIME_CLASS(CJob)))
    {
        try
        {
            m_pMsg = new CJob;
        }
        catch(...)
        {
            m_dwLastError = ERROR_NOT_ENOUGH_MEMORY;
            CALL_FAIL (MEM_ERR, TEXT ("new CJob"), m_dwLastError);
            goto exit;
        }

        m_dwLastError = ((CJob*)m_pMsg)->Copy(*((CJob*)pMsg));
        if(ERROR_SUCCESS != m_dwLastError)
        {
            return m_dwLastError;
        }
    }
    else
    {
        ASSERTION_FAILURE
    }

    try
    {
        switch(type)
        {
        case FOLDER_TYPE_INCOMING:
            bCreatePersonalInfo = FALSE;

            m_pPages[0] = new CIncomingGeneralPg(m_pMsg);
            m_pPages[1] = new CIncomingDetailsPg(m_pMsg);

            break;
        case FOLDER_TYPE_INBOX:
            bCreatePersonalInfo = FALSE;

            m_pPages[0] = new CInboxGeneralPg(m_pMsg);
            m_pPages[1] = new CInboxDetailsPg(m_pMsg);

            break;
        case FOLDER_TYPE_OUTBOX:
        
            m_pPages[0] = new COutboxGeneralPg(m_pMsg);
            m_pPages[1] = new COutboxDetailsPg(m_pMsg);

            break;
        case FOLDER_TYPE_SENT_ITEMS:
    
            m_pPages[0] = new CSentItemsGeneralPg(m_pMsg);
            m_pPages[1] = new CSentItemsDetailsPg(m_pMsg);

            break;
        default:
            ASSERTION_FAILURE;
            break;
        };

        if(bCreatePersonalInfo)
        {
            //
            // create sender info page
            //
            m_pPages[2] = new CPersonalInfoPg(IDS_SENDER_INFO_CAPTION, 
                                              PERSON_SENDER, 
                                              m_pMsg,
                                              pFolder);

            m_dwLastError = ((CPersonalInfoPg*)m_pPages[2])->Init();
            if(ERROR_SUCCESS != m_dwLastError)
            {
                CALL_FAIL (GENERAL_ERR, TEXT ("CPersonalInfoPg::Init"), m_dwLastError);
            }
        }
    }
    catch(...)
    {
        m_dwLastError = ERROR_NOT_ENOUGH_MEMORY;
        CALL_FAIL (MEM_ERR, TEXT ("new CPropertyPage"), m_dwLastError);
        goto exit;
    }

    //
    // add pages to sheet
    //
    for(dw=0; dw < PROP_SHEET_PAGES_NUM; ++dw)
    {
        if(NULL != m_pPages[dw])
        {
            AddPage(m_pPages[dw]);
        }
    }

exit:
    if(ERROR_SUCCESS != m_dwLastError)
    {
        for(DWORD dw=0; dw < PROP_SHEET_PAGES_NUM; ++dw)
        {
            SAFE_DELETE(m_pPages[dw]);
        }
    }

    return m_dwLastError;
}

CItemPropSheet::~CItemPropSheet()
{
    for(DWORD dw=0; dw < PROP_SHEET_PAGES_NUM; ++dw)
    {
        SAFE_DELETE(m_pPages[dw]);
    }

    SAFE_DELETE(m_pMsg);
}


BEGIN_MESSAGE_MAP(CItemPropSheet, CPropertySheet)
	//{{AFX_MSG_MAP(CItemPropSheet)
	ON_WM_ACTIVATE()
    ON_MESSAGE(WM_SET_SHEET_FOCUS, OnSetSheetFocus)
	ON_WM_CREATE()
    ON_MESSAGE(WM_HELP, OnHelp)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CItemPropSheet message handlers

void 
CItemPropSheet::OnActivate(
    UINT nState, 
    CWnd* pWndOther,
    BOOL bMinimized
) 
{
    DBG_ENTER(TEXT("CItemPropSheet::OnActivate"));

    CPropertySheet::OnActivate(nState, pWndOther, bMinimized);
	
    //
    // hide OK button
    //
    CWnd *pWnd = GetDlgItem( IDOK );
    ASSERTION(NULL != pWnd);
	pWnd->ShowWindow( FALSE );	

    //
    // rename Cancel button
    //
    CString cstrText;
    DWORD dwRes = LoadResourceString (cstrText, IDS_BUTTON_CLOSE);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (RESOURCE_ERR, TEXT("LoadResourceString"), dwRes);
        return;
    }

    pWnd = GetDlgItem( IDCANCEL );
    ASSERT(NULL != pWnd);
	pWnd->SetWindowText(cstrText);	
}

LONG 
CItemPropSheet::OnSetSheetFocus(
    UINT wParam, 
    LONG lParam
)
{
    //
    // set focus on Close button
    //
    CWnd *pWnd = GetDlgItem( IDCANCEL );
    ASSERT(NULL != pWnd);
    pWnd->SetFocus();
    return 0;
} 

int 
CItemPropSheet::OnCreate(
    LPCREATESTRUCT lpCreateStruct
) 
{
	if (CPropertySheet::OnCreate(lpCreateStruct) == -1)
		return -1;
	
    ModifyStyleEx(0, WS_EX_CONTEXTHELP);
	
	return 0;
}

LONG 
CItemPropSheet::OnHelp(
    UINT wParam, 
    LONG lParam
)
{
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\job.cpp ===
// Job.cpp: implementation of the CJob class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#define __FILE_ID__     17

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CJob, CObject)

DWORD
CJob::Init (
    PFAX_JOB_ENTRY_EX pJob,
    CServerNode* pServer
)
/*++

Routine name : CJob::Init

Routine description:

    Constructs a new job from a FAX_JOB_ENTRY_EX structure

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    pJob            [in] - Pointer to FAX_JOB_ENTRY_EX structure
    pServer         [in] - pointer to CServerNode object

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CJob::Init"), dwRes);

    ASSERTION (pServer);
    m_pServer = pServer;

    ASSERTION (!m_bValid);

    m_dwJobOnlyValidityMask = pJob->dwValidityMask;

    try
    {
        //
        // Message id
        //
        ASSERTION (m_dwJobOnlyValidityMask & FAX_JOB_FIELD_MESSAGE_ID );
        m_dwlMessageId = pJob->dwlMessageId;

        //
        // Broadcast id
        //
        m_dwlBroadcastId = (m_dwJobOnlyValidityMask & FAX_JOB_FIELD_BROADCAST_ID) ?
                            pJob->dwlBroadcastId : 0;

        //
        // Recipient info
        //
        m_cstrRecipientNumber = pJob->lpctstrRecipientNumber ?
                                pJob->lpctstrRecipientNumber : TEXT("");
        m_cstrRecipientName   = pJob->lpctstrRecipientName ?
                                pJob->lpctstrRecipientName : TEXT("");
        //
        // Sender info
        //
        m_cstrSenderUserName = pJob->lpctstrSenderUserName ?
                               pJob->lpctstrSenderUserName : TEXT("");
        m_cstrBillingCode    = pJob->lpctstrBillingCode ?
                               pJob->lpctstrBillingCode : TEXT("");
        //
        // Document info
        //
        m_cstrDocumentName = pJob->lpctstrDocumentName ?
                             pJob->lpctstrDocumentName : TEXT("");
        m_cstrSubject      = pJob->lpctstrSubject ?
                             pJob->lpctstrSubject : TEXT("");

        //
        // Server name
        //
        m_cstrServerName = m_pServer->Machine();

        //
        // Original scheduled time
        //
        if (m_dwJobOnlyValidityMask & FAX_JOB_FIELD_ORIGINAL_SCHEDULE_TIME)
        {
            m_tmOriginalScheduleTime = pJob->tmOriginalScheduleTime;
        }
        else
        {
            m_tmOriginalScheduleTime.Zero ();
        }
        //
        // Submission time
        //
        if (m_dwJobOnlyValidityMask & FAX_JOB_FIELD_SUBMISSION_TIME)
        {
            m_tmSubmissionTime = pJob->tmSubmissionTime;
        }
        else
        {
            m_tmSubmissionTime.Zero ();
        }
        //
        // Priority
        //
        if (m_dwJobOnlyValidityMask & FAX_JOB_FIELD_PRIORITY)
        {
            m_Priority = pJob->Priority;
            ASSERTION (m_Priority <= FAX_PRIORITY_TYPE_HIGH);
        }
        else
        {
            m_Priority = (FAX_ENUM_PRIORITY_TYPE)-1;
        }
    }
    catch (CException &ex)
    {
        TCHAR wszCause[1024];

        ex.GetErrorMessage (wszCause, 1024);
        VERBOSE (EXCEPTION_ERR,
                 TEXT("CJob::Init caused exception : %s"),
                 wszCause);
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        return dwRes;
    }

    m_bValid = TRUE;

    m_dwPossibleOperations = 0;
    if (m_dwJobOnlyValidityMask & FAX_JOB_FIELD_STATUS_SUB_STRUCT)
    {
        //
        // Now update the status
        //
        dwRes = UpdateStatus (pJob->pStatus);
    }
    else
    {
        //
        // No status
        //
        VERBOSE (DBG_MSG, TEXT("Job id 0x%016I64x has no status"), m_dwlMessageId);
        m_dwValidityMask = m_dwJobOnlyValidityMask;
        ASSERTION_FAILURE;
    }
    return dwRes;
}   // CJob::Init

DWORD
CJob::UpdateStatus (
    PFAX_JOB_STATUS pStatus
)
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CJob::UpdateStatus"), dwRes);

    ASSERTION (m_bValid);
    ASSERTION (pStatus);

    m_dwValidityMask = m_dwJobOnlyValidityMask | (pStatus->dwValidityMask);

    try
    {
        //
        // Job id
        //
        ASSERTION (m_dwValidityMask & FAX_JOB_FIELD_JOB_ID);
        m_dwJobID = pStatus->dwJobID;
        //
        // Job type
        //
        ASSERTION (m_dwValidityMask & FAX_JOB_FIELD_TYPE);
        m_dwJobType = pStatus->dwJobType;
        //
        // Queue status
        //
        ASSERTION (m_dwValidityMask & FAX_JOB_FIELD_QUEUE_STATUS);
        m_dwQueueStatus = pStatus->dwQueueStatus;
        //
        // Extended status
        //
        m_dwExtendedStatus = pStatus->dwExtendedStatus;
        m_cstrExtendedStatus = pStatus->lpctstrExtendedStatus;
        //
        // Size
        //
        if (m_dwValidityMask & FAX_JOB_FIELD_SIZE)
        {
            m_dwSize = pStatus->dwSize;
        }
        else
        {
            m_dwSize = 0;
        }
        //
        // Page count
        //
        if (m_dwValidityMask & FAX_JOB_FIELD_PAGE_COUNT)
        {
            m_dwPageCount = pStatus->dwPageCount;
        }
        else
        {
            m_dwPageCount = 0;
        }
        //
        // Current page
        //
        if (m_dwValidityMask & FAX_JOB_FIELD_CURRENT_PAGE)
        {
            m_dwCurrentPage = pStatus->dwCurrentPage;
        }
        else
        {
            m_dwCurrentPage = 0;
        }
        //
        // TCID and CSID
        //
        m_cstrTsid = pStatus->lpctstrTsid;
        m_cstrCsid = pStatus->lpctstrCsid;
        //
        // Scheduled time
        //
        if (m_dwValidityMask & FAX_JOB_FIELD_SCHEDULE_TIME)
        {
            m_tmScheduleTime = pStatus->tmScheduleTime;
        }
        else
        {
            m_tmScheduleTime.Zero ();
        }
        //
        // Start time
        //
        if (m_dwValidityMask & FAX_JOB_FIELD_TRANSMISSION_START_TIME)
        {
            m_tmTransmissionStartTime = pStatus->tmTransmissionStartTime;
        }
        else
        {
            m_tmTransmissionStartTime.Zero ();
        }

        //
        // End time
        //
        if (m_dwValidityMask & FAX_JOB_FIELD_TRANSMISSION_END_TIME)
        {
            m_tmTransmissionEndTime = pStatus->tmTransmissionEndTime;
        }
        else
        {
            m_tmTransmissionEndTime.Zero ();
        }

        //
        // Device
        //
        m_dwDeviceID = pStatus->dwDeviceID;
        m_cstrDeviceName = pStatus->lpctstrDeviceName;
        //
        // Retries
        //
        if (m_dwValidityMask & FAX_JOB_FIELD_RETRIES)
        {
            m_dwRetries = pStatus->dwRetries;
        }
        else
        {
            m_dwRetries = 0;
        }
        //
        // Caller id and routing info
        //
        m_cstrCallerID = pStatus->lpctstrCallerID;
        m_cstrRoutingInfo = pStatus->lpctstrRoutingInfo;

        //
        // possible job operations
        //
        m_dwPossibleOperations = pStatus->dwAvailableJobOperations | FAX_JOB_OP_PROPERTIES;
    }
    catch (CException &ex)
    {
        TCHAR wszCause[1024];

        ex.GetErrorMessage (wszCause, 1024);
        VERBOSE (EXCEPTION_ERR,
                 TEXT("CJob::UpdateStatus caused exception : %s"),
                 wszCause);
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        m_bValid = FALSE;
        return dwRes;
    }

    ASSERTION (ERROR_SUCCESS == dwRes);
    return dwRes;
}   // CJob::UpdateStatus

const JobStatusType
CJob::GetStatus () const
/*++

Routine name : CJob::GetStatus

Routine description:

    Finds the current job status

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:


Return Value:

    Job status

--*/
{
    DBG_ENTER(TEXT("CJob::GetStatus"));

    ASSERTION (m_dwValidityMask & FAX_JOB_FIELD_STATUS_SUB_STRUCT);
    ASSERTION (m_dwValidityMask & FAX_JOB_FIELD_QUEUE_STATUS);

    DWORD dwQueueStatus = m_dwQueueStatus;
    //
    // Start by checking status modifiers:
    //
    if (dwQueueStatus & JS_PAUSED)
    {
        return JOB_STAT_PAUSED;
    }
    //
    // We igonre the JS_NOLINE modifier.
    // Remove the modifiers now.
    //
    dwQueueStatus &= ~(JS_PAUSED | JS_NOLINE);
    //
    // Check other status values
    //
    switch (dwQueueStatus)
    {
        case JS_PENDING:
            return JOB_STAT_PENDING;
        case JS_INPROGRESS:
        case JS_FAILED:      // The job is about to be deleted in a sec. Do not update status.
            return JOB_STAT_INPROGRESS;
        case JS_DELETING:
            return JOB_STAT_DELETING;
        case JS_RETRYING:
            return JOB_STAT_RETRYING;
        case JS_RETRIES_EXCEEDED:
            return JOB_STAT_RETRIES_EXCEEDED;
        case JS_COMPLETED:
            return JOB_STAT_COMPLETED;
        case JS_CANCELED:
            return JOB_STAT_CANCELED;
        case JS_CANCELING:
            return JOB_STAT_CANCELING;
        case JS_ROUTING:
            return JOB_STAT_ROUTING;
        default:
            ASSERTION_FAILURE;
            return (JobStatusType)-1;
    }
}   // CJob::StatusValue


DWORD
CJob::GetTiff (
    CString &cstrTiffLocation
) const
/*++

Routine name : CJob::GetTiff

Routine description:

    Retrieves the job's TIFF file from the server

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    cstrTiffLocation              [out]    - Name of TIFF file

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CJob::GetTiff"), dwRes);

    dwRes = CopyTiffFromServer (m_pServer,
                                m_dwlMessageId,
                                FAX_MESSAGE_FOLDER_QUEUE,
                                cstrTiffLocation);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("CopyTiffFromServer"), dwRes);
    }
    return dwRes;
}   // CJob::GetTiff

DWORD
CJob::DoJobOperation (
    DWORD dwJobOp
)
/*++

Routine name : CJob::DoJobOperation

Routine description:

    Performs an operation on the job

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    dwJobOp   [in]     - Operation.
                         Supported operations are:
                         FAX_JOB_OP_PAUSE, FAX_JOB_OP_RESUME,
                         FAX_JOB_OP_RESTART, and FAX_JOB_OP_DELETE.

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CJob::DoJobOperation"), dwRes);
    DWORD dwJobCommand;
    switch (dwJobOp)
    {
        case FAX_JOB_OP_PAUSE:
            dwJobCommand = JC_PAUSE;
            break;

        case FAX_JOB_OP_RESUME:
            dwJobCommand = JC_RESUME;
            break;

        case FAX_JOB_OP_RESTART:
            dwJobCommand = JC_RESTART;
            break;

        case FAX_JOB_OP_DELETE:
            dwJobCommand = JC_DELETE;
            break;

        default:
            ASSERTION_FAILURE;
            dwRes = ERROR_CAN_NOT_COMPLETE;
            return dwRes;
    }
    if (!(dwJobOp & GetPossibleOperations()))
    {
        VERBOSE (DBG_MSG, TEXT("Job can no longer do operation"));
        dwRes = ERROR_CAN_NOT_COMPLETE;
        return dwRes;
    }
    HANDLE hFax;
    dwRes = m_pServer->GetConnectionHandle (hFax);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("CServerNode::GetConnectionHandle"), dwRes);
        return dwRes;
    }

    FAX_JOB_ENTRY fje = {0};
    fje.SizeOfStruct = sizeof(FAX_JOB_ENTRY);

    START_RPC_TIME(TEXT("FaxSetJob"));
    if (!FaxSetJob (hFax,
                    m_dwJobID,
                    dwJobCommand,
                    &fje))
    {
        dwRes = GetLastError ();
        END_RPC_TIME(TEXT("FaxSetJob"));
        m_pServer->SetLastRPCError (dwRes);
        CALL_FAIL (RPC_ERR, TEXT("FaxSetJob"), dwRes);
        return dwRes;
    }
    END_RPC_TIME(TEXT("FaxSetJob"));

    ASSERTION (ERROR_SUCCESS == dwRes);
    return dwRes;
}   // CJob::DoJobOperation


DWORD
CJob::Copy(
    const CJob& other
)
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CJob::Copy"), dwRes);

    try
    {
        m_dwlMessageId = other.m_dwlMessageId;
        m_dwlBroadcastId = other.m_dwlBroadcastId;
        m_dwValidityMask = other.m_dwValidityMask;
        m_dwJobOnlyValidityMask = other.m_dwJobOnlyValidityMask;
        m_dwJobID = other.m_dwJobID;
        m_dwJobType = other.m_dwJobType;
        m_dwQueueStatus = other.m_dwQueueStatus;
        m_dwExtendedStatus = other.m_dwExtendedStatus;
        m_dwSize = other.m_dwSize;
        m_dwPageCount = other.m_dwPageCount;
        m_dwCurrentPage = other.m_dwCurrentPage;
        m_dwDeviceID = other.m_dwDeviceID;
        m_dwRetries = other.m_dwRetries;
        m_cstrRecipientNumber = other.m_cstrRecipientNumber;
        m_cstrRecipientName = other.m_cstrRecipientName;
        m_cstrSenderUserName = other.m_cstrSenderUserName;
        m_cstrBillingCode = other.m_cstrBillingCode;
        m_cstrDocumentName = other.m_cstrDocumentName;
        m_cstrSubject = other.m_cstrSubject;
        m_cstrExtendedStatus = other.m_cstrExtendedStatus;
        m_cstrTsid = other.m_cstrTsid;
        m_cstrCsid = other.m_cstrCsid;
        m_cstrDeviceName = other.m_cstrDeviceName;
        m_cstrCallerID = other.m_cstrCallerID;
        m_cstrRoutingInfo = other.m_cstrRoutingInfo;
        m_tmOriginalScheduleTime = other.m_tmOriginalScheduleTime;
        m_tmSubmissionTime = other.m_tmSubmissionTime;
        m_tmScheduleTime = other.m_tmScheduleTime;
        m_tmTransmissionStartTime = other.m_tmTransmissionStartTime;
        m_tmTransmissionEndTime = other.m_tmTransmissionEndTime;
        m_Priority = other.m_Priority;
        m_dwPossibleOperations = other.m_dwPossibleOperations;
        m_cstrServerName = other.m_cstrServerName;

        m_bValid = other.m_bValid;
    }
    catch(...)
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
    }

    return dwRes;

} // CJob::Copy
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\job.h ===
// Job.h: interface for the CJob class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_JOB_H__0021D6D0_519B_42BA_85C7_8C9E600E408A__INCLUDED_)
#define AFX_JOB_H__0021D6D0_519B_42BA_85C7_8C9E600E408A__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


//
// Possible operations on a job / message
//
enum
{
    FAX_JOB_OP_PROPERTIES = 0x0080,
    FAX_JOB_OP_ALL        = FAX_JOB_OP_VIEW        | FAX_JOB_OP_PAUSE          | 
                            FAX_JOB_OP_RESUME      | FAX_JOB_OP_RESTART        | 
                            FAX_JOB_OP_DELETE      | FAX_JOB_OP_RECIPIENT_INFO | 
                            FAX_JOB_OP_SENDER_INFO | FAX_JOB_OP_PROPERTIES
};


class CJob : public CFaxMsg
{
public:

    DECLARE_DYNCREATE(CJob)

    //
    // Init / shutdown:
    //
    CJob () {}
    virtual ~CJob() {}


    DWORD Init (PFAX_JOB_ENTRY_EX pJob, CServerNode* pServer);
    DWORD UpdateStatus (PFAX_JOB_STATUS pStatus);

    DWORD Copy(const CJob& other);

    //
    // Operations:
    //
    DWORD GetTiff (CString &cstrTiffLocation) const;
    DWORD Pause ()
        { return DoJobOperation (FAX_JOB_OP_PAUSE); }

    DWORD Resume ()
        { return DoJobOperation (FAX_JOB_OP_RESUME); }

    DWORD Restart ()
        { return DoJobOperation (FAX_JOB_OP_RESTART); }

    DWORD Delete ()
        { return DoJobOperation (FAX_JOB_OP_DELETE); }
    //
    // Item retrival:
    //
        
    const JobStatusType GetStatus () const;

    const CString &GetExtendedStatusString () const  
        { ASSERT (m_bValid); return m_cstrExtendedStatus; }

    const DWORD GetCurrentPage () const
        { ASSERT (m_bValid); return m_dwCurrentPage; }

    const CFaxTime &GetScheduleTime () const    
        { ASSERT (m_bValid); return m_tmScheduleTime; }


private:

    DWORD DoJobOperation (DWORD dwJobOp);

    DWORD     m_dwCurrentPage; 

    CString   m_cstrExtendedStatus; 

    CFaxTime  m_tmScheduleTime; 
};


#endif // !defined(AFX_JOB_H__0021D6D0_519B_42BA_85C7_8C9E600E408A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\leftview.cpp ===
// LeftView.cpp : implementation of the CLeftView class
//

#include "stdafx.h"
#define __FILE_ID__     4

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern CClientConsoleApp theApp;

CImageList  CLeftView::m_ImageList;

/////////////////////////////////////////////////////////////////////////////
// CLeftView

IMPLEMENT_DYNCREATE(CLeftView, CTreeView)

BEGIN_MESSAGE_MAP(CLeftView, CTreeView)
    //{{AFX_MSG_MAP(CLeftView)
    ON_NOTIFY_REFLECT(TVN_SELCHANGED, OnTreeSelChanged)
    ON_NOTIFY_REFLECT(NM_RCLICK, OnRightClick)
    ON_WM_CHAR( )
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CLeftView construction/destruction

CLeftView::CLeftView() :
    m_treeitemRoot (NULL),
    m_pCurrentView(NULL),
    m_iLastActivityStringId(0)
{}

CLeftView::~CLeftView()
{}

BOOL CLeftView::PreCreateWindow(CREATESTRUCT& cs)
{
    return CTreeView::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CLeftView drawing

void CLeftView::OnDraw(CDC* pDC)
{
    CClientConsoleDoc* pDoc = GetDocument();
    ASSERT_VALID(pDoc);
}


DWORD 
CLeftView::RefreshImageList ()
{
    HIMAGELIST himl = NULL;
    DWORD dwRes = ERROR_SUCCESS;

    DBG_ENTER(TEXT("CLeftView::RefreshImageList"), dwRes);
    //
    // Build and load the image list
    //
    himl = m_ImageList.Detach();
    if (himl)
    {
        ImageList_Destroy(himl);
    }
    himl = ImageList_LoadImage(AfxGetResourceHandle(), 
                               MAKEINTRESOURCE(IDB_TREE_IMAGES), 
                               16, 
                               0,
                               RGB(0, 255, 0), 
                               IMAGE_BITMAP, 
                               LR_LOADTRANSPARENT | LR_CREATEDIBSECTION);
    if (NULL == himl)
    {
        dwRes = GetLastError();
        CALL_FAIL (RESOURCE_ERR, TEXT("ImageList_LoadImage"), dwRes);
    }
    else
    {
        m_ImageList.Attach (himl);
    }
    GetTreeCtrl().SetImageList (&m_ImageList, TVSIL_NORMAL);
    return dwRes;
}   // CLeftView::RefreshImageList

void CLeftView::OnInitialUpdate()
{
    DWORD dwRes;
    DBG_ENTER(TEXT("CLeftView::OnInitialUpdate"));

    CTreeView::OnInitialUpdate();
 
    CClientConsoleDoc* pDoc = GetDocument();
    if(!pDoc)
    {
        ASSERTION(pDoc);
        PopupError (ERROR_GEN_FAILURE);
        return;
    }
    
    //
    // Set the style of the tree 
    //
    CTreeCtrl &Tree = GetTreeCtrl();
    LONG lWnd = GetWindowLong (Tree.m_hWnd, GWL_STYLE);
    if (!lWnd)
    {
        dwRes = GetLastError ();
        CALL_FAIL (WINDOW_ERR, TEXT("GetWindowLong"), dwRes);
        PopupError (dwRes);
        return;
    }
    lWnd |= (TVS_HASLINES           |   // Lines between node
             TVS_HASBUTTONS         |   // Tree has +/- (expand/collapse) buttons
             TVS_INFOTIP            |   // Allow tooltip messages
             TVS_LINESATROOT        |   // Root object has lines
             TVS_SHOWSELALWAYS          // Always show selected node
            );
    if (!SetWindowLong (Tree.m_hWnd, GWL_STYLE, lWnd))
    {
        dwRes = GetLastError ();
        CALL_FAIL (WINDOW_ERR, TEXT("SetWindowLong"), dwRes);
        PopupError (dwRes);
        return;
    }
    RefreshImageList();
    //
    // Create the 4 views of the 4 different folder types.
    //
    CMainFrame *pFrm = GetFrm();
    if (!pFrm)
    {
        //
        //  Shutdown in progress
        //
        return;
    }

    dwRes = pFrm->CreateFolderViews (GetDocument());
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("CMainFrame::CreateFolderViews"), dwRes);
        PopupError (dwRes);
        return;
    }

    //
    // Build root node
    //
    CString cstrNodeName;
    dwRes = LoadResourceString (cstrNodeName, IDS_TREE_ROOT_NAME);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("LoadResourceString"), dwRes);
        PopupError (dwRes);
        return;
    }

    CString& cstrSingleServer =  pDoc->GetSingleServerName();
    if(!cstrSingleServer.IsEmpty())
    {
        CString cstrRoot;
        try
        {
            cstrRoot.Format(TEXT("%s (%s)"), cstrNodeName, cstrSingleServer);
            cstrNodeName = cstrRoot;
        }
        catch(...)
        {
            dwRes = ERROR_NOT_ENOUGH_MEMORY;
            CALL_FAIL (MEM_ERR, TEXT("CString operation"), dwRes);
            PopupError (dwRes);
            return;
        }
    }

    m_treeitemRoot = Tree.InsertItem (cstrNodeName);
    if (NULL == m_treeitemRoot)
    {
        dwRes = ERROR_GEN_FAILURE;
        CALL_FAIL (WINDOW_ERR, TEXT("CTreeCtrl::InsertItem"), dwRes);
        PopupError (dwRes);
        return;
    }
    Tree.SetItemImage (m_treeitemRoot, TREE_IMAGE_ROOT, TREE_IMAGE_ROOT);
    //
    // Set the item data of the root to NULL.
    //
    Tree.SetItemData  (m_treeitemRoot, 0);


    HTREEITEM hItemIncoming;
    HTREEITEM hItemInbox;
    HTREEITEM hItemOutbox;
    HTREEITEM hItemSentItems;

    //
    // Add Incoming
    //
    dwRes = SyncFolderNode (m_treeitemRoot,                  // Parent node
                            TRUE,                            // Visible?
                            IDS_TREE_NODE_INCOMING,          // node string
                            TVI_LAST,                        // Insert after (= TVI_FIRST)
                            TREE_IMAGE_INCOMING,             // Normal icon
                            TREE_IMAGE_INCOMING,             // Selected icon
                            (LPARAM)pFrm->GetIncomingView(), // Node's data
                            hItemIncoming);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (WINDOW_ERR, TEXT("SyncFolderNode"), dwRes);
        PopupError (dwRes);
        return;
    }

    //
    // Add Inbox
    //
    dwRes = SyncFolderNode (m_treeitemRoot,                // Parent node
                            TRUE,                          // Visible?
                            IDS_TREE_NODE_INBOX,           // node string
                            TVI_LAST,                      // Insert after (= TVI_FIRST)
                            TREE_IMAGE_INBOX,              // Normal icon
                            TREE_IMAGE_INBOX,              // Selected icon
                            (LPARAM)pFrm->GetInboxView(),  // Node's data
                            hItemInbox);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (WINDOW_ERR, TEXT("SyncFolderNode"), dwRes);
        PopupError (dwRes);
        return;
    }

    //
    // Add Outbox
    //
    dwRes = SyncFolderNode (m_treeitemRoot,                 // Parent node
                            TRUE,                           // Visible?
                            IDS_TREE_NODE_OUTBOX,           // node string
                            TVI_LAST,                       // Insert after (= TVI_FIRST)
                            TREE_IMAGE_OUTBOX,              // Normal icon
                            TREE_IMAGE_OUTBOX,              // Selected icon
                            (LPARAM)pFrm->GetOutboxView(),  // Node's data
                            hItemOutbox);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (WINDOW_ERR, TEXT("SyncFolderNode"), dwRes);
        PopupError (dwRes);
        return;
    }

    //
    // Add SentItems
    //
    dwRes = SyncFolderNode (m_treeitemRoot,                 // Parent node
                            TRUE,                           // Visible?
                            IDS_TREE_NODE_SENT_ITEMS,       // node string
                            TVI_LAST,                       // Insert after (= TVI_FIRST)
                            TREE_IMAGE_INBOX,               // Normal icon
                            TREE_IMAGE_INBOX,               // Selected icon
                            (LPARAM)pFrm->GetSentItemsView(),// Node's data
                            hItemSentItems);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (WINDOW_ERR, TEXT("SyncFolderNode"), dwRes);
        PopupError (dwRes);
        return;
    }
    //
    // Expand the root to expose all the servers
    //
    Tree.Expand (m_treeitemRoot, TVE_EXPAND);    


    dwRes = pDoc->RefreshServersList();
    if(ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("CClientConsoleDoc::RefreshServersList"), dwRes);
        PopupError (dwRes);
        return;
    }


    if(theApp.IsCmdLineOpenFolder())
    {
        //
        // select folder according to command line
        //
        SelectFolder (theApp.GetCmdLineFolderType());
    }

#ifdef UNICODE
    DetectImportFiles();
#endif // UNICODE
}   // CLeftView::OnInitialUpdate


VOID
CLeftView::SelectFolder (
    FolderType type
)
{
    DBG_ENTER(TEXT("CLeftView::SelectFolder"), TEXT("type=%ld"), type);
    CFolderListView *pView = NULL;
    INT iNodeStringResource;
    CMainFrame *pFrm = GetFrm();
    if (!pFrm)
    {
        //
        //  Shutdown in progress
        //
        return;
    }
    switch(type)
    {
        case FOLDER_TYPE_INCOMING:
            iNodeStringResource = IDS_TREE_NODE_INCOMING;
            pView = pFrm->GetIncomingView();
            break;
        case FOLDER_TYPE_INBOX:
            iNodeStringResource = IDS_TREE_NODE_INBOX;
            pView = pFrm->GetInboxView();
            break;
        case FOLDER_TYPE_OUTBOX:
            iNodeStringResource = IDS_TREE_NODE_OUTBOX;
            pView = pFrm->GetOutboxView();
            break;
        case FOLDER_TYPE_SENT_ITEMS:
            iNodeStringResource = IDS_TREE_NODE_SENT_ITEMS;
            pView = pFrm->GetSentItemsView();
            break;
        default:
            ASSERTION_FAILURE
            return;
    }

    HTREEITEM hItem;
    CString cstrNodeName;
    //
    // Retrieve node's title string
    //
    if (ERROR_SUCCESS != LoadResourceString (cstrNodeName, iNodeStringResource))
    {
        return;
    }

    hItem = FindNode (GetTreeCtrl().GetRootItem(), cstrNodeName);
    if (!hItem)
    {
        ASSERTION_FAILURE
        return;
    }
    if(!GetTreeCtrl().Select(hItem, TVGN_CARET))
    {
        CALL_FAIL (WINDOW_ERR, TEXT("CTreeCtrl::Select"), ERROR_CAN_NOT_COMPLETE);
    }

    //
    // Force data change while handling this message, otherwise the current view is not changed until the 
    // notification message reaches the left view.
    //
    ASSERTION (pView);
    NM_TREEVIEW nmtv = {0};
    LRESULT     lr;
    nmtv.itemNew.lParam = (LPARAM)pView;
    OnTreeSelChanged ((NMHDR*)&nmtv, &lr);
}   // CLeftView::SelectFolder

/////////////////////////////////////////////////////////////////////////////
// CLeftView diagnostics

#ifdef _DEBUG
void CLeftView::AssertValid() const
{
    CTreeView::AssertValid();
}

void CLeftView::Dump(CDumpContext& dc) const
{
    CTreeView::Dump(dc);
}

CClientConsoleDoc* CLeftView::GetDocument() // non-debug version is inline
{
    ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CClientConsoleDoc)));
    return (CClientConsoleDoc*)m_pDocument;
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CLeftView message handlers

HTREEITEM
CLeftView::FindNode (
    HTREEITEM hRoot,
    CString &cstrNodeString
)
/*++

Routine name : CLeftView::FindNode

Routine description:

    Finds a node in the tree that has a specific string

Author:

    Eran Yariv (EranY), Feb, 2000

Arguments:

    hRoot            [in] - Root of search: all direct sons (only) of root will be searched
    cstrNodeString   [in] - String to look for

Return Value:

    Handle to found tree item, NULL if not found

--*/
{
    CTreeCtrl &refTree = GetTreeCtrl();
    for (HTREEITEM hChildItem = refTree.GetChildItem (hRoot); 
         hChildItem != NULL;
         hChildItem = refTree.GetNextSiblingItem (hChildItem))
    {
        if (cstrNodeString == refTree.GetItemText (hChildItem))
        {
            //
            // Match found
            //
            return hChildItem;
        }
    }
    return NULL;
}   // CLeftView::FindNode

DWORD 
CLeftView::SyncFolderNode (
    HTREEITEM       hParent,
    BOOL            bVisible,
    int             iNodeStringResource,
    HTREEITEM       hInsertAfter,
    TreeIconType    iconNormal,
    TreeIconType    iconSelected,
    LPARAM          lparamNodeData,
    HTREEITEM      &hNode
)
/*++

Routine name : CLeftView::SyncFolderNode

Routine description:

    Synchronizes a tree folder

Author:

    Eran Yariv (EranY), Feb, 2000

Arguments:

    hParent               [in]     - Parent node
    bVisible              [in]     - Should the node be visible?
    iNodeStringResource   [in]     - Resource of node's title string
    hInsertAfter          [in]     - Sibling to insert after (must exist)
    iconNormal            [in]     - Icon of normal image
    iconSelected          [in]     - Icon of selected image
    lparamNodeData        [in]     - Node assigned data
    hNode                 [out]    - Node tree item (changed only if node had to be created).
                                     Set to NULL if node was removed.

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CLeftView::SyncFolderNode"), dwRes);

    CString cstrNodeName;
    //
    // Retrieve node's title string
    //
    dwRes = LoadResourceString (cstrNodeName, iNodeStringResource);
    if (ERROR_SUCCESS != dwRes)
    {
        return dwRes;
    }
    CTreeCtrl &refTree = GetTreeCtrl();
    hNode = FindNode (hParent, cstrNodeName);
    if (!bVisible)
    {
        //
        // The node should not be visible at all
        //
        if (hNode)
        {
            if (refTree.GetSelectedItem () == hNode)
            {
                //
                // If the node is currently selected, select its parent
                //
                refTree.SelectItem (hParent);
            }
            //
            // Remove node
            //
            if (!refTree.DeleteItem (hNode))
            {
                dwRes = ERROR_GEN_FAILURE;
                CALL_FAIL (WINDOW_ERR, TEXT("CTreeCtrl::DeleteItem"), dwRes);
                return dwRes;
            }
        }
        hNode = NULL;
    }
    else
    {
        //
        // The node should be visible
        //
        if (!hNode)
        {
            //
            // Node does not exist, create it
            //
            TVINSERTSTRUCT tvis;
            tvis.hParent = hParent;
            tvis.hInsertAfter = hInsertAfter;
            tvis.item.mask = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM;
            tvis.item.pszText = const_cast<LPTSTR> ((LPCTSTR) cstrNodeName);
            tvis.item.iImage = iconNormal;
            tvis.item.iSelectedImage = iconSelected;
            tvis.item.state = 0;
            tvis.item.stateMask = 0;
            tvis.item.lParam = lparamNodeData;
            hNode = refTree.InsertItem (&tvis);
            if (NULL == hNode)
            {
                dwRes = ERROR_GEN_FAILURE;
                CALL_FAIL (WINDOW_ERR, TEXT("CTreeCtrl::InsertItem"), dwRes);
                return dwRes;
            }
        }
        else
        {
            //
            // Node already exists, just update its image and assigned data
            //
            TVITEM tvi;
  
            tvi.hItem  = hNode;
            tvi.mask   = TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM;
            tvi.iImage = iconNormal;
            tvi.iSelectedImage = iconSelected;
            tvi.lParam = lparamNodeData;
            if (!refTree.SetItem (&tvi))
            {
                dwRes = ERROR_GEN_FAILURE;
                CALL_FAIL (WINDOW_ERR, TEXT("CTreeCtrl::SetItem"), dwRes);
                return dwRes;
            }
        }
    }
    ASSERTION (ERROR_SUCCESS == dwRes);
    return dwRes;
}   // CLeftView::SyncFolderNode


void 
CLeftView::OnTreeSelChanged(
    NMHDR* pNMHDR, 
    LRESULT* pResult
) 
/*++

Routine name : CLeftView::OnTreeSelChanged

Routine description:

    Called by the framework when a node is selected in the tree

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    pNMHDR          [in ] - Pointer to structure describing old and new node
    pResult         [out] - Result

Return Value:

    None.

--*/
{
    NM_TREEVIEW* pNMTreeView = (NM_TREEVIEW*)pNMHDR;
    DBG_ENTER(TEXT("CLeftView::OnTreeSelChanged"));
    
    *pResult = 0;

    //
    // Retrieve item data of new node and cast to CObject
    //
    CFolderListView*  pFolderView = (CFolderListView*) pNMTreeView->itemNew.lParam;


    if (GetCurrentView() == pFolderView)
    {
        //
        // Hey, that folder is ALREADY the current one.
        // No change required.
        //
        VERBOSE (DBG_MSG, TEXT("Requested folder is already the current one. No change performed."));
        return;
    }

    CMainFrame *pFrm = GetFrm();
    if (!pFrm)
    {
        //
        //  Shutdown in progress
        //
        return;
    }

    pFrm->SwitchRightPaneView (pFolderView);
    m_pCurrentView = pFolderView;

    if(NULL == pFolderView)
    {
        SetFocus();
        return;
    }
    
    FolderType type = m_pCurrentView->GetType();

    GetDocument()->ViewFolder(type);
    
    SetFocus();

    if(FOLDER_TYPE_OUTBOX == type)
    {
        theApp.OutboxViewed();
    }

}   // CLeftView::OnTreeSelChanged


BOOL 
CLeftView::CanRefreshFolder()   
/*++

Routine name : CLeftView::CanRefreshFolder

Routine description:

    does the user can referesh curent folder

Author:

    Alexander Malysh (AlexMay), May, 2000

Arguments:


Return Value:

    TRUE if yes, FALSE otherwise.

--*/
{ 
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CLeftView::CanRefreshFolder"));

    BOOL  bRefreshing;
    DWORD dwOffLineCount;

    GetServerState(bRefreshing, dwOffLineCount);

    return !bRefreshing;
}


DWORD
CLeftView::RefreshCurrentFolder ()
/*++

Routine name : CLeftView::RefreshCurrentFolder

Routine description:

    Causes a refresh of the currently displayed folder (right pane)

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:


Return Value:

    Standard win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CLeftView::RefreshCurrentFolder"), dwRes);

    CClientConsoleDoc* pDoc = GetDocument();
    if(!pDoc)
    {
        ASSERTION(pDoc);
        return dwRes;
    }

    if(!m_pCurrentView)
    {
        //
        // root is selected
        //
        // clear all the folders
        //
        CMainFrame *pFrm = GetFrm();
        if (!pFrm)
        {
            //
            //  Shutdown in progress
            //
            return dwRes;
        }

        pFrm->GetIncomingView()->OnUpdate(NULL, UPDATE_HINT_CLEAR_VIEW, NULL);
        pFrm->GetInboxView()->OnUpdate(NULL, UPDATE_HINT_CLEAR_VIEW, NULL);
        pFrm->GetSentItemsView()->OnUpdate(NULL, UPDATE_HINT_CLEAR_VIEW, NULL);
        pFrm->GetOutboxView()->OnUpdate(NULL, UPDATE_HINT_CLEAR_VIEW, NULL);

        pDoc->SetInvalidFolder(FOLDER_TYPE_INBOX);
        pDoc->SetInvalidFolder(FOLDER_TYPE_OUTBOX);
        pDoc->SetInvalidFolder(FOLDER_TYPE_SENT_ITEMS);
        pDoc->SetInvalidFolder(FOLDER_TYPE_INCOMING);

        //
        // refresh server status
        //
        CServerNode* pServerNode;
        const SERVERS_LIST& srvList = pDoc->GetServersList();
        for (SERVERS_LIST::iterator it = srvList.begin(); it != srvList.end(); ++it)
        {
            pServerNode = *it;
            pServerNode->RefreshState();
        }

        return dwRes;
    }

    FolderType type = m_pCurrentView->GetType();

    //
    // clear view
    // 
    m_pCurrentView->OnUpdate(NULL, UPDATE_HINT_CLEAR_VIEW, NULL);

    //
    // Invalidate Folder
    //
    pDoc->SetInvalidFolder(type);

    //
    // refresh folder
    //
    pDoc->ViewFolder(type);

    return dwRes;
}   // CLeftView::RefreshCurrentFolder

DWORD
CLeftView::OpenSelectColumnsDlg()
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CLeftView::OpenSelectColumnsDlg"), dwRes);
    ASSERTION(m_pCurrentView);

    dwRes = m_pCurrentView->OpenSelectColumnsDlg();
    if(ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("CFolderListView::OpenSelectColumnsDlg"), dwRes);
    }

    return dwRes;
}

void 
CLeftView::GetServerState(
    BOOL&  bRefreshing, 
    DWORD& dwOffLineCount
)
/*++

Routine name : CLeftView::GetServerState

Routine description:

    calculate servers status

Author:

    Alexander Malysh (AlexMay), May, 2000

Arguments:

    bRefreshing                   [out]    - is one of servers or folder refreshing
    dwOffLineCount                [out]    - a number of offline servers

Return Value:

    None.

--*/
{
    DWORD dwRes = ERROR_SUCCESS;

    bRefreshing    = FALSE;
    dwOffLineCount = 0;

    const SERVERS_LIST& srvList = GetDocument()->GetServersList();

    FolderType type;
    CServerNode* pServerNode;
    for (SERVERS_LIST::iterator it = srvList.begin(); it != srvList.end(); ++it)
    {
        pServerNode = *it;

        if(m_pCurrentView)
        {
            //
            // is refreshing ?
            //
            type = m_pCurrentView->GetType();
            if(pServerNode->GetFolder(type)->IsRefreshing())
            {
                bRefreshing = TRUE;
            }
        }
        else
        {
            //
            // root selected
            //
            if(pServerNode->GetFolder(FOLDER_TYPE_INBOX)->IsRefreshing()      ||
               pServerNode->GetFolder(FOLDER_TYPE_OUTBOX)->IsRefreshing()     ||
               pServerNode->GetFolder(FOLDER_TYPE_SENT_ITEMS)->IsRefreshing() ||
               pServerNode->GetFolder(FOLDER_TYPE_INCOMING)->IsRefreshing())
            {
                bRefreshing = TRUE;
            }
        }

        if(pServerNode->IsRefreshing())
        {
            bRefreshing = TRUE;
        }
        else if(!pServerNode->IsOnline())
        {
            ++dwOffLineCount;
        }
    }
}

BOOL 
CLeftView::GetActivity(
    CString &cstr,
    HICON& hIcon
)
/*++

Routine name : CLeftView::GetActivity

Routine description:

    calculate status bar activity string and icon

Author:

    Alexander Malysh (AlexMay), Apr, 2000

Arguments:

    cstr                          [out]    - activity string
    hIcon                         [out]    - icon

Return Value:

    TRUE if any activity, FALSE otherwise.

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    BOOL  bRes        = TRUE;
    DWORD dwOffLine   = 0;
    BOOL  bRefreshing = FALSE;
    int   nIconRes     = 0;
    int   nStringRes   = 0;
    DWORD dwServerCount = GetDocument()->GetServerCount();

    GetServerState(bRefreshing, dwOffLine);

    if(0 == dwServerCount)
    {
        //
        // no fax printer install
        //
        nIconRes   = IDI_SRV_WRN;
        nStringRes = IDS_NO_SRV_INSTALL;
    }
    else if(bRefreshing)
    {
        nIconRes   = IDI_SRV_WAIT;
        nStringRes = IDS_FOLDER_REFRESHING;
    }
    else if(dwOffLine)
    {
        nIconRes = IDI_SRV_WRN;

        if(dwServerCount == dwOffLine)
        {
            nStringRes = IDS_SRV_OFFLINE;
        }
        else
        {
            nStringRes = IDS_SRV_PART_OFFLINE;
        }
    }
    else
    {
        //
        // online
        //
        nIconRes   = IDI_SRV_OK;
        nStringRes = IDS_SRV_ONLINE;
    }

    if (m_iLastActivityStringId != nStringRes)
    {
        if (m_pCurrentView)
        {
            //
            // Force a recalc of the mouse cursor
            //
            m_pCurrentView->PostMessage (WM_SETCURSOR, 0, 0);
        }
        m_iLastActivityStringId = nStringRes;
    }

    if(0 != nStringRes)
    {
        //
        // load string
        //
        dwRes = LoadResourceString (cstr, nStringRes);
        if (ERROR_SUCCESS != dwRes)
        {
            bRes = FALSE;
        }
    }

    //
    // load icon
    //
    if(0 != nIconRes)
    {
        hIcon = (HICON)LoadImage(GetResourceHandle(), 
                                 MAKEINTRESOURCE(nIconRes), 
                                 IMAGE_ICON, 
                                 16, 
                                 16, 
                                 LR_SHARED);
        if(NULL == hIcon)
        {
            DBG_ENTER(TEXT("CLeftView::GetActivity"));
            dwRes = GetLastError();
            CALL_FAIL (RESOURCE_ERR, TEXT("LoadImage"), dwRes);
            bRes = FALSE;
        }
    }
    return bRes;
}   // CLeftView::GetActivityString





void 
CLeftView::OnRightClick(
    NMHDR* pNMHDR, 
    LRESULT* pResult
) 
/*++

Routine name : CLeftView::OnRightClick

Routine description:

    mouse right click handler

Author:

    Alexander Malysh (AlexMay), Feb, 2000

Arguments:

    pNMHDR                        [in]     - message info
    pResult                       [out]    - result

Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CLeftView::OnRightClick"));

    *pResult = 0;

    //
    // get cursor position
    //
    CPoint ptScreen(GetMessagePos());

    CPoint ptClient(ptScreen);
    ScreenToClient(&ptClient);

    UINT nFlags;
    CTreeCtrl &refTree = GetTreeCtrl();
    HTREEITEM hItem = refTree.HitTest(ptClient, &nFlags);

    if(0 == hItem)
    {
        return;
    }

    //
    // select the item
    //
    BOOL bRes = refTree.Select(hItem, TVGN_CARET);
    if(!bRes)
    {
        CALL_FAIL (WINDOW_ERR, TEXT("CTreeCtrl::Select"), ERROR_GEN_FAILURE);
        return;
    }

    //
    // TODO
    //
    return;

    int nMenuResource = 0;

    if (NULL == m_pCurrentView)
    {
        nMenuResource = IDM_TREE_ROOT_OPTIONS;
    }
    else
    {
        switch(m_pCurrentView->GetType())
        {
        case FOLDER_TYPE_OUTBOX:
            nMenuResource = IDM_OUTBOX_FOLDER;
            break;
        case FOLDER_TYPE_INCOMING:
        case FOLDER_TYPE_INBOX:
        case FOLDER_TYPE_SENT_ITEMS:
            break;
        default:
            ASSERTION_FAILURE
            break;
        }
    }
        
    if(0 == nMenuResource)
    {
        return;
    }

    //
    // popup menu
    //
    CMenu mnuContainer;
    if (!mnuContainer.LoadMenu (nMenuResource))
    {
        CALL_FAIL (RESOURCE_ERR, TEXT("CMenu::LoadMenu"), ERROR_GEN_FAILURE);
        return;
    }

    CMenu* pmnuPopup = mnuContainer.GetSubMenu (0);
    ASSERTION (pmnuPopup);
    if (!pmnuPopup->TrackPopupMenu (TPM_LEFTALIGN, 
                                    ptScreen.x, 
                                    ptScreen.y, 
                                    AfxGetMainWnd ()))
    {
        CALL_FAIL (RESOURCE_ERR, TEXT("CMenu::TrackPopupMenu"), ERROR_GEN_FAILURE);
    }   
} // CLeftView::OnRightClick



DWORD 
CLeftView::RemoveTreeItem(
    HTREEITEM hItem
)
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CLeftView::RemoveTreeItem"), dwRes);

    ASSERTION(hItem);

    CTreeCtrl &refTree = GetTreeCtrl();
    
    if(!refTree.DeleteItem(hItem))
    {
        dwRes = ERROR_CAN_NOT_COMPLETE;
        CALL_FAIL (WINDOW_ERR, TEXT("CTreeCtrl::DeleteItem"), dwRes);
        return dwRes;
    }

    return dwRes;
}


DWORD 
CLeftView::SelectRoot()
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CLeftView::SelectRoot"), dwRes);

    CTreeCtrl &refTree = GetTreeCtrl();

    if(!refTree.Select(m_treeitemRoot, TVGN_CARET))
    {
        dwRes = ERROR_CAN_NOT_COMPLETE;
        CALL_FAIL (WINDOW_ERR, TEXT("CTreeCtrl::Select"), dwRes);
        return dwRes;
    }

    return dwRes;
}


DWORD 
CLeftView::OpenHelpTopic()
/*++

Routine name : CLeftView::OpenHelpTopic

Routine description:

    open appropriate help topic according to current selection

Author:

    Alexander Malysh (AlexMay), Mar, 2000

Arguments:


Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CLeftView::OpenHelpTopic"), dwRes);

    TCHAR* tszHelpTopic = FAX_HELP_WELCOME;

    if(NULL != m_pCurrentView)
    {
        switch(m_pCurrentView->GetType())
        {
        case FOLDER_TYPE_INCOMING:
            tszHelpTopic = FAX_HELP_INCOMING;
            break;
        case FOLDER_TYPE_INBOX:
            tszHelpTopic = FAX_HELP_INBOX;
            break;
        case FOLDER_TYPE_OUTBOX:
            tszHelpTopic = FAX_HELP_OUTBOX;
            break;
        case FOLDER_TYPE_SENT_ITEMS:
            tszHelpTopic = FAX_HELP_SENTITEMS;
            break;
        default:
            ASSERTION_FAILURE
            break;
        }
    }

    dwRes = ::HtmlHelpTopic(m_hWnd, tszHelpTopic);
    if(ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("HtmlHelpTopic"),dwRes);
    }

    return dwRes;

} // CLeftView::OpenHelpTopic

int 
CLeftView::GetDataCount()
{
    int nCount = -1;
    if(NULL != m_pCurrentView)
    {
        FolderType type = m_pCurrentView->GetType();

        nCount = GetDocument()->GetFolderDataCount(type);
    }

    return nCount;
}

void 
CLeftView::OnChar( 
    UINT nChar, 
    UINT nRepCnt, 
    UINT nFlags 
)
/*++

Routine name : CFolderListView::OnChar

Routine description:

    The framework calls this member function when a keystroke translates 
    to a nonsystem character

Arguments:

  nChar     [in] - Contains the character code value of the key.
  nRepCnt   [in] - Contains the repeat count
  nFlags    [in] - Contains the scan code

Return Value:

    None.

--*/
{
    if(VK_TAB == nChar)
    {
        if(m_pCurrentView)
        {
            m_pCurrentView->SetFocus();
        }
    }
    else
    {
        CTreeView::OnChar(nChar, nRepCnt, nFlags);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\message.cpp ===
// Message.cpp: implementation of the CArchiveMsg class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#define __FILE_ID__     13

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNCREATE(CArchiveMsg, CObject)

DWORD 
CArchiveMsg::Init (
    PFAX_MESSAGE pMsg,
    CServerNode* pServer
)
/*++

Routine name : CArchiveMsg::Init

Routine description:

    Constructs a new message from a FAX_MESSAGE structure

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    pMsg            [in] - Pointer to FAX_MESSAGE structure
    pServer         [in] - pointer to CServerNode object

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CArchiveMsg::Init"), dwRes);

    ASSERTION(pServer);

    m_pServer = pServer;

    m_bValid = FALSE;
    try
    {
        m_dwValidityMask = pMsg->dwValidityMask;
        //
        // Message id
        //        
        ASSERTION (m_dwValidityMask & FAX_JOB_FIELD_MESSAGE_ID);
        m_dwlMessageId = pMsg->dwlMessageId;

        //
        // Broadcast id
        //
        m_dwlBroadcastId = (m_dwValidityMask & FAX_JOB_FIELD_BROADCAST_ID) ? 
                            pMsg->dwlBroadcastId : 0;

        //
        // Job type
        //
        ASSERTION (m_dwValidityMask & FAX_JOB_FIELD_TYPE);
        m_dwJobType = pMsg->dwJobType;
        //
        // Extended status
        //
        m_dwExtendedStatus = (m_dwValidityMask & FAX_JOB_FIELD_STATUS_EX) ?
                                                 pMsg->dwExtendedStatus : 0;
        //
        // Job size
        //
        m_dwSize = (m_dwValidityMask & FAX_JOB_FIELD_SIZE) ? pMsg->dwSize : 0;

        //
        // Page count
        //
        m_dwPageCount = (m_dwValidityMask & FAX_JOB_FIELD_PAGE_COUNT) ? pMsg->dwPageCount : 0;

        //
        // Original scheduled time
        //
        if (m_dwValidityMask & FAX_JOB_FIELD_ORIGINAL_SCHEDULE_TIME)
        {
            m_tmOriginalScheduleTime = pMsg->tmOriginalScheduleTime;
        }
        else
        {
            m_tmOriginalScheduleTime.Zero ();
        }
        //
        // Submission time
        //
        if (m_dwValidityMask & FAX_JOB_FIELD_SUBMISSION_TIME)
        {
            m_tmSubmissionTime = pMsg->tmOriginalScheduleTime;
        }
        else
        {
            m_tmSubmissionTime.Zero ();
        }
        //
        // Transmission start time
        //
        if (m_dwValidityMask & FAX_JOB_FIELD_TRANSMISSION_START_TIME)
        {
            m_tmTransmissionStartTime = pMsg->tmTransmissionStartTime;
        }
        else
        {
            m_tmTransmissionStartTime.Zero ();
        }
        //
        // Transmission end time
        //
        if (m_dwValidityMask & FAX_JOB_FIELD_TRANSMISSION_END_TIME)
        {
            m_tmTransmissionEndTime = pMsg->tmTransmissionEndTime;
        }
        else
        {
            m_tmTransmissionEndTime.Zero ();
        }
        //
        // Transmission duration
        //
        if ((m_dwValidityMask & FAX_JOB_FIELD_TRANSMISSION_END_TIME) &&
            (m_dwValidityMask & FAX_JOB_FIELD_TRANSMISSION_START_TIME))
        {
            m_tmTransmissionDuration = m_tmTransmissionEndTime - m_tmTransmissionStartTime;
        }
        else
        {
            m_tmTransmissionDuration.Zero ();
        }
        //
        // Priority
        //
        if (m_dwValidityMask & FAX_JOB_FIELD_PRIORITY)
        {
            m_Priority = pMsg->Priority;
            ASSERTION (m_Priority <= FAX_PRIORITY_TYPE_HIGH);
        }
        else
        {
            m_Priority = (FAX_ENUM_PRIORITY_TYPE)-1;
        }
        //
        // Retries
        //
        if (m_dwValidityMask & FAX_JOB_FIELD_RETRIES)
        {
            m_dwRetries = pMsg->dwRetries;
        }
        else
        {
            m_dwRetries = 0;
        }
        //
        // Recipient info
        //
        m_cstrRecipientNumber = pMsg->lpctstrRecipientNumber ?
                                pMsg->lpctstrRecipientNumber : TEXT("");
        m_cstrRecipientName   = pMsg->lpctstrRecipientName ?
                                pMsg->lpctstrRecipientName : TEXT("");
        //
        // Sender info
        //
        m_cstrSenderNumber = pMsg->lpctstrSenderNumber ?
                             pMsg->lpctstrSenderNumber : TEXT("");
        m_cstrSenderName   = pMsg->lpctstrSenderName ?
                           pMsg->lpctstrSenderName : TEXT("");
        //
        // TSID / CSID
        //
        m_cstrTsid = pMsg->lpctstrTsid ?
                     pMsg->lpctstrTsid : TEXT("");
        m_cstrCsid = pMsg->lpctstrCsid ?
                     pMsg->lpctstrCsid : TEXT("");
        //
        // User
        //
        m_cstrSenderUserName = pMsg->lpctstrSenderUserName ?
                               pMsg->lpctstrSenderUserName : TEXT("");
        //
        // Billing
        //
        m_cstrBillingCode = pMsg->lpctstrBillingCode ?
                            pMsg->lpctstrBillingCode : TEXT("");
        //
        // Device
        //
        m_cstrDeviceName = pMsg->lpctstrDeviceName ?
                           pMsg->lpctstrDeviceName : TEXT("");
        //
        // Document
        //
        m_cstrDocumentName = pMsg->lpctstrDocumentName ?
                             pMsg->lpctstrDocumentName : TEXT("");
        //
        // Subject
        //
        m_cstrSubject = pMsg->lpctstrSubject ?
                        pMsg->lpctstrSubject : TEXT("");
        //
        // Caller id
        //
        m_cstrCallerID = pMsg->lpctstrCallerID ?
                         pMsg->lpctstrCallerID : TEXT("");
        //
        // Routing info
        //
        m_cstrRoutingInfo = pMsg->lpctstrRoutingInfo ?
                            pMsg->lpctstrRoutingInfo : TEXT("");
        //
        // Server name
        //
        m_cstrServerName = m_pServer->Machine();

        m_dwPossibleOperations = FAX_JOB_OP_VIEW | FAX_JOB_OP_DELETE | FAX_JOB_OP_PROPERTIES;
    }
    catch (CException &ex)
    {
        TCHAR wszCause[1024];

        ex.GetErrorMessage (wszCause, 1024);
        VERBOSE (EXCEPTION_ERR,
                 TEXT("Init caused exception : %s"), 
                 wszCause);
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        return dwRes;
    }

    ASSERTION (ERROR_SUCCESS == dwRes);
    m_bValid = TRUE;
    return dwRes;
}   // CArchiveMsg::Init


DWORD 
CArchiveMsg::GetTiff (
    CString &cstrTiffLocation
) const
/*++

Routine name : CArchiveMsg::GetTiff

Routine description:

    Retrieves the message's TIFF from the server

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    cstrTiffLocation    [out]    - Name of TIFF file

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CArchiveMsg::GetTiff"), dwRes);

    dwRes = CopyTiffFromServer (m_pServer,
                                m_dwlMessageId,
                                (JT_SEND == m_dwJobType) ? 
                                    FAX_MESSAGE_FOLDER_SENTITEMS : 
                                    FAX_MESSAGE_FOLDER_INBOX,
                                cstrTiffLocation);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("CopyTiffFromServer"), dwRes);
    }
    return dwRes;
}

DWORD 
CArchiveMsg::Delete ()
/*++

Routine name : CArchiveMsg::Delete

Routine description:

    Deletes the message

Author:

    Eran Yariv (EranY), Jan, 2000

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CArchiveMsg::Delete"), dwRes);

    if (!(GetPossibleOperations() & FAX_JOB_OP_DELETE))
    {
        VERBOSE (DBG_MSG, TEXT("Message can no longer be deleted"));
        dwRes = ERROR_CAN_NOT_COMPLETE;
        return dwRes;
    }
    HANDLE hFax;
    dwRes = m_pServer->GetConnectionHandle (hFax);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("CServerNode::GetConnectionHandle"), dwRes);
        return dwRes;
    }
    START_RPC_TIME(TEXT("FaxRemoveMessage")); 
    if (!FaxRemoveMessage (hFax,
                           m_dwlMessageId,
                           (JT_SEND == m_dwJobType) ? 
                               FAX_MESSAGE_FOLDER_SENTITEMS : 
                               FAX_MESSAGE_FOLDER_INBOX))
    {
        dwRes = GetLastError ();
        END_RPC_TIME(TEXT("FaxRemoveMessage")); 
        m_pServer->SetLastRPCError (dwRes);
        CALL_FAIL (RPC_ERR, TEXT("FaxRemoveMessage"), dwRes);
        return dwRes;
    }
    END_RPC_TIME(TEXT("FaxRemoveMessage")); 

    ASSERTION (ERROR_SUCCESS == dwRes);    
    return dwRes;
}   // CArchiveMsg::Delete


DWORD
CArchiveMsg::Copy(
    const CArchiveMsg& other
)
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CArchiveMsg::Copy"), dwRes);

    try
    {
        m_dwValidityMask = other.m_dwValidityMask;
        m_dwJobType = other.m_dwJobType;
        m_dwExtendedStatus = other.m_dwExtendedStatus;
        m_dwlMessageId = other.m_dwlMessageId;
        m_dwlBroadcastId = other.m_dwlBroadcastId;
        m_dwSize = other.m_dwSize;
        m_dwPageCount = other.m_dwPageCount;
        m_tmOriginalScheduleTime = other.m_tmOriginalScheduleTime;
        m_tmSubmissionTime = other.m_tmSubmissionTime;
        m_tmTransmissionStartTime = other.m_tmTransmissionStartTime;
        m_tmTransmissionEndTime = other.m_tmTransmissionEndTime;
        m_tmTransmissionDuration = other.m_tmTransmissionDuration;
        m_Priority = other.m_Priority;
        m_dwRetries = other.m_dwRetries;
        m_cstrRecipientNumber = other.m_cstrRecipientNumber;
        m_cstrRecipientName = other.m_cstrRecipientName;
        m_cstrSenderNumber = other.m_cstrSenderNumber;
        m_cstrSenderName = other.m_cstrSenderName;
        m_cstrTsid = other.m_cstrTsid;
        m_cstrCsid = other.m_cstrCsid;
        m_cstrSenderUserName = other.m_cstrSenderUserName;
        m_cstrBillingCode = other.m_cstrBillingCode;
        m_cstrDeviceName = other.m_cstrDeviceName;
        m_cstrDocumentName = other.m_cstrDocumentName;
        m_cstrSubject = other.m_cstrSubject;
        m_cstrCallerID = other.m_cstrCallerID;
        m_cstrRoutingInfo = other.m_cstrRoutingInfo;
        m_cstrServerName = other.m_cstrServerName;
            
        m_bValid = other.m_bValid;
    }
    catch(...)
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
    }

    return dwRes;

} // CArchiveMsg::Copy
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\mainfrm.cpp ===
// MainFrm.cpp : implementation of the CMainFrame class
//

#include "stdafx.h"

#define __FILE_ID__     5

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern CClientConsoleApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNCREATE(CMainFrame, CFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
    //{{AFX_MSG_MAP(CMainFrame)
    ON_WM_CREATE()
    ON_WM_CLOSE()
    ON_WM_SETTINGCHANGE()
    ON_WM_SYSCOLORCHANGE()
    //}}AFX_MSG_MAP
    ON_COMMAND(ID_HELP_FINDER,             OnHelpContents)
    ON_MESSAGE(WM_HELP,                    OnHelp)                   // F1
    ON_COMMAND(ID_VIEW_REFRESH_FOLDER,     OnRefreshFolder)
    ON_COMMAND(ID_SEND_NEW_FAX,            OnSendNewFax)
    ON_COMMAND(ID_RECEIVE_NEW_FAX,         OnReceiveNewFax)
    ON_COMMAND(ID_TOOLS_USER_INFO,         OnViewOptions)
    ON_COMMAND(ID_TOOLS_CONFIG_WIZARD,     OnToolsConfigWizard)
    ON_COMMAND(ID_TOOLS_ADMIN_CONSOLE,     OnToolsAdminConsole)    
    ON_COMMAND(ID_TOOLS_MONITOR,           OnToolsMonitor)    
    ON_COMMAND(ID_VIEW_COVER_PAGES,        OnToolsCoverPages)    
    ON_COMMAND(ID_VIEW_SERVER_STATUS,      OnToolsServerStatus)    
    ON_COMMAND(ID_TOOLS_FAX_PRINTER_PROPS, OnToolsFaxPrinterProps)    
    ON_COMMAND(ID_VIEW_SELECT_COLUMNS,     OnSelectColumns)
    ON_COMMAND(ID_IMPORT_INBOX,            OnImportInbox)
    ON_COMMAND(ID_IMPORT_SENT,             OnImportSentItems)
    ON_UPDATE_COMMAND_UI_RANGE(ID_TOOLS_CONFIG_WIZARD, ID_TOOLS_MONITOR, OnUpdateWindowsXPTools)
    ON_UPDATE_COMMAND_UI(ID_VIEW_SELECT_COLUMNS,          OnUpdateSelectColumns)       	
    ON_UPDATE_COMMAND_UI(ID_VIEW_SERVER_STATUS,           OnUpdateServerStatus)       
    ON_UPDATE_COMMAND_UI(ID_VIEW_REFRESH_FOLDER,          OnUpdateRefreshFolder)
    ON_UPDATE_COMMAND_UI(ID_INDICATOR_FOLDER_ITEMS_COUNT, OnUpdateFolderItemsCount)
    ON_UPDATE_COMMAND_UI(ID_INDICATOR_ACTIVITY,           OnUpdateActivity)    
    ON_UPDATE_COMMAND_UI(ID_SEND_NEW_FAX,                 OnUpdateSendNewFax)
    ON_UPDATE_COMMAND_UI(ID_RECEIVE_NEW_FAX,              OnUpdateReceiveNewFax)
    ON_UPDATE_COMMAND_UI(ID_IMPORT_SENT,                  OnUpdateImportSent)
    ON_UPDATE_COMMAND_UI(ID_TOOLS_FAX_PRINTER_PROPS,      OnUpdateToolsFaxPrinterProps)    
    ON_UPDATE_COMMAND_UI(ID_HELP_FINDER,                  OnUpdateHelpContents)    
    ON_MESSAGE(WM_POPUP_ERROR,                            OnPopupError)
    ON_MESSAGE(WM_CONSOLE_SET_ACTIVE_FOLDER,              OnSetActiveFolder)
    ON_MESSAGE(WM_CONSOLE_SELECT_ITEM,                    OnSelectItem)
    ON_MESSAGE(WM_QUERYENDSESSION, OnQueryEndSession)
    ON_NOTIFY(NM_DBLCLK, AFX_IDW_STATUS_BAR, OnStatusBarDblClk )
END_MESSAGE_MAP()


//
// List of indices of items used in the Incoming folder
//
#define INCOMING_DEF_COL_NUM   8

static MsgViewItemType IncomingColumnsUsed[] = 
                {
                    MSG_VIEW_ITEM_ICON,                    // default 0 
                    MSG_VIEW_ITEM_TRANSMISSION_START_TIME, // default 1 
                    MSG_VIEW_ITEM_TSID,                    // default 2
                    MSG_VIEW_ITEM_CALLER_ID,               // default 3 
                    MSG_VIEW_ITEM_STATUS,                  // default 4 
                    MSG_VIEW_ITEM_EXTENDED_STATUS,         // default 5 
                    MSG_VIEW_ITEM_CURRENT_PAGE,            // default 6 
                    MSG_VIEW_ITEM_SIZE,                    // default 7 
                    MSG_VIEW_ITEM_SERVER,          
                    MSG_VIEW_ITEM_CSID,            
                    MSG_VIEW_ITEM_DEVICE,          
                    MSG_VIEW_ITEM_ROUTING_INFO,    
                    MSG_VIEW_ITEM_SEND_TIME,   // schedule time
                    MSG_VIEW_ITEM_TRANSMISSION_END_TIME,
                    MSG_VIEW_ITEM_ID,              
                    MSG_VIEW_ITEM_NUM_PAGES, 
                    MSG_VIEW_ITEM_RETRIES,         
                    MSG_VIEW_ITEM_END              // End of list
                };


//
// List of indices of items used in the Inbox folder
//
#define INBOX_DEF_COL_NUM   8

static MsgViewItemType InboxColumnsUsed[] = 
                {
                    MSG_VIEW_ITEM_ICON,                    // default 0 
                    MSG_VIEW_ITEM_TRANSMISSION_START_TIME, // default 1 
                    MSG_VIEW_ITEM_TSID,                    // default 2 
                    MSG_VIEW_ITEM_CALLER_ID,               // default 3 
                    MSG_VIEW_ITEM_NUM_PAGES,               // default 4 
                    MSG_VIEW_ITEM_STATUS,                  // default 5 
                    MSG_VIEW_ITEM_SIZE,                    // default 6 
                    MSG_VIEW_ITEM_CSID,                    // default 7
                    MSG_VIEW_ITEM_SERVER,                
                    MSG_VIEW_ITEM_TRANSMISSION_END_TIME, 
                    MSG_VIEW_ITEM_TRANSMISSION_DURATION, 
                    MSG_VIEW_ITEM_DEVICE,                
                    MSG_VIEW_ITEM_ROUTING_INFO,          
                    MSG_VIEW_ITEM_ID,                    
                    MSG_VIEW_ITEM_END              // End of list
                };

//
// List of indices of items used in the sent items folder
//
#define SENT_ITEMS_DEF_COL_NUM   8

static MsgViewItemType SentItemsColumnsUsed[] = 
                {
                    MSG_VIEW_ITEM_ICON,                   // default 0
                    MSG_VIEW_ITEM_TRANSMISSION_START_TIME,// default 1
                    MSG_VIEW_ITEM_RECIPIENT_NAME,         // default 2
                    MSG_VIEW_ITEM_RECIPIENT_NUMBER,       // default 3
                    MSG_VIEW_ITEM_SUBJECT,                // default 4
                    MSG_VIEW_ITEM_DOC_NAME,               // default 5
                    MSG_VIEW_ITEM_NUM_PAGES,              // default 6
                    MSG_VIEW_ITEM_SIZE,                   // default 7
                    MSG_VIEW_ITEM_SERVER,
                    MSG_VIEW_ITEM_USER,
                    MSG_VIEW_ITEM_PRIORITY,
                    MSG_VIEW_ITEM_CSID,
                    MSG_VIEW_ITEM_TSID,
                    MSG_VIEW_ITEM_ORIG_TIME,
                    MSG_VIEW_ITEM_RETRIES,
                    MSG_VIEW_ITEM_ID,
                    MSG_VIEW_ITEM_BROADCAST_ID,
                    MSG_VIEW_ITEM_SUBMIT_TIME,
                    MSG_VIEW_ITEM_TRANSMISSION_DURATION,
                    MSG_VIEW_ITEM_TRANSMISSION_END_TIME,
                    MSG_VIEW_ITEM_BILLING,
                    MSG_VIEW_ITEM_SENDER_NAME,
                    MSG_VIEW_ITEM_SENDER_NUMBER,
                    MSG_VIEW_ITEM_END    // End of list
                };

//
// List of indices of items used in the Outbox folder
//

#define OUTBOX_DEF_COL_NUM   9

static MsgViewItemType OutboxColumnsUsed[] = 
                {
					MSG_VIEW_ITEM_ICON,             // default 0
                    MSG_VIEW_ITEM_SUBMIT_TIME,      // default 1
                    MSG_VIEW_ITEM_RECIPIENT_NAME,   // default 2
                    MSG_VIEW_ITEM_RECIPIENT_NUMBER, // default 3
                    MSG_VIEW_ITEM_SUBJECT,          // default 4
                    MSG_VIEW_ITEM_DOC_NAME,         // default 5
                    MSG_VIEW_ITEM_STATUS,           // default 6
                    MSG_VIEW_ITEM_EXTENDED_STATUS,  // default 7 					
                    MSG_VIEW_ITEM_CURRENT_PAGE,     // default 8 					
                    MSG_VIEW_ITEM_SEND_TIME,        
                    MSG_VIEW_ITEM_SERVER,    
                    MSG_VIEW_ITEM_NUM_PAGES,       
                    MSG_VIEW_ITEM_USER,        
                    MSG_VIEW_ITEM_PRIORITY,    
                    MSG_VIEW_ITEM_CSID,        
                    MSG_VIEW_ITEM_TSID,        
                    MSG_VIEW_ITEM_ORIG_TIME,   
                    MSG_VIEW_ITEM_SIZE,        
                    MSG_VIEW_ITEM_DEVICE,        
                    MSG_VIEW_ITEM_RETRIES,     
                    MSG_VIEW_ITEM_ID,      
                    MSG_VIEW_ITEM_BROADCAST_ID,
                    MSG_VIEW_ITEM_BILLING,         
                    MSG_VIEW_ITEM_END    // End of list
                };

//
// Status bar indicators
//
static UINT indicators[] =
{
	ID_SEPARATOR,           // status line indicator (menu item)
	ID_INDICATOR_FOLDER_ITEMS_COUNT,  // status line indicator (num of folder items)
	ID_INDICATOR_ACTIVITY,            // status line indicator (Activity)
};


/////////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame() :
    m_pInitialRightPaneView (NULL),
    m_pLeftView (NULL),
    m_pIncomingView(NULL),
    m_pInboxView(NULL),
    m_pSentItemsView(NULL),
    m_pOutboxView(NULL)
{}

CMainFrame::~CMainFrame()
{
    //
    // Destroy our custom views (if needed)
    //
    if (m_pIncomingView && ::IsWindow (m_pIncomingView->m_hWnd))
    {
        m_pIncomingView->DestroyWindow  ();
    }
    if (m_pInboxView && ::IsWindow (m_pInboxView->m_hWnd))
    {
        m_pInboxView->DestroyWindow  ();
    }
    if (m_pSentItemsView && ::IsWindow (m_pSentItemsView->m_hWnd))
    {
        m_pSentItemsView->DestroyWindow  ();
    }
    if (m_pOutboxView && ::IsWindow (m_pOutboxView->m_hWnd))
    {
        m_pOutboxView->DestroyWindow  ();
    }
}

int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    int iRes = 0;
    DWORD dwRes;
    DBG_ENTER(TEXT("CMainFrame::OnCreate"), (HRESULT &)iRes);

    if (CFrameWnd::OnCreate(lpCreateStruct) == -1)
    {
        iRes = -1;
        CALL_FAIL (STARTUP_ERR, TEXT("CFrameWnd::OnCreate"), iRes);
        return iRes;
    }

    FrameToSavedLayout();

    //
    // Create the toolbar
    //  
    if (!m_wndToolBar.CreateEx(this) ||
        !m_wndToolBar.LoadToolBar(IDR_MAINFRAME))
    {
        iRes = -1;
        CALL_FAIL (STARTUP_ERR, 
                   TEXT("CToolBar::CreateEx or CToolBar::LoadToolBar"), 
                   iRes);
        return iRes;
    }
    //
    // Create the rebar and place the toolbar + dialogbar in it.
    //
    if (!m_wndReBar.Create(this) ||
        !m_wndReBar.AddBar(&m_wndToolBar))
    {
        iRes = -1;
        CALL_FAIL (STARTUP_ERR, 
                   TEXT("CReBar::Create or CReBar::AddBar"), 
                   iRes);
        return iRes;
    }
    //
    // Create the status bar
    //
    if (!m_wndStatusBar.CreateEx (this, SBARS_SIZEGRIP | SBT_TOOLTIPS) ||
        !m_wndStatusBar.SetIndicators (indicators, sizeof(indicators)/sizeof(UINT)))
    {
        iRes = -1;
        CALL_FAIL (STARTUP_ERR, 
                   TEXT("CStatusBar::CreateEx or CStatusBar::SetIndicators"), 
                   iRes);
        return iRes;
    }

    //
    // set pane width
    //
    m_wndStatusBar.SetPaneInfo(STATUS_PANE_ITEM_COUNT, 
                               ID_INDICATOR_FOLDER_ITEMS_COUNT, 
                               SBPS_NORMAL, 
                               80);
    m_wndStatusBar.SetPaneInfo(STATUS_PANE_ACTIVITY, 
                               ID_INDICATOR_ACTIVITY,           
                               SBPS_STRETCH, 
                               200);

    // TODO: Remove this if you don't want tool tips
    m_wndToolBar.SetBarStyle(m_wndToolBar.GetBarStyle() | CBRS_TOOLTIPS | CBRS_FLYBY);
    //
    // Load strings used for display throughout the application - priority & job status
    //
    dwRes = CViewRow::InitStrings ();
    if (ERROR_SUCCESS != dwRes)
    {
        iRes = -1;
        CALL_FAIL (RESOURCE_ERR, TEXT("CJob::InitStrings"), dwRes);
        return iRes;
    }
    return iRes;
}

BOOL CMainFrame::OnCreateClient(LPCREATESTRUCT /*lpcs*/,
    CCreateContext* pContext)
{
    BOOL bRes = TRUE;
    DBG_ENTER(TEXT("CMainFrame::OnCreateClient"), bRes);
    //
    // Create splitter window
    //
    if (!m_wndSplitter.CreateStatic(this, 1, 2))
    {
        bRes = FALSE;
        CALL_FAIL (STARTUP_ERR, TEXT("CSplitterWnd::CreateStatic"), bRes);
        return bRes;
    }
    CRect r;
    GetWindowRect(r);

    int iLeftWidth = int(r.Width()*0.32),
        iRightWidth = int(r.Width()*0.68);

    if (!m_wndSplitter.CreateView(0, 
                                  0, 
                                  RUNTIME_CLASS(CLeftView), 
                                  CSize(iLeftWidth, r.Height()), 
                                  pContext
                                 ) ||
        !m_wndSplitter.CreateView(0, 
                                  1, 
                                  RUNTIME_CLASS(CClientConsoleView), 
                                  CSize(iRightWidth, r.Height()), 
                                  pContext
                                 )
       )
    {
        m_wndSplitter.DestroyWindow();
        bRes = FALSE;
        CALL_FAIL (STARTUP_ERR, TEXT("CSplitterWnd::CreateView"), bRes);
        return bRes;
    }
    m_pInitialRightPaneView = GetRightPane ();
    m_pLeftView = (CLeftView *)(m_wndSplitter.GetPane(0,0));

    SplitterToSavedLayout();

	return bRes;
}   // CMainFrame::OnCreateClient

BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs)
{
    BOOL bRes = TRUE;
    DBG_ENTER(TEXT("CMainFrame::PreCreateWindow"), bRes);
    
    //
    // The following line removes the document name from the application's title.
    //
    cs.style &= ~FWS_ADDTOTITLE;
    //
    // Use the unique class name so that FindWindow can later locate it.
    //
    cs.lpszClass = theApp.GetClassName();

    if( !CFrameWnd::PreCreateWindow(cs) )
    {
        bRes = FALSE;
        CALL_FAIL (STARTUP_ERR, TEXT("CFrameWnd::PreCreateWindow"), bRes);
        return bRes;
    }
    return bRes;
}

/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
    CFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext& dc) const
{
    CFrameWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers

CListView* CMainFrame::GetRightPane()
{
    CWnd* pWnd = m_wndSplitter.GetPane(0, 1);
    return (CListView *)pWnd;
}

void 
CMainFrame::SwitchRightPaneView(
    CListView *pNewView
)
/*++

Routine name : CMainFrame::SwitchRightPaneView

Routine description:

    Switches the view displayed in the right pane to a new view

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    pNewView            [in] - View to display in the right pane

Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CMainFrame::SwitchRightPaneView"));
    ASSERT_VALID (&m_wndSplitter);
    if (!pNewView)
    {
        //
        // Switch back to our initial right pane view
        //
        pNewView = m_pInitialRightPaneView;
    }
    ASSERTION (pNewView);
    ASSERT_KINDOF (CListView, pNewView);
    //
    // Get window at current pane
    //
    CWnd *pPaneWnd = m_wndSplitter.GetPane (0,1);
    ASSERT_VALID (pPaneWnd);
    CListView *pCurrentView = static_cast<CListView*> (pPaneWnd);        
    //
    // Exchange view window ID's so RecalcLayout() works.
    //
    UINT uCurrentViewId = ::GetWindowLong(pCurrentView->m_hWnd, GWL_ID);
    UINT uNewViewId =     ::GetWindowLong(pNewView->m_hWnd,     GWL_ID);
    if (uCurrentViewId == uNewViewId)
    {
        //
        // Same view - do nothing
        //
        return;
    }
    ::SetWindowLong(pCurrentView->m_hWnd, GWL_ID, uNewViewId);
    ::SetWindowLong(pNewView->m_hWnd,     GWL_ID, uCurrentViewId);
    //
    // Hide current view and show the new view
    //
    pCurrentView->ShowWindow(SW_HIDE);
    pNewView->ShowWindow(SW_SHOW);
    SetActiveView(pNewView);
    //
    // Cause redraw in new view
    //
    pNewView->Invalidate();
    //
    // Recalc frame layout
    //
    m_wndSplitter.RecalcLayout ();
}   // CMainFrame::SwitchRightPaneView

void CMainFrame::OnRefreshFolder()
/*++

Routine name : CMainFrame::OnRefreshFolder

Routine description:

    Called by the framework to refresh the current folder (F5)

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:


Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CMainFrame::OnRefreshFolder"));
    DWORD dwRes = GetLeftView()->RefreshCurrentFolder ();
}

void 
CMainFrame::OnSelectColumns()
{
    DBG_ENTER(TEXT("CMainFrame::OnSelectColumns"));

    DWORD dwRes = m_pLeftView->OpenSelectColumnsDlg();
	if(ERROR_SUCCESS != dwRes)
	{
        CALL_FAIL (GENERAL_ERR, TEXT("CLeftView::OpenSelectColumnsDlg"), dwRes);
		PopupError(dwRes);
	}
}

void 
CMainFrame::OnUpdateSelectColumns(
	CCmdUI* pCmdUI
)
{
    DBG_ENTER(TEXT("CMainFrame::OnUpdateSelectColumns"));

	pCmdUI->Enable(m_pLeftView->CanOpenSelectColumnsDlg());
}

void 
CMainFrame::OnUpdateFolderItemsCount(
    CCmdUI* pCmdUI
) 
/*++

Routine name : CMainFrame::OnUpdateFolderItemsCount

Routine description:

	status bar indication of folder items count

Author:

	Alexander Malysh (AlexMay),	Jan, 2000

Arguments:

	pCmdUI                        [in/out] 

Return Value:

    None.

--*/
{
    CString cstrText;
    if(NULL != m_pLeftView)
    {
        int nItemCount = m_pLeftView->GetDataCount();
        //
        // if nItemCount < 0 this information is not relevant
        //
        if(nItemCount >= 0)
        {
            CString cstrFormat;
            DWORD dwRes = LoadResourceString (cstrFormat, 
                            (1 == nItemCount) ? IDS_STATUS_BAR_ITEM : IDS_STATUS_BAR_ITEMS);
            if (ERROR_SUCCESS != dwRes)
            {
                goto exit;
            }
            
            try
            {
                cstrText.Format(cstrFormat, nItemCount);
            }
            catch(...)
            {
                dwRes = ERROR_NOT_ENOUGH_MEMORY;
                goto exit;
            }
        }
    }

exit:
    pCmdUI->SetText (cstrText);
}

void 
CMainFrame::OnStatusBarDblClk( 
    NMHDR* pNotifyStruct, 
    LRESULT* result 
)
{
    POINT pt;
    GetCursorPos(&pt);

    CRect rc;
    m_wndStatusBar.GetItemRect(STATUS_PANE_ACTIVITY, &rc);
    m_wndStatusBar.ClientToScreen(&rc);

    if(rc.PtInRect(pt))
    {
        OnToolsServerStatus();
    }
}

void 
CMainFrame::OnUpdateActivity(
    CCmdUI* pCmdUI
)
{
    CString cstrText;
    HICON hIcon = NULL;

    if (!m_pLeftView)
    {
        //
        // No left view yet
        //
        return;
    }

    if (!m_pLeftView->GetActivity(cstrText, hIcon))
    {
        //
        // Activity string is to be ignored
        //
        cstrText.Empty ();
    }

    CStatusBarCtrl& barCtrl = m_wndStatusBar.GetStatusBarCtrl();
    barCtrl.SetIcon(STATUS_PANE_ACTIVITY, hIcon);
    pCmdUI->SetText (cstrText);
}

void 
CMainFrame::OnUpdateRefreshFolder(
    CCmdUI* pCmdUI
) 
/*++

Routine name : CMainFrame::OnUpdateRefreshFolder

Routine description:

    Called by the framework to know if the current folder can be refreshed (F5)

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    pCmdUI          [in] - Answer buffer

Return Value:

    None.

--*/
{
    pCmdUI->Enable(GetLeftView()->CanRefreshFolder());
}


LRESULT 
CMainFrame::OnPopupError (
    WPARAM wParam, 
    LPARAM lParam)
/*++

Routine name : CMainFrame::OnPopupError

Routine description:

    Handles the WM_POPUP_ERROR messages

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    wParam   [in]     - Error code
    lParam   [in]     - Hiword contains the __FILE_ID__ and 
                        Loword contains the line number

Return Value:

    Standard result code

--*/
{
    DWORD dwErrCode = (DWORD) wParam;
    WORD  wFileId   = HIWORD(DWORD(lParam));
    WORD  wLineNumber = LOWORD(DWORD(lParam));

    CErrorDlg ErrDlg(dwErrCode, wFileId, wLineNumber);
    return ErrDlg.DoModal (); 
}   // CMainFrame::OnPopupError


LRESULT 
CMainFrame::OnSelectItem (
    WPARAM wParam, 
    LPARAM lParam)
/*++

Routine name : CMainFrame::OnSelectItem

Routine description:

    Handles the WM_CONSOLE_SELECT_ITEM messages

Author:

    Eran Yariv (EranY), May, 2001

Arguments:

    wParam   [in]     - Low 32-bits of message id
    lParam   [in]     - High 32-bits of message id

Return Value:

    Standard result code

--*/
{
    DBG_ENTER(TEXT("CMainFrame::OnSelectItem"), TEXT("wParam=%ld, lParam=%ld"), wParam, lParam);


    ULARGE_INTEGER uli;
    uli.LowPart = wParam;
    uli.HighPart = lParam;

    if (!m_pLeftView)
    {
        return FALSE;
    }

    CFolderListView* pCurView = m_pLeftView->GetCurrentView();
    if (!pCurView)
    {
        return FALSE;
    }
    pCurView->SelectItemById(uli.QuadPart);
    return TRUE;
}   // CMainFrame::OnSelectItem


LRESULT 
CMainFrame::OnSetActiveFolder (
    WPARAM wParam, 
    LPARAM lParam)
/*++

Routine name : CMainFrame::OnSetActiveFolder

Routine description:

    Handles the WM_CONSOLE_SET_ACTIVE_FOLDER messages

Author:

    Eran Yariv (EranY), May, 2001

Arguments:

    wParam   [in]     - FolderType value
    lParam   [in]     - Unused

Return Value:

    Standard result code

--*/
{
    DBG_ENTER(TEXT("CMainFrame::OnSetActiveFolder"), TEXT("wParam=%ld, lParam=%ld"), wParam, lParam);

    if (wParam > FOLDER_TYPE_INCOMING)
    {
        VERBOSE (GENERAL_ERR, TEXT("wParam is out of range - message ignored"));
        return FALSE;
    }
    
    if (!m_pLeftView)
    {
        return FALSE;
    }
    m_pLeftView->SelectFolder (FolderType(wParam));
    return TRUE;
}   // CMainFrame::OnSetActiveFolder

DWORD   
CMainFrame::CreateFolderViews (
    CDocument *pDoc
)
/*++

Routine name : CMainFrame::CreateFolderViews

Routine description:

    Creates the 4 global views used for folders display

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    pDoc            [in] - Pointer to document to attach to the new views

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CMainFrame::CreateFolderViews"), dwRes);

    DWORD dwChildID = AFX_IDW_PANE_FIRST + 10;

    ASSERTION (!m_pIncomingView && !m_pInboxView && !m_pSentItemsView && !m_pOutboxView);

    //
    // Create incoming view
    //
    dwRes = CreateDynamicView (dwChildID++,
                               CLIENT_INCOMING_VIEW,
                               RUNTIME_CLASS(CFolderListView), 
                               pDoc,
                               (PINT)IncomingColumnsUsed,
                               INCOMING_DEF_COL_NUM,
                               (CFolderListView **)&m_pIncomingView,
                               FOLDER_TYPE_INCOMING);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("CMainFrame::CreateDynamicView (Incoming)"), dwRes);
        return dwRes;
    }

    //
    // Create inbox view
    //
    dwRes = CreateDynamicView (dwChildID++,
                               CLIENT_INBOX_VIEW,
                               RUNTIME_CLASS(CFolderListView), 
                               pDoc,
                               (PINT)InboxColumnsUsed,
                               INBOX_DEF_COL_NUM,
                               (CFolderListView **)&m_pInboxView,
                               FOLDER_TYPE_INBOX);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("CMainFrame::CreateDynamicView (Inbox)"), dwRes);
        return dwRes;
    }

    //
    // Create SentItems view
    //
    dwRes = CreateDynamicView (dwChildID++,
                               CLIENT_SENT_ITEMS_VIEW,
                               RUNTIME_CLASS(CFolderListView),
                               pDoc,
                               (PINT)SentItemsColumnsUsed,
                               SENT_ITEMS_DEF_COL_NUM,
                               (CFolderListView **)&m_pSentItemsView,
                               FOLDER_TYPE_SENT_ITEMS);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("CMainFrame::CreateDynamicView (SentItems)"), dwRes);
        return dwRes;
    }

    //
    // Create Outbox view
    //
    dwRes = CreateDynamicView (dwChildID++,
                               CLIENT_OUTBOX_VIEW,
                               RUNTIME_CLASS(CFolderListView),
                               pDoc,
                               (PINT)OutboxColumnsUsed,
                               OUTBOX_DEF_COL_NUM,
                               (CFolderListView **)&m_pOutboxView,
                               FOLDER_TYPE_OUTBOX);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("CMainFrame::CreateDynamicView (Outbox)"), dwRes);
        return dwRes;
    }

    return dwRes;
}   // CMainFrame::CreateFolderViews

DWORD   
CMainFrame::CreateDynamicView (
    DWORD             dwChildId, 
    LPCTSTR           lpctstrName, 
    CRuntimeClass*    pViewClass,
    CDocument*        pDoc,
    int*              pColumnsUsed,
    DWORD             dwDefaultColNum,
    CFolderListView** ppNewView,
    FolderType        type
)
/*++

Routine name : CMainFrame::CreateDynamicView

Routine description:

    Creates a new view dynamically

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    dwChildId       [in ] - New child id (within the splitter) of the view
    lpctstrName     [in ] - Name of the view
    pViewClass      [in ] - Class of the view
    pDoc            [in ] - Pointer to document to attach to the new view
    pColumnsUsed    [in ] - List of columns to use in the view
    dwDefaultColNum [in ] - default column number
    ppNewView       [out] - Pointer to newly created view

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CMainFrame::CreateDynamicView"), dwRes);

    ASSERTION (pDoc);

    CCreateContext contextT;
    contextT.m_pNewViewClass = pViewClass;
    contextT.m_pCurrentDoc = pDoc;
    contextT.m_pNewDocTemplate = pDoc->GetDocTemplate();
    contextT.m_pLastView = NULL;
    contextT.m_pCurrentFrame = NULL;
    try
    {
        *ppNewView = (CFolderListView*)(pViewClass->CreateObject());
        if (NULL == *ppNewView)
        {
            dwRes = ERROR_NOT_ENOUGH_MEMORY;
            CALL_FAIL (MEM_ERR, TEXT ("CRuntimeClass::CreateObject"), dwRes);
            return dwRes;
        }
    }
    catch (CException &ex)
    {
        TCHAR wszCause[1024];

        ex.GetErrorMessage (wszCause, 1024);
        VERBOSE (EXCEPTION_ERR,
                 TEXT("CreateObject caused exception : %s"), 
                 wszCause);
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        return dwRes;
    }

    (*ppNewView)->SetType(type);

    ASSERT((*ppNewView)->m_hWnd == NULL);       // Not yet created

    DWORD dwStyle = WS_CHILD            |       // Child window (of splitter)
                    WS_BORDER           |       // Has borders
                    LVS_REPORT          |       // Report style
                    LVS_SHAREIMAGELISTS |       // All views use one global image list
                    LVS_SHOWSELALWAYS;          // Always show selected items

    //
    // Create the view 
    //
    CRect rect;
    if (!(*ppNewView)->Create(NULL, 
                              lpctstrName, 
                              dwStyle,
                              rect, 
                              &m_wndSplitter, 
                              dwChildId, 
                              &contextT))
    {
        dwRes = ERROR_GEN_FAILURE;
        CALL_FAIL (WINDOW_ERR, TEXT("CFolderListView::Create"), dwRes);
        //
        // pWnd will be cleaned up by PostNcDestroy
        //
        return dwRes;
    }

    //
    // Init the columns
    //
    dwRes = (*ppNewView)->InitColumns (pColumnsUsed, dwDefaultColNum);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("CFolderListView::InitColumns"), dwRes);
    }

	dwRes = (*ppNewView)->ReadLayout(lpctstrName);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("CFolderListView::ReadLayout"), dwRes);
    }

	(*ppNewView)->ColumnsToLayout();


    return dwRes;
}   // CMainFrame::CreateDynamicView

void 
CMainFrame::SaveLayout()
/*++

Routine name : CMainFrame::SaveLayout

Routine description:

	saves windows layout to the registry

Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CMainFrame::SaveLayout"));

    DWORD dwRes = ERROR_SUCCESS;

    //
    // save folders layout
    //
    dwRes = m_pIncomingView->SaveLayout(CLIENT_INCOMING_VIEW);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("CFolderListView::SaveLayout"), dwRes);
    }
    dwRes = m_pInboxView->SaveLayout(CLIENT_INBOX_VIEW);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("CFolderListView::SaveLayout"), dwRes);
    }

    dwRes = m_pSentItemsView->SaveLayout(CLIENT_SENT_ITEMS_VIEW);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("CFolderListView::SaveLayout"), dwRes);
    }

    dwRes = m_pOutboxView->SaveLayout(CLIENT_OUTBOX_VIEW);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("CFolderListView::SaveLayout"), dwRes);
    }
    
    //
    // save main frame layout
    //
    WINDOWPLACEMENT wndpl;
    if(!GetWindowPlacement(&wndpl))
    {
        CALL_FAIL (WINDOW_ERR, TEXT("CMainFrame::GetWindowPlacement"), 0);
    }
    else
    {
        BOOL bRes = TRUE;
	    bRes &= theApp.WriteProfileInt(CLIENT_MAIN_FRAME, 
                                       CLIENT_MAXIMIZED, 
								       (SW_SHOWMAXIMIZED == wndpl.showCmd));
	    bRes &= theApp.WriteProfileInt(CLIENT_MAIN_FRAME, 
                                       CLIENT_NORMAL_POS_TOP, 
		    				           wndpl.rcNormalPosition.top);
	    bRes &= theApp.WriteProfileInt(CLIENT_MAIN_FRAME, 
                                       CLIENT_NORMAL_POS_RIGHT, 
		    				           wndpl.rcNormalPosition.right);
	    bRes &= theApp.WriteProfileInt(CLIENT_MAIN_FRAME, 
                                       CLIENT_NORMAL_POS_BOTTOM, 
		    				           wndpl.rcNormalPosition.bottom);
	    bRes &= theApp.WriteProfileInt(CLIENT_MAIN_FRAME, 
                                       CLIENT_NORMAL_POS_LEFT, 
		    				           wndpl.rcNormalPosition.left);        

        int cxCur, cxMin;
        m_wndSplitter.GetColumnInfo(0, cxCur, cxMin);
	    bRes &= theApp.WriteProfileInt(CLIENT_MAIN_FRAME, CLIENT_SPLITTER_POS, cxCur);
        if (!bRes)
        {
            VERBOSE (DBG_MSG, TEXT("Could not save one or more window positions"));
        }
    }
}

LRESULT 
CMainFrame::OnQueryEndSession(
    WPARAM, 
    LPARAM
)
/*++

Routine name : CMainFrame::OnQueryEndSession

Routine description:

    The system shutdown message handler
	Saves windows layout to the registry

Return Value:

    TRUE If the application can terminate conveniently
    FALSE otherwise

--*/
{
    DBG_ENTER(TEXT("CMainFrame::OnQueryEndSession"));

    SaveLayout();

    return TRUE;
}

void 
CMainFrame::OnClose() 
/*++

Routine name : CMainFrame::OnClose

Routine description:

	saves windows layout to the registry

Author:

	Alexander Malysh (AlexMay),	Jan, 2000

Arguments:


Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CMainFrame::OnClose"));

    SaveLayout();

	CFrameWnd::OnClose();
}

void 
CMainFrame::FrameToSavedLayout()
/*++

Routine name : CMainFrame::FrameToSavedLayout

Routine description:

	reads main frame size and position from registry and resize the window

Author:

	Alexander Malysh (AlexMay),	Jan, 2000

Arguments:


Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CMainFrame::FrameToSavedLayout"));

    WINDOWPLACEMENT wndpl;
    if(!GetWindowPlacement(&wndpl))
    {
        CALL_FAIL (WINDOW_ERR, TEXT("CMainFrame::GetWindowPlacement"), 0);
        return;
    }

    wndpl.rcNormalPosition.top = theApp.GetProfileInt(CLIENT_MAIN_FRAME, 
                                                    CLIENT_NORMAL_POS_TOP, -1);
    wndpl.rcNormalPosition.right = theApp.GetProfileInt(CLIENT_MAIN_FRAME, 
                                                    CLIENT_NORMAL_POS_RIGHT, -1);
    wndpl.rcNormalPosition.bottom = theApp.GetProfileInt(CLIENT_MAIN_FRAME, 
                                                    CLIENT_NORMAL_POS_BOTTOM, -1);
    wndpl.rcNormalPosition.left = theApp.GetProfileInt(CLIENT_MAIN_FRAME, 
                                                        CLIENT_NORMAL_POS_LEFT, -1);

    if(wndpl.rcNormalPosition.top    < 0 || wndpl.rcNormalPosition.right < 0 ||
       wndpl.rcNormalPosition.bottom < 0 ||  wndpl.rcNormalPosition.left < 0)
    {
        VERBOSE (DBG_MSG, TEXT("Could not load one or more window positions"));
        return;
    }

    if(!SetWindowPlacement(&wndpl))
    {
        CALL_FAIL (WINDOW_ERR, TEXT("CMainFrame::SetWindowPlacement"), 0);
    }
}

void 
CMainFrame::SplitterToSavedLayout()
{
    DBG_ENTER(TEXT("CMainFrame::SplitterToSavedLayout"));
    //
    // set splitter position according to saved value
    //
    int xPos = theApp.GetProfileInt(CLIENT_MAIN_FRAME, CLIENT_SPLITTER_POS, -1);
    if(xPos < 0)
    {
        VERBOSE (DBG_MSG, TEXT("Could not load splitter position"));
        return;
    }
    
    m_wndSplitter.SetColumnInfo(0, xPos, 10);
}


void 
CMainFrame::ActivateFrame(
    int nCmdShow
) 
{
    //
    // maximize according to saved value
    //
    BOOL bMaximized = theApp.GetProfileInt(CLIENT_MAIN_FRAME, CLIENT_MAXIMIZED, 0);
    if (bMaximized)
    {
        nCmdShow = SW_SHOWMAXIMIZED;
    }
	CFrameWnd::ActivateFrame(nCmdShow);
}

//
// MAX_NUM_SERVERS is defined to limit the range of messages we consider 
// as server notification. 
// 
#define MAX_NUM_SERVERS             256

LRESULT 
CMainFrame::WindowProc( 
    UINT message, 
    WPARAM wParam, 
    LPARAM lParam 
)
/*++

Routine name : CMainFrame::WindowProc

Routine description:

	Handle windows messages before MFC dispatches them.
    Here we handle notification messages from the servers.

Author:

	Eran Yariv (EranY),	Jan, 2000

Arguments:

	message           [in]     - Specifies the Windows message to be processed
    wParam            [in]     - 
    lParam            [in]     - 

Return Value:

    TRUE if mesage was handled by the function, FALSE otherwise.

--*/
{
    BOOL bRes = FALSE;    
	if ((WM_SERVER_NOTIFY_BASE > message) ||
        (WM_SERVER_NOTIFY_BASE + MAX_NUM_SERVERS < message))
    {
        //
        // This is not a server notification message
        //
        return CFrameWnd::WindowProc(message, wParam, lParam);
    }
    //
    // From now on, we're dealing with a server notification
    //
    DBG_ENTER(TEXT("CMainFrame::WindowProc"), 
              bRes, 
              TEXT("Msg=0x%08x, lParam=0x%08x, wParam=0x%08x"),
              message,
              lParam,
              wParam);

    //
    // This message should not be processed any more
    //
    bRes = TRUE;
    //
    // Try looking up the server node for which this message is intended
    //
    CServerNode *pServer = CServerNode::LookupServerFromMessageId (message);
    FAX_EVENT_EX *pEvent = (FAX_EVENT_EX *)(lParam);
    ASSERTION (pEvent);
    ASSERTION (sizeof (FAX_EVENT_EX) == pEvent->dwSizeOfStruct);
    if (pServer)
    {
        //
        // Tell the server a notification has arrived for it
        //
        VERBOSE (DBG_MSG, TEXT("Message was coming from %s"), pServer->Machine());
        DWORD dwRes = pServer->OnNotificationMessage (pEvent);
        if (ERROR_SUCCESS != dwRes)
        {
            CALL_FAIL (GENERAL_ERR, TEXT("CServerNode::OnNotificationMessage"), dwRes);
        }
    }
    else
    {
        VERBOSE (DBG_MSG, TEXT("Got server notification - No server found as sink"));
    }
    //
    // Processed or not - delete the message
    //

    //
    // Plant a special value here to catch reuse of the same pointer
    //
    pEvent->dwSizeOfStruct = 0xbabe;
    FaxFreeBuffer (pEvent);
    return bRes;

} // CMainFrame::WindowProc

void 
CMainFrame::OnToolsAdminConsole()
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CMainFrame::OnToolsAdminConsole"));

    HINSTANCE hAdmin;
    hAdmin = ShellExecute(
				            m_hWnd,
				            TEXT("open"),
				            FAX_ADMIN_CONSOLE_IMAGE_NAME,
				            NULL,
				            NULL,
				            SW_SHOWNORMAL
	            		 );
    if((DWORD_PTR)hAdmin <= 32)
    {
        //
        // error
        //
        dwRes = PtrToUlong(hAdmin);
        PopupError(dwRes);
        CALL_FAIL (GENERAL_ERR, TEXT("ShellExecute"), dwRes);
    }    
}

void 
CMainFrame::OnToolsConfigWizard()
/*++

Routine name : CMainFrame::OnToolsConfigWizard

Routine description:

    Fax Configuration Wizard invocation

Return Value:

  none

--*/
{
    DBG_ENTER(TEXT("CMainFrame::OnToolsConfigWizard"));

    //
    // explicit launch
    //
    theApp.LaunchConfigWizard(TRUE);
}

void 
CMainFrame::OnToolsMonitor()
/*++

Routine name : CMainFrame::OnToolsMonitor

Routine description:

    Open Fax Monitor dialog

Return Value:

  none

--*/
{
    DBG_ENTER(TEXT("CMainFrame::OnToolsMonitor"));

    HWND hWndFaxMon = ::FindWindow(FAXSTAT_WINCLASS, NULL);
    if (hWndFaxMon) 
    {
        ::PostMessage(hWndFaxMon, WM_FAXSTAT_OPEN_MONITOR, 0, 0);
    }
}

void 
CMainFrame::OnToolsFaxPrinterProps()
/*++

Routine name : CMainFrame::OnToolsFaxPrinterProps

Routine description:

    Open Fax Printer Properties dialog

Return Value:

  none

--*/ 
{
    DBG_ENTER(TEXT("CMainFrame::OnToolsMonitor"));
    //
    // Open fax printer properties
    //
    FaxPrinterProperty(0);
}

void 
CMainFrame::OnUpdateWindowsXPTools(
    CCmdUI* pCmdUI
)
/*++

Routine name : CMainFrame::OnToolsConfigWizard

Routine description:

    Delete Fax Configuration Wizard and Admin Console 
    menu items for non Windows XP plarform

Return Value:

  none

--*/
{
    DBG_ENTER(TEXT("CMainFrame::OnUpdateConfigWizard"));
    
    if(pCmdUI->m_pMenu)
    {
        if(!IsWinXPOS())
        {
            pCmdUI->m_pMenu->DeleteMenu(ID_TOOLS_CONFIG_WIZARD,     MF_BYCOMMAND);
            pCmdUI->m_pMenu->DeleteMenu(ID_TOOLS_ADMIN_CONSOLE,     MF_BYCOMMAND);
            pCmdUI->m_pMenu->DeleteMenu(ID_TOOLS_MONITOR,           MF_BYCOMMAND);
            pCmdUI->m_pMenu->DeleteMenu(ID_TOOLS_FAX_PRINTER_PROPS, MF_BYCOMMAND);
        }
        else
        {
            //
            // Windows XP OS - check SKU
            //
            if (IsDesktopSKU() || !IsFaxComponentInstalled(FAX_COMPONENT_ADMIN))
            {
                pCmdUI->m_pMenu->DeleteMenu(ID_TOOLS_ADMIN_CONSOLE, MF_BYCOMMAND);
            }

            if(!IsFaxComponentInstalled(FAX_COMPONENT_CONFIG_WZRD))
            {
                pCmdUI->m_pMenu->DeleteMenu(ID_TOOLS_CONFIG_WIZARD, MF_BYCOMMAND);
            } 

            if(!IsFaxComponentInstalled(FAX_COMPONENT_MONITOR))
            {
                pCmdUI->m_pMenu->DeleteMenu(ID_TOOLS_MONITOR, MF_BYCOMMAND);
            }

            if(!IsFaxComponentInstalled(FAX_COMPONENT_DRIVER_UI))
            {
                pCmdUI->m_pMenu->DeleteMenu(ID_TOOLS_FAX_PRINTER_PROPS, MF_BYCOMMAND);
            }
        }

        if(pCmdUI->m_pMenu->GetMenuItemCount() == 4)
        {
            //
            // delete the menu separator
            //
            pCmdUI->m_pMenu->DeleteMenu(3, MF_BYPOSITION);
        }
    }
}

void 
CMainFrame::OnUpdateToolsFaxPrinterProps(
    CCmdUI* pCmdUI
)
{ 
    BOOL bEnable = FALSE;

	CClientConsoleDoc* pDoc = (CClientConsoleDoc*)GetActiveDocument();
	if(NULL != pDoc)
	{
        //
        // find local fax server
        //
        if(pDoc->FindServerByName(NULL))
        {
             bEnable = TRUE;
        }
    }

    pCmdUI->Enable(bEnable); 
}

void 
CMainFrame::OnUpdateSendNewFax(
    CCmdUI* pCmdUI
)
{ 
    BOOL bEnable = FALSE;

	CClientConsoleDoc* pDoc = (CClientConsoleDoc*)GetActiveDocument();
	if(NULL != pDoc)
	{
        bEnable = pDoc->IsSendFaxEnable();
    }

    pCmdUI->Enable(bEnable); 
}


void 
CMainFrame::OnUpdateReceiveNewFax(
    CCmdUI* pCmdUI
)
{ 
    BOOL bEnable = FALSE;

    if (IsWinXPOS ())
    {   
        //
        // Receive now works only in Windows XP
        //
	    CClientConsoleDoc* pDoc = (CClientConsoleDoc*)GetActiveDocument();
	    if(NULL != pDoc)
	    {
            bEnable = pDoc->CanReceiveNow();
        }
    }
    pCmdUI->Enable(bEnable); 
}

void 
CMainFrame::OnReceiveNewFax()
/*++

Routine name : CMainFrame::OnReceiveNewFax

Routine description:

	Starts receiving now

Author:

	Eran Yariv (EranY).	Mar, 2001

Arguments:


Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CMainFrame::OnReceiveNewFax"));

    HWND hWndFaxMon = ::FindWindow(FAXSTAT_WINCLASS, NULL);
    if (hWndFaxMon) 
    {
        ::PostMessage(hWndFaxMon, WM_FAXSTAT_RECEIVE_NOW, 0, 0);
    }
}   // CMainFrame::OnReceiveNewFax
    

void 
CMainFrame::OnSendNewFax()
/*++

Routine name : CMainFrame::OnSendNewFax

Routine description:

	start send fax wizard

Author:

	Alexander Malysh (AlexMay),	Feb, 2000

Arguments:


Return Value:

    None.

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CMainFrame::OnSendNewFax"));
    
    //
    // get send fax wizard location
    //
    CString cstrFaxSend;
    dwRes = GetAppLoadPath(cstrFaxSend);
    if(ERROR_SUCCESS != dwRes)
    {
        PopupError(dwRes);
        CALL_FAIL (GENERAL_ERR, TEXT("GetAppLoadPath"), dwRes);
        return;
    }

    try
    {
        cstrFaxSend += FAX_SEND_IMAGE_NAME;
    }
    catch(...)
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        PopupError(dwRes);
        CALL_FAIL (MEM_ERR, TEXT("CString::operator+"), dwRes);
        return ;
    }

    //
    // start send fax wizard
    //
    HINSTANCE hWizard = ShellExecute(NULL, 
                                     TEXT("open"), 
                                     cstrFaxSend, 
                                     NULL, 
                                     NULL, 
                                     SW_RESTORE 
                                    );    
    if((DWORD_PTR)hWizard <= 32)
    {
        //
        // error
        //
        dwRes = PtrToUlong(hWizard);
        PopupError(dwRes);
        CALL_FAIL (GENERAL_ERR, TEXT("ShellExecute"), dwRes);
        return;
    }

} // CMainFrame::OnSendNewFax

void 
CMainFrame::OnViewOptions()
{
    DBG_ENTER(TEXT("CMainFrame::OnViewOptions"));

    CUserInfoDlg userInfo;
    if(userInfo.DoModal() == IDABORT)
    {
        DWORD dwRes = userInfo.GetLastDlgError();
        CALL_FAIL (GENERAL_ERR, TEXT("CUserInfoDlg::DoModal"), dwRes);
        PopupError(dwRes);
    }
}

void
CMainFrame::OnToolsCoverPages()
{
    DBG_ENTER(TEXT("CMainFrame::OnToolsCoverPages"));

    CCoverPagesDlg cpDlg;
    if(cpDlg.DoModal() == IDABORT)
    {
        DWORD dwRes = cpDlg.GetLastDlgError();
        CALL_FAIL (GENERAL_ERR, TEXT("CCoverPagesDlg::DoModal"), dwRes);
        PopupError(dwRes);
    }
}

void 
CMainFrame::OnSettingChange(
	UINT uFlags, 
	LPCTSTR lpszSection
) 
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CMainFrame::OnSettingChange"));

	CFrameWnd::OnSettingChange(uFlags, lpszSection);

	if(lpszSection && !_tcscmp(lpszSection, TEXT("devices")))
	{
		//
		// some change in the system devices
		//
		CClientConsoleDoc* pDoc = (CClientConsoleDoc*)GetActiveDocument();
		if(NULL != pDoc)
		{
			dwRes = pDoc->RefreshServersList();
			if(ERROR_SUCCESS != dwRes)
			{
				CALL_FAIL (GENERAL_ERR, TEXT("CClientConsoleDoc::RefreshServersList"), dwRes);
			}
		}
	}
} // CMainFrame::OnSettingChange


LONG 
CMainFrame::OnHelp(
    UINT wParam, 
    LONG lParam
)
/*++

Routine name : CMainFrame::OnHelp

Routine description:

	F1 key handler

Author:

	Alexander Malysh (AlexMay),	Mar, 2000

Arguments:

	wParam                        [in]     - 
	lParam                        [in]     - LPHELPINFO

Return Value:

    LONG

--*/
{  
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CMainFrame::OnHelp"));

    if(!IsFaxComponentInstalled(FAX_COMPONENT_HELP_CLIENT_CHM))
    {
        //
        // The help file is not installed
        //
        return TRUE;
    }

    if(NULL != m_pLeftView)
    {
        dwRes = m_pLeftView->OpenHelpTopic();
        if(ERROR_SUCCESS != dwRes)
        {
            CALL_FAIL (GENERAL_ERR, TEXT("CLeftView::OpenHelpTopic"),dwRes);
        }
    }
    else
    {
        OnHelpContents();
    }

    return TRUE;
}

void 
CMainFrame::OnUpdateHelpContents(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(IsFaxComponentInstalled(FAX_COMPONENT_HELP_CLIENT_CHM));
}

void 
CMainFrame::OnHelpContents()
/*++

Routine name : CMainFrame::OnHelpContents

Routine description:

	Help Contents menu item handler

Author:

	Alexander Malysh (AlexMay),	Mar, 2000

Arguments:


Return Value:

    None.

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CMainFrame::OnHelpContents"));

    dwRes = ::HtmlHelpTopic(m_hWnd, FAX_HELP_WELCOME);
    if(ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("HtmlHelpTopic"),dwRes);
    }
}

void 
CMainFrame::OnUpdateServerStatus(
    CCmdUI* pCmdUI
)
{
    BOOL bEnable = FALSE;

    CClientConsoleDoc* pDoc = (CClientConsoleDoc*)GetActiveDocument();
    if(NULL != pDoc)
    {
        bEnable = pDoc->GetServerCount() > 0;
    }

    pCmdUI->Enable(bEnable);
}

void 
CMainFrame::OnToolsServerStatus()
{
    DBG_ENTER(TEXT("CMainFrame::OnToolsServerStatus"));

    CClientConsoleDoc* pDoc = (CClientConsoleDoc*)GetActiveDocument();
    if(pDoc->GetServerCount() == 0)
    {
        //
        // no fax printer install
        //
        return;
    }

    CServerStatusDlg srvStatus(pDoc);
    if(srvStatus.DoModal() == IDABORT)
    {
        DWORD dwRes = srvStatus.GetLastDlgError();
        CALL_FAIL (GENERAL_ERR, TEXT("CServerStatusDlg::DoModal"), dwRes);
        PopupError(dwRes);
    }
}
void 
CMainFrame::OnImportSentItems()
{
    ImportArchive(TRUE);
}

void 
CMainFrame::OnImportInbox()
{
    ImportArchive(FALSE);
}


void 
CMainFrame::ImportArchive(
    BOOL bSentArch
)
/*++

Routine name : CMainFrame::ImportArchive

Routine description:

    Import W2K MS faxes into the fax archive

Arguments:

    bSentArch - [in] TRUE for Sent Items, FALSE for Inbox

Return Value:

    None.

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CMainFrame::ImportArchive"));

#ifdef UNICODE

    HKEY   hRegKey;
    DWORD  dwSize;
    DWORD  dwFlags = 0;
    WCHAR* pszFolder = NULL;

    CFolderDialog dlgFolder;

    //
    // Read initial import folder
    //
    if ((hRegKey = OpenRegistryKey(HKEY_LOCAL_MACHINE, REGKEY_FAX_SETUP, TRUE, KEY_QUERY_VALUE)))
    {
        if(bSentArch)
        {
            pszFolder = GetRegistryString(hRegKey, REGVAL_W2K_SENT_ITEMS, NULL);
        }
        else
        {
            pszFolder = GetRegistryStringMultiSz(hRegKey, REGVAL_W2K_INBOX, NULL, &dwSize);
        }

        RegCloseKey(hRegKey);
    }
    else
    {
        CALL_FAIL(GENERAL_ERR, TEXT("OpenRegistryKey"), GetLastError());
    }
    dwRes = dlgFolder.Init(pszFolder, bSentArch ? IDS_IMPORT_TITLE_SENTITEMS : IDS_IMPORT_TITLE_INBOX);
    if(ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL(GENERAL_ERR, TEXT("CMainFrame::ImportArchive"), dwRes);
        goto exit;
    }

    //
    // Display Browse for folder dialog
    //
    if (IsWinXPOS())
    {
        //
        // The new BIF_NONEWFOLDERBUTTON is only defined for WinXP and above
        //
        dwFlags = BIF_NONEWFOLDERBUTTON;
    }

    if(IDOK != dlgFolder.DoModal(dwFlags))
    {
        goto exit;
    }

    //
    // Import the selected folder
    //
    dwRes = ImportArchiveFolderUI(dlgFolder.GetSelectedFolder(), bSentArch, m_hWnd);   
    if(ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL(GENERAL_ERR, TEXT("ImportArchiveFolderUI"), dwRes);
    }

exit:

    MemFree(pszFolder);

#endif // UNICODE

}

void 
CMainFrame::OnUpdateImportSent(CCmdUI* pCmdUI)
{
    if(pCmdUI->m_pMenu)
    {
        if(!IsWinXPOS())
        {

            //
            // Delete the Import menu item and separator for non Windows XP OS
            //
            pCmdUI->m_pMenu->DeleteMenu(14, MF_BYPOSITION);
            pCmdUI->m_pMenu->DeleteMenu(13, MF_BYPOSITION);
        }
    }
}

afx_msg void 
CMainFrame::OnSysColorChange()
{
    //
    // Refresh the image lists we use - force it to refresh
    // Since the image list are static FolderListView members (shared between all instances),
    // we just pick any instance and call it's refresh function with bForce=TRUE.
    //
    if (m_pIncomingView)
    {
        m_pIncomingView->RefreshImageLists(TRUE);
        m_pIncomingView->Invalidate ();
    }
    if (m_pInboxView)
    {
        m_pInboxView->RefreshImageLists(FALSE);
        m_pInboxView->Invalidate ();
    }
    if (m_pSentItemsView)
    {
        m_pSentItemsView->RefreshImageLists(FALSE);
        m_pSentItemsView->Invalidate ();
    }
    if (m_pOutboxView)
    {
        m_pOutboxView->RefreshImageLists(FALSE);
        m_pOutboxView->Invalidate ();
    }
    if (m_pLeftView)
    {
        m_pLeftView->RefreshImageList ();
        m_pLeftView->Invalidate();
    }
    if (m_pInitialRightPaneView)
    {
        m_pInitialRightPaneView->GetListCtrl().SetBkColor(::GetSysColor(COLOR_WINDOW));
    }
}   // CMainFrame::OnSysColorChange
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\mainfrm.h ===
// MainFrm.h : interface of the CMainFrame class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_MAINFRM_H__989CC918_D8CD_4A1E_811B_1AEE446A303D__INCLUDED_)
#define AFX_MAINFRM_H__989CC918_D8CD_4A1E_811B_1AEE446A303D__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//
// WM_POPUP_ERROR is a message sent to the framework whenever an error
// popup should be displayed. 
// This way, even background threads can popup errors.
//
// WPARAM: Win32 error code
// LPARAM: HiWord = file id, LowWord = line number
// 
#define WM_POPUP_ERROR                      WM_APP + 3

// WM_CONSOLE_SET_ACTIVE_FOLDER is a message sent to the framework whenever 
// a new instance wishes to activate a previous instance and set the active folder.
//
// WPARAM: FolderType value
// LPARAM: unused.
// 
#define WM_CONSOLE_SET_ACTIVE_FOLDER        WM_APP + 4

// WM_CONSOLE_SELECT_ITEM is a message sent to the framework whenever 
// a new instance wishes to activate a previous instance and select a specific item in the startup folder
//
// WPARAM: Low 32-bits of message id
// LPARAM: High 32-bits of message id
// 
#define WM_CONSOLE_SELECT_ITEM              WM_APP + 5

//
// HTML Help topics
//
#define FAX_HELP_WELCOME            TEXT("::/FaxC_C_welcome.htm")
#define FAX_HELP_OUTBOX             TEXT("::/FaxC_C_FaxManageOutCont.htm")
#define FAX_HELP_INBOX              TEXT("::/FaxC_C_FaxArchCont.htm")
#define FAX_HELP_SENTITEMS          TEXT("::/FaxC_C_FaxArchCont.htm")
#define FAX_HELP_INCOMING           TEXT("::/FaxC_C_FaxManageCont.htm")
#define FAX_HELP_IMPORT             TEXT("::/FaxC_H_Import.htm")

#define STATUS_PANE_ITEM_COUNT      1
#define STATUS_PANE_ACTIVITY        2

class CCoverPagesView;

class CMainFrame : public CFrameWnd
{
    
protected: // create from serialization only
    CMainFrame();
    DECLARE_DYNCREATE(CMainFrame)

// Attributes
protected:
    CSplitterWnd m_wndSplitter;

public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CMainFrame)
    public:
    virtual BOOL OnCreateClient(LPCREATESTRUCT lpcs, CCreateContext* pContext);
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
    virtual void ActivateFrame(int nCmdShow = -1);
    //}}AFX_VIRTUAL

// Implementation
public:
    void SwitchRightPaneView (CListView *pNewView);
    virtual ~CMainFrame();
    CListView* GetRightPane();
    CView *GetActivePane()   { return (CView *) (m_wndSplitter.GetActivePane()); }
    CLeftView *GetLeftView() { return m_pLeftView; }

    CFolderListView    *GetIncomingView()  { return m_pIncomingView;   }
    CFolderListView    *GetInboxView()     { return m_pInboxView;      }
    CFolderListView    *GetSentItemsView() { return m_pSentItemsView;  }
    CFolderListView    *GetOutboxView()    { return m_pOutboxView;     }

    DWORD CreateFolderViews (CDocument *pDoc);

    void RefreshStatusBar ()
    {
        m_wndStatusBar.PostMessage (WM_IDLEUPDATECMDUI);
        m_wndStatusBar.UpdateWindow ();
    }

    LRESULT WindowProc( UINT message, WPARAM wParam, LPARAM lParam );

#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

protected:  // control bar embedded members
    CStatusBar  m_wndStatusBar;
    CToolBar    m_wndToolBar;
    CReBar      m_wndReBar;

// Generated message map functions
protected:
    //{{AFX_MSG(CMainFrame)
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg LRESULT OnPopupError (WPARAM, LPARAM);
    afx_msg LRESULT OnSetActiveFolder (WPARAM, LPARAM);
    afx_msg LRESULT OnSelectItem (WPARAM, LPARAM);
    afx_msg void OnClose();
    afx_msg void OnSysColorChange();
	afx_msg void OnSettingChange(UINT uFlags, LPCTSTR lpszSection);
    afx_msg LONG OnHelp(UINT wParam, LONG lParam);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:

    afx_msg void OnHelpContents();
    afx_msg void OnRefreshFolder ();
    afx_msg void OnSendNewFax();
    afx_msg void OnReceiveNewFax();
    afx_msg void OnViewOptions();
    afx_msg void OnToolsCoverPages();
    afx_msg void OnToolsServerStatus();
    afx_msg void OnSelectColumns();
    afx_msg void OnToolsConfigWizard();
    afx_msg void OnToolsAdminConsole();
    afx_msg void OnToolsMonitor();
    afx_msg void OnImportSentItems();
    afx_msg void OnImportInbox();
    afx_msg void OnToolsFaxPrinterProps();
    afx_msg void OnUpdateWindowsXPTools(CCmdUI* pCmdUI);
    afx_msg void OnUpdateSelectColumns(CCmdUI* pCmdUI);
    afx_msg void OnUpdateServerStatus(CCmdUI* pCmdUI);
    afx_msg void OnUpdateRefreshFolder(CCmdUI* pCmdUI);
    afx_msg void OnUpdateFolderItemsCount(CCmdUI* pCmdUI);
    afx_msg void OnUpdateActivity(CCmdUI* pCmdUI);
    afx_msg void OnUpdateSendNewFax(CCmdUI* pCmdUI);
    afx_msg void OnUpdateReceiveNewFax(CCmdUI* pCmdUI);
    afx_msg void OnUpdateImportSent(CCmdUI* pCmdUI);
    afx_msg void OnUpdateToolsFaxPrinterProps(CCmdUI* pCmdUI);
    afx_msg void OnUpdateHelpContents(CCmdUI* pCmdUI);
    afx_msg void OnStatusBarDblClk(NMHDR* pNotifyStruct, LRESULT* result);
    afx_msg LRESULT OnQueryEndSession(WPARAM, LPARAM);

    DWORD   CreateDynamicView (DWORD dwChildId, 
                               LPCTSTR lpctstrName, 
                               CRuntimeClass* pViewClass,
                               CDocument *pDoc,
                               int *pColumnsUsed,
                               DWORD dwDefaultColNum,
                               CFolderListView **ppNewView,
                               FolderType type);

    void SaveLayout();
    void FrameToSavedLayout();
    void SplitterToSavedLayout();

    void ImportArchive(BOOL bSentArch);

    CListView *m_pInitialRightPaneView; // Points to the initial right pane view 
                                        // created during the frame creation.
                                        // This view is used when the tree root is
                                        // selected or when a server node is selected 
                                        // in the tree.

    CLeftView *m_pLeftView;             // Pointer to the left view.
                                        // We must have this here (instead of using GetPane)
                                        // for threads to call the left pane.

    CFolderListView*    m_pIncomingView;   // Pointer to the global view 
                                           // of the incoming folder
    CFolderListView*    m_pInboxView;      // Pointer to the global view 
                                           // of the inbox folder
    CFolderListView*    m_pSentItemsView;  // Pointer to the global view 
                                           // of the sent items folder
    CFolderListView*    m_pOutboxView;     // Pointer to the global view 
                                           // of the outbox folder
};

inline CMainFrame *GetFrm ()       { return (CMainFrame *)AfxGetMainWnd(); }

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MAINFRM_H__989CC918_D8CD_4A1E_811B_1AEE446A303D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\leftview.h ===
// LeftView.h : interface of the CLeftView class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_LEFTVIEW_H__8D2F8964_7AE2_4CB2_9FFB_03CF78C2C869__INCLUDED_)
#define AFX_LEFTVIEW_H__8D2F8964_7AE2_4CB2_9FFB_03CF78C2C869__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


//
// List of icon indices, used in the tree control
//
typedef enum
{
    TREE_IMAGE_ROOT,                // Client console tree root
    TREE_IMAGE_SERVER_ONLINE,       // Online server
    TREE_IMAGE_SERVER_OFFLINE,      // Offline server
    TREE_IMAGE_INCOMING,            // Incoming folder
    TREE_IMAGE_INBOX,               // Inbox folder
    TREE_IMAGE_OUTBOX_PAUSED,       // The server's outgoing queue is paused 
    TREE_IMAGE_OUTBOX_BLOCKED,      // The server's outgoing queue is blocked
    TREE_IMAGE_OUTBOX,              // Outbox folder
    TREE_IMAGE_SERVER_REFRESHING,   // Refreshing server (connecting...)
    TREE_IMAGE_MAX
} TreeIconType; 

class CLeftView : public CTreeView
{
protected: // create from serialization only
    CLeftView();
    DECLARE_DYNCREATE(CLeftView)

// Attributes
public:
    virtual  ~CLeftView();

    CClientConsoleDoc* GetDocument();

    CFolderListView* GetCurrentView() { return m_pCurrentView; }

    BOOL   CanRefreshFolder();
    DWORD  RefreshCurrentFolder();

    DWORD OpenSelectColumnsDlg();
    BOOL  CanOpenSelectColumnsDlg() { return m_pCurrentView ? TRUE : FALSE; }

    int GetDataCount();

    BOOL GetActivity(CString& cstr, HICON& hIcon);

    BOOL  IsRemoteServerSelected();
    DWORD RemoveTreeItem(HTREEITEM hItem);

    DWORD SelectRoot();

    DWORD OpenHelpTopic();

    VOID  SelectFolder (FolderType);

    DWORD RefreshImageList ();

    static CImageList  m_ImageList;       // Image list of tree icons

#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CLeftView)
    public:
    virtual void OnDraw(CDC* pDC);  // overridden to draw this view
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
    protected:
    virtual void OnInitialUpdate(); // called first time after construct
    //}}AFX_VIRTUAL

// Generated message map functions
protected:
    //{{AFX_MSG(CLeftView)
    afx_msg void OnTreeSelChanged(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnRightClick(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnChar(UINT nChar, UINT nRepCnt, UINT nFlags);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:

    void GetServerState(BOOL& bRefreshing, DWORD& dwOffLineCount);

    DWORD 
    SyncFolderNode (
        HTREEITEM       hParent,
        BOOL            bVisible,
        int             iNodeStringResource,
        HTREEITEM       hInsertAfter,
        TreeIconType    iconNormal,
        TreeIconType    iconSelected,
        LPARAM          lparamNodeData,
        HTREEITEM      &hNode
    );

    HTREEITEM FindNode (HTREEITEM hRoot, CString &cstrNodeString);

    HTREEITEM   m_treeitemRoot;    // Root fo tree

    CFolderListView*  m_pCurrentView;

    int         m_iLastActivityStringId;
};

#ifndef _DEBUG  // debug version in LeftView.cpp
inline CClientConsoleDoc* CLeftView::GetDocument()
   { return (CClientConsoleDoc*)m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_LEFTVIEW_H__8D2F8964_7AE2_4CB2_9FFB_03CF78C2C869__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\message.h ===
// Message.h: interface for the CArchiveMsg class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_MESSAGE_H__C1376D20_394B_4B2F_BF50_0585A2A85AE2__INCLUDED_)
#define AFX_MESSAGE_H__C1376D20_394B_4B2F_BF50_0585A2A85AE2__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef NUMERIC_CMP
    #define NUMERIC_CMP(a,b)   (((a) == (b)) ? 0 : (((a) < (b)) ? -1 : 1))
#endif

class CArchiveMsg : public CFaxMsg
{
public:

    DECLARE_DYNCREATE(CArchiveMsg)

    CArchiveMsg () {}
    virtual ~CArchiveMsg() {}

    DWORD Init (PFAX_MESSAGE pMsg, CServerNode* pServer);

    DWORD Copy(const CArchiveMsg& other);

    //
    // Operations:
    //
    DWORD GetTiff (CString &cstrTiffLocation) const;
    DWORD Delete ();

    //
    // Item retrival:
    //
    const CString &GetSenderName () const           
        { ASSERT (m_bValid); return m_cstrSenderName; }

    const CString &GetSenderNumber () const         
        { ASSERT (m_bValid); return m_cstrSenderNumber; }

    const CFaxDuration &GetTransmissionDuration () const 
        { ASSERT (m_bValid); return m_tmTransmissionDuration; }

private:

    CString       m_cstrSenderNumber; 
    CString       m_cstrSenderName; 

    CFaxDuration  m_tmTransmissionDuration; 
};

#endif // !defined(AFX_MESSAGE_H__C1376D20_394B_4B2F_BF50_0585A2A85AE2__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\messagefolder.cpp ===
// MessageFolder.cpp: implementation of the CMessageFolder class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#define __FILE_ID__     14

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

#define DEFAULT_NUM_MSGS_PER_CALL       100


DWORD  CMessageFolder::m_sdwNumMessagesPerRPCCall = 0;

void 
CMessageFolder::ReadConfiguration ()
/*++

Routine name : CMessageFolder::ReadConfiguration

Routine description:

    Reads the Messages-Per-RPC-Call parameters from the registry

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:


Return Value:

    None.

--*/
{
    m_sdwNumMessagesPerRPCCall = 
        AfxGetApp ()->GetProfileInt (CLIENT_ARCHIVE_KEY, 
                                     CLIENT_ARCHIVE_MSGS_PER_CALL, 
                                     DEFAULT_NUM_MSGS_PER_CALL);
}

DWORD
CMessageFolder::Refresh ()
/*++

Routine name : CMessageFolder::Refresh

Routine description:

    Rebuilds the map of the message using the client API.
    This function is always called in the context of a worker thread.

    This function must be called when the data critical section is held.

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:


Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CMessageFolder::Refresh"), dwRes, TEXT("Type=%d"), Type());
    //
    // Enumerate archived messages from the server
    //
    ASSERTION (m_pServer);
    HANDLE              hFax;
    HANDLE              hEnum;
    DWORD               dwIndex;
    DWORD               dwNumMsgs = 0;
    PFAX_MESSAGE        pMsgs = NULL;
    MSGS_MAP            mapChunk;


    ASSERTION (m_sdwNumMessagesPerRPCCall);
    dwRes = m_pServer->GetConnectionHandle (hFax);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (RPC_ERR, TEXT("CFolder::GetConnectionHandle"), dwRes);
        return dwRes;
    }
    if (m_bStopRefresh)
    {
        //
        // Quit immediately
        //
        return dwRes;
    }
    START_RPC_TIME(TEXT("FaxStartMessagesEnum")); 
    if (!FaxStartMessagesEnum (hFax, m_Folder, &hEnum))
    {
        dwRes = GetLastError ();
        END_RPC_TIME(TEXT("FaxStartMessagesEnum"));
        if (ERROR_NO_MORE_ITEMS == dwRes)
        {
            //
            // This is not a real error - the folder is simply empty
            //
            VERBOSE (DBG_MSG, TEXT("Folder is empty"));
            dwRes = ERROR_SUCCESS;
            return dwRes;
        }
        m_pServer->SetLastRPCError (dwRes);
        CALL_FAIL (RPC_ERR, TEXT("FaxStartMessagesEnum"), dwRes);
        return dwRes;
    }
    END_RPC_TIME(TEXT("FaxStartMessagesEnum"));
    if (m_bStopRefresh)
    {
        //
        // Quit immediately
        //
        goto exit;
    }
    //
    // Make sure our list is empty
    //
    ASSERTION (!m_Msgs.size()); 
    //
    // Get the messages in bunches
    //
    while (ERROR_SUCCESS == dwRes)
    {
        DWORD dwReturnedMsgs;
        START_RPC_TIME(TEXT("FaxEnumMessages")); 
        if (!FaxEnumMessages (hEnum, m_sdwNumMessagesPerRPCCall, &pMsgs, &dwReturnedMsgs))
        {
            dwRes = GetLastError ();
            END_RPC_TIME(TEXT("FaxEnumMessages"));
            if (ERROR_NO_MORE_ITEMS != dwRes)
            {   
                //
                // Really an error
                //
                m_pServer->SetLastRPCError (dwRes);
                CALL_FAIL (RPC_ERR, TEXT("FaxEnumMessages"), dwRes);
                goto exit;
            }
            else
            {
                //
                // Not an error - just a "end of data" sign
                //
                break;
            }
        }
        END_RPC_TIME(TEXT("FaxEnumMessages"));
        if (m_bStopRefresh)
        {
            //
            // Quit immediately
            //
            goto exit;
        }
        //
        // Success in enumeration
        //
        mapChunk.clear();
        for (dwIndex = 0; dwIndex < dwReturnedMsgs; dwIndex++)
        {
            CArchiveMsg *pMsg = NULL;
            //
            // Create a new message 
            //
            try
            {
                pMsg = new CArchiveMsg;
            }
            catch (...)
            {
                dwRes = ERROR_NOT_ENOUGH_MEMORY;
                CALL_FAIL (MEM_ERR, TEXT("new CArchiveMsg"), dwRes);
                goto exit;
            }
            //
            // Init the message 
            //
            dwRes = pMsg->Init (&pMsgs[dwIndex], m_pServer);
            if (ERROR_SUCCESS != dwRes)
            {
                CALL_FAIL (MEM_ERR, TEXT("CArchiveMsg::Init"), dwRes);
                SAFE_DELETE (pMsg);
                goto exit;
            }
            //
            // Enter the message into the map
            //
            EnterData();
            try
            {
                m_Msgs[pMsgs[dwIndex].dwlMessageId] = pMsg;
                mapChunk[pMsgs[dwIndex].dwlMessageId] = pMsg;
            }
            catch (...)
            {
                dwRes = ERROR_NOT_ENOUGH_MEMORY;
                CALL_FAIL (MEM_ERR, TEXT("map::operator[]"), dwRes);
                SAFE_DELETE (pMsg);
                LeaveData ();
                goto exit;
            }
            LeaveData ();

            if (m_bStopRefresh)
            {
                //
                // Quit immediately
                //
                goto exit;
            }
        }
        //
        // Free current chunk of messages
        //
        FaxFreeBuffer ((LPVOID)pMsgs);
        pMsgs = NULL;

        if (m_pAssignedView)
        {
            //
            // Folder has a view attached
            //
            m_pAssignedView->SendMessage (
                           WM_FOLDER_ADD_CHUNK,
                           WPARAM (dwRes), 
                           LPARAM (&mapChunk));
        }
    }
    if (ERROR_NO_MORE_ITEMS == dwRes)
    {
        //
        // Not a real error
        //
        dwRes = ERROR_SUCCESS;
    }
    ASSERTION (ERROR_SUCCESS == dwRes);

exit:

    //
    // Close enumeration handle
    //
    ASSERTION (hEnum);
    {
        START_RPC_TIME(TEXT("FaxEndMessagesEnum")); 
        if (!FaxEndMessagesEnum (hEnum))
        {
            dwRes = GetLastError ();
            END_RPC_TIME(TEXT("FaxEndMessagesEnum"));
            m_pServer->SetLastRPCError (dwRes);
            CALL_FAIL (RPC_ERR, TEXT("FaxEndMessagesEnum"), dwRes);
        }
        else
        {
            END_RPC_TIME(TEXT("FaxEndMessagesEnum"));
        }
    }
    //
    // Free left overs (if exist)
    //
    FaxFreeBuffer ((LPVOID)pMsgs);
    return dwRes;
}   // CMessageFolder::Refresh



DWORD 
CMessageFolder::OnJobAdded (
    DWORDLONG dwlMsgId
)
/*++

Routine name : CMessageFolder::OnJobAdded

Routine description:

	Handles notification of a message added to the archive

Author:

	Eran Yariv (EranY),	Feb, 2000

Arguments:

	dwlMsgId   [in]     - New message unique id

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CMessageFolder::OnJobAdded"), 
              dwRes, 
              TEXT("MsgId=0x%016I64x, Type=%d"), 
              dwlMsgId,
              Type());

    HANDLE              hFax;
    PFAX_MESSAGE        pFaxMsg = NULL;
    CArchiveMsg           *pMsg = NULL;

    EnterData ();
    pMsg = (CArchiveMsg*)FindMessage (dwlMsgId);
    if (pMsg)
    {
        //
        // This message is already in the archive
        //
        VERBOSE (DBG_MSG, TEXT("Message is already known and visible"));
        goto exit;
    }
    //
    // Get information about this message
    //
    dwRes = m_pServer->GetConnectionHandle (hFax);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (RPC_ERR, TEXT("CFolder::GetConnectionHandle"), dwRes);
        goto exit;
    }
    {
        START_RPC_TIME(TEXT("FaxGetMessage")); 
        if (!FaxGetMessage (hFax, dwlMsgId, m_Folder, &pFaxMsg))
        {
            dwRes = GetLastError ();
            END_RPC_TIME(TEXT("FaxGetMessage"));
            m_pServer->SetLastRPCError (dwRes);
            CALL_FAIL (RPC_ERR, TEXT("FaxGetMessage"), dwRes);
            goto exit;
        }
        END_RPC_TIME(TEXT("FaxGetMessage"));
    }
    //
    // Enter a new message to the map
    //
    try
    {
        pMsg = new CArchiveMsg;
        ASSERTION (pMsg);
        m_Msgs[pFaxMsg->dwlMessageId] = pMsg;
    }
    catch (...)
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        SAFE_DELETE (pMsg);
        goto exit;
    }
    //
    // Init the message 
    //
    dwRes = pMsg->Init (pFaxMsg, m_pServer);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (MEM_ERR, TEXT("CArchiveMsg::Init"), dwRes);
        //
        // Remove message from map and delete it
        //
        if (pMsg)
        {
            try
            {
                m_Msgs.erase (pFaxMsg->dwlMessageId);
            }
            catch (...)
            {
                dwRes = ERROR_NOT_ENOUGH_MEMORY;
                CALL_FAIL (MEM_ERR, TEXT("map::erase"), dwRes);
            }
            SAFE_DELETE (pMsg);
        }
        goto exit;
    }
    if (m_pAssignedView)
    {
        //
        // If this folder is alive - tell our view to add the message
        //
        m_pAssignedView->OnUpdate (NULL, UPDATE_HINT_ADD_ITEM, pMsg);
    }
    
    ASSERTION (ERROR_SUCCESS == dwRes);

exit:
    if(pFaxMsg)
    {
        FaxFreeBuffer(pFaxMsg);
    }
    LeaveData ();
    return dwRes;
}   // CMessageFolder::OnJobAdded
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\messagefolder.h ===
// MessageFolder.h: interface for the CMessageFolder class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_MESSAGEFOLDER_H__5236D732_0E9D_4B89_A1CB_2185C21746FD__INCLUDED_)
#define AFX_MESSAGEFOLDER_H__5236D732_0E9D_4B89_A1CB_2185C21746FD__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CMessageFolder : public CFolder  
{
public:
    CMessageFolder(
        FolderType type, 
        FAX_ENUM_MESSAGE_FOLDER Folder
    ) : 
        CFolder(type),
        m_Folder (Folder)
    {}

    virtual ~CMessageFolder() { PreDestruct(); }

    DWORD Refresh ();

    static void ReadConfiguration ();

    DWORD OnJobAdded (DWORDLONG dwlMsgId);
    DWORD OnJobUpdated (DWORDLONG dwlMsgId, PFAX_JOB_STATUS pNewStatus)
        { ASSERT (FALSE); return ERROR_CALL_NOT_IMPLEMENTED; }

private:

    FAX_ENUM_MESSAGE_FOLDER m_Folder;   // Inbox / Sent items
    static DWORD            m_sdwNumMessagesPerRPCCall; // Number of messages to 
                                                        // retrieve per RPC call.
};

#endif // !defined(AFX_MESSAGEFOLDER_H__5236D732_0E9D_4B89_A1CB_2185C21746FD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\outboxdetailspg.cpp ===
// OutboxDetailsPg.cpp : implementation file
//

#include "stdafx.h"

#define __FILE_ID__     53

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//
// this array maps CViewRow items to 
// dialog control IDs
//
static TMsgPageInfo s_PageInfo[] = 
{
    MSG_VIEW_ITEM_USER,             IDC_USER_VALUE,
    MSG_VIEW_ITEM_PRIORITY,         IDC_PRIORITY_VALUE,
    MSG_VIEW_ITEM_CSID,             IDC_CSID_VALUE,
    MSG_VIEW_ITEM_TSID,             IDC_TSID_VALUE,
    MSG_VIEW_ITEM_DEVICE,           IDC_DEVICE_VALUE,
    MSG_VIEW_ITEM_RETRIES,          IDC_RETRIES_VALUE,
    MSG_VIEW_ITEM_ID,               IDC_JOB_ID_VALUE,
    MSG_VIEW_ITEM_BROADCAST_ID,     IDC_BROADCAST_ID_VALUE,
    MSG_VIEW_ITEM_SUBMIT_TIME,      IDC_SUBMISSION_TIME_VALUE,
    MSG_VIEW_ITEM_BILLING,          IDC_BILLING_CODE_VALUE
};


/////////////////////////////////////////////////////////////////////////////
// COutboxDetailsPg property page

IMPLEMENT_DYNCREATE(COutboxDetailsPg, CMsgPropertyPg)


COutboxDetailsPg::COutboxDetailsPg(
    CFaxMsg* pMsg     // pointer to CJob
) : 
    CMsgPropertyPg(COutboxDetailsPg::IDD, pMsg)
{
}

COutboxDetailsPg::~COutboxDetailsPg()
{
}

void COutboxDetailsPg::DoDataExchange(CDataExchange* pDX)
{
	CMsgPropertyPg::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(COutboxDetailsPg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(COutboxDetailsPg, CMsgPropertyPg)
	//{{AFX_MSG_MAP(COutboxDetailsPg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// COutboxDetailsPg message handlers

BOOL 
COutboxDetailsPg::OnInitDialog() 
{
    DBG_ENTER(TEXT("COutboxDetailsPg::OnInitDialog"));

    CMsgPropertyPg::OnInitDialog();

    Refresh(s_PageInfo, sizeof(s_PageInfo)/sizeof(s_PageInfo[0]));
	
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\outboxgeneralpg.cpp ===
// OutboxGeneralPg.cpp : implementation file
//

#include "stdafx.h"

#define __FILE_ID__     43

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//
// this array maps CViewRow items to 
// dialog control IDs
//
static TMsgPageInfo s_PageInfo[] = 
{
    MSG_VIEW_ITEM_DOC_NAME,         IDC_DOC_NAME_VALUE,
    MSG_VIEW_ITEM_SUBJECT,          IDC_SUBJECT_VALUE,
    MSG_VIEW_ITEM_RECIPIENT_NAME,   IDC_RECIPIENT_NAME_VALUE,
    MSG_VIEW_ITEM_RECIPIENT_NUMBER, IDC_RECIPIENT_NUMBER_VALUE,
    MSG_VIEW_ITEM_STATUS,           IDC_STATUS_VALUE,
    MSG_VIEW_ITEM_EXTENDED_STATUS,  IDC_EXTENDED_STATUS_VALUE,
    MSG_VIEW_ITEM_NUM_PAGES,        IDC_PAGES_VALUE,
    MSG_VIEW_ITEM_CURRENT_PAGE,     IDC_CURRENT_PAGE_VALUE,
    MSG_VIEW_ITEM_SIZE,             IDC_SIZE_VALUE,
    MSG_VIEW_ITEM_SEND_TIME,        IDC_TRANSMISSION_TIME_VALUE
};


/////////////////////////////////////////////////////////////////////////////
// COutboxGeneralPg property page

IMPLEMENT_DYNCREATE(COutboxGeneralPg, CMsgPropertyPg)


COutboxGeneralPg::COutboxGeneralPg(
    CFaxMsg* pMsg     // pointer to CJob
) : 
    CMsgPropertyPg(COutboxGeneralPg::IDD, pMsg)
{
}

COutboxGeneralPg::~COutboxGeneralPg()
{
}

void COutboxGeneralPg::DoDataExchange(CDataExchange* pDX)
{
	CMsgPropertyPg::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(COutboxGeneralPg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(COutboxGeneralPg, CMsgPropertyPg)
	//{{AFX_MSG_MAP(COutboxGeneralPg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// COutboxGeneralPg message handlers

BOOL 
COutboxGeneralPg::OnInitDialog() 
{
    DBG_ENTER(TEXT("COutboxGeneralPg::OnInitDialog"));

    CMsgPropertyPg::OnInitDialog();

    Refresh(s_PageInfo, sizeof(s_PageInfo)/sizeof(s_PageInfo[0]));

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\msgpropertypg.cpp ===
// MessagePropertyPg.cpp : implementation file
//

#include "stdafx.h"

#define __FILE_ID__     58

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CMessagePropertyPg property page

IMPLEMENT_DYNCREATE(CMsgPropertyPg, CFaxClientPg)

CMsgPropertyPg::CMsgPropertyPg(
    DWORD dwResId,      // dialog resource id
    CFaxMsg* pMsg       // pointer to CArchiveMsg/CJob
): 
    CFaxClientPg(dwResId),
    m_pMsg(pMsg)
{
}

CMsgPropertyPg::~CMsgPropertyPg()
{
}

void CMsgPropertyPg::DoDataExchange(CDataExchange* pDX)
{
	CFaxClientPg::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMessagePropertyPg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CMsgPropertyPg, CFaxClientPg)
	//{{AFX_MSG_MAP(CMessagePropertyPg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMessagePropertyPg message handlers

void
CMsgPropertyPg::Refresh(
    TMsgPageInfo* pPageInfo,    // page info array
    DWORD dwSize                    // size of the array
) 
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CMessagePropertyPg::Refresh"));

    CFaxClientPg::OnInitDialog();

    CItemPropSheet* pParent = (CItemPropSheet*)GetParent();

    //
    // create CArchiveMsg adapter
    //
    CViewRow messView;
    dwRes = messView.AttachToMsg(m_pMsg);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("CViewRow::AttachToMsg"), dwRes);
        pParent->SetLastError(ERROR_INVALID_DATA);
        pParent->EndDialog(IDABORT);
        return;
    }

    
    CWnd *pWnd;

    for(DWORD dw=0; dw < dwSize; ++dw)
    {
        //
        // set item value
        //
        pWnd = GetDlgItem(pPageInfo[dw].dwValueResId);
        if(NULL == pWnd)
        {
            dwRes = ERROR_INVALID_HANDLE;
            CALL_FAIL (WINDOW_ERR, TEXT("CWnd::GetDlgItem"), dwRes);
            break;
        }
        pWnd->SetWindowText(messView.GetItemString(pPageInfo[dw].itemType));
        //
        // Place the caret back at the beginning of the text
        //
        pWnd->SendMessage (EM_SETSEL, 0, 0);
    }
    
    if (ERROR_SUCCESS != dwRes)
    {
        pParent->SetLastError(ERROR_INVALID_DATA);
        pParent->EndDialog(IDABORT);
    }
}

BOOL 
CMsgPropertyPg::OnSetActive()
{
  BOOL bRes = CFaxClientPg::OnSetActive();

  GetParent()->PostMessage(WM_SET_SHEET_FOCUS, 0, 0L);

  return bRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\outboxdetailspg.h ===
#if !defined(AFX_OUTBOXDETAILSPG_H__A2BCE6CD_3ABB_456A_B9B0_198AA6E5CFFD__INCLUDED_)
#define AFX_OUTBOXDETAILSPG_H__A2BCE6CD_3ABB_456A_B9B0_198AA6E5CFFD__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// OutboxDetailsPg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// COutboxDetailsPg dialog

class COutboxDetailsPg : public CMsgPropertyPg
{
	DECLARE_DYNCREATE(COutboxDetailsPg)

// Construction
public:
	COutboxDetailsPg(CFaxMsg* pMsg);
	~COutboxDetailsPg();

// Dialog Data
	//{{AFX_DATA(COutboxDetailsPg)
	enum { IDD = IDD_OUTBOX_DETAILS };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(COutboxDetailsPg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
private:
    COutboxDetailsPg() {}

protected:
	// Generated message map functions
	//{{AFX_MSG(COutboxDetailsPg)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_OUTBOXDETAILSPG_H__A2BCE6CD_3ABB_456A_B9B0_198AA6E5CFFD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\msgpropertypg.h ===
#if !defined(AFX_MESSAGEPROPERTYPG_H__B7AA6069_11CD_4BE2_AFC5_A9C5E9B79CE5__INCLUDED_)
#define AFX_MESSAGEPROPERTYPG_H__B7AA6069_11CD_4BE2_AFC5_A9C5E9B79CE5__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// MsgPropertyPg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CMessagePropertyPg dialog

class CMsgPropertyPg : public CFaxClientPg
{
	DECLARE_DYNCREATE(CMsgPropertyPg)

// Construction
public:
	CMsgPropertyPg(DWORD dwResId, CFaxMsg* pMsg);
	~CMsgPropertyPg();

// Dialog Data
	//{{AFX_DATA(CMsgPropertyPg)
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CMessagePropertyPg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    virtual BOOL OnSetActive();
	//}}AFX_VIRTUAL

// Implementation
protected:
    CMsgPropertyPg() {}

    void Refresh(TMsgPageInfo* pPageInfo, DWORD dwSize);

    CFaxMsg* m_pMsg;

    // Generated message map functions
	//{{AFX_MSG(CMsgPropertyPg)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MESSAGEPROPERTYPG_H__B7AA6069_11CD_4BE2_AFC5_A9C5E9B79CE5__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\outboxgeneralpg.h ===
#if !defined(AFX_OUTBOXGENERALPG_H__A2BCE6CD_3ABB_456A_B9B0_198AA6E5CFFD__INCLUDED_)
#define AFX_OUTBOXGENERALPG_H__A2BCE6CD_3ABB_456A_B9B0_198AA6E5CFFD__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// OutboxGeneralPg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// COutboxGeneralPg dialog

class COutboxGeneralPg : public CMsgPropertyPg
{
	DECLARE_DYNCREATE(COutboxGeneralPg)

// Construction
public:
	COutboxGeneralPg(CFaxMsg* pMsg);
	~COutboxGeneralPg();

// Dialog Data
	//{{AFX_DATA(COutboxGeneralPg)
	enum { IDD = IDD_OUTBOX_GENERAL };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(COutboxGeneralPg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
private:
    COutboxGeneralPg() {}

protected:
	// Generated message map functions
	//{{AFX_MSG(COutboxGeneralPg)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_OUTBOXGENERALPG_H__A2BCE6CD_3ABB_456A_B9B0_198AA6E5CFFD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\personalinfopg.cpp ===
// PersonalInfoPg.cpp : implementation file
//

#include "stdafx.h"

#define __FILE_ID__     44

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//
// this array maps dialog control IDs to
// number of string in FAX_PERSONAL_PROFILE structure
//
static TPersonalPageInfo s_PageInfo[] = 
{ 
    IDC_NAME_VALUE,             PERSONAL_PROFILE_NAME,
    IDC_FAX_NUMBER_VALUE,       PERSONAL_PROFILE_FAX_NUMBER,
    IDC_COMPANY_VALUE,          PERSONAL_PROFILE_COMPANY,
    IDC_TITLE_VALUE,            PERSONAL_PROFILE_TITLE,
    IDC_DEPARTMENT_VALUE,       PERSONAL_PROFILE_DEPARTMENT,
    IDC_OFFICE_VALUE,           PERSONAL_PROFILE_OFFICE_LOCATION,
    IDC_HOME_PHONE_VALUE,       PERSONAL_PROFILE_HOME_PHONE,
    IDC_BUSINESS_PHONE_VALUE,   PERSONAL_PROFILE_OFFICE_PHONE,
    IDC_EMAIL_VALUE,            PERSONAL_PROFILE_EMAIL,
    IDC_BILLING_CODE_VALUE,     PERSONAL_PROFILE_BILLING_CODE,
    IDC_ADDRESS_VALUE,          PERSONAL_PROFILE_STREET_ADDRESS
};

/////////////////////////////////////////////////////////////////////////////
// CPersonalInfoPg property page

IMPLEMENT_DYNCREATE(CPersonalInfoPg, CFaxClientPg)


CPersonalInfoPg::CPersonalInfoPg(
    DWORD dwCaptionId,              // page caption id
    EnumPersinalInfo ePersonalInfo, // type of Persinal Info (SENDER or RECIPIENT)
    CFaxMsg* pMsg,                  // pointer to CJob or CArchiveMsg
    CFolder* pFolder                // folder
) : 
    CFaxClientPg(CPersonalInfoPg::IDD, dwCaptionId),
    m_ePersonalInfo(ePersonalInfo),
    m_pPersonalProfile(NULL),
    m_pMsg(pMsg),
    m_pFolder(pFolder)
{
    DBG_ENTER(TEXT("CPersonalInfoPg::CPersonalInfoPg"));

    ASSERTION(NULL != pFolder);
    ASSERTION(PERSON_SENDER == ePersonalInfo || PERSON_RECIPIENT == ePersonalInfo);
}

CPersonalInfoPg::~CPersonalInfoPg()
{
    if(m_pPersonalProfile)
    {
        FaxFreeBuffer(m_pPersonalProfile);
    }
}

void CPersonalInfoPg::DoDataExchange(CDataExchange* pDX)
{
	CFaxClientPg::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPersonalInfoPg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPersonalInfoPg, CFaxClientPg)
	//{{AFX_MSG_MAP(CPersonalInfoPg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPersonalInfoPg message handlers

DWORD 
CPersonalInfoPg::Init()
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CPersonalInfoPg::Init"));


    ASSERTION(m_pFolder);

    //
    // get server handle
    //
    CServerNode *pServer = const_cast<CServerNode *>(m_pFolder->GetServer());       
    HANDLE hFax;
    dwRes = pServer->GetConnectionHandle (hFax);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("CServerNode::GetConnectionHandle"), dwRes);
        return dwRes;        
    }

    //
    // get folder type and message id
    //
    DWORDLONG  dwlMessageId;
    FAX_ENUM_MESSAGE_FOLDER  eFolder;    
    FolderType type = m_pFolder->Type();

    dwlMessageId = m_pMsg->GetId();

    switch(type)
    {
    case FOLDER_TYPE_INCOMING:
    case FOLDER_TYPE_OUTBOX:
        eFolder = FAX_MESSAGE_FOLDER_QUEUE;
        break;
    case FOLDER_TYPE_INBOX:
        eFolder = FAX_MESSAGE_FOLDER_INBOX;
        break;
    case FOLDER_TYPE_SENT_ITEMS:
        eFolder = FAX_MESSAGE_FOLDER_SENTITEMS;
        break;
    default:
        ASSERTION_FAILURE
        return ERROR_CAN_NOT_COMPLETE;
    };

    //
    // get personal info
    //
    if(PERSON_RECIPIENT == m_ePersonalInfo)
    {
        //
        // get recipient info
        //
        START_RPC_TIME(TEXT("FaxGetRecipientInfo")); 
        if (!FaxGetRecipientInfo(hFax, dwlMessageId, eFolder, &m_pPersonalProfile))
        {
            dwRes = GetLastError ();
            END_RPC_TIME(TEXT("FaxGetRecipientInfo")); 
            pServer->SetLastRPCError (dwRes);
            CALL_FAIL (RPC_ERR, TEXT("FaxGetRecipientInfo"), dwRes);
            m_pPersonalProfile = NULL;
            return dwRes;
        }
        END_RPC_TIME(TEXT("FaxGetRecipientInfo")); 
    }
    else // if(PERSON_SENDER == m_ePersonalInfo)
    {
        //
        // get sender info
        //
        START_RPC_TIME(TEXT("FaxGetSenderInfo")); 
        if (!FaxGetSenderInfo(hFax, dwlMessageId, eFolder, &m_pPersonalProfile))
        {
            dwRes = GetLastError ();
            END_RPC_TIME(TEXT("FaxGetSenderInfo")); 
            pServer->SetLastRPCError (dwRes);
            CALL_FAIL (RPC_ERR, TEXT("FaxGetSenderInfo"), dwRes);
            m_pPersonalProfile = NULL;
            return dwRes;
        }
        END_RPC_TIME(TEXT("FaxGetSenderInfo")); 
    }


    return dwRes;
}

BOOL 
CPersonalInfoPg::OnInitDialog() 
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CPersonalInfoPg::OnInitDialog"));

    CFaxClientPg::OnInitDialog();

    if(!m_pPersonalProfile)
    {
        return TRUE;
    }

    CItemPropSheet* pParent = (CItemPropSheet*)GetParent();


    //
    // array of strings from FAX_PERSONAL_PROFILE
    //
    TCHAR** ptchValues = ptchValues = &(m_pPersonalProfile->lptstrName);

    CWnd *pWnd;
    dwRes = ERROR_SUCCESS;
    DWORD dwSize = sizeof(s_PageInfo)/sizeof(s_PageInfo[0]);    
    for(DWORD dw=0; dw < dwSize; ++dw)
    {
        //
        // set item value
        //
        pWnd = GetDlgItem(s_PageInfo[dw].dwValueResId);
        if(NULL == pWnd)
        {
            dwRes = ERROR_INVALID_HANDLE;
            CALL_FAIL (WINDOW_ERR, TEXT("CWnd::GetDlgItem"), dwRes);
            break;
        }

        pWnd->SetWindowText(ptchValues[s_PageInfo[dw].eValStrNum]);
        //
        // Place the caret back at the beginning of the text
        //
        pWnd->SendMessage (EM_SETSEL, 0, 0);
    }

    if (ERROR_SUCCESS != dwRes)
    {
        pParent->SetLastError(ERROR_INVALID_DATA);
        pParent->EndDialog(IDABORT);
    }
	
	return TRUE;
}

BOOL 
CPersonalInfoPg::OnSetActive()
{
  BOOL bRes = CFaxClientPg::OnSetActive();

  GetParent()->PostMessage(WM_SET_SHEET_FOCUS, 0, 0L);

  return bRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\queuefolder.h ===
// QueueFolder.h: interface for the CQueueFolder class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_QUEUEFOLDER_H__D91FC386_B879_4485_B32F_9A53F59554E3__INCLUDED_)
#define AFX_QUEUEFOLDER_H__D91FC386_B879_4485_B32F_9A53F59554E3__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CQueueFolder : public CFolder  
{
public:
    CQueueFolder(
        FolderType type, 
        DWORD dwJobTypes
    ) : 
        CFolder(type),
        m_dwJobTypes(dwJobTypes) 
    {}

    virtual ~CQueueFolder() { PreDestruct(); }

    DECLARE_DYNAMIC(CQueueFolder)

    DWORD Refresh ();

    DWORD OnJobAdded (DWORDLONG dwlMsgId);
    DWORD OnJobUpdated (DWORDLONG dwlMsgId, PFAX_JOB_STATUS pNewStatus);

private:
    
    DWORD  m_dwJobTypes;   // Bit mask of JT_* values to retrieve
};

#endif // !defined(AFX_QUEUEFOLDER_H__D91FC386_B879_4485_B32F_9A53F59554E3__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\personalinfopg.h ===
#if !defined(AFX_PERSONALINFOPG_H__C3EA2FB2_67AC_4552_AE70_7DE1E0544B60__INCLUDED_)
#define AFX_PERSONALINFOPG_H__C3EA2FB2_67AC_4552_AE70_7DE1E0544B60__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// PersonalInfoPg.h : header file
//

//
// this is FAX_PERSONAL_PROFILE struct string data members enum
// it ALWAYS should be synced with FAX_PERSONAL_PROFILE
//
enum EnumPersonalProfile
{
    PERSONAL_PROFILE_NAME = 0,
    PERSONAL_PROFILE_FAX_NUMBER,
    PERSONAL_PROFILE_COMPANY,
    PERSONAL_PROFILE_STREET_ADDRESS,
    PERSONAL_PROFILE_CITY,
    PERSONAL_PROFILE_STATE,
    PERSONAL_PROFILE_ZIP,
    PERSONAL_PROFILE_COUNTRY,
    PERSONAL_PROFILE_TITLE,
    PERSONAL_PROFILE_DEPARTMENT,
    PERSONAL_PROFILE_OFFICE_LOCATION,
    PERSONAL_PROFILE_HOME_PHONE,
    PERSONAL_PROFILE_OFFICE_PHONE,
    PERSONAL_PROFILE_EMAIL,
    PERSONAL_PROFILE_BILLING_CODE,
    PERSONAL_PROFILE_STR_NUM
};

struct TPersonalPageInfo
{
    DWORD               dwValueResId; // item value control id
    EnumPersonalProfile eValStrNum;   // number of string in FAX_PERSONAL_PROFILE structure
};

enum EnumPersinalInfo {PERSON_SENDER, PERSON_RECIPIENT};

/////////////////////////////////////////////////////////////////////////////
// CPersonalInfoPg dialog

class CPersonalInfoPg : public CFaxClientPg
{
	DECLARE_DYNCREATE(CPersonalInfoPg)

// Construction
public:    
	CPersonalInfoPg(DWORD dwCaptionId, 
                    EnumPersinalInfo ePersonalInfo, 
                    CFaxMsg* pMsg,
                    CFolder* pFolder);
	~CPersonalInfoPg();

    DWORD Init();

// Dialog Data
	//{{AFX_DATA(CPersonalInfoPg)
	enum { IDD = IDD_PERSONAL_INFO };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CPersonalInfoPg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    virtual BOOL OnSetActive();
	//}}AFX_VIRTUAL

// Implementation
private:
    CPersonalInfoPg() {}

    PFAX_PERSONAL_PROFILE m_pPersonalProfile;
    EnumPersinalInfo      m_ePersonalInfo;

    CFaxMsg* m_pMsg;
    CFolder* m_pFolder;

protected:
	// Generated message map functions
	//{{AFX_MSG(CPersonalInfoPg)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PERSONALINFOPG_H__C3EA2FB2_67AC_4552_AE70_7DE1E0544B60__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\printerselectdlg.cpp ===
// PrinterSelectDlg.cpp : implementation file
//

#include "stdafx.h"
#define __FILE_ID__     73

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPrinterSelectDlg dialog


CPrinterSelectDlg::CPrinterSelectDlg(CWnd* pParent /*=NULL*/)
	: CFaxClientDlg(CPrinterSelectDlg::IDD, pParent),
    m_pPrinterInfo2(NULL),
    m_dwNumPrinters(0)
{
    m_tszPrinter[0] = 0;

	//{{AFX_DATA_INIT(CPrinterSelectDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CPrinterSelectDlg::~CPrinterSelectDlg()
{
    SAFE_DELETE_ARRAY (m_pPrinterInfo2);
}

void CPrinterSelectDlg::DoDataExchange(CDataExchange* pDX)
{
	CFaxClientDlg::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPrinterSelectDlg)
	DDX_Control(pDX, IDC_PRINTER_SELECTOR, m_comboPrinters);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPrinterSelectDlg, CFaxClientDlg)
	//{{AFX_MSG_MAP(CPrinterSelectDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPrinterSelectDlg message handlers

DWORD
CPrinterSelectDlg::Init()
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CPrinterSelectDlg::Init"));

    dwRes = GetPrintersInfo(m_pPrinterInfo2, m_dwNumPrinters);
    if(ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("GetPrintersInfo"), dwRes);
        return dwRes;
    }
   
    return dwRes;
}

BOOL 
CPrinterSelectDlg::OnInitDialog() 
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CPrinterSelectDlg::OnInitDialog"));

    CFaxClientDlg::OnInitDialog();

    ASSERTION(m_pPrinterInfo2);

    int    nInx;
    TCHAR  tszDisplayStr[MAX_PATH];

    //
    // get default printer name
    //
    TCHAR  tszDefPrinter[MAX_PATH];
    DWORD  dwSize = sizeof(tszDefPrinter);
    if(!DPGetDefaultPrinter(tszDefPrinter, &dwSize))
    {
        CALL_FAIL (GENERAL_ERR, TEXT("DPGetDefaultPrinter"), ERROR_CAN_NOT_COMPLETE);
        _tcsnset(tszDefPrinter, TEXT('\0'), 2);
    }

    //
    // fill in printers combo box
    //
    for (DWORD dw=0; dw < m_dwNumPrinters; ++dw) 
    {
        if(m_pPrinterInfo2[dw].pPrinterName)
        {
            PrinterNameToDisplayStr(m_pPrinterInfo2[dw].pPrinterName, 
                                    tszDisplayStr,
                                    sizeof(tszDisplayStr) / sizeof (tszDisplayStr[0]));

            if(_tcscmp(m_pPrinterInfo2[dw].pPrinterName, tszDefPrinter) == 0)
            {
                //
                // save default printer display name
                //
                _tcscpy(tszDefPrinter, tszDisplayStr);
            }

            nInx = m_comboPrinters.AddString(tszDisplayStr);
            if(nInx >= 0)
            {
                if(CB_ERR == m_comboPrinters.SetItemDataPtr(nInx, (void*)&m_pPrinterInfo2[dw]))
                {
                    CALL_FAIL (WINDOW_ERR, TEXT("CComboBox::SetItemDataPtr"), ERROR_CAN_NOT_COMPLETE);
                }
            }
            else
            {
                CALL_FAIL (WINDOW_ERR, TEXT("CComboBox::AddString"), ERROR_CAN_NOT_COMPLETE);
            }
        }
    }

    //
    // set current selection on default printer
    //
    if(_tcslen(tszDefPrinter) > 0)
    {
        nInx = m_comboPrinters.SelectString(-1, tszDefPrinter);
        if(nInx < 0)
        {
            CALL_FAIL (WINDOW_ERR, TEXT("CComboBox::SelectString"), ERROR_CAN_NOT_COMPLETE);
        }
    }
	
	return TRUE;  
}

void CPrinterSelectDlg::OnOK() 
{
    DBG_ENTER(TEXT("CPrinterSelectDlg::OnOK"));

    int nIndex = m_comboPrinters.GetCurSel();
    if(CB_ERR != nIndex)
    {
        PRINTER_INFO_2* prnInfo = (PRINTER_INFO_2*)m_comboPrinters.GetItemDataPtr(nIndex);
        if(prnInfo && -1 != (INT_PTR)prnInfo)
        {
            _tcscpy(m_tszPrinter, prnInfo->pPrinterName);
        }
        else
        {
            CALL_FAIL (WINDOW_ERR, TEXT("CComboBox::GetItemDataPtr"), ERROR_CAN_NOT_COMPLETE);
        }
    }
    else
    {
        CALL_FAIL (WINDOW_ERR, TEXT("CComboBox::GetCurSel"), ERROR_CAN_NOT_COMPLETE);
    }
	
	CFaxClientDlg::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\sentitemsdetailspg.cpp ===
// SentItemsDetailsPg.cpp : implementation file
//

#include "stdafx.h"

#define __FILE_ID__     55

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// this array maps CViewRow items to 
// dialog control IDs
//
static TMsgPageInfo s_PageInfo[] = 
{
    MSG_VIEW_ITEM_USER,             IDC_USER_VALUE,
    MSG_VIEW_ITEM_PRIORITY,         IDC_PRIORITY_VALUE,
    MSG_VIEW_ITEM_CSID,             IDC_CSID_VALUE,
    MSG_VIEW_ITEM_TSID,             IDC_TSID_VALUE,
    MSG_VIEW_ITEM_ORIG_TIME,        IDC_SCHEDULED_TIME_VALUE,
    MSG_VIEW_ITEM_RETRIES,          IDC_RETRIES_VALUE,
    MSG_VIEW_ITEM_ID,               IDC_JOB_ID_VALUE,
    MSG_VIEW_ITEM_BROADCAST_ID,     IDC_BROADCAST_ID_VALUE,
    MSG_VIEW_ITEM_SUBMIT_TIME,      IDC_SUBMISSION_TIME_VALUE,
    MSG_VIEW_ITEM_BILLING,          IDC_BILLING_CODE_VALUE
};

/////////////////////////////////////////////////////////////////////////////
// CSentItemsDetailsPg property page

IMPLEMENT_DYNCREATE(CSentItemsDetailsPg, CMsgPropertyPg)


CSentItemsDetailsPg::CSentItemsDetailsPg(
    CFaxMsg* pMsg     // pointer to CArchiveMsg
) : 
    CMsgPropertyPg(CSentItemsDetailsPg::IDD, pMsg)
{
}

CSentItemsDetailsPg::~CSentItemsDetailsPg()
{
}

void CSentItemsDetailsPg::DoDataExchange(CDataExchange* pDX)
{
	CMsgPropertyPg::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSentItemsDetailsPg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSentItemsDetailsPg, CMsgPropertyPg)
	//{{AFX_MSG_MAP(CSentItemsDetailsPg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSentItemsDetailsPg message handlers

BOOL 
CSentItemsDetailsPg::OnInitDialog() 
{
    DBG_ENTER(TEXT("CSentItemsDetailsPg::OnInitDialog"));

    CMsgPropertyPg::OnInitDialog();

    Refresh(s_PageInfo, sizeof(s_PageInfo)/sizeof(s_PageInfo[0]));
	
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\printerselectdlg.h ===
#if !defined(AFX_PRINTERSELECTDLG_H__7AADFEBA_2CBF_4B46_89D0_4FF321769A24__INCLUDED_)
#define AFX_PRINTERSELECTDLG_H__7AADFEBA_2CBF_4B46_89D0_4FF321769A24__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// PrinterSelectDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CPrinterSelectDlg dialog

class CPrinterSelectDlg : public CFaxClientDlg
{
// Construction
public:
	CPrinterSelectDlg(CWnd* pParent = NULL);   // standard constructor
    CPrinterSelectDlg::~CPrinterSelectDlg();

    DWORD Init();

    TCHAR* GetPrinter() { return m_tszPrinter; };

// Dialog Data
	//{{AFX_DATA(CPrinterSelectDlg)
	enum { IDD = IDD_PRINTER_SELECT };
	CComboBox	m_comboPrinters;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CPrinterSelectDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

    PRINTER_INFO_2* m_pPrinterInfo2;
    DWORD           m_dwNumPrinters;
    TCHAR           m_tszPrinter[MAX_PATH];

	// Generated message map functions
	//{{AFX_MSG(CPrinterSelectDlg)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PRINTERSELECTDLG_H__7AADFEBA_2CBF_4B46_89D0_4FF321769A24__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\queuefolder.cpp ===
// QueueFolder.cpp: implementation of the CQueueFolder class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#define __FILE_ID__     19

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNAMIC(CQueueFolder, CFolder)




DWORD
CQueueFolder::Refresh ()
/*++

Routine name : CQueueFolder::Refresh

Routine description:

    Rebuilds the map of the jobs using the client API.
    This function is always called in the context of a worker thread.

    This function must be called when the data critical section is held.

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:


Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CQueueFolder::Refresh"), dwRes, TEXT("Type=%d"), Type());

    //
    // Enumerate jobs from the server
    //
    ASSERTION (m_pServer);
    HANDLE            hFax;
    PFAX_JOB_ENTRY_EX pEntries;
    DWORD             dwNumJobs;
    DWORD             dw;

    dwRes = m_pServer->GetConnectionHandle (hFax);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (RPC_ERR, TEXT("CFolder::GetConnectionHandle"), dwRes);
        return dwRes;
    }
    if (m_bStopRefresh)
    {
        //
        // Quit immediately
        //
        return dwRes;
    }
    START_RPC_TIME(TEXT("FaxEnumJobsEx")); 
    if (!FaxEnumJobsEx (hFax, 
                        m_dwJobTypes,
                        &pEntries,
                        &dwNumJobs))
    {
        dwRes = GetLastError ();
        END_RPC_TIME(TEXT("FaxEnumJobsEx"));
        m_pServer->SetLastRPCError (dwRes);
        CALL_FAIL (RPC_ERR, TEXT("FaxEnumJobsEx"), dwRes);
        return dwRes;
    }
    END_RPC_TIME(TEXT("FaxEnumJobsEx"));
    if (m_bStopRefresh)
    {
        //
        // Quit immediately
        //
        goto exit;
    }
    //
    // Make sure our map is empty
    //
    ASSERTION (!m_Msgs.size()); 
    //
    // Fill the map and the list control
    //
    for (dw = 0; dw < dwNumJobs; dw++)
    {
        PFAX_JOB_ENTRY_EX pEntry = &pEntries[dw];
        
        if((pEntry->pStatus->dwQueueStatus & JS_COMPLETED) ||
           (pEntry->pStatus->dwQueueStatus & JS_CANCELED))
        {
            //
            // don't display completed or canceled jobs
            //
            continue;
        }

        CJob *pJob = NULL;
        try
        {
            pJob = new CJob;
        }
        catch (...)
        {
            dwRes = ERROR_NOT_ENOUGH_MEMORY;
            CALL_FAIL (MEM_ERR, TEXT("new CJob"), dwRes);
            goto exit;
        }
        //
        // Init the message 
        //
        dwRes = pJob->Init (pEntry, m_pServer);
        if (ERROR_SUCCESS != dwRes)
        {
            CALL_FAIL (MEM_ERR, TEXT("CJob::Init"), dwRes);
            SAFE_DELETE (pJob);
            goto exit;
        }
        //
        // Enter the message into the map
        //
        EnterData();
        try
        {
            m_Msgs[pEntry->dwlMessageId] = pJob;
        }
        catch (...)
        {
            dwRes = ERROR_NOT_ENOUGH_MEMORY;
            CALL_FAIL (MEM_ERR, TEXT("map::operator[]"), dwRes);
            SAFE_DELETE (pJob);
            LeaveData ();
            goto exit;
        }
        LeaveData ();
        if (m_bStopRefresh)
        {
            //
            // Quit immediately
            //
            goto exit;
        }
    }

    if (m_pAssignedView)
    {
        //
        // Folder has a view attached
        //
        m_pAssignedView->SendMessage (
                       WM_FOLDER_ADD_CHUNK,
                       WPARAM (dwRes), 
                       LPARAM (&m_Msgs));
    }

    ASSERTION (ERROR_SUCCESS == dwRes);

exit:
    FaxFreeBuffer ((LPVOID)pEntries);
    return dwRes;
}   // CQueueFolder::Refresh


DWORD 
CQueueFolder::OnJobAdded (
    DWORDLONG dwlMsgId
)
/*++

Routine name : CQueueFolder::OnJobAdded

Routine description:

	Handles notification of a job added to the queue

Author:

	Eran Yariv (EranY),	Feb, 2000

Arguments:

	dwlMsgId   [in]     - New job unique id

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CQueueFolder::OnJobAdded"), 
              dwRes, 
              TEXT("MsgId=0x%016I64x, Type=%d"), 
              dwlMsgId,
              Type());

    HANDLE              hFax;
    PFAX_JOB_ENTRY_EX   pFaxJob = NULL;
    CJob               *pJob = NULL;

    EnterData ();
    pJob = (CJob*)FindMessage (dwlMsgId); 
    if (pJob)
    {
        //
        // This job is already in the queue
        //
        VERBOSE (DBG_MSG, TEXT("Job is already known and visible"));
        goto exit;
    }
    //
    // Get information about this job
    //
    dwRes = m_pServer->GetConnectionHandle (hFax);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (RPC_ERR, TEXT("CFolder::GetConnectionHandle"), dwRes);
        goto exit;
    }
    {
        START_RPC_TIME(TEXT("FaxGetJobEx")); 
        if (!FaxGetJobEx (hFax, dwlMsgId, &pFaxJob))
        {
            dwRes = GetLastError ();
            END_RPC_TIME(TEXT("FaxGetJobEx"));
            m_pServer->SetLastRPCError (dwRes);
            CALL_FAIL (RPC_ERR, TEXT("FaxGetJobEx"), dwRes);
            goto exit;
        }
        END_RPC_TIME(TEXT("FaxGetJobEx"));
    }
    //
    // Enter a new job to the map
    //
    try
    {
        pJob = new CJob;
        ASSERTION (pJob);
        m_Msgs[pFaxJob->dwlMessageId] = pJob;
    }
    catch (...)
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        SAFE_DELETE (pJob);
        goto exit;
    }
    //
    // Init the message 
    //
    dwRes = pJob->Init (pFaxJob, m_pServer);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (MEM_ERR, TEXT("CJob::Init"), dwRes);
        if (pJob)
        {
            try
            {
                m_Msgs.erase (pFaxJob->dwlMessageId);
            }
            catch (...)
            {
                dwRes = ERROR_NOT_ENOUGH_MEMORY;
                CALL_FAIL (MEM_ERR, TEXT("map::erase"), dwRes);
            }
            SAFE_DELETE (pJob);
        }
        goto exit;
    }
    if (m_pAssignedView)
    {
        //
        // If this folder is alive - tell our view to add the job
        //
        m_pAssignedView->OnUpdate (NULL, UPDATE_HINT_ADD_ITEM, pJob);
    }
    
    ASSERTION (ERROR_SUCCESS == dwRes);

exit:
    if(pFaxJob)
    {
        FaxFreeBuffer(pFaxJob);
    }
    LeaveData ();
    return dwRes;
}   // CQueueFolder::OnJobAdded


DWORD 
CQueueFolder::OnJobUpdated (
    DWORDLONG dwlMsgId,
    PFAX_JOB_STATUS pNewStatus
)
/*++

Routine name : CQueueFolder::OnJobUpdated

Routine description:

	Handles notification of a job removed from the queue

Author:

	Eran Yariv (EranY),	Feb, 2000

Arguments:

	dwlMsgId   [in]     - Job unique id
    pNewStatus [in]     - New status of the job

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CQueueFolder::OnJobUpdated"),
              dwRes, 
              TEXT("MsgId=0x%016I64x, Type=%d"), 
              dwlMsgId,
              Type());

    CJob *pJob = NULL;

    EnterData ();
    pJob = (CJob*)FindMessage (dwlMsgId);
    if (!pJob)
    {
        //
        // This job is not in the queue - treat the notification as if the job was added
        //
        VERBOSE (DBG_MSG, TEXT("Job is not known - adding it"));
        LeaveData ();
        dwRes = OnJobAdded (dwlMsgId);
        return dwRes;
    }
    //
    // Update job's status
    //
    dwRes = pJob->UpdateStatus (pNewStatus);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("CJob::UpdateStatus"), dwRes);
        goto exit;
    }
    if (m_pAssignedView)
    {
        //
        // If this folder is alive - tell our view to update the job
        //
        m_pAssignedView->OnUpdate (NULL, UPDATE_HINT_UPDATE_ITEM, pJob);
    }

    ASSERTION (ERROR_SUCCESS == dwRes);

exit:
    LeaveData ();
    return dwRes;
}   // CQueueFolder::OnJobUpdated
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\sentitemsgeneralpg.cpp ===
// SentItemsGeneralPg.cpp : implementation file
//

#include "stdafx.h"

#define __FILE_ID__     45

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// this array maps CViewRow items to 
// dialog control IDs
//
static TMsgPageInfo s_PageInfo[] = 
{
    MSG_VIEW_ITEM_DOC_NAME,         IDC_DOC_NAME_VALUE,
    MSG_VIEW_ITEM_SUBJECT,          IDC_SUBJECT_VALUE,
    MSG_VIEW_ITEM_RECIPIENT_NAME,   IDC_RECIPIENT_NAME_VALUE,
    MSG_VIEW_ITEM_RECIPIENT_NUMBER, IDC_RECIPIENT_NUMBER_VALUE,
    MSG_VIEW_ITEM_NUM_PAGES,        IDC_PAGES_VALUE,
    MSG_VIEW_ITEM_SIZE,             IDC_SIZE_VALUE,
    MSG_VIEW_ITEM_SENDER_NAME,      IDC_SENDER_NAME_VALUE,
    MSG_VIEW_ITEM_SENDER_NUMBER,    IDC_SENDER_NUMBER_VALUE,
    MSG_VIEW_ITEM_TRANSMISSION_START_TIME, IDC_START_TIME_VALUE,
    MSG_VIEW_ITEM_TRANSMISSION_END_TIME,   IDC_END_TIME_VALUE,
    MSG_VIEW_ITEM_TRANSMISSION_DURATION,   IDC_DURATION_VALUE
};

/////////////////////////////////////////////////////////////////////////////
// CSentItemsGeneralPg property page

IMPLEMENT_DYNCREATE(CSentItemsGeneralPg, CMsgPropertyPg)


CSentItemsGeneralPg::CSentItemsGeneralPg(
    CFaxMsg* pMsg     // pointer to CArchiveMsg
) : 
    CMsgPropertyPg(CSentItemsGeneralPg::IDD, pMsg)
{
}

CSentItemsGeneralPg::~CSentItemsGeneralPg()
{
}

void CSentItemsGeneralPg::DoDataExchange(CDataExchange* pDX)
{
	CMsgPropertyPg::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSentItemsGeneralPg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSentItemsGeneralPg, CMsgPropertyPg)
	//{{AFX_MSG_MAP(CSentItemsGeneralPg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSentItemsGeneralPg message handlers

BOOL 
CSentItemsGeneralPg::OnInitDialog() 
{
    DBG_ENTER(TEXT("CSentItemsGeneralPg::OnInitDialog"));

    CMsgPropertyPg::OnInitDialog();

    Refresh(s_PageInfo, sizeof(s_PageInfo)/sizeof(s_PageInfo[0]));
	
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\sentitemsgeneralpg.h ===
#if !defined(AFX_SENTITEMSGENERALPG_H__E5645AEB_4289_4D6D_B000_60C3A52638F0__INCLUDED_)
#define AFX_SENTITEMSGENERALPG_H__E5645AEB_4289_4D6D_B000_60C3A52638F0__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// SentItemsGeneralPg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CSentItemsGeneralPg dialog

class CSentItemsGeneralPg : public CMsgPropertyPg
{
	DECLARE_DYNCREATE(CSentItemsGeneralPg)

// Construction
public:
	CSentItemsGeneralPg(CFaxMsg* pMsg);
	~CSentItemsGeneralPg();

// Dialog Data
	//{{AFX_DATA(CSentItemsGeneralPg)
	enum { IDD = IDD_SENT_ITEMS_GENERAL };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CSentItemsGeneralPg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
private:
    CSentItemsGeneralPg() {}

protected:
	// Generated message map functions
	//{{AFX_MSG(CSentItemsGeneralPg)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SENTITEMSGENERALPG_H__E5645AEB_4289_4D6D_B000_60C3A52638F0__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\sentitemsdetailspg.h ===
#if !defined(AFX_SENTITEMSDETAILSPG_H__E5645AEB_4289_4D6D_B000_60C3A52638F0__INCLUDED_)
#define AFX_SENTITEMSDETAILSPG_H__E5645AEB_4289_4D6D_B000_60C3A52638F0__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// SentItemsDetailsPg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CSentItemsDetailsPg dialog

class CSentItemsDetailsPg : public CMsgPropertyPg
{
	DECLARE_DYNCREATE(CSentItemsDetailsPg)

// Construction
public:
	CSentItemsDetailsPg(CFaxMsg* pMsg);
	~CSentItemsDetailsPg();

// Dialog Data
	//{{AFX_DATA(CSentItemsDetailsPg)
	enum { IDD = IDD_SENT_ITEMS_DETAILS };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CSentItemsDetailsPg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
private:
    CSentItemsDetailsPg() {}

protected:
	// Generated message map functions
	//{{AFX_MSG(CSentItemsDetailsPg)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SENTITEMSDETAILSPG_H__E5645AEB_4289_4D6D_B000_60C3A52638F0__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\servernode.cpp ===
// ServerNode.cpp: implementation of the CServerNode class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#define __FILE_ID__     23

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNAMIC(CServerNode, CTreeNode)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CServerNode::CServerNode() :
    CTreeNode(FOLDER_TYPE_SERVER),
    m_bValid(TRUE),
    m_dwRights (0),
    m_dwQueueState (0),
    m_bSelfDestruct (FALSE),
    m_hConnection (NULL),
    m_hNotification (NULL),
    m_bCsBuildupValid (FALSE),
    m_bCsBuildupThreadValid(FALSE),
    m_hBuildupThread (NULL),
    m_bInBuildup (FALSE),
    m_dwLastRPCError (0),
    m_Inbox (FOLDER_TYPE_INBOX, FAX_MESSAGE_FOLDER_INBOX),
    m_SentItems (FOLDER_TYPE_SENT_ITEMS, FAX_MESSAGE_FOLDER_SENTITEMS),
    m_Outbox (FOLDER_TYPE_OUTBOX, JT_SEND),
    m_Incoming (FOLDER_TYPE_INCOMING, JT_RECEIVE | JT_ROUTING)
{}

CServerNode::~CServerNode()
{
    DBG_ENTER(TEXT("CServerNode::~CServerNode"), TEXT("%s"), m_cstrMachine);
    DWORD dwRes = StopBuildThread ();
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("CServerNode::StopBuildThread"), dwRes);
    }
    dwRes = Disconnect (TRUE);    // Shutdown aware
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("CServerNode::Disconnect"), dwRes);
    }
    if (m_bCsBuildupValid)
    {
        DeleteCriticalSection (&m_csBuildup);
    }
    if(m_bCsBuildupThreadValid)
    {
        DeleteCriticalSection (&m_csBuildupThread);
    }
}

void CServerNode::AssertValid() const
{
    CObject::AssertValid();
}

void CServerNode::Dump( CDumpContext &dc ) const
{
    CObject::Dump( dc );
    dc << TEXT(" Server = ") << m_cstrMachine;
}

//
// Static class members:
//
CServerNode::MESSAGES_MAP CServerNode::m_sMsgs;
DWORD        CServerNode::m_sdwMinFreeMsg = WM_SERVER_NOTIFY_BASE;
CRITICAL_SECTION CServerNode::m_sMsgsCs;
BOOL CServerNode::m_sbMsgsCsInitialized = FALSE;

DWORD 
CServerNode::InitMsgsMap ()
/*++

Routine name : CServerNode::InitMsgsMap

Routine description:

    Initializes the notification messages map

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:


Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CServerNode::InitMsgsMap"), dwRes);

    ASSERTION (!m_sbMsgsCsInitialized);
    try
    {
        InitializeCriticalSection (&m_sMsgsCs);
    }
    catch (...)
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        CALL_FAIL (MEM_ERR, TEXT ("InitializeCriticalSection"), dwRes);
        return dwRes;
    }
    m_sbMsgsCsInitialized = TRUE;
    return dwRes;
}   // CServerNode::InitMsgsMap

DWORD 
CServerNode::ShutdownMsgsMap ()
/*++

Routine name : CServerNode::ShutdownMsgsMap

Routine description:

    Shuts down the notification messages map

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:


Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CServerNode::ShutdownMsgsMap"), dwRes);

    if (!m_sbMsgsCsInitialized)
    {
        return dwRes;
    }
    EnterCriticalSection (&m_sMsgsCs);
    m_sMsgs.clear ();
    LeaveCriticalSection (&m_sMsgsCs);
    m_sbMsgsCsInitialized = FALSE;
    DeleteCriticalSection (&m_sMsgsCs);
    return dwRes;
}   // CServerNode::ShutdownMsgsMap

CServerNode *
CServerNode::LookupServerFromMessageId (
    DWORD dwMsgId
)
/*++

Routine name : CServerNode::LookupServerFromMessageId

Routine description:

    Given a mesage id, looks up the server this message was sent to

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    dwMsgId                       [in]     - Message id

Return Value:

    Server node that should process the message or NULL if message id is not mapped

--*/
{
    DBG_ENTER(TEXT("CServerNode::LookupServerFromMessageId"), TEXT("%ld"), dwMsgId);
    CServerNode *pRes = NULL;
    if (!m_sbMsgsCsInitialized)
    {
        return pRes;
    }
    EnterCriticalSection (&m_sMsgsCs);
    MESSAGES_MAP::iterator it = m_sMsgs.find (dwMsgId);
    if (m_sMsgs.end() == it)
    {
        //
        // Item not found there
        //
        VERBOSE (DBG_MSG, 
                 TEXT("Notification message %ld has no associated server"),
                 dwMsgId);
    }
    else
    {
        pRes = (*it).second;
    }
    LeaveCriticalSection (&m_sMsgsCs);
    return pRes;
}   // CServerNode::LookupServerFromMessageId


DWORD 
CServerNode::AllocateNewMessageId (
    CServerNode *pServer, 
    DWORD &dwMsgId
)
/*++

Routine name : CServerNode::AllocateNewMessageId

Routine description:

    Allocates a new message id for server's notification

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    pServer                       [in]     - Pointer to server
    dwMsgId                       [out]    - New message id

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CServerNode::AllocateNewMessageId"), dwRes, TEXT("%s"), pServer->Machine());

    if (!m_sbMsgsCsInitialized)
    {
        //
        // Map no longer exists
        //
        dwRes = ERROR_SHUTDOWN_IN_PROGRESS;
        return dwRes;
    }

    EnterCriticalSection (&m_sMsgsCs);
    for (DWORD dw = m_sdwMinFreeMsg; ; dw++)
    {
        CServerNode *pSrv = LookupServerFromMessageId (dw);
        if (!pSrv)
        {
            //
            // Free spot found
            //
            dwMsgId = dw;
            try
            {
                m_sMsgs[dwMsgId] = pServer;
            }
            catch (...)
            {
                //
                // Not enough memory
                //
                dwRes = ERROR_NOT_ENOUGH_MEMORY;
                CALL_FAIL (MEM_ERR, TEXT("map::operator []"), dwRes);
                goto exit;
            }
            //
            // Success
            //
            VERBOSE (DBG_MSG, 
                     TEXT("Server %s registered for notification on message 0x%08x"),
                     pServer->Machine(),
                     dwMsgId);
            goto exit;
        }
    }

exit:
    LeaveCriticalSection (&m_sMsgsCs);
    return dwRes;                
}   // CServerNode::AllocateNewMessageId

DWORD 
CServerNode::FreeMessageId (
    DWORD dwMsgId
)
/*++

Routine name : CServerNode::FreeMessageId

Routine description:

    Frees a message id back to the map

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    dwMsgId           [in]     - Message id to free

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CServerNode::FreeMessageId"), dwRes);

    if (!m_sbMsgsCsInitialized)
    {
        //
        // Map no longer exists
        //
        dwRes = ERROR_SHUTDOWN_IN_PROGRESS;
        return dwRes;
    }
    EnterCriticalSection (&m_sMsgsCs);
    try
    {
        m_sMsgs.erase (dwMsgId);
    }
    catch (...)
    {
        //
        // Not enough memory
        //
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        CALL_FAIL (MEM_ERR, TEXT("map::erase"), dwRes);
        goto exit;
    }
    //
    // Success
    //
    VERBOSE (DBG_MSG, 
             TEXT("Server unregistered for notification on message 0x%08x"),
             dwMsgId);

    if (dwMsgId < m_sdwMinFreeMsg)
    {
        //
        // Free spot was created lower than before.
        //
        m_sdwMinFreeMsg = dwMsgId;
    }
exit:
    LeaveCriticalSection (&m_sMsgsCs);
    return dwRes;
}   // CServerNode::FreeMessageId


DWORD 
CServerNode::Connect()
/*++

Routine name : CServerNode::Connect

Routine description:

    Connects to the fax server

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:


Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CServerNode::Connect"), dwRes, TEXT("%s"), m_cstrMachine);

    ASSERTION (!m_hConnection);
    START_RPC_TIME(TEXT("FaxConnectFaxServer"));    
    if (!FaxConnectFaxServer ((LPCTSTR)m_cstrMachine, &m_hConnection))
    {
        dwRes = GetLastError ();
        SetLastRPCError (dwRes, FALSE); // Don't disconnect on error
        CALL_FAIL (RPC_ERR, TEXT("FaxConnectFaxServer"), dwRes);
        m_hConnection = NULL;
    }
    END_RPC_TIME(TEXT("FaxConnectFaxServer"));    
    return dwRes;
}   // CServerNode::Connect

DWORD 
CServerNode::Disconnect(
    BOOL bShutdownAware,
    BOOL bWaitForBuildThread
)
/*++

Routine name : CServerNode::Disconnect

Routine description:

    Disconnects from the server and closes the notification handle.

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    bShutdownAware    [in]     - If TRUE, disables disconnection 
                                 while application is shutting down
    bWaitForBuildThread [in]   - If TRUE, wait for build threads stop
Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CServerNode::Disconnect"), dwRes, TEXT("%s"), m_cstrMachine);

    if(bWaitForBuildThread)
    {
        //
        // just turn on m_bStopBuildup flag
        //
        StopBuildThread (FALSE);
        m_Inbox.StopBuildThread(FALSE);
        m_SentItems.StopBuildThread(FALSE);
        m_Outbox.StopBuildThread(FALSE);
        m_Incoming.StopBuildThread(FALSE);

        //
        // wait for the all threads finish
        //
        dwRes = StopBuildThread();
        if (ERROR_SUCCESS != dwRes)
        {
            CALL_FAIL (GENERAL_ERR, TEXT("CServerNode::StopBuildThread"), dwRes);
        }

        dwRes = m_Inbox.StopBuildThread();
        if (ERROR_SUCCESS != dwRes)
        {
            CALL_FAIL (GENERAL_ERR, TEXT("m_Inbox.StopBuildThread"), dwRes);
        }

        dwRes = m_SentItems.StopBuildThread();
        if (ERROR_SUCCESS != dwRes)
        {
            CALL_FAIL (GENERAL_ERR, TEXT("m_SentItems.StopBuildThread"), dwRes);
        }

        dwRes = m_Outbox.StopBuildThread();
        if (ERROR_SUCCESS != dwRes)
        {
            CALL_FAIL (GENERAL_ERR, TEXT("m_Outbox.StopBuildThread"), dwRes);
        }

        dwRes = m_Incoming.StopBuildThread();
        if (ERROR_SUCCESS != dwRes)
        {
            CALL_FAIL (GENERAL_ERR, TEXT("m_Incoming.StopBuildThread"), dwRes);
        }
    }

    if (!m_hConnection)
    {
        //
        // Already disconnected
        //
        return dwRes;
    }
    if (bShutdownAware && CClientConsoleDoc::ShuttingDown())
    {
        VERBOSE (DBG_MSG,
                 TEXT("Left open connection (and notification) to %s because we're shutting down."),
                 m_cstrMachine);
        return dwRes;
    }

    if (m_hNotification)
    {
        //
        // Unregister server notifications
        //
        START_RPC_TIME(TEXT("FaxUnregisterForServerEvents"));    
        if (!FaxUnregisterForServerEvents (m_hNotification))
        {
            dwRes = GetLastError ();
            END_RPC_TIME(TEXT("FaxUnregisterForServerEvents")); 
            SetLastRPCError (dwRes, FALSE); // Don't disconnect on error
            CALL_FAIL (RPC_ERR, TEXT("FaxUnregisterForServerEvents"), dwRes);
            //
            // Carry on with disconnection
            //
        }
        END_RPC_TIME(TEXT("FaxUnregisterForServerEvents")); 
        //
        // Free the message id back to the map
        //
        dwRes = FreeMessageId (m_dwMsgId);
        if (ERROR_SUCCESS != dwRes)
        {
            CALL_FAIL (GENERAL_ERR, TEXT("FreeMessageId"), dwRes);
            //
            // Carry on with disconnection
            //
        }
    }
    //
    // Close connection
    //
    START_RPC_TIME(TEXT("FaxClose"));    
    if (!FaxClose (m_hConnection))
    {
        dwRes = GetLastError ();
        END_RPC_TIME(TEXT("FaxClose")); 
        SetLastRPCError (dwRes, FALSE); // Don't disconnect on error
        CALL_FAIL (RPC_ERR, TEXT("FaxClose"), dwRes);
        m_hConnection = NULL;
        return dwRes;
    }
    END_RPC_TIME(TEXT("FaxClose")); 
    m_hConnection = NULL;
    m_hNotification = NULL;

    return dwRes;
}   // CServerNode::Disconnect

DWORD 
CServerNode::GetConnectionHandle (
    HANDLE &hFax
)
/*++

Routine name : CServerNode::GetConnectionHandle

Routine description:

    Retrieves connection handle (re-connects if neeed)

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    hFax                          [out]    - Connection handle

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CServerNode::GetConnectionHandle"), dwRes);

    //
    // Protect the m_hBuildupThread from CloseHandle() more then once
    //
    EnterCriticalSection (&m_csBuildupThread);

    if (m_hConnection)
    {
        //
        // We already have a live connection
        //
        hFax = m_hConnection;
        goto exit;
    }

    //
    // Refresh server state with first connection.
    // RefreshState() creates a background thread that will call Connect()
    //
    dwRes = RefreshState();
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT ("RefreshState"), dwRes);
        goto exit;
    }
    if(NULL != m_hBuildupThread)
    {
        //
        // Wait for that background thread to end
        //
        dwRes = WaitForThreadDeathOrShutdown (m_hBuildupThread);
        if (ERROR_SUCCESS != dwRes)
        {
            CALL_FAIL (GENERAL_ERR, TEXT("WaitForThreadDeathOrShutdown"), dwRes);
        }
        CloseHandle (m_hBuildupThread);
        m_hBuildupThread = NULL;
    }
    hFax = m_hConnection;

    if(!hFax)
    {
        dwRes = ERROR_INVALID_HANDLE;
    }

exit:
    LeaveCriticalSection (&m_csBuildupThread);

    return dwRes;
}   // CServerNode::GetConnectionHandle 

DWORD 
CServerNode::Init (
    LPCTSTR tstrMachine
)
/*++

Routine name : CServerNode::Init

Routine description:

    Inits server node information

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    tstrMachine                   [in]     - Server machine name

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CServerNode::Init"), dwRes);

    ASSERTION (!m_bCsBuildupValid);
    ASSERTION (!m_hConnection);
    //
    // Create buildup thread critical section
    //
    try
    {
        InitializeCriticalSection (&m_csBuildup);
    }
    catch (...)
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        CALL_FAIL (MEM_ERR, TEXT ("InitializeCriticalSection(&m_csBuildup)"), dwRes);
        return dwRes;
    }
    m_bCsBuildupValid = TRUE;

    try
    {
        InitializeCriticalSection (&m_csBuildupThread);
    }
    catch (...)
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        CALL_FAIL (MEM_ERR, TEXT ("InitializeCriticalSection(&m_csBuildupThread)"), dwRes);
        return dwRes;
    }
    m_bCsBuildupThreadValid = TRUE;

    //
    // Save our connection + server names
    //
    try
    {
        m_cstrMachine = tstrMachine;
        //
        // Remove leading backslashes from machine's name
        //
        m_cstrMachine.Remove (TEXT('\\'));
    }
    catch (CException &ex)
    {
        TCHAR wszCause[1024];

        ex.GetErrorMessage (wszCause, 1024);
        VERBOSE (EXCEPTION_ERR,
                 TEXT("CString::operator = caused exception : %s"), 
                 wszCause);
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        return dwRes;
    }
    dwRes = CreateFolders ();
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("CreateFolders"), dwRes);
    }
    return dwRes;
}   // CServerNode::Init

DWORD
CServerNode::SetNewQueueState (
    DWORD dwNewState
)
/*++

Routine name : CServerNode::SetNewQueueState

Routine description:

    Sets the news state of the queue

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    dwNewState                    [in]     - New queue state

Return Value:

    Standard Win32 error code

--*/
{
    HANDLE hFax;
    DWORD dwRes;
    DBG_ENTER(TEXT("CServerNode::SetNewQueueState"), dwRes);

    dwRes = GetConnectionHandle(hFax);
    if (ERROR_SUCCESS != dwRes)
    {
        return dwRes;
    }
    START_RPC_TIME(TEXT("FaxSetQueue"));    
    if (!FaxSetQueue (hFax, dwNewState))
    {
        dwRes = GetLastError ();
        END_RPC_TIME(TEXT("FaxSetQueue")); 
        SetLastRPCError (dwRes);
        CALL_FAIL (RPC_ERR, TEXT("FaxSetQueue"), dwRes);
        return dwRes;
    }
    END_RPC_TIME(TEXT("FaxSetQueue")); 
    return dwRes;
}   // CServerNode::SetNewQueueState

DWORD 
CServerNode::BlockIncoming (
    BOOL bBlock
)
/*++

Routine name : CServerNode::BlockIncoming

Routine description:

    Blocks / unblocks the incoming queue

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    bBlock                        [in]     - TRUE if block

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes;
    DBG_ENTER(TEXT("CServerNode::BlockIncoming"), dwRes);

    DWORD dwNewState = bBlock ? (m_dwQueueState | FAX_INCOMING_BLOCKED) : 
                                (m_dwQueueState & ~FAX_INCOMING_BLOCKED);
    dwRes = SetNewQueueState (dwNewState);
    if (ERROR_SUCCESS == dwRes)
    {
        m_dwQueueState = dwNewState;
    }
    return dwRes;
}   // CServerNode::BlockIncoming

DWORD 
CServerNode::BlockOutbox (
    BOOL bBlock
)
/*++

Routine name : CServerNode::BlockOutbox

Routine description:

    Blocks / unblocks the outgoing queue

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    bBlock                        [in]     - TRUE if block

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes;
    DBG_ENTER(TEXT("CServerNode::BlockOutbox"), dwRes);

    DWORD dwNewState = bBlock ? (m_dwQueueState | FAX_OUTBOX_BLOCKED) : 
                                (m_dwQueueState & ~FAX_OUTBOX_BLOCKED);
    dwRes = SetNewQueueState (dwNewState);
    if (ERROR_SUCCESS == dwRes)
    {
        m_dwQueueState = dwNewState;
    }
    return dwRes;
}   // CServerNode::BlockOutbox

DWORD 
CServerNode::PauseOutbox (
    BOOL bPause
)
/*++

Routine name : CServerNode::PauseOutbox

Routine description:

    Pauses / resumes the outgoing queue

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    bPause                        [in]     - TRUE if pause

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes;
    DBG_ENTER(TEXT("CServerNode::PauseOutbox"), dwRes);

    DWORD dwNewState = bPause ? (m_dwQueueState | FAX_OUTBOX_PAUSED) : 
                                (m_dwQueueState & ~FAX_OUTBOX_PAUSED);
    dwRes = SetNewQueueState (dwNewState);
    if (ERROR_SUCCESS == dwRes)
    {
        m_dwQueueState = dwNewState;
    }
    return dwRes;
}   // CServerNode::PauseOutbox

    
DWORD 
CServerNode::CreateFolders ()
/*++

Routine name : CServerNode::CreateFolders

Routine description:

    Creates the 4 folders of the server

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:


Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CServerNode::CreateFolders"), dwRes);

    //
    // Create inbox folder
    //
    m_Inbox.SetServer(this);

    dwRes = m_Inbox.Init ();
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (WINDOW_ERR, TEXT("CMessageFolder::Init"), dwRes);
        goto error;
    }
    //
    // Create outbox folder
    //
    m_Outbox.SetServer(this);

    dwRes = m_Outbox.Init ();
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (WINDOW_ERR, TEXT("CQueueFolder::Init"), dwRes);
        goto error;
    }
    //
    // Create sentitems folder
    //
    m_SentItems.SetServer(this);

    dwRes = m_SentItems.Init ();
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (WINDOW_ERR, TEXT("CMessageFolder::Init"), dwRes);
        goto error;
    }
    //
    // Create incoming folder
    //
    m_Incoming.SetServer(this);

    dwRes = m_Incoming.Init ();
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (WINDOW_ERR, TEXT("CQueueFolder::Init"), dwRes);
        goto error;
    }

    ASSERTION (ERROR_SUCCESS == dwRes);

error:
    return dwRes;            
}   // CServerNode::CreateFolders


DWORD 
CServerNode::InvalidateSubFolders (
    BOOL bClearView
)
/*++

Routine name : CServerNode::InvalidateSubFolders

Routine description:

    Invalidates the contents of all 4 sub folders

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    bClearView     [in] Should we clear attached view ?

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CServerNode::InvalidateSubFolders"), dwRes);

    dwRes = m_Inbox.InvalidateContents (bClearView);   
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("m_Inbox.InvalidateContents"), dwRes);
        return dwRes;
    }
    dwRes = m_Outbox.InvalidateContents (bClearView);   
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("m_Outbox.InvalidateContents"), dwRes);
        return dwRes;
    }
    dwRes = m_SentItems.InvalidateContents (bClearView);   
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("m_SentItems.InvalidateContents"), dwRes);
        return dwRes;
    }
    dwRes = m_Incoming.InvalidateContents (bClearView);   
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("m_Incoming.InvalidateContents"), dwRes);
        return dwRes;
    }
    return dwRes;
}   // CServerNode::InvalidateSubFolders

    

//
// Buildup thread functions:
//

DWORD
CServerNode::ClearContents ()
/*++

Routine name : CServerNode::ClearContents

Routine description:

    Clears the server's contents

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:


Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes;
    DBG_ENTER(TEXT("CServerNode::ClearContents"), dwRes);

    dwRes = Disconnect ();
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (RPC_ERR, TEXT("Disconnect"), dwRes);
        return dwRes;
    }
    dwRes = InvalidateSubFolders(FALSE);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (RPC_ERR, TEXT("InvalidateSubFolders"), dwRes);
        return dwRes;
    }
    return dwRes;
}   // CServerNode::ClearContents

DWORD 
CServerNode::RefreshState()
/*++

Routine name : CServerNode::RefreshState

Routine description:

    Refreshes the server's state

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:


Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes;
    DBG_ENTER(TEXT("CServerNode::RefreshState"), dwRes, TEXT("%s"), m_cstrMachine);

    DWORD dwThreadId;
    //
    // Stop the current (if any) buildup thread and make sure it's dead
    //
    dwRes = StopBuildThread ();
    EnterCriticalSection (&m_csBuildup);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (RESOURCE_ERR, TEXT("CServerNode::StopBuildThread"), dwRes);
        goto exit;
    }
    //
    // Tell our view to refresh our image
    //
    m_bInBuildup = TRUE;
    //
    // Start the thread that will fill the data (in the background)
    //
    m_bStopBuildup = FALSE;
    m_hBuildupThread = CreateThread (  
                        NULL,               // No security
                        0,                  // Default stack size
                        BuildupThreadProc,  // Thread procedure
                        (LPVOID)this,       // Parameter
                        0,                  // Normal creation
                        &dwThreadId         // We must have a thread id for win9x
                     );
    if (NULL == m_hBuildupThread)
    {
        dwRes = GetLastError ();
        CALL_FAIL (RESOURCE_ERR, TEXT("CreateThread"), dwRes);
        goto exit;
    }
    ASSERTION (ERROR_SUCCESS == dwRes);

exit:
    LeaveCriticalSection (&m_csBuildup);
    if (ERROR_SUCCESS != dwRes)
    {
        //
        // Build up failed
        //
        m_bInBuildup = FALSE;
    }
    return dwRes;
}   // CServerNode::RefreshState

DWORD
CServerNode::Buildup ()
/*++

Routine name : CServerNode::Buildup

Routine description:

    Server refresh worker thread function.
    Works in a background thread and performs the following:
       1. FaxConnectFaxServer (if not already connected)
       2. FaxGetQueueStates
       3. FaxAccessCheckEx (MAXIMUM_ALLOWED)
       4. FaxRegisterForServerEvents

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:


Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CServerNode::Buildup"), dwRes, TEXT("%s"), m_cstrMachine);

    HANDLE hFax;
    HWND hwnd;
    CMainFrame *pMainFrm = NULL;
    DWORD dwEventTypes = FAX_EVENT_TYPE_OUT_QUEUE |     // Outbox events
                         FAX_EVENT_TYPE_QUEUE_STATE |   // Paused / blocked queue events
                         FAX_EVENT_TYPE_OUT_ARCHIVE |   // SentItems events
                         FAX_EVENT_TYPE_FXSSVC_ENDED;   // Server shutdown events

    //
    // Ask the server for a notification handle
    //  
    pMainFrm = GetFrm();
    if (NULL == pMainFrm)
    {
        //
        // No main frame - probably we're shutting down
        //
        goto exit;
    }

    //
    // get connection
    //
    if (m_hConnection)
    {
        hFax = m_hConnection;
    }
    else
    {
        dwRes = Connect ();
        if (ERROR_SUCCESS != dwRes)
        {
            goto exit;
        }
        ASSERTION (m_hConnection);
        hFax = m_hConnection;
    }
    
    if (m_bStopBuildup)
    {
        //
        // Thread should stop abruptly
        //
        dwRes = ERROR_CANCELLED;
        goto exit;
    }
    {
        START_RPC_TIME(TEXT("FaxGetQueueStates"));    
        if (!FaxGetQueueStates (hFax, &m_dwQueueState))
        {
            dwRes = GetLastError ();
            END_RPC_TIME(TEXT("FaxGetQueueStates"));    
            SetLastRPCError (dwRes);
            CALL_FAIL (RPC_ERR, TEXT("FaxGetQueueStates"), dwRes);
            goto exit;
        }
        END_RPC_TIME(TEXT("FaxGetQueueStates"));    
    }
    if (m_bStopBuildup)
    {
        //
        // Thread should stop abruptly
        //
        dwRes = ERROR_CANCELLED;
        goto exit;
    }

    {
        //
        // retrieve the access rights of the caller
        //
        START_RPC_TIME(TEXT("FaxAccessCheckEx"));    
        if (!FaxAccessCheckEx (hFax, MAXIMUM_ALLOWED, &m_dwRights))
        {
            dwRes = GetLastError ();
            END_RPC_TIME(TEXT("FaxAccessCheckEx"));    
            SetLastRPCError (dwRes);
            CALL_FAIL (RPC_ERR, TEXT("FaxAccessCheckEx"), dwRes);
            goto exit;
        }
        END_RPC_TIME(TEXT("FaxAccessCheckEx"));    
    }
    if (m_bStopBuildup)
    {
        //
        // Thread should stop abruptly
        //
        dwRes = ERROR_CANCELLED;
        goto exit;
    }

    //
    // Register for notifications - start by allocating a message id
    //
    if(m_hNotification)
    {
        //
        // already registered
        //
        goto exit;
    }

    dwRes = AllocateNewMessageId (this, m_dwMsgId);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("AllocateNewMessageId"), dwRes);
        goto exit;
    }

    hwnd = pMainFrm->m_hWnd;
    if (CanSeeAllJobs())
    {
        dwEventTypes |= FAX_EVENT_TYPE_IN_QUEUE;    // Incoming folder events
    }
    if (CanSeeInbox())
    {
        dwEventTypes |= FAX_EVENT_TYPE_IN_ARCHIVE;  // Inbox folder events
    }
       
    {
        START_RPC_TIME(TEXT("FaxRegisterForServerEvents"));    
        if (!FaxRegisterForServerEvents (   
                    hFax,
                    dwEventTypes,   // Types of events to receive
                    NULL,           // Not using completion ports
                    0,              // Not using completion ports
                    hwnd,           // Handle of window to receive notification messages
                    m_dwMsgId,      // Message id
                    &m_hNotification// Notification handle
           ))
        {
            dwRes = GetLastError ();
            SetLastRPCError (dwRes, FALSE);    // Do not auto-disconnect
            CALL_FAIL (RPC_ERR, TEXT("FaxRegisterForServerEvents"), dwRes);
            m_hNotification = NULL;
            goto exit;
        }
        END_RPC_TIME(TEXT("FaxRegisterForServerEvents"));    
    }
    ASSERTION (ERROR_SUCCESS == dwRes);

exit:

    m_bInBuildup = FALSE;

    if (!m_bStopBuildup)
    {
        if (ERROR_SUCCESS != dwRes)
        {
            //
            // Some error occured during refresh
            //
            Disconnect (FALSE, FALSE);
        }
    }

    if (pMainFrm)
    {
        pMainFrm->RefreshStatusBar ();
    }

    return dwRes;
}   // CServerNode::Buildup


DWORD 
WINAPI 
CServerNode::BuildupThreadProc (
    LPVOID lpParameter
)
/*++

Routine name : CServerNode::BuildupThreadProc

Routine description:

    Server refresh thread entry point.
    This is a static function which accepts a pointer to the actual CServerNode instance
    and calls the Buildup function on the real instance.

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    lpParameter   [in]     - Pointer to server node that created the thread

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CServerNode::BuildupThreadProc"), dwRes);

    CServerNode *pServer = (CServerNode *)lpParameter;
    ASSERTION (pServer);
    ASSERT_KINDOF (CServerNode, pServer);

    dwRes = pServer->Buildup ();
    if (pServer->m_bSelfDestruct)
    {
        //
        // Object was waiting for thread to stop before it could destruct itself
        //
        delete pServer;
    }
    return dwRes;
}   // CServerNode::BuildupThreadProc


DWORD            
CServerNode::StopBuildThread (
    BOOL bWaitForDeath
)
/*++

Routine name : CServerNode::StopBuildThread

Routine description:

    Stops the server's buildup thread

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    bWaitForDeath      [in]     - If TRUE, waits until the thread is dead

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CServerNode::StopBuildThread"), dwRes);

    m_bStopBuildup = TRUE;
    if (!bWaitForDeath)
    {
        return dwRes;
    }

    //
    // Protect the m_hBuildupThread from CloseHandle() more then once
    //
    EnterCriticalSection (&m_csBuildupThread);

    if(NULL == m_hBuildupThread)
    {
        goto exit;
    }
    //
    // Wait for build thread to die
    //
    dwRes = WaitForThreadDeathOrShutdown (m_hBuildupThread);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("WaitForThreadDeathOrShutdown"), dwRes);
    }
    CloseHandle (m_hBuildupThread);
    m_hBuildupThread = NULL;

exit:
    LeaveCriticalSection (&m_csBuildupThread);

    return dwRes;
}   // CServerNode::StopBuildThread

BOOL  
CServerNode::FatalRPCError (
    DWORD dwErr
)
/*++

Routine name : CServerNode::FatalRPCError

Routine description:

    Checks if an error code means a fatal RPC connection state

Author:

    Eran Yariv (EranY), Feb, 2000

Arguments:

    dwErr         [in]     - Error code to check

Return Value:

    TRUE if error code means a fatal RPC connection state, FALSE otherwise.

--*/
{
    BOOL bRes = FALSE;
    DBG_ENTER(TEXT("CServerNode::FatalRPCError"), bRes);

    switch (bRes)
    {
        case RPC_S_INVALID_BINDING:
        case EPT_S_CANT_PERFORM_OP:
        case RPC_S_ADDRESS_ERROR:
        case RPC_S_COMM_FAILURE:
        case RPC_S_NO_BINDINGS:
        case RPC_S_SERVER_UNAVAILABLE:
            //
            // Something really bad happened to our RPC connection
            //
            bRes = TRUE;
            break;
    }
    return bRes;
}   // CServerNode::FatalRPCError


void 
CServerNode::SetLastRPCError (
    DWORD dwErr, 
    BOOL DisconnectOnFailure
)
/*++

Routine name : CServerNode::SetLastRPCError

Routine description:

    Sets the last RPC error encountered on this server

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    dwErr               [in]     - Error code
    DisconnectOnFailure [in]     - If TRUE, disconnects from the server upon error

Return Value:

    None.

--*/
{
    DBG_ENTER(TEXT("CServerNode::SetLastRPCError"), TEXT("%ld"), dwErr);

    m_dwLastRPCError = dwErr;
    if (DisconnectOnFailure && FatalRPCError(dwErr))
    {
        //
        // We have a real failure here - disconnect now.
        //
        DWORD dwRes = Disconnect ();
        if (ERROR_SUCCESS != dwRes)
        {
            CALL_FAIL (RPC_ERR, TEXT("CServerNode::Disconnect"), dwRes);
        }
    }
}   // CServerNode::SetLastRPCError

void
CServerNode::Destroy ()
/*++

Routine name : CServerNode::Destroy

Routine description:

    Destroys the server's node.
    Since the dtor is private, this is the only way to destroy the server node.
    
    If the server is not busy refreshing itself, it deletes itself.
    Otherwise, it signals a suicide request and the thread destorys the node.

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:


Return Value:

    None.

--*/
{
    if (m_bSelfDestruct)
    {
        //
        // Already being destroyed
        //
        return;
    }
    EnterCriticalSection (&m_csBuildup);
    m_bSelfDestruct = TRUE;
    if (m_hBuildupThread)
    {
        //
        // Thread is running, just mark request for self-destruction
        //
        LeaveCriticalSection (&m_csBuildup);
    }
    else
    {
        //
        // Suicide
        //
        LeaveCriticalSection (&m_csBuildup);
        delete this;
    }
}   // CServerNode::Destroy 

DWORD
CServerNode::GetActivity(
    CString& cstrText, 
    TreeIconType& iconIndex
) const
/*++

Routine name : CServerNode::GetActivityStringResource

Routine description:

    Returns the resource id of a string identifying the activity of the server

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    cstrText       [out] - activity string
    iconIndex      [out] - icon index

Return Value:

    Activity string resource id

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CServerNode::GetActivity"), dwRes);

    DWORD dwStrRes = 0;
    if (IsRefreshing())
    {
        iconIndex = TREE_IMAGE_SERVER_REFRESHING;
        dwStrRes = IDS_SERVER_REFRESHING;
    }
    else if (IsOnline ())
    {
        if (IsOutboxBlocked())
        {
            //
            // Server's Outgoing queue is blocked
            //
            iconIndex = TREE_IMAGE_OUTBOX_BLOCKED;
            dwStrRes = IDS_SERVER_OUTBOX_BLOCKED;
        }
        else if (IsOutboxPaused())
        {
            //
            // Server's Outgoing queue is paused
            //
            iconIndex = TREE_IMAGE_OUTBOX_PAUSED;
            dwStrRes = IDS_SERVER_OUTBOX_PAUSED;
        }
        else
        {
            //
            // Server's Outgoing queue is fully functional
            //
            iconIndex = TREE_IMAGE_SERVER_ONLINE;
            dwStrRes = IDS_SERVER_ONLINE;
        }
    }
    else
    {
        iconIndex = TREE_IMAGE_SERVER_OFFLINE;

        //
        // Server is offline
        //
        if (RPC_S_SERVER_UNAVAILABLE == m_dwLastRPCError)
        {
            //
            // The RPC server is unavailable.
            //
            dwStrRes = IDS_SERVER_OFFLINE;
        }
        else
        {
            //
            // General network / RPC error
            //
            dwStrRes = IDS_SERVER_NET_ERROR;
        }
    }

    dwRes = LoadResourceString(cstrText, dwStrRes);
    if(ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("LoadResourceString"), dwRes);
        return dwRes;
    }                    

    return dwRes;

}   // CServerNode::GetActivityStringResource



DWORD  
CServerNode::OnNotificationMessage (
    PFAX_EVENT_EX pEvent
)
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CServerNode::OnNotificationMessage"), dwRes);

    ASSERTION (pEvent);

    switch (pEvent->EventType)
    {
        case FAX_EVENT_TYPE_IN_QUEUE:
            //
            // Something happened in the incoming folder
            //
            if (m_Incoming.Locked() || !m_Incoming.IsValid())
            {
                //
                // Folder is locked or invalid - do not process notifications
                //
                dwRes = ERROR_LOCK_VIOLATION;
                VERBOSE (DBG_MSG, 
                         TEXT("Incoming folder is locked or invalid - notification is NOT processed"));
                return dwRes;
            }

            switch (pEvent->EventInfo.JobInfo.Type)
            {
                case FAX_JOB_EVENT_TYPE_ADDED:
                    //
                    // A job was added
                    //
                    VERBOSE (DBG_MSG, 
                             TEXT("Got server notification from %s - ")
                             TEXT("FAX_EVENT_TYPE_IN_QUEUE / FAX_JOB_EVENT_TYPE_ADDED")
                             TEXT(" / 0x%016I64x"),
                             m_cstrMachine, 
                             pEvent->EventInfo.JobInfo.dwlMessageId);
                    dwRes = m_Incoming.OnJobAdded (pEvent->EventInfo.JobInfo.dwlMessageId);
                    break;

                case FAX_JOB_EVENT_TYPE_REMOVED:
                    //
                    // A job was removed
                    //
                    VERBOSE (DBG_MSG, 
                             TEXT("Got server notification from %s - ")
                             TEXT("FAX_EVENT_TYPE_IN_QUEUE / FAX_JOB_EVENT_TYPE_REMOVED")
                             TEXT(" / 0x%016I64x"),
                             m_cstrMachine, 
                             pEvent->EventInfo.JobInfo.dwlMessageId);
                    dwRes = m_Incoming.OnJobRemoved (pEvent->EventInfo.JobInfo.dwlMessageId);
                    break;

                case FAX_JOB_EVENT_TYPE_STATUS:
                    //
                    // A job has changed its status
                    //
                    VERBOSE (DBG_MSG, 
                             TEXT("Got server notification from %s - ")
                             TEXT("FAX_EVENT_TYPE_IN_QUEUE / FAX_JOB_EVENT_TYPE_STATUS")
                             TEXT(" / 0x%016I64x (status = 0x%08x)"),
                             m_cstrMachine, 
                             pEvent->EventInfo.JobInfo.dwlMessageId,
                             pEvent->EventInfo.JobInfo.pJobData->dwQueueStatus);

                    if((pEvent->EventInfo.JobInfo.pJobData->dwQueueStatus & JS_COMPLETED) ||
                       (pEvent->EventInfo.JobInfo.pJobData->dwQueueStatus & JS_CANCELED))
                    {
                        //
                        // don't display completed or canceled jobs
                        //
                        dwRes = m_Incoming.OnJobRemoved (pEvent->EventInfo.JobInfo.dwlMessageId);
                    }
                    else
                    {
                        dwRes = m_Incoming.OnJobUpdated (pEvent->EventInfo.JobInfo.dwlMessageId,
                                                         pEvent->EventInfo.JobInfo.pJobData); 
                    }

                    break;

                default:
                    dwRes = ERROR_GEN_FAILURE;
                    VERBOSE (DBG_MSG, 
                             TEXT("Got unknown server notification from %s - ")
                             TEXT("FAX_EVENT_TYPE_IN_QUEUE / %d / 0x%016I64x"),
                             m_cstrMachine, 
                             pEvent->EventInfo.JobInfo.Type,
                             pEvent->EventInfo.JobInfo.dwlMessageId);
                    break;
            }
            break;

        case FAX_EVENT_TYPE_OUT_QUEUE:
            //
            // Something happened in the outbox folder
            //
            if (m_Outbox.Locked() || !m_Outbox.IsValid())
            {
                //
                // Folder is locked or invalid - do not process notifications
                //
                dwRes = ERROR_LOCK_VIOLATION;
                VERBOSE (DBG_MSG, 
                         TEXT("Outbox folder is locked or invalid - notification is NOT processed"));
                return dwRes;
            }
            switch (pEvent->EventInfo.JobInfo.Type)
            {
                case FAX_JOB_EVENT_TYPE_ADDED:
                    //
                    // A job was added
                    //
                    VERBOSE (DBG_MSG, 
                             TEXT("Got server notification from %s - ")
                             TEXT("FAX_EVENT_TYPE_OUT_QUEUE / FAX_JOB_EVENT_TYPE_ADDED")
                             TEXT(" / 0x%016I64x"),
                             m_cstrMachine, 
                             pEvent->EventInfo.JobInfo.dwlMessageId);
                    dwRes = m_Outbox.OnJobAdded (pEvent->EventInfo.JobInfo.dwlMessageId);
                    break;

                case FAX_JOB_EVENT_TYPE_REMOVED:
                    //
                    // A job was removed
                    //
                    VERBOSE (DBG_MSG, 
                             TEXT("Got server notification from %s - ")
                             TEXT("FAX_EVENT_TYPE_OUT_QUEUE / FAX_JOB_EVENT_TYPE_REMOVED")
                             TEXT(" / 0x%016I64x"),
                             m_cstrMachine, 
                             pEvent->EventInfo.JobInfo.dwlMessageId);
                    dwRes = m_Outbox.OnJobRemoved (pEvent->EventInfo.JobInfo.dwlMessageId);
                    break;

                case FAX_JOB_EVENT_TYPE_STATUS:
                    //
                    // A job has changed its status
                    //
                    VERBOSE (DBG_MSG, 
                             TEXT("Got server notification from %s - ")
                             TEXT("FAX_EVENT_TYPE_OUT_QUEUE / FAX_JOB_EVENT_TYPE_STATUS")
                             TEXT(" / 0x%016I64x (status = 0x%08x)"),
                             m_cstrMachine, 
                             pEvent->EventInfo.JobInfo.dwlMessageId,
                             pEvent->EventInfo.JobInfo.pJobData->dwQueueStatus);

                    if((pEvent->EventInfo.JobInfo.pJobData->dwQueueStatus & JS_COMPLETED) ||
                       (pEvent->EventInfo.JobInfo.pJobData->dwQueueStatus & JS_CANCELED))
                    {
                        //
                        // don't display completed or canceled jobs
                        //
                        dwRes = m_Outbox.OnJobRemoved (pEvent->EventInfo.JobInfo.dwlMessageId);
                    }
                    else
                    {
                        dwRes = m_Outbox.OnJobUpdated (pEvent->EventInfo.JobInfo.dwlMessageId,
                                                       pEvent->EventInfo.JobInfo.pJobData); 
                    }

                    break;

                default:
                    dwRes = ERROR_GEN_FAILURE;
                    VERBOSE (DBG_MSG, 
                             TEXT("Got unknown server notification from %s - ")
                             TEXT("FAX_EVENT_TYPE_OUT_QUEUE / %d / 0x%016I64x"),
                             m_cstrMachine, 
                             pEvent->EventInfo.JobInfo.Type,
                             pEvent->EventInfo.JobInfo.dwlMessageId);
                    break;
            }
            break;

        case FAX_EVENT_TYPE_QUEUE_STATE:
            //
            // Queue states have changed.
            // Update internal data with new queue states.
            //
            VERBOSE (DBG_MSG, 
                     TEXT("Got server notification from %s - FAX_EVENT_TYPE_QUEUE_STATE / %d"),
                     m_cstrMachine, 
                     pEvent->EventInfo.dwQueueStates);
            //
            // Assert valid values only
            //            
            ASSERTION (0 == (pEvent->EventInfo.dwQueueStates & ~(FAX_INCOMING_BLOCKED |
                                                                 FAX_OUTBOX_BLOCKED   |
                                                                 FAX_OUTBOX_PAUSED)));
            m_dwQueueState = pEvent->EventInfo.dwQueueStates;
            break;

        case FAX_EVENT_TYPE_IN_ARCHIVE:
            //
            // Something happened in the Inbox folder
            //
            if (m_Inbox.Locked() || !m_Inbox.IsValid())
            {
                //
                // Folder is locked or invalid - do not process notifications
                //
                dwRes = ERROR_LOCK_VIOLATION;
                VERBOSE (DBG_MSG, 
                         TEXT("Inbox folder is locked or invalid - notification is NOT processed"));
                return dwRes;
            }
            switch (pEvent->EventInfo.JobInfo.Type)
            {
                case FAX_JOB_EVENT_TYPE_ADDED:
                    //
                    // A message was added
                    //
                    VERBOSE (DBG_MSG, 
                             TEXT("Got server notification from %s - ")
                             TEXT("FAX_EVENT_TYPE_IN_ARCHIVE / FAX_JOB_EVENT_TYPE_ADDED")
                             TEXT(" / 0x%016I64x"),
                             m_cstrMachine, 
                             pEvent->EventInfo.JobInfo.dwlMessageId);
                    dwRes = m_Inbox.OnJobAdded (pEvent->EventInfo.JobInfo.dwlMessageId);
                    break;

                case FAX_JOB_EVENT_TYPE_REMOVED:
                    //
                    // A message was removed
                    //
                    VERBOSE (DBG_MSG, 
                             TEXT("Got server notification from %s - ")
                             TEXT("FAX_EVENT_TYPE_IN_ARCHIVE / FAX_JOB_EVENT_TYPE_REMOVED")
                             TEXT(" / 0x%016I64x"),
                             m_cstrMachine, 
                             pEvent->EventInfo.JobInfo.dwlMessageId);
                    dwRes = m_Inbox.OnJobRemoved (pEvent->EventInfo.JobInfo.dwlMessageId);
                    break;

                default:
                    dwRes = ERROR_GEN_FAILURE;
                    VERBOSE (DBG_MSG, 
                             TEXT("Got unknown server notification from %s - ")
                             TEXT("FAX_EVENT_TYPE_IN_ARCHIVE / %d / 0x%016I64x"),
                             m_cstrMachine, 
                             pEvent->EventInfo.JobInfo.Type,
                             pEvent->EventInfo.JobInfo.dwlMessageId);
                    break;
            }
            break;

        case FAX_EVENT_TYPE_OUT_ARCHIVE:
            //
            // Something happened in the SentItems folder
            //
            if (m_SentItems.Locked() || !m_SentItems.IsValid())
            {
                //
                // Folder is locked or invalid - do not process notifications
                //
                dwRes = ERROR_LOCK_VIOLATION;
                VERBOSE (DBG_MSG, 
                         TEXT("SentItems folder is locked or invalid - notification is NOT processed"));
                return dwRes;
            }
            switch (pEvent->EventInfo.JobInfo.Type)
            {
                case FAX_JOB_EVENT_TYPE_ADDED:
                    //
                    // A message was added
                    //
                    VERBOSE (DBG_MSG, 
                             TEXT("Got server notification from %s - ")
                             TEXT("FAX_EVENT_TYPE_OUT_ARCHIVE / FAX_JOB_EVENT_TYPE_ADDED")
                             TEXT(" / 0x%016I64x"),
                             m_cstrMachine, 
                             pEvent->EventInfo.JobInfo.dwlMessageId);
                    dwRes = m_SentItems.OnJobAdded (pEvent->EventInfo.JobInfo.dwlMessageId);
                    break;

                case FAX_JOB_EVENT_TYPE_REMOVED:
                    //
                    // A message was removed
                    //
                    VERBOSE (DBG_MSG, 
                             TEXT("Got server notification from %s - ")
                             TEXT("FAX_EVENT_TYPE_OUT_ARCHIVE / FAX_JOB_EVENT_TYPE_REMOVED")
                             TEXT(" / 0x%016I64x"),
                             m_cstrMachine, 
                             pEvent->EventInfo.JobInfo.dwlMessageId);
                    dwRes = m_SentItems.OnJobRemoved (pEvent->EventInfo.JobInfo.dwlMessageId);
                    break;

                default:
                    dwRes = ERROR_GEN_FAILURE;
                    VERBOSE (DBG_MSG, 
                             TEXT("Got unknown server notification from %s - ")
                             TEXT("FAX_EVENT_TYPE_OUT_ARCHIVE / %d / 0x%016I64x"),
                             m_cstrMachine, 
                             pEvent->EventInfo.JobInfo.Type,
                             pEvent->EventInfo.JobInfo.dwlMessageId);
                    break;
            }
            break;

        case FAX_EVENT_TYPE_FXSSVC_ENDED:
            //
            // Fax service is shutting down
            //
            VERBOSE (DBG_MSG, 
                     TEXT("Got server notification from %s - FAX_EVENT_TYPE_FXSSVC_ENDED"),
                     m_cstrMachine);
            dwRes = Disconnect ();
            if (ERROR_SUCCESS != dwRes)
            {
                CALL_FAIL (GENERAL_ERR, TEXT("Disconnect"), dwRes);
            }
            dwRes = InvalidateSubFolders (TRUE);
            if (ERROR_SUCCESS != dwRes)
            {
                CALL_FAIL (GENERAL_ERR, TEXT("InvalidateSubFolders"), dwRes);
            }
            break;

        default:
            dwRes = ERROR_GEN_FAILURE;
            VERBOSE (DBG_MSG, 
                     TEXT("Got unknown server notification from %s - %d"),
                     m_cstrMachine,
                     pEvent->EventType);
            break;
    }
    return dwRes;
}   // CServerNode::OnNotificationMessage 


CFolder* 
CServerNode::GetFolder(FolderType type)
{
    CFolder* pFolder=NULL;

    switch(type)
    {
    case FOLDER_TYPE_INBOX:
        pFolder = &m_Inbox;
        break;
    case FOLDER_TYPE_OUTBOX:
        pFolder = &m_Outbox;
        break;
    case FOLDER_TYPE_SENT_ITEMS:
        pFolder = &m_SentItems;
        break;
    case FOLDER_TYPE_INCOMING:
        pFolder = &m_Incoming;
        break;
    default:
        {
            DBG_ENTER(TEXT("CServerNode::GetFolder"));
            ASSERTION_FAILURE
        }
        break;
    }

    return pFolder;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\servernode.h ===
// ServerNode.h: interface for the CServerNode class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_SERVERNODE_H__1B5E5554_A8BB_4682_B1A8_56453753643D__INCLUDED_)
#define AFX_SERVERNODE_H__1B5E5554_A8BB_4682_B1A8_56453753643D__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


//
// WM_SERVER_NOTIFY_BASE is the base (minimal) message id used for notifications
// that arrive from the server(s). Each server is assigned a differnet message id
// which is equal of bigger than this value.
//
#define WM_SERVER_NOTIFY_BASE       WM_APP + 10

#ifndef __AFXWIN_H__
    #error include 'stdafx.h' before including this file for PCH
#endif

class CServerNode : public CTreeNode
{
public:
    CServerNode ();

    DECLARE_DYNAMIC(CServerNode)

    DWORD Init (LPCTSTR tstrMachine);
    const CString & Machine () const    { return m_cstrMachine; }

    DWORD RefreshState ();

    void AttachFoldersToViews()
        {
            m_Inbox.AttachView();
            m_SentItems.AttachView();
            m_Outbox.AttachView();
            m_Incoming.AttachView();
        }

    BOOL  IsIncomingBlocked () const    { return (m_dwQueueState & FAX_INCOMING_BLOCKED) ? TRUE : FALSE; }
    BOOL  IsOutboxBlocked () const      { return (m_dwQueueState & FAX_OUTBOX_BLOCKED) ? TRUE : FALSE; }
    BOOL  IsOutboxPaused () const       { return (m_dwQueueState & FAX_OUTBOX_PAUSED) ? TRUE : FALSE; }

    BOOL  IsOnline () const          { return m_hConnection ? TRUE : FALSE; }
    BOOL  IsRefreshing() const       { return m_bInBuildup; }
    DWORD GetActivity(CString& cstrText, TreeIconType& iconIndex) const;


    DWORD BlockIncoming (BOOL bBlock);
    DWORD BlockOutbox (BOOL bBlock);
    DWORD PauseOutbox (BOOL bPause);

    BOOL  CanSeeInbox ()     const { return IsRightHeld(FAX_ACCESS_QUERY_IN_ARCHIVE);   }
    BOOL  CanManageInbox()   const { return IsRightHeld(FAX_ACCESS_MANAGE_IN_ARCHIVE);  }
    BOOL  CanSeeAllJobs ()   const { return IsRightHeld(FAX_ACCESS_QUERY_JOBS);         }
    BOOL  CanManageAllJobs() const { return IsRightHeld(FAX_ACCESS_MANAGE_JOBS);        }
	BOOL  CanManageConfig()  const { return IsRightHeld(FAX_ACCESS_MANAGE_CONFIG);      } 
	BOOL  CanSendFax()       const { return (IsRightHeld(FAX_ACCESS_SUBMIT)			||
											 IsRightHeld(FAX_ACCESS_SUBMIT_NORMAL)	||
											 IsRightHeld(FAX_ACCESS_SUBMIT_HIGH))		&& 
                                            !IsOutboxBlocked();                         } 
    BOOL  CanReceiveNow()    const { return IsRightHeld(FAX_ACCESS_QUERY_IN_ARCHIVE) &&     // FaxAnswerCall requires FAX_ACCESS_QUERY_IN_ARCHIVE
                                            m_cstrMachine.IsEmpty();                    }   // FaxAnswerCall only works on local server

    CFolder* GetFolder(FolderType type);

    const CMessageFolder   &GetInbox () const     { return m_Inbox;     }
    const CMessageFolder   &GetSentItems () const { return m_SentItems; }
    const CQueueFolder     &GetOutbox () const    { return m_Outbox;    }
    const CQueueFolder     &GetIncoming () const  { return m_Incoming;  }

    virtual void AssertValid( ) const;
    virtual void Dump( CDumpContext &dc ) const;

    DWORD GetConnectionHandle (HANDLE &hFax);

    DWORD InvalidateSubFolders(BOOL bClearView);

    void SetLastRPCError (DWORD dwErr, BOOL DisconnectOnFailure = TRUE);
    DWORD GetLastRPCError ()            { return m_dwLastRPCError; }

    DWORD Disconnect (BOOL bShutdownAware = FALSE, BOOL bWaitForBuildThread = TRUE);
    void Destroy ();

    static CServerNode *LookupServerFromMessageId (DWORD dwMsgId);

    static DWORD InitMsgsMap ();
    static DWORD ShutdownMsgsMap ();

    DWORD  OnNotificationMessage (PFAX_EVENT_EX pEvent);

	BOOL IsValid() { return m_bValid; }
	void SetValid(BOOL bValid) { m_bValid = bValid; }

    DWORD GetNotifyMsgID() { return m_dwMsgId; }

private:

    virtual ~CServerNode();

    BOOL IsRightHeld (DWORD dwRight) const
    {
        return ((m_dwRights & dwRight) == dwRight) ? TRUE : FALSE;
    }

    DWORD Connect ();

	BOOL  m_bValid;
    DWORD SetNewQueueState (DWORD dwNewState);
    DWORD ClearContents ();

    DWORD CreateFolders ();
    BOOL  FatalRPCError (DWORD dwErr);

    DWORD       m_dwRights;     // Current relevant access rights
    DWORD       m_dwQueueState; // Current queue state
    HANDLE      m_hConnection;  // Handle to RPC connection
    CString     m_cstrMachine;  // Server's machine name

    CMessageFolder      m_Inbox;       // Inbox folder
    CMessageFolder      m_SentItems;   // SentItems folder
    CQueueFolder        m_Outbox;      // Outbox folder
    CQueueFolder        m_Incoming;    // Incoming folder

    DWORD               m_dwLastRPCError;   // Error code of last RPC call

    //
    // Buildup thread members and functions:
    //
    CRITICAL_SECTION    m_csBuildup;            // Protects buildup phase
    BOOL                m_bCsBuildupValid;      // Is the critical section valid?
    HANDLE              m_hBuildupThread;       // Handle of background contents building thread
    BOOL                m_bStopBuildup;         // Should we abort the buildup operation?
    BOOL                m_bInBuildup;           // Are we doing a buildup now?

    CRITICAL_SECTION    m_csBuildupThread;      // Protects access to the m_hBuildupThread
    BOOL                m_bCsBuildupThreadValid;// Is the critical section valid?

    DWORD               StopBuildThread (BOOL bWaitForDeath = TRUE);
    DWORD               Buildup ();

    BOOL                m_bSelfDestruct;        // Should we destroy ourselves ASAP?

    static DWORD WINAPI BuildupThreadProc (LPVOID lpParameter);

    //
    // Notifications handling:
    //
    HANDLE              m_hNotification;    // Notification registration handle
    DWORD               m_dwMsgId;          // Windows message id used for notification
        //
        // Map between Windows message and server pointer from 
        // which the notification message was sent.
        //
    typedef map <DWORD, CServerNode *> MESSAGES_MAP;    
    static CRITICAL_SECTION m_sMsgsCs;   // Protects access to the map
    static BOOL             m_sbMsgsCsInitialized;  // Was m_sMsgsCs initialized;
    static MESSAGES_MAP     m_sMsgs;
    static DWORD            m_sdwMinFreeMsg; // The smallest available message id
    static DWORD AllocateNewMessageId (CServerNode *pServer, DWORD &dwMsdgId);
    static DWORD FreeMessageId (DWORD dwMsgId);
    
};

#endif // !defined(AFX_SERVERNODE_H__1B5E5554_A8BB_4682_B1A8_56453753643D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\sortheader.cpp ===
// SortHeader.cpp : implementation file
//

#include "stdafx.h"
#define __FILE_ID__     6

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


#define SORT_UP_ARROW_ICON_ID     1
#define SORT_DOWN_ARROW_ICON_ID   2

/////////////////////////////////////////////////////////////////////////////
// CSortHeader

CSortHeader::CSortHeader() :
    m_nSortColumn (-1), // Not sorted,
    m_hwndList (NULL)   // No attached list view control
{}

CSortHeader::~CSortHeader()
{
    Detach ();
}


BEGIN_MESSAGE_MAP(CSortHeader, CHeaderCtrl)
    //{{AFX_MSG_MAP(CSortHeader)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSortHeader message handlers

int 
CSortHeader::SetSortImage(
    int nCol, 
    BOOL bAscending
)
/*++

Routine name : CSortHeader::SetSortImage

Routine description:

    Sets the current sort column & sort order

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    nCol            [in ] - Sort column index
    bAscending      [in ] - Sort order

Return Value:

    Previous sort column

--*/
{
    DBG_ENTER(TEXT("CSortHeader::SetSortImage"),
              TEXT("Col=%d, bAscending = %d"),
              nCol,
              bAscending);

    int nPrevCol = m_nSortColumn;

    m_nSortColumn = nCol;
    if (nPrevCol == nCol && m_bSortAscending == bAscending)
    {
        //
        // Sort column didn't change and sort order didn't change - return now
        //
        return nPrevCol;
    }
    m_bSortAscending = bAscending;

    if (!IsWinXPOS())
    {
        HD_ITEM hditem;
        //
        // Change the entire header control to owner-drawn
        //
        hditem.mask = HDI_FORMAT;
        GetItem( nCol, &hditem );
        hditem.fmt |= HDF_OWNERDRAW;
        SetItem( nCol, &hditem );
        //
        // Invalidate header control so that it gets redrawn
        //
        Invalidate();
    }
    else
    {
        //
        // No need for owner-drawn header control in Windows XP.
        // We can use bitmaps along with text.
        //
        ASSERTION (m_hwndList);
        LV_COLUMN lvc;
        if (-1 != nPrevCol)
        {
            //
            // Remove the sort arrow from the previously sorted column
            //
            lvc.mask = LVCF_FMT;
            ListView_GetColumn (m_hwndList, nPrevCol, &lvc);
            lvc.fmt &= ~(LVCFMT_IMAGE | LVCFMT_BITMAP_ON_RIGHT);
            ListView_SetColumn(m_hwndList, nPrevCol, &lvc);
        } 
        if (-1 != nCol)
        {
            //
            // Add sort arrow to the currently sorted column
            //
            lvc.mask = LVCF_FMT;
            ListView_GetColumn (m_hwndList, nCol, &lvc);
            lvc.fmt |= (LVCFMT_IMAGE | LVCFMT_BITMAP_ON_RIGHT);
            lvc.mask = LVCF_IMAGE | LVCF_FMT;
            lvc.iImage = m_bSortAscending ? SORT_UP_ARROW_ICON_ID : SORT_DOWN_ARROW_ICON_ID;
            ListView_SetColumn(m_hwndList, nCol, &lvc);
        }
    }
    return nPrevCol;
}

void CSortHeader::DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct) 
{
    CDC dc;

    dc.Attach( lpDrawItemStruct->hDC );
    //
    // Get the column rect
    //
    CRect rcLabel( lpDrawItemStruct->rcItem );
    //
    // Save DC
    //
    int nSavedDC = dc.SaveDC();
    //
    // Set clipping region to limit drawing within column
    //
    CRgn rgn;
    rgn.CreateRectRgnIndirect( &rcLabel );
    dc.SelectObject( &rgn );
    rgn.DeleteObject();
    //
    // Draw the background
    //
    dc.FillRect(rcLabel, &CBrush(::GetSysColor(COLOR_3DFACE)));
    //
    // Labels are offset by a certain amount  
    // This offset is related to the width of a space character
    //
    int offset = dc.GetTextExtent(_T(" "), 1 ).cx*2;
    //
    // Get the column text and format
    //
    TCHAR buf[256];
    HD_ITEM hditem;

    hditem.mask = HDI_TEXT | HDI_FORMAT;
    hditem.pszText = buf;
    hditem.cchTextMax = 255;

    GetItem( lpDrawItemStruct->itemID, &hditem );
    //
    // Determine format for drawing column label
    UINT uFormat = DT_SINGLELINE | DT_NOPREFIX | DT_NOCLIP | DT_VCENTER | DT_END_ELLIPSIS;
    if( hditem.fmt & HDF_CENTER)
    {
        uFormat |= DT_CENTER;
    }
    else if( hditem.fmt & HDF_RIGHT)
    {
        uFormat |= DT_RIGHT;
    }
    else
    {
        uFormat |= DT_LEFT;
    }
    //
    // Adjust the rect if the mouse button is pressed on it
    //
    if( lpDrawItemStruct->itemState == ODS_SELECTED )
    {
        rcLabel.left++;
        rcLabel.top += 2;
        rcLabel.right++;
    }
    //
    // Adjust the rect further if Sort arrow is to be displayed
    //
    if( lpDrawItemStruct->itemID == (UINT)m_nSortColumn )
    {
        rcLabel.right -= 3 * offset;
    }

    rcLabel.left += offset;
    rcLabel.right -= offset;
    //
    // Draw column label
    //
    if( rcLabel.left < rcLabel.right )
    {
        dc.DrawText(buf,-1,rcLabel, uFormat);
    }
    //
    // Draw the Sort arrow
    //
    if( lpDrawItemStruct->itemID == (UINT)m_nSortColumn )
    {
        CRect rcIcon( lpDrawItemStruct->rcItem );
        //
        // Set up pens to use for drawing the triangle
        //
        CPen penLight(PS_SOLID, 1, GetSysColor(COLOR_3DHILIGHT));
        CPen penShadow(PS_SOLID, 1, GetSysColor(COLOR_3DSHADOW));
        CPen *pOldPen = dc.SelectObject( &penLight );
        offset = (rcIcon.bottom - rcIcon.top) / 4;
        if (m_bSortAscending) 
        {
            //
            // Draw triangle pointing upwards
            //
            dc.MoveTo( rcIcon.right - 2*offset, offset);
            dc.LineTo( rcIcon.right - offset, rcIcon.bottom - offset-1 );
            dc.LineTo( rcIcon.right - 3*offset-2, rcIcon.bottom - offset-1 );
            dc.MoveTo( rcIcon.right - 3*offset-1, rcIcon.bottom - offset-1 );
            dc.SelectObject( &penShadow );
            dc.LineTo( rcIcon.right - 2*offset, offset-1);      
        }       
        else 
        {
            //
            // Draw triangle pointing downwards
            //
            dc.MoveTo( rcIcon.right - offset-1, offset);
            dc.LineTo( rcIcon.right - 2*offset-1, rcIcon.bottom - offset );
            dc.MoveTo( rcIcon.right - 2*offset-2, rcIcon.bottom - offset );
            dc.SelectObject( &penShadow );
            dc.LineTo( rcIcon.right - 3*offset-1, offset );
            dc.LineTo( rcIcon.right - offset-1, offset);        
        }       
        //
        // Restore the pen
        //
        dc.SelectObject( pOldPen );
    }
    //
    // Restore dc
    //
    dc.RestoreDC( nSavedDC );
    //
    // Detach the dc before returning
    //
    dc.Detach();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\serverstatusdlg.cpp ===
// ServerStatus.cpp : implementation file
//

#include "stdafx.h"
#define __FILE_ID__     82

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

struct TSrvStatusColInfo
{
    DWORD dwStrRes; // column header string
    DWORD dwWidth;  // column width
};

static TSrvStatusColInfo s_colInfo[] = 
{
    IDS_SRV_COL_SERVER,        133,
    IDS_SRV_COL_STATUS,        120
};

/////////////////////////////////////////////////////////////////////////////
// CServerStatusDlg dialog


CServerStatusDlg::CServerStatusDlg(CClientConsoleDoc* pDoc, CWnd* pParent /*=NULL*/)
	: CFaxClientDlg(CServerStatusDlg::IDD, pParent),
    m_pDoc(pDoc)
{
    ASSERT(m_pDoc);
}


void CServerStatusDlg::DoDataExchange(CDataExchange* pDX)
{
	CFaxClientDlg::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CServerStatusDlg)
	DDX_Control(pDX, IDC_LIST_SERVER, m_listServer);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CServerStatusDlg, CFaxClientDlg)
	//{{AFX_MSG_MAP(CServerStatusDlg)
	ON_NOTIFY(LVN_KEYDOWN, IDC_LIST_SERVER, OnKeydownListCp)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CServerStatusDlg message handlers

BOOL 
CServerStatusDlg::OnInitDialog() 
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CServerStatusDlg::OnInitDialog"));

    CFaxClientDlg::OnInitDialog();
	
    //
    // init CListCtrl
    //
    m_listServer.SetExtendedStyle (LVS_EX_FULLROWSELECT |    // Entire row is selected
                                   LVS_EX_INFOTIP       |    // Allow tooltips
                                   LVS_EX_ONECLICKACTIVATE); // Hover cursor effect

    m_listServer.SetImageList (&CLeftView::m_ImageList, LVSIL_SMALL);

    int nRes;
    CString cstrHeader;
    DWORD nCols = sizeof(s_colInfo)/sizeof(s_colInfo[0]);

    //
    // init column
    //
    for(int i=0; i < nCols; ++i)
    {
        //
        // load title string
        //
        m_dwLastError = LoadResourceString (cstrHeader, s_colInfo[i].dwStrRes);
        if(ERROR_SUCCESS != m_dwLastError)
        {
            CALL_FAIL (RESOURCE_ERR, TEXT ("LoadResourceString"), m_dwLastError);
            EndDialog(IDABORT);
            return FALSE;
        }

        //
        // insert column
        //
        nRes = m_listServer.InsertColumn(i, cstrHeader, LVCFMT_LEFT, s_colInfo[i].dwWidth);
        if(nRes != i)
        {
            m_dwLastError = GetLastError();
            CALL_FAIL (WINDOW_ERR, TEXT ("CListView::InsertColumn"), m_dwLastError);
            EndDialog(IDABORT);
            return FALSE;
        }
    }

    //
    // fill list control with servers
    //
    m_dwLastError = RefreshServerList();
    if(ERROR_SUCCESS != m_dwLastError)
    {
        CALL_FAIL (GENERAL_ERR, TEXT ("RefreshServerList"), m_dwLastError);
        EndDialog(IDABORT);
        return FALSE;
    }

	
	return TRUE;
}

DWORD 
CServerStatusDlg::RefreshServerList()
/*++

Routine name : CServerStatusDlg::RefreshServerList

Routine description:

	fill in list control with servers statuses

Author:

	Alexander Malysh (AlexMay),	Apr, 2000

Arguments:


Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CCoverPagesDlg::RefreshServerList"), dwRes);

    if(!m_listServer.DeleteAllItems())
    {
        dwRes = ERROR_CAN_NOT_COMPLETE;
        CALL_FAIL (WINDOW_ERR, TEXT ("CListView::DeleteAllItems"), dwRes);
        return dwRes;
    }

    const SERVERS_LIST& srvList = m_pDoc->GetServersList();

    int nItem, nRes;
    CString cstrName;
    CString cstrStatus;
    TreeIconType iconIndex;
    CServerNode* pServerNode;
    for (SERVERS_LIST::iterator it = srvList.begin(); it != srvList.end(); ++it)
    {
        //
        // get server name
        //
        pServerNode = *it;
        try
        {
            cstrName = pServerNode->Machine();
        }
        catch(...)
        {
            dwRes = ERROR_NOT_ENOUGH_MEMORY;
            CALL_FAIL (MEM_ERR, TEXT("CString::operator="), dwRes);
            return dwRes;
        }

        if(cstrName.GetLength() == 0)
        {
            dwRes = LoadResourceString(cstrName, IDS_LOCAL_SERVER);
            if(ERROR_SUCCESS != dwRes)
            {
                CALL_FAIL (GENERAL_ERR, TEXT("LoadResourceString"), dwRes);
                return dwRes;
            }                    
        }

        //
        // get server status
        //
        dwRes = pServerNode->GetActivity(cstrStatus, iconIndex);
        if(ERROR_SUCCESS != dwRes)
        {
            CALL_FAIL (GENERAL_ERR, TEXT("CServerNode::GetActivity"), dwRes);
            return dwRes;
        }                    

        nItem = m_listServer.GetItemCount();

        //
        // insert server row
        //
        nItem = m_listServer.InsertItem(nItem, cstrName, iconIndex);
        if(nItem < 0)
        {
            dwRes = ERROR_CAN_NOT_COMPLETE;
            CALL_FAIL (WINDOW_ERR, TEXT ("CListView::InsertItem"), dwRes);
            return dwRes;
        }

        //
        // display server status
        //
        nRes = m_listServer.SetItemText(nItem, 1, cstrStatus);
        if(!nRes)
        {
            dwRes = ERROR_CAN_NOT_COMPLETE;
            CALL_FAIL (WINDOW_ERR, TEXT ("CListView::SetItemText"), dwRes);
            return dwRes;
        }
    }

    return dwRes;

} // CServerStatusDlg::RefreshServerList

void 
CServerStatusDlg::OnKeydownListCp(NMHDR* pNMHDR, LRESULT* pResult) 
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CCoverPagesDlg::OnKeydownListCp"));

    LV_KEYDOWN* pLVKeyDow = (LV_KEYDOWN*)pNMHDR;

    if(VK_F5 == pLVKeyDow->wVKey)
    {
        //
        // F5 was pressed
        //
        dwRes = RefreshServerList();
        if(ERROR_SUCCESS != dwRes)
        {
            CALL_FAIL (GENERAL_ERR, TEXT ("RefreshServerList"), dwRes);
        }
    }
    
	*pResult = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\serverstatusdlg.h ===
#if !defined(AFX_SERVERSTATUS_H__13E9E42D_A0CA_4111_9DB7_A9FBD889A168__INCLUDED_)
#define AFX_SERVERSTATUS_H__13E9E42D_A0CA_4111_9DB7_A9FBD889A168__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ServerStatus.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CServerStatusDlg dialog

class CServerStatusDlg : public CFaxClientDlg
{
// Construction
public:
	CServerStatusDlg(CClientConsoleDoc* pDoc, CWnd* pParent = NULL);

// Dialog Data
	//{{AFX_DATA(CServerStatusDlg)
	enum { IDD = IDD_SERVER_STATUS };
	CListCtrl	m_listServer;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CServerStatusDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

    CClientConsoleDoc* m_pDoc;

    DWORD RefreshServerList();

	// Generated message map functions
	//{{AFX_MSG(CServerStatusDlg)
	virtual BOOL OnInitDialog();
    afx_msg void OnKeydownListCp(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SERVERSTATUS_H__13E9E42D_A0CA_4111_9DB7_A9FBD889A168__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	ClientConsole.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\treenode.cpp ===
// TreeNode.cpp: implementation of the CTreeNode class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#define __FILE_ID__     61

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNAMIC(CTreeNode, CObject)

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CTreeNode::CTreeNode(FolderType type):
    m_Type(type)          // node type
{
    DBG_ENTER(TEXT("CTreeNode::CTreeNode"));
 
    ASSERTION ((type >= 0) && (type < FOLDER_TYPE_MAX));
}

CTreeNode::~CTreeNode()
{
}

void CTreeNode::AssertValid() const
{
    CObject::AssertValid();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\sortheader.h ===
#if !defined(AFX_SORTHEADER_H__A5F69D17_1989_4206_8A14_7AC8C91AB797__INCLUDED_)
#define AFX_SORTHEADER_H__A5F69D17_1989_4206_8A14_7AC8C91AB797__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// SortHeader.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CSortHeader window

class CSortHeader : public CHeaderCtrl
{
// Construction
public:
    CSortHeader();

// Attributes
public:

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CSortHeader)
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CSortHeader();
    int SetSortImage (int nCol, BOOL bAscending);
    void    SetListControl (HWND hwnd)  { m_hwndList = hwnd; }


    // Generated message map functions
protected:
    //{{AFX_MSG(CSortHeader)
    //}}AFX_MSG

    void    DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);

    int     m_nSortColumn;
    BOOL    m_bSortAscending;
    HWND    m_hwndList;

    DECLARE_MESSAGE_MAP()

private:

};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SORTHEADER_H__A5F69D17_1989_4206_8A14_7AC8C91AB797__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

Author:

    Eran Yariv (EranY)

!ENDIF

!include ..\..\faxsrc.inc

TARGETPATH=obj
TARGETTYPE=PROGRAM

UMTYPE=windows
C_DEFINES=$(C_DEFINES) /D_NT_SUR_ /DNO_STRICT /DWIN4 /DNT4 /DNT_BUILD /D_WIN32_IE=0x0400

NOMFCPDB=1
USE_NATIVE_EH=1
USE_STL=1
USE_LATEST_MFC=1


PRECOMPILED_INCLUDE=..\stdafx.h
PRECOMPILED_PCH=stdafx.pch
PRECOMPILED_OBJ=stdafx.obj
PRECOMPILED_CXX=1

INCLUDES=               \
    ..;                 \
    $(INCLUDES); 

!ifndef NOUNICODE
TARGETLIBS = $(FAXLIB)\*\$(WINFAX).lib \
             $(FAXLIB)\*\$(FAXTIFF).lib  
!else
TARGETLIBS = $(FAXLIB)\win95\*\$(WINFAX).lib \
             $(FAXLIB)\win95\*\$(FAXTIFF).lib  
!endif

TARGETLIBS= $(TARGETLIBS) \
    $(BASEDIR)\public\sdk\lib\*\comdlg32.lib    \
    $(BASEDIR)\public\sdk\lib\*\ole32.lib       \
    $(BASEDIR)\public\sdk\lib\*\shell32.lib     \
    $(BASEDIR)\public\sdk\lib\*\uuid.lib        \
    $(BASEDIR)\public\sdk\lib\*\winspool.lib    \
    $(BASEDIR)\public\sdk\lib\*\comctl32.lib    \
    $(BASEDIR)\public\sdk\lib\*\htmlhelp.lib    \
    ..\resources\obj\*\$(FAXCLIENTRES).lib      \
    $(FAXROOT)\util\debugex\$(DEBUG_TYPE)\obj\*\debugex.lib

SOURCES=\
    ..\ClientConsole.cpp        \
    ..\ClientConsoleDoc.cpp     \
    ..\ClientConsoleView.cpp    \
    ..\Folder.cpp               \
    ..\FolderListView.cpp       \
    ..\Job.cpp                  \
    ..\LeftView.cpp             \
    ..\MainFrm.cpp              \
    ..\Message.cpp              \
    ..\MessageFolder.cpp        \
    ..\QueueFolder.cpp          \
    ..\ServerNode.cpp           \
    ..\SortHeader.cpp           \
    ..\Utils.cpp                \
    ..\ErrorDlg.cpp             \
    ..\FaxTime.cpp              \
    ..\ViewRow.cpp              \
    ..\ColumnSelectDlg.cpp      \
    ..\Version.rc               \
    ..\ItemPropSheet.cpp        \
    ..\InboxGeneralPg.cpp       \
    ..\IncomingGeneralPg.cpp    \
    ..\OutboxGeneralPg.cpp      \
    ..\SentItemsGeneralPg.cpp   \
    ..\PersonalInfoPg.cpp       \
    ..\InboxDetailsPg.cpp       \
    ..\IncomingDetailsPg.cpp    \
    ..\OutboxDetailsPg.cpp      \
    ..\SentItemsDetailsPg.cpp   \
    ..\MsgPropertyPg.cpp        \
    ..\TreeNode.cpp             \
    ..\UserInfoDlg.cpp          \
    ..\FolderDialog.cpp         \
    ..\FaxClientPg.cpp          \
    ..\CoverPagesDlg.cpp        \
    ..\FaxClientDlg.cpp         \
    ..\CmdLineInfo.cpp          \
    ..\ServerStatusDlg.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\userinfodlg.h ===
#if !defined(AFX_OPTIONSUSERINFOPG_H__BF10E6C1_FC10_422F_9F76_1D0BBD7C73CA__INCLUDED_)
#define AFX_OPTIONSUSERINFOPG_H__BF10E6C1_FC10_422F_9F76_1D0BBD7C73CA__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// OptionsUserInfoPg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CUserInfoDlg dialog

class CUserInfoDlg : public CFaxClientDlg
{

// Construction
public:
	CUserInfoDlg();
	~CUserInfoDlg();

// Dialog Data
	//{{AFX_DATA(CUserInfoDlg)
	enum { IDD = IDD_OPTIONS_USER_INFO };
    CEdit	m_editAddress;
	CButton	m_butOk;
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA

    #define ADDRESS_MAX_LEN  512

private:
    DWORD Save();

private:
    TCHAR** m_tchStrArray;
    FAX_PERSONAL_PROFILE m_PersonalProfile;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CUserInfoDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CUserInfoDlg)
    virtual void OnOK();
	virtual BOOL OnInitDialog();
	afx_msg void OnModify();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_OPTIONSUSERINFOPG_H__BF10E6C1_FC10_422F_9F76_1D0BBD7C73CA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\treenode.h ===
// TreeNode.h: interface for the CTreeNode class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_TREENODE_H__3B753848_4860_4DC5_AC1E_F3514CE4E839__INCLUDED_)
#define AFX_TREENODE_H__3B753848_4860_4DC5_AC1E_F3514CE4E839__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

enum FolderType
{
    FOLDER_TYPE_INBOX,
    FOLDER_TYPE_OUTBOX,
    FOLDER_TYPE_SENT_ITEMS,
    FOLDER_TYPE_INCOMING,    
    FOLDER_TYPE_SERVER,      
    FOLDER_TYPE_COVER_PAGES, 
    FOLDER_TYPE_MAX
};

class CFolderListView;

class CTreeNode : public CObject  
{
public:
	CTreeNode(FolderType type);
	virtual ~CTreeNode();

    FolderType Type() const  { return m_Type; }

    virtual BOOL IsRefreshing() const = 0;

    virtual void AssertValid() const;

    DECLARE_DYNAMIC(CTreeNode)

protected:

    FolderType m_Type;          // Type of this folder
};

#endif // !defined(AFX_TREENODE_H__3B753848_4860_4DC5_AC1E_F3514CE4E839__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\userinfodlg.cpp ===
// OptionsUserInfoPg.cpp : implementation file
//

#include "stdafx.h"


#define __FILE_ID__     71

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//
// this array maps dialog control IDs to
// number of string in FAX_PERSONAL_PROFILE structure
//
static TPersonalPageInfo s_PageInfo[] = 
{ 
    IDC_NAME_VALUE,             PERSONAL_PROFILE_NAME,                
    IDC_FAX_NUMBER_VALUE,       PERSONAL_PROFILE_FAX_NUMBER,          
    IDC_COMPANY_VALUE,          PERSONAL_PROFILE_COMPANY,             
    IDC_TITLE_VALUE,            PERSONAL_PROFILE_TITLE,               
    IDC_DEPARTMENT_VALUE,       PERSONAL_PROFILE_DEPARTMENT,          
    IDC_OFFICE_VALUE,           PERSONAL_PROFILE_OFFICE_LOCATION,     
    IDC_HOME_PHONE_VALUE,       PERSONAL_PROFILE_HOME_PHONE,          
    IDC_BUSINESS_PHONE_VALUE,   PERSONAL_PROFILE_OFFICE_PHONE,        
    IDC_EMAIL_VALUE,            PERSONAL_PROFILE_EMAIL,       
    IDC_BILLING_CODE_VALUE,     PERSONAL_PROFILE_BILLING_CODE,
    IDC_ADDRESS_VALUE,          PERSONAL_PROFILE_STREET_ADDRESS
};


/////////////////////////////////////////////////////////////////////////////
// CUserInfoDlg property page


CUserInfoDlg::CUserInfoDlg(): 
    CFaxClientDlg(CUserInfoDlg::IDD)
{
    memset((LPVOID)&m_PersonalProfile, 0, sizeof(m_PersonalProfile));   
    m_PersonalProfile.dwSizeOfStruct = sizeof(m_PersonalProfile);

    m_tchStrArray =  &(m_PersonalProfile.lptstrName);
}

CUserInfoDlg::~CUserInfoDlg()
{
    //
    // free memory
    //
    for(DWORD dw=0; dw < PERSONAL_PROFILE_STR_NUM; ++dw)
    {
        MemFree(m_tchStrArray[dw]);
    }
}

void CUserInfoDlg::DoDataExchange(CDataExchange* pDX)
{
    CFaxClientDlg::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CUserInfoDlg)
    DDX_Control(pDX, IDC_ADDRESS_VALUE, m_editAddress);
    DDX_Control(pDX, IDOK, m_butOk);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CUserInfoDlg, CFaxClientDlg)
    //{{AFX_MSG_MAP(CUserInfoDlg)
    ON_EN_CHANGE(IDC_NAME_VALUE,           OnModify)
    ON_EN_CHANGE(IDC_NAME_VALUE,           OnModify)
    ON_EN_CHANGE(IDC_FAX_NUMBER_VALUE,     OnModify)
    ON_EN_CHANGE(IDC_COMPANY_VALUE,        OnModify)
    ON_EN_CHANGE(IDC_TITLE_VALUE,          OnModify)
    ON_EN_CHANGE(IDC_DEPARTMENT_VALUE,     OnModify)
    ON_EN_CHANGE(IDC_OFFICE_VALUE,         OnModify)
    ON_EN_CHANGE(IDC_HOME_PHONE_VALUE,     OnModify)
    ON_EN_CHANGE(IDC_BUSINESS_PHONE_VALUE, OnModify)
    ON_EN_CHANGE(IDC_EMAIL_VALUE,          OnModify)
    ON_EN_CHANGE(IDC_BILLING_CODE_VALUE,   OnModify)
    ON_EN_CHANGE(IDC_ADDRESS_VALUE,        OnModify)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CUserInfoDlg message handlers

BOOL 
CUserInfoDlg::OnInitDialog() 
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("COptionsSettingsPg::OnInitDialog"));

    CFaxClientDlg::OnInitDialog();

    //
    // get user info
    //
    FAX_PERSONAL_PROFILE personalProfile;
    memset((LPVOID)&personalProfile, 0, sizeof(personalProfile));   
    personalProfile.dwSizeOfStruct = sizeof(personalProfile);

    HRESULT hResult = FaxGetSenderInformation(&personalProfile);
    if(S_OK != hResult)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("FaxGetSenderInformation"), hResult);
        return TRUE;
    }

    //
    // A numeric edit control should be LTR
    //
    SetLTREditDirection(m_hWnd, IDC_FAX_NUMBER_VALUE);
    SetLTREditDirection(m_hWnd, IDC_EMAIL_VALUE);
    SetLTREditDirection(m_hWnd, IDC_HOME_PHONE_VALUE);
    SetLTREditDirection(m_hWnd, IDC_BUSINESS_PHONE_VALUE);

    //
    // copy strings into the private structure
    //
    DWORD dwLen;
    TCHAR** tchStrArray =  &(personalProfile.lptstrName);
    for(DWORD dw=0; dw < PERSONAL_PROFILE_STR_NUM; ++dw)
    {
        if(NULL == tchStrArray[dw])
        {
            continue;
        }

        dwLen = _tcslen(tchStrArray[dw]);
        if(0 == dwLen)
        {
            continue;
        }

        m_tchStrArray[dw] = (TCHAR*)MemAlloc(sizeof(TCHAR)*(dwLen+1));
        if(!m_tchStrArray[dw])
        {
            dwRes = ERROR_NOT_ENOUGH_MEMORY;
            CALL_FAIL (MEM_ERR, TEXT("MemAlloc"), dwRes);
            PopupError(dwRes);
            break;
        }

        _tcscpy(m_tchStrArray[dw], tchStrArray[dw]);
    }

    FaxFreeSenderInformation(&personalProfile);

    //
    // display user info
    //
    CEdit* pEdit;
    DWORD dwSize = sizeof(s_PageInfo)/sizeof(s_PageInfo[0]);    
    for(dw=0; dw < dwSize; ++dw)
    {
        //
        // set item value
        //
        pEdit = (CEdit*)GetDlgItem(s_PageInfo[dw].dwValueResId);
        ASSERTION(NULL != pEdit);

        pEdit->SetWindowText(m_tchStrArray[s_PageInfo[dw].eValStrNum]);
        pEdit->SetLimitText(80);
        //
        // Place the caret back at the beginning of the text
        //
        pEdit->SendMessage (EM_SETSEL, 0, 0);
    }

    m_editAddress.SetLimitText(ADDRESS_MAX_LEN);

    m_butOk.EnableWindow(FALSE);    
    
    return TRUE;

} // CUserInfoDlg::OnInitDialog


void 
CUserInfoDlg::OnModify() 
{
    m_butOk.EnableWindow(TRUE); 
}

void 
CUserInfoDlg::OnOK()
{
    DBG_ENTER(TEXT("CUserInfoDlg::OnOK"));

    DWORD dwRes = Save();
    if(ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("Save"),dwRes);
        PopupError(dwRes);
        return;
    }

    CFaxClientDlg::OnOK();
}

DWORD
CUserInfoDlg::Save() 
/*++

Routine name : CUserInfoDlg::Save

Routine description:

    save the settings into the registry

Author:

    Alexander Malysh (AlexMay), Feb, 2000

Arguments:


Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CUserInfoDlg::Save"), dwRes);

    //
    // get user info from UI and save it into FAX_PERSONAL_PROFILE structure
    //
    CWnd *pWnd;
    DWORD dwLen;
    TCHAR tszText[512];
    DWORD dwSize = sizeof(s_PageInfo)/sizeof(s_PageInfo[0]);    
    for(DWORD dw=0; dw < dwSize; ++dw)
    {
        //
        // get item value
        //
        pWnd = GetDlgItem(s_PageInfo[dw].dwValueResId);
        ASSERTION(NULL != pWnd);

        pWnd->GetWindowText(tszText, sizeof(tszText)/sizeof(tszText[0]));

        if(m_tchStrArray[s_PageInfo[dw].eValStrNum])
        {
            if(_tcscmp(m_tchStrArray[s_PageInfo[dw].eValStrNum], tszText) == 0)
            {
                continue;
            }
        }

        MemFree(m_tchStrArray[s_PageInfo[dw].eValStrNum]);
        m_tchStrArray[s_PageInfo[dw].eValStrNum] = NULL;

        dwLen = _tcslen(tszText);
        if(0 == dwLen)
        {
            continue;
        }

        //
        // copy string into FAX_PERSONAL_PROFILE structure
        //
        m_tchStrArray[s_PageInfo[dw].eValStrNum] = (TCHAR*)MemAlloc(sizeof(TCHAR)*(dwLen+1));
        if(!m_tchStrArray[s_PageInfo[dw].eValStrNum])
        {
            dwRes = ERROR_NOT_ENOUGH_MEMORY;
            CALL_FAIL (MEM_ERR, TEXT("MemAlloc"), dwRes);
            break;
        }

        _tcscpy(m_tchStrArray[s_PageInfo[dw].eValStrNum], tszText);
    }

    //
    // save user info into the registry
    //
    HRESULT hResult;
    if(ERROR_SUCCESS == dwRes)
    {
        hResult = FaxSetSenderInformation(&m_PersonalProfile);
        if(S_OK != hResult)
        {
            dwRes = hResult;
            CALL_FAIL (GENERAL_ERR, TEXT("FaxSetSenderInformation"), hResult);
        }
    }


    return dwRes;

} // CUserInfoDlg::Save
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__5C2C92BD_853F_48F7_8067_255E5DA21502__INCLUDED_)
#define AFX_STDAFX_H__5C2C92BD_853F_48F7_8067_255E5DA21502__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#pragma warning (disable : 4786)    // identifier was truncated to 255 characters in the debug information

#define VC_EXTRALEAN        // Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <objbase.h>
#include <afxext.h>         // MFC extensions
#include <afxcview.h>
#include <afxdisp.h>        // MFC Automation classes
#include <afxdtctl.h>       // MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>         // MFC support for Windows Common Controls
#include <afxodlgs.h>       // MFC support for Windows Common Dialogs    
#endif // _AFX_NO_AFXCMN_SUPPORT
#include <afxpriv.h>

#include <mapi.h>

//
// Windows headers:
//
#include <WinSpool.h>
#include <shlwapi.h>
//
// Fax server includes:
//
#include <FaxReg.h>     // Fax registry settings
//
// STL includes:
//
#include <list>
#include <map>
#include <set>
using namespace std;

#include <DebugEx.h>

#include <htmlhelp.h>
#include "..\inc\faxutil.h"
#include "..\build\cvernum.h"
#include "..\tiff\inc\tifflib.h"

//
// Pre-declarations (to prevent include loops):
//
class CClientConsoleDoc;
class CServerNode;
class CFolder;
class CLeftView;
class CFolderListView;
//
// Local includes:
//

#include "resources\res32inc.h"
#include "TreeNode.h"
#include "CmdLineInfo.h"
#include "MainFrm.h"
#include "FaxTime.h"
#include "FaxMsg.h"
#include "Utils.h"
#include "FaxClientPg.h"
#include "FaxClientDlg.h"
#include "ErrorDlg.h"
#include "ClientConsole.h"
#include "Job.h"
#include "Message.h"
#include "ViewRow.h"
#include "SortHeader.h"
#include "Folder.h"
#include "FolderListView.h"
#include "QueueFolder.h"
#include "MessageFolder.h"
#include "LeftView.h"
#include "ServerNode.h"
#include "ClientConsoleDoc.h"
#include "ClientConsoleView.h"
#include "ColumnSelectDlg.h"
#include "ItemPropSheet.h"
#include "MsgPropertyPg.h"
#include "InboxGeneralPg.h"
#include "IncomingGeneralPg.h"
#include "OutboxGeneralPg.h"
#include "SentItemsGeneralPg.h"
#include "PersonalInfoPg.h"
#include "InboxDetailsPg.h"
#include "IncomingDetailsPg.h"
#include "OutboxDetailsPg.h"
#include "SentItemsDetailsPg.h"
#include "UserInfoDlg.h"
#include "FolderDialog.h"
#include "CoverPagesDlg.h"
#include "ServerStatusDlg.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__5C2C92BD_853F_48F7_8067_255E5DA21502__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\resources\dllentry.c ===
#include <windows.h>
#include "res32inc.h"


//
// Global exported resource handle
//
HINSTANCE g_hResDll = NULL;


#ifdef __cplusplus
extern "C"
#endif

HMODULE 
__stdcall
GetResourceHandle()
{
    return g_hResDll;
}

BOOL WINAPI DllMain(HINSTANCE hDLLInst, DWORD  fdwReason, LPVOID lpvReserved)
{
	switch (fdwReason)
	{
		case DLL_PROCESS_ATTACH:
            DisableThreadLibraryCalls(hDLLInst);
            g_hResDll = hDLLInst;
			break;

		case DLL_PROCESS_DETACH:
			break;

		case DLL_THREAD_ATTACH:
			break;

		case DLL_THREAD_DETACH:
			break;
	}
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\viewrow.cpp ===
// ViewRow.cpp: implementation of the CViewRow class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#define __FILE_ID__     31

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//
// The following four arrays of strings are filled during app. startup from 
// the string table resource by calling InitStrings
//
CString CViewRow::m_cstrPriorities[FAX_PRIORITY_TYPE_HIGH+1];
CString CViewRow::m_cstrQueueStatus[NUM_JOB_STATUS];
CString CViewRow::m_cstrQueueExtendedStatus[JS_EX_CALL_ABORTED - JS_EX_DISCONNECTED + 1];
CString CViewRow::m_cstrMessageStatus[2];

int CViewRow::m_Alignments[MSG_VIEW_ITEM_END] = 
{
	 LVCFMT_LEFT,           // MSG_VIEW_ITEM_ICON
     LVCFMT_LEFT,           // MSG_VIEW_ITEM_STATUS
     LVCFMT_LEFT,           // MSG_VIEW_ITEM_SERVER
     LVCFMT_RIGHT,          // MSG_VIEW_ITEM_NUM_PAGES
     LVCFMT_LEFT,           // MSG_VIEW_ITEM_CSID
     LVCFMT_LEFT,           // MSG_VIEW_ITEM_TSID
     LVCFMT_RIGHT,          // MSG_VIEW_ITEM_SIZE
     LVCFMT_LEFT,           // MSG_VIEW_ITEM_DEVICE
     LVCFMT_RIGHT,          // MSG_VIEW_ITEM_RETRIES
     LVCFMT_RIGHT,          // MSG_VIEW_ITEM_ID
     LVCFMT_RIGHT,          // MSG_VIEW_ITEM_BROADCAST_ID
     LVCFMT_LEFT,           // MSG_VIEW_ITEM_CALLER_ID
     LVCFMT_LEFT,           // MSG_VIEW_ITEM_ROUTING_INFO
     LVCFMT_LEFT,           // MSG_VIEW_ITEM_DOC_NAME
     LVCFMT_LEFT,           // MSG_VIEW_ITEM_SUBJECT
     LVCFMT_LEFT,           // MSG_VIEW_ITEM_RECIPIENT_NAME
     LVCFMT_LEFT,           // MSG_VIEW_ITEM_RECIPIENT_NUMBER
     LVCFMT_LEFT,           // MSG_VIEW_ITEM_USER
     LVCFMT_LEFT,           // MSG_VIEW_ITEM_PRIORITY
     LVCFMT_LEFT,           // MSG_VIEW_ITEM_ORIG_TIME
     LVCFMT_LEFT,           // MSG_VIEW_ITEM_SUBMIT_TIME
     LVCFMT_LEFT,           // MSG_VIEW_ITEM_BILLING
     LVCFMT_LEFT,           // MSG_VIEW_ITEM_TRANSMISSION_START_TIME
     LVCFMT_LEFT,           // MSG_VIEW_ITEM_SEND_TIME
     LVCFMT_LEFT,           // MSG_VIEW_ITEM_EXTENDED_STATUS
     LVCFMT_RIGHT,          // MSG_VIEW_ITEM_CURRENT_PAGE
     LVCFMT_LEFT,           // MSG_VIEW_ITEM_SENDER_NAME
     LVCFMT_LEFT,           // MSG_VIEW_ITEM_SENDER_NUMBER
     LVCFMT_LEFT,           // MSG_VIEW_ITEM_TRANSMISSION_END_TIME
     LVCFMT_RIGHT           // MSG_VIEW_ITEM_TRANSMISSION_DURATION
}; 

int CViewRow::m_TitleResources[MSG_VIEW_ITEM_END] = 
{
    IDS_COLUMN_ICON,            // MSG_VIEW_ITEM_ICON,
    IDS_MSG_COLUMN_STATUS,      // MSG_VIEW_ITEM_STATUS,
    IDS_MSG_COLUMN_SERVER,      // MSG_VIEW_ITEM_SERVER,
    IDS_MSG_COLUMN_NUM_PAGES,   // MSG_VIEW_ITEM_NUM_PAGES,
    IDS_MSG_COLUMN_CSID,        // MSG_VIEW_ITEM_CSID,
    IDS_MSG_COLUMN_TSID,        // MSG_VIEW_ITEM_TSID,    
    IDS_MSG_COLUMN_SIZE,        // MSG_VIEW_ITEM_SIZE,
    IDS_MSG_COLUMN_DEVICE,      // MSG_VIEW_ITEM_DEVICE,
    IDS_MSG_COLUMN_RETRIES,     // MSG_VIEW_ITEM_RETRIES,
    IDS_MSG_COLUMN_JOB_ID,      // MSG_VIEW_ITEM_ID,
    IDS_MSG_COLUMN_BROADCAST_ID,// MSG_VIEW_ITEM_BROADCAST_ID
    IDS_MSG_COLUMN_CALLER_ID,   // MSG_VIEW_ITEM_CALLER_ID,
    IDS_MSG_COLUMN_ROUTING_INFO,// MSG_VIEW_ITEM_ROUTING_INFO,
    IDS_MSG_COLUMN_DOC_NAME,    // MSG_VIEW_ITEM_DOC_NAME,
    IDS_MSG_COLUMN_SUBJECT,     // MSG_VIEW_ITEM_SUBJECT,
    IDS_MSG_COLUMN_RECP_NAME,   // MSG_VIEW_ITEM_RECIPIENT_NAME,
    IDS_MSG_COLUMN_RECP_NUM,    // MSG_VIEW_ITEM_RECIPIENT_NUMBER,
    IDS_MSG_COLUMN_USER,        // MSG_VIEW_ITEM_USER,
    IDS_MSG_COLUMN_PRIORITY,    // MSG_VIEW_ITEM_PRIORITY,
    IDS_MSG_COLUMN_ORIG_TIME,   // MSG_VIEW_ITEM_ORIG_TIME,
    IDS_MSG_COLUMN_SUBMIT_TIME, // MSG_VIEW_ITEM_SUBMIT_TIME,
    IDS_MSG_COLUMN_BILLING,     // MSG_VIEW_ITEM_BILLING,
    IDS_MSG_COLUMN_TRANSMISSION_START_TIME, // MSG_VIEW_ITEM_TRANSMISSION_START_TIME,
    IDS_MSG_COLUMN_SEND_TIME,   // MSG_VIEW_ITEM_SEND_TIME,
    IDS_MSG_COLUMN_EX_STATUS,   // MSG_VIEW_ITEM_EXTENDED_STATUS,
    IDS_MSG_COLUMN_CURR_PAGE,   // MSG_VIEW_ITEM_CURRENT_PAGE,
    IDS_MSG_COLUMN_SENDER_NAME, // MSG_VIEW_ITEM_SENDER_NAME,
    IDS_MSG_COLUMN_SENDER_NUM,  // MSG_VIEW_ITEM_SENDER_NUMBER,
    IDS_MSG_COLUMN_TRANSMISSION_END_TIME, // MSG_VIEW_ITEM_TRANSMISSION_END_TIME,
    IDS_MSG_COLUMN_TRANSMISSION_DURATION  // MSG_VIEW_ITEM_TRANSMISSION_DURATION,
};


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

DWORD 
CViewRow::InitStrings ()
/*++

Routine name : CViewRow::InitStrings

Routine description:

    Loads the static strings used to display status etc.
    Static.

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:


Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CViewRow::InitStrings"), dwRes);
    //
    // Load strings used for diaply throughout the application - job status
    //
    int iStatusIds[] = 
    {
        IDS_PENDING,
        IDS_INPROGRESS,
        IDS_DELETING,
        IDS_PAUSED,
        IDS_RETRYING,
        IDS_RETRIES_EXCEEDED,
        IDS_COMPLETED,
        IDS_CANCELED,
        IDS_CANCELING,
        IDS_ROUTING,
        IDS_ROUTING_RETRY,
        IDS_ROUTING_INPROGRESS,
        IDS_ROUTING_FAILED
    };

    for (int i = JOB_STAT_PENDING; i < NUM_JOB_STATUS; i++)
    {
        dwRes = LoadResourceString (m_cstrQueueStatus[i], iStatusIds[i]);
        if (ERROR_SUCCESS != dwRes)
        {
            CALL_FAIL (RESOURCE_ERR, TEXT("LoadResourceString"), dwRes);
            return dwRes;
        }
    }
    //
    // Load strings used for diaply throughout the application - job extended status
    //
    int iExtStatusIds[] = 
    {
        IDS_DISCONNECTED,    
        IDS_INITIALIZING,    
        IDS_DIALING,         
        IDS_TRANSMITTING,    
        IDS_ANSWERED,        
        IDS_RECEIVING,       
        IDS_LINE_UNAVAILABLE,
        IDS_BUSY,            
        IDS_NO_ANSWER,       
        IDS_BAD_ADDRESS,     
        IDS_NO_DIAL_TONE,    
        IDS_FATAL_ERROR,     
        IDS_CALL_DELAYED,    
        IDS_CALL_BLACKLISTED,
        IDS_NOT_FAX_CALL,
		IDS_STATUS_PARTIALLY_RECEIVED,
        IDS_HANDLED,
		IDS_CALL_COMPLETED,
		IDS_CALL_ABORTED
    };           
    for (i = 0; i < sizeof(iExtStatusIds) / sizeof (iExtStatusIds[0]); i++)
    {
        dwRes = LoadResourceString (m_cstrQueueExtendedStatus[i], iExtStatusIds[i]);
        if (ERROR_SUCCESS != dwRes)
        {
            CALL_FAIL (RESOURCE_ERR, TEXT("LoadResourceString"), dwRes);
            return dwRes;
        }
    }
    int iPrioritiyIds[] = 
    {
        IDS_LOW_PRIORITY,
        IDS_NORMAL_PRIORITY,
        IDS_HIGH_PRIORITY
    };

    for (i = FAX_PRIORITY_TYPE_LOW; i <= FAX_PRIORITY_TYPE_HIGH; i++)
    {
        dwRes = LoadResourceString (m_cstrPriorities[i], iPrioritiyIds[i]);
        if (ERROR_SUCCESS != dwRes)
        {
            CALL_FAIL (RESOURCE_ERR, TEXT("LoadResourceString"), dwRes);
            return dwRes;
        }
    }
    dwRes = LoadResourceString (m_cstrMessageStatus[0], IDS_STATUS_SUCCESS);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (RESOURCE_ERR, TEXT("LoadResourceString"), dwRes);
        return dwRes;
    }
    dwRes = LoadResourceString (m_cstrMessageStatus[1], IDS_STATUS_PARTIALLY_RECEIVED);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (RESOURCE_ERR, TEXT("LoadResourceString"), dwRes);
        return dwRes;
    }
    return dwRes;
}   // CViewRow::InitStrings

DWORD    
CViewRow::GetItemTitle (
    DWORD item, 
    CString &cstrRes
) 
/*++

Routine name : CViewRow::GetItemTitle

Routine description:

    Retrieves the title string of an item in the view

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    item            [in ] - Item
    cstrRes         [out] - String buffer

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CViewRow::GetItemTitle"), dwRes);

    ASSERTION (item < MSG_VIEW_ITEM_END);

    dwRes = LoadResourceString (cstrRes, m_TitleResources[item]);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("LoadResourceString"), dwRes);
    }
    return dwRes;

}   // CViewRow::GetItemTitle


DWORD 
CViewRow::DetachFromMsg()
/*++

Routine name : CViewRow::DetachFromMsg

Routine description:

	Ivalidate content, empty all strings

Author:

	Alexander Malysh (AlexMay),	Apr, 2000

Arguments:


Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CViewRow::ResetDisplayStrings"), dwRes);

    m_bAttached = FALSE;
    m_bStringsPreparedForDisplay = FALSE;

    for(DWORD dw=0; dw < MSG_VIEW_ITEM_END; ++dw)
    {
        try
        {
            m_Strings[dw].Empty();
        }
        catch(...)
        {
            dwRes = ERROR_NOT_ENOUGH_MEMORY;
            CALL_FAIL (GENERAL_ERR, TEXT("CString::Empty"), dwRes);
            return dwRes;
        }
    }

    return dwRes;
}


DWORD CViewRow::AttachToMsg(
    CFaxMsg *pMsg,
    BOOL PrepareStrings
)
/*++

Routine name : CViewRow::AttachToMsg

Routine description:

    Attach the view row to an existing message.

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    pMsg            [in] - Message to attach to
    PrepareStrings  [in] - If TRUE, also create internal strings 
                           representation for list display.

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CViewRow::AttachToMsg"), dwRes);

    ASSERTION (pMsg);

    dwRes = DetachFromMsg();
    if(ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("DetachFromMsg"), dwRes);
        return dwRes;
    }

    if (PrepareStrings)
    {
        DWORD dwValidityMask = pMsg->GetValidityMask ();
        try
        {
            //
            // Msg id
            //
            m_Strings[MSG_VIEW_ITEM_ID] = DWORDLONG2String (pMsg->GetId());

            //
            // Msg broadcast id
            //
            m_Strings[MSG_VIEW_ITEM_BROADCAST_ID] = (pMsg->GetBroadcastId() != 0) ? 
                                                    DWORDLONG2String (pMsg->GetBroadcastId()) : TEXT("");

            //
            // Msg size
            //
            if (dwValidityMask & FAX_JOB_FIELD_SIZE)
            {
                dwRes = FaxSizeFormat(pMsg->GetSize(), m_Strings[MSG_VIEW_ITEM_SIZE]);
                if(ERROR_SUCCESS != dwRes)
                {
                    CALL_FAIL (GENERAL_ERR, TEXT("FaxSizeFormat"), dwRes);
                    return dwRes;
                }
            }
            //
            // Page count
            //
            if (dwValidityMask & FAX_JOB_FIELD_PAGE_COUNT)
            {
                m_Strings[MSG_VIEW_ITEM_NUM_PAGES] = DWORD2String (pMsg->GetNumPages());
            }
            //
            // Original scheduled time
            //
            if (dwValidityMask & FAX_JOB_FIELD_ORIGINAL_SCHEDULE_TIME)
            {
                m_Strings[MSG_VIEW_ITEM_ORIG_TIME] = 
                    pMsg->GetOrigTime().FormatByUserLocale ();
            }
            //
            // Submission time
            //
            if (dwValidityMask & FAX_JOB_FIELD_SUBMISSION_TIME)
            {
                m_Strings[MSG_VIEW_ITEM_SUBMIT_TIME] = 
                    pMsg->GetSubmissionTime().FormatByUserLocale ();
            }
            //
            // Transmission start time
            //
            if (dwValidityMask & FAX_JOB_FIELD_TRANSMISSION_START_TIME)
            {
                m_Strings[MSG_VIEW_ITEM_TRANSMISSION_START_TIME] = 
                    pMsg->GetTransmissionStartTime().FormatByUserLocale ();
            }

            //
            // Transmission end time
            //
            if (dwValidityMask & FAX_JOB_FIELD_TRANSMISSION_END_TIME)
            {
                m_Strings[MSG_VIEW_ITEM_TRANSMISSION_END_TIME] = 
                    pMsg->GetTransmissionEndTime().FormatByUserLocale ();
            }

            //
            // Priority
            //
            if (dwValidityMask & FAX_JOB_FIELD_PRIORITY)
            {
                m_Strings[MSG_VIEW_ITEM_PRIORITY] = m_cstrPriorities[pMsg->GetPriority()];
            }
            //
            // Retries
            //
            if (dwValidityMask & FAX_JOB_FIELD_RETRIES)
            {
                m_Strings[MSG_VIEW_ITEM_RETRIES] = DWORD2String (pMsg->GetRetries());
            }
            //
            // Recipient info
            //
            m_Strings[MSG_VIEW_ITEM_RECIPIENT_NUMBER] = pMsg->GetRecipientNumber();

#ifdef UNICODE
            if(theApp.IsRTLUI())
            {
                //
                // Phone number always should be LTR
                // Add LEFT-TO-RIGHT OVERRIDE  (LRO)
                //
                m_Strings[MSG_VIEW_ITEM_RECIPIENT_NUMBER].Insert(0, UNICODE_LRO);
            }
#endif
            m_Strings[MSG_VIEW_ITEM_RECIPIENT_NAME] = pMsg->GetRecipientName();
            //
            // TSID / CSID
            //
            m_Strings[MSG_VIEW_ITEM_TSID] = pMsg->GetTSID();
            m_Strings[MSG_VIEW_ITEM_CSID] = pMsg->GetCSID();
            //
            // User
            //
            m_Strings[MSG_VIEW_ITEM_USER] = pMsg->GetUser();
            //
            // Billing
            //
            m_Strings[MSG_VIEW_ITEM_BILLING] = pMsg->GetBilling();
            //
            // Device
            //
            m_Strings[MSG_VIEW_ITEM_DEVICE] = pMsg->GetDevice();
            //
            // Document
            //
            m_Strings[MSG_VIEW_ITEM_DOC_NAME] = pMsg->GetDocName();
            //
            // Subject
            //
            m_Strings[MSG_VIEW_ITEM_SUBJECT] = pMsg->GetSubject();
            //
            // Caller id
            //
            m_Strings[MSG_VIEW_ITEM_CALLER_ID] = pMsg->GetCallerId();
            //
            // Routing info
            //
            m_Strings[MSG_VIEW_ITEM_ROUTING_INFO] = pMsg->GetRoutingInfo();

            //
            // Server name
            //
            m_Strings[MSG_VIEW_ITEM_SERVER] = pMsg->GetServerName();
            if(m_Strings[MSG_VIEW_ITEM_SERVER].GetLength() == 0)
            {
                dwRes = LoadResourceString(m_Strings[MSG_VIEW_ITEM_SERVER], 
                                           IDS_LOCAL_SERVER);
                if(ERROR_SUCCESS != dwRes)
                {
                    CALL_FAIL (GENERAL_ERR, TEXT("LoadResourceString"), dwRes);
                    return dwRes;
                }                    
            }

            //
            // Icon
            //
            m_Icon = CalcIcon (pMsg);

            dwRes = InitStatusStr(pMsg);
            if(ERROR_SUCCESS != dwRes)
            {
                CALL_FAIL (GENERAL_ERR, TEXT("CViewRow::InitStatusStr"), dwRes);
                return dwRes;
            }                    

            dwRes = InitExtStatusStr(pMsg);
            if(ERROR_SUCCESS != dwRes)
            {
                CALL_FAIL (GENERAL_ERR, TEXT("CViewRow::InitExtStatusStr"), dwRes);
                return dwRes;
            }                    

            if(pMsg->IsKindOf(RUNTIME_CLASS(CArchiveMsg)))
            {                
                //
                // Sender info
                //
                m_Strings[MSG_VIEW_ITEM_SENDER_NUMBER] = pMsg->GetSenderNumber();
#ifdef UNICODE
                if(theApp.IsRTLUI())
                {
                    //
                    // Phone number always should be LTR
                    // Add LEFT-TO-RIGHT OVERRIDE  (LRO)
                    //
                    m_Strings[MSG_VIEW_ITEM_SENDER_NUMBER].Insert(0, UNICODE_LRO);
                }
#endif
                
                m_Strings[MSG_VIEW_ITEM_SENDER_NAME] = pMsg->GetSenderName();

                //
                // Transmission duration
                //
                if ((dwValidityMask & FAX_JOB_FIELD_TRANSMISSION_END_TIME) &&
                    (dwValidityMask & FAX_JOB_FIELD_TRANSMISSION_START_TIME))
                {
                    m_Strings[MSG_VIEW_ITEM_TRANSMISSION_DURATION] = 
                        pMsg->GetTransmissionDuration().FormatByUserLocale ();
                }
            }
            else if(pMsg->IsKindOf(RUNTIME_CLASS(CJob)))
            {
                //
                // Current page
                //
                if (dwValidityMask & FAX_JOB_FIELD_CURRENT_PAGE)
                {
                    m_Strings[MSG_VIEW_ITEM_CURRENT_PAGE] = 
                                            DWORD2String (pMsg->GetCurrentPage());
                }

                //
                // Send time
                //
                if (dwValidityMask & FAX_JOB_FIELD_SCHEDULE_TIME)
                {
                    m_Strings[MSG_VIEW_ITEM_SEND_TIME] = 
                            pMsg->GetScheduleTime().FormatByUserLocale ();
                }
            }
            else
            {
                ASSERTION_FAILURE
            }
        }

        catch (CException &ex)
        {
            TCHAR wszCause[1024];

            ex.GetErrorMessage (wszCause, 1024);
            VERBOSE (EXCEPTION_ERR,
                     TEXT("CJob::Init caused exception : %s"), 
                     wszCause);
            dwRes = ERROR_NOT_ENOUGH_MEMORY;
            return dwRes;
        }
        m_bStringsPreparedForDisplay = TRUE;
    }
    ASSERTION (ERROR_SUCCESS == dwRes);
    m_bAttached = TRUE;
    m_pMsg = pMsg;
    return dwRes;
}   // CViewRow::AttachToMessage

DWORD 
CViewRow::InitStatusStr(
    CFaxMsg *pMsg
)
/*++

Routine name : CViewRow::InitStatusStr

Routine description:

    Init m_Strings[MSG_VIEW_ITEM_STATUS] string with status

Arguments:

    pMsg           [in] - CFaxMsg

Return Value:

    error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CViewRow::InitStatusStr"));

    ASSERTION(pMsg);

    try
    {
        DWORD dwValidityMask = pMsg->GetValidityMask ();

        if(pMsg->IsKindOf(RUNTIME_CLASS(CArchiveMsg)))
        {
            //
            // Status
            //
            switch (pMsg->GetType())
            {
                case JT_RECEIVE:
                    //
                    // Received message
                    //
                    if ((pMsg->GetExtendedStatus ()) == JS_EX_PARTIALLY_RECEIVED)
                    {
                        //
                        // Partially received fax
                        //
                        m_Strings[MSG_VIEW_ITEM_STATUS] = m_cstrMessageStatus[1];
                    }
                    else
                    {
                        //
                        // Fully received fax
                        //
                        m_Strings[MSG_VIEW_ITEM_STATUS] = m_cstrMessageStatus[0];
                    }
                    break;

                case JT_SEND:
                    //
                    // Sent message
                    //
                    m_Strings[MSG_VIEW_ITEM_STATUS] = m_cstrMessageStatus[0];
                    break;

                default:
                    ASSERTION_FAILURE;
                    m_Strings[MSG_VIEW_ITEM_STATUS].Empty ();
                    break;
            }                              
        }
        else if(pMsg->IsKindOf(RUNTIME_CLASS(CJob)))
        {
            //
            // Queue status
            //
            ASSERTION (dwValidityMask & FAX_JOB_FIELD_QUEUE_STATUS);
            JobStatusType stat = pMsg->GetStatus();
            BOOL bValidStatus = TRUE;
            ASSERTION ((stat >= JOB_STAT_PENDING) && (stat < NUM_JOB_STATUS));

            if(pMsg->GetType() == JT_ROUTING)
            {
            switch(stat)
                {
                    case JOB_STAT_INPROGRESS:
                        stat = JOB_STAT_ROUTING_INPROGRESS;
                        break;
                    case JOB_STAT_RETRYING:
                        stat = JOB_STAT_ROUTING_RETRY;
                        break;
                    case JOB_STAT_RETRIES_EXCEEDED:
                        stat = JOB_STAT_ROUTING_FAILED;
                        break;
                    default:
                        //
                        // Future / unknown job status
                        //
                        bValidStatus = FALSE;
                        break;
                };
            }
            if (bValidStatus)
            {
                m_Strings[MSG_VIEW_ITEM_STATUS] = m_cstrQueueStatus[stat];
            }
            else
            {
                //
                // Unknown (future) status - use empty etring
                //
                m_Strings[MSG_VIEW_ITEM_STATUS].Empty();
            }
                
        }
        else
        {
            ASSERTION_FAILURE;
        }
    }
    catch(CException &ex)
    {
        TCHAR szCause[MAX_PATH];

        if(ex.GetErrorMessage(szCause, ARR_SIZE(szCause)))
        {
            VERBOSE (EXCEPTION_ERR, TEXT("%s"), szCause);
        }
        ex.Delete();

        dwRes = ERROR_NOT_ENOUGH_MEMORY;
    }

    return dwRes;
}

DWORD 
CViewRow::InitExtStatusStr(
    CFaxMsg *pMsg
)
/*++

Routine name : CViewRow::InitExtStatusStr

Routine description:

    Init m_Strings[MSG_VIEW_ITEM_EXTENDED_STATUS] string with extended status

Arguments:

    pMsg           [in] - CFaxMsg

Return Value:

    error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CViewRow::InitExtStatusStr"));

    ASSERTION(pMsg);

    try
    {
        DWORD dwValidityMask = pMsg->GetValidityMask ();

        if(pMsg->IsKindOf(RUNTIME_CLASS(CJob)))
        {
            //
            // Extended status
            //
            if ((dwValidityMask & FAX_JOB_FIELD_STATUS_EX))
            {
                //
                // Extended status is reported
                //
                DWORD dwExtStatus = pMsg->GetExtendedStatus ();

                ASSERTION (dwExtStatus >= JS_EX_DISCONNECTED);

                if (dwExtStatus >= JS_EX_PROPRIETARY)
                {
                    //
                    // Proprietary extended status
                    //
                    m_Strings[MSG_VIEW_ITEM_EXTENDED_STATUS] = 
                            pMsg->GetExtendedStatusString();
                    if (m_Strings[MSG_VIEW_ITEM_EXTENDED_STATUS].IsEmpty())
                    {
                        //
                        // No string defined, display numeric value
                        //
                        m_Strings[MSG_VIEW_ITEM_EXTENDED_STATUS].Format (
                                                         TEXT("%ld"), dwExtStatus);
                    }
                }
                else if (dwExtStatus > FAX_API_VER_1_MAX_JS_EX)
                {
                    //
                    // Unknown (future) extended status - use blank string
                    //
                    m_Strings[MSG_VIEW_ITEM_EXTENDED_STATUS].Empty();
                }
                else
                {
                    //
                    // Predefined extended status
                    //
                    m_Strings[MSG_VIEW_ITEM_EXTENDED_STATUS] = 
                                m_cstrQueueExtendedStatus[dwExtStatus - JS_EX_DISCONNECTED];
                }
            }
        }
    }
    catch(CException &ex)
    {
        TCHAR szCause[MAX_PATH];

        if(ex.GetErrorMessage(szCause, ARR_SIZE(szCause)))
        {
            VERBOSE (EXCEPTION_ERR, TEXT("%s"), szCause);
        }
        ex.Delete();

        dwRes = ERROR_NOT_ENOUGH_MEMORY;
    }

    return dwRes;
}


IconType 
CViewRow::CalcIcon(
    CFaxMsg *pMsg
)
{
    DBG_ENTER(TEXT("CViewRow::CalcIcon"));
    ASSERTION(pMsg);

    IconType icon = INVALID;

    if(pMsg->IsKindOf(RUNTIME_CLASS(CArchiveMsg)))
    {
        icon = CalcMessageIcon(pMsg);
    }
    else if(pMsg->IsKindOf(RUNTIME_CLASS(CJob)))
    {
        icon = CalcJobIcon(pMsg);
    }
    else
    {
        ASSERTION_FAILURE
    }
    return icon;
}

IconType 
CViewRow::CalcJobIcon(
    CFaxMsg *pJob
)
{
    DBG_ENTER(TEXT("CViewRow::CalcJobIcon"));
    ASSERTION(pJob);

    int iStatus = pJob->GetStatus();

    ASSERTION (pJob->GetValidityMask() & FAX_JOB_FIELD_STATUS_SUB_STRUCT);
    ASSERTION (pJob->GetValidityMask() && FAX_JOB_FIELD_TYPE);
    switch (pJob->GetType())
    {
        case JT_ROUTING:
            //
            // Routing job
            //
            switch (iStatus)
            {
                case JOB_STAT_PENDING:
                case JOB_STAT_DELETING:
                case JOB_STAT_RETRYING:
                case JOB_STAT_CANCELING:
                case JOB_STAT_INPROGRESS:
                    return LIST_IMAGE_ROUTING;
                    break;

                case JOB_STAT_RETRIES_EXCEEDED:
                    return LIST_IMAGE_ERROR;
                    break;

                default:
                    //
                    // We don't allow MSG_STAT_COMPLETED, MSG_STAT_PAUSED, 
                    // and MSG_STAT_CANCELED.
                    //
                    ASSERTION_FAILURE;
                    return INVALID;
            }
            break;

        case JT_RECEIVE:
            //
            // Receiving job
            //
            switch (iStatus)
            {
                case JOB_STAT_CANCELING:
                case JOB_STAT_INPROGRESS:
                case JOB_STAT_ROUTING:
                    return LIST_IMAGE_RECEIVING;
                    break;

                default:
                    //
                    // We don't allow MSG_STAT_COMPLETED, MSG_STAT_PAUSED, 
                    // MSG_STAT_PENDING, MSG_STAT_DELETING, 
                    // MSG_STAT_RETRYING
                    // MSG_STAT_RETRIES_EXCEEDED,
                    // and MSG_STAT_CANCELED.
                    //
                    ASSERTION_FAILURE;
                    return INVALID;
            }
            break;
        

        case JT_SEND:
            switch (iStatus)
            {
                case JOB_STAT_PENDING:
                case JOB_STAT_DELETING:
                case JOB_STAT_RETRYING:
                case JOB_STAT_CANCELING:
                case JOB_STAT_COMPLETED:
                case JOB_STAT_CANCELED:
                    return LIST_IMAGE_NORMAL_MESSAGE;
                    break;

                case JOB_STAT_RETRIES_EXCEEDED:
                    return LIST_IMAGE_ERROR;
                    break;

                case JOB_STAT_PAUSED:
                    return LIST_IMAGE_PAUSED;
                    break;

                case JOB_STAT_INPROGRESS:
                    return LIST_IMAGE_SENDING;
                    break;

                default:
                    //
                    // Unknown job status
                    //
                    ASSERTION_FAILURE;
                    return INVALID;
            }
            break;

        default:
            ASSERTION_FAILURE;
            return INVALID;
    }
}

IconType 
CViewRow::CalcMessageIcon(
    CFaxMsg *pMsg
)
{
    DBG_ENTER(TEXT("CViewRow::CalcMessageIcon"));
    ASSERTION(pMsg);

    switch (pMsg->GetType())
    {
        case JT_RECEIVE:
            //
            // Received message
            //
            if ((pMsg->GetExtendedStatus ()) == JS_EX_PARTIALLY_RECEIVED)
            {
                //
                // Partially received fax
                //
                return LIST_IMAGE_PARTIALLY_RECEIVED;
            }
            else
            {
                //
                // Fully received fax
                //
                return LIST_IMAGE_SUCCESS;
            }
            break;

        case JT_SEND:
            return LIST_IMAGE_SUCCESS;

        default:
            ASSERTION_FAILURE;
            return INVALID;
    }
}

int      
CViewRow::CompareByItem (
    CViewRow &other, 
    DWORD item
)
/*++

Routine name : CViewRow::CompareByItem

Routine description:

    Compares a list item against another one

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    other           [in] - Other list item
    item            [in] - Item to compare by

Return Value:

    -1 if smaler than other, 0 if identical, +1 if bigger than other

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CViewRow::CompareByItem"));

    ASSERTION (item < MSG_VIEW_ITEM_END);
    ASSERTION (m_bAttached && other.m_bAttached);

    if(other.m_pMsg->IsKindOf(RUNTIME_CLASS(CJob))  !=
             m_pMsg->IsKindOf(RUNTIME_CLASS(CJob)))
    {
        ASSERTION_FAILURE;
        return 1;
    }

    switch (item)
    {
        case MSG_VIEW_ITEM_ICON:
        case MSG_VIEW_ITEM_STATUS:
            dwRes = InitStatusStr(m_pMsg);
            if(ERROR_SUCCESS != dwRes)
            {
                CALL_FAIL (GENERAL_ERR, TEXT("CViewRow::InitStatusStr"), dwRes);
                return 0;
            }                    

            dwRes = other.InitStatusStr(other.m_pMsg);
            if(ERROR_SUCCESS != dwRes)
            {
                CALL_FAIL (GENERAL_ERR, TEXT("CViewRow::InitStatusStr"), dwRes);
                return 0;
            }                    

            return m_Strings[MSG_VIEW_ITEM_STATUS].Compare(other.m_Strings[MSG_VIEW_ITEM_STATUS]);

        case MSG_VIEW_ITEM_EXTENDED_STATUS:
            dwRes = InitExtStatusStr(m_pMsg);
            if(ERROR_SUCCESS != dwRes)
            {
                CALL_FAIL (GENERAL_ERR, TEXT("CViewRow::InitStatusStr"), dwRes);
                return 0;
            }                    

            dwRes = other.InitExtStatusStr(other.m_pMsg);
            if(ERROR_SUCCESS != dwRes)
            {
                CALL_FAIL (GENERAL_ERR, TEXT("CViewRow::InitStatusStr"), dwRes);
                return 0;
            }                    

            return m_Strings[item].Compare(other.m_Strings[item]);

        case MSG_VIEW_ITEM_SERVER:
            return m_pMsg->GetServerName().Compare (other.m_pMsg->GetServerName());

        case MSG_VIEW_ITEM_CSID:
            return m_pMsg->GetCSID().Compare (other.m_pMsg->GetCSID());

        case MSG_VIEW_ITEM_TSID:
            return m_pMsg->GetTSID().Compare (other.m_pMsg->GetTSID());

        case MSG_VIEW_ITEM_DEVICE:
            return m_pMsg->GetDevice().Compare (other.m_pMsg->GetDevice());

        case MSG_VIEW_ITEM_CALLER_ID:
            return m_pMsg->GetCallerId().Compare (other.m_pMsg->GetCallerId());

        case MSG_VIEW_ITEM_ROUTING_INFO:
            return m_pMsg->GetRoutingInfo().Compare (other.m_pMsg->GetRoutingInfo());

        case MSG_VIEW_ITEM_DOC_NAME:
            return m_pMsg->GetDocName().Compare (other.m_pMsg->GetDocName());

        case MSG_VIEW_ITEM_SUBJECT:
            return m_pMsg->GetSubject().Compare (other.m_pMsg->GetSubject());

        case MSG_VIEW_ITEM_RECIPIENT_NAME:
            return m_pMsg->GetRecipientName().Compare (other.m_pMsg->GetRecipientName());

        case MSG_VIEW_ITEM_RECIPIENT_NUMBER:
            return m_pMsg->GetRecipientNumber().Compare (other.m_pMsg->GetRecipientNumber());

        case MSG_VIEW_ITEM_USER:
            return m_pMsg->GetUser().Compare (other.m_pMsg->GetUser());

        case MSG_VIEW_ITEM_PRIORITY:
            return NUMERIC_CMP(m_pMsg->GetPriority(), other.m_pMsg->GetPriority());

        case MSG_VIEW_ITEM_BILLING:
            return m_pMsg->GetBilling().Compare (other.m_pMsg->GetBilling());

        case MSG_VIEW_ITEM_NUM_PAGES:
            return NUMERIC_CMP(m_pMsg->GetNumPages(), other.m_pMsg->GetNumPages());

        case MSG_VIEW_ITEM_CURRENT_PAGE:
            return NUMERIC_CMP(m_pMsg->GetCurrentPage(), other.m_pMsg->GetCurrentPage());

        case MSG_VIEW_ITEM_TRANSMISSION_START_TIME:
            return m_pMsg->GetTransmissionStartTime().Compare (
                        other.m_pMsg->GetTransmissionStartTime());

        case MSG_VIEW_ITEM_SIZE:
            return NUMERIC_CMP(m_pMsg->GetSize(), other.m_pMsg->GetSize());

        case MSG_VIEW_ITEM_RETRIES:
            return NUMERIC_CMP(m_pMsg->GetRetries(), other.m_pMsg->GetRetries());

        case MSG_VIEW_ITEM_ID:
            return NUMERIC_CMP(m_pMsg->GetId(), other.m_pMsg->GetId());

        case MSG_VIEW_ITEM_BROADCAST_ID:
            return NUMERIC_CMP(m_pMsg->GetBroadcastId(), other.m_pMsg->GetBroadcastId());
            
        case MSG_VIEW_ITEM_ORIG_TIME:
            return m_pMsg->GetOrigTime().Compare (
                        other.m_pMsg->GetOrigTime());

        case MSG_VIEW_ITEM_SUBMIT_TIME:
            return m_pMsg->GetSubmissionTime().Compare (
                        other.m_pMsg->GetSubmissionTime());

        case MSG_VIEW_ITEM_SEND_TIME:
            return m_pMsg->GetScheduleTime().Compare (
                        other.m_pMsg->GetScheduleTime());

        case MSG_VIEW_ITEM_SENDER_NAME:
            return m_pMsg->GetSenderName().Compare (other.m_pMsg->GetSenderName());

        case MSG_VIEW_ITEM_SENDER_NUMBER:
            return m_pMsg->GetSenderNumber().Compare (other.m_pMsg->GetSenderNumber());

        case MSG_VIEW_ITEM_TRANSMISSION_END_TIME:
            return m_pMsg->GetTransmissionEndTime().Compare (
                        other.m_pMsg->GetTransmissionEndTime());

        case MSG_VIEW_ITEM_TRANSMISSION_DURATION:
            return m_pMsg->GetTransmissionDuration().Compare (
                        other.m_pMsg->GetTransmissionDuration());

        default:
            ASSERTION_FAILURE;
            return 0;
    }
    ASSERTION_FAILURE;
}   // CViewRow::CompareByItem
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\resources\res32inc.h ===
/* 

  File: res32inc.h

  Abstract: Resource module include file

*/

#ifndef _RES_32_INC_H
#define _RES_32_INC_H

#include "resource.h"

#ifdef __cplusplus
extern "C" {
#endif

HMODULE 
__stdcall
GetResourceHandle();

#ifdef __cplusplus
}
#endif

#endif      // _RES_32_INC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\utils.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    Utils.h

Abstract:

    Provides utility functions for the entire poject

Author:

    Eran Yariv (EranY)  Dec, 1999

Revision History:

--*/

#if !defined(AFX_UTILS_H__6E33CFA1_C99A_4691_9F91_00451692D3DB__INCLUDED_)
#define AFX_UTILS_H__6E33CFA1_C99A_4691_9F91_00451692D3DB__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

DWORD
LoadResourceString (
    CString &cstr,
    int      ResId
);

#define SAFE_DELETE(x)       if (NULL != (x)) { delete   (x); (x) = NULL; }
#define SAFE_DELETE_ARRAY(x) if (NULL != (x)) { delete [](x); (x) = NULL; }

CString DWORDLONG2String (DWORDLONG dwlData);
CString DWORD2String     (DWORD dwData);
CString Win32Error2String(DWORD dwWin32Err);
                  
DWORD LoadDIBImageList (CImageList &, 
                        int iResourceId, 
                        DWORD dwImageWidth,
                        COLORREF crMask);


DWORD WaitForThreadDeathOrShutdown (HANDLE hThread);

DWORD 
GetUniqueFileName (LPCTSTR lpctstrExt, CString &cstrResult);

DWORD CopyTiffFromServer (CServerNode *pServer,
                          DWORDLONG dwlMsgId, 
                          FAX_ENUM_MESSAGE_FOLDER Folder,
                          CString &cstrTiff);

DWORD GetDllVersion (LPCTSTR lpszDllName);

DWORD ReadRegistryString (LPCTSTR lpszSection, LPCTSTR lpszKey, CString& cstrValue);
DWORD WriteRegistryString(LPCTSTR lpszSection, LPCTSTR lpszKey, CString& cstrValue);

DWORD FaxSizeFormat(DWORDLONG dwlSize, CString& cstrValue);

DWORD GetAppLoadPath(CString& cstrLoadPath);


DWORD HtmlHelpTopic(HWND hWnd, TCHAR* tszHelpTopic);
DWORD GetAppHelpFile(TCHAR* tszHelpFile, TCHAR* tszHelpExt);

#define PACKVERSION(major,minor) MAKELONG(minor,major)

struct FaxTempFile
{
	//
	// hWaitHandles[0] handle of application that uses a temp file
	// hWaitHandles[1] handle of shutdown event
	//
    HANDLE hWaitHandles[2];
    TCHAR  tszFileName[MAX_PATH];
    TCHAR  tszOldDefaultPrinter[MAX_PATH];
};

DWORD WINAPI DeleteTmpFileThrdProc(LPVOID lpFileStruct);
DWORD FillInCountryCombo(CComboBox& combo);

BOOL DPGetDefaultPrinter(LPTSTR pPrinterName, LPDWORD pdwBufferSize);
BOOL DPSetDefaultPrinter(LPTSTR pPrinterName);

DWORD GetPrintersInfo(PRINTER_INFO_2*& pPrinterInfo2, DWORD& dwNumPrinters);
DWORD PrinterNameToDisplayStr(TCHAR* pPrinterName, TCHAR* pDisplayStr, DWORD dwStrSize);

UINT_PTR CALLBACK OFNHookProc(HWND, UINT, WPARAM, LPARAM);

int AlignedAfxMessageBox( LPCTSTR lpszText, UINT nType = MB_OK, UINT nIDHelp = 0 );
int AlignedAfxMessageBox( UINT nIDPrompt, UINT nType = MB_OK, UINT nIDHelp = (UINT) -1 );

//
// Import.cpp
//
#ifdef UNICODE

DWORD ImportArchiveFolderUI(LPCWSTR cstrImportFolder, BOOL bSentItems, HWND hWnd);
DWORD DetectImportFiles();

#endif // UNICODE

#endif // !defined(AFX_UTILS_H__6E33CFA1_C99A_4691_9F91_00451692D3DB__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\viewrow.h ===
// ViewRow.h: interface for the CViewRow class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_VIEWROW_H__6BEB111C_C0F4_46DD_A28A_0BFEE31CA6EF__INCLUDED_)
#define AFX_VIEWROW_H__6BEB111C_C0F4_46DD_A28A_0BFEE31CA6EF__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//
// List of ids for images in the image list used for icons in the list view
//
typedef enum
{
    INVALID = -1,
    LIST_IMAGE_PARTIALLY_RECEIVED,
    LIST_IMAGE_NORMAL_MESSAGE,
    LIST_IMAGE_RECEIVING,
    LIST_IMAGE_ROUTING,
    LIST_IMAGE_ERROR,
    LIST_IMAGE_PAUSED,
    LIST_IMAGE_SENDING,
    LIST_IMAGE_SUCCESS,
    LIST_IMAGE_COVERPAGE
} IconType;


// 
// Items available for a view
//
typedef enum 
{
    //
    // common items
    //
	MSG_VIEW_ITEM_ICON,
    MSG_VIEW_ITEM_STATUS,
    MSG_VIEW_ITEM_SERVER,
    MSG_VIEW_ITEM_NUM_PAGES,
    MSG_VIEW_ITEM_CSID,
    MSG_VIEW_ITEM_TSID,    
    MSG_VIEW_ITEM_SIZE,
    MSG_VIEW_ITEM_DEVICE,
    MSG_VIEW_ITEM_RETRIES,
    MSG_VIEW_ITEM_ID,
    MSG_VIEW_ITEM_BROADCAST_ID,
    MSG_VIEW_ITEM_CALLER_ID,
    MSG_VIEW_ITEM_ROUTING_INFO,
    MSG_VIEW_ITEM_DOC_NAME,
    MSG_VIEW_ITEM_SUBJECT,
    MSG_VIEW_ITEM_RECIPIENT_NAME,
    MSG_VIEW_ITEM_RECIPIENT_NUMBER,
    MSG_VIEW_ITEM_USER,
    MSG_VIEW_ITEM_PRIORITY,
    MSG_VIEW_ITEM_ORIG_TIME,
    MSG_VIEW_ITEM_SUBMIT_TIME,
    MSG_VIEW_ITEM_BILLING,
    MSG_VIEW_ITEM_TRANSMISSION_START_TIME,
    //
    // job specific
    //
    MSG_VIEW_ITEM_SEND_TIME,
    MSG_VIEW_ITEM_EXTENDED_STATUS,
    MSG_VIEW_ITEM_CURRENT_PAGE,
    //
    // message specific
    //
    MSG_VIEW_ITEM_SENDER_NAME,
    MSG_VIEW_ITEM_SENDER_NUMBER,
    MSG_VIEW_ITEM_TRANSMISSION_END_TIME,
    MSG_VIEW_ITEM_TRANSMISSION_DURATION,
    //
    // End of list (unused)
    //
    MSG_VIEW_ITEM_END    
} MsgViewItemType;


class CViewRow  
{
public:
    CViewRow() : 
        m_pMsg(NULL),
        m_bAttached(FALSE),
        m_bStringsPreparedForDisplay(FALSE)
        {}
    virtual ~CViewRow() {}

    DWORD AttachToMsg(CFaxMsg *pMsg, BOOL PrepareStrings=TRUE);

    int CompareByItem (CViewRow &other, DWORD item);

    IconType GetIcon () const
        { ASSERT (m_bAttached); return m_Icon; }

    static  DWORD InitStrings ();

    static  DWORD GetItemTitle (DWORD, CString &);

    static int GetItemAlignment (DWORD item)
        { ASSERT (item >=0 && item < MSG_VIEW_ITEM_END); return m_Alignments[item]; }

    const CString &GetItemString (DWORD item) const
        { 
            ASSERT (m_bAttached && item >=0 && item < MSG_VIEW_ITEM_END); 
            ASSERT (MSG_VIEW_ITEM_ICON != item);
            ASSERT (m_bStringsPreparedForDisplay);
            return m_Strings[item]; 
        }

    static BOOL IsItemIcon (DWORD item)
        { return (MSG_VIEW_ITEM_ICON == item); }

protected:
    CFaxMsg* m_pMsg;

    BOOL       m_bAttached;     // Are we attached to the job / message?
    IconType   m_Icon;          // Icon id of job / message

    BOOL       m_bStringsPreparedForDisplay;      // Is m_Strings valid?

    CString    m_Strings[MSG_VIEW_ITEM_END]; // String representation of 
                                             // item's data
  
    static CString m_cstrPriorities[FAX_PRIORITY_TYPE_HIGH+1];
    static CString m_cstrQueueStatus[NUM_JOB_STATUS];
    static CString m_cstrQueueExtendedStatus[JS_EX_CALL_ABORTED - JS_EX_DISCONNECTED + 1];
    static CString m_cstrMessageStatus[2];

    static int m_Alignments[MSG_VIEW_ITEM_END];
    static int m_TitleResources[MSG_VIEW_ITEM_END];

    DWORD DetachFromMsg();

    IconType CalcIcon(CFaxMsg *pMsg);

private:
    IconType CalcJobIcon(CFaxMsg *pJob);
    IconType CalcMessageIcon(CFaxMsg *pMsg);

    DWORD InitStatusStr(CFaxMsg *pMsg);
    DWORD InitExtStatusStr(CFaxMsg *pMsg);

};

#endif // !defined(AFX_VIEWROW_H__6BEB111C_C0F4_46DD_A28A_0BFEE31CA6EF__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\utils.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    Utils.cpp

Abstract:

    Provides utility functions for the entire poject

Author:

    Eran Yariv (EranY)  Dec, 1999

Revision History:

--*/

#include "stdafx.h"
#define __FILE_ID__     10


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern CClientConsoleApp theApp;


DWORD
LoadResourceString (
    CString &cstr,
    int      ResId
)
/*++

Routine name : LoadResourceString

Routine description:

    Loads a string from the resource

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    cstr            [out] - String buffer
    ResId           [in ] - String resource id

Return Value:

    Standard win32 error code

--*/
{
    BOOL bRes;
    DWORD dwRes = ERROR_SUCCESS;

    try
    {
        bRes = cstr.LoadString (ResId);
    }
    catch (CMemoryException &ex)
    {
        DBG_ENTER(TEXT("LoadResourceString"), dwRes);
        TCHAR wszCause[1024];

        ex.GetErrorMessage (wszCause, 1024);
        VERBOSE (EXCEPTION_ERR,
                 TEXT("CString::LoadString caused exception : %s"), 
                 wszCause);
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        PopupError (dwRes);
        return dwRes;
    }
    if (!bRes)
    {
        dwRes = ERROR_NOT_FOUND;
        PopupError (dwRes);
        return dwRes;
    }
    return dwRes;
}   // LoadResourceString

CString 
DWORDLONG2String (
    DWORDLONG dwlData
)
/*++

Routine name : DWORDLONG2String

Routine description:

    Converts a 64-bit unsigned number to string

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    dwlData         [in] - Number to convert

Return Value:

    Output string

--*/
{
    CString cstrResult;
    cstrResult.Format (TEXT("0x%016I64x"), dwlData);
    return cstrResult;
}   // DWORDLONG2String


CString 
DWORD2String (
    DWORD dwData
)
/*++

Routine name : DWORD2String

Routine description:

    Converts a 32-bit unsigned number to string

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    dwData          [in] - Number to convert

Return Value:

    Output string

--*/
{
    CString cstrResult;
    cstrResult.Format (TEXT("%ld"), dwData);
    return cstrResult;
}   // DWORD2String


CString 
Win32Error2String (
    DWORD dwWin32Err
)
/*++

Routine name : Win32Error2String

Routine description:

    Format a Win32 error code to a string

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    dwWin32Err          [in] - Win32 error code

Return Value:

    Result string

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("Win32Error2String"));

    LPTSTR  lpszError=NULL;
    //
    // Create descriptive error text
    //
    if (!FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER |
                        FORMAT_MESSAGE_FROM_SYSTEM,
                        NULL,
                        dwWin32Err,
                        0,
                        (TCHAR *)&lpszError,
                        0,
                        NULL))
    {
        //
        // Failure to format the message
        //
        dwRes = GetLastError ();
        CALL_FAIL (RESOURCE_ERR, TEXT("FormatMessage"), dwRes);
        PopupError (dwRes);
        AfxThrowResourceException ();
    }
    CString cstrResult;
    try
    {
        cstrResult = lpszError;
    }
    catch (CException *pEx)
    {
        LocalFree (lpszError);
        throw (pEx);
    }
    LocalFree (lpszError);
    return cstrResult;
}   // Win32Error2String



DWORD 
LoadDIBImageList (
    CImageList &iml, 
    int iResourceId, 
    DWORD dwImageWidth,
    COLORREF crMask
)
/*++

Routine name : LoadDIBImageList

Routine description:

    Loads an image list from the resource, retaining 24-bit colors

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    iml             [out] - Image list buffer
    iResourceId     [in ] - Image list bitmap resource id
    dwImageWidth    [in ] - Image width (pixels)
    crMask          [in ] - Color key (transparent mask)

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("LoadDIBImageList"), dwRes);

    HINSTANCE hInst = AfxFindResourceHandle(MAKEINTRESOURCE(iResourceId), RT_BITMAP);
    if (hInst)
    {
        HIMAGELIST hIml = ImageList_LoadImage ( hInst,
                                                MAKEINTRESOURCE(iResourceId),
                                                dwImageWidth,
                                                0,
                                                crMask,
                                                IMAGE_BITMAP,
                                                LR_DEFAULTCOLOR);
        if (hIml)
        {
            if (!iml.Attach (hIml))
            {
                dwRes = ERROR_GEN_FAILURE;
                CALL_FAIL (WINDOW_ERR, TEXT("CImageList::Attach"), dwRes);
                DeleteObject (hIml);
            }
        }
        else
        {
            //
            //  ImageList_LoadImage() failed
            //
            dwRes = GetLastError();
            CALL_FAIL (WINDOW_ERR, _T("ImageList_LoadImage"), dwRes);
        }
    }
    else
    {
        //
        //  AfxFindResourceHandle() failed
        //
        dwRes = GetLastError();
        CALL_FAIL (WINDOW_ERR, _T("AfxFindResourceHandle"), dwRes);
    }
    return dwRes;
}   // LoadDIBImageList



#define BUILD_THREAD_DEATH_TIMEOUT INFINITE


DWORD 
WaitForThreadDeathOrShutdown (
    HANDLE hThread
)
/*++

Routine name : WaitForThreadDeathOrShutdown

Routine description:

    Waits for a thread to end.
    Also processes windows messages in the background.
    Stops waiting if the application is shutting down.

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    hThread         [in] - Handle to thread

Return Value:

    Standard Win23 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("WaitForThreadDeathOrShutdown"), dwRes);

    for (;;)
    {
        //
        // We wait on the thread handle and the shutdown event (which ever comes first)
        //
        HANDLE hWaitHandles[2];
        hWaitHandles[0] = hThread;
        hWaitHandles[1] = CClientConsoleDoc::GetShutdownEvent ();
        if (NULL == hWaitHandles[1])
        {
            //
            // We're shutting down
            //
            return dwRes;
        }
        DWORD dwStart = GetTickCount ();
        VERBOSE (DBG_MSG,
                 TEXT("Entering WaitForMultipleObjects (timeout = %ld)"), 
                 BUILD_THREAD_DEATH_TIMEOUT);
        //
        // Wait now....
        //
        dwRes = MsgWaitForMultipleObjects(
                   sizeof (hWaitHandles) / sizeof(hWaitHandles[0]), // Num of wait objects
                   hWaitHandles,                                    // Array of wait objects
                   FALSE,                                           // Wait for either one
                   BUILD_THREAD_DEATH_TIMEOUT,                      // Timeout
                   QS_ALLINPUT);                                    // Accept messages

        DWORD dwRes2 = GetLastError();
        VERBOSE (DBG_MSG, 
                 TEXT("Leaving WaitForMultipleObjects after waiting for %ld millisecs"),
                 GetTickCount() - dwStart);
        switch (dwRes)
        {
            case WAIT_FAILED:
                dwRes = dwRes2;
                if (ERROR_INVALID_HANDLE == dwRes)
                {
                    //
                    // The thread is dead
                    //
                    VERBOSE (DBG_MSG, TEXT("Thread is dead (ERROR_INVALID_HANDLE)"));
                    dwRes = ERROR_SUCCESS;
                }
                goto exit;

            case WAIT_OBJECT_0:
                //
                // The thread is not running
                //
                VERBOSE (DBG_MSG, TEXT("Thread is dead (WAIT_OBJECT_0)"));
                dwRes = ERROR_SUCCESS;
                goto exit;

            case WAIT_OBJECT_0 + 1:
                //
                // Shutdown is now in progress
                //
                VERBOSE (DBG_MSG, TEXT("Shutdown in progress"));
                dwRes = ERROR_SUCCESS;
                goto exit;

            case WAIT_OBJECT_0 + 2:
                //
                // System message (WM_xxx) in our queue
                //
                MSG msg;
                
                if (TRUE == ::GetMessage (&msg, NULL, NULL, NULL))
                {
                    VERBOSE (DBG_MSG, 
                             TEXT("System message (0x%x)- deferring to AfxWndProc"),
                             msg.message);

                    CMainFrame *pFrm = GetFrm();
                    if (!pFrm)
                    {
                        //
                        //  Shutdown in progress
                        //
                        goto exit;
                    }

                    if (msg.message != WM_KICKIDLE && 
                        !pFrm->PreTranslateMessage(&msg))
                    {
                        ::TranslateMessage(&msg);
                        ::DispatchMessage(&msg);
                    }
                }
                else
                {
                    //
                    // Got WM_QUIT
                    //
                    AfxPostQuitMessage (0);
                    dwRes = ERROR_SUCCESS;
                    goto exit;
                }
                break;

            case WAIT_TIMEOUT:
                //
                // Thread won't die !!!
                //
                VERBOSE (DBG_MSG, 
                         TEXT("Wait timeout (%ld millisecs)"), 
                         BUILD_THREAD_DEATH_TIMEOUT);
                goto exit;

            default:
                //
                // What's this???
                //
                VERBOSE (DBG_MSG, 
                         TEXT("Unknown error (%ld)"), 
                         dwRes);
                ASSERTION_FAILURE;
                goto exit;
        }
    }
exit:
    return dwRes;
}   // WaitForThreadDeathOrShutdown

DWORD 
GetUniqueFileName (
    LPCTSTR lpctstrExt,
    CString &cstrResult
)
/*++

Routine name : GetUniqueFileName

Routine description:

    Generates a unique file name

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    lpctstrExt   [in]     - File extension
    cstrResult   [out]    - Result file name

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("GetUniqueFileName"), dwRes);

    TCHAR szDir[MAX_PATH];
    //
    // Get path to temp dir
    //
    if (!GetTempPath (MAX_PATH, szDir))
    {
        dwRes = GetLastError ();
        CALL_FAIL (FILE_ERR, TEXT("GetTempPath"), dwRes);
        return dwRes;
    }
    //
    // Try out indices - start with a random index and advance (cyclic) by 1.
    // We're calling rand() 3 times here because we want to get a larger
    // range than 0..RAND_MAX (=32768)
    //
    DWORD dwStartIndex = DWORD((DWORDLONG)(rand()) * 
                                (DWORDLONG)(rand()) * 
                                (DWORDLONG)(rand())
                              );
    for (DWORD dwIndex = dwStartIndex+1; dwIndex != dwStartIndex; dwIndex++)
    {
        try
        {
            cstrResult.Format (TEXT("%s%s%08x%08x.%s"),
                               szDir,
                               CONSOLE_PREVIEW_TIFF_PREFIX,
                               GetCurrentProcessId(),
                               dwIndex,
                               lpctstrExt);
        }
        catch (CMemoryException &ex)
        {
            TCHAR wszCause[1024];

            ex.GetErrorMessage (wszCause, 1024);
            VERBOSE (EXCEPTION_ERR,
                     TEXT("CString::Format caused exception : %s"), 
                     wszCause);
            dwRes = ERROR_NOT_ENOUGH_MEMORY;
            return dwRes;
        }
        HANDLE hFile = CreateFile(  cstrResult,
                                    GENERIC_WRITE,
                                    FILE_SHARE_READ,
                                    NULL,
                                    CREATE_NEW,
                                    FILE_ATTRIBUTE_NORMAL | FILE_ATTRIBUTE_TEMPORARY,
                                    NULL);
        if (INVALID_HANDLE_VALUE == hFile)
        {
            dwRes = GetLastError ();
            if (ERROR_FILE_EXISTS == dwRes)
            {
                //
                // Try next index id
                //
                dwRes = ERROR_SUCCESS;
                continue;
            }
            CALL_FAIL (FILE_ERR, TEXT("CreateFile"), dwRes);
            return dwRes;
        }
        //
        // Success - close the file (leave it with size 0)
        //
        CloseHandle (hFile);
        return dwRes;
    }
    //
    // We just scanned 4GB file names and all were busy - impossible.
    //
    ASSERTION_FAILURE;
    dwRes = ERROR_GEN_FAILURE;
    return dwRes;
}   // GetUniqueFileName

DWORD 
CopyTiffFromServer (
    CServerNode *pServer,
    DWORDLONG dwlMsgId, 
    FAX_ENUM_MESSAGE_FOLDER Folder,
    CString &cstrTiff
)
/*++

Routine name : CopyTiffFromServer

Routine description:

    Copies a TIFF file from the server's archive / queue

Author:

    Eran Yariv (EranY), Jan, 2000

Arguments:

    pServer       [in]     - Pointer to the server node
    dwlMsgId      [in]     - Id of job / message
    Folder        [in]     - Folder of message / job
    cstrTiff      [out]    - Name of TIFF file that arrived from the server

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("CopyTiffFromServer"), dwRes);

    //
    // Create a temporary file name for the TIFF
    //
    dwRes = GetUniqueFileName (FAX_TIF_FILE_EXT, cstrTiff);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("GetUniqueFileName"), dwRes);
        return dwRes;
    }
    HANDLE hFax;
    dwRes = pServer->GetConnectionHandle (hFax);
    if (ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("CServerNode::GetConnectionHandle"), dwRes);
        goto exit;
    }
    {
        START_RPC_TIME(TEXT("FaxGetMessageTiff")); 
        if (!FaxGetMessageTiff (hFax,
                                dwlMsgId,
                                Folder,
                                cstrTiff))
        {
            dwRes = GetLastError ();
            END_RPC_TIME(TEXT("FaxGetMessageTiff")); 
            pServer->SetLastRPCError (dwRes);
            CALL_FAIL (RPC_ERR, TEXT("FaxGetMessageTiff"), dwRes);
            goto exit;
        }
        END_RPC_TIME(TEXT("FaxGetMessageTiff")); 
    }

    ASSERTION (ERROR_SUCCESS == dwRes);    

exit:
    if (ERROR_SUCCESS != dwRes)
    {
        DeleteFile (cstrTiff);
    }
    return dwRes;
}   // CopyTiffFromServer

DWORD 
GetDllVersion (
    LPCTSTR lpszDllName
)
/*++

Routine Description:
    Returns the version information for a DLL exporting "DllGetVersion".
    DllGetVersion is exported by the shell DLLs (specifically COMCTRL32.DLL).
      
Arguments:

    lpszDllName - The name of the DLL to get version information from.

Return Value:

    The version is retuned as DWORD where:
    HIWORD ( version DWORD  ) = Major Version
    LOWORD ( version DWORD  ) = Minor Version
    Use the macro PACKVERSION to comapre versions.
    If the DLL does not export "DllGetVersion" the function returns 0.
    
--*/
{
    DWORD dwVersion = 0;
    DBG_ENTER(TEXT("GetDllVersion"), dwVersion, TEXT("%s"), lpszDllName);

    HINSTANCE hinstDll;

    hinstDll = LoadLibrary(lpszDllName);
	
    if(hinstDll)
    {
        DLLGETVERSIONPROC pDllGetVersion;
        pDllGetVersion = (DLLGETVERSIONPROC) GetProcAddress(hinstDll, "DllGetVersion");
        // Because some DLLs may not implement this function, you
        // must test for it explicitly. Depending on the particular 
        // DLL, the lack of a DllGetVersion function may
        // be a useful indicator of the version.
        if(pDllGetVersion)
        {
            DLLVERSIONINFO dvi;
            HRESULT hr;

            ZeroMemory(&dvi, sizeof(dvi));
            dvi.cbSize = sizeof(dvi);

            hr = (*pDllGetVersion)(&dvi);

            if(SUCCEEDED(hr))
            {
                dwVersion = PACKVERSION(dvi.dwMajorVersion, dvi.dwMinorVersion);
            }
        }
        FreeLibrary(hinstDll);
    }
    return dwVersion;
}   // GetDllVersion


DWORD 
ReadRegistryString(
    LPCTSTR lpszSection, // in
    LPCTSTR lpszKey,     // in
    CString& cstrValue   // out
)
/*++

Routine name : ReadRegistryString

Routine description:

	read string from registry

Author:

	Alexander Malysh (AlexMay),	Feb, 2000

Arguments:

	lpszSection                   [in]     - section
	lpszKey                       [in]     - key
	out                           [out]    - value

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("ReadRegistryString"), dwRes);

    HKEY hKey;
    dwRes = RegOpenKeyEx( HKEY_CURRENT_USER, lpszSection, 0, KEY_QUERY_VALUE, &hKey);
    if(ERROR_SUCCESS != dwRes)
    {
       CALL_FAIL (GENERAL_ERR, TEXT("RegOpenKeyEx"), dwRes);
       return dwRes;
    }

    DWORD dwType;
    TCHAR  tchData[1024];
    DWORD dwDataSize = sizeof(tchData);
    dwRes = RegQueryValueEx( hKey, lpszKey, 0, &dwType, (BYTE*)tchData, &dwDataSize);
    if(ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("RegQueryValueEx"), dwRes);
        goto exit;
    }

    if(REG_SZ != dwType)
    {
        dwRes = ERROR_BADDB;
        goto exit;
    }

    try
    {
        cstrValue = tchData;
    }
    catch(...)
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        CALL_FAIL (MEM_ERR, TEXT("CString::operator="), dwRes);
        goto exit;
    }

exit:
    dwRes = RegCloseKey( hKey );
    if(ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("RegCloseKey"), dwRes);
        return dwRes;
    }

    return dwRes;

} // ReadRegistryString

DWORD 
WriteRegistryString(
    LPCTSTR lpszSection, // in
    LPCTSTR lpszKey,     // in
    CString& cstrValue   // in
)
/*++

Routine name : WriteRegistryString

Routine description:

	write string to the regostry

Author:

	Alexander Malysh (AlexMay),	Feb, 2000

Arguments:

	lpszSection                   [in]     - section
	lpszKey                       [in]     - key
	out                           [in]     - value

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("WriteRegistryString"), dwRes);

    HKEY hKey;
    dwRes = RegOpenKeyEx( HKEY_CURRENT_USER, lpszSection, 0, KEY_SET_VALUE, &hKey);
    if(ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("RegOpenKeyEx"), dwRes);
        return dwRes;
    }

    LPCTSTR lpData = (LPCTSTR)cstrValue;
    dwRes = RegSetValueEx( hKey, 
                           lpszKey, 
                           0, 
                           REG_SZ, 
                           (BYTE*)lpData, 
                           (1 + cstrValue.GetLength()) * sizeof (TCHAR));
    if(ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("RegSetValueEx"), dwRes);
        goto exit;
    }

exit:
    dwRes = RegCloseKey( hKey );
    if(ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("RegCloseKey"), dwRes);
        return dwRes;
    }

    return dwRes;

} // WriteRegistryString


DWORD 
FaxSizeFormat(
    DWORDLONG dwlSize, // in
    CString& cstrValue // out
)
/*++

Routine name : FaxSizeFormat

Routine description:

	format string of file size

Author:

	Alexander Malysh (AlexMay),	Feb, 2000

Arguments:

	wdlSize                       [in]     - size
	out                           [out]    - formatted string

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("FaxSizeFormat"), dwRes);

	if(dwlSize > 0 && dwlSize < 1024)
	{
		dwlSize = 1;
	}
	else
	{
		dwlSize = dwlSize / (DWORDLONG)1024;
	}

    try
    {
        cstrValue.Format (TEXT("%I64d"), dwlSize);
    }
    catch(...)
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        CALL_FAIL (MEM_ERR, TEXT("CString::Format"), dwRes);
        return dwRes;
    }

    //
    // format the number
    //
    int nFormatRes;
    TCHAR tszNumber[100];
    nFormatRes = GetNumberFormat(LOCALE_USER_DEFAULT,  // locale
                                 0,                    // options
                                 cstrValue,            // input number string
                                 NULL,                 // formatting information
                                 tszNumber,            // output buffer
                                 sizeof(tszNumber) / sizeof(tszNumber[0]) // size of output buffer
                                );
    if(0 == nFormatRes)
    {
        dwRes = GetLastError();
        CALL_FAIL (GENERAL_ERR, TEXT("GetNumberFormat"), dwRes);
        return dwRes;
    }

    //
    // get decimal separator
    //
    TCHAR tszDec[10];
    nFormatRes = GetLocaleInfo(LOCALE_USER_DEFAULT,      // locale identifier
                               LOCALE_SDECIMAL,          // information type
                               tszDec,                   // information buffer
                               sizeof(tszDec) / sizeof(tszDec[0]) // size of buffer
                              );
    if(0 == nFormatRes)
    {
        dwRes = GetLastError();
        CALL_FAIL (GENERAL_ERR, TEXT("GetLocaleInfo"), dwRes);
        return dwRes;
    }

    //
    // cut the string on the decimal separator
    //
    TCHAR* pSeparator = _tcsstr(tszNumber, tszDec);
    if(NULL != pSeparator)
    {
        *pSeparator = TEXT('\0');
    }

    try
    {
        TCHAR szFormat[64] = {0}; 
#ifdef UNICODE
        if(theApp.IsRTLUI())
        {
            //
            // Size field always should be LTR
            // Add LEFT-TO-RIGHT OVERRIDE  (LRO)
            //
            szFormat[0] = UNICODE_LRO;
        }
#endif
        _tcscat(szFormat, TEXT("%s KB"));

        cstrValue.Format (szFormat, tszNumber);
    }
    catch(...)
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        CALL_FAIL (MEM_ERR, TEXT("CString::Format"), dwRes);
        return dwRes;
    }
    
    return dwRes;

} // FaxSizeFormat


DWORD 
HtmlHelpTopic(
    HWND hWnd, 
    TCHAR* tszHelpTopic
)
/*++

Routine name : HtmlHelpTopic

Routine description:

	open HTML Help topic

Author:

	Alexander Malysh (AlexMay),	Mar, 2000

Arguments:

	hWnd                          [in]     - window handler
	tszHelpTopic                  [in]     - help topic

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("HtmlHelpTopic"), dwRes);
    ASSERTION(tszHelpTopic);

    //
    // get help file name
    //
    TCHAR tszHelpFile[2*MAX_PATH];
    dwRes = GetAppHelpFile(tszHelpFile, FAX_HTML_HELP_EXT);
    if(ERROR_SUCCESS != dwRes)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("GetAppHelpFile"), dwRes);
        return dwRes;
    }

    //
    // append help topic to the help file name
    //
    _tcscat(tszHelpFile, tszHelpTopic);

    SetLastError(0);
    HtmlHelp(NULL, tszHelpFile, HH_DISPLAY_TOPIC, NULL);

    if(ERROR_DLL_NOT_FOUND == GetLastError())
    {
        AlignedAfxMessageBox(IDS_ERR_NO_HTML_HELP);
    }

    return dwRes;
}


DWORD 
GetAppHelpFile(
    TCHAR* tszHelpFile, 
    TCHAR* tszHelpExt
)
/*++

Routine name : GetAppHelpFile

Routine description:

	get application help file name
    tszHelpFile should be minimum MAX_PATH

Author:

	Alexander Malysh (AlexMay),	Mar, 2000

Arguments:

	tszHelpFile                   [out]    - help file name
	tszHelpExt                    [in]     - help file extension

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("GetAppHelpFile"), dwRes);
    ASSERTION(tszHelpFile);
    ASSERTION(tszHelpExt);

    _stprintf(tszHelpFile, TEXT("%s.%s"), theApp.m_pszExeName, tszHelpExt);

    return dwRes;

} // GetAppHelpFile

DWORD 
GetAppLoadPath(
    CString& cstrLoadPath
)
/*++

Routine name : GetAppLoadPath

Routine description:

	The directory from which the application loaded

Author:

	Alexander Malysh (AlexMay),	Feb, 2000

Arguments:

	cstrLoadPath                  [out]    - the directory

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("GetAppLoadPath"), dwRes);

    TCHAR tszFullPath[MAX_PATH+1];
    DWORD dwGetRes = GetModuleFileName(NULL, 
                                       tszFullPath, 
                                       sizeof(tszFullPath)/sizeof(tszFullPath[0])
                                       );
    if(0 == dwGetRes)
    {
        dwRes = GetLastError();
        CALL_FAIL (FILE_ERR, TEXT("GetModuleFileName"), dwRes);
        return dwRes;
    }

    //
    // cut file name
    //
    TCHAR* ptchFile = _tcsrchr(tszFullPath, TEXT('\\'));
    ASSERTION(ptchFile);

    ptchFile = _tcsinc(ptchFile);
    *ptchFile = TEXT('\0');

    try
    {
        cstrLoadPath = tszFullPath;
    }
    catch(...)
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        CALL_FAIL (MEM_ERR, TEXT("CString::operator="), dwRes);
        return dwRes;
    }

    return dwRes;

} // GetAppLoadPath



DWORD 
FillInCountryCombo(
	CComboBox& combo
)
/*++

Routine name : FillInCountryCombo

Routine description:

	fill in combo box with countries names from TAPI

Author:

	Alexander Malysh (AlexMay),	Mar, 2000

Arguments:

	combo                         [in/out] - combo box

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("FillInCountryCombo"), dwRes);

	//
	// load TAPI32.DLL
	//
	HINSTANCE hInstTapi = ::LoadLibrary(TEXT("TAPI32.DLL"));
	if(NULL == hInstTapi)
	{
		dwRes = GetLastError();
        CALL_FAIL (GENERAL_ERR, TEXT("LoadLibrary(\"TAPI32.DLL\")"), dwRes);
		return dwRes;
	}

	DWORD dw;
	DWORD dwIndex;
	TCHAR* szCountryName;

	LONG lRes;
	BYTE* pBuffer = NULL;
	DWORD dwBuffSize = 22*1024;
	LINECOUNTRYLIST*  pLineCountryList = NULL;
	LINECOUNTRYENTRY* pCountryEntry = NULL;

	DWORD dwVersion = TAPI_CURRENT_VERSION;

	//
	// get appropriate lineGetCountry function address
	//
	LONG (WINAPI *pfnLineGetCountry)(DWORD, DWORD, LPLINECOUNTRYLIST);
#ifdef UNICODE
	(FARPROC&)pfnLineGetCountry = GetProcAddress(hInstTapi, "lineGetCountryW");
#else
	(FARPROC&)pfnLineGetCountry = GetProcAddress(hInstTapi, "lineGetCountryA");
	if (NULL == pfnLineGetCountry)
	{
		//
		// we assume that the TAPI version is 1.4
		// in TAPI version 0x00010004 there is only lineGetCountry function
		//
		dwVersion = 0x00010004;
		(FARPROC&)pfnLineGetCountry = GetProcAddress(hInstTapi, "lineGetCountry");
	}
#endif
	if (NULL == pfnLineGetCountry)
	{
		dwRes = GetLastError();
        CALL_FAIL (GENERAL_ERR, TEXT("GetProcAddress(\"lineGetCountry\")"), dwRes);
		goto exit;
	}
	
	while(TRUE)
	{
		//
		// allocate a buffer for country list
		//
		try
		{
			pBuffer = new BYTE[dwBuffSize]; 
		}
		catch(...)
		{
			dwRes = ERROR_NOT_ENOUGH_MEMORY;
			CALL_FAIL (MEM_ERR, TEXT("new BYTE[dwBuffSize]"), dwRes);
			return dwRes;
		}

		pLineCountryList = (LINECOUNTRYLIST*)pBuffer;
		pLineCountryList->dwTotalSize = dwBuffSize;

		//
		// get TAPI country list
		//
		lRes = pfnLineGetCountry((DWORD)0, dwVersion, pLineCountryList);
		if((pLineCountryList->dwNeededSize > dwBuffSize) &&
		   (0 == lRes || LINEERR_STRUCTURETOOSMALL == lRes))
		{
			//
			// need more memory
			//
			dwBuffSize = pLineCountryList->dwNeededSize + 1;
			SAFE_DELETE_ARRAY(pBuffer);
			continue;
		}
				
		if(0 != lRes)
		{
			dwRes = ERROR_CAN_NOT_COMPLETE;
			CALL_FAIL(GENERAL_ERR, TEXT("lineGetCountry"), dwRes);
			goto exit;
		}

		//
		// success
		//
		break;				
	}

	pCountryEntry = (LINECOUNTRYENTRY*)(pBuffer + pLineCountryList->dwCountryListOffset);

	//
	// iterate into country list and fill in the combo box
	//
	for(dw=0; dw < pLineCountryList->dwNumCountries; ++dw)
	{
		szCountryName = (TCHAR*)(pBuffer + pCountryEntry[dw].dwCountryNameOffset);

		dwIndex = combo.AddString(szCountryName);
		if(CB_ERR == dwIndex)
		{
			dwRes = ERROR_CAN_NOT_COMPLETE;
	        CALL_FAIL(WINDOW_ERR, TEXT("CConboBox::AddString"), dwRes);
			break;
		}
		if(CB_ERRSPACE == dwIndex)
		{
			dwRes = ERROR_NOT_ENOUGH_MEMORY;
	        CALL_FAIL(MEM_ERR, TEXT("CConboBox::AddString"), dwRes);
			break;
		}
	}

exit:
	SAFE_DELETE_ARRAY(pBuffer);

	if(!FreeLibrary(hInstTapi))
	{
		dwRes = GetLastError();
		CALL_FAIL (GENERAL_ERR, TEXT("FreeLibrary (TAPI32.DLL)"), dwRes);
	}

	return dwRes;

} // FillInCountryCombo


//
// From MSDN: ID: Q246772 
//
// Size of internal buffer used to hold "printername,drivername,portname"
// string. Increasing this may be necessary for huge strings.
//
#define MAXBUFFERSIZE 250
//
/*----------------------------------------------------------------*/ 
/* DPGetDefaultPrinter                                            */ 
/*                                                                */ 
/* Parameters:                                                    */ 
/*   pPrinterName: Buffer alloc'd by caller to hold printer name. */ 
/*   pdwBufferSize: On input, ptr to size of pPrinterName.        */ 
/*          On output, min required size of pPrinterName.         */ 
/*                                                                */ 
/* NOTE: You must include enough space for the NULL terminator!   */ 
/*                                                                */ 
/* Returns: TRUE for success, FALSE for failure.                  */ 
/*----------------------------------------------------------------*/ 
BOOL DPGetDefaultPrinter(LPTSTR pPrinterName, LPDWORD pdwBufferSize)
{
    BOOL bFlag;
    OSVERSIONINFO osv = {0};
    TCHAR cBuffer[MAXBUFFERSIZE];
    PRINTER_INFO_2 *ppi2 = NULL;
    DWORD dwNeeded = 0;
    DWORD dwReturned = 0;
  
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("DPGetDefaultPrinter"), dwRes);

  // What version of Windows are you running?
  osv.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
  GetVersionEx(&osv);
  
  // If Windows 95 or 98, use EnumPrinters...
  if (osv.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
  {
    // The first EnumPrinters() tells you how big our buffer should
    // be in order to hold ALL of PRINTER_INFO_2. Note that this will
    // usually return FALSE. This only means that the buffer (the 4th
    // parameter) was not filled in. You don't want it filled in here...
    EnumPrinters(PRINTER_ENUM_DEFAULT, NULL, 2, NULL, 0, &dwNeeded, &dwReturned);
    if (dwNeeded == 0) 
    {
        return FALSE;
    }
    
    // Allocate enough space for PRINTER_INFO_2...
    ppi2 = (PRINTER_INFO_2 *)GlobalAlloc(GPTR, dwNeeded);
    if (!ppi2)
    {
        return FALSE;
    }
    
    // The second EnumPrinters() will fill in all the current information...
    bFlag = EnumPrinters(PRINTER_ENUM_DEFAULT, NULL, 2, (LPBYTE)ppi2, dwNeeded, &dwNeeded, &dwReturned);
    if (!bFlag)
    {
        GlobalFree(ppi2);
        return FALSE;
    }
    
    // If given buffer too small, set required size and fail...
    if ((DWORD)lstrlen(ppi2->pPrinterName) >= *pdwBufferSize)
    {
        *pdwBufferSize = (DWORD)lstrlen(ppi2->pPrinterName) + 1;
        GlobalFree(ppi2);
        return FALSE;
    }
    
    // Copy printer name into passed-in buffer...
    lstrcpy(pPrinterName, ppi2->pPrinterName);
    
    // Set buffer size parameter to min required buffer size...
    *pdwBufferSize = (DWORD)lstrlen(ppi2->pPrinterName) + 1;
  }
  
  // If Windows NT, use the GetDefaultPrinter API for Windows 2000,
  // or GetProfileString for version 4.0 and earlier...
  else if (osv.dwPlatformId == VER_PLATFORM_WIN32_NT)
  {
    if (osv.dwMajorVersion >= 5) // Windows 2000 or later
    {
        HMODULE hSpooler = ::LoadLibrary(TEXT("winspool.drv"));
        if(!hSpooler)
        {
			dwRes = GetLastError();
	        CALL_FAIL(GENERAL_ERR, TEXT("LoadLibrary(winspool.drv)"), dwRes);
            return FALSE;
        }

        BOOL (*pfnGetDefaultPrinter)(LPTSTR, LPDWORD);
        (FARPROC&)pfnGetDefaultPrinter = GetProcAddress(hSpooler, "GetDefaultPrinterW");
        if(!pfnGetDefaultPrinter)
        {
			dwRes = GetLastError();
	        CALL_FAIL(GENERAL_ERR, TEXT("GetProcAddress(GetDefaultPrinter)"), dwRes);

            FreeLibrary(hSpooler);
            return FALSE;
        }

        if(!pfnGetDefaultPrinter(pPrinterName, pdwBufferSize))
        {
			dwRes = GetLastError();
	        CALL_FAIL(GENERAL_ERR, TEXT("GetDefaultPrinter"), dwRes);

            FreeLibrary(hSpooler);
            return FALSE;
        }

        FreeLibrary(hSpooler);
    }    
    else // NT4.0 or earlier
    {
      // Retrieve the default string from Win.ini (the registry).
      // String will be in form "printername,drivername,portname".
      if (GetProfileString(TEXT("windows"), 
                           TEXT("device"), 
                           TEXT(",,,"), 
                           cBuffer, 
                           MAXBUFFERSIZE) <= 0)
      {
        return FALSE;
      }
      
      // Printer name precedes first "," character...
      _tcstok(cBuffer, TEXT(","));
      
      // If given buffer too small, set required size and fail...
      if ((DWORD)lstrlen(cBuffer) >= *pdwBufferSize)
      {
        *pdwBufferSize = (DWORD)lstrlen(cBuffer) + 1;
        return FALSE;
      }
      
      // Copy printer name into passed-in buffer...
      lstrcpy(pPrinterName, cBuffer);
      
      // Set buffer size parameter to min required buffer size...
      *pdwBufferSize = (DWORD)lstrlen(cBuffer) + 1;
    }
  }
  
  // Cleanup...
  if (ppi2)
    GlobalFree(ppi2);
  
  return TRUE;
}

#undef MAXBUFFERSIZE

//
// From MSDN: ID: Q246772 
//
/*-----------------------------------------------------------------*/ 
/* DPSetDefaultPrinter                                             */ 
/*                                                                 */ 
/* Parameters:                                                     */ 
/*   pPrinterName: Valid name of existing printer to make default. */ 
/*                                                                 */ 
/* Returns: TRUE for success, FALSE for failure.                   */ 
/*-----------------------------------------------------------------*/ 
BOOL DPSetDefaultPrinter(LPTSTR pPrinterName)
{
    BOOL bFlag;
    OSVERSIONINFO osv = {0};
    DWORD dwNeeded = 0;
    HANDLE hPrinter = NULL;
    PRINTER_INFO_2 *ppi2 = NULL;
    LPTSTR pBuffer = NULL;
  
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("DPSetDefaultPrinter"), dwRes);

  // What version of Windows are you running?
  osv.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
  GetVersionEx(&osv);
  
  if (!pPrinterName)
  {
        return FALSE;
  }
  
  // If Windows 95 or 98, use SetPrinter...
  if (osv.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
  {
    // Open this printer so you can get information about it...
    bFlag = OpenPrinter(pPrinterName, &hPrinter, NULL);
    if (!bFlag || !hPrinter)
    {
      return FALSE;
    }
    
    // The first GetPrinter() tells you how big our buffer should
    // be in order to hold ALL of PRINTER_INFO_2. Note that this will
    // usually return FALSE. This only means that the buffer (the 3rd
    // parameter) was not filled in. You don't want it filled in here...
    GetPrinter(hPrinter, 2, 0, 0, &dwNeeded);
    if (dwNeeded == 0)
    {
      ClosePrinter(hPrinter);
      return FALSE;
    }
    
    // Allocate enough space for PRINTER_INFO_2...
    ppi2 = (PRINTER_INFO_2 *)GlobalAlloc(GPTR, dwNeeded);
    if (!ppi2)
    {
      ClosePrinter(hPrinter);
      return FALSE;
    }
    
    // The second GetPrinter() will fill in all the current information
    // so that all you need to do is modify what you're interested in...
    bFlag = GetPrinter(hPrinter, 2, (LPBYTE)ppi2, dwNeeded, &dwNeeded);
    if (!bFlag)
    {
      ClosePrinter(hPrinter);
      GlobalFree(ppi2);
      return FALSE;
    }
    
    // Set default printer attribute for this printer...
    ppi2->Attributes |= PRINTER_ATTRIBUTE_DEFAULT;
    bFlag = SetPrinter(hPrinter, 2, (LPBYTE)ppi2, 0);
    if (!bFlag)
    {
      ClosePrinter(hPrinter);
      GlobalFree(ppi2);
      return FALSE;
    }
  }
  
  // If Windows NT, use the SetDefaultPrinter API for Windows 2000,
  // or WriteProfileString for version 4.0 and earlier...
  else if (osv.dwPlatformId == VER_PLATFORM_WIN32_NT)
  {
    if (osv.dwMajorVersion >= 5) // Windows 2000 or later...
    {
        HMODULE hSpooler = ::LoadLibrary(TEXT("winspool.drv"));
        if(!hSpooler)
        {
			dwRes = GetLastError();
	        CALL_FAIL(GENERAL_ERR, TEXT("LoadLibrary(winspool.drv)"), dwRes);
            return FALSE;
        }

        BOOL (*pfnSetDefaultPrinter)(LPTSTR);
        (FARPROC&)pfnSetDefaultPrinter = GetProcAddress(hSpooler, "SetDefaultPrinterW");
        if(!pfnSetDefaultPrinter)
        {
			dwRes = GetLastError();
	        CALL_FAIL(GENERAL_ERR, TEXT("GetProcAddress(SetDefaultPrinter)"), dwRes);

            FreeLibrary(hSpooler);
            return FALSE;
        }

        if(!pfnSetDefaultPrinter(pPrinterName))
        {
			dwRes = GetLastError();
	        CALL_FAIL(GENERAL_ERR, TEXT("SetDefaultPrinter"), dwRes);

            FreeLibrary(hSpooler);
            return FALSE;
        }

        FreeLibrary(hSpooler);
    }    
    else // NT4.0 or earlier...
    {
      // Open this printer so you can get information about it...
      bFlag = OpenPrinter(pPrinterName, &hPrinter, NULL);
      if (!bFlag || !hPrinter)
        return FALSE;
      
      // The first GetPrinter() tells you how big our buffer should
      // be in order to hold ALL of PRINTER_INFO_2. Note that this will
      // usually return FALSE. This only means that the buffer (the 3rd
      // parameter) was not filled in. You don't want it filled in here...
      GetPrinter(hPrinter, 2, 0, 0, &dwNeeded);
      if (dwNeeded == 0)
      {
        ClosePrinter(hPrinter);
        return FALSE;
      }
      
      // Allocate enough space for PRINTER_INFO_2...
      ppi2 = (PRINTER_INFO_2 *)GlobalAlloc(GPTR, dwNeeded);
      if (!ppi2)
      {
        ClosePrinter(hPrinter);
        return FALSE;
      }
      
      // The second GetPrinter() fills in all the current<BR/>
      // information...
      bFlag = GetPrinter(hPrinter, 2, (LPBYTE)ppi2, dwNeeded, &dwNeeded);
      if ((!bFlag) || (!ppi2->pDriverName) || (!ppi2->pPortName))
      {
        ClosePrinter(hPrinter);
        GlobalFree(ppi2);
        return FALSE;
      }
      
      // Allocate buffer big enough for concatenated string.
      // String will be in form "printername,drivername,portname"...
      pBuffer = (LPTSTR)GlobalAlloc(GPTR,
        lstrlen(pPrinterName) +
        lstrlen(ppi2->pDriverName) +
        lstrlen(ppi2->pPortName) + 3);
      if (!pBuffer)
      {
        ClosePrinter(hPrinter);
        GlobalFree(ppi2);
        return FALSE;
      }
      
      // Build string in form "printername,drivername,portname"...
      lstrcpy(pBuffer, pPrinterName);  lstrcat(pBuffer, TEXT(","));
      lstrcat(pBuffer, ppi2->pDriverName);  lstrcat(pBuffer, TEXT(","));
      lstrcat(pBuffer, ppi2->pPortName);
      
      // Set the default printer in Win.ini and registry...
      bFlag = WriteProfileString(TEXT("windows"), TEXT("device"), pBuffer);
      if (!bFlag)
      {
        ClosePrinter(hPrinter);
        GlobalFree(ppi2);
        GlobalFree(pBuffer);
        return FALSE;
      }
    }    
  }
  
  // Cleanup...
  if (hPrinter)
    ClosePrinter(hPrinter);
  if (ppi2)
    GlobalFree(ppi2);
  if (pBuffer)
    GlobalFree(pBuffer);
  
  return TRUE;
} 

DWORD
GetPrintersInfo(
    PRINTER_INFO_2*& pPrinterInfo2,
    DWORD& dwNumPrinters
)
/*++

Routine name : GetPrintersInfo

Routine description:

	enumerate printers and get printers info

Author:

	Alexander Malysh (AlexMay),	Feb, 2000

Arguments:

	pPrinterInfo2                 [out]    - printer info structure array
	dwNumPrinters                 [out]    - number of printers

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("GetPrintersInfo"), dwRes);

    //
    // First call, just collect required sizes
    //
    DWORD dwRequiredSize;
    if (!EnumPrinters ( PRINTER_ENUM_LOCAL | PRINTER_ENUM_CONNECTIONS,
                        NULL,   // Local server
                        2,      // Info level
                        NULL,   // Initial buffer
                        0,      // Initial buffer size
                        &dwRequiredSize,
                        &dwNumPrinters))
    {
        DWORD dwEnumRes = GetLastError ();
        if (ERROR_INSUFFICIENT_BUFFER != dwEnumRes)
        {
            dwRes = dwEnumRes;
            CALL_FAIL (RESOURCE_ERR, TEXT("EnumPrinters"), dwRes);
            return dwRes;
        }
    }
    //
    // Allocate buffer for printers list
    //
    try
    {
        pPrinterInfo2 = (PRINTER_INFO_2 *) new BYTE[dwRequiredSize];
    }
    catch (...)
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY; 
        CALL_FAIL (MEM_ERR, TEXT("new BYTE[dwRequiredSize]"), dwRes);
        return dwRes;
    }
    //
    // 2nd call, get the printers list
    //
    if (!EnumPrinters ( PRINTER_ENUM_LOCAL | PRINTER_ENUM_CONNECTIONS,
                        NULL,                       // Local server
                        2,                          // Info level
                        (LPBYTE)pPrinterInfo2,      // Buffer
                        dwRequiredSize,             // Buffer size
                        &dwRequiredSize,
                        &dwNumPrinters))
    {
        dwRes = GetLastError ();
        CALL_FAIL (RESOURCE_ERR, TEXT("EnumPrinters"), dwRes);
        SAFE_DELETE_ARRAY (pPrinterInfo2);
        return dwRes;
    }

    if (!dwNumPrinters) 
    {
        VERBOSE(DBG_MSG, TEXT("No printers in this machine"));
    }

    return dwRes;

} // GetPrintersInfo


DWORD 
PrinterNameToDisplayStr(
    TCHAR* pPrinterName, 
    TCHAR* pDisplayStr,
    DWORD  dwStrSize
)
/*++

Routine name : PrinterNameToDisplayStr

Routine description:

	convert printer name to display name
    "\\server\printer" -> "printer on server"

Arguments:

	pPrinterName    [in]     - printer name
	pDisplayStr     [out]    - converted name, should be MAX_PATH
    dwStrSize       [in]     - pDisplayStr size

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DBG_ENTER(TEXT("PrinterNameToDisplayStr"), dwRes);

    ASSERTION(pPrinterName);
    ASSERTION(pDisplayStr);
    ASSERTION(_tcslen(pPrinterName) < MAX_PATH-1);

    TCHAR* ptr1 = pPrinterName;
    TCHAR* ptr2;
    TCHAR  tszServer[MAX_PATH];
    TCHAR  tszPrinter[MAX_PATH];
    TCHAR  tszFormat[MAX_PATH];

    _tcsncpy(pDisplayStr, pPrinterName, dwStrSize);

    if(_tcsnccmp(ptr1, TEXT("\\\\"), 2) != 0)
    {
        return dwRes;
    }
        
    ptr1 = _tcsninc(ptr1, 2);
    _tcscpy(tszServer, ptr1);

    ptr1 = _tcschr(tszServer, TEXT('\\'));
    if(!ptr1)
    {
        return dwRes;
    }

    ptr2 = _tcsinc(ptr1);
    _tcscpy(tszPrinter, ptr2);

    //
    // replase '\' with 0
    //
    _tcsnset(ptr1, TEXT('\0'), 1);

    if(_tcslen(tszServer) == 0 ||  _tcslen(tszPrinter) == 0)
    {
        return dwRes;
    }

    if(!LoadString(GetResourceHandle(), 
                   IDS_PRINTER_NAME_FORMAT,
                   tszFormat,
                   sizeof(tszFormat)/sizeof(TCHAR)))
    {
        dwRes = GetLastError ();
        CALL_FAIL (RESOURCE_ERR, TEXT("LoadString"), dwRes);
        return dwRes;
    }

    _sntprintf(pDisplayStr, dwStrSize, tszFormat, tszPrinter, tszServer);
   
    return dwRes;

} // PrinterNameToDisplayStr
UINT_PTR 
CALLBACK 
OFNHookProc(
  HWND hdlg,      // handle to child dialog box
  UINT uiMsg,     // message identifier
  WPARAM wParam,  // message parameter
  LPARAM lParam   // message parameter
)
/*++

Routine name : OFNHookProc

Routine description:

    Callback function that is used with the 
    Explorer-style Open and Save As dialog boxes.
    Refer MSDN for more info.

--*/
{
    UINT_PTR nRes = 0;

    if(WM_NOTIFY == uiMsg)
    {
        LPOFNOTIFY pOfNotify = (LPOFNOTIFY)lParam;
        if(CDN_FILEOK == pOfNotify->hdr.code)
        {
            if(_tcslen(pOfNotify->lpOFN->lpstrFile) > (MAX_PATH-10))
            {
                AlignedAfxMessageBox(IDS_SAVE_AS_TOO_LONG, MB_OK | MB_ICONEXCLAMATION);
                SetWindowLong(hdlg, DWLP_MSGRESULT, 1);
                nRes = 1;
            }
        }
    }
    return nRes;
}

int 
AlignedAfxMessageBox( 
    LPCTSTR lpszText, 
    UINT    nType, 
    UINT    nIDHelp
)
/*++

Routine name : AlignedAfxMessageBox

Routine description:

    Display message box with correct reading order

Arguments:

    AfxMessageBox() arguments

Return Value:

    MessageBox() result

--*/
{
    if(IsRTLUILanguage())
    {
        nType |= MB_RTLREADING | MB_RIGHT; 
    }

    return AfxMessageBox(lpszText, nType, nIDHelp);
}

int 
AlignedAfxMessageBox( 
    UINT nIDPrompt, 
    UINT nType, 
    UINT nIDHelp
)
/*++

Routine name : AlignedAfxMessageBox

Routine description:

    Display message box with correct reading order

Arguments:

    AfxMessageBox() arguments

Return Value:

    MessageBox() result

--*/
{
    if(IsRTLUILanguage())
    {
        nType |= MB_RTLREADING | MB_RIGHT;
    }

    return AfxMessageBox(nIDPrompt, nType, nIDHelp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\clientconsole\resources\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Copy of clientconsole.rc
//
#define IDD_ABOUTBOX                    100
#define ID_VIEW_ARRANGE                 127
#define IDR_MAINFRAME                   128
#define IDB_TREE_IMAGES                 130
#define IDB_LIST_IMAGES                 131
#define ID_VIEW_REFRESH_FOLDER          132
#define IDD_ERROR                       135
#define IDD_COLUMN_SELECT               136
#define IDR_ICON_ERROR                  137
#define IDC_STATIC_AVAILABLE            138
#define IDC_STATIC_DISPLAYED            139
#define IDC_BUT_ADD                     140
#define IDC_BUT_REMOVE                  141
#define IDC_BUT_UP                      142
#define IDC_BUT_DOWN                    143
#define IDC_LIST_DISPLAYED              144
#define IDC_LIST_AVAILABLE              145
#define ID_VIEW_SELECT_COLUMNS          146
#define ID_INDICATOR_FOLDER_ITEMS_COUNT 147
#define ID_INDICATOR_ACTIVITY           148
#define IDB_DOC_ICON                    149
#define IDD_OUTBOX_GENERAL              150
#define IDD_INCOMING_GENERAL            151
#define IDD_SENT_ITEMS_GENERAL          152
#define IDD_INBOX_GENERAL               153
#define IDD_PERSONAL_INFO               154
#define IDD_INBOX_DETAILS               155
#define IDD_INCOMING_DETAILS            156
#define IDD_OUTBOX_DETAILS              157
#define IDD_SENT_ITEMS_DETAILS          158
#define IDD_COPY_CP_FROM_SRV            159
#define ID_SEND_NEW_FAX                 160
#define ID_ADD_NEW_FAX_PRINTER          161
#define ID_REMOVE_FAX_PRINTER           162
#define ID_VIEW_OPTIONS                 163
#define IDD_OPTIONS_USER_INFO           165
#define IDI_USER_INFO                   167
#define IDI_OPTIONS                     168
#define IDD_ADDRESS                     169
#define IDD_COVER_PAGES                 170
#define IDI_SRV_WRN                     171
#define IDI_SRV_OK                      172
#define IDI_SRV_WAIT                    173
#define ID_RECEIVE_NEW_FAX              174
#define IDD_IMPORT                      175
#define IDI_ICON_INFO                   176
#define IDD_IMPORT_INFO                 177
#define IDC_ERROR_TEXT                  1001
#define IDC_SEPERATOR                   1003
#define IDC_DETAILS_DATA                1004
#define IDC_DETAILS                     1005
#define IDM_OUTBOX                      1006
#define IDM_INCOMING                    1007
#define IDM_INBOX                       1008
#define IDM_SENTITEMS                   1009
#define ID_FOLDER_ITEM_VIEW             1010
#define ID_FOLDER_ITEM_PRINT            1011
#define ID_FOLDER_ITEM_PAUSE            1012
#define ID_FOLDER_ITEM_RESUME           1013
#define ID_FOLDER_ITEM_RESTART          1014
#define ID_FOLDER_ITEM_PROPERTIES       1015
#define ID_FOLDER_ITEM_DELETE           1016
#define ID_FOLDER_ITEM_COPY             1017
#define ID_FOLDER_ITEM_MAIL_TO          1018
#define ID_SELECT_ALL                   1019
#define ID_SELECT_NONE                  1020
#define ID_SELECT_INVERT                1021
#define ID_FOLDER_ITEM_RENAME           1022
#define ID_REFRESH_SERVER_STATUS        1023
#define IDC_DOC_NAME_TITLE              1100
#define IDC_DOC_NAME_VALUE              1101
#define IDC_SUBJECT_TITLE               1102
#define IDC_SUBJECT_VALUE               1103
#define IDC_RECIPIENT_NAME_TITLE        1104
#define IDC_RECIPIENT_NAME_VALUE        1105
#define IDC_RECIPIENT_NUMBER_TITLE      1106
#define IDC_RECIPIENT_NUMBER_VALUE      1107
#define IDC_STATUS_TITLE                1108
#define IDC_STATUS_VALUE                1109
#define IDC_EXTENDED_STATUS_TITLE       1110
#define IDC_EXTENDED_STATUS_VALUE       1111
#define IDC_PAGES_TITLE                 1112
#define IDC_PAGES_VALUE                 1113
#define IDC_CURRENT_PAGE_TITLE          1114
#define IDC_CURRENT_PAGE_VALUE          1115
#define IDC_USER_TITLE                  1116
#define IDC_USER_VALUE                  1117
#define IDC_PRIORITY_TITLE              1118
#define IDC_PRIORITY_VALUE              1119
#define IDC_CSID_TITLE                  1120
#define IDC_CSID_VALUE                  1121
#define IDC_TSID_TITLE                  1122
#define IDC_TSID_VALUE                  1123
#define IDC_SCHEDULED_TIME_TITLE        1124
#define IDC_SCHEDULED_TIME_VALUE        1125
#define IDC_CALLER_ID_TITLE             1126
#define IDC_CALLER_ID_VALUE             1127
#define IDC_SIZE_TITLE                  1128
#define IDC_SIZE_VALUE                  1129
#define IDC_DEVICE_TITLE                1130
#define IDC_DEVICE_VALUE                1131
#define IDC_ROUTING_INFO_TITLE          1132
#define IDC_ROUTING_INFO_VALUE          1133
#define IDC_JOB_ID_TITLE                1134
#define IDC_JOB_ID_VALUE                1135
#define IDC_SUBMISSION_TIME_TITLE       1136
#define IDC_SUBMISSION_TIME_VALUE       1137
#define IDC_SENDER_NAME_TITLE           1138
#define IDC_TRANSMISSION_TIME_TITLE     1139
#define IDC_TRANSMISSION_TIME_VALUE     1140
#define IDC_SENDER_NAME_VALUE           1141
#define IDC_BILLING_CODE_TITLE          1142
#define IDC_BILLING_CODE_VALUE          1143
#define IDC_START_TIME_TITLE            1144
#define IDC_START_TIME_VALUE            1145
#define IDC_END_TIME_TITLE              1146
#define IDC_NAME_TITLE                  1147
#define IDC_END_TIME_VALUE              1148
#define IDC_NAME_VALUE                  1149
#define IDC_DURATION_TITLE              1150
#define IDC_FAX_NUMBER_TITLE            1151
#define IDC_DURATION_VALUE              1152
#define IDC_FAX_NUMBER_VALUE            1153
#define IDC_SENDER_NUMBER_TITLE         1154
#define IDC_COMPANY_TITLE               1155
#define IDC_SENDER_NUMBER_VALUE         1156
#define IDC_COMPANY_VALUE               1157
#define IDC_STREET_VALUE                1159
#define IDC_CITY_TITLE                  1160
#define IDC_CITY_VALUE                  1161
#define IDC_STATE_TITLE                 1162
#define IDC_STATE_VALUE                 1163
#define IDC_ZIP_CODE_TITLE              1164
#define IDC_ZIP_CODE_VALUE              1165
#define IDC_COUNTRY_TITLE               1166
#define IDC_COUNTRY_VALUE               1167
#define IDC_TITLE_TITLE                 1168
#define IDC_TITLE_VALUE                 1169
#define IDC_DEPARTMENT_TITLE            1170
#define IDC_DEPARTMENT_VALUE            1171
#define IDC_OFFICE_TITLE                1172
#define IDC_OFFICE_VALUE                1173
#define IDC_HOME_PHONE_TITLE            1174
#define IDC_HOME_PHONE_VALUE            1175
#define IDC_BUSINESS_PHONE_TITLE        1176
#define IDC_BUSINESS_PHONE_VALUE        1177
#define IDC_EMAIL_TITLE                 1180
#define IDC_EMAIL_VALUE                 1181
#define IDC_RETRIES_TITLE               1182
#define IDC_RETRIES_VALUE               1183
#define IDC_STATIC_DOC_INFO             1200
#define IDC_STATIC_STATUS               1201
#define IDC_STATIC_TRANS_INFO           1202
#define IDC_STATIC_PERSONAL             1203
#define IDC_STATIC_ADDRESS              1204
#define IDC_EDIT_TEST                   1205
#define ID_COV_PAGE_NEW                 1208
#define IDC_SELECT_CP_FOR_COPY          1211
#define IDC_LIST_CP                     1212
#define IDM_TREE_ROOT_OPTIONS           1213
#define IDC_COVER_PAGES_DIR             1215
#define IDC_BUT_CP_BROWSE               1216
#define IDC_CONFIRMATIONS               1217
#define IDC_CONFIRM_ITEM_DELETION       1218
#define IDC_CONFIRM_PRINTER_REMOVAL     1220
#define IDC_COVER_PAGES_LOCATION        1221
#define IDC_USER_INFO                   1222
#define IDC_STATIC_USER_INFO            1223
#define IDC_BUT_ADDRESS                 1225
#define IDC_ADDRESS_TITLE               1226
#define IDC_ADDRESS_VALUE               1227
#define IDM_OUTBOX_FOLDER               1228
#define IDM_INCOMING_FOLDER             1229
#define ID_QUEUE_BLOCK                  1230
#define ID_QUEUE_UNBLOCK                1231
#define ID_QUEUE_PAUSE                  1232
#define ID_QUEUE_RESUME                 1233
#define ID_QUEUE_DELETE_ALL_FAXES       1234
#define ID_VIEW_COVER_PAGES             1235
#define ID_TOOLS_USER_INFO              1236
#define IDC_CP_OPEN                     1238
#define IDC_CP_NEW                      1239
#define IDC_CP_RENAME                   1240
#define IDC_CP_DELETE                   1241
#define IDC_CP_ADD                      1244
#define IDD_SERVER_STATUS               1245
#define IDC_LIST_SERVER                 1246
#define ID_VIEW_SERVER_STATUS           1247
#define IDC_ABOUT_PRODUCT               1248
#define IDC_ABOUT_VERSION               1249
#define IDC_ABOUT_COPYRIGHT             1250
#define IDC_BROADCAST_ID_TITLE          1251
#define IDC_BROADCAST_ID_VALUE          1252
#define ID_TOOLS_CONFIG_WIZARD          1301
#define ID_TOOLS_ADMIN_CONSOLE          1302
#define ID_TOOLS_FAX_PRINTER_PROPS      1303
#define ID_TOOLS_MONITOR                1304
#define ID_IMPORT_INBOX                 1310
#define ID_IMPORT_SENT                  1311
#define IDC_BUTTON1                     1311
#define IDC_IMPORT_FOLDER               1312
#define IDC_IMPORT_PROGRESS_BAR         1313
#define IDC_PROGRESS_NUMBER             1314
#define IDC_IMPORT_HELP_LINK            1315
#define IDB_ERROR_IMG                   32515
#define ID_DOCUMENT_RESUME              32771
#define IDS_TREE_NODE_INBOX             57605
#define IDS_TREE_NODE_SENT_ITEMS        57606
#define IDS_TREE_NODE_OUTBOX            57607
#define IDS_TREE_NODE_INCOMING          57608
#define IDS_TREE_ROOT_NAME              57638
#define IDS_STATUS_SUCCESS              57657
#define IDS_STATUS_PARTIALLY_RECEIVED   57658
#define IDS_LOW_PRIORITY                57661
#define IDS_NORMAL_PRIORITY             57662
#define IDS_HIGH_PRIORITY               57663
#define IDS_CANCELING                   57672
#define IDS_CANCELED                    57673
#define IDS_COMPLETED                   57674
#define IDS_RETRIES_EXCEEDED            57675
#define IDS_PENDING                     57676
#define IDS_RETRYING                    57677
#define IDS_PAUSED                      57679
#define IDS_DELETING                    57683
#define IDS_INPROGRESS                  57684
#define IDS_MSG_COLUMN_STATUS           57691
#define IDS_MSG_COLUMN_SERVER           57692
#define IDS_MSG_COLUMN_NUM_PAGES        57693
#define IDS_MSG_COLUMN_CSID             57694
#define IDS_MSG_COLUMN_TSID             57695
#define IDS_MSG_COLUMN_SIZE             57696
#define IDS_MSG_COLUMN_DEVICE           57697
#define IDS_MSG_COLUMN_RETRIES          57698
#define IDS_MSG_COLUMN_JOB_ID           57699
#define IDS_MSG_COLUMN_CALLER_ID        57700
#define IDS_MSG_COLUMN_ROUTING_INFO     57701
#define IDS_MSG_COLUMN_DOC_NAME         57702
#define IDS_MSG_COLUMN_SUBJECT          57703
#define IDS_MSG_COLUMN_RECP_NAME        57704
#define IDS_MSG_COLUMN_RECP_NUM         57705
#define IDS_MSG_COLUMN_USER             57706
#define IDS_MSG_COLUMN_PRIORITY         57707
#define IDS_MSG_COLUMN_ORIG_TIME        57708
#define IDS_MSG_COLUMN_SUBMIT_TIME      57709
#define IDS_MSG_COLUMN_BILLING          57710
#define IDS_MSG_COLUMN_TRANSMISSION_START_TIME 57711
#define IDS_MSG_COLUMN_SEND_TIME        57712
#define IDS_MSG_COLUMN_EX_STATUS        57713
#define IDS_MSG_COLUMN_CURR_PAGE        57714
#define IDS_MSG_COLUMN_SENDER_NAME      57715
#define IDS_MSG_COLUMN_SENDER_NUM       57716
#define IDS_MSG_COLUMN_TRANSMISSION_END_TIME 57717
#define IDS_MSG_COLUMN_TRANSMISSION_DURATION 57718
#define IDS_ERR_CONNECTION_FAILED       57730
#define IDS_ERR_NO_MEMORY               57731
#define IDS_ERR_ACCESS_DENIED           57732
#define IDS_ERR_OPERATION_FAILED        57733
#define IDS_ERR_CANT_COMPLETE_OPERATION 57734
#define IDS_MSG_COLUMN_BROADCAST_ID     57735
#define IDS_DISCONNECTED                58000
#define IDS_INITIALIZING                58001
#define IDS_DIALING                     58002
#define IDS_TRANSMITTING                58003
#define IDS_ANSWERED                    58004
#define IDS_RECEIVING                   58005
#define IDS_LINE_UNAVAILABLE            58006
#define IDS_BUSY                        58007
#define IDS_NO_ANSWER                   58008
#define IDS_BAD_ADDRESS                 58009
#define IDS_NO_DIAL_TONE                58010
#define IDS_FATAL_ERROR                 58011
#define IDS_CALL_DELAYED                58012
#define IDS_CALL_BLACKLISTED            58013
#define IDS_NOT_FAX_CALL                58014
#define IDS_HANDLED                     58015
#define IDS_CALL_COMPLETED              58016
#define IDS_CALL_ABORTED                58017
#define IDS_TREE_NODE_FORMAT_REMOTE     61204
#define IDS_TREE_NODE_FORMAT_LOCAL      61205
#define IDS_STATUS_BAR_ITEM             61206
#define IDS_STATUS_BAR_ITEMS            61207
#define IDS_COLUMN_ICON                 61208
#define IDS_FOLDER_IDLE                 61209
#define IDS_SERVER_REFRESHING           61210
#define IDS_SERVER_ONLINE               61211
#define IDS_SERVER_OFFLINE              61212
#define IDS_FOLDER_REFRESHING           61213
#define IDS_FOLDER_SORTING              61214
#define IDS_SERVER_NET_ERROR            61215
#define IDS_FOLDER_REFRESH_FAILED       61216
#define IDS_BUTTON_CLOSE                61222
#define IDS_SENDER_INFO_CAPTION         61224
#define IDS_RECIPIENT_INFO_CAPTION      61225
#define IDS_PROPERTIES_SHEET_CAPTION    61226
#define IDS_BAD_COMCTL32                61227
#define IDS_PERSONAL_COVER_PAGES        61228
#define IDS_COV_COLUMN_NAME             61229
#define IDS_COV_COLUMN_MODIFIED         61230
#define IDS_COV_COLUMN_SIZE             61231
#define IDS_COVER_PAGE                  61232
#define IDS_COVER_PAGE_EXISTS           61234
#define IDS_SURE_DELETE_ONE             61235
#define IDS_SURE_DELETE_MANY            61236
#define IDS_OPTIONS_CAPTION             61239
#define IDS_SELECT_CP_DIR               61240
#define IDS_LOCAL_SERVER                61243
#define IDS_SRV_COL_SERVER              61244
#define IDS_SRV_COL_STATUS              61245
#define IDS_SRV_PART_OFFLINE            61246
#define IDS_SRV_OFFLINE                 61247
#define IDS_SRV_ONLINE                  61248
#define IDS_NO_SRV_INSTALL              61249
#define IDS_VERSION_FORMAT              61250
#define IDS_PERSONAL_CP_DIR             61251
#define IDS_ROUTING                     61252
#define IDS_ROUTING_RETRY               61253
#define IDS_ROUTING_INPROGRESS          61254
#define IDS_ROUTING_FAILED              61255
#define IDS_NO_OPEN_ASSOCIATION         61256
#define IDS_NO_PRINT_ASSOCIATION        61257
#define IDS_PRINTER_NAME_FORMAT         61258
#define IDS_SAVE_AS_TOO_LONG            61259
#define IDS_ERR_SRV_OUTOFMEMORY         61260
#define IDS_ERR_FILE_ACCESS_DENIED      61261
#define IDS_ERR_MESSAGE_NOT_FOUND       61262
#define IDS_ERR_NO_HTML_HELP            61263
#define IDS_SERVER_OUTBOX_BLOCKED       61264
#define IDS_SERVER_OUTBOX_PAUSED        61265
#define IDS_IMPORT_TITLE_INBOX          61266
#define IDS_IMPORT_EMPTY_FOLDER         61267
#define IDS_IMPORT_TO_INBOX             61268
#define IDS_IMPORT_TO_SENT_ITEMS        61269
#define IDS_IMPORT_NUMBER               61270
#define IDS_IMPORT_ERROR                61271
#define IDS_IMPORT_INFO                 61272
#define IDS_IMPORT_BAD_FORMAT           61273
#define IDS_COPY_CP_TITLE               61274
#define IDS_IMPORT_NO_ACCESS            61275
#define IDS_SAVE_AS_FILTER_FORMAT       61276
#define IDS_CP_ADD_FILTER_FORMAT        61277
#define IDS_IMPORT_TITLE_SENTITEMS      61278

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        175
#define _APS_NEXT_COMMAND_VALUE         32779
#define _APS_NEXT_CONTROL_VALUE         1312
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxactivity.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxActivity.cpp

Abstract:

	Implementation of CFaxActivity Class.

Author:

	Iv Garber (IvG)	Jun, 2000

Revision History:

--*/

#include "stdafx.h"
#include "FaxComEx.h"
#include "FaxActivity.h"

//
//========================= QUEUED MESSAGES =============================
//
STDMETHODIMP 
CFaxActivity::get_QueuedMessages(
    long *plQueuedMessages
)
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxActivity::get_QueuedMessages"), hr);
    hr = GetNumberOfMessages(mtQUEUED, plQueuedMessages);
	return hr;
}

//
//========================= OUTGOING MESSAGES =============================
//
STDMETHODIMP 
CFaxActivity::get_OutgoingMessages(
    long *plOutgoingMessages
)
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxActivity::get_OutgoingMessages"), hr);
    hr = GetNumberOfMessages(mtOUTGOING, plOutgoingMessages);
	return hr;
}

//
//========================= ROUTING MESSAGES =============================
//
STDMETHODIMP 
CFaxActivity::get_RoutingMessages(
    long *plRoutingMessages
)
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxActivity::get_RoutingMessages"), hr);
    hr = GetNumberOfMessages(mtROUTING, plRoutingMessages);
	return hr;
}

//
//========================= INCOMING MESSAGES =============================
//
STDMETHODIMP 
CFaxActivity::get_IncomingMessages(
    long *plIncomingMessages
)
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxActivity::get_IncomingMessages"), hr);
    hr = GetNumberOfMessages(mtINCOMING, plIncomingMessages);
	return hr;
}

//
//=================== GET NUMBER OF MESSAGES ===================================
//
STDMETHODIMP
CFaxActivity::GetNumberOfMessages(
    MSG_TYPE msgType,
    long * plNumber
)
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxActivity::GetNumberOfMessages"), hr);

    //
    //  check that we have got good ptr
    //
    if (::IsBadWritePtr(plNumber, sizeof(long)))
    {
        hr = E_POINTER;
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr(plNumber, sizeof(long))"), hr);
        AtlReportError(CLSID_FaxActivity, 
            IDS_ERROR_INVALID_ARGUMENT, 
            IID_IFaxActivity, 
            hr, 
            _Module.GetResourceInstance());
        return hr;
    }

    //
    //  Bring data from Server in the first time
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    switch(msgType)
    {
    case mtINCOMING:
        *plNumber = m_ServerActivity.dwIncomingMessages;
        break;
    case mtROUTING:
        *plNumber = m_ServerActivity.dwRoutingMessages;
        break;
    case mtOUTGOING:
        *plNumber = m_ServerActivity.dwOutgoingMessages;
        break;
    case mtQUEUED:
        *plNumber = m_ServerActivity.dwQueuedMessages;
        break;
    default:
        //
        //  ASSERT(FALSE)
        //
        ATLASSERT(msgType == mtQUEUED);     
        break;
    }

    return hr;
}

//
//========================= REFRESH ============================================
//
STDMETHODIMP 
CFaxActivity::Refresh()
/*++

Routine name : CFaxActivity::Refresh

Routine description:

	Refresh the contents of the object : bring new data from the Server.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:


Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxActivity::Refresh"), hr);

    //
    //  Get Fax Server Handle
    //
    HANDLE  hFaxHandle = NULL;
    hr = GetFaxHandle(&hFaxHandle);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxActivity, 
            GetErrorMsgId(hr), 
            IID_IFaxActivity, 
            hr, 
            _Module.GetResourceInstance());
        return hr;
    }


    //
    //  Ask from Server new Activity data
    //
    if (!FaxGetServerActivity(hFaxHandle, &m_ServerActivity))
    {
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        AtlReportError(CLSID_FaxActivity, 
            GetErrorMsgId(hr), 
            IID_IFaxActivity, 
            hr, 
            _Module.GetResourceInstance());
        CALL_FAIL(GENERAL_ERR, _T("FaxGetServerActivity(hFaxHandle, &ServerActivity)"), hr);
        return hr;
    }

    m_bInited = true;
	return hr;
}

//
//======================= SUPPORT ERROR INFO ==================================
//
STDMETHODIMP 
CFaxActivity::InterfaceSupportsErrorInfo(
    REFIID riid
)
/*++

Routine name : CFaxActivity::InterfaceSupportsErrorInfo

Routine description:

	ATL's implementation of Support Error Info.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	riid                          [in]    - reference to the ifc to check.

Return Value:

    Standard HRESULT code

--*/
{
	static const IID* arr[] = 
	{
		&IID_IFaxActivity
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxactivity.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxActivity.h

Abstract:

	Declaration of the CFaxActivity Class.

Author:

	Iv Garber (IvG)	Jun, 2000

Revision History:

--*/

#ifndef __FAXACTIVITY_H_
#define __FAXACTIVITY_H_

#include "resource.h"       // main symbols
#include "FaxCommon.h"


// 
//==================== ACTIVITY ==========================================
//
class ATL_NO_VTABLE CFaxActivity : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public ISupportErrorInfo,
	public IDispatchImpl<IFaxActivity, &IID_IFaxActivity, &LIBID_FAXCOMEXLib>,
    public CFaxInitInner
{
public:
    CFaxActivity() : CFaxInitInner(_T("FAX ACTIVITY")),
        m_bInited(false)
	{
        m_ServerActivity.dwSizeOfStruct = sizeof(FAX_SERVER_ACTIVITY);
	}

DECLARE_REGISTRY_RESOURCEID(IDR_FAXACTIVITY)
DECLARE_NOT_AGGREGATABLE(CFaxActivity)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxActivity)
	COM_INTERFACE_ENTRY(IFaxActivity)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY(IFaxInitInner)
END_COM_MAP()

//  Interfaces
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

	STDMETHOD(Refresh)();

	STDMETHOD(get_QueuedMessages)(/*[out, retval]*/ long *plQueuedMessages);
	STDMETHOD(get_RoutingMessages)(/*[out, retval]*/ long *plRoutingMessages);
	STDMETHOD(get_IncomingMessages)(/*[out, retval]*/ long *plIncomingMessages);
	STDMETHOD(get_OutgoingMessages)(/*[out, retval]*/ long *plOutgoingMessages);

private:
    typedef enum MSG_TYPE { mtINCOMING, mtROUTING, mtOUTGOING, mtQUEUED } MSG_TYPE;

    bool                    m_bInited;
    FAX_SERVER_ACTIVITY     m_ServerActivity;

    STDMETHOD(GetNumberOfMessages)(MSG_TYPE msgType, long *plNumber);
};

#endif //__FAXACTIVITY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxarchiveinner.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	faxarchiveinner.h

Abstract:

	Declaration and Implementation of Fax Archive Inner Template Class.

Author:

	Iv Garber (IvG)	May, 2000

Revision History:

--*/

#ifndef __FAXARCHIVEINNER_H_
#define __FAXARCHIVEINNER_H_

#include "resource.h"       // main symbols
#include "FaxCommon.h"


//
//================ FAX ARCHIVE INNER =========================================
//
template <class T, const IID* piid, const CLSID* pcid, FAX_ENUM_MESSAGE_FOLDER ArchiveType, 
		  class MsgIfc, class MsgType, class IteratorIfc, class IteratorType>
class CFaxArchiveInner : 
	public IDispatchImpl<T, piid, &LIBID_FAXCOMEXLib>, 
	public CFaxInitInner
{
public:
    CFaxArchiveInner() : CFaxInitInner(_T("FAX ARCHIVE INNER"))
	{
		m_bInitialized = FALSE;
	}

	virtual ~CFaxArchiveInner() 
	{};

	STDMETHOD(get_SizeLow)(/*[out, retval]*/ long *plSizeLow);	
	STDMETHOD(get_SizeHigh)(/*[out, retval]*/ long *plSizeHigh);
	STDMETHOD(get_UseArchive)(/*[out, retval]*/ VARIANT_BOOL *pbUseArchive);
	STDMETHOD(put_UseArchive)(/*[in]*/ VARIANT_BOOL bUseArchive);
	STDMETHOD(get_ArchiveFolder)(BSTR *pbstrArchiveFolder);
	STDMETHOD(put_ArchiveFolder)(BSTR bstrArchiveFolder);
	STDMETHOD(get_SizeQuotaWarning)(VARIANT_BOOL *pbSizeQuotaWarning);
	STDMETHOD(put_SizeQuotaWarning)(VARIANT_BOOL bSizeQuotaWarning);
	STDMETHOD(get_HighQuotaWaterMark)(long *plHighQuotaWaterMark);
	STDMETHOD(put_HighQuotaWaterMark)(long lHighQuotaWaterMark);
	STDMETHOD(get_LowQuotaWaterMark)(long *plLowQuotaWaterMark);
	STDMETHOD(put_LowQuotaWaterMark)(long lLowQuotaWaterMark);
	STDMETHOD(get_AgeLimit)(long *plAgeLimit);
	STDMETHOD(put_AgeLimit)(long lAgeLimit);
	STDMETHOD(Refresh)();
	STDMETHOD(Save)();
	STDMETHOD(GetMessage)(BSTR bstrMessageId, MsgIfc **ppFaxMessage);
	STDMETHOD(GetMessages)(long lPrefetchSize, IteratorIfc **ppFaxMessageIterator);

private:
	bool			m_bInitialized;

	VARIANT_BOOL	m_bUseArchive;
	CComBSTR		m_bstrArchiveFolder;
	VARIANT_BOOL	m_bSizeQuotaWarning;
	long			m_lHighQuotaWaterMark;
	long			m_lLowQuotaWaterMark;
	long			m_lAgeLimit;
	ULARGE_INTEGER	m_uliSize;
};

//
//========================= REFRESH ====================================
//
template <class T, const IID* piid, const CLSID* pcid, FAX_ENUM_MESSAGE_FOLDER ArchiveType, 
		  class MsgIfc, class MsgType, class IteratorIfc, class IteratorType>
STDMETHODIMP
CFaxArchiveInner<T, piid, pcid, ArchiveType, MsgIfc, MsgType, IteratorIfc, IteratorType>
	::Refresh(
)
/*++

Routine name : CFaxArchiveInner::Refresh

Routine description:

	Retrieve Current Configuration of the Incoming / Outgoing Archive on Fax Server

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:


Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;

	DBG_ENTER (_T("CFaxArchiveInner::Refresh"), hr);

	//
	//	Get Fax Server Handle
	//
	HANDLE	hFaxHandle = NULL;
	hr = GetFaxHandle(&hFaxHandle);
	if (FAILED(hr))
	{
		AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr, _Module.GetResourceInstance());
		return hr;
	}

	CFaxPtr<FAX_ARCHIVE_CONFIG>		pFaxArchiveConfig;
	if ( 0 == ::FaxGetArchiveConfiguration(hFaxHandle, ArchiveType, &pFaxArchiveConfig))
	{
		//
		//	Failed to Get Archive Configuration
		//
		hr = Fax_HRESULT_FROM_WIN32(GetLastError());
		AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr, _Module.GetResourceInstance());
		CALL_FAIL(GENERAL_ERR, _T("::FaxGetArchiveConfiguration()"), hr);
		return hr;
	}

	if (!pFaxArchiveConfig || pFaxArchiveConfig->dwSizeOfStruct != sizeof(FAX_ARCHIVE_CONFIG))
	{
		//
		//	Failed to Get Archive Configuration
		//
		hr = E_FAIL;
		AtlReportError(*pcid, IDS_ERROR_OPERATION_FAILED, *piid, hr, _Module.GetResourceInstance());
		CALL_FAIL(GENERAL_ERR, _T("Invalid pFaxArchiveConfig"), hr);
		return hr;
	}

	m_bUseArchive = bool2VARIANT_BOOL(pFaxArchiveConfig->bUseArchive);
	m_bSizeQuotaWarning = bool2VARIANT_BOOL(pFaxArchiveConfig->bSizeQuotaWarning);
	m_lHighQuotaWaterMark = pFaxArchiveConfig->dwSizeQuotaHighWatermark;
	m_lLowQuotaWaterMark = pFaxArchiveConfig->dwSizeQuotaLowWatermark;
	m_lAgeLimit = pFaxArchiveConfig->dwAgeLimit;
	m_uliSize.QuadPart = pFaxArchiveConfig->dwlArchiveSize;

	m_bstrArchiveFolder = pFaxArchiveConfig->lpcstrFolder;
	if (!m_bstrArchiveFolder && pFaxArchiveConfig->lpcstrFolder) 
	{
		hr = E_OUTOFMEMORY;
		AtlReportError(*pcid, IDS_ERROR_OUTOFMEMORY, *piid, hr, _Module.GetResourceInstance());
		CALL_FAIL(MEM_ERR, _T("CComBSTR& operator=()"), hr);
		return hr;
	}

    m_bInitialized = TRUE;
	return hr;
}

//
//==================== USE ARCHIVE ====================================
//
template <class T, const IID* piid, const CLSID* pcid, FAX_ENUM_MESSAGE_FOLDER ArchiveType, 
		  class MsgIfc, class MsgType, class IteratorIfc, class IteratorType>
STDMETHODIMP 
CFaxArchiveInner<T, piid, pcid, ArchiveType, MsgIfc, MsgType, IteratorIfc, IteratorType>
	::get_UseArchive(
		VARIANT_BOOL *pbUseArchive
)
/*++

Routine name : CFaxArchiveInner::get_UseArchive

Routine description:

	Return Flag indicating whether or not to Archive the Fax Messages

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pbUseArchive                  [out]    - Ptr to the Place to put Current value of the Flag

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxArchiveInner::get_UseArchive"), hr);

	//	
	//	Initialize before first use
	//
	if (!m_bInitialized)
	{
		hr = Refresh();
		if (FAILED(hr))
		{
			return hr;
		}
	}

    hr = GetVariantBool(pbUseArchive, m_bUseArchive);
    if (FAILED(hr))
    {
        AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr, _Module.GetResourceInstance());
        return hr;
    }
	return hr;
}

template <class T, const IID* piid, const CLSID* pcid, FAX_ENUM_MESSAGE_FOLDER ArchiveType, 
		  class MsgIfc, class MsgType, class IteratorIfc, class IteratorType>
STDMETHODIMP 
CFaxArchiveInner<T, piid, pcid, ArchiveType, MsgIfc, MsgType, IteratorIfc, IteratorType>::
	put_UseArchive(
		VARIANT_BOOL bUseArchive
)
/*++

Routine name : CFaxArchiveInner::put_UseArchive

Routine description:

	Set new Use Archive Flag

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	bUseArchive                   [in]    - the new Value for the Use Archive Flag

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;

	DBG_ENTER (_T("CFaxArchiveInner::put_UseArchive"), hr, _T("%ld"), bUseArchive);

	//	
	//	Initialize before first use
	//
	if (!m_bInitialized)
	{
		hr = Refresh();
		if (FAILED(hr))
		{
			return hr;
		}
	}

	m_bUseArchive = bUseArchive;
	return hr;
}

//
//==================== ARCHIVE FOLDER ====================================
//
template <class T, const IID* piid, const CLSID* pcid, FAX_ENUM_MESSAGE_FOLDER ArchiveType, 
		  class MsgIfc, class MsgType, class IteratorIfc, class IteratorType>
STDMETHODIMP 
CFaxArchiveInner<T, piid, pcid, ArchiveType, MsgIfc, MsgType, IteratorIfc, IteratorType>
	::get_ArchiveFolder(
		BSTR *pbstrArchiveFolder
)
/*++

Routine name : CFaxArchiveInner::get_ArchiveFolder

Routine description:

	return Archive Folder on Server

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pbstrArchiveFolder              [out]    - the Archive Folder

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT hr = S_OK;
	DBG_ENTER (TEXT("CFaxArchiveInner::get_ArchiveFolder"), hr);

	//	
	//	Initialize before first use
	//
	if (!m_bInitialized)
	{
		hr = Refresh();
		if (FAILED(hr))
		{
			return hr;
		}
	}

    hr = GetBstr(pbstrArchiveFolder, m_bstrArchiveFolder);
    if (FAILED(hr))
    {
        AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr, _Module.GetResourceInstance());
        return hr;
    }
	return hr;
}

template <class T, const IID* piid, const CLSID* pcid, FAX_ENUM_MESSAGE_FOLDER ArchiveType, 
		  class MsgIfc, class MsgType, class IteratorIfc, class IteratorType>
STDMETHODIMP 
CFaxArchiveInner<T, piid, pcid, ArchiveType, MsgIfc, MsgType, IteratorIfc, IteratorType>
	::put_ArchiveFolder (
		BSTR bstrArchiveFolder
)
/*++

Routine name : CFaxArchiveInner::put_ArchiveFolder

Routine description:

	Set Archive Folder

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	bstrArchiveFolder              [in]    - new Archive Folder on Server 

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;

	DBG_ENTER (_T("CFaxArchiveInner::put_ArchiveFolder"), hr, _T("%s"), bstrArchiveFolder);

	//	
	//	Initialize before first use
	//
	if (!m_bInitialized)
	{
		hr = Refresh();
		if (FAILED(hr))
		{
			return hr;
		}
	}

	m_bstrArchiveFolder = bstrArchiveFolder;
	if (bstrArchiveFolder && !m_bstrArchiveFolder)
	{
		//
		//	Not enough memory
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(*pcid, 
			IDS_ERROR_OUTOFMEMORY, 
			*piid, 
			hr, 
			_Module.GetResourceInstance());
		CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
		return hr;
	}

	return hr;
}

//
//==================== SIZE QUOTA WARNING ================================
//
template <class T, const IID* piid, const CLSID* pcid, FAX_ENUM_MESSAGE_FOLDER ArchiveType, 
		  class MsgIfc, class MsgType, class IteratorIfc, class IteratorType>
STDMETHODIMP 
CFaxArchiveInner<T, piid, pcid, ArchiveType, MsgIfc, MsgType, IteratorIfc, IteratorType>
	::get_SizeQuotaWarning(
		VARIANT_BOOL *pbSizeQuotaWarning
)
/*++

Routine name : CFaxArchiveInner::get_SizeQuotaWarning

Routine description:

	Return Flag indicating whether or not to issue event log warning when
	watermarks are crossed

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pbSizeQuotaWarning            [out]    - ptr to place where to put the Current value of the Flag

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxArchiveInner::get_SizeQuotaWarning"), hr);

	//	
	//	Initialize before first use
	//
	if (!m_bInitialized)
	{
		hr = Refresh();
		if (FAILED(hr))
		{
			return hr;
		}
	}

    hr = GetVariantBool(pbSizeQuotaWarning, m_bSizeQuotaWarning);
    if (FAILED(hr))
    {
        AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr, _Module.GetResourceInstance());
        return hr;
    }
	return hr;
}

template <class T, const IID* piid, const CLSID* pcid, FAX_ENUM_MESSAGE_FOLDER ArchiveType, 
		  class MsgIfc, class MsgType, class IteratorIfc, class IteratorType>
STDMETHODIMP 
CFaxArchiveInner<T, piid, pcid, ArchiveType, MsgIfc, MsgType, IteratorIfc, IteratorType>
	::put_SizeQuotaWarning(
		VARIANT_BOOL bSizeQuotaWarning
)
/*++

Routine name : CFaxArchiveInner::put_SizeQuotaWarning

Routine description:

	Set new SizeQuotaWarning Flag

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	bSizeQuotaWarning              [in]    - the new Value for the SizeQuotaWarning Flag

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxArchiveInner::put_SizeQuotaWarning"), hr, _T("%ld"), bSizeQuotaWarning);

	//	
	//	Initialize before first use
	//
	if (!m_bInitialized)
	{
		hr = Refresh();
		if (FAILED(hr))
		{
			return hr;
		}
	}

	m_bSizeQuotaWarning = bSizeQuotaWarning;
	return hr;
}

//
//================= QUOTA WATER MARKS ===============================
//
template <class T, const IID* piid, const CLSID* pcid, FAX_ENUM_MESSAGE_FOLDER ArchiveType, 
		  class MsgIfc, class MsgType, class IteratorIfc, class IteratorType>
STDMETHODIMP 
CFaxArchiveInner<T, piid, pcid, ArchiveType, MsgIfc, MsgType, IteratorIfc, IteratorType>
	::get_HighQuotaWaterMark(
		long *plHighQuotaWaterMark
)
/*++

Routine name : CFaxArchiveInner::get_HighQuotaWaterMark

Routine description:

	Return HighQuotaWaterMark

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	plHighQuotaWaterMark		[out]    - HighQuotaWaterMark

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;

	DBG_ENTER (TEXT("CFaxArchiveInner::get_HighQuotaWaterMark"), hr);

	//	
	//	Initialize before first use
	//
	if (!m_bInitialized)
	{
		hr = Refresh();
		if (FAILED(hr))
		{
			return hr;
		}
	}

    hr = GetLong(plHighQuotaWaterMark , m_lHighQuotaWaterMark);
    if (FAILED(hr))
    {
        AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr, _Module.GetResourceInstance());
        return hr;
    }
	return hr;
}

template <class T, const IID* piid, const CLSID* pcid, FAX_ENUM_MESSAGE_FOLDER ArchiveType, 
		  class MsgIfc, class MsgType, class IteratorIfc, class IteratorType>
STDMETHODIMP 
CFaxArchiveInner<T, piid, pcid, ArchiveType, MsgIfc, MsgType, IteratorIfc, IteratorType>
	::put_HighQuotaWaterMark(
		long lHighQuotaWaterMark
)
/*++

Routine name : CFaxArchiveInner::put_HighQuotaWaterMark

Routine description:

	Set HighQuotaWaterMark

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	lHighQuotaWaterMark		[in]    - HighQuotaWaterMark to Set

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxArchiveInner::put_HighQuotaWaterMark"), hr, _T("%ld"), lHighQuotaWaterMark);

	//	
	//	Initialize before first use
	//
	if (!m_bInitialized)
	{
		hr = Refresh();
		if (FAILED(hr))
		{
			return hr;
		}
	}

	m_lHighQuotaWaterMark = lHighQuotaWaterMark;
	return hr;
}

template <class T, const IID* piid, const CLSID* pcid, FAX_ENUM_MESSAGE_FOLDER ArchiveType, 
		  class MsgIfc, class MsgType, class IteratorIfc, class IteratorType>
STDMETHODIMP 
CFaxArchiveInner<T, piid, pcid, ArchiveType, MsgIfc, MsgType, IteratorIfc, IteratorType>
	::get_LowQuotaWaterMark(
		long *plLowQuotaWaterMark
)
/*++

Routine name : CFaxArchiveInner::get_LowQuotaWaterMark

Routine description:

	Return LowQuotaWaterMark

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	plLowQuotaWaterMark			[out]    - LowQuotaWaterMark

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxArchiveInner::get_LowQuotaWaterMark"), hr);

	//	
	//	Initialize before first use
	//
	if (!m_bInitialized)
	{
		hr = Refresh();
		if (FAILED(hr))
		{
			return hr;
		}
	}

    hr = GetLong(plLowQuotaWaterMark , m_lLowQuotaWaterMark);
    if (FAILED(hr))
    {
        AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr, _Module.GetResourceInstance());
        return hr;
    }
	return hr;
}

template <class T, const IID* piid, const CLSID* pcid, FAX_ENUM_MESSAGE_FOLDER ArchiveType, 
		  class MsgIfc, class MsgType, class IteratorIfc, class IteratorType>
STDMETHODIMP 
CFaxArchiveInner<T, piid, pcid, ArchiveType, MsgIfc, MsgType, IteratorIfc, IteratorType>
	::put_LowQuotaWaterMark(
		long lLowQuotaWaterMark
)
/*++

Routine name : CFaxArchiveInner::put_LowQuotaWaterMark

Routine description:

	Set LowQuotaWaterMark

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	lLowQuotaWaterMark		[in]    - LowQuotaWaterMark to Set

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxArchiveInner::put_LowQuotaWaterMark"), hr, _T("%ld"), lLowQuotaWaterMark);

	//	
	//	Initialize before first use
	//
	if (!m_bInitialized)
	{
		hr = Refresh();
		if (FAILED(hr))
		{
			return hr;
		}
	}

	m_lLowQuotaWaterMark = lLowQuotaWaterMark;
	return hr;
}

//
//================= AGE LIMIT ===============================
//
template <class T, const IID* piid, const CLSID* pcid, FAX_ENUM_MESSAGE_FOLDER ArchiveType, 
		  class MsgIfc, class MsgType, class IteratorIfc, class IteratorType>
STDMETHODIMP 
CFaxArchiveInner<T, piid, pcid, ArchiveType, MsgIfc, MsgType, IteratorIfc, IteratorType>
	::get_AgeLimit(
		long *plAgeLimit
)
/*++

Routine name : CFaxArchiveInner::get_AgeLimit

Routine description:

	Return how long in days Fax Message is stored at Fax Server

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	plAgeLimit				[out]    - AgeLimit

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxArchiveInner::get_AgeLimit"), hr);

	//	
	//	Initialize before first use
	//
	if (!m_bInitialized)
	{
		hr = Refresh();
		if (FAILED(hr))
		{
			return hr;
		}
	}

    hr = GetLong(plAgeLimit, m_lAgeLimit);
    if (FAILED(hr))
    {
        AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr, _Module.GetResourceInstance());
        return hr;
    }
	return hr;
}

template <class T, const IID* piid, const CLSID* pcid, FAX_ENUM_MESSAGE_FOLDER ArchiveType, 
		  class MsgIfc, class MsgType, class IteratorIfc, class IteratorType>
STDMETHODIMP 
CFaxArchiveInner<T, piid, pcid, ArchiveType, MsgIfc, MsgType, IteratorIfc, IteratorType>
	::put_AgeLimit(
		long lAgeLimit
)
/*++

Routine name : CFaxArchiveInner::put_AgeLimit

Routine description:

	Set AgeLimit

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	lAgeLimit		[in]    - AgeLimit to Set

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxArchiveInner::put_AgeLimit"), hr, _T("%ld"), lAgeLimit);

	//	
	//	Initialize before first use
	//
	if (!m_bInitialized)
	{
		hr = Refresh();
		if (FAILED(hr))
		{
			return hr;
		}
	}

	m_lAgeLimit = lAgeLimit;
	return hr;
}

//
//================= SIZE ==============================================
//
template <class T, const IID* piid, const CLSID* pcid, FAX_ENUM_MESSAGE_FOLDER ArchiveType, 
		  class MsgIfc, class MsgType, class IteratorIfc, class IteratorType>
STDMETHODIMP 
CFaxArchiveInner<T, piid, pcid, ArchiveType, MsgIfc, MsgType, IteratorIfc, IteratorType>
	::get_SizeLow(
		long *plSizeLow
)
/*++

Routine name : CFaxArchiveInner::get_SizeLow

Routine description:

	Return Size in Bytes of the Archive

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	plSizeLow					[out]    - Ptr to the place to put the Size in

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxArchiveInner::get_SizeLow"), hr);

	//	
	//	Initialize before first use
	//
	if (!m_bInitialized)
	{
		hr = Refresh();
		if (FAILED(hr))
		{
			return hr;
		}
	}

    hr = GetLong(plSizeLow, long(m_uliSize.LowPart));
    if (FAILED(hr))
    {
        AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr, _Module.GetResourceInstance());
        return hr;
    }
	return hr;
}

template <class T, const IID* piid, const CLSID* pcid, FAX_ENUM_MESSAGE_FOLDER ArchiveType, 
		  class MsgIfc, class MsgType, class IteratorIfc, class IteratorType>
STDMETHODIMP 
CFaxArchiveInner<T, piid, pcid, ArchiveType, MsgIfc, MsgType, IteratorIfc, IteratorType>
	::get_SizeHigh(
		long *plSizeHigh
)
/*++

Routine name : CFaxArchiveInner::get_SizeHigh

Routine description:

	Return Size in Bytes of the Archive

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	plSizeHigh					[out]    - Ptr to the place to put the Size in

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxArchiveInner::get_SizeHigh"), hr);

	//	
	//	Initialize before first use
	//
	if (!m_bInitialized)
	{
		hr = Refresh();
		if (FAILED(hr))
		{
			return hr;
		}
	}

    hr = GetLong(plSizeHigh, long(m_uliSize.HighPart));
    if (FAILED(hr))
    {
        AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr, _Module.GetResourceInstance());
        return hr;
    }
	return hr;
}

//
//========================= SAVE ====================================
//
template <class T, const IID* piid, const CLSID* pcid, FAX_ENUM_MESSAGE_FOLDER ArchiveType, 
		  class MsgIfc, class MsgType, class IteratorIfc, class IteratorType>
STDMETHODIMP 
CFaxArchiveInner<T, piid, pcid, ArchiveType, MsgIfc, MsgType, IteratorIfc, IteratorType>
	::Save(
)
/*++

Routine name : CFaxArchiveInner::Save

Routine description:

	Save the Archive's Configuration

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:


Return Value:

    Standard HRESULT code

--*/
{
	HRESULT				hr = S_OK;
	HANDLE				hFaxHandle = NULL;
	FAX_ARCHIVE_CONFIG	FaxArchiveConfig;

	DBG_ENTER (_T("CFaxArchiveInner::Save"), hr);

	//
	//	Get Fax Server Handle
	//
	hr = GetFaxHandle(&hFaxHandle);
	if (FAILED(hr))
	{
		AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr, _Module.GetResourceInstance());
		return hr;
	}

	if (hFaxHandle == NULL)
	{
		//
		//	Fax Server Is Not Connected 
		//
		hr = E_HANDLE;
		AtlReportError(*pcid, 
			IDS_ERROR_SERVER_NOT_CONNECTED, 
			*piid, 
			hr, 
			_Module.GetResourceInstance());
		CALL_FAIL(GENERAL_ERR, _T("hFaxHandle == NULL"), hr);
		return hr;
	}

	//
	//	FaxArchiveConfig.dwlArchiveSize is ignored for SetConfiguration()
	//
	FaxArchiveConfig.dwSizeOfStruct = sizeof(FAX_ARCHIVE_CONFIG);

	FaxArchiveConfig.bUseArchive = VARIANT_BOOL2bool(m_bUseArchive);
	FaxArchiveConfig.bSizeQuotaWarning = VARIANT_BOOL2bool(m_bSizeQuotaWarning);
	FaxArchiveConfig.dwSizeQuotaHighWatermark = m_lHighQuotaWaterMark;
	FaxArchiveConfig.dwSizeQuotaLowWatermark = m_lLowQuotaWaterMark;
	FaxArchiveConfig.dwAgeLimit = m_lAgeLimit;
	FaxArchiveConfig.lpcstrFolder = m_bstrArchiveFolder;

	if ( 0 == ::FaxSetArchiveConfiguration(hFaxHandle, ArchiveType, &FaxArchiveConfig))
	{
		//
		//	Failed to Set Archive Configuration
		//
		hr = Fax_HRESULT_FROM_WIN32(GetLastError());
		AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr, _Module.GetResourceInstance());
		CALL_FAIL(GENERAL_ERR, _T("::FaxSetArchiveConfiguration()"), hr);
		return hr;
	}
	return hr;
}

//
//=============== GET MESSAGE ========================================
//
template <class T, const IID* piid, const CLSID* pcid, FAX_ENUM_MESSAGE_FOLDER ArchiveType, 
		  class MsgIfc, class MsgType, class IteratorIfc, class IteratorType>
STDMETHODIMP 
CFaxArchiveInner<T, piid, pcid, ArchiveType, MsgIfc, MsgType, IteratorIfc, IteratorType>
	::GetMessage(
		BSTR bstrMessageId, 
		MsgIfc **ppFaxMessage
)
/*++

Routine name : CFaxArchiveInner::GetMessage

Routine description:

	Return Message by given Id

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	bstrMessageId               [in]    - Id of the Message to return
	ppFaxMessage				[out]    - Ptr to the place to put the Message

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT	hr = S_OK;

	DBG_ENTER (TEXT("CFaxArchiveInner::GetMessage"), hr, _T("%s"), bstrMessageId);

	//
	//	Check that we can write to the given pointer
	//
	if (::IsBadWritePtr(ppFaxMessage, sizeof(MsgIfc *)))
	{
		//
		//	Got Bad Return Pointer
		//
		hr = E_POINTER;
		AtlReportError(*pcid, IDS_ERROR_INVALID_ARGUMENT, *piid, hr, _Module.GetResourceInstance());
		CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr"), hr);
		return hr;
	}

	//
	//	Get Fax Server Handle
	//
	HANDLE	hFaxHandle = NULL;
	hr = GetFaxHandle(&hFaxHandle);
	if (FAILED(hr))
	{
		AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr, _Module.GetResourceInstance());
		return hr;
	}
	
	//
	//	convert Message Id that we've got to hexadecimal DWORDLONG
	//
	DWORDLONG	dwlMsgId;
	int iParsed = _stscanf (bstrMessageId, _T("%I64x"), &dwlMsgId);	
	if ( iParsed != 1)
	{
		//
		//	Failed to conver the number
		//
		hr = E_INVALIDARG;
		CALL_FAIL(GENERAL_ERR, _T("_stscanf()"), hr);
		AtlReportError(*pcid, IDS_ERROR_INVALIDMSGID, *piid, hr, _Module.GetResourceInstance());
		return hr;
	}

	CFaxPtr<FAX_MESSAGE>	pFaxPtrMessage;
	if (!FaxGetMessage(hFaxHandle, dwlMsgId, ArchiveType, &pFaxPtrMessage))
	{
		//
		//	Failed to retrieve the Message
		//
		hr = Fax_HRESULT_FROM_WIN32(GetLastError());
		AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr, _Module.GetResourceInstance());
		CALL_FAIL(GENERAL_ERR, _T("FaxGetMessage()"), hr);
		return hr;
	}

    //
    //  Check that pFaxPtrMessage is valid
    //
	if (!pFaxPtrMessage || pFaxPtrMessage->dwSizeOfStruct != sizeof(FAX_MESSAGE))
	{
		//
		//	Failed to Get Message
		//
		hr = E_FAIL;
		AtlReportError(*pcid, IDS_ERROR_OPERATION_FAILED, *piid, hr, _Module.GetResourceInstance());
		CALL_FAIL(GENERAL_ERR, _T("Invalid pFaxMessage"), hr);
		return hr;
	}

	//
	//	Create Message Object
	//
	CComPtr<MsgIfc>		pTmpMessage;
	hr = MsgType::Create(&pTmpMessage);
	if (FAILED(hr))
	{
		//
		//	Failed to create the Message object
		//
		AtlReportError(*pcid, IDS_ERROR_OPERATION_FAILED, *piid, hr, _Module.GetResourceInstance());
		CALL_FAIL(GENERAL_ERR, _T("MsgType::Create()"), hr);
		return hr;
	}

	//
	//	Initialize the Message Object
	//
	hr = ((MsgType *)((MsgIfc *)pTmpMessage))->Init(pFaxPtrMessage, m_pIFaxServerInner);
	if (FAILED(hr))
	{
		//
		// Failed to Init the Message Object
		//
		AtlReportError(*pcid, IDS_ERROR_OPERATION_FAILED, *piid, hr, _Module.GetResourceInstance());
		CALL_FAIL(GENERAL_ERR, _T("<casted>pTmpMessage->Init(pFaxMessage, m_pIFaxServerInner)"), hr);
		return hr;
	}

	//
	//	Return Message Object to the Caller
	//
	hr = pTmpMessage.CopyTo(ppFaxMessage);
	if (FAILED(hr))
	{
		//
		//	Failed to Copy Interface
		//
		AtlReportError(*pcid, IDS_ERROR_OPERATION_FAILED, *piid, hr, _Module.GetResourceInstance());
		CALL_FAIL(GENERAL_ERR, _T("CComPtr::CopyTo"), hr);
		return hr;
	}

	return hr;
}

//
//========================= GET MESSAGES ==============================================
//
template <class T, const IID* piid, const CLSID* pcid, FAX_ENUM_MESSAGE_FOLDER ArchiveType, 
		  class MsgIfc, class MsgType, class IteratorIfc, class IteratorType>
STDMETHODIMP 
CFaxArchiveInner<T, piid, pcid, ArchiveType, MsgIfc, MsgType, IteratorIfc, IteratorType>
	::GetMessages(
		long lPrefetchSize, 
		IteratorIfc **ppFaxMessageIterator
)
/*++

Routine name : CFaxArchiveInner::GetMessages

Routine description:

	Return Iterator on Archive's Messages.

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	lPrefetchSize               [in]    - Size of Prefetch Buffer for Messages.
	ppFaxMessageIterator		[out]    - Ptr to place to put Iterator Object

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxArchiveInner::GetMessages"), hr);

    CObjectHandler<IteratorType, IteratorIfc>   objectCreator;
    hr = objectCreator.GetObject(ppFaxMessageIterator, m_pIFaxServerInner);
    if (FAILED(hr))
    {
		AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr, _Module.GetResourceInstance());
        return hr;
    }
    return hr;
}	

#endif //__FAXARCHIVEINNER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxactivitylogging.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxActivityLogging.h

Abstract:

	Declaration of the CFaxActivityLogging Class.

Author:

	Iv Garber (IvG)	Jun, 2000

Revision History:

--*/

#ifndef __FAXACTIVITYLOGGING_H_
#define __FAXACTIVITYLOGGING_H_

#include "resource.h"       // main symbols
#include "FaxCommon.h"

//
//================ FAX ACTIVITY LOGGING =================================================
//
class ATL_NO_VTABLE CFaxActivityLogging : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public ISupportErrorInfo,
	public IDispatchImpl<IFaxActivityLogging, &IID_IFaxActivityLogging, &LIBID_FAXCOMEXLib>,
    public CFaxInitInner
{
public:
    CFaxActivityLogging() : CFaxInitInner(_T("FAX ACTIVITY LOGGING")), m_bInited(false)
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_FAXACTIVITYLOGGING)
DECLARE_NOT_AGGREGATABLE(CFaxActivityLogging)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxActivityLogging)
	COM_INTERFACE_ENTRY(IFaxActivityLogging)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY(IFaxInitInner)
END_COM_MAP()

//  Interfaces
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

    STDMETHOD(get_LogIncoming)(/*[out, retval]*/ VARIANT_BOOL *pbLogIncoming);
    STDMETHOD(put_LogIncoming)(/*[out, retval]*/ VARIANT_BOOL bLogIncoming);
    STDMETHOD(get_LogOutgoing)(/*[out, retval]*/ VARIANT_BOOL *pbLogOutgoing);
    STDMETHOD(put_LogOutgoing)(/*[out, retval]*/ VARIANT_BOOL bLogOutgoing);
    STDMETHOD(get_DatabasePath)(/*[out, retval]*/ BSTR *pbstrDatabasePath);
    STDMETHOD(put_DatabasePath)(/*[out, retval]*/ BSTR bstrDatabasePath);

    STDMETHOD(Refresh)();
    STDMETHOD(Save)();

private:
    VARIANT_BOOL    m_bLogIncoming;
    VARIANT_BOOL    m_bLogOutgoing;
    CComBSTR        m_bstrDatabasePath;
    bool            m_bInited;
};

#endif //__FAXACTIVITYLOGGING_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxactivitylogging.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxActivityLogging.cpp

Abstract:

	Implementation of Activity Logging Class.

Author:

	Iv Garber (IvG)	Jun, 2000

Revision History:

--*/

#include "stdafx.h"
#include "FaxComEx.h"
#include "FaxActivityLogging.h"

//
//==================== SAVE ========================================
//
STDMETHODIMP
CFaxActivityLogging::Save(
)
/*++

Routine name : CFaxActivityLogging::Save

Routine description:

	Save current Activity Logging Configuration to the Server.

Author:

	Iv Garber (IvG),	June, 2000

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;

    DBG_ENTER(_T("CFaxActivityLogging::Save"), hr);

    if (!m_bInited)
    {
        //
        //  nothing was done to the Configuration
        //
        return hr;
    }

    //
    //  Get Fax Server Handle
    //
    HANDLE  hFaxHandle = NULL;
    hr = GetFaxHandle(&hFaxHandle);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxActivityLogging, 
            GetErrorMsgId(hr), 
            IID_IFaxActivityLogging, 
            hr, 
            _Module.GetResourceInstance());
        return hr;
    }

    //
    //  Create Activity Logging Configuration
    //

    FAX_ACTIVITY_LOGGING_CONFIG    alConfig;
    alConfig.dwSizeOfStruct = sizeof(FAX_ACTIVITY_LOGGING_CONFIG);
    alConfig.bLogIncoming = VARIANT_BOOL2bool(m_bLogIncoming);
    alConfig.bLogOutgoing = VARIANT_BOOL2bool(m_bLogOutgoing);
    alConfig.lptstrDBPath = m_bstrDatabasePath;

    //
    //  Ask the Server to set the Activity Configuration
    //
    if (!FaxSetActivityLoggingConfiguration(hFaxHandle, &alConfig))
    {
        //
        //  Failed to set the Configuration to the Server
        //
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        AtlReportError(CLSID_FaxActivityLogging, 
            GetErrorMsgId(hr), 
            IID_IFaxActivityLogging, 
            hr, 
            _Module.GetResourceInstance());
        CALL_FAIL(GENERAL_ERR, _T("FaxSetActivityLoggingConfiguration()"), hr);
        return hr;
    }

    return hr;
}

//
//==================== REFRESH ========================================
//
STDMETHODIMP
CFaxActivityLogging::Refresh(
)
/*++

Routine name : CFaxActivityLogging::Refresh

Routine description:

	Bring new Activity Logging cofiguration from the Server.

Author:

	Iv Garber (IvG),	June, 2000

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;

    DBG_ENTER(_T("CFaxActivityLogging::Refresh"), hr);

    //
    //  Get Fax Server Handle
    //
    HANDLE  hFaxHandle = NULL;
    hr = GetFaxHandle(&hFaxHandle);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxActivityLogging, 
            GetErrorMsgId(hr), 
            IID_IFaxActivityLogging, 
            hr, 
            _Module.GetResourceInstance());
        return hr;
    }

    //
    //  Ask the Server for the Mail Configuration
    //
    CFaxPtr<FAX_ACTIVITY_LOGGING_CONFIG>    pConfig;
    if (!FaxGetActivityLoggingConfiguration(hFaxHandle, &pConfig))
    {
        //
        //  Failed to get the Configuration from the Server
        //
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        AtlReportError(CLSID_FaxActivityLogging, 
            GetErrorMsgId(hr), 
            IID_IFaxActivityLogging, 
            hr, 
            _Module.GetResourceInstance());
        CALL_FAIL(GENERAL_ERR, _T("FaxGetActivityLoggingConfiguration()"), hr);
        return hr;
    }

    //  
    //  Check that pConfig is valid
    //
    if (!pConfig || pConfig->dwSizeOfStruct != sizeof(FAX_ACTIVITY_LOGGING_CONFIG))
    {
        hr = E_FAIL;
        AtlReportError(CLSID_FaxActivityLogging, 
            GetErrorMsgId(hr), 
            IID_IFaxActivityLogging, 
            hr, 
            _Module.GetResourceInstance());
        CALL_FAIL(GENERAL_ERR, _T("(!pConfig || SizeOfStruct != sizeof(FAX_ACTIVITY_LOGGING_CONFIG))"), hr);
        return hr;
    }

    m_bLogIncoming = bool2VARIANT_BOOL(pConfig->bLogIncoming);
    m_bLogOutgoing = bool2VARIANT_BOOL(pConfig->bLogOutgoing);

    m_bstrDatabasePath = ::SysAllocString(pConfig->lptstrDBPath);
    if ( (pConfig->lptstrDBPath) && !m_bstrDatabasePath )
    {
		//
		//	Failed to Copy
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxActivityLogging, 
            IDS_ERROR_OUTOFMEMORY, 
            IID_IFaxActivityLogging, 
            hr,
            _Module.GetResourceInstance());
		CALL_FAIL(MEM_ERR, _T("::SysAllocString()"), hr);
		return hr;
    }

    m_bInited = true;
    return hr;
}

//
//============================= DATABASE PATH ====================================
//
STDMETHODIMP 
CFaxActivityLogging::put_DatabasePath(
	BSTR bstrDatabasePath
)
/*++

Routine name : CFaxActivityLogging::put_DatabasePath

Routine description:

	Set the Database Path

Author:

	Iv Garber (IvG),	June, 2000

Arguments:

	bstrDatabasePath              [in]    - the new value of Database Path

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;

	DBG_ENTER (_T("CFaxActivityLogging::put_DatabasePath"), hr, _T("%s"), bstrDatabasePath);

    //
    //  Sync with the Server for the first time
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    m_bstrDatabasePath = bstrDatabasePath;
	if (bstrDatabasePath && !m_bstrDatabasePath)
	{
		//	
		//	not enough memory
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxActivityLogging, 
            IDS_ERROR_OUTOFMEMORY, 
            IID_IFaxActivityLogging, 
            hr,
            _Module.GetResourceInstance());
		CALL_FAIL(MEM_ERR, _T("CComBSTR::operator=()"), hr);
		return hr;
	}
    return hr;
}

STDMETHODIMP 
CFaxActivityLogging::get_DatabasePath(
	BSTR *pbstrDatabasePath
)
/*++

Routine name : CFaxActivityLogging::get_DatabasePath

Routine description:

	Return current Database Path

Author:

	Iv Garber (IvG),	June, 2000

Arguments:

	pbstrDatabasePath                    [out]    - the current Database Path

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxActivityLogging::get_DatabasePath"), hr);

    //
    //  Sync with the Server for the first time
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    hr = GetBstr(pbstrDatabasePath, m_bstrDatabasePath);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxActivityLogging, GetErrorMsgId(hr), IID_IFaxActivityLogging, hr, _Module.GetResourceInstance());
        return hr;
    }

	return hr;
}

//
//===================== LOG OUTGOING ======================================
//
STDMETHODIMP
CFaxActivityLogging::get_LogOutgoing(
    VARIANT_BOOL *pbLogOutgoing
)
/*++

Routine name : CFaxActivityLogging::get_LogOutgoing

Routine description:

	Return Log Incoming value

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	pbLogOutgoing                 [out]    - the value of the Log Incoming to return

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxActivityLogging::get_LogOutgoing"), hr);

    //
    //  Sync with the Server for the first time
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    hr = GetVariantBool(pbLogOutgoing, m_bLogOutgoing);
    if (FAILED(hr))
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxActivityLogging, GetErrorMsgId(hr), IID_IFaxActivityLogging, hr, _Module.GetResourceInstance());
        return hr;
    }

    return hr;
}

STDMETHODIMP
CFaxActivityLogging::put_LogOutgoing(
    VARIANT_BOOL bLogOutgoing
)
/*++

Routine name : CFaxActivityLogging::put_LogOutgoing

Routine description:

	Set new Log Incoming value

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	bLogOutgoing                 [in]    - the value of the Log Incoming to set

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxActivityLogging::put_LogOutgoing"), hr, _T("Log Incoming : %d"), bLogOutgoing);

    //
    //  Sync with the Server for the first time
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    m_bLogOutgoing = bLogOutgoing;
    return hr;
}

//
//===================== LOG INCOMING ======================================
//
STDMETHODIMP
CFaxActivityLogging::get_LogIncoming(
    VARIANT_BOOL *pbLogIncoming
)
/*++

Routine name : CFaxActivityLogging::get_LogIncoming

Routine description:

	Return Log Incoming value

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	pbLogIncoming                 [out]    - the value of the Log Incoming to return

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxActivityLogging::get_LogIncoming"), hr);

    //
    //  Sync with the Server for the first time
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    hr = GetVariantBool(pbLogIncoming, m_bLogIncoming);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxActivityLogging, GetErrorMsgId(hr), IID_IFaxActivityLogging, hr, _Module.GetResourceInstance());
        return hr;
    }

    return hr;
}

STDMETHODIMP
CFaxActivityLogging::put_LogIncoming(
    VARIANT_BOOL bLogIncoming
)
/*++

Routine name : CFaxActivityLogging::put_LogIncoming

Routine description:

	Set new Log Incoming value

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	bLogIncoming                 [in]    - the value of the Log Incoming to set

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxActivityLogging::put_LogIncoming"), hr, _T("Log Incoming : %d"), bLogIncoming);

    //
    //  Sync with the Server for the first time
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    m_bLogIncoming = bLogIncoming;
    return hr;
}

//
//================ SUPPORT ERROR INFO ====================================
//
STDMETHODIMP 
CFaxActivityLogging::InterfaceSupportsErrorInfo(
    REFIID riid
)
/*++

Routine name : CFaxActivityLogging::InterfaceSupportsErrorInfo

Routine description:

	ATL's implementation of Support Error Info.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	riid                          [in]    - Reference to the IID

Return Value:

    Standard HRESULT code

--*/
{
	static const IID* arr[] = 
	{
		&IID_IFaxActivityLogging
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxcommon.h ===
//	Fax Common Functions Definitions

#ifndef __FAXCOMMON_H_
#define __FAXCOMMON_H_

//
// Class: CComContainedObject2
// Author: ronenbar
// Date: 14-Apr-2002
//
// This is modified version of ATL's CComContainedObject.
// It implements IUnknown so the life time of an object inherited from
// it is managed by the controlling uknown (AddRef and Release are delegated to
// the controlling unknown.
// However, unlike the original class this class DOES NOT DELEGATE QueryInterface
// to the controlling IUnknown.
// This is useful when implementing a contained object which is returned via a container
// object method and not via its QueryInterface. I.e. the contrainer is not an aggregator
// but just want the embedded object life time to be managed by the container.
//
//

template <class Base> //Base must be derived from CComObjectRoot
class CComContainedObject2 : public Base
{
public:
        typedef Base _BaseClass;
        CComContainedObject2(void* pv) {m_pOuterUnknown = (IUnknown*)pv;}
#ifdef _ATL_DEBUG_INTERFACES
        ~CComContainedObject2()
        {
                _Module.DeleteNonAddRefThunk(_GetRawUnknown());
                _Module.DeleteNonAddRefThunk(m_pOuterUnknown);
        }
#endif

        STDMETHOD_(ULONG, AddRef)() {return OuterAddRef();}
        STDMETHOD_(ULONG, Release)() {return OuterRelease();}
        STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
        {		
				HRESULT hr;
				//
				// Don't delegate QueryInterface to the control IUnknown
				//
                hr = _InternalQueryInterface(iid, ppvObject);
                return hr;
        }
        template <class Q>
        HRESULT STDMETHODCALLTYPE QueryInterface(Q** pp)
        {
                return QueryInterface(__uuidof(Q), (void**)pp);
        }
        //GetControllingUnknown may be virtual if the Base class has declared
        //DECLARE_GET_CONTROLLING_UNKNOWN()
        IUnknown* GetControllingUnknown()
        {
#ifdef _ATL_DEBUG_INTERFACES
                IUnknown* p;
                _Module.AddNonAddRefThunk(m_pOuterUnknown, _T("CComContainedObject2"), &p);
                return p;
#else
                return m_pOuterUnknown;
#endif
        }
};

inline 
HRESULT Fax_HRESULT_FROM_WIN32 (DWORD dwWin32Err)
{
    if (dwWin32Err >= FAX_ERR_START && dwWin32Err <= FAX_ERR_END)
    {
        //
        // Fax specific error code - make a HRESULT using FACILITY_ITF
        //
        return MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, dwWin32Err);
    }
    else
    {
        return HRESULT_FROM_WIN32(dwWin32Err);
    }
}   // Fax_HRESULT_FROM_WIN32

//
//================ PRIVATE INTERFACE FOR FAX SERVER ===========================
//
MIDL_INTERFACE("80459F70-BBC8-4d68-8EAB-75516195EB02")
IFaxServerInner : public IUnknown
{
	STDMETHOD(GetHandle)(/*[out, retval]*/ HANDLE* pFaxHandle) = 0;
};


//
//=========== TRANSLATION BETWEEN BOOL OF C++ AND BOOL OF VB ==============
//
#define bool2VARIANT_BOOL(b)   ((b) ? VARIANT_TRUE : VARIANT_FALSE)
#define VARIANT_BOOL2bool(b)   ((VARIANT_TRUE == (b)) ? true : false)


//
//================ INIT INNER private interface ===========================
//
MIDL_INTERFACE("D0C7F049-22C1-441c-A2F4-675CC53BDF81")
IFaxInitInner : public IUnknown
{
	STDMETHOD(Init)(/*[in]*/ IFaxServerInner* pServer) = 0;
	STDMETHOD(GetFaxHandle)(/*[out]*/ HANDLE *pFaxHandle) = 0;
};


//
//================== INIT INNER IMPLEMENTATION -- NO ADDREF ON SERVER ==================
//
#define     MAX_LENGTH      50

class CFaxInitInner : public IFaxInitInner
{
public:
    CFaxInitInner(TCHAR *tcObjectName) : m_pIFaxServerInner(NULL)
    {
        DBG_ENTER(_T("FAX INIT INNER::CREATE"), _T("ObjectName = %s"), tcObjectName);
        _tcsncpy(m_tstrObjectName, tcObjectName, MAX_LENGTH);    
    
    }

    ~CFaxInitInner()
    {
        DBG_ENTER(_T("FAX INIT INNER::DESTROY"), _T("ObjectName = %s"), m_tstrObjectName);
    }

	STDMETHOD(Init)(/*[in]*/ IFaxServerInner* pServer);
	STDMETHOD(GetFaxHandle)(/*[out]*/ HANDLE *pFaxHandle);

protected:
	IFaxServerInner*	m_pIFaxServerInner;
private:
    TCHAR    m_tstrObjectName[MAX_LENGTH];
};


//
//================== INIT INNER IMPLEMENTATION -- PLUS ADDREF ON SERVER ==================
//
class CFaxInitInnerAddRef : public CFaxInitInner
{
public:
    CFaxInitInnerAddRef(TCHAR *tcObjectName) : CFaxInitInner(tcObjectName)
    {}

    ~CFaxInitInnerAddRef()
    {
        if(m_pIFaxServerInner) 
        {
            m_pIFaxServerInner->Release();
        }
    }

    STDMETHOD(Init)(/*[in]*/ IFaxServerInner* pServer)
    {
        HRESULT     hr = S_OK;
        DBG_ENTER(_T("CFaxInitInnerAddRef::Init"));
        hr = CFaxInitInner::Init(pServer);
        if (SUCCEEDED(hr))
        {
            m_pIFaxServerInner->AddRef();
        }
        return hr;
    };
};


//
//================ COMMON FUNCTONS ============================================
//
UINT GetErrorMsgId(HRESULT hRes);
HRESULT SystemTime2LocalDate(SYSTEMTIME sysTimeFrom, DATE *pdtTo);
HRESULT VarByteSA2Binary(VARIANT varFrom, BYTE **ppbData);
HRESULT Binary2VarByteSA(BYTE *pbDataFrom, VARIANT *pvarTo, DWORD dwLength);
HRESULT GetBstr(BSTR *pbstrTo, BSTR bstrFrom);
HRESULT GetVariantBool(VARIANT_BOOL *pbTo, VARIANT_BOOL bFrom);
HRESULT GetLong(long *plTo, long lFrom);
HRESULT SetExtensionProperty(IFaxServerInner *pServer, long lDeviceId, BSTR bstrGUID, VARIANT vProperty);
HRESULT GetExtensionProperty(IFaxServerInner *pServer, long lDeviceId, BSTR bstrGUID, VARIANT *pvProperty);
HRESULT GetBstrFromDwordlong(/*[in]*/ DWORDLONG  dwlFrom, /*[out]*/ BSTR *pbstrTo);

//
//================== FAX SMART PTR -- BASE VERSION ==================================
//
template <typename T>
class CFaxPtrBase
{
private:
	virtual void Free()
	{
        DBG_ENTER(_T("CFaxPtrBase::Free()"), _T("PTR:%ld"), p);
		if (p)
		{
			FaxFreeBuffer(p);
            p = NULL;
		}
	}

public:
	CFaxPtrBase()
	{
		p = NULL;
	}

	virtual ~CFaxPtrBase()
	{
		Free();
	}

	T** operator&()
	{
		ATLASSERT(p==NULL);
		return &p;
	}

	bool operator!() const
	{
		return (p == NULL);
	}

	operator T*() const
	{
		return (T*)p;
	}

	T* operator=(T* lp)
	{
        DBG_ENTER(_T("CFaxPtrBase::operator=()"));
		Free();
		p = lp;
		return (T*)p;
	}

   	T* Detach()
	{
		T* pt = p;
		p = NULL;
		return pt;
	}

	T* p;
};

//
//================== FAX SMART PTR -- FULL VERSION ==================================
//
template <typename T>
class CFaxPtr : public CFaxPtrBase<T>
{
public:
	T* operator->() const
	{
		ATLASSERT(p!=NULL);
		return (T*)p;
	}
};

//
//======================== OBJECT HANDLER ======================================
//
template<typename ClassName, typename IfcType>
class CObjectHandler
{
public :
    //
    //=================== GET CONTAINED OBJECT =============================================
    //
    HRESULT GetContainedObject(IfcType **ppObject, 
        CComContainedObject2<ClassName> **ppInstanceVar, 
        IFaxServerInner *pServerInner)
    {
    	HRESULT				hr = S_OK;
    	DBG_ENTER (_T("CObjectHandler::GetContainedObject"), hr);

        //
        //  Check that we have got a good ptr
        //
        if (::IsBadWritePtr(ppObject, sizeof(IfcType *))) 
	    {
		    hr = E_POINTER;
		    CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr()"), hr);
		    return hr;
        }

        if (!*ppInstanceVar)
        {
            hr = CreateContainedObject(ppInstanceVar, pServerInner);
            if (FAILED(hr))
            {
                return hr;
            }
        }

	    hr = (*ppInstanceVar)->QueryInterface(ppObject);
        if (FAILED(hr))
        {
		    hr = E_FAIL;
		    CALL_FAIL(GENERAL_ERR, _T("(*ppInstanceVar)->QueryInterface(ppObject)"), hr);
		    return hr;
        }

	    return hr;
    }

    //
    //=================== CREATE CONTAINED OBJECT =============================================
    //
    HRESULT CreateContainedObject(CComContainedObject2<ClassName> **ppObject, IFaxServerInner *pServerInner)
    {
	    HRESULT				hr = S_OK;
	    DBG_ENTER (_T("CObjectHandler::CreateObject"), hr);

        //
        //  Create the Object 
        //
        *ppObject = new CComContainedObject2<ClassName>(pServerInner);

        //
        //  Init the Object
        //
	    hr = (*ppObject)->Init(pServerInner);
	    if (FAILED(hr))
	    {
		    //
		    // Failed to Init the Object
		    //
		    CALL_FAIL(GENERAL_ERR, _T("(*ppObject)->Init(pServerInner)"), hr);
		    return hr;
	    }

        return hr;
    };

    //
    //=================== GET OBJECT =============================================
    //
    HRESULT GetObject(IfcType **ppObject, IFaxServerInner *pServerInner)
    {
        HRESULT		hr = S_OK;
        DBG_ENTER (TEXT("CObjectHandler::GetObject"), hr);

        //
        //  Check that we have got a good ptr
        //
        if (::IsBadWritePtr(ppObject, sizeof(IfcType *))) 
	    {
		    hr = E_POINTER;
		    CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr()"), hr);
		    return hr;
        }

	    //
	    // Create new Object
	    //
	    CComPtr<IfcType>        pObjectTmp;
        hr = ClassName::Create(&pObjectTmp);
	    if (FAILED(hr))
	    {
		    CALL_FAIL(GENERAL_ERR, _T("ClassName::Create(&pObjectTmp)"), hr);
		    return hr;
	    }

	    //
	    //	Get IFaxInitInner Interface from the Object
	    //
	    CComQIPtr<IFaxInitInner> pObjectInit(pObjectTmp);
	    ATLASSERT(pObjectInit);

	    //
	    //	Initialize the Object
	    //
	    hr = pObjectInit->Init(pServerInner);
	    if (FAILED(hr))
	    {
		    CALL_FAIL(GENERAL_ERR, _T("pObjectInit->Init(pServerInner)"), hr);
		    return hr;
	    }

		//
		//	Return the Object
		//
	    hr = pObjectTmp.CopyTo(ppObject);
	    if (FAILED(hr))
	    {
		    CALL_FAIL(GENERAL_ERR, _T("CComPtr::CopyTo"), hr);
		    return hr;
	    }
    	return hr;
    };
};

//
//====================== COLLECTION KILLER =========================================
//
template <typename ContainerType>
class CCollectionKiller
{
public:
    STDMETHODIMP EmptyObjectCollection(ContainerType *pColl)
    {
        HRESULT     hr = S_OK;
        DBG_ENTER(_T("CCollectionKiller::EmptyObjectCollection"));

        //
        //  Release all objects
        //
        ContainerType::iterator it = pColl->begin();
        while ( it != pColl->end())
        {
            (*it++)->Release();
        }

        hr = ClearCollection(pColl);
        return hr;
    };

    STDMETHODIMP ClearCollection(ContainerType *pColl)
    {
        HRESULT     hr = S_OK;
        DBG_ENTER(_T("CCollectionKiller::ClearCollection"), hr);

	    //
	    //	Pop the Objects from the Collection
	    //
	    try 
	    {
		    pColl->clear();
	    }
	    catch (exception &)
	    {
            hr = E_OUTOFMEMORY;
		    CALL_FAIL(MEM_ERR, _T("pColl->clear()"), hr);
	    }
        return hr;
    };
};

#endif	//  __FAXCOMMON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxcomex.cpp ===
// FaxComEx.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f FaxComExps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "FaxComEx.h"
#include "FaxComEx_i.c"

#include "FaxSender.h"
#include "FaxDevice.h"
#include "FaxServer.h"
#include "FaxDevices.h"
#include "FaxFolders.h"
#include "FaxActivity.h"
#include "FaxSecurity.h"
#include "FaxDocument.h"
#include "FaxRecipient.h"
#include "FaxDeviceIds.h"
#include "FaxRecipients.h"
#include "FaxIncomingJob.h"
#include "FaxOutgoingJob.h"
#include "FaxIncomingJobs.h"
#include "FaxOutgoingJobs.h"
#include "FaxEventLogging.h"
#include "FaxOutgoingQueue.h"
#include "FaxIncomingQueue.h"
#include "FaxInboundRouting.h"
#include "FaxLoggingOptions.h"
#include "FaxReceiptOptions.h"
#include "FaxDeviceProvider.h"
#include "FaxIncomingMessage.h"
#include "FaxIncomingArchive.h"
#include "FaxOutgoingArchive.h"
#include "FaxOutgoingMessage.h"
#include "FaxOutboundRouting.h"
#include "FaxDeviceProviders.h"
#include "FaxActivityLogging.h"
#include "FaxOutboundRoutingRule.h"
#include "FaxOutboundRoutingRules.h"
#include "FaxOutboundRoutingGroup.h"
#include "FaxInboundRoutingMethod.h"
#include "FaxInboundRoutingMethods.h"
#include "FaxOutboundRoutingGroups.h"
#include "FaxIncomingMessageIterator.h"
#include "FaxOutgoingMessageIterator.h"
#include "FaxInboundRoutingExtension.h"
#include "FaxInboundRoutingExtensions.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_FaxDocument, CFaxDocument)
OBJECT_ENTRY(CLSID_FaxServer, CFaxServer)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_FAXCOMEXLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxcommon.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxCommon.cpp

Abstract:

	Implementation of common Interfaces and Functions.

Author:

	Iv Garber (IvG)	May, 2000

Revision History:

--*/

#include "StdAfx.h"
#include "resource.h"
#include "FaxComEx.h"
#include "FaxCommon.h"
#include "faxutil.h"
#include "FaxServer.h"

//
//============= GET BSTR FROM DWORDLONG ==========================================
//
HRESULT
GetBstrFromDwordlong(
    /*[in]*/ DWORDLONG  dwlFrom,
    /*[out]*/ BSTR *pbstrTo
)
/*++

Routine name : GetBstrFromDwordlong

Routine description:

	Convert DWORDLONG into BSTR. Used in Message, and in Events in Server.

Author:

	Iv Garber (IvG),	Jul, 2000

Arguments:

	dwlFrom                       [in]    - DWORDLONG value to convert to BSTR
	pbstrTo                       [out]    - ptr to the BSTR to return

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("GetBstrFromDwordlong"), hr, _T("DWORDLONG=%ld"), dwlFrom);

    //
    //  Convert DWORDLONG into buffer of TCHARs
    //
    TCHAR   tcBuffer[25];
    ::_i64tot(dwlFrom, tcBuffer, 16);

    //
    //  Create BSTR from that buffer
    //
    BSTR    bstrTemp;
    bstrTemp = ::SysAllocString(tcBuffer);
    if (!bstrTemp)
    {
        //
        //  Not enough memory
        //
        hr = E_OUTOFMEMORY;
        CALL_FAIL(MEM_ERR, _T("SysAllocString()"), hr);
        return hr;
    }

    //
    //  Return created BSTR
    //
    *pbstrTo = bstrTemp;
    return hr;
}

//
//===================== GET EXTENSION PROPERTY ===============================================
//
HRESULT
GetExtensionProperty(
    /*[in]*/ IFaxServerInner *pServer,
    /*[in]*/ long lDeviceId,
    /*[in]*/ BSTR bstrGUID, 
    /*[out, retval]*/ VARIANT *pvProperty
)
/*++

Routine name : GetExtensionProperty

Routine description:

	Retrieves the Extension Data by given GUID from the Server.
    Used by FaxServer and FaxDevice Classes.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

    pServer                   [in]    --  Ptr to the Fax Server Object
    lDeviceId                 [in]    --  Device Id with which the Extension Property is assosiated
    bstrGUID                  [in]    --  Extension's Data GUID
    pvProperty                [out]    --  Variant with the Blob to Return

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("GetExtensionProperty"), hr, _T("GUID=%s"), bstrGUID);

	//
	//	Get Fax Server Handle
	//
    HANDLE faxHandle;
	hr = pServer->GetHandle(&faxHandle);
    ATLASSERT(SUCCEEDED(hr));

	if (faxHandle == NULL)
	{
		//
		//	Fax Server is not connected
		//
		hr = Fax_HRESULT_FROM_WIN32(ERROR_NOT_CONNECTED);
		CALL_FAIL(GENERAL_ERR, _T("faxHandle == NULL"), hr);
		return hr;
	}

    //
    //  Ask Server to Get the Extension Property we want
    //
    CFaxPtrBase<void>   pData;
    DWORD               dwSize = 0;
    if (!FaxGetExtensionData(faxHandle, lDeviceId, bstrGUID, &pData, &dwSize))
    {
		hr = Fax_HRESULT_FROM_WIN32(GetLastError());
		CALL_FAIL(GENERAL_ERR, _T("FaxGetExtensionData(faxHandle, m_lID, bstrGUID, &pData, &dwSize)"), hr);
		return hr;
    }

    //
    //  Create SafeArray to Return to User
    //
    hr = Binary2VarByteSA(((BYTE *)(pData.p)), pvProperty, dwSize);
    if (FAILED(hr))
    {
        return hr;
    }

    return hr; 
};

//
//===================== SET EXTENSION PROPERTY ===============================================
//  TODO:   should work with empty vProperty
//
HRESULT
SetExtensionProperty(
    /*[in]*/ IFaxServerInner *pServer,
    /*[in]*/ long lDeviceId,
    /*[in]*/ BSTR bstrGUID, 
    /*[in]*/ VARIANT vProperty
)
/*++

Routine name : SetExtensionProperty

Routine description:

	Used by FaxDevice and FaxServer Classes, to Set the Extension Data by given GUID on the Server.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

    pServer                   [in]    --  Ptr to the Fax Server Object
    lDeviceId                 [in]    --  Device Id with which the Extension Property is assosiated
    bstrGUID                  [in]    --  Extension's Data GUID
    vProperty                 [in]    --  Variant with the Blob to Set

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("SetExtensionProperty"), hr, _T("GUID=%s"), bstrGUID);

	//
	//	Get Fax Server Handle
	//
    HANDLE faxHandle;
	hr = pServer->GetHandle(&faxHandle);
    ATLASSERT(SUCCEEDED(hr));

	if (faxHandle == NULL)
	{
		//
		//	Fax Server is not connected
		//
		hr = Fax_HRESULT_FROM_WIN32(ERROR_NOT_CONNECTED);
		CALL_FAIL(GENERAL_ERR, _T("faxHandle == NULL"), hr);
		return hr;
	}

    //
    //  check that Variant contains SafeArray
    //
    if (vProperty.vt != (VT_ARRAY | VT_UI1))
    {
        hr = E_INVALIDARG;
        CALL_FAIL(GENERAL_ERR, _T("(vProperty.vt != VT_ARRAY | VT_BYTE)"), hr);
        return hr;
    }

    //
    //  Create Binary from the SafeArray we got
    //
    CFaxPtrLocal<void>  pData;
    hr = VarByteSA2Binary(vProperty, (BYTE **)&pData);
    if (FAILED(hr))
    {
        return hr;
    }

    //
    //  Ask Server to Set the Extension Property we want
    //
    DWORD       dwLength = vProperty.parray->rgsabound[0].cElements;
    if (!FaxSetExtensionData(faxHandle, lDeviceId, bstrGUID, pData, dwLength))
    {
		hr = Fax_HRESULT_FROM_WIN32(GetLastError());
		CALL_FAIL(GENERAL_ERR, _T("FaxSetExtensionData(faxHandle, m_lID, bstrGUID, &pData, dwLength)"), hr);
		return hr;
    }

    return hr; 
};

//
//========================= GET LONG ========================================
//
HRESULT GetLong(
	long    *plTo, 
    long    lFrom
)
/*++

Routine name : GetLong

Routine description:

	Check that plTo is valid
    Copy the given lFrom into plTo

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	plTo                [out]    - Ptr to put the value
    lFrom               [in]    -  value to put
    
Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("GetLong"), hr, _T("lFrom=%d"), lFrom);

	//
	//	Check that we have got good Ptr
	//
	if (::IsBadWritePtr(plTo, sizeof(long)))
	{
		hr = E_POINTER;
		CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr(plTo, sizeof(long))"), hr);
		return hr;
	}

	*plTo = lFrom;
	return hr;
}

//
//========================= GET VARIANT BOOL ========================================
//
HRESULT GetVariantBool(
	VARIANT_BOOL    *pbTo, 
    VARIANT_BOOL    bFrom
)
/*++

Routine name : GetVariantBool

Routine description:

	Check that pbTo is valid
    Copy the given bFrom into pbTo

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	pbTo                [out]    - Ptr to put the value
    bFrom               [in]    -  value to put
    
Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("GetVariantBool"), hr, _T("bFrom=%d"), bFrom);

	//
	//	Check that we have got good Ptr
	//
	if (::IsBadWritePtr(pbTo, sizeof(VARIANT_BOOL)))
	{
		hr = E_POINTER;
		CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr(pbTo, sizeof(VARIANT_BOOL))"), hr);
		return hr;
	}

	*pbTo = bFrom;
	return hr;
}

//
//========================= GET BSTR ========================================
//
HRESULT GetBstr(
	BSTR    *pbstrTo, 
    BSTR    bstrFrom
)
/*++

Routine name : GetBstr

Routine description:

	Check that pbstTo is valid
    SysAllocString for bstrFrom
    Copy the newly created string into pbstrTo

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	pbstrTo                [out]    - Ptr to put the value
    bstrFrom               [in]    -   Ptr to the string to return 
    
Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("GetBstr"), hr, _T("String=%s"), bstrFrom);

	//
	//	Check that we have got good Ptr
	//
	if (::IsBadWritePtr(pbstrTo, sizeof(BSTR)))
	{
		hr = E_POINTER;
		CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr(pbstrTo, sizeof(BSTR))"), hr);
		return hr;
	}

    //
    //  First copy the string locally
    //
	BSTR	bstrTemp;
    bstrTemp = ::SysAllocString(bstrFrom);
	if (!bstrTemp && bstrFrom)
	{
		hr = E_OUTOFMEMORY;
		CALL_FAIL(MEM_ERR, _T("::SysAllocString(bstrFrom)"), hr);
		return hr;
	}

	*pbstrTo = bstrTemp;
	return hr;
}

//
//======= CONVERNT BYTE BLOB INTO VARIANT CONTAINING BYTE SAFE ARRAY  ============
//
HRESULT Binary2VarByteSA(
    BYTE *pbDataFrom, 
    VARIANT *pvarTo,
    DWORD   dwLength
)
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("Binary2VarByteSA"), hr, _T("Size=%d"), dwLength);

    //
    //  Allocate the safe array : vector of Unsigned Chars
    //
    SAFEARRAY *pSafeArray;
	pSafeArray = ::SafeArrayCreateVector(VT_UI1, 0, dwLength);
	if (pSafeArray == NULL)
	{
		//
		//	Not Enough Memory
		//
		hr = E_OUTOFMEMORY;
		CALL_FAIL(MEM_ERR, _T("::SafeArrayCreateVector(VT_UI1, 0, dwLength)"), hr);
		return hr;
	}

    //
    //  get Access to the elements of the Safe Array
    //
	BYTE *pbElement;
	hr = ::SafeArrayAccessData(pSafeArray, (void **) &pbElement);
	if (FAILED(hr))
	{
		//
		//	Failed to access safearray
		//
        hr = E_FAIL;
		CALL_FAIL(GENERAL_ERR, _T("::SafeArrayAccessData(pSafeArray, &pbElement)"), hr);
        SafeArrayDestroy(pSafeArray);
		return hr;
	}

    //
    //  Fill the Safe Array with the bytes from pbDataFrom
    //
    memcpy(pbElement, pbDataFrom, dwLength);

	hr = ::SafeArrayUnaccessData(pSafeArray);
    if (FAILED(hr))
    {
	    CALL_FAIL(GENERAL_ERR, _T("::SafeArrayUnaccessData(pSafeArray)"), hr);
    }

    //
    //  Return the Safe Array inside the VARIANT we got
    //
    VariantInit(pvarTo);
    pvarTo->vt = VT_UI1 | VT_ARRAY;
    pvarTo->parray = pSafeArray;
    return hr;
}


//
//======= CONVERNT VARIANT CONTAINING BYTE SAFE ARRAY INTO POINTER TO BYTES BLOB =========
//
HRESULT 
VarByteSA2Binary(
    VARIANT varFrom, 
    BYTE **ppbData
)
{
    HRESULT hr = S_OK;
    DBG_ENTER(_T("VarByteSA2Binary"), hr);

    //
    // Check that Variant has right type
    //
    if ((varFrom.vt !=  VT_UI1) && (varFrom.vt != (VT_UI1 | VT_ARRAY)))
    {
        hr = E_INVALIDARG;
        CALL_FAIL(GENERAL_ERR, _T("pVarFrom->vt not VT_UI1 or VT_UI1 | VT_ARRAY"), hr);
        return hr;
    }
  
    ULONG       ulNum = 0;
    SAFEARRAY   *pSafeArray = NULL;

    //
    // Is there is only one member ?
    //
    if (varFrom.vt == VT_UI1)
    {
        ulNum = 1;
    }
    else
    {
        //
        // Get safe array values
        //
        pSafeArray = varFrom.parray;

        if (!pSafeArray)
        {
            hr = E_INVALIDARG;
            CALL_FAIL(GENERAL_ERR, _T("!pSafeArray ( = varFrom.parray )"), hr);
            return hr;        
        }

        if (SafeArrayGetDim(pSafeArray) != 1)
        {
            hr = E_INVALIDARG;
            CALL_FAIL(GENERAL_ERR, _T("SafeArrayGetDim(pSafeArray) != 1"), hr);
            return hr;        
        }

        if (pSafeArray->rgsabound[0].lLbound != 0)
        {
            hr = E_INVALIDARG;
            CALL_FAIL(GENERAL_ERR, _T("pSafeArray->rgsabound[0].lLbound != 0"), hr);
            return hr;        
        }

        ulNum = pSafeArray->rgsabound[0].cElements;
    }

    //
    //  Allocate memory for the safearray
    //
    *ppbData = (BYTE *)MemAlloc(ulNum);
	if (!*ppbData)
	{
		//
		//	Not enough memory
		//
		hr = E_OUTOFMEMORY;
		CALL_FAIL(MEM_ERR, _T("MemAlloc(sizeof(ulNum)"), hr);
		return hr;
	}
    ZeroMemory(*ppbData, ulNum);

    //
    //  Fill pbData with the values from the pSafeArray
    //
    if (!pSafeArray)
    {
        *ppbData[0] = varFrom.bVal;
    }
    else
    {
        //
        //  Get Access to the Safe Array
        //
        BYTE *pbElement;
	    hr = ::SafeArrayAccessData(pSafeArray, (void **) &pbElement);
	    if (FAILED(hr))
	    {
            hr = E_FAIL;
		    CALL_FAIL(GENERAL_ERR, _T("::SafeArrayAccessData(pSafeArray, &pbElement)"), hr);
		    return hr;
	    }

        //
        //  Fill pbData with the values from the Safe Array 
        //
        memcpy(*ppbData, pbElement, ulNum);

        hr = ::SafeArrayUnaccessData(pSafeArray);
        if (FAILED(hr))
        {
	        CALL_FAIL(GENERAL_ERR, _T("::SafeArrayUnaccessData(pSafeArray)"), hr);
        }

    }
    return hr;
}

//
//======================= INIT ============================================
//
STDMETHODIMP
CFaxInitInner::Init(
	/*[in]*/ IFaxServerInner* pServer
)
/*++

Routine name : CFaxInitInner::Init

Routine description:

	Store Ptr to the Fax Server. Used in most of the objects

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pServer                       [in]    - Ptr to the Fax Server

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT hr = S_OK;
	DBG_ENTER (TEXT("CFaxInitInner::Init"), hr);
	m_pIFaxServerInner = pServer;
	return hr;
}

//
//======================= GET FAX HANDLE ============================================
//
STDMETHODIMP
CFaxInitInner::GetFaxHandle(
	/*[in]*/ HANDLE* pFaxHandle
)
/*++

Routine name : CFaxInitInner::GetFaxHandle

Routine description:

	Ask m_pIServerInner for handle to the fax server and handle error

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	pFaxHandle						[out]    - Ptr to the returned Fax Handle

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT hr = S_OK;

	DBG_ENTER (TEXT("CFaxInitInner::GetFaxHandle"), hr);

	//
	//	Get Fax Server Handle
	//
	hr = m_pIFaxServerInner->GetHandle(pFaxHandle);
    ATLASSERT(SUCCEEDED(hr));

	if (*pFaxHandle == NULL)
	{
		//
		//	Fax Server is not connected
		//
		hr = Fax_HRESULT_FROM_WIN32(ERROR_NOT_CONNECTED);
		CALL_FAIL(GENERAL_ERR, _T("hFaxHandle==NULL"), hr);
		return hr;
	}

	return hr;
}

//
//======================= GET ERROR MESSAGE ID ================================
//
UINT 
GetErrorMsgId(
	HRESULT hRes
)
/*++

Routine name : GetErrorMsgId

Routine description:

	Return IDS of the Message according to the given result of the RPC call
		and not only RPC

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	hRes                         [in]    - the RPC call result

Return Value:

    UINT IDS of the Message to show to the User

--*/
{
	switch(hRes)
	{
        case E_POINTER:
	    case HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER):
		    return IDS_ERROR_INVALID_ARGUMENT;

        case E_OUTOFMEMORY:
	    case HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY):
		    return IDS_ERROR_OUTOFMEMORY;

	    case HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED):
		    return IDS_ERROR_ACCESSDENIED;

	    case E_HANDLE:
        case HRESULT_FROM_WIN32(ERROR_NOT_CONNECTED):
            return IDS_ERROR_SERVER_NOT_CONNECTED;

	    case HRESULT_FROM_WIN32(RPC_S_INVALID_BINDING):
	    case HRESULT_FROM_WIN32(EPT_S_CANT_PERFORM_OP):
	    case HRESULT_FROM_WIN32(RPC_S_ADDRESS_ERROR):
	    case HRESULT_FROM_WIN32(RPC_S_CALL_CANCELLED):
	    case HRESULT_FROM_WIN32(RPC_S_CALL_FAILED):
	    case HRESULT_FROM_WIN32(RPC_S_CALL_FAILED_DNE):
	    case HRESULT_FROM_WIN32(RPC_S_COMM_FAILURE):
	    case HRESULT_FROM_WIN32(RPC_S_NO_BINDINGS):
	    case HRESULT_FROM_WIN32(RPC_S_SERVER_TOO_BUSY):
	    case HRESULT_FROM_WIN32(RPC_S_SERVER_UNAVAILABLE):
		    return IDS_ERROR_CONNECTION_FAILED;

        case HRESULT_FROM_WIN32(ERROR_WRITE_PROTECT):
            return IDS_ERROR_QUEUE_BLOCKED;

        case FAX_E_FILE_ACCESS_DENIED:
            return IDS_ERROR_FILE_ACCESS_DENIED;

        case FAX_E_SRV_OUTOFMEMORY:
            return IDS_ERROR_SRV_OUTOFMEMORY;

        case FAX_E_GROUP_NOT_FOUND:
            return IDS_ERROR_GROUP_NOT_FOUND;

        case FAX_E_BAD_GROUP_CONFIGURATION:
            return IDS_ERROR_BAD_GROUP_CONFIGURATION;

        case FAX_E_GROUP_IN_USE:
            return IDS_ERROR_GROUP_IN_USE;

        case FAX_E_RULE_NOT_FOUND:
            return IDS_ERROR_RULE_NOT_FOUND;

        case FAX_E_NOT_NTFS:
            return IDS_ERROR_NOT_NTFS;

        case FAX_E_DIRECTORY_IN_USE:
            return IDS_ERROR_DIRECTORY_IN_USE;

        case FAX_E_MESSAGE_NOT_FOUND:
            return IDS_ERROR_MESSAGE_NOT_FOUND;

        case FAX_E_DEVICE_NUM_LIMIT_EXCEEDED:
            return IDS_ERROR_DEVICE_NUM_LIMIT_EXCEEDED;

        case FAX_E_NOT_SUPPORTED_ON_THIS_SKU:
            return IDS_ERROR_NOT_SUPPORTED_ON_THIS_SKU;

        case FAX_E_VERSION_MISMATCH:
            return IDS_ERROR_VERSION_MISMATCH;

	    default:
		    return IDS_ERROR_OPERATION_FAILED;
	}
}

//
//====================== SYSTEM TIME TO LOCAL DATE ============================================
//
HRESULT
SystemTime2LocalDate(
    SYSTEMTIME sysTimeFrom, 
    DATE *pdtTo
)
/*++

Routine name : SystemTime2LocalDate

Routine description:

    Convert the System Time stored in FAX_MESSAGE struct to the DATE understood by client

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    tmFrom          [in]    - the System time to convert
    pdtTo           [out]   - the Date to return

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;

    DBG_ENTER (TEXT("SystemTime2LocalDate"), hr);

    //
    //  convert System Time to File Time
    //
    FILETIME fileSysTime;
    if(!SystemTimeToFileTime(&sysTimeFrom, &fileSysTime))
    {
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        CALL_FAIL (GENERAL_ERR, _T("SystemTimeToFileTime"), hr);
        return hr;
    }

    //
    //  convert File Time to Local File Time
    //
    FILETIME fileLocalTime;
    if(!FileTimeToLocalFileTime(&fileSysTime, &fileLocalTime))
    {
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        CALL_FAIL (GENERAL_ERR, _T("FileTimeToLocalFileTime"), hr);
        return hr;
    }

    //
    //  convert Local File Time back to System Time
    //
    if(!FileTimeToSystemTime(&fileLocalTime, &sysTimeFrom))
    {
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        CALL_FAIL (GENERAL_ERR, _T("FileTimeToSystemTime"), hr);
        return hr;
    }

    //
    //  finally, convert now local System Time to Variant Time
    //
    if (!SystemTimeToVariantTime(&sysTimeFrom, pdtTo))
    {
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        CALL_FAIL (GENERAL_ERR, _T("SystemTimeToVariantTime"), hr);
        return hr;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxdevice.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    FaxDevice.cpp

Abstract:

    Implementation of CFaxDevice class.

Author:

    Iv Garber (IvG) Jun, 2000

Revision History:

--*/

#include "stdafx.h"
#include "FaxComEx.h"
#include "FaxDevice.h"
#include "..\..\inc\FaxUIConstants.h"


//
//===================== ANSWER CALL ================================================
//
STDMETHODIMP
CFaxDevice::AnswerCall()
/*++

Routine name : CFaxDevice::AnswerCall

Routine description:

    Answer a Call when Manual Answer is set ON. The lCallId parameter is received from  OnNewCall notification.

Author:

    Iv Garber (IvG),    Dec, 2000

Arguments:


Return Value:

    Standard HRESULT code

--*/
{
    HRESULT hr = S_OK;
    DBG_ENTER(_T("CFaxDevice::AnswerCall"), hr);

    //
    //  Get Fax Server Handle
    //
    HANDLE faxHandle;
    hr = m_pIFaxServerInner->GetHandle(&faxHandle);
    ATLASSERT(SUCCEEDED(hr));

    if (faxHandle == NULL)
    {
        //
        //  Fax Server is not connected
        //
        hr = Fax_HRESULT_FROM_WIN32(ERROR_NOT_CONNECTED);
        CALL_FAIL(GENERAL_ERR, _T("faxHandle == NULL"), hr);
        AtlReportError(CLSID_FaxDevice, GetErrorMsgId(hr), IID_IFaxDevice, hr, _Module.GetResourceInstance());
        return hr;
    }

    //
    //  Ask Server to Answer the Call
    //
    if (!FaxAnswerCall(faxHandle, m_lID))
    {
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        CALL_FAIL(GENERAL_ERR, _T("FaxAnswerCall(faxHandle, lCallId, m_lID)"), hr);
        AtlReportError(CLSID_FaxDevice, GetErrorMsgId(hr), IID_IFaxDevice, hr, _Module.GetResourceInstance());
        return hr;
    }

    return hr;
}


//
//===================== GET RINGING NOW ================================================
//
STDMETHODIMP
CFaxDevice::get_RingingNow(
    /*[out, retval]*/ VARIANT_BOOL *pbRingingNow
)
/*++

Routine name : CFaxDevice::get_RingingNow

Routine description:

    Return whether or not the Device was ringing at the moment the properties were taken.

Author:

    Iv Garber (IvG),    Dec, 2000

Arguments:

    pbRingingNow            [out]    - the result

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxDevice::get_RingingNow"), hr);

    hr = GetVariantBool(pbRingingNow, bool2VARIANT_BOOL(m_dwStatus & FAX_DEVICE_STATUS_RINGING));
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxDevice, GetErrorMsgId(hr), IID_IFaxDevice, hr, _Module.GetResourceInstance());
        return hr;
    }
    return hr;
};

//
//===================== GET RECEIVING NOW ================================================
//
STDMETHODIMP
CFaxDevice::get_ReceivingNow(
    /*[out, retval]*/ VARIANT_BOOL *pbReceivingNow
)
/*++

Routine name : CFaxDevice::get_ReceivingNow

Routine description:

    Return whether or not the Device was receiving when the properties were taken.

Author:

    Iv Garber (IvG),    Jul, 2000

Arguments:

    pbReceivingNow            [out]    - the result

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxDevice::get_ReceivingNow"), hr);

    hr = GetVariantBool(pbReceivingNow, bool2VARIANT_BOOL(m_dwStatus & FAX_DEVICE_STATUS_RECEIVING));
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxDevice, GetErrorMsgId(hr), IID_IFaxDevice, hr, _Module.GetResourceInstance());
        return hr;
    }
    return hr;
};

//
//===================== GET SENDING NOW ================================================
//
STDMETHODIMP
CFaxDevice::get_SendingNow(
    /*[out, retval]*/ VARIANT_BOOL *pbSendingNow
)
/*++

Routine name : CFaxDevice::get_SendingNow

Routine description:

    Return whether or not the Device was sending when the properties were taken.

Author:

    Iv Garber (IvG),    Jul, 2000

Arguments:

    pbSendingNow            [out]    - the result

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxDevice::get_SendingNow"), hr);

    hr = GetVariantBool(pbSendingNow, bool2VARIANT_BOOL(m_dwStatus & FAX_DEVICE_STATUS_SENDING));
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxDevice, GetErrorMsgId(hr), IID_IFaxDevice, hr, _Module.GetResourceInstance());
        return hr;
    }
    return hr;
};

//
//===================== SET EXTENSION PROPERTY ===============================================
//  TODO:   should work with empty vProperty
//
STDMETHODIMP
CFaxDevice::SetExtensionProperty(
    /*[in]*/ BSTR bstrGUID, 
    /*[in]*/ VARIANT vProperty
)
/*++

Routine name : CFaxDevice::SetExtensionProperty

Routine description:

    Set the Extension Data by given GUID on the Server.

Author:

    Iv Garber (IvG),    Jun, 2000

Arguments:

    bstrGUID                  [in]    --  Extension's Data GUID
    vProperty                 [out]    --  Variant with the Blob to Set

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxDevice::SetExtensionProperty()"), hr, _T("GUID=%s"), bstrGUID);

    hr = ::SetExtensionProperty(m_pIFaxServerInner, m_lID, bstrGUID, vProperty);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxDevice, GetErrorMsgId(hr), IID_IFaxDevice, hr, _Module.GetResourceInstance());
        return hr;
    }

    return hr;
};

//
//===================== GET EXTENSION PROPERTY ===============================================
//
STDMETHODIMP
CFaxDevice::GetExtensionProperty(
    /*[in]*/ BSTR bstrGUID, 
    /*[out, retval]*/ VARIANT *pvProperty
)
/*++

Routine name : CFaxDevice::GetExtensionProperty

Routine description:

    Retrieves the Extension Data by given GUID from the Server.

Author:

    Iv Garber (IvG),    Jun, 2000

Arguments:

    bstrGUID                  [in]    --  Extension's Data GUID
    pvProperty                [out]    --  Variant with the Blob to Return

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxDevice::GetExtensionProperty()"), hr, _T("GUID=%s"), bstrGUID);

    hr = ::GetExtensionProperty(m_pIFaxServerInner, m_lID, bstrGUID, pvProperty);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxDevice, GetErrorMsgId(hr), IID_IFaxDevice, hr, _Module.GetResourceInstance());
        return hr;
    }

    return hr;
};

//
//===================== USE ROUTING METHOD ===============================================
//
STDMETHODIMP
CFaxDevice::UseRoutingMethod(
    /*[in]*/ BSTR bstrMethodGUID, 
    /*[in]*/ VARIANT_BOOL bUse
)
/*++

Routine name : CFaxDevice::UseRoutingMethod

Routine description:

    Add/Remove Routing Method for the Device.

Author:

    Iv Garber (IvG),    Jun, 2000

Arguments:

    bstrMethodGUID          [in]    --  Method to Add/Remove
    bUse                    [in]    --  Add or Remove Operation Indicator


Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxDevice::UseRoutingMethod()"), hr, _T("MethodGUID=%s, bUse=%d"), bstrMethodGUID, bUse);

    //
    //  Get Fax Server Handle
    //
    HANDLE faxHandle;
    hr = m_pIFaxServerInner->GetHandle(&faxHandle);
    ATLASSERT(SUCCEEDED(hr));

    if (faxHandle == NULL)
    {
        //
        //  Fax Server is not connected
        //
        hr = Fax_HRESULT_FROM_WIN32(ERROR_NOT_CONNECTED);
        CALL_FAIL(GENERAL_ERR, _T("faxHandle == NULL"), hr);
        AtlReportError(CLSID_FaxDevice, GetErrorMsgId(hr), IID_IFaxDevice, hr, _Module.GetResourceInstance());
        return hr;
    }
    //
    //  Open Port for the Device
    //
    HANDLE  hPort;
    if (!FaxOpenPort(faxHandle, m_lID, PORT_OPEN_MODIFY, &hPort))
    {
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        CALL_FAIL(GENERAL_ERR, _T("FaxOpenPort(faxHandle, m_lID, PORT_OPEN_QUERY, &hPort)"), hr);
        AtlReportError(CLSID_FaxDevice, GetErrorMsgId(hr), IID_IFaxDevice, hr, _Module.GetResourceInstance());
        return hr;
    }
    ATLASSERT(hPort);
    //
    //  Ask Server to Add/Remove the Method for the Device
    //
    if (!FaxEnableRoutingMethod(hPort, bstrMethodGUID, VARIANT_BOOL2bool(bUse)))
    {
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        CALL_FAIL(GENERAL_ERR, _T("FaxEnableRoutingMethod(faxHandle, bstrMethodGUID, VARIANT_BOOL2bool(bUse))"), hr);
        AtlReportError(CLSID_FaxDevice, GetErrorMsgId(hr), IID_IFaxDevice, hr, _Module.GetResourceInstance());
        goto exit;
    }
exit:
    if (!FaxClose(hPort))
    {
        CALL_FAIL(GENERAL_ERR, _T("FaxClose(hPort)"), Fax_HRESULT_FROM_WIN32(GetLastError()));
    } 
    //
    //  no need to store change locally, because each time get_UsedRoutingMethods is used,
    //  it brings the updated data from the Server.
    //
    return hr; 
}   // CFaxDevice::UseRoutingMethod

//
//===================== SAVE ===============================================
//
STDMETHODIMP
CFaxDevice::Save()
/*++

Routine name : CFaxDevice::Save

Routine description:

    Save the data of the Device to the Server.

Author:

    Iv Garber (IvG),    Jun, 2000

Arguments:


Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxDevice::Save()"), hr);

    //
    //  Get Fax Server Handle
    //
    HANDLE faxHandle;
    hr = m_pIFaxServerInner->GetHandle(&faxHandle);
    ATLASSERT(SUCCEEDED(hr));

    if (faxHandle == NULL)
    {
        //
        //  Fax Server is not connected
        //
        hr = Fax_HRESULT_FROM_WIN32(ERROR_NOT_CONNECTED);
        CALL_FAIL(GENERAL_ERR, _T("faxHandle == NULL"), hr);
        AtlReportError(CLSID_FaxDevice, GetErrorMsgId(hr), IID_IFaxDevice, hr, _Module.GetResourceInstance());
        return hr;
    }

    //
    //  Create FAX_PORT_INFO struct and fill it with the values
    //
    FAX_PORT_INFO_EX        Data = {0};

    Data.ReceiveMode = m_ReceiveMode;
    Data.bSend = m_bSendEnabled;

    Data.dwRings = m_lRings;
    Data.dwSizeOfStruct = sizeof(FAX_PORT_INFO_EX);

    Data.lptstrCsid = m_bstrCSID;
    Data.lptstrDescription = m_bstrDescr;
    Data.lptstrTsid = m_bstrTSID;

    //
    //  Save the Data struct on Server
    //
    if (!FaxSetPortEx(faxHandle, m_lID, &Data))
    {
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        CALL_FAIL(GENERAL_ERR, _T("FaxSetPortEx(faxHandle, m_lID, &Data)"), hr);
        AtlReportError(CLSID_FaxDevice, GetErrorMsgId(hr), IID_IFaxDevice, hr, _Module.GetResourceInstance());
        return hr;
    }

    return hr; 
};

//
//===================== REFRESH ===============================================
//
STDMETHODIMP
CFaxDevice::Refresh()
/*++

Routine name : CFaxDevice::Refresh

Routine description:

    Bring from the Server data for the Device.

Author:

    Iv Garber (IvG),    Jun, 2000

Arguments:


Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxDevice::Refresh()"), hr);

    //
    //  Get Fax Server Handle
    //
    HANDLE faxHandle;
    hr = m_pIFaxServerInner->GetHandle(&faxHandle);
    ATLASSERT(SUCCEEDED(hr));

    if (faxHandle == NULL)
    {
        //
        //  Fax Server is not connected
        //
        hr = Fax_HRESULT_FROM_WIN32(ERROR_NOT_CONNECTED);
        CALL_FAIL(GENERAL_ERR, _T("faxHandle == NULL"), hr);
        AtlReportError(CLSID_FaxDevice, GetErrorMsgId(hr), IID_IFaxDevice, hr, _Module.GetResourceInstance());
        return hr;
    }

    //
    //  Ask Server for Data about Device
    //
    CFaxPtr<FAX_PORT_INFO_EX>   pDevice;
    if (!FaxGetPortEx(faxHandle, m_lID, &pDevice))
    {
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        CALL_FAIL(GENERAL_ERR, _T("FaxGetPortEx(faxHandle, m_lId, &pDevice)"), hr);
        AtlReportError(CLSID_FaxDevice, GetErrorMsgId(hr), IID_IFaxDevice, hr, _Module.GetResourceInstance());
        return hr;
    }
    hr = Init(pDevice, NULL);
    return hr; 
};

//
//================== GET USED ROUTING METHODS ==================================
//
STDMETHODIMP
CFaxDevice::get_UsedRoutingMethods(
    /*[out, retval]*/ VARIANT *pvUsedRoutingMethods
)
/*++

Routine name : CFaxDevice::get_UsedRoutingMethods

Routine description:

    Return Variant containing the SafeArray of Used by the Device Routing Methods GUIDs.

Author:

    Iv Garber (IvG),    Jun, 2000

Arguments:

    pvUsedRoutingMethods          [out]    - the Variant containing the Result

Return Value:

    Standard HRESULT code

--*/

{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxDevice::get_UsedRoutingMethods"), hr);

    //
    //  Get Fax Server Handle
    //
    HANDLE faxHandle;
    hr = m_pIFaxServerInner->GetHandle(&faxHandle);
    ATLASSERT(SUCCEEDED(hr));

    if (faxHandle == NULL)
    {
        //
        //  Fax Server is not connected
        //
        hr = Fax_HRESULT_FROM_WIN32(ERROR_NOT_CONNECTED);
        CALL_FAIL(GENERAL_ERR, _T("faxHandle == NULL"), hr);
        AtlReportError(CLSID_FaxDevice, GetErrorMsgId(hr), IID_IFaxDevice, hr, _Module.GetResourceInstance());
        return hr;
    }

    //
    //  Open Port for the Device
    //
    HANDLE  portHandle;
    if (!FaxOpenPort(faxHandle, m_lID, PORT_OPEN_QUERY, &portHandle))
    {
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        CALL_FAIL(GENERAL_ERR, _T("FaxOpenPort(faxHandle, m_lID, PORT_OPEN_QUERY, &portHandle)"), hr);
        AtlReportError(CLSID_FaxDevice, GetErrorMsgId(hr), IID_IFaxDevice, hr, _Module.GetResourceInstance());
        return hr;
    }
    ATLASSERT(portHandle);

    //
    //  Bring from the Server all Device's Routing Methods
    //
    DWORD       dwNum = 0;
    CFaxPtr<FAX_ROUTING_METHOD>   pMethods;
    BOOL    bResult = FaxEnumRoutingMethods(portHandle, &pMethods, &dwNum);
    if (!bResult)
    {
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        CALL_FAIL(GENERAL_ERR, _T("FaxEnumRoutingMethods(portHandle, &pMethods, &dwNum)"), hr);
        AtlReportError(CLSID_FaxDevice, GetErrorMsgId(hr), IID_IFaxDevice, hr, _Module.GetResourceInstance());
        if (!FaxClose(portHandle))
        {
            CALL_FAIL(GENERAL_ERR, _T("FaxClose(portHandle)"), Fax_HRESULT_FROM_WIN32(GetLastError()));
        }        
        return hr;
    }

    if (!FaxClose(portHandle))
    {
        CALL_FAIL(GENERAL_ERR, _T("FaxClose(portHandle)"), Fax_HRESULT_FROM_WIN32(GetLastError()));
    }        

    //
    //  Create SafeArray
    //
    SAFEARRAY *psaGUIDs;
    psaGUIDs = ::SafeArrayCreateVector(VT_BSTR, 0, dwNum);
    if (!psaGUIDs)
    {
        hr = E_FAIL;
        CALL_FAIL(GENERAL_ERR, _T("SafeArrayCreateVector(VT_BSTR, 0, dwNum)"), hr);
        AtlReportError(CLSID_FaxDevice, GetErrorMsgId(hr), IID_IFaxDevice, hr, _Module.GetResourceInstance());
        return hr;
    }

    //
    //  Got Access to the SafeArray
    //
    BSTR    *pbstrElement;
    hr = ::SafeArrayAccessData(psaGUIDs, (void **) &pbstrElement);
    if (FAILED(hr))
    {
        hr = E_FAIL;
        CALL_FAIL(GENERAL_ERR, _T("::SafeArrayAccessData(psaGUIDs, &pbstrElement)"), hr);
        AtlReportError(CLSID_FaxDevice, GetErrorMsgId(hr), IID_IFaxDevice, hr, _Module.GetResourceInstance());
        ::SafeArrayDestroy(psaGUIDs);
        return hr;
    }

    //
    //  Put Methods GUIDs into the SafeArray
    //
    for ( DWORD i=0 ; i<dwNum ; i++ )
    {
        pbstrElement[i] = ::SysAllocString(pMethods[i].Guid);
        if (pMethods[i].Guid && !pbstrElement[i])
        {
            //
            //  Not Enough Memory
            //
            hr = E_OUTOFMEMORY;
            CALL_FAIL(MEM_ERR, _T("::SysAllocString(pMethods[i])"), hr);
            AtlReportError(CLSID_FaxDevice, GetErrorMsgId(hr), IID_IFaxDevice, hr, _Module.GetResourceInstance());
            ::SafeArrayUnaccessData(psaGUIDs);
            ::SafeArrayDestroy(psaGUIDs);
            return hr;
        }
    }

    //
    //  Unaccess the SafeArray
    //
    hr = ::SafeArrayUnaccessData(psaGUIDs);
    if (FAILED(hr))
    {
        CALL_FAIL(GENERAL_ERR, _T("::SafeArrayUnaccessData(psaGUIDs)"), hr);
    }


    //
    //  Put the SafeArray we created into the given Variant
    //
    VariantInit(pvUsedRoutingMethods);
    pvUsedRoutingMethods->vt = VT_BSTR | VT_ARRAY;
    pvUsedRoutingMethods->parray = psaGUIDs;
    return hr;
};

//
//================= PUT DESCRIPTION ======================================
//
STDMETHODIMP 
CFaxDevice::put_Description(
    /*[in]*/ BSTR   bstrDescription
)
/*++

Routine name : CFaxDevice::put_Description

Routine description:

    Set Description

Author:

    Iv Garber (IvG),    Jun, 2000

Arguments:

    bstrDescription                    [in]    - new Description

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (_T("CFaxDevice::put_Description"), hr, _T("Value=%s"), bstrDescription);

    m_bstrDescr = bstrDescription;
    if (!m_bstrDescr && bstrDescription)
    {
        //
        //  Not enough memory
        //
        hr = E_OUTOFMEMORY;
        AtlReportError(CLSID_FaxDevice, IDS_ERROR_OUTOFMEMORY, IID_IFaxDevice, hr, _Module.GetResourceInstance());
        CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
        return hr;
    }

    return hr;
}

//
//================= PUT CSID ======================================
//
STDMETHODIMP 
CFaxDevice::put_CSID (
    /*[in]*/ BSTR   bstrCSID
)
/*++

Routine name : CFaxDevice::put_CSID

Routine description:

    Set CSID

Author:

    Iv Garber (IvG),    Jun, 2000

Arguments:

    bstrCSID                    [in]    - new TSID

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (_T("CFaxDevice::put_CSID"), hr, _T("Value=%s"), bstrCSID);

    if (SysStringLen(bstrCSID) > FXS_TSID_CSID_MAX_LENGTH)
    {
        //
        //  Out of the Range
        //
        hr = E_INVALIDARG;
        AtlReportError(CLSID_FaxDevice, IDS_ERROR_OUTOFRANGE, IID_IFaxDevice, hr, _Module.GetResourceInstance());
        CALL_FAIL(GENERAL_ERR, _T("TSID is too long"), hr);
        return hr;
    }
    
    m_bstrCSID = bstrCSID;
    if (!m_bstrCSID && bstrCSID)
    {
        //
        //  Not enough memory
        //
        hr = E_OUTOFMEMORY;
        AtlReportError(CLSID_FaxDevice, IDS_ERROR_OUTOFMEMORY, IID_IFaxDevice, hr, _Module.GetResourceInstance());
        CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
        return hr;
    }

    return hr;
}

//
//================= PUT TSID ======================================
//
STDMETHODIMP 
CFaxDevice::put_TSID (
    /*[in]*/ BSTR   bstrTSID
)
/*++

Routine name : CFaxDevice::put_TSID

Routine description:

    Set TSID

Author:

    Iv Garber (IvG),    Jun, 2000

Arguments:

    bstrTSID                    [in]    - new TSID

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (_T("CFaxDevice::put_TSID"), hr, _T("Value=%s"), bstrTSID);

    if (SysStringLen(bstrTSID) > FXS_TSID_CSID_MAX_LENGTH)
    {
        //
        //  Out of the Range
        //
        hr = E_INVALIDARG;
        AtlReportError(CLSID_FaxDevice, IDS_ERROR_OUTOFRANGE, IID_IFaxDevice, hr, _Module.GetResourceInstance());
        CALL_FAIL(GENERAL_ERR, _T("TSID is too long"), hr);
        return hr;
    }

    m_bstrTSID = bstrTSID;
    if (!m_bstrTSID && bstrTSID)
    {
        //
        //  Not enough memory
        //
        hr = E_OUTOFMEMORY;
        AtlReportError(CLSID_FaxDevice, IDS_ERROR_OUTOFMEMORY, IID_IFaxDevice, hr, _Module.GetResourceInstance());
        CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
        return hr;
    }

    return hr;
}

//
//=============== PUT RECEIVE MODE =====================================================
//
STDMETHODIMP
CFaxDevice::put_ReceiveMode(
    /*[in]*/ FAX_DEVICE_RECEIVE_MODE_ENUM ReceiveMode
)
/*++

Routine name : CFaxDevice::put_ReceiveMode

Routine description:

    Set New Value of Receive Mode Attribute for Device Object.

Author:

    Iv Garber (IvG),    Aug, 2000

Arguments:

    ReceiveMode             [in]    - the new value to set

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxDevice::put_ReceiveMode"), hr, _T("Value=%d"), ReceiveMode);

    //
    //  Set receive mode
    //
    if ((ReceiveMode > fdrmMANUAL_ANSWER) || (ReceiveMode < fdrmNO_ANSWER))
    {
        hr = E_INVALIDARG;
        AtlReportError(CLSID_FaxDevice, IDS_ERROR_INVALID_ARGUMENT, IID_IFaxDevice, hr, _Module.GetResourceInstance());
        CALL_FAIL(GENERAL_ERR, _T("ReceiveMode > fdrmMANUAL_ANSWER"), hr);
        return hr;
    }
    if (fdrmMANUAL_ANSWER == ReceiveMode)
    {
        //
        //  Check to see if the device is virtual    
        //  Get Fax Server Handle
        //
        HANDLE faxHandle;
        hr = m_pIFaxServerInner->GetHandle(&faxHandle);
        ATLASSERT(SUCCEEDED(hr));

        if (faxHandle == NULL)
        {
            //
            //  Fax Server is not connected
            //
            hr = Fax_HRESULT_FROM_WIN32(ERROR_NOT_CONNECTED);
            CALL_FAIL(GENERAL_ERR, _T("faxHandle == NULL"), hr);
            AtlReportError(CLSID_FaxDevice, GetErrorMsgId(hr), IID_IFaxDevice, hr, _Module.GetResourceInstance());
            return hr;
        }

        BOOL bVirtual;
        DWORD dwRes = IsDeviceVirtual (faxHandle, m_lID, &bVirtual);
        if (ERROR_SUCCESS != dwRes)
        {
            hr = Fax_HRESULT_FROM_WIN32(dwRes);
            CALL_FAIL(GENERAL_ERR, _T("IsDeviceVirtual"), hr);
            AtlReportError(CLSID_FaxDevice, GetErrorMsgId(hr), IID_IFaxDevice, hr, _Module.GetResourceInstance());
            return hr;
        }
        if (bVirtual)
        {
            //
            // Virtual devices cannot be set to manual-answer mode
            //
            hr = Fax_HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED);
            CALL_FAIL(GENERAL_ERR, _T("IsDeviceVirtual"), hr);
            AtlReportError(CLSID_FaxDevice, GetErrorMsgId(hr), IID_IFaxDevice, hr, _Module.GetResourceInstance());
            return hr;
        }
    }                
    m_ReceiveMode = FAX_ENUM_DEVICE_RECEIVE_MODE (ReceiveMode);
    return hr;
}

//
//=============== PUT SEND ENABLED ==================================================
//
STDMETHODIMP
CFaxDevice::put_SendEnabled(
    /*[in]*/ VARIANT_BOOL bSendEnabled
)
/*++

Routine name : CFaxDevice::put_SendEnabled

Routine description:

    Set New Value for Send Property for Device Object.

Author:

    Iv Garber (IvG),    Jun, 2000

Arguments:

    bSendEnabled                         [in]    - the new value to set

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxDevice::put_SendEnabled"), hr, _T("Value=%d"), bSendEnabled);

    m_bSendEnabled = VARIANT_BOOL2bool(bSendEnabled);
    return hr;
}

//
//=============== PUT RINGS BEFORE ANSWER ======================================
//
STDMETHODIMP
CFaxDevice::put_RingsBeforeAnswer(
    /*[in]*/ long lRings
)
/*++

Routine name : CFaxDevice::put_RingsBeforeAnswer

Routine description:

    Set New Value for the Rings Before Answer Property for Device Object

Author:

    Iv Garber (IvG),    Jun, 2000

Arguments:

    lRings                        [in]    - the new value to set

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxDevice::put_RingsBeforeAnswer)"), hr, _T("Value=%d"), lRings);

    if (lRings < FXS_RINGS_LOWER || lRings > FXS_RINGS_UPPER)
    {
        hr = E_INVALIDARG;
        AtlReportError(CLSID_FaxDevice, IDS_ERROR_INVALID_ARGUMENT, IID_IFaxDevice, hr, _Module.GetResourceInstance());
        CALL_FAIL(GENERAL_ERR, _T("lRings<0"), hr);
        return hr;
    }
    m_lRings = lRings;
    return hr; 
};
    
//
//===================== GET CSID ================================================
//
STDMETHODIMP
CFaxDevice::get_CSID(
    /*[out, retval]*/ BSTR *pbstrCSID
)
/*++

Routine name : CFaxDevice::get_CSID

Routine description:

    Return the Device's CSID.

Author:

    Iv Garber (IvG),    Jun, 2000

Arguments:

    pbstrCSID                   [out]    - the Ptr where to put the value

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxDevice::get_CSID"), hr);

    hr = GetBstr(pbstrCSID, m_bstrCSID);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxDevice, GetErrorMsgId(hr), IID_IFaxDevice, hr, _Module.GetResourceInstance());
        return hr;
    }
    return hr;
}

//
//===================== GET TSID ================================================
//
STDMETHODIMP
CFaxDevice::get_TSID(
    /*[out, retval]*/ BSTR *pbstrTSID
)
/*++

Routine name : CFaxDevice::get_TSID

Routine description:

    Return the Device's TSID.

Author:

    Iv Garber (IvG),    Jun, 2000

Arguments:

    pbstrTSID                   [out]    - the Ptr where to put the value

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxDevice::get_TSID"), hr);

    hr = GetBstr(pbstrTSID, m_bstrTSID);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxDevice, GetErrorMsgId(hr), IID_IFaxDevice, hr, _Module.GetResourceInstance());
        return hr;
    }
    return hr;
}

//
//===================== GET RECEIVE MODE =============================================
//
STDMETHODIMP
CFaxDevice::get_ReceiveMode(
    /*[out, retval]*/ FAX_DEVICE_RECEIVE_MODE_ENUM *pReceiveMode
)
/*++

Routine name : CFaxDevice::get_ReceiveMode

Routine description:

    Return the Device's Receive Mode Attribute.

Author:

    Iv Garber (IvG),    Aug, 2000

Arguments:

    pReceiveMode                  [out]    - the value

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxDevice::get_ReceiveMode"), hr);

	if (::IsBadWritePtr(pReceiveMode, sizeof(FAX_DEVICE_RECEIVE_MODE_ENUM)))
	{
		hr = E_POINTER;
		CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr(pReceiveMode, sizeof(FAX_DEVICE_RECEIVE_MODE_ENUM))"), hr);
		return hr;
	}

    *pReceiveMode = (FAX_DEVICE_RECEIVE_MODE_ENUM) m_ReceiveMode;
    return hr;
};

//
//===================== GET SEND ENABLED ============================================
//
STDMETHODIMP
CFaxDevice::get_SendEnabled(
    /*[out, retval]*/ VARIANT_BOOL *pbSendEnabled
)
/*++

Routine name : CFaxDevice::get_SendEnabled

Routine description:

    Return the Device's Send Attribute.

Author:

    Iv Garber (IvG),    Jun, 2000

Arguments:

    pbSendEnabled                  [out]    - the value

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxDevice::get_SendEnabled"), hr);

    hr = GetVariantBool(pbSendEnabled, bool2VARIANT_BOOL(m_bSendEnabled));
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxDevice, GetErrorMsgId(hr), IID_IFaxDevice, hr, _Module.GetResourceInstance());
    }
    return hr;
};

//
//===================== GET DESCRIPTION ================================================
//
STDMETHODIMP
CFaxDevice::get_Description(
    /*[out, retval]*/ BSTR *pbstrDescription
)
/*++

Routine name : CFaxDevice::get_Description

Routine description:

    Return the Device's Description.

Author:

    Iv Garber (IvG),    Jun, 2000

Arguments:

    pbstrDescription                [out]    - the Ptr where to put the value

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxDevice::get_Description"), hr);

    hr = GetBstr(pbstrDescription, m_bstrDescr);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxDevice, GetErrorMsgId(hr), IID_IFaxDevice, hr, _Module.GetResourceInstance());
    }
    return hr;
}

//
//===================== GET POWERED OFF ================================================
//
STDMETHODIMP
CFaxDevice::get_PoweredOff(
    /*[out, retval]*/ VARIANT_BOOL *pbPoweredOff
)
/*++

Routine name : CFaxDevice::get_PoweredOff

Routine description:

    Return the Device's Powered Off Attribute.

Author:

    Iv Garber (IvG),    Jun, 2000

Arguments:

    pbPoweredOff                [out]    - the value

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxDevice::get_PoweredOff"), hr);

    hr = GetVariantBool(pbPoweredOff, bool2VARIANT_BOOL(m_dwStatus & FAX_DEVICE_STATUS_POWERED_OFF));
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxDevice, GetErrorMsgId(hr), IID_IFaxDevice, hr, _Module.GetResourceInstance());
    }
    return hr;
};

//
//===================== GET PROVIDER UNIQUE NAME ================================================
//
STDMETHODIMP
CFaxDevice::get_ProviderUniqueName(
    /*[out, retval]*/ BSTR *pbstrProviderUniqueName
)
/*++

Routine name : CFaxDevice::get_ProviderUniqueName

Routine description:

    Return the Device Provider's Unique Name.

Author:

    Iv Garber (IvG),    Jun, 2000

Arguments:

    pbstrProviderUniqueName           [out]    - the Ptr where to put the value

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxDevice::get_ProviderUniqueName"), hr);

    hr = GetBstr(pbstrProviderUniqueName, m_bstrProviderUniqueName);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxDevice, GetErrorMsgId(hr), IID_IFaxDevice, hr, _Module.GetResourceInstance());
    }
    return hr;
}

//
//===================== GET DEVICE NAME ================================================
//
STDMETHODIMP
CFaxDevice::get_DeviceName(
    /*[out, retval]*/ BSTR *pbstrDeviceName
)
/*++

Routine name : CFaxDevice::get_DeviceName

Routine description:

    Return the Device's Name.

Author:

    Iv Garber (IvG),    Jun, 2000

Arguments:

    pbstrDeviceName                [out]    - the Ptr where to put the value

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxDevice::get_DeviceName"), hr);

    hr = GetBstr(pbstrDeviceName, m_bstrDeviceName);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxDevice, GetErrorMsgId(hr), IID_IFaxDevice, hr, _Module.GetResourceInstance());
    }
    return hr;
}

//
//===================== GET RINGS BEFORE ANSWER ================================================
//
STDMETHODIMP
CFaxDevice::get_RingsBeforeAnswer(
    /*[out, retval]*/ long *plRingsBeforeAnswer
)
/*++

Routine name : CFaxDevice::get_RingsBeforeAnswer

Routine description:

    Return the Device's Number of Rings Before the Answer.

Author:

    Iv Garber (IvG),    Jun, 2000

Arguments:

    plRingsBeforeAnswer         [out]    - the Number of Device Rings

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxDevice::get_RingsBeforeAnswer"), hr);

    hr = GetLong(plRingsBeforeAnswer, m_lRings);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxDevice, GetErrorMsgId(hr), IID_IFaxDevice, hr, _Module.GetResourceInstance());
    }
    return hr;
};

//
//===================== GET ID ================================================
//
STDMETHODIMP
CFaxDevice::get_Id(
    /*[out, retval]*/ long *plId
)
/*++

Routine name : CFaxDevice::get_Id

Routine description:

    Return the Device Id.

Author:

    Iv Garber (IvG),    Jun, 2000

Arguments:

    plId                          [out]    - the Device ID

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxDevice::get_Id"), hr);

    hr = GetLong(plId, m_lID);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxDevice, GetErrorMsgId(hr), IID_IFaxDevice, hr, _Module.GetResourceInstance());
    }
    return hr;
};

//
//========================= INIT ==============================================
//
STDMETHODIMP
CFaxDevice::Init(
    FAX_PORT_INFO_EX *pInfo,
    IFaxServerInner  *pServer
)
/*++

Routine name : CFaxDevice::Init

Routine description:

    Initialize the Object with the given data.

Author:

    Iv Garber (IvG),    Jun, 2000

Arguments:

    pInfo                         [in]    - Ptr to the Device's Data.
    pServer                       [in]    - Ptr to the Fax Server.

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxDevice::Init"), hr);

    //
    //  Store different Device Fields
    //
    m_lID = pInfo->dwDeviceID;
    m_lRings = pInfo->dwRings;
    m_bSendEnabled = pInfo->bSend;
    m_ReceiveMode = pInfo->ReceiveMode;
    m_dwStatus = pInfo->dwStatus;

    m_bstrDescr = pInfo->lptstrDescription;
    m_bstrProviderUniqueName = pInfo->lpctstrProviderGUID;
    m_bstrDeviceName = pInfo->lpctstrDeviceName;
    m_bstrTSID = pInfo->lptstrTsid;
    m_bstrCSID = pInfo->lptstrCsid;
    if ( (pInfo->lptstrDescription && !m_bstrDescr) ||
         (pInfo->lpctstrProviderGUID && !m_bstrProviderUniqueName) ||
         (pInfo->lptstrTsid && !m_bstrTSID) ||
         (pInfo->lpctstrDeviceName && !m_bstrDeviceName) ||
         (pInfo->lptstrCsid && !m_bstrCSID) )
    {
        hr = E_OUTOFMEMORY;
        CALL_FAIL(MEM_ERR, _T("CComBSTR::operator=()"), hr);
        AtlReportError(CLSID_FaxDevice, IDS_ERROR_OUTOFMEMORY, IID_IFaxDevice, hr, _Module.GetResourceInstance());
        return hr;
    }

    if (pServer)
    {
        //
        //  Store Ptr to Fax Server Object
        //
        hr = CFaxInitInnerAddRef::Init(pServer);
    }

    return hr;
}

//
//========================= SUPPORT ERROR INFO ====================================
//
STDMETHODIMP 
CFaxDevice::InterfaceSupportsErrorInfo(
    REFIID riid
)
/*++

Routine name : CFaxDevice::InterfaceSupportsErrorInfo

Routine description:

    ATL's implementation of Support Error Info.

Author:

    Iv Garber (IvG),    Jun, 2000

Arguments:

    riid                          [in]    - Reference to the Interface.

Return Value:

    Standard HRESULT code

--*/
{
    static const IID* arr[] = 
    {
        &IID_IFaxDevice
    };
    for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
    {
        if (InlineIsEqualGUID(*arr[i],riid))
            return S_OK;
    }
    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxdevice.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxDevice.h

Abstract:

	Declaration of the CFaxDevice class.

Author:

	Iv Garber (IvG)	Jun, 2000

Revision History:

--*/

#ifndef __FAXDEVICE_H_
#define __FAXDEVICE_H_

#include "resource.h"       // main symbols
#include "FaxLocalPtr.h"

//
//================= FAX DEVICE =================================================
//  Fax Device Object is created by Fax Devices Collection.
//  Fax Devices Collection makes AddRef() on each Device Object.
//  Each Device Object makes AddRef() on the Fax Server.
//  This is done because Fax Device Object needs the Handle to the Fax Server
//      to perform Refresh() etc.
//
class ATL_NO_VTABLE CFaxDevice : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public ISupportErrorInfo,
	public IDispatchImpl<IFaxDevice, &IID_IFaxDevice, &LIBID_FAXCOMEXLib>,
    public CFaxInitInnerAddRef
{
public:
    CFaxDevice() : CFaxInitInnerAddRef(_T("FAX DEVICE"))
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_FAXDEVICE)
DECLARE_NOT_AGGREGATABLE(CFaxDevice)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxDevice)
	COM_INTERFACE_ENTRY(IFaxDevice)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

//  Interfaces
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

	STDMETHOD(Save)();
	STDMETHOD(Refresh)();
    STDMETHOD(AnswerCall)();

	STDMETHOD(put_CSID)(/*[in]*/ BSTR bstrCSID);
	STDMETHOD(put_TSID)(/*[in]*/ BSTR bstrTSID);
	STDMETHOD(get_Id)(/*[out, retval]*/ long *plId);
	STDMETHOD(get_CSID)(/*[out, retval]*/ BSTR *pbstrCSID);
	STDMETHOD(get_TSID)(/*[out, retval]*/ BSTR *pbstrTSID);
	STDMETHOD(put_Description)(/*[in]*/ BSTR bstrDescription);
	STDMETHOD(put_SendEnabled)(/*[in]*/ VARIANT_BOOL bSendEnabled);
	STDMETHOD(get_DeviceName)(/*[out, retval]*/ BSTR *pbstrDeviceName);
	STDMETHOD(put_RingsBeforeAnswer)(/*[in]*/ long lRingsBeforeAnswer);
	STDMETHOD(get_Description)(/*[out, retval]*/ BSTR *pbstrDescription);
	STDMETHOD(get_ProviderUniqueName)(/*[out, retval]*/ BSTR *pbstrProviderUniqueName);
	STDMETHOD(get_SendingNow)(/*[out, retval]*/ VARIANT_BOOL *pbSendingNow);
	STDMETHOD(get_PoweredOff)(/*[out, retval]*/ VARIANT_BOOL *pbPoweredOff);
	STDMETHOD(get_RingingNow)(/*[out, retval]*/ VARIANT_BOOL *pbRingingNow);
	STDMETHOD(get_SendEnabled)(/*[out, retval]*/ VARIANT_BOOL *pbSendEnabled);
	STDMETHOD(get_ReceivingNow)(/*[out, retval]*/ VARIANT_BOOL *pbReceivingNow);
    STDMETHOD(put_ReceiveMode)(/*[in]*/ FAX_DEVICE_RECEIVE_MODE_ENUM ReceiveMode);
	STDMETHOD(get_RingsBeforeAnswer)(/*[out, retval]*/ long *plRingsBeforeAnswer);
    STDMETHOD(get_ReceiveMode)(/*[out, retval]*/ FAX_DEVICE_RECEIVE_MODE_ENUM *pReceiveMode);

	STDMETHOD(get_UsedRoutingMethods)(/*[out, retval]*/ VARIANT *pvUsedRoutingMethods);
	STDMETHOD(UseRoutingMethod)(/*[in]*/ BSTR bstrMethodGUID, /*[in]*/ VARIANT_BOOL bUse);

	STDMETHOD(SetExtensionProperty)(/*[in]*/ BSTR bstrGUID, /*[in]*/ VARIANT vProperty);
	STDMETHOD(GetExtensionProperty)(/*[in]*/ BSTR bstrGUID, /*[out, retval]*/ VARIANT *pvProperty);

//  Internal Use
    STDMETHOD(Init)(FAX_PORT_INFO_EX *pInfo, IFaxServerInner *pServer);

private:
    long    m_lID;
    long    m_lRings;

    BOOL    m_bSendEnabled;
    FAX_ENUM_DEVICE_RECEIVE_MODE    m_ReceiveMode;

    DWORD   m_dwStatus;

    CComBSTR    m_bstrTSID;
    CComBSTR    m_bstrCSID;
    CComBSTR    m_bstrDescr;
    CComBSTR    m_bstrDeviceName;
    CComBSTR    m_bstrProviderUniqueName;
};

#endif //__FAXDEVICE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxdeviceprovider.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxDeviceProvider.h

Abstract:

	Declaration of the CFaxDeviceProvider Class.

Author:

	Iv Garber (IvG)	Jun, 2000

Revision History:

--*/


#ifndef __FAXDEVICEPROVIDER_H_
#define __FAXDEVICEPROVIDER_H_

#include "resource.h"       // main symbols
#include "FaxLocalPtr.h"

//
//=================== FAX DEVICE PROVIDER ========================================
//
class ATL_NO_VTABLE CFaxDeviceProvider : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public ISupportErrorInfo,
	public IDispatchImpl<IFaxDeviceProvider, &IID_IFaxDeviceProvider, &LIBID_FAXCOMEXLib>
{
public:
    CFaxDeviceProvider() : 
      m_psaDeviceIDs(NULL)
	{
        DBG_ENTER(_T("FAX DEVICE PROVIDER::CREATE"));
	}

    ~CFaxDeviceProvider()
    {
        HRESULT     hr = S_OK;
        DBG_ENTER(_T("FAX DEVICE PROVIDER::DESTROY"));
        if (m_psaDeviceIDs)
        {
            hr = SafeArrayDestroy(m_psaDeviceIDs);
            if (FAILED(hr))
            {
                CALL_FAIL(GENERAL_ERR, _T("SafeArrayDestroy(m_psaDeviceIDs)"), hr);
            }
        }
    }

DECLARE_REGISTRY_RESOURCEID(IDR_FAXDEVICEPROVIDER)
DECLARE_NOT_AGGREGATABLE(CFaxDeviceProvider)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxDeviceProvider)
	COM_INTERFACE_ENTRY(IFaxDeviceProvider)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

//  Interfaces
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

    STDMETHOD(get_Debug)(/*[out, retval]*/ VARIANT_BOOL *pbDebug);
    STDMETHOD(get_MajorBuild)(/*[out, retval]*/ long *plMajorBuild);
    STDMETHOD(get_MinorBuild)(/*[out, retval]*/ long *plMinorBuild);
    STDMETHOD(get_DeviceIds)(/*[out, retval]*/ VARIANT *pvDeviceIds);
    STDMETHOD(get_ImageName)(/*[out, retval]*/ BSTR *pbstrImageName);
    STDMETHOD(get_UniqueName)(/*[out, retval]*/ BSTR *pbstrUniqueName);
    STDMETHOD(get_MajorVersion)(/*[out, retval]*/ long *plMajorVersion);
    STDMETHOD(get_MinorVersion)(/*[out, retval]*/ long *plMinorVersion);
    STDMETHOD(get_InitErrorCode)(/*[out, retval]*/ long *plInitErrorCode);
    STDMETHOD(get_FriendlyName)(/*[out, retval]*/ BSTR *pbstrFriendlyName);
    STDMETHOD(get_Status)(/*[out, retval]*/ FAX_PROVIDER_STATUS_ENUM *pStatus);
    STDMETHOD(get_TapiProviderName)(/*[out, retval]*/ BSTR *pbstrTapiProviderName);

//	Internal Use
    STDMETHOD(Init)(FAX_DEVICE_PROVIDER_INFO *pInfo, FAX_PORT_INFO_EX *pDevices, DWORD dwNum);

private:
    long            m_lMajorBuild;
    long            m_lMinorBuild;
    long            m_lMajorVersion;
    long            m_lMinorVersion;
    long            m_lLastError;

    CComBSTR        m_bstrUniqueName;
    CComBSTR        m_bstrImageName;
    CComBSTR        m_bstrFriendlyName;
    CComBSTR        m_bstrTapiProviderName;

    SAFEARRAY       *m_psaDeviceIDs;

    VARIANT_BOOL    m_bDebug;

    FAX_PROVIDER_STATUS_ENUM        m_Status;
};

#endif //__FAXDEVICEPROVIDER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxdeviceids.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxDeviceIds.h

Abstract:

	Declaration of the CFaxDeviceIds class

Author:

	Iv Garber (IvG)	Jun, 2000

Revision History:

--*/

#ifndef __FAXDEVICEIDS_H_
#define __FAXDEVICEIDS_H_

#include "resource.h"       // main symbols
#include "FaxCommon.h"
#include <vector>
#include "VCUE_Copy.h"

namespace DeviceIdsNamespace
{

	// Store the Device Ids in Vector
	typedef	std::vector<long>	ContainerType;

	// Typedef the copy classes using existing typedefs
    typedef VCUE::GenericCopy<VARIANT, long>    EnumCopyType;
    typedef VCUE::GenericCopy<long, long>       CollectionCopyType;

    typedef CComEnumOnSTL< IEnumVARIANT, &__uuidof(IEnumVARIANT), VARIANT, EnumCopyType, 
        ContainerType > EnumType;

    typedef ICollectionOnSTLImpl< IFaxDeviceIds, ContainerType, long, CollectionCopyType, 
        EnumType > CollectionType;
};

using namespace DeviceIdsNamespace;

//
//===================== FAX DEVICE IDS COLLECTION ======================================
//  FaxDeviceIDs Collection needs Ptr to the Fax Server, for Remove, Add and SetOrder
//  operations. So, it inherits from CFaxInitInnerAddRef class.
//
class ATL_NO_VTABLE CFaxDeviceIds : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public ISupportErrorInfo,
    public IDispatchImpl<DeviceIdsNamespace::CollectionType, &IID_IFaxDeviceIds, &LIBID_FAXCOMEXLib>,
    public CFaxInitInnerAddRef
{
public:
    CFaxDeviceIds() : CFaxInitInnerAddRef(_T("FAX DEVICE IDS"))
	{
	}
    ~CFaxDeviceIds()
    {
        //
        //  Clear the Collection
        //
        CCollectionKiller<DeviceIdsNamespace::ContainerType>  CKiller;
        CKiller.ClearCollection(&m_coll);    
    }

DECLARE_REGISTRY_RESOURCEID(IDR_FAXDEVICEIDS)
DECLARE_NOT_AGGREGATABLE(CFaxDeviceIds)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxDeviceIds)
	COM_INTERFACE_ENTRY(IFaxDeviceIds)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

//  Interfaces
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

    STDMETHOD(Add)(/*[in]*/ long lDeviceId);
    STDMETHOD(Remove)(/*[in]*/ long lIndex);
    STDMETHOD(SetOrder)(/*[in]*/ long lDeviceId, /*[in]*/ long lNewOrder);

//  Internal Use
    STDMETHOD(Init)(/*[in]*/ DWORD *pDeviceIds, /*[in]*/ DWORD dwNum, /*[in]*/ BSTR bstrGroupName, 
        /*[in]*/ IFaxServerInner *pServer);

private:
    CComBSTR    m_bstrGroupName;

//  Private Functions
    STDMETHOD(UpdateGroup)();
};

#endif //__FAXDEVICEIDS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxdeviceids.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxDeviceIds.cpp

Abstract:

	Implementation of CFaxDeviceIds class.

Author:

	Iv Garber (IvG)	Jun, 2000

Revision History:

--*/

#include "stdafx.h"
#include "FaxComEx.h"
#include "FaxDeviceIds.h"
#include "faxutil.h"

//
//======================= UPDATE GROUP ======================================
//
STDMETHODIMP
CFaxDeviceIds::UpdateGroup()
/*++

Routine name : CFaxDeviceIds::UpdateGroup

Routine description:

	Update Group Info at Server.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:


Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxDeviceIds::UpdateGroup"));

    //
    //  Get Fax Handle
    //
    HANDLE faxHandle;
	hr = m_pIFaxServerInner->GetHandle(&faxHandle);
    ATLASSERT(SUCCEEDED(hr));

	if (faxHandle == NULL)
	{
		//
		//	Fax Server is not connected
		//
		hr = Fax_HRESULT_FROM_WIN32(ERROR_NOT_CONNECTED);
		CALL_FAIL(GENERAL_ERR, _T("faxHandle == NULL"), hr);
        AtlReportError(CLSID_FaxDeviceIds, GetErrorMsgId(hr), IID_IFaxDeviceIds, hr, _Module.GetResourceInstance());
		return hr;
	}

    //
    //  Create Group Structure
    //
    FAX_OUTBOUND_ROUTING_GROUP      groupData;
    groupData.dwNumDevices = m_coll.size();
    groupData.dwSizeOfStruct = sizeof(FAX_OUTBOUND_ROUTING_GROUP);
    groupData.lpctstrGroupName = m_bstrGroupName;
    groupData.Status = FAX_GROUP_STATUS_ALL_DEV_VALID;

    groupData.lpdwDevices = (DWORD *)MemAlloc(sizeof(DWORD) * groupData.dwNumDevices);
    if (!groupData.lpdwDevices)
    {
		hr = E_OUTOFMEMORY;
		CALL_FAIL(MEM_ERR, _T("MemAlloc(sizeof(DWORD) * groupData.dwNumDevices)"), hr);
        AtlReportError(CLSID_FaxDeviceIds, IDS_ERROR_OUTOFMEMORY, IID_IFaxDeviceIds, hr, _Module.GetResourceInstance());
		return hr;
    }

    ContainerType::iterator DeviceIdIterator = m_coll.begin();
    DWORD   i = 0;
    while ( DeviceIdIterator != m_coll.end())
    {
        groupData.lpdwDevices[i] = *DeviceIdIterator;

        DeviceIdIterator++;
        i++;
    }

    //
    //  Call Server to Update Group's Info
    //
    if (!FaxSetOutboundGroup(faxHandle, &groupData))
    {
		hr = Fax_HRESULT_FROM_WIN32(GetLastError());
		CALL_FAIL(GENERAL_ERR, _T("FaxSetOutboundGroup(faxHandle, &groupData)"), hr);
        AtlReportError(CLSID_FaxDeviceIds, GetErrorMsgId(hr), IID_IFaxDeviceIds, hr, _Module.GetResourceInstance());
		return hr;
    }

    return hr;
}

//
//==================================== INIT ======================================
//
STDMETHODIMP
CFaxDeviceIds::Init(
    /*[in]*/ DWORD *pDeviceIds, 
    /*[in]*/ DWORD dwNum, 
    /*[in]*/ BSTR bstrGroupName,
    /*[in]*/ IFaxServerInner *pServer
)
/*++

Routine name : CFaxDeviceIds::Init

Routine description:

	Initialize the DeviceIds Collection.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	pDeviceIds                    [in]    - Ptr to the DeviceIds
	dwNum                         [in]    - Count of the Device Ids
	bstrGroupName                 [in]    - Name of the owner Group
	pServer                       [in]    - Ptr to the Server Object

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxDeviceIds::Init"), hr, _T("NumDevices=%d GroupName=%s"), dwNum, bstrGroupName);

    m_bstrGroupName = bstrGroupName;
    if (bstrGroupName && !m_bstrGroupName)
    {
        hr = E_OUTOFMEMORY;
		CALL_FAIL(MEM_ERR, _T("CComBSTR::operator=()"), hr);
        AtlReportError(CLSID_FaxDeviceIds, IDS_ERROR_OUTOFMEMORY, IID_IFaxDeviceIds, hr, _Module.GetResourceInstance());
		return hr;
    }

    //
    //  Fill the Collection with Device Ids
    //
    for ( DWORD i=0 ; i<dwNum ; i++ )
    {
        try
        {
            m_coll.push_back(pDeviceIds[i]);
        }
        catch (exception &)
        {
		    hr = E_OUTOFMEMORY;
		    AtlReportError(CLSID_FaxDeviceIds, IDS_ERROR_OUTOFMEMORY, IID_IFaxDeviceIds, hr, _Module.GetResourceInstance());
		    CALL_FAIL(MEM_ERR, _T("m_coll.push_back(pDeviceIds[i])"), hr);
		    return hr;
	    }
    }

    //
    //  Store and AddRef the Ptr to the Fax Server Object
    //
    hr = CFaxInitInnerAddRef::Init(pServer);
    return hr;
}

//
//==================================== ADD ======================================
//
STDMETHODIMP
CFaxDeviceIds::Add(
    /*[in]*/ long lDeviceId
)
/*++

Routine name : CFaxDeviceIds::Add

Routine description:

	Add new Device ID to the Collection

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	lDeviceId                     [in]    - the Device Id to add

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxDeviceIds::Add"), hr, _T("DeviceId=%ld"), lDeviceId);

    //
    //  Check that we can Add Device Id
    //
    if (_tcsicmp(m_bstrGroupName, ROUTING_GROUP_ALL_DEVICES) == 0)
    {
        //
        //  This is the "All Devices" Group
        //
	    hr = E_INVALIDARG;
	    CALL_FAIL(GENERAL_ERR, _T("All Devices Group"), hr);
        AtlReportError(CLSID_FaxDeviceIds, IDS_ERROR_ALLDEVICESGROUP, IID_IFaxDeviceIds, hr, _Module.GetResourceInstance());
        return hr;
    }

	//
	//	Put the Device Id in the collection
	//
	try 
	{
		m_coll.push_back(lDeviceId);
	}
	catch (exception &)
	{
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxDeviceIds, IDS_ERROR_OUTOFMEMORY, IID_IFaxDeviceIds, hr, _Module.GetResourceInstance());
		CALL_FAIL(MEM_ERR, _T("m_coll.push_back(lDeviceId)"), hr);
		return hr;
	}

    //
    //  Update Group's Info at Server
    //
    hr = UpdateGroup();
    if (FAILED(hr))
    {
        //
        //  Failed to Add the Device Id --> remove it from the Collection as well
        //
	    try 
	    {
		    m_coll.pop_back();
	    }
	    catch (exception &)
	    {
		    //
            //  Only write to Debug
            //
		    CALL_FAIL(MEM_ERR, _T("m_coll.push_back(lDeviceId)"), E_OUTOFMEMORY);
	    }

        return hr;
    }

    return hr;
}

//
//======================== REMOVE =================================================
//
STDMETHODIMP
CFaxDeviceIds::Remove(
    /*[in]*/ long lIndex
)
/*++

Routine name : CFaxDeviceIds::Remove

Routine description:

	Remove the given Item from the Collection

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	lIndex                        [in]    - Index of the Item to remove

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxDeviceIds::Remove"), hr, _T("Index=%ld"), lIndex);

    //
    //  Check that we can Remove the Device from the Collection
    //
    if (_tcsicmp(m_bstrGroupName, ROUTING_GROUP_ALL_DEVICES) == 0)
    {
        //
        //  This is the "All Devices" Group
        //
	    hr = E_INVALIDARG;
	    CALL_FAIL(GENERAL_ERR, _T("All Devices Group"), hr);
        AtlReportError(CLSID_FaxDeviceIds, IDS_ERROR_ALLDEVICESGROUP, IID_IFaxDeviceIds, hr, _Module.GetResourceInstance());
        return hr;
    }

    //
    //  Check that Index is Valid
    //
    if ((lIndex > m_coll.size()) || (lIndex < 1))
    {
	    hr = E_INVALIDARG;
	    CALL_FAIL(GENERAL_ERR, _T("(lIndex > m_coll.size() or lIndex < 1)"), hr);
        AtlReportError(CLSID_FaxDeviceIds, IDS_ERROR_OUTOFRANGE, IID_IFaxDeviceIds, hr, _Module.GetResourceInstance());
        return hr;
    }

	//
	//	Remove the Item from the Collection
	//
    long    lDeviceId;
	try 
	{
        ContainerType::iterator it;
        it = m_coll.begin() + lIndex - 1;
        lDeviceId = *it;
		m_coll.erase(it);
	}
	catch (exception &)
	{
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxDeviceIds, IDS_ERROR_OUTOFMEMORY, IID_IFaxDeviceIds, hr, _Module.GetResourceInstance());
		CALL_FAIL(MEM_ERR, _T("m_coll.erase(it)"), hr);
		return hr;
	}

    //
    //  Update Group's Info at Server
    //
    hr = UpdateGroup();
    if (FAILED(hr))
    {
        //
        //  Failed to Remove the Device --> Add it back into the Collection
        //
	    try 
	    {
            ContainerType::iterator it;
            it = m_coll.begin() + lIndex - 1;
            m_coll.insert(it, lDeviceId);
	    }
	    catch (exception &)
	    {
            //
            //  Only Debug 
            //
		    CALL_FAIL(MEM_ERR, _T("m_coll.insert(it, lDeviceId)"), E_OUTOFMEMORY);
	    }

        return hr;
    }

    return hr;
}

//
//======================== SET ORDER =================================================
//
STDMETHODIMP
CFaxDeviceIds::SetOrder(
    /*[in]*/ long lDeviceId, 
    /*[in]*/ long lNewOrder
)
/*++

Routine name : CFaxDeviceIds::SetOrder

Routine description:

	Update Order for the Device Id

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	lDeviceId                     [in]    - the Device Id
	lNewOrder                     [in]    - the new Order of the Device Id

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxDeviceIds::SetOrder"), hr, _T("Id=%ld Order=%ld"), lDeviceId, lNewOrder);

    //
    //  Before setting the Device's Order at Server, check that the Device is present in the Collection
    //
    ContainerType::iterator it;
    it = m_coll.begin();
    while (it != m_coll.end())
    {
        if ((*it) == lDeviceId)
        {
            break;
        }

        it++;
    }

    if (it == m_coll.end())
    {
        //
        //  Our Collection does not contain such Device Id
        //
        hr = E_INVALIDARG;
		CALL_FAIL(GENERAL_ERR, _T("(The Device Id does not found in the Collection !!)"), hr);
        AtlReportError(CLSID_FaxDeviceIds, GetErrorMsgId(hr), IID_IFaxDeviceIds, hr, _Module.GetResourceInstance());
		return hr;
    }

    //
    //  Get Fax Handle
    //
    HANDLE faxHandle;
	hr = m_pIFaxServerInner->GetHandle(&faxHandle);
    ATLASSERT(SUCCEEDED(hr));

	if (faxHandle == NULL)
	{
		//
		//	Fax Server is not connected
		//
		hr = Fax_HRESULT_FROM_WIN32(ERROR_NOT_CONNECTED);
		CALL_FAIL(GENERAL_ERR, _T("faxHandle == NULL"), hr);
        AtlReportError(CLSID_FaxDeviceIds, GetErrorMsgId(hr), IID_IFaxDeviceIds, hr, _Module.GetResourceInstance());
		return hr;
	}

    //  Call Server to Update the Device's Order
    //
    if (!FaxSetDeviceOrderInGroup(faxHandle, m_bstrGroupName, lDeviceId, lNewOrder))
    {
		hr = Fax_HRESULT_FROM_WIN32(ERROR_NOT_CONNECTED);
		CALL_FAIL(GENERAL_ERR, _T("FaxSetDeviceOrderInGroup(faxHandle, m_bstrGroupName, lDeviceId, lNewOrder)"), hr);
        AtlReportError(CLSID_FaxDeviceIds, GetErrorMsgId(hr), IID_IFaxDeviceIds, hr, _Module.GetResourceInstance());
		return hr;
    }

    //
    //  Remove the Device Id from its Place in the Collection and Put it in the Desired Place
    //
	try 
	{
        m_coll.erase(it);

        it = m_coll.begin() + lNewOrder - 1;
        m_coll.insert(it, lDeviceId);
	}
	catch (exception &)
	{
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxDeviceIds, IDS_ERROR_OUTOFMEMORY, IID_IFaxDeviceIds, hr, _Module.GetResourceInstance());
		CALL_FAIL(MEM_ERR, _T("m_coll.erase(it)/insert(it, lDeviceId)"), hr);
		return hr;
	}

    return hr;
}

//
//===================== SUPPORT ERROR INFO ======================================
//
STDMETHODIMP 
CFaxDeviceIds::InterfaceSupportsErrorInfo(
    REFIID riid
)
/*++

Routine name : CFaxDeviceIds::InterfaceSupportsErrorInfo

Routine description:

	ATL's implementation of the ISupportErrorInfo Interface.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	riid                          [in]    - Reference to the Interface

Return Value:

    Standard HRESULT code

--*/
{
	static const IID* arr[] = 
	{
		&IID_IFaxDeviceIds
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxdeviceprovider.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxDeviceProvider.cpp

Abstract:

	Implementation of CFaxDeviceProvider Class.

Author:

	Iv Garber (IvG)	Jun, 2000

Revision History:

--*/

#include "stdafx.h"
#include "FaxComEx.h"
#include "FaxDeviceProvider.h"

//
//========================= GET UNIQUE NAME ========================================
//
STDMETHODIMP 
CFaxDeviceProvider::get_UniqueName(
	BSTR *pbstrUniqueName
)
/*++

Routine name : CFaxDeviceProvider::get_UniqueName

Routine description:

	Return Name of the Device Provider

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	pbstrUniqueName                [out]    - Ptr to put the UniqueName

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxDeviceProvider::get_UniqueName"), hr);
    hr = GetBstr(pbstrUniqueName, m_bstrUniqueName);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxDeviceProvider, GetErrorMsgId(hr), IID_IFaxDeviceProvider, hr, _Module.GetResourceInstance());
        return hr;
    }
    return hr;
}

//
//========================= GET IMAGE NAME ========================================
//
STDMETHODIMP 
CFaxDeviceProvider::get_ImageName(
	BSTR *pbstrImageName
)
/*++

Routine name : CFaxDeviceProvider::get_ImageName

Routine description:

	Return Image Name of the Device Provider

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	pbstrImageName                [out]    - Ptr to put the ImageName

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxDeviceProvider::get_ImageName"), hr);
    hr = GetBstr(pbstrImageName, m_bstrImageName);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxDeviceProvider, GetErrorMsgId(hr), IID_IFaxDeviceProvider, hr, _Module.GetResourceInstance());
        return hr;
    }
    return hr;
}

//
//========================= GET FRIENDLY NAME ========================================
//
STDMETHODIMP 
CFaxDeviceProvider::get_FriendlyName(
	BSTR *pbstrFriendlyName
)
/*++

Routine name : CFaxDeviceProvider::get_FriendlyName

Routine description:

	Return Friendly Name of the Device Provider

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	pbstrFriendlyName               [out]    - Ptr to put the FriendlyName

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxDeviceProvider::get_FriendlyName"), hr);
    hr = GetBstr(pbstrFriendlyName, m_bstrFriendlyName);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxDeviceProvider, GetErrorMsgId(hr), IID_IFaxDeviceProvider, hr, _Module.GetResourceInstance());
        return hr;
    }
    return hr;
}

//
//========================= GET TAPI PROVIDER NAME ========================================
//
STDMETHODIMP 
CFaxDeviceProvider::get_TapiProviderName(
	BSTR *pbstrTapiProviderName
)
/*++

Routine name : CFaxDeviceProvider::get_TapiProviderName

Routine description:

	Return Tapi Provider Name of the Device Provider

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	pbstrTapiProviderName               [out]    - Ptr to put the TapiProviderName

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxDeviceProvider::get_TapiProviderName"), hr);
    hr = GetBstr(pbstrTapiProviderName, m_bstrTapiProviderName);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxDeviceProvider, GetErrorMsgId(hr), IID_IFaxDeviceProvider, hr, _Module.GetResourceInstance());
        return hr;
    }
    return hr;
}

//
//===================== GET STATUS =========================================
//
STDMETHODIMP 
CFaxDeviceProvider::get_Status(
	FAX_PROVIDER_STATUS_ENUM *pStatus
)
/*++

Routine name : CFaxDeviceProvider::get_Status

Routine description:

	Return Status of the Device Provider

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	pStatus                [out]    - Ptr to put Status value

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxDeviceProvider::get_Status"), hr);

	//
	//	Check that we have got good Ptr
	//
	if (::IsBadWritePtr(pStatus, sizeof(FAX_PROVIDER_STATUS_ENUM)))
	{
		hr = E_POINTER;
		CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr(pStatus, sizeof(FAX_PROVIDER_STATUS_ENUM))"), hr);
        AtlReportError(CLSID_FaxDeviceProvider, GetErrorMsgId(hr), IID_IFaxDeviceProvider, hr, _Module.GetResourceInstance());
        return hr;
	}

	*pStatus = m_Status;
	return hr;
}

//
//===================== GET INIT ERROR CODE =========================================
//
STDMETHODIMP 
CFaxDeviceProvider::get_InitErrorCode(
	long *plInitErrorCode
)
/*++

Routine name : CFaxDeviceProvider::get_InitErrorCode

Routine description:

	Return InitErrorCode of the Device Provider

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	plInitErrorCode                [out]    - Ptr to put InitErrorCode value

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxDeviceProvider::get_InitErrorCode"), hr);

    hr = GetLong(plInitErrorCode, m_lLastError);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxDeviceProvider, GetErrorMsgId(hr), IID_IFaxDeviceProvider, hr, _Module.GetResourceInstance());
        return hr;
    }
	return hr;
}

//
//===================== GET DEBUG =========================================
//
STDMETHODIMP 
CFaxDeviceProvider::get_Debug(
	VARIANT_BOOL *pbDebug
)
/*++

Routine name : CFaxDeviceProvider::get_Debug

Routine description:

	Return if the Device Provider compiled in Debug version

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	pbDebug                 [out]    - Ptr to put Debug value

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxDeviceProvider::get_Debug"), hr);

    hr = GetVariantBool(pbDebug, m_bDebug);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxDeviceProvider, GetErrorMsgId(hr), IID_IFaxDeviceProvider, hr, _Module.GetResourceInstance());
        return hr;
    }
	return hr;
}

//
//===================== GET MAJOR BUILD =========================================
//
STDMETHODIMP 
CFaxDeviceProvider::get_MajorBuild(
	long *plMajorBuild
)
/*++

Routine name : CFaxDeviceProvider::get_MajorBuild

Routine description:

	Return MajorBuild of the Device Provider

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	plMajorBuild                [out]    - Ptr to put MajorBuild value

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxDeviceProvider::get_MajorBuild"), hr);

    hr = GetLong(plMajorBuild, m_lMajorBuild);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxDeviceProvider, GetErrorMsgId(hr), IID_IFaxDeviceProvider, hr, _Module.GetResourceInstance());
        return hr;
    }
	return hr;
}

//
//===================== GET MINOR BUILD =========================================
//
STDMETHODIMP 
CFaxDeviceProvider::get_MinorBuild(
	long *plMinorBuild
)
/*++

Routine name : CFaxDeviceProvider::get_MinorBuild

Routine description:

	Return MinorBuild of the Device Provider

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	plMinorBuild                [out]    - Ptr to put MinorBuild value

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxDeviceProvider::get_MinorBuild"), hr);

    hr = GetLong(plMinorBuild, m_lMinorBuild);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxDeviceProvider, GetErrorMsgId(hr), IID_IFaxDeviceProvider, hr, _Module.GetResourceInstance());
        return hr;
    }
	return hr;
}

//
//===================== GET MAJOR VERSION =========================================
//
STDMETHODIMP 
CFaxDeviceProvider::get_MajorVersion(
	long *plMajorVersion
)
/*++

Routine name : CFaxDeviceProvider::get_MajorVersion

Routine description:

	Return MajorVersion of the Device Provider

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	plMajorVersion                [out]    - Ptr to put MajorVersion value

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxDeviceProvider::get_MajorVersion"), hr);

    hr = GetLong(plMajorVersion, m_lMajorVersion);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxDeviceProvider, GetErrorMsgId(hr), IID_IFaxDeviceProvider, hr, _Module.GetResourceInstance());
        return hr;
    }
	return hr;
}

//
//===================== GET MINOR VERSION =========================================
//
STDMETHODIMP 
CFaxDeviceProvider::get_MinorVersion(
	long *plMinorVersion
)
/*++

Routine name : CFaxDeviceProvider::get_MinorVersion

Routine description:

	Return MinorVersion of the Device Provider

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	plMinorVersion                [out]    - Ptr to put MinorVersionvalue

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxDeviceProvider::get_MinorVersion"), hr);

    hr = GetLong(plMinorVersion, m_lMinorVersion);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxDeviceProvider, GetErrorMsgId(hr), IID_IFaxDeviceProvider, hr, _Module.GetResourceInstance());
        return hr;
    }
	return hr;
}

//
//===================== GET DEVICE IDS =========================================
//
STDMETHODIMP 
CFaxDeviceProvider::get_DeviceIds(
	/*[out, retval]*/ VARIANT *pvDeviceIds
)
/*++

Routine name : CFaxDeviceProvider::get_DeviceIds

Routine description:

	Return array of all device ids exposed by the Device Provider

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	pvDeviceIds                 [out]    - Ptr to put Variant containing Safearray of IDs

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxDeviceProvider::get_DeviceIds"), hr);

	//
	//	Check that we can write to the given pointer
	//
	if (::IsBadWritePtr(pvDeviceIds, sizeof(VARIANT)))
	{
		hr = E_POINTER;
		AtlReportError(
            CLSID_FaxDeviceProvider,
            GetErrorMsgId(hr), 
            IID_IFaxDeviceProvider, 
            hr,
            _Module.GetResourceInstance());
		CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr(pvDeviceIds, sizeof(VARIANT))"), hr);
		return hr;
	}

    //
    //  Allocate the safe array : vector of long
    //
    SAFEARRAY   *psaResult;
    hr = SafeArrayCopy(m_psaDeviceIDs, &psaResult);
    if (FAILED(hr) || !psaResult)
    {
        if (!psaResult)
        {
            hr = E_OUTOFMEMORY;
        }
        AtlReportError(CLSID_FaxDeviceProvider, GetErrorMsgId(hr), IID_IFaxDeviceProvider, hr, _Module.GetResourceInstance());
		CALL_FAIL(MEM_ERR, _T("SafeArrayCopy(m_psaDeviceIDs, &psaResult)"), hr);
		return hr;
	}

    //
    //  Return the Safe Array inside the VARIANT we got
    //
    VariantInit(pvDeviceIds);
    pvDeviceIds->vt = VT_I4 | VT_ARRAY;
    pvDeviceIds->parray = psaResult;
    return hr;
}

//
//==================== INIT ========================================
//
STDMETHODIMP
CFaxDeviceProvider::Init(
    FAX_DEVICE_PROVIDER_INFO *pInfo,
    FAX_PORT_INFO_EX *pDevices,
    DWORD dwNum
)
/*++

Routine name : CFaxDeviceProvider::Init

Routine description:

	Initialize the Device Provider Object with given Information.
    Allocates memory and stores given pInfo.
    Find in the pDevices its own Devices, create Variant of SafeArray containing them.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	pInfo               [in]  -- the Info of the Device Provider Object
    pDevices            [in]  -- array of all available Devices
    dwNum               [in]  -- number of elements in pDevices array

Return Value:

    Standard HRESULT code

--*/

{
	HRESULT     hr = S_OK;
	DBG_ENTER (TEXT("CFaxDeviceProvider::Init"), hr);

    //
    //  Copy the FAX_DEVICE_PROVIDER_INFO
    //
    m_Status = FAX_PROVIDER_STATUS_ENUM(pInfo->Status);
    m_lLastError = pInfo->dwLastError;

    if (!(pInfo->Version.bValid))
    {
        m_lMajorBuild = 0;
        m_lMinorBuild = 0;
        m_lMajorVersion = 0;
        m_lMinorVersion = 0;
        m_bDebug = VARIANT_FALSE;
    }
    else
    {
        m_lMajorBuild = pInfo->Version.wMajorBuildNumber;
        m_lMinorBuild = pInfo->Version.wMinorBuildNumber;
        m_lMajorVersion = pInfo->Version.wMajorVersion;
        m_lMinorVersion = pInfo->Version.wMinorVersion;
        m_bDebug = bool2VARIANT_BOOL((pInfo->Version.dwFlags & FAX_VER_FLAG_CHECKED) ? true : false);
    }

    m_bstrUniqueName = pInfo->lpctstrGUID;
    m_bstrImageName = pInfo->lpctstrImageName;
    m_bstrFriendlyName = pInfo->lpctstrFriendlyName;
    m_bstrTapiProviderName = pInfo->lpctstrProviderName;
    if ( (pInfo->lpctstrGUID && !m_bstrUniqueName) ||
         (pInfo->lpctstrFriendlyName && !m_bstrFriendlyName) ||
         (pInfo->lpctstrImageName && !m_bstrImageName) ||
         (pInfo->lpctstrProviderName && !m_bstrTapiProviderName) )
    {
        hr = E_OUTOFMEMORY;
        CALL_FAIL(MEM_ERR, _T("CComBSTR::operator=()"), hr);
        AtlReportError(CLSID_FaxDeviceProvider, GetErrorMsgId(hr), IID_IFaxDeviceProvider, hr, _Module.GetResourceInstance());
        return hr;
    }

    //
    //  count the devices of the Provider
    //
    DWORD   dwCount = 0;
    for (DWORD  i=0 ; i<dwNum ; i++ )
    {
        if ( _tcsicmp(pDevices[i].lpctstrProviderGUID, m_bstrUniqueName) == 0 )
        {
            dwCount++;
        }
    }

    //
    //  Allocate the safe array : vector of long
    //
	m_psaDeviceIDs = ::SafeArrayCreateVector(VT_I4, 0, dwCount);
	if (m_psaDeviceIDs == NULL)
	{
		//
		//	Not Enough Memory
		//
		hr = E_OUTOFMEMORY;
        AtlReportError(CLSID_FaxDeviceProvider, GetErrorMsgId(hr), IID_IFaxDeviceProvider, hr, _Module.GetResourceInstance());
		CALL_FAIL(MEM_ERR, _T("::SafeArrayCreateVector(VT_I4, 0, dwCount)"), hr);
		return hr;
	}

    if ( dwCount>0 )
    {

        //
        //  get Access to the elements of the Safe Array
        //
	    DWORD   *pdwElement;
	    hr = ::SafeArrayAccessData(m_psaDeviceIDs, (void **) &pdwElement);
	    if (FAILED(hr))
	    {
		    //
		    //	Failed to access safearray
		    //
            hr = E_FAIL;
		    CALL_FAIL(GENERAL_ERR, _T("::SafeArrayAccessData(m_psaDeviceIDs, &pdwElement)"), hr);
            AtlReportError(CLSID_FaxDeviceProvider, GetErrorMsgId(hr), IID_IFaxDeviceProvider, hr, _Module.GetResourceInstance());
		    return hr;
	    }

        //
        //  Fill the array with values
        //
        DWORD       idx = 0;
        for ( i=0 ; i<dwNum ; i++ )
        {
            if ( _tcsicmp(pDevices[i].lpctstrProviderGUID, m_bstrUniqueName) == 0 )
            {
                pdwElement[idx] = pDevices[i].dwDeviceID;
                idx++;
            }
        }

        //
        //  free the safearray from the access  
        //
	    hr = ::SafeArrayUnaccessData(m_psaDeviceIDs);
        if (FAILED(hr))
        {
	        CALL_FAIL(GENERAL_ERR, _T("::SafeArrayUnaccessData(m_psaDeviceIDs)"), hr);
        }
    }

    return hr;
}

//
//==================== SUPPORT ERROR INFO =============================================
//
STDMETHODIMP 
CFaxDeviceProvider::InterfaceSupportsErrorInfo(
    REFIID riid
)
/*++

Routine name : CFaxDeviceProvider::InterfaceSupportsErrorInfo

Routine description:

	ATL's implementation of Support Error Info.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	riid                          [in]    - Reference to the Interface.

Return Value:

    Standard HRESULT code

--*/
{
	static const IID* arr[] = 
	{
		&IID_IFaxDeviceProvider
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxdeviceproviders.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxDeviceProviders.cpp

Abstract:

	Implementation of CFaxDeviceProviders Class

Author:

	Iv Garber (IvG)	Jun, 2000

Revision History:

--*/


#include "stdafx.h"
#include "FaxComEx.h"
#include "FaxDeviceProviders.h"

//
//==================== CREATE ========================================
//
HRESULT 
CFaxDeviceProviders::Create (
	IFaxDeviceProviders **ppDeviceProviders
)
/*++

Routine name : CFaxDeviceProviders::Create

Routine description:

	Static function to create the Fax Device Providers Collection Object

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	ppDeviceProviders           [out]  -- the new Fax Device Providers Collection Object

Return Value:

    Standard HRESULT code

--*/

{
	HRESULT     hr = S_OK;
	DBG_ENTER (TEXT("CFaxDeviceProviders::Create"), hr);

    //
    //  Create Instance of the Collection
    //
	CComObject<CFaxDeviceProviders>		*pClass;
	hr = CComObject<CFaxDeviceProviders>::CreateInstance(&pClass);
	if (FAILED(hr))
	{
		CALL_FAIL(GENERAL_ERR, _T("CComObject<CFaxDeviceProviders>::CreateInstance(&pClass)"), hr);
		return hr;
	}

    //
    //  Return the desired Interface Ptr
    //
	hr = pClass->QueryInterface(ppDeviceProviders);
	if (FAILED(hr))
	{
		CALL_FAIL(GENERAL_ERR, _T("pClass->QueryInterface(ppDeviceProviders)"), hr);
		return hr;
	}

	return hr;
}	//	CFaxDeviceProviders::Create()

//
//============================= INIT ============================================
//
STDMETHODIMP
CFaxDeviceProviders::Init(
    IFaxServerInner *pServerInner
)
/*++

Routine name : CFaxDeviceProviders::Init

Routine description:

	Initialize the Collection : 
    1)  get from RPC all Device Provider and all Devices Structures, 
    2)  create COM objects for each structure,
    3)  init all these objects with the Device Provider structure and Devices array,
    4)  AddRef() each object,
    5)  put the Ptrs to Objects into the STL::vector.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	pServerInner                    [in]    - Ptr to the Fax Server.

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxDeviceProviders::Init"), hr);

	//
	//	Get Fax Server Handle
	//
    HANDLE faxHandle;
	hr = pServerInner->GetHandle(&faxHandle);
    ATLASSERT(SUCCEEDED(hr));

	if (faxHandle == NULL)
	{
		//
		//	Fax Server is not connected
		//
		hr = Fax_HRESULT_FROM_WIN32(ERROR_NOT_CONNECTED);
		CALL_FAIL(GENERAL_ERR, _T("faxHandle == NULL"), hr);
        AtlReportError(CLSID_FaxDeviceProviders, GetErrorMsgId(hr), IID_IFaxDeviceProviders, hr, _Module.GetResourceInstance());
		return hr;
	}

    //
    //  Bring from the Server all Device Providers
    //
    DWORD       dwNum = 0;
    CFaxPtr<FAX_DEVICE_PROVIDER_INFO>   pDeviceProviders;
    if (!FaxEnumerateProviders(faxHandle, &pDeviceProviders, &dwNum))
    {
		hr = Fax_HRESULT_FROM_WIN32(GetLastError());
		CALL_FAIL(GENERAL_ERR, _T("FaxEnumerateProviders(faxHandle, &pDeviceProviders, &dwNum"), hr);
        AtlReportError(CLSID_FaxDeviceProviders, GetErrorMsgId(hr), IID_IFaxDeviceProviders, hr, _Module.GetResourceInstance());
		return hr;
    }


    //
    //  Bring all the Devices from the Server
    //
    CFaxPtr<FAX_PORT_INFO_EX>   pDevices;
    DWORD                       dwNumDevices = 0;
    if (!FaxEnumPortsEx(faxHandle, &pDevices, &dwNumDevices))
    {
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        AtlReportError(CLSID_FaxDeviceProviders, GetErrorMsgId(hr), IID_IFaxDeviceProviders, hr, _Module.GetResourceInstance());
        CALL_FAIL(GENERAL_ERR, _T("FaxEnumPortsEx(hFaxHandle, &pDevices, &dwNumDevices)"), hr);
        return hr;
    }

    //
    //  Fill the Collection with Objects
    //
    CComObject<CFaxDeviceProvider>  *pClass = NULL;
    CComPtr<IFaxDeviceProvider>     pObject = NULL;
    for (DWORD i=0 ; i<dwNum ; i++ )
    {
        //
        //  Create Device Provider Object
        //
        hr = CComObject<CFaxDeviceProvider>::CreateInstance(&pClass);
        if (FAILED(hr) || (!pClass))
        {
            if (!pClass)
            {
                hr = E_OUTOFMEMORY;
    		    CALL_FAIL(MEM_ERR, _T("CComObject<CFaxDeviceProvider>::CreateInstance(&pClass)"), hr);
            }
            else
            {
    		    CALL_FAIL(GENERAL_ERR, _T("CComObject<CFaxDeviceProvider>::CreateInstance(&pClass)"), hr);
            }

            AtlReportError(CLSID_FaxDeviceProviders, GetErrorMsgId(hr), IID_IFaxDeviceProviders, hr, _Module.GetResourceInstance());
		    return hr;
        }

        //
        //  Init the Device Provider Object
        //
        hr = pClass->Init(&pDeviceProviders[i], pDevices, dwNumDevices);
        if (FAILED(hr))
        {
            CALL_FAIL(GENERAL_ERR, _T("pClass->Init(&pDeviceProviders[i], pDevices)"), hr);
            AtlReportError(CLSID_FaxDeviceProviders, GetErrorMsgId(hr), IID_IFaxDeviceProviders, hr, _Module.GetResourceInstance());
            delete pClass;
            return hr;
        }

        //
        //  Get Interface from the pClass.
        //  This will make AddRef() on the Interface. 
        //  This is the Collection's AddRef, which is freed at Collection's Dtor.
        //
        hr = pClass->QueryInterface(&pObject);
        if (FAILED(hr) || (!pObject))
        {
            if (!pObject)
            {
                hr = E_FAIL;
            }
            CALL_FAIL(GENERAL_ERR, _T("pClass->QueryInterface(&pObject)"), hr);
            AtlReportError(CLSID_FaxDeviceProviders, GetErrorMsgId(hr), IID_IFaxDeviceProviders, hr, _Module.GetResourceInstance());
            delete pClass;
            return hr;
        }

	    //
	    //	Put the Object in the collection
	    //
	    try 
	    {
		    m_coll.push_back(pObject);
	    }
	    catch (exception &)
	    {
		    hr = E_OUTOFMEMORY;
		    AtlReportError(CLSID_FaxDeviceProviders, IDS_ERROR_OUTOFMEMORY, IID_IFaxDeviceProviders, hr, _Module.GetResourceInstance());
		    CALL_FAIL(MEM_ERR, _T("m_coll.push_back(pObject)"), hr);

            //
            //  pObject will call Release(), which will delete the pClass
            //
		    return hr;
	    }

        //
        //  We want to save the current AddRef() to Collection
        //
        pObject.Detach();
    }

    return hr;
}

//
//============================= GET ITEM =========================================
//
STDMETHODIMP
CFaxDeviceProviders::get_Item(
    /*[in]*/ VARIANT vIndex, 
    /*[out, retval]*/ IFaxDeviceProvider **ppDeviceProvider
)
/*++

Routine name : CFaxDeviceProviders::get_Item

Routine description:

	Return an Item from the Collection.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	vIndex                        [in]    - Identifier of the Item to return.
	ppDeviceProvider              [out]    - the result value

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxDeviceProviders::get_Item"), hr);

    //
    //  Check the Ptr we have got
    //
    if (::IsBadWritePtr(ppDeviceProvider, sizeof(IFaxDeviceProvider *)))
    {
        hr = E_POINTER;
        AtlReportError(CLSID_FaxDeviceProviders, 
            IDS_ERROR_INVALID_ARGUMENT, 
            IID_IFaxDeviceProviders, 
            hr, 
            _Module.GetResourceInstance());
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr(ppDeviceProvider)"), hr);
		return hr;
    }

    CComVariant var;

    if (vIndex.vt != VT_BSTR)
    {
        //
        //  vIndex is not BSTR ==> convert to VT_I4
        //
        hr = var.ChangeType(VT_I4, &vIndex);
        if (SUCCEEDED(hr))
        {
            VERBOSE(DBG_MSG, _T("Parameter is Number : %d"), var.lVal);
            //
            //  call default ATL's implementation
            //
            hr = ICollectionOnSTLImpl<IFaxDeviceProviders, ContainerType, 
                IFaxDeviceProvider*, CollectionCopyType, EnumType>::get_Item(var.lVal, ppDeviceProvider);
            return hr;
		}
    }

    //
    //  convert to BSTR
    //
    hr = var.ChangeType(VT_BSTR, &vIndex);
    if (FAILED(hr))
    {
        hr = E_INVALIDARG;
        AtlReportError(CLSID_FaxDeviceProviders, 
            IDS_ERROR_INVALID_ARGUMENT, 
            IID_IFaxDeviceProviders, 
            hr, 
            _Module.GetResourceInstance());
        CALL_FAIL(GENERAL_ERR, _T("var.ChangeType(VT_BSTR, &vIndex)"), hr);
        return hr;
    }

    VERBOSE(DBG_MSG, _T("Parameter is String : %s"), var.bstrVal);

    ContainerType::iterator it = m_coll.begin();
    while (it != m_coll.end())
    {
        CComBSTR    bstrUniqueName;
        hr = (*it)->get_UniqueName(&bstrUniqueName);
        if (FAILED(hr))
        {
		    CALL_FAIL(GENERAL_ERR, _T("(*it)->get_UniqueName(&bstrUniqueName)"), hr);
            AtlReportError(CLSID_FaxDeviceProviders, 
                GetErrorMsgId(hr),
                IID_IFaxDeviceProviders, 
                hr, 
                _Module.GetResourceInstance());
            return hr;
        }

        if (_tcsicmp(bstrUniqueName, var.bstrVal) == 0)
        {
            //
            //  found the desired Device Provider
            //
            (*it)->AddRef();
            *ppDeviceProvider = *it;
            return hr;
        }
        it++;
    }

    //
    //  Device Provider does not exist
    //
	hr = E_INVALIDARG;
	CALL_FAIL(GENERAL_ERR, _T("Device Provider Is Not Found"), hr);
	AtlReportError(CLSID_FaxDeviceProviders, 
        IDS_ERROR_INVALIDDEVPROVGUID, 
        IID_IFaxDeviceProviders, 
        hr, 
        _Module.GetResourceInstance());
	return hr;
}

//
//================== SUPPORT ERROR INFO ========================================
//
STDMETHODIMP 
CFaxDeviceProviders::InterfaceSupportsErrorInfo(
    REFIID riid
)
/*++

Routine name : CFaxDeviceProviders::InterfaceSupportsErrorInfo

Routine description:

	ATL's implementation of Support Error Info.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	riid                          [in]    - Reference to the Interface.

Return Value:

    Standard HRESULT code

--*/
{
	static const IID* arr[] = 
	{
		&IID_IFaxDeviceProviders
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxdeviceproviders.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxDeviceProviders.h

Abstract:

	Declaration of the CFaxDeviceProviders Class.

Author:

	Iv Garber (IvG)	Jun, 2000

Revision History:

--*/


#ifndef __FAXDEVICEPROVIDERS_H_
#define __FAXDEVICEPROVIDERS_H_

#include "resource.h"       // main symbols
#include "FaxCommon.h"
#include <vector>
#include "VCUE_Copy.h"
#include "FaxDeviceProvider.h"

namespace DeviceProvidersNamespace
{

    //
    //  Device Provider Objects are stored in Vector of STL.
    //  When initialized, they got ALL their data. 
    //  They never call Fax Server.
    //  They do not depend neither on Fax Server nor on Device Providers Collection
    //  after they are created and initialized.
    //  So, they implemented as usual COM Objects. 
    //  The Collection stores Ptrs to them, and makes ONE AddRef(). 
    //  Each time User asks for an Object from the Collection, an additional AddRef() happens. 
    //  When killed, Collection calls Release() on all its Device Provider Objects.
    //  Those that are not asked by User, dies. 
    //  Those, that have User's AddRef() - remains alive, untill User free its Reference on them.
    //  The Device Provider Object can continue to live after all objects are freed,
    //  including Fax Server and all its Descendants. 
    //  THIS IS BECAUSE Device Provider Object and their Collection is Snap-Shot 
    //  of the situation on the Server. They are not updatable, but a read-only objects.
    //  To get the updated data, User must ask new Collection from the Server.
    //
	typedef	std::vector<IFaxDeviceProvider*>        ContainerType;

	// Use IEnumVARIANT as the enumerator for VB compatibility
	typedef	VARIANT			    EnumExposedType;
	typedef	IEnumVARIANT        EnumIfc;

	//  Copy Classes
    typedef VCUE::CopyIfc2Variant<ContainerType::value_type>    EnumCopyType;
    typedef VCUE::CopyIfc<ContainerType::value_type>            CollectionCopyType;

    //  Enumeration Type, shortcut for next typedef
    typedef CComEnumOnSTL< EnumIfc, &__uuidof(EnumIfc), EnumExposedType, EnumCopyType, ContainerType >    
        EnumType;

    //  Collection Type, real ancestor of the DeviceProvider Collection
    typedef ICollectionOnSTLImpl< IFaxDeviceProviders, ContainerType, ContainerType::value_type, 
        CollectionCopyType, EnumType >    CollectionType;
};

using namespace DeviceProvidersNamespace;

//
//==================== FAX DEVICE PROVIDERS ===========================================
//
class ATL_NO_VTABLE CFaxDeviceProviders : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public ISupportErrorInfo,
    public IDispatchImpl<DeviceProvidersNamespace::CollectionType, &IID_IFaxDeviceProviders, 
                        &LIBID_FAXCOMEXLib>,
    public CFaxInitInner
{
public:
    CFaxDeviceProviders() : CFaxInitInner(_T("FAX DEVICE PROVIDERS"))
    {}

    ~CFaxDeviceProviders()
    {
        CCollectionKiller<DeviceProvidersNamespace::ContainerType>  CKiller;
        CKiller.EmptyObjectCollection(&m_coll);
    }

DECLARE_REGISTRY_RESOURCEID(IDR_FAXDEVICEPROVIDERS)
DECLARE_NOT_AGGREGATABLE(CFaxDeviceProviders)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxDeviceProviders)
	COM_INTERFACE_ENTRY(IFaxDeviceProviders)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY(IFaxInitInner)
END_COM_MAP()

//  Interfaces
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
    STDMETHOD(get_Item)(/*[in]*/ VARIANT vIndex, /*[out, retval]*/ IFaxDeviceProvider **ppDeviceProvider);

//  Internal Use
    STDMETHOD(Init)(IFaxServerInner *pServerInner);
    static HRESULT Create(IFaxDeviceProviders **ppDeviceProviders);
};

#endif //__FAXDEVICEPROVIDERS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxdevices.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxDevices.cpp

Abstract:

	Implementation of CFaxDevices class.

Author:

	Iv Garber (IvG)	Jun, 2000

Revision History:

--*/

#include "stdafx.h"
#include "FaxComEx.h"
#include "FaxDevices.h"

//
//============================= GET ITEM =========================================
//
STDMETHODIMP
CFaxDevices::get_Item(
    /*[in]*/ VARIANT vIndex, 
    /*[out, retval]*/ IFaxDevice **ppDevice
)
/*++

Routine name : CFaxDevices::get_Item

Routine description:

	Return a Device from the Collection. 
    A Device is identified either by its Index in the Collection, or by its Name.

Author:

	Iv Garber (IvG),	May, 2001

Arguments:

	vIndex      [in]    - Variant containing Index or Name of the Device to return.
	ppDevice    [out]   - ptr to the Device to return

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxDevices::get_Item"), hr);

    //
    //  Check the Ptr we have got
    //
    if (::IsBadWritePtr(ppDevice, sizeof(IFaxDevice *)))
    {
        hr = E_POINTER;
        AtlReportError(CLSID_FaxDevices, IDS_ERROR_INVALID_ARGUMENT, IID_IFaxDevices, hr, _Module.GetResourceInstance());
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr(ppDevice)"), hr);
		return hr;
    }

    CComVariant var;

    if (vIndex.vt != VT_BSTR)
    {
        //
        //  vIndex is not BSTR ==> convert to VT_I4
        //
        hr = var.ChangeType(VT_I4, &vIndex);
        if (SUCCEEDED(hr))
        {
            VERBOSE(DBG_MSG, _T("Parameter is Number : %d"), var.lVal);
            //
            //  call default ATL's implementation
            //
            hr = ICollectionOnSTLImpl<IFaxDevices, ContainerType, 
                IFaxDevice*, CollectionCopyType, EnumType>::get_Item(var.lVal, ppDevice);
            return hr;
		}
    }

    //
    //  convert to BSTR
    //
    hr = var.ChangeType(VT_BSTR, &vIndex);
    if (FAILED(hr))
    {
        hr = E_INVALIDARG;
        AtlReportError(CLSID_FaxDevices, IDS_ERROR_INVALID_ARGUMENT, IID_IFaxDevices, hr, _Module.GetResourceInstance());
        CALL_FAIL(GENERAL_ERR, _T("var.ChangeType(VT_BSTR, &vIndex)"), hr);
        return hr;
    }

    VERBOSE(DBG_MSG, _T("Parameter is String : %s"), var.bstrVal);

    ContainerType::iterator it = m_coll.begin();
    while (it != m_coll.end())
    {
        CComBSTR    bstrDeviceName;
        hr = (*it)->get_DeviceName(&bstrDeviceName);
        if (FAILED(hr))
        {
		    CALL_FAIL(GENERAL_ERR, _T("(*it)->get_DeviceName(&bstrDeviceName)"), hr);
            AtlReportError(CLSID_FaxDevices, GetErrorMsgId(hr), IID_IFaxDevices, hr, _Module.GetResourceInstance());
            return hr;
        }

        if (_tcsicmp(bstrDeviceName, var.bstrVal) == 0)
        {
            //
            //  found the desired Device 
            //
            (*it)->AddRef();
            *ppDevice = *it;
            return hr;
        }
        it++;
    }

    //
    //  Device does not exist
    //
	hr = E_INVALIDARG;
	CALL_FAIL(GENERAL_ERR, _T("Device Is Not Found"), hr);
	AtlReportError(CLSID_FaxDevices, IDS_ERROR_INVALIDDEVICE, IID_IFaxDevices, hr, _Module.GetResourceInstance());
	return hr;
}

//
//==================== ITEM BY ID ================================================
//
STDMETHODIMP
CFaxDevices::get_ItemById(
    /*[in]*/ long lId, 
    /*[out, retval]*/ IFaxDevice **ppDevice
)
/*++

Routine name : CFaxDevices::get_ItemById

Routine description:

	Return Fax Device Object by given Device ID.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	lId                           [in]    - the ID of the Device to Return
	ppFaxDevice                   [out]    - the Device To Return

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxDevices::get_ItemById"), hr, _T("ID=%d"), lId);

    //
    //  Check the Ptr we have got
    //
    if (::IsBadWritePtr(ppDevice, sizeof(IFaxDevice *)))
    {
        hr = E_POINTER;
        AtlReportError(CLSID_FaxDevices, IDS_ERROR_INVALID_ARGUMENT, IID_IFaxDevices, hr, _Module.GetResourceInstance());
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr(ppDevice)"), hr);
		return hr;
    }

    //
    //  Find the Device In the Collection
    //
    long    lDeviceID;
    ContainerType::iterator it = m_coll.begin();
    while (it != m_coll.end())
    {
        hr = (*it)->get_Id(&lDeviceID);
        if (FAILED(hr))
        {
		    CALL_FAIL(GENERAL_ERR, _T("(*it)->get_Id(&lDeviceID)"), hr);
            AtlReportError(CLSID_FaxDevices, GetErrorMsgId(hr), IID_IFaxDevices, hr, _Module.GetResourceInstance());
            return hr;
        }

        if (lId == lDeviceID)
        {
            //
            //  found the desired Device 
            //
            (*it)->AddRef();
            *ppDevice = *it;
            return hr;
        }
        it++;
    }

    //
    //  Device does not exist
    //
	hr = E_INVALIDARG;
	CALL_FAIL(GENERAL_ERR, _T("Device Is Not Found"), hr);
	AtlReportError(CLSID_FaxDevices, IDS_ERROR_INVALIDDEVICEID, IID_IFaxDevices, hr, _Module.GetResourceInstance());
    return hr;
}

//
//============================= INIT ============================================
//
STDMETHODIMP
CFaxDevices::Init(
    IFaxServerInner *pServerInner
)
/*++

Routine name : CFaxDevices::Init

Routine description:

	Initialize the Collection : get from RPC all Devices,
    Create all Objects and store them in the stl::vector.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	pServerInner                    [in]    - Ptr to the Fax Server.

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxDevices::Init"), hr);

	//
	//	Get Fax Server Handle
	//
    HANDLE faxHandle;
	hr = pServerInner->GetHandle(&faxHandle);
    ATLASSERT(SUCCEEDED(hr));

	if (faxHandle == NULL)
	{
		//
		//	Fax Server is not connected
		//
		hr = Fax_HRESULT_FROM_WIN32(ERROR_NOT_CONNECTED);
		CALL_FAIL(GENERAL_ERR, _T("faxHandle == NULL"), hr);
        AtlReportError(CLSID_FaxDevices, GetErrorMsgId(hr), IID_IFaxDevices, hr, _Module.GetResourceInstance());
		return hr;
	}

    //
    //  Bring from the Server all Devices 
    //
    DWORD       dwNum = 0;
    CFaxPtr<FAX_PORT_INFO_EX>   pDevices;
    if (!FaxEnumPortsEx(faxHandle, &pDevices, &dwNum))
    {
		hr = Fax_HRESULT_FROM_WIN32(GetLastError());
		CALL_FAIL(GENERAL_ERR, _T("FaxEnumPortsEx(faxHandle, &pDevices, &dwNum)"), hr);
        AtlReportError(CLSID_FaxDevices, GetErrorMsgId(hr), IID_IFaxDevices, hr, _Module.GetResourceInstance());
		return hr;
    }
    //
    //  Fill the Collection with Objects
    //
    CComObject<CFaxDevice>  *pClass = NULL;
    CComPtr<IFaxDevice>     pObject = NULL;
    for (DWORD i=0 ; i<dwNum ; i++ )
    {
        //
        //  Create Device Object
        //
        hr = CComObject<CFaxDevice>::CreateInstance(&pClass);
        if (FAILED(hr) || (!pClass))
        {
            if (!pClass)
            {
                hr = E_OUTOFMEMORY;
    		    CALL_FAIL(MEM_ERR, _T("CComObject<CFaxDevice>::CreateInstance(&pClass)"), hr);
            }
            else
            {
    		    CALL_FAIL(GENERAL_ERR, _T("CComObject<CFaxDevice>::CreateInstance(&pClass)"), hr);
            }

            AtlReportError(CLSID_FaxDevices, GetErrorMsgId(hr), IID_IFaxDevices, hr, _Module.GetResourceInstance());
		    return hr;
        }

        //
        //  Init the Device Object
        //
        hr = pClass->Init(&pDevices[i], 
                          pServerInner);
        if (FAILED(hr))
        {
            CALL_FAIL(GENERAL_ERR, _T("pClass->Init(&pDevices[i], pServerInner)"), hr);
            AtlReportError(CLSID_FaxDevices, GetErrorMsgId(hr), IID_IFaxDevices, hr, _Module.GetResourceInstance());
            delete pClass;
            return hr;
        }

        //
        //  Get Interface from the pClass.
        //  This will make AddRef() on the Interface. 
        //  This is the Collection's AddRef, which is freed at Collection's Dtor.
        //
        hr = pClass->QueryInterface(&pObject);
        if (FAILED(hr) || (!pObject))
        {
            if (!pObject)
            {
                hr = E_FAIL;
            }
            CALL_FAIL(GENERAL_ERR, _T("pClass->QueryInterface(&pObject)"), hr);
            AtlReportError(CLSID_FaxDevices, GetErrorMsgId(hr), IID_IFaxDevices, hr, _Module.GetResourceInstance());
            delete pClass;
            return hr;
        }

	    //
	    //	Put the Object in the collection
	    //
	    try 
	    {
		    m_coll.push_back(pObject);
	    }
	    catch (exception &)
	    {
		    hr = E_OUTOFMEMORY;
		    AtlReportError(CLSID_FaxDevices, IDS_ERROR_OUTOFMEMORY, IID_IFaxDevices, hr, _Module.GetResourceInstance());
		    CALL_FAIL(MEM_ERR, _T("m_coll.push_back(pObject)"), hr);

            //
            //  no need to delete the pClass. pObject is CComPtr, it will be Released, and this 
            //  will delete the pClass object.
            //
		    return hr;
	    }

        //
        //  We want to save the current AddRef() to Collection
        //
        pObject.Detach();

    }

    return hr;
}

//
//==================== CREATE ========================================
//
HRESULT 
CFaxDevices::Create (
	IFaxDevices **ppDevices
)
/*++

Routine name : CFaxDevices::Create

Routine description:

	Static function to create the Fax Devices Collection Object

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	ppDevices              [out]  -- the new Fax Devices Collection Object

Return Value:

    Standard HRESULT code

--*/

{
	HRESULT     hr = S_OK;
	DBG_ENTER (TEXT("CFaxDevices::Create"), hr);

    //
    //  Create Instance of the Collection
    //
	CComObject<CFaxDevices>		*pClass;
	hr = CComObject<CFaxDevices>::CreateInstance(&pClass);
	if (FAILED(hr))
	{
		CALL_FAIL(GENERAL_ERR, _T("CComObject<CFaxDevices>::CreateInstance(&pClass)"), hr);
		return hr;
	}

    //
    //  Return the desired Interface Ptr
    //
	hr = pClass->QueryInterface(ppDevices);
	if (FAILED(hr))
	{
		CALL_FAIL(GENERAL_ERR, _T("pClass->QueryInterface(ppDevices)"), hr);
		return hr;
	}

	return hr;
}	//	CFaxDevices::Create()

//
//=================== SUPPORT ERROR INFO =================================================
//
STDMETHODIMP 
CFaxDevices::InterfaceSupportsErrorInfo(
    REFIID riid
)
/*++

Routine name : CFaxDevices::InterfaceSupportsErrorInfo

Routine description:

	ATL's implementation of Support Error Info.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	riid                          [in]    - Reference to the Infterface to check

Return Value:

    Standard HRESULT code

--*/
{
	static const IID* arr[] = 
	{
		&IID_IFaxDevices
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxdevices.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxDevices.h

Abstract:

	Declaration of the CFaxDevices class.

Author:

	Iv Garber (IvG)	Jun, 2000

Revision History:

--*/

#ifndef __FAXDEVICES_H_
#define __FAXDEVICES_H_

#include "resource.h"       // main symbols
#include "FaxCommon.h"
#include <vector>
#include "VCUE_Copy.h"
#include "FaxDevice.h"

namespace DevicesNamespace
{

    //
    //  Device Objects are stored in Vector of STL.
    //  When initialized, they got ALL their data, and Fax Server Ptr.
    //  They do not depend on Devices Collection, only on Fax Server.
    //  So, they implemented as usual COM Objects. 
    //  They inherit from CFaxInitInnerAddRef class, which means they make AddRef() 
    //  on Fax Server ( at Init() ).
    //  By doing this, the objects prevent the death of the Fax Server prematurely.
    //  So, if the User frees all its references to the Fax Server, but holds its
    //  reference to the Device Object, the Device Object will continue to work,
    //  because Fax Server Object actually did not died.
    //  The Collection stores Ptrs to them, and makes ONE AddRef(). 
    //  Each time User asks for an Object from the Collection, an additional AddRef() happens. 
    //  When killed, Collection calls Release() on all its Device Provider Objects.
    //  Those that were not requested by the User, dies. 
    //  Those, that have User's AddRef() - remains alive, untill User free its Reference on them.
    //  Fax Server remains alive untill all the Device Collections and all Device Objects are killed.
    //  At their death, they Release() the Fax Server.
    //
	typedef	std::vector<IFaxDevice*>       ContainerType;

	// Use IEnumVARIANT as the enumerator for VB compatibility
	typedef	VARIANT			EnumExposedType;
	typedef	IEnumVARIANT    EnumIfc;

	//  Copy Classes
    typedef VCUE::CopyIfc2Variant<ContainerType::value_type>    EnumCopyType;
    typedef VCUE::CopyIfc<ContainerType::value_type>            CollectionCopyType;

    typedef CComEnumOnSTL< EnumIfc, &__uuidof(EnumIfc), EnumExposedType, EnumCopyType, 
        ContainerType >    EnumType;

    typedef ICollectionOnSTLImpl< IFaxDevices, ContainerType, ContainerType::value_type, 
        CollectionCopyType, EnumType >    CollectionType;
};

using namespace DevicesNamespace;

//
//===================== FAX DEVICES =============================================
//
class ATL_NO_VTABLE CFaxDevices : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public ISupportErrorInfo,
    public IDispatchImpl<DevicesNamespace::CollectionType, &IID_IFaxDevices, &LIBID_FAXCOMEXLib>,
    public CFaxInitInner    //  for Debug + Creation thru CObjectHandler
{
public:
    CFaxDevices() : CFaxInitInner(_T("FAX DEVICES"))
	{
	}

    ~CFaxDevices()
    {
        CCollectionKiller<DevicesNamespace::ContainerType>  CKiller;
        CKiller.EmptyObjectCollection(&m_coll);
    }

DECLARE_REGISTRY_RESOURCEID(IDR_FAXDEVICES)
DECLARE_NOT_AGGREGATABLE(CFaxDevices)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxDevices)
	COM_INTERFACE_ENTRY(IFaxDevices)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY(IFaxInitInner)
END_COM_MAP()

//  Interfaces
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
    STDMETHOD(get_Item)(/*[in]*/ VARIANT vIndex, /*[out, retval]*/ IFaxDevice **ppDevice);
    STDMETHOD(get_ItemById)(/*[in]*/ long lId, /*[out, retval]*/ IFaxDevice **ppFaxDevice);

//  Internal Use
    static HRESULT Create(IFaxDevices **ppDevices);
    STDMETHOD(Init)(IFaxServerInner *pServer);
};

#endif //__FAXDEVICES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxdocument.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    FaxDocument.cpp

Abstract:

    Implementation of CFaxDocument

Author:

    Iv Garber (IvG) Apr, 2000

Revision History:

--*/

#include "stdafx.h"
#include "FaxComEx.h"
#include "FaxDocument.h"
#include "faxutil.h"


//
//==================== SUBMIT =======================================
//
STDMETHODIMP
CFaxDocument::Submit(
    /*[in]*/ BSTR bstrFaxServerName, 
    /*[out, retval]*/ VARIANT *pvFaxOutgoingJobIDs
)
/*++

Routine name : CFaxDocument::Submit

Routine description:

    Connect to the Fax Server whose name is given as a parameter to the function;
    Submit the Fax Document on this Fax Server;
    Disconnect from the Fax Server.

Author:

    Iv Garber (IvG),    Dec, 2000

Arguments:

    bstrFaxServerName             [in]    - Fax Server Name to connect and send the document through
    ppsfbstrFaxOutgoingJobIDs     [out, retval]    - Result : List of Created Jobs for the Document

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;

    DBG_ENTER (_T("CFaxDocument::Submit"), hr, _T("%s"), bstrFaxServerName);

    //
    //  Create Fax Server Object
    //
    CComObject<CFaxServer>  *pFaxServer = NULL;
    hr = CComObject<CFaxServer>::CreateInstance(&pFaxServer);
    if (FAILED(hr) || !pFaxServer)
    {
        //
        //  Not enough memory
        //
        hr = E_OUTOFMEMORY;
        Error(IDS_ERROR_OUTOFMEMORY, IID_IFaxDocument, hr);
        CALL_FAIL(MEM_ERR, _T("new CComObject<CFaxServer>"), hr);
        goto exit;
    }
    pFaxServer->AddRef();

    //
    //  Connect to Fax Server
    //
    hr = pFaxServer->Connect(bstrFaxServerName);
    if (FAILED(hr))
    {
        //
        //  Connect handles the error
        //
        CALL_FAIL(GENERAL_ERR, _T("faxServer.Connect()"), hr);
        goto exit;
    }

    //
    //  Submit Fax Document
    //
    hr = ConnectedSubmit(pFaxServer, pvFaxOutgoingJobIDs);
    if (FAILED(hr))
    {
        //
        //  Submit handles the error 
        //
        CALL_FAIL(GENERAL_ERR, _T("Submit(faxServer,...)"), hr);
        goto exit;
    }

    //
    //  Disconnect
    //
    hr = pFaxServer->Disconnect();
    if (FAILED(hr))
    {
        //
        //  Disconnect handles the error 
        //
        CALL_FAIL(GENERAL_ERR, _T("faxServer.Disconnect())"), hr);
    }

exit:
    if (pFaxServer)
    {
        pFaxServer->Release();
    }

    return hr;
}


//
//================= FINAL CONSTRUCT ===========================
//
HRESULT 
CFaxDocument::FinalConstruct()
/*++

Routine name : CFaxDocument::FinalConstruct

Routine description:

    Final Construct

Author:

    Iv Garber (IvG),    Apr, 2000

Arguments:


Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;

    DBG_ENTER (_T("CFaxDocument::FinalConstruct"), hr);

    //
    //  Initialize instance vars
    //
    m_CallHandle = 0;
    m_ScheduleTime = 0;
    m_Priority = fptLOW;
    m_ReceiptType = frtNONE;
    m_ScheduleType = fstNOW;
    m_CoverPageType = fcptNONE;
    m_bAttachFax = VARIANT_FALSE;
    m_bUseGrouping = VARIANT_FALSE;

    return hr;
}

//
//==================== CONNECTED SUBMIT =======================================
//
STDMETHODIMP
CFaxDocument::ConnectedSubmit(
    /*[in]*/ IFaxServer *pFaxServer, 
    /*[out, retval]*/ VARIANT *pvFaxOutgoingJobIDs
)
/*++

Routine name : CFaxDocument::ConnectedSubmit

Routine description:

    Submit the Fax Document on already connected Fax Server

Author:

    Iv Garber (IvG),    Apr, 2000

Arguments:

    pFaxServer                    [in]    - Fax Server to Send the Document through
    ppsfbstrFaxOutgoingJobIDs     [out, retval]    - Result : List of Created Jobs for the Document

Return Value:

    Standard HRESULT code

--*/
{

    HRESULT     hr = S_OK;
    bool        bRes = TRUE;
    HANDLE      hFaxHandle = NULL;
    LPCTSTR     lpctstrFileName = NULL;
    DWORD       dwNumRecipients = 0;
    long        lNum = 0L;
    LONG_PTR    i = 0;
    DWORDLONG   dwlMessageId = 0;
    PDWORDLONG  lpdwlRecipientMsgIds = NULL;

    PFAX_PERSONAL_PROFILE       pRecipientsPersonalProfile = NULL;
    FAX_PERSONAL_PROFILE        SenderPersonalProfile;
    PFAX_COVERPAGE_INFO_EX      pCoverPageInfoEx = NULL;
    FAX_JOB_PARAM_EX            JobParamEx;

    SAFEARRAY                   *psa = NULL;

    DBG_ENTER (_T("CFaxDocument::ConnectedSubmit"), hr);

    if (!pFaxServer)
    {
        //
        //  Bad Return OR Interface Pointer
        //
        hr = E_POINTER;
        Error(IDS_ERROR_INVALID_ARGUMENT, IID_IFaxDocument, hr);
        CALL_FAIL(GENERAL_ERR, _T("!pFaxServer"), hr);
        return hr;
    }

    if ( ::IsBadWritePtr(pvFaxOutgoingJobIDs, sizeof(VARIANT)) )
    {
        //
        //  Bad Return OR Interface Pointer
        //
        hr = E_POINTER;
        Error(IDS_ERROR_INVALID_ARGUMENT, IID_IFaxDocument, hr);
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr(pvFaxOutgoingJobIDs, sizeof(VARIANT))"), hr);
        return hr;
    }

    //
    //  Recipients Collection must exist and must contain at least one item
    //
    if (!m_Recipients)
    {
        hr = E_INVALIDARG;
        Error(IDS_ERROR_NO_RECIPIENTS, IID_IFaxDocument, hr);
        CALL_FAIL(GENERAL_ERR, _T("!m_Recipients"), hr);
        return hr;
    }

    //
    //  Get Fax Server Handle
    //
    CComQIPtr<IFaxServerInner>  pIFaxServerInner(pFaxServer);
    if (!pIFaxServerInner)
    {
        hr = E_FAIL;
        Error(IDS_ERROR_OPERATION_FAILED, IID_IFaxDocument, hr);
        CALL_FAIL(GENERAL_ERR, 
            _T("CComQIPtr<IFaxServerInner>	pIFaxServerInner(pFaxServer)"), 
            hr);
        return hr;
    }

    hr = pIFaxServerInner->GetHandle(&hFaxHandle);
    if (FAILED(hr))
    {
        Error(IDS_ERROR_OPERATION_FAILED, IID_IFaxDocument, hr);
        CALL_FAIL(GENERAL_ERR, _T("pIFaxServerInner->GetHandle(&hFaxHandle)"), hr);
        return hr;
    }

    if (hFaxHandle == NULL)
    {
        //
        //  Fax Server is not connected
        //
        hr = Fax_HRESULT_FROM_WIN32(ERROR_NOT_CONNECTED);
        Error(IDS_ERROR_SERVER_NOT_CONNECTED, IID_IFaxDocument, hr);
        CALL_FAIL(GENERAL_ERR, _T("hFaxHandle==NULL"), hr);
        return hr;
    }

    //
    //  Get File Name of the Document
    //
    if (m_bstrBody && (m_bstrBody.Length() > 0))
    {
        lpctstrFileName = m_bstrBody;
    }
    else
    {
        //
        //  check that Cover Page exists
        //
        if (m_CoverPageType == fcptNONE)
        {
            //
            //  invalid arguments combination
            //
            hr = E_INVALIDARG;
            Error(IDS_ERROR_NOTHING_TO_SUBMIT, IID_IFaxDocument, hr);
            CALL_FAIL(GENERAL_ERR, _T("No Document Body and CoverPageType == fcptNONE"), hr);
            return hr;
        }
    }

    //
    //  Check consistency of Cover Page data
    //
    if ( (m_CoverPageType != fcptNONE) && (m_bstrCoverPage.Length() < 1))
    {
        //
        //  Cover Page File Name is missing
        //
        hr = E_INVALIDARG;
        Error(IDS_ERROR_NOCOVERPAGE, IID_IFaxDocument, hr);
        CALL_FAIL(GENERAL_ERR, _T("CoverPageType != fcptNONE but m_bstrCoverPage is empty."), hr);
        return hr;
    }

    //
    //  Prepare Cover Page data
    //
    if ((m_CoverPageType != fcptNONE) || (m_bstrSubject.Length() > 0))
    {
        pCoverPageInfoEx = PFAX_COVERPAGE_INFO_EX(MemAlloc(sizeof(FAX_COVERPAGE_INFO_EX)));
        if (!pCoverPageInfoEx)
        {
            //
            //  Not enough memory
            //
            hr = E_OUTOFMEMORY;
            Error(IDS_ERROR_OUTOFMEMORY, IID_IFaxDocument, hr);
            CALL_FAIL(MEM_ERR, _T("MemAlloc(sizeof(FAX_COVERPAGE_INFO_EX)"), hr);
            return hr;
        }

        ZeroMemory(pCoverPageInfoEx, sizeof(FAX_COVERPAGE_INFO_EX));
        pCoverPageInfoEx ->dwSizeOfStruct = sizeof(FAX_COVERPAGE_INFO_EX);

        pCoverPageInfoEx ->lptstrSubject = m_bstrSubject;

        if (m_CoverPageType != fcptNONE)
        {
            pCoverPageInfoEx ->dwCoverPageFormat = FAX_COVERPAGE_FMT_COV;
            pCoverPageInfoEx ->lptstrCoverPageFileName = m_bstrCoverPage;
            pCoverPageInfoEx ->bServerBased = (m_CoverPageType == fcptSERVER);
            pCoverPageInfoEx ->lptstrNote = m_bstrNote;
        }
        else
        {
            //
            //  No Cover Page, only Subject
            //
            pCoverPageInfoEx ->dwCoverPageFormat = FAX_COVERPAGE_FMT_COV_SUBJECT_ONLY;
        }
    }

    //
    //  Call Sender Profile to Bring its Data
    //
    m_Sender.GetSenderProfile(&SenderPersonalProfile);
    if (FAILED(hr))
    {
        Error(IDS_ERROR_OPERATION_FAILED, IID_IFaxDocument, hr);
        CALL_FAIL(GENERAL_ERR, _T("m_Sender.GetSenderProfile(&SenderPersonalProfile)"), hr);
        goto error;
    }

    //
    //  Get Number of Recipients
    //
    hr = m_Recipients->get_Count(&lNum);
    if (FAILED(hr))
    {
        Error(IDS_ERROR_OPERATION_FAILED, IID_IFaxDocument, hr);
        CALL_FAIL(GENERAL_ERR, _T("m_Recipients->get_Count()"), hr);
        goto error;
    }

    if (lNum <= 0)
    {
        hr = E_INVALIDARG;
        Error(IDS_ERROR_NO_RECIPIENTS, IID_IFaxDocument, hr);
        CALL_FAIL(GENERAL_ERR, _T("!m_Recipients"), hr);
        goto error;
    }

    //
    //  TapiConnection / CallHandle support
    //
    if (m_TapiConnection || (m_CallHandle != 0))
    {
        if (lNum > 1)
        {
            //
            //  ONLY ONE Recipient is allowed in this case
            //
            hr = E_INVALIDARG;
            Error(IDS_ERROR_ILLEGAL_RECIPIENTS, IID_IFaxDocument, hr);
            CALL_FAIL(GENERAL_ERR, _T("TapiConnection and/or CallHandle + more than ONE Recipients."), hr);
            goto error;
        }

        if (m_TapiConnection)
        {
            //
            //  Pass TapiConnection to the Fax Service
            //
            JobParamEx.dwReserved[0] = 0xFFFF1234;
            JobParamEx.dwReserved[1] = DWORD_PTR(m_TapiConnection.p);
        }
    }

    //
    //  Total number of Recipients
    //
    dwNumRecipients = lNum;

    //
    //  Get Array of Recipient Personal Profiles
    //
    pRecipientsPersonalProfile = PFAX_PERSONAL_PROFILE(MemAlloc(sizeof(FAX_PERSONAL_PROFILE) * lNum));
    if (!pRecipientsPersonalProfile)
    {
        //
        //  Not enough memory
        //
        hr = E_OUTOFMEMORY;
        Error(IDS_ERROR_OUTOFMEMORY, IID_IFaxDocument, hr);
        CALL_FAIL(MEM_ERR, _T("MemAlloc(sizeof(FAX_PERSONAL_PROFILE) * lNum)"), hr);
        goto error;
    }

    for ( i = 1 ; i <= lNum ; i++ )
    {
        //
        //  Get Next Recipient
        //
        CComPtr<IFaxRecipient>  pCurrRecipient = NULL;
        hr = m_Recipients->get_Item(i, &pCurrRecipient);
        if (FAILED(hr))
        {
            Error(IDS_ERROR_OPERATION_FAILED, IID_IFaxDocument, hr);
            CALL_FAIL(GENERAL_ERR, _T("m_Recipients->get_Item(i, &pCurrRecipient)"), hr);
            goto error;
        }

        //
        //  Get its Data
        //
        BSTR    bstrName = NULL;
        BSTR    bstrFaxNumber = NULL;

        hr = pCurrRecipient->get_Name(&bstrName);
        if (FAILED(hr))
        {
            Error(IDS_ERROR_OPERATION_FAILED, IID_IFaxDocument, hr);
            CALL_FAIL(GENERAL_ERR, _T("pCurrRecipient->get_Name(&bstrName)"), hr);
            goto error;
        }

        hr = pCurrRecipient->get_FaxNumber(&bstrFaxNumber);
        if (FAILED(hr))
        {
            Error(IDS_ERROR_OPERATION_FAILED, IID_IFaxDocument, hr);
            CALL_FAIL(GENERAL_ERR, _T("pCurrRecipient->get_FaxNumber(&bstrFaxNumber)"), hr);
            goto error;
        }

        //
        //  Store the data to pass at Fax Submit
        //
        FAX_PERSONAL_PROFILE    currProfile = {0};
        currProfile.dwSizeOfStruct = sizeof(FAX_PERSONAL_PROFILE);
        currProfile.lptstrFaxNumber = bstrFaxNumber;
        currProfile.lptstrName = bstrName;

        *(pRecipientsPersonalProfile + i - 1) = currProfile;
    }

    //
    //  Fill Job Params 
    //
    JobParamEx.dwSizeOfStruct = sizeof(FAX_JOB_PARAM_EX);
    JobParamEx.lptstrReceiptDeliveryAddress = m_bstrReceiptAddress;
    JobParamEx.Priority = FAX_ENUM_PRIORITY_TYPE(m_Priority);
    JobParamEx.lptstrDocumentName = m_bstrDocName;
    JobParamEx.dwScheduleAction = m_ScheduleType;
    JobParamEx.dwPageCount = 0;
    JobParamEx.hCall = m_CallHandle;    //  either Zero or Valid Value

    if ((m_bUseGrouping == VARIANT_TRUE) && (dwNumRecipients > 1))
    {
         JobParamEx.dwReceiptDeliveryType = m_ReceiptType | DRT_GRP_PARENT;
    }
    else
    {
         JobParamEx.dwReceiptDeliveryType = m_ReceiptType;
    }

    //
    //  Add AttachFaxToReceipt flag if applicable.
    //
    //  The conditions are :
    //      1.  m_bAttachFax is set to VARIANT_TRUE
    //      2.  ReceiptType is MAIL 
    //      3.  The next case is NOT the current one :
    //              m_bUseGrouping is set to VARIANT_TRUE
    //              no Body
    //              Number of Recipients is more than ONE
    //
    if ( (m_bAttachFax == VARIANT_TRUE) 
        &&
         (m_ReceiptType == frtMAIL) 
        &&
         ((m_bUseGrouping == VARIANT_FALSE) || (m_bstrBody) || (dwNumRecipients == 1))
       ) 
    {
        JobParamEx.dwReceiptDeliveryType |= DRT_ATTACH_FAX;
    }

    if (m_ScheduleType == fstSPECIFIC_TIME)
    {
        if (m_ScheduleTime == 0)
        {
            //
            //  Invalid Combination
            //
            hr = E_INVALIDARG;
            Error(IDS_ERROR_SCHEDULE_TYPE, IID_IFaxDocument, hr);
            CALL_FAIL(GENERAL_ERR, 
                _T("m_ScheduleType==fstSPECIFIC_TIME but m_ScheduleTime==0"), 
                hr);
            goto error;
        }

        SYSTEMTIME  ScheduleTime;

        if (TRUE != VariantTimeToSystemTime(m_ScheduleTime, &ScheduleTime))
        {
            //
            //  VariantTimeToSystemTime failed
            //
            hr = E_INVALIDARG;
            Error(IDS_ERROR_OPERATION_FAILED, IID_IFaxDocument, hr);
            CALL_FAIL(GENERAL_ERR, _T("VariantTimeToSystemTime"), hr);
            goto error;
        }

        JobParamEx.tmSchedule = ScheduleTime;
    }

    lpdwlRecipientMsgIds = PDWORDLONG(MemAlloc(sizeof(DWORDLONG) * lNum));
    if (!lpdwlRecipientMsgIds)
    {
        //
        //  Not enough memory
        //
        hr = E_OUTOFMEMORY;
        Error(IDS_ERROR_OUTOFMEMORY, IID_IFaxDocument, hr);
        CALL_FAIL(MEM_ERR, _T("MemAlloc(sizeof(DWORDLONG) * lNum"), hr);
        goto error;
    }

    if ( FALSE == FaxSendDocumentEx(hFaxHandle, 
        lpctstrFileName, 
        pCoverPageInfoEx, 
        &SenderPersonalProfile,
        dwNumRecipients,
        pRecipientsPersonalProfile,
        &JobParamEx,
        &dwlMessageId,
        lpdwlRecipientMsgIds) )
    {
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        Error(GetErrorMsgId(hr), IID_IFaxDocument, hr);
        CALL_FAIL(GENERAL_ERR, _T("FaxSendDocumentEx()"), hr);
        goto error;
    }

    //
    //  Put Received Job Ids into SafeArray
    //
    psa = ::SafeArrayCreateVector(VT_BSTR, 0, lNum);
    if (!psa)
    {
        //
        //  Not Enough Memory
        //
        hr = E_OUTOFMEMORY;
        Error(IDS_ERROR_OUTOFMEMORY, IID_IFaxDocument, hr);
        CALL_FAIL(MEM_ERR, _T("::SafeArrayCreate()"), hr);
        goto error;
    }

    BSTR *pbstr;
    hr = ::SafeArrayAccessData(psa, (void **) &pbstr);
    if (FAILED(hr))
    {
        //
        //  Failed to access safearray
        //
        Error(IDS_ERROR_OPERATION_FAILED, IID_IFaxDocument, hr);
        CALL_FAIL(GENERAL_ERR, _T("::SafeArrayAccessData()"), hr);
        goto error;
    }

    TCHAR       tcBuffer[25];
    for ( i = 0 ; i < lNum ; i++ )
    {
        ::_i64tot(lpdwlRecipientMsgIds[i], tcBuffer, 10);
        pbstr[i] = ::SysAllocString(tcBuffer);
        if (pbstr[i] == NULL)
        {
            //
            //  Not Enough Memory
            //
            hr = E_OUTOFMEMORY;
            Error(IDS_ERROR_OUTOFMEMORY, IID_IFaxDocument, hr);
            CALL_FAIL(MEM_ERR, _T("::SysAllocString()"), hr);
            goto error;
        }
    }

    hr = SafeArrayUnaccessData(psa);
    if (FAILED(hr))
    {
        CALL_FAIL(GENERAL_ERR, _T("::SafeArrayUnaccessData(psa)"), hr);
    }

    VariantInit(pvFaxOutgoingJobIDs);
    pvFaxOutgoingJobIDs->vt = VT_BSTR | VT_ARRAY;
    pvFaxOutgoingJobIDs->parray = psa;
    goto ok;

error:
    //
    //  Delete SafeArray only in the case on an Error
    //
    if (psa)
    {
        SafeArrayDestroy(psa);
    }

ok:
    if (pCoverPageInfoEx) 
    {
        MemFree(pCoverPageInfoEx);
    }

    if (pRecipientsPersonalProfile) 
    {
        for (i = 0 ; i < dwNumRecipients ; i++ )
        {
            //
            //  Free the Name and the Fax Number of each Recipient
            //
            ::SysFreeString(pRecipientsPersonalProfile[i].lptstrName);
            ::SysFreeString(pRecipientsPersonalProfile[i].lptstrFaxNumber);
        }

        MemFree(pRecipientsPersonalProfile);
    }

    if (lpdwlRecipientMsgIds)
    {
        MemFree(lpdwlRecipientMsgIds);
    }

    return hr;
}

//
//==================== INTERFACE SUPPORT ERROR INFO =======================
//
STDMETHODIMP
CFaxDocument::InterfaceSupportsErrorInfo (
    REFIID riid
)
/*++

Routine name : CFaxRecipients::InterfaceSupportsErrorInfo

Routine description:

    ATL's implementation of Support Error Info

Author:

    Iv Garber (IvG),    Apr, 2000

Arguments:

    riid                          [in]    - Interface ID

Return Value:

    Standard HRESULT code

--*/
{
    static const IID* arr[] = 
    {
        &IID_IFaxDocument
    };
    for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
    {
        if (InlineIsEqualGUID(*arr[i],riid))
            return S_OK;
    }
    return S_FALSE;
}

//
//========================= GET OBJECTS ======================================
//
STDMETHODIMP 
CFaxDocument::get_Sender (
    IFaxSender **ppFaxSender
)
/*++

Routine name : CFaxDocument::get_Sender

Routine description:

    Return Default Sender Information

Author:

    Iv Garber (IvG),    Apr, 2000

Arguments:

    ppFaxSender            [out]    - current Sender object

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;

    DBG_ENTER (_T("CFaxDocument::get_Sender"), hr);

    if (::IsBadWritePtr(ppFaxSender, sizeof(IFaxSender *)))
    {
        //
        //  Got a bad return pointer
        //
        hr = E_POINTER;
        Error(IDS_ERROR_INVALID_ARGUMENT, IID_IFaxDocument, hr);
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr()"), hr);
        return hr;
    }

    //
    //  Sender Profile is created at Final Construct
    //
    hr = m_Sender.QueryInterface(ppFaxSender);
    if (FAILED(hr))
    {
        //
        //  Failed to copy interface
        //
        Error(IDS_ERROR_OPERATION_FAILED, IID_IFaxDocument, hr);
        CALL_FAIL(GENERAL_ERR, _T("CCom<IFaxSender>::CopyTo()"), hr);
        return hr;
    }

    return hr;
}

STDMETHODIMP 
CFaxDocument::get_Recipients (
    IFaxRecipients **ppFaxRecipients
)
/*++

Routine name : CFaxDocument::get_Recipients

Routine description:

    Return Recipients Collection

Author:

    Iv Garber (IvG),    Apr, 2000

Arguments:

    ppFaxRecipients               [out]    - The Recipients Collection

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;

    DBG_ENTER (_T("CFaxDocument::get_Recipients"), hr);

    if (::IsBadWritePtr(ppFaxRecipients, sizeof(IFaxRecipients *)))
    {
        //
        //  Got a bad return pointer
        //
        hr = E_POINTER;
        Error(IDS_ERROR_INVALID_ARGUMENT, IID_IFaxDocument, hr);
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr()"), hr);
        return hr;
    }

    if (!(m_Recipients))
    {
        //
        // Create collection on demand only once.
        //
        hr = CFaxRecipients::Create(&m_Recipients);
        if (FAILED(hr))
        {
            //
            //  Failure to create recipients collection
            //
            Error(IDS_ERROR_OPERATION_FAILED, IID_IFaxDocument, hr);
            CALL_FAIL(GENERAL_ERR, _T("CFaxRecipients::Create"), hr);
            return hr;
        }
    }

    hr = m_Recipients.CopyTo(ppFaxRecipients);
    if (FAILED(hr))
    {
        //
        //  Failed to copy Interface
        //
        Error(IDS_ERROR_OPERATION_FAILED, IID_IFaxDocument, hr);
        CALL_FAIL(GENERAL_ERR, _T("CComBSTR::CopyTo"), hr);
        return hr;
    }

    return hr;
}

//
//========================= PUT BSTR ATTRIBUTES ========================
//
STDMETHODIMP 
CFaxDocument::put_Body (
    BSTR bstrBody
)
/*++

Routine name : CFaxDocument::put_Body

Routine description:

    Set Body of the Document. Receives full path to the file to send through fax server.

Author:

    Iv Garber (IvG),    May, 2001

Arguments:

    bstrBody                 [in]    - the Body of the Document.

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;

    DBG_ENTER (_T("CFaxDocument::put_Body"), hr, _T("%s"), bstrBody);

    m_bstrBody = bstrBody;
    if (bstrBody && !m_bstrBody)
    {
        //
        //  not enough memory
        //
        hr = E_OUTOFMEMORY;
        Error(IDS_ERROR_OUTOFMEMORY, IID_IFaxDocument, hr);
        CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
        return hr;
    }

    return hr;
}

STDMETHODIMP 
CFaxDocument::put_CoverPage (
    BSTR bstrCoverPage
)
/*++

Routine name : CFaxDocument::put_CoverPage

Routine description:

    Set Cover Page

Author:

    Iv Garber (IvG),    Apr, 2000

Arguments:

    bstrCoverPage                 [in]    - new Cover Page value

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;

    DBG_ENTER (_T("CFaxDocument::put_CoverPage"), hr, _T("%s"), bstrCoverPage);

    m_bstrCoverPage = bstrCoverPage;
    if (bstrCoverPage && !m_bstrCoverPage)
    {
        //
        //  not enough memory
        //
        hr = E_OUTOFMEMORY;
        Error(IDS_ERROR_OUTOFMEMORY, IID_IFaxDocument, hr);
        CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
        return hr;
    }

    return hr;
}

STDMETHODIMP 
CFaxDocument::put_Subject ( 
    BSTR bstrSubject
)
/*++

Routine name : CFaxDocument::put_Subject

Routine description:

    Set Subject of the Fax Document

Author:

    Iv Garber (IvG),    Apr, 2000

Arguments:

    bstrSubject                   [in]    - The new Subject value

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;

    DBG_ENTER (_T("CFaxDocument::put_Subject"), hr, _T("%s"), bstrSubject);

    m_bstrSubject = bstrSubject;
    if (bstrSubject && !m_bstrSubject)
    {
        //
        //  not enough memory
        //
        hr = E_OUTOFMEMORY;
        Error(IDS_ERROR_OUTOFMEMORY, IID_IFaxDocument, hr);
        CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
        return hr;
    }

    return hr;
}

STDMETHODIMP 
CFaxDocument::put_Note (
    BSTR bstrNote
)
/*++

Routine name : CFaxDocument::put_Note

Routine description:

    Set Note for the Document

Author:

    Iv Garber (IvG),    Apr, 2000

Arguments:

    bstrNote                     [in]    - the new Note field

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;

    DBG_ENTER (_T("CFaxDocument::put_Note"), hr, _T("%s"), bstrNote);

    m_bstrNote = bstrNote;
    if (bstrNote && !m_bstrNote)
    {
        //
        //  not enough memory
        //
        hr = E_OUTOFMEMORY;
        Error(IDS_ERROR_OUTOFMEMORY, IID_IFaxDocument, hr);
        CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
        return hr;
    }

    return hr;
}

STDMETHODIMP 
CFaxDocument::put_DocumentName (
    BSTR bstrDocumentName
)
/*++

Routine name : CFaxDocument::put_DocumentName

Routine description:

    Set the Name of the Document

Author:

    Iv Garber (IvG),    Apr, 2000

Arguments:

    bstrDocumentName              [in]    - the new Name of the Document

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;

    DBG_ENTER (_T("CFaxDocument::put_DocumentName"), 
        hr, 
        _T("%s"),
        bstrDocumentName);

    m_bstrDocName = bstrDocumentName;
    if (bstrDocumentName && !m_bstrDocName)
    {
        //  
        //  not enough memory
        //
        hr = E_OUTOFMEMORY;
        Error(IDS_ERROR_OUTOFMEMORY, IID_IFaxDocument, hr);
        CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
        return hr;
    }

    return hr;
}

STDMETHODIMP 
CFaxDocument::put_ReceiptAddress (
    BSTR bstrReceiptAddress
)
/*++

Routine name : CFaxDocument::put_ReceiptAddress

Routine description:

    Set Receipt Address

Author:

    Iv Garber (IvG),    Apr, 2000

Arguments:

    bstrReceiptAddress            [in]    - the Receipt Address

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;

    DBG_ENTER (_T("CFaxDocument::put_ReceiptAddress"), 
        hr, 
        _T("%s"),
        bstrReceiptAddress);

    m_bstrReceiptAddress = bstrReceiptAddress;
    if (bstrReceiptAddress && !m_bstrReceiptAddress)
    {
        //  
        //  not enough memory
        //
        hr = E_OUTOFMEMORY;
        Error(IDS_ERROR_OUTOFMEMORY, IID_IFaxDocument, hr);
        CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
        return hr;
    }

    return hr;
}

//
//========================= GET BSTR ATTRIBUTES ========================
//
STDMETHODIMP 
CFaxDocument::get_Body (
    BSTR *pbstrBody
)
/*++

Routine name : CFaxDocument::get_Body

Routine description:

    Returns full path to the file containing the Body of the Document to send.

Author:

    Iv Garber (IvG),    May, 2001

Arguments:

    pbstrBody           [out]    - ptr to place to put the Body path 

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxDocument::get_Body"), hr);

    hr = GetBstr(pbstrBody, m_bstrBody);
    if (FAILED(hr))
    {
        Error(GetErrorMsgId(hr), IID_IFaxDocument, hr);
        return hr;
    }
    return hr;
}

STDMETHODIMP 
CFaxDocument::get_CoverPage (
    BSTR *pbstrCoverPage
)
/*++

Routine name : CFaxDocument::get_CoverPage

Routine description:

    Return Cover Page Path

Author:

    Iv Garber (IvG),    Apr, 2000

Arguments:

    pbstrCoverPage                [out]    - ptr to place to put the Cover Page Path

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxDocument::get_CoverPage"), hr);

    hr = GetBstr(pbstrCoverPage, m_bstrCoverPage);
    if (FAILED(hr))
    {
        Error(GetErrorMsgId(hr), IID_IFaxDocument, hr);
        return hr;
    }
    return hr;
}

STDMETHODIMP 
CFaxDocument::get_Subject (
    BSTR *pbstrSubject
)
/*++

Routine name : CFaxDocument::get_Subject

Routine description:

    Return Subject

Author:

    Iv Garber (IvG),    Apr, 2000

Arguments:

    pbstrSubject                  [out]    - The Document's Subject

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxDocument::get_Subject"), hr);

    hr = GetBstr(pbstrSubject, m_bstrSubject);
    if (FAILED(hr))
    {
        Error(GetErrorMsgId(hr), IID_IFaxDocument, hr);
        return hr;
    }
    return hr;
}

STDMETHODIMP 
CFaxDocument::get_Note(
    BSTR *pbstrNote
)
/*++

Routine name : CFaxDocument::get_Note

Routine description:

    Return Note field of the Cover Page

Author:

    Iv Garber (IvG),    Apr, 2000

Arguments:

    pbstrNote                    [out]    - the Note

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;

    DBG_ENTER (TEXT("CFaxDocument::get_Note"), hr);

    hr = GetBstr(pbstrNote, m_bstrNote);
    if (FAILED(hr))
    {
        Error(GetErrorMsgId(hr), IID_IFaxDocument, hr);
        return hr;
    }
    return hr;
}

STDMETHODIMP 
CFaxDocument::get_DocumentName(
    BSTR *pbstrDocumentName
)
/*++

Routine name : CFaxDocument::get_DocumentName

Routine description:

    Return Document Name

Author:

    Iv Garber (IvG),    Apr, 2000

Arguments:

    pbstrDocumentName             [out]    - Name of the Document

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxDocument::get_Document Name"), hr);

    hr = GetBstr(pbstrDocumentName, m_bstrDocName);
    if (FAILED(hr))
    {
        Error(GetErrorMsgId(hr), IID_IFaxDocument, hr);
        return hr;
    }
    return hr;
}

STDMETHODIMP 
CFaxDocument::get_ReceiptAddress(
    BSTR *pbstrReceiptAddress
)
/*++

Routine name : CFaxDocument::get_ReceiptAddress

Routine description:

    Return Receipt Address

Author:

    Iv Garber (IvG),    Apr, 2000

Arguments:

    pbstrReceiptAddress           [out]    - Receipt Address

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxDocument::get_ReceiptAddress"), hr);

    hr = GetBstr(pbstrReceiptAddress, m_bstrReceiptAddress);
    if (FAILED(hr))
    {
        Error(GetErrorMsgId(hr), IID_IFaxDocument, hr);
        return hr;
    }
    return hr;
}

//
//========================= GET & PUT OTHER ATTRIBUTES ========================
//
STDMETHODIMP 
CFaxDocument::get_ScheduleTime(
    DATE *pdateScheduleTime
)
/*++

Routine name : CFaxDocument::get_ScheduleTime

Routine description:

    Return Schedule Time

Author:

    Iv Garber (IvG),    Apr, 2000

Arguments:

    pdateScheduleTime             [out]    - the Schedule Time

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;

    DBG_ENTER (TEXT("CFaxDocument::get_ScheduleTime"), hr);

    //
    //  Check that we can write to the given pointer
    //
    if (::IsBadWritePtr(pdateScheduleTime, sizeof(DATE)))
    {
        //  
        //  Got Bad Ptr
        //  
        hr = E_POINTER;
        Error(IDS_ERROR_INVALID_ARGUMENT, IID_IFaxDocument, hr);
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr()"), hr);
        return hr;
    }

    *pdateScheduleTime = m_ScheduleTime;
    return hr;
}

STDMETHODIMP 
CFaxDocument::put_ScheduleTime(
    DATE dateScheduleTime
)
/*++

Routine name : CFaxDocument::put_ScheduleTime

Routine description:

    Return Schedule Time

Author:

    Iv Garber (IvG),    Apr, 2000

Arguments:

    dateScheduleTime              [in]    - the new Schedule Time

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;

    DBG_ENTER (_T("CFaxDocument::put_ScheduleTime"),
        hr, 
        _T("%f"), 
        dateScheduleTime);

    m_ScheduleTime = dateScheduleTime;
    return hr;
}

STDMETHODIMP 
CFaxDocument::get_CallHandle(
    long *plCallHandle
)
/*++

Routine name : CFaxDocument::get_CallHandle

Routine description:

    Return Call Handle

Author:

    Iv Garber (IvG),    Apr, 2000

Arguments:

    plCallHandle                  [out]    - Call Handle

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxDocument::get_CallHandle"), hr);

    hr = GetLong(plCallHandle, m_CallHandle);
    if (FAILED(hr))
    {
        Error(GetErrorMsgId(hr), IID_IFaxDocument, hr);
        return hr;
    }
    return hr;
}

STDMETHODIMP 
CFaxDocument::put_CallHandle(
    long lCallHandle
)
/*++

Routine name : CFaxDocument::put_CallHandle

Routine description:

    Set Call Handle

Author:

    Iv Garber (IvG),    Apr, 2000

Arguments:

    lCallHandle                   [in]    - Call Handle to Set

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (_T("CFaxDocument::put_CallHandle"), hr, _T("%ld"), lCallHandle);

    m_CallHandle = lCallHandle;
    return hr;
}

STDMETHODIMP 
CFaxDocument::get_CoverPageType(
    FAX_COVERPAGE_TYPE_ENUM *pCoverPageType
)
/*++

Routine name : CFaxDocument::get_CoverPageType

Routine description:

    Returns Type of the Cover Page used : whether it is Local or Server Cover Page,
        or the Cover Page is not used.

Author:

    Iv Garber (IvG),    Nov, 2000

Arguments:

    pCoverPageType          [out]    - ptr to the place to put the Cover Page Type

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxDocument::get_CoverPageType"), hr);

    //
    //  Check that we can write to the given pointer
    //
    if (::IsBadWritePtr(pCoverPageType, sizeof(FAX_COVERPAGE_TYPE_ENUM)))
    {
        //
        //  Got Bad Return Pointer
        //
        hr = E_POINTER;
        Error(IDS_ERROR_INVALID_ARGUMENT, IID_IFaxDocument, hr);
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr()"), hr);
        return hr;
    }

    *pCoverPageType = m_CoverPageType;
    return hr;
}

STDMETHODIMP 
CFaxDocument::put_CoverPageType(
    FAX_COVERPAGE_TYPE_ENUM CoverPageType
)
/*++

Routine name : CFaxDocument::put_CoverPageType

Routine description:

    Set Type of the Cover Page : either Local or Server or do not use Cover Page.

Author:

    Iv Garber (IvG),    Nov, 2000

Arguments:

    CoverPageType           [in]    - the new Value of the Type

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (_T("CFaxDocument::put_CoverPageType"), hr, _T("%ld"), CoverPageType);

    if (CoverPageType < fcptNONE || CoverPageType > fcptSERVER)
    {
        //
        //  Cover Page Type is wrong
        //
        hr = E_INVALIDARG;
        Error(IDS_ERROR_OUTOFRANGE, IID_IFaxDocument, hr);
        CALL_FAIL(GENERAL_ERR, _T("Cover Page Type is out of range"), hr);
        return hr;
    }

    m_CoverPageType = FAX_COVERPAGE_TYPE_ENUM(CoverPageType);
    return hr;
}

STDMETHODIMP 
CFaxDocument::get_ScheduleType(
    FAX_SCHEDULE_TYPE_ENUM *pScheduleType
)
/*++

Routine name : CFaxDocument::get_ScheduleType

Routine description:

    Return Schedule Type

Author:

    Iv Garber (IvG),    Apr, 2000

Arguments:

    pScheduleType                 [out]    - ptr to put the Current Schedule Type

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxDocument::get_ScheduleType"), hr);

    //
    //  Check that we can write to the given pointer
    //
    if (::IsBadWritePtr(pScheduleType, sizeof(FAX_SCHEDULE_TYPE_ENUM)))
    {
        //
        //  Got Bad Return Pointer
        //
        hr = E_POINTER;
        Error(IDS_ERROR_INVALID_ARGUMENT, IID_IFaxDocument, hr);
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr()"), hr);
        return hr;
    }

    *pScheduleType = m_ScheduleType;
    return hr;
}

STDMETHODIMP 
CFaxDocument::put_ScheduleType(
    FAX_SCHEDULE_TYPE_ENUM ScheduleType
)
/*++

Routine name : CFaxDocument::put_ScheduleType

Routine description:

    Set Schedule Type

Author:

    Iv Garber (IvG),    Apr, 2000

Arguments:

    ScheduleType                  [in]    - new Schedule Type

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (_T("CFaxDocument::put_ScheduleType"), hr, _T("Type=%d"), ScheduleType);

    if (ScheduleType < fstNOW || ScheduleType > fstDISCOUNT_PERIOD)
    {
        //
        //  Schedule Type is wrong
        //
        hr = E_INVALIDARG;
        Error(IDS_ERROR_OUTOFRANGE, IID_IFaxDocument, hr);
        CALL_FAIL(GENERAL_ERR, _T("Schedule Type is out of range"), hr);
        return hr;
    }

    m_ScheduleType = FAX_SCHEDULE_TYPE_ENUM(ScheduleType);
    return hr;
}

STDMETHODIMP 
CFaxDocument::get_ReceiptType(
    FAX_RECEIPT_TYPE_ENUM *pReceiptType
)
/*++

Routine name : CFaxDocument::get_ReceiptType

Routine description:

    Return Receipt Type

Author:

    Iv Garber (IvG),    Apr, 2000

Arguments:

    pReceiptType                  [out]    - ptr to put the Current Receipt Type

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxDocument::get_ReceiptType"), hr);

    //
    //  Check that we can write to the given pointer
    //
    if (::IsBadWritePtr(pReceiptType, sizeof(FAX_SCHEDULE_TYPE_ENUM)))
    {
        //  
        //  Got Bad Return Pointer
        //
        hr = E_POINTER;
        Error(IDS_ERROR_INVALID_ARGUMENT, IID_IFaxDocument, hr);
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr()"), hr);
        return hr;
    }

    *pReceiptType = m_ReceiptType;
    return hr;
}

STDMETHODIMP 
CFaxDocument::put_ReceiptType(
    FAX_RECEIPT_TYPE_ENUM ReceiptType
)
/*++

Routine name : CFaxDocument::put_ReceiptType

Routine description:

    Set Receipt Type

Author:

    Iv Garber (IvG),    Apr, 2000

Arguments:

    ReceiptType                   [in]    - new Receipt Type

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (_T("CFaxDocument::put_ReceiptType"), hr, _T("%d"), ReceiptType);

    if ((ReceiptType != frtNONE) && (ReceiptType != frtMSGBOX) && (ReceiptType != frtMAIL))
    {
        //  
        //  Out of range
        //
        hr = E_INVALIDARG;
        Error(IDS_ERROR_OUTOFRANGE, IID_IFaxDocument, hr);
        CALL_FAIL(GENERAL_ERR, _T("Receipt Type is out of range. It may be one of the values allowed by the Server."), hr);
        return hr;
    }

    m_ReceiptType = FAX_RECEIPT_TYPE_ENUM(ReceiptType);
    return hr;
}

STDMETHODIMP 
CFaxDocument::get_AttachFaxToReceipt(
    VARIANT_BOOL *pbAttachFax
)
/*++

Routine name : CFaxDocument::get_AttachFaxToReceipt

Routine description:

    Return Flag indicating whether or not Fax Service should Attach Fax To the Receipt

Author:

    Iv Garber (IvG),    Dec, 2000

Arguments:

    pbAttachFax         [out]    - the Current value of the Flag

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (_T("CFaxDocument::get_AttachFaxToReceipt"), hr);

    hr = GetVariantBool(pbAttachFax, m_bAttachFax);
    if (FAILED(hr))
    {
        Error(GetErrorMsgId(hr), IID_IFaxDocument, hr);
        return hr;
    }
    return hr;
}

STDMETHODIMP 
CFaxDocument::put_AttachFaxToReceipt(
    VARIANT_BOOL bAttachFax
)
/*++

Routine name : CFaxDocument::put_AttachFaxToReceipt

Routine description:

    Set whether Fax Server should attach the fax to the receipt

Author:

    Iv Garber (IvG),    Dec, 2000

Arguments:

    bAttachFax              [in]    - the new value of the Flag

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (_T("CFaxDocument::put_AttachFaxToReceipt"), hr, _T("%d"), bAttachFax);

    m_bAttachFax = bAttachFax;
    return hr;
}

STDMETHODIMP 
CFaxDocument::get_GroupBroadcastReceipts(
    VARIANT_BOOL *pbUseGrouping
)
/*++

Routine name : CFaxDocument::get_GroupBroadcastReceipts

Routine description:

    Return Flag indicating whether or not Broadcast Receipts are Grouped

Author:

    Iv Garber (IvG),    Apr, 2000

Arguments:

    pbUseGrouping                  [out]    - the Current value of the Flag

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (_T("CFaxDocument::get_GroupBroadcastReceipts"), hr);

    hr = GetVariantBool(pbUseGrouping, m_bUseGrouping);
    if (FAILED(hr))
    {
        Error(GetErrorMsgId(hr), IID_IFaxDocument, hr);
        return hr;
    }
    return hr;
}

STDMETHODIMP 
CFaxDocument::put_GroupBroadcastReceipts(
    VARIANT_BOOL bUseGrouping
)
/*++

Routine name : CFaxDocument::put_GroupBroadcastReceipts

Routine description:

    Set Group Broadcast Receipts Flag

Author:

    Iv Garber (IvG),    Apr, 2000

Arguments:

    bUseGrouping                   [in]    - the new value of the Flag

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (_T("CFaxDocument::put_GroupBroadcastReceipts"), hr, _T("%d"), bUseGrouping);

    m_bUseGrouping = bUseGrouping;
    return hr;
}

STDMETHODIMP 
CFaxDocument::get_Priority(
    FAX_PRIORITY_TYPE_ENUM *pPriority
)
/*++

Routine name : CFaxDocument::get_Priority

Routine description:

    Return Current Priority of the Document

Author:

    Iv Garber (IvG),    Apr, 2000

Arguments:

    pPriority                     [out]    - the Current Priority

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;

    DBG_ENTER (TEXT("CFaxDocument::get_Priority"), hr);

    //
    //  Check that we can write to the given pointer
    //
    if (::IsBadWritePtr(pPriority, sizeof(FAX_PRIORITY_TYPE_ENUM)))
    {
        //  
        //  Got Bad Return Pointer
        //
        hr = E_POINTER;
        Error(IDS_ERROR_INVALID_ARGUMENT, IID_IFaxDocument, hr);
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr()"), hr);
        return hr;
    }

    *pPriority = m_Priority;
    return hr;
}

STDMETHODIMP 
CFaxDocument::put_Priority(
    FAX_PRIORITY_TYPE_ENUM Priority
)
/*++

Routine name : CFaxDocument::put_Priority

Routine description:

    Set new Priority for the Document

Author:

    Iv Garber (IvG),    Apr, 2000

Arguments:

    Priority                      [in]    - the new Priority

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (_T("CFaxDocument::put_Priority"), hr, _T("%d"), Priority);

    if (Priority < fptLOW || Priority > fptHIGH)
    {
        //
        //  Out of the Range
        //
        hr = E_INVALIDARG;
        Error(IDS_ERROR_OUTOFRANGE, IID_IFaxDocument, hr);
        CALL_FAIL(GENERAL_ERR, _T("Priority is out of the Range"), hr);
        return hr;
    }

    m_Priority = FAX_PRIORITY_TYPE_ENUM(Priority);
    return hr;
}

STDMETHODIMP 
CFaxDocument::get_TapiConnection(
    IDispatch **ppTapiConnection
)
/*++

Routine name : CFaxDocument::get_TapiConnection

Routine description:

    Return Tapi Connection

Author:

    Iv Garber (IvG),    Apr, 2000

Arguments:

    ppTapiConnection              [out]    - the Tapi Connection Interface

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxDocument::get_TapiConnection"), hr);

    //
    //  Check that we can write to the given pointer
    //
    if (::IsBadWritePtr(ppTapiConnection, sizeof(IDispatch *)))
    {
        //
        //  Got Bad Return Pointer
        //
        hr = E_POINTER;
        Error(IDS_ERROR_INVALID_ARGUMENT, IID_IFaxDocument, hr);
        CALL_FAIL(GENERAL_ERR, _T("IsBadWritePtr()"), hr);
        return hr;
    }

    hr = m_TapiConnection.CopyTo(ppTapiConnection);
    if (FAILED(hr))
    {
        //  
        //  Failed to Copy Interface
        //
        Error(IDS_ERROR_OPERATION_FAILED, IID_IFaxDocument, hr);
        CALL_FAIL(GENERAL_ERR, _T("CComPtr<IDispatch>::CopyTo()"), hr);
        return hr;
    }

    return hr;
}

STDMETHODIMP 
CFaxDocument::putref_TapiConnection(
    IDispatch *pTapiConnection
)
{
    HRESULT     hr = S_OK;
    DBG_ENTER (_T("CFaxDocument::putref_TapiConnection"), hr, _T("%ld"), pTapiConnection);

    if (!pTapiConnection) 
    {
        //  
        //  Got NULL interface
        //  
        hr = E_POINTER;
        Error(IDS_ERROR_INVALID_ARGUMENT, IID_IFaxDocument, hr);
        CALL_FAIL(GENERAL_ERR, _T("!pTapiConnection"), hr);
        return hr;
    }

    m_TapiConnection = pTapiConnection;
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxdocument.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxDocument.h

Abstract:

	Declaration of the CFaxDocument class.

Author:

	Iv Garber (IvG)	Jun, 2000

Revision History:

--*/

#ifndef __FAXDOCUMENT_H_
#define __FAXDOCUMENT_H_

#include "resource.h"       // main symbols
#include "FaxRecipients.h"
#include "FaxServer.h"

//
//======================== FAX DOCUMENT ===========================================
//
class ATL_NO_VTABLE CFaxDocument : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CFaxDocument, &CLSID_FaxDocument>,
	public ISupportErrorInfo,
	public IDispatchImpl<IFaxDocument, &IID_IFaxDocument, &LIBID_FAXCOMEXLib>
{
public:
	CFaxDocument() :
	  m_Sender(this)
	{
        DBG_ENTER(_T("FAX DOCUMENT -- CREATE"));
    };

	~CFaxDocument()
	{
        DBG_ENTER(_T("FAX DOCUMENT -- DESTROY"));
    };

DECLARE_REGISTRY_RESOURCEID(IDR_FAXDOCUMENT)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxDocument)
	COM_INTERFACE_ENTRY(IFaxDocument)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

//  Interfaces
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

	STDMETHOD(Submit)(/*[in]*/ BSTR bstrFaxServerName, /*[out, retval]*/ VARIANT *pvFaxOutgoingJobIDs);
	STDMETHOD(ConnectedSubmit)(/*[in]*/ IFaxServer *pFaxServer, /*[out, retval]*/ VARIANT *pvFaxOutgoingJobIDs);

	STDMETHOD(put_Body)(/*[in]*/ BSTR bstrBody);
	STDMETHOD(get_Body)(/*[out, retval]*/ BSTR *pbstrBody);

	STDMETHOD(put_Note)(/*[in]*/ BSTR bstrNote);
	STDMETHOD(get_Note)(/*[out, retval]*/ BSTR *pbstrNote);

	STDMETHOD(put_Subject)(/*[in]*/ BSTR bstrSubject);
	STDMETHOD(get_Subject)(/*[out, retval]*/ BSTR *pbstrSubject);

	STDMETHOD(put_CallHandle)(/*[in]*/ long lCallHandle);
	STDMETHOD(get_CallHandle)(/*[out, retval]*/ long *plCallHandle);

	STDMETHOD(put_CoverPage)(/*[in]*/ BSTR bstrCoverPage);
	STDMETHOD(get_CoverPage)(/*[out, retval]*/ BSTR *pbstrCoverPage);

	STDMETHOD(put_ScheduleTime)(/*[in]*/ DATE dateScheduleTime);
	STDMETHOD(get_ScheduleTime)(/*[out, retval]*/ DATE *pdateScheduleTime);

	STDMETHOD(put_DocumentName)(/*[in]*/ BSTR bstrDocumentName);
	STDMETHOD(get_DocumentName)(/*[out, retval]*/ BSTR *pbstrDocumentName);

	STDMETHOD(put_ReceiptAddress)(/*[in]*/ BSTR bstrReceiptAddress);
	STDMETHOD(get_ReceiptAddress)(/*[out, retval]*/ BSTR *pbstrReceiptAddress);

	STDMETHOD(put_Priority)(/*[in]*/ FAX_PRIORITY_TYPE_ENUM Priority);
	STDMETHOD(get_Priority)(/*[out, retval]*/ FAX_PRIORITY_TYPE_ENUM *pPriority);

	STDMETHOD(put_AttachFaxToReceipt)(/*[in]*/ VARIANT_BOOL bAttachFax);
	STDMETHOD(get_AttachFaxToReceipt)(/*[out, retval]*/ VARIANT_BOOL *pbAttachFax);

	STDMETHOD(putref_TapiConnection)(/*[in]*/ IDispatch* pTapiConnection);
	STDMETHOD(get_TapiConnection)(/*[out, retval]*/ IDispatch **ppTapiConnection);

	STDMETHOD(put_ReceiptType)(/*[in]*/ FAX_RECEIPT_TYPE_ENUM ReceiptType);
	STDMETHOD(get_ReceiptType)(/*[out, retval]*/ FAX_RECEIPT_TYPE_ENUM *pReceiptType);

	STDMETHOD(put_GroupBroadcastReceipts)(/*[in]*/ VARIANT_BOOL bUseGrouping);
	STDMETHOD(get_GroupBroadcastReceipts)(/*[out, retval]*/ VARIANT_BOOL *pbUseGrouping);

	STDMETHOD(put_ScheduleType)(/*[in]*/ FAX_SCHEDULE_TYPE_ENUM ScheduleType);
	STDMETHOD(get_ScheduleType)(/*[out, retval]*/ FAX_SCHEDULE_TYPE_ENUM *pScheduleType);

	STDMETHOD(put_CoverPageType)(/*[in]*/ FAX_COVERPAGE_TYPE_ENUM CoverPageType);
	STDMETHOD(get_CoverPageType)(/*[out, retval]*/ FAX_COVERPAGE_TYPE_ENUM *pCoverPageType);

	STDMETHOD(get_Recipients)(/*[out, retval]*/ IFaxRecipients **ppFaxRecipients);
	STDMETHOD(get_Sender)(/*[out, retval]*/ IFaxSender **ppFaxSender);

	HRESULT FinalConstruct();

private:
	CComPtr<IFaxRecipients> m_Recipients;
	CComPtr<IDispatch>		m_TapiConnection;
	FAX_SCHEDULE_TYPE_ENUM	m_ScheduleType;
	FAX_RECEIPT_TYPE_ENUM	m_ReceiptType;
	FAX_PRIORITY_TYPE_ENUM	m_Priority;
	FAX_COVERPAGE_TYPE_ENUM m_CoverPageType;
	CComBSTR                m_bstrBody;
	CComBSTR				m_bstrCoverPage;
	CComBSTR				m_bstrSubject;
	CComBSTR				m_bstrNote;
	CComBSTR				m_bstrDocName;
	CComBSTR				m_bstrReceiptAddress;
	DATE					m_ScheduleTime;
	long					m_CallHandle;
	VARIANT_BOOL			m_bUseGrouping;
	VARIANT_BOOL			m_bAttachFax;

	CComContainedObject2<CFaxSender>  m_Sender;
};

#endif //__FAXDOCUMENT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxeventlogging.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxEventLogging.h

Abstract:

	Declaration of the CFaxEventLogging Class.

Author:

	Iv Garber (IvG)	Jun, 2000

Revision History:

--*/

#ifndef __FAXEVENTLOGGING_H_
#define __FAXEVENTLOGGING_H_

#include "resource.h"       // main symbols
#include "FaxCommon.h"

//
//========================= EVENT LOGGING ======================================
//
class ATL_NO_VTABLE CFaxEventLogging : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public ISupportErrorInfo,
	public IDispatchImpl<IFaxEventLogging, &IID_IFaxEventLogging, &LIBID_FAXCOMEXLib>,
    public CFaxInitInner
{
public:
    CFaxEventLogging() : CFaxInitInner(_T("FAX EVENT LOGGING")),
        m_bInited(false),
        m_InitLevel(fllNONE),
        m_OutboundLevel(fllNONE),
        m_InboundLevel(fllNONE),
        m_GeneralLevel(fllNONE)
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_FAXEVENTLOGGING)
DECLARE_NOT_AGGREGATABLE(CFaxEventLogging)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxEventLogging)
	COM_INTERFACE_ENTRY(IFaxEventLogging)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY(IFaxInitInner)
END_COM_MAP()

//  Interfaces
    STDMETHOD(Save)();
    STDMETHOD(Refresh)();

	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

    STDMETHOD(put_InitEventsLevel)(/*[out, retval]*/ FAX_LOG_LEVEL_ENUM InitEventLevel);
    STDMETHOD(get_InitEventsLevel)(/*[out, retval]*/ FAX_LOG_LEVEL_ENUM *pInitEventLevel);
    STDMETHOD(put_InboundEventsLevel)(/*[out, retval]*/ FAX_LOG_LEVEL_ENUM InboundEventLevel);
    STDMETHOD(put_GeneralEventsLevel)(/*[out, retval]*/ FAX_LOG_LEVEL_ENUM GeneralEventsLevel);
    STDMETHOD(get_InboundEventsLevel)(/*[out, retval]*/ FAX_LOG_LEVEL_ENUM *pInboundEventLevel);
    STDMETHOD(put_OutboundEventsLevel)(/*[out, retval]*/ FAX_LOG_LEVEL_ENUM OutboundEventsLevel);
    STDMETHOD(get_GeneralEventsLevel)(/*[out, retval]*/ FAX_LOG_LEVEL_ENUM *pGeneralEventsLevel);
    STDMETHOD(get_OutboundEventsLevel)(/*[out, retval]*/ FAX_LOG_LEVEL_ENUM *pOutboundEventsLevel);

private:
    bool                m_bInited;
    FAX_LOG_LEVEL_ENUM  m_InitLevel;
    FAX_LOG_LEVEL_ENUM  m_OutboundLevel;
    FAX_LOG_LEVEL_ENUM  m_InboundLevel;
    FAX_LOG_LEVEL_ENUM  m_GeneralLevel;
    CComBSTR            m_bstrInitName;
    CComBSTR            m_bstrOutboundName;
    CComBSTR            m_bstrInboundName;
    CComBSTR            m_bstrGeneralName;

    STDMETHOD(GetLevel)(FAX_ENUM_LOG_CATEGORIES faxCategory, FAX_LOG_LEVEL_ENUM *faxLevel);
    STDMETHOD(PutLevel)(FAX_ENUM_LOG_CATEGORIES faxCategory, FAX_LOG_LEVEL_ENUM faxLevel);
};

#endif //__FAXEVENTLOGGING_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxeventlogging.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxEventLogging.cpp

Abstract:

	Implementation of Event Logging Class.

Author:

	Iv Garber (IvG)	Jun, 2000

Revision History:

--*/

#include "stdafx.h"
#include "FaxComEx.h"
#include "FaxEventLogging.h"

//
//================= PUT LEVEL =======================================
//
STDMETHODIMP
CFaxEventLogging::PutLevel(
    FAX_ENUM_LOG_CATEGORIES faxCategory,
    FAX_LOG_LEVEL_ENUM faxLevel
)
/*++

Routine name : CFaxEventLogging::PutLevel

Routine description:

	Set the Level of given Category.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	faxCategory                   [in]    - the Category for which level is desired.
	faxLevel                      [in]    - the result : level of the given category

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;

    DBG_ENTER(_T("CFaxEventLogging::PutLevel"), hr, _T("Category : %d"), faxCategory);

    //
    //  check the range
    //
    if (faxLevel > fllMAX || faxLevel < fllNONE)
    {
		//
		//	Out of range
		//
		hr = E_INVALIDARG;
		AtlReportError(CLSID_FaxEventLogging,
            IDS_ERROR_OUTOFRANGE, 
            IID_IFaxEventLogging, 
            hr,
            _Module.GetResourceInstance());
		CALL_FAIL(GENERAL_ERR, _T("Level is out of range"), hr);
		return hr;
    }

    //
    //  Sync with the Server for the first time
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    switch(faxCategory)
    {
    case FAXLOG_CATEGORY_INIT:
        m_InitLevel = faxLevel;
        break;
    case FAXLOG_CATEGORY_OUTBOUND:
        m_OutboundLevel = faxLevel;
        break;
    case FAXLOG_CATEGORY_INBOUND:
        m_InboundLevel = faxLevel;
        break;
    default:
        m_GeneralLevel = faxLevel;
        break;
    }

    return hr;
}

//
//================= GET LEVEL =======================================
//
STDMETHODIMP
CFaxEventLogging::GetLevel(
    FAX_ENUM_LOG_CATEGORIES faxCategory,
    FAX_LOG_LEVEL_ENUM     *pLevel
)
/*++

Routine name : CFaxEventLogging::GetLevel

Routine description:

	Return current Level of given Category.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	faxCategory                   [in]    - the Category for which level is desired.
	pLevel                        [out]    - the result : level of the given category

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;

    DBG_ENTER(_T("CFaxEventLogging::GetLevel"), hr, _T("Category : %d"), faxCategory);

    //
    //  Check that we have a good pointer 
    //
    if (::IsBadWritePtr(pLevel, sizeof(FAX_LOG_LEVEL_ENUM)))
    {
		//
		//	Got Bad Return Pointer
		//
		hr = E_POINTER;
		AtlReportError(CLSID_FaxEventLogging, 
            IDS_ERROR_INVALID_ARGUMENT, 
            IID_IFaxEventLogging, 
            hr, 
            _Module.GetResourceInstance());
		CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr(pLevel, sizeof(FAX_LOG_LEVEL_ENUM))"), hr);
		return hr;
	}

    //
    //  Sync with the Server for the first time
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    switch(faxCategory)
    {
    case FAXLOG_CATEGORY_INIT:
        *pLevel = m_InitLevel;
        break;
    case FAXLOG_CATEGORY_OUTBOUND:
        *pLevel = m_OutboundLevel;
        break;
    case FAXLOG_CATEGORY_INBOUND:
        *pLevel = m_InboundLevel;
        break;
    default:
        *pLevel = m_GeneralLevel;
        break;
    }

    return hr;
}

//
//====================== PUT INIT EVENTS LEVEL ======================================
//
STDMETHODIMP
CFaxEventLogging::put_InitEventsLevel(
    /*[out, retval]*/ FAX_LOG_LEVEL_ENUM InitEventLevel
)
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxEventLogging::put_InitEventsLogging"), hr, _T("Level=%d"), InitEventLevel);
    hr = PutLevel(FAXLOG_CATEGORY_INIT, InitEventLevel);
    return hr;
}
    
//
//====================== PUT INBOUND EVENTS LEVEL ======================================
//
STDMETHODIMP
CFaxEventLogging::put_InboundEventsLevel(
    /*[out, retval]*/ FAX_LOG_LEVEL_ENUM InboundEventLevel
)
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxEventLogging::put_InboundEventsLogging"), hr, _T("Level=%d"), InboundEventLevel);
    hr = PutLevel(FAXLOG_CATEGORY_INBOUND, InboundEventLevel);
    return hr;
}

//
//====================== PUT OUTBOUND EVENTS LEVEL ======================================
//
STDMETHODIMP
CFaxEventLogging::put_OutboundEventsLevel(
    /*[out, retval]*/ FAX_LOG_LEVEL_ENUM OutboundEventLevel
)
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxEventLogging::put_OutboundEventsLogging"), hr, _T("Level=%d"), OutboundEventLevel);
    hr = PutLevel(FAXLOG_CATEGORY_OUTBOUND, OutboundEventLevel);
    return hr;
}

//
//====================== PUT GENERAL EVENTS LEVEL ======================================
//
STDMETHODIMP
CFaxEventLogging::put_GeneralEventsLevel(
    /*[out, retval]*/ FAX_LOG_LEVEL_ENUM GeneralEventLevel
)
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxEventLogging::put_GeneralEventsLogging"), hr, _T("Level=%d"), GeneralEventLevel);
    hr = PutLevel(FAXLOG_CATEGORY_UNKNOWN, GeneralEventLevel);
    return hr;
}

//
//====================== GET_INIT EVENTS LEVEL ======================================
//
STDMETHODIMP
CFaxEventLogging::get_InitEventsLevel(
    /*[out, retval]*/ FAX_LOG_LEVEL_ENUM *pInitEventLevel
)
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxEventLogging::get_InitEventsLogging"), hr);
    hr = GetLevel(FAXLOG_CATEGORY_INIT, pInitEventLevel);
    return hr;
}
    
//
//====================== GET INBOUND EVENTS LEVEL ======================================
//
STDMETHODIMP
CFaxEventLogging::get_InboundEventsLevel(
    /*[out, retval]*/ FAX_LOG_LEVEL_ENUM *pInboundEventLevel
)
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxEventLogging::get_InboundEventsLogging"), hr);
    hr = GetLevel(FAXLOG_CATEGORY_INBOUND, pInboundEventLevel);
    return hr;
}

//
//====================== GET OUTBOUND EVENTS LEVEL ======================================
//
STDMETHODIMP
CFaxEventLogging::get_OutboundEventsLevel(
    /*[out, retval]*/ FAX_LOG_LEVEL_ENUM *pOutboundEventLevel
)
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxEventLogging::get_OutboundEventsLogging"), hr);
    hr = GetLevel(FAXLOG_CATEGORY_OUTBOUND, pOutboundEventLevel);
    return hr;
}

//
//====================== GET GENERAL EVENTS LEVEL ======================================
//
STDMETHODIMP
CFaxEventLogging::get_GeneralEventsLevel(
    /*[out, retval]*/ FAX_LOG_LEVEL_ENUM *pGeneralEventLevel
)
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxEventLogging::get_GeneralEventsLogging"), hr);
    hr = GetLevel(FAXLOG_CATEGORY_UNKNOWN, pGeneralEventLevel);
    return hr;
}

//
//================== SAVE ===============================================================
//
STDMETHODIMP 
CFaxEventLogging::Save()
/*++

Routine name : CFaxEventLogging::Save

Routine description:

	Save the Object's contents : bring its current logging categories settings to the Server.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:


Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;

    DBG_ENTER(_T("CFaxEventLogging::Save"), hr);

    if (!m_bInited)
    {
        //
        //  No changes
        //
        return hr;
    }

    //
    //  Get Fax Server Handle
    //
    HANDLE  hFaxHandle = NULL;
    hr = GetFaxHandle(&hFaxHandle);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxEventLogging, 
            GetErrorMsgId(hr), 
            IID_IFaxEventLogging, 
            hr, 
            _Module.GetResourceInstance());
        return hr;
    }

    DWORD   dwNum = 4;
    FAX_LOG_CATEGORY    faxCategories[4];

    faxCategories[0].Category = FAXLOG_CATEGORY_INIT;
    faxCategories[0].Name = m_bstrInitName;
    faxCategories[0].Level = FAX_ENUM_LOG_LEVELS(m_InitLevel);
    faxCategories[1].Category = FAXLOG_CATEGORY_INBOUND;
    faxCategories[1].Name = m_bstrInboundName;
    faxCategories[1].Level = FAX_ENUM_LOG_LEVELS(m_InboundLevel);
    faxCategories[2].Category = FAXLOG_CATEGORY_OUTBOUND;
    faxCategories[2].Name = m_bstrOutboundName;
    faxCategories[2].Level = FAX_ENUM_LOG_LEVELS(m_OutboundLevel);
    faxCategories[3].Category = FAXLOG_CATEGORY_UNKNOWN;
    faxCategories[3].Name = m_bstrGeneralName;
    faxCategories[3].Level = FAX_ENUM_LOG_LEVELS(m_GeneralLevel);

    //
    //  Store out setting at the Server 
    //
    if (!FaxSetLoggingCategories(hFaxHandle, faxCategories, dwNum))
    {
        //
        //  Failed to put the Logging Categories to the Server
        //
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        AtlReportError(CLSID_FaxEventLogging, 
            GetErrorMsgId(hr), 
            IID_IFaxEventLogging, 
            hr, 
            _Module.GetResourceInstance());
        CALL_FAIL(GENERAL_ERR, _T("FaxSetLoggingCategories(hFaxHandle, faxCategories, dwNum)"), hr);
        return hr;
    }

    return hr;
}

//
//================== REFRESH ===========================================
//
STDMETHODIMP 
CFaxEventLogging::Refresh()
/*++

Routine name : CFaxEventLogging::Refresh

Routine description:

	Refresh the Object's contents : bring new logging categories settings from the Server.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:


Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;

    DBG_ENTER(_T("CFaxEventLogging::Refresh"), hr);

    //
    //  Get Fax Server Handle
    //
    HANDLE  hFaxHandle = NULL;
    hr = GetFaxHandle(&hFaxHandle);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxEventLogging, 
            GetErrorMsgId(hr), 
            IID_IFaxEventLogging, 
            hr, 
            _Module.GetResourceInstance());
        return hr;
    }

    //
    //  Ask the Server for the Logging Settings
    //
    DWORD   dwNum;
    CFaxPtr<FAX_LOG_CATEGORY>   pLogCategory;
    if (!FaxGetLoggingCategories(hFaxHandle, &pLogCategory, &dwNum))
    {
        //
        //  Failed to get the Logging Categories from the Server
        //
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        AtlReportError(CLSID_FaxEventLogging, 
            GetErrorMsgId(hr), 
            IID_IFaxEventLogging, 
            hr, 
            _Module.GetResourceInstance());
        CALL_FAIL(GENERAL_ERR, _T("FaxGetLoggingCategories(hFaxHandle, &pLogCategory, &dwNum)"), hr);
        return hr;
    }

    //
    //  must be 4 categories
    //
    ATLASSERT(dwNum == 4);

    for (DWORD i=0; i<dwNum; i++)
    {
        switch(pLogCategory[i].Category)
        {
        case FAXLOG_CATEGORY_INIT:
            m_bstrInitName = pLogCategory[i].Name;
            m_InitLevel = FAX_LOG_LEVEL_ENUM(pLogCategory[i].Level);
            break;
        case FAXLOG_CATEGORY_OUTBOUND:
            m_bstrOutboundName = pLogCategory[i].Name;
            m_OutboundLevel = FAX_LOG_LEVEL_ENUM(pLogCategory[i].Level);
            break;
        case FAXLOG_CATEGORY_INBOUND:
            m_bstrInboundName = pLogCategory[i].Name;
            m_InboundLevel = FAX_LOG_LEVEL_ENUM(pLogCategory[i].Level);
            break;
        case FAXLOG_CATEGORY_UNKNOWN:
            m_bstrGeneralName = pLogCategory[i].Name;
            m_GeneralLevel = FAX_LOG_LEVEL_ENUM(pLogCategory[i].Level);
            break;
        default:
            // 
            //  ASSERT(FALSE)
            //
            ATLASSERT(pLogCategory[i].Category == FAXLOG_CATEGORY_INIT);
            break;
        }
    }

    m_bInited = true;
    return hr;
}

//
//================== SUPPORT ERROR INFO =====================================
//
STDMETHODIMP 
CFaxEventLogging::InterfaceSupportsErrorInfo(
    REFIID riid
)
/*++

Routine name : CFaxEventLogging::InterfaceSupportsErrorInfo

Routine description:

	ATL's implementation of Support Error Info.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	riid                          [in]    - Reference to the IID

Return Value:

    Standard HRESULT code

--*/
{
	static const IID* arr[] = 
	{
		&IID_IFaxEventLogging
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxfolders.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxFolders.cpp

Abstract:

	Implementation of CFaxFolders

Author:

	Iv Garber (IvG)	Apr, 2000

Revision History:

--*/

#include "stdafx.h"
#include "FaxComEx.h"
#include "FaxFolders.h"


//
//==================== INTERFACE SUPPORT ERROR INFO =====================
//
STDMETHODIMP 
CFaxFolders::InterfaceSupportsErrorInfo(
	REFIID riid
)
/*++

Routine name : CFaxFolders::InterfaceSupportsErrorInfo

Routine description:

	ATL's implementation of Interface Support Error Info

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	riid                          [in]    - Reference of the Interface

Return Value:

    Standard HRESULT code

--*/
{
	static const IID* arr[] = 
	{
		&IID_IFaxFolders
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}	//	CFaxFolders::InterfaceSupportErrorInfo

//
//==================== GET OUTGOING QUEUE ====================================
//
STDMETHODIMP 
CFaxFolders::get_OutgoingQueue(
	IFaxOutgoingQueue **ppOutgoingQueue
)
/*++

Routine name : CFaxFolders::get_OutgoingQueue

Routine description:

	Return OutgoingQueue 

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	ppOutgoingQueue                          [out]    - ptr to put the IOutgoingQueue Ifc

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT				hr = S_OK;
	DBG_ENTER (_T("CFaxFolders::get_OutgoingQueue"), hr);

    CObjectHandler<CFaxOutgoingQueue, IFaxOutgoingQueue>    ObjectCreator;
    hr = ObjectCreator.GetContainedObject(ppOutgoingQueue, &m_pOutgoingQueue, m_pIFaxServerInner);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxFolders, 
			GetErrorMsgId(hr), 
			IID_IFaxFolders, 
			hr, 
			_Module.GetResourceInstance());
        return hr;
    }
    return hr;
}	//	CFaxFolders::get_OutgoingQueue()

//
//==================== GET INCOMING ARCHIVE ====================================
//
STDMETHODIMP 
CFaxFolders::get_IncomingArchive(
	IFaxIncomingArchive **ppIncomingArchive
)
/*++

Routine name : CFaxFolders::get_IncomingArchive

Routine description:

	Return Incoming Archive

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pIncomingArchive                          [out]    - The ptr to the place to put IncomingArchive

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxFolders::get_IncomingArchive"), hr);

    CObjectHandler<CFaxIncomingArchive, IFaxIncomingArchive>    ObjectCreator;
    hr = ObjectCreator.GetContainedObject(ppIncomingArchive, &m_pIncomingArchive, m_pIFaxServerInner);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxFolders, 
			GetErrorMsgId(hr), 
			IID_IFaxFolders, 
			hr, 
			_Module.GetResourceInstance());
        return hr;
    }
    return hr;
}	//	CFaxFolders::get_IncomingArchive()

//
//==================== GET INCOMING QUEUE ====================================
//
STDMETHODIMP 
CFaxFolders::get_IncomingQueue(
	IFaxIncomingQueue **ppIncomingQueue
)
/*++
Routine name : CFaxFolders::get_IncomingQueue

Routine description:

	Return Incoming Queue

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pIncomingQueue                         [out]    - The Incoming Queue

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxFolders::get_IncomingQueue"), hr);

	CObjectHandler<CFaxIncomingQueue, IFaxIncomingQueue>    ObjectCreator;
    hr = ObjectCreator.GetContainedObject(ppIncomingQueue, &m_pIncomingQueue, m_pIFaxServerInner);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxFolders, 
			GetErrorMsgId(hr), 
			IID_IFaxFolders, 
			hr, 
			_Module.GetResourceInstance());
        return hr;
    }
    return hr;
}	//	CFaxFolders::get_IncomingQueue()

//
//==================== GET OUTGOING ARCHIVE ====================================
//
STDMETHODIMP 
CFaxFolders::get_OutgoingArchive(
	IFaxOutgoingArchive **ppOutgoingArchive
)
/*++

Routine name : CFaxFolders::get_OutgoingArchive

Routine description:

	Return Outgoing Archive Object

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pOutgoingArchive                          [out]    - The ptr to put Outgoing Archive Object

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxFolders::get_OutgoingArchive"), hr);

	CObjectHandler<CFaxOutgoingArchive, IFaxOutgoingArchive>    ObjectCreator;
    hr = ObjectCreator.GetContainedObject(ppOutgoingArchive, &m_pOutgoingArchive, m_pIFaxServerInner);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxFolders, 
			GetErrorMsgId(hr), 
			IID_IFaxFolders, 
			hr, 
			_Module.GetResourceInstance());
        return hr;
    }
    return hr;
}	//	CFaxFolders::get_OutgoingArchive()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxinboundrouting.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxInboundRouting.h

Abstract:

	Declaration of the CFaxInboundRouting Class.

Author:

	Iv Garber (IvG)	Jun, 2000

Revision History:

--*/

#ifndef __FAXINBOUNDROUTING_H_
#define __FAXINBOUNDROUTING_H_

#include "resource.h"       // main symbols
#include "FaxCommon.h"
#include "FaxInboundRoutingExtensions.h"
#include "FaxInboundRoutingMethods.h"

//
// ================ INBOUND ROUTING ==================================================
//  Both IRExtensions and IRMethods Collections are not cached.
//  Rather they are created each time the InboundRouting is asked for them.
//  To be sure that the Server Object is up during their lifetime, they do 
//      AddRef() on the Server Ojbect at their Init() function.
//
class ATL_NO_VTABLE CFaxInboundRouting : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public ISupportErrorInfo,
	public IDispatchImpl<IFaxInboundRouting, &IID_IFaxInboundRouting, &LIBID_FAXCOMEXLib>,
    public CFaxInitInner
{
public:
    CFaxInboundRouting() : CFaxInitInner(_T("FAX INBOUND ROUTING"))
	{}

DECLARE_REGISTRY_RESOURCEID(IDR_FAXINBOUNDROUTING)
DECLARE_NOT_AGGREGATABLE(CFaxInboundRouting)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxInboundRouting)
	COM_INTERFACE_ENTRY(IFaxInboundRouting)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

//  Interfaces
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

    STDMETHOD(GetExtensions)(/*[out, retval]*/ IFaxInboundRoutingExtensions **ppExtensions);
    STDMETHOD(GetMethods)(/*[out, retval]*/ IFaxInboundRoutingMethods **ppMethods);
};

#endif //__FAXINBOUNDROUTING_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxfolders.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxFolders.h

Abstract:

	Declaration of the CFaxFolders Class.

Author:

	Iv Garber (IvG)	Jun, 2000

Revision History:

--*/


#ifndef __FAXFOLDERS_H_
#define __FAXFOLDERS_H_

#include "resource.h"       // main symbols
#include "FaxCommon.h"
#include "FaxOutgoingQueue.h"
#include "FaxIncomingArchive.h"
#include "FaxIncomingQueue.h"
#include "FaxOutgoingArchive.h"


//
//===================== FAX FOLDERS ========================================
//
class ATL_NO_VTABLE CFaxFolders : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public ISupportErrorInfo,
	public IDispatchImpl<IFaxFolders, &IID_IFaxFolders, &LIBID_FAXCOMEXLib>,
	public CFaxInitInner
{
public:
    CFaxFolders() : CFaxInitInner(_T("FAX FOLDERS")),
        m_pOutgoingQueue(NULL),
        m_pIncomingQueue(NULL),
        m_pIncomingArchive(NULL),
        m_pOutgoingArchive(NULL)
	{}
    ~CFaxFolders()
    {
        //
        //  free all the allocated objects
        //
        if (m_pOutgoingQueue) 
        {
            delete m_pOutgoingQueue;
        }

        if (m_pIncomingQueue) 
        {
            delete m_pIncomingQueue;
        }

        if (m_pOutgoingArchive) 
        {
            delete m_pOutgoingArchive;
        }

        if (m_pIncomingArchive) 
        {
            delete m_pIncomingArchive;
        }
    }


DECLARE_REGISTRY_RESOURCEID(IDR_FAXFOLDERS)
DECLARE_NOT_AGGREGATABLE(CFaxFolders)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxFolders)
	COM_INTERFACE_ENTRY(IFaxFolders)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY(IFaxInitInner)
END_COM_MAP()

// Interfaces 
STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

STDMETHOD(get_OutgoingQueue)(/*[out, retval]*/ IFaxOutgoingQueue **pOutgoingQueue);
STDMETHOD(get_IncomingQueue)(/*[out, retval]*/ IFaxIncomingQueue **pIncomingQueue);
STDMETHOD(get_IncomingArchive)(/*[out, retval]*/ IFaxIncomingArchive **pIncomingArchive);
STDMETHOD(get_OutgoingArchive)(/*[out, retval]*/ IFaxOutgoingArchive **pOutgoingArchive);

private:
	CComContainedObject2<CFaxOutgoingQueue>      *m_pOutgoingQueue;
	CComContainedObject2<CFaxIncomingArchive>    *m_pIncomingArchive;
	CComContainedObject2<CFaxIncomingQueue>      *m_pIncomingQueue;
	CComContainedObject2<CFaxOutgoingArchive>    *m_pOutgoingArchive;
};

#endif //__FAXFOLDERS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxinboundrouting.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxInboundRouting.cpp

Abstract:

	Implementation of CFaxInboundRouting Class.

Author:

	Iv Garber (IvG)	Jun, 2000

Revision History:

--*/

#include "stdafx.h"
#include "FaxComEx.h"
#include "FaxInboundRouting.h"

//
//================== GET METHODS COLLECTION OBJECT ==============================
//
STDMETHODIMP 
CFaxInboundRouting::GetMethods(
    IFaxInboundRoutingMethods **ppMethods
)
/*++

Routine name : CFaxInboundRouting::GetMethods

Routine description:

	Return Methods Collection Object

Author:

	Iv Garber (IvG),	June, 2000

Arguments:

	ppMethods            [out]    - Ptr to the Place for Methods Collection Object 

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT				hr = S_OK;
	DBG_ENTER (_T("CFaxInboundRouting::GetMethods"), hr);

    CObjectHandler<CFaxInboundRoutingMethods, IFaxInboundRoutingMethods>    ObjectCreator;
    hr = ObjectCreator.GetObject(ppMethods, m_pIFaxServerInner);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxInboundRouting, GetErrorMsgId(hr), IID_IFaxInboundRouting, hr, _Module.GetResourceInstance());
        return hr;
    }
    return hr;
}

//
//================== GET EXTENSIONS COLLECTION OBJECT ==============================
//
STDMETHODIMP 
CFaxInboundRouting::GetExtensions(
    IFaxInboundRoutingExtensions **ppExtensions
)
/*++

Routine name : CFaxInboundRouting::GetExtensions

Routine description:

	Return Extensions Collection Object

Author:

	Iv Garber (IvG),	June, 2000

Arguments:

	ppExtensions            [out]    - Ptr to the Place for Extensions Collection Object 

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT				hr = S_OK;
	DBG_ENTER (_T("CFaxInboundRouting::GetExtensions"), hr);

    CObjectHandler<CFaxInboundRoutingExtensions, IFaxInboundRoutingExtensions>    ObjectCreator;
    hr = ObjectCreator.GetObject(ppExtensions, m_pIFaxServerInner);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxInboundRouting, GetErrorMsgId(hr), IID_IFaxInboundRouting, hr, _Module.GetResourceInstance());
        return hr;
    }
    return hr;
}

//
//===================== SUPPORT ERROR INFO ======================================
//
STDMETHODIMP 
CFaxInboundRouting::InterfaceSupportsErrorInfo(
    REFIID riid
)
/*++

Routine name : CFaxInboundRouting::InterfaceSupportsErrorInfo

Routine description:

	ATL's implementation of Support Error Info.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	riid                          [in]    - reference to the Interface.

Return Value:

    Standard HRESULT code

--*/
{
	static const IID* arr[] = 
	{
		&IID_IFaxInboundRouting
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxinboundroutingextension.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxInboundRoutingExtension.h

Abstract:

	Declaration of the CFaxInboundRoutingExtension class.

Author:

	Iv Garber (IvG)	Jul, 2000

Revision History:

--*/

#ifndef __FAXINBOUNDROUTINGEXTENSION_H_
#define __FAXINBOUNDROUTINGEXTENSION_H_

#include "resource.h"       // main symbols
#include "FaxLocalPtr.h"

//
//================== FAX INBOUND ROUTING EXTENSION ==========================================
//  This is a READ-ONLY object. At its Init it gots all its data. It never uses FaxServer.
//
class ATL_NO_VTABLE CFaxInboundRoutingExtension : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public ISupportErrorInfo,
	public IDispatchImpl<IFaxInboundRoutingExtension, &IID_IFaxInboundRoutingExtension, &LIBID_FAXCOMEXLib>,
    public CFaxInitInner    //  for Debug purposes only
{
public:
    CFaxInboundRoutingExtension() : CFaxInitInner(_T("FAX INBOUND ROUTING EXTENSION")),
        m_psaMethods(NULL)
	{}

    ~CFaxInboundRoutingExtension()
    {
        HRESULT     hr = S_OK;
        if (m_psaMethods)
        {
            hr = SafeArrayDestroy(m_psaMethods);
            if (FAILED(hr))
            {
                DBG_ENTER(_T("CFaxInboundRoutingExtension::Dtor"));
                CALL_FAIL(GENERAL_ERR, _T("SafeArrayDestroy(m_psaMethods)"), hr);
            }
        }
    }


DECLARE_REGISTRY_RESOURCEID(IDR_FAXINBOUNDROUTINGEXTENSION)
DECLARE_NOT_AGGREGATABLE(CFaxInboundRoutingExtension)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxInboundRoutingExtension)
	COM_INTERFACE_ENTRY(IFaxInboundRoutingExtension)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

//  Interfaces
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

    STDMETHOD(get_Debug)(/*[out, retval]*/ VARIANT_BOOL *pbDebug);
    STDMETHOD(get_MajorBuild)(/*[out, retval]*/ long *plMajorBuild);
    STDMETHOD(get_MinorBuild)(/*[out, retval]*/ long *plMinorBuild);
    STDMETHOD(get_ImageName)(/*[out, retval]*/ BSTR *pbstrImageName);
    STDMETHOD(get_UniqueName)(/*[out, retval]*/ BSTR *pbstrUniqueName);
    STDMETHOD(get_MajorVersion)(/*[out, retval]*/ long *plMajorVersion);
    STDMETHOD(get_MinorVersion)(/*[out, retval]*/ long *plMinorVersion);
    STDMETHOD(get_InitErrorCode)(/*[out, retval]*/ long *plInitErrorCode);
    STDMETHOD(get_FriendlyName)(/*[out, retval]*/ BSTR *pbstrFriendlyName);
    STDMETHOD(get_Status)(/*[out, retval]*/ FAX_PROVIDER_STATUS_ENUM *pStatus);

    STDMETHOD(get_Methods)(/*[out, retval]*/ VARIANT *pvMethods);

//	Internal Use
    STDMETHOD(Init)(FAX_ROUTING_EXTENSION_INFO *pInfo, FAX_GLOBAL_ROUTING_INFO *pMethods, DWORD dwNum);
    
private:
    DWORD           m_dwLastError;
    DWORD           m_dwMajorBuild;
    DWORD           m_dwMinorBuild;
    DWORD           m_dwMajorVersion;
    DWORD           m_dwMinorVersion;

    CComBSTR        m_bstrFriendlyName;
    CComBSTR        m_bstrImageName;
    CComBSTR        m_bstrUniqueName;

    VARIANT_BOOL    m_bDebug;

    SAFEARRAY       *m_psaMethods;

    FAX_PROVIDER_STATUS_ENUM    m_Status;
};

#endif //__FAXINBOUNDROUTINGEXTENSION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxinboundroutingextensions.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxInboundRoutingExtensions.h

Abstract:

	Declaration of the CFaxInboundRoutingExtensions class

Author:

	Iv Garber (IvG)	Jul, 2000

Revision History:

--*/

#ifndef __FAXINBOUNDROUTINGEXTENSIONS_H_
#define __FAXINBOUNDROUTINGEXTENSIONS_H_

#include "resource.h"       // main symbols
#include <vector>
#include "VCUE_Copy.h"
#include "FaxCommon.h"

//#include "FaxDeviceProvider.h"

//
//  Very same as Device Providers Collection and Device Provider Objects
//
namespace IRExtensionsNamespace
{
    //
    //  Inbound Routing Extension Objects are stored in Vector of STL.
    //  When initialized, they got ALL their data. 
    //  They never call Fax Server.
    //  They do not depend neither on Fax Server nor on Extensions Collection
    //  after they are created and initialized.
    //  So, they implemented as usual COM Objects. 
    //  The Collection stores Ptrs to them, and makes ONE AddRef(). 
    //  Each time User asks for an Object from the Collection, an additional AddRef() happens. 
    //  When killed, Collection calls Release() on all contained in it Extension Objects.
    //  Those that are not asked by User, dies. 
    //  Those, that have User's AddRef() - remains alive, untill User free its Reference on them.
    //  The Extension Object can continue to live after all objects are freed,
    //  including Fax Server and all its Descendants. 
    //  THIS IS BECAUSE Extension Object and their Collection is Snap-Shot 
    //  of the situation on the Server. They are not updatable, but a read-only objects.
    //  To get the updated data, User must ask new Collection from the Server.
    //
	typedef	std::vector<IFaxInboundRoutingExtension*>        ContainerType;

	// Use IEnumVARIANT as the enumerator for VB compatibility
	typedef	VARIANT			    EnumExposedType;
	typedef	IEnumVARIANT        EnumIfc;

	//  Copy Classes
    typedef VCUE::CopyIfc2Variant<ContainerType::value_type>    EnumCopyType;
    typedef VCUE::CopyIfc<ContainerType::value_type>            CollectionCopyType;

    //  Enumeration Type, shortcut for next typedef
    typedef CComEnumOnSTL< EnumIfc, &__uuidof(EnumIfc), EnumExposedType, EnumCopyType, ContainerType >    
        EnumType;

    //  Collection Type, real ancestor of the IR Extensions Collection
    typedef ICollectionOnSTLImpl< IFaxInboundRoutingExtensions, ContainerType, ContainerType::value_type, 
        CollectionCopyType, EnumType >    CollectionType;
};

using namespace IRExtensionsNamespace;

//
//===================== INBOUND ROUTING EXTENSIONS COLLECTION =================================
//
class ATL_NO_VTABLE CFaxInboundRoutingExtensions : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public ISupportErrorInfo,
    public IDispatchImpl<IRExtensionsNamespace::CollectionType, &IID_IFaxInboundRoutingExtensions, 
		   &LIBID_FAXCOMEXLib>,
    public CFaxInitInner
{
public:
	CFaxInboundRoutingExtensions() : CFaxInitInner(_T("INBOUND ROUTING EXTENSIONS COLLECTION"))
	{}

    ~CFaxInboundRoutingExtensions()
    {
        CCollectionKiller<IRExtensionsNamespace::ContainerType>  CKiller;
        CKiller.EmptyObjectCollection(&m_coll);
    }

DECLARE_REGISTRY_RESOURCEID(IDR_FAXINBOUNDROUTINGEXTENSIONS)
DECLARE_NOT_AGGREGATABLE(CFaxInboundRoutingExtensions)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxInboundRoutingExtensions)
	COM_INTERFACE_ENTRY(IFaxInboundRoutingExtensions)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY(IFaxInitInner)
END_COM_MAP()

//  Interfaces
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
    STDMETHOD(get_Item)(/*[in]*/ VARIANT vIndex, 
        /*[out, retval]*/ IFaxInboundRoutingExtension **ppExtension);

//  Internal Use
    STDMETHOD(Init)(IFaxServerInner *pServerInner);
    static HRESULT Create(IFaxInboundRoutingExtensions **ppIRExtensions);
};

#endif //__FAXINBOUNDROUTINGEXTENSIONS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxinboundroutingmethod.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxInboundRoutingMethod.cpp

Abstract:

	Implementation of CFaxInboundRoutingMethod Class.

Author:

	Iv Garber (IvG)	Jun, 2000

Revision History:

--*/

#include "stdafx.h"
#include "FaxComEx.h"
#include "FaxInboundRoutingMethod.h"

//
//==================== REFRESH ========================================
//
STDMETHODIMP
CFaxInboundRoutingMethod::Refresh()
/*++

Routine name : CFaxInboundRoutingMethod::Refresh

Routine description:

    Bring from the Server new Method Data ( only Priority may change ).

Author:

	Iv Garber (IvG),	Jun, 2000

Return Value:

    Standard HRESULT code

--*/

{
	HRESULT     hr = S_OK;
	DBG_ENTER (TEXT("CFaxInboundRoutingMethod::Refresh"), hr);

	//
	//	Get Fax Server Handle
	//
    HANDLE faxHandle;
	hr = m_pIFaxServerInner->GetHandle(&faxHandle);
    ATLASSERT(SUCCEEDED(hr));

	if (faxHandle == NULL)
	{
		//
		//	Fax Server is not connected
		//
		hr = Fax_HRESULT_FROM_WIN32(ERROR_NOT_CONNECTED);
		CALL_FAIL(GENERAL_ERR, _T("(faxHandle == NULL)"), hr);
        AtlReportError(CLSID_FaxInboundRoutingMethod, GetErrorMsgId(hr), IID_IFaxInboundRoutingMethod, hr, _Module.GetResourceInstance());
		return hr;
	}

    //
    //  Bring from the Server all Inbound Routing Methods
    //
    DWORD       dwNum = 0;
    CFaxPtr<FAX_GLOBAL_ROUTING_INFO>    pMethods;
    if (!FaxEnumGlobalRoutingInfo(faxHandle, &pMethods, &dwNum))
    {
		hr = Fax_HRESULT_FROM_WIN32(GetLastError());
		CALL_FAIL(GENERAL_ERR, _T("FaxEnumGlobalRoutingInfo(faxHandle, &pMethods, &dwNum)"), hr);
        AtlReportError(CLSID_FaxInboundRoutingMethod, GetErrorMsgId(hr), IID_IFaxInboundRoutingMethod, hr, _Module.GetResourceInstance());
		return hr;
    }

    //
    //  find our Method
    //
    for ( DWORD i=0 ; i<dwNum ; i++ )
    {
        if ( _tcsicmp(pMethods[i].Guid, m_bstrGUID) == 0 )
        {
            hr = Init(&pMethods[i], NULL);
            return hr;
        }
    }

    return hr;
}

//
//==================== INIT ========================================
//
STDMETHODIMP
CFaxInboundRoutingMethod::Init(
    FAX_GLOBAL_ROUTING_INFO *pInfo,
    IFaxServerInner *pServer
)
/*++

Routine name : CFaxInboundRoutingMethod::Init

Routine description:

	Initialize the IR Method Object with given Information.
    Allocates memory and stores given pInfo.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	pInfo               [in]  -- the Info of the IR Method Object
	pServer             [in]  -- Ptr to the Server

Return Value:

    Standard HRESULT code

--*/

{
	HRESULT     hr = S_OK;
	DBG_ENTER (TEXT("CFaxInboundRoutingMethod::Init"), hr);

    //
    //  Copy the FAX_GLOBAL_ROUTING_INFO structure
    //
    m_lPriority = pInfo->Priority;

    m_bstrGUID = pInfo->Guid;
    m_bstrImageName = pInfo->ExtensionImageName;
    m_bstrFriendlyName = pInfo->ExtensionFriendlyName;
    m_bstrFunctionName = pInfo->FunctionName;
    m_bstrName = pInfo->FriendlyName;
    if ( (pInfo->Guid && !m_bstrGUID) ||
         (pInfo->FriendlyName && !m_bstrName) ||
         (pInfo->ExtensionImageName && !m_bstrImageName) ||
         (pInfo->ExtensionFriendlyName && !m_bstrFriendlyName) ||
         (pInfo->FunctionName && !m_bstrFunctionName) )
    {
        hr = E_OUTOFMEMORY;
        CALL_FAIL(MEM_ERR, _T("CComBSTR::operator=()"), hr);
        AtlReportError(CLSID_FaxInboundRoutingMethod, GetErrorMsgId(hr), IID_IFaxInboundRoutingMethod, hr, _Module.GetResourceInstance());
        return hr;
    }

    if (pServer)
    {

        //
        //  Store Ptr to the Server
        //
        hr = CFaxInitInnerAddRef::Init(pServer);
    }
    return hr;
}

//
//===================== SAVE ================================================
//
STDMETHODIMP
CFaxInboundRoutingMethod::Save()
/*++

Routine name : CFaxInboundRoutingMethod::Save

Routine description:

	Save the Method's Priority.

Author:

	Iv Garber (IvG),	Jun, 2000

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxInboundRoutingMethod::Save"), hr);

	//
	//	Get Fax Server Handle
	//
    HANDLE faxHandle;
	hr = m_pIFaxServerInner->GetHandle(&faxHandle);
    ATLASSERT(SUCCEEDED(hr));

	if (faxHandle == NULL)
	{
		//
		//	Fax Server is not connected
		//
		hr = Fax_HRESULT_FROM_WIN32(ERROR_NOT_CONNECTED);
		CALL_FAIL(GENERAL_ERR, _T("(faxHandle == NULL)"), hr);
        AtlReportError(CLSID_FaxInboundRoutingMethod, GetErrorMsgId(hr), IID_IFaxInboundRoutingMethod, hr, _Module.GetResourceInstance());
		return hr;
	}

    //
    //  Prepare Structure 
    //
    FAX_GLOBAL_ROUTING_INFO     Data;
    Data.Guid = m_bstrGUID;
    Data.Priority = m_lPriority;
    Data.SizeOfStruct = sizeof(FAX_GLOBAL_ROUTING_INFO);
    Data.ExtensionFriendlyName = NULL;
    Data.ExtensionImageName = NULL;
    Data.FriendlyName = NULL;
    Data.FunctionName = NULL;

    //
    //  Call Server to update its data about the Method
    //
    if (!FaxSetGlobalRoutingInfo(faxHandle, &Data))
    {
		hr = Fax_HRESULT_FROM_WIN32(GetLastError());
		CALL_FAIL(GENERAL_ERR, _T("FaxSetGlobalRoutingInfo(faxHandle, &Data)"), hr);
        AtlReportError(CLSID_FaxInboundRoutingMethod, GetErrorMsgId(hr), IID_IFaxInboundRoutingMethod, hr, _Module.GetResourceInstance());
		return hr;
    }

    return hr;
}

//
//===================== PUT PRIORITY ================================================
//
STDMETHODIMP
CFaxInboundRoutingMethod::put_Priority(
    /*[in]*/ long lPriority
)
/*++

Routine name : CFaxInboundRoutingMethod::put_Priority

Routine description:

	Set the Method's Priority -- Order within the Collection of all Methods.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	lPriority      [out]    - the value to set

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxInboundRoutingMethod::put_Priority"), hr, _T("PR=%d"), lPriority);

    if (lPriority < 1)
    {
        //
        //  Out Of Range
        //
		hr = E_INVALIDARG;
		AtlReportError(CLSID_FaxInboundRoutingMethod, IDS_ERROR_OUTOFRANGE, IID_IFaxInboundRoutingMethod, hr, _Module.GetResourceInstance());
		CALL_FAIL(GENERAL_ERR, _T("(lPriority < 1)"), hr);
		return hr;
    }

    m_lPriority = lPriority;
    return hr;
}

//
//===================== GET PRIORITY ================================================
//
STDMETHODIMP
CFaxInboundRoutingMethod::get_Priority(
    /*[out, retval]*/ long *plPriority
)
/*++

Routine name : CFaxInboundRoutingMethod::get_Priority

Routine description:

	Return the Method's Priority -- Order within the Collection of all Methods.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	plPriority      [out]    - the Ptr where to put the value

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxInboundRoutingMethod::get_Priority"), hr);

    hr = GetLong(plPriority, m_lPriority);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxInboundRoutingMethod, GetErrorMsgId(hr), IID_IFaxInboundRoutingMethod, hr, _Module.GetResourceInstance());
        return hr;
    }
    return hr;
}

//
//===================== GET EXTENSION IMAGE NAME ================================================
//
STDMETHODIMP
CFaxInboundRoutingMethod::get_ExtensionImageName(
    /*[out, retval]*/ BSTR *pbstrExtensionImageName
)
/*++

Routine name : CFaxInboundRoutingMethod::get_ExtensionImageName

Routine description:

	Return the Method's Extension Image Name.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	pbstrExtensionImageName             [out]    - the Ptr where to put the value

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxInboundRoutingMethod::get_ExtensionImageName"), hr);

    hr = GetBstr(pbstrExtensionImageName, m_bstrImageName);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxInboundRoutingMethod, GetErrorMsgId(hr), IID_IFaxInboundRoutingMethod, hr, _Module.GetResourceInstance());
        return hr;
    }
    return hr;
}

//
//===================== GET EXTENSION FRIENDLY NAME ================================================
//
STDMETHODIMP
CFaxInboundRoutingMethod::get_ExtensionFriendlyName(
    /*[out, retval]*/ BSTR *pbstrExtensionFriendlyName
)
/*++

Routine name : CFaxInboundRoutingMethod::get_ExtensionFriendlyName

Routine description:

	Return the Method's Extension Friendly Name.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	pbstrExtensionFriendlyName             [out]    - the Ptr where to put the value

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxInboundRoutingMethod::get_ExtensionFriendlyName"), hr);

    hr = GetBstr(pbstrExtensionFriendlyName, m_bstrFriendlyName);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxInboundRoutingMethod, GetErrorMsgId(hr), IID_IFaxInboundRoutingMethod, hr, _Module.GetResourceInstance());
        return hr;
    }
    return hr;
}

//
//===================== GET FUNCTION NAME ================================================
//
STDMETHODIMP
CFaxInboundRoutingMethod::get_FunctionName(
    /*[out, retval]*/ BSTR *pbstrFunctionName
)
/*++

Routine name : CFaxInboundRoutingMethod::get_FunctionName

Routine description:

	Return the Method's Function Name.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	pbstrFunctionName                   [out]    - the Ptr where to put the value

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxInboundRoutingMethod::get_FunctionName"), hr);

    hr = GetBstr(pbstrFunctionName, m_bstrFunctionName);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxInboundRoutingMethod, GetErrorMsgId(hr), IID_IFaxInboundRoutingMethod, hr, _Module.GetResourceInstance());
        return hr;
    }
    return hr;
}

//
//===================== GET GUID ================================================
//
STDMETHODIMP
CFaxInboundRoutingMethod::get_GUID(
    /*[out, retval]*/ BSTR *pbstrGUID
)
/*++

Routine name : CFaxInboundRoutingMethod::get_GUID

Routine description:

	Return the Method's GUID.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	pbstrGUID                   [out]    - the Ptr where to put the value

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxInboundRoutingMethod::get_GUID"), hr);

    hr = GetBstr(pbstrGUID, m_bstrGUID);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxInboundRoutingMethod, GetErrorMsgId(hr), IID_IFaxInboundRoutingMethod, hr, _Module.GetResourceInstance());
        return hr;
    }
    return hr;
}

//
//===================== GET NAME ================================================
//
STDMETHODIMP
CFaxInboundRoutingMethod::get_Name(
    /*[out, retval]*/ BSTR *pbstrName
)
/*++

Routine name : CFaxInboundRoutingMethod::get_Name

Routine description:

	Return the Method's Name.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	pbstrName                   [out]    - the Ptr where to put the value

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxInboundRoutingMethod::get_Name"), hr);

    hr = GetBstr(pbstrName, m_bstrName);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxInboundRoutingMethod, GetErrorMsgId(hr), IID_IFaxInboundRoutingMethod, hr, _Module.GetResourceInstance());
        return hr;
    }
    return hr;
}

//
//========================= SUPPORT ERROR INFO ====================================
//
STDMETHODIMP 
CFaxInboundRoutingMethod::InterfaceSupportsErrorInfo(
    REFIID riid
)
/*++

Routine name : CFaxInboundRoutingMethod::InterfaceSupportsErrorInfo

Routine description:

	ATL's implementation of Support Error Info.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	riid                          [in]    - Reference to the Interface.

Return Value:

    Standard HRESULT code

--*/
{
	static const IID* arr[] = 
	{
		&IID_IFaxInboundRoutingMethod
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxinboundroutingextension.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxInboundRoutingExtension.cpp

Abstract:

	Implementation of CFaxInboundRoutingExtension class.

Author:

	Iv Garber (IvG)	Jul, 2000

Revision History:

--*/

#include "stdafx.h"
#include "FaxComEx.h"
#include "FaxInboundRoutingExtension.h"


//
//===================== GET METHODS =========================================
//
STDMETHODIMP 
CFaxInboundRoutingExtension::get_Methods(
	/*[out, retval]*/ VARIANT *pvMethods
)
/*++

Routine name : CFaxInboundRoutingExtension::get_Methods

Routine description:

	Return array of all Method GUIDS exposed by the IR Extension

Author:

	Iv Garber (IvG),	Jul, 2000

Arguments:

	pvMethods           [out]    - Ptr to put Variant containing Safearray of Methods

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxInboundRoutingExtension::get_Methods"), hr);

	//
	//	Check that we can write to the given pointer
	//
	if (::IsBadWritePtr(pvMethods, sizeof(VARIANT)))
	{
		hr = E_POINTER;
		AtlReportError(CLSID_FaxInboundRoutingExtension, GetErrorMsgId(hr), IID_IFaxInboundRoutingExtension, hr, _Module.GetResourceInstance());
		CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr(pvMethods, sizeof(VARIANT))"), hr);
		return hr;
	}

    //
    //  Allocate the safe array : vector of BSTR
    //
    SAFEARRAY   *psaResult;
    hr = SafeArrayCopy(m_psaMethods, &psaResult);
    if (FAILED(hr) || !psaResult)
    {
        if (!psaResult)
        {
            hr = E_OUTOFMEMORY;
        }
        AtlReportError(CLSID_FaxInboundRoutingExtension, GetErrorMsgId(hr), IID_IFaxInboundRoutingExtension, hr, _Module.GetResourceInstance());
		CALL_FAIL(MEM_ERR, _T("SafeArrayCopy(m_psaMethods, &psaResult)"), hr);
		return hr;
	}

    //
    //  Return the Safe Array inside the VARIANT we got
    //
    VariantInit(pvMethods);
    pvMethods->vt = VT_BSTR | VT_ARRAY;
    pvMethods->parray = psaResult;
    return hr;
}

//
//===================== GET STATUS =========================================
//
STDMETHODIMP 
CFaxInboundRoutingExtension::get_Status(
	FAX_PROVIDER_STATUS_ENUM *pStatus
)
/*++

Routine name : CFaxInboundRoutingExtension::get_Status

Routine description:

	Return Status of the IR Extension

Author:

	Iv Garber (IvG),	Jul, 2000

Arguments:

	pStatus                [out]    - Ptr to put Status value

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxInboundRoutingExtension::get_Status"), hr);

	//
	//	Check that we have got good Ptr
	//
	if (::IsBadWritePtr(pStatus, sizeof(FAX_PROVIDER_STATUS_ENUM)))
	{
		hr = E_POINTER;
		CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr(pStatus, sizeof(FAX_PROVIDER_STATUS_ENUM))"), hr);
        AtlReportError(CLSID_FaxInboundRoutingExtension, GetErrorMsgId(hr), IID_IFaxInboundRoutingExtension, hr, _Module.GetResourceInstance());
        return hr;
	}

	*pStatus = m_Status;
	return hr;
}

//
//========================= GET IMAGE NAME ========================================
//
STDMETHODIMP 
CFaxInboundRoutingExtension::get_ImageName(
	BSTR *pbstrImageName
)
/*++

Routine name : CFaxInboundRoutingExtension::get_ImageName

Routine description:

	Return Image Name of the IR Extension

Author:

	Iv Garber (IvG),	Jul, 2000

Arguments:

	pbstrImageName                [out]    - Ptr to put the ImageName

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxInboundRoutingExtension::get_ImageName"), hr);
    hr = GetBstr(pbstrImageName, m_bstrImageName);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxInboundRoutingExtension, GetErrorMsgId(hr), IID_IFaxInboundRoutingExtension, hr, _Module.GetResourceInstance());
        return hr;
    }
    return hr;
}

//
//========================= GET FRIENDLY NAME ========================================
//
STDMETHODIMP 
CFaxInboundRoutingExtension::get_FriendlyName(
	BSTR *pbstrFriendlyName
)
/*++

Routine name : CFaxInboundRoutingExtension::get_FriendlyName

Routine description:

	Return Friendly Name of the IR Extension

Author:

	Iv Garber (IvG),	Jul, 2000

Arguments:

	pbstrFriendlyName               [out]    - Ptr to put the FriendlyName

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxInboundRoutingExtension::get_FriendlyName"), hr);
    hr = GetBstr(pbstrFriendlyName, m_bstrFriendlyName);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxInboundRoutingExtension, GetErrorMsgId(hr), IID_IFaxInboundRoutingExtension, hr, _Module.GetResourceInstance());
        return hr;
    }
    return hr;
}

//
//========================= GET UNIQUE NAME ========================================
//
STDMETHODIMP 
CFaxInboundRoutingExtension::get_UniqueName(
	BSTR *pbstrUniqueName
)
/*++

Routine name : CFaxInboundRoutingExtension::get_UniqueName

Routine description:

	Return Unique Name of the IR Extension

Author:

	Iv Garber (IvG),	Jul, 2000

Arguments:

	pbstrUniqueName               [out]    - Ptr to put the Unique Name

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxInboundRoutingExtension::get_UniquName"), hr);
    hr = GetBstr(pbstrUniqueName, m_bstrUniqueName);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxInboundRoutingExtension, GetErrorMsgId(hr), IID_IFaxInboundRoutingExtension, hr, _Module.GetResourceInstance());
        return hr;
    }
    return hr;
}

//
//===================== GET DEBUG =========================================
//
STDMETHODIMP 
CFaxInboundRoutingExtension::get_Debug(
	VARIANT_BOOL *pbDebug
)
/*++

Routine name : CFaxInboundRoutingExtension::get_Debug

Routine description:

	Return if the IR Extension is compiled in Debug version

Author:

	Iv Garber (IvG),	Jul, 2000

Arguments:

	pbDebug                 [out]    - Ptr to put Debug value

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxInboundRoutingExtension::get_Debug"), hr);

    hr = GetVariantBool(pbDebug, m_bDebug);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxInboundRoutingExtension, GetErrorMsgId(hr), IID_IFaxInboundRoutingExtension, hr, _Module.GetResourceInstance());
        return hr;
    }
	return hr;
}

//
//===================== GET MAJOR BUILD =========================================
//
STDMETHODIMP 
CFaxInboundRoutingExtension::get_MajorBuild(
	long *plMajorBuild
)
/*++

Routine name : CFaxInboundRoutingExtension::get_MajorBuild

Routine description:

	Return MajorBuild of the IR Extension

Author:

	Iv Garber (IvG),	Jul, 2000

Arguments:

	plMajorBuild                [out]    - Ptr to put MajorBuild value

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxInboundRoutingExtension::get_MajorBuild"), hr);

    hr = GetLong(plMajorBuild, m_dwMajorBuild);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxInboundRoutingExtension, GetErrorMsgId(hr), IID_IFaxInboundRoutingExtension, hr, _Module.GetResourceInstance());
        return hr;
    }
	return hr;
}

//
//===================== GET MINOR BUILD =========================================
//
STDMETHODIMP 
CFaxInboundRoutingExtension::get_MinorBuild(
	long *plMinorBuild
)
/*++

Routine name : CFaxInboundRoutingExtension::get_MinorBuild

Routine description:

	Return MinorBuild of the IR Extension

Author:

	Iv Garber (IvG),	Jul, 2000

Arguments:

	plMinorBuild                [out]    - Ptr to put MinorBuild value

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxInboundRoutingExtension::get_MinorBuild"), hr);

    hr = GetLong(plMinorBuild, m_dwMinorBuild);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxInboundRoutingExtension, GetErrorMsgId(hr), IID_IFaxInboundRoutingExtension, hr, _Module.GetResourceInstance());
        return hr;
    }
	return hr;
}

//
//===================== GET MAJOR VERSION =========================================
//
STDMETHODIMP 
CFaxInboundRoutingExtension::get_MajorVersion(
	long *plMajorVersion
)
/*++

Routine name : CFaxInboundRoutingExtension::get_MajorVersion

Routine description:

	Return MajorVersion of the IR Extension

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	plMajorVersion                [out]    - Ptr to put MajorVersion value

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxInboundRoutingExtension::get_MajorVersion"), hr);

    hr = GetLong(plMajorVersion, m_dwMajorVersion);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxInboundRoutingExtension, GetErrorMsgId(hr), IID_IFaxInboundRoutingExtension, hr, _Module.GetResourceInstance());
        return hr;
    }
	return hr;
}

//
//===================== GET MINOR VERSION =========================================
//
STDMETHODIMP 
CFaxInboundRoutingExtension::get_MinorVersion(
	long *plMinorVersion
)
/*++

Routine name : CFaxInboundRoutingExtension::get_MinorVersion

Routine description:

	Return MinorVersion of the IR Extension

Author:

	Iv Garber (IvG),	Jul, 2000

Arguments:

	plMinorVersion                [out]    - Ptr to put MinorVersionvalue

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxInboundRoutingExtension::get_MinorVersion"), hr);

    hr = GetLong(plMinorVersion, m_dwMinorVersion);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxInboundRoutingExtension, GetErrorMsgId(hr), IID_IFaxInboundRoutingExtension, hr, _Module.GetResourceInstance());
        return hr;
    }
	return hr;
}

//
//===================== GET INIT ERROR CODE =========================================
//
STDMETHODIMP 
CFaxInboundRoutingExtension::get_InitErrorCode(
	long *plInitErrorCode
)
/*++

Routine name : CFaxInboundRoutingExtension::get_InitErrorCode

Routine description:

	Return InitErrorCode of the IR Extension

Author:

	Iv Garber (IvG),	Jul, 2000

Arguments:

	plInitErrorCode                [out]    - Ptr to put InitErrorCode value

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxInboundRoutingExtension::get_InitErrorCode"), hr);

    hr = GetLong(plInitErrorCode, m_dwLastError);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxInboundRoutingExtension, GetErrorMsgId(hr), IID_IFaxInboundRoutingExtension, hr, _Module.GetResourceInstance());
        return hr;
    }
	return hr;
}

//
//==================== INIT ========================================
//
STDMETHODIMP
CFaxInboundRoutingExtension::Init(
    FAX_ROUTING_EXTENSION_INFO *pInfo,
    FAX_GLOBAL_ROUTING_INFO *pMethods,
    DWORD dwNum
)
/*++

Routine name : CFaxInboundRoutingExtesnion::Init

Routine description:

	Initialize the IR Extension Object with given Information.
    Allocates memory and stores given pInfo.
    Find in the pMethods its own Methods, create Variant of SafeArray containing them.

Author:

	Iv Garber (IvG),	Jul, 2000

Arguments:

	pInfo               [in]  -- the Info of the IR Extension Object
    pMethods            [in]  -- array of all available Methods
    dwNum               [in]  -- number of elements in pMethods array

Return Value:

    Standard HRESULT code

--*/

{
	HRESULT     hr = S_OK;
	DBG_ENTER (TEXT("CFaxInboundRoutingExtension::Init"), hr);

    //
    //  Copy the FAX_ROUTING_EXTENSION_INFO
    //
    m_dwLastError = pInfo->dwLastError;
    m_Status = FAX_PROVIDER_STATUS_ENUM(pInfo->Status);

    if (!(pInfo->Version.bValid))
    {
        m_dwMajorBuild = 0;
        m_dwMinorBuild = 0;
        m_dwMajorVersion = 0;
        m_dwMinorVersion = 0;
        m_bDebug = VARIANT_FALSE;
    }
    else
    {
        m_dwMajorBuild = pInfo->Version.wMajorBuildNumber;
        m_dwMinorBuild = pInfo->Version.wMinorBuildNumber;
        m_dwMajorVersion = pInfo->Version.wMajorVersion;
        m_dwMinorVersion = pInfo->Version.wMinorVersion;
        m_bDebug = bool2VARIANT_BOOL((pInfo->Version.dwFlags & FAX_VER_FLAG_CHECKED) ? true : false);
    }

    m_bstrImageName = pInfo->lpctstrImageName;
    m_bstrFriendlyName = pInfo->lpctstrFriendlyName;
    m_bstrUniqueName = pInfo->lpctstrExtensionName;
    if ( (pInfo->lpctstrImageName && !m_bstrImageName) ||
         (pInfo->lpctstrFriendlyName && !m_bstrFriendlyName) ||
         (pInfo->lpctstrExtensionName && !m_bstrUniqueName) )
    {
        hr = E_OUTOFMEMORY;
        CALL_FAIL(MEM_ERR, _T("CComBSTR::operator=()"), hr);
        AtlReportError(CLSID_FaxInboundRoutingExtension, GetErrorMsgId(hr), IID_IFaxInboundRoutingExtension, hr, _Module.GetResourceInstance());
        return hr;
    }

    //
    //  count the Methods of the IR Extension
    //
    DWORD   dwCount = 0;
    for (DWORD  i=0 ; i<dwNum ; i++ )
    {
        //
        //  We may only compare Friendly Name and Image Name.
        //  This is potentially a problem. 
        //  Extensions should be distinguished by their Unique Name.
        //
        if ( (_tcscmp(pMethods[i].ExtensionFriendlyName, m_bstrFriendlyName) == 0) &&
             (_tcscmp(pMethods[i].ExtensionImageName, m_bstrImageName) == 0) )
        {
            dwCount++;
        }
    }

    //
    //  Allocate the safe array : vector of BSTR
    //
	m_psaMethods = ::SafeArrayCreateVector(VT_BSTR, 0, dwCount);
	if (!m_psaMethods)
	{
		//
		//	Not Enough Memory
		//
		hr = E_OUTOFMEMORY;
        AtlReportError(CLSID_FaxInboundRoutingExtension, GetErrorMsgId(hr), IID_IFaxInboundRoutingExtension, hr, _Module.GetResourceInstance());
		CALL_FAIL(MEM_ERR, _T("::SafeArrayCreateVector(VT_BSTR, 0, dwCount)"), hr);
		return hr;
	}

    if ( dwCount>0 )
    {

        //
        //  get Access to the elements of the Safe Array
        //
	    BSTR *pbstrElement;
	    hr = ::SafeArrayAccessData(m_psaMethods, (void **) &pbstrElement);
	    if (FAILED(hr))
	    {
		    //
		    //	Failed to access safearray
		    //
            hr = E_FAIL;
		    CALL_FAIL(GENERAL_ERR, _T("::SafeArrayAccessData(m_psaMethods, &pbstrElement)"), hr);
            AtlReportError(CLSID_FaxInboundRoutingExtension, GetErrorMsgId(hr), IID_IFaxInboundRoutingExtension, hr, _Module.GetResourceInstance());
		    return hr;
	    }

        //
        //  Fill the array with values
        //
        DWORD       idx = 0;
        for ( i=0 ; i<dwNum ; i++ )
        {
        //
        //  Like the previous comparison :
        //      We may only compare Friendly Name and Image Name.
        //      This is potentially a problem. 
        //      Extensions should be distinguished by their Unique Name.
        //
            if ( (_tcscmp(pMethods[i].ExtensionFriendlyName, m_bstrFriendlyName) == 0) &&
                 (_tcscmp(pMethods[i].ExtensionImageName, m_bstrImageName) == 0) )
            {
                //
                //  Allocate memory for the GUID and store ptr to it in the SafeArray
                //
                BSTR bstrTmp = NULL;
                bstrTmp = ::SysAllocString(pMethods[i].Guid);
                if (pMethods[i].Guid && !bstrTmp)
                {
		            //
		            //	Not Enough Memory
		            //
		            hr = E_OUTOFMEMORY;
                    AtlReportError(CLSID_FaxInboundRoutingExtension, GetErrorMsgId(hr), IID_IFaxInboundRoutingExtension, hr, _Module.GetResourceInstance());
		            CALL_FAIL(MEM_ERR, _T("::SysAllocString(pMethods[i].Guid)"), hr);
                    SafeArrayUnaccessData(m_psaMethods);
                    SafeArrayDestroy(m_psaMethods);
                    m_psaMethods = NULL;
		            return hr;
                }

                pbstrElement[idx] = bstrTmp;
                idx++;
            }
        }
        ATLASSERT(idx == dwCount);

        //
        //  free the safearray from the access  
        //
	    hr = ::SafeArrayUnaccessData(m_psaMethods);
        if (FAILED(hr))
        {
	        CALL_FAIL(GENERAL_ERR, _T("::SafeArrayUnaccessData(m_psaMethods)"), hr);
            return hr;
        }
    }

    return hr;
}

//
//==================== SUPPORT ERROR INFO =============================================
//
STDMETHODIMP 
CFaxInboundRoutingExtension::InterfaceSupportsErrorInfo(
    REFIID riid
)
/*++

Routine name : CFaxInboundRoutingExtension::InterfaceSupportsErrorInfo

Routine description:

	ATL's implementation of Support Error Info.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	riid                          [in]    - Reference to the Interface.

Return Value:

    Standard HRESULT code

--*/
{
	static const IID* arr[] = 
	{
		&IID_IFaxInboundRoutingExtension
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxinboundroutingextensions.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxInboundRoutingExtensions.cpp

Abstract:

	Implementation of CFaxInboundRoutingExtensions class.

Author:

	Iv Garber (IvG)	Jul, 2000

Revision History:

--*/

#include "stdafx.h"
#include "FaxComEx.h"
#include "FaxInboundRoutingExtensions.h"
#include "FaxInboundRoutingExtension.h"

//
//==================== CREATE ========================================
//
HRESULT 
CFaxInboundRoutingExtensions::Create (
	IFaxInboundRoutingExtensions **ppIRExtensions
)
/*++

Routine name : CFaxInboundRoutingExtensions::Create

Routine description:

	Static function to create the Fax IR Extensions Collection Object

Author:

	Iv Garber (IvG),	Jul, 2000

Arguments:

	ppIRExtensions          [out]  -- the new Fax IR Extensions Collection Object

Return Value:

    Standard HRESULT code

--*/

{
	HRESULT     hr = S_OK;
	DBG_ENTER (TEXT("CFaxInboundRoutingExtensions::Create"), hr);

    //
    //  Create Instance of the Collection
    //
	CComObject<CFaxInboundRoutingExtensions>		*pClass;
	hr = CComObject<CFaxInboundRoutingExtensions>::CreateInstance(&pClass);
	if (FAILED(hr))
	{
		CALL_FAIL(GENERAL_ERR, _T("CComObject<CFaxInboundRoutingExtensions>::CreateInstance(&pClass)"), hr);
		return hr;
	}

    //
    //  Return the desired Interface Ptr
    //
	hr = pClass->QueryInterface(ppIRExtensions);
	if (FAILED(hr))
	{
		CALL_FAIL(GENERAL_ERR, _T("pClass->QueryInterface(ppIRExtensions)"), hr);
		return hr;
	}

	return hr;
}	//	CFaxInboundRoutingExtensions::Create()

//
//============================= INIT ============================================
//
STDMETHODIMP
CFaxInboundRoutingExtensions::Init(
    IFaxServerInner *pServerInner
)
/*++

Routine name : CFaxInboundRoutingExtensions::Init

Routine description:

	Initialize the Collection : 
    1)  get from RPC all IR Extensions and all Methods Structures, 
    2)  create COM objects for each structure,
    3)  init all these objects with the IR Extension structure and Methods array,
    4)  AddRef() each object,
    5)  put the Ptrs to Objects into the STL::vector.

Author:

	Iv Garber (IvG),	Jul, 2000

Arguments:

	pServerInner                    [in]    - Ptr to the Fax Server.

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxInboundRoutingExtensions::Init"), hr);

	//
	//	Get Fax Server Handle
	//
    HANDLE faxHandle;
	hr = pServerInner->GetHandle(&faxHandle);
    ATLASSERT(SUCCEEDED(hr));

	if (faxHandle == NULL)
	{
		//
		//	Fax Server is not connected
		//
		hr = Fax_HRESULT_FROM_WIN32(ERROR_NOT_CONNECTED);
		CALL_FAIL(GENERAL_ERR, _T("faxHandle == NULL"), hr);
        AtlReportError(CLSID_FaxInboundRoutingExtensions, GetErrorMsgId(hr), IID_IFaxInboundRoutingExtensions, hr, _Module.GetResourceInstance());
		return hr;
	}

    //
    //  Bring from the Server all IR Extensions
    //
    DWORD       dwNum = 0;
    CFaxPtr<FAX_ROUTING_EXTENSION_INFO>   pIRExtensions;
    if (!FaxEnumRoutingExtensions(faxHandle, &pIRExtensions, &dwNum))
    {
		hr = Fax_HRESULT_FROM_WIN32(GetLastError());
		CALL_FAIL(GENERAL_ERR, _T("FaxEnumRoutingExtensions(faxHandle, &pIRExtensions, &dwNum"), hr);
        AtlReportError(CLSID_FaxInboundRoutingExtensions, GetErrorMsgId(hr), IID_IFaxInboundRoutingExtensions, hr, _Module.GetResourceInstance());
		return hr;
    }

    //
    //  Bring all the Methods from the Server
    //
    DWORD       dwNumMethods = 0;
    CFaxPtr<FAX_GLOBAL_ROUTING_INFO>   pMethods;
    if (!FaxEnumGlobalRoutingInfo(faxHandle, &pMethods, &dwNumMethods))
    {
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        AtlReportError(CLSID_FaxInboundRoutingExtensions, GetErrorMsgId(hr), IID_IFaxInboundRoutingExtensions, hr, _Module.GetResourceInstance());
        CALL_FAIL(GENERAL_ERR, _T("FaxEnumGlobalRoutingInfo(hFaxHandle, &pMethods, &dwNumMethods)"), hr);
        return hr;
    }

    //
    //  Fill the Collection with Objects
    //
    CComObject<CFaxInboundRoutingExtension>  *pClass = NULL;
    CComPtr<IFaxInboundRoutingExtension>     pObject = NULL;
    for (DWORD i=0 ; i<dwNum ; i++ )
    {
        //
        //  Create IR Extensin Object
        //
        hr = CComObject<CFaxInboundRoutingExtension>::CreateInstance(&pClass);
        if (FAILED(hr) || (!pClass))
        {
            if (!pClass)
            {
                hr = E_OUTOFMEMORY;
    		    CALL_FAIL(MEM_ERR, _T("CComObject<CFaxInboundRoutingExtension>::CreateInstance(&pClass)"), hr);
            }
            else
            {
    		    CALL_FAIL(GENERAL_ERR, _T("CComObject<CFaxInboundRoutingExtension>::CreateInstance(&pClass)"), hr);
            }

            AtlReportError(CLSID_FaxInboundRoutingExtensions, GetErrorMsgId(hr), IID_IFaxInboundRoutingExtensions, hr, _Module.GetResourceInstance());
		    return hr;
        }

        //
        //  Init the IR Extension Object
        //
        hr = pClass->Init(&pIRExtensions[i], pMethods, dwNumMethods);
        if (FAILED(hr))
        {
            CALL_FAIL(GENERAL_ERR, _T("pClass->Init(&pIRExtensions[i], pMethods, dwNumMethods)"), hr);
            AtlReportError(CLSID_FaxInboundRoutingExtensions, GetErrorMsgId(hr), IID_IFaxInboundRoutingExtensions, hr, _Module.GetResourceInstance());
            delete pClass;
            return hr;
        }

        //
        //  Get Interface from the pClass.
        //  This will make AddRef() on the Interface. 
        //  This is the Collection's AddRef, which is freed at Collection's Dtor.
        //
        hr = pClass->QueryInterface(&pObject);
        if (FAILED(hr) || (!pObject))
        {
            if (!pObject)
            {
                hr = E_FAIL;
            }
            CALL_FAIL(GENERAL_ERR, _T("pClass->QueryInterface(&pObject)"), hr);
            AtlReportError(CLSID_FaxInboundRoutingExtensions, GetErrorMsgId(hr), IID_IFaxInboundRoutingExtensions, hr, _Module.GetResourceInstance());
            delete pClass;
            return hr;
        }

	    //
	    //	Put the Object in the collection
	    //
	    try 
	    {
		    m_coll.push_back(pObject);
	    }
	    catch (exception &)
	    {
		    hr = E_OUTOFMEMORY;
		    AtlReportError(CLSID_FaxInboundRoutingExtensions, IDS_ERROR_OUTOFMEMORY, IID_IFaxInboundRoutingExtensions, hr, _Module.GetResourceInstance());
		    CALL_FAIL(MEM_ERR, _T("m_coll.push_back(pObject)"), hr);

            //
            //  pObject will call Release(), which will delete the pClass
            //
		    return hr;
	    }

        //
        //  We want to save the current AddRef() to Collection
        //
        pObject.Detach();
    }

    return hr;
}

//
//============================= GET ITEM =========================================
//
STDMETHODIMP
CFaxInboundRoutingExtensions::get_Item(
    /*[in]*/ VARIANT vIndex, 
    /*[out, retval]*/ IFaxInboundRoutingExtension **ppIRExtension
)
/*++

Routine name : CFaxInboundRoutingExtensions::get_Item

Routine description:

	Return an Item from the Collection.

Author:

	Iv Garber (IvG),	Jul, 2000

Arguments:

	vIndex                          [in]    - Identifier of the Item to return.
	ppIRExtension                   [out]    - the result value

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxInboundRoutingExtensions::get_Item"), hr);

    //
    //  Check the Ptr we have got
    //
    if (::IsBadWritePtr(ppIRExtension, sizeof(IFaxInboundRoutingExtension *)))
    {
        hr = E_POINTER;
        AtlReportError(CLSID_FaxInboundRoutingExtensions, IDS_ERROR_INVALID_ARGUMENT, IID_IFaxInboundRoutingExtensions, hr, _Module.GetResourceInstance());
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr(ppIRExtension)"), hr);
		return hr;
    }

    CComVariant var;

    if (vIndex.vt != VT_BSTR)
    {
        //
        //  vIndex is not BSTR ==> convert to VT_I4
        //
        hr = var.ChangeType(VT_I4, &vIndex);
        if (SUCCEEDED(hr))
        {
            VERBOSE(DBG_MSG, _T("Parameter is Number : %d"), var.lVal);
            //
            //  call default ATL's implementation
            //
            hr = ICollectionOnSTLImpl<IFaxInboundRoutingExtensions, ContainerType, 
                IFaxInboundRoutingExtension*, CollectionCopyType, EnumType>::get_Item(var.lVal, 
                ppIRExtension);
            return hr;
		}
    }

    //
    //  convert to BSTR
    //
    hr = var.ChangeType(VT_BSTR, &vIndex);
    if (FAILED(hr))
    {
        hr = E_INVALIDARG;
        AtlReportError(CLSID_FaxInboundRoutingExtensions, IDS_ERROR_INVALID_ARGUMENT, IID_IFaxInboundRoutingExtensions, hr, _Module.GetResourceInstance());
        CALL_FAIL(GENERAL_ERR, _T("var.ChangeType(VT_BSTR, &vIndex)"), hr);
        return hr;
    }

    VERBOSE(DBG_MSG, _T("Parameter is String : %s"), var.bstrVal);

    ContainerType::iterator it = m_coll.begin();
    while (it != m_coll.end())
    {
        CComBSTR    bstrName;
        hr = (*it)->get_UniqueName(&bstrName);
        if (FAILED(hr))
        {
		    CALL_FAIL(GENERAL_ERR, _T("(*it)->get_UniqueName(&bstrName)"), hr);
            AtlReportError(CLSID_FaxInboundRoutingExtensions, GetErrorMsgId(hr), IID_IFaxInboundRoutingExtensions, hr, _Module.GetResourceInstance());
            return hr;
        }

        if (_tcsicmp(bstrName, var.bstrVal) == 0)
        {
            //
            //  found the desired IR Extension
            //
            (*it)->AddRef();
            *ppIRExtension = *it;
            return hr;
        }
        it++;
    }

    //
    //  IR Extension does not exist
    //
	hr = E_INVALIDARG;
	CALL_FAIL(GENERAL_ERR, _T("Inbound Routing Extension Is Not Found"), hr);
	AtlReportError(CLSID_FaxInboundRoutingExtensions, IDS_ERROR_WRONGEXTENSIONNAME, IID_IFaxInboundRoutingExtensions, hr, _Module.GetResourceInstance());
	return hr;
}

//
//================== SUPPORT ERROR INFO ========================================
//
STDMETHODIMP 
CFaxInboundRoutingExtensions::InterfaceSupportsErrorInfo(
    REFIID riid
)
/*++

Routine name : CFaxInboundRoutingExtensions::InterfaceSupportsErrorInfo

Routine description:

	ATL's implementation of Support Error Info.

Author:

	Iv Garber (IvG),	Jul, 2000

Arguments:

	riid                          [in]    - Reference to the Interface.

Return Value:

    Standard HRESULT code

--*/
{
	static const IID* arr[] = 
	{
		&IID_IFaxInboundRoutingExtensions
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxinboundroutingmethod.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxInboundRoutingMethod.h

Abstract:

	Declaration of the CFaxInboundRoutingMethod Class.

Author:

	Iv Garber (IvG)	Jun, 2000

Revision History:

--*/

#ifndef __FAXINBOUNDROUTINGMETHOD_H_
#define __FAXINBOUNDROUTINGMETHOD_H_

#include "resource.h"       // main symbols
#include "FaxCommon.h"

//
//==================== FAX INBOUND ROUTING METHOD =============================
//
class ATL_NO_VTABLE CFaxInboundRoutingMethod : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public ISupportErrorInfo,
	public IDispatchImpl<IFaxInboundRoutingMethod, &IID_IFaxInboundRoutingMethod, &LIBID_FAXCOMEXLib>,
    public CFaxInitInnerAddRef
{
public:
    CFaxInboundRoutingMethod() : CFaxInitInnerAddRef(_T("FAX INBOUND ROUTING METHOD"))
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_FAXINBOUNDROUTINGMETHOD)
DECLARE_NOT_AGGREGATABLE(CFaxInboundRoutingMethod)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxInboundRoutingMethod)
	COM_INTERFACE_ENTRY(IFaxInboundRoutingMethod)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

//  Interfaces
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

    STDMETHOD(get_Name)(/*[out, retval]*/ BSTR *pbstrName);
    STDMETHOD(get_GUID)(/*[out, retval]*/ BSTR *pbstrGUID);
    STDMETHOD(get_FunctionName)(/*[out, retval]*/ BSTR *pbstrFunctionName);
    STDMETHOD(get_ExtensionFriendlyName)(/*[out, retval]*/ BSTR *pbstrExtensionFriendlyName);
    STDMETHOD(get_ExtensionImageName)(/*[out, retval]*/ BSTR *pbstrExtensionImageName);

    STDMETHOD(put_Priority)(/*[in]*/ long lPriority);
    STDMETHOD(get_Priority)(/*[out, retval]*/ long *plPriority);

    STDMETHOD(Save)();
    STDMETHOD(Refresh)();

//  Internal Use
    STDMETHOD(Init)(FAX_GLOBAL_ROUTING_INFO *pInfo, IFaxServerInner *pServer);

private:
    CComBSTR    m_bstrName;
    CComBSTR    m_bstrGUID;
    CComBSTR    m_bstrFunctionName;
    CComBSTR    m_bstrFriendlyName;
    CComBSTR    m_bstrImageName;
    long        m_lPriority;
};

#endif //__FAXINBOUNDROUTINGMETHOD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxinboundroutingmethods.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxInboundRoutingMethods.h

Abstract:

	Declaration of the CFaxInboundRoutingMethods class.

Author:

	Iv Garber (IvG)	Jun, 2000

Revision History:

--*/

#ifndef __FAXINBOUNDROUTINGMETHODS_H_
#define __FAXINBOUNDROUTINGMETHODS_H_

#include "resource.h"       // main symbols
#include <vector>
#include "VCUE_Copy.h"
#include "FaxCommon.h"

namespace MethodsNamespace
{

    //
    //  Method Objects are stored in Vector of STL.
    //  When initialized, they got ALL their data, and Fax Server Ptr.
    //  They do not depend on Methods Collection, only on Fax Server.
    //  So, they implemented as usual COM Objects. 
    //  They inherit from CFaxInitInnerAddRef class, which means they make AddRef() 
    //  on Fax Server ( at Init() ).
    //  By doing this, the objects prevent the death of the Fax Server prematurely.
    //  So, if the User frees all its references to the Fax Server, but holds its
    //  reference to the Method Object, the Method Object will continue to work,
    //  because Fax Server Object actually did not died.
    //  The Collection stores Ptrs to them, and makes ONE AddRef(). 
    //  Each time User asks for an Object from the Collection, an additional AddRef() happens. 
    //  When killed, Collection calls Release() on all its Method Objects.
    //  Those that were not requested by the User, dies. 
    //  Those, that have User's AddRef() - remains alive, untill User frees its Reference on them.
    //  Fax Server remains alive untill all the Methods Collections and all Method Objects are killed.
    //  At their death, they Release() the Fax Server.
    //
	typedef	std::vector<IFaxInboundRoutingMethod*>       ContainerType;

	// Use IEnumVARIANT as the enumerator for VB compatibility
	typedef	VARIANT			EnumExposedType;
	typedef	IEnumVARIANT    EnumIfc;

	//  Copy Classes
    typedef VCUE::CopyIfc2Variant<ContainerType::value_type>    EnumCopyType;
    typedef VCUE::CopyIfc<ContainerType::value_type>            CollectionCopyType;

    typedef CComEnumOnSTL< EnumIfc, &__uuidof(EnumIfc), EnumExposedType, EnumCopyType, 
        ContainerType >    EnumType;

    typedef ICollectionOnSTLImpl< IFaxInboundRoutingMethods, ContainerType, ContainerType::value_type, 
        CollectionCopyType, EnumType >    CollectionType;
};

using namespace MethodsNamespace;

//
//================= FAX INBOUND ROUTING METHODS ============================================
// 
class ATL_NO_VTABLE CFaxInboundRoutingMethods : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public ISupportErrorInfo,
    public IDispatchImpl<MethodsNamespace::CollectionType, &IID_IFaxInboundRoutingMethods, &LIBID_FAXCOMEXLib>,
    public CFaxInitInner    //  for Debug + Creation thru CObjectHandler
{
public:
    CFaxInboundRoutingMethods() : CFaxInitInner(_T("FAX INBOUND ROUTING METHODS"))
	{
	}

    ~CFaxInboundRoutingMethods()
    {
        CCollectionKiller<MethodsNamespace::ContainerType>  CKiller;
        CKiller.EmptyObjectCollection(&m_coll);
    }

DECLARE_REGISTRY_RESOURCEID(IDR_FAXINBOUNDROUTINGMETHODS)
DECLARE_NOT_AGGREGATABLE(CFaxInboundRoutingMethods)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxInboundRoutingMethods)
	COM_INTERFACE_ENTRY(IFaxInboundRoutingMethods)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY(IFaxInitInner)
END_COM_MAP()

//  Interfaces
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
    STDMETHOD(get_Item)(/*[in]*/ VARIANT vIndex, /*[out, retval]*/ IFaxInboundRoutingMethod **ppMethod);

//  Internal Use
    static HRESULT Create(IFaxInboundRoutingMethods **ppMethods);
    STDMETHOD(Init)(IFaxServerInner *pServer);
};

#endif //__FAXINBOUNDROUTINGMETHODS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxinboundroutingmethods.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxInboundRoutingMethods.cpp

Abstract:

	Implementation of CFaxInboundRoutingMethods Class.

Author:

	Iv Garber (IvG)	Jun, 2000

Revision History:

--*/

#include "stdafx.h"
#include "FaxComEx.h"
#include "FaxInboundRoutingMethods.h"
#include "FaxInboundRoutingMethod.h"

//
//================== SUPPORT ERROR INFO ========================================
//
STDMETHODIMP 
CFaxInboundRoutingMethods::InterfaceSupportsErrorInfo(
    REFIID riid
)
/*++

Routine name : CFaxInboundRoutingMethods::InterfaceSupportsErrorInfo

Routine description:

	ATL's implementation of Support Error Info.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	riid                          [in]    - Reference to the Interface.

Return Value:

    Standard HRESULT code

--*/
{
	static const IID* arr[] = 
	{
		&IID_IFaxInboundRoutingMethods
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

//
//==================== CREATE ========================================
//
HRESULT 
CFaxInboundRoutingMethods::Create (
	IFaxInboundRoutingMethods **ppMethods
)
/*++

Routine name : CFaxInboundRoutingMethods::Create

Routine description:

	Static function to create the Fax Inbound Routing Methods Collection Object

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	ppMethods              [out]  -- the new Fax Inbound Routing Methods Collection Object

Return Value:

    Standard HRESULT code

--*/

{
	HRESULT     hr = S_OK;
	DBG_ENTER (TEXT("CFaxInboundRoutingMethods::Create"), hr);

    //
    //  Create Instance of the Collection
    //
	CComObject<CFaxInboundRoutingMethods>		*pClass;
	hr = CComObject<CFaxInboundRoutingMethods>::CreateInstance(&pClass);
	if (FAILED(hr))
	{
		CALL_FAIL(GENERAL_ERR, _T("CComObject<CFaxInboundRoutingMethods>::CreateInstance(&pClass)"), hr);
		return hr;
	}

    //
    //  Return the desired Interface Ptr
    //
	hr = pClass->QueryInterface(ppMethods);
	if (FAILED(hr))
	{
		CALL_FAIL(GENERAL_ERR, _T("pClass->QueryInterface(ppMethods)"), hr);
		return hr;
	}

	return hr;
}	//	CFaxInboundRoutingMethods::Create()

//
//============================= INIT ============================================
//
STDMETHODIMP
CFaxInboundRoutingMethods::Init(
    IFaxServerInner *pServerInner
)
/*++

Routine name : CFaxInboundRoutingMethods::Init

Routine description:

	Initialize the Collection : 
    1)  get from RPC all IR Methods, 
    2)  create COM objects for each one,
    3)  AddRef() each object,
    4)  put the Ptrs to Objects into the STL::vector.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	pServerInner                    [in]    - Ptr to the Fax Server.

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxInboundRoutingMethods::Init"), hr);

	//
	//	Get Fax Server Handle
	//
    HANDLE faxHandle;
	hr = pServerInner->GetHandle(&faxHandle);
    ATLASSERT(SUCCEEDED(hr));

	if (faxHandle == NULL)
	{
		//
		//	Fax Server is not connected
		//
		hr = Fax_HRESULT_FROM_WIN32(ERROR_NOT_CONNECTED);
		CALL_FAIL(GENERAL_ERR, _T("faxHandle == NULL"), hr);
        AtlReportError(CLSID_FaxInboundRoutingMethods, GetErrorMsgId(hr), IID_IFaxInboundRoutingMethods, hr, _Module.GetResourceInstance());
		return hr;
	}

    //
    //  Bring from the Server all Inbound Routing Methods
    //
    DWORD       dwNum = 0;
    CFaxPtr<FAX_GLOBAL_ROUTING_INFO>    pMethods;
    if (!FaxEnumGlobalRoutingInfo(faxHandle, &pMethods, &dwNum))
    {
		hr = Fax_HRESULT_FROM_WIN32(GetLastError());
		CALL_FAIL(GENERAL_ERR, _T("FaxEnumGlobalRoutingInfo(faxHandle, &pMethods, &dwNum)"), hr);
        AtlReportError(CLSID_FaxInboundRoutingMethods, GetErrorMsgId(hr), IID_IFaxInboundRoutingMethods, hr, _Module.GetResourceInstance());
		return hr;
    }

    //
    //  Fill the Collection with Objects
    //
    CComObject<CFaxInboundRoutingMethod>    *pClass = NULL;
    CComPtr<IFaxInboundRoutingMethod>       pObject = NULL;
    for (DWORD i=0 ; i<dwNum ; i++ )
    {
        //
        //  Create IR Method Object
        //
        hr = CComObject<CFaxInboundRoutingMethod>::CreateInstance(&pClass);
        if (FAILED(hr) || (!pClass))
        {
            if (!pClass)
            {
                hr = E_OUTOFMEMORY;
    		    CALL_FAIL(MEM_ERR, _T("CComObject<CFaxInboundRoutingMethod>::CreateInstance(&pClass)"), hr);
            }
            else
            {
    		    CALL_FAIL(GENERAL_ERR, _T("CComObject<CFaxInboundRoutingMethod>::CreateInstance(&pClass)"), hr);
            }

            AtlReportError(CLSID_FaxInboundRoutingMethods, GetErrorMsgId(hr), IID_IFaxInboundRoutingMethods, hr, _Module.GetResourceInstance());
		    return hr;
        }

        //
        //  Init the IR Method Object
        //
        hr = pClass->Init(&pMethods[i], pServerInner);
        if (FAILED(hr))
        {
            CALL_FAIL(GENERAL_ERR, _T("pClass->Init(&pMethods[i], pServerInner)"), hr);
            AtlReportError(CLSID_FaxInboundRoutingMethods, GetErrorMsgId(hr), IID_IFaxInboundRoutingMethods, hr, _Module.GetResourceInstance());
            delete pClass;
            return hr;
        }

        //
        //  Get Interface from the pClass.
        //  This will make AddRef() on the Interface. 
        //  This is the Collection's AddRef, which is freed at Collection's Dtor.
        //
        hr = pClass->QueryInterface(&pObject);
        if (FAILED(hr) || (!pObject))
        {
            if (!pObject)
            {
                hr = E_FAIL;
            }
            CALL_FAIL(GENERAL_ERR, _T("pClass->QueryInterface(&pObject)"), hr);
            AtlReportError(CLSID_FaxInboundRoutingMethods, GetErrorMsgId(hr), IID_IFaxInboundRoutingMethods, hr, _Module.GetResourceInstance());
            delete pClass;
            return hr;
        }

	    //
	    //	Put the Object in the collection
	    //
	    try 
	    {
		    m_coll.push_back(pObject);
	    }
	    catch (exception &)
	    {
		    hr = E_OUTOFMEMORY;
            AtlReportError(CLSID_FaxInboundRoutingMethods, IDS_ERROR_OUTOFMEMORY, IID_IFaxInboundRoutingMethods, hr, _Module.GetResourceInstance());
		    CALL_FAIL(MEM_ERR, _T("m_coll.push_back(pObject)"), hr);

            //
            //  pObject will call Release(), which will delete the pClass
            //
		    return hr;
	    }

        //
        //  We want to save the current AddRef() to Collection
        //
        pObject.Detach();
    }

    return hr;
}

//
//============================= GET ITEM =========================================
//
STDMETHODIMP
CFaxInboundRoutingMethods::get_Item(
    /*[in]*/ VARIANT vIndex, 
    /*[out, retval]*/ IFaxInboundRoutingMethod **ppMethod
)
/*++

Routine name : CFaxInboundRoutingMethods::get_Item

Routine description:

	Return an Item from the Collection.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	vIndex                        [in]    - Identifier of the Item to return.
	ppMethod                      [out]    - the result value

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxInboundRoutingMethods::get_Item"), hr);

    //
    //  Check the Ptr we have got
    //
    if (::IsBadWritePtr(ppMethod, sizeof(IFaxInboundRoutingMethod *)))
    {
        hr = E_POINTER;
        AtlReportError(CLSID_FaxInboundRoutingMethods, IDS_ERROR_INVALID_ARGUMENT, IID_IFaxInboundRoutingMethods, hr, _Module.GetResourceInstance());
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr(ppMethod)"), hr);
		return hr;
    }

    CComVariant var;

    if (vIndex.vt != VT_BSTR)
    {
        //
        //  vIndex is not BSTR ==> convert to VT_I4
        //
        hr = var.ChangeType(VT_I4, &vIndex);
        if (SUCCEEDED(hr))
        {
            VERBOSE(DBG_MSG, _T("Parameter is Number : %d"), var.lVal);
            //
            //  call default ATL's implementation
            //
            hr = ICollectionOnSTLImpl<IFaxInboundRoutingMethods, ContainerType, 
                IFaxInboundRoutingMethod*, CollectionCopyType, EnumType>::get_Item(var.lVal, ppMethod);
            return hr;
		}
    }

    //
    //  convert to BSTR
    //
    hr = var.ChangeType(VT_BSTR, &vIndex);
    if (FAILED(hr))
    {
        hr = E_INVALIDARG;
        AtlReportError(CLSID_FaxInboundRoutingMethods, IDS_ERROR_INVALID_ARGUMENT, IID_IFaxInboundRoutingMethods, hr, _Module.GetResourceInstance());
        CALL_FAIL(GENERAL_ERR, _T("var.ChangeType(VT_BSTR, &vIndex)"), hr);
        return hr;
    }

    VERBOSE(DBG_MSG, _T("Parameter is String : %s"), var.bstrVal);

    ContainerType::iterator it = m_coll.begin();
    while (it != m_coll.end())
    {
        CComBSTR    bstrGUID;
        hr = (*it)->get_GUID(&bstrGUID);
        if (FAILED(hr))
        {
		    CALL_FAIL(GENERAL_ERR, _T("(*it)->get_GUID(&bstrGUID)"), hr);
            AtlReportError(CLSID_FaxInboundRoutingMethods, GetErrorMsgId(hr), IID_IFaxInboundRoutingMethods, hr, _Module.GetResourceInstance());
            return hr;
        }

        if (_tcsicmp(bstrGUID, var.bstrVal) == 0)
        {
            //
            //  found the desired Method
            //
            (*it)->AddRef();
            *ppMethod = *it;
            return hr;
        }
        it++;
    }

    //
    //  desired Method is not found
    //
	hr = E_INVALIDARG;
	CALL_FAIL(GENERAL_ERR, _T("Method Is Not Found"), hr);
	AtlReportError(CLSID_FaxInboundRoutingMethods, IDS_ERROR_INVALIDMETHODGUID, IID_IFaxInboundRoutingMethods, hr, _Module.GetResourceInstance());
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxincomingarchive.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxIncomingArchive.cpp

Abstract:

	Implementation of CFaxIncomingArchive

Author:

	Iv Garber (IvG)	Apr, 2000

Revision History:

--*/

#include "stdafx.h"
#include "FaxComEx.h"
#include "FaxIncomingArchive.h"

//
//==================== INTERFACE SUPPORT ERROR INFO =====================
//
STDMETHODIMP 
CFaxIncomingArchive::InterfaceSupportsErrorInfo(
	REFIID riid
)
/*++

Routine name : CFaxIncomingArchive::InterfaceSupportsErrorInfo

Routine description:

	ATL's implementation of Interface Support Error Info

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	riid                          [in]    - Reference of the Interface

Return Value:

    Standard HRESULT code

--*/
{
	static const IID* arr[] = 
	{
		&IID_IFaxIncomingArchive
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxincomingarchive.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxIncomingArchive.h

Abstract:

	Declaration of Fax Incoming Archive Class

Author:

	Iv Garber (IvG)	May, 2000

Revision History:

--*/

#ifndef __FAXINCOMINGARCHIVE_H_
#define __FAXINCOMINGARCHIVE_H_

#include "resource.h"       // main symbols
#include "FaxArchiveInner.h"
#include "FaxIncomingMessageIterator.h"


/////////////////////////////////////////////////////////////////////////////
// CFaxIncomingArchive
class ATL_NO_VTABLE CFaxIncomingArchive : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public ISupportErrorInfo,
	public CFaxArchiveInner<IFaxIncomingArchive, &IID_IFaxIncomingArchive, &CLSID_FaxIncomingArchive, 
		FAX_MESSAGE_FOLDER_INBOX, IFaxIncomingMessage, CFaxIncomingMessage,
		IFaxIncomingMessageIterator, CFaxIncomingMessageIterator>
{
public:
	CFaxIncomingArchive() 
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_FAXINCOMINGARCHIVE)
DECLARE_NOT_AGGREGATABLE(CFaxIncomingArchive)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxIncomingArchive)
	COM_INTERFACE_ENTRY(IFaxIncomingArchive)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY(IFaxInitInner)
END_COM_MAP()

//	Interfaces
STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

};

#endif //__FAXINCOMINGARCHIVE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxincomingjob.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxIncomingJob.h

Abstract:

	Declaration of CFaxIncomingJob Class

Author:

	Iv Garber (IvG)	May, 2000

Revision History:

--*/


#ifndef __FAXINCOMINGJOB_H_
#define __FAXINCOMINGJOB_H_

#include "resource.h"       // main symbols
#include "FaxJobInner.h"


//
//===================== FAX INCOMING JOB ================================================
//
class ATL_NO_VTABLE CFaxIncomingJob : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public ISupportErrorInfo,
	public CFaxJobInner<IFaxIncomingJob, &IID_IFaxIncomingJob, &CLSID_FaxIncomingJob>
{
public:
	CFaxIncomingJob()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_FAXINCOMINGJOB)
DECLARE_NOT_AGGREGATABLE(CFaxIncomingJob)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxIncomingJob)
	COM_INTERFACE_ENTRY(IFaxIncomingJob)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

//  Interfaces
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

//	Internal Use
static HRESULT Create(IFaxIncomingJob **ppIncomingJob);
};

#endif //__FAXINCOMINGJOB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxincomingjobs.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxIncomingJobs.h

Abstract:

	Definition of Fax Incoming JobS Class.

Author:

	Iv Garber (IvG)	May, 2000

Revision History:

--*/

#ifndef __FAXINCOMINGJOBS_H_
#define __FAXINCOMINGJOBS_H_

#include "resource.h"       // main symbols

#include <vector>
#include "FaxIncomingJob.h"
#include "FaxJobsCollection.h"


namespace IncomingJobsNamespace
{

	// Jobs stored in array, pointers to them - in vector
	typedef	std::vector<IFaxIncomingJob*>	ContainerType;

	// The collection interface exposes the data as Incoming Job objects
	typedef	IFaxIncomingJob     CollectionExposedType;
	typedef IFaxIncomingJobs	CollectionIfc;

	// Use IEnumVARIANT as the enumerator for VB compatibility
	typedef	VARIANT				EnumExposedType;
	typedef	IEnumVARIANT		EnumIfc;

	// Typedef the copy classes using existing typedefs
    typedef VCUE::CopyIfc2Variant<ContainerType::value_type>    EnumCopyType;
    typedef VCUE::CopyIfc<IFaxIncomingJob*>    CollectionCopyType;

    typedef CComEnumOnSTL< EnumIfc, &__uuidof(EnumIfc), 
		EnumExposedType, EnumCopyType, ContainerType >    EnumType;

    typedef JobCollection< CollectionIfc, ContainerType, CollectionExposedType, CollectionCopyType, 
        EnumType, CFaxIncomingJob, &IID_IFaxIncomingJobs, &CLSID_FaxIncomingJobs >    CollectionType;
};

using namespace IncomingJobsNamespace;

//
//==================== CFaxIncomingJobs ==========================================
//
class ATL_NO_VTABLE CFaxIncomingJobs : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public ISupportErrorInfo,
    public IDispatchImpl<IncomingJobsNamespace::CollectionType, &IID_IFaxIncomingJobs, &LIBID_FAXCOMEXLib>
{
public:
	CFaxIncomingJobs()
	{
        DBG_ENTER(_T("FAX INCOMING JOBS::CREATE"));
	}

DECLARE_REGISTRY_RESOURCEID(IDR_FAXINCOMINGJOBS)
DECLARE_NOT_AGGREGATABLE(CFaxIncomingJobs)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxIncomingJobs)
	COM_INTERFACE_ENTRY(IFaxIncomingJobs)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

//  Interfaces
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

//  Internal Use
	static HRESULT Create(IFaxIncomingJobs **ppIncomingJobs);
};

#endif //__FAXINCOMINGJOBS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxincomingmessage.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxIncomingMessage.h

Abstract:

	Definition of CFaxIncomingMessage Class.

Author:

	Iv Garber (IvG)	May, 2000

Revision History:

--*/

#ifndef __FAXINCOMINGMESSAGE_H_
#define __FAXINCOMINGMESSAGE_H_

#include "resource.h"       // main symbols
#include "FaxMessageInner.h"

//
//=============== FAX INCOMING MESSAGE =============================================
//
class ATL_NO_VTABLE CFaxIncomingMessage : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public ISupportErrorInfo,
	public CFaxMessageInner<IFaxIncomingMessage, &IID_IFaxIncomingMessage, 
		&CLSID_FaxIncomingMessage, FAX_MESSAGE_FOLDER_INBOX>
{
public:
	CFaxIncomingMessage()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_FAXINCOMINGMESSAGE)
DECLARE_NOT_AGGREGATABLE(CFaxIncomingMessage)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxIncomingMessage)
	COM_INTERFACE_ENTRY(IFaxIncomingMessage)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

//	Interfaces
STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

//	Internal Use
static HRESULT Create(IFaxIncomingMessage **ppIncomingMessage);
};

#endif //__FAXINCOMINGMESSAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxincomingjob.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxIncomingJob.cpp

Abstract:

	Implementation of CFaxIncomingJob Class

Author:

	Iv Garber (IvG)	May, 2000

Revision History:

--*/

#include "stdafx.h"
#include "FaxComEx.h"
#include "FaxIncomingJob.h"

//
//==================== INTERFACE SUPPORT ERROR INFO ========================
//
STDMETHODIMP CFaxIncomingJob::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IFaxIncomingJob
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

//
//==================== CREATE ========================================
//
HRESULT 
CFaxIncomingJob::Create (
	IFaxIncomingJob **ppIncomingJob
)
/*++

Routine name : CFaxIncomingJob::Create

Routine description:

	Static function to create the Fax Inbound Message Instance

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	ppIncomingJob             [out]  -- the new Fax Inbound Message Instance

Return Value:

    Standard HRESULT code

--*/

{
	CComObject<CFaxIncomingJob>		*pClass;
	HRESULT								hr = S_OK;

	DBG_ENTER (TEXT("CFaxIncomingJob::Create"), hr);

	hr = CComObject<CFaxIncomingJob>::CreateInstance(&pClass);
	if (FAILED(hr))
	{
		//
		//	Failed to create Instance
		//
		CALL_FAIL(GENERAL_ERR, _T("CComObject<CFaxIncomingJob>::CreateInstance()"), hr);
		return hr;
	}

	hr = pClass->QueryInterface(__uuidof(IFaxIncomingJob), (void **) ppIncomingJob);
	if (FAILED(hr))
	{
		//
		//	Failed to Query Fax Inbound Message Interface
		//
		CALL_FAIL(GENERAL_ERR, _T("QueryInterface()"), hr);
		return hr;
	}

	return hr;
}	//	CFaxIncomingJob::Create()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxincomingjobs.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxIncomingJobs.cpp

Abstract:

	Implementation of CFaxIncomingJobs Class.

Author:

	Iv Garber (IvG)	May, 2000

Revision History:

--*/

#include "stdafx.h"
#include "FaxComEx.h"
#include "FaxIncomingJobs.h"

//
//==================== CREATE ========================================
//
HRESULT 
CFaxIncomingJobs::Create (
	IFaxIncomingJobs **ppIncomingJobs
)
/*++

Routine name : CFaxIncomingJobs::Create

Routine description:

	Static function to create the Fax IncomingJobs Object

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	ppIncomingJobs		[out]  -- the new Fax IncomingJobs Object

Return Value:

    Standard HRESULT code

--*/

{
	HRESULT	        					hr = S_OK;

	DBG_ENTER (TEXT("CFaxIncomingJobs::Create"), hr);

	CComObject<CFaxIncomingJobs>		*pClass;
	hr = CComObject<CFaxIncomingJobs>::CreateInstance(&pClass);
	if (FAILED(hr))
	{
		//
		//	Failed to create Instance
		//
		CALL_FAIL(GENERAL_ERR, _T("CComObject<CFaxIncomingJobs>::CreateInstance()"), hr);
		return hr;
	}

	hr = pClass->QueryInterface(__uuidof(IFaxIncomingJobs), (void **) ppIncomingJobs);
	if (FAILED(hr))
	{
		//
		//	Failed to Query Fax IncomingJobs Interface
		//
		CALL_FAIL(GENERAL_ERR, _T("QueryInterface()"), hr);
		return hr;
	}

	return hr;
}	//	CFaxIncomingJobs::Create()

//
//======================== SUPPORT ERROR INFO ====================================
//
STDMETHODIMP CFaxIncomingJobs::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IFaxIncomingJobs
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxincomingmessageiterator.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxIncomingMessageIterator.cpp

Abstract:

	Implementation of Incoming Message Iterator Class.

Author:

	Iv Garber (IvG)	May, 2000

Revision History:

--*/

#include "stdafx.h"
#include "FaxComEx.h"
#include "FaxIncomingMessageIterator.h"
#include "FaxIncomingMessage.h"


//
//========================== SUPPORT ERROR INFO ===============================
//
STDMETHODIMP 
CFaxIncomingMessageIterator::InterfaceSupportsErrorInfo(
	REFIID riid
)
/*++

Routine name : CFaxIncomingMessageIterator::InterfaceSupportsErrorInfo

Routine description:

	ATL's support Error Info.

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	riid                          [in]    - IID of the Interface

Return Value:

    Standard HRESULT code

--*/
{
	static const IID* arr[] = 
	{
		&IID_IFaxIncomingMessageIterator
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

//
//==================== CREATE ========================================
//
HRESULT 
CFaxIncomingMessageIterator::Create (
	IFaxIncomingMessageIterator **pIncomingMsgIterator
)
/*++

Routine name : CFaxIncomingMessageIterator::Create

Routine description:

	Static function to create the Fax Incoming Message Iterator Object

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	pIncomingMsgIterator		[out]  -- the new Fax Incoming Message Iterator Object

Return Value:

    Standard HRESULT code

--*/

{
	CComObject<CFaxIncomingMessageIterator>		*pClass;
	HRESULT			hr = S_OK;

	DBG_ENTER (TEXT("CFaxIncomingMessageIterator::Create"), hr);

	hr = CComObject<CFaxIncomingMessageIterator>::CreateInstance(&pClass);
	if (FAILED(hr))
	{
		//
		//	Failed to create Instance
		//
		CALL_FAIL(GENERAL_ERR, _T("CComObject<CFaxIncomingMessageIterator>::CreateInstance()"), hr);
		return hr;
	}

	hr = pClass->QueryInterface(__uuidof(IFaxIncomingMessageIterator), (void **) pIncomingMsgIterator);
	if (FAILED(hr))
	{
		//
		//	Failed to Query Fax Incoming Message Iterator Interface
		//
		CALL_FAIL(GENERAL_ERR, _T("QueryInterface()"), hr);
		return hr;
	}
	return hr;
}	//	CFaxIncomingMessageIterator::Create()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxincomingmessageiterator.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxIncomingMessageIterator.h

Abstract:

	Definition of Incoming Message Iterator.

Author:

	Iv Garber (IvG)	May, 2000

Revision History:

--*/

#ifndef __FAXINCOMINGMESSAGEITERATOR_H_
#define __FAXINCOMINGMESSAGEITERATOR_H_

#include "resource.h"       // main symbols
#include "FaxIncomingMessage.h"
#include "FaxMessageIteratorInner.h"


//
//====================== INCOMING MESSAGE ITERATOR =======================================
//
class ATL_NO_VTABLE CFaxIncomingMessageIterator : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public ISupportErrorInfo,
	public CFaxMessageIteratorInner<IFaxIncomingMessageIterator, 
		&IID_IFaxIncomingMessageIterator, &CLSID_FaxIncomingMessageIterator, 
		FAX_MESSAGE_FOLDER_INBOX,
		IFaxIncomingMessage, CFaxIncomingMessage>
{
public:
	CFaxIncomingMessageIterator()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_FAXINCOMINGMESSAGEITERATOR)
DECLARE_NOT_AGGREGATABLE(CFaxIncomingMessageIterator)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxIncomingMessageIterator)
	COM_INTERFACE_ENTRY(IFaxIncomingMessageIterator)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY(IFaxInitInner)
END_COM_MAP()

//	Interfaces
STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

//	Internal Use
static HRESULT Create(IFaxIncomingMessageIterator **pIncomingMsgIterator);

};

#endif //__FAXINCOMINGMESSAGEITERATOR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxincomingqueue.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxIncomingQueue.cpp

Abstract:

	Implementation of CFaxIncomingQueue

Author:

	Iv Garber (IvG)	Apr, 2000

Revision History:

--*/

#include "stdafx.h"
#include "FaxComEx.h"
#include "FaxIncomingQueue.h"


//
//==================== INTERFACE SUPPORT ERROR INFO =====================
//
STDMETHODIMP 
CFaxIncomingQueue::InterfaceSupportsErrorInfo(
	REFIID riid
)
/*++

Routine name : CFaxIncomingQueue::InterfaceSupportsErrorInfo

Routine description:

	ATL's implementation of Interface Support Error Info

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	riid                          [in]    - Reference of the Interface

Return Value:

    Standard HRESULT code

--*/
{
	static const IID* arr[] = 
	{
		&IID_IFaxIncomingQueue
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxincomingmessage.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxIncomingMessage.cpp

Abstract:

	Implementation of Fax Inbound Message COM Object

Author:

	Iv Garber (IvG)	May, 2000

Revision History:

--*/

#include "stdafx.h"
#include "FaxComEx.h"
#include "FaxIncomingMessage.h"

//
//=================== SUPPORT ERROR INFO =======================================
//
STDMETHODIMP 
CFaxIncomingMessage::InterfaceSupportsErrorInfo(
	REFIID riid
)
{
	static const IID* arr[] = 
	{
		&IID_IFaxIncomingMessage
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

//
//==================== CREATE ========================================
//
HRESULT 
CFaxIncomingMessage::Create (
	IFaxIncomingMessage **ppIncomingMessage
)
/*++

Routine name : CFaxIncomingMessage::Create

Routine description:

	Static function to create the Fax Inbound Message Instance

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	ppIncomingMessage             [out]  -- the new Fax Inbound Message Instance

Return Value:

    Standard HRESULT code

--*/

{
	CComObject<CFaxIncomingMessage>		*pClass;
	HRESULT								hr = S_OK;

	DBG_ENTER (TEXT("CFaxIncomingMessage::Create"), hr);

	hr = CComObject<CFaxIncomingMessage>::CreateInstance(&pClass);
	if (FAILED(hr))
	{
		//
		//	Failed to create Instance
		//
		CALL_FAIL(GENERAL_ERR, _T("CComObject<CFaxIncomingMessage>::CreateInstance()"), hr);
		return hr;
	}

	hr = pClass->QueryInterface(__uuidof(IFaxIncomingMessage),
		(void **) ppIncomingMessage);
	if (FAILED(hr))
	{
		//
		//	Failed to Query Fax Inbound Message Interface
		//
		CALL_FAIL(GENERAL_ERR, _T("QueryInterface()"), hr);
		return hr;
	}

	return hr;
}	//	CFaxIncomingMessage::Create()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxincomingqueue.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	faxincomingqueue.h

Abstract:

	Declaration of the CFaxIncomingQueue Class.

Author:

	Iv Garber (IvG)	Jun, 2000

Revision History:

--*/


#ifndef __FAXINCOMINGQUEUE_H_
#define __FAXINCOMINGQUEUE_H_

#include "resource.h"       // main symbols
#include "FaxQueueInner.h"
#include "FaxIncomingJob.h"
#include "FaxIncomingJobs.h"


//
//==================== FAX INCOMING QUEUE ========================================
//
class ATL_NO_VTABLE CFaxIncomingQueue : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public ISupportErrorInfo,
	public CFaxQueueInner<IFaxIncomingQueue, &IID_IFaxIncomingQueue, &CLSID_FaxIncomingQueue, true,
		IFaxIncomingJob, CFaxIncomingJob, IFaxIncomingJobs, CFaxIncomingJobs>
{
public:
	CFaxIncomingQueue()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_FAXINCOMINGQUEUE)
DECLARE_NOT_AGGREGATABLE(CFaxIncomingQueue)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxIncomingQueue)
	COM_INTERFACE_ENTRY(IFaxIncomingQueue)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY(IFaxInitInner)
END_COM_MAP()

//	Interfaces
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
};

#endif //__FAXINCOMINGQUEUE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxlocalptr.h ===
#ifndef __FAXLOCALPTR_H_
#define __FAXLOCALPTR_H_

#include "FaxCommon.h"
#include "faxutil.h"


//
//================== FAX SMART PTR -- LOCAL VERSION ==================================
//
template <typename T>
class CFaxPtrLocal : public CFaxPtrBase<T>
{
protected:
	virtual void Free()
	{
        DBG_ENTER(_T("CFaxPtrLocal::Free()"), _T("PTR:%ld"), p);
		if (p)
		{
			MemFree(p);
            p = NULL;
		}
	}
public:
	virtual ~CFaxPtrLocal()
	{
        Free();
	}

	T* operator=(T* lp)
	{
        DBG_ENTER(_T("CFaxPtrLocal::operator=()"));
        return CFaxPtrBase<T>::operator=(lp);
	}
};

#endif  //  __FAXLOCALPTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxjobscollection.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxJobsCollection.h

Abstract:

	Implementation of Copy Policy Classes and Job Collection Class.

Author:

	Iv Garber (IvG)	May, 2000

Revision History:

--*/

#ifndef __FAXJOBSCOLLECTION_H_
#define __FAXJOBSCOLLECTION_H_

#include "VCUE_Copy.h"

//
//================= FAX JOB COLLECTION TEMPLATE ================================
//
template <class CollectionIfc, class ContainerType, class CollectionExposedType, class CollectionCopyType, 
         class EnumType, class JobClass, const IID* piid, const CLSID* pcid>
class JobCollection : public ICollectionOnSTLImpl<CollectionIfc, ContainerType, CollectionExposedType*, 
    CollectionCopyType, EnumType>
{
public :
    JobCollection()
    {
        DBG_ENTER(_T("JOB COLLECTION :: CREATE"));
    }
    ~JobCollection()
    {
        DBG_ENTER(_T("JOB COLLECTION :: DESTROY"));
        CCollectionKiller<ContainerType>  CKiller;
        CKiller.EmptyObjectCollection(&m_coll);
    }

//  Interfaces
    STDMETHOD(get_Item)(/*[in]*/ VARIANT vIndex, /*[out, retval]*/ CollectionExposedType **pFaxJob);

//  Internal Use
    HRESULT Init(FAX_JOB_ENTRY_EX*  pJobs, DWORD dwJobCount, IFaxServerInner *pFaxServerInner);
};

//
//============================= GET ITEM =========================================
//
template <class CollectionIfc, class ContainerType, class CollectionExposedType, 
            class CollectionCopyType, class EnumType, class JobClass, const IID* piid, 
            const CLSID* pcid>
STDMETHODIMP
JobCollection<CollectionIfc, ContainerType, CollectionExposedType, CollectionCopyType, EnumType, JobClass, 
    piid, pcid>::get_Item(
        /*[in]*/ VARIANT vIndex, 
        /*[out, retval]*/ CollectionExposedType **pFaxJob
)
/*++

Routine name : JobCollection::get_Item

Routine description:

	Return Item Job from the Collection.

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	vIndex                        [in]    - Index of the Job to find
	pFaxJob                       [out]    - the resulting Job Object

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;

    DBG_ENTER(_T("JobCollection::get_Item"), hr);

    if (::IsBadWritePtr(pFaxJob, sizeof(CollectionExposedType *)))
    {
        //
        //  Invalid Argument
        //
        hr = E_POINTER;
        AtlReportError(*pcid, IDS_ERROR_INVALID_ARGUMENT, *piid, hr, _Module.GetResourceInstance());
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr(pFaxJob)"), hr);
		return hr;
    }

    CComVariant var;

    if (vIndex.vt != VT_BSTR)
    {
        //
        //  vIndex is not BSTR ==> convert to VT_I4
        //
        hr = var.ChangeType(VT_I4, &vIndex);
        if (SUCCEEDED(hr))
        {
            VERBOSE(DBG_MSG, _T("Parameter is Number : %d"), var.lVal);
            //
            //  call default ATL's implementation
            //
            hr = ICollectionOnSTLImpl<CollectionIfc, ContainerType, CollectionExposedType*, 
                CollectionCopyType, EnumType>::get_Item(var.lVal, pFaxJob);
            return hr;
		}
    }

    //
    //  convert to BSTR
    //
    hr = var.ChangeType(VT_BSTR, &vIndex);
    if (FAILED(hr))
    {
        //
        //  Got wrong vIndex
        //
        hr = E_INVALIDARG;
        AtlReportError(*pcid, IDS_ERROR_INVALIDINDEX, *piid, hr, _Module.GetResourceInstance());
        CALL_FAIL(GENERAL_ERR, _T("var.ChangeType(VT_BSTR, &vIndex)"), hr);
        return hr;
    }

    VERBOSE(DBG_MSG, _T("Parameter is String : %s"), var.bstrVal);

    ContainerType::iterator it = m_coll.begin();
    while (it != m_coll.end())
    {
        CComBSTR    bstrMsgId;
        hr = (*it)->get_Id(&bstrMsgId);
        if (FAILED(hr))
        {
		    CALL_FAIL(GENERAL_ERR, _T("it->get_Id(&dwlMsgid)"), hr);
		    AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr, _Module.GetResourceInstance());
		    return hr;
        }

        if (_tcsicmp(bstrMsgId, var.bstrVal) == 0)
        {
            //
            //  found the desired Job
            //
            (*it)->AddRef();
            *pFaxJob = *it;
            return hr;
        }
        it++;
    }

    //
    //  Job not found
    //
	hr = E_INVALIDARG;
	CALL_FAIL(GENERAL_ERR, _T("Job Not Found"), hr);
	AtlReportError(*pcid, IDS_ERROR_INVALIDMSGID, *piid, hr, _Module.GetResourceInstance());
	return hr;
}

//
//============================= INIT =========================================
//
template <class CollectionIfc, class ContainerType, class CollectionExposedType, class CollectionCopyType, 
         class EnumType, class JobType, const IID* piid, const CLSID* pcid>
HRESULT
JobCollection<CollectionIfc, ContainerType, CollectionExposedType, CollectionCopyType, EnumType, 
    JobType, piid, pcid>::Init(
        /*[in]*/ FAX_JOB_ENTRY_EX *pJobs, 
        /*[in]*/ DWORD  dwJobCount, 
        /*[in]*/ IFaxServerInner *pFaxServerInner
)
/*++

Routine name : JobCollection::Init

Routine description:

	Fill the collection with pointers to structures

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

    pJobs                     [in]    -   ptr to array of structs
    dwJobCount                [in]    -   num of structs in the array
    pFaxServerInner           [in]    -   ptr to Fax Server object

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;

    DBG_ENTER(_T("JobCollection::Init"), hr);

    //
    //  Fill collection with data :
    //      create object for each element in structure
    //
    for ( long i = 0 ; i < dwJobCount ; i++ )
    {
        //
    	//	Create Job Object
	    //	
	    CComPtr<CollectionExposedType>   pNewJobObject;
	    hr = JobType::Create(&pNewJobObject);
	    if (FAILED(hr))
	    {
		    AtlReportError(*pcid, IDS_ERROR_OPERATION_FAILED, *piid, hr, _Module.GetResourceInstance());
		    CALL_FAIL(GENERAL_ERR, _T("JobType::Create(&pNewJobObject)"), hr);
		    return hr;
	    }

	    //
	    //	Initialize the Job Object
	    //
	    hr = ((JobType *)((CollectionExposedType *)pNewJobObject))->Init(&pJobs[i], pFaxServerInner);
	    if (FAILED(hr))
	    {
		    AtlReportError(*pcid, IDS_ERROR_OPERATION_FAILED, *piid, hr, _Module.GetResourceInstance());
		    CALL_FAIL(GENERAL_ERR, _T("pNewJobObject->Init()"), hr);
		    return hr;
	    }

	    //
	    //	Put the Object in the collection
	    //
	    try 
	    {
		    m_coll.push_back(pNewJobObject);
	    }
	    catch (exception &)
	    {
		    //
		    //	Failed to put ptr to the new Job Object in the vector
		    //
		    hr = E_OUTOFMEMORY;
		    AtlReportError(*pcid, IDS_ERROR_OUTOFMEMORY, *piid, hr, _Module.GetResourceInstance());
		    CALL_FAIL(MEM_ERR, _T("m_coll.push_back(pNewJobObject.Detach())"), hr);
		    return hr;
	    }

        pNewJobObject.Detach();
    }
    
    return hr;
}

#endif  //   __FAXJOBSCOLLECTION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxjobstatus.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    FaxJobStatus.cpp

Abstract:

    Implementation of CFaxJobStatus Class.

Author:

    Iv Garber (IvG) Jun, 2000

Revision History:

--*/

#include "stdafx.h"
#include "FaxComEx.h"
#include "FaxJobStatus.h"

//
//====================== GET JOB TYPE ===============================
//
STDMETHODIMP
CFaxJobStatus::get_JobType(
    FAX_JOB_TYPE_ENUM *pJobType
)
/*++

Routine name : CFaxJobStatus::get_JobType

Routine description:

    Return the Type of the Job

Author:

    Iv Garber (IvG),    Jul, 2000

Arguments:

    pJobType             [out]    - Return Value of Job Type

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobStatus::get_JobType"), hr);

    //
    //  Check that we can write to the given pointer
    //
    if (::IsBadWritePtr(pJobType, sizeof(FAX_JOB_TYPE_ENUM)))
    {
        //
        //  Got Bad Return Pointer
        //
        hr = E_POINTER;
        AtlReportError(CLSID_FaxJobStatus, IDS_ERROR_INVALID_ARGUMENT, IID_IFaxJobStatus, hr, _Module.GetResourceInstance());
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr"), hr);
        return hr;
    }

    *pJobType = m_JobType;
    return hr;
}

//
//====================== GET TRANSMISSION END ======================================
//
STDMETHODIMP
CFaxJobStatus::get_TransmissionEnd(
    DATE *pdateTransmissionEnd
)
/*++

Routine name : CFaxJobStatus::get_TransmissionEnd

Routine description:

    Return Job's Transmission End

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    pdateTransmissionEnd            [out]    - pointer to the place to put the value

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobStatus::get_TransmissionEnd"), hr);

    //
    //  Check that we can write to the given pointer
    //
    if (::IsBadWritePtr(pdateTransmissionEnd, sizeof(DATE)))
    {
        //
        //  Got Bad Ptr
        //
        hr = E_POINTER;
        AtlReportError(CLSID_FaxJobStatus, IDS_ERROR_INVALID_ARGUMENT, IID_IFaxJobStatus, hr, _Module.GetResourceInstance());
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr()"), hr);
        return hr;
    }

    hr = SystemTime2LocalDate(m_dtTransmissionEnd, pdateTransmissionEnd);
    if (FAILED(hr))
    {
        //
        //  Failed to convert the system time to localized variant date
        //
        AtlReportError(CLSID_FaxJobStatus, GetErrorMsgId(hr), IID_IFaxJobStatus, hr, _Module.GetResourceInstance());
        return hr;
    }

    return hr;
}

//
//========================= GET TRANSMISSION START ===============================
//
STDMETHODIMP
CFaxJobStatus::get_TransmissionStart(
    DATE *pdateTransmissionStart
)
/*++

Routine name : CFaxJobStatus::get_TransmissionStart

Routine description:

    Return Time the Job is started to transmit

Author:

    Iv Garber (IvG),    Jul, 2000

Arguments:

    pdateTransmissionStart      [out]    - pointer to place to put the Transmission Start

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobStatus::get_TransmissionStart"), hr);

    //
    //  Check that we can write to the given pointer
    //
    if (::IsBadWritePtr(pdateTransmissionStart, sizeof(DATE)))
    {
        //
        //  Got Bad Ptr
        //
        hr = E_POINTER;
        AtlReportError(CLSID_FaxJobStatus, IDS_ERROR_INVALID_ARGUMENT, IID_IFaxJobStatus, hr, _Module.GetResourceInstance());
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr()"), hr);
        return hr;
    }

    hr = SystemTime2LocalDate(m_dtTransmissionStart, pdateTransmissionStart);
    if (FAILED(hr))
    {
        //
        //  Failed to convert the system time to localized variant date
        //
        AtlReportError(CLSID_FaxJobStatus, GetErrorMsgId(hr), IID_IFaxJobStatus, hr, _Module.GetResourceInstance());
        return hr;
    }

    return hr;
}

//
//========================= GET SCHEDULED TIME ===============================
//
STDMETHODIMP
CFaxJobStatus::get_ScheduledTime(
    DATE *pdateScheduledTime
)
/*++

Routine name : CFaxJobStatus::get_ScheduledTime

Routine description:

    Return Time the Job is scheduled

Author:

    Iv Garber (IvG),    Jul, 2000

Arguments:

    pdateScheduledTime      [out]    - pointer to place to put Scheduled Time

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobStatus::get_ScheduledTime"), hr);

    //
    //  Check that we can write to the given pointer
    //
    if (::IsBadWritePtr(pdateScheduledTime, sizeof(DATE)))
    {
        //
        //  Got Bad Ptr
        //
        hr = E_POINTER;
        AtlReportError(CLSID_FaxJobStatus, IDS_ERROR_INVALID_ARGUMENT, IID_IFaxJobStatus, hr, _Module.GetResourceInstance());
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr()"), hr);
        return hr;
    }

    hr = SystemTime2LocalDate(m_dtScheduleTime, pdateScheduledTime);
    if (FAILED(hr))
    {
        //
        //  Failed to convert the system time to localized variant date
        //
        AtlReportError(CLSID_FaxJobStatus, GetErrorMsgId(hr), IID_IFaxJobStatus, hr, _Module.GetResourceInstance());
        return hr;
    }

    return hr;
}

//
//====================== GET AVAILABLE OPERATIONS ==================================
//
STDMETHODIMP
CFaxJobStatus::get_AvailableOperations(
    FAX_JOB_OPERATIONS_ENUM *pAvailableOperations
)
/*++

Routine name : CFaxJobStatus::get_AvailableOperations

Routine description:

    The operations available for the Fax Job

Author:

    Iv Garber (IvG),    Jul, 2000

Arguments:

    pAvailableOperations                 [out]    - Pointer to the place to put the Bit-Wise Combination
                                                    of Available Operations on the current Fax Job

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobStatus::get_AvailableOperations"), hr);

    //
    //  Check that we have got good Ptr
    //
    if (::IsBadWritePtr(pAvailableOperations, sizeof(FAX_JOB_OPERATIONS_ENUM)))
    {
        hr = E_POINTER;
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr(pAvailableOperations, sizeof(FAX_JOB_OPERATIONS_ENUM))"), hr);
        AtlReportError(CLSID_FaxJobStatus, GetErrorMsgId(hr), IID_IFaxJobStatus, hr, _Module.GetResourceInstance());
        return hr;
    }

    *pAvailableOperations = FAX_JOB_OPERATIONS_ENUM(m_dwAvailableOperations);
    return hr;
}

//
//====================== GET PAGES ================================================
//
STDMETHODIMP
CFaxJobStatus::get_Pages(
    long *plPages
)
/*++

Routine name : CFaxJobStatus::get_Pages

Routine description:

    Return total number of pages of the message

Author:

    Iv Garber (IvG),    Jul, 2000

Arguments:

    plPages                 [out]    - Pointer to the place to put the value

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobStatus::get_Pages"), hr);

    hr = GetLong(plPages, m_dwPageCount);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxJobStatus, GetErrorMsgId(hr), IID_IFaxJobStatus, hr, _Module.GetResourceInstance());
        return hr;
    }
    return hr;
}

//
//====================== GET CALLER ID ================================================
//
STDMETHODIMP
CFaxJobStatus::get_CallerId(
    BSTR *pbstrCallerId
)
/*++

Routine name : CFaxJobStatus::get_CallerId

Routine description:

    Return the Caller Id of Job's Phone Call

Author:

    Iv Garber (IvG),    Jul, 2000

Arguments:

    pbstrCallerId           [out]    - pointer to the place to put the Caller Id

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobStatus::get_CallerId"), hr);

    hr = GetBstr(pbstrCallerId, m_bstrCallerId);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxJobStatus, GetErrorMsgId(hr), IID_IFaxJobStatus, hr, _Module.GetResourceInstance());
        return hr;
    }
    return hr;
}

//
//====================== GET ROUTING INFORMATION ======================================
//
STDMETHODIMP
CFaxJobStatus::get_RoutingInformation(
    BSTR *pbstrRoutingInformation
)
/*++

Routine name : CFaxJobStatus::get_RoutingInformation

Routine description:

    Return the Routing Information of the Job

Author:

    Iv Garber (IvG),    Jul, 2000

Arguments:

    pbstrRoutingInformation         [out]    - pointer to place to put Routing Information

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobStatus::get_RoutingInformation"), hr);

    hr = GetBstr(pbstrRoutingInformation, m_bstrRoutingInfo);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxJobStatus, GetErrorMsgId(hr), IID_IFaxJobStatus, hr, _Module.GetResourceInstance());
        return hr;
    }
    return hr;
}

//
//====================== GET STATUS =============================================
//
HRESULT
CFaxJobStatus::get_Status(
    FAX_JOB_STATUS_ENUM *pStatus
)
/*++

Routine name : CFaxJobStatus::get_Status

Routine description:

    The current Queue Status of the Fax Job

Author:

    Iv Garber (IvG),    Jul, 2000

Arguments:

    pStatus                    [out]    - Pointer to the place to put the Bit-Wise Combination of status

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobStatus::get_Status"), hr);

    //
    //  Check that we have got good Ptr
    //
    if (::IsBadWritePtr(pStatus, sizeof(FAX_JOB_STATUS_ENUM)))
    {
        hr = E_POINTER;
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr(pStatus, sizeof(FAX_JOB_STATUS_ENUM))"), hr);
        AtlReportError(CLSID_FaxJobStatus, GetErrorMsgId(hr), IID_IFaxJobStatus, hr, _Module.GetResourceInstance());
        return hr;
    }

    *pStatus = FAX_JOB_STATUS_ENUM(m_dwQueueStatus);
    return hr;
}

//
//====================== GET EXTENDED STATUS CODE ===============================
//
STDMETHODIMP
CFaxJobStatus::get_ExtendedStatusCode(
    FAX_JOB_EXTENDED_STATUS_ENUM *pExtendedStatusCode
)
/*++

Routine name : CFaxJobStatus::get_ExtendedStatusCode

Routine description:

    The Code of the Extended Status of the Fax Job

Author:

    Iv Garber (IvG),    Jul, 2000

Arguments:

    pExtendedStatusCode             [out]    - Pointer to the place to put the status code

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobStatus::get_ExtendedStatusCode"), hr);

    //
    //  Check that we can write to the given pointer
    //
    if (::IsBadWritePtr(pExtendedStatusCode, sizeof(FAX_JOB_EXTENDED_STATUS_ENUM)))
    {
        //
        //  Got Bad Return Pointer
        //
        hr = E_POINTER;
        AtlReportError(CLSID_FaxJobStatus, IDS_ERROR_INVALID_ARGUMENT, IID_IFaxJobStatus, hr, _Module.GetResourceInstance());
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr"), hr);
        return hr;
    }

    *pExtendedStatusCode = m_ExtendedStatusCode;
    return hr;
}

//
//====================== GET RETRIES =============================================
//
STDMETHODIMP
CFaxJobStatus::get_Retries(
    long *plRetries
)
/*++

Routine name : CFaxJobStatus::get_Retries

Routine description:

    The number of unsuccessful retries of the Fax Job

Author:

    Iv Garber (IvG),    Jul, 2000

Arguments:

    plRetries                    [out]    - Pointer to the place to put the number of Retries

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobStatus::get_Retries"), hr);

    hr = GetLong(plRetries, m_dwRetries);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxJobStatus, GetErrorMsgId(hr), IID_IFaxJobStatus, hr, _Module.GetResourceInstance());
        return hr;
    }
    return hr;
}

//
//====================== GET TSID ================================================
//
STDMETHODIMP
CFaxJobStatus::get_TSID(
    BSTR *pbstrTSID
)
/*++

Routine name : CFaxJobStatus::get_TSID

Routine description:

    Return Transmitting Station ID of the Job

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    pbstrTSID             [out]    - pointer to the place to put the TSID

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobStatus::get_TSID"), hr);

    hr = GetBstr(pbstrTSID, m_bstrTSID);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxJobStatus, GetErrorMsgId(hr), IID_IFaxJobStatus, hr, _Module.GetResourceInstance());
        return hr;
    }
    return hr;
}

//
//====================== GET CSID ================================================
//
STDMETHODIMP
CFaxJobStatus::get_CSID(
    BSTR *pbstrCSID
)
/*++

Routine name : CFaxJobStatus::get_CSID

Routine description:

    Return Called Station ID of the Job

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    pbstrCSID             [out]    - pointer to the place to put the CSID

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobStatus::get_CSID"), hr);

    hr = GetBstr(pbstrCSID, m_bstrCSID);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxJobStatus, GetErrorMsgId(hr), IID_IFaxJobStatus, hr, _Module.GetResourceInstance());
        return hr;
    }
    return hr;
}

//
//====================== GET EXTENDED STATUS =======================================
//
STDMETHODIMP
CFaxJobStatus::get_ExtendedStatus(
    BSTR *pbstrExtendedStatus
)
/*++

Routine name : CFaxJobStatus::get_ExtendedStatus

Routine description:

    Return String Description of the Extended Status of the Job

Author:

    Iv Garber (IvG),    Jul, 2000

Arguments:

    pbstrExtendedStatus             [out]    - pointer to the place to put the Extended Status

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobStatus::get_ExtendedStatus"), hr);

    hr = GetBstr(pbstrExtendedStatus, m_bstrExtendedStatus);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxJobStatus, GetErrorMsgId(hr), IID_IFaxJobStatus, hr, _Module.GetResourceInstance());
        return hr;
    }
    return hr;
}

//
//====================== GET CURRENT PAGE =============================================
//
STDMETHODIMP
CFaxJobStatus::get_CurrentPage(
    long *plCurrentPage
)
/*++

Routine name : CFaxJobStatus::get_CurrentPage

Routine description:

    Current Page number being received / sent

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    plCurrentPage           [out]    - Pointer to the place to put the Current Page Number

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobStatus::get_CurrentPage"), hr);

    hr = GetLong(plCurrentPage, m_dwCurrentPage);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxJobStatus, GetErrorMsgId(hr), IID_IFaxJobStatus, hr, _Module.GetResourceInstance());
        return hr;
    }
    return hr;
}

//
//====================== GET DEVICE ID =============================================
//
STDMETHODIMP
CFaxJobStatus::get_DeviceId(
    long *plDeviceId
)
/*++

Routine name : CFaxJobStatus::get_DeviceId

Routine description:

    The Device Id by which the Job is being sent / received.

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    plDeviceId              [out]    - Pointer to the place to put the Device Id

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobStatus::get_DeviceId"), hr);

    hr = GetLong(plDeviceId, m_dwDeviceId);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxJobStatus, GetErrorMsgId(hr), IID_IFaxJobStatus, hr, _Module.GetResourceInstance());
        return hr;
    }
    return hr;
}

//
//====================== GET SIZE ================================================
//
STDMETHODIMP
CFaxJobStatus::get_Size(
    long *plSize
)
/*++

Routine name : CFaxJobStatus::get_Size

Routine description:

    Return Size ( in bytes ) of Fax Job's TIFF File

Author:

    Iv Garber (IvG),    Jul, 2000

Arguments:

    plSize                  [out]    - Pointer to the place to put Size

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobStatus::get_Size"), hr);

    hr = GetLong(plSize, m_dwSize);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxJobStatus, GetErrorMsgId(hr), IID_IFaxJobStatus, hr, _Module.GetResourceInstance());
        return hr;
    }
    return hr;
}

//
//==================== INIT ===================================================
//
HRESULT
CFaxJobStatus::Init(
    FAX_JOB_STATUS *pJobStatus
)
/*++

Routine name : CFaxJobStatus::Init

Routine description:

    Initialize the Job Status Class with the data from FAX_JOB_STATUS struct

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    pJobStatus                  [in]    - Job Info

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobStatus::Init"), hr);

    ATLASSERT(pJobStatus);

    //
    //  dwQueueStatus cannot contain JS_DELETING value
    //
    ATLASSERT(0 == (pJobStatus->dwQueueStatus & JS_DELETING));

    //
    //  Set Job Type
    //
    switch(pJobStatus->dwJobType)
    {
    case JT_SEND:
        m_JobType = fjtSEND;
        break;

    case JT_RECEIVE:
        m_JobType = fjtRECEIVE;
        break;

    case JT_ROUTING:
        m_JobType = fjtROUTING;
        break;

    default:
        CALL_FAIL(GENERAL_ERR, 
            _T("CFaxJobStatus::Init() got unknown/unsupported Job Type : %ld"), 
            pJobStatus->dwJobType);

        //
        //  This is assert false
        //
        ATLASSERT(pJobStatus->dwJobType == JT_RECEIVE);

        AtlReportError(CLSID_FaxJobStatus, 
            IDS_ERROR_INVALID_ARGUMENT, 
            IID_IFaxJobStatus, 
            hr, 
            _Module.GetResourceInstance());
        hr = E_INVALIDARG;
        return hr;
    }

    m_dwSize = pJobStatus->dwSize;
    m_dwJobId = pJobStatus->dwJobID;
    m_dwRetries = pJobStatus->dwRetries;
    m_dwDeviceId = pJobStatus->dwDeviceID;
    m_dwPageCount = pJobStatus->dwPageCount;
    m_dwCurrentPage = pJobStatus->dwCurrentPage;
    m_dwQueueStatus = pJobStatus->dwQueueStatus;
    m_dwAvailableOperations = pJobStatus->dwAvailableJobOperations;
    m_ExtendedStatusCode = FAX_JOB_EXTENDED_STATUS_ENUM(pJobStatus->dwExtendedStatus);

    m_dtScheduleTime = pJobStatus->tmScheduleTime;
    m_dtTransmissionEnd = pJobStatus->tmTransmissionEndTime;
    m_dtTransmissionStart = pJobStatus->tmTransmissionStartTime;

    m_bstrTSID = pJobStatus->lpctstrTsid;
    m_bstrCSID = pJobStatus->lpctstrCsid;
    m_bstrExtendedStatus = pJobStatus->lpctstrExtendedStatus;
    m_bstrRoutingInfo = pJobStatus->lpctstrRoutingInfo;
    m_bstrCallerId = pJobStatus->lpctstrCallerID;
    if ( ((pJobStatus->lpctstrTsid) && !m_bstrTSID) ||
         ((pJobStatus->lpctstrCsid) && !m_bstrCSID) ||
         ((pJobStatus->lpctstrRoutingInfo) && !m_bstrRoutingInfo) ||
         ((pJobStatus->lpctstrExtendedStatus) && !m_bstrExtendedStatus) ||
         ((pJobStatus->lpctstrCallerID) && !m_bstrCallerId) )
    {
        //
        //  Not enough memory to copy the TSID into CComBSTR
        //
        hr = E_OUTOFMEMORY;
        AtlReportError(CLSID_FaxJobStatus, IDS_ERROR_OUTOFMEMORY, IID_IFaxJobStatus, hr, _Module.GetResourceInstance());
        CALL_FAIL(MEM_ERR, _T("CComBSTR::operator=()"), hr);
        return hr;
    }

    return hr;
}

//
//======================= SUPPORT ERROR INFO ==================================
//
STDMETHODIMP
CFaxJobStatus::InterfaceSupportsErrorInfo(
    REFIID riid
)
/*++

Routine name : CFaxJobStatus::InterfaceSupportsErrorInfo

Routine description:

    ATL's implementation of Support Error Info.

Author:

    Iv Garber (IvG),    Jul, 2000

Arguments:

    riid                          [in]    - reference to the ifc to check.

Return Value:

    Standard HRESULT code

--*/
{
    static const IID* arr[] =
    {
        &IID_IFaxJobStatus
    };
    for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
    {
        if (InlineIsEqualGUID(*arr[i],riid))
            return S_OK;
    }
    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxjobstatus.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxJobStatus.h

Abstract:

	Declaration of the CFaxJobStatus Class.

Author:

	Iv Garber (IvG)	Jun, 2000

Revision History:

--*/

#ifndef __FAXJOBSTATUS_H_
#define __FAXJOBSTATUS_H_

#include "resource.h"       // main symbols
#include "FaxCommon.h"

// 
//==================== JOB STATUS ==========================================
//
class ATL_NO_VTABLE CFaxJobStatus : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public ISupportErrorInfo,
	public IDispatchImpl<IFaxJobStatus, &IID_IFaxJobStatus, &LIBID_FAXCOMEXLib>
{
public:
    CFaxJobStatus()
	{
        DBG_ENTER(_T("FAX JOB STATUS -- CREATE"));
	}

    ~CFaxJobStatus()
	{
        DBG_ENTER(_T("FAX JOB STATUS -- DESTROY"));
	}
DECLARE_REGISTRY_RESOURCEID(IDR_FAXJOBSTATUS)
DECLARE_NOT_AGGREGATABLE(CFaxJobStatus)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxJobStatus)
	COM_INTERFACE_ENTRY(IFaxJobStatus)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

//  Interfaces
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

    STDMETHOD(get_Size)(/*[out, retval]*/ long *plSize);
    STDMETHOD(get_Pages)(/*[out, retval]*/ long *plPages);
    STDMETHOD(get_TSID)(/*[out, retval]*/ BSTR *pbstrTSID);
    STDMETHOD(get_CSID)(/*[out, retval]*/ BSTR *pbstrCSID);
    STDMETHOD(get_Retries)(/*[out, retval]*/ long *plRetries);
    STDMETHOD(get_DeviceId)(/*[out, retval]*/ long *plDeviceId);
    STDMETHOD(get_CallerId)(/*[out, retval]*/ BSTR *pbstrCallerId);
    STDMETHOD(get_CurrentPage)(/*[out, retval]*/ long *plCurrentPage);
    STDMETHOD(get_Status)(/*[out, retval]*/ FAX_JOB_STATUS_ENUM *pStatus);
    STDMETHOD(get_JobType)(/*[out, retval]*/ FAX_JOB_TYPE_ENUM *pJobType);
    STDMETHOD(get_ScheduledTime)(/*[out, retval]*/ DATE *pdateScheduledTime);
    STDMETHOD(get_ExtendedStatus)(/*[out, retval]*/ BSTR *pbstrExtendedStatus);
    STDMETHOD(get_TransmissionEnd)(/*[out, retval]*/ DATE *pdateTransmissionEnd);
    STDMETHOD(get_TransmissionStart)(/*[out, retval]*/ DATE *pdateTransmissionStart);
    STDMETHOD(get_RoutingInformation)(/*[out, retval]*/ BSTR *pbstrRoutingInformation);
    STDMETHOD(get_AvailableOperations)(/*[out, retval]*/ FAX_JOB_OPERATIONS_ENUM *pAvailableOperations);
    STDMETHOD(get_ExtendedStatusCode)(/*[out, retval]*/ FAX_JOB_EXTENDED_STATUS_ENUM *pExtendedStatusCode);

//  Internal Use
    HRESULT Init(FAX_JOB_STATUS *pJobStatus);
    DWORD   GetJobId(void) { return m_dwJobId; };

private:
    DWORD       m_dwSize;
    DWORD       m_dwJobId;
    DWORD       m_dwRetries;
    DWORD       m_dwDeviceId;
    DWORD       m_dwPageCount;
    DWORD       m_dwCurrentPage;
    DWORD       m_dwQueueStatus;
    DWORD       m_dwAvailableOperations;

    CComBSTR    m_bstrTSID;
    CComBSTR    m_bstrCSID;
    CComBSTR    m_bstrCallerId;
    CComBSTR    m_bstrRoutingInfo;
    CComBSTR    m_bstrExtendedStatus;

    SYSTEMTIME  m_dtScheduleTime;
    SYSTEMTIME  m_dtTransmissionEnd;
    SYSTEMTIME  m_dtTransmissionStart;

    FAX_JOB_TYPE_ENUM               m_JobType;
    FAX_JOB_EXTENDED_STATUS_ENUM    m_ExtendedStatusCode;
};

#endif //__FAXJOBSTATUS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxjobinner.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    FaxJobInner.h

Abstract:

    Implementation of Fax Job Inner Class : 
        Base Class for Inbound and Outbound Job Classes.

Author:

    Iv Garber (IvG) May, 2000

Revision History:

--*/


#ifndef __FAXJOBINNER_H_
#define __FAXJOBINNER_H_

#include "FaxJobStatus.h"
#include "FaxSender.h"

//
//===================== FAX JOB INNER CLASS ===============================
//
template<class T, const IID* piid, const CLSID* pcid> 
class CFaxJobInner : 
    public IDispatchImpl<T, piid, &LIBID_FAXCOMEXLib>,
    public CFaxInitInnerAddRef
{
public:
    CFaxJobInner() : CFaxInitInnerAddRef(_T("FAX JOB INNER"))
    {
        m_pSender = NULL;
        m_pRecipient = NULL;
    };

    ~CFaxJobInner()
    {
        if (m_pSender)
        {
            m_pSender->Release();
        }
        if (m_pRecipient)
        {
            m_pRecipient->Release();
        }
    };

    STDMETHOD(Init)(PFAX_JOB_ENTRY_EX pFaxJob, IFaxServerInner *pServer);

//  common for both Jobs
	STDMETHOD(Cancel)();
	STDMETHOD(Refresh)();
	STDMETHOD(CopyTiff)(BSTR bstrTiffPath);
    STDMETHOD(get_Id)(/*[out, retval]*/ BSTR *pbstrId);
    STDMETHOD(get_Size)(/*[out, retval]*/ long *plSize);
	STDMETHOD(get_CSID)(/*[out, retval]*/ BSTR *pbstrCSID);
	STDMETHOD(get_TSID)(/*[out, retval]*/ BSTR *pbstrTSID);
	STDMETHOD(get_Retries)(/*[out, retval]*/ long *plRetries);
	STDMETHOD(get_DeviceId)(/*[out, retval]*/ long *plDeviceId);
	STDMETHOD(get_CurrentPage)(/*[out, retval]*/ long *plCurrentPage);
	STDMETHOD(get_Status)(/*[out, retval]*/ FAX_JOB_STATUS_ENUM *pStatus);
	STDMETHOD(get_ExtendedStatus)(/*[out, retval]*/ BSTR *pbstrExtendedStatus);
	STDMETHOD(get_TransmissionEnd)(/*[out, retval]*/ DATE *pdateTransmissionEnd);
	STDMETHOD(get_TransmissionStart)(/*[out, retval]*/ DATE *pdateTransmissionStart);
	STDMETHOD(get_ExtendedStatusCode)(FAX_JOB_EXTENDED_STATUS_ENUM *pExtendedStatusCode);
	STDMETHOD(get_AvailableOperations)(/*[out, retval]*/ FAX_JOB_OPERATIONS_ENUM *pAvailableOperations);

//  specific for Outbound Job
	STDMETHOD(Pause)();
	STDMETHOD(Resume)();
	STDMETHOD(Restart)();
	STDMETHOD(get_Sender)(IFaxSender **ppFaxSender);
	STDMETHOD(get_Pages)(/*[out, retval]*/ long *plPages);
	STDMETHOD(get_Recipient)(IFaxRecipient **ppFaxRecipient);
	STDMETHOD(get_Subject)(/*[out, retval]*/ BSTR *pbstrSubject);
	STDMETHOD(get_ReceiptType)(FAX_RECEIPT_TYPE_ENUM *pReceiptType);
	STDMETHOD(get_DocumentName)(/*[out, retval]*/ BSTR *pbstrDocumentName);
    STDMETHOD(get_SubmissionId)(/*[out, retval] */BSTR *pbstrSubmissionId);
	STDMETHOD(get_OriginalScheduledTime)(DATE *pdateOriginalScheduledTime);
	STDMETHOD(get_ScheduledTime)(/*[out, retval]*/ DATE *pdateScheduledTime);
	STDMETHOD(get_SubmissionTime)(/*[out, retval]*/ DATE *pdateSubmissionTime);
	STDMETHOD(get_Priority)(/*[out, retval]*/ FAX_PRIORITY_TYPE_ENUM *pPriority);
    STDMETHOD(get_GroupBroadcastReceipts)(VARIANT_BOOL *pbGroupBroadcastReceipts);

// specific for Inbound Job
    STDMETHOD(get_CallerId)(/*[out, retval]*/ BSTR *pbstrCallerId);
    STDMETHOD(get_JobType)(/*[out, retval]*/ FAX_JOB_TYPE_ENUM *pJobType);
	STDMETHOD(get_RoutingInformation)(/*[out, retval]*/ BSTR *pbstrRoutingInformation);

private:

    DWORDLONG   m_dwlMessageId;
    DWORDLONG   m_dwlBroadcastId;
    DWORD       m_dwReceiptType;
    CComBSTR    m_bstrSubject;
    CComBSTR    m_bstrDocumentName;
    SYSTEMTIME  m_tmOriginalScheduleTime;
    SYSTEMTIME  m_tmSubmissionTime;
    FAX_PRIORITY_TYPE_ENUM      m_Priority;

    CComObject<CFaxJobStatus>   m_JobStatus;
    CComObject<CFaxSender>      *m_pSender;
    CComObject<CFaxRecipient>   *m_pRecipient;

    STDMETHOD(UpdateJob)(FAX_ENUM_JOB_COMMANDS cmdToPerform);
};

//
//====================== GET JOB TYPE ===============================
//
template<class T, const IID* piid, const CLSID* pcid> 
STDMETHODIMP 
CFaxJobInner<T, piid, pcid>::get_JobType(
    FAX_JOB_TYPE_ENUM *pJobType
)
/*++

Routine name : CFaxJobInner::get_JobType

Routine description:

    Return the Type of the Job

Author:

    Iv Garber (IvG),    Jul, 2000

Arguments:

    pJobType             [out]    - Return Value of Job Type
    
Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobInner::get_JobType"), hr);
    hr = m_JobStatus.get_JobType(pJobType);
    return hr;
}

//
//==================== INIT ===================================================
//
template<class T, const IID* piid, const CLSID* pcid> 
STDMETHODIMP 
CFaxJobInner<T, piid, pcid>::Init(
    PFAX_JOB_ENTRY_EX pFaxJob,
    IFaxServerInner* pFaxServerInner
)
/*++

Routine name : CFaxJobInner::Init

Routine description:

    Initialize the JobInner Class : store Job Information and Ptr to Server

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    pFaxJob                   [in]    - Job Info
    pFaxServerInner           [in]    - Ptr to Server

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;

    DBG_ENTER (TEXT("CFaxJobInner::Init"), hr);

    ATLASSERT(pFaxJob->pStatus);

    //
    //  Store the given structure
    //
    m_dwlMessageId = pFaxJob->dwlMessageId;
    m_dwlBroadcastId = pFaxJob->dwlBroadcastId;
    m_dwReceiptType = pFaxJob->dwDeliveryReportType;
    m_Priority = FAX_PRIORITY_TYPE_ENUM(pFaxJob->Priority);

    m_tmOriginalScheduleTime = pFaxJob->tmOriginalScheduleTime;
    m_tmSubmissionTime = pFaxJob->tmSubmissionTime;

    m_bstrSubject = pFaxJob->lpctstrSubject;
    m_bstrDocumentName = pFaxJob->lpctstrDocumentName;
    if ( (pFaxJob->lpctstrSubject && !m_bstrSubject) ||
         (pFaxJob->lpctstrDocumentName && !m_bstrDocumentName) )
    {
        //
        //  Not enough memory to copy the TSID into CComBSTR
        //
        hr = E_OUTOFMEMORY;
        AtlReportError(*pcid, IDS_ERROR_OUTOFMEMORY, *piid, hr, _Module.GetResourceInstance());
        CALL_FAIL(MEM_ERR, _T("CComBSTR::operator=()"), hr);
        return hr;
    }
    
    //
    //  Create Status Object
    //
    hr = m_JobStatus.Init(pFaxJob->pStatus);
    if (FAILED(hr))
    {
        AtlReportError(*pcid, IDS_ERROR_OUTOFMEMORY, *piid, hr, _Module.GetResourceInstance());
        CALL_FAIL(MEM_ERR, _T("m_JobStatus.Init"), hr);
        return hr;
    }

    //
    //  When called from Refresh(), no need to set pFaxServerInner
    //
    if (pFaxServerInner)
    {
        hr = CFaxInitInnerAddRef::Init(pFaxServerInner);
    }
    return hr;
}

//
//====================== GET ID ================================================
//
template<class T, const IID* piid, const CLSID *pcid> 
STDMETHODIMP 
CFaxJobInner<T, piid, pcid>::get_Id(
    BSTR *pbstrId
)
/*++

Routine name : CFaxJobInner::get_Id

Routine description:

    Return Unique ID of the Message

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    pbstrId             [out]    - pointer to the place to put the ID 

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;

    DBG_ENTER (TEXT("CFaxJobInner::get_Id"), hr);

    //
    //  Check that we can write to the given pointer
    //
    if (::IsBadWritePtr(pbstrId, sizeof(BSTR)))
    {
        //
        //  got bad pointer
        //
        hr = E_POINTER;
        AtlReportError(*pcid, IDS_ERROR_INVALID_ARGUMENT, *piid, hr, _Module.GetResourceInstance());
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr()"), hr);
        return hr;
    }

    //
    //  Translate m_dwlMessageId into BSTR
    //
    TCHAR   tcBuffer[25];
    BSTR    bstrTemp;

    ::_i64tot(m_dwlMessageId, tcBuffer, 16);
    bstrTemp = ::SysAllocString(tcBuffer);
    if (!bstrTemp)
    {
        //
        //  Not enough memory
        //
        hr = E_OUTOFMEMORY;
        AtlReportError(*pcid, IDS_ERROR_OUTOFMEMORY, *piid, hr, _Module.GetResourceInstance());
        CALL_FAIL(MEM_ERR, _T("SysAllocString()"), hr);
        return hr;
    }

    *pbstrId = bstrTemp;
    return hr;
}

//
//====================== GET SIZE ================================================
//
template<class T, const IID* piid, const CLSID *pcid> 
STDMETHODIMP 
CFaxJobInner<T, piid, pcid>::get_Size(
    long *plSize
)
/*++

Routine name : CFaxJobInner::get_Size

Routine description:

    Return Size ( in bytes ) of Fax Job's TIFF File

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    plSize                  [out]    - Pointer to the place to put Size

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobInner::get_Size"), hr);
    hr = m_JobStatus.get_Size(plSize);
    return hr;
}

//
//====================== GET CURRENT PAGE =============================================
//
template<class T, const IID* piid, const CLSID *pcid> 
STDMETHODIMP 
CFaxJobInner<T, piid, pcid>::get_CurrentPage(
    long *plCurrentPage
)
/*++

Routine name : CFaxJobInner::get_CurrentPage

Routine description:

    Current Page number being received / sent

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    plCurrentPage           [out]    - Pointer to the place to put the Current Page Number

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobInner::get_CurrentPage"), hr);
    hr = m_JobStatus.get_CurrentPage(plCurrentPage);
	return hr;
}

//
//====================== GET DEVICE ID =============================================
//
template<class T, const IID* piid, const CLSID *pcid> 
STDMETHODIMP 
CFaxJobInner<T, piid, pcid>::get_DeviceId(
    long *plDeviceId
)
/*++

Routine name : CFaxJobInner::get_DeviceId

Routine description:

    The Device Id by which the Job is being sent / received.

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    plDeviceId              [out]    - Pointer to the place to put the Device Id
    
Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobInner::get_DeviceId"), hr);
    hr = m_JobStatus.get_DeviceId(plDeviceId);
	return hr;
}

//
//====================== GET STATUS =============================================
//
template<class T, const IID* piid, const CLSID *pcid> 
STDMETHODIMP 
CFaxJobInner<T, piid, pcid>::get_Status(
    FAX_JOB_STATUS_ENUM *pStatus
)
/*++

Routine name : CFaxJobInner::get_Status

Routine description:

    The current Queue Status of the Fax Job

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    pStatus                    [out]    - Pointer to the place to put the Bit-Wise Combination of status
    
Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobInner::get_Status"), hr);
    hr = m_JobStatus.get_Status(pStatus);
	return hr;
}

//
//====================== GET EXTENDED STATUS CODE ===============================
//
template<class T, const IID* piid, const CLSID *pcid> 
STDMETHODIMP 
CFaxJobInner<T, piid, pcid>::get_ExtendedStatusCode(
    FAX_JOB_EXTENDED_STATUS_ENUM *pExtendedStatusCode
)
/*++

Routine name : CFaxJobInner::get_ExtendedStatusCode

Routine description:

    The Code of the Extended Status of the Fax Job

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    pExtendedStatusCode             [out]    - Pointer to the place to put the status code
    
Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobInner::get_ExtendedStatusCode"), hr);
    hr = m_JobStatus.get_ExtendedStatusCode(pExtendedStatusCode);
    return hr;
}

//
//====================== GET RETRIES =============================================
//
template<class T, const IID* piid, const CLSID *pcid> 
STDMETHODIMP 
CFaxJobInner<T, piid, pcid>::get_Retries(
    long *plRetries
)
/*++

Routine name : CFaxJobInner::get_Retries

Routine description:

    The number of unsuccessful retries of the Fax Job

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    plRetries                    [out]    - Pointer to the place to put the number of Retries
    
Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobInner::get_Retries"), hr);
    hr = m_JobStatus.get_Retries(plRetries);
	return hr;
}

//
//====================== GET TSID ================================================
//
template<class T, const IID* piid, const CLSID *pcid> 
STDMETHODIMP 
CFaxJobInner<T, piid, pcid>::get_TSID(
    BSTR *pbstrTSID
)
/*++

Routine name : CFaxJobInner::get_TSID

Routine description:

    Return Transmitting Station ID of the Job

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    pbstrTSID             [out]    - pointer to the place to put the TSID

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobInner::get_TSID"), hr);
    hr = m_JobStatus.get_TSID(pbstrTSID);
	return hr;
}

//
//====================== GET CSID ================================================
//
template<class T, const IID* piid, const CLSID *pcid> 
STDMETHODIMP 
CFaxJobInner<T, piid, pcid>::get_CSID(
    BSTR *pbstrCSID
)
/*++

Routine name : CFaxJobInner::get_CSID

Routine description:

    Return Called Station ID of the Job

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    pbstrCSID             [out]    - pointer to the place to put the CSID

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobInner::get_CSID"), hr);
    hr = m_JobStatus.get_CSID(pbstrCSID);
    return hr;
}

//
//====================== GET EXTENDED STATUS =======================================
//
template<class T, const IID* piid, const CLSID *pcid> 
STDMETHODIMP 
CFaxJobInner<T, piid, pcid>::get_ExtendedStatus(
    BSTR *pbstrExtendedStatus
)
/*++

Routine name : CFaxJobInner::get_ExtendedStatus

Routine description:

    Return String Description of the Extended Status of the Job

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    pbstrExtendedStatus             [out]    - pointer to the place to put the Extended Status 

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobInner::get_ExtendedStatus"), hr);
    hr = m_JobStatus.get_ExtendedStatus(pbstrExtendedStatus);
	return hr;
}

//
//====================== GET SUBJECT ================================================
//
template<class T, const IID* piid, const CLSID *pcid> 
STDMETHODIMP 
CFaxJobInner<T, piid, pcid>::get_Subject(
    BSTR *pbstrSubject
)
/*++

Routine name : CFaxJobInner::get_Subject

Routine description:

    Return the Subject field of the Cover Page

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    pbstrSubject            [out]    - pointer to the place to put Subject contents

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobInner::get_Subject"), hr);

    hr = GetBstr(pbstrSubject, m_bstrSubject);
    if (FAILED(hr))
    {
        AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr, _Module.GetResourceInstance());
        return hr;
    }
	return hr;
}

//
//====================== GET CALLER ID ================================================
//
template<class T, const IID* piid, const CLSID *pcid> 
STDMETHODIMP 
CFaxJobInner<T, piid, pcid>::get_CallerId(
    BSTR *pbstrCallerId
)
/*++

Routine name : CFaxJobInner::get_CallerId

Routine description:

    Return the Caller Id of Job's Phone Call

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    pbstrCallerId           [out]    - pointer to the place to put the Caller Id

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobInner::get_CallerId"), hr);
    hr = m_JobStatus.get_CallerId(pbstrCallerId);
    return hr;
}

//
//====================== GET ROUTING INFORMATION ======================================
//
template<class T, const IID* piid, const CLSID *pcid> 
STDMETHODIMP 
CFaxJobInner<T, piid, pcid>::get_RoutingInformation(
    BSTR *pbstrRoutingInformation
)
/*++

Routine name : CFaxJobInner::get_RoutingInformation

Routine description:

    Return the Routing Information of the Job

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    pbstrRoutingInformation         [out]    - pointer to place to put Routing Information

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobInner::get_RoutingInformation"), hr);
    hr = m_JobStatus.get_RoutingInformation(pbstrRoutingInformation);
	return hr;
}

//
//====================== GET DOCUMENT NAME ================================================
//
template<class T, const IID* piid, const CLSID *pcid> 
STDMETHODIMP 
CFaxJobInner<T, piid, pcid>::get_DocumentName(
    BSTR *pbstrDocumentName
)
/*++

Routine name : CFaxJobInner::get_DocumentName

Routine description:

    Return the Friendly Name of the Document

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    pbstrDocumentName             [out]    - pointer to the place to put Document Name

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobInner::get_DocumentName"), hr);

    hr = GetBstr(pbstrDocumentName, m_bstrDocumentName);
    if (FAILED(hr))
    {
        AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr, _Module.GetResourceInstance());
        return hr;
    }
	return hr;
}

//
//====================== GET PAGES ================================================
//
template<class T, const IID* piid, const CLSID *pcid> 
STDMETHODIMP 
CFaxJobInner<T, piid, pcid>::get_Pages(
    long *plPages
)
/*++

Routine name : CFaxJobInner::get_Pages

Routine description:

    Return total number of pages of the message

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    plPages                 [out]    - Pointer to the place to put the value

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobInner::get_Pages"), hr);
    hr = m_JobStatus.get_Pages(plPages);
	return hr;
}


//
//====================== GET PRIORITY ================================================
//
template<class T, const IID* piid, const CLSID *pcid> 
STDMETHODIMP 
CFaxJobInner<T, piid, pcid>::get_Priority(
    FAX_PRIORITY_TYPE_ENUM  *pPriority
)
/*++

Routine name : CFaxJobInner::get_Priority

Routine description:

    Return the Priority of Fax Job

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    pPriority                  [out]    - Pointer to the place to put the Priority

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobInner::get_Priority"), hr);

    //
    //  Check that we can write to the given pointer
    //
    if (::IsBadWritePtr(pPriority, sizeof(FAX_PRIORITY_TYPE_ENUM)))
    {
        //
        //  Got Bad Return Pointer
        //
        hr = E_POINTER;
        AtlReportError(*pcid, IDS_ERROR_INVALID_ARGUMENT, *piid, hr, _Module.GetResourceInstance());
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr"), hr);
        return hr;
    }

    *pPriority = m_Priority;
    return hr;
}

//
//====================== GET AVAILABLE OPERATIONS ==================================
//
template<class T, const IID* piid, const CLSID *pcid> 
STDMETHODIMP 
CFaxJobInner<T, piid, pcid>::get_AvailableOperations(
    FAX_JOB_OPERATIONS_ENUM  *pAvailableOperations
)
/*++

Routine name : CFaxJobInner::get_AvailableOperations

Routine description:

    The operations available for the Fax Job

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    pAvailableOperations                 [out]    - Pointer to the place to put the Bit-Wise Combination of result
    
Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobInner::get_AvailableOperations"), hr);
    hr = m_JobStatus.get_AvailableOperations(pAvailableOperations);
	return hr;
}


//
//====================== GET SUBMISSION ID ================================================
//
template<class T, const IID* piid, const CLSID *pcid> 
STDMETHODIMP 
CFaxJobInner<T, piid, pcid>::get_SubmissionId(
    BSTR *pbstrSubmissionId
)
/*++

Routine name : CFaxJobInner::get_SubmissionId

Routine description:

    Return Submission ID of the Job

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    pbstrSubmissionId             [out]    - pointer to the place to put the Submission ID 

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobInner::get_SubmissionId"), hr);

    //
    //  Check that we can write to the given pointer
    //
    if (::IsBadWritePtr(pbstrSubmissionId, sizeof(BSTR)))
    {
        //
        //  got bad pointer
        //
        hr = E_POINTER;
        AtlReportError(*pcid, IDS_ERROR_INVALID_ARGUMENT, *piid, hr, _Module.GetResourceInstance());
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr()"), hr);
        return hr;
    }

    //
    //  Translate m_dwlBroadcastId into BSTR
    //
    TCHAR   tcBuffer[25];
    BSTR    bstrTemp;

    ::_i64tot(m_dwlBroadcastId, tcBuffer, 16);
    bstrTemp = ::SysAllocString(tcBuffer);
    if (!bstrTemp)
    {
        //
        //  Not enough memory
        //
        hr = E_OUTOFMEMORY;
        AtlReportError(*pcid, IDS_ERROR_OUTOFMEMORY, *piid, hr, _Module.GetResourceInstance());
        CALL_FAIL(MEM_ERR, _T("SysAllocString()"), hr);
        return hr;
    }

    *pbstrSubmissionId = bstrTemp;
    return hr;
}
    
//
//====================== GET RECIPIENT ================================================
//
template<class T, const IID* piid, const CLSID *pcid> 
STDMETHODIMP
CFaxJobInner<T, piid, pcid>::get_Recipient(
    /*[out, retval] */IFaxRecipient **ppRecipient
)
/*++

Routine name : CFaxJobInner::get_Recipient

Routine description:

    Return Job's Recipient Information

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    ppRecipient                 [out]    - Ptr to the Place to put Recipient Information

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (_T("CFaxJobInner::get_Recipient"), hr);

    //
    //  Check that we can write to the given pointer
    //
    if (::IsBadWritePtr(ppRecipient, sizeof(IFaxRecipient* )))
    {
        //
        //  got bad pointer
        //
        hr = E_POINTER;
        AtlReportError(*pcid, IDS_ERROR_INVALID_ARGUMENT, *piid, hr, _Module.GetResourceInstance());
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr()"), hr);
        return hr;
    }

    if (!m_pRecipient)
    {
        //
        //  First Time Calling. Take the Recipient Info from Server
        //

        //
        //  Get Fax Server Handle
        //
        HANDLE  hFaxHandle = NULL;
        hr = GetFaxHandle(&hFaxHandle);
        if (FAILED(hr))
        {
            AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr, _Module.GetResourceInstance());
            return hr;
        }

        //
        //  Get Personal Profile Info
        //
        CFaxPtr<FAX_PERSONAL_PROFILE>   pPersonalProfile;
        if (!FaxGetRecipientInfo(hFaxHandle, m_dwlMessageId, FAX_MESSAGE_FOLDER_QUEUE, &pPersonalProfile))
        {
            //
            //  Failed to get Personal Profile Info
            //
            hr = Fax_HRESULT_FROM_WIN32(GetLastError());
            AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr, _Module.GetResourceInstance());
            CALL_FAIL(GENERAL_ERR, _T("FaxGetRecipientInfo()"), hr);
            return hr;
        }

        //
        //  Check that pPersonalProfile is valid
        //
	    if (!pPersonalProfile || pPersonalProfile->dwSizeOfStruct != sizeof(FAX_PERSONAL_PROFILE))
	    {
		    //
		    //	Failed to Get Personal Profile
		    //
		    hr = E_FAIL;
		    AtlReportError(*pcid, IDS_ERROR_OPERATION_FAILED, *piid, hr, _Module.GetResourceInstance());
		    CALL_FAIL(GENERAL_ERR, _T("Invalid pPersonalProfile"), hr);
		    return hr;
	    }

        //
        //  Create Recipient Object
        //
        hr = CComObject<CFaxRecipient>::CreateInstance(&m_pRecipient);
        if (FAILED(hr) || !m_pRecipient)
        {
            hr = E_OUTOFMEMORY;
            AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr, _Module.GetResourceInstance());
            CALL_FAIL(GENERAL_ERR, _T("CComObject<CFaxRecipient>::CreateInstance(&m_pRecipient)"), hr);
            return hr;
        }

        //
        //  We want Recipient object to live
        //
        m_pRecipient->AddRef();

        //
        //  Fill the Data
        //
        hr = m_pRecipient->PutRecipientProfile(pPersonalProfile);
        if (FAILED(hr))
        {
            //
            //  Failed to fill the Recipient's Object with RPC's data
            //
            AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr, _Module.GetResourceInstance());
            CALL_FAIL(GENERAL_ERR, _T("m_pRecipient->PutRecipientProfile(pPersonalProfile)"), hr);
            m_pRecipient->Release();
            m_pRecipient = NULL;
            return hr;
        }
    }

    //
    //  Return Recipient Object to Caller
    //
    hr = m_pRecipient->QueryInterface(ppRecipient);
    if (FAILED(hr))
    {
        //
        //  Failed to Query Interface
        //
        AtlReportError(*pcid, IDS_ERROR_OPERATION_FAILED, *piid, hr, _Module.GetResourceInstance());
        CALL_FAIL(MEM_ERR, _T("CComObject<CFaxRecipient>::QueryInterface()"), hr);
        return hr;
    }

    return hr;
}

//
//====================== GET SENDER ================================================
//
template<class T, const IID* piid, const CLSID *pcid> 
STDMETHODIMP
CFaxJobInner<T, piid, pcid>::get_Sender(
    /*[out, retval] */IFaxSender **ppSender
)
/*++

Routine name : CFaxJobInner::get_Sender

Routine description:

    Return Job's Sender Information

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    ppSender                [out]    - Ptr to the Place to put Sender Information

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (_T("CFaxJobInner::get_Sender"), hr);

    //
    //  Check that we can write to the given pointer
    //
    if (::IsBadWritePtr(ppSender, sizeof(IFaxSender* )))
    {
        //
        //  got bad pointer
        //
        hr = E_POINTER;
        AtlReportError(*pcid, IDS_ERROR_INVALID_ARGUMENT, *piid, hr, _Module.GetResourceInstance());
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr()"), hr);
        return hr;
    }

    if (!m_pSender)
    {
        //
        //  The Function is called for the First Time. Let's bring Sender's Data from Server
        //

        //
        //  Get Fax Server Handle
        //
        HANDLE  hFaxHandle = NULL;
        hr = GetFaxHandle(&hFaxHandle);
        if (FAILED(hr))
        {
            AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr, _Module.GetResourceInstance());
            return hr;
        }

        //
        //  Get Personal Profile Info
        //
        CFaxPtr<FAX_PERSONAL_PROFILE>   pPersonalProfile;
        if (!FaxGetSenderInfo(hFaxHandle, m_dwlMessageId, FAX_MESSAGE_FOLDER_QUEUE, &pPersonalProfile))
        {
            //
            //  Failed to get Personal Profile Info
            //
            hr = Fax_HRESULT_FROM_WIN32(GetLastError());
            AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr, _Module.GetResourceInstance());
            CALL_FAIL(GENERAL_ERR, _T("FaxGetSenderInfo()"), hr);
            return hr;
        }

        //
        //  Check that pPersonalProfile is valid
        //
	    if (!pPersonalProfile || pPersonalProfile->dwSizeOfStruct != sizeof(FAX_PERSONAL_PROFILE))
	    {
		    //
		    //	Failed to Get Personal Profile
		    //
		    hr = E_FAIL;
		    AtlReportError(*pcid, IDS_ERROR_OPERATION_FAILED, *piid, hr, _Module.GetResourceInstance());
		    CALL_FAIL(GENERAL_ERR, _T("Invalid pPersonalProfile"), hr);
		    return hr;
	    }

        //
        //  Create Sender Object
        //
        hr = CComObject<CFaxSender>::CreateInstance(&m_pSender);
        if (FAILED(hr) || !m_pSender)
        {
            hr = E_OUTOFMEMORY;
            AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr, _Module.GetResourceInstance());
            CALL_FAIL(GENERAL_ERR, _T("CComObject<CFaxSender>::CreateInstance(&m_pSender)"), hr);
            return hr;
        }

        //
        //  We want Sender object to live
        //
        m_pSender->AddRef();

        //
        //  Fill the Data
        //
        hr = m_pSender->PutSenderProfile(pPersonalProfile);
        if (FAILED(hr))
        {
            //
            //  Failed to fill the Sender's Object with RPC's data
            //
            AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr, _Module.GetResourceInstance());
            CALL_FAIL(GENERAL_ERR, _T("m_pSender->PutSenderProfile(pPersonalProfile)"), hr);
            m_pSender->Release();
            m_pSender = NULL;
            return hr;
        }
    }

    //
    //  Return Sender Object to Caller
    //
    hr = m_pSender->QueryInterface(ppSender);
    if (FAILED(hr))
    {
        //
        //  Failed to Query Interface
        //
        AtlReportError(*pcid, IDS_ERROR_OPERATION_FAILED, *piid, hr, _Module.GetResourceInstance());
        CALL_FAIL(MEM_ERR, _T("CComObject<CFaxSender>::QueryInterface()"), hr);
        return hr;
    }
    return hr;
}

//
//========================= GET ORIGINAL SCHEDULED TIME ===============================
//
template<class T, const IID* piid, const CLSID *pcid> 
STDMETHODIMP 
CFaxJobInner<T, piid, pcid>::get_OriginalScheduledTime(
    DATE *pdateOriginalScheduledTime
)
/*++

Routine name : CFaxJobInner::get_OriginalScheduledTime

Routine description:

    Return Time the Job was originally scheduled

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    pdateOriginalScheduledTime      [out]    - pointer to place to put Original Scheduled Time

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobInner::get_OriginalScheduledTime"), hr);

    //
    //  Check that we can write to the given pointer
    //
    if (::IsBadWritePtr(pdateOriginalScheduledTime, sizeof(DATE)))
    {
        //  
        //  Got Bad Ptr
        //  
        hr = E_POINTER;
        AtlReportError(*pcid, IDS_ERROR_INVALID_ARGUMENT, *piid, hr, _Module.GetResourceInstance());
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr()"), hr);
        return hr;
    }

    hr = SystemTime2LocalDate(m_tmOriginalScheduleTime, pdateOriginalScheduledTime);
    if (FAILED(hr))
    {
        //
        //  Failed to convert the system time to localized variant date
        //
        AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr, _Module.GetResourceInstance());
        return hr;
    }

    return hr;
}

//
//========================= GET SUBMISSION TIME ===============================
//
template<class T, const IID* piid, const CLSID *pcid> 
STDMETHODIMP 
CFaxJobInner<T, piid, pcid>::get_SubmissionTime(
    DATE *pdateSubmissionTime
)
/*++

Routine name : CFaxJobInner::get_SubmissionTime

Routine description:

    Return Time the Job was submitted

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    pdateSubmissionTime      [out]    - pointer to place to put Submission Time

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobInner::get_SubmissionTime"), hr);

    //
    //  Check that we can write to the given pointer
    //
    if (::IsBadWritePtr(pdateSubmissionTime, sizeof(DATE)))
    {
        //  
        //  Got Bad Ptr
        //  
        hr = E_POINTER;
        AtlReportError(*pcid, IDS_ERROR_INVALID_ARGUMENT, *piid, hr, _Module.GetResourceInstance());
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr()"), hr);
        return hr;
    }

    hr = SystemTime2LocalDate(m_tmSubmissionTime, pdateSubmissionTime);
    if (FAILED(hr))
    {
        //
        //  Failed to convert the system time to localized variant date
        //
        AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr, _Module.GetResourceInstance());
        return hr;
    }

    return hr;
}

//
//========================= GET SCHEDULED TIME ===============================
//
template<class T, const IID* piid, const CLSID *pcid> 
STDMETHODIMP 
CFaxJobInner<T, piid, pcid>::get_ScheduledTime(
    DATE *pdateScheduledTime
)
/*++

Routine name : CFaxJobInner::get_ScheduledTime

Routine description:

    Return Time the Job is scheduled

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    pdateScheduledTime      [out]    - pointer to place to put Scheduled Time

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobInner::get_ScheduledTime"), hr);
    hr = m_JobStatus.get_ScheduledTime(pdateScheduledTime);
    return hr;
}

//
//========================= GET TRANSMISSION START ===============================
//
template<class T, const IID* piid, const CLSID *pcid> 
STDMETHODIMP 
CFaxJobInner<T, piid, pcid>::get_TransmissionStart(
    DATE *pdateTransmissionStart
)
/*++

Routine name : CFaxJobInner::get_TransmissionStart

Routine description:

    Return Time the Job is started to transmit

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    pdateTransmissionStart      [out]    - pointer to place to put the Transmission Start

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobInner::get_TransmissionStart"), hr);
    hr = m_JobStatus.get_TransmissionStart(pdateTransmissionStart);
    return hr;
}

//    
//====================== GET GROUP BROADCAST REPORTS ========================
//
template<class T, const IID* piid, const CLSID *pcid> 
STDMETHODIMP 
CFaxJobInner<T, piid, pcid>::get_GroupBroadcastReceipts(
    VARIANT_BOOL *pbGroupBroadcastReceipts
)
/*++

Routine name : CFaxJobInner::get_GroupBroadcastReceipts

Routine description:

    Return whether Receipts are grouped

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    pbGroupBroadcastReceipts      [out]    - pointer to the place to put the value

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobInner::get_GroupBroadcastReceipts"), hr);

    hr = GetVariantBool(pbGroupBroadcastReceipts, ((m_dwReceiptType & DRT_GRP_PARENT) ? VARIANT_TRUE : VARIANT_FALSE));
    if (FAILED(hr))
    {
        AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr, _Module.GetResourceInstance());
        return hr;
    }
	return hr;
}

//    
//====================== GET RECEIPT TYPE ========================
//
template<class T, const IID* piid, const CLSID *pcid> 
STDMETHODIMP 
CFaxJobInner<T, piid, pcid>::get_ReceiptType(
    FAX_RECEIPT_TYPE_ENUM *pReceiptType
)
/*++

Routine name : CFaxJobInner::get_ReceiptType

Routine description:

    Return the type of the receipts

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    pbReceiptType      [out]    - pointer to the place to put the value

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobInner::get_ReceiptType"), hr);

    //
    //  Check that we can write to the given pointer
    //
    if (::IsBadWritePtr(pReceiptType, sizeof(FAX_RECEIPT_TYPE_ENUM)))
    {
        //  
        //  Got Bad Ptr
        //  
        hr = E_POINTER;
        AtlReportError(*pcid, IDS_ERROR_INVALID_ARGUMENT, *piid, hr, _Module.GetResourceInstance());
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr()"), hr);
        return hr;
    }

    //
    //  return the delivery report type WITHOUT the modifiers bit
    //
    *pReceiptType = FAX_RECEIPT_TYPE_ENUM((m_dwReceiptType) & (~DRT_MODIFIERS));
    return hr;
}

//
//====================== COPY TIFF ================================================
//
template<class T, const IID* piid, const CLSID *pcid> 
STDMETHODIMP 
CFaxJobInner<T, piid, pcid>::CopyTiff(
    /*[in]*/ BSTR bstrTiffPath
)
/*++

Routine name : CFaxJobInner::CopyTiff

Routine description:

    Copies the Job's Tiff Image to a file on the local computer.

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    bstrTiffPath                  [in]    - the file to copy to

Return Value:

    Standard    HRESULT     code

--*/
{
    HRESULT     hr = S_OK;
    HANDLE      hFaxHandle = NULL;

    DBG_ENTER (TEXT("CFaxJobInner::CopyTiff"), hr, _T("%s"), bstrTiffPath);

    //
    //  Get Fax Server Handle
    //
    hr = GetFaxHandle(&hFaxHandle);
    if (FAILED(hr))
    {
        AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr, _Module.GetResourceInstance());
        return hr;
    }

    if (!FaxGetMessageTiff(hFaxHandle, m_dwlMessageId, FAX_MESSAGE_FOLDER_QUEUE, bstrTiffPath))
    {
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr, _Module.GetResourceInstance());
        CALL_FAIL(GENERAL_ERR, 
            _T("FaxGetMessageTiff(hFaxHandle, m_pJobInfo->dwlMessageId, FAX_MESSAGE_FOLDER_QUEUE, bstrTiffPath)"), 
            hr);
        return hr;
    }

    return hr;
}

//
//====================== CANCEL ================================================
//
template<class T, const IID* piid, const CLSID *pcid> 
STDMETHODIMP 
CFaxJobInner<T, piid, pcid>::Cancel(
)
/*++

Routine name : CFaxJobInner::Cancel

Routine description:

    Cancel the Job

Author:

    Iv Garber (IvG),    May, 2000

Return Value:

    Standard    HRESULT     code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobInner::Cancel"), hr);
    hr = UpdateJob(JC_DELETE);
    return hr;
}

//
//====================== PAUSE ================================================
//
template<class T, const IID* piid, const CLSID *pcid> 
STDMETHODIMP 
CFaxJobInner<T, piid, pcid>::Pause(
)
/*++

Routine name : CFaxJobInner::Pause

Routine description:

    Pause the Job

Author:

    Iv Garber (IvG),    May, 2000

Return Value:

    Standard    HRESULT     code

--*/
{
    HRESULT     hr = S_OK;
    HANDLE      hFaxHandle = NULL;
    hr = UpdateJob(JC_PAUSE);
    return hr;
}

//
//====================== RESUME ================================================
//
template<class T, const IID* piid, const CLSID *pcid> 
STDMETHODIMP 
CFaxJobInner<T, piid, pcid>::Resume(
)
/*++

Routine name : CFaxJobInner::Resume

Routine description:

    Resume the Job

Author:

    Iv Garber (IvG),    May, 2000

Return Value:

    Standard    HRESULT     code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobInner::Resume"), hr);
    hr = UpdateJob(JC_RESUME);
    return hr;
}

//
//====================== RESTART ================================================
//
template<class T, const IID* piid, const CLSID *pcid> 
STDMETHODIMP 
CFaxJobInner<T, piid, pcid>::Restart(
)
/*++

Routine name : CFaxJobInner::Restart

Routine description:

    Restart the Job

Author:

    Iv Garber (IvG),    May, 2000

Return Value:

    Standard    HRESULT     code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobInner::Restart"), hr);
    hr = UpdateJob(JC_RESTART);
    return hr;
}

//
//====================== GET TRANSMISSION END ======================================
//
template<class T, const IID* piid, const CLSID *pcid> 
STDMETHODIMP 
CFaxJobInner<T, piid, pcid>::get_TransmissionEnd(
    DATE *pdateTransmissionEnd
)
/*++

Routine name : CFaxJobInner::get_TransmissionEnd

Routine description:

    Return Job's Transmission End

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    pdateTransmissionEnd            [out]    - pointer to the place to put the value

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxJobInner::get_TransmissionEnd"), hr);
    hr = m_JobStatus.get_TransmissionEnd(pdateTransmissionEnd);
    return hr;
}

//
//====================== REFRESH ================================================
//
template<class T, const IID* piid, const CLSID *pcid> 
STDMETHODIMP 
CFaxJobInner<T, piid, pcid>::Refresh(
)
/*++

Routine name : CFaxJobInner::Refresh

Routine description:

    Refresh the Job

Author:

    Iv Garber (IvG),    May, 2000

Return Value:

    Standard    HRESULT     code

--*/
{
    HRESULT     hr = S_OK;
    HANDLE      hFaxHandle = NULL;

    DBG_ENTER (TEXT("CFaxJobInner::Refresh"), hr);

    //
    //  Get Fax Server Handle
    //
    hr = GetFaxHandle(&hFaxHandle);
    if (FAILED(hr))
    {
        AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr, _Module.GetResourceInstance());
        return hr;
    }

    CFaxPtr<FAX_JOB_ENTRY_EX>   pJobInfo;
    if (!FaxGetJobEx(hFaxHandle, m_dwlMessageId, &pJobInfo))
    {
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr, _Module.GetResourceInstance());
        CALL_FAIL(GENERAL_ERR, _T("FaxGetJobEx(hFaxHandle, m_pJobInfo->dwlMessageId, &m_pJobInfo)"), hr);
        return hr;
    }

    hr = Init(pJobInfo, NULL);

    return hr;
}

//
//====================== UPDATE JOB ================================================
//
template<class T, const IID* piid, const CLSID *pcid> 
STDMETHODIMP 
CFaxJobInner<T, piid, pcid>::UpdateJob(
    FAX_ENUM_JOB_COMMANDS   cmdToPerform
)
/*++

Routine name : CFaxJobInner::Update

Routine description:

    Perform the desired operation on the Job

Author:

    Iv Garber (IvG),    June, 2000

Return Value:

    Standard    HRESULT     code

--*/
{
    HRESULT     hr = S_OK;
    HANDLE      hFaxHandle = NULL;

    DBG_ENTER (TEXT("CFaxJobInner::Update"), hr, _T("command is : %d"), cmdToPerform);

    //
    //  Get Fax Server Handle
    //
    hr = GetFaxHandle(&hFaxHandle);
    if (FAILED(hr))
    {
        AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr, _Module.GetResourceInstance());
        return hr;
    }

    FAX_JOB_ENTRY fje = {0};
    fje.SizeOfStruct = sizeof(FAX_JOB_ENTRY);

    if (!FaxSetJob(hFaxHandle, m_JobStatus.GetJobId(), cmdToPerform, &fje))
    {
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr, _Module.GetResourceInstance());
        CALL_FAIL(GENERAL_ERR, 
            _T("FaxSetJob(hFaxHandle, m_JobStatus.GtJobId(), cmdToPerform, &fje)"), 
            hr);
        return hr;
    }

    return hr;
}

#endif //   __FAXJOBINNER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxloggingoptions.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxLoggingOptions.h

Abstract:

	Declaration of the CFaxLoggingOptions Class.

Author:

	Iv Garber (IvG)	Jun, 2000

Revision History:

--*/


#ifndef __FAXLOGGINGOPTIONS_H_
#define __FAXLOGGINGOPTIONS_H_

#include "resource.h"       // main symbols
#include "FaxCommon.h"
#include "FaxActivityLogging.h"
#include "FaxEventLogging.h"


// 
//================== LOGGING OPTIONS =======================================
//
class ATL_NO_VTABLE CFaxLoggingOptions : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public ISupportErrorInfo,
	public IDispatchImpl<IFaxLoggingOptions, &IID_IFaxLoggingOptions, &LIBID_FAXCOMEXLib>,
    public CFaxInitInner
{
public:
    CFaxLoggingOptions() : CFaxInitInner(_T("FAX LOGGING OPTIONS")),
        m_pEvent(NULL),
        m_pActivity(NULL)
	{
	}
    ~CFaxLoggingOptions()
    {
        //
        //  free all the allocated objects
        //
        if (m_pEvent) 
        {
            delete m_pEvent;
        }

        if (m_pActivity) 
        {
            delete m_pActivity;
        }
    }


DECLARE_REGISTRY_RESOURCEID(IDR_FAXLOGGINGOPTIONS)
DECLARE_NOT_AGGREGATABLE(CFaxLoggingOptions)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxLoggingOptions)
	COM_INTERFACE_ENTRY(IFaxLoggingOptions)
	COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IFaxInitInner)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

//  Interfaces
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

    STDMETHOD(get_EventLogging)(/*[out, retval]*/ IFaxEventLogging **pFaxEventLogging);
    STDMETHOD(get_ActivityLogging)(/*[out, retval]*/ IFaxActivityLogging **pFaxActivityLogging);

private:
    CComContainedObject2<CFaxEventLogging>       *m_pEvent;
    CComContainedObject2<CFaxActivityLogging>    *m_pActivity;
};

#endif //__FAXLOGGINGOPTIONS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxloggingoptions.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxLoggingOptions.cpp

Abstract:

	Implementation of Fax Logging Options Class.

Author:

	Iv Garber (IvG)	May, 2000

Revision History:

--*/

#include "stdafx.h"
#include "FaxComEx.h"
#include "FaxLoggingOptions.h"


//
//================== GET ACTIVITY LOGGING OBJECT ==============================
//
STDMETHODIMP 
CFaxLoggingOptions::get_ActivityLogging(
    /*[out, retval]*/ IFaxActivityLogging **ppActivityLogging
)
/*++

Routine name : CFaxLoggingOptions::get_ActivityLogging

Routine description:

	Return Activity Logging Object

Author:

	Iv Garber (IvG),	June, 2000

Arguments:

	ppActivityLogging              [out]    - the Activity Logging Object

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT				hr = S_OK;
	DBG_ENTER (_T("CFaxLoggingOptions::get_ActivityLogging"), hr);

    CObjectHandler<CFaxActivityLogging, IFaxActivityLogging>    ObjectCreator;
    hr = ObjectCreator.GetContainedObject(ppActivityLogging, &m_pActivity, m_pIFaxServerInner);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxLoggingOptions,
            GetErrorMsgId(hr), 
            IID_IFaxLoggingOptions, 
            hr,
            _Module.GetResourceInstance());
        return hr;
    }
    return hr;
}

//
//================== GET EVENT LOGGING OBJECT ==============================
//
STDMETHODIMP 
CFaxLoggingOptions::get_EventLogging(
    /*[out, retval]*/ IFaxEventLogging **ppEventLogging
)
/*++

Routine name : CFaxLoggingOptions::get_EventLogging

Routine description:

	Return Event Logging Object

Author:

	Iv Garber (IvG),	June, 2000

Arguments:

	ppEventLogging              [out]    - the Event Logging Object

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT				hr = S_OK;
	DBG_ENTER (_T("CFaxLoggingOptions::get_EventLogging"), hr);

    CObjectHandler<CFaxEventLogging, IFaxEventLogging>    ObjectCreator;
    hr = ObjectCreator.GetContainedObject(ppEventLogging, &m_pEvent, m_pIFaxServerInner);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxLoggingOptions,
            GetErrorMsgId(hr), 
            IID_IFaxLoggingOptions, 
            hr,
            _Module.GetResourceInstance());
        return hr;
    }
    return hr;
}

//
//==================== INTERFACE SUPPORT ERROR INFO =====================
//
STDMETHODIMP 
CFaxLoggingOptions::InterfaceSupportsErrorInfo(
	REFIID riid
)
/*++

Routine name : CFaxLoggingOptions::InterfaceSupportsErrorInfo

Routine description:

	ATL's implementation of Support Error Info

Author:

	Iv Garber (IvG),	June, 2000

Arguments:

	riid                          [in]    - Reference to the Interface

Return Value:

    Standard HRESULT code

--*/
{
	static const IID* arr[] = 
	{
		&IID_IFaxLoggingOptions
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxmessageinner.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    FaxMessageInner.h

Abstract:

    Implementation of Fax Message Inner Class : 
        Base Class for Inbound and Outbound Message Classes.

Author:

    Iv Garber (IvG) May, 2000

Revision History:

--*/


#ifndef __FAXMESSAGEINNER_H_
#define __FAXMESSAGEINNER_H_

#include "FaxCommon.h"
#include "FaxSender.h"

//
//===================== FAX MESSAGE INNER CLASS ===============================
//
template<class T, const IID* piid, const CLSID* pcid, FAX_ENUM_MESSAGE_FOLDER FolderType> 
class CFaxMessageInner : 
    public IDispatchImpl<T, piid, &LIBID_FAXCOMEXLib>,
    public CFaxInitInnerAddRef
{
public:
    CFaxMessageInner() : CFaxInitInnerAddRef(_T("FAX MESSAGE INNER"))
    {
        m_pSender = NULL;
        m_pRecipient = NULL;
    };

    virtual ~CFaxMessageInner() 
    {
        if (m_pSender)
        {
            m_pSender->Release();
        }
        if (m_pRecipient)
        {
            m_pRecipient->Release();
        }
    };

    STDMETHOD(Init)(PFAX_MESSAGE pFaxMessage, IFaxServerInner* pFaxServerInner);

    STDMETHOD(get_Id)(/*[out, retval]*/ BSTR *pbstrId);
    STDMETHOD(get_SubmissionId)(/*[out, retval] */BSTR *pbstrSubmissionId);
    STDMETHOD(get_DeviceName)(/*[out, retval]*/ BSTR *pbstrDeviceName);
    STDMETHOD(get_TSID)(/*[out, retval]*/ BSTR *pbstrTSID);
    STDMETHOD(get_CSID)(/*[out, retval]*/ BSTR *pbstrCSID);
    STDMETHOD(get_CallerId)(/*[out, retval]*/ BSTR *pbstrCallerId);
    STDMETHOD(get_RoutingInformation)(/*[out, retval]*/ BSTR *pbstrRoutingInformation);
    STDMETHOD(get_DocumentName)(/*[out, retval] */BSTR *pbstrDocumentName);
    STDMETHOD(get_Subject)(/*[out, retval] */BSTR *pbstrSubject);
    STDMETHOD(get_Size)(/*[out, retval]*/ long *plSize);
    STDMETHOD(get_Pages)(/*[out, retval]*/ long *plPages);
    STDMETHOD(get_Retries)(/*[out, retval]*/ long *plRetries);
    STDMETHOD(get_Priority)(/*[out, retval] */FAX_PRIORITY_TYPE_ENUM *pPriority);
    STDMETHOD(get_TransmissionStart)(/*[out, retval]*/ DATE *pdateTransmissionStart);
    STDMETHOD(get_TransmissionEnd)(/*[out, retval]*/ DATE *pdateTransmissionEnd);
    STDMETHOD(get_OriginalScheduledTime)(/*[out, retval] */DATE *pdateOriginalScheduledTime);
    STDMETHOD(get_SubmissionTime)(/*[out, retval] */DATE *pdateSubmissionTime);

    STDMETHOD(CopyTiff)(/*[in]*/ BSTR bstrTiffPath);
    STDMETHOD(Delete)();

    STDMETHOD(get_Sender)(/*[out, retval] */IFaxSender **ppFaxSender);
    STDMETHOD(get_Recipient)(/*[out, retval] */IFaxRecipient **ppFaxRecipient);
private:
    CComBSTR    m_bstrSubmissionId;
    CComBSTR    m_bstrTSID;
    CComBSTR    m_bstrDeviceName;
    CComBSTR    m_bstrCSID;
    CComBSTR    m_bstrCallerId;
    CComBSTR    m_bstrRoutingInfo;
    CComBSTR    m_bstrDocName;
    CComBSTR    m_bstrSubject;
    CComBSTR    m_bstrNote;
    long        m_lSize;
    long        m_lPages;
    long        m_lRetries;
    DATE        m_dtTransmissionStart;
    DATE        m_dtTransmissionEnd;
    DATE        m_dtOriginalScheduledTime;
    DATE        m_dtSubmissionTime;
	DWORD		m_dwValidityMask;
    DWORDLONG   m_dwlMsgId;

    FAX_PRIORITY_TYPE_ENUM  m_Priority;

    CComObject<CFaxSender>      *m_pSender;
    CComObject<CFaxRecipient>   *m_pRecipient;
};

//
//====================== GET ID ================================================
//
template<class T, const IID* piid, const CLSID *pcid, FAX_ENUM_MESSAGE_FOLDER FolderType> 
STDMETHODIMP 
CFaxMessageInner<T, piid, pcid, FolderType>::get_Id(
    BSTR *pbstrId
)
/*++

Routine name : CFaxMessageInner::get_Id

Routine description:

    Return Unique ID of the Message

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    pbstrId             [out]    - pointer to the place to put the ID 

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;

    DBG_ENTER (TEXT("CFaxMessageInner::get_Id"), hr);

    //
    //  Check that we can write to the given pointer
    //
    if (::IsBadWritePtr(pbstrId, sizeof(BSTR)))
    {
        //
        //  got bad pointer
        //
        hr = E_POINTER;
        AtlReportError(*pcid, IDS_ERROR_INVALID_ARGUMENT, *piid, hr, _Module.GetResourceInstance());
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr()"), hr);
        return hr;
    }

    //
    //  Convert m_dwlMsgId into BSTR pbstrId
    //
    hr = GetBstrFromDwordlong(m_dwlMsgId, pbstrId);
    if (FAILED(hr))
    {
        AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr, _Module.GetResourceInstance());
        return hr;
    }

    return hr;
}

//
//====================== GET SIZE ================================================
//
template<class T, const IID* piid, const CLSID *pcid, FAX_ENUM_MESSAGE_FOLDER FolderType> 
STDMETHODIMP 
CFaxMessageInner<T, piid, pcid, FolderType>::get_Size(
    long *plSize
)
/*++

Routine name : CFaxMessageInner::get_Size

Routine description:

    Return Size ( in bytes ) of Fax Message's TIFF File

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    plSize                  [out]    - Pointer to the place to put Size

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxMessageInner::get_Size"), hr);

    hr = GetLong(plSize, m_lSize);
    if (FAILED(hr))
    {
		AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr, _Module.GetResourceInstance());
        return hr;
    }
	return hr;
}

//
//====================== GET PAGES ================================================
//
template<class T, const IID* piid, const CLSID *pcid, FAX_ENUM_MESSAGE_FOLDER FolderType> 
STDMETHODIMP 
CFaxMessageInner<T, piid, pcid, FolderType>::get_Pages(
    long *plPages
)
/*++

Routine name : CFaxMessageInner::get_Pages

Routine description:

    Return total number of pages of the message

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    plPages                 [out]    - Pointer to the place to put the value

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxMessageInner::get_Pages"), hr);

    hr = GetLong(plPages, m_lPages);
    if (FAILED(hr))
    {
		AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr, _Module.GetResourceInstance());
        return hr;
    }
	return hr;
}

//
//====================== GET TSID ================================================
//
template<class T, const IID* piid, const CLSID *pcid, FAX_ENUM_MESSAGE_FOLDER FolderType> 
STDMETHODIMP 
CFaxMessageInner<T, piid, pcid, FolderType>::get_TSID(
    BSTR *pbstrTSID
)
/*++

Routine name : CFaxMessageInner::get_TSID

Routine description:

    Return Transmitting Station ID of the Message

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    pbstrTSID             [out]    - pointer to the place to put the TSID

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxMessageInner::get_TSID"), hr);

    hr = GetBstr(pbstrTSID, m_bstrTSID);
    if (FAILED(hr))
    {
		AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr, _Module.GetResourceInstance());
        return hr;
    }
	return hr;
}

//
//====================== GET CSID ================================================
//
template<class T, const IID* piid, const CLSID *pcid, FAX_ENUM_MESSAGE_FOLDER FolderType> 
STDMETHODIMP 
CFaxMessageInner<T, piid, pcid, FolderType>::get_CSID(
    BSTR *pbstrCSID
)
/*++

Routine name : CFaxMessageInner::get_CSID

Routine description:

    Return Called Station ID of the Message

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    pbstrCSID             [out]    - pointer to the place to put the CSID

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxMessageInner::get_CSID"), hr);

    hr = GetBstr(pbstrCSID, m_bstrCSID);
    if (FAILED(hr))
    {
		AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr, _Module.GetResourceInstance());
        return hr;
    }
	return hr;
}

//
//====================== GET PRIORITY ================================================
//
template<class T, const IID* piid, const CLSID *pcid, FAX_ENUM_MESSAGE_FOLDER FolderType> 
STDMETHODIMP 
CFaxMessageInner<T, piid, pcid, FolderType>::get_Priority(
    FAX_PRIORITY_TYPE_ENUM  *pPriority
)
/*++

Routine name : CFaxMessageInner::get_Priority

Routine description:

    Return the Priority of Fax Message

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    pPriority                  [out]    - Pointer to the place to put the Priority

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxMessageInner::get_Priority"), hr);

    //
    //  Check that we can write to the given pointer
    //
    if (::IsBadWritePtr(pPriority, sizeof(FAX_PRIORITY_TYPE_ENUM)))
    {
        //
        //  Got Bad Return Pointer
        //
        hr = E_POINTER;
        AtlReportError(*pcid, IDS_ERROR_INVALID_ARGUMENT, *piid, hr, _Module.GetResourceInstance());
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr"), hr);
        return hr;
    }

    *pPriority = FAX_PRIORITY_TYPE_ENUM(m_Priority);
    return hr;
}

//
//====================== GET RETRIES ================================================
//
template<class T, const IID* piid, const CLSID *pcid, FAX_ENUM_MESSAGE_FOLDER FolderType> 
STDMETHODIMP 
CFaxMessageInner<T, piid, pcid, FolderType>::get_Retries(
    long *plRetries
)
/*++

Routine name : CFaxMessageInner::get_Retries

Routine description:

    Number of failed transmission retries

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    plRetries             [out]    - Pointer to the place to put Retries value

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;

    DBG_ENTER (TEXT("CFaxMessageInner::get_Retries"), hr);

    hr = GetLong(plRetries, m_lRetries);
    if (FAILED(hr))
    {
		AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr, _Module.GetResourceInstance());
        return hr;
    }
	return hr;
}

//
//====================== GET DEVICE NAME ================================================
//
template<class T, const IID* piid, const CLSID *pcid, FAX_ENUM_MESSAGE_FOLDER FolderType> 
STDMETHODIMP 
CFaxMessageInner<T, piid, pcid, FolderType>::get_DeviceName(
    BSTR *pbstrDeviceName
)
/*++

Routine name : CFaxMessageInner::get_DeviceName

Routine description:

    Return the Name of the Device by which the Message was Received / Transmitted.

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    pbstrDeviceName             [out]    - pointer to the place to put the Device Name

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxMessageInner::get_DeviceName"), hr);

    hr = GetBstr(pbstrDeviceName, m_bstrDeviceName);
    if (FAILED(hr))
    {
		AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr, _Module.GetResourceInstance());
        return hr;
    }
	return hr;
}

//
//====================== GET DOCUMENT NAME ================================================
//
template<class T, const IID* piid, const CLSID *pcid, FAX_ENUM_MESSAGE_FOLDER FolderType> 
STDMETHODIMP 
CFaxMessageInner<T, piid, pcid, FolderType>::get_DocumentName(
    BSTR *pbstrDocumentName
)
/*++

Routine name : CFaxMessageInner::get_DocumentName

Routine description:

    Return the Friendly Name of the Document

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    pbstrDocumentName             [out]    - pointer to the place to put Document Name

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxMessageInner::get_DocumentName"), hr);

    hr = GetBstr(pbstrDocumentName, m_bstrDocName);
    if (FAILED(hr))
    {
		AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr, _Module.GetResourceInstance());
        return hr;
    }
	return hr;
}

//
//====================== GET SUBJECT ================================================
//
template<class T, const IID* piid, const CLSID *pcid, FAX_ENUM_MESSAGE_FOLDER FolderType> 
STDMETHODIMP 
CFaxMessageInner<T, piid, pcid, FolderType>::get_Subject(
    BSTR *pbstrSubject
)
/*++

Routine name : CFaxMessageInner::get_Subject

Routine description:

    Return the Subject field of the Cover Page

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    pbstrSubject            [out]    - pointer to the place to put Subject contents

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxMessageInner::get_Subject"), hr);

    hr = GetBstr(pbstrSubject, m_bstrSubject);
    if (FAILED(hr))
    {
		AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr, _Module.GetResourceInstance());
        return hr;
    }
	return hr;
}

//
//====================== GET CALLER ID ================================================
//
template<class T, const IID* piid, const CLSID *pcid, FAX_ENUM_MESSAGE_FOLDER FolderType> 
STDMETHODIMP 
CFaxMessageInner<T, piid, pcid, FolderType>::get_CallerId(
    BSTR *pbstrCallerId
)
/*++

Routine name : CFaxMessageInner::get_CallerId

Routine description:

    Return the Caller Id of Message's Phone Call

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    pbstrCallerId           [out]    - pointer to the place to put the Caller Id

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxMessageInner::get_CallerId"), hr);

    hr = GetBstr(pbstrCallerId, m_bstrCallerId);
    if (FAILED(hr))
    {
		AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr, _Module.GetResourceInstance());
        return hr;
    }
	return hr;
}

//
//====================== GET ROUTING INFORMATION ======================================
//
template<class T, const IID* piid, const CLSID *pcid, FAX_ENUM_MESSAGE_FOLDER FolderType> 
STDMETHODIMP 
CFaxMessageInner<T, piid, pcid, FolderType>::get_RoutingInformation(
    BSTR *pbstrRoutingInformation
)
/*++

Routine name : CFaxMessageInner::get_RoutingInformation

Routine description:

    Return the Routing Information of the Message

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    pbstrRoutingInformation         [out]    - pointer to place to put Routing Information

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxMessageInner::get_RoutingInformation"), hr);

    hr = GetBstr(pbstrRoutingInformation, m_bstrRoutingInfo);
    if (FAILED(hr))
    {
		AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr, _Module.GetResourceInstance());
        return hr;
    }
	return hr;
}

//
//========================= GET TRANSMITTION START TIME ===============================
//
template<class T, const IID* piid, const CLSID *pcid, FAX_ENUM_MESSAGE_FOLDER FolderType> 
STDMETHODIMP 
CFaxMessageInner<T, piid, pcid, FolderType>::get_TransmissionStart(
    DATE *pdateTransmissionStart
)
/*++

Routine name : CFaxMessageInner::get_TransmissionStart

Routine description:

    Return Time the Message started its Transmission

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    pbstrTransmissionStart      [out]    - pointer to place to put Transmission Start

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxMessageInner::get_TransmissionStart"), hr);

    //
    //  Check that we can write to the given pointer
    //
    if (::IsBadWritePtr(pdateTransmissionStart, sizeof(DATE)))
    {
        //  
        //  Got Bad Ptr
        //  
        hr = E_POINTER;
        AtlReportError(*pcid, IDS_ERROR_INVALID_ARGUMENT, *piid, hr, _Module.GetResourceInstance());
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr()"), hr);
        return hr;
    }

    *pdateTransmissionStart = m_dtTransmissionStart;
    return hr;
}

//
//========================= GET TRANSMITTION END TIME ===============================
//
template<class T, const IID* piid, const CLSID *pcid, FAX_ENUM_MESSAGE_FOLDER FolderType> 
STDMETHODIMP 
CFaxMessageInner<T, piid, pcid, FolderType>::get_TransmissionEnd(
    DATE *pdateTransmissionEnd
)
/*++

Routine name : CFaxMessageInner::get_TransmissionEnd

Routine description:

    Return Time the Message ended its Transmission

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    pbstrTransmissionEnd        [out]    - pointer to place to put Transmission End

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxMessageInner::get_TransmissionEnd"), hr);

    //
    //  Check that we can write to the given pointer
    //
    if (::IsBadWritePtr(pdateTransmissionEnd, sizeof(DATE)))
    {
        //  
        //  Got Bad Ptr
        //  
        hr = E_POINTER;
        AtlReportError(*pcid, IDS_ERROR_INVALID_ARGUMENT, *piid, hr, _Module.GetResourceInstance());
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr()"), hr);
        return hr;
    }

    *pdateTransmissionEnd = m_dtTransmissionEnd;
    return hr;
}

//
//========================= GET ORIGINAL SCHEDULED TIME ===============================
//
template<class T, const IID* piid, const CLSID *pcid, FAX_ENUM_MESSAGE_FOLDER FolderType> 
STDMETHODIMP 
CFaxMessageInner<T, piid, pcid, FolderType>::get_OriginalScheduledTime(
    DATE *pdateOriginalScheduledTime
)
/*++

Routine name : CFaxMessageInner::get_OriginalScheduledTime

Routine description:

    Return Time the Message was originally scheduled

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    pbstrOriginalScheduledTime      [out]    - pointer to place to put Original Scheduled Time

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;

    DBG_ENTER (TEXT("CFaxMessageInner::get_OriginalScheduledTime"), hr);

    //
    //  Check that we can write to the given pointer
    //
    if (::IsBadWritePtr(pdateOriginalScheduledTime, sizeof(DATE)))
    {
        //  
        //  Got Bad Ptr
        //  
        hr = E_POINTER;
        AtlReportError(*pcid, IDS_ERROR_INVALID_ARGUMENT, *piid, hr, _Module.GetResourceInstance());
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr()"), hr);
        return hr;
    }

    *pdateOriginalScheduledTime = m_dtOriginalScheduledTime;
    return hr;
}

//
//========================= GET SUBMISSION TIME ===============================
//
template<class T, const IID* piid, const CLSID *pcid, FAX_ENUM_MESSAGE_FOLDER FolderType> 
STDMETHODIMP 
CFaxMessageInner<T, piid, pcid, FolderType>::get_SubmissionTime(
    DATE *pdateSubmissionTime
)
/*++

Routine name : CFaxMessageInner::get_SubmissionTime

Routine description:

    Return Time the Message was submitted

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    pdateSubmissionTime     [out]    - pointer to place to put Submission Time

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxMessageInner::get_SubmissionTime"), hr);

    //
    //  Check that we can write to the given pointer
    //
    if (::IsBadWritePtr(pdateSubmissionTime, sizeof(DATE)))
    {
        //  
        //  Got Bad Ptr
        //  
        hr = E_POINTER;
        AtlReportError(*pcid, IDS_ERROR_INVALID_ARGUMENT, *piid, hr, _Module.GetResourceInstance());
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr()"), hr);
        return hr;
    }

    *pdateSubmissionTime = m_dtSubmissionTime;
    return hr;
}

//
//====================== GET SUBMISSION ID ================================================
//
template<class T, const IID* piid, const CLSID *pcid, FAX_ENUM_MESSAGE_FOLDER FolderType> 
STDMETHODIMP 
CFaxMessageInner<T, piid, pcid, FolderType>::get_SubmissionId(
    BSTR *pbstrSubmissionId
)
/*++

Routine name : CFaxMessageInner::get_SubmissionId

Routine description:

    Return Submission ID of the Message

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    pbstrSubmissionId             [out]    - pointer to the place to put the Submission ID 

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxMessageInner::get_SubmissionId"), hr);

    hr = GetBstr(pbstrSubmissionId, m_bstrSubmissionId);
    if (FAILED(hr))
    {
		AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr, _Module.GetResourceInstance());
        return hr;
    }
	return hr;
}

//
//====================== DELETE ================================================
//
template<class T, const IID* piid, const CLSID *pcid, FAX_ENUM_MESSAGE_FOLDER FolderType> 
STDMETHODIMP 
CFaxMessageInner<T, piid, pcid, FolderType>::Delete()
/*++

Routine name : CFaxMessageInner::Delete

Routine description:

    Delete the Message from the Archive

Author:

    Iv Garber (IvG),    May, 2000

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    HANDLE      hFaxHandle = NULL;

    DBG_ENTER (TEXT("CFaxMessageInner::Delete"), hr);

    //
    //  Get Fax Server Handle
    //
    hr = GetFaxHandle(&hFaxHandle);
    if (FAILED(hr))
    {
        AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr, _Module.GetResourceInstance());
        return hr;
    }

    if (!FaxRemoveMessage(hFaxHandle, m_dwlMsgId, FolderType))
    {
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr, _Module.GetResourceInstance());
        CALL_FAIL(GENERAL_ERR, 
            _T("FaxRemoveMessage(hFaxHandle, m_FaxMsg.dwlMessageId, FolderType)"), 
            hr);
        return hr;
    }

    return hr;
}

//
//====================== COPY TIFF ================================================
//
template<class T, const IID* piid, const CLSID *pcid, FAX_ENUM_MESSAGE_FOLDER FolderType> 
STDMETHODIMP 
CFaxMessageInner<T, piid, pcid, FolderType>::CopyTiff(
    /*[in]*/ BSTR bstrTiffPath
)
/*++

Routine name : CFaxMessageInner::CopyTiff

Routine description:

    Copies the Fax Message Tiff Image to a file on the local computer.

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    bstrTiffPath                  [in]    - the file to copy to

Return Value:

    Standard    HRESULT     code

--*/
{
    HRESULT     hr = S_OK;
    HANDLE      hFaxHandle = NULL;

    DBG_ENTER (TEXT("CFaxMessageInner::CopyTiff"), hr, _T("%s"), bstrTiffPath);

    //
    //  Get Fax Server Handle
    //
    hr = GetFaxHandle(&hFaxHandle);
    if (FAILED(hr))
    {
        AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr, _Module.GetResourceInstance());
        return hr;
    }

    if (!FaxGetMessageTiff(hFaxHandle, m_dwlMsgId, FolderType, bstrTiffPath))
    {
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr, _Module.GetResourceInstance());
        CALL_FAIL(GENERAL_ERR, 
            _T("FaxGetMessageTiff(hFaxHandle, m_FaxMsg.dwlMessageId, FolderType, bstrTiffPath)"), 
            hr);
        return hr;
    }

    return hr;
}

//
//==================== INIT ===================================================
//
template<class T, const IID* piid, const CLSID *pcid, FAX_ENUM_MESSAGE_FOLDER FolderType> 
STDMETHODIMP 
CFaxMessageInner<T, piid, pcid, FolderType>::Init(
    /*[in]*/ PFAX_MESSAGE pFaxMessage,
    IFaxServerInner* pFaxServerInner
)
/*++

Routine name : CFaxMessageInner::Init

Routine description:

    Initialize the Message Inner Class : put Message Information and Ptr to Server

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    pFaxMessage                   [in]    - Message Info
    pFaxServerInner               [in]    - Ptr to Server

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;

    DBG_ENTER (TEXT("CFaxMessageInner::Init"), hr);

    //
    //  dwlBroadcastId is DWORDLONG, we need to convert it to the BSTR
    //
    TCHAR       tcBuffer[25];
    ::_i64tot(pFaxMessage->dwlBroadcastId, tcBuffer, 16);
    m_bstrSubmissionId = tcBuffer;

    m_bstrTSID = pFaxMessage->lpctstrTsid;
    m_bstrCSID = pFaxMessage->lpctstrCsid;
    m_bstrDeviceName = pFaxMessage->lpctstrDeviceName;
    m_bstrDocName = pFaxMessage->lpctstrDocumentName;
    m_bstrSubject = pFaxMessage->lpctstrSubject;
    m_bstrCallerId = pFaxMessage->lpctstrCallerID;
    m_bstrRoutingInfo = pFaxMessage->lpctstrRoutingInfo;
	m_dwValidityMask = pFaxMessage->dwValidityMask;

    if ( (!m_bstrSubmissionId) ||
         (pFaxMessage->lpctstrTsid && !m_bstrTSID) ||
         (pFaxMessage->lpctstrCsid && !m_bstrCSID) ||
         (pFaxMessage->lpctstrDeviceName && !m_bstrDeviceName) ||
         (pFaxMessage->lpctstrDocumentName && !m_bstrDocName) ||
         (pFaxMessage->lpctstrSubject && !m_bstrSubject) ||
         (pFaxMessage->lpctstrCallerID && !m_bstrCallerId) ||
         (pFaxMessage->lpctstrRoutingInfo && !m_bstrRoutingInfo) )
    {
        //
        //  Not Enough Memory
        //
        hr = E_OUTOFMEMORY;
        AtlReportError(*pcid, IDS_ERROR_OUTOFMEMORY, *piid, hr, _Module.GetResourceInstance());
        CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
        return hr;
    }

    m_lSize = pFaxMessage->dwSize;
    m_lPages = pFaxMessage->dwPageCount;
    m_Priority = FAX_PRIORITY_TYPE_ENUM(pFaxMessage->Priority);
    m_lRetries = pFaxMessage->dwRetries;
    m_dwlMsgId = pFaxMessage->dwlMessageId;

    //
    //  convert time fields to local variant date
    //
	if (m_dwValidityMask & FAX_JOB_FIELD_TRANSMISSION_START_TIME)
	{
		hr = SystemTime2LocalDate(pFaxMessage->tmTransmissionStartTime, &m_dtTransmissionStart);
        if (FAILED(hr))
        {
            hr = E_FAIL;
            CALL_FAIL(GENERAL_ERR, _T("SystemTime2LocalDate(TransmissionStartTime)"), hr);
            AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr, _Module.GetResourceInstance());
            return hr;
        }
    }
    else
    {
        m_dtTransmissionStart = DATE(0);
    }

	if (m_dwValidityMask & FAX_JOB_FIELD_TRANSMISSION_END_TIME)
	{
        hr = SystemTime2LocalDate(pFaxMessage->tmTransmissionEndTime, &m_dtTransmissionEnd);
        if (FAILED(hr))
        {
            hr = E_FAIL;
            CALL_FAIL(GENERAL_ERR, _T("SystemTime2LocalDate(TransmissionEndTime)"), hr);
            AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr, _Module.GetResourceInstance());
            return hr;
        }
    }
    else
    {
        m_dtTransmissionStart = DATE(0);
    }


	if (m_dwValidityMask & FAX_JOB_FIELD_ORIGINAL_SCHEDULE_TIME)
	{
        hr = SystemTime2LocalDate(pFaxMessage->tmOriginalScheduleTime, &m_dtOriginalScheduledTime);
        if (FAILED(hr))
        {
            hr = E_FAIL;
            CALL_FAIL(GENERAL_ERR, _T("SystemTime2LocalDate(OriginalScheduledTime)"), hr);
            AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr, _Module.GetResourceInstance());
            return hr;
        }
    }
    else
    {
        m_dtTransmissionStart = DATE(0);
    }

	if (m_dwValidityMask & FAX_JOB_FIELD_SUBMISSION_TIME)
	{
        hr = SystemTime2LocalDate(pFaxMessage->tmSubmissionTime, &m_dtSubmissionTime);
        if (FAILED(hr))
        {
            hr = E_FAIL;
            CALL_FAIL(GENERAL_ERR, _T("SystemTime2LocalDate(SubmissionTime)"), hr);
            AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr, _Module.GetResourceInstance());
            return hr;
        }
    }
    else
    {
        m_dtTransmissionStart = DATE(0);
    }

    hr = CFaxInitInnerAddRef::Init(pFaxServerInner);
    return hr;
}

//
//====================== GET SENDER ================================================
//
template<class T, const IID* piid, const CLSID *pcid, FAX_ENUM_MESSAGE_FOLDER FolderType> 
STDMETHODIMP
CFaxMessageInner<T, piid, pcid, FolderType>::get_Sender(
    /*[out, retval] */IFaxSender **ppFaxSender
)
/*++

Routine name : CFaxMessageInner::get_Sender

Routine description:

    Return Message Sender Information

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    ppFaxSender             [out]    - Ptr to the Place to put Sender object

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;

    DBG_ENTER (TEXT("CFaxMessageInner::get_Sender"), hr);

    //
    //  Check that we can write to the given pointer
    //
    if (::IsBadWritePtr(ppFaxSender, sizeof(IFaxSender* )))
    {
        //
        //  got bad pointer
        //
        hr = E_POINTER;
        AtlReportError(*pcid, IDS_ERROR_INVALID_ARGUMENT, *piid, hr, _Module.GetResourceInstance());
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr()"), hr);
        return hr;
    }

    if (!m_pSender)
    {
        //
        //  We have been called for the First Time. Bring Sender's data from the Server
        //

        //
        //  Get Fax Server Handle
        //
        HANDLE  hFaxHandle = NULL;
        hr = GetFaxHandle(&hFaxHandle);
        if (FAILED(hr))
        {
            AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr, _Module.GetResourceInstance());
            return hr;
        }

        //
        //  Get Sender Info
        //
        CFaxPtr<FAX_PERSONAL_PROFILE>   pPersonalProfile;
        if (!FaxGetSenderInfo(hFaxHandle, m_dwlMsgId, FolderType, &pPersonalProfile))
        {
            //
            //  Failed to get Sender Info
            //
            hr = Fax_HRESULT_FROM_WIN32(GetLastError());
            AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr, _Module.GetResourceInstance());
            CALL_FAIL(GENERAL_ERR, _T("FaxGetSenderInfo()"), hr);
            return hr;
        }

        //
        //  Check that pPersonalProfile is valid
        //
	    if (!pPersonalProfile || pPersonalProfile->dwSizeOfStruct != sizeof(FAX_PERSONAL_PROFILE))
	    {
		    //
		    //	Failed to Get Personal Profile
		    //
		    hr = E_FAIL;
		    AtlReportError(*pcid, IDS_ERROR_OPERATION_FAILED, *piid, hr, _Module.GetResourceInstance());
		    CALL_FAIL(GENERAL_ERR, _T("Invalid pPersonalProfile"), hr);
		    return hr;
	    }

        //
        //  Create Sender Object
        //
        hr = CComObject<CFaxSender>::CreateInstance(&m_pSender);
        if (FAILED(hr) || !m_pSender)
        {
            hr = E_OUTOFMEMORY;
            AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr, _Module.GetResourceInstance());
            CALL_FAIL(GENERAL_ERR, _T("CComObject<CFaxSender>::CreateInstance(&m_pSender)"), hr);
            return hr;
        }

        //
        //  We want Sender object to live
        //
        m_pSender->AddRef();

        //
        //  Fill the Data
        //
        hr = m_pSender->PutSenderProfile(pPersonalProfile);
        if (FAILED(hr))
        {
            //
            //  Failed to fill the Sender's Object with RPC's data
            //
            AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr, _Module.GetResourceInstance());
            CALL_FAIL(GENERAL_ERR, _T("m_pSender->PutSenderProfile(pPersonalProfile)"), hr);
            m_pSender->Release();
            m_pSender = NULL;
            return hr;
        }
    }

    //
    //  Return Sender Object to Caller
    //
    hr = m_pSender->QueryInterface(ppFaxSender);
    if (FAILED(hr))
    {
        //
        //  Failed to query interface
        //
        AtlReportError(*pcid, IDS_ERROR_OPERATION_FAILED, *piid, hr, _Module.GetResourceInstance());
        CALL_FAIL(MEM_ERR, _T("CComObject<CFaxSender>::QueryInterface()"), hr);
        return hr;
    }

    return hr;
}
    
//
//====================== GET RECIPIENT ================================================
//
template<class T, const IID* piid, const CLSID *pcid, FAX_ENUM_MESSAGE_FOLDER FolderType> 
STDMETHODIMP
CFaxMessageInner<T, piid, pcid, FolderType>::get_Recipient(
    /*[out, retval] */IFaxRecipient **ppRecipient
)
/*++

Routine name : CFaxMessageInner::get_Recipient

Routine description:

    Return Message Recipient object

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    ppFaxRecipient          [out]    - Ptr to the Place to put Recipient object

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;

    DBG_ENTER (_T("CFaxMessageInner::get_Recipient"), hr);

    //
    //  Check that we can write to the given pointer
    //
    if (::IsBadWritePtr(ppRecipient, sizeof(IFaxRecipient* )))
    {
        //
        //  got bad pointer
        //
        hr = E_POINTER;
        AtlReportError(*pcid, IDS_ERROR_INVALID_ARGUMENT, *piid, hr, _Module.GetResourceInstance());
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr()"), hr);
        return hr;
    }

    if (!m_pRecipient)
    {
        //
        //  We have been called for the first time
        //

        //
        //  Get Fax Server Handle
        //
        HANDLE  hFaxHandle = NULL;
        hr = GetFaxHandle(&hFaxHandle);
        if (FAILED(hr))
        {
            AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr, _Module.GetResourceInstance());
            return hr;
        }

        //
        //  Get Recipient Info
        //
        CFaxPtr<FAX_PERSONAL_PROFILE>   pPersonalProfile;
        if (!FaxGetRecipientInfo(hFaxHandle, m_dwlMsgId, FolderType, &pPersonalProfile))
        {
            //
            //  Failed to get Recipient Info
            //
            hr = Fax_HRESULT_FROM_WIN32(GetLastError());
            AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr, _Module.GetResourceInstance());
            CALL_FAIL(GENERAL_ERR, _T("FaxGetRecipientInfo()"), hr);
            return hr;
        }

        //
        //  Check that pPersonalProfile is valid
        //
	    if (!pPersonalProfile || pPersonalProfile->dwSizeOfStruct != sizeof(FAX_PERSONAL_PROFILE))
	    {
		    //
		    //	Failed to Get Personal Profile
		    //
		    hr = E_FAIL;
		    AtlReportError(*pcid, IDS_ERROR_OPERATION_FAILED, *piid, hr, _Module.GetResourceInstance());
		    CALL_FAIL(GENERAL_ERR, _T("Invalid pPersonalProfile"), hr);
		    return hr;
	    }

        //
        //  Create Recipient Object
        //
        hr = CComObject<CFaxRecipient>::CreateInstance(&m_pRecipient);
        if (FAILED(hr) || !m_pRecipient)
        {
            hr = E_OUTOFMEMORY;
            AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr, _Module.GetResourceInstance());
            CALL_FAIL(GENERAL_ERR, _T("CComObject<CFaxRecipient>::CreateInstance(&m_pRecipient)"), hr);
            return hr;
        }

        //
        //  We want Recipient object to live
        //
        m_pRecipient->AddRef();

        //
        //  Fill the Data
        //
        hr = m_pRecipient->PutRecipientProfile(pPersonalProfile);
        if (FAILED(hr))
        {
            //
            //  Failed to fill the Recipient's Object with RPC's data
            //
            AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr, _Module.GetResourceInstance());
            CALL_FAIL(GENERAL_ERR, _T("m_pRecipient->PutRecipientProfile(pPersonalProfile)"), hr);
            m_pRecipient->Release();
            m_pRecipient = NULL;
            return hr;
        }
    }

    //
    //  Return Recipient Object to Caller
    //
    hr = m_pRecipient->QueryInterface(ppRecipient);
    if (FAILED(hr))
    {
        //
        //  Failed to Query Interface
        //
        AtlReportError(*pcid, IDS_ERROR_OPERATION_FAILED, *piid, hr, _Module.GetResourceInstance());
        CALL_FAIL(MEM_ERR, _T("CComObject<CFaxRecipient>::QueryInterface()"), hr);
        return hr;
    }

    return hr;
}

#endif //   __FAXMESSAGEINNER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxoutboundrouting.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxOutboundRouting.h

Abstract:

	Declaration of the CFaxOutboundRouting class.

Author:

	Iv Garber (IvG)	Jun, 2000

Revision History:

--*/

#ifndef __FAXOUTBOUNDROUTING_H_
#define __FAXOUTBOUNDROUTING_H_

#include "resource.h"       // main symbols
#include "FaxCommon.h"

//
//=================== FAX OUTBOUND ROUTING =============================================
//  Like in FaxInboundRouting, both ORGroups and ORRules Collections are not cached.
//  Rather they are created each time the OutboundRouting is asked for them.
//  To be sure that the Server Object is up during their lifetime, they do 
//      AddRef() on the Server Ojbect at their Init() function.

class ATL_NO_VTABLE CFaxOutboundRouting : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public ISupportErrorInfo,
	public IDispatchImpl<IFaxOutboundRouting, &IID_IFaxOutboundRouting, &LIBID_FAXCOMEXLib>,
    public CFaxInitInner
{
public:
    CFaxOutboundRouting() : CFaxInitInner(_T("FAX OUTBOUND ROUTING"))
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_FAXOUTBOUNDROUTING)
DECLARE_NOT_AGGREGATABLE(CFaxOutboundRouting)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxOutboundRouting)
	COM_INTERFACE_ENTRY(IFaxOutboundRouting)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

//  Interfaces
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

    STDMETHOD(GetGroups)(/*[out, retval]*/ IFaxOutboundRoutingGroups **ppGroups);
    STDMETHOD(GetRules)(/*[out, retval]*/ IFaxOutboundRoutingRules **ppRules);
};

#endif //__FAXOUTBOUNDROUTING_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxoutboundroutinggroup.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxOutboundRoutingGroup.h

Abstract:

	Declaration of the CFaxOutboundRoutingGroup class.

Author:

	Iv Garber (IvG)	Jun, 2000

Revision History:

--*/

#ifndef __FAXOUTBOUNDROUTINGGROUP_H_
#define __FAXOUTBOUNDROUTINGGROUP_H_

#include "resource.h"       // main symbols
#include "FaxCommon.h"

//
//================= FAX OUTBOUND ROUTING GROUP ===============================
//  Fax Outbound Routing Group does not need Ptr to the Fax Server.
//  All its Properties are taken at Init.
//
class ATL_NO_VTABLE CFaxOutboundRoutingGroup : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public ISupportErrorInfo,
	public IDispatchImpl<IFaxOutboundRoutingGroup, &IID_IFaxOutboundRoutingGroup, &LIBID_FAXCOMEXLib>
{
public:
    CFaxOutboundRoutingGroup() 
    {
        DBG_ENTER(_T("FAX OUTBOUND ROUTING GROUP -- CREATE"));
	}

    ~CFaxOutboundRoutingGroup()
    {
        DBG_ENTER(_T("FAX OUTBOUND ROUTING GROUP -- DESTROY"));
	}

DECLARE_REGISTRY_RESOURCEID(IDR_FAXOUTBOUNDROUTINGGROUP)
DECLARE_NOT_AGGREGATABLE(CFaxOutboundRoutingGroup)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxOutboundRoutingGroup)
	COM_INTERFACE_ENTRY(IFaxOutboundRoutingGroup)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

//  Interfaces
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

    STDMETHOD(get_Name)(/*[out, retval]*/ BSTR *pbstrName);
    STDMETHOD(get_Status)(/*[out, retval]*/ FAX_GROUP_STATUS_ENUM *pStatus);
    STDMETHOD(get_DeviceIds)(/*[out, retval]*/ IFaxDeviceIds **pFaxDeviceIds);

//  Internal Use
    STDMETHOD(Init)(FAX_OUTBOUND_ROUTING_GROUP *pInfo, IFaxServerInner *pServer);

private:
    CComBSTR                m_bstrName;
    FAX_GROUP_STATUS_ENUM   m_Status;
    CComPtr<IFaxDeviceIds>  m_pDeviceIds;
};

#endif //__FAXOUTBOUNDROUTINGGROUP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxoutboundroutinggroup.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxOutboundRoutingGroup.cpp

Abstract:

	Implementation of CFaxOutboundRoutingGroup class.

Author:

	Iv Garber (IvG)	Jun, 2000

Revision History:

--*/

#include "stdafx.h"
#include "FaxComEx.h"
#include "FaxOutboundRoutingGroup.h"
#include "FaxDeviceIds.h"

//
//========================= GET DEVICE IDS ========================================
//
STDMETHODIMP
CFaxOutboundRoutingGroup::get_DeviceIds(
    /*[out, retval]*/ IFaxDeviceIds **pFaxDeviceIds
)
/*++

Routine name : CFaxOutboundRoutingGroup::get_DeviceIds

Routine description:

	Returns DeviceIds Collection owned by the Group

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	pFaxDeviceIds                 [out]    - the Collection to Return

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxOutboundRoutingGroup::get_DeviceIds"), hr);

    //
    //  Check that Ptr we have got -- is OK
    //
    if (IsBadWritePtr(pFaxDeviceIds, sizeof(IFaxDeviceIds*)))
    {
		hr = E_POINTER;
		CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr(pFaxDeviceIds, sizeof(IFaxDeviceIds *))"), hr);
        AtlReportError(CLSID_FaxOutboundRoutingGroup, GetErrorMsgId(hr), IID_IFaxOutboundRoutingGroup, hr, _Module.GetResourceInstance());
		return hr;
	}

    //
    //  Return the m_pDeviceIds Collection Object
    //
    hr = m_pDeviceIds.CopyTo(pFaxDeviceIds);
    if (FAILED(hr))
    {
		hr = E_FAIL;
		CALL_FAIL(GENERAL_ERR, _T("CComPtr.CopyTo(pFaxDeviceIds)"), hr);
        AtlReportError(CLSID_FaxOutboundRoutingGroup, GetErrorMsgId(hr), IID_IFaxOutboundRoutingGroup, hr, _Module.GetResourceInstance());
		return hr;
    }

    return hr;
}

//
//========================= INIT ========================================
//
STDMETHODIMP
CFaxOutboundRoutingGroup::Init(
    /*[in]*/ FAX_OUTBOUND_ROUTING_GROUP *pInfo, 
    /*[in]*/ IFaxServerInner *pServer
)
/*++

Routine name : CFaxOutboundRoutingGroup::Init

Routine description:

	Initialize the Group Object with given Data.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	pInfo                         [in]    - Data of the Group
	pServer                       [in]    - Ptr to the Server

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxOutboundRoutingGroup::Init"), hr);

    m_Status = FAX_GROUP_STATUS_ENUM(pInfo->Status);

    m_bstrName = pInfo->lpctstrGroupName;
    if (pInfo->lpctstrGroupName && !m_bstrName)
    {
		//	
		//	not enough memory
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxOutboundRoutingGroup, IDS_ERROR_OUTOFMEMORY, IID_IFaxOutboundRoutingGroup, hr, _Module.GetResourceInstance());
		CALL_FAIL(MEM_ERR, _T("CComBSTR::operator=()"), hr);
		return hr;
    }

    //
    //  Create Device Ids Collection
    //
    CComObject<CFaxDeviceIds>    *pClass = NULL;
    hr = CComObject<CFaxDeviceIds>::CreateInstance(&pClass);
    if (FAILED(hr) || (!pClass))
    {
        if (!pClass)
        {
            hr = E_OUTOFMEMORY;
    		CALL_FAIL(MEM_ERR, _T("CComObject<CFaxDeviceIds>::CreateInstance(&pClass)"), hr);
        }
        else
        {
    		CALL_FAIL(GENERAL_ERR, _T("CComObject<CFaxDeviceIds>::CreateInstance(&pClass)"), hr);
        }

		AtlReportError(CLSID_FaxOutboundRoutingGroup, IDS_ERROR_OUTOFMEMORY, IID_IFaxOutboundRoutingGroup, hr, _Module.GetResourceInstance());
		return hr;
    }

    //
    //  Init the DeviceIds Collection
    //
    hr = pClass->Init(pInfo->lpdwDevices, pInfo->dwNumDevices, m_bstrName, pServer);
    if (FAILED(hr))
    {
        CALL_FAIL(GENERAL_ERR, _T("pClass->Init(pInfo->lpdwDevices, pInfo->dwNumDevices, m_bstrName, pServer)"), hr);
		AtlReportError(CLSID_FaxOutboundRoutingGroup, IDS_ERROR_OUTOFMEMORY, IID_IFaxOutboundRoutingGroup, hr, _Module.GetResourceInstance());
        delete pClass;
        return hr;
    }

    //
    //  Get Interface from the pClass.
    //  This will make AddRef() on the Interface. 
    //  This is the Collection's AddRef, which is freed at Collection's Dtor.
    //
    hr = pClass->QueryInterface(&m_pDeviceIds);
    if (FAILED(hr) || (!m_pDeviceIds))
    {
        if (!m_pDeviceIds)
        {
            hr = E_FAIL;
        }
        CALL_FAIL(GENERAL_ERR, _T("pClass->QueryInterface(&m_pDeviceIds)"), hr);
		AtlReportError(CLSID_FaxOutboundRoutingGroup, IDS_ERROR_OUTOFMEMORY, IID_IFaxOutboundRoutingGroup, hr, _Module.GetResourceInstance());
        delete pClass;
        return hr;
    }

    return hr;
}

//
//========================= GET STATUS ========================================
//
STDMETHODIMP
CFaxOutboundRoutingGroup::get_Status(
    /*[out, retval]*/ FAX_GROUP_STATUS_ENUM *pStatus
)
/*++

Routine name : CFaxOutboundRoutingGroup::get_Status

Routine description:

    Return the Status of the Group

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

    pStatus             [out]    -  the return value
    
Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxOutboundRoutingGroup::get_Status"), hr);

	//
	//	Check that we have got good Ptr
	//
	if (::IsBadWritePtr(pStatus, sizeof(FAX_GROUP_STATUS_ENUM)))
	{
		hr = E_POINTER;
		CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr(pStatus, sizeof(FAX_GROUP_STATUS_ENUM))"), hr);
        AtlReportError(CLSID_FaxOutboundRoutingGroup, GetErrorMsgId(hr), IID_IFaxOutboundRoutingGroup, hr, _Module.GetResourceInstance());
		return hr;
	}

	*pStatus = m_Status;
	return hr;
}

//
//========================= GET NAME ========================================
//
STDMETHODIMP 
CFaxOutboundRoutingGroup::get_Name(
	BSTR *pbstrName
)
/*++

Routine name : CFaxOutboundRoutingGroup::get_Name

Routine description:

	Return Name of the OR Group

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	pbstrName                   [out]    - Ptr to put the Name

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxOutboundRoutingGroup::get_Name"), hr);
    hr = GetBstr(pbstrName, m_bstrName);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxOutboundRoutingGroup, GetErrorMsgId(hr), IID_IFaxOutboundRoutingGroup, hr, _Module.GetResourceInstance());
        return hr;
    }
    return hr;
}

//
//===================== SUPPORT ERROR INFO ======================================
//
STDMETHODIMP 
CFaxOutboundRoutingGroup::InterfaceSupportsErrorInfo(
    REFIID riid
)
/*++

Routine name : CFaxOutboundRoutingGroup::InterfaceSupportsErrorInfo

Routine description:

	ATL's implementation of the ISupportErrorInfo Interface.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	riid                          [in]    - Reference to the Interface

Return Value:

    Standard HRESULT code

--*/
{
	static const IID* arr[] = 
	{
		&IID_IFaxOutboundRoutingGroup
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxoutboundrouting.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxOutboundRouting.cpp

Abstract:

	Implementation of CFaxOutboundRouting class.

Author:

	Iv Garber (IvG)	Jun, 2000

Revision History:

--*/

#include "stdafx.h"
#include "FaxComEx.h"
#include "FaxOutboundRouting.h"
#include "FaxOutboundRoutingRules.h"
#include "FaxOutboundRoutingGroups.h"

//
//===================== SUPPORT ERROR INFO ======================================
//
STDMETHODIMP 
CFaxOutboundRouting::InterfaceSupportsErrorInfo(
    REFIID riid
)
/*++

Routine name : CFaxOutboundRouting::InterfaceSupportsErrorInfo

Routine description:

	ATL's implementation of Support Error Info.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	riid                          [in]    - reference to the Interface.

Return Value:

    Standard HRESULT code

--*/
{
	static const IID* arr[] = 
	{
		&IID_IFaxOutboundRouting
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

//
//================== GET RULES COLLECTION OBJECT ==============================
//
STDMETHODIMP 
CFaxOutboundRouting::GetRules(
    IFaxOutboundRoutingRules **ppRules
)
/*++

Routine name : CFaxOutboundRouting::GetRules

Routine description:

	Return Rules Collection Object

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	ppRules             [out]    - the Rules Collection Object 

Return Value:

    Standard HRESULT code

Notes:

    Rules Collection is not cached at this level. It is created from the scratch
    each time user asks for it.

--*/
{
	HRESULT				hr = S_OK;
	DBG_ENTER (_T("CFaxOutboundRouting::GetRules"), hr);

    CObjectHandler<CFaxOutboundRoutingRules, IFaxOutboundRoutingRules>    ObjectCreator;
    hr = ObjectCreator.GetObject(ppRules, m_pIFaxServerInner);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxOutboundRouting, GetErrorMsgId(hr), IID_IFaxOutboundRouting, hr, _Module.GetResourceInstance());
        return hr;
    }
    return hr;
}

//
//================== GET GROUPS COLLECTION OBJECT ==============================
//
STDMETHODIMP 
CFaxOutboundRouting::GetGroups(
    IFaxOutboundRoutingGroups **ppGroups
)
/*++

Routine name : CFaxOutboundRouting::GetGroups

Routine description:

	Return Groups Collection Object

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	ppGroups             [out]    - the Groups Collection Object 

Return Value:

    Standard HRESULT code

Notes:

    Groups Collection is not cached at this level. It is created from the scratch
    each time user asks for it.

--*/
{
	HRESULT				hr = S_OK;
	DBG_ENTER (_T("CFaxOutboundRouting::GetGroups"), hr);

    CObjectHandler<CFaxOutboundRoutingGroups, IFaxOutboundRoutingGroups>    ObjectCreator;
    hr = ObjectCreator.GetObject(ppGroups, m_pIFaxServerInner);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxOutboundRouting, GetErrorMsgId(hr), IID_IFaxOutboundRouting, hr, _Module.GetResourceInstance());
        return hr;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxoutboundroutinggroups.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxOutboundRoutingGroups.h

Abstract:

	Declaration of the CFaxOutboundRoutingGroups class.

Author:

	Iv Garber (IvG)	Jun, 2000

Revision History:

--*/

#ifndef __FAXOUTBOUNDROUTINGGROUPS_H_
#define __FAXOUTBOUNDROUTINGGROUPS_H_

#include "resource.h"       // main symbols
#include <vector>
#include "VCUE_Copy.h"
#include "FaxCommon.h"

namespace GroupsNamespace
{
    //
    //  Group Objects are stored in Vector of STL.
    //
    //  When initialized, they got ALL their data, and Fax Server Ptr.
    //  They do NOT depend on Groups Collection, and NOT on the Fax Server Object. 
    //
    //  The Collection makes ONE AddRef() for each Group Object, to prevent its death. 
    //  When killed, Collection calls Release() on all its Group Objects.
    //
	typedef	std::vector<IFaxOutboundRoutingGroup*>       ContainerType;

	// Use IEnumVARIANT as the enumerator for VB compatibility
	typedef	VARIANT			EnumExposedType;
	typedef	IEnumVARIANT    EnumIfc;

	//  Copy Classes
    typedef VCUE::CopyIfc2Variant<ContainerType::value_type>    EnumCopyType;
    typedef VCUE::CopyIfc<ContainerType::value_type>            CollectionCopyType;

    typedef CComEnumOnSTL< EnumIfc, &__uuidof(EnumIfc), EnumExposedType, EnumCopyType, 
        ContainerType >    EnumType;

    typedef ICollectionOnSTLImpl< IFaxOutboundRoutingGroups, ContainerType, 
        ContainerType::value_type, CollectionCopyType, EnumType >    CollectionType;
};

using namespace GroupsNamespace;

//
//==================== FAX OUTBOUND ROUTING GROUPS ===================================
//
//  FaxOutboundRoutingGroups creates a collection of all its Group Objects at Init.
//  It needs Ptr to the Fax Server Object, for Add and Remove operations. 
//  To prevent the death of the Fax Server before its own death, the Collection
//  makes AddRef() on Server. To do this, it inherits from CFaxInitInnerAddRef.
//  
//  When creating Group Objects, the Collection passes Ptr to the Fax Server Object
//  to them, and from this moment, the Objects are not dependent on the Collection.
//  They live their own lifes. Collection makes one AddRef() on them, to prevent their 
//  death before its own death, exactly as in the case with the Fax Server Object.
//
//  The Group Object itself does NOT need Ptr to the Fax Server Object.
//
class ATL_NO_VTABLE CFaxOutboundRoutingGroups : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public ISupportErrorInfo,
    public IDispatchImpl<GroupsNamespace::CollectionType, &IID_IFaxOutboundRoutingGroups, &LIBID_FAXCOMEXLib>,
    public CFaxInitInnerAddRef
{
public:
    CFaxOutboundRoutingGroups() : CFaxInitInnerAddRef(_T("FAX OUTBOUND ROUTING GROUPS"))
	{
	}

    ~CFaxOutboundRoutingGroups()
    {
        CCollectionKiller<GroupsNamespace::ContainerType>  CKiller;
        CKiller.EmptyObjectCollection(&m_coll);
    }

DECLARE_REGISTRY_RESOURCEID(IDR_FAXOUTBOUNDROUTINGGROUPS)
DECLARE_NOT_AGGREGATABLE(CFaxOutboundRoutingGroups)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxOutboundRoutingGroups)
	COM_INTERFACE_ENTRY(IFaxOutboundRoutingGroups)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY(IFaxInitInner)
END_COM_MAP()

//  Interfaces
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

    STDMETHOD(get_Item)(/*[in]*/ VARIANT vIndex, /*[out, retval]*/ IFaxOutboundRoutingGroup **ppGroup);
    STDMETHOD(Remove)(/*[in]*/ VARIANT vIndex);
    STDMETHOD(Add)(/*[in]*/ BSTR bstrName, /*[out, retval]*/ IFaxOutboundRoutingGroup **ppGroup);

//  Internal Use
    static HRESULT Create(IFaxOutboundRoutingGroups **ppGroups);
    STDMETHOD(Init)(IFaxServerInner *pServer);

private:
    STDMETHOD(AddGroup)(/*[in]*/ FAX_OUTBOUND_ROUTING_GROUP *pInfo, IFaxOutboundRoutingGroup **ppNewGroup = NULL);
    STDMETHOD(FindGroup)(/*[in]*/ VARIANT vIndex, /*[out]*/ GroupsNamespace::ContainerType::iterator &it);
};

#endif //__FAXOUTBOUNDROUTINGGROUPS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxmessageiteratorinner.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxMessageIteratorInner.h

Abstract:

	Implementation of Fax Message Iterator  Inner Class : 
		Base Class for Inbound and Outbound Message Iterators Classes.

Author:

	Iv Garber (IvG)	May, 2000

Revision History:

--*/


#ifndef __FAXMESSAGEITERATORINNER_H_
#define __FAXMESSAGEITERATORINNER_H_

#include "FaxCommon.h"


//
//===================== FAX MESSAGE ITERATOR INNER CLASS ===============================
//
template<class T, const IID* piid, const CLSID* pcid, FAX_ENUM_MESSAGE_FOLDER FolderType,
         class MsgIfc, class MsgType> 
class CFaxMessageIteratorInner : 
	public IDispatchImpl<T, piid, &LIBID_FAXCOMEXLib>,
	public CFaxInitInnerAddRef
{
public:
    CFaxMessageIteratorInner() : CFaxInitInnerAddRef(_T("FAX MESSAGE ITERATOR INNER")),
        m_dwPrefetchSize(prv_DEFAULT_PREFETCH_SIZE),
        m_hEnum(NULL)
	{};

	virtual ~CFaxMessageIteratorInner() 
	{
        DBG_ENTER(_T("CFaxMessageIteratorInner::Dtor"));
		if (m_hEnum)
		{
			//
			//	Close currently active Enumeration
			//
			FaxEndMessagesEnum(m_hEnum);

		}
	}

	STDMETHOD(get_PrefetchSize)(/*[out, retval]*/ long *plPrefetchSize);
	STDMETHOD(put_PrefetchSize)(/*[in]*/ long lPrefetchSize);
	STDMETHOD(get_AtEOF)(/*[out, retval]*/ VARIANT_BOOL *pbEOF);
	STDMETHOD(MoveFirst)();
	STDMETHOD(MoveNext)();
	STDMETHOD(get_Message)(MsgIfc **ppMessage);

private:
	DWORD			        m_dwPrefetchSize;
	HANDLE			        m_hEnum;
	CFaxPtr<FAX_MESSAGE>	m_pMsgList;
	DWORD			        m_dwTotalMsgNum;
	DWORD			        m_dwCurMsgNum;

private:
	HRESULT RetrieveMessages();
	HRESULT SetEOF();
};

//
//====================== GET PREFETCH SIZE ================================================
//
template<class T, const IID* piid, const CLSID* pcid, FAX_ENUM_MESSAGE_FOLDER FolderType,
         class MsgIfc, class MsgType> 
STDMETHODIMP 
CFaxMessageIteratorInner<T, piid, pcid, FolderType, MsgIfc, MsgType>::get_PrefetchSize(
	long *plPrefetchSize
)
/*++

Routine name : CFaxMessageIteratorInner::get_PrefetchSize

Routine description:

	Return current Prefetch Size value

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	plPrefetchSize			[out]    - pointer to the place to put the PrefetchSize value

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxMessageInner::get_PrefetchSize"), hr);

    //
    //  If not yet, start Enumeration
    //
    if (!m_hEnum)
    {
        hr = MoveFirst();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    hr = GetLong(plPrefetchSize, m_dwPrefetchSize);
    if (FAILED(hr))
    {
        AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr, _Module.GetResourceInstance());
        return hr;
    }
	return hr;
}

//
//====================== PUT PREFETCH SIZE ================================================
//
template<class T, const IID* piid, const CLSID* pcid, FAX_ENUM_MESSAGE_FOLDER FolderType,
         class MsgIfc, class MsgType> 
STDMETHODIMP 
CFaxMessageIteratorInner<T, piid, pcid, FolderType, MsgIfc, MsgType>::put_PrefetchSize(
	long lPrefetchSize
)
/*++

Routine name : CFaxMessageIteratorInner::put_PrefetchSize

Routine description:

	Set the Prefetch Size 

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	lPrefetchSize			[in]    - the value of the Prefetch Size to set

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;

	DBG_ENTER (TEXT("CFaxMessageInner::put_PrefetchSize"), hr, _T("%ld"), lPrefetchSize);

    //
    //  If not yet, start Enumeration
    //
    if (!m_hEnum)
    {
        hr = MoveFirst();
        if (FAILED(hr))
        {
            return hr;
        }
    }

	//
	//	Check that lPrefetchSize is valid 
	//
	if (lPrefetchSize < 1)
	{
		//
		//	illegal value
		//
		hr = E_INVALIDARG;
		AtlReportError(*pcid, IDS_ERROR_ZERO_PREFETCHSIZE, *piid, hr, _Module.GetResourceInstance());
		CALL_FAIL(GENERAL_ERR, _T("lPrefetchSize < 1"), hr);
		return hr;
	}

	m_dwPrefetchSize = lPrefetchSize;
	return hr;
}

//
//====================== GET AtEOF ====================================================
//
template<class T, const IID* piid, const CLSID* pcid, FAX_ENUM_MESSAGE_FOLDER FolderType,
         class MsgIfc, class MsgType> 
STDMETHODIMP 
CFaxMessageIteratorInner<T, piid, pcid, FolderType, MsgIfc, MsgType>::get_AtEOF(
	VARIANT_BOOL *pbEOF
)
/*++

Routine name : CFaxMessageIteratorInner::get_EOF

Routine description:

	Return EOF value

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	pbEOF			[out]    - pointer to the place to put the EOF value

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxMessageInner::get_EOF"), hr);

    //
    //  If not yet, start Enumeration
    //
    if (!m_hEnum)
    {
        hr = MoveFirst();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    hr = GetVariantBool(pbEOF, ((m_pMsgList) ? VARIANT_FALSE : VARIANT_TRUE));
    if (FAILED(hr))
    {
        AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr, _Module.GetResourceInstance());
        return hr;
    }
	return hr;
}

//
//====================== MOVE FIRST ================================================
//
template<class T, const IID* piid, const CLSID* pcid, FAX_ENUM_MESSAGE_FOLDER FolderType,
         class MsgIfc, class MsgType> 
STDMETHODIMP 
CFaxMessageIteratorInner<T, piid, pcid, FolderType, MsgIfc, MsgType>::MoveFirst(
)
/*++

Routine name : CFaxMessageIteratorInner::MoveFirst

Routine description:

	Start New Enumeration

Author:

	Iv Garber (IvG),	May, 2000

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxMessageIteratorInner::MoveFirst"), hr);

	//
	//	Clear current Msg List
	//
	SetEOF();

	if (m_hEnum)
	{
		//
		//	Enumeration already started. Close it before starting new one
		//
		if (!FaxEndMessagesEnum(m_hEnum))
		{
			//
			//	Failed to Stop current Enumeration
			//
			hr = Fax_HRESULT_FROM_WIN32(GetLastError());
			AtlReportError(*pcid, IDS_ERROR_OPERATION_FAILED, *piid, hr, _Module.GetResourceInstance());
			CALL_FAIL(GENERAL_ERR, _T("FaxEndMessagesEnum(hEnum)"), hr);
			return hr;
		}

		m_hEnum = NULL;
	}

	//
	//	Get Fax Server Handle
	//
	HANDLE	hFaxHandle = NULL;
	hr = GetFaxHandle(&hFaxHandle);
	if (FAILED(hr))
	{
		AtlReportError(*pcid, IDS_ERROR_OPERATION_FAILED, *piid, hr, _Module.GetResourceInstance());
		return hr;
	}

	//
	//	Start new Enumeration
	//
	if (!FaxStartMessagesEnum(hFaxHandle, FolderType, &m_hEnum))
	{
		//
		//	Failed to Start an Enumeration
		//
		DWORD	dwError = GetLastError();

		if (dwError == ERROR_FILE_NOT_FOUND)
		{
			//
			//	EOF case
			//
			return hr;
		}

   		hr = Fax_HRESULT_FROM_WIN32(dwError);
		AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr, _Module.GetResourceInstance());
		CALL_FAIL(GENERAL_ERR, _T("FaxStartMessagesEnum()"), hr);
		return hr;
	}

	//
	//	Bring new Msg List
	//
	hr = RetrieveMessages();
	return hr;
}


//
//====================== RETRIEVE MESSAGES ================================================
//
template<class T, const IID* piid, const CLSID* pcid, FAX_ENUM_MESSAGE_FOLDER FolderType,
         class MsgIfc, class MsgType> 
HRESULT
CFaxMessageIteratorInner<T, piid, pcid, FolderType, MsgIfc, MsgType>::RetrieveMessages(
)
/*++

Routine name : CFaxMessageIteratorInner::RetrieveMessages

Routine description:

	Retrieve Message List

Author:

	Iv Garber (IvG),	May, 2000

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;

	DBG_ENTER (TEXT("CFaxMessageIteratorInner::RetrieveMessages"), hr);

	//
	//	Retrieve List of Messages
	//
	if (!FaxEnumMessages(m_hEnum, m_dwPrefetchSize, &m_pMsgList, &m_dwTotalMsgNum))
	{
		//
		//	Failed to get Msg List
		//
		DWORD	dwError = GetLastError();

		if (dwError == ERROR_NO_MORE_ITEMS)
		{
			//
			//	EOF Case
			//
			return hr;
		}

		hr = Fax_HRESULT_FROM_WIN32(GetLastError());
		AtlReportError(*pcid, IDS_ERROR_OPERATION_FAILED, *piid, hr, _Module.GetResourceInstance());
		CALL_FAIL(GENERAL_ERR, _T("FaxEnumMessages()"), hr);
		return hr;
	}

	ATLASSERT(m_pMsgList);

	return hr;
}

//
//====================== MOVE NEXT ================================================
//
template<class T, const IID* piid, const CLSID* pcid, FAX_ENUM_MESSAGE_FOLDER FolderType,
         class MsgIfc, class MsgType> 
STDMETHODIMP 
CFaxMessageIteratorInner<T, piid, pcid, FolderType, MsgIfc, MsgType>::MoveNext(
)
/*++

Routine name : FolderType>::MoveNext

Routine description:

	Move the cursor to the next Message in the List.

Author:

	Iv Garber (IvG),	May, 2000

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;

	DBG_ENTER (TEXT("CFaxMessageInner::MoveNext"), hr);

    //
    //  If not yet, start Enumeration
    //
    if (!m_hEnum)
    {
        hr = MoveFirst();
        if (FAILED(hr))
        {
            return hr;
        }
    }

	m_dwCurMsgNum++;

	if (m_dwCurMsgNum == m_dwTotalMsgNum)
	{
		//
		//	We've read all the Msg List. Let's bring next one
		//
		SetEOF();
		hr = RetrieveMessages();
	}

	return hr;

}

//
//====================== SET EOF ================================================
//
template<class T, const IID* piid, const CLSID *pcid, FAX_ENUM_MESSAGE_FOLDER FolderType,
         class MsgIfc, class MsgType> 
HRESULT
CFaxMessageIteratorInner<T, piid, pcid, FolderType, MsgIfc, MsgType>::SetEOF(
)
/*++

Routine name : FolderType>::SetEOF

Routine description:

	Clear all instance variables dealing with Msg List.

Author:

	Iv Garber (IvG),	May, 2000

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;

	DBG_ENTER (TEXT("CFaxMessageInner::SetEOF"), hr);

	m_dwCurMsgNum = 0;
	m_dwTotalMsgNum = 0;
    m_pMsgList.Detach();
	return hr;
}

//
//====================== GET MESSAGE ================================================
//
//
template<class T, const IID* piid, const CLSID* pcid, FAX_ENUM_MESSAGE_FOLDER FolderType,
         class MsgIfc, class MsgType> 
STDMETHODIMP
CFaxMessageIteratorInner<T, piid, pcid, FolderType, MsgIfc, MsgType>::get_Message(
    MsgIfc **ppMessage
)
/*++

Routine name : CFaxMessageIteratorInner::GetMessage

Routine description:

	Return Next Message Object from the Archive 

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	ppMessage		[out]    - pointer to the place to put the Message Object

Return Value:

	Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;

	DBG_ENTER (TEXT("CFaxMessageIteratorInner::GetMessage"), hr);


    //
    //  If not yet, start Enumeration
    //
    if (!m_hEnum)
    {
        hr = MoveFirst();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    if (!m_pMsgList)
    {
        //
        //  Error, we at EOF
        //
        hr = ERROR_HANDLE_EOF;
		AtlReportError(*pcid, IDS_ERROR_EOF, *piid, hr, _Module.GetResourceInstance());
		CALL_FAIL(GENERAL_ERR, _T("FaxEnumMessages()"), hr);
		return hr;
    }

	//
	//	Create Message Object
	//	
	CComPtr<MsgIfc>		pMsg;
	hr = MsgType::Create(&pMsg);
	if (FAILED(hr))
	{
		//
		//	Failed to create Message object
		//
		AtlReportError(*pcid, IDS_ERROR_OPERATION_FAILED, *piid, hr, _Module.GetResourceInstance());
		CALL_FAIL(GENERAL_ERR, _T("MessageClass::Create(&pMsg)"), hr);
		return hr;
	}

	//
	//	Initialize the Message Object
	//
	hr = ((MsgType *)((MsgIfc *)pMsg))->Init(&m_pMsgList[m_dwCurMsgNum], m_pIFaxServerInner);
	if (FAILED(hr))
	{
		//
		// Failed to Init the Message Object
		//
		AtlReportError(*pcid, IDS_ERROR_OPERATION_FAILED, *piid, hr, _Module.GetResourceInstance());
		CALL_FAIL(GENERAL_ERR, _T("pMsg->Init()"), hr);
		return hr;
	}

	//
	//	Return Message Object to the Caller
	//
	hr = pMsg.CopyTo(ppMessage);
	if (FAILED(hr))
	{
		//
		//	Failed to Copy Interface
		//
		AtlReportError(*pcid, IDS_ERROR_OPERATION_FAILED, *piid, hr, _Module.GetResourceInstance());
		CALL_FAIL(GENERAL_ERR, _T("CComPtr::CopyTo"), hr);
		return hr;
	}
	return hr;
}

#endif //	__FAXMESSAGEITERATORINNER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxoutboundroutingrule.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxOutboundRoutingRule.cpp

Abstract:

	Implementation of CFaxOutboundRoutingRule class.

Author:

	Iv Garber (IvG)	Jun, 2000

Revision History:

--*/

#include "stdafx.h"
#include "FaxComEx.h"
#include "FaxOutboundRoutingRule.h"
#include "..\..\inc\FaxUIConstants.h"

//
//====================== REFRESH ====================================
//
STDMETHODIMP
CFaxOutboundRoutingRule::Refresh(
)
/*++

Routine name : CFaxOutboundRoutingRule::Refresh

Routine description:

	Bring up-to-dated Contents of the Rule Object from the Fax Server.

Author:

	Iv Garber (IvG),	Jun, 2000

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxOutboundRoutingRule::Refresh"), hr);

    //
    //  Get Fax Handle
    //
    HANDLE faxHandle;
	hr = m_pIFaxServerInner->GetHandle(&faxHandle);
    ATLASSERT(SUCCEEDED(hr));

	if (faxHandle == NULL)
	{
		//
		//	Fax Server is not connected
		//
		hr = Fax_HRESULT_FROM_WIN32(ERROR_NOT_CONNECTED);
		CALL_FAIL(GENERAL_ERR, _T("faxHandle == NULL"), hr);
        AtlReportError(CLSID_FaxOutboundRoutingRule, GetErrorMsgId(hr), IID_IFaxOutboundRoutingRule, hr, _Module.GetResourceInstance());
		return hr;
	}

    //
    //  Call Server for the Data
    //
    CFaxPtr<FAX_OUTBOUND_ROUTING_RULE>  pRules;
    DWORD                               dwNum = 0;
    if (!FaxEnumOutboundRules(faxHandle, &pRules, &dwNum))
    {
		hr = Fax_HRESULT_FROM_WIN32(GetLastError());
		CALL_FAIL(GENERAL_ERR, _T("FaxEnumOutboundRules(faxHandle, &pRules, &dwNum)"), hr);
        AtlReportError(CLSID_FaxOutboundRoutingRule, GetErrorMsgId(hr), IID_IFaxOutboundRoutingRule, hr, _Module.GetResourceInstance());
		return hr;
    }

    //
    //  Find Current Rule 
    //
    for ( DWORD i=0 ; i<dwNum ; i++ )
    {
        if ( (pRules[i].dwAreaCode == m_dwAreaCode) &&
             (pRules[i].dwCountryCode == m_dwCountryCode) )
        {
            hr = Init(&pRules[i], NULL);
            return hr;
        }
    }

    //
    //  Rule not found
    //
    hr = Fax_HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	CALL_FAIL(GENERAL_ERR, _T("Such Rule is not found anymore"), hr);
    AtlReportError(CLSID_FaxOutboundRoutingRule, GetErrorMsgId(hr), IID_IFaxOutboundRoutingRule, hr, _Module.GetResourceInstance());
    return hr;
}

//
//====================== SAVE ====================================
//
STDMETHODIMP
CFaxOutboundRoutingRule::Save(
)
/*++

Routine name : CFaxOutboundRoutingRule::Save

Routine description:

	Save the Contents of the Rule Object to the Fax Server.

Author:

	Iv Garber (IvG),	Jun, 2000

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxOutboundRoutingRule::Save"), hr);

    //
    //  Get Fax Handle
    //
    HANDLE faxHandle;
	hr = m_pIFaxServerInner->GetHandle(&faxHandle);
    ATLASSERT(SUCCEEDED(hr));

	if (faxHandle == NULL)
	{
		//
		//	Fax Server is not connected
		//
		hr = Fax_HRESULT_FROM_WIN32(ERROR_NOT_CONNECTED);
		CALL_FAIL(GENERAL_ERR, _T("faxHandle == NULL"), hr);
        AtlReportError(CLSID_FaxOutboundRoutingRule, GetErrorMsgId(hr), IID_IFaxOutboundRoutingRule, hr, _Module.GetResourceInstance());
		return hr;
	}

    //
    //  Create Structure with Rule's Data
    //
    FAX_OUTBOUND_ROUTING_RULE   ruleData;

    ruleData.bUseGroup = (!m_bUseDevice);

    if (m_bUseDevice)
    {
        ruleData.Destination.dwDeviceId = m_dwDeviceId;
    }
    else
    {
        ruleData.Destination.lpcstrGroupName = m_bstrGroupName;
    }

    ruleData.dwAreaCode = m_dwAreaCode;
    ruleData.dwCountryCode = m_dwCountryCode;
    ruleData.dwSizeOfStruct = sizeof(FAX_OUTBOUND_ROUTING_RULE);
    ruleData.Status = FAX_ENUM_RULE_STATUS(m_Status);

    //
    //  Call Server
    //
    if (!FaxSetOutboundRule(faxHandle, &ruleData))
    {
		hr = Fax_HRESULT_FROM_WIN32(GetLastError());
		CALL_FAIL(GENERAL_ERR, _T("FaxSetOutboundRule(faxHandle, &ruleData)"), hr);
        AtlReportError(CLSID_FaxOutboundRoutingRule, GetErrorMsgId(hr), IID_IFaxOutboundRoutingRule, hr, _Module.GetResourceInstance());
		return hr;
    }

    return hr;
}

//
//====================== PUT GROUP NAME ====================================
//
STDMETHODIMP
CFaxOutboundRoutingRule::put_GroupName(
    /*[in]*/ BSTR bstrGroupName
)
/*++

Routine name : CFaxOutboundRoutingRule::put_GroupName

Routine description:

	Set new Group Name for the Rule.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	bstrGroupName               [in]    - the new value for the Group Name 

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxOutboundRoutingRule::put_GroupName"), hr, _T("New Value=%s"), bstrGroupName);

    m_bstrGroupName = bstrGroupName;
    if (bstrGroupName && !m_bstrGroupName)
    {
		hr = E_OUTOFMEMORY;
        CALL_FAIL(MEM_ERR, _T("CComBSTR::operator =()"), hr);
		AtlReportError(CLSID_FaxOutboundRoutingRule, IDS_ERROR_OUTOFMEMORY, IID_IFaxOutboundRoutingRule, hr, _Module.GetResourceInstance());
        return hr;
    }
    return hr;
}

//
//===================== GET GROUP NAME ======================================
//
STDMETHODIMP
CFaxOutboundRoutingRule::get_GroupName(
    /*[out, retval]*/ BSTR *pbstrGroupName
)
/*++

Routine name : CFaxOutboundRoutingRule::get_GroupName

Routine description:

	Return the Group Name of the Rule.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	pbstrGroupName                 [out]    - The Result

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxOutboundRoutingRule::get_GroupName"), hr);

    hr = GetBstr(pbstrGroupName, m_bstrGroupName);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxOutboundRoutingRule, GetErrorMsgId(hr), IID_IFaxOutboundRoutingRule, hr, _Module.GetResourceInstance());
        return hr;
    }

    return hr;
}

//
//====================== PUT DEVICE ID ====================================
//
STDMETHODIMP
CFaxOutboundRoutingRule::put_DeviceId(
    /*[in]*/ long lDeviceId
)
/*++

Routine name : CFaxOutboundRoutingRule::put_DeviceId

Routine description:

	Set new Device Id for the Rule.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	lDeviceId           [in]    - the new value for the Device 

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxOutboundRoutingRule::put_DeviceId"), hr, _T("New Value=%ld"), lDeviceId);

    if ((lDeviceId > FXS_MAX_PORT_NUM) || (lDeviceId < FXS_MIN_PORT_NUM)) 
    {
		//
		//	Out of the Range
		//
		hr = E_INVALIDARG;
		AtlReportError(CLSID_FaxOutboundRoutingRule, IDS_ERROR_OUTOFRANGE, IID_IFaxOutboundRoutingRule, hr, _Module.GetResourceInstance());
		CALL_FAIL(GENERAL_ERR, _T("Device ID is out of the Range"), hr);
		return hr;
    }

    m_dwDeviceId = lDeviceId;
    return hr;
}

//
//===================== GET DEVICE ID ======================================
//
STDMETHODIMP
CFaxOutboundRoutingRule::get_DeviceId(
    /*[out, retval]*/ long *plDeviceId
)
/*++

Routine name : CFaxOutboundRoutingRule::get_DeviceId

Routine description:

	Return the Device Id of the Rule.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	plDeviceId                 [out]    - The Result

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxOutboundRoutingRule::get_DeviceId"), hr);

    hr = GetLong(plDeviceId, m_dwDeviceId);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxOutboundRoutingRule, GetErrorMsgId(hr), IID_IFaxOutboundRoutingRule, hr, _Module.GetResourceInstance());
        return hr;
    }

    return hr;
}

//
//====================== PUT USE DEVICE ====================================
//
STDMETHODIMP
CFaxOutboundRoutingRule::put_UseDevice(
    /*[in]*/ VARIANT_BOOL bUseDevice
)
/*++

Routine name : CFaxOutboundRoutingRule::put_UseDevice

Routine description:

	Set new Value for Use Device Flag.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	bUseDevice                    [in]    - the new value for the Flag

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxOutboundRoutingRule::put_UseDevice"), hr, _T("New Value=%d"), bUseDevice);
    m_bUseDevice = VARIANT_BOOL2bool(bUseDevice);
    return hr;
}

//
//===================== GET USE DEVICE ======================================
//
STDMETHODIMP
CFaxOutboundRoutingRule::get_UseDevice(
    /*[out, retval]*/ VARIANT_BOOL *pbUseDevice
)
/*++

Routine name : CFaxOutboundRoutingRule::get_UseDevice

Routine description:

	Return whether the Rule uses Device.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	pbUseDevice                 [out]    - The Result

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxOutboundRoutingRule::get_UseDevice"), hr);

    hr = GetVariantBool(pbUseDevice, bool2VARIANT_BOOL(m_bUseDevice));
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxOutboundRoutingRule, GetErrorMsgId(hr), IID_IFaxOutboundRoutingRule, hr, _Module.GetResourceInstance());
        return hr;
    }

    return hr;
}

//
//===================== GET STATUS ======================================
//
STDMETHODIMP
CFaxOutboundRoutingRule::get_Status(
    /*[out, retval]*/ FAX_RULE_STATUS_ENUM  *pStatus
)
/*++

Routine name : CFaxOutboundRoutingRule::get_Status

Routine description:

	Return Status of the Rule.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	pStatus                      [out]    - The Result

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxOutboundRoutingRule::get_Status"), hr);

	//
	//	Check that we have got good Ptr
	//
	if (::IsBadWritePtr(pStatus, sizeof(FAX_RULE_STATUS_ENUM)))
	{
		hr = E_POINTER;
		CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr(pStatus, sizeof(FAX_RULE_STATUS_ENUM))"), hr);
        AtlReportError(CLSID_FaxOutboundRoutingRule, GetErrorMsgId(hr), IID_IFaxOutboundRoutingRule, hr, _Module.GetResourceInstance());
		return hr;
	}

	*pStatus = m_Status;
	return hr;
}

//
//===================== GET AREA CODE ======================================
//
STDMETHODIMP
CFaxOutboundRoutingRule::get_AreaCode(
    /*[out, retval]*/ long *plAreaCode
)
/*++

Routine name : CFaxOutboundRoutingRule::get_AreaCode

Routine description:

	Return Area Code of the Rule.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	plAreaCode                 [out]    - The Result

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxOutboundRoutingRule::get_AreaCode"), hr);

    hr = GetLong(plAreaCode, m_dwAreaCode);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxOutboundRoutingRule, GetErrorMsgId(hr), IID_IFaxOutboundRoutingRule, hr, _Module.GetResourceInstance());
        return hr;
    }

    return hr;
}

//
//===================== GET COUNTRY CODE ======================================
//
STDMETHODIMP
CFaxOutboundRoutingRule::get_CountryCode(
    /*[out, retval]*/ long *plCountryCode
)
/*++

Routine name : CFaxOutboundRoutingRule::get_CountryCode

Routine description:

	Return Country Code of the Rule.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	plCountryCode                 [out]    - The Result

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxOutboundRoutingRule::get_CountryCode"), hr);

    hr = GetLong(plCountryCode, m_dwCountryCode);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxOutboundRoutingRule, GetErrorMsgId(hr), IID_IFaxOutboundRoutingRule, hr, _Module.GetResourceInstance());
        return hr;
    }

    return hr;
}

//
//===================== SUPPORT ERROR INFO ======================================
//
STDMETHODIMP 
CFaxOutboundRoutingRule::InterfaceSupportsErrorInfo(
    REFIID riid
)
/*++

Routine name : CFaxOutboundRoutingRule::InterfaceSupportsErrorInfo

Routine description:

	ATL's implementation of Support Error Info.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	riid                          [in]    - reference to the Interface.

Return Value:

    Standard HRESULT code

--*/
{
	static const IID* arr[] = 
	{
		&IID_IFaxOutboundRoutingRule
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

//
//=================== INIT ======================================
//
STDMETHODIMP
CFaxOutboundRoutingRule::Init(
    /*[in]*/ FAX_OUTBOUND_ROUTING_RULE *pInfo, 
    /*[in]*/ IFaxServerInner *pServer
)
/*++

Routine name : CFaxOutboundRoutingRule::Init

Routine description:

	Initialize the Rule Object.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	pInfo                         [in]    - Ptr to the Rule Info Structure
	pServer                       [in]    - Ptr to the Fax Server Object.

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxOutboundRoutingRule::Init"), hr);

    //
    //  Store data from the Struct internally
    //
    m_dwAreaCode = pInfo->dwAreaCode;
    m_dwCountryCode = pInfo->dwCountryCode;
    m_Status = FAX_RULE_STATUS_ENUM(pInfo->Status);
    m_bUseDevice = (!pInfo->bUseGroup);

    if (m_bUseDevice)
    {
        m_dwDeviceId = pInfo->Destination.dwDeviceId;
        m_bstrGroupName.Empty();
    }
    else
    {
        m_dwDeviceId = 0;
        m_bstrGroupName = pInfo->Destination.lpcstrGroupName;
        if (pInfo->Destination.lpcstrGroupName && !m_bstrGroupName)
        {
		    hr = E_OUTOFMEMORY;
            CALL_FAIL(MEM_ERR, _T("CComBSTR::operator =()"), hr);
		    AtlReportError(CLSID_FaxOutboundRoutingRule, IDS_ERROR_OUTOFMEMORY, IID_IFaxOutboundRoutingRule, hr, _Module.GetResourceInstance());
            return hr;
        }
    }

    //
    //  When called from Refresh, no need to update Ptr to Fax Server Object 
    //
    if (pServer)
    {

        //
        //  Store the Ptr to the Fax Server Object and make AddRef() on it
        //
        hr = CFaxInitInnerAddRef::Init(pServer);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxoutboundroutinggroups.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxOutboundRoutingGroups.cpp

Abstract:

	Implementation of CFaxOutboundRoutingGroups class.

Author:

	Iv Garber (IvG)	Jun, 2000

Revision History:

--*/

#include "stdafx.h"
#include "FaxComEx.h"
#include "FaxOutboundRoutingGroups.h"
#include "FaxOutboundRoutingGroup.h"

//
//================= FIND GROUP =======================================================
//
STDMETHODIMP
CFaxOutboundRoutingGroups::FindGroup(
    /*[in]*/ VARIANT vIndex,
    /*[out]*/ ContainerType::iterator &it
)
/*++

Routine name : CFaxOutboundRoutingGroups::FindGroup

Routine description:

	Find Group by given Variant : either Group Name either Group Index in the Collection

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	vIndex                        [in]    - the Key to Find the Group 
    it                            [out]   - the found Group Iterator

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxOutboundRoutingGroups::FindGroup"), hr);

    CComVariant     var;
    if (vIndex.vt != VT_BSTR)
    {
        //
        //  vIndex is not BSTR ==> convert to VT_I4
        //
        hr = var.ChangeType(VT_I4, &vIndex);
        if (SUCCEEDED(hr))
        {
            VERBOSE(DBG_MSG, _T("Parameter is Number : %d"), var.lVal);

            //
            //  Check the Range of the Index
            //
            if (var.lVal > m_coll.size() || var.lVal < 1)
            {
		        //
		        //	Invalid Index
		        //
        		hr = E_INVALIDARG;
		        AtlReportError(CLSID_FaxOutboundRoutingGroups, IDS_ERROR_OUTOFRANGE, IID_IFaxOutboundRoutingGroups, hr, _Module.GetResourceInstance());
        		CALL_FAIL(GENERAL_ERR, _T("lIndex < 1 || lIndex > m_coll.size()"), hr);
		        return hr;
        	}

            //
            //  Find the Group Object to Remove
            //
            it = m_coll.begin() + var.lVal - 1;
            return hr;
		}
    }

    //
    //  We didnot success to convert the var to Number
    //  So, try to convert it to the STRING
    //
    hr = var.ChangeType(VT_BSTR, &vIndex);
    if (FAILED(hr))
    {
        hr = E_INVALIDARG;
        AtlReportError(CLSID_FaxOutboundRoutingGroups, IDS_ERROR_INVALID_ARGUMENT, IID_IFaxOutboundRoutingGroups, hr, _Module.GetResourceInstance());
        CALL_FAIL(GENERAL_ERR, _T("var.ChangeType(VT_BSTR, &vIndex)"), hr);
        return hr;
    }

    VERBOSE(DBG_MSG, _T("Parameter is String : %s"), var.bstrVal);

    CComBSTR    bstrName;
    it = m_coll.begin();
    while (it != m_coll.end())
    {
        hr = (*it)->get_Name(&bstrName);
        if (FAILED(hr))
        {
		    CALL_FAIL(GENERAL_ERR, _T("(*it)->get_Name(&bstrName)"), hr);
            AtlReportError(CLSID_FaxOutboundRoutingGroups, IDS_ERROR_INVALID_ARGUMENT, IID_IFaxOutboundRoutingGroups, hr, _Module.GetResourceInstance());
            return hr;
        }

        if (_tcsicmp(bstrName, var.bstrVal) == 0)
        {
            //
            //  found the desired OR Group
            //
            return hr;
        }
        it++;
    }

	hr = E_INVALIDARG;
	CALL_FAIL(GENERAL_ERR, _T("Group Is Not Found"), hr);
    AtlReportError(CLSID_FaxOutboundRoutingGroups, IDS_ERROR_INVALID_ARGUMENT, IID_IFaxOutboundRoutingGroups, hr, _Module.GetResourceInstance());
    return hr;
}

//
//===================== ADD GROUP =================================================
//
STDMETHODIMP
CFaxOutboundRoutingGroups::AddGroup(
    /*[in]*/ FAX_OUTBOUND_ROUTING_GROUP *pInfo,
    /*[out]*/ IFaxOutboundRoutingGroup **ppNewGroup
)
/*++

Routine name : CFaxOutboundRoutingGroups::AddGroup

Routine description:

	Create new Group Object and add it to the Collection.
    If ppNewGroup is NOT NULL, return in it ptr to the new Group Object.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

    pInfo                   [in]    -   Ptr to the Group's Data
    ppNewGroup              [out]    -  Ptr to the new Group Object

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxOutboundRoutingGroups::AddGroup"), hr);

    //
    //  Create Group Object
    //
    CComObject<CFaxOutboundRoutingGroup>  *pClass = NULL;
    hr = CComObject<CFaxOutboundRoutingGroup>::CreateInstance(&pClass);
    if (FAILED(hr) || (!pClass))
    {
        if (!pClass)
        {
            hr = E_OUTOFMEMORY;
    		CALL_FAIL(MEM_ERR, _T("CComObject<CFaxOutboundRoutingGroup>::CreateInstance(&pClass)"), hr);
        }
        else
        {
    		CALL_FAIL(GENERAL_ERR, _T("CComObject<CFaxOutboundRoutingGroup>::CreateInstance(&pClass)"), hr);
        }

        AtlReportError(CLSID_FaxOutboundRoutingGroups, GetErrorMsgId(hr), IID_IFaxOutboundRoutingGroups, hr, _Module.GetResourceInstance());
		return hr;
    }

    //
    //  Init the Group Object
    //
    hr = pClass->Init(pInfo, m_pIFaxServerInner);
    if (FAILED(hr))
    {
        CALL_FAIL(GENERAL_ERR, _T("pClass->Init(pInfo, m_pIFaxServerInner)"), hr);
        AtlReportError(CLSID_FaxOutboundRoutingGroups, GetErrorMsgId(hr), IID_IFaxOutboundRoutingGroups, hr, _Module.GetResourceInstance());
        delete pClass;
        return hr;
    }

    //
    //  Get Interface from the pClass.
    //  This will make AddRef() on the Interface. 
    //  This is the Collection's AddRef, which is freed at Collection's Dtor.
    //
    CComPtr<IFaxOutboundRoutingGroup>     pObject = NULL;
    hr = pClass->QueryInterface(&pObject);
    if (FAILED(hr) || (!pObject))
    {
        if (!pObject)
        {
            hr = E_FAIL;
        }
        CALL_FAIL(GENERAL_ERR, _T("pClass->QueryInterface(&pObject)"), hr);
        AtlReportError(CLSID_FaxOutboundRoutingGroups, GetErrorMsgId(hr), IID_IFaxOutboundRoutingGroups, hr, _Module.GetResourceInstance());
        delete pClass;
        return hr;
    }

	//
	//	Put the Object in the collection
	//
	try 
	{
		m_coll.push_back(pObject);
	}
	catch (exception &)
	{
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxOutboundRoutingGroups, IDS_ERROR_OUTOFMEMORY, IID_IFaxOutboundRoutingGroups, hr, _Module.GetResourceInstance());
		CALL_FAIL(MEM_ERR, _T("m_coll.push_back(pObject)"), hr);

        //
        //  pObject will call Release(), which will delete the pClass
        //
		return hr;
	}

    //
    //  We want to save the current AddRef() to Collection
    //
    pObject.Detach();

    //
    //  Return new Group Object, if required
    //
    if (ppNewGroup)
    {
        if (::IsBadWritePtr(ppNewGroup, sizeof(IFaxOutboundRoutingGroup *)))
        {
		    hr = E_POINTER;
		    CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr(ppNewGroup, sizeof(IFaxOutboundRoutingGroup *))"), hr);
		    return hr;
        }
        else
        {
            *ppNewGroup = m_coll.back();
            (*ppNewGroup)->AddRef();
        }
    }

    return hr;
}

//
//================= ADD =======================================================
//
STDMETHODIMP
CFaxOutboundRoutingGroups::Add(
    /*[in]*/ BSTR bstrName, 
    /*[out, retval]*/ IFaxOutboundRoutingGroup **ppGroup
)
/*++

Routine name : CFaxOutboundRoutingGroups::Add

Routine description:

	Add new Group to the Groups Collection

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	bstrName                      [in]    - Name of the new Group
	ppGroup                       [out]    - the Group Object

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxOutboundRoutingGroups::Add"), hr, _T("Name=%s"), bstrName);

    //
    //  Check if the Name is valid
    //
    if (_tcsicmp(bstrName, ROUTING_GROUP_ALL_DEVICES) == 0)
    {
        //
        //  Cannot Add the "All Devices" Group
        //
	    hr = E_INVALIDARG;
	    CALL_FAIL(GENERAL_ERR, _T("All Devices Group"), hr);
        AtlReportError(CLSID_FaxOutboundRoutingGroups, IDS_ERROR_ALLDEVICESGROUP, IID_IFaxOutboundRoutingGroups, hr, _Module.GetResourceInstance());
        return hr;
    }

	//
	//	Get Fax Server Handle
	//
    HANDLE faxHandle;
	hr = m_pIFaxServerInner->GetHandle(&faxHandle);
    ATLASSERT(SUCCEEDED(hr));

	if (faxHandle == NULL)
	{
		//
		//	Fax Server is not connected
		//
		hr = Fax_HRESULT_FROM_WIN32(ERROR_NOT_CONNECTED);
		CALL_FAIL(GENERAL_ERR, _T("faxHandle == NULL"), hr);
        AtlReportError(CLSID_FaxOutboundRoutingGroups, IDS_ERROR_INVALID_ARGUMENT, IID_IFaxOutboundRoutingGroups, hr, _Module.GetResourceInstance());
		return hr;
	}

    //
    //  Add the Group to the Fax Server
    //
    if (!FaxAddOutboundGroup(faxHandle, bstrName))
    {
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
		CALL_FAIL(GENERAL_ERR, _T("FaxAddOutboundGroup(faxHandle, bstrName)"), hr);
        AtlReportError(CLSID_FaxOutboundRoutingGroups, GetErrorMsgId(hr), IID_IFaxOutboundRoutingGroups, hr, _Module.GetResourceInstance());
		return hr;
    }

    //
    //  Add the Group to the Collection
    //
    FAX_OUTBOUND_ROUTING_GROUP  groupData;

    groupData.dwNumDevices = 0;
    groupData.dwSizeOfStruct = sizeof(FAX_OUTBOUND_ROUTING_GROUP);
    groupData.lpctstrGroupName = bstrName;
    groupData.lpdwDevices = NULL;
    groupData.Status = FAX_GROUP_STATUS_EMPTY;

    hr = AddGroup(&groupData, ppGroup);
    return hr;
}

//
//================= REMOVE =======================================================
//
STDMETHODIMP
CFaxOutboundRoutingGroups::Remove(
    /*[in]*/ VARIANT vIndex
)
/*++

Routine name : CFaxOutboundRoutingGroups::Remove

Routine description:

	Remove Group by the given key

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	vIndex                        [in]    - the Key to Find the Group to Remove

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxOutboundRoutingGroups::Remove"), hr);

    //
    //  Find the Group
    //
    ContainerType::iterator it;
    hr = FindGroup(vIndex, it);
    if (FAILED(hr))
    {
        return hr;
    }

    //
    //  Take the Name of the Group
    //
    CComBSTR    bstrName;
    hr = (*it)->get_Name(&bstrName);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxOutboundRoutingGroups, GetErrorMsgId(hr), IID_IFaxOutboundRoutingGroups, hr, _Module.GetResourceInstance());
        CALL_FAIL(GENERAL_ERR, _T("(*it)->get_Name(&bstrName)"), hr);
		return hr;
    }

    //
    //  Check that Name is valid
    //
    if (_tcsicmp(bstrName, ROUTING_GROUP_ALL_DEVICES) == 0)
    {
        //
        //  Cannot Remove "All Devices" Group
        //
	    hr = E_INVALIDARG;
	    CALL_FAIL(GENERAL_ERR, _T("All Devices Group"), hr);
        AtlReportError(CLSID_FaxOutboundRoutingGroups, IDS_ERROR_ALLDEVICESGROUP, IID_IFaxOutboundRoutingGroups, hr, _Module.GetResourceInstance());
        return hr;
    }

	//
	//	Get Fax Server Handle
	//
    HANDLE faxHandle;
	hr = m_pIFaxServerInner->GetHandle(&faxHandle);
    ATLASSERT(SUCCEEDED(hr));

	if (faxHandle == NULL)
	{
		//
		//	Fax Server is not connected
		//
		hr = Fax_HRESULT_FROM_WIN32(ERROR_NOT_CONNECTED);
		CALL_FAIL(GENERAL_ERR, _T("faxHandle == NULL"), hr);
        AtlReportError(CLSID_FaxOutboundRoutingGroups, IDS_ERROR_INVALID_ARGUMENT, IID_IFaxOutboundRoutingGroups, hr, _Module.GetResourceInstance());
		return hr;
	}

    //
    //  Remove from Fax Server
    //
    if (!FaxRemoveOutboundGroup(faxHandle, bstrName))
    {
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
		CALL_FAIL(GENERAL_ERR, _T("FaxRemoveOutboundGroup(faxHandle, bstrName)"), hr);
        AtlReportError(CLSID_FaxOutboundRoutingGroups, GetErrorMsgId(hr), IID_IFaxOutboundRoutingGroups, hr, _Module.GetResourceInstance());
		return hr;
    }

    //
    //  If successed, remove from our collection as well
    //
	try
	{
		m_coll.erase(it);
	}
	catch(exception &)
	{
		//
		//	Failed to remove the Group
		//
		hr = E_OUTOFMEMORY;
        AtlReportError(CLSID_FaxOutboundRoutingGroups, GetErrorMsgId(hr), IID_IFaxOutboundRoutingGroups, hr, _Module.GetResourceInstance());
		CALL_FAIL(MEM_ERR, _T("m_coll.erase(it)"), hr);
		return hr;
	}

    return hr;
}

//
//==================== GET ITEM ===================================================
//
STDMETHODIMP
CFaxOutboundRoutingGroups::get_Item(
    /*[in]*/ VARIANT vIndex, 
    /*[out, retval]*/ IFaxOutboundRoutingGroup **ppGroup
)
/*++

Routine name : CFaxOutboundRoutingGroups::get_Item

Routine description:

	Return Item from the Collection either by Group Name either by its Index inside the Collection.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	vIndex                        [in]    - Group Name or Item Index
	ppGroup                       [out]    - the resultant Group Object

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxOutboundRoutingGroups::get_Item"), hr);

    //
    //  Check the Ptr we have got
    //
    if (::IsBadWritePtr(ppGroup, sizeof(IFaxOutboundRoutingGroup *)))
    {
        hr = E_POINTER;
        AtlReportError(CLSID_FaxOutboundRoutingGroups, IDS_ERROR_INVALID_ARGUMENT, IID_IFaxOutboundRoutingGroups, hr, _Module.GetResourceInstance());
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr(ppGroup, sizeof(IFaxOutboundRoutingGroup *))"), hr);
		return hr;
    }

    //
    //  Find the Group
    //
    ContainerType::iterator it;
    hr = FindGroup(vIndex, it);
    if (FAILED(hr))
    {
        return hr;
    };

    //
    //  Return it to Caller
    //
    (*it)->AddRef();
    *ppGroup = *it;
    return hr;
}

//
//==================== INIT ===================================================
//
STDMETHODIMP
CFaxOutboundRoutingGroups::Init(
    /*[in]*/ IFaxServerInner *pServer
)
/*++

Routine name : CFaxOutboundRoutingGroups::Init

Routine description:

	Initialize the Groups Collection : create all Group Objects.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	pServer                       [in]    - Ptr to the Fax Server Object.

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxOutboundRoutingGroups::Init"), hr);

    //
    //  First, set the Ptr to the Server
    //
    hr = CFaxInitInnerAddRef::Init(pServer);
    if (FAILED(hr))
    {
        return hr;
    }

    //
    //  Get Fax Handle
    //
    HANDLE faxHandle;
	hr = m_pIFaxServerInner->GetHandle(&faxHandle);
    ATLASSERT(SUCCEEDED(hr));

	if (faxHandle == NULL)
	{
		//
		//	Fax Server is not connected
		//
		hr = Fax_HRESULT_FROM_WIN32(ERROR_NOT_CONNECTED);
		CALL_FAIL(GENERAL_ERR, _T("faxHandle == NULL"), hr);
        AtlReportError(CLSID_FaxOutboundRoutingGroups, GetErrorMsgId(hr), IID_IFaxOutboundRoutingGroups, hr, _Module.GetResourceInstance());
		return hr;
	}

    //
    //  Call Server to Return all OR Groups
    //
    CFaxPtr<FAX_OUTBOUND_ROUTING_GROUP> pGroups;
    DWORD                               dwNum = 0;
    if (!FaxEnumOutboundGroups(faxHandle, &pGroups, &dwNum))
    {
		hr = Fax_HRESULT_FROM_WIN32(GetLastError());
		CALL_FAIL(GENERAL_ERR, _T("FaxEnumOutboundGroups(faxHandle, &pGroups, &dwNum)"), hr);
        AtlReportError(CLSID_FaxOutboundRoutingGroups, GetErrorMsgId(hr), IID_IFaxOutboundRoutingGroups, hr, _Module.GetResourceInstance());
		return hr;
    }

    //
    //  Fill the Collection with Objects
    //
    for (DWORD i=0 ; i<dwNum ; i++ )
    {
        hr = AddGroup(&pGroups[i]);
        if (FAILED(hr))
        {
            return hr;
        }
    }

    return hr;
}

//
//==================== CREATE ========================================
//
HRESULT 
CFaxOutboundRoutingGroups::Create (
	/*[out, retval]*/IFaxOutboundRoutingGroups **ppGroups
)
/*++

Routine name : CFaxOutboundRoutingGroups::Create

Routine description:

	Static function to create the Fax Outbound Routing Groups Collection Object

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	ppGroups                [out]  -- the new Fax OR Groups Collection Object

Return Value:

    Standard HRESULT code

--*/

{
	HRESULT     hr = S_OK;
	DBG_ENTER (_T("CFaxOutboundRoutingGroups::Create"), hr);

    //
    //  Create Instance of the Collection
    //
	CComObject<CFaxOutboundRoutingGroups>		*pClass;
	hr = CComObject<CFaxOutboundRoutingGroups>::CreateInstance(&pClass);
	if (FAILED(hr))
	{
		CALL_FAIL(GENERAL_ERR, _T("CComObject<CFaxOutboundRoutingGroups>::CreateInstance(&pClass)"), hr);
		return hr;
	}

    //
    //  Return the desired Interface Ptr
    //
	hr = pClass->QueryInterface(ppGroups);
	if (FAILED(hr))
	{
		CALL_FAIL(GENERAL_ERR, _T("pClass->QueryInterface(ppGroups)"), hr);
		return hr;
	}

	return hr;
}	//	CFaxOutboundRoutingGroups::Create()

//
//===================== SUPPORT ERROR INFO ======================================
//
STDMETHODIMP 
CFaxOutboundRoutingGroups::InterfaceSupportsErrorInfo(
    REFIID riid
)
/*++

Routine name : CFaxOutboundRoutingGroups::InterfaceSupportsErrorInfo

Routine description:

	ATL's implementation of the ISupportErrorInfo Interface.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	riid                          [in]    - Reference to the Interface

Return Value:

    Standard HRESULT code

--*/
{
	static const IID* arr[] = 
	{
		&IID_IFaxOutboundRoutingGroups
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxoutboundroutingrule.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxOutboundRoutingRule.h

Abstract:

	Declaration of the CFaxOutboundRoutingRule class.

Author:

	Iv Garber (IvG)	Jun, 2000

Revision History:

--*/

#ifndef __FAXOUTBOUNDROUTINGRULE_H_
#define __FAXOUTBOUNDROUTINGRULE_H_

#include "resource.h"       // main symbols
#include "FaxCommon.h"

//
//======================== FAX OUTBOUND ROUTING RULE =================================
//  FaxOutboundRoutingRule Object is created by FaxOutboundRoutingRuleS Collection.
//  At Init, the Collection passes the Ptr to the Fax Server Object.
//  Rule Object needs this Ptr to perform Save and Refresh.
//  So, Rule Object makes AddRef() on the Fax Server Object, to prevent its death.
//  To do this, Rule Object inherits from the CFaxInitInnerAddRef class.
//
class ATL_NO_VTABLE CFaxOutboundRoutingRule : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public ISupportErrorInfo,
	public IDispatchImpl<IFaxOutboundRoutingRule, &IID_IFaxOutboundRoutingRule, &LIBID_FAXCOMEXLib>,
    public CFaxInitInnerAddRef
{
public:
    CFaxOutboundRoutingRule() : CFaxInitInnerAddRef(_T("FAX OUTBOUND ROUTING RULE"))
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_FAXOUTBOUNDROUTINGRULE)
DECLARE_NOT_AGGREGATABLE(CFaxOutboundRoutingRule)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxOutboundRoutingRule)
	COM_INTERFACE_ENTRY(IFaxOutboundRoutingRule)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

//  Interfaces
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

    STDMETHOD(get_CountryCode)(/*[out, retval]*/ long *plCountryCode);
    STDMETHOD(get_AreaCode)(/*[out, retval]*/ long *plAreaCode);
    STDMETHOD(get_Status)(/*[out, retval]*/ FAX_RULE_STATUS_ENUM *pStatus);

    STDMETHOD(get_UseDevice)(/*[out, retval]*/ VARIANT_BOOL *pbUseDevice);
    STDMETHOD(put_UseDevice)(/*[in]*/ VARIANT_BOOL bUseDevice);

    STDMETHOD(get_DeviceId)(/*[out, retval]*/ long *plDeviceId);
    STDMETHOD(put_DeviceId)(/*[in]*/ long DeviceId);

    STDMETHOD(get_GroupName)(/*[out, retval]*/ BSTR *pbstrGroupName);
	STDMETHOD(put_GroupName)(/*[in]*/ BSTR bstrGroupName);

	STDMETHOD(Save)();
    STDMETHOD(Refresh)();

//  Internal Use
    STDMETHOD(Init)(FAX_OUTBOUND_ROUTING_RULE *pInfo, IFaxServerInner *pServer);

private:
    DWORD       m_dwAreaCode;
    DWORD       m_dwCountryCode;
    DWORD       m_dwDeviceId;
    BOOL        m_bUseDevice;
    CComBSTR    m_bstrGroupName;

    FAX_RULE_STATUS_ENUM    m_Status;
};

#endif //__FAXOUTBOUNDROUTINGRULE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxoutboundroutingrules.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxOutboundRoutingRules.cpp

Abstract:

	Implementation of CFaxOutboundRoutingRules class.

Author:

	Iv Garber (IvG)	Jun, 2000

Revision History:

--*/

#include "stdafx.h"
#include "FaxComEx.h"
#include "FaxOutboundRoutingRules.h"
#include "FaxOutboundRoutingRule.h"

//
//======================= ADD RULE ============================================
//
STDMETHODIMP
CFaxOutboundRoutingRules::AddRule(
    /*[in]*/ FAX_OUTBOUND_ROUTING_RULE *pInfo,
    /*[out]*/ IFaxOutboundRoutingRule **ppNewRule
)
/*++

Routine name : CFaxOutboundRoutingRules::AddRule

Routine description:

	Create new Rule Object and put it into the Collection.
    Returns pointer to this new Rule Object, if ppNewRule is valid ptr.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	pInfo               [in]    - Ptr to the Rule's Data
    ppRule              [out]   - Ptr to the Rule's Object in the Collection

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxOutboundRoutingRules::AddRule"), hr);

    //
    //  Create Rule Object
    //
    CComObject<CFaxOutboundRoutingRule>  *pClass = NULL;
    hr = CComObject<CFaxOutboundRoutingRule>::CreateInstance(&pClass);
    if (FAILED(hr) || (!pClass))
    {
        if (!pClass)
        {
            hr = E_OUTOFMEMORY;
    		CALL_FAIL(MEM_ERR, _T("CComObject<CFaxOutboundRoutingRule>::CreateInstance(&pClass)"), hr);
        }
        else
        {
    		CALL_FAIL(GENERAL_ERR, _T("CComObject<CFaxOutboundRoutingRule>::CreateInstance(&pClass)"), hr);
        }

        AtlReportError(CLSID_FaxOutboundRoutingRules, GetErrorMsgId(hr), IID_IFaxOutboundRoutingRules, hr, _Module.GetResourceInstance());
		return hr;
    }

    //
    //  Init the Rule Object
    //
    hr = pClass->Init(pInfo, m_pIFaxServerInner);
    if (FAILED(hr))
    {
        CALL_FAIL(GENERAL_ERR, _T("pClass->Init(pInfo, m_pIFaxServerInner)"), hr);
        AtlReportError(CLSID_FaxOutboundRoutingRules, GetErrorMsgId(hr), IID_IFaxOutboundRoutingRules, hr, _Module.GetResourceInstance());
        delete pClass;
        return hr;
    }

    //
    //  Get Interface from the pClass.
    //  This will make AddRef() on the Interface. 
    //  This is the Collection's AddRef, which is freed at Collection's Dtor.
    //
    CComPtr<IFaxOutboundRoutingRule>     pObject = NULL;
    hr = pClass->QueryInterface(&pObject);
    if (FAILED(hr) || (!pObject))
    {
        if (!pObject)
        {
            hr = E_FAIL;
        }
        CALL_FAIL(GENERAL_ERR, _T("pClass->QueryInterface(&pObject)"), hr);
        AtlReportError(CLSID_FaxOutboundRoutingRules, GetErrorMsgId(hr), IID_IFaxOutboundRoutingRules, hr, _Module.GetResourceInstance());
        delete pClass;
        return hr;
    }

	//
	//	Put the Object in the collection
	//
	try 
	{
		m_coll.push_back(pObject);
	}
	catch (exception &)
	{
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxOutboundRoutingRules, IDS_ERROR_OUTOFMEMORY, IID_IFaxOutboundRoutingRules, hr, _Module.GetResourceInstance());
		CALL_FAIL(MEM_ERR, _T("m_coll.push_back(pObject)"), hr);

        //
        //  pObject will call Release(), which will delete the pClass
        //
		return hr;
	}

    //
    //  We want to save the current AddRef() to Collection
    //
    pObject.Detach();

    //
    //  if required, return ptr to the new Rule Object
    //
    if (ppNewRule)
    {
        if (::IsBadWritePtr(ppNewRule, sizeof(IFaxOutboundRoutingRule *)))
	    {
		    hr = E_POINTER;
		    CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr(ppNewRule, sizeof(IFaxOutboundRoutingRule *))"), hr);
		    return hr;
        }
        else
        {
            *ppNewRule = m_coll.back();
            (*ppNewRule)->AddRef();
        }
    }

    return hr;
}

//
//==================== INIT ===================================================
//
STDMETHODIMP
CFaxOutboundRoutingRules::Init(
    /*[in]*/ IFaxServerInner *pServer
)
/*++

Routine name : CFaxOutboundRoutingRules::Init

Routine description:

	Initialize the Rules Collection

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	pServer                       [in]    - Ptr to the Server

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxOutboundRoutingRules::Init"), hr);

    //
    //  First, set the Ptr to the Server
    //
    hr = CFaxInitInnerAddRef::Init(pServer);
    if (FAILED(hr))
    {
        return hr;
    }

    //
    //  Get Fax Handle
    //
    HANDLE faxHandle;
	hr = m_pIFaxServerInner->GetHandle(&faxHandle);
    ATLASSERT(SUCCEEDED(hr));

	if (faxHandle == NULL)
	{
		//
		//	Fax Server is not connected
		//
		hr = Fax_HRESULT_FROM_WIN32(ERROR_NOT_CONNECTED);
		CALL_FAIL(GENERAL_ERR, _T("faxHandle == NULL"), hr);
        AtlReportError(CLSID_FaxOutboundRoutingRules, GetErrorMsgId(hr), IID_IFaxOutboundRoutingRules, hr, _Module.GetResourceInstance());
		return hr;
	}

    //
    //  Call Server to Return all OR Rules
    //
    CFaxPtr<FAX_OUTBOUND_ROUTING_RULE>  pRules;
    DWORD                               dwNum = 0;
    if (!FaxEnumOutboundRules(faxHandle, &pRules, &dwNum))
    {
		hr = Fax_HRESULT_FROM_WIN32(GetLastError());
		CALL_FAIL(GENERAL_ERR, _T("FaxEnumOutboundRules(faxHandle, &pRules, &dwNum)"), hr);
        AtlReportError(CLSID_FaxOutboundRoutingRules, GetErrorMsgId(hr), IID_IFaxOutboundRoutingRules, hr, _Module.GetResourceInstance());
		return hr;
    }

    //
    //  Fill the Collection with Objects
    //
    for (DWORD i=0 ; i<dwNum ; i++ )
    {
        hr = AddRule(&pRules[i]);
        if (FAILED(hr))
        {
            return hr;
        }
    }

    return hr;
}

//
//==================== ADD ===================================================
//
STDMETHODIMP
CFaxOutboundRoutingRules::Add(
    /*[in]*/ long lCountryCode, 
    /*[in]*/ long lAreaCode, 
    /*[in]*/ VARIANT_BOOL bUseDevice, 
    /*[in]*/ BSTR bstrGroupName,
    /*[in]*/ long lDeviceId, 
    /*[out]*/ IFaxOutboundRoutingRule **ppRule
)
/*++

Routine name : CFaxOutboundRoutingRules::Add

Routine description:

	Add new Rule to the Collection and to the Server.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	lCountryCode                  [in]    - Country Code of the new Rule
	lAreaCode                     [in]    - Area Code for the new Rule
	bUseDevice                    [in]    - bUseDevice Flag of the new Rule
	bstrGroupName                 [in]    - Group Name of the new Rule
	lDeviceId                     [in]    - Device Id of the new Rule
	ppRule                        [in]    - the created Rule

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxOutboundRoutingRules::Add"), hr, _T("Country=%ld Area=%ld bUseDevice=%ld Group=%s DeviceId=%ld"), lCountryCode, lAreaCode, bUseDevice, bstrGroupName, lDeviceId);

    //
    //  Get Fax Handle
    //
    HANDLE faxHandle;
	hr = m_pIFaxServerInner->GetHandle(&faxHandle);
    ATLASSERT(SUCCEEDED(hr));

	if (faxHandle == NULL)
	{
		//
		//	Fax Server is not connected
		//
		hr = Fax_HRESULT_FROM_WIN32(ERROR_NOT_CONNECTED);
		CALL_FAIL(GENERAL_ERR, _T("faxHandle == NULL"), hr);
        AtlReportError(CLSID_FaxOutboundRoutingRules, GetErrorMsgId(hr), IID_IFaxOutboundRoutingRules, hr, _Module.GetResourceInstance());
		return hr;
	}

    //
    //  Call Server to Add the Rule
    //
    bool bUseDeviceRule = VARIANT_BOOL2bool(bUseDevice);
    if (!FaxAddOutboundRule(faxHandle, lAreaCode, lCountryCode, lDeviceId, bstrGroupName, (!bUseDeviceRule)))
    {
		hr = Fax_HRESULT_FROM_WIN32(GetLastError());
		CALL_FAIL(GENERAL_ERR, _T("FaxAddOutboundRule(faxHandle, lAreaCode, lCountryCode, lDeviceId, bstrGroupName, (!bUseDeviceRule))"), hr);
        AtlReportError(CLSID_FaxOutboundRoutingRules, GetErrorMsgId(hr), IID_IFaxOutboundRoutingRules, hr, _Module.GetResourceInstance());
		return hr;
    }

    //
    //  Take from the Server updated list of Rules -- because of unknown Status of new Rule
    //
    CFaxPtr<FAX_OUTBOUND_ROUTING_RULE>  pRules;
    DWORD                               dwNum = 0;
    if (!FaxEnumOutboundRules(faxHandle, &pRules, &dwNum))
    {
		hr = Fax_HRESULT_FROM_WIN32(GetLastError());
		CALL_FAIL(GENERAL_ERR, _T("FaxEnumOutboundRules(faxHandle, &pRules, &dwNum)"), hr);
        AtlReportError(CLSID_FaxOutboundRoutingRules, GetErrorMsgId(hr), IID_IFaxOutboundRoutingRules, hr, _Module.GetResourceInstance());
		return hr;
    }

    //
    //  Find Our Rule
    //
    for (DWORD i=0 ; i<dwNum ; i++ )
    {
        if ( (pRules[i].dwAreaCode == lAreaCode) && (pRules[i].dwCountryCode == lCountryCode) )
        {
            //
            //  Add it to the Collection
            //
            hr = AddRule(&pRules[i], ppRule);
            return hr;
        }
    }

    return hr;
}

//
//================= FIND RULE =================================================
//
STDMETHODIMP
CFaxOutboundRoutingRules::FindRule(
    /*[in]*/ long lCountryCode,
    /*[in]*/ long lAreaCode,
    /*[out]*/ ContainerType::iterator *pRule
)
/*++

Routine name : CFaxOutboundRoutingRules::FindRule

Routine description:

	Find Rule in the Collection by its Country and Area Code

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	lCountryCode                  [in]    - the Country Code to look for
	lAreaCode                     [in]    - the Area Code to look for
	pRule                         [out]    - the resultant Rule

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxOutboundRoutingRules::FindRule"), hr, _T("Area=%ld Country=%ld"), lAreaCode, lCountryCode);

    long lRuleAreaCode;
    long lRuleCountryCode;

	ContainerType::iterator	it;
	it = m_coll.begin();
    while ( it != m_coll.end() )
    {
        //
        //  Get Country Code of the Current Rule 
        //
        hr = (*it)->get_CountryCode(&lRuleCountryCode);
        if (FAILED(hr))
        {
		    CALL_FAIL(GENERAL_ERR, _T("(*it)->get_CountryCode(&lCountryCode)"), hr);
            AtlReportError(CLSID_FaxOutboundRoutingRules, GetErrorMsgId(hr), IID_IFaxOutboundRoutingRules, hr, _Module.GetResourceInstance());
		    return hr;
        }

        if (lRuleCountryCode == lCountryCode)
        {
            //
            //  Get Area Code of the Current Rule 
            //
            hr = (*it)->get_AreaCode(&lRuleAreaCode);
            if (FAILED(hr))
            {
		        CALL_FAIL(GENERAL_ERR, _T("(*it)->get_AreaCode(&lAreaCode)"), hr);
                AtlReportError(CLSID_FaxOutboundRoutingRules, GetErrorMsgId(hr), IID_IFaxOutboundRoutingRules, hr, _Module.GetResourceInstance());
		        return hr;
            }

            if (lAreaCode == lRuleAreaCode)
            {
                *pRule = it;
                return hr;
            }
        }

        it++;
    }

    //
    //  Rule Not Found
    //
    hr = E_INVALIDARG;
    CALL_FAIL(GENERAL_ERR, _T("Such Rule is not found"), hr);
    AtlReportError(CLSID_FaxOutboundRoutingRules, GetErrorMsgId(hr), IID_IFaxOutboundRoutingRules, hr, _Module.GetResourceInstance());
    return hr;
};

//
//==================== ITEM BY COUNTRY AND AREA ========================================
//
STDMETHODIMP
CFaxOutboundRoutingRules::ItemByCountryAndArea(
    /*[in]*/ long lCountryCode, 
    /*[in]*/ long lAreaCode, 
    /*[out, retval]*/ IFaxOutboundRoutingRule **ppRule)
/*++

Routine name : CFaxOutboundRoutingRules::ItemByCountryAndArea

Routine description:

	Return Item by given Country and Area Code

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	lCountryCode                  [in]    - the Country Code
	lAreaCode                     [in]    - the Area COde
	ppRule                        [out]    - the Rule to return

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxOutboundRoutingRules::ItemByCountryAndArea"), hr, _T("Area=%ld Country=%ld"), lAreaCode, lCountryCode);

    //
    //  Check that we have got a good Ptr
    //
    if (::IsBadWritePtr(ppRule, sizeof(IFaxOutboundRoutingRule *)))
    {
		hr = E_POINTER;
		CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr(ppRule, sizeof(IFaxOutboundRoutingRule *))"), hr);
        AtlReportError(CLSID_FaxOutboundRoutingRules, GetErrorMsgId(hr), IID_IFaxOutboundRoutingRules, hr, _Module.GetResourceInstance());
		return hr;
    }

    //
    //  Find the Item
    //
    ContainerType::iterator ruleIt;
    hr = FindRule(lCountryCode, lAreaCode, &ruleIt);
    if (FAILED(hr))
    {
        return hr;
    }

    //
    //  Return the found Rule
    //
    (*ruleIt)->AddRef();
    *ppRule = (*ruleIt);
    return hr;
}

//
//==================== REMOVE BY COUNTRY AND AREA ========================================
//
STDMETHODIMP
CFaxOutboundRoutingRules::RemoveByCountryAndArea(
	/*[in]*/ long lCountryCode,
    /*[in]*/ long lAreaCode
)
/*++

Routine name : CFaxOutboundRoutingRules::RemoveByCountryAndArea

Routine description:

	Remove Rule from the Collection and at Server as well.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

        lAreaCode       [in]    -   Area Code of the Rule to Remove
        lCountryCode    [in]    -   Country Code of the Rule to Remove

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxOutboundRoutingRules::RemoveByCountryAndArea"), hr, _T("Area=%ld Country=%ld"), lAreaCode, lCountryCode);

    //
    //  Check that this is not a Default Rule
    //
    if (lAreaCode == frrcANY_CODE && lCountryCode == frrcANY_CODE)
    {
        hr = E_INVALIDARG;
        CALL_FAIL(GENERAL_ERR, _T("Remove the Default Rule"), hr);
        AtlReportError(CLSID_FaxOutboundRoutingRules, IDS_ERROR_REMOVEDEFAULTRULE, IID_IFaxOutboundRoutingRules, hr, _Module.GetResourceInstance());
        return hr;
    }

    //
    //  Find the Rule
    //
	ContainerType::iterator	ruleIt;
    hr = FindRule(lCountryCode, lAreaCode, &ruleIt);
    if (FAILED(hr))
    {
        return hr;
    }

    //
    //  Remove the found Rule
    //
    hr = RemoveRule(lAreaCode, lCountryCode, ruleIt);
    return hr;
}

//
//==================== REMOVE RULE ========================================
//
STDMETHODIMP
CFaxOutboundRoutingRules::RemoveRule (
	/*[in]*/ long lAreaCode,
    /*[in]*/ long lCountryCode,
    /*[in]*/ ContainerType::iterator &it
)
/*++

Routine name : CFaxOutboundRoutingRules::RemoveRule

Routine description:

	Remove Rule from the Collection and from the Server.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

        lAreaCode       [in]    -   Area Code of the Rule to Remove
        lCountryCode    [in]    -   Country Code of the Rule to Remove
        it              [in]    -   Reference to the Iterator poiting to the Rule in the Collection

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxOutboundRoutingRules::RemoveRule"), hr, _T("Area=%ld Country=%ld"), lAreaCode, lCountryCode);

    //
    //  Get Fax Handle
    //
    HANDLE faxHandle;
	hr = m_pIFaxServerInner->GetHandle(&faxHandle);
    ATLASSERT(SUCCEEDED(hr));

	if (faxHandle == NULL)
	{
		//
		//	Fax Server is not connected
		//
		hr = Fax_HRESULT_FROM_WIN32(ERROR_NOT_CONNECTED);
		CALL_FAIL(GENERAL_ERR, _T("faxHandle == NULL"), hr);
        AtlReportError(CLSID_FaxOutboundRoutingRules, GetErrorMsgId(hr), IID_IFaxOutboundRoutingRules, hr, _Module.GetResourceInstance());
		return hr;
	}

    //
    //  Call Server to Remove the Rule
    //
    if (!FaxRemoveOutboundRule(faxHandle, lAreaCode, lCountryCode))
    {
		hr = Fax_HRESULT_FROM_WIN32(GetLastError());
		CALL_FAIL(GENERAL_ERR, _T("FaxRemoveOutboundRule(faxHandle, lAreaCode, lCountryCode)"), hr);
        AtlReportError(CLSID_FaxOutboundRoutingRules, GetErrorMsgId(hr), IID_IFaxOutboundRoutingRules, hr, _Module.GetResourceInstance());
		return hr;
    }

    //
    //  Remove from our Collection as well
    //
	try
	{
		m_coll.erase(it);
	}
	catch(exception &)
	{
		//
		//	Failed to remove the Rule
		//
		hr = E_OUTOFMEMORY;
        AtlReportError(CLSID_FaxOutboundRoutingRules, GetErrorMsgId(hr), IID_IFaxOutboundRoutingRules, hr, _Module.GetResourceInstance());
		CALL_FAIL(MEM_ERR, _T("m_coll.erase(it)"), hr);
		return hr;
	}

    return hr;
}

//
//==================== REMOVE ========================================
//
STDMETHODIMP
CFaxOutboundRoutingRules::Remove (
	/*[in]*/ long lIndex
)
/*++

Routine name : CFaxOutboundRoutingRules::Remove

Routine description:

	Remove Rule from the Collection and at Server as well.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	lIndex                        [in]    - Index of the Rule to Remove.

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxOutboundRoutingRules::Remove"), hr, _T("Index=%ld"), lIndex);

	if (lIndex < 1 || lIndex > m_coll.size()) 
	{
		//
		//	Invalid Index
		//
		hr = E_INVALIDARG;
		AtlReportError(CLSID_FaxOutboundRoutingRules, IDS_ERROR_OUTOFRANGE, IID_IFaxOutboundRoutingRules, hr, _Module.GetResourceInstance());
		CALL_FAIL(GENERAL_ERR, _T("lIndex < 1 || lIndex > m_coll.size()"), hr);
		return hr;
	}

	ContainerType::iterator	it;
	it = m_coll.begin() + lIndex - 1;

    //
    //  Get Area Code of the Rule to Remove
    //
    long lAreaCode;
    hr = (*it)->get_AreaCode(&lAreaCode);
    if (FAILED(hr))
    {
		CALL_FAIL(GENERAL_ERR, _T("(*it)->get_AreaCode(&lAreaCode)"), hr);
        AtlReportError(CLSID_FaxOutboundRoutingRules, GetErrorMsgId(hr), IID_IFaxOutboundRoutingRules, hr, _Module.GetResourceInstance());
		return hr;
    }

    //
    //  Get Country Code of the Rule to Remove
    //
    long lCountryCode;
    hr = (*it)->get_CountryCode(&lCountryCode);
    if (FAILED(hr))
    {
		CALL_FAIL(GENERAL_ERR, _T("(*it)->get_CountryCode(&lCountryCode)"), hr);
        AtlReportError(CLSID_FaxOutboundRoutingRules, GetErrorMsgId(hr), IID_IFaxOutboundRoutingRules, hr, _Module.GetResourceInstance());
		return hr;
    }

    //
    //  Check that this is not a Default Rule
    //
    if (lAreaCode == frrcANY_CODE && lCountryCode == frrcANY_CODE)
    {
        hr = E_INVALIDARG;
        CALL_FAIL(GENERAL_ERR, _T("Remove the Default Rule"), hr);
        AtlReportError(CLSID_FaxOutboundRoutingRules, IDS_ERROR_REMOVEDEFAULTRULE, IID_IFaxOutboundRoutingRules, hr, _Module.GetResourceInstance());
        return hr;
    }

    //
    //  Remove the Rule from the Server and from our Collection
    //
    hr = RemoveRule(lAreaCode, lCountryCode, it);
    return hr;
}

//
//==================== CREATE ========================================
//
HRESULT 
CFaxOutboundRoutingRules::Create (
	/*[out, retval]*/IFaxOutboundRoutingRules **ppRules
)
/*++

Routine name : CFaxOutboundRoutingRules::Create

Routine description:

	Static function to create the Fax Outbound Routing Rules Collection Object

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	ppRules                     [out]  -- the new Fax OR Rules Collection Object

Return Value:

    Standard HRESULT code

--*/

{
	HRESULT     hr = S_OK;
	DBG_ENTER (_T("CFaxOutboundRoutingRules::Create"), hr);

    //
    //  Create Instance of the Collection
    //
	CComObject<CFaxOutboundRoutingRules>		*pClass;
	hr = CComObject<CFaxOutboundRoutingRules>::CreateInstance(&pClass);
	if (FAILED(hr))
	{
		CALL_FAIL(GENERAL_ERR, _T("CComObject<CFaxOutboundRoutingRules>::CreateInstance(&pClass)"), hr);
		return hr;
	}

    //
    //  Return the desired Interface Ptr
    //
	hr = pClass->QueryInterface(ppRules);
	if (FAILED(hr))
	{
		CALL_FAIL(GENERAL_ERR, _T("pClass->QueryInterface(ppRules)"), hr);
		return hr;
	}

	return hr;
}	//	CFaxOutboundRoutingRules::Create()

//
//===================== SUPPORT ERROR INFO ======================================
//
STDMETHODIMP 
CFaxOutboundRoutingRules::InterfaceSupportsErrorInfo(
    REFIID riid
)
/*++

Routine name : CFaxOutboundRoutingRules::InterfaceSupportsErrorInfo

Routine description:

	ATL's implementation of Support Error Info.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	riid                          [in]    - reference to the Interface.

Return Value:

    Standard HRESULT code

--*/
{
	static const IID* arr[] = 
	{
		&IID_IFaxOutboundRoutingRules
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxoutgoingarchive.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxOutgoingArchive.cpp

Abstract:

	Implementation of CFaxOutgoingArchive

Author:

	Iv Garber (IvG)	Apr, 2000

Revision History:

--*/

#include "stdafx.h"
#include "FaxComEx.h"
#include "FaxOutgoingArchive.h"

//
//==================== INTERFACE SUPPORT ERROR INFO =====================
//
STDMETHODIMP 
CFaxOutgoingArchive::InterfaceSupportsErrorInfo(
	REFIID riid
)
/*++

Routine name : CFaxOutgoingArchive::InterfaceSupportsErrorInfo

Routine description:

	ATL's implementation of Interface Support Error Info

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	riid                          [in]    - Reference of the Interface

Return Value:

    Standard HRESULT code

--*/
{
	static const IID* arr[] = 
	{
		&IID_IFaxOutgoingArchive
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxoutgoingarchive.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	faxoutgoingarchive.h

Abstract:

	Declaration of the CFaxOutgoingArchive Class.

Author:

	Iv Garber (IvG)	Jun, 2000

Revision History:

--*/


#ifndef __FAXOUTGOINGARCHIVE_H_
#define __FAXOUTGOINGARCHIVE_H_

#include "resource.h"       // main symbols
#include "FaxArchiveInner.h"
#include "FaxOutgoingMessageIterator.h"


//
//================= FAX OUTGOING ARCHIVE ==================================================
//
class ATL_NO_VTABLE CFaxOutgoingArchive : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public ISupportErrorInfo,
	public CFaxArchiveInner<IFaxOutgoingArchive, &IID_IFaxOutgoingArchive, &CLSID_FaxOutgoingArchive, 
		FAX_MESSAGE_FOLDER_SENTITEMS, IFaxOutgoingMessage, CFaxOutgoingMessage,
		IFaxOutgoingMessageIterator, CFaxOutgoingMessageIterator>
{
public:
	CFaxOutgoingArchive()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_FAXOUTGOINGARCHIVE)
DECLARE_NOT_AGGREGATABLE(CFaxOutgoingArchive)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxOutgoingArchive)
	COM_INTERFACE_ENTRY(IFaxOutgoingArchive)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY(IFaxInitInner)
END_COM_MAP()

//	Interfaces
STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

};

#endif //__FAXOUTGOINGARCHIVE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxoutgoingjob.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxOutgoingJob.cpp

Abstract:

	Implementation of Fax Outgoing Job Class.

Author:

	Iv Garber (IvG)	May, 2000

Revision History:

--*/

#include "stdafx.h"
#include "FaxComEx.h"
#include "FaxOutgoingJob.h"

//
//==================== INTERFACE SUPPORT ERROR INFO ==========================
//
STDMETHODIMP CFaxOutgoingJob::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IFaxOutgoingJob
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

//
//==================== CREATE ========================================
//
HRESULT 
CFaxOutgoingJob::Create (
	IFaxOutgoingJob **ppOutgoingJob
)
/*++

Routine name : CFaxOutgoingJob::Create

Routine description:

	Static function to create the Fax Inbound Message Instance

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	ppOutgoingJob             [out]  -- the new Fax Inbound Message Instance

Return Value:

    Standard HRESULT code

--*/

{
	CComObject<CFaxOutgoingJob>		*pClass;
	HRESULT								hr = S_OK;

	DBG_ENTER (TEXT("CFaxOutgoingJob::Create"), hr);

	hr = CComObject<CFaxOutgoingJob>::CreateInstance(&pClass);
	if (FAILED(hr))
	{
		//
		//	Failed to create Instance
		//
		CALL_FAIL(GENERAL_ERR, _T("CComObject<CFaxOutgoingJob>::CreateInstance()"), hr);
		return hr;
	}

	hr = pClass->QueryInterface(__uuidof(IFaxOutgoingJob), (void **) ppOutgoingJob);
	if (FAILED(hr))
	{
		//
		//	Failed to Query Fax Inbound Message Interface
		//
		CALL_FAIL(GENERAL_ERR, _T("QueryInterface()"), hr);
		return hr;
	}

	return hr;
}	//	CFaxOutgoingJob::Create()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxoutboundroutingrules.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxOutboundRoutingRules.h

Abstract:

	Declaration of the CFaxOutboundRoutingRules class.

Author:

	Iv Garber (IvG)	Jun, 2000

Revision History:

--*/


#ifndef __FAXOUTBOUNDROUTINGRULES_H_
#define __FAXOUTBOUNDROUTINGRULES_H_

#include "resource.h"       // main symbols
#include "FaxCommon.h"
#include <vector>
#include "VCUE_Copy.h"

namespace RulesNamespace
{

    //
    //  Rule Objects are stored in Vector of STL.
    //
    //  When initialized, they got ALL their data, and Fax Server Ptr.
    //  They do not depend on Rules Collection, only on Fax Server.
    //  They inherit from CFaxInitInnerAddRef class, which means they make AddRef() 
    //  on Fax Server ( at Init() ).
    //
    //  The Collection makes ONE AddRef() for each Rule Object, to prevent its death. 
    //  When killed, Collection calls Release() on all its Rule Objects.
    //
    //  At Rule Object's death, it calls Release() on the Fax Server Object.
    //
	typedef	std::vector<IFaxOutboundRoutingRule*>       ContainerType;

	// Use IEnumVARIANT as the enumerator for VB compatibility
	typedef	VARIANT			EnumExposedType;
	typedef	IEnumVARIANT    EnumIfc;

	//  Copy Classes
    typedef VCUE::CopyIfc2Variant<ContainerType::value_type>    EnumCopyType;
    typedef VCUE::CopyIfc<ContainerType::value_type>            CollectionCopyType;

    typedef CComEnumOnSTL< EnumIfc, &__uuidof(EnumIfc), EnumExposedType, EnumCopyType, 
        ContainerType >    EnumType;

    typedef ICollectionOnSTLImpl< IFaxOutboundRoutingRules, ContainerType, 
        ContainerType::value_type, CollectionCopyType, EnumType >    CollectionType;
};

using namespace RulesNamespace;

//
//==================== FAX OUTBOUND ROUTING RULES ===================================
//
//  FaxOutboundRoutingRules creates a collection of all its Rule Objects at Init.
//  It needs Ptr to the Fax Server Object, for Add and Remove operations. 
//  To prevent the death of the Fax Server before its own death, the Collection
//  makes AddRef() on Server. To do this, it inherits from CFaxInitInnerAddRef.
//  
//  When creating Rule Objects, the Collection passes Ptr to the Fax Server Object
//  to them, and from this moment, the Objects are not dependent on the Collection.
//  They live their own lifes. Collection makes one AddRef() on them, to prevent their 
//  death before its own death, exactly as in the case with the Fax Server Object.
//
//  The Rule Object itself needs Ptr to the Fax Server Object, to perform its 
//  Save and Refresh. So, Rule Object also makes AddRef() on the Fax Server Object,
//  to prevent its permature death.
//
class ATL_NO_VTABLE CFaxOutboundRoutingRules : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public ISupportErrorInfo,
    public IDispatchImpl<RulesNamespace::CollectionType, &IID_IFaxOutboundRoutingRules, &LIBID_FAXCOMEXLib>,
    public CFaxInitInnerAddRef
{
public:
    CFaxOutboundRoutingRules() : CFaxInitInnerAddRef(_T("FAX OUTBOUND ROUTING RULES"))
	{
	}

    ~CFaxOutboundRoutingRules()
    {
        CCollectionKiller<RulesNamespace::ContainerType>  CKiller;
        CKiller.EmptyObjectCollection(&m_coll);
    }


DECLARE_REGISTRY_RESOURCEID(IDR_FAXOUTBOUNDROUTINGRULES)
DECLARE_NOT_AGGREGATABLE(CFaxOutboundRoutingRules)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxOutboundRoutingRules)
	COM_INTERFACE_ENTRY(IFaxOutboundRoutingRules)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY(IFaxInitInner)
END_COM_MAP()

//  Interfaces
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

    STDMETHOD(Remove)(/*[in]*/ long lIndex);
    STDMETHOD(RemoveByCountryAndArea)(/*[in]*/ long lCountryCode, /*[in]*/ long lAreaCode);

    STDMETHOD(ItemByCountryAndArea)(/*[in]*/ long lCountryCode, /*[in]*/ long lAreaCode, 
        /*[out, retval]*/ IFaxOutboundRoutingRule **ppRule);

    STDMETHOD(Add)(long lCountryCode, long lAreaCode, VARIANT_BOOL bUseDevice, BSTR bstrGroupName,
        long lDeviceId, IFaxOutboundRoutingRule **pFaxOutboundRoutingRule);

//  Internal Use
    static HRESULT Create(IFaxOutboundRoutingRules **ppRules);
    STDMETHOD(Init)(IFaxServerInner *pServer);

private:
    STDMETHOD(RemoveRule)(long lAreaCode, long lCountryCode, RulesNamespace::ContainerType::iterator &it);
    STDMETHOD(FindRule)(long lCountryCode, long lAreaCode, RulesNamespace::ContainerType::iterator *pRule);
    STDMETHOD(AddRule)(FAX_OUTBOUND_ROUTING_RULE *pInfo, IFaxOutboundRoutingRule **ppNewRule = NULL);
};

#endif //__FAXOUTBOUNDROUTINGRULES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxoutgoingjobs.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxOutgoingJobs.cpp

Abstract:

	Implementation of Fax Outgoing Jobs Class

Author:

	Iv Garber (IvG)	May, 2000

Revision History:

--*/


#include "stdafx.h"
#include "FaxComEx.h"
#include "FaxOutgoingJobs.h"

//
//==================== CREATE ========================================
//
HRESULT 
CFaxOutgoingJobs::Create (
	IFaxOutgoingJobs **ppOutgoingJobs
)
/*++

Routine name : CFaxOutgoingJobs::Create

Routine description:

	Static function to create the Fax OutgoingJobs Object

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	ppOutgoingJobs		[out]  -- the new Fax OutgoingJobs Object

Return Value:

    Standard HRESULT code

--*/

{
	HRESULT	        					hr = S_OK;

	DBG_ENTER (TEXT("CFaxOutgoingJobs::Create"), hr);

	CComObject<CFaxOutgoingJobs>		*pClass;
	hr = CComObject<CFaxOutgoingJobs>::CreateInstance(&pClass);
	if (FAILED(hr))
	{
		//
		//	Failed to create Instance
		//
		CALL_FAIL(GENERAL_ERR, _T("CComObject<CFaxOutgoingJobs>::CreateInstance()"), hr);
		return hr;
	}

	hr = pClass->QueryInterface(__uuidof(IFaxOutgoingJobs), (void **) ppOutgoingJobs);
	if (FAILED(hr))
	{
		//
		//	Failed to Query Fax OutgoingJobs Interface
		//
		CALL_FAIL(GENERAL_ERR, _T("QueryInterface()"), hr);
		return hr;
	}

	return hr;
}	//	CFaxIncomingJobs::Create()

//
//=================== SUPPORT ERROR INFO ===========================================
//
STDMETHODIMP CFaxOutgoingJobs::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IFaxOutgoingJobs
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxoutgoingjobs.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxOutgoingJobs.h

Abstract:

	Declaration of Fax Outgoing Jobs Class

Author:

	Iv Garber (IvG)	May, 2000

Revision History:

--*/

#ifndef __FAXOUTGOINGJOBS_H_
#define __FAXOUTGOINGJOBS_H_

#include "resource.h"       // main symbols
#include <vector>
#include "FaxOutgoingJob.h"
#include "FaxJobsCollection.h"


namespace OutgoingJobsNamespace
{

	// Jobs stored in array, pointers to them - in vector
	typedef	std::vector<IFaxOutgoingJob*>	ContainerType;

	// The collection interface exposes the data as Job objects
	typedef	IFaxOutgoingJob	    CollectionExposedType;
	typedef IFaxOutgoingJobs	CollectionIfc;

	// Use IEnumVARIANT as the enumerator for VB compatibility
	typedef	VARIANT				EnumExposedType;
	typedef	IEnumVARIANT		EnumIfc;

	// Typedef the copy classes using existing typedefs
    typedef VCUE::CopyIfc2Variant<ContainerType::value_type>    EnumCopyType;
    typedef VCUE::CopyIfc<IFaxOutgoingJob*>    CollectionCopyType;

    typedef CComEnumOnSTL< EnumIfc, &__uuidof(EnumIfc), 
		EnumExposedType, EnumCopyType, ContainerType >    EnumType;

    typedef JobCollection< CollectionIfc, ContainerType, CollectionExposedType, CollectionCopyType, 
        EnumType, CFaxOutgoingJob, &IID_IFaxOutgoingJobs, &CLSID_FaxOutgoingJobs >    CollectionType;
};

using namespace OutgoingJobsNamespace;


//
//=================== FAX OUTGOING JOBS =========================================
//
class ATL_NO_VTABLE CFaxOutgoingJobs : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public ISupportErrorInfo,
    public IDispatchImpl<OutgoingJobsNamespace::CollectionType, &IID_IFaxOutgoingJobs, &LIBID_FAXCOMEXLib>
{
public:
	CFaxOutgoingJobs()
	{
        DBG_ENTER(_T("FAX OUTGOING JOBS::CREATE"));
	}

DECLARE_REGISTRY_RESOURCEID(IDR_FAXOUTGOINGJOBS)
DECLARE_NOT_AGGREGATABLE(CFaxOutgoingJobs)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxOutgoingJobs)
	COM_INTERFACE_ENTRY(IFaxOutgoingJobs)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

//  Interfaces
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

//  Internal Use
	static HRESULT Create(IFaxOutgoingJobs **ppOutgoingJobs);
};

#endif //__FAXOUTGOINGJOBS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxoutgoingmessage.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxOutgoingMessage.cpp

Abstract:

	Implementation of Fax Outgoing Message Class

Author:

	Iv Garber (IvG)	May, 2000

Revision History:

--*/

#include "stdafx.h"
#include "FaxComEx.h"
#include "FaxOutgoingMessage.h"


//
//==================== CREATE ========================================
//
HRESULT 
CFaxOutgoingMessage::Create (
	IFaxOutgoingMessage **ppOutgoingMessage
)
/*++

Routine name : CFaxOutgoingMessage::Create

Routine description:

	Static function to create the Fax Outgoing Message Instance

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	ppOutgoingMessage             [out]  -- the new Fax Outgoing Message Instance

Return Value:

    Standard HRESULT code

--*/

{
	CComObject<CFaxOutgoingMessage>		*pClass;
	HRESULT								hr = S_OK;

	DBG_ENTER (TEXT("CFaxOutgoingMessage::Create"), hr);

	hr = CComObject<CFaxOutgoingMessage>::CreateInstance(&pClass);
	if (FAILED(hr))
	{
		//
		//	Failed to create Instance
		//
		CALL_FAIL(GENERAL_ERR, _T("CComObject<CFaxOutgoingMessage>::CreateInstance()"), hr);
		return hr;
	}

	hr = pClass->QueryInterface(__uuidof(IFaxOutgoingMessage),
		(void **) ppOutgoingMessage);
	if (FAILED(hr))
	{
		//
		//	Failed to Query Fax Outgoing Message Interface
		//
		CALL_FAIL(GENERAL_ERR, _T("QueryInterface()"), hr);
		return hr;
	}

	return hr;
}	//	CFaxOutgoingMessage::Create()

//
//============================ SUPPORT ERROR INFO ==================================================
//
STDMETHODIMP 
CFaxOutgoingMessage::InterfaceSupportsErrorInfo(
	REFIID riid
)
/*++

Routine name : CFaxOutgoingMessage::InterfaceSupportsErrorInfo

Routine description:

	ATL's implementation of Error Info Support

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	riid                          [in]    -	IID of the interface to check whether supports Error Info

Return Value:

    Standard HRESULT code

--*/
{
	static const IID* arr[] = 
	{
		&IID_IFaxOutgoingMessage
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxoutgoingjob.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxOutgoingJob.h

Abstract:

	Definition of Fax Outgoing Job Class.

Author:

	Iv Garber (IvG)	May, 2000

Revision History:

--*/


#ifndef __FAXOUTGOINGJOB_H_
#define __FAXOUTGOINGJOB_H_

#include "resource.h"       // main symbols
#include "FaxJobInner.h"


//
//========================= FAX OUTGOING JOB ============================================
//
class ATL_NO_VTABLE CFaxOutgoingJob : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public ISupportErrorInfo,
	public CFaxJobInner<IFaxOutgoingJob, &IID_IFaxOutgoingJob, &CLSID_FaxOutgoingJob>
{
public:
	CFaxOutgoingJob()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_FAXOUTGOINGJOB)
DECLARE_NOT_AGGREGATABLE(CFaxOutgoingJob)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxOutgoingJob)
	COM_INTERFACE_ENTRY(IFaxOutgoingJob)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

// Interfaces
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

//	Internal Use
    static HRESULT Create(IFaxOutgoingJob **ppOutgoingJob);
};

#endif //__FAXOUTGOINGJOB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxoutgoingmessage.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxOutgoingMessage.h

Abstract:

	Declaration of Fax Outgoing Message Class.

Author:

	Iv Garber (IvG)	May, 2000

Revision History:

--*/


#ifndef __FAXOUTGOINGMESSAGE_H_
#define __FAXOUTGOINGMESSAGE_H_

#include "resource.h"       // main symbols
#include "FaxMessageInner.h"

//
//===================== FAX OUTGOING MESSAGE ======================================
//
class ATL_NO_VTABLE CFaxOutgoingMessage : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public ISupportErrorInfo,
	public CFaxMessageInner<IFaxOutgoingMessage, &IID_IFaxOutgoingMessage, 
		&CLSID_FaxOutgoingMessage, FAX_MESSAGE_FOLDER_SENTITEMS>
{
public:
	CFaxOutgoingMessage()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_FAXOUTGOINGMESSAGE)
DECLARE_NOT_AGGREGATABLE(CFaxOutgoingMessage)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxOutgoingMessage)
	COM_INTERFACE_ENTRY(IFaxOutgoingMessage)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

//	Interfaces
STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

//	Internal Use
static HRESULT Create(IFaxOutgoingMessage **ppOutgoingMessage);

};

#endif //__FAXOUTGOINGMESSAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxoutgoingmessageiterator.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxOutgoingMessageIterator.cpp

Abstract:

	Implementation of CFaxOutgoingMessageIterator.

Author:

	Iv Garber (IvG)	May, 2000

Revision History:

--*/

#include "stdafx.h"
#include "FaxComEx.h"
#include "FaxOutgoingMessageIterator.h"
#include "FaxOutgoingMessage.h"

//
//========================= SUPPORT ERROR INFO =======================================
//
STDMETHODIMP 
CFaxOutgoingMessageIterator::InterfaceSupportsErrorInfo(
	REFIID riid
)
/*++

Routine name : CFaxOutgoingMessageIterator::InterfaceSupportsErrorInfo

Routine description:

	ATL's Support for Error Info.

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	riid                          [in]    - IID of the Interface

Return Value:

    Standard HRESULT code

--*/
{
	static const IID* arr[] = 
	{
		&IID_IFaxOutgoingMessageIterator
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

//
//==================== CREATE ========================================
//
HRESULT 
CFaxOutgoingMessageIterator::Create (
	IFaxOutgoingMessageIterator **pOutgoingMsgIterator
)
/*++

Routine name : CFaxOutgoingMessageIterator::Create

Routine description:

	Static function to create the Fax Outgoing Message Iterator Object

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	pOutgoingMsgIterator		[out]  -- the new Fax Outgoing Message Iterator Object

Return Value:

    Standard HRESULT code

--*/

{
	CComObject<CFaxOutgoingMessageIterator>		*pClass;
	HRESULT			hr = S_OK;

	DBG_ENTER (TEXT("CFaxOutgoingMessageIterator::Create"), hr);

	hr = CComObject<CFaxOutgoingMessageIterator>::CreateInstance(&pClass);
	if (FAILED(hr))
	{
		//
		//	Failed to create Instance
		//
		CALL_FAIL(GENERAL_ERR, _T("CComObject<CFaxOutgoingMessageIterator>::CreateInstance()"), hr);
		return hr;
	}

	hr = pClass->QueryInterface(__uuidof(IFaxOutgoingMessageIterator), (void **) pOutgoingMsgIterator);
	if (FAILED(hr))
	{
		//
		//	Failed to Query Fax Outgoing Message Iterator Interface
		//
		CALL_FAIL(GENERAL_ERR, _T("QueryInterface()"), hr);
		return hr;
	}
	return hr;
}	//	CFaxOutgoingMessageIterator::Create()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxoutgoingqueue.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxOutgoingQueue.cpp

Abstract:

	Implementation of CFaxOutgoingQueue

Author:

	Iv Garber (IvG)	Apr, 2000

Revision History:

--*/

#include "stdafx.h"
#include "FaxComEx.h"
#include "FaxOutgoingQueue.h"
#include "..\..\inc\FaxUIConstants.h"


//
//==================== GET DATE ===================================================
//
STDMETHODIMP 
CFaxOutgoingQueue::GetDate(
    FAX_TIME faxTime,
	DATE *pDate
)
/*++

Routine name : CFaxOutgoingQueue::GetDate

Routine description:

	Return the date 

Author:

	Iv Garber (IvG),	June, 2000

Arguments:

    faxTime      [in]     - time to convert from
	pDate        [out]    - Ptr to the Place to put the Date

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxOutgoingQueue::GetDate"), hr);

	//
	//	Check that we can write to the given pointer
	//
	if (::IsBadWritePtr(pDate, sizeof(DATE)))
	{
		//
		//	Got Bad Return Pointer
		//
		hr = E_POINTER;
		AtlReportError(CLSID_FaxOutgoingQueue, IDS_ERROR_INVALID_ARGUMENT, IID_IFaxOutgoingQueue, hr, _Module.GetResourceInstance());
		CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr(pDate)"), hr);
		return hr;
	}

    // 
    //  sync first
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    SYSTEMTIME  sysTime = {0};
    sysTime.wHour = faxTime.Hour;
    sysTime.wMinute = faxTime.Minute;

    DATE    dtResult = 0;

    if (sysTime.wHour == 0 && sysTime.wMinute == 0)
    {
        *pDate = dtResult;
	    return hr;
    }

    if (!SystemTimeToVariantTime(&sysTime, &dtResult))
    {
        hr = E_FAIL;
		AtlReportError(CLSID_FaxOutgoingQueue, 
            IDS_ERROR_OPERATION_FAILED, 
            IID_IFaxOutgoingQueue, 
            hr, 
            _Module.GetResourceInstance());
		CALL_FAIL(GENERAL_ERR, _T("SystemTimeToVariantTime"), hr);
		return hr;
    }

    *pDate = dtResult;
	return hr;
}

//
//==================== SET DATE ==========================================
//
STDMETHODIMP 
CFaxOutgoingQueue::SetDate(
		DATE date,
        FAX_TIME *pfaxTime
)
/*++

Routine name : CFaxOutgoingQueue::SetDate

Routine description:

	Set new value for the given Time

Author:

	Iv Garber (IvG),	June, 2000

Arguments:

	date                [in]    - the new Value for the date
    pfaxTime             [in]    - where to put the value

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;

	DBG_ENTER (_T("CFaxOutgoingQueue::SetDate"), hr);

    // 
    //  sync first
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    SYSTEMTIME  sysTime;

    if (!VariantTimeToSystemTime(date, &sysTime))
    {
        hr = E_FAIL;
		AtlReportError(CLSID_FaxOutgoingQueue, 
            IDS_ERROR_OPERATION_FAILED, 
            IID_IFaxOutgoingQueue, 
            hr, 
            _Module.GetResourceInstance());
		CALL_FAIL(GENERAL_ERR, _T("VariantTimeToSystemTime"), hr);
		return hr;
    }

    pfaxTime->Hour = sysTime.wHour;
    pfaxTime->Minute = sysTime.wMinute;
	return hr;
}

//
//==================== DISCOUNT RATE END ==========================================
//
STDMETHODIMP 
CFaxOutgoingQueue::get_DiscountRateEnd(
		DATE *pdateDiscountRateEnd
)
/*++

Routine name : CFaxOutgoingQueue::get_DiscountRateEnd

Routine description:

	Return date when the Discount period begins

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	pdateDiscountRateEnd        [out]    - Ptr to the Place to put the DiscountRateEnd

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxOutgoingQueue::get_DiscountRateEnd"), hr);
    hr = GetDate(m_pConfig->dtDiscountEnd, pdateDiscountRateEnd);
    return hr;
}

STDMETHODIMP 
CFaxOutgoingQueue::put_DiscountRateEnd(
		DATE dateDiscountRateEnd
)
/*++

Routine name : CFaxOutgoingQueue::put_DiscountRateEnd

Routine description:

	Set new value Discount Rate End

Author:

	Iv Garber (IvG),	June, 2000

Arguments:

	dateDiscountRateEnd                     [in]    - the new Value for DiscountRateEnd

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxOutgoingQueue::put_DiscountRateEnd"), hr);
    hr = SetDate(dateDiscountRateEnd, &(m_pConfig->dtDiscountEnd));
    return hr;
}

//
//==================== DISCOUNT RATE START ==========================================
//
STDMETHODIMP 
CFaxOutgoingQueue::get_DiscountRateStart(
		DATE *pdateDiscountRateStart
)
/*++

Routine name : CFaxOutgoingQueue::get_DiscountRateStart

Routine description:

	Return date when the Discount period begins

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	pdateDiscountRateStart        [out]    - Ptr to the Place to put the DiscountRateStart

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxOutgoingQueue::get_DiscountRateStart"), hr);
    hr = GetDate(m_pConfig->dtDiscountStart, pdateDiscountRateStart);
    return hr;
}

STDMETHODIMP 
CFaxOutgoingQueue::put_DiscountRateStart(
		DATE dateDiscountRateStart
)
/*++

Routine name : CFaxOutgoingQueue::put_DiscountRateStart

Routine description:

	Set new value Discount Rate Start

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	dateDiscountRateStart                     [in]    - the new Value for DiscountRateStart

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxOutgoingQueue::put_DiscountRateStart"), hr);
    hr = SetDate(dateDiscountRateStart, &(m_pConfig->dtDiscountStart));
    return hr;
}

//
//==================== RETRY DELAY ==========================================
//
STDMETHODIMP 
CFaxOutgoingQueue::get_RetryDelay(
		long *plRetryDelay
)
/*++

Routine name : CFaxOutgoingQueue::get_RetryDelay

Routine description:

	Return number of RetryDelay

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	plRetryDelay        [out]    - Ptr to the Place to put the number of RetryDelay

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxOutgoingQueue::get_RetryDelay"), hr);

    // 
    //  sync first
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    hr = GetLong(plRetryDelay, m_pConfig->dwRetryDelay);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxOutgoingQueue,GetErrorMsgId(hr), IID_IFaxOutgoingQueue, hr, _Module.GetResourceInstance());
        return hr;
    }
	return hr;
}

STDMETHODIMP 
CFaxOutgoingQueue::put_RetryDelay(
		long lRetryDelay
)
/*++

Routine name : CFaxOutgoingQueue::put_RetryDelay

Routine description:

	Set new value for this flag

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	lRetryDelay                     [in]    - the new Value of number of RetryDelay

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxOutgoingQueue::put_RetryDelay"), hr, _T("%ld"), lRetryDelay);

    // 
    //  sync first
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    if (lRetryDelay > FXS_RETRYDELAY_UPPER || lRetryDelay < FXS_RETRYDELAY_LOWER)
    {
		//
		//	Out of the Range
		//
		hr = E_INVALIDARG;
		AtlReportError(CLSID_FaxOutgoingQueue, IDS_ERROR_OUTOFRANGE, IID_IFaxOutgoingQueue, hr, _Module.GetResourceInstance());
		CALL_FAIL(GENERAL_ERR, _T("Type is out of the Range"), hr);
		return hr;
    }

	m_pConfig->dwRetryDelay = lRetryDelay;
	return hr;
}

//
//==================== AGE LIMIT ==========================================
//
STDMETHODIMP 
CFaxOutgoingQueue::get_AgeLimit(
    long *plAgeLimit
)
/*++

Routine name : CFaxOutgoingQueue::get_AgeLimit

Routine description:

	Return number of AgeLimit

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	plAgeLimit        [out]    - Ptr to the Place to put the number of AgeLimit

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxOutgoingQueue::get_AgeLimit"), hr);

    // 
    //  sync first
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    hr = GetLong(plAgeLimit, m_pConfig->dwAgeLimit);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxOutgoingQueue,GetErrorMsgId(hr), IID_IFaxOutgoingQueue, hr, _Module.GetResourceInstance());
        return hr;
    }
	return hr;
}

STDMETHODIMP 
CFaxOutgoingQueue::put_AgeLimit(
		long lAgeLimit
)
/*++

Routine name : CFaxOutgoingQueue::put_AgeLimit

Routine description:

	Set new value for this flag

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	lAgeLimit                     [in]    - the new Value of number of AgeLimit

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxOutgoingQueue::put_AgeLimit"), hr, _T("%ld"), lAgeLimit);

    // 
    //  sync first
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

	m_pConfig->dwAgeLimit = lAgeLimit;
	return hr;
}

//
//==================== RETRIES ==========================================
//
STDMETHODIMP 
CFaxOutgoingQueue::get_Retries(
		long *plRetries
)
/*++

Routine name : CFaxOutgoingQueue::get_Retries

Routine description:

	Return number of Retries

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	plRetries        [out]    - Ptr to the Place to put the number of retries

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxOutgoingQueue::get_Retries"), hr);

    // 
    //  sync first
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    hr = GetLong(plRetries, m_pConfig->dwRetries);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxOutgoingQueue,GetErrorMsgId(hr), IID_IFaxOutgoingQueue, hr, _Module.GetResourceInstance());
        return hr;
    }
	return hr;
}

STDMETHODIMP 
CFaxOutgoingQueue::put_Retries(
		long lRetries
)
/*++

Routine name : CFaxOutgoingQueue::put_Retries

Routine description:

	Set new value for this flag

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	lRetries                     [in]    - the new Value of number of retries

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxOutgoingQueue::put_Retries"), hr, _T("%ld"), lRetries);

    // 
    //  sync first
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    if (lRetries > FXS_RETRIES_UPPER || lRetries < FXS_RETRIES_LOWER)
    {
		//
		//	Out of the Range
		//
		hr = E_INVALIDARG;
		AtlReportError(CLSID_FaxOutgoingQueue, IDS_ERROR_OUTOFRANGE, IID_IFaxOutgoingQueue, hr, _Module.GetResourceInstance());
		CALL_FAIL(GENERAL_ERR, _T("Type is out of the Range"), hr);
		return hr;
    }

	m_pConfig->dwRetries = lRetries;
	return hr;
}

//
//==================== BRANDING ==========================================
//
STDMETHODIMP 
CFaxOutgoingQueue::get_Branding(
		VARIANT_BOOL *pbBranding
)
/*++

Routine name : CFaxOutgoingQueue::get_Branding

Routine description:

	Return Flag indicating whether Branding exists

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	pbBranding        [out]    - Ptr to the Place to put Current value of the Flag

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxOutgoingQueue::get_Branding"), hr);

    // 
    //  sync first
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    hr = GetVariantBool(pbBranding, bool2VARIANT_BOOL(m_pConfig->bBranding));
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxOutgoingQueue,GetErrorMsgId(hr), IID_IFaxOutgoingQueue, hr, _Module.GetResourceInstance());
        return hr;
    }
	return hr;
}

STDMETHODIMP 
CFaxOutgoingQueue::put_Branding(
		VARIANT_BOOL bBranding
)
/*++

Routine name : CFaxOutgoingQueue::put_Branding

Routine description:

	Set new value for this flag

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	bBranding                     [in]    - the new Value for the Flag

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxOutgoingQueue::put_Branding"), hr, _T("%d"), bBranding);

    // 
    //  sync first
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

	m_pConfig->bBranding = VARIANT_BOOL2bool(bBranding);
	return hr;
}

//
//==================== USE DEVICE TSID ==========================================
//
STDMETHODIMP 
CFaxOutgoingQueue::get_UseDeviceTSID(
		VARIANT_BOOL *pbUseDeviceTSID
)
/*++

Routine name : CFaxOutgoingQueue::get_UseDeviceTSID

Routine description:

	Return Flag indicating whether to use device TSID

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	pbUseDeviceTSID        [out]    - Ptr to the Place to put Current value of the Flag

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxOutgoingQueue::get_UseDeviceTSID"), hr);

    // 
    //  sync first
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    hr = GetVariantBool(pbUseDeviceTSID, bool2VARIANT_BOOL(m_pConfig->bUseDeviceTSID));
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxOutgoingQueue,GetErrorMsgId(hr), IID_IFaxOutgoingQueue, hr, _Module.GetResourceInstance());
        return hr;
    }
	return hr;
}

STDMETHODIMP 
CFaxOutgoingQueue::put_UseDeviceTSID(
		VARIANT_BOOL bUseDeviceTSID
)
/*++

Routine name : CFaxOutgoingQueue::put_UseDeviceTSID

Routine description:

	Set new value for this flag

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	bUseDeviceTSID              [in]    - the new Value for the Flag

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxOutgoingQueue::put_UseDeviceTSID"), hr, _T("%d"), bUseDeviceTSID);

    // 
    //  sync first
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

	m_pConfig->bUseDeviceTSID = VARIANT_BOOL2bool(bUseDeviceTSID);
	return hr;
}

//
//==================== ALLOW PERSONAL COVER PAGES ==========================================
//
STDMETHODIMP 
CFaxOutgoingQueue::get_AllowPersonalCoverPages(
		VARIANT_BOOL *pbAllowPersonalCoverPages
)
/*++

Routine name : CFaxOutgoingQueue::get_AllowPersonalCoverPages

Routine description:

	Return Flag indicating whether Personal Cover Pages are allowed

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	pbAllowPersonalCoverPages   [out]    - Ptr to the Place to put Current value of the Flag

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
    DBG_ENTER (TEXT("CFaxOutgoingQueue::get_AllowPersonalCoverPages"), hr);

    // 
    //  sync first
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    hr = GetVariantBool(pbAllowPersonalCoverPages, bool2VARIANT_BOOL(m_pConfig->bAllowPersonalCP));
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxOutgoingQueue,GetErrorMsgId(hr), IID_IFaxOutgoingQueue, hr, _Module.GetResourceInstance());
        return hr;
    }
	return hr;
}

STDMETHODIMP 
CFaxOutgoingQueue::put_AllowPersonalCoverPages(
		VARIANT_BOOL bAllowPersonalCoverPages
)
/*++

Routine name : CFaxOutgoingQueue::put_AllowPersonalCoverPages

Routine description:

	Set new value for this flag

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	bAllowPersonalCoverPages        [in]    - the new Value for the Flag

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;

	DBG_ENTER (_T("CFaxOutgoingQueue::put_AllowPersonalCoverPages"), hr, _T("%d"), bAllowPersonalCoverPages);

    // 
    //  sync first
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

	m_pConfig->bAllowPersonalCP = VARIANT_BOOL2bool(bAllowPersonalCoverPages);
	return hr;
}

//
//==================== SAVE ==============================================
//
STDMETHODIMP 
CFaxOutgoingQueue::Save(
)
/*++

Routine name : CFaxOutgoingQueue::Save

Routine description:

	Save current Outgoing Queue Configuration to the Server.

Author:

	Iv Garber (IvG),	May, 2000

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;

	DBG_ENTER (TEXT("CFaxOutgoingQueue::Save"), hr);

    //
    //  Get Fax Handle 
    //
    HANDLE  hFaxHandle = NULL;
    hr = GetFaxHandle(&hFaxHandle);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxOutgoingQueue, 
            GetErrorMsgId(hr), 
            IID_IFaxOutgoingQueue, 
            hr, 
            _Module.GetResourceInstance());
        return hr;
    }

    //
    //  Save Outgoing Queue Configuration
    //
    if (!FaxSetOutboxConfiguration(hFaxHandle, m_pConfig))
    {
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        CALL_FAIL(GENERAL_ERR, _T("FaxSetOutboxConfiguration"), hr);
        AtlReportError(CLSID_FaxOutgoingQueue, 
            GetErrorMsgId(hr), 
            IID_IFaxOutgoingQueue, 
            hr, 
            _Module.GetResourceInstance());
        return hr;
    }

    //
    //  Save Paused and Blocked as well
    //
    hr = CFaxQueueInner<IFaxOutgoingQueue, &IID_IFaxOutgoingQueue, &CLSID_FaxOutgoingQueue, false,
        IFaxOutgoingJob, CFaxOutgoingJob, IFaxOutgoingJobs, CFaxOutgoingJobs>::Save();

    return hr;
}

//
//==================== REFRESH ==============================================
//
STDMETHODIMP 
CFaxOutgoingQueue::Refresh(
)
/*++

Routine name : CFaxOutgoingQueue::Refresh

Routine description:

	Bring Outgoing Queue Configuration from the Server.

Author:

	Iv Garber (IvG),	May, 2000

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;

	DBG_ENTER (TEXT("CFaxOutgoingQueue::Refresh"), hr);

    //
    //  Get Fax Handle 
    //
    HANDLE  hFaxHandle = NULL;
    hr = GetFaxHandle(&hFaxHandle);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxOutgoingQueue, 
            GetErrorMsgId(hr), 
            IID_IFaxOutgoingQueue, 
            hr, 
            _Module.GetResourceInstance());
        return hr;
    }

    //
    //  Get Outgoing Queue Configuration
    //
    if (!FaxGetOutboxConfiguration(hFaxHandle, &m_pConfig))
    {
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        CALL_FAIL(GENERAL_ERR, _T("FaxGetOutboxConfiguration"), hr);
        AtlReportError(CLSID_FaxOutgoingQueue, 
            GetErrorMsgId(hr), 
            IID_IFaxOutgoingQueue, 
            hr, 
            _Module.GetResourceInstance());
        return hr;
    }

	if (!m_pConfig || m_pConfig->dwSizeOfStruct != sizeof(FAX_OUTBOX_CONFIG))
	{
		//
		//	Failed to Get Outgoing Queue Configuration
		//
		hr = E_FAIL;
		AtlReportError(CLSID_FaxOutgoingQueue, 
            IDS_ERROR_OPERATION_FAILED, 
            IID_IFaxOutgoingQueue, 
            hr, 
            _Module.GetResourceInstance());
		CALL_FAIL(GENERAL_ERR, _T("Invalid m_pConfig"), hr);
		return hr;
	}

    //
    //  Refresh Paused and Blocked as well
    //
    hr = CFaxQueueInner<IFaxOutgoingQueue, &IID_IFaxOutgoingQueue, &CLSID_FaxOutgoingQueue, false,
        IFaxOutgoingJob, CFaxOutgoingJob, IFaxOutgoingJobs, CFaxOutgoingJobs>::Refresh();

    if (SUCCEEDED(hr))  
    {
        //
        //  We are synced now
        //
        m_bInited = true;
    }

    return hr;
}

//
//==================== INTERFACE SUPPORT ERROR INFO =====================
//
STDMETHODIMP 
CFaxOutgoingQueue::InterfaceSupportsErrorInfo(
	REFIID riid
)
/*++

Routine name : CFaxOutgoingQueue::InterfaceSupportsErrorInfo

Routine description:

	ATL's implementation of Interface Support Error Info

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	riid                          [in]    - Reference of the Interface

Return Value:

    Standard HRESULT code

--*/
{
	static const IID* arr[] = 
	{
		&IID_IFaxOutgoingQueue
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxoutgoingqueue.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	faxoutgoingqueue.h

Abstract:

	Declaration of the CFaxOutgoingQueue Class.

Author:

	Iv Garber (IvG)	Jun, 2000

Revision History:

--*/


#ifndef __FAXOUTGOINGQUEUE_H_
#define __FAXOUTGOINGQUEUE_H_

#include "resource.h"       // main symbols
#include "FaxQueueInner.h"
#include "FaxOutgoingJob.h"
#include "FaxOutgoingJobs.h"

//
//================= FAX OUTGOING QUEUE =============================================
//
class ATL_NO_VTABLE CFaxOutgoingQueue : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public ISupportErrorInfo,
	public CFaxQueueInner<IFaxOutgoingQueue, &IID_IFaxOutgoingQueue, &CLSID_FaxOutgoingQueue, false,
		IFaxOutgoingJob, CFaxOutgoingJob, IFaxOutgoingJobs, CFaxOutgoingJobs>
{
public:
	CFaxOutgoingQueue() 
	{
        m_bInited = false;
	}

DECLARE_REGISTRY_RESOURCEID(IDR_FAXOUTGOINGQUEUE)
DECLARE_NOT_AGGREGATABLE(CFaxOutgoingQueue)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxOutgoingQueue)
	COM_INTERFACE_ENTRY(IFaxOutgoingQueue)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY(IFaxInitInner)
END_COM_MAP()

//	Interfaces
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

	STDMETHOD(Save)();
	STDMETHOD(Refresh)();
	STDMETHOD(put_Retries)(long lRetries);
	STDMETHOD(get_Retries)(long *plRetries);
	STDMETHOD(put_AgeLimit)(long lAgeLimit);
	STDMETHOD(get_AgeLimit)(long *plAgeLimit);
	STDMETHOD(put_RetryDelay)(long lRetryDelay);
	STDMETHOD(get_RetryDelay)(long *plRetryDelay);
	STDMETHOD(put_Branding)(VARIANT_BOOL bBranding);
	STDMETHOD(get_Branding)(VARIANT_BOOL *pbBranding);
	STDMETHOD(put_DiscountRateEnd)(DATE dateDiscountRateEnd);
	STDMETHOD(put_UseDeviceTSID)(VARIANT_BOOL bUseDeviceTSID);
	STDMETHOD(get_DiscountRateEnd)(DATE *pdateDiscountRateEnd);
	STDMETHOD(get_UseDeviceTSID)(VARIANT_BOOL *pbUseDeviceTSID);
	STDMETHOD(put_DiscountRateStart)(DATE dateDiscountRateStart);
	STDMETHOD(get_DiscountRateStart)(DATE *pdateDiscountRateStart);
	STDMETHOD(put_AllowPersonalCoverPages)(VARIANT_BOOL bAllowPersonalCoverPages);
	STDMETHOD(get_AllowPersonalCoverPages)(VARIANT_BOOL *pbAllowPersonalCoverPages);

//	Internal Use
    STDMETHOD(GetDate)(FAX_TIME faxTime, DATE *pDate);
    STDMETHOD(SetDate)(DATE date, FAX_TIME *pfaxTime);

private:
    bool                        m_bInited;
    CFaxPtr<FAX_OUTBOX_CONFIG>  m_pConfig;
};

#endif //__FAXOUTGOINGQUEUE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxpersonalprofile.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxPersonalProfile.h

Abstract:

	Definition of Personal Profile Class

Author:

	Iv Garber (IvG)	May, 2000

Revision History:

--*/

#ifndef __FAXPERSONALPROFILE_H_
#define __FAXPERSONALPROFILE_H_

#include "resource.h"
#include "FaxCommon.h"

//
//================ HIDDEN INTERFACE OF PERSONAL PROFILE ===========================
//

MIDL_INTERFACE("41E2D834-3F09-4860-A426-1698E9ECDC72")
IFaxPersonalProfileInner : public IUnknown
{
	STDMETHOD(GetProfileData)(/*[out, retval]*/ FAX_PERSONAL_PROFILE *pProfileData) = 0;
	STDMETHOD(PutProfileData)(/*[in]*/ FAX_PERSONAL_PROFILE *pProfileData) = 0;
};

/////////////////////////////////////////////////////////////////////////////
// CFaxPersonalProfile
class ATL_NO_VTABLE CFaxPersonalProfile : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public ISupportErrorInfo,
	public IDispatchImpl<IFaxPersonalProfile, &IID_IFaxPersonalProfile, &LIBID_FAXCOMEXLib>,
	public IFaxPersonalProfileInner
{
public:
	CFaxPersonalProfile()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_FAXPERSONALPROFILE)
DECLARE_NOT_AGGREGATABLE(CFaxPersonalProfile)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxPersonalProfile)
	COM_INTERFACE_ENTRY(IFaxPersonalProfile)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY(IFaxPersonalProfileInner)
END_COM_MAP()

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IFaxPersonalProfile
public:
	static HRESULT Create(IFaxPersonalProfile **ppFaxPersonalProfile);
	STDMETHOD(GetProfileData)(/*[out, retval]*/ FAX_PERSONAL_PROFILE *pProfileData);
	STDMETHOD(PutProfileData)(/*[in]*/ FAX_PERSONAL_PROFILE *pProfileData);

	STDMETHOD(SaveDefaultSender)();
	STDMETHOD(LoadDefaultSender)();
	STDMETHOD(get_BillingCode)(/*[out, retval]*/ BSTR *pbstrBillingCode);
	STDMETHOD(put_BillingCode)(/*[in]*/ BSTR bstrBillingCode);
	STDMETHOD(get_City)(/*[out, retval]*/ BSTR *pbstrCity);
	STDMETHOD(put_City)(/*[in]*/ BSTR bstrCity);
	STDMETHOD(get_Company)(/*[out, retval]*/ BSTR *pbstrCompany);
	STDMETHOD(put_Company)(/*[in]*/ BSTR bstrCompany);
	STDMETHOD(get_Country)(/*[out, retval]*/ BSTR *pbstrCountry);
	STDMETHOD(put_Country)(/*[in]*/ BSTR bstrCountry);
	STDMETHOD(get_Department)(/*[out, retval]*/ BSTR *pbstrDepartment);
	STDMETHOD(put_Department)(/*[in]*/ BSTR bstrDepartment);
	STDMETHOD(get_Email)(/*[out, retval]*/ BSTR *pbstrEmail);
	STDMETHOD(put_Email)(/*[in]*/ BSTR bstrEmail);
	STDMETHOD(get_FaxNumber)(/*[out, retval]*/ BSTR *pbstrFaxNumber);
	STDMETHOD(put_FaxNumber)(/*[in]*/ BSTR bstrFaxNumber);
	STDMETHOD(get_HomePhone)(/*[out, retval]*/ BSTR *pbstrHomePhone);
	STDMETHOD(put_HomePhone)(/*[in]*/ BSTR bstrHomePhone);
	STDMETHOD(get_Name)(/*[out, retval]*/ BSTR *pbstrName);
	STDMETHOD(put_Name)(/*[in]*/ BSTR bstrName);
	STDMETHOD(get_TSID)(/*[out, retval]*/ BSTR *pbstrTSID);
	STDMETHOD(put_TSID)(/*[in]*/ BSTR bstrTSID);
	STDMETHOD(get_OfficePhone)(/*[out, retval]*/ BSTR *pbstrOfficePhone);
	STDMETHOD(put_OfficePhone)(/*[in]*/ BSTR bstrOfficePhone);
	STDMETHOD(get_OfficeLocation)(/*[out, retval]*/ BSTR *pbstrOfficeLocation);
	STDMETHOD(put_OfficeLocation)(/*[in]*/ BSTR bstrOfficeLocation);
	STDMETHOD(get_State)(/*[out, retval]*/ BSTR *pbstrState);
	STDMETHOD(put_State)(/*[in]*/ BSTR bstrState);
	STDMETHOD(get_StreetAddress)(/*[out, retval]*/ BSTR *pbstrStreetAddress);
	STDMETHOD(put_StreetAddress)(/*[in]*/ BSTR bstrStreetAddress);
	STDMETHOD(get_Title)(/*[out, retval]*/ BSTR *pbstrTitle);
	STDMETHOD(put_Title)(/*[in]*/ BSTR bstrTitle);
	STDMETHOD(get_ZipCode)(/*[out, retval]*/ BSTR *pbstrZipCode);
	STDMETHOD(put_ZipCode)(/*[in]*/ BSTR bstrZipCode);

private:
	CComBSTR	m_bstrOfficeLocation;
	CComBSTR	m_bstrStreetAddress;
	CComBSTR	m_bstrOfficePhone;
	CComBSTR	m_bstrBillingCode;
	CComBSTR	m_bstrDepartment;
	CComBSTR	m_bstrFaxNumber;
	CComBSTR	m_bstrHomePhone;
	CComBSTR	m_bstrCompany;
	CComBSTR	m_bstrCountry;
	CComBSTR	m_bstrZipCode;
	CComBSTR	m_bstrEmail;
	CComBSTR	m_bstrState;
	CComBSTR	m_bstrTitle;
	CComBSTR	m_bstrCity;
	CComBSTR	m_bstrName;
	CComBSTR	m_bstrTSID;
};

#endif //__FAXPERSONALPROFILE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxoutgoingmessageiterator.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxOutgoingMessageIterator.h

Abstract:

	Declaration of Fax Outgoing Message Iterator Class.

Author:

	Iv Garber (IvG)	May, 2000

Revision History:

--*/

#ifndef __FAXOUTGOINGMESSAGEITERATOR_H_
#define __FAXOUTGOINGMESSAGEITERATOR_H_

#include "resource.h"       // main symbols
#include "FaxMessageIteratorInner.h"
#include "FaxOutgoingMessage.h"


//
//=============== FAX OUTGOING MESSAGE ITERATOR ===========================================
//
class ATL_NO_VTABLE CFaxOutgoingMessageIterator : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public ISupportErrorInfo,
	public CFaxMessageIteratorInner<IFaxOutgoingMessageIterator,
		&IID_IFaxOutgoingMessageIterator, &CLSID_FaxOutgoingMessageIterator, 
		FAX_MESSAGE_FOLDER_SENTITEMS, 
		IFaxOutgoingMessage, CFaxOutgoingMessage>
{
public:
	CFaxOutgoingMessageIterator()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_FAXOUTGOINGMESSAGEITERATOR)
DECLARE_NOT_AGGREGATABLE(CFaxOutgoingMessageIterator)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxOutgoingMessageIterator)
	COM_INTERFACE_ENTRY(IFaxOutgoingMessageIterator)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY(IFaxInitInner)
END_COM_MAP()

//	Interfaces
STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

//	Internal Use
static HRESULT Create(IFaxOutgoingMessageIterator **pOutgoingMsgIterator);
};

#endif //__FAXOUTGOINGMESSAGEITERATOR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxqueueinner.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxQueueInner.h

Abstract:

	Declaration and Implementation of Fax Queue Inner Template Class.

Author:

	Iv Garber (IvG)	May, 2000

Revision History:

--*/

#ifndef __FAXQUEUEINNER_H_
#define __FAXQUEUEINNER_H_

#include "resource.h"       // main symbols
#include "FaxCommon.h"


//
//================ FAX QUEUE INNER =========================================
//
//	Implementation of Commonality for Fax Incoming and Outgoing Queues
//
template <class T, const IID* piid, const CLSID* pcid, VARIANT_BOOL bIncoming,
         class JobIfc, class JobType, class CollectionIfc, class CollectionType>
class CFaxQueueInner : 
	public IDispatchImpl<T, piid, &LIBID_FAXCOMEXLib>, 
	public CFaxInitInner
{
public:
    CFaxQueueInner() : CFaxInitInner(_T("FAX QUEUE INNER"))
	{
		m_bInited = FALSE;
	}

	virtual ~CFaxQueueInner() 
	{};

//  Interfaces
	STDMETHOD(Save)();
	STDMETHOD(Refresh)();
	STDMETHOD(get_Blocked)(/*[out, retval]*/ VARIANT_BOOL *pbBlocked);
	STDMETHOD(put_Blocked)(/*[in]*/ VARIANT_BOOL bBlocked);
	STDMETHOD(get_Paused)(VARIANT_BOOL *pbPaused);
	STDMETHOD(put_Paused)(VARIANT_BOOL bPaused);
	STDMETHOD(GetJob)(/*[in]*/ BSTR bstrJobId, /*[out, retval]*/ JobIfc **pFaxJob);
	STDMETHOD(GetJobs)(/*[out, retval]*/CollectionIfc ** ppFaxJobsCollection);

private:
	bool			            m_bInited;
	VARIANT_BOOL                m_bBlocked;
	VARIANT_BOOL                m_bPaused;
};

//
//==================== BLOCKED ==========================================
//
template <class T, const IID* piid, const CLSID* pcid, VARIANT_BOOL bIncoming,
         class JobIfc, class JobType, class CollectionIfc, class CollectionType>
STDMETHODIMP 
CFaxQueueInner<T, piid, pcid, bIncoming, JobIfc, JobType, CollectionIfc, CollectionType>
	::get_Blocked(
		VARIANT_BOOL *pbBlocked
)
/*++

Routine name : CFaxQueueInner::get_Blocked

Routine description:

	Return Flag indicating whether or not the Queue is blocked

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	pbBlocked                  [out]    - Ptr to the Place to put Current value of the Flag

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxQueueInner::get_Blocked"), hr);

    // 
    //  sync first
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    hr = GetVariantBool(pbBlocked, m_bBlocked);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxOutgoingQueue,GetErrorMsgId(hr), IID_IFaxOutgoingQueue, hr, _Module.GetResourceInstance());
        return hr;
    }
	return hr;
}

template <class T, const IID* piid, const CLSID* pcid, VARIANT_BOOL bIncoming,
         class JobIfc, class JobType, class CollectionIfc, class CollectionType>
STDMETHODIMP 
CFaxQueueInner<T, piid, pcid, bIncoming, JobIfc, JobType, CollectionIfc, CollectionType>
    ::put_Blocked(
		VARIANT_BOOL bBlocked
)
/*++

Routine name : CFaxQueueInner::put_Blocked

Routine description:

	Set new value for the Blocked flag 

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	bBlocked                   [in]    - the new Value for the Blocked Flag

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxQueueInner::put_Blocked"), hr, _T("%d"), bBlocked);

    // 
    //  sync first
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

	m_bBlocked = bBlocked;
	return hr;
}

//
//==================== REFRESH ==========================================
//
template <class T, const IID* piid, const CLSID* pcid, bool bIncoming,
         class JobIfc, class JobType, class CollectionIfc, class CollectionType>
STDMETHODIMP 
CFaxQueueInner<T, piid, pcid, bIncoming, JobIfc, JobType, CollectionIfc, CollectionType>
	::Refresh(
)
/*++

Routine name : CFaxQueueInner::Refresh

Routine description:

	Bring the Queue Configuration from the Fax Server.

Author:

	Iv Garber (IvG),	May, 2000

Return Value:

    Standard HRESULT code.

--*/
{
	HRESULT		hr = S_OK;

	DBG_ENTER (_T("CFaxQueueInner::Refresh"), hr);

    //
    //  Get Fax Handle 
    //
    HANDLE  hFaxHandle = NULL;
    hr = GetFaxHandle(&hFaxHandle);
    if (FAILED(hr))
    {
		AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr, _Module.GetResourceInstance());
        return hr;
    }

    //
    //  Get Queue Status
    //
    DWORD   dwQueueStates = 0;
    if (!FaxGetQueueStates(hFaxHandle, &dwQueueStates))
    {
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        CALL_FAIL(GENERAL_ERR, _T("FaxGetQueueStates"), hr);
        AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr, _Module.GetResourceInstance());
        return hr;
    }

    //
    //  Extract the values
    //
    DWORD   dwBlockState = (bIncoming) ? FAX_INCOMING_BLOCKED : FAX_OUTBOX_BLOCKED;
    m_bBlocked = (dwQueueStates & dwBlockState) ? VARIANT_TRUE : VARIANT_FALSE;

    if (!bIncoming)
    {
        m_bPaused = (dwQueueStates & FAX_OUTBOX_PAUSED) ? VARIANT_TRUE : VARIANT_FALSE;
    }

    m_bInited = true;
    return hr;
}

//
//==================== SAVE ==========================================
//
template <class T, const IID* piid, const CLSID* pcid, VARIANT_BOOL bIncoming,
         class JobIfc, class JobType, class CollectionIfc, class CollectionType>
STDMETHODIMP 
CFaxQueueInner<T, piid, pcid, bIncoming, JobIfc, JobType, CollectionIfc, CollectionType>
	::Save(
)
/*++

Routine name : CFaxQueueInner::Save

Routine description:

	Save the current Queue Configuration to the Fax Server.

Author:

	Iv Garber (IvG),	May, 2000

Return Value:

    Standard HRESULT code.

--*/
{
	HRESULT		hr = S_OK;

	DBG_ENTER (_T("CFaxQueueInner::Save"), hr);

    //
    //  Nothing changed
    //
    if (!m_bInited)
    {
        return hr;
    }

    //
    //  Get Fax Handle 
    //
    HANDLE  hFaxHandle = NULL;
    hr = GetFaxHandle(&hFaxHandle);
    if (FAILED(hr))
    {
		AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr, _Module.GetResourceInstance());
        return hr;
    }

    //
    //  Get current Queue Status
    //
    DWORD   dwQueueStates;
    if (!FaxGetQueueStates(hFaxHandle, &dwQueueStates))
    {
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        CALL_FAIL(GENERAL_ERR, _T("FaxGetQueueStates"), hr);
        AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr, _Module.GetResourceInstance());
        return hr;
    }

    //
    //  Update it with our current state
    //
    DWORD   dwBlockState = (bIncoming) ? FAX_INCOMING_BLOCKED : FAX_OUTBOX_BLOCKED;
    if (m_bBlocked == VARIANT_TRUE)
    {
        dwQueueStates |= dwBlockState;
    }
    else
    {
        dwQueueStates &= ~dwBlockState;
    }

    if (!bIncoming)
    {
        if (m_bPaused == VARIANT_TRUE)
        {
            dwQueueStates |= FAX_OUTBOX_PAUSED;
        }
        else
        {
            dwQueueStates &= ~FAX_OUTBOX_PAUSED;
        }
    }

    //
    //  Store in the Server
    //
    if (!FaxSetQueue(hFaxHandle, dwQueueStates))
    {
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        CALL_FAIL(GENERAL_ERR, _T("FaxSetQueue"), hr);
        AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr, _Module.GetResourceInstance());
        return hr;
    }

    return hr;
}

//
//==================== PAUSED ==========================================
//
template <class T, const IID* piid, const CLSID* pcid, VARIANT_BOOL bIncoming,
         class JobIfc, class JobType, class CollectionIfc, class CollectionType>
STDMETHODIMP 
CFaxQueueInner<T, piid, pcid, bIncoming, JobIfc, JobType, CollectionIfc, CollectionType>
	::get_Paused(
		VARIANT_BOOL *pbPaused
)
/*++

Routine name : CFaxQueueInner::get_Paused

Routine description:

	Return Flag indicating whether or not the Queue is paused

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	pbPaused                  [out]    - Ptr to the Place to put Current value of the Flag

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;

	DBG_ENTER (TEXT("CFaxQueueInner::get_Paused"), hr);

    // 
    //  sync first
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    hr = GetVariantBool(pbPaused, m_bPaused);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxOutgoingQueue,GetErrorMsgId(hr), IID_IFaxOutgoingQueue, hr, _Module.GetResourceInstance());
        return hr;
    }
	return hr;
}

template <class T, const IID* piid, const CLSID* pcid, VARIANT_BOOL bIncoming,
         class JobIfc, class JobType, class CollectionIfc, class CollectionType>
STDMETHODIMP 
CFaxQueueInner<T, piid, pcid, bIncoming, JobIfc, JobType, CollectionIfc, CollectionType>
    ::put_Paused(
		VARIANT_BOOL bPaused
)
/*++

Routine name : CFaxQueueInner::put_Paused

Routine description:

	Set new value for the Paused flag 

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	bPaused                   [in]    - the new Value for the Paused Flag

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxQueueInner::put_Paused"), hr, _T("%d"), bPaused);

    // 
    //  sync first
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

	m_bPaused = bPaused;
	return hr;
}

//
//==================== GET JOB ==========================================
//
template <class T, const IID* piid, const CLSID* pcid, VARIANT_BOOL bIncoming,
         class JobIfc, class JobType, class CollectionIfc, class CollectionType>
STDMETHODIMP 
CFaxQueueInner<T, piid, pcid, bIncoming, JobIfc, JobType, CollectionIfc, CollectionType>
	::GetJob(
        /*[in]*/ BSTR bstrJobId, 
        /*[out, retval]*/ JobIfc **ppFaxJob
)
/*++

Routine name : CFaxQueueInner::GetJob

Routine description:

	Return Job object corresponding to the given Job Id

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	bstrJobId                  [in]    - Id of the Job
    pFaxJob                    [out]   - resulting Job Object 

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;

	DBG_ENTER (TEXT("CFaxQueueInner::GetJob"), hr, _T("Job ID : %s"), bstrJobId);

	//
	//	Check that we can write to the given pointer
	//
	if (::IsBadWritePtr(ppFaxJob, sizeof(JobIfc *)))
	{
		//
		//	Got Bad Return Pointer
		//
		hr = E_POINTER;
		AtlReportError(*pcid, IDS_ERROR_INVALID_ARGUMENT, *piid, hr, _Module.GetResourceInstance());
		CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr()"), hr);
		return hr;
	}

    // 
    //  no need to sync first
    //

    //
    //  Get Fax Server Handle
    //
    HANDLE  hFaxHandle = NULL;
    hr = GetFaxHandle(&hFaxHandle);
    if (FAILED(hr))
    {
        AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr, _Module.GetResourceInstance());
        return hr;
    }

	//
	//	convert Job Id that we've got to hexadecimal DWORDLONG
	//
	DWORDLONG	dwlJobId;
	int iParsed = _stscanf (bstrJobId, _T("%I64x"), &dwlJobId);	
	if ( iParsed != 1)
	{
		//
		//	Failed to conver the number
		//
		hr = E_INVALIDARG;
		CALL_FAIL(GENERAL_ERR, _T("_stscanf()"), hr);
		AtlReportError(*pcid, IDS_ERROR_INVALIDMSGID, *piid, hr, _Module.GetResourceInstance());
		return hr;
	}

    //
    //  Get the Job Info from the Server
    //
    CFaxPtr<FAX_JOB_ENTRY_EX>   pJobInfo;
    if (!FaxGetJobEx(hFaxHandle, dwlJobId, &pJobInfo))
    {
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr, _Module.GetResourceInstance());
        CALL_FAIL(GENERAL_ERR, _T("FaxGetJobEx(hFaxHandle, m_JobInfo->dwlMessageId, &m_JobInfo)"), hr);
        return hr;
    }

    //
    //  Check that pJobInfo is valid
    //
	if (!pJobInfo || pJobInfo->dwSizeOfStruct != sizeof(FAX_JOB_ENTRY_EX))
	{
		//
		//	Failed to Get Job
		//
		hr = E_FAIL;
		AtlReportError(*pcid, IDS_ERROR_OPERATION_FAILED, *piid, hr, _Module.GetResourceInstance());
		CALL_FAIL(GENERAL_ERR, _T("Invalid pJobInfo"), hr);
		return hr;
	}

    //
    //  Check that Type of the Job is compatible with the Type of the Queue
    //
    if (bIncoming)
    {
        if ( !((pJobInfo->pStatus->dwJobType) & JT_RECEIVE) && 
             !((pJobInfo->pStatus->dwJobType) & JT_ROUTING) )
        {
            //
            //  the desired Job is not Incoming
            //
		    hr = Fax_HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
		    AtlReportError(*pcid, IDS_ERROR_INVALIDMSGID, *piid, hr, _Module.GetResourceInstance());
		    CALL_FAIL(GENERAL_ERR, _T("The desired Job is NOT Incoming"), hr);
		    return hr;
        }
    }
    else
    {
        if ( !((pJobInfo->pStatus->dwJobType) & JT_SEND) )
        {
            //
            //  the desired Job is not Outgoing
            //
		    hr = Fax_HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
		    AtlReportError(*pcid, IDS_ERROR_INVALIDMSGID, *piid, hr, _Module.GetResourceInstance());
		    CALL_FAIL(GENERAL_ERR, _T("The desired Job is NOT Outgoing"), hr);
		    return hr;
        }
    }
    
	//
	//	Create Job Object
	//
	CComPtr<JobIfc>		pTmpJob;
	hr = JobType::Create(&pTmpJob);
	if (FAILED(hr))
	{
		//
		//	Failed to create the Job object
		//
		AtlReportError(*pcid, IDS_ERROR_OPERATION_FAILED, *piid, hr, _Module.GetResourceInstance());
		CALL_FAIL(GENERAL_ERR, _T("JobType::Create()"), hr);
		return hr;
	}

	//
	//	Initialize the Job Object
    //
    //  Job will free the Job Info struct
    //
	hr = ((JobType *)((JobIfc *)pTmpJob))->Init(pJobInfo, m_pIFaxServerInner);
	if (FAILED(hr))
	{
		//
		// Failed to Init the Job Object
		//
		AtlReportError(*pcid, IDS_ERROR_OPERATION_FAILED, *piid, hr, _Module.GetResourceInstance());
		CALL_FAIL(GENERAL_ERR, _T("<casted>pTmpJob->Init(pJobInfo, m_pIFaxServerInner)"), hr);
		return hr;
	}

	//
	//	Return Job Object to the Caller
	//
	hr = pTmpJob.CopyTo(ppFaxJob);
	if (FAILED(hr))
	{
		//
		//	Failed to Copy Interface
		//
		AtlReportError(*pcid, IDS_ERROR_OPERATION_FAILED, *piid, hr, _Module.GetResourceInstance());
		CALL_FAIL(GENERAL_ERR, _T("CComPtr::CopyTo"), hr);
		return hr;
	}

    //
    //  ppFaxJob uses this Job Info. Do not free the memory yet
    //
    pJobInfo.Detach();
	return hr;
}

//
//==================== GET JOBS ==========================================
//
template <class T, const IID* piid, const CLSID* pcid, VARIANT_BOOL bIncoming,
         class JobIfc, class JobType, class CollectionIfc, class CollectionType>
STDMETHODIMP 
CFaxQueueInner<T, piid, pcid, bIncoming, JobIfc, JobType, CollectionIfc, CollectionType>
	::GetJobs(
        /*[out, retval]*/CollectionIfc ** ppJobsCollection)
/*++

Routine name : CFaxQueueInner::GetJobs

Routine description:

	Return Jobs Collection

Author:

	Iv Garber (IvG),	May, 2000

Arguments:
    
      ppFaxJobsCollection           [out, retval]   -   the Jobs Collection

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;

	DBG_ENTER (TEXT("CFaxQueueInner::GetJobs"), hr);

	//
	//	Check that we can write to the given pointer
	//
    if (::IsBadWritePtr(ppJobsCollection, sizeof(CollectionIfc *)))
    {
		//
		//	Got Bad Return Pointer
		//
		hr = E_POINTER;
		AtlReportError(*pcid, IDS_ERROR_INVALID_ARGUMENT, *piid, hr, _Module.GetResourceInstance());
		CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr()"), hr);
		return hr;
	}

    //
    //  Get Fax Server Handle
    //
    HANDLE  hFaxHandle = NULL;
    hr = GetFaxHandle(&hFaxHandle);
    if (FAILED(hr))
    {
        AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr, _Module.GetResourceInstance());
        return hr;
    }

    //
    //  Bring the Jobs from the Server
    //
    DWORD   dwJobTypes;
    dwJobTypes = (bIncoming) ? (JT_RECEIVE | JT_ROUTING) : (JT_SEND);

    DWORD   dwJobCount;
    CFaxPtr<FAX_JOB_ENTRY_EX>   pJobCollection;
    if (!FaxEnumJobsEx(hFaxHandle, dwJobTypes, &pJobCollection, &dwJobCount))
    {
		//
		// Failed to Get the Job Collection
		//
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
		AtlReportError(*pcid, GetErrorMsgId(hr), *piid, hr, _Module.GetResourceInstance());
		CALL_FAIL(GENERAL_ERR, _T("FaxEnumJobEx(hFaxHandle, dwJobTypes, &m_pJobCollection,...)"), hr);
		return hr;
    }

    //
    //  Create Jobs Collection
    //
	CComPtr<CollectionIfc>		pTmpJobCollection;
	hr = CollectionType::Create(&pTmpJobCollection);
	if (FAILED(hr))
	{
		//
		//	Failed to create the Job Collection
		//
		AtlReportError(*pcid, IDS_ERROR_OPERATION_FAILED, *piid, hr, _Module.GetResourceInstance());
		CALL_FAIL(GENERAL_ERR, _T("CollectionType::Create()"), hr);
		return hr;
	}

	//
	//	Initialize the Job Collection
    //      Job Collection will COPY all the data from pJobCollection
	//
	hr = ((CollectionType *)((CollectionIfc *)pTmpJobCollection))->Init(pJobCollection, 
        dwJobCount, 
        m_pIFaxServerInner);
	if (FAILED(hr))
	{
		//
		// Failed to Init the Job Collection
		//
		AtlReportError(*pcid, IDS_ERROR_OPERATION_FAILED, *piid, hr, _Module.GetResourceInstance());
		CALL_FAIL(GENERAL_ERR, _T("pTmpJobCollection->Init(m_pJobCollection, m_pIFaxServerInner)"), hr);
		return hr;
	}

	//
	//	Return Job Object to the Caller
	//
	hr = pTmpJobCollection.CopyTo(ppJobsCollection);
	if (FAILED(hr))
	{
		//
		//	Failed to Copy Interface
		//
		AtlReportError(*pcid, IDS_ERROR_OPERATION_FAILED, *piid, hr, _Module.GetResourceInstance());
		CALL_FAIL(GENERAL_ERR, _T("CComPtr::CopyTo"), hr);
		return hr;
	}

	return hr;
}


#endif //__FAXQUEUEINNER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxpersonalprofile.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxPersonalProfile.cpp

Abstract:

	Implementation of Fax Personal Profile 

Author:

	Iv Garber (IvG)	Apr, 2000

Revision History:

--*/

#include "stdafx.h"
#include "FaxComEx.h"
#include "FaxPersonalProfile.h"
#include "..\..\inc\FaxUIConstants.h"

//
//===================== GET PROFILE DATA =====================================
//
STDMETHODIMP
CFaxPersonalProfile::GetProfileData(
	FAX_PERSONAL_PROFILE *pProfileData
)
/*++

Routine name : CFaxPersonalProfile::GetProfileData

Routine description:

	Fills the pProfileData with the data of the object.

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	pProfileData                  [out]    - the FAX_PERSONAL_PROFILE struct to fill

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxPersonalProfile::GetProfileData"), hr);

	if (::IsBadWritePtr(pProfileData, sizeof(FAX_PERSONAL_PROFILE)))
	{
		//
		//	Bad Return OR Interface Pointer
		//
		hr = E_POINTER;
		CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr()"), hr);
		return hr;
	}

	pProfileData->dwSizeOfStruct	= sizeof(FAX_PERSONAL_PROFILE);
	pProfileData->lptstrCity		= m_bstrCity;
	pProfileData->lptstrCompany		= m_bstrCompany;
	pProfileData->lptstrCountry		= m_bstrCountry;
	pProfileData->lptstrEmail		= m_bstrEmail;
	pProfileData->lptstrName		= m_bstrName;
	pProfileData->lptstrState		= m_bstrState;
	pProfileData->lptstrTitle		= m_bstrTitle;
	pProfileData->lptstrTSID		= m_bstrTSID;
	pProfileData->lptstrZip			= m_bstrZipCode;
	pProfileData->lptstrFaxNumber	= m_bstrFaxNumber;
	pProfileData->lptstrHomePhone	= m_bstrHomePhone;
	pProfileData->lptstrDepartment	= m_bstrDepartment;
	pProfileData->lptstrBillingCode = m_bstrBillingCode;
	pProfileData->lptstrOfficePhone	= m_bstrOfficePhone;
	pProfileData->lptstrOfficeLocation	= m_bstrOfficeLocation;
	pProfileData->lptstrStreetAddress	= m_bstrStreetAddress;

	return hr;
}

//
//============== PUT PROFILE DATA ============================================
//
STDMETHODIMP
CFaxPersonalProfile::PutProfileData(
	FAX_PERSONAL_PROFILE *pProfileData
)
/*++

Routine name : CFaxPersonalProfile::PutProfileData

Routine description:

	Receives FAX_PERSONAL_PROFILE structure and fills the Object's fields.

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	pProfileData                  [in]    - the data to put into the object's variables

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxPersonalProfile::PutProfileData"), hr);

	m_bstrCity		=	pProfileData->lptstrCity;
	m_bstrCompany	=	pProfileData->lptstrCompany;
	m_bstrCountry	=	pProfileData->lptstrCountry;
	m_bstrEmail		=	pProfileData->lptstrEmail;
	m_bstrHomePhone	=	pProfileData->lptstrHomePhone;
	m_bstrFaxNumber	=	pProfileData->lptstrFaxNumber;
	m_bstrName		=	pProfileData->lptstrName;
	m_bstrState		=	pProfileData->lptstrState;
	m_bstrZipCode	=	pProfileData->lptstrZip;
	m_bstrTitle		=	pProfileData->lptstrTitle;
	m_bstrTSID		=	pProfileData->lptstrTSID;
	m_bstrBillingCode	=	pProfileData->lptstrBillingCode;
	m_bstrDepartment	=	pProfileData->lptstrDepartment;
	m_bstrStreetAddress	=	pProfileData->lptstrStreetAddress;
	m_bstrOfficePhone	=	pProfileData->lptstrOfficePhone;
	m_bstrOfficeLocation	=	pProfileData->lptstrOfficeLocation;

	if ((pProfileData->lptstrCity && !m_bstrCity) ||
		(pProfileData->lptstrCompany && !m_bstrCompany) ||
		(pProfileData->lptstrCountry && !m_bstrCountry) ||
		(pProfileData->lptstrEmail && !m_bstrEmail) ||
		(pProfileData->lptstrHomePhone && !m_bstrHomePhone) ||
		(pProfileData->lptstrFaxNumber && !m_bstrFaxNumber) ||
		(pProfileData->lptstrName && !m_bstrName) ||
		(pProfileData->lptstrState && !m_bstrState) ||
		(pProfileData->lptstrZip && !m_bstrZipCode) ||
		(pProfileData->lptstrTSID && !m_bstrTSID) ||
		(pProfileData->lptstrBillingCode && !m_bstrBillingCode) ||
		(pProfileData->lptstrDepartment && !m_bstrDepartment) ||
		(pProfileData->lptstrStreetAddress && !m_bstrStreetAddress) ||
		(pProfileData->lptstrOfficePhone && !m_bstrOfficePhone) ||
		(pProfileData->lptstrOfficeLocation && !m_bstrOfficeLocation))
	{
		//
		//	Not enough memory
		//
		hr = E_OUTOFMEMORY;
		CALL_FAIL(MEM_ERR, _T("CComBSTR::operator=()"), hr);
	}

	return hr;
}
	
//
//==================== DEFAULT SENDER ===================================
//
STDMETHODIMP 
CFaxPersonalProfile::LoadDefaultSender ( 
)
/*++

Routine name : CFaxPersonalProfile::LoadDefaultSender

Routine description:

	Load Default Sender Information from the local Registry

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	NONE

Return Value:

    Standard HRESULT code

--*/
{
	FAX_PERSONAL_PROFILE	DefaultSenderProfile;
	HRESULT					hr;

	DBG_ENTER (TEXT("CFaxPersonalProfile::LoadDefaultSender"), hr);

	DefaultSenderProfile.dwSizeOfStruct = sizeof(FAX_PERSONAL_PROFILE);

	hr = FaxGetSenderInformation(&DefaultSenderProfile);
	if (FAILED(hr))
	{
		//
		//	Failed to get Sender Information
		//
		AtlReportError(CLSID_FaxPersonalProfile, 
			GetErrorMsgId(hr), 
			IID_IFaxPersonalProfile, 
			hr, 
			_Module.GetResourceInstance());
		CALL_FAIL(GENERAL_ERR, _T("FaxGetSenderInformation()"), hr);
		return hr;
	}

	hr = PutProfileData(&DefaultSenderProfile);
	if (FAILED(hr))
	{
		//
		//	Not Enough Memory
		//
		AtlReportError(CLSID_FaxPersonalProfile, 
			IDS_ERROR_OUTOFMEMORY, 
			IID_IFaxPersonalProfile, 
			hr, 
			_Module.GetResourceInstance());
		//
		// no return, we still need to free information
		//
	}

	HRESULT hr1 = FaxFreeSenderInformation(&DefaultSenderProfile);
	if (FAILED(hr1))
	{
		hr = hr1;
		CALL_FAIL(GENERAL_ERR, _T("FaxFreeSenderInformation()"), hr);
		return hr;
	}

	return hr;
}

//
//	SaveAs
//
STDMETHODIMP 
CFaxPersonalProfile::SaveDefaultSender (
)
/*++

Routine name : CFaxPersonalProfile::SaveDefaultSender

Routine description:

	Save current Profile as the Default in the Local Registry

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	NONE

Return Value:

    Standard HRESULT code

--*/

{
	FAX_PERSONAL_PROFILE	DefaultSenderProfile;
	HRESULT					hr;

	DBG_ENTER (TEXT("CFaxPersonalProfile::SaveDefaultSender"), hr);
	
	hr = GetProfileData(&DefaultSenderProfile);
	ATLASSERT(SUCCEEDED(hr));

	hr = FaxSetSenderInformation(&DefaultSenderProfile);
	if (FAILED(hr))
	{
		AtlReportError(CLSID_FaxPersonalProfile, 
			GetErrorMsgId(hr), 
			IID_IFaxPersonalProfile, 
			hr, 
			_Module.GetResourceInstance());
		CALL_FAIL(GENERAL_ERR, _T("FaxSetSenderInformation()"), hr);
		return hr;
	}

	return hr;
}

//
//==================== INTERFACE SUPPORT ERROR INFO =====================
//
STDMETHODIMP 
CFaxPersonalProfile::InterfaceSupportsErrorInfo (
	REFIID riid
)
/*++

Routine name : CFaxPersonalProfile::InterfaceSupportsErrorInfo

Routine description:

	ATL's implementation of Support Error Info

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	riid                          [in]    - Interface ID

Return Value:

    Standard HRESULT code

--*/
{
	static const IID* arr[] = 
	{
		&IID_IFaxPersonalProfile
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

//
//==================== CREATE ========================================
//
HRESULT 
CFaxPersonalProfile::Create (
	IFaxPersonalProfile **ppPersonalProfile
)
/*++

Routine name : CFaxPersonalProfile::Create

Routine description:

	Static function to create the Fax Personal Profile Instance

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	ppPersonalProfile             [out]  -- the new Fax Personal Profile Instance

Return Value:

    Standard HRESULT code

--*/

{
	CComObject<CFaxPersonalProfile>		*pClass;
	HRESULT								hr = S_OK;

	DBG_ENTER (TEXT("CFaxPersonalProfile::Create"), hr);

	hr = CComObject<CFaxPersonalProfile>::CreateInstance(&pClass);
	if (FAILED(hr))
	{
		//
		//	Failed to create Instance
		//
		CALL_FAIL(GENERAL_ERR, _T("CComObject<CFaxPersonalProfile>::CreateInstance()"), hr);
		return hr;
	}

	hr = pClass->QueryInterface(__uuidof(IFaxPersonalProfile), (void **) ppPersonalProfile);
	if (FAILED(hr))
	{
		//
		//	Failed to Query Personal Profile Interface
		//
		CALL_FAIL(GENERAL_ERR, _T("QueryInterface()"), hr);
		return hr;
	}

	return hr;
}

//
//==================== BILLING CODE ========================================
//
STDMETHODIMP 
CFaxPersonalProfile::get_BillingCode(
	BSTR *pbstrBillingCode
)
/*++

Routine name : CFaxPersonalProfile::get_BillingCode

Routine description:

	return Billing Code

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pbstrBillingCode              [out]    - the Billing Code

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT hr = S_OK;
	DBG_ENTER (TEXT("CFaxPersonalProfile::get_BillingCode"), hr);

    hr = GetBstr(pbstrBillingCode, m_bstrBillingCode);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxPersonalProfile, GetErrorMsgId(hr), IID_IFaxPersonalProfile, hr, _Module.GetResourceInstance());
        return hr;
    }
	return hr;
}

STDMETHODIMP 
CFaxPersonalProfile::put_BillingCode (
	BSTR bstrBillingCode
)
/*++

Routine name : CFaxPersonalProfile::put_BillingCode

Routine description:

	Set Billing Code

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	bstrBillingCode               [in]    - new Billing Code value

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;

	DBG_ENTER (_T("CFaxPersonalProfile::put_BillingCode"), 
		hr, 
		_T("%s"), 
		bstrBillingCode);

	m_bstrBillingCode = bstrBillingCode;
	if (bstrBillingCode && !m_bstrBillingCode)
	{
		//
		//	Not enough memory
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxPersonalProfile, 
			IDS_ERROR_OUTOFMEMORY, 
			IID_IFaxPersonalProfile, 
			hr, 
			_Module.GetResourceInstance());
		CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
		return hr;
	}

	return hr;
}

//
//==================== CITY ========================================
//
STDMETHODIMP 
CFaxPersonalProfile::get_City(
	BSTR *pbstrCity
)
/*++

Routine name : CFaxPersonalProfile::get_City

Routine description:

	return City

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pbstrCity              [out]    - the City

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT hr = S_OK;
	DBG_ENTER (TEXT("CFaxPersonalProfile::get_City"), hr);

    hr = GetBstr(pbstrCity, m_bstrCity);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxPersonalProfile, GetErrorMsgId(hr), IID_IFaxPersonalProfile, hr, _Module.GetResourceInstance());
        return hr;
    }
	return hr;
}

STDMETHODIMP 
CFaxPersonalProfile::put_City (
	BSTR bstrCity
)
/*++

Routine name : CFaxPersonalProfile::put_City

Routine description:

	Set City

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	bstrCity               [in]    - new City value

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxPersonalProfile::put_City"), hr, _T("%s"), bstrCity);

	m_bstrCity = bstrCity;
	if (!m_bstrCity && bstrCity)
	{
		//
		//	Not enough memory
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxPersonalProfile, 
			IDS_ERROR_OUTOFMEMORY, 
			IID_IFaxPersonalProfile, 
			hr, 
			_Module.GetResourceInstance());
		CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
		return hr;
	}

	return hr;
}

//
//==================== COMPANY ========================================
//
STDMETHODIMP 
CFaxPersonalProfile::get_Company(
	BSTR *pbstrCompany
)
/*++

Routine name : CFaxPersonalProfile::get_Company

Routine description:

	return Company

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pbstrCompany              [out]    - the Company

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT hr = S_OK;
	DBG_ENTER (TEXT("CFaxPersonalProfile::get_Company"), hr);

    hr = GetBstr(pbstrCompany, m_bstrCompany);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxPersonalProfile, GetErrorMsgId(hr), IID_IFaxPersonalProfile, hr, _Module.GetResourceInstance());
        return hr;
    }
	return hr;
}

STDMETHODIMP 
CFaxPersonalProfile::put_Company (
	BSTR bstrCompany
)
/*++

Routine name : CFaxPersonalProfile::put_Company

Routine description:

	Set Company

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	bstrCompany               [in]    - new Company value

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxPersonalProfile::put_Company"), hr, _T("%s"), bstrCompany);

	m_bstrCompany = bstrCompany;
	if (!m_bstrCompany && bstrCompany)
	{
		//
		//	Not enough memory
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxPersonalProfile, IDS_ERROR_OUTOFMEMORY, IID_IFaxPersonalProfile, hr, _Module.GetResourceInstance());
		CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
		return hr;
	}

	return hr;
}

//
//==================== COUNTRY ========================================
//
STDMETHODIMP 
CFaxPersonalProfile::get_Country(
	BSTR *pbstrCountry
)
/*++

Routine name : CFaxPersonalProfile::get_Country

Routine description:

	return Country

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pbstrCountry	            [out]    - the Country

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT hr = S_OK;
	DBG_ENTER (TEXT("CFaxPersonalProfile::get_Country"), hr);

    hr = GetBstr(pbstrCountry, m_bstrCountry);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxPersonalProfile, GetErrorMsgId(hr), IID_IFaxPersonalProfile, hr, _Module.GetResourceInstance());
        return hr;
    }
	return hr;
}

STDMETHODIMP 
CFaxPersonalProfile::put_Country (
	BSTR bstrCountry
)
/*++

Routine name : CFaxPersonalProfile::put_Country

Routine description:

	Set Country

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	bstrCountry               [in]    - new Country value

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxPersonalProfile::put_Country"), hr, _T("%s"), bstrCountry);

	m_bstrCountry = bstrCountry;
	if (!m_bstrCountry && bstrCountry)
	{
		//
		//	Not enough memory
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxPersonalProfile, 
			IDS_ERROR_OUTOFMEMORY, 
			IID_IFaxPersonalProfile, 
			hr, 
			_Module.GetResourceInstance());
		CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
		return hr;
	}

	return hr;
}

//
//==================== DEPARTMENT ========================================
//
STDMETHODIMP 
CFaxPersonalProfile::get_Department(
	BSTR *pbstrDepartment
)
/*++

Routine name : CFaxPersonalProfile::get_Department

Routine description:

	return Department

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pbstrDepartment	            [out]    - the Department

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT hr = S_OK;
	DBG_ENTER (TEXT("CFaxPersonalProfile::get_Department"), hr);

    hr = GetBstr(pbstrDepartment, m_bstrDepartment);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxPersonalProfile, GetErrorMsgId(hr), IID_IFaxPersonalProfile, hr, _Module.GetResourceInstance());
        return hr;
    }
	return hr;
}

STDMETHODIMP 
CFaxPersonalProfile::put_Department (
	BSTR bstrDepartment
)
/*++

Routine name : CFaxPersonalProfile::put_Department

Routine description:

	Set Department

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	bstrDepartment               [in]    - new Department value

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxPersonalProfile::put_Department"), hr, _T("%s"), bstrDepartment);

	m_bstrDepartment = bstrDepartment;
	if (!m_bstrDepartment && bstrDepartment)
	{
		//
		//	Not enough memory
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxPersonalProfile, 
			IDS_ERROR_OUTOFMEMORY, 
			IID_IFaxPersonalProfile, 
			hr, 
			_Module.GetResourceInstance());
		CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
		return hr;
	}

	return hr;
}

//
//==================== EMAIL ========================================
//
STDMETHODIMP 
CFaxPersonalProfile::get_Email(
	BSTR *pbstrEmail
)
/*++

Routine name : CFaxPersonalProfile::get_Email

Routine description:

	return Email

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pbstrEmail	            [out]    - the Email

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT hr = S_OK;
	DBG_ENTER (TEXT("CFaxPersonalProfile::get_Email"), hr);

    hr = GetBstr(pbstrEmail, m_bstrEmail);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxPersonalProfile, GetErrorMsgId(hr), IID_IFaxPersonalProfile, hr, _Module.GetResourceInstance());
        return hr;
    }
	return hr;
}

STDMETHODIMP 
CFaxPersonalProfile::put_Email (
	BSTR bstrEmail
)
/*++

Routine name : CFaxPersonalProfile::put_Email

Routine description:

	Set Email

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	bstrEmail               [in]    - new Email value

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxPersonalProfile::put_Email"), hr, _T("%s"), bstrEmail);

	m_bstrEmail = bstrEmail;
	if (!m_bstrEmail && bstrEmail)
	{
		//
		//	Not enough memory
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxPersonalProfile, 
			IDS_ERROR_OUTOFMEMORY, 
			IID_IFaxPersonalProfile, 
			hr, 
			_Module.GetResourceInstance());
		CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
		return hr;
	}

	return hr;
}

//
//==================== FAX NUMBER ========================================
//
STDMETHODIMP 
CFaxPersonalProfile::get_FaxNumber(
	BSTR *pbstrFaxNumber
)
/*++

Routine name : CFaxPersonalProfile::get_FaxNumber

Routine description:

	return FaxNumber

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pbstrFaxNumber	            [out]    - the FaxNumber

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT hr = S_OK;
	DBG_ENTER (TEXT("CFaxPersonalProfile::get_FaxNumber"), hr);

    hr = GetBstr(pbstrFaxNumber, m_bstrFaxNumber);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxPersonalProfile, GetErrorMsgId(hr), IID_IFaxPersonalProfile, hr, _Module.GetResourceInstance());
        return hr;
    }
	return hr;
}

STDMETHODIMP 
CFaxPersonalProfile::put_FaxNumber (
	BSTR bstrFaxNumber
)
/*++

Routine name : CFaxPersonalProfile::put_FaxNumber

Routine description:

	Set FaxNumber

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	bstrFaxNumber               [in]    - new Fax Number 

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxPersonalProfile::put_FaxNumber"), hr, _T("%s"), bstrFaxNumber);

	m_bstrFaxNumber = bstrFaxNumber;
	if (!m_bstrFaxNumber && bstrFaxNumber)
	{
		//
		//	Not enough memory
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxPersonalProfile, 
			IDS_ERROR_OUTOFMEMORY, 
			IID_IFaxPersonalProfile, 
			hr, 
			_Module.GetResourceInstance());
		CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
		return hr;
	}

	return hr;
}

//
//==================== HOME PHONE ========================================
//
STDMETHODIMP 
CFaxPersonalProfile::get_HomePhone(
	BSTR *pbstrHomePhone
)
/*++

Routine name : CFaxPersonalProfile::get_HomePhone

Routine description:

	return HomePhone

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pbstrHomePhone	            [out]    - the HomePhone

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT hr = S_OK;
	DBG_ENTER (TEXT("CFaxPersonalProfile::get_HomePhone"), hr);

    hr = GetBstr(pbstrHomePhone, m_bstrHomePhone);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxPersonalProfile, GetErrorMsgId(hr), IID_IFaxPersonalProfile, hr, _Module.GetResourceInstance());
        return hr;
    }
	return hr;
}

STDMETHODIMP 
CFaxPersonalProfile::put_HomePhone (
	BSTR bstrHomePhone
)
/*++

Routine name : CFaxPersonalProfile::put_HomePhone

Routine description:

	Set HomePhone

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	bstrHomePhone               [in]    - new HomePhone

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxPersonalProfile::put_HomePhone"), hr, _T("%s"), bstrHomePhone);

	m_bstrHomePhone = bstrHomePhone;
	if (!m_bstrHomePhone && bstrHomePhone)
	{
		//
		//	Not enough memory
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxPersonalProfile, 
			IDS_ERROR_OUTOFMEMORY, 
			IID_IFaxPersonalProfile, 
			hr, 
			_Module.GetResourceInstance());
		CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
		return hr;
	}

	return hr;
}

//
//==================== NAME ========================================
//
STDMETHODIMP 
CFaxPersonalProfile::get_Name(
	BSTR *pbstrName
)
/*++

Routine name : CFaxPersonalProfile::get_Name

Routine description:

	return Name

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pbstrName	            [out]    - the Name

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT hr = S_OK;
	DBG_ENTER (TEXT("CFaxPersonalProfile::get_Name"), hr);

    hr = GetBstr(pbstrName, m_bstrName);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxPersonalProfile, GetErrorMsgId(hr), IID_IFaxPersonalProfile, hr, _Module.GetResourceInstance());
        return hr;
    }
	return hr;
}

STDMETHODIMP 
CFaxPersonalProfile::put_Name (
	BSTR bstrName
)
/*++

Routine name : CFaxPersonalProfile::put_Name

Routine description:

	Set Name

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	bstrName               [in]    - new Name

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxPersonalProfile::put_Name"), hr, _T("%s"), bstrName);

	m_bstrName = bstrName;
	if (!m_bstrName && bstrName)
	{
		//
		//	Not enough memory
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxPersonalProfile, 
			IDS_ERROR_OUTOFMEMORY, 
			IID_IFaxPersonalProfile, 
			hr, 
			_Module.GetResourceInstance());
		CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
		return hr;
	}

	return hr;
}

//
//==================== TSID ========================================
//
STDMETHODIMP 
CFaxPersonalProfile::get_TSID(
	BSTR *pbstrTSID
)
/*++

Routine name : CFaxPersonalProfile::get_TSID

Routine description:

	return TSID

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pbstrTSID	            [out]    - the TSID

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT hr = S_OK;
	DBG_ENTER (TEXT("CFaxPersonalProfile::get_TSID"), hr);

    hr = GetBstr(pbstrTSID, m_bstrTSID);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxPersonalProfile, GetErrorMsgId(hr), IID_IFaxPersonalProfile, hr, _Module.GetResourceInstance());
        return hr;
    }
	return hr;
}

STDMETHODIMP 
CFaxPersonalProfile::put_TSID (
	BSTR bstrTSID
)
/*++

Routine name : CFaxPersonalProfile::put_TSID

Routine description:

	Set TSID

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	bstrTSID               [in]    - new TSID

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxPersonalProfile::put_TSID"), hr, _T("%s"), bstrTSID);

    if (SysStringLen(bstrTSID) > FXS_TSID_CSID_MAX_LENGTH)
    {
		//
		//	Out of the Range
		//
		hr = E_INVALIDARG;
		AtlReportError(CLSID_FaxPersonalProfile, IDS_ERROR_OUTOFRANGE, IID_IFaxPersonalProfile, hr, _Module.GetResourceInstance());
		CALL_FAIL(GENERAL_ERR, _T("TSID is too long"), hr);
		return hr;
    }
    
    m_bstrTSID = bstrTSID;
	if (!m_bstrTSID && bstrTSID)
	{
		//
		//	Not enough memory
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxPersonalProfile, 
			IDS_ERROR_OUTOFMEMORY, 
			IID_IFaxPersonalProfile, 
			hr, 
			_Module.GetResourceInstance());
		CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
		return hr;
	}

	return hr;
}

//
//==================== OFFICE PHONE ========================================
//
STDMETHODIMP 
CFaxPersonalProfile::get_OfficePhone(
	BSTR *pbstrOfficePhone
)
/*++

Routine name : CFaxPersonalProfile::get_OfficePhone

Routine description:

	return OfficePhone

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pbstrOfficePhone	            [out]    - the OfficePhone

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT hr = S_OK;
	DBG_ENTER (TEXT("CFaxPersonalProfile::get_OfficePhone"), hr);
		
    hr = GetBstr(pbstrOfficePhone, m_bstrOfficePhone);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxPersonalProfile, GetErrorMsgId(hr), IID_IFaxPersonalProfile, hr, _Module.GetResourceInstance());
        return hr;
    }
	return hr;
}

STDMETHODIMP 
CFaxPersonalProfile::put_OfficePhone (
	BSTR bstrOfficePhone
)
/*++

Routine name : CFaxPersonalProfile::put_OfficePhone

Routine description:

	Set OfficePhone

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	bstrOfficePhone               [in]    - new OfficePhone

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxPersonalProfile::put_OfficePhone"), hr, _T("%s"), bstrOfficePhone);

	m_bstrOfficePhone = bstrOfficePhone;
	if (!m_bstrOfficePhone && bstrOfficePhone)
	{
		//
		//	Not enough memory
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxPersonalProfile, 
			IDS_ERROR_OUTOFMEMORY, 
			IID_IFaxPersonalProfile, 
			hr, _Module.GetResourceInstance());
		CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
		return hr;
	}

	return hr;
}

//
//==================== OFFICE LOCATION ========================================
//
STDMETHODIMP 
CFaxPersonalProfile::get_OfficeLocation(
	BSTR *pbstrOfficeLocation
)
/*++

Routine name : CFaxPersonalProfile::get_OfficeLocation

Routine description:

	return OfficeLocation

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pbstrOfficeLocation	            [out]    - the OfficeLocation

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT hr = S_OK;
	DBG_ENTER (TEXT("CFaxPersonalProfile::get_OfficeLocation"), hr);

    hr = GetBstr(pbstrOfficeLocation, m_bstrOfficeLocation);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxPersonalProfile, GetErrorMsgId(hr), IID_IFaxPersonalProfile, hr, _Module.GetResourceInstance());
        return hr;
    }
	return hr;
}

STDMETHODIMP 
CFaxPersonalProfile::put_OfficeLocation (
	BSTR bstrOfficeLocation
)
/*++

Routine name : CFaxPersonalProfile::put_OfficeLocation

Routine description:

	Set OfficeLocation

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	bstrOfficeLocation               [in]    - new OfficeLocation

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxPersonalProfile::put_OfficeLocation"), hr, _T("%s"), bstrOfficeLocation);

	m_bstrOfficeLocation = bstrOfficeLocation;
	if (!m_bstrOfficeLocation && bstrOfficeLocation)
	{
		//
		//	Not enough memory
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxPersonalProfile, 
			IDS_ERROR_OUTOFMEMORY, 
			IID_IFaxPersonalProfile, 
			hr, 
			_Module.GetResourceInstance());
		CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
		return hr;
	}

	return hr;
}

//
//==================== STATE ========================================
//
STDMETHODIMP 
CFaxPersonalProfile::get_State(
	BSTR *pbstrState
)
/*++

Routine name : CFaxPersonalProfile::get_State

Routine description:

	return State

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pbstrState	            [out]    - the State

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT hr = S_OK;
	DBG_ENTER (TEXT("CFaxPersonalProfile::get_State"), hr);

    hr = GetBstr(pbstrState, m_bstrState);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxPersonalProfile, GetErrorMsgId(hr), IID_IFaxPersonalProfile, hr, _Module.GetResourceInstance());
        return hr;
    }
	return hr;
}

STDMETHODIMP 
CFaxPersonalProfile::put_State (
	BSTR bstrState
)
/*++

Routine name : CFaxPersonalProfile::put_State

Routine description:

	Set State

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	bstrState				[in]    - new State

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxPersonalProfile::put_State"), hr, _T("%s"), bstrState);

	m_bstrState = bstrState;
	if (!m_bstrState && bstrState)
	{
		//
		//	Not enough memory
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxPersonalProfile, 
			IDS_ERROR_OUTOFMEMORY, 
			IID_IFaxPersonalProfile, 
			hr, 
			_Module.GetResourceInstance());
		CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
		return hr;
	}

	return hr;
}

//
//==================== STREET ADDRESS ========================================
//
STDMETHODIMP 
CFaxPersonalProfile::get_StreetAddress (
	BSTR *pbstrStreetAddress
)
/*++

Routine name : CFaxPersonalProfile::get_StreetAddress

Routine description:

	return StreetAddress

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pbstrStreetAddress	            [out]    - the StreetAddress

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT hr = S_OK;
	DBG_ENTER (TEXT("CFaxPersonalProfile::get_StreetAddress"), hr);

    hr = GetBstr(pbstrStreetAddress, m_bstrStreetAddress);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxPersonalProfile, GetErrorMsgId(hr), IID_IFaxPersonalProfile, hr, _Module.GetResourceInstance());
        return hr;
    }
	return hr;
}

STDMETHODIMP 
CFaxPersonalProfile::put_StreetAddress (
	BSTR bstrStreetAddress
)
/*++

Routine name : CFaxPersonalProfile::put_StreetAddress

Routine description:

	Set StreetAddress

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	bstrStreetAddress				[in]    - new StreetAddress

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxPersonalProfile::put_StreetAddress"), hr, _T("%s"), bstrStreetAddress);

	m_bstrStreetAddress = bstrStreetAddress;
	if (!m_bstrStreetAddress && bstrStreetAddress)
	{
		//
		//	Not enough memory
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxPersonalProfile, 
			IDS_ERROR_OUTOFMEMORY, 
			IID_IFaxPersonalProfile, 
			hr, 
			_Module.GetResourceInstance());
		CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
		return hr;
	}

	return hr;
}

//
//==================== TITLE ========================================
//
STDMETHODIMP 
CFaxPersonalProfile::get_Title (
	BSTR *pbstrTitle
)
/*++

Routine name : CFaxPersonalProfile::get_Title

Routine description:

	return Title

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pbstrTitle	            [out]    - the Title

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT hr = S_OK;
	DBG_ENTER (TEXT("CFaxPersonalProfile::get_Title"), hr);

    hr = GetBstr(pbstrTitle, m_bstrTitle);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxPersonalProfile, GetErrorMsgId(hr), IID_IFaxPersonalProfile, hr, _Module.GetResourceInstance());
        return hr;
    }
	return hr;
}

STDMETHODIMP 
CFaxPersonalProfile::put_Title (
	BSTR bstrTitle
)
/*++

Routine name : CFaxPersonalProfile::put_Title

Routine description:

	Set Title

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	bstrTitle				[in]    - new Title

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxPersonalProfile::put_Title"), hr, _T("%s"), bstrTitle);

	m_bstrTitle = bstrTitle;
	if (!m_bstrTitle && bstrTitle)
	{
		//
		//	Not enough memory
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxPersonalProfile, 
			IDS_ERROR_OUTOFMEMORY, 
			IID_IFaxPersonalProfile, 
			hr, 
			_Module.GetResourceInstance());
		CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
		return hr;
	}

	return hr;
}

//
//==================== ZIP CODE ========================================
//
STDMETHODIMP 
CFaxPersonalProfile::get_ZipCode (
	BSTR *pbstrZipCode
)
/*++

Routine name : CFaxPersonalProfile::get_ZipCode

Routine description:

	return ZipCode

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pbstrZipCode	            [out]    - the ZipCode

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT hr = S_OK;
	DBG_ENTER (TEXT("CFaxPersonalProfile::get_ZipCode"), hr);

    hr = GetBstr(pbstrZipCode, m_bstrZipCode);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxPersonalProfile, GetErrorMsgId(hr), IID_IFaxPersonalProfile, hr, _Module.GetResourceInstance());
        return hr;
    }
	return hr;
}

STDMETHODIMP 
CFaxPersonalProfile::put_ZipCode (
	BSTR bstrZipCode
)
/*++

Routine name : CFaxPersonalProfile::put_ZipCode

Routine description:

	Set ZipCode

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	bstrZipCode				[in]    - new ZipCode

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxPersonalProfile::put_ZipCode"), hr, _T("%s"), bstrZipCode);

	m_bstrZipCode = bstrZipCode;
	if (!m_bstrZipCode && bstrZipCode)
	{
		//
		//	Not enough memory
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxPersonalProfile, 
			IDS_ERROR_OUTOFMEMORY, 
			IID_IFaxPersonalProfile, 
			hr, 
			_Module.GetResourceInstance());
		CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
		return hr;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxreceiptoptions.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	faxreceiptoptions.h

Abstract:

	Declaration of the CFaxReceiptOptions class.

Author:

	Iv Garber (IvG)	Jul, 2000

Revision History:

--*/

#ifndef __FAXRECEIPTOPTIONS_H_
#define __FAXRECEIPTOPTIONS_H_

#include "resource.h"       // main symbols
#include "FaxCommon.h"

//
//====================== FAX RECEIPT OPTIONS =======================================
//
class ATL_NO_VTABLE CFaxReceiptOptions : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public ISupportErrorInfo,
	public IDispatchImpl<IFaxReceiptOptions, &IID_IFaxReceiptOptions, &LIBID_FAXCOMEXLib>,
    public CFaxInitInner
{
public:
    CFaxReceiptOptions() : CFaxInitInner(_T("FAX RECEIPT OPTIONS")), 
        m_bInited(false)
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_FAXRECEIPTOPTIONS)
DECLARE_NOT_AGGREGATABLE(CFaxReceiptOptions)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxReceiptOptions)
	COM_INTERFACE_ENTRY(IFaxReceiptOptions)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY(IFaxInitInner)
END_COM_MAP()

//  Interfaces
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

    STDMETHOD(Save)();
    STDMETHOD(Refresh)();

    STDMETHOD(put_SMTPPort)(/*[in]*/ long lSMTPPort);
    STDMETHOD(get_SMTPPort)(/*[out, retval]*/ long *plSMTPPort);

    STDMETHOD(put_SMTPUser)(/*[in]*/ BSTR bstrSMTPUser);
    STDMETHOD(get_SMTPUser)(/*[out, retval]*/ BSTR *pbstrSMTPUser);

    STDMETHOD(put_SMTPSender)(/*[in]*/ BSTR bstrSMTPSender);
    STDMETHOD(get_SMTPSender)(/*[out, retval]*/ BSTR *pbstrSMTPSender);

    STDMETHOD(put_SMTPServer)(/*[in]*/ BSTR bstrSMTPServer);
    STDMETHOD(get_SMTPServer)(/*[out, retval]*/ BSTR *pbstrSMTPServer);

    STDMETHOD(put_SMTPPassword)(/*[in]*/ BSTR bstrSMTPPassword);
    STDMETHOD(get_SMTPPassword)(/*[out, retval]*/ BSTR *pbstrSMTPPassword);

    STDMETHOD(put_AllowedReceipts)(/*[in]*/ FAX_RECEIPT_TYPE_ENUM AllowedReceipts);
    STDMETHOD(get_AllowedReceipts)(/*[out, retval]*/ FAX_RECEIPT_TYPE_ENUM *pAllowedReceipts);

    STDMETHOD(put_AuthenticationType)(/*[in]*/ FAX_SMTP_AUTHENTICATION_TYPE_ENUM Type);
    STDMETHOD(get_AuthenticationType)(/*[out, retval]*/ FAX_SMTP_AUTHENTICATION_TYPE_ENUM *pType);

    STDMETHOD(get_UseForInboundRouting)(/*[out, retval]*/ VARIANT_BOOL *pbUseForInboundRouting);
    STDMETHOD(put_UseForInboundRouting)(/*[in]*/ VARIANT_BOOL bUseForInboundRouting);

private:
    bool            m_bInited;
    DWORD           m_dwPort;
    DWORD           m_dwAllowedReceipts;                      
    CComBSTR        m_bstrSender;
    CComBSTR        m_bstrUser;
    CComBSTR        m_bstrPassword;
    CComBSTR        m_bstrServer;
    VARIANT_BOOL    m_bUseForInboundRouting;
    FAX_SMTP_AUTHENTICATION_TYPE_ENUM   m_AuthType;
};

#endif //__FAXRECEIPTOPTIONS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxreceiptoptions.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxReceiptOptions.cpp

Abstract:

	Implementation of Fax Receipts Options Class.

Author:

	Iv Garber (IvG)	May, 2000

Revision History:

--*/

#include "stdafx.h"
#include "FaxComEx.h"
#include "FaxReceiptOptions.h"

//
//========================= USE FOR INBOUND ROUTING ====================================================
//
STDMETHODIMP 
CFaxReceiptOptions::put_UseForInboundRouting(
    VARIANT_BOOL bUseForInboundRouting
)
/*++

Routine name : CFaxReceiptOptions::put_UseForInboundRouting

Routine description:

	Set flag indicating whether current IFaxReceiptsOptions configuration should be used within the MS Routing 
        Extension to route the incoming faxed through SMTP e-mail.

Author:

	Iv Garber (IvG),	Feb, 2001

Arguments:

	bUseForInboundRouting      [out]    - the flag. See description

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxReceiptOptions::put_UseForInboundRouting"), hr);

    //
    //  Sync with the Server for the first time
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    m_bUseForInboundRouting = bUseForInboundRouting;
    return hr;
}

//
//========================= USE FOR INBOUND ROUTING ====================================================
//
STDMETHODIMP 
CFaxReceiptOptions::get_UseForInboundRouting(
    VARIANT_BOOL *pbUseForInboundRouting
)
/*++

Routine name : CFaxReceiptOptions::get_UseForInboundRouting

Routine description:

	Return flag indicating whether current IFaxReceiptsOptions configuration should be used within the MS Routing 
        Extension to route the incoming faxed through SMTP e-mail.

Author:

	Iv Garber (IvG),	Feb, 2001

Arguments:

	pbUseForInboundRouting      [out]    - the flag. See description

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxReceiptOptions::get_UseForInboundRouting"), hr);

    //
    //  Sync with the Server for the first time
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    hr = GetVariantBool(pbUseForInboundRouting, m_bUseForInboundRouting);
    if (FAILED(hr))
    {
	    AtlReportError(CLSID_FaxReceiptOptions, 
            GetErrorMsgId(hr), 
            IID_IFaxReceiptOptions, 
            hr, 
            _Module.GetResourceInstance());
        return hr;
    }
    return hr;
}

//
//========================= ALLOWED RECEIPTS ====================================================
//
STDMETHODIMP 
CFaxReceiptOptions::get_AllowedReceipts(
    FAX_RECEIPT_TYPE_ENUM *pAllowedReceipts
)
/*++

Routine name : CFaxReceiptOptions::get_AllowedReceipts

Routine description:

	Return the Receipt Types allowed by the Server

Author:

	Iv Garber (IvG),	Jul, 2000

Arguments:

	pAllowedReceipts       [out]    - the Bit-Wise Combination of Allowed Receipt Types 

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxReceiptOptions::get_AllowedReceipts"), hr);

	//
	//	Check that we can write to the given pointer
	//
	if (::IsBadWritePtr(pAllowedReceipts, sizeof(FAX_RECEIPT_TYPE_ENUM)))
	{
		//	
		//	Got Bad Return Pointer
		//
		hr = E_POINTER;
		AtlReportError(CLSID_FaxReceiptOptions, IDS_ERROR_INVALID_ARGUMENT, IID_IFaxReceiptOptions, hr, _Module.GetResourceInstance());
		CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr()"), hr);
		return hr;
	}

    //
    //  Sync with the Server for the first time
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    *pAllowedReceipts = FAX_RECEIPT_TYPE_ENUM(m_dwAllowedReceipts);
	return hr;
}

STDMETHODIMP 
CFaxReceiptOptions::put_AllowedReceipts(
    FAX_RECEIPT_TYPE_ENUM AllowedReceipts
)
/*++

Routine name : CFaxReceiptOptions::put_AllowedReceipts

Routine description:

	Change the Receipts Types on Server

Author:

	Iv Garber (IvG),	Jul, 2000

Arguments:

	AllowedReceipts        [in]    - the new Bit-Wise Combination of Allowed Receipt Types 

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxReceiptOptions::put_AllowedReceipts"), hr, _T("%d"), AllowedReceipts);

    //
    //  Check that value is valid
    //
    if ((AllowedReceipts != frtNONE) && (AllowedReceipts & ~(frtMAIL | frtMSGBOX))) // Invalid bits
    {
		hr = E_INVALIDARG;
		AtlReportError(CLSID_FaxReceiptOptions, IDS_ERROR_INVALID_ARGUMENT, IID_IFaxReceiptOptions, hr, _Module.GetResourceInstance());
		CALL_FAIL(GENERAL_ERR, _T("(AllowedReceipts is wrong)"), hr);
		return hr;
    }

    //
    //  Sync with the Server for the first time
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

	m_dwAllowedReceipts = AllowedReceipts;
	return hr;
}

//
//========================= SMTP PORT ====================================================
//
STDMETHODIMP 
CFaxReceiptOptions::get_SMTPPort(
	long *plSMTPPort
)
/*++

Routine name : CFaxReceiptOptions::get_SMTPPort

Routine description:

	Return the SMTPPort

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	plSMTPPort                     [out]    - the Current SMTPPort

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxReceiptOptions::get_SMTPPort"), hr);

    //
    //  Sync with the Server for the first time
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    hr = GetLong(plSMTPPort, m_dwPort);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxReceiptOptions, GetErrorMsgId(hr), IID_IFaxReceiptOptions, hr, _Module.GetResourceInstance());
        return hr;
    }
	return hr;
}

STDMETHODIMP 
CFaxReceiptOptions::put_SMTPPort(
	long lSMTPPort
)
/*++

Routine name : CFaxReceiptOptions::put_SMTPPort

Routine description:

	Set new SMTPPort for Receipts 

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	SMTPPort                    [in]    - the new Receipts SMTPPort

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;

	DBG_ENTER (_T("CFaxReceiptOptions::put_SMTPPort"), hr, _T("%d"), lSMTPPort);

    //
    //  Sync with the Server for the first time
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

	m_dwPort = lSMTPPort;
	return hr;
}

//
//========================= TYPE ====================================================
//
STDMETHODIMP 
CFaxReceiptOptions::get_AuthenticationType(
	FAX_SMTP_AUTHENTICATION_TYPE_ENUM *pType
)
/*++

Routine name : CFaxReceiptOptions::get_AuthenticationType

Routine description:

	Return the Authentication Type supported by the Server

Author:

	Iv Garber (IvG),	Jul, 2000

Arguments:

	pType                     [out]    - the result

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxReceiptOptions::get_AuthenticationType"), hr);

	//
	//	Check that we can write to the given pointer
	//
	if (::IsBadWritePtr(pType, sizeof(FAX_SMTP_AUTHENTICATION_TYPE_ENUM)))
	{
		//	
		//	Got Bad Return Pointer
		//
		hr = E_POINTER;
		AtlReportError(CLSID_FaxReceiptOptions, IDS_ERROR_INVALID_ARGUMENT, IID_IFaxReceiptOptions, hr, _Module.GetResourceInstance());
		CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr()"), hr);
		return hr;
	}

    //
    //  Sync with the Server for the first time
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

	*pType = m_AuthType;
	return hr;
}

STDMETHODIMP 
CFaxReceiptOptions::put_AuthenticationType(
	FAX_SMTP_AUTHENTICATION_TYPE_ENUM Type
)
/*++

Routine name : CFaxReceiptOptions::put_AuthenticationType

Routine description:

	Set new Authenticatin Type for the Server

Author:

	Iv Garber (IvG),	Jul, 2000

Arguments:

	Type                    [in]    - the new Authentication type for the Server

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxReceiptOptions::put_AuthenticationType"), hr, _T("%d"), Type);

    //
    //  Sync with the Server for the first time
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    //
    //  Check Ranges
    //
	if (Type < fsatANONYMOUS || Type > fsatNTLM)
	{
		//
		//	Out of the Range
		//
		hr = E_INVALIDARG;
		AtlReportError(CLSID_FaxReceiptOptions, IDS_ERROR_OUTOFRANGE, IID_IFaxReceiptOptions, hr, _Module.GetResourceInstance());
		CALL_FAIL(GENERAL_ERR, _T("Type is out of the Range"), hr);
		return hr;
	}

	m_AuthType = FAX_SMTP_AUTHENTICATION_TYPE_ENUM(Type);
	return hr;
}

//
//============================= SMTP SENDER ====================================
//
STDMETHODIMP 
CFaxReceiptOptions::put_SMTPSender(
	BSTR bstrSMTPSender
)
/*++

Routine name : CFaxReceiptOptions::put_SMTPSender

Routine description:

	Set the SMTPSender

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	bstrSMTPSender              [in]    - the new value of SMTPSender

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;

	DBG_ENTER (_T("CFaxReceiptOptions::put_SMTPSender"), hr, _T("%s"), bstrSMTPSender);

    //
    //  Sync with the Server for the first time
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    m_bstrSender = bstrSMTPSender;
	if (bstrSMTPSender && !m_bstrSender)
	{
		//	
		//	not enough memory
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxReceiptOptions, 
            IDS_ERROR_OUTOFMEMORY, 
            IID_IFaxReceiptOptions, 
            hr,
            _Module.GetResourceInstance());
		CALL_FAIL(MEM_ERR, _T("CComBSTR::operator=()"), hr);
		return hr;
	}
    return hr;
}

STDMETHODIMP 
CFaxReceiptOptions::get_SMTPSender(
	BSTR *pbstrSMTPSender
)
/*++

Routine name : CFaxReceiptOptions::get_SMTPSender

Routine description:

	Return the SMTP Sender

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pbstrSMTPSender                    [out]    - the SMTPSender

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxReceiptOptions::get_SMTPSender"), hr);

    //
    //  Sync with the Server for the first time
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    hr = GetBstr(pbstrSMTPSender, m_bstrSender);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxReceiptOptions, GetErrorMsgId(hr), IID_IFaxReceiptOptions, hr, _Module.GetResourceInstance());
        return hr;
    }
	return hr;
}

//
//============================= SMTP USER ====================================
//
STDMETHODIMP 
CFaxReceiptOptions::put_SMTPUser(
	BSTR bstrSMTPUser
)
/*++

Routine name : CFaxReceiptOptions::put_SMTPUser

Routine description:

	Set the SMTPUser

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	bstrSMTPUser              [in]    - the new value of SMTPUser

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;

	DBG_ENTER (_T("CFaxReceiptOptions::put_SMTPUser"), hr, _T("%s"), bstrSMTPUser);

    //
    //  Sync with the Server for the first time
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    m_bstrUser = bstrSMTPUser;
	if (bstrSMTPUser && !m_bstrUser)
	{
		//	
		//	not enough memory
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxReceiptOptions, 
            IDS_ERROR_OUTOFMEMORY, 
            IID_IFaxReceiptOptions, 
            hr,
            _Module.GetResourceInstance());
		CALL_FAIL(MEM_ERR, _T("::SysAllocString()"), hr);
		return hr;
	}

	return hr;
}

STDMETHODIMP 
CFaxReceiptOptions::get_SMTPUser(
	BSTR *pbstrSMTPUser
)
/*++

Routine name : CFaxReceiptOptions::get_SMTPUser

Routine description:

	Return the SMTP User

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pbstrSMTPUser                    [out]    - the SMTPUser

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxReceiptOptions::get_SMTPUser"), hr);

    //
    //  Sync with the Server for the first time
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    hr = GetBstr(pbstrSMTPUser, m_bstrUser);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxReceiptOptions, GetErrorMsgId(hr), IID_IFaxReceiptOptions, hr, _Module.GetResourceInstance());
        return hr;
    }
	return hr;
}

//
//============================= SMTP PASSWORD ====================================
//
STDMETHODIMP 
CFaxReceiptOptions::put_SMTPPassword(
	BSTR bstrSMTPPassword
)
/*++

Routine name : CFaxReceiptOptions::put_SMTPPassword

Routine description:

	Set the SMTPPassword

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	bstrSMTPPassword              [in]    - the new value of SMTPPassword

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;

	DBG_ENTER (_T("CFaxReceiptOptions::put_SMTPPassword"), hr, _T("%s"), bstrSMTPPassword);

    //
    //  Sync with the Server for the first time
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    m_bstrPassword = bstrSMTPPassword;
	if (bstrSMTPPassword && !m_bstrPassword)
	{
		//	
		//	not enough memory
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxReceiptOptions, 
            IDS_ERROR_OUTOFMEMORY, 
            IID_IFaxReceiptOptions, 
            hr,
            _Module.GetResourceInstance());
		CALL_FAIL(MEM_ERR, _T("::SysAllocString()"), hr);
		return hr;
	}

	return hr;
}

STDMETHODIMP 
CFaxReceiptOptions::get_SMTPPassword(
	BSTR *pbstrSMTPPassword
)
/*++

Routine name : CFaxReceiptOptions::get_SMTPPassword

Routine description:

	Return the SMTP Password

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pbstrSMTPPassword                    [out]    - the SMTPPassword

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;

	DBG_ENTER (TEXT("CFaxReceiptOptions::get_SMTPPassword"), hr);

    //
    //  Sync with the Server for the first time
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    hr = GetBstr(pbstrSMTPPassword, m_bstrPassword);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxReceiptOptions, GetErrorMsgId(hr), IID_IFaxReceiptOptions, hr, _Module.GetResourceInstance());
        return hr;
    }
	return hr;
}

//
//============================= SMTP SERVER ====================================
//
STDMETHODIMP 
CFaxReceiptOptions::put_SMTPServer(
	BSTR bstrSMTPServer
)
/*++

Routine name : CFaxReceiptOptions::put_SMTPServer

Routine description:

	Set the SMTPServer

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	bstrSMTPServer              [in]    - the new value of SMTPServer

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;

	DBG_ENTER (_T("CFaxReceiptOptions::put_SMTPServer"), hr, _T("%s"), bstrSMTPServer);

    //
    //  Sync with the Server for the first time
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    m_bstrServer = bstrSMTPServer;
	if (bstrSMTPServer && !m_bstrServer)
	{
		//	
		//	not enough memory
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxReceiptOptions, 
            IDS_ERROR_OUTOFMEMORY, 
            IID_IFaxReceiptOptions, 
            hr,
            _Module.GetResourceInstance());
		CALL_FAIL(MEM_ERR, _T("CComBSTR::operator=()"), hr);
		return hr;
	}

	return hr;
}

STDMETHODIMP 
CFaxReceiptOptions::get_SMTPServer(
	BSTR *pbstrSMTPServer
)
/*++

Routine name : CFaxReceiptOptions::get_SMTPServer

Routine description:

	Return the SMTP Server

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pbstrSMTPServer                    [out]    - the SMTPServer

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxReceiptOptions::get_SMTPServer"), hr);

    //
    //  Sync with the Server for the first time
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    hr = GetBstr(pbstrSMTPServer, m_bstrServer);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxReceiptOptions, GetErrorMsgId(hr), IID_IFaxReceiptOptions, hr, _Module.GetResourceInstance());
        return hr;
    }
	return hr;
}


//
//==================== SAVE ========================================
//
STDMETHODIMP
CFaxReceiptOptions::Save(
)
/*++

Routine name : CFaxReceiptOptions::Save

Routine description:

	Save current Receipt Options at the Server.

Author:

	Iv Garber (IvG),	May, 2000

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;

    DBG_ENTER(_T("CFaxReceiptOptions::Save"), hr);

    if (!m_bInited)
    {
        //
        //  nothing was done to the Receipt Options
        //
        return hr;
    }

    if (m_dwAllowedReceipts & frtMAIL)
    {

        //
        //  check validity of values
        //
        switch(m_AuthType)
        {
        case fsatNTLM:
        case fsatBASIC:
            if ((::SysStringLen(m_bstrUser) < 1) || (::SysStringLen(m_bstrPassword) < 1))
            {
                hr = E_FAIL;
                AtlReportError(CLSID_FaxReceiptOptions, IDS_ERROR_NOUSERPASSWORD, IID_IFaxReceiptOptions, hr, _Module.GetResourceInstance());
                CALL_FAIL(GENERAL_ERR, _T("ReceiptOptions = SMTP_NTLM/BASIC + User/Password is empty"), hr);
                return hr;
            }

            // no break, continue to SMTP_ANONYMOUS case

        case fsatANONYMOUS:
            if ((::SysStringLen(m_bstrServer) < 1) || (::SysStringLen(m_bstrSender) < 1) || m_dwPort < 1)
            {
                hr = E_FAIL;
                AtlReportError(CLSID_FaxReceiptOptions, IDS_ERROR_NOSERVERSENDERPORT, IID_IFaxReceiptOptions, hr, _Module.GetResourceInstance());
                CALL_FAIL(GENERAL_ERR, _T("ReceiptOptions = SMTP_... + Server/Sender/Port is empty"), hr);
                return hr;
            }
            break;
        default:
            //
            //  assert (FALSE)
            //
            ATLASSERT(m_AuthType == fsatANONYMOUS);
            break;
        }
    }

    //
    //  Get Fax Server Handle
    //
    HANDLE  hFaxHandle = NULL;
    hr = GetFaxHandle(&hFaxHandle);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxReceiptOptions, GetErrorMsgId(hr), IID_IFaxReceiptOptions, hr, _Module.GetResourceInstance());
        return hr;
    }

    //
    //  Create ReceiptOptions Struct
    //
    FAX_RECEIPTS_CONFIG    ReceiptsConfig = {0};
    ReceiptsConfig.dwSizeOfStruct = sizeof(FAX_RECEIPTS_CONFIG);
    ReceiptsConfig.dwSMTPPort = m_dwPort;
    ReceiptsConfig.lptstrSMTPFrom = m_bstrSender;
    ReceiptsConfig.lptstrSMTPUserName = m_bstrUser;
    ReceiptsConfig.lptstrSMTPPassword = m_bstrPassword;
    ReceiptsConfig.lptstrSMTPServer = m_bstrServer;
    ReceiptsConfig.SMTPAuthOption = FAX_ENUM_SMTP_AUTH_OPTIONS(m_AuthType);
    ReceiptsConfig.dwAllowedReceipts = m_dwAllowedReceipts;
    ReceiptsConfig.bIsToUseForMSRouteThroughEmailMethod = VARIANT_BOOL2bool(m_bUseForInboundRouting);

    //
    //  Ask the Server to set the Receipt Configuration
    //
    if (!FaxSetReceiptsConfiguration(hFaxHandle, &ReceiptsConfig))
    {
        //
        //  Failed to set Receipts Options on the Server
        //
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        AtlReportError(CLSID_FaxReceiptOptions, GetErrorMsgId(hr), IID_IFaxReceiptOptions, hr, _Module.GetResourceInstance());
        CALL_FAIL(GENERAL_ERR, _T("FaxSetReceiptConfiguration(hFaxHandle, &ReceiptsConfig)"), hr);
        return hr;
    }

    return hr;
}

//
//==================== REFRESH ========================================
//
STDMETHODIMP
CFaxReceiptOptions::Refresh(
)
/*++

Routine name : CFaxReceiptOptions::Refresh

Routine description:

	Bring new Receipt Options from the Server.

Author:

	Iv Garber (IvG),	May, 2000

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxReceiptOptions::Refresh"), hr);

    //
    //  Get Fax Server Handle
    //
    HANDLE  hFaxHandle = NULL;
    hr = GetFaxHandle(&hFaxHandle);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxReceiptOptions, 
            GetErrorMsgId(hr), 
            IID_IFaxReceiptOptions, 
            hr, 
            _Module.GetResourceInstance());
        return hr;
    }

    //
    //  Ask Server for the Receipts Options Struct
    //
    CFaxPtr<FAX_RECEIPTS_CONFIG>    pReceiptsConfig;
    if (!FaxGetReceiptsConfiguration(hFaxHandle, &pReceiptsConfig))
    {
        //
        //  Failed to get Receipts Options object from the Server
        //
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        AtlReportError(CLSID_FaxReceiptOptions, 
            GetErrorMsgId(hr), 
            IID_IFaxReceiptOptions, 
            hr, 
            _Module.GetResourceInstance());
        CALL_FAIL(GENERAL_ERR, _T("FaxGetReceiptConfiguration(hFaxHandle, &pReceiptsConfig)"), hr);
        return hr;
    }

    //  
    //  Check that pReceiptConfig is valid
    //
    if (!pReceiptsConfig || pReceiptsConfig->dwSizeOfStruct != sizeof(FAX_RECEIPTS_CONFIG))
    {
        hr = E_FAIL;
        AtlReportError(CLSID_FaxReceiptOptions, 
            GetErrorMsgId(hr), 
            IID_IFaxReceiptOptions, 
            hr, 
            _Module.GetResourceInstance());
        CALL_FAIL(GENERAL_ERR, _T("(!m_pReceiptsConfig || SizeOfStruct != sizeof(FAX_RECEIPTS_CONFIG))"), hr);
        return hr;
    }

    m_dwPort = pReceiptsConfig->dwSMTPPort;
    m_AuthType = FAX_SMTP_AUTHENTICATION_TYPE_ENUM(pReceiptsConfig->SMTPAuthOption);
    m_dwAllowedReceipts = pReceiptsConfig->dwAllowedReceipts;
    m_bUseForInboundRouting = bool2VARIANT_BOOL(pReceiptsConfig->bIsToUseForMSRouteThroughEmailMethod);

    m_bstrSender = ::SysAllocString(pReceiptsConfig->lptstrSMTPFrom);
    m_bstrUser = ::SysAllocString(pReceiptsConfig->lptstrSMTPUserName);
    m_bstrPassword = ::SysAllocString(pReceiptsConfig->lptstrSMTPPassword);
    m_bstrServer = ::SysAllocString(pReceiptsConfig->lptstrSMTPServer);
    if ( ((pReceiptsConfig->lptstrSMTPFrom) && !m_bstrSender) ||
         ((pReceiptsConfig->lptstrSMTPUserName) && !m_bstrUser) ||
         ((pReceiptsConfig->lptstrSMTPPassword) && !m_bstrPassword) ||
         ((pReceiptsConfig->lptstrSMTPServer) && !m_bstrServer) )
    {
		//
		//	Failed to Copy
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxReceiptOptions, IDS_ERROR_OUTOFMEMORY, IID_IFaxReceiptOptions, hr, _Module.GetResourceInstance());
		CALL_FAIL(MEM_ERR, _T("::SysAllocString()"), hr);
		return hr;
    }

    m_bInited = true;
    return hr;
}

//
//================ SUPPORT ERRRO INFO =========================================
//
STDMETHODIMP 
CFaxReceiptOptions::InterfaceSupportsErrorInfo(
    REFIID riid
)
/*++

Routine name : CFaxReceiptOptions::InterfaceSupportsErrorInfo

Routine description:

	ATL's implementation of Interface Support Error Info.

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	riid                          [in]    - IID of the Interface to check.

Return Value:

    Standard HRESULT code

--*/
{
	static const IID* arr[] = 
	{
		&IID_IFaxReceiptOptions
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxrecipient.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxRecipeint.h

Abstract:

	Definition of Recipient Class

Author:

	Iv Garber (IvG)	May, 2000

Revision History:

--*/

#ifndef __FAXRECIPIENT_H_
#define __FAXRECIPIENT_H_

#include "resource.h"
#include "FaxCommon.h"

//
//========================== FAX RECIPIENT ===============================================
//
class ATL_NO_VTABLE CFaxRecipient : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public ISupportErrorInfo,
	public IDispatchImpl<IFaxRecipient, &IID_IFaxRecipient, &LIBID_FAXCOMEXLib>
{
public:
	CFaxRecipient()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_FAXRECIPIENT)
DECLARE_NOT_AGGREGATABLE(CFaxRecipient)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxRecipient)
	COM_INTERFACE_ENTRY(IFaxRecipient)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

public:
	static HRESULT Create(IFaxRecipient **ppRecipient);
	STDMETHOD(GetRecipientProfile)(/*[out, retval]*/ FAX_PERSONAL_PROFILE *pRecipientProfile);
	STDMETHOD(PutRecipientProfile)(/*[in]*/ FAX_PERSONAL_PROFILE *pRecipientProfile);

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IFaxRecipient
	STDMETHOD(get_FaxNumber)(/*[out, retval]*/ BSTR *pbstrFaxNumber);
	STDMETHOD(put_FaxNumber)(/*[in]*/ BSTR bstrFaxNumber);
	STDMETHOD(get_Name)(/*[out, retval]*/ BSTR *pbstrName);
	STDMETHOD(put_Name)(/*[in]*/ BSTR bstrName);

private:
	CComBSTR	m_bstrFaxNumber;
	CComBSTR	m_bstrName;
};

#endif //__FAXRECIPIENT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxrecipient.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxRecipient.cpp

Abstract:

	Implementation of Fax Recipient Interface

Author:

	Iv Garber (IvG)	Apr, 2000

Revision History:

--*/

#include "stdafx.h"
#include "FaxComEx.h"
#include "FaxRecipient.h"
#include "..\..\inc\FaxUIConstants.h"

//
//===================== GET RECIPIENT PROFILE =====================================
//
STDMETHODIMP
CFaxRecipient::GetRecipientProfile(
	FAX_PERSONAL_PROFILE *pRecipientProfile
)
/*++

Routine name : CFaxRecipient::GetRecipientProfile

Routine description:

	Fills the pRecipientProfile with the data of the object.

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	pRecipientProfile               [out]    - the FAX_PERSONAL_PROFILE struct to fill

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxRecipient::GetRecipientProfile"), hr);

	if (::IsBadWritePtr(pRecipientProfile, sizeof(FAX_PERSONAL_PROFILE)))
	{
		//
		//	Bad Return OR Interface Pointer
		//
		hr = E_POINTER;
		CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr()"), hr);
		return hr;
	}

    ZeroMemory(pRecipientProfile, sizeof(FAX_PERSONAL_PROFILE));

	pRecipientProfile->dwSizeOfStruct	= sizeof(FAX_PERSONAL_PROFILE);
	pRecipientProfile->lptstrName		= m_bstrName;
	pRecipientProfile->lptstrFaxNumber	= m_bstrFaxNumber;

	return hr;
}

//
//============== PUT RECIPIENT PROFILE ============================================
//
STDMETHODIMP
CFaxRecipient::PutRecipientProfile(
	FAX_PERSONAL_PROFILE *pRecipientProfile
)
/*++

Routine name : CFaxRecipient::PutRecipientProfile

Routine description:

	Receives FAX_PERSONAL_PROFILE structure and fills the Recipient's fields.

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	pRecipientProfile               [in]    - the data to put into the object's variables

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;

	DBG_ENTER (_T("CFaxRecipient::PutRecipientProfile"), hr);

	m_bstrFaxNumber	=	pRecipientProfile->lptstrFaxNumber;
	m_bstrName		=	pRecipientProfile->lptstrName;

	if ((pRecipientProfile->lptstrFaxNumber && !m_bstrFaxNumber) ||
		(pRecipientProfile->lptstrName && !m_bstrName))
	{
		//
		//	Not enough memory
		//
		hr = E_OUTOFMEMORY;
		CALL_FAIL(MEM_ERR, _T("CComBSTR::operator=()"), hr);
	}

	return hr;
}


//
//==================== INTERFACE SUPPORT ERROR INFO =====================
//
STDMETHODIMP 
CFaxRecipient::InterfaceSupportsErrorInfo (
	REFIID riid
)
/*++

Routine name : CFaxRecipient::InterfaceSupportsErrorInfo

Routine description:

	ATL's implementation of Support Error Info

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	riid                          [in]    - Interface ID

Return Value:

    Standard HRESULT code

--*/
{
	static const IID* arr[] = 
	{
		&IID_IFaxRecipient
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

//
//==================== CREATE ========================================
//
HRESULT 
CFaxRecipient::Create (
	IFaxRecipient **ppRecipient
)
/*++

Routine name : CFaxRecipient::Create

Routine description:

	Static function to create the Fax Recipient Instance

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	ppRecipient         [out]  -- the new Fax Recipient Instance

Return Value:

    Standard HRESULT code

--*/

{
	CComObject<CFaxRecipient>		*pClass;
	HRESULT					        hr = S_OK;

	DBG_ENTER (TEXT("CFaxRecipient::Create"), hr);

	hr = CComObject<CFaxRecipient>::CreateInstance(&pClass);
	if (FAILED(hr))
	{
		//
		//	Failed to create Instance
		//
		CALL_FAIL(GENERAL_ERR, _T("CComObject<CFaxRecipient>::CreateInstance()"), hr);
		return hr;
	}

	hr = pClass->QueryInterface(__uuidof(IFaxRecipient), (void **) ppRecipient);
	if (FAILED(hr))
	{
		//
		//	Failed to Query Recipient Interface
		//
		CALL_FAIL(GENERAL_ERR, _T("QueryInterface()"), hr);
		return hr;
	}

	return hr;
}


//
//==================== FAX NUMBER ========================================
//
STDMETHODIMP 
CFaxRecipient::get_FaxNumber(
	BSTR *pbstrFaxNumber
)
/*++

Routine name : CFaxRecipient::get_FaxNumber

Routine description:

	return FaxNumber

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pbstrFaxNumber	            [out]    - the FaxNumber

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT hr = S_OK;
	DBG_ENTER (TEXT("CFaxRecipient::get_FaxNumber"), hr);

    hr = GetBstr(pbstrFaxNumber, m_bstrFaxNumber);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxRecipient, GetErrorMsgId(hr), IID_IFaxRecipient, hr, _Module.GetResourceInstance());
        return hr;
    }
	return hr;
}

STDMETHODIMP 
CFaxRecipient::put_FaxNumber (
	BSTR bstrFaxNumber
)
/*++

Routine name : CFaxRecipient::put_FaxNumber

Routine description:

	Set FaxNumber

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	bstrFaxNumber               [in]    - new Fax Number 

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;

	DBG_ENTER (_T("CFaxRecipient::put_FaxNumber"), hr, _T("%s"), bstrFaxNumber);

	m_bstrFaxNumber = bstrFaxNumber;
	if (!m_bstrFaxNumber && bstrFaxNumber)
	{
		//
		//	Not enough memory
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxRecipient, IDS_ERROR_OUTOFMEMORY, IID_IFaxRecipient, hr, _Module.GetResourceInstance());
		CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
		return hr;
	}

	return hr;
}


//
//==================== NAME ========================================
//
STDMETHODIMP 
CFaxRecipient::get_Name(
	BSTR *pbstrName
)
/*++

Routine name : CFaxRecipient::get_Name

Routine description:

	return Name

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pbstrName	            [out]    - the Name

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT hr = S_OK;
	DBG_ENTER (_T("CFaxRecipient::get_Name"), hr);

    hr = GetBstr(pbstrName, m_bstrName);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxRecipient, GetErrorMsgId(hr), IID_IFaxRecipient, hr, _Module.GetResourceInstance());
        return hr;
    }
	return hr;
}

STDMETHODIMP 
CFaxRecipient::put_Name (
	BSTR bstrName
)
/*++

Routine name : CFaxRecipient::put_Name

Routine description:

	Set Name

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	bstrName               [in]    - new Name

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxRecipient::put_Name"), hr, _T("%s"), bstrName);

	m_bstrName = bstrName;
	if (!m_bstrName && bstrName)
	{
		//
		//	Not enough memory
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxRecipient, IDS_ERROR_OUTOFMEMORY, IID_IFaxRecipient, hr, _Module.GetResourceInstance());
		CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
		return hr;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxrecipients.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxRecipients.h

Abstract:

	Declaration of the CFaxRecipients class.

Author:

	Iv Garber (IvG)	Jul, 2000

Revision History:

--*/

#ifndef __FAXRECIPIENTS_H_
#define __FAXRECIPIENTS_H_

#include "resource.h"       // main symbols

#include <deque>
#include "VCUE_Copy.h"
#include "FaxRecipient.h"

namespace Recipients
{
	// Store the Recipients in the Deque
	typedef	std::deque<IFaxRecipient*>	ContainerType;

    //  Expose the Recipients
	typedef	IFaxRecipient*	            CollectionExposedType;
	typedef IFaxRecipients	            CollectionIfc;

	// Use IEnumVARIANT as the enumerator for VB compatibility
	typedef	VARIANT				EnumExposedType;
	typedef	IEnumVARIANT		EnumIfc;

	// Typedef the copy classes using existing typedefs
    typedef VCUE::CopyIfc2Variant<ContainerType::value_type>    EnumCopyType;
    typedef VCUE::CopyIfc<CollectionExposedType>                CollectionCopyType;

    typedef CComEnumOnSTL< EnumIfc, &__uuidof(EnumIfc), 
		EnumExposedType, EnumCopyType, ContainerType >    EnumType;

    typedef ICollectionOnSTLImpl< CollectionIfc, ContainerType, 
		CollectionExposedType, CollectionCopyType, EnumType >    CollectionType;
};

using namespace Recipients;

//
//=============================== FAX RECIPIENTS =====================================
//
class ATL_NO_VTABLE CFaxRecipients : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public ISupportErrorInfo,
	public IDispatchImpl<Recipients::CollectionType, &IID_IFaxRecipients, &LIBID_FAXCOMEXLib>
{
public:
	CFaxRecipients()
	{
        DBG_ENTER(_T("FAX RECIPIENTS -- CREATE"));
	}

	~CFaxRecipients()
	{
        DBG_ENTER(_T("FAX RECIPIENTS -- DESTROY"));

        //
        //  Free the Collection
        //
        HRESULT hr = S_OK;
        long size = m_coll.size();
        for ( long i = 1 ; i <= size ; i++ )
        {
            hr = Remove(1);
            if (FAILED(hr))
            {
                CALL_FAIL(GENERAL_ERR, _T("Remove(1)"), hr);
            }
        }
	}

DECLARE_REGISTRY_RESOURCEID(IDR_FAXRECIPIENTS)
DECLARE_NOT_AGGREGATABLE(CFaxRecipients)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxRecipients)
	COM_INTERFACE_ENTRY(IFaxRecipients)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

//  Interfaces
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
	STDMETHOD(Add)(/*[in]*/ BSTR bstrFaxNumber, /*[in, defaultvalue("")]*/ BSTR bstrName, IFaxRecipient **ppRecipient);
	STDMETHOD(Remove)(/*[in]*/ long lIndex);

//  Internal Use
	static HRESULT Create(IFaxRecipients **ppFaxRecipients);
};

#endif //__FAXRECIPIENTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxsecurity.h ===
// FaxSecurity.h : Declaration of the CFaxSecurity

#ifndef __FAXSECURITY_H_
#define __FAXSECURITY_H_

#include "resource.h"       // main symbols
#include "FaxLocalPtr.h"


//
//======================== FAX SECURITY ==============================================
//
class ATL_NO_VTABLE CFaxSecurity : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public ISupportErrorInfo,
	public IDispatchImpl<IFaxSecurity, &IID_IFaxSecurity, &LIBID_FAXCOMEXLib>,
    public CFaxInitInner
{
public:
    CFaxSecurity() : CFaxInitInner(_T("FAX SECURITY")),
        m_bInited(false),
        m_dwSecurityInformation(OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION)
	{
	}

    ~CFaxSecurity()
    {
    }

DECLARE_REGISTRY_RESOURCEID(IDR_FAXSECURITY)
DECLARE_NOT_AGGREGATABLE(CFaxSecurity)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxSecurity)
	COM_INTERFACE_ENTRY(IFaxSecurity)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY(IFaxInitInner)
END_COM_MAP()

//  Interfaces
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

    STDMETHOD(Save)();
    STDMETHOD(Refresh)();
    STDMETHOD(put_Descriptor)(/*[in]*/ VARIANT vDescriptor);
    STDMETHOD(get_Descriptor)(/*[out, retval]*/ VARIANT *pvDescriptor);
    STDMETHOD(get_GrantedRights)(/*[out, retval]*/ FAX_ACCESS_RIGHTS_ENUM *pGrantedRights);

    STDMETHOD(put_InformationType)(/*[in]*/ long lInformationType);
    STDMETHOD(get_InformationType)(/*[out, retval]*/ long *plInformationType);

private:
    bool                m_bInited;
    DWORD               m_dwAccessRights;
    CFaxPtrLocal<BYTE>  m_pbSD;
    DWORD               m_dwSecurityInformation;
};

#endif //__FAXSECURITY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxrecipients.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxRecipients.cpp

Abstract:

	Implementation of Fax Recipients Collection

Author:

	Iv Garber (IvG)	Apr, 2000

Revision History:

--*/

#include "stdafx.h"
#include "FaxComEx.h"
#include "FaxRecipients.h"

//
//====================== ADD & REMOVE ==================================
//
STDMETHODIMP 
CFaxRecipients::Add ( 
	/*[in]*/ BSTR bstrFaxNumber,
	/*[in,defaultvalue("")]*/ BSTR bstrName,
	/*[out, retval]*/ IFaxRecipient **ppRecipient
) 
/*++

Routine name : CFaxRecipients::Add

Routine description:

	Add New Recipient to the Recipients Collection

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	ppRecipient                [out]    - Ptr to the newly created Recipient

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;

	DBG_ENTER (_T("CFaxRecipients::Add"), hr);

	//
	//	Check that we can write to the given pointer
	//
	if (::IsBadWritePtr(ppRecipient, sizeof(IFaxRecipient* )))
	{
		//
		//	Got a bad return pointer
		//
		hr = E_POINTER;
		AtlReportError(CLSID_FaxRecipients, 
			IDS_ERROR_INVALID_ARGUMENT, 
			IID_IFaxRecipients, 
			hr, 
			_Module.GetResourceInstance());
		CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr()"), hr);
		return hr;
	}

	//
	//	Fax Number should exist
	//
	if (::SysStringLen(bstrFaxNumber) < 1)
	{
		hr = E_INVALIDARG;
		AtlReportError(CLSID_FaxRecipients, 
			IDS_ERROR_EMPTY_ARGUMENT, 
			IID_IFaxRecipients, 
			hr,
			_Module.GetResourceInstance());
		CALL_FAIL(GENERAL_ERR, _T("::SysStringLen(bstrFaxNumber) < 1"), hr);
		return hr;
	}

	CComPtr<IFaxRecipient>	pNewRecipient;

	hr = CFaxRecipient::Create(&pNewRecipient);
	if (FAILED(hr))
	{
		//
		//	Failed to create Recipient object
		//
		AtlReportError(CLSID_FaxRecipients, 
			IDS_ERROR_OPERATION_FAILED, 
			IID_IFaxRecipients, 
			hr, 
			_Module.GetResourceInstance());
		CALL_FAIL(GENERAL_ERR, _T("CFaxRecipient::Create()"), hr);
		return hr;
	}

	try 
	{
		m_coll.push_back(pNewRecipient);
	}
	catch (exception &)
	{
		//
		//	Failed to add the Recipient to the Collection
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxRecipients, 
			IDS_ERROR_OUTOFMEMORY, 
			IID_IFaxRecipients, 
			hr, 
			_Module.GetResourceInstance());
		CALL_FAIL(MEM_ERR, _T("m_coll.push_back()"), hr);
		return hr;
	}

	//
	//	Put Fax Number
	//
	hr = pNewRecipient->put_FaxNumber(bstrFaxNumber);
	if (FAILED(hr))
	{
		AtlReportError(CLSID_FaxRecipients, 
			IDS_ERROR_OPERATION_FAILED, 
			IID_IFaxRecipients, 
			hr, 
			_Module.GetResourceInstance());
		CALL_FAIL(MEM_ERR, _T("pNewRecipient->put_FaxNumber(bstrFaxNumber)"), hr);
		return hr;
	}

	//
	//	Put Recipient's Name
	//
	hr = pNewRecipient->put_Name(bstrName);
	if (FAILED(hr))
	{
		AtlReportError(CLSID_FaxRecipients, 
			IDS_ERROR_OPERATION_FAILED, 
			IID_IFaxRecipients, 
			hr, 
			_Module.GetResourceInstance());
		CALL_FAIL(MEM_ERR, _T("pNewRecipient->put_Name(bstrName)"), hr);
		return hr;
	}

	//
	//	Additional AddRef() to prevent death of the Recipient
	//
	(*pNewRecipient).AddRef();

	pNewRecipient.CopyTo(ppRecipient);
	return hr; 
};

STDMETHODIMP 
CFaxRecipients::Remove (
	/*[in]*/ long lIndex
) 
/*++

Routine name : CFaxRecipients::Remove

Routine description:

	Remove Recipient at given index from the Collection

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	lIndex                        [in]    - Index of the Recipient to Remove

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;

	DBG_ENTER (_T("CFaxRecipients::Remove"), hr, _T("%d"), lIndex);

	if (lIndex < 1 || lIndex > m_coll.size()) 
	{
		//
		//	Invalid Index
		//
		hr = E_INVALIDARG;
		AtlReportError(CLSID_FaxRecipients, 
			IDS_ERROR_OUTOFRANGE, 
			IID_IFaxRecipients, 
			hr, 
			_Module.GetResourceInstance());
		CALL_FAIL(GENERAL_ERR, _T("lIndex > m_coll.size()"), hr);
		return hr;
	}

	ContainerType::iterator	it;

	it = m_coll.begin() + lIndex - 1;

	hr = (*it)->Release();
	if (FAILED(hr))
	{
		//
		//	Failed to Release the Interface
		//
		AtlReportError(CLSID_FaxRecipients, 
			IDS_ERROR_OPERATION_FAILED, 
			IID_IFaxRecipients, 
			hr, 
			_Module.GetResourceInstance());
		CALL_FAIL(GENERAL_ERR, _T("Release()"), hr);
		return hr;
	}

	try
	{
		m_coll.erase(it);
	}
	catch(exception &)
	{
		//
		//	Failed to remove the Recipient from the Collection
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxRecipients, 
			IDS_ERROR_OUTOFMEMORY, 
			IID_IFaxRecipients, 
			hr, 
			_Module.GetResourceInstance());
		CALL_FAIL(MEM_ERR, _T("m_coll.erase()"), hr);
		return hr;
	}

	return hr; 
};

//
//====================== CREATE ==================================
//
HRESULT 
CFaxRecipients::Create ( 
	IFaxRecipients **ppRecipients
)
/*++

Routine name : CFaxRecipients::Create

Routine description:

	Static function to Create Recipients Collection

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	ppRecipients                  [out]    - the resulting collection

Return Value:

    Standard HRESULT code

--*/
{
	CComObject<CFaxRecipients>	*pClass;
	HRESULT						hr;

	DBG_ENTER (_T("CFaxRecipients::Create"), hr);

	hr = CComObject<CFaxRecipients>::CreateInstance(&pClass);
	if (FAILED(hr))
	{
		//
		//	Failed to create Instance
		//
		CALL_FAIL(GENERAL_ERR, _T("CComObject<CFaxRecipients>::CreateInstance()"), hr);
		return hr;
	}

	hr = pClass->QueryInterface(__uuidof(IFaxRecipients), (void **) ppRecipients);
	if (FAILED(hr))
	{
		//
		//	Failed to Query Fax Recipients Interface
		//
		CALL_FAIL(GENERAL_ERR, _T("QueryInterface()"), hr);
		return hr;
	}

	return hr;
}

//
//==================== INTERFACE SUPPORT ERROR INFO =====================
//
STDMETHODIMP 
CFaxRecipients::InterfaceSupportsErrorInfo (
	REFIID riid
)
/*++

Routine name : CFaxRecipients::InterfaceSupportsErrorInfo

Routine description:

	ATL's implementation of Support Error Info

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	riid                          [in]    - Interface ID

Return Value:

    Standard HRESULT code

--*/
{
	static const IID* arr[] = 
	{
		&IID_IFaxRecipients
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxsender.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxSender.h

Abstract:

	Definition of Sender Class

Author:

	Iv Garber (IvG)	May, 2000

Revision History:

--*/

#ifndef __FAXSENDER_H_
#define __FAXSENDER_H_

#include "resource.h"
#include "FaxCommon.h"
#include "FaxRecipient.h"

//
//====================== FAX SENDER ===========================================================
//
class ATL_NO_VTABLE CFaxSender : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public ISupportErrorInfo,
	public IDispatchImpl<IFaxSender, &IID_IFaxSender, &LIBID_FAXCOMEXLib>
{
public:
	CFaxSender()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_FAXSENDER)
DECLARE_NOT_AGGREGATABLE(CFaxSender)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxSender)
	COM_INTERFACE_ENTRY(IFaxSender)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

public:
	static HRESULT Create(IFaxSender **ppSender);
	STDMETHOD(GetSenderProfile)(/*[out, retval]*/ FAX_PERSONAL_PROFILE *pSenderProfile);
	STDMETHOD(PutSenderProfile)(/*[in]*/ FAX_PERSONAL_PROFILE *pSenderProfile);

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IFaxSender
	STDMETHOD(SaveDefaultSender)();
	STDMETHOD(LoadDefaultSender)();
	STDMETHOD(get_BillingCode)(/*[out, retval]*/ BSTR *pbstrBillingCode);
	STDMETHOD(put_BillingCode)(/*[in]*/ BSTR bstrBillingCode);
	STDMETHOD(get_City)(/*[out, retval]*/ BSTR *pbstrCity);
	STDMETHOD(put_City)(/*[in]*/ BSTR bstrCity);
	STDMETHOD(get_Company)(/*[out, retval]*/ BSTR *pbstrCompany);
	STDMETHOD(put_Company)(/*[in]*/ BSTR bstrCompany);
	STDMETHOD(get_Country)(/*[out, retval]*/ BSTR *pbstrCountry);
	STDMETHOD(put_Country)(/*[in]*/ BSTR bstrCountry);
	STDMETHOD(get_Department)(/*[out, retval]*/ BSTR *pbstrDepartment);
	STDMETHOD(put_Department)(/*[in]*/ BSTR bstrDepartment);
	STDMETHOD(get_Email)(/*[out, retval]*/ BSTR *pbstrEmail);
	STDMETHOD(put_Email)(/*[in]*/ BSTR bstrEmail);
	STDMETHOD(get_HomePhone)(/*[out, retval]*/ BSTR *pbstrHomePhone);
	STDMETHOD(put_HomePhone)(/*[in]*/ BSTR bstrHomePhone);
	STDMETHOD(get_TSID)(/*[out, retval]*/ BSTR *pbstrTSID);
	STDMETHOD(put_TSID)(/*[in]*/ BSTR bstrTSID);
	STDMETHOD(get_OfficePhone)(/*[out, retval]*/ BSTR *pbstrOfficePhone);
	STDMETHOD(put_OfficePhone)(/*[in]*/ BSTR bstrOfficePhone);
	STDMETHOD(get_OfficeLocation)(/*[out, retval]*/ BSTR *pbstrOfficeLocation);
	STDMETHOD(put_OfficeLocation)(/*[in]*/ BSTR bstrOfficeLocation);
	STDMETHOD(get_State)(/*[out, retval]*/ BSTR *pbstrState);
	STDMETHOD(put_State)(/*[in]*/ BSTR bstrState);
	STDMETHOD(get_StreetAddress)(/*[out, retval]*/ BSTR *pbstrStreetAddress);
	STDMETHOD(put_StreetAddress)(/*[in]*/ BSTR bstrStreetAddress);
	STDMETHOD(get_Title)(/*[out, retval]*/ BSTR *pbstrTitle);
	STDMETHOD(put_Title)(/*[in]*/ BSTR bstrTitle);
	STDMETHOD(get_ZipCode)(/*[out, retval]*/ BSTR *pbstrZipCode);
	STDMETHOD(put_ZipCode)(/*[in]*/ BSTR bstrZipCode);
	STDMETHOD(get_FaxNumber)(/*[out, retval]*/ BSTR *pbstrFaxNumber);
	STDMETHOD(put_FaxNumber)(/*[in]*/ BSTR bstrFaxNumber);
	STDMETHOD(get_Name)(/*[out, retval]*/ BSTR *pbstrName);
	STDMETHOD(put_Name)(/*[in]*/ BSTR bstrName);

private:
	CComBSTR	m_bstrOfficeLocation;
	CComBSTR	m_bstrStreetAddress;
	CComBSTR	m_bstrOfficePhone;
	CComBSTR	m_bstrBillingCode;
	CComBSTR	m_bstrDepartment;
	CComBSTR	m_bstrHomePhone;
	CComBSTR	m_bstrCompany;
	CComBSTR	m_bstrCountry;
	CComBSTR	m_bstrZipCode;
	CComBSTR	m_bstrEmail;
	CComBSTR	m_bstrState;
	CComBSTR	m_bstrTitle;
	CComBSTR	m_bstrCity;
	CComBSTR	m_bstrTSID;

    CComObject<CFaxRecipient>   m_Recipient;
};

#endif //__FAXSENDER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxsender.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxSender.cpp

Abstract:

	Implementation of Fax Sender Interface

Author:

	Iv Garber (IvG)	Apr, 2000

Revision History:

--*/

#include "stdafx.h"
#include "FaxComEx.h"
#include "FaxSender.h"
#include "..\..\inc\FaxUIConstants.h"

//
//===================== GET SENDER PROFILE =====================================
//
STDMETHODIMP
CFaxSender::GetSenderProfile(
	FAX_PERSONAL_PROFILE *pSenderProfile
)
/*++

Routine name : CFaxSender::GetSenderProfile

Routine description:

	Fills the pSenderProfile with the data of the object.

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	pSenderProfile          [out]    - the FAX_PERSONAL_PROFILE struct to fill

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxSender::GetSenderProfile"), hr);

    //
    //  First fill the Recipient's fields
    //
    hr = m_Recipient.GetRecipientProfile(pSenderProfile);
    if (FAILED(hr))
    {
		CALL_FAIL(GENERAL_ERR, _T("m_Recipient.GetRecipientProfile(pSenderProfile)"), hr);
        return hr;
    }

    //
    //  now add Sender's fields
    //
	pSenderProfile->lptstrCity		        = m_bstrCity;
	pSenderProfile->lptstrCompany	        = m_bstrCompany;
	pSenderProfile->lptstrCountry	        = m_bstrCountry;
	pSenderProfile->lptstrEmail		        = m_bstrEmail;
	pSenderProfile->lptstrState		        = m_bstrState;
	pSenderProfile->lptstrTitle		        = m_bstrTitle;
	pSenderProfile->lptstrTSID		        = m_bstrTSID;
	pSenderProfile->lptstrZip		        = m_bstrZipCode;
	pSenderProfile->lptstrHomePhone	        = m_bstrHomePhone;
	pSenderProfile->lptstrDepartment        = m_bstrDepartment;
	pSenderProfile->lptstrBillingCode       = m_bstrBillingCode;
	pSenderProfile->lptstrOfficePhone	    = m_bstrOfficePhone;
	pSenderProfile->lptstrOfficeLocation    = m_bstrOfficeLocation;
	pSenderProfile->lptstrStreetAddress	    = m_bstrStreetAddress;

	return hr;
}

//
//============== PUT SENDER PROFILE ============================================
//
STDMETHODIMP
CFaxSender::PutSenderProfile(
	FAX_PERSONAL_PROFILE *pSenderProfile
)
/*++

Routine name : CFaxSender::PutSenderProfile

Routine description:

	Receives FAX_PERSONAL_PROFILE structure and fills the Object's fields.

Author:

	Iv Garber (IvG),	May, 2000

Arguments:

	pSenderProfile          [in]    - the data to put into the object's variables

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (TEXT("CFaxSender::PutSenderProfile"), hr);

    //
    //  First put the Recipient fields
    //
    hr = m_Recipient.PutRecipientProfile(pSenderProfile);
    if (FAILED(hr))
    {
        //
        //  PutRecipientProfile handles the error case
        //
		CALL_FAIL(GENERAL_ERR, _T("m_Recipient.PutRecipientProfile(pSenderProfile)"), hr);
        return hr;
    }

    //
    //  Now set Sender's fields
    //
	m_bstrCity		=	pSenderProfile->lptstrCity;
	m_bstrCompany	=	pSenderProfile->lptstrCompany;
	m_bstrCountry	=	pSenderProfile->lptstrCountry;
	m_bstrEmail		=	pSenderProfile->lptstrEmail;
	m_bstrHomePhone	=	pSenderProfile->lptstrHomePhone;
	m_bstrState		=	pSenderProfile->lptstrState;
	m_bstrZipCode	=	pSenderProfile->lptstrZip;
	m_bstrTitle		=	pSenderProfile->lptstrTitle;
	m_bstrTSID		=	pSenderProfile->lptstrTSID;
	m_bstrBillingCode	=	pSenderProfile->lptstrBillingCode;
	m_bstrDepartment	=	pSenderProfile->lptstrDepartment;
	m_bstrStreetAddress	=	pSenderProfile->lptstrStreetAddress;
	m_bstrOfficePhone	=	pSenderProfile->lptstrOfficePhone;
	m_bstrOfficeLocation	=	pSenderProfile->lptstrOfficeLocation;

	if ((pSenderProfile->lptstrCity && !m_bstrCity) ||
		(pSenderProfile->lptstrCompany && !m_bstrCompany) ||
		(pSenderProfile->lptstrCountry && !m_bstrCountry) ||
		(pSenderProfile->lptstrEmail && !m_bstrEmail) ||
		(pSenderProfile->lptstrHomePhone && !m_bstrHomePhone) ||
		(pSenderProfile->lptstrState && !m_bstrState) ||
		(pSenderProfile->lptstrZip && !m_bstrZipCode) ||
		(pSenderProfile->lptstrTSID && !m_bstrTSID) ||
		(pSenderProfile->lptstrBillingCode && !m_bstrBillingCode) ||
		(pSenderProfile->lptstrDepartment && !m_bstrDepartment) ||
		(pSenderProfile->lptstrStreetAddress && !m_bstrStreetAddress) ||
		(pSenderProfile->lptstrOfficePhone && !m_bstrOfficePhone) ||
		(pSenderProfile->lptstrOfficeLocation && !m_bstrOfficeLocation))
	{
		//
		//	Not enough memory
		//
		hr = E_OUTOFMEMORY;
		CALL_FAIL(MEM_ERR, _T("CComBSTR::operator=()"), hr);
	}

	return hr;
}
	
//
//==================== DEFAULT SENDER ===================================
//
STDMETHODIMP 
CFaxSender::LoadDefaultSender ( 
)
/*++

Routine name : CFaxSender::LoadDefaultSender

Routine description:

	Load Default Sender Information from the local Registry

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	NONE

Return Value:

    Standard HRESULT code

--*/
{
	FAX_PERSONAL_PROFILE	DefaultSenderProfile;
	HRESULT					hr;

	DBG_ENTER (TEXT("CFaxSender::LoadDefaultSender"), hr);

	DefaultSenderProfile.dwSizeOfStruct = sizeof(FAX_PERSONAL_PROFILE);

	hr = FaxGetSenderInformation(&DefaultSenderProfile);
	if (FAILED(hr))
	{
		//
		//	Failed to get Sender Information
		//
		AtlReportError(CLSID_FaxSender, 
			GetErrorMsgId(hr), 
			IID_IFaxSender, 
			hr, 
			_Module.GetResourceInstance());
		CALL_FAIL(GENERAL_ERR, _T("FaxGetSenderInformation()"), hr);
		return hr;
	}

	hr = PutSenderProfile(&DefaultSenderProfile);
	if (FAILED(hr))
	{
		//
		//	Not Enough Memory
		//
		AtlReportError(CLSID_FaxSender, 
			IDS_ERROR_OUTOFMEMORY, 
			IID_IFaxSender, 
			hr, 
			_Module.GetResourceInstance());
		//
		// no return, we still need to free information
		//
	}

	HRESULT hr1 = FaxFreeSenderInformation(&DefaultSenderProfile);
	if (FAILED(hr1))
	{
		hr = hr1;
		CALL_FAIL(GENERAL_ERR, _T("FaxFreeSenderInformation()"), hr);
		return hr;
	}

	return hr;
}

//
//	SaveAs
//
STDMETHODIMP 
CFaxSender::SaveDefaultSender (
)
/*++

Routine name : CFaxSender::SaveDefaultSender

Routine description:

	Save current Profile as the Default in the Local Registry

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	NONE

Return Value:

    Standard HRESULT code

--*/

{
	FAX_PERSONAL_PROFILE	DefaultSenderProfile;
	HRESULT					hr;

	DBG_ENTER (TEXT("CFaxSender::SaveDefaultSender"), hr);
	
	hr = GetSenderProfile(&DefaultSenderProfile);
	ATLASSERT(SUCCEEDED(hr));

	hr = FaxSetSenderInformation(&DefaultSenderProfile);
	if (FAILED(hr))
	{
		AtlReportError(CLSID_FaxSender, 
			GetErrorMsgId(hr), 
			IID_IFaxSender, 
			hr, 
			_Module.GetResourceInstance());
		CALL_FAIL(GENERAL_ERR, _T("FaxSetSenderInformation()"), hr);
		return hr;
	}

	return hr;
}

//
//==================== INTERFACE SUPPORT ERROR INFO =====================
//
STDMETHODIMP 
CFaxSender::InterfaceSupportsErrorInfo (
	REFIID riid
)
/*++

Routine name : CFaxSender::InterfaceSupportsErrorInfo

Routine description:

	ATL's implementation of Support Error Info

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	riid                          [in]    - Interface ID

Return Value:

    Standard HRESULT code

--*/
{
	static const IID* arr[] = 
	{
		&IID_IFaxSender
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

//
//==================== CREATE ========================================
//
HRESULT 
CFaxSender::Create (
	IFaxSender **ppSender
)
/*++

Routine name : CFaxSender::Create

Routine description:

	Static function to create the Fax Sender Instance

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	ppSender             [out]  -- the new Fax Sender Instance

Return Value:

    Standard HRESULT code

--*/

{
	CComObject<CFaxSender>		*pClass;
	HRESULT								hr = S_OK;

	DBG_ENTER (TEXT("CFaxSender::Create"), hr);

	hr = CComObject<CFaxSender>::CreateInstance(&pClass);
	if (FAILED(hr))
	{
		//
		//	Failed to create Instance
		//
		CALL_FAIL(GENERAL_ERR, _T("CComObject<CFaxSender>::CreateInstance()"), hr);
		return hr;
	}

	hr = pClass->QueryInterface(__uuidof(IFaxSender), (void **) ppSender);
	if (FAILED(hr))
	{
		CALL_FAIL(GENERAL_ERR, _T("QueryInterface()"), hr);
		return hr;
	}

	return hr;
}

//
//==================== BILLING CODE ========================================
//
STDMETHODIMP 
CFaxSender::get_BillingCode(
	BSTR *pbstrBillingCode
)
/*++

Routine name : CFaxSender::get_BillingCode

Routine description:

	return Billing Code

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pbstrBillingCode              [out]    - the Billing Code

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT hr = S_OK;
	DBG_ENTER (TEXT("CFaxSender::get_BillingCode"), hr);

    hr = GetBstr(pbstrBillingCode, m_bstrBillingCode);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxSender, GetErrorMsgId(hr), IID_IFaxSender, hr, _Module.GetResourceInstance());
        return hr;
    }
	return hr;
}

STDMETHODIMP 
CFaxSender::put_BillingCode (
	BSTR bstrBillingCode
)
/*++

Routine name : CFaxSender::put_BillingCode

Routine description:

	Set Billing Code

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	bstrBillingCode               [in]    - new Billing Code value

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;

	DBG_ENTER (_T("CFaxSender::put_BillingCode"), 
		hr, 
		_T("%s"), 
		bstrBillingCode);

	m_bstrBillingCode = bstrBillingCode;
	if (bstrBillingCode && !m_bstrBillingCode)
	{
		//
		//	Not enough memory
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxSender, 
			IDS_ERROR_OUTOFMEMORY, 
			IID_IFaxSender, 
			hr, 
			_Module.GetResourceInstance());
		CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
		return hr;
	}

	return hr;
}

//
//==================== CITY ========================================
//
STDMETHODIMP 
CFaxSender::get_City(
	BSTR *pbstrCity
)
/*++

Routine name : CFaxSender::get_City

Routine description:

	return City

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pbstrCity              [out]    - the City

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT hr = S_OK;
	DBG_ENTER (TEXT("CFaxSender::get_City"), hr);

    hr = GetBstr(pbstrCity, m_bstrCity);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxSender, GetErrorMsgId(hr), IID_IFaxSender, hr, _Module.GetResourceInstance());
        return hr;
    }
	return hr;
}

STDMETHODIMP 
CFaxSender::put_City (
	BSTR bstrCity
)
/*++

Routine name : CFaxSender::put_City

Routine description:

	Set City

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	bstrCity               [in]    - new City value

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxSender::put_City"), hr, _T("%s"), bstrCity);

	m_bstrCity = bstrCity;
	if (!m_bstrCity && bstrCity)
	{
		//
		//	Not enough memory
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxSender, 
			IDS_ERROR_OUTOFMEMORY, 
			IID_IFaxSender, 
			hr, 
			_Module.GetResourceInstance());
		CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
		return hr;
	}

	return hr;
}

//
//==================== COMPANY ========================================
//
STDMETHODIMP 
CFaxSender::get_Company(
	BSTR *pbstrCompany
)
/*++

Routine name : CFaxSender::get_Company

Routine description:

	return Company

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pbstrCompany              [out]    - the Company

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT hr = S_OK;
	DBG_ENTER (TEXT("CFaxSender::get_Company"), hr);

    hr = GetBstr(pbstrCompany, m_bstrCompany);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxSender, GetErrorMsgId(hr), IID_IFaxSender, hr, _Module.GetResourceInstance());
        return hr;
    }
	return hr;
}

STDMETHODIMP 
CFaxSender::put_Company (
	BSTR bstrCompany
)
/*++

Routine name : CFaxSender::put_Company

Routine description:

	Set Company

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	bstrCompany               [in]    - new Company value

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxSender::put_Company"), hr, _T("%s"), bstrCompany);

	m_bstrCompany = bstrCompany;
	if (!m_bstrCompany && bstrCompany)
	{
		//
		//	Not enough memory
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxSender, IDS_ERROR_OUTOFMEMORY, IID_IFaxSender, hr, _Module.GetResourceInstance());
		CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
		return hr;
	}

	return hr;
}

//
//==================== COUNTRY ========================================
//
STDMETHODIMP 
CFaxSender::get_Country(
	BSTR *pbstrCountry
)
/*++

Routine name : CFaxSender::get_Country

Routine description:

	return Country

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pbstrCountry	            [out]    - the Country

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT hr = S_OK;
	DBG_ENTER (TEXT("CFaxSender::get_Country"), hr);

    hr = GetBstr(pbstrCountry, m_bstrCountry);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxSender, GetErrorMsgId(hr), IID_IFaxSender, hr, _Module.GetResourceInstance());
        return hr;
    }
	return hr;
}

STDMETHODIMP 
CFaxSender::put_Country (
	BSTR bstrCountry
)
/*++

Routine name : CFaxSender::put_Country

Routine description:

	Set Country

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	bstrCountry               [in]    - new Country value

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxSender::put_Country"), hr, _T("%s"), bstrCountry);

	m_bstrCountry = bstrCountry;
	if (!m_bstrCountry && bstrCountry)
	{
		//
		//	Not enough memory
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxSender, 
			IDS_ERROR_OUTOFMEMORY, 
			IID_IFaxSender, 
			hr, 
			_Module.GetResourceInstance());
		CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
		return hr;
	}

	return hr;
}

//
//==================== DEPARTMENT ========================================
//
STDMETHODIMP 
CFaxSender::get_Department(
	BSTR *pbstrDepartment
)
/*++

Routine name : CFaxSender::get_Department

Routine description:

	return Department

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pbstrDepartment	            [out]    - the Department

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT hr = S_OK;
	DBG_ENTER (TEXT("CFaxSender::get_Department"), hr);

    hr = GetBstr(pbstrDepartment, m_bstrDepartment);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxSender, GetErrorMsgId(hr), IID_IFaxSender, hr, _Module.GetResourceInstance());
        return hr;
    }
	return hr;
}

STDMETHODIMP 
CFaxSender::put_Department (
	BSTR bstrDepartment
)
/*++

Routine name : CFaxSender::put_Department

Routine description:

	Set Department

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	bstrDepartment               [in]    - new Department value

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxSender::put_Department"), hr, _T("%s"), bstrDepartment);

	m_bstrDepartment = bstrDepartment;
	if (!m_bstrDepartment && bstrDepartment)
	{
		//
		//	Not enough memory
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxSender, 
			IDS_ERROR_OUTOFMEMORY, 
			IID_IFaxSender, 
			hr, 
			_Module.GetResourceInstance());
		CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
		return hr;
	}

	return hr;
}

//
//==================== EMAIL ========================================
//
STDMETHODIMP 
CFaxSender::get_Email(
	BSTR *pbstrEmail
)
/*++

Routine name : CFaxSender::get_Email

Routine description:

	return Email

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pbstrEmail	            [out]    - the Email

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT hr = S_OK;
	DBG_ENTER (TEXT("CFaxSender::get_Email"), hr);

    hr = GetBstr(pbstrEmail, m_bstrEmail);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxSender, GetErrorMsgId(hr), IID_IFaxSender, hr, _Module.GetResourceInstance());
        return hr;
    }
	return hr;
}

STDMETHODIMP 
CFaxSender::put_Email (
	BSTR bstrEmail
)
/*++

Routine name : CFaxSender::put_Email

Routine description:

	Set Email

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	bstrEmail               [in]    - new Email value

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxSender::put_Email"), hr, _T("%s"), bstrEmail);

	m_bstrEmail = bstrEmail;
	if (!m_bstrEmail && bstrEmail)
	{
		//
		//	Not enough memory
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxSender, 
			IDS_ERROR_OUTOFMEMORY, 
			IID_IFaxSender, 
			hr, 
			_Module.GetResourceInstance());
		CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
		return hr;
	}

	return hr;
}

//
//==================== HOME PHONE ========================================
//
STDMETHODIMP 
CFaxSender::get_HomePhone(
	BSTR *pbstrHomePhone
)
/*++

Routine name : CFaxSender::get_HomePhone

Routine description:

	return HomePhone

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pbstrHomePhone	            [out]    - the HomePhone

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT hr = S_OK;
	DBG_ENTER (TEXT("CFaxSender::get_HomePhone"), hr);

    hr = GetBstr(pbstrHomePhone, m_bstrHomePhone);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxSender, GetErrorMsgId(hr), IID_IFaxSender, hr, _Module.GetResourceInstance());
        return hr;
    }
	return hr;
}

STDMETHODIMP 
CFaxSender::put_HomePhone (
	BSTR bstrHomePhone
)
/*++

Routine name : CFaxSender::put_HomePhone

Routine description:

	Set HomePhone

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	bstrHomePhone               [in]    - new HomePhone

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxSender::put_HomePhone"), hr, _T("%s"), bstrHomePhone);

	m_bstrHomePhone = bstrHomePhone;
	if (!m_bstrHomePhone && bstrHomePhone)
	{
		//
		//	Not enough memory
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxSender, 
			IDS_ERROR_OUTOFMEMORY, 
			IID_IFaxSender, 
			hr, 
			_Module.GetResourceInstance());
		CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
		return hr;
	}

	return hr;
}


//
//==================== TSID ========================================
//
STDMETHODIMP 
CFaxSender::get_TSID(
	BSTR *pbstrTSID
)
/*++

Routine name : CFaxSender::get_TSID

Routine description:

	return TSID

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pbstrTSID	            [out]    - the TSID

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT hr = S_OK;
	DBG_ENTER (TEXT("CFaxSender::get_TSID"), hr);

    hr = GetBstr(pbstrTSID, m_bstrTSID);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxSender, GetErrorMsgId(hr), IID_IFaxSender, hr, _Module.GetResourceInstance());
        return hr;
    }
	return hr;
}

STDMETHODIMP 
CFaxSender::put_TSID (
	BSTR bstrTSID
)
/*++

Routine name : CFaxSender::put_TSID

Routine description:

	Set TSID

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	bstrTSID               [in]    - new TSID

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxSender::put_TSID"), hr, _T("%s"), bstrTSID);

    if (SysStringLen(bstrTSID) > FXS_TSID_CSID_MAX_LENGTH)
    {
		//
		//	Out of the Range
		//
		hr = E_INVALIDARG;
		AtlReportError(CLSID_FaxSender, IDS_ERROR_OUTOFRANGE, IID_IFaxSender, hr, _Module.GetResourceInstance());
		CALL_FAIL(GENERAL_ERR, _T("TSID is too long"), hr);
		return hr;
    }
    
    m_bstrTSID = bstrTSID;
	if (!m_bstrTSID && bstrTSID)
	{
		//
		//	Not enough memory
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxSender, 
			IDS_ERROR_OUTOFMEMORY, 
			IID_IFaxSender, 
			hr, 
			_Module.GetResourceInstance());
		CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
		return hr;
	}

	return hr;
}

//
//==================== OFFICE PHONE ========================================
//
STDMETHODIMP 
CFaxSender::get_OfficePhone(
	BSTR *pbstrOfficePhone
)
/*++

Routine name : CFaxSender::get_OfficePhone

Routine description:

	return OfficePhone

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pbstrOfficePhone	            [out]    - the OfficePhone

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT hr = S_OK;
	DBG_ENTER (TEXT("CFaxSender::get_OfficePhone"), hr);
		
    hr = GetBstr(pbstrOfficePhone, m_bstrOfficePhone);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxSender, GetErrorMsgId(hr), IID_IFaxSender, hr, _Module.GetResourceInstance());
        return hr;
    }
	return hr;
}

STDMETHODIMP 
CFaxSender::put_OfficePhone (
	BSTR bstrOfficePhone
)
/*++

Routine name : CFaxSender::put_OfficePhone

Routine description:

	Set OfficePhone

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	bstrOfficePhone               [in]    - new OfficePhone

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxSender::put_OfficePhone"), hr, _T("%s"), bstrOfficePhone);

	m_bstrOfficePhone = bstrOfficePhone;
	if (!m_bstrOfficePhone && bstrOfficePhone)
	{
		//
		//	Not enough memory
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxSender, 
			IDS_ERROR_OUTOFMEMORY, 
			IID_IFaxSender, 
			hr, _Module.GetResourceInstance());
		CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
		return hr;
	}

	return hr;
}

//
//==================== OFFICE LOCATION ========================================
//
STDMETHODIMP 
CFaxSender::get_OfficeLocation(
	BSTR *pbstrOfficeLocation
)
/*++

Routine name : CFaxSender::get_OfficeLocation

Routine description:

	return OfficeLocation

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pbstrOfficeLocation	            [out]    - the OfficeLocation

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT hr = S_OK;
	DBG_ENTER (TEXT("CFaxSender::get_OfficeLocation"), hr);

    hr = GetBstr(pbstrOfficeLocation, m_bstrOfficeLocation);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxSender, GetErrorMsgId(hr), IID_IFaxSender, hr, _Module.GetResourceInstance());
        return hr;
    }
	return hr;
}

STDMETHODIMP 
CFaxSender::put_OfficeLocation (
	BSTR bstrOfficeLocation
)
/*++

Routine name : CFaxSender::put_OfficeLocation

Routine description:

	Set OfficeLocation

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	bstrOfficeLocation               [in]    - new OfficeLocation

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxSender::put_OfficeLocation"), hr, _T("%s"), bstrOfficeLocation);

	m_bstrOfficeLocation = bstrOfficeLocation;
	if (!m_bstrOfficeLocation && bstrOfficeLocation)
	{
		//
		//	Not enough memory
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxSender, 
			IDS_ERROR_OUTOFMEMORY, 
			IID_IFaxSender, 
			hr, 
			_Module.GetResourceInstance());
		CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
		return hr;
	}

	return hr;
}

//
//==================== STATE ========================================
//
STDMETHODIMP 
CFaxSender::get_State(
	BSTR *pbstrState
)
/*++

Routine name : CFaxSender::get_State

Routine description:

	return State

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pbstrState	            [out]    - the State

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT hr = S_OK;
	DBG_ENTER (TEXT("CFaxSender::get_State"), hr);

    hr = GetBstr(pbstrState, m_bstrState);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxSender, GetErrorMsgId(hr), IID_IFaxSender, hr, _Module.GetResourceInstance());
        return hr;
    }
	return hr;
}

STDMETHODIMP 
CFaxSender::put_State (
	BSTR bstrState
)
/*++

Routine name : CFaxSender::put_State

Routine description:

	Set State

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	bstrState				[in]    - new State

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxSender::put_State"), hr, _T("%s"), bstrState);

	m_bstrState = bstrState;
	if (!m_bstrState && bstrState)
	{
		//
		//	Not enough memory
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxSender, 
			IDS_ERROR_OUTOFMEMORY, 
			IID_IFaxSender, 
			hr, 
			_Module.GetResourceInstance());
		CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
		return hr;
	}

	return hr;
}

//
//==================== STREET ADDRESS ========================================
//
STDMETHODIMP 
CFaxSender::get_StreetAddress (
	BSTR *pbstrStreetAddress
)
/*++

Routine name : CFaxSender::get_StreetAddress

Routine description:

	return StreetAddress

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pbstrStreetAddress	            [out]    - the StreetAddress

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT hr = S_OK;
	DBG_ENTER (TEXT("CFaxSender::get_StreetAddress"), hr);

    hr = GetBstr(pbstrStreetAddress, m_bstrStreetAddress);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxSender, GetErrorMsgId(hr), IID_IFaxSender, hr, _Module.GetResourceInstance());
        return hr;
    }
	return hr;
}

STDMETHODIMP 
CFaxSender::put_StreetAddress (
	BSTR bstrStreetAddress
)
/*++

Routine name : CFaxSender::put_StreetAddress

Routine description:

	Set StreetAddress

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	bstrStreetAddress				[in]    - new StreetAddress

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxSender::put_StreetAddress"), hr, _T("%s"), bstrStreetAddress);

	m_bstrStreetAddress = bstrStreetAddress;
	if (!m_bstrStreetAddress && bstrStreetAddress)
	{
		//
		//	Not enough memory
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxSender, 
			IDS_ERROR_OUTOFMEMORY, 
			IID_IFaxSender, 
			hr, 
			_Module.GetResourceInstance());
		CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
		return hr;
	}

	return hr;
}

//
//==================== TITLE ========================================
//
STDMETHODIMP 
CFaxSender::get_Title (
	BSTR *pbstrTitle
)
/*++

Routine name : CFaxSender::get_Title

Routine description:

	return Title

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pbstrTitle	            [out]    - the Title

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT hr = S_OK;
	DBG_ENTER (TEXT("CFaxSender::get_Title"), hr);

    hr = GetBstr(pbstrTitle, m_bstrTitle);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxSender, GetErrorMsgId(hr), IID_IFaxSender, hr, _Module.GetResourceInstance());
        return hr;
    }
	return hr;
}

STDMETHODIMP 
CFaxSender::put_Title (
	BSTR bstrTitle
)
/*++

Routine name : CFaxSender::put_Title

Routine description:

	Set Title

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	bstrTitle				[in]    - new Title

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxSender::put_Title"), hr, _T("%s"), bstrTitle);

	m_bstrTitle = bstrTitle;
	if (!m_bstrTitle && bstrTitle)
	{
		//
		//	Not enough memory
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxSender, 
			IDS_ERROR_OUTOFMEMORY, 
			IID_IFaxSender, 
			hr, 
			_Module.GetResourceInstance());
		CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
		return hr;
	}

	return hr;
}

//
//==================== ZIP CODE ========================================
//
STDMETHODIMP 
CFaxSender::get_ZipCode (
	BSTR *pbstrZipCode
)
/*++

Routine name : CFaxSender::get_ZipCode

Routine description:

	return ZipCode

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pbstrZipCode	            [out]    - the ZipCode

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT hr = S_OK;
	DBG_ENTER (TEXT("CFaxSender::get_ZipCode"), hr);

    hr = GetBstr(pbstrZipCode, m_bstrZipCode);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxSender, GetErrorMsgId(hr), IID_IFaxSender, hr, _Module.GetResourceInstance());
        return hr;
    }
	return hr;
}

STDMETHODIMP 
CFaxSender::put_ZipCode (
	BSTR bstrZipCode
)
/*++

Routine name : CFaxSender::put_ZipCode

Routine description:

	Set ZipCode

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	bstrZipCode				[in]    - new ZipCode

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxSender::put_ZipCode"), hr, _T("%s"), bstrZipCode);

	m_bstrZipCode = bstrZipCode;
	if (!m_bstrZipCode && bstrZipCode)
	{
		//
		//	Not enough memory
		//
		hr = E_OUTOFMEMORY;
		AtlReportError(CLSID_FaxSender, 
			IDS_ERROR_OUTOFMEMORY, 
			IID_IFaxSender, 
			hr, 
			_Module.GetResourceInstance());
		CALL_FAIL(MEM_ERR, _T("CComBSTR::operator="), hr);
		return hr;
	}

	return hr;
}


//
//==================== FAX NUMBER ========================================
//
STDMETHODIMP 
CFaxSender::get_FaxNumber(
	BSTR *pbstrFaxNumber
)
/*++

Routine name : CFaxSender::get_FaxNumber

Routine description:

	return FaxNumber

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pbstrFaxNumber	            [out]    - the FaxNumber

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT hr = S_OK;
	DBG_ENTER (_T("CFaxSender::get_FaxNumber"), hr);

    hr = m_Recipient.get_FaxNumber(pbstrFaxNumber);
    return hr;
}

STDMETHODIMP 
CFaxSender::put_FaxNumber (
	BSTR bstrFaxNumber
)
/*++

Routine name : CFaxSender::put_FaxNumber

Routine description:

	Set FaxNumber

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	bstrFaxNumber               [in]    - new Fax Number 

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER(_T("CFaxSender::put_FaxNumber"), hr, _T("%s"), bstrFaxNumber);

	hr = m_Recipient.put_FaxNumber(bstrFaxNumber);
	return hr;
}


//
//==================== NAME ========================================
//
STDMETHODIMP 
CFaxSender::get_Name(
	BSTR *pbstrName
)
/*++

Routine name : CFaxSender::get_Name

Routine description:

	return Name

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	pbstrName	            [out]    - the Name

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT hr = S_OK;
	DBG_ENTER (_T("CFaxSender::get_Name"), hr);

    hr = m_Recipient.get_Name(pbstrName);
	return hr;
}

STDMETHODIMP 
CFaxSender::put_Name (
	BSTR bstrName
)
/*++

Routine name : CFaxSender::put_Name

Routine description:

	Set Name

Author:

	Iv Garber (IvG),	Apr, 2000

Arguments:

	bstrName               [in]    - new Name

Return Value:

    Standard HRESULT code

--*/
{
	HRESULT		hr = S_OK;
	DBG_ENTER (_T("CFaxSender::put_Name"), hr, _T("%s"), bstrName);

	hr = m_Recipient.put_Name(bstrName);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxserver.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    FaxServer.cpp

Abstract:

    Implementation of CFaxServer

Author:

    Iv Garber (IvG) Apr, 2000

Revision History:

--*/

#include "stdafx.h"
#include "FaxComEx.h"
#include "FaxServer.h"
#include "FaxDevices.h"
#include "FaxDeviceProviders.h"

//
//================== GET API VERSION ==============================
//
STDMETHODIMP
CFaxServer::get_APIVersion(
    /*[out, retval]*/ FAX_SERVER_APIVERSION_ENUM *pAPIVersion
)
/*++

Routine name : CFaxServer::get_APIVersion

Routine description:

    Return API Version of the Fax Server.

Author:

    Iv Garber (IvG),    May, 2001

Arguments:

    pAPIVersion                [out]    - ptr to the place to put the API Version of the Fax Server 

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxServer::get_APIVersion"), hr);

    if (!m_bVersionValid)
    {
        //
        //  get Version of the Server
        //
        hr = GetVersion();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    //
    //  Check the pointer we have got
    //
    if (::IsBadWritePtr(pAPIVersion, sizeof(FAX_SERVER_APIVERSION_ENUM))) 
    {
        //
        //  Got a bad return pointer
        //
        hr = E_POINTER;
        Error(GetErrorMsgId(hr), IID_IFaxServer, hr); 
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr()"), hr);
        return hr;
    }

    *pAPIVersion = m_APIVersion;
    return hr;
}

//
//====================== CLEAR NOTIFY WINDOW ============================
//
void 
CFaxServer::ClearNotifyWindow(void)
/*++

Routine name : CFaxServer::ClearNotifyWindow

Routine description:

    Clear Notify Window.

Author:

    Iv Garber (IvG),    Jul, 2000

Arguments:

    None.

Return Value:

    None.

--*/
{
    if (m_pNotifyWindow && ::IsWindow(m_pNotifyWindow->m_hWnd))
    {
        m_pNotifyWindow->DestroyWindow();
    }

    if (m_pNotifyWindow)
    {
        delete m_pNotifyWindow;
        m_pNotifyWindow = NULL;
    }
    return;
}

//
//====================== PROCESS JOB NOTIFICATION =======================
//
HRESULT
CFaxServer::ProcessJobNotification(
    /*[in]*/ DWORDLONG   dwlJobId,
    /*[in]*/ FAX_ENUM_JOB_EVENT_TYPE eventType,
    /*[in]*/ LOCATION place,
    /*[in]*/ FAX_JOB_STATUS *pJobStatus
)
/*++

Routine name : CFaxServer::ProcessJobNotification

Routine description:

    Call appropriate Fire Method, for Jobs/Messages in Queues/Archives.

Author:

    Iv Garber (IvG),    Jul, 2000

Arguments:

    dwlJobId                      [in]    - Id of the Job/Message
    eventType                     [in]    - Type of the Event
    place                         [in]    - Where the Job/Message sits
    pJobStatus                    [in]    - FAX_JOB_STATUS structure

Return Value:

    Standard HRESULT value.

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxServer::ProcessJobNotification"), 
        hr, 
        _T("JOBID=%ld EVENTTYPE=%ld PLACE=%d"), 
        dwlJobId, 
        eventType, 
        place);

    //
    //  Convert JobId from DWORDLONG into BSTR 
    //
    CComBSTR bstrJobId;
    hr = GetBstrFromDwordlong(dwlJobId,  &bstrJobId);
    if (FAILED(hr))
    {
        CALL_FAIL(GENERAL_ERR, _T("GetBstrFromDwordlong(dwlJobId, &bstrJobId)"), hr);
        return hr;
    }

    //
    //  Check Type of the Event that happened
    //
    switch (eventType)
    {
    case FAX_JOB_EVENT_TYPE_ADDED:

        switch (place)
        {
        case IN_QUEUE:
            hr = Fire_OnIncomingJobAdded(this, bstrJobId);
            break;
        case OUT_QUEUE:
            hr = Fire_OnOutgoingJobAdded(this, bstrJobId);
            break;
        case IN_ARCHIVE:
            hr = Fire_OnIncomingMessageAdded(this, bstrJobId);
            break;
        case OUT_ARCHIVE:
            hr = Fire_OnOutgoingMessageAdded(this, bstrJobId);
            break;
        default:
            //
            //  assert (FALSE)
            //
            ATLASSERT(place == IN_QUEUE);  
            hr = E_FAIL;
            return hr;
        }

        if (FAILED(hr))
        {
            CALL_FAIL(GENERAL_ERR, _T("Fire_On In/Out Job/Message Added(this, bstrJobId)"), hr);
            return hr;
        }
        break;
    case FAX_JOB_EVENT_TYPE_REMOVED:

        switch (place)
        {
        case IN_QUEUE:
            hr = Fire_OnIncomingJobRemoved(this, bstrJobId);
            break;
        case OUT_QUEUE:
            hr = Fire_OnOutgoingJobRemoved(this, bstrJobId);
            break;
        case IN_ARCHIVE:
            hr = Fire_OnIncomingMessageRemoved(this, bstrJobId);
            break;
        case OUT_ARCHIVE:
            hr = Fire_OnOutgoingMessageRemoved(this, bstrJobId);
            break;
        default:
            //
            //  assert (FALSE)
            //
            ATLASSERT(place == IN_QUEUE);  
            hr = E_FAIL;
            return hr;
        }

        if (FAILED(hr))
        {
            CALL_FAIL(GENERAL_ERR, _T("Fire_On In/Out Job/Message Removed(this, bstrJobId)"), hr);
            return hr;
        }
        break;
    case FAX_JOB_EVENT_TYPE_STATUS:
        {
            ATLASSERT(pJobStatus);

            //
            //  Create Job Status Object to pass to the Events
            //
            CComObject<CFaxJobStatus>   *pJobStatusClass = NULL;
            pJobStatusClass = new CComObject<CFaxJobStatus>;
            if (!pJobStatusClass)
            {
                //
                //  Out of Memory
                //
                CALL_FAIL(MEM_ERR, _T("new CComObject<CFaxJobStatus>"), hr);
                return hr;
            }

            //
            //  Init the Object
            //
            hr = pJobStatusClass->Init(pJobStatus);
            if (FAILED(hr))
            {
                CALL_FAIL(GENERAL_ERR, _T("pJobStatusClass->Init(pJobStatus)"), hr);
                delete pJobStatusClass;
                return hr;
            }

            //
            //  Query the Interface from the Object
            //
            CComPtr<IFaxJobStatus>      pFaxJobStatus = NULL;
            hr = pJobStatusClass->QueryInterface(IID_IFaxJobStatus, (void **) &pFaxJobStatus);
            if (FAILED(hr) || !pFaxJobStatus)
            {
                CALL_FAIL(GENERAL_ERR, _T("pJobStatusClass->QueryInterface(pFaxJobStatus)"), hr);
                delete pJobStatusClass;
                return hr;
            }

            switch (place)
            {
            case IN_QUEUE:
                hr = Fire_OnIncomingJobChanged(this, bstrJobId, pFaxJobStatus);
                break;
            case OUT_QUEUE:
                hr = Fire_OnOutgoingJobChanged(this, bstrJobId, pFaxJobStatus);
                break;
            default:
                //
                //  assert (FALSE)
                //
                ATLASSERT(place == IN_QUEUE);  
                hr = E_FAIL;
                return hr;
            }

            if (FAILED(hr))
            {
                CALL_FAIL(GENERAL_ERR, _T("Fire_On In/Out JobChanged(this, bstrJobId)"), hr);
                return hr;
            }
        }
        break;

    default:
        //
        //  assert (FALSE)
        //
        ATLASSERT(eventType == FAX_JOB_EVENT_TYPE_STATUS);  
        hr = E_FAIL;
        return hr;
    }

    return hr;
}

//
//================= PROCESS MESSAGE ============================================
//
HRESULT
CFaxServer::ProcessMessage(
    FAX_EVENT_EX *pFaxEventInfo
)
/*++

Routine name : CFaxServer::ProcessMessage

Routine description:

    Fire appropriate Message

Author:

    Iv Garber (IvG),    Jul, 2000

Arguments:

    pFaxEventInfo                 [TBD]    - Information about current Event

Return Value:

    None.

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxServer::ProcessMessage"), hr);

    if (!m_faxHandle)
    {
        //
        //  Fax Server already disconnected
        //
        VERBOSE(DBG_WARNING, _T("FaxServer already disconnected."));
        return hr;
    }

    switch (pFaxEventInfo->EventType)
    {
    case FAX_EVENT_TYPE_IN_QUEUE:

        ProcessJobNotification(pFaxEventInfo->EventInfo.JobInfo.dwlMessageId, 
            pFaxEventInfo->EventInfo.JobInfo.Type, 
            IN_QUEUE,
            pFaxEventInfo->EventInfo.JobInfo.pJobData);
        break;

    case FAX_EVENT_TYPE_OUT_QUEUE:

        ProcessJobNotification(pFaxEventInfo->EventInfo.JobInfo.dwlMessageId, 
            pFaxEventInfo->EventInfo.JobInfo.Type, 
            OUT_QUEUE,
            pFaxEventInfo->EventInfo.JobInfo.pJobData);
        break;

    case FAX_EVENT_TYPE_IN_ARCHIVE:

        ProcessJobNotification(pFaxEventInfo->EventInfo.JobInfo.dwlMessageId, 
            pFaxEventInfo->EventInfo.JobInfo.Type, 
            IN_ARCHIVE);
        break;

    case FAX_EVENT_TYPE_OUT_ARCHIVE:

        ProcessJobNotification(pFaxEventInfo->EventInfo.JobInfo.dwlMessageId, 
            pFaxEventInfo->EventInfo.JobInfo.Type, 
            OUT_ARCHIVE);
        break;

    case FAX_EVENT_TYPE_CONFIG:

        switch (pFaxEventInfo->EventInfo.ConfigType)
        {
        case FAX_CONFIG_TYPE_RECEIPTS:
            hr = Fire_OnReceiptOptionsChange(this);
            break;
        case FAX_CONFIG_TYPE_ACTIVITY_LOGGING:
            hr = Fire_OnActivityLoggingConfigChange(this);
            break;
        case FAX_CONFIG_TYPE_OUTBOX:
            hr = Fire_OnOutgoingQueueConfigChange(this);
            break;
        case FAX_CONFIG_TYPE_SENTITEMS:
            hr = Fire_OnOutgoingArchiveConfigChange(this);
            break;
        case FAX_CONFIG_TYPE_INBOX:
            hr = Fire_OnIncomingArchiveConfigChange(this);
            break;
        case FAX_CONFIG_TYPE_SECURITY:
            hr = Fire_OnSecurityConfigChange(this);
            break;
        case FAX_CONFIG_TYPE_EVENTLOGS:
            hr = Fire_OnEventLoggingConfigChange(this);
            break;
        case FAX_CONFIG_TYPE_DEVICES:
            hr = Fire_OnDevicesConfigChange(this);
            break;
        case FAX_CONFIG_TYPE_OUT_GROUPS:
            hr = Fire_OnOutboundRoutingGroupsConfigChange(this);
            break;
        case FAX_CONFIG_TYPE_OUT_RULES:
            hr = Fire_OnOutboundRoutingRulesConfigChange(this);
            break;
        default:
            //
            //  assert (FALSE)
            //
            ATLASSERT(pFaxEventInfo->EventInfo.ConfigType == FAX_CONFIG_TYPE_OUT_RULES);  
            hr = E_FAIL;
            return hr;
        }

        if (FAILED(hr))
        {
            CALL_FAIL(GENERAL_ERR, _T("Fire_On <...> ConfigChange(this)"), hr);
            return hr;
        }
        break;

    case FAX_EVENT_TYPE_ACTIVITY:

        hr = Fire_OnServerActivityChange(this, 
            pFaxEventInfo->EventInfo.ActivityInfo.dwIncomingMessages,
            pFaxEventInfo->EventInfo.ActivityInfo.dwRoutingMessages,
            pFaxEventInfo->EventInfo.ActivityInfo.dwOutgoingMessages,
            pFaxEventInfo->EventInfo.ActivityInfo.dwQueuedMessages);
        if (FAILED(hr))
        {
            CALL_FAIL(GENERAL_ERR, _T("Fire_OnServerActivityChange(this, ...)"), hr);
            return hr;
        }
        break;

    case FAX_EVENT_TYPE_QUEUE_STATE:

        hr = Fire_OnQueuesStatusChange(this, 
            bool2VARIANT_BOOL(pFaxEventInfo->EventInfo.dwQueueStates & FAX_OUTBOX_BLOCKED), 
            bool2VARIANT_BOOL(pFaxEventInfo->EventInfo.dwQueueStates & FAX_OUTBOX_PAUSED),
            bool2VARIANT_BOOL(pFaxEventInfo->EventInfo.dwQueueStates & FAX_INCOMING_BLOCKED));
        if (FAILED(hr))
        {
            CALL_FAIL(GENERAL_ERR, _T("Fire_OnQueueStatusChange(this, ...)"), hr);
            return hr;
        }
        break;

    case FAX_EVENT_TYPE_NEW_CALL:
        {
            CComBSTR    bstrCallerId = pFaxEventInfo->EventInfo.NewCall.lptstrCallerId;
            if (pFaxEventInfo->EventInfo.NewCall.lptstrCallerId && !bstrCallerId)
            {
                CALL_FAIL(MEM_ERR, _T("CComBSTR::operator=()"), E_OUTOFMEMORY);
                return hr;
            }

            hr = Fire_OnNewCall(this, 
                pFaxEventInfo->EventInfo.NewCall.hCall,
                pFaxEventInfo->EventInfo.NewCall.dwDeviceId,
                bstrCallerId);
            if (FAILED(hr))
            {
                CALL_FAIL(GENERAL_ERR, _T("Fire_OnNewCall(this, ...)"), hr);
                return hr;
            }
        }
        break;

    case FAX_EVENT_TYPE_FXSSVC_ENDED:

        hr = Fire_OnServerShutDown(this);
        if (FAILED(hr))
        {
            CALL_FAIL(GENERAL_ERR, _T("Fire_OnServerShutDown(this)"), hr);
            return hr;
        }
        break;

    case FAX_EVENT_TYPE_DEVICE_STATUS:

        hr = Fire_OnDeviceStatusChange(this, 
            pFaxEventInfo->EventInfo.DeviceStatus.dwDeviceId,
            bool2VARIANT_BOOL(pFaxEventInfo->EventInfo.DeviceStatus.dwNewStatus & FAX_DEVICE_STATUS_POWERED_OFF),
            bool2VARIANT_BOOL(pFaxEventInfo->EventInfo.DeviceStatus.dwNewStatus & FAX_DEVICE_STATUS_SENDING),
            bool2VARIANT_BOOL(pFaxEventInfo->EventInfo.DeviceStatus.dwNewStatus & FAX_DEVICE_STATUS_RECEIVING),
            bool2VARIANT_BOOL(pFaxEventInfo->EventInfo.DeviceStatus.dwNewStatus & FAX_DEVICE_STATUS_RINGING));
        if (FAILED(hr))
        {
            CALL_FAIL(GENERAL_ERR, _T("Fire_OnDeviceStatusChange(this, dwDeviceId, ...)"), hr);
            return hr;
        }
        break;

    default:
        //
        //  assert (FALSE)
        //
        ATLASSERT(pFaxEventInfo->EventType == FAX_EVENT_TYPE_FXSSVC_ENDED);  
        hr = E_FAIL;
        return hr;
    }

    return hr;
}

//
//========== MESSAGE HANDLER FUNCTION ======================================
//
LRESULT 
CNotifyWindow::OnMessage(UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam, 
    BOOL& bHandled
)
/*++

Routine name : CNotifyWindow::OnMessage

Routine description:

    Get the Message and call Server's ProcessMessage.

Author:

    Iv Garber (IvG),    Jul, 2000

Arguments:

    uMsg                          [in]    - Msg Id
    wParam                        [in]    - wParam
    lParam                        [in]    - LParam
    bHandled                      [in,out]    - bHandled

Return Value:

    Standard result code

--*/
{
    DBG_ENTER(_T("CNotifyWindow::OnMessage"));

    //
    //  Check that lParam is valid
    //
    if (!lParam)
    {
        CALL_FAIL(GENERAL_ERR, _T("(!lParam)"), E_FAIL);
        return 0;
    }

    if (::IsBadReadPtr((FAX_EVENT_EX *)lParam, sizeof(FAX_EVENT_EX)))
    {
        CALL_FAIL(GENERAL_ERR, _T("(::IsBadReadPtr((FAX_EVENT_EX *)lParam, sizeof(FAX_EVENT_EX))"), E_FAIL);
        return 0;
    }

    if (((FAX_EVENT_EX *)lParam)->dwSizeOfStruct != sizeof(FAX_EVENT_EX))
    {
        CALL_FAIL(GENERAL_ERR, _T("(((FAX_EVENT_EX *)lParam)->dwSizeOfStruct != sizeof(FAX_EVENT_EX))"), E_FAIL);
        return 0;
    }

    //
    //  Call Server to Process the Message
    //
    if (m_pServer)
    {
        HRESULT hr = S_OK;
        hr = m_pServer->ProcessMessage((FAX_EVENT_EX *)lParam);
        if (FAILED(hr))
        {
            CALL_FAIL(GENERAL_ERR, _T("m_pServer->ProcessMessage()"), hr);
        }
    }

    //
    //  Free the Buffer
    //
    FaxFreeBuffer((void *)lParam);
    return 0;
}

//
//================ GET METHOD DATA ================================================
//
void
CFaxServer::GetMethodData(
    /*[in]*/ BSTR    bstrAllString,
    /*[out]*/ LPWSTR strWhereToPut
)
/*++

Routine name : CFaxServer::GetMethodData

Routine description:

    Read from bstrAllString data upto DELIMITER and store it in strWhereToPut. 
    Used in GetRegisteredData for Extension Method Registration.

Author:

    Iv Garber (IvG),    Jul, 2000

Arguments:

    bstrAllString                 [TBD]    - in subsequent calls
    strWhereToPut                 [TBD]    - where to put the value that was readed from the bstrAllString.

--*/
{
    BOOL bRes = TRUE;
    DBG_ENTER(_T("CFaxServer::GetMethodData()"));

    //
    //  Find Method Name
    //
    BSTR bstrTmp;
    bstrTmp = _tcstok(bstrAllString, DELIMITER);
    if (!bstrTmp)
    {
        CALL_FAIL(MEM_ERR, _T("_tcstok(bstrAllString, DELIMITER))"), bRes);
        RaiseException(EXCEPTION_INVALID_METHOD_DATA, 0, 0, 0);
    }

    //
    //  Check that length of the readen data
    //
    if (_tcslen(bstrTmp) > 100)
    {
        //
        //  Error : exceeds the limit
        //
        CALL_FAIL(GENERAL_ERR, _T("(_tcslen(bstrTmp) > 100)"), E_FAIL);
        RaiseException(EXCEPTION_INVALID_METHOD_DATA, 0, 0, 0);
    }

    memcpy(strWhereToPut, bstrTmp, (sizeof(TCHAR) * (_tcslen(bstrTmp) + 1)));
    return;
}

//
//============= GET REGISTERED DATA =========================================
//
BOOL
CFaxServer::GetRegisteredData(
    /*[out]*/ LPWSTR MethodName, 
    /*[out]*/ LPWSTR FriendlyName, 
    /*[out]*/ LPWSTR FunctionName, 
    /*[out]*/ LPWSTR Guid
)
/*++

Routine name : CFaxServer::GetRegisteredData

Routine description:

    Return data about specific Method being registered.

Author:

    Iv Garber (IvG),    Jul, 2000

Arguments:

    MethodName                    [TBD]    - Name of the Method
    FriendlyName                  [TBD]    - Friendly Name of the Method
    FunctionName                  [TBD]    - Function Name of the Method
    Guid                          [TBD]    - GUID of the Method

Return Value:

    TRUE if Method Data is filled ok, FALSE if all the methods already registered.

Notes:

    The function raises an exception when any error happens.    

--*/
{
    BOOL    bRes = TRUE;
    DBG_ENTER(_T("CFaxServer::GetRegisteredData"), bRes);

    //
    //  Check if we already finished the array
    //
    if (m_pRegMethods->rgsabound[0].cElements == m_lLastRegisteredMethod)
    {
        bRes = FALSE;
        CALL_FAIL(GENERAL_ERR, _T("We have reached the End of the Array"), bRes);
        return bRes;
    }

    CComBSTR    bstrMethodData;
    HRESULT hr = SafeArrayGetElement(m_pRegMethods, &m_lLastRegisteredMethod, &bstrMethodData);
    if (FAILED(hr))
    {
        CALL_FAIL(GENERAL_ERR, _T("SafeArrayGetElement(m_pRegMethods, ...)"), hr);
        RaiseException(EXCEPTION_INVALID_METHOD_DATA, 0, 0, 0);
    }

    GetMethodData(bstrMethodData, MethodName);
    GetMethodData(NULL, FriendlyName);
    GetMethodData(NULL, FunctionName);
    GetMethodData(NULL, Guid);

    //
    //  Increase the Index of the SafeArray
    //
    m_lLastRegisteredMethod++;
    return bRes;
}

//
//=================== REGISTER METHOD CALLBACK ===============================
//
BOOL CALLBACK RegisterMethodCallback(
    /*[in]*/ HANDLE FaxHandle, 
    /*[in]*/ LPVOID Context, 
    /*[out]*/ LPWSTR MethodName, 
    /*[out]*/ LPWSTR FriendlyName, 
    /*[out]*/ LPWSTR FunctionName, 
    /*[out]*/ LPWSTR Guid
)
{
    BOOL    bRes = TRUE;
    DBG_ENTER(_T("RegisterMethodCallback"), bRes);

    bRes = ((CFaxServer *)Context)->GetRegisteredData(MethodName, FriendlyName, FunctionName, Guid);
    return bRes;
}

//
//=================== LISTEN TO SERVER EVENTS ===============================
//
STDMETHODIMP
CFaxServer::ListenToServerEvents(
    /*[in]*/ FAX_SERVER_EVENTS_TYPE_ENUM EventTypes
)
/*++

Routine name : CFaxServer::ListenToServerEvents

Routine description:

    Starts or stops listening to Server Events.

Author:

    Iv Garber (IvG),    Jul, 2000

Arguments:

    EventTypes                   [in]    - Events to listen to.

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxServer::ListenToServerEvents"), hr, _T("Events=%ld"), EventTypes);

    //
    //  Check Fax Handle
    //
    if (m_faxHandle == NULL)
    {
        //
        //  Server not Connected
        //
        hr = E_HANDLE;
        Error(GetErrorMsgId(hr), IID_IFaxServer, hr); 
        CALL_FAIL(GENERAL_ERR, _T("m_FaxHandle == NULL"), hr);
        return hr;
    }

    HANDLE  hEvent = NULL;
    if (EventTypes > fsetNONE)
    {
        if (!m_pNotifyWindow)
        {
            //
            //  Create new Window
            //
            m_pNotifyWindow = new CNotifyWindow(this);
            if (!m_pNotifyWindow)
            {
                //
                //  Out of Memory
                //
                hr = E_OUTOFMEMORY;
                Error(IDS_ERROR_OUTOFMEMORY, IID_IFaxServer, hr);
                CALL_FAIL(MEM_ERR, _T("new CNotifyWindow(this)"), hr);
                return hr;
            }

            RECT    rcRect;
            ZeroMemory(&rcRect, sizeof(rcRect));

            m_pNotifyWindow->Create(NULL, rcRect, NULL, WS_POPUP, 0x0, 0);
            if (!::IsWindow(m_pNotifyWindow->m_hWnd))
            {
                //
                //  Failed to Create Window
                //
                hr = E_FAIL;
                CALL_FAIL(GENERAL_ERR, _T("m_pNotifyWindow->Create(NULL, rcRect)"), hr);
                ClearNotifyWindow();
                Error(GetErrorMsgId(hr), IID_IFaxServer, hr);
                return hr;
            }
        }

        //
        //  Register for new Set of Events 
        //
        if (!FaxRegisterForServerEvents(m_faxHandle, 
            EventTypes, 
            NULL, 
            0, 
            m_pNotifyWindow->m_hWnd, 
            m_pNotifyWindow->GetMessageId(), 
            &hEvent))
        {
            //
            //  Failed to Register given Set of Events
            //
            hr = Fax_HRESULT_FROM_WIN32(GetLastError());
            Error(GetErrorMsgId(hr), IID_IFaxServer, hr);
            CALL_FAIL(GENERAL_ERR, _T("FaxRegisterForServerEvents(m_faxHandle, lEventTypes, ...)"), hr);
            ClearNotifyWindow();
            return hr;
        }
    }

    //
    //  Unregister from the previous set of Events, if there was one
    //
    if (m_hEvent)
    {
        if (!FaxUnregisterForServerEvents(m_hEvent))
        {
            //
            //  Failed to Unregister given Set of Events
            //
            hr = Fax_HRESULT_FROM_WIN32(GetLastError());
            CALL_FAIL(GENERAL_ERR, _T("FaxUnregisterForServerEvents(m_hEvent)"), hr);

            //
            //  Return Error only when Caller specially wanted to Unregister.
            //  Otherwise, debug Warning is enough.
            //
            if (EventTypes == fsetNONE)
            {
                Error(GetErrorMsgId(hr), IID_IFaxServer, hr);
                return hr;
            }
        }
    }

    //
    //  store the new Listening HANDLE for future UNRegistration
    //
    m_hEvent = hEvent;
    if (m_hEvent == NULL)
    {
        ClearNotifyWindow();
    }
    m_EventTypes = EventTypes;
    return hr;
}

//
//=================== GET REGISTERED EVENTS ===============================
//
STDMETHODIMP
CFaxServer::get_RegisteredEvents(
    /*[out, retval]*/ FAX_SERVER_EVENTS_TYPE_ENUM *pEventTypes
)
/*++

Routine name : CFaxServer::get_RegisteredEvents

Routine description:

    Return Bit-Wise Combination of Events the Fax Server is Listening to

Author:

    Iv Garber (IvG),    Dec, 2000

Arguments:

    pEventTypes                   [out]    - the Event Types to return

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;

    DBG_ENTER(_T("CFaxServer::get_RegisteredEvents"), hr);

    //
    //  Check the Fax Service Handle
    //
    if (m_faxHandle == NULL)
    {
        //
        //  Server not Connected
        //
        hr = E_HANDLE;
        Error(GetErrorMsgId(hr), IID_IFaxServer, hr); 
        CALL_FAIL(GENERAL_ERR, _T("m_FaxHandle == NULL"), hr);
        return hr;
    }

    //
    //  Check the pointer we have got
    //
    if (::IsBadWritePtr(pEventTypes, sizeof(FAX_SERVER_EVENTS_TYPE_ENUM))) 
    {
        //
        //  Got a bad return pointer
        //
        hr = E_POINTER;
        Error(GetErrorMsgId(hr), IID_IFaxServer, hr); 
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr()"), hr);
        return hr;
    }

    *pEventTypes = m_EventTypes;
    return hr;
}


//
//=================== REGISTER DEVICE PROVIDER ===============================
//
STDMETHODIMP
CFaxServer::RegisterDeviceProvider(
    /*[in]*/ BSTR bstrGUID, 
    /*[in]*/ BSTR bstrFriendlyName,
    /*[in]*/ BSTR bstrImageName, 
    /*[in]*/ BSTR bstrTspName,
    /*[in]*/ long lFSPIVersion
)
/*++

Routine name : CFaxServer::RegisterDeviceProvider

Routine description:

    Register the FSP

Author:

    Iv Garber (IvG),    Jun, 2000

Arguments:

    bstrGUID                      [in]    - GUID of the FSP
    bstrFriendlyName              [in]    - Frienly Name of the FSP
    bstrImageName                 [in]    - Image Name of the FSP
    TspName                       [in]    - TspName of the FSP
    FSPIVersion                   [in]    - Version of the FSP interface

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxServer::RegisterDeviceProvider"), 
        hr,
        _T("GUID=%s FriendlyName=%s ImageName=%s TspNameName=%s Version=%d"), 
        bstrGUID, 
        bstrFriendlyName, 
        bstrImageName, 
        bstrTspName,
        lFSPIVersion);

    if (m_faxHandle == NULL)
    {
        //
        //  Server not Connected
        //
        hr = E_HANDLE;
        Error(GetErrorMsgId(hr), IID_IFaxServer, hr); 
        CALL_FAIL(GENERAL_ERR, _T("m_FaxHandle == NULL"), hr);
        return hr;
    }

    //
    //  Check if GUID is valid
    //
    hr = IsValidGUID(bstrGUID);
    if (FAILED(hr))
    {
        CALL_FAIL(GENERAL_ERR, _T("IsValidGUID(bstrGUID)"), hr);
        Error(GetErrorMsgId(hr), IID_IFaxServer, hr);
        return hr;
    }

    //
    //  Register the FSP
    //
    if (!FaxRegisterServiceProviderEx(m_faxHandle, 
        bstrGUID, 
        bstrFriendlyName, 
        bstrImageName, 
        bstrTspName, 
        lFSPIVersion,
        0))             //  capabilities
    {
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        Error(GetErrorMsgId(hr), IID_IFaxServer, hr);
        CALL_FAIL(GENERAL_ERR, _T("FaxRegisterServiceProviderEx(m_faxHandle, bstrUniqueName, ...)"), hr);
        return hr;
    }

    return hr;
}

//
//================= REGISTER INBOUND ROUTING EXTENSION ================================
//
STDMETHODIMP
CFaxServer::RegisterInboundRoutingExtension(
    /*[in]*/ BSTR bstrExtensionName,
    /*[in]*/ BSTR bstrFriendlyName, 
    /*[in]*/ BSTR bstrImageName, 
    /*[in]*/ VARIANT vMethods
)
/*++

Routine name : CFaxServer::RegisterInboundRoutingExtension

Routine description:

    Register Inbound Routing Extension.

Author:

    Iv Garber (IvG),    Jun, 2000

Arguments:

    bstrExtensionName             [in]    - Extension Name
    bstrFriendlyName              [in]    - Friendly Name
    bstrImageName                 [in]    - Image Name
    vMethods                      [in]    - SafeArray of the Methods Data

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxServer::RegisterInboundRoutingExtension"), hr, _T("Name=%s Friendly=%s Image=%s"),bstrExtensionName, bstrFriendlyName, bstrImageName);

    if (m_faxHandle == NULL)
    {
        //
        //  Server not Connected
        //
        hr = E_HANDLE;
        Error(GetErrorMsgId(hr), IID_IFaxServer, hr); 
        CALL_FAIL(GENERAL_ERR, _T("m_FaxHandle == NULL"), hr);
        return hr;
    }

    //
    //  Check the Validity of the SafeArray
    //
    if (vMethods.vt != (VT_ARRAY | VT_BSTR))
    {
        hr = E_INVALIDARG;
        Error(IDS_ERROR_METHODSNOTARRAY, IID_IFaxServer, hr);
        CALL_FAIL(GENERAL_ERR, _T("(vMethods.vt != VT_ARRAY | VT_BSTR)"), hr);
        return hr;
    }

    m_pRegMethods = vMethods.parray;
    if (!m_pRegMethods)
    {
        hr = E_INVALIDARG;
        CALL_FAIL(GENERAL_ERR, _T("!m_pRegMethods ( = vMethods.parray )"), hr);
        Error(IDS_ERROR_METHODSNOTARRAY, IID_IFaxServer, hr);
        return hr;        
    }

    if (SafeArrayGetDim(m_pRegMethods) != 1)
    {
        hr = E_INVALIDARG;
        CALL_FAIL(GENERAL_ERR, _T("SafeArrayGetDim(m_pRegMethods) != 1"), hr);
        Error(IDS_ERROR_METHODSNOTARRAY, IID_IFaxServer, hr);
        return hr;        
    }

    if (m_pRegMethods->rgsabound[0].lLbound != 0)
    {
        hr = E_INVALIDARG;
        Error(IDS_ERROR_METHODSNOTARRAY, IID_IFaxServer, hr);
        CALL_FAIL(GENERAL_ERR, _T("m_pRegMethods->rgsabound[0].lLbound != 0"), hr);
        return hr;        
    }

    //
    //  Register the IR Extension
    //
    m_lLastRegisteredMethod = 0;
    if (!FaxRegisterRoutingExtension(m_faxHandle, 
        bstrExtensionName, 
        bstrFriendlyName, 
        bstrImageName, 
        RegisterMethodCallback, 
        this))
    {
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        Error(GetErrorMsgId(hr), IID_IFaxServer, hr);
        CALL_FAIL(GENERAL_ERR, _T("FaxRegisterRoutingExtension(m_faxHandle, bstrExtensionName, ...)"), hr);
        return hr;
    }

    return hr;
}

//
//========== UNREGISTER INBOUND ROUTING EXTENSION ==============================================
//
STDMETHODIMP
CFaxServer::UnregisterInboundRoutingExtension(
    /*[in]*/ BSTR bstrExtensionUniqueName
)
/*++

Routine name : CFaxServer::UnregisterExtensionUniqueName

Routine description:

    Unregister the Inbound Routing Extension

Author:

    Iv Garber (IvG),    Jun, 2000

Arguments:

    bstrExtensionUniqueName     - Unique Name of the IR Extension to Unregister

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxServer::UnregisterInboundRoutingExtension"), hr, _T("Unique Name =%s"), bstrExtensionUniqueName);

    if (m_faxHandle == NULL)
    {
        //
        //  Server not Connected
        //
        hr = E_HANDLE;
        Error(GetErrorMsgId(hr), IID_IFaxServer, hr); 
        CALL_FAIL(GENERAL_ERR, _T("m_FaxHandle == NULL"), hr);
        return hr;
    }

    //
    //  Unregister the given Routing Extension
    //
    if (!FaxUnregisterRoutingExtension(m_faxHandle, bstrExtensionUniqueName))
    {
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        CALL_FAIL(GENERAL_ERR, _T("FaxUnregisterRoutingExtension(m_faxHandle, bstrExtensionUniqueName)"), hr);
        Error(GetErrorMsgId(hr), IID_IFaxServer, hr);
        return hr;
    }

    return hr;
}

//
//========== UNREGISTER DEVICE PROVIDER ==============================================
//
STDMETHODIMP
CFaxServer::UnregisterDeviceProvider(
    /*[in]*/ BSTR bstrUniqueName
)
/*++

Routine name : CFaxServer::UnregisterDeviceProvider

Routine description:

    Unregister the Device Provider

Author:

    Iv Garber (IvG),    Jun, 2000

Arguments:

    bstrUniqueName      [in]    - UniqueName of the Device Provider to Unregister

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxServer::UnregisterDeviceProvider"), hr, _T("UniqueName=%s"), bstrUniqueName);

    if (m_faxHandle == NULL)
    {
        //
        //  Server not Connected
        //
        hr = E_HANDLE;
        Error(GetErrorMsgId(hr), IID_IFaxServer, hr); 
        CALL_FAIL(GENERAL_ERR, _T("m_FaxHandle == NULL"), hr);
        return hr;
    }

    //
    //  Unregister the given Device Provider
    //
    if (!FaxUnregisterServiceProviderEx(m_faxHandle, bstrUniqueName))
    {
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        CALL_FAIL(GENERAL_ERR, _T("FaxUnregisterServiceProviderEx(m_faxHandle, bstrUniqueName)"), hr);
        Error(GetErrorMsgId(hr), IID_IFaxServer, hr);
        return hr;
    }

    return hr;
}

//
//===================== GET EXTENSION PROPERTY ===============================================
//
STDMETHODIMP
CFaxServer::GetExtensionProperty(
    /*[in]*/ BSTR bstrGUID, 
    /*[out, retval]*/ VARIANT *pvProperty
)
/*++

Routine name : CFaxServer::GetExtensionProperty

Routine description:

    Retrieves the global Extension Data from the Server.

Author:

    Iv Garber (IvG),    Jun, 2000

Arguments:

    bstrGUID                  [in]    --  Extension's Data GUID
    pvProperty                [out]    --  Variant with the Blob to Return

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxServer::GetExtensionProperty()"), hr, _T("GUID=%s"), bstrGUID);

    hr = ::GetExtensionProperty(this, 0, bstrGUID, pvProperty);
    if (FAILED(hr))
    {
        Error(GetErrorMsgId(hr), IID_IFaxServer, hr);
        return hr;
    }

    return hr;
};

//
//============= SET EXTENSION PROPERTY =============================
//
STDMETHODIMP
CFaxServer::SetExtensionProperty(
    /*[in]*/ BSTR bstrGUID, 
    /*[in]*/ VARIANT vProperty
)
/*++

Routine name : CFaxServer::SetExtensionProperty

Routine description:

    Stores Extension Configuration Property at Server level.

Author:

    Iv Garber (IvG),    Jun, 2000

Arguments:

    bstrGUID                      [in]    - GUID of the Property
    vProperty                     [in]    - the Property to Store : SafeArray of Bytes

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxServer::SetExtensionProperty()"), hr, _T("GUID=%s"), bstrGUID);

    hr = ::SetExtensionProperty(this, 0, bstrGUID, vProperty);
    if (FAILED(hr))
    {
        Error(GetErrorMsgId(hr), IID_IFaxServer, hr);
        return hr;
    }

    return hr;

}

//
//================== GET DEBUG ==============================
//
STDMETHODIMP
CFaxServer::get_Debug(
    /*[out, retval]*/ VARIANT_BOOL *pbDebug
)
/*++

Routine name : CFaxServer::get_Debug

Routine description:

    Return Whether Server is in Debug Mode.

Author:

    Iv Garber (IvG),    Jun, 2000

Arguments:

    pbDebug                     [out]    - the result

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxServer::get_Debug"), hr);

    if (!m_bVersionValid)
    {
        //
        //  get Version of the Server
        //
        hr = GetVersion();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    //
    //  Return the Value
    //
    hr = GetVariantBool(pbDebug, bool2VARIANT_BOOL((m_Version.dwFlags & FAX_VER_FLAG_CHECKED) ? true : false));
    if (FAILED(hr))
    {
        Error(GetErrorMsgId(hr), IID_IFaxServer, hr);
        return hr;
    }

    return hr;
}

//
//================== GET MINOR BUILD ==============================
//
STDMETHODIMP
CFaxServer::get_MinorBuild(
    /*[out, retval]*/ long *plMinorBuild
)
/*++

Routine name : CFaxServer::get_MinorBuild

Routine description:

    Return Minor Build of the Server.

Author:

    Iv Garber (IvG),    Jun, 2000

Arguments:

    plMinorBuild                [out]    - the result

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxServer::get_MinorBuild"), hr);

    if (!m_bVersionValid)
    {
        //
        //  get Version of the Server
        //
        hr = GetVersion();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    //
    //  Return the Value
    //
    hr = GetLong(plMinorBuild, m_Version.wMinorBuildNumber);
    if (FAILED(hr))
    {
        Error(GetErrorMsgId(hr), IID_IFaxServer, hr);
        return hr;
    }

    return hr;
}

//
//================== GET MAJOR BUILD ==============================
//
STDMETHODIMP
CFaxServer::get_MajorBuild(
    /*[out, retval]*/ long *plMajorBuild
)
/*++

Routine name : CFaxServer::get_MajorBuild

Routine description:

    Return Major Build of the Server.

Author:

    Iv Garber (IvG),    Jun, 2000

Arguments:

    plMajorBuild                [out]    - the result

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxServer::get_MajorBuild"), hr);

    if (!m_bVersionValid)
    {
        //
        //  get Version of the Server
        //
        hr = GetVersion();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    //
    //  Return the Value
    //
    hr = GetLong(plMajorBuild, m_Version.wMajorBuildNumber);
    if (FAILED(hr))
    {
        Error(GetErrorMsgId(hr), IID_IFaxServer, hr);
        return hr;
    }

    return hr;
}

//
//================== GET MINOR VERSION ==============================
//
STDMETHODIMP
CFaxServer::get_MinorVersion(
    /*[out, retval]*/ long *plMinorVersion
)
/*++

Routine name : CFaxServer::get_MinorVersion

Routine description:

    Return Minor Version of the Server.

Author:

    Iv Garber (IvG),    Jun, 2000

Arguments:

    plMinorVersion                [out]    - the result

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxServer::get_MinorVersion"), hr);

    if (!m_bVersionValid)
    {
        //
        //  get Version of the Server
        //
        hr = GetVersion();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    //
    //  Return the Value
    //
    hr = GetLong(plMinorVersion, m_Version.wMinorVersion);
    if (FAILED(hr))
    {
        Error(GetErrorMsgId(hr), IID_IFaxServer, hr);
        return hr;
    }

    return hr;
}

//
//================== GET VERSION ==============================
//
STDMETHODIMP
CFaxServer::GetVersion()
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxServer::GetVersion"), hr);

    if (m_faxHandle == NULL)
    {
        //
        //  Server not Connected
        //
        hr = E_HANDLE;
        Error(GetErrorMsgId(hr), IID_IFaxServer, hr); 
        CALL_FAIL(GENERAL_ERR, _T("m_FaxHandle == NULL"), hr);
        return hr;
    }

    //
    //  Get Version from the Fax Server
    //
    ZeroMemory(&m_Version, sizeof(FAX_VERSION));
    m_Version.dwSizeOfStruct = sizeof(FAX_VERSION);
    if (!FaxGetVersion(m_faxHandle, &m_Version))
    {
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        Error(GetErrorMsgId(hr), IID_IFaxServer, hr);
        CALL_FAIL(GENERAL_ERR, _T("FaxGetVersion(m_faxHandle, &m_Version))"), hr);
        return hr;
    }

    //
    //  Check that we have got good Version struct
    //
    if (m_Version.dwSizeOfStruct != sizeof(FAX_VERSION))
    {
        hr = E_FAIL;
        Error(GetErrorMsgId(hr), IID_IFaxServer, hr);
        CALL_FAIL(GENERAL_ERR, _T("m_Version.dwSizeOfStruct != sizeof(FAX_VERSION)"), hr);
        return hr;
    }
    ATLASSERT(m_Version.bValid);

    //
    //  Get API Version from the Fax Server
    //
    if (!FaxGetReportedServerAPIVersion(m_faxHandle, LPDWORD(&m_APIVersion)))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        Error(GetErrorMsgId(hr), IID_IFaxServer, hr);
        CALL_FAIL(GENERAL_ERR, _T("FaxGetReportedServerAPIVersion(m_faxHandle, &m_APIVersion))"), hr);
        return hr;
    }

    //
    //  m_Version & m_APIVersion are valid and OK
    //  
    m_bVersionValid = true;
    return hr;
}

//
//================== GET MAJOR VERSION ==============================
//
STDMETHODIMP
CFaxServer::get_MajorVersion(
    /*[out, retval]*/ long *plMajorVersion
)
/*++

Routine name : CFaxServer::get_MajorVersion

Routine description:

    Return Major Version of the Server.

Author:

    Iv Garber (IvG),    Jun, 2000

Arguments:

    plMajorVersion                [out]    - the result

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxServer::get_MajorVersion"), hr);

    if (!m_bVersionValid)
    {
        //
        //  get Version of the Server
        //
        hr = GetVersion();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    //
    //  Return the Value
    //
    hr = GetLong(plMajorVersion, m_Version.wMajorVersion);
    if (FAILED(hr))
    {
        Error(GetErrorMsgId(hr), IID_IFaxServer, hr);
        return hr;
    }

    return hr;
}

//
//================== GET OUTBOUND ROUTING OBJECT ==============================
//
STDMETHODIMP 
CFaxServer::get_OutboundRouting(
    IFaxOutboundRouting **ppOutboundRouting
)
/*++

Routine name : CFaxServer::get_OutboundRouting

Routine description:

    Return Outbound Routing Shortcut Object

Author:

    Iv Garber (IvG),    Jun, 2000

Arguments:

    ppOutboundRouting        [out]    - the Outbound Routing Object

Return Value:

    Standard HRESULT code

Notes:

    FaxOutboundRouting is Contained Object, because of :
    a)  It needs Ptr to Fax Server, to create Groups/Rules Collections 
        each time it is asked to.
    b)  Fax Server caches it, to allow fast dot notation ( Server.OutboundRouting.<...> )

--*/
{
    HRESULT             hr = S_OK;
    DBG_ENTER (_T("CFaxServer::get_OutboundRouting"), hr);

    CObjectHandler<CFaxOutboundRouting, IFaxOutboundRouting>    ObjectCreator;
    hr = ObjectCreator.GetContainedObject(ppOutboundRouting, &m_pOutboundRouting, this);
    if (FAILED(hr))
    {
        Error(GetErrorMsgId(hr), IID_IFaxServer, hr);
        return hr;
    }

    return hr;
}

//
//================== GET DEVICES OBJECT ==============================
//
STDMETHODIMP 
CFaxServer::GetDevices(
    IFaxDevices **ppDevices
)
/*++

Routine name : CFaxServer::get_Devices

Routine description:

    Return Devices Collection Object

Author:

    Iv Garber (IvG),    Jun, 2000

Arguments:

    ppDevices           [out]    - the Devices Collection Object

Return Value:

    Standard HRESULT code

Notes:
    
    Devices is a collection. It is not cached by the Server. 
    Each time the function is called, the new collection is created. 
    This enables the user to refresh the collection.

--*/
{
    HRESULT             hr = S_OK;
    DBG_ENTER (_T("CFaxServer::get_Devices"), hr);

    CObjectHandler<CFaxDevices, IFaxDevices>    ObjectCreator;
    hr = ObjectCreator.GetObject(ppDevices, this);
    if (FAILED(hr))
    {
        Error(GetErrorMsgId(hr), IID_IFaxServer, hr);
        return hr;
    }

    return hr;
}

//
//================== GET DEVICE PROVIDERS OBJECT ==============================
//
STDMETHODIMP 
CFaxServer::GetDeviceProviders(
    IFaxDeviceProviders **ppDeviceProviders
)
/*++

Routine name : CFaxServer::get_DeviceProviders

Routine description:

    Return Device Providers Collection Object

Author:

    Iv Garber (IvG),    Jun, 2000

Arguments:

    ppDeviceProviders        [out]    - the Device Providers Collection Object

Return Value:

    Standard HRESULT code

Notes:
    
    Device Providers is a collection. It is not cached by the Server. 
    Each time the function is called, the new collection is created. 
    This enables the user to refresh the collection.

--*/
{
    HRESULT             hr = S_OK;
    DBG_ENTER (_T("CFaxServer::get_DeviceProviders"), hr);

    CObjectHandler<CFaxDeviceProviders, IFaxDeviceProviders>    ObjectCreator;
    hr = ObjectCreator.GetObject(ppDeviceProviders, this);
    if (FAILED(hr))
    {
        Error(GetErrorMsgId(hr), IID_IFaxServer, hr);
        return hr;
    }

    return hr;
}

//
//================== GET INBOUND ROUTING OBJECT ==============================
//
STDMETHODIMP 
CFaxServer::get_InboundRouting(
    IFaxInboundRouting **ppInboundRouting
)
/*++

Routine name : CFaxServer::get_InboundRouting

Routine description:

    Return Inbound Routing Shortcut Object

Author:

    Iv Garber (IvG),    June, 2000

Arguments:

    ppInboundRouting        [out]    - the Inbound Routing Object

Return Value:

    Standard HRESULT code

Notes:

    FaxInboundRouting is Contained Object, because of :
    a)  It needs Ptr to Fax Server, to create Extensions/Methods Collections 
        each time it is asked to.
    b)  Fax Server caches it, to allow fast dot notation ( Server.InboundRouting.<...> )

--*/
{
    HRESULT             hr = S_OK;
    DBG_ENTER (_T("CFaxServer::get_InboundRouting"), hr);

    CObjectHandler<CFaxInboundRouting, IFaxInboundRouting>    ObjectCreator;
    hr = ObjectCreator.GetContainedObject(ppInboundRouting, &m_pInboundRouting, this);
    if (FAILED(hr))
    {
        Error(GetErrorMsgId(hr), IID_IFaxServer, hr);
        return hr;
    }

    return hr;
}

//
//================== GET SECURITY OBJECT ==============================
//
STDMETHODIMP 
CFaxServer::get_Security(
    IFaxSecurity **ppSecurity
)
/*++

Routine name : CFaxServer::get_Security

Routine description:

    Return Security Object

Author:

    Iv Garber (IvG),    June, 2000

Arguments:

    ppSecurity        [out]    - the Security Object

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT             hr = S_OK;
    DBG_ENTER (_T("CFaxServer::get_Security"), hr);

    CObjectHandler<CFaxSecurity, IFaxSecurity>    ObjectCreator;
    hr = ObjectCreator.GetContainedObject(ppSecurity, &m_pSecurity, this);
    if (FAILED(hr))
    {
        Error(GetErrorMsgId(hr), IID_IFaxServer, hr);
        return hr;
    }

    return hr;
}

//
//================== GET ACTIVITY OBJECT ==============================
//
STDMETHODIMP 
CFaxServer::get_Activity(
    IFaxActivity **ppActivity
)
/*++

Routine name : CFaxServer::get_Activity

Routine description:

    Return Activity Object

Author:

    Iv Garber (IvG),    June, 2000

Arguments:

    ppActivity        [out]    - the Activity Object

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT             hr = S_OK;
    DBG_ENTER (_T("CFaxServer::get_Activity"), hr);

    CObjectHandler<CFaxActivity, IFaxActivity>    ObjectCreator;
    hr = ObjectCreator.GetContainedObject(ppActivity, &m_pActivity, this);
    if (FAILED(hr))
    {
        Error(GetErrorMsgId(hr), IID_IFaxServer, hr);
        return hr;
    }

    return hr;
}

//
//================== GET LOGGING OPTIONS OBJECT ==============================
//
STDMETHODIMP 
CFaxServer::get_LoggingOptions(
    IFaxLoggingOptions **ppLoggingOptions
)
/*++

Routine name : CFaxServer::get_LoggingOptions

Routine description:

    Return Logging Options Object

Author:

    Iv Garber (IvG),    June, 2000

Arguments:

    ppLoggingOptions        [out]    - the Logging Options Object

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT             hr = S_OK;
    DBG_ENTER (_T("CFaxServer::get_LoggingOptions"), hr);

    CObjectHandler<CFaxLoggingOptions, IFaxLoggingOptions>    ObjectCreator;
    hr = ObjectCreator.GetContainedObject(ppLoggingOptions, &m_pLoggingOptions, this);
    if (FAILED(hr))
    {
        Error(GetErrorMsgId(hr), IID_IFaxServer, hr);
        return hr;
    }

    return hr;
}

//
//==================== GET HANDLE =====================================
//
STDMETHODIMP
CFaxServer::GetHandle(
    /*[out, retval]*/ HANDLE* pFaxHandle
)
/*++

Routine name : CFaxServer::GetHandle

Routine description:

    Return Handle to the Fax Server, if possible

Author:

    Iv Garber (IvG),    Apr, 2000

Arguments:

    seqId                         [in]    - the seqId of the Caller

Return Value:

    HANDLE to the Fax Server

--*/
{
    HRESULT     hr = S_OK;

    DBG_ENTER (_T("CFaxServer::GetHandle"), hr);

    if (::IsBadWritePtr(pFaxHandle, sizeof(HANDLE *))) 
    {
        //
        //  Got a bad return pointer
        //
        hr = E_POINTER;
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr()"), hr);
        return hr;
    }

    *pFaxHandle = m_faxHandle;
    return hr;

}   //  CFaxServer::GetHandle

//
//==================== INTERFACE SUPPORT ERROR INFO =====================
//
STDMETHODIMP 
CFaxServer::InterfaceSupportsErrorInfo(
    REFIID riid
)
/*++

Routine name : CFaxServer::InterfaceSupportsErrorInfo

Routine description:

    ATL's implementation of Support Error Info

Author:

    Iv Garber (IvG),    Apr, 2000

Arguments:

    riid                          [in]    - Reference to the Interface

Return Value:

    Standard HRESULT code

--*/
{
    static const IID* arr[] = 
    {
        &IID_IFaxServer
    };
    for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
    {
        if (InlineIsEqualGUID(*arr[i],riid))
            return S_OK;
    }
    return S_FALSE;
}

//
//================== GET FOLDERS OBJECT ==============================
//
STDMETHODIMP 
CFaxServer::get_Folders(
IFaxFolders **ppFolders
)
/*++

Routine name : CFaxServer::get_Folders

Routine description:

    Return Folders Shortcut Object

Author:

    Iv Garber (IvG),    Apr, 2000

Arguments:

    pFaxFolders                  [out]    - Fax Folders Object

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT             hr = S_OK;
    DBG_ENTER (_T("CFaxServer::get_Folders"), hr);

    CObjectHandler<CFaxFolders, IFaxFolders>    ObjectCreator;
    hr = ObjectCreator.GetContainedObject(ppFolders, &m_pFolders, this);
    if (FAILED(hr))
    {
        Error(GetErrorMsgId(hr), IID_IFaxServer, hr);
        return hr;
    }

    return hr;
}

//
//================== DISCONNECT =============================================
// {CR}
STDMETHODIMP 
CFaxServer::Disconnect()
{
    HRESULT     hr = S_OK;

    DBG_ENTER (_T("CFaxServer::Disconnect"), hr);

    if (!m_faxHandle)
    {
        return hr;
    }

    //
    //  first UnListen, while we still connected
    //
    hr = ListenToServerEvents(fsetNONE);
    if (FAILED(hr))
    {
        //
        //  Show the error, but continue
        //
        CALL_FAIL(GENERAL_ERR, _T("ListenToServerEvents(fsetNONE)"), hr);
    }

    if (!FaxClose(m_faxHandle))
    {
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        Error(IDS_ERROR_OPERATION_FAILED, IID_IFaxServer, hr);
        CALL_FAIL(GENERAL_ERR, _T("FaxClose()"), hr);
        return hr;
    }

    m_faxHandle = NULL;
    m_bstrServerName.Empty();
    return hr;
}

//
//=================== CONNECT =======================================
//{CR}
STDMETHODIMP CFaxServer::Connect(
    BSTR bstrServerName
)
/*++

Routine name : CFaxServer::Connect

Routine description:

    Connect to the given Fax Server

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    bstrServerName                [in]    - Name of the Fax Server to Connect to

Return Value:

    Standard HRESULT code

--*/
{
    HANDLE      h_tmpFaxHandle;
	DWORD		dwServerAPIVersion;
    HRESULT     hr = S_OK;

    DBG_ENTER (_T("CFaxServer::Connect"), hr, _T("%s"), bstrServerName);

    m_bstrServerName = bstrServerName;

    if (!FaxConnectFaxServer(m_bstrServerName, &h_tmpFaxHandle))
    {
        //
        //  Failed to Connect to the Server
        //
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        Error(GetErrorMsgId(hr), IID_IFaxServer, hr);
        CALL_FAIL(GENERAL_ERR, _T("FaxConnectFaxServer()"), hr);
        return hr;
    }
    ATLASSERT(h_tmpFaxHandle);

	//
    //  Get API Version from the Fax Server
    //
    if (!FaxGetReportedServerAPIVersion(h_tmpFaxHandle, &dwServerAPIVersion))
    {
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        Error(GetErrorMsgId(hr), IID_IFaxServer, hr);
        CALL_FAIL(GENERAL_ERR, _T("FaxGetReportedServerAPIVersion(h_tmpFaxHandle, &dwServerAPIVersion))"), hr);
        FaxClose(h_tmpFaxHandle);
        return hr;
    }

	//
	// Block Whistler clients from connection to BOS servers
	//
	if (FAX_API_VERSION_1 > dwServerAPIVersion)
    {
        hr = Fax_HRESULT_FROM_WIN32(FAX_ERR_VERSION_MISMATCH);
		Error(GetErrorMsgId(hr), IID_IFaxServer, hr);
        CALL_FAIL(GENERAL_ERR, _T("Mismatch client and server versions"), hr);
        FaxClose(h_tmpFaxHandle);
        return hr;
    }

    if (m_faxHandle)
    {
        //
        //  Reconnect 
        //
        hr = Disconnect();
        if (FAILED(hr))
        {
            //
            //  Failed to DisConnect from the Previous Server
            //
            CALL_FAIL(DBG_MSG, _T("Disconnect()"), hr);
        }
    }

    m_faxHandle = h_tmpFaxHandle;
    return hr;
}

//
//============== GET & PUT PROPERTIES ===============================
//
STDMETHODIMP CFaxServer::get_ServerName(
    BSTR *pbstrServerName
)
/*++

Routine name : CFaxServer::get_ServerName

Routine description:

    Return Name of the Server

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    pbstrServerName               [out]    - Name of the Server to Return

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxServer::get_ServerName"), hr);

    hr = GetBstr(pbstrServerName, m_bstrServerName);
    if (FAILED(hr))
    {
        Error(GetErrorMsgId(hr), IID_IFaxServer, hr);
        return hr;
    }
    return hr;
}

//
//============== MAIL OPTIONS OBJECT =========================================
//
STDMETHODIMP 
CFaxServer::get_ReceiptOptions(
    IFaxReceiptOptions **ppReceiptOptions
)
/*++

Routine name : CFaxServer::get_ReceiptOptions

Routine description:

    Return Mail Options Object.

Author:

    Iv Garber (IvG),    May, 2000

Arguments:

    ppReceiptOptions              [out, retval]    - Ptr to the place to put the object.

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT             hr = S_OK;
    DBG_ENTER (_T("CFaxServer::get_ReceiptOptions"), hr);

    CObjectHandler<CFaxReceiptOptions, IFaxReceiptOptions>    ObjectCreator;
    hr = ObjectCreator.GetContainedObject(ppReceiptOptions, &m_pReceiptOptions, this);
    if (FAILED(hr))
    {
        Error(GetErrorMsgId(hr), IID_IFaxServer, hr);
        return hr;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxserver.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxServer.h

Abstract:

	Declaration of the CFaxServer Class.

Author:

	Iv Garber (IvG)	Jun, 2000

Revision History:

--*/

#ifndef __FAXSERVER_H_
#define __FAXSERVER_H_

#include "resource.h"       // main symbols
#include "FaxFolders.h"
#include "FaxReceiptOptions.h"
#include "FaxLoggingOptions.h"
#include "FaxActivity.h"
#include "FaxSecurity.h"
#include "FaxInboundRouting.h"
#include "FaxOutboundRouting.h"
#include <atlwin.h>
#include "FXSCOMEXCP.h"

//
//================= WINDOW FOR NOTIFICATIONS =================================
//

//
//  Forward Declaration
//
class CFaxServer;

class CNotifyWindow : public CWindowImpl<CNotifyWindow>
{
public:
    CNotifyWindow(CFaxServer *pServer)
    {
        DBG_ENTER(_T("CNotifyWindow::Ctor"));

        m_pServer = pServer;
        m_MessageId = RegisterWindowMessage(_T("{2E037B27-CF8A-4abd-B1E0-5704943BEA6F}"));
        if (m_MessageId == 0)
        {
            m_MessageId = WM_USER + 876;
        }
    }

    BEGIN_MSG_MAP(CNotifyWindow)
        MESSAGE_HANDLER(m_MessageId, OnMessage)
    END_MSG_MAP()

    UINT GetMessageId(void) { return m_MessageId; };

private:
    UINT        m_MessageId;
    CFaxServer  *m_pServer;

    LRESULT OnMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled);
};


//
//================= REGISTRATION OF ROUTING EXTENSION METHODS ===========================
//

#define     DELIMITER                           _T(";")
#define     EXCEPTION_INVALID_METHOD_DATA       0xE0000001

BOOL CALLBACK RegisterMethodCallback(HANDLE FaxHandle, LPVOID Context, LPWSTR MethodName, 
                                     LPWSTR FriendlyName, LPWSTR FunctionName, LPWSTR Guid);

//
//=============== FAX SERVER ==================================================
//
class ATL_NO_VTABLE CFaxServer : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CFaxServer, &CLSID_FaxServer>,
	public ISupportErrorInfo,
	public IDispatchImpl<IFaxServer, &IID_IFaxServer, &LIBID_FAXCOMEXLib>,
	public IFaxServerInner,
    public CFaxInitInner,    //  for Debug purposes only
    public IConnectionPointContainerImpl<CFaxServer>,
    public CProxyIFaxServerNotify< CFaxServer >
{
public:
	CFaxServer() : CFaxInitInner(_T("FAX SERVER")),
      m_faxHandle(NULL),
      m_pFolders(NULL),
      m_pActivity(NULL),
      m_pSecurity(NULL),
      m_pReceiptOptions(NULL),
      m_pLoggingOptions(NULL),
      m_pInboundRouting(NULL),
      m_pOutboundRouting(NULL),
      m_bVersionValid(false),
      m_pNotifyWindow(NULL),
      m_hEvent(NULL),
      m_lLastRegisteredMethod(0),
      m_EventTypes(fsetNONE)
	{
    }

	~CFaxServer()
	{
        //
        //  Disconnect
        //
        if (m_faxHandle)
        {
            Disconnect();
        }

        //
        //  free all the allocated objects
        //
        if (m_pFolders) 
        {
            delete m_pFolders;
        }

        if (m_pActivity) 
        {
            delete m_pActivity;
        }

        if (m_pSecurity) 
        {
            delete m_pSecurity;
        }

        if (m_pReceiptOptions) 
        {
            delete m_pReceiptOptions;
        }

        if (m_pLoggingOptions) 
        {
            delete m_pLoggingOptions;
        }

        if (m_pInboundRouting) 
        {
            delete m_pInboundRouting;
        }

        if (m_pOutboundRouting) 
        {
            delete m_pOutboundRouting;
        }
	}

DECLARE_REGISTRY_RESOURCEID(IDR_FAXSERVER)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CFaxServer)
	COM_INTERFACE_ENTRY(IFaxServer)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IFaxServerInner)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY(IConnectionPointContainer)
END_COM_MAP()

BEGIN_CONNECTION_POINT_MAP(CFaxServer)
    CONNECTION_POINT_ENTRY(DIID_IFaxServerNotify)
END_CONNECTION_POINT_MAP()

//  Interfaces
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

	STDMETHOD(Disconnect)();
	STDMETHOD(Connect)(BSTR bstrServerName);

	STDMETHOD(GetDevices)(/*[out, retval]*/ IFaxDevices **ppDevices);
	STDMETHOD(get_Folders)(/*[out, retval]*/ IFaxFolders **ppFolders);
	STDMETHOD(get_Activity)(/*[out, retval]*/ IFaxActivity **ppActivity);
	STDMETHOD(get_Security)(/*[out, retval]*/ IFaxSecurity **ppSecurity);
	STDMETHOD(get_ReceiptOptions)(/*[out, retval]*/ IFaxReceiptOptions **ppReceiptOptions);
    STDMETHOD(get_LoggingOptions)(/*[out, retval]*/ IFaxLoggingOptions **ppLoggingOptions);
	STDMETHOD(get_InboundRouting)(/*[out, retval]*/ IFaxInboundRouting **ppInboundRouting);
	STDMETHOD(GetDeviceProviders)(/*[out, retval]*/ IFaxDeviceProviders **ppDeviceProviders);
	STDMETHOD(get_OutboundRouting)(/*[out, retval]*/ IFaxOutboundRouting **ppFaxOutboundRouting);

	STDMETHOD(get_Debug)(/*[out, retval]*/ VARIANT_BOOL *pbDebug);
	STDMETHOD(get_MajorBuild)(/*[out, retval]*/ long *plMajorBuild);
	STDMETHOD(get_MinorBuild)(/*[out, retval]*/ long *plMinorBuild);
	STDMETHOD(get_ServerName)(/*[out, retval]*/ BSTR *pbstrServerName);
	STDMETHOD(get_MajorVersion)(/*[out, retval]*/ long *plMajorVersion);
	STDMETHOD(get_MinorVersion)(/*[out, retval]*/ long *plMinorVersion);
    STDMETHOD(get_APIVersion)(/*[out,retval]*/ FAX_SERVER_APIVERSION_ENUM *pAPIVersion);

	STDMETHOD(SetExtensionProperty)(/*[in]*/ BSTR bstrGUID, /*[in]*/ VARIANT vProperty);
	STDMETHOD(GetExtensionProperty)(/*[in]*/ BSTR bstrGUID, /*[out, retval]*/ VARIANT *pvProperty);

	STDMETHOD(UnregisterDeviceProvider)(BSTR bstrProviderUniqueName);
	STDMETHOD(UnregisterInboundRoutingExtension)(BSTR bstrExtensionUniqueName);
    STDMETHOD(RegisterDeviceProvider)(
        /*[in]*/ BSTR bstrGUID, 
        /*[in]*/ BSTR bstrFriendlyName, 
        /*[in]*/ BSTR bstrImageName, 
        /*[in]*/ BSTR TspName,
        /*[in]*/ long lFSPIVersion);
    STDMETHOD(RegisterInboundRoutingExtension)(
        /*[in]*/ BSTR bstrExtensionName, 
        /*[in]*/ BSTR bstrFriendlyName, 
        /*[in]*/ BSTR bstrImageName, 
        /*[in]*/ VARIANT vMethods);

	STDMETHOD(ListenToServerEvents)(/*[in]*/ FAX_SERVER_EVENTS_TYPE_ENUM EventTypes);
    STDMETHOD(get_RegisteredEvents)(/*[out, retval]*/ FAX_SERVER_EVENTS_TYPE_ENUM *pEventTypes);

//  Internal Use
	STDMETHOD(GetHandle)(/*[out, retval]*/ HANDLE* pFaxHandle);
    BOOL GetRegisteredData(LPWSTR MethodName, LPWSTR FriendlyName, LPWSTR FunctionName, LPWSTR Guid);
    HRESULT ProcessMessage(FAX_EVENT_EX *pFaxEventInfo);

private:
	HANDLE                      m_faxHandle;
	CComBSTR                    m_bstrServerName;

    FAX_VERSION                 m_Version;
    FAX_SERVER_APIVERSION_ENUM  m_APIVersion;
    bool                        m_bVersionValid;

    long                        m_lLastRegisteredMethod;
    SAFEARRAY                   *m_pRegMethods;

    FAX_SERVER_EVENTS_TYPE_ENUM     m_EventTypes;

    //
    //  All these objects requires alive Server Object
    //  so their Reference Counting is done by the Server
    //
    CComContainedObject2<CFaxFolders>            *m_pFolders;
    CComContainedObject2<CFaxActivity>           *m_pActivity;
    CComContainedObject2<CFaxSecurity>           *m_pSecurity;
    CComContainedObject2<CFaxReceiptOptions>     *m_pReceiptOptions;
    CComContainedObject2<CFaxLoggingOptions>     *m_pLoggingOptions;
    CComContainedObject2<CFaxInboundRouting>     *m_pInboundRouting;
    CComContainedObject2<CFaxOutboundRouting>    *m_pOutboundRouting;

    //
    //  Window for Notifications
    //
    CNotifyWindow   *m_pNotifyWindow;
    HANDLE          m_hEvent;

//  Functions
    STDMETHOD(GetVersion)();
    void GetMethodData(/*[in]*/ BSTR    bstrAllString, /*[out]*/ LPWSTR strWhereToPut);
    void ClearNotifyWindow(void);

    typedef enum LOCATION { IN_QUEUE, OUT_QUEUE, IN_ARCHIVE, OUT_ARCHIVE } LOCATION;

    HRESULT ProcessJobNotification(DWORDLONG dwlJobId, FAX_ENUM_JOB_EVENT_TYPE eventType, 
        LOCATION place, FAX_JOB_STATUS *pJobStatus = NULL);
};

#endif //__FAXSERVER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\faxsecurity.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FaxSecurity.cpp

Abstract:

	Implementation of CFaxSecurity Class.

Author:

	Iv Garber (IvG)	Jun, 2000

Revision History:

--*/

#include "stdafx.h"
#include "FaxComEx.h"
#include "FaxSecurity.h"
#include "faxutil.h"


//
//================== INFORMATION TYPE ===========================================
//
STDMETHODIMP 
CFaxSecurity::get_InformationType(
    long *plInformationType
)
/*++

Routine name : CFaxSecurity::get_InformationType

Routine description:

    Return current SecurityInformation value

Author:

    Iv Garber (IvG),    May, 2001

Arguments:

    plInformationType   [out]    - the SecurityInformation data to be returned

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER (TEXT("CFaxSecurity::get_InformationType"), hr);

    hr = GetLong(plInformationType, m_dwSecurityInformation);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxSecurity, GetErrorMsgId(hr), IID_IFaxSecurity, hr, _Module.GetResourceInstance());
        return hr;
    }
    return hr;
}

STDMETHODIMP 
CFaxSecurity::put_InformationType(
    long lInformationType
)
/*++

Routine name : CFaxSecurity::put_InformationType

Routine description:

    Set SecurityInformation for the Descriptor

Author:

    Iv Garber (IvG),    May, 2001

Arguments:

    lInformationType    [in]    - the SecurityInformation data to set

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DWORD dwSecInfo = ( OWNER_SECURITY_INFORMATION  |
                        GROUP_SECURITY_INFORMATION  |
                        DACL_SECURITY_INFORMATION   |
                        SACL_SECURITY_INFORMATION );

    DBG_ENTER (_T("CFaxSecurity::put_InformationType"), hr, _T("%ld"), lInformationType);


    if (m_dwSecurityInformation != lInformationType)
    {
        //
        //  check that lInformationType is valid
        //

        if (0 == (lInformationType & dwSecInfo))
        {
            hr = E_INVALIDARG;
            CALL_FAIL(GENERAL_ERR, _T("lInformationType does not contain good bits."), hr);
            AtlReportError(
                CLSID_FaxSecurity, 
                IDS_ERROR_INVALID_ARGUMENT, 
                IID_IFaxSecurity, 
                hr, 
                _Module.GetResourceInstance());
            return hr;
        }

        if (0 != (lInformationType & ~dwSecInfo))
        {
            hr = E_INVALIDARG;
            CALL_FAIL(GENERAL_ERR, _T("lInformationType contains bad bits."), hr);
            AtlReportError(
                CLSID_FaxSecurity, 
                IDS_ERROR_INVALID_ARGUMENT, 
                IID_IFaxSecurity, 
                hr, 
                _Module.GetResourceInstance());
            return hr;
        }

        m_dwSecurityInformation = lInformationType;

        //
        //  we want to discard current Descriptor, because its security_information is different now
        //
        m_bInited = false;
    }

    return hr;
}

//
//================== DESCRIPTOR ===========================================
//
STDMETHODIMP 
CFaxSecurity::put_Descriptor(
    /*[out, retval]*/ VARIANT vDescriptor
)
/*++

Routine name : CFaxSecurity::put_Descriptor

Routine description:

	Set the given Security Descriptor

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

    sabDescriptor               [in]    -   the given Security Descriptor


Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxSecurity::put_Descriptor"), hr);

    //
    //  First, initialize the FaxSecurity object
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    //
    //  Before filling the m_pbSD with the User's value, store its current value for roll-back
    //
    CFaxPtrLocal<BYTE>  pSDTmp;
    pSDTmp = m_pbSD.Detach();

    hr = VarByteSA2Binary(vDescriptor, &m_pbSD);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxSecurity, GetErrorMsgId(hr), IID_IFaxSecurity, hr, _Module.GetResourceInstance());
        goto exit;
    }

    //
    //  Check that we have got a valid Descriptor
    //
    if (!::IsValidSecurityDescriptor(m_pbSD))
    {
        hr = E_INVALIDARG;
        CALL_FAIL(GENERAL_ERR, _T("IsValidSecurityDescriptor(m_pbSD)"), hr);
        AtlReportError(CLSID_FaxSecurity, IDS_ERROR_INVALID_ARGUMENT, IID_IFaxSecurity, hr, _Module.GetResourceInstance());
        goto exit;
    }

    //
    //  Check that we have got a Self-Relative Descriptor
    //
    SECURITY_DESCRIPTOR_CONTROL     sdControl;
    DWORD                           dwRevision;
    if (!::GetSecurityDescriptorControl(m_pbSD, &sdControl, &dwRevision))
    {
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        CALL_FAIL(GENERAL_ERR, _T("GetSecurityDescriptorContrl(m_pbSD, &sdControl, ...)"), hr);
        AtlReportError(CLSID_FaxSecurity, IDS_ERROR_INVALID_ARGUMENT, IID_IFaxSecurity, hr, _Module.GetResourceInstance());
        goto exit;
    }

    if (!(sdControl & SE_SELF_RELATIVE))
    {
        //
        //  Security Descriptor is not Self-Relative
        //
        hr = E_INVALIDARG;
        CALL_FAIL(GENERAL_ERR, _T("Security Descriptor is not Self-Relative"), hr);
        AtlReportError(CLSID_FaxSecurity, IDS_ERROR_SDNOTSELFRELATIVE, IID_IFaxSecurity, hr, _Module.GetResourceInstance());
        goto exit;
    }

    //
    //  we have valid Descriptor. Old one will be deallocated by pSecDescTmp
    //
    return hr;

exit:
    //
    //  Set previous value for the Descriptor
    //
    m_pbSD = pSDTmp.Detach();
    return hr;
}

STDMETHODIMP 
CFaxSecurity::get_Descriptor(
    /*[out, retval]*/ VARIANT *pvDescriptor
)
/*++

Routine name : CFaxSecurity::get_Descriptor

Routine description:

	Return the current Security Descriptor

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:


Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxSecurity::get_Descriptor"), hr);

    //
    //  check that we have got good ptr
    //
    if (::IsBadWritePtr(pvDescriptor, sizeof(VARIANT)))
    {
        hr = E_POINTER;
        CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr(pvDescriptor, sizeof(VARIANT))"), hr);
        AtlReportError(CLSID_FaxSecurity, IDS_ERROR_INVALID_ARGUMENT, IID_IFaxSecurity, hr, _Module.GetResourceInstance());
        return hr;
    }

    //
    //  Bring the data from the Server, if not brought yet
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    //
    //  Find size of the Security Descriptor
    //
    DWORD   dwLength = GetSecurityDescriptorLength(m_pbSD);

    //
    //  Convert the byte blob into variant containing Safe Array of bytes
    //
    hr = Binary2VarByteSA(m_pbSD, pvDescriptor, dwLength);
    if (FAILED(hr))
    {
		AtlReportError(CLSID_FaxSecurity, GetErrorMsgId(hr), IID_IFaxSecurity, hr, _Module.GetResourceInstance());
		return hr;
    }

    return hr;
}

//
//================== SAVE ===========================================
//
STDMETHODIMP 
CFaxSecurity::Save()
/*++

Routine name : CFaxSecurity::Save

Routine description:

	Save the Object's contents to the Server

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:


Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxSecurity::Save"), hr);

    //
    //  No changes ==> nothing to update at the Server
    //
    if (!m_bInited)
    {
        return hr;
    }

    //
    //  Get Fax Server Handle
    //
    HANDLE  hFaxHandle = NULL;
    hr = GetFaxHandle(&hFaxHandle);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxSecurity, GetErrorMsgId(hr), IID_IFaxSecurity, hr, _Module.GetResourceInstance());
        return hr;
    }

    //
    //  Set Security Data at the Server 
    //
    if (!FaxSetSecurity(hFaxHandle, m_dwSecurityInformation, m_pbSD))
    {
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        CALL_FAIL(GENERAL_ERR, _T("FaxSetSecurity(hFaxHandle, dwSecInfo, m_pbSD)"), hr);
        AtlReportError(CLSID_FaxSecurity, GetErrorMsgId(hr), IID_IFaxSecurity, hr, _Module.GetResourceInstance());
        return hr;
    }
    return hr;
}

//
//================== GET GRANTED RIGHTS ===========================================
//
STDMETHODIMP 
CFaxSecurity::get_GrantedRights(
    FAX_ACCESS_RIGHTS_ENUM *pGrantedRights    
)
/*++

Routine name : CFaxSecurity::get_GrantedRights

Routine description:

	Return current Access Rights of a user

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

    pGrantedRights      [out, retval]   -   Bit-Wise combination of the granted rights of the user

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;
    DBG_ENTER(_T("CFaxSecurity::get_GrantedRights"), hr);

	//
	//	Check that we have got good Ptr
	//
	if (::IsBadWritePtr(pGrantedRights, sizeof(FAX_ACCESS_RIGHTS_ENUM)))
	{
		hr = E_POINTER;
		CALL_FAIL(GENERAL_ERR, _T("::IsBadWritePtr(pGrantedRights, sizeof(FAX_ACCESS_RIGHTS_ENUM))"), hr);
        AtlReportError(CLSID_FaxSecurity, GetErrorMsgId(hr), IID_IFaxSecurity, hr, _Module.GetResourceInstance());
		return hr;
	}

    //
    //  Bring the data from the Server, if not brought yet
    //
    if (!m_bInited)
    {
        hr = Refresh();
        if (FAILED(hr))
        {
            return hr;
        }
    }

	*pGrantedRights = FAX_ACCESS_RIGHTS_ENUM(m_dwAccessRights);
    return hr;
}
    
//
//================== REFRESH ===========================================
//
STDMETHODIMP 
CFaxSecurity::Refresh()
/*++

Routine name : CFaxSecurity::Refresh

Routine description:

	Refresh the Object's contents : bring new Security data from the Server.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:


Return Value:

    Standard HRESULT code

--*/
{
    HRESULT     hr = S_OK;

    DBG_ENTER(_T("CFaxSecurity::Refresh"), hr);

    //
    //  Get Fax Server Handle
    //
    HANDLE  hFaxHandle = NULL;
    hr = GetFaxHandle(&hFaxHandle);
    if (FAILED(hr))
    {
        AtlReportError(CLSID_FaxSecurity, GetErrorMsgId(hr), IID_IFaxSecurity, hr, _Module.GetResourceInstance());
        return hr;
    }

    //
    //  Ask the Server for the SD
    //
    PSECURITY_DESCRIPTOR    pSecDesc = NULL;
    if (!FaxGetSecurityEx(hFaxHandle, m_dwSecurityInformation, &pSecDesc))
    {
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        CALL_FAIL(GENERAL_ERR, _T("FaxGetSecurityEx(hFaxHandle, m_dwSecurityInformation, &m_pSecurityDescriptor)"), hr);
        AtlReportError(CLSID_FaxSecurity, GetErrorMsgId(hr), IID_IFaxSecurity, hr, _Module.GetResourceInstance());
        return hr;
    }

    //
    //  Copy the given SD to m_pbSD
    //
    DWORD   dwLength = GetSecurityDescriptorLength(pSecDesc);
    m_pbSD = (BYTE *)MemAlloc(dwLength);
    if (!m_pbSD)
    {
        hr = E_OUTOFMEMORY;
        CALL_FAIL(MEM_ERR, _T("MemAlloc(dwLength)"), hr);
        AtlReportError(CLSID_FaxSecurity, IDS_ERROR_OUTOFMEMORY, IID_IFaxSecurity, hr, _Module.GetResourceInstance());
        return hr;
    }

    memcpy(m_pbSD, pSecDesc, dwLength);

    //
    //  Free the Server's memory for SD
    //
    FaxFreeBuffer(pSecDesc);

    //
    //  Ask the Server for the Access Rights Data
    //
    if (!FaxAccessCheckEx(hFaxHandle, MAXIMUM_ALLOWED, &m_dwAccessRights))
    {
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        CALL_FAIL(GENERAL_ERR, _T("FaxAccessCheckEx(hFaxHandle, MAXIMUM_ALLOWED, &m_dwAccessRights)"), hr);
        AtlReportError(CLSID_FaxSecurity, GetErrorMsgId(hr), IID_IFaxSecurity, hr, _Module.GetResourceInstance());
        return hr;
    }

    m_bInited = true;
    return hr;
}

//
//============================ SUPPORT ERROR INFO =======================================
//
STDMETHODIMP 
CFaxSecurity::InterfaceSupportsErrorInfo(
    REFIID riid
)
/*++

Routine name : CFaxSecurity::InterfaceSupportsErrorInfo

Routine description:

	ATL's implementation of Support Error Info mechanism.

Author:

	Iv Garber (IvG),	Jun, 2000

Arguments:

	riid                          [in]    - Reference to the Interface to check.

Return Value:

    Standard HRESULT code

--*/
{
	static const IID* arr[] = 
	{
		&IID_IFaxSecurity
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\fxscomexcp.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

	FXSCOMEXCP.h

Abstract:

	ATL's implementation of IConnectionPoint Ifc.
    Generated by ATL's Wizard.

Author:

	Iv Garber (IvG)	Jul, 2000

Revision History:

--*/

#ifndef _FXSCOMEXCP_H_
#define _FXSCOMEXCP_H_

template <class T>
class CProxyIFaxServerNotify : public IConnectionPointImpl<T, &DIID_IFaxServerNotify, CComDynamicUnkArray>
{
	//Warning this class may be recreated by the wizard.
public:
	HRESULT Fire_OnIncomingJobAdded(IFaxServer * pFaxServer, BSTR bstrJobId)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[2];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[1] = pFaxServer;
				pvars[0] = bstrJobId;
				DISPPARAMS disp = { pvars, NULL, 2, 0 };
				pDispatch->Invoke(0x1, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
	HRESULT Fire_OnIncomingJobRemoved(IFaxServer * pFaxServer, BSTR bstrJobId)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[2];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[1] = pFaxServer;
				pvars[0] = bstrJobId;
				DISPPARAMS disp = { pvars, NULL, 2, 0 };
				pDispatch->Invoke(0x2, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
	HRESULT Fire_OnIncomingJobChanged(IFaxServer * pFaxServer, BSTR bstrJobId, IFaxJobStatus * pJobStatus)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[3];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[2] = pFaxServer;
				pvars[1] = bstrJobId;
				pvars[0] = pJobStatus;
				DISPPARAMS disp = { pvars, NULL, 3, 0 };
				pDispatch->Invoke(0x3, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
	HRESULT Fire_OnOutgoingJobAdded(IFaxServer * pFaxServer, BSTR bstrJobId)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[2];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[1] = pFaxServer;
				pvars[0] = bstrJobId;
				DISPPARAMS disp = { pvars, NULL, 2, 0 };
				pDispatch->Invoke(0x4, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
	HRESULT Fire_OnOutgoingJobRemoved(IFaxServer * pFaxServer, BSTR bstrJobId)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[2];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[1] = pFaxServer;
				pvars[0] = bstrJobId;
				DISPPARAMS disp = { pvars, NULL, 2, 0 };
				pDispatch->Invoke(0x5, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
	HRESULT Fire_OnOutgoingJobChanged(IFaxServer * pFaxServer, BSTR bstrJobId, IFaxJobStatus * pJobStatus)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[3];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[2] = pFaxServer;
				pvars[1] = bstrJobId;
				pvars[0] = pJobStatus;
				DISPPARAMS disp = { pvars, NULL, 3, 0 };
				pDispatch->Invoke(0x6, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
	HRESULT Fire_OnIncomingMessageAdded(IFaxServer * pFaxServer, BSTR bstrMessageId)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[2];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[1] = pFaxServer;
				pvars[0] = bstrMessageId;
				DISPPARAMS disp = { pvars, NULL, 2, 0 };
				pDispatch->Invoke(0x7, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
	HRESULT Fire_OnIncomingMessageRemoved(IFaxServer * pFaxServer, BSTR bstrMessageId)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[2];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[1] = pFaxServer;
				pvars[0] = bstrMessageId;
				DISPPARAMS disp = { pvars, NULL, 2, 0 };
				pDispatch->Invoke(0x8, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
	HRESULT Fire_OnOutgoingMessageAdded(IFaxServer * pFaxServer, BSTR bstrMessageId)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[2];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[1] = pFaxServer;
				pvars[0] = bstrMessageId;
				DISPPARAMS disp = { pvars, NULL, 2, 0 };
				pDispatch->Invoke(0x9, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
	HRESULT Fire_OnOutgoingMessageRemoved(IFaxServer * pFaxServer, BSTR bstrMessageId)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[2];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[1] = pFaxServer;
				pvars[0] = bstrMessageId;
				DISPPARAMS disp = { pvars, NULL, 2, 0 };
				pDispatch->Invoke(0xa, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
	HRESULT Fire_OnReceiptOptionsChange(IFaxServer * pFaxServer)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[0] = pFaxServer;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0xb, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
	HRESULT Fire_OnActivityLoggingConfigChange(IFaxServer * pFaxServer)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[0] = pFaxServer;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0xc, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
	HRESULT Fire_OnSecurityConfigChange(IFaxServer * pFaxServer)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[0] = pFaxServer;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0xd, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
	HRESULT Fire_OnEventLoggingConfigChange(IFaxServer * pFaxServer)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[0] = pFaxServer;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0xe, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
	HRESULT Fire_OnOutgoingQueueConfigChange(IFaxServer * pFaxServer)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[0] = pFaxServer;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0xf, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
	HRESULT Fire_OnOutgoingArchiveConfigChange(IFaxServer * pFaxServer)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[0] = pFaxServer;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0x10, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
	HRESULT Fire_OnIncomingArchiveConfigChange(IFaxServer * pFaxServer)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[0] = pFaxServer;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0x11, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
	HRESULT Fire_OnDevicesConfigChange(IFaxServer * pFaxServer)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[0] = pFaxServer;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0x12, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
	HRESULT Fire_OnOutboundRoutingGroupsConfigChange(IFaxServer * pFaxServer)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[0] = pFaxServer;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0x13, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
	HRESULT Fire_OnOutboundRoutingRulesConfigChange(IFaxServer * pFaxServer)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[0] = pFaxServer;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0x14, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
	HRESULT Fire_OnServerActivityChange(IFaxServer * pFaxServer, LONG lIncomingMessages, LONG lRoutingMessages, LONG lOutgoingMessages, LONG lQueuedMessages)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[5];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[4] = pFaxServer;
				pvars[3] = lIncomingMessages;
				pvars[2] = lRoutingMessages;
				pvars[1] = lOutgoingMessages;
				pvars[0] = lQueuedMessages;
				DISPPARAMS disp = { pvars, NULL, 5, 0 };
				pDispatch->Invoke(0x15, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
	HRESULT Fire_OnQueuesStatusChange(IFaxServer * pFaxServer, VARIANT_BOOL bOutgoingQueueBlocked, VARIANT_BOOL bOutgoingQueuePaused, VARIANT_BOOL bIncomingQueueBlocked)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[4];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[3] = pFaxServer;
				pvars[2] = bOutgoingQueueBlocked;
				pvars[1] = bOutgoingQueuePaused;
				pvars[0] = bIncomingQueueBlocked;
				DISPPARAMS disp = { pvars, NULL, 4, 0 };
				pDispatch->Invoke(0x16, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
	HRESULT Fire_OnNewCall(IFaxServer * pFaxServer, LONG lCallId, LONG lDeviceId, BSTR bstrCallerId)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[4];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[3] = pFaxServer;
				pvars[2] = lCallId;
				pvars[1] = lDeviceId;
				pvars[0] = bstrCallerId;
				DISPPARAMS disp = { pvars, NULL, 4, 0 };
				pDispatch->Invoke(0x17, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
	HRESULT Fire_OnServerShutDown(IFaxServer * pFaxServer)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[0] = pFaxServer;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0x18, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}

	HRESULT Fire_OnDeviceStatusChange(  IFaxServer * pFaxServer, 
                                        LONG lDeviceId, 
                                        VARIANT_BOOL bPoweredOff, 
                                        VARIANT_BOOL bSending, 
                                        VARIANT_BOOL bReceiving, 
                                        VARIANT_BOOL bRinging)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[6];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[5] = pFaxServer;
				pvars[4] = lDeviceId;
				pvars[3] = bPoweredOff;
				pvars[2] = bSending;
				pvars[1] = bReceiving;
				pvars[0] = bRinging;
				DISPPARAMS disp = { pvars, NULL, 6, 0 };
				pDispatch->Invoke(0x19, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\win2k\faxcom.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    faxitg.cpp

Abstract:

    This file implements the dll exports from this
    control(s).

Author:

    Wesley Witt (wesw) 13-May-1997

Environment:

    User Mode

--*/

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"


#include "faxcom_i.c"
#include "faxtiff.h"
#include "faxsvr.h"
#include "Status.h"
#include "FaxJob.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_FaxTiff, CFaxTiff)
    OBJECT_ENTRY(CLSID_FaxServer, CFaxServer)	
END_OBJECT_MAP()

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH) {
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    } else if (dwReason == DLL_PROCESS_DETACH) {
        _Module.Term();
    }
    return TRUE;
}


STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}


STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}


STDAPI DllRegisterServer(void)
{
    return _Module.RegisterServer(TRUE);
}


STDAPI DllUnregisterServer(void)
{
    _Module.UnregisterServer();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by FaxComEx.rc
//
#define IDS_PROJNAME                    100
#define IDR_FAXSERVER                   101
#define IDR_FAXDEVICEPROVIDERS          102
#define IDR_FAXDEVICES                  103
#define IDR_FAXINBOUNDROUTING           104
#define IDR_FAXFOLDERS                  105
#define IDR_FAXLOGGINGOPTIONS           106
#define IDR_FAXACTIVITY                 107
#define IDR_FAXOUTBOUNDROUTING          108
#define IDR_FAXRECEIPTOPTIONS           109
#define IDR_FAXSECURITY                 110
#define IDR_FAXDOCUMENT                 111
#define IDR_FAXSENDER                   113
#define IDR_FAXRECIPIENTS               114
#define IDR_FAXINCOMINGARCHIVE          115
#define IDR_FAXINCOMINGQUEUE            116
#define IDR_FAXOUTGOINGARCHIVE          117
#define IDR_FAXOUTGOINGQUEUE            118
#define IDR_FAXINCOMINGMESSAGEITERATOR  119
#define IDR_FAXINCOMINGMESSAGE          120
#define IDR_FAXOUTGOINGJOBS             123
#define IDR_FAXOUTGOINGJOB              128
#define IDR_FAXOUTGOINGMESSAGEITERATOR  129
#define IDR_FAXOUTGOINGMESSAGE          130
#define IDR_FAXINCOMINGJOBS             131
#define IDR_FAXINCOMINGJOB              132
#define IDR_FAXDEVICEPROVIDER           133
#define IDR_FAXDEVICE                   134
#define IDR_FAXACTIVITYLOGGING          135
#define IDR_FAXEVENTLOGGING             136
#define IDR_FAXOUTBOUNDROUTINGGROUPS    137
#define IDR_FAXOUTBOUNDROUTINGGROUP     138
#define IDR_FAXDEVICEIDS                139
#define IDR_FAXOUTBOUNDROUTINGRULES     140
#define IDR_FAXOUTBOUNDROUTINGRULE      141
#define IDR_FAXINBOUNDROUTINGEXTENSIONS 142
#define IDR_FAXINBOUNDROUTINGEXTENSION  143
#define IDR_FAXINBOUNDROUTINGMETHODS    144
#define IDR_FAXINBOUNDROUTINGMETHOD     145
#define IDS_FAXARCHIVEINNERIMPL_DESC    146
#define IDR_FAXJOBSTATUS                147
#define IDR_FAXRECIPIENT                148

#define IDS_ERROR_INVALID_ARGUMENT          0x0200
#define IDS_ERROR_NO_RECIPIENTS             0x0201
#define IDS_ERROR_OPERATION_FAILED          0x0202
#define IDS_ERROR_NOTHING_TO_SUBMIT         0x0203
#define IDS_ERROR_SCHEDULE_TYPE             0x0204
#define IDS_ERROR_SERVER_NOT_CONNECTED      0x0205
#define IDS_ERROR_OUTOFMEMORY               0x0206
#define IDS_ERROR_EMPTY_ARGUMENT            0x0207
#define IDS_ERROR_OUTOFRANGE                0x0208
#define IDS_ERROR_ACCESSDENIED              0x0209
#define IDS_ERROR_ZERO_PREFETCHSIZE         0x0210
#define IDS_ERROR_ITERATOR_NOTSTARTED       0x0211
#define IDS_ERROR_EMPTY_FOLDER              0x0212
#define IDS_ERROR_INVALIDMSGID              0x0213
#define IDS_ERROR_EOF                       0x0214
#define IDS_ERROR_CONNECTION_FAILED         0x0215
#define IDS_ERROR_INVALIDINDEX              0x0216
#define IDS_ERROR_NOUSERPASSWORD            0x0218
#define IDS_ERROR_NOSERVERSENDERPORT        0x0219
#define IDS_ERROR_SDNOTSELFRELATIVE         0x0220
#define IDS_ERROR_INVALIDMETHODGUID         0x0222
#define IDS_ERROR_INVALIDDEVPROVGUID        0x0223
#define IDS_ERROR_INVALIDDEVICEID           0x0224
#define IDS_ERROR_REMOVEDEFAULTRULE         0x0225
#define IDS_ERROR_ALLDEVICESGROUP           0x0226
#define IDS_ERROR_METHODSNOTARRAY           0x0227
#define IDS_ERROR_WRONGEXTENSIONNAME        0x0228
#define IDS_ERROR_NOCOVERPAGE               0x0229
#define IDS_ERROR_QUEUE_BLOCKED             0x0230
#define IDS_ERROR_INVALIDDEVICE             0x0231
#define IDS_ERROR_GROUP_NOT_FOUND           0x0232
#define IDS_ERROR_BAD_GROUP_CONFIGURATION   0x0233
#define IDS_ERROR_GROUP_IN_USE              0x0234
#define IDS_ERROR_RULE_NOT_FOUND            0x0235
#define IDS_ERROR_NOT_NTFS                  0x0236
#define IDS_ERROR_DIRECTORY_IN_USE          0x0237
#define IDS_ERROR_MESSAGE_NOT_FOUND         0x0238
#define IDS_ERROR_DEVICE_NUM_LIMIT_EXCEEDED 0x0239
#define IDS_ERROR_NOT_SUPPORTED_ON_THIS_SKU 0x0240
#define IDS_ERROR_VERSION_MISMATCH          0x0241
#define IDS_ERROR_FILE_ACCESS_DENIED        0x0242
#define IDS_ERROR_SRV_OUTOFMEMORY           0x0243
#define IDS_ERROR_ILLEGAL_RECIPIENTS        0x0244


//
// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           148
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__9EF4F5DF_CE05_4E4B_9E56_0152142B8AF9__INCLUDED_)
#define AFX_STDAFX_H__9EF4F5DF_CE05_4E4B_9E56_0152142B8AF9__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#include <fxsapip.h>
#include <comdef.h>

#include <debugex.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__9EF4F5DF_CE05_4E4B_9E56_0152142B8AF9__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\vcue_copy.h ===
// This is a part of the Active Template Library. 
// Copyright (C) 1995-1999 Microsoft Corporation
// All rights reserved. 
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

// VCUE_Copy.h
//
// This file contains ATL-style copy policy classes
// ATL uses copy policy classes in its enumerator and collection interface implementations
//
//////////////////////////////////////////////////////////////////////

#if !defined(_GENERICCOPY_H___36A49827_B15B_11D2_BA63_00C04F8EC847___INCLUDED_)
#define _GENERICCOPY_H___36A49827_B15B_11D2_BA63_00C04F8EC847___INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <AtlCom.h>

namespace VCUE
{
	template <class DestinationType, class SourceType = DestinationType>
	class GenericCopy
	{
	public :
		typedef DestinationType	destination_type;
		typedef SourceType		source_type;

		static void init(destination_type* p)
		{
			_Copy<destination_type>::init(p);
		}
		static void destroy(destination_type* p)
		{
			_Copy<destination_type>::destroy(p);
		}
		static HRESULT copy(destination_type* pTo, const source_type* pFrom)
		{
			return _Copy<destination_type>::copy(pTo, const_cast<source_type*>(pFrom));
		}

	}; // class GenericCopy

	template <>
	class GenericCopy<VARIANT, BSTR>
	{
	public :
		typedef VARIANT	destination_type;
		typedef BSTR	source_type;

		static void init(destination_type* p)
		{
			GenericCopy<destination_type>::init(p);
		}
		static void destroy(destination_type* p)
		{
			GenericCopy<destination_type>::destroy(p);
		}
		static HRESULT copy(destination_type* pTo, const source_type* pFrom)
		{
			return CComVariant(*pFrom).Detach(pTo);
		}

	}; // class GenericCopy<VARIANT, BSTR>

	template < class SourceType >
	class CopyIfc2Variant
	{
	public :
		static void init(VARIANT* p)
		{
			GenericCopy<VARIANT>::init(p);
		}
		static void destroy(VARIANT* p)
		{
			GenericCopy<VARIANT>::destroy(p);
		}
		static HRESULT copy(VARIANT* pTo, const SourceType* pFrom)
		{
			return CComVariant(*pFrom).Detach(pTo);
		}

	}; // class CopyIfc2Variant< SourceType >

	template < class TheType >
	class CopyIfc
	{
	public :
		static void init(TheType* p)
		{
			GenericCopy<TheType>::init(p);
		}
		static void destroy(TheType* p)
		{
			GenericCopy<TheType>::destroy(p);
		}
		static HRESULT copy(TheType* pTo, const TheType* pFrom)
		{
            ((IUnknown *)(* pFrom))->AddRef();
            *pTo = *pFrom;
			return S_OK;
		}

	}; // class CopyIfc< TheType >

	template <>
	class GenericCopy<VARIANT, long>
	{
	public :
		typedef VARIANT	destination_type;
		typedef long    source_type;

		static void init(destination_type* p)
		{
			GenericCopy<destination_type>::init(p);
		}
		static void destroy(destination_type* p)
		{
			GenericCopy<destination_type>::destroy(p);
		}
		static HRESULT copy(destination_type* pTo, const source_type* pFrom)
		{
			return CComVariant(*pFrom).Detach(pTo);
		}

	}; // class GenericCopy<VARIANT, long>

}; // namespace VCUE

#endif // !defined(_GENERICCOPY_H___36A49827_B15B_11D2_BA63_00C04F8EC847___INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\whistler\vcue_collection.h ===
// This is a part of the Active Template Library. 
// Copyright (C) 1995-1999 Microsoft Corporation
// All rights reserved. 
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

// VCUE_Collection.h
//
// This header contains code that simplifies or enhances use of ATL's collection
// and enumerator classes, ICollectionOnSTLImpl, IEnumOnSTLImpl, CComEnumOnSTL, CComEnumImpl, and CComEnum
//
//////////////////////////////////////////////////////////////////////

#if !defined(_COLLECTION_H___36A49828_B15B_11D2_BA63_00C04F8EC847___INCLUDED_)
#define _COLLECTION_H___36A49828_B15B_11D2_BA63_00C04F8EC847___INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <AtlCom.h>

namespace VCUE
{

// CGenericDataHolder is a class that stores data
// The lifetime of objects of this class is managed via the IUnknown interface
// which makes objects of this class suitable as a source of shared data
// Clients that need access to the data can keep a CGenericDataHolder object alive
// just by holding a COM reference on that object

// This class is used (by default) by ICollectionOnSTLCopyImpl::get__NewEnum to provide data
// to be shared between an enumerator and its clones.

	template < class DataType, class ThreadModel = CComObjectThreadModel >
	class ATL_NO_VTABLE CGenericDataHolder :
		public IUnknown,
		public CComObjectRootEx< ThreadModel >
	{
	public:
		typedef CGenericDataHolder< DataType, ThreadModel > thisClass;

		BEGIN_COM_MAP(thisClass)
			COM_INTERFACE_ENTRY(IUnknown)
		END_COM_MAP()

		template < class SourceType >
		HRESULT Copy(const SourceType& c)
		{
			m_Data = c;
			return S_OK;

		} // HRESULT Copy(const SourceType& c)

		DataType m_Data;

	}; // class ATL_NO_VTABLE CGenericDataHolder

// CreateSTLEnumerator wraps the necessary creation, initialization 
// and error handling code for the the creation of a CComEnumOnSTL-style enumerator
	
// *** EXAMPLE : Using CreateSTLEnumerator to implement get__NewEnum ***
//		typedef CComEnumOnSTL<IEnumVARIANT, &IID_IEnumVARIANT, VARIANT,
//	                     _Copy<VARIANT>, std::vector<CComVariant> > VarVarEnum;
//		std::vector<CComVariant> m_vec;
//		STDMETHOD(get__NewEnum)(IUnknown** ppUnk)
//		{
//			return CreateSTLEnumerator<VarVarEnum>(ppUnk, this, m_vec);
//		}

	template <class EnumType, class CollType>
	HRESULT CreateSTLEnumerator(IUnknown** ppUnk, IUnknown* pUnkForRelease, CollType& collection)
	{
		if (ppUnk == NULL)
			return E_POINTER;
		*ppUnk = NULL;

		CComObject<EnumType>* pEnum = NULL;
		HRESULT hr = CComObject<EnumType>::CreateInstance(&pEnum);

		if (FAILED(hr))
			return hr;

		hr = pEnum->Init(pUnkForRelease, collection);

		if (SUCCEEDED(hr))
			hr = pEnum->QueryInterface(ppUnk);

		if (FAILED(hr))
			delete pEnum;

		return hr;

	} // HRESULT CreateSTLEnumerator(IUnknown** ppUnk, IUnknown* pUnkForRelease, CollType& collection)

// CreateEnumerator wraps the necessary creation, initialization 
// and error handling code for the the creation of a CComEnum-style enumerator

	template <class EnumType, class ElementType>
	HRESULT CreateEnumerator(IUnknown** ppUnk,
							 ElementType* begin, ElementType* end,
							 IUnknown* pUnk,
							 CComEnumFlags flags)
	{
		if (ppUnk == NULL)
			return E_POINTER;
		*ppUnk = NULL;

		CComObject<EnumType>* pEnum = NULL;
		HRESULT hr = CComObject<EnumType>::CreateInstance(&pEnum);

		if (FAILED(hr))
			return hr;

		hr = pEnum->Init(begin, end, pUnk, flags);

		if (SUCCEEDED(hr))
			hr = pEnum->QueryInterface(ppUnk);

		if (FAILED(hr))
			delete pEnum;

		return hr;

	} // CreateEnumerator


// ICollectionOnSTLCopyImpl derives from ICollectionOnSTLImpl and overrides get__NewEnum
// The new implementation provides each enumerator with its own copy of the collection data.
// (Note that this only applies to enumerators returned directly by get__NewEnum.
//  Cloned enumerators use their parent's data as before.
//	This is OK because the enumerator never changes the data)

// Use this class when:
//		The collection can change while there are outstanding enumerators
// And	You don't want to invalidate those enumerators when that happens
// And	You are sure that the performance hit is worth it
// And	You are sure that the way items are copied between containers works correctly
//			(You can adjust this by passing a different class as the Holder parameter)

// Mostly you can use this class in exactly the same 
// way that you would use ICollectionOnSTLImpl.

	template <class T, class CollType, class ItemType, class CopyItem, class EnumType, class Holder = CGenericDataHolder< CollType > >
	class ICollectionOnSTLCopyImpl :
		public ICollectionOnSTLImpl<T, CollType, ItemType, CopyItem, EnumType>
	{
	public :
		STDMETHOD(get__NewEnum)(IUnknown** ppUnk)
		{
			typedef CComObject< Holder > HolderObject;
			HolderObject* p = NULL;
			HRESULT hr = HolderObject::CreateInstance(&p);
			if (FAILED(hr))
				return hr;

			hr = p->Copy(m_coll);
			if (FAILED(hr))
				return hr;

			return CreateSTLEnumerator<EnumType>(ppUnk, p, p->m_Data);
		
		} // STDMETHOD(get__NewEnum)(IUnknown** ppUnk)

	}; // class ICollectionOnSTLCopyImpl

}; // namespace VCUE

#endif // !defined(_COLLECTION_H___36A49828_B15B_11D2_BA63_00C04F8EC847___INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\win2k\faxroute.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    faxroute.h

Abstract:

    This file implements the faxroute interface/object.

Author:

    Wesley Witt (wesw) 13-May-1997

Environment:

    User Mode

--*/

#ifndef __FAXROUTE_H_
#define __FAXROUTE_H_

#include "resource.h"       // main symbols
#include "faxport.h"
#include <winfax.h>


class ATL_NO_VTABLE CFaxRoutingMethods :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CFaxRoutingMethods, &CLSID_FaxRoutingMethods>,
    public IDispatchImpl<IFaxRoutingMethods, &IID_IFaxRoutingMethods, &LIBID_FAXCOMLib>
{
public:
    CFaxRoutingMethods();
    ~CFaxRoutingMethods();
    BOOL Init(CFaxPort *pFaxPort);

DECLARE_REGISTRY_RESOURCEID(IDR_FAXROUTINGMETHODS)

BEGIN_COM_MAP(CFaxRoutingMethods)
    COM_INTERFACE_ENTRY(IFaxRoutingMethods)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

public:    
    STDMETHOD(get_Count)(/*[out, retval]*/ long *pVal);
    STDMETHOD(get_Item)(/*[in]*/ long Index, /*[out, retval]*/ VARIANT *pVal);

private:
    DWORD               m_LastFaxError;
    CFaxPort           *m_pFaxPort;
    DWORD               m_MethodCount;
    CComVariant        *m_VarVect;
};


class ATL_NO_VTABLE CFaxRoutingMethod :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CFaxRoutingMethod, &CLSID_FaxRoutingMethod>,
    public ISupportErrorInfo,
    public IDispatchImpl<IFaxRoutingMethod, &IID_IFaxRoutingMethod, &LIBID_FAXCOMLib>
{
public:
    CFaxRoutingMethod();
    ~CFaxRoutingMethod();
    BOOL Initialize(CFaxPort *pFaxPort,DWORD,BOOL,LPCWSTR,LPCWSTR,LPCWSTR,LPCWSTR,LPCWSTR,LPCWSTR);

DECLARE_REGISTRY_RESOURCEID(IDR_FAXROUTINGMETHOD)
DECLARE_NOT_AGGREGATABLE(CFaxRoutingMethod)

BEGIN_COM_MAP(CFaxRoutingMethod)
    COM_INTERFACE_ENTRY(IFaxRoutingMethod)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

public:
    STDMETHOD(get_RoutingData)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_ExtensionName)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_FriendlyName)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_ImageName)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_FunctionName)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_Guid)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_DeviceName)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_Enable)(/*[out, retval]*/ BOOL *pVal);
    STDMETHOD(put_Enable)(/*[in]*/ BOOL newVal);
    STDMETHOD(get_DeviceId)(/*[out, retval]*/ long *pVal);

private:
    CFaxPort           *m_pFaxPort;
    DWORD               m_LastFaxError;
    DWORD               m_DeviceId;
    BOOL                m_Enabled;
    BSTR                m_DeviceName;
    BSTR                m_Guid;
    BSTR                m_FunctionName;
    BSTR                m_ImageName;
    BSTR                m_FriendlyName;
    BSTR                m_ExtensionName;
    LPBYTE              m_RoutingData;

};

#endif //__FAXROUTE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\win2k\faxdoc.cpp ===
// FaxDoc.cpp : Implementation of CFaxDoc
#include "stdafx.h"
#include "FaxDoc.h"
#include "faxutil.h"

long TotalRows;
long IndexMax = 2;


/////////////////////////////////////////////////////////////////////////////
// CFaxDoc

STDMETHODIMP CFaxDoc::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IFaxDoc,
	};
	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

STDMETHODIMP CFaxDoc::get_FileName(BSTR * pVal)
{
    BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FileName);
    if (!tmp && m_FileName) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
}

STDMETHODIMP CFaxDoc::put_FileName(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    if (m_FileName) {
        SysFreeString( m_FileName);
    }
    m_FileName = tmp;    
    
	return S_OK;
}

STDMETHODIMP CFaxDoc::get_CoverpageName(BSTR * pVal)
{
	BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxCoverpageInfo->CoverPageName);
    if (!tmp && m_FaxCoverpageInfo->CoverPageName) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
       
}

STDMETHODIMP CFaxDoc::put_CoverpageName(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    if (m_CoverpageName) {
        SysFreeString( m_CoverpageName);
    }
    m_CoverpageName = tmp;

    m_FaxCoverpageInfo->CoverPageName = m_CoverpageName;

    return S_OK;
}

STDMETHODIMP CFaxDoc::get_SendCoverpage(BOOL * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }

    __try {
        *pVal = m_SendCoverpage;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        
    }
    
    return E_UNEXPECTED;
	
}

STDMETHODIMP CFaxDoc::put_SendCoverpage(BOOL newVal)
{
	m_SendCoverpage = newVal;

	return S_OK;
}

STDMETHODIMP CFaxDoc::get_ServerCoverpage(BOOL * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }

    __try {
        *pVal = m_FaxCoverpageInfo->UseServerCoverPage;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {

    }
    
    return E_UNEXPECTED;
    
}

STDMETHODIMP CFaxDoc::put_ServerCoverpage(BOOL newVal)
{
	m_FaxCoverpageInfo->UseServerCoverPage = newVal;

	return S_OK;
}

STDMETHODIMP CFaxDoc::get_DiscountSend(BOOL * pVal)
{
    
    if (!pVal) {
        return E_POINTER;
    }

    __try {
        *pVal = m_DiscountSend;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          
    }
    
    return E_UNEXPECTED;
	
}

STDMETHODIMP CFaxDoc::put_DiscountSend(BOOL newVal)
{
	m_DiscountSend = newVal;
	m_FaxJobParams->ScheduleAction = m_DiscountSend ? JSA_DISCOUNT_PERIOD : JSA_NOW;

	return S_OK;
}

STDMETHODIMP CFaxDoc::get_RecipientName(BSTR * pVal)
{
	BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxCoverpageInfo->RecName);
    if (!tmp && m_FaxCoverpageInfo->RecName) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
    
}

STDMETHODIMP CFaxDoc::put_RecipientName(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    if (m_RecipientName) {
        SysFreeString( m_RecipientName);
    }
    m_RecipientName = tmp;

    m_FaxCoverpageInfo->RecName = m_RecipientName;
    m_FaxJobParams->RecipientName = m_RecipientName;

    return S_OK;
}

STDMETHODIMP CFaxDoc::get_RecipientCompany(BSTR * pVal)
{
	BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxCoverpageInfo->RecCompany);
    if (!tmp && m_FaxCoverpageInfo->RecCompany) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
    
}

STDMETHODIMP CFaxDoc::put_RecipientCompany(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    if (m_RecipientCompany) {
        SysFreeString( m_RecipientCompany);
    }
    m_RecipientCompany = tmp;

    m_FaxCoverpageInfo->RecCompany= m_RecipientCompany;

    return S_OK;
}

STDMETHODIMP CFaxDoc::get_RecipientAddress(BSTR * pVal)
{
	BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxCoverpageInfo->RecStreetAddress);
    if (!tmp && m_FaxCoverpageInfo->RecStreetAddress) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;

}

STDMETHODIMP CFaxDoc::put_RecipientAddress(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    if (m_RecipientAddress) {
        SysFreeString( m_RecipientAddress);
    }
    m_RecipientAddress = tmp;

    m_FaxCoverpageInfo->RecStreetAddress = m_RecipientAddress;

    return S_OK;
}

STDMETHODIMP CFaxDoc::get_RecipientCity(BSTR * pVal)
{

    BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxCoverpageInfo->RecCity);
    if (!tmp && m_FaxCoverpageInfo->RecCity) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
	
}

STDMETHODIMP CFaxDoc::put_RecipientCity(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    if (m_RecipientCity) {
        SysFreeString( m_RecipientCity);
    }
    m_RecipientCity = tmp;

    m_FaxCoverpageInfo->RecCity = m_RecipientCity;

    return S_OK;
}

STDMETHODIMP CFaxDoc::get_RecipientState(BSTR * pVal)
{
	BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxCoverpageInfo->RecState);
    if (!tmp && m_FaxCoverpageInfo->RecState) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
        
}

STDMETHODIMP CFaxDoc::put_RecipientState(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    if (m_RecipientState) {
        SysFreeString( m_RecipientState);
    }
    m_RecipientState = tmp;

    m_FaxCoverpageInfo->RecState = m_RecipientState;

    return S_OK;
}

STDMETHODIMP CFaxDoc::get_RecipientZip(BSTR * pVal)
{
	BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxCoverpageInfo->RecZip);
    if (!tmp && m_FaxCoverpageInfo->RecZip) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
        
}

STDMETHODIMP CFaxDoc::put_RecipientZip(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    if (m_RecipientZip) {
        SysFreeString( m_RecipientZip);
    }
    m_RecipientZip = tmp;

    m_FaxCoverpageInfo->RecZip = m_RecipientZip;

    return S_OK;
}

STDMETHODIMP CFaxDoc::get_RecipientCountry(BSTR * pVal)
{
	BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxCoverpageInfo->RecCountry);
    if (!tmp && m_FaxCoverpageInfo->RecCountry) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
        
}

STDMETHODIMP CFaxDoc::put_RecipientCountry(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    if (m_RecipientCountry) {
        SysFreeString( m_RecipientCountry);
    }
    m_RecipientCountry = tmp;

    m_FaxCoverpageInfo->RecCountry = m_RecipientCountry;

	return S_OK;
}

STDMETHODIMP CFaxDoc::get_RecipientTitle(BSTR * pVal)
{
    BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxCoverpageInfo->RecTitle);
    if (!tmp && m_FaxCoverpageInfo->RecTitle) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
    
}

STDMETHODIMP CFaxDoc::put_RecipientTitle(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    if (m_RecipientTitle) {
        SysFreeString( m_RecipientTitle);
    }
    m_RecipientTitle = tmp;

    m_FaxCoverpageInfo->RecTitle = m_RecipientTitle;

    return S_OK;
}

STDMETHODIMP CFaxDoc::get_RecipientDepartment(BSTR * pVal)
{
	BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxCoverpageInfo->RecDepartment);
    if (!tmp && m_FaxCoverpageInfo->RecDepartment) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
    
}

STDMETHODIMP CFaxDoc::put_RecipientDepartment(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    if (m_RecipientDepartment) {
        SysFreeString( m_RecipientDepartment);
    }
    m_RecipientDepartment = tmp;

    m_FaxCoverpageInfo->RecDepartment = m_RecipientDepartment;

	return S_OK;
}

STDMETHODIMP CFaxDoc::get_RecipientOffice(BSTR * pVal)
{
	BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxCoverpageInfo->RecOfficeLocation);
    if (!tmp && m_FaxCoverpageInfo->RecOfficeLocation) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
    
}

STDMETHODIMP CFaxDoc::put_RecipientOffice(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    if (m_RecipientOffice) {
        SysFreeString( m_RecipientOffice);
    }
    m_RecipientOffice = tmp;

    m_FaxCoverpageInfo->RecOfficeLocation = m_RecipientOffice;

    return S_OK;
}

STDMETHODIMP CFaxDoc::get_RecipientHomePhone(BSTR * pVal)
{
	BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxCoverpageInfo->RecHomePhone);
    if (!tmp && m_FaxCoverpageInfo->RecHomePhone) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
    
}

STDMETHODIMP CFaxDoc::put_RecipientHomePhone(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    if (m_RecipientHomePhone) {
        SysFreeString( m_RecipientHomePhone);
    }
    m_RecipientHomePhone = tmp;

    m_FaxCoverpageInfo->RecHomePhone = m_RecipientHomePhone;

    return S_OK;
}

STDMETHODIMP CFaxDoc::get_RecipientOfficePhone(BSTR * pVal)
{
	BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxCoverpageInfo->RecOfficePhone);
    if (!tmp && m_FaxCoverpageInfo->RecOfficePhone ) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
}

STDMETHODIMP CFaxDoc::put_RecipientOfficePhone(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    if (m_RecipientOfficePhone) {
        SysFreeString( m_RecipientOfficePhone);
    }
    m_RecipientOfficePhone = tmp;

    m_FaxCoverpageInfo->RecOfficePhone = m_RecipientOfficePhone;

    return S_OK;
}

STDMETHODIMP CFaxDoc::get_SenderFax(BSTR * pVal)
{
	BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_SenderFax);
    if (!tmp && m_SenderFax) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
}

STDMETHODIMP CFaxDoc::put_SenderFax(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    if (m_SenderFax) {
        SysFreeString( m_SenderFax);
    }
    m_SenderFax = tmp;

    m_FaxCoverpageInfo->SdrFaxNumber = m_SenderFax;

    return S_OK;
}


STDMETHODIMP CFaxDoc::get_SenderName(BSTR * pVal)
{
	BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxCoverpageInfo->SdrName);
    if (!tmp && m_FaxCoverpageInfo->SdrName) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
    
}

STDMETHODIMP CFaxDoc::put_SenderName(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    if (m_SenderName) {
        SysFreeString( m_SenderName);
    }
    m_SenderName = tmp;

    m_FaxCoverpageInfo->SdrName = m_SenderName;
    m_FaxJobParams->SenderName = m_SenderName;

    return S_OK;
}

STDMETHODIMP CFaxDoc::get_SenderCompany(BSTR * pVal)
{
	BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxCoverpageInfo->SdrCompany);
    if (!tmp && m_FaxCoverpageInfo->SdrCompany) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
    
}

STDMETHODIMP CFaxDoc::put_SenderCompany(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    if (m_SenderCompany) {
        SysFreeString( m_SenderCompany);
    }
    m_SenderCompany = tmp;

    m_FaxCoverpageInfo->SdrCompany = m_SenderCompany;
    m_FaxJobParams->SenderCompany = m_SenderCompany;

    return S_OK;
}

STDMETHODIMP CFaxDoc::get_SenderAddress(BSTR * pVal)
{
    BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxCoverpageInfo->SdrAddress);
    if (!tmp && m_FaxCoverpageInfo->SdrAddress) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
}

STDMETHODIMP CFaxDoc::put_SenderAddress(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    if (m_SenderAddress) {
        SysFreeString( m_SenderAddress);
    }
    m_SenderAddress = tmp;

    m_FaxCoverpageInfo->SdrAddress = m_SenderAddress;

    return S_OK;
}

STDMETHODIMP CFaxDoc::get_SenderTitle(BSTR * pVal)
{
    BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxCoverpageInfo->SdrTitle);
    if (!tmp && m_FaxCoverpageInfo->SdrTitle) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
	
}

STDMETHODIMP CFaxDoc::put_SenderTitle(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    if (m_SenderTitle) {
        SysFreeString( m_SenderTitle);
    }
    m_SenderTitle = tmp;

    m_FaxCoverpageInfo->SdrTitle = m_SenderTitle;

    return S_OK;
}

STDMETHODIMP CFaxDoc::get_SenderDepartment(BSTR * pVal)
{
	BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxCoverpageInfo->SdrDepartment);
    if (!tmp && m_FaxCoverpageInfo->SdrDepartment) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
    
}

STDMETHODIMP CFaxDoc::put_SenderDepartment(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    if (m_SenderDepartment) {
        SysFreeString( m_SenderDepartment);
    }
    m_SenderDepartment = tmp;

    m_FaxCoverpageInfo->SdrDepartment = m_SenderDepartment;
    m_FaxJobParams->SenderDept = m_SenderDepartment;

    return S_OK;
}

STDMETHODIMP CFaxDoc::get_SenderOffice(BSTR * pVal)
{
	BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxCoverpageInfo->SdrOfficeLocation);
    if (!tmp && m_FaxCoverpageInfo->SdrOfficeLocation) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
    
}

STDMETHODIMP CFaxDoc::put_SenderOffice(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    if (m_SenderOfficeLocation) {
        SysFreeString( m_SenderOfficeLocation);
    }
    m_SenderOfficeLocation = tmp;

    m_FaxCoverpageInfo->SdrOfficeLocation = m_SenderOfficeLocation;

    return S_OK;
}

STDMETHODIMP CFaxDoc::get_SenderHomePhone(BSTR * pVal)
{
	BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxCoverpageInfo->SdrHomePhone);
    if (!tmp && m_FaxCoverpageInfo->SdrHomePhone) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
    
}

STDMETHODIMP CFaxDoc::put_SenderHomePhone(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    if (m_SenderHomePhone) {
        SysFreeString( m_SenderHomePhone);
    }
    m_SenderHomePhone = tmp;

    m_FaxCoverpageInfo->SdrHomePhone = m_SenderHomePhone;

    return S_OK;
}

STDMETHODIMP CFaxDoc::get_SenderOfficePhone(BSTR * pVal)
{
	BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxCoverpageInfo->SdrOfficePhone);
    if (!tmp && m_FaxCoverpageInfo->SdrOfficePhone) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
        
}

STDMETHODIMP CFaxDoc::put_SenderOfficePhone(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }

    if (m_SenderOfficePhone) {
        SysFreeString( m_SenderOfficePhone);
    }
    m_SenderOfficePhone = tmp;

    m_FaxCoverpageInfo->SdrOfficePhone = m_SenderOfficePhone;

    return S_OK;
}

STDMETHODIMP CFaxDoc::get_CoverpageNote(BSTR * pVal)
{
	BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxCoverpageInfo->Note);
    if (!tmp && m_FaxCoverpageInfo->Note) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
    	
}

STDMETHODIMP CFaxDoc::put_CoverpageNote(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    if (m_Note) {
        SysFreeString( m_Note);
    }
    m_Note = tmp;

    m_FaxCoverpageInfo->Note = m_Note;

    return S_OK;
}

STDMETHODIMP CFaxDoc::get_CoverpageSubject(BSTR * pVal)
{
	BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxCoverpageInfo->Subject);
    if (!tmp && m_FaxCoverpageInfo->Subject) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
    
}

STDMETHODIMP CFaxDoc::put_CoverpageSubject(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    if (m_Subject) {
        SysFreeString( m_Subject);
    }
    m_Subject = tmp;

    m_FaxCoverpageInfo->Subject = m_Subject;

    return S_OK;
}

STDMETHODIMP CFaxDoc::get_Tsid(BSTR * pVal)
{
	BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxJobParams->Tsid);
    if (!tmp && m_FaxJobParams->Tsid) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
    
}

STDMETHODIMP CFaxDoc::put_Tsid(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    if (m_Tsid) {
        SysFreeString( m_Tsid);
    }
    m_Tsid = tmp;

    m_FaxJobParams->Tsid = m_Tsid;

    return S_OK;
}

STDMETHODIMP CFaxDoc::get_BillingCode(BSTR * pVal)
{
	BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxJobParams->BillingCode);
    if (!tmp && m_FaxJobParams->BillingCode) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
    
}

STDMETHODIMP CFaxDoc::put_BillingCode(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }

    if (m_BillingCode) {
        SysFreeString( m_BillingCode );
    }
    m_BillingCode = tmp;

    m_FaxJobParams->BillingCode = m_BillingCode;
        
    return S_OK;
}

STDMETHODIMP CFaxDoc::get_EmailAddress(BSTR * pVal)
{
	BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxJobParams->DeliveryReportAddress);
    if (!tmp && m_FaxJobParams->DeliveryReportAddress) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
    	
}

STDMETHODIMP CFaxDoc::put_EmailAddress(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    if (m_EmailAddress) {
        SysFreeString( m_EmailAddress);
    }
    m_EmailAddress = tmp;

    m_FaxJobParams->DeliveryReportAddress = m_EmailAddress;

    return S_OK;
}

STDMETHODIMP CFaxDoc::get_DisplayName(BSTR * pVal)
{
	BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxJobParams->DocumentName);
    if (!tmp && m_FaxJobParams->DocumentName) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;
    	
}

STDMETHODIMP CFaxDoc::put_DisplayName(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }

    if (m_DocumentName) {
        SysFreeString( m_DocumentName);
    }
    m_DocumentName = tmp;

    m_FaxJobParams->DocumentName = m_DocumentName;

    return S_OK;
}

STDMETHODIMP CFaxDoc::Send(long * pVal)
{
    
    //
    // user must specify a file name.
    // if user specifies a fax number, use that. 
    // else use the tapi call handle or connection object if it's there
    //
    if (!m_FileName) {
       return E_INVALIDARG;
    }

    if (!m_FaxJobParams->RecipientNumber) {
       //
       // see if they have a call handle or a connection object
       //
       if (!m_FaxJobParams->CallHandle) {       
          if (!m_TapiConnectionObject) {        
              return E_INVALIDARG;
          } else {
             m_FaxJobParams->Reserved[0] = 0xFFFF1234;
             m_FaxJobParams->Reserved[1] = (ULONG_PTR)m_TapiConnectionObject;
          }
       }
    }
    
    if (!FaxSendDocument(m_pFaxServer->GetFaxHandle(),
                         m_FileName,
                         m_FaxJobParams,
                         m_SendCoverpage ? m_FaxCoverpageInfo : NULL,
                         &m_JobId) ) {
        return Fax_HRESULT_FROM_WIN32(GetLastError());
    }

    if (m_TapiConnectionObject) {
       m_TapiConnectionObject->Release();
       m_TapiConnectionObject = NULL;
    }

    *pVal = m_JobId;

	return S_OK;
}

STDMETHODIMP CFaxDoc::get_FaxNumber(BSTR * pVal)
{
	BSTR tmp;
    
    if (!pVal) {
        return E_POINTER;
    }

    tmp = SysAllocString (m_FaxJobParams->RecipientNumber);
    if (!tmp && m_FaxJobParams->RecipientNumber) {
        return E_OUTOFMEMORY;
    }

    __try {
        *pVal = tmp;

        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
          SysFreeString( tmp );
    }
    
    return E_UNEXPECTED;

}

STDMETHODIMP CFaxDoc::put_FaxNumber(BSTR newVal)
{
    BSTR tmp = SysAllocString( newVal );
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    if (m_FaxNumber) {
        SysFreeString( m_FaxNumber);
    }
    m_FaxNumber = tmp;

    m_FaxCoverpageInfo->RecFaxNumber = m_FaxNumber;
    m_FaxJobParams->RecipientNumber = m_FaxNumber;

    return S_OK;
}

CFaxDoc::~CFaxDoc()
{
    if (m_FaxJobParams) {
        FaxFreeBuffer(m_FaxJobParams);
    }

    if (m_FaxCoverpageInfo) {
    FaxFreeBuffer(m_FaxCoverpageInfo);
    }

    if (m_pFaxServer) {
        m_pFaxServer->Release();
    }

    if (m_FileName) {
        SysFreeString( m_FileName);
    }

    if (m_FaxNumber) {
        SysFreeString( m_FaxNumber);
    }

    if (m_Tsid) {
        SysFreeString( m_Tsid);
    }
    if (m_BillingCode) {
        SysFreeString( m_BillingCode);
    }
    if (m_EmailAddress) {
        SysFreeString( m_EmailAddress);
    }
    if (m_DocumentName) {
        SysFreeString(m_DocumentName);
    }
    if (m_Note) {
        SysFreeString( m_Note);
    }
    if (m_Subject) {
        SysFreeString( m_Subject);
    }
    if (m_CoverpageName) {
        SysFreeString( m_CoverpageName);
    }
    if (m_RecipientName) {
        SysFreeString( m_RecipientName);
    }
    if (m_RecipientNumber) {
        SysFreeString( m_RecipientNumber);
    }
    if (m_RecipientCompany) {
        SysFreeString( m_RecipientCompany);
    }
    if (m_RecipientAddress) {
        SysFreeString(m_RecipientAddress);
    }
    if (m_RecipientCity) {
        SysFreeString(m_RecipientCity);
    }
    if (m_RecipientState) {
        SysFreeString(m_RecipientState);
    }
    if (m_RecipientZip) {
        SysFreeString(m_RecipientZip);
    }
    if (m_RecipientCountry) {
        SysFreeString(m_RecipientCountry);
    }
    if (m_RecipientTitle) {
        SysFreeString(m_RecipientTitle);
    }
    if (m_RecipientDepartment) {
        SysFreeString(m_RecipientDepartment);
    }
    if (m_RecipientOffice) {
        SysFreeString(m_RecipientOffice);
    }
    if (m_RecipientHomePhone) {
        SysFreeString(m_RecipientHomePhone);
    }
    if (m_RecipientOfficePhone) {
        SysFreeString(m_RecipientOfficePhone);
    }
    if (m_SenderName) {
        SysFreeString(m_SenderName);
    }
    if (m_SenderCompany) {
        SysFreeString(m_SenderCompany);
    }
    if (m_SenderAddress) {
        SysFreeString(m_SenderAddress);
    }
    if (m_SenderTitle) {
        SysFreeString(m_SenderTitle);
    }
    if (m_SenderDepartment) {
        SysFreeString(m_SenderDepartment);
    }
    if (m_SenderFax) {
        SysFreeString(m_SenderFax);
    }    
    if (m_SenderOfficeLocation) {
        SysFreeString(m_SenderOfficeLocation);
    }
    if (m_SenderHomePhone) {
        SysFreeString(m_SenderHomePhone);
    }
    if (m_SenderOfficePhone) {
        SysFreeString(m_SenderOfficePhone);
    }

}

BOOL CFaxDoc::Init(BSTR FileName, CFaxServer * pFaxServer)
{
    HRESULT hr;
    
    m_pFaxServer = pFaxServer;

    //
    // make sure our fax handle doesn't get destroyed
    //
    hr = m_pFaxServer->AddRef();
    if (FAILED(hr)) {
        m_pFaxServer = NULL;
        return FALSE;
    }

    //
    // save our filename
    // 
    hr = put_FileName(FileName);
    if (FAILED(hr)) {
        return FALSE;
    }

    return TRUE;

}

STDMETHODIMP CFaxDoc::putref_ConnectionObject(IDispatch* newVal)
{
    if (!newVal) {
       return E_POINTER;
    }

    if (m_TapiConnectionObject) {
        m_TapiConnectionObject->Release();
        m_TapiConnectionObject = NULL;
    }

    HRESULT hr = newVal->QueryInterface(IID_IDispatch,(void**) &m_TapiConnectionObject);
    if (FAILED(hr)) {
       return hr;
    }
        
    return S_OK;
}

STDMETHODIMP CFaxDoc::put_CallHandle(long newVal)
{
    if (!newVal) {
       return E_INVALIDARG;
    }
    
    m_FaxJobParams->CallHandle = (HCALL)newVal;

    return S_OK;
}

STDMETHODIMP CFaxDoc::get_CallHandle(long *pVal)
{	    
    if (!pVal) {
       return E_POINTER;
    }
    
    __try {
        *pVal = (long)m_FaxJobParams->CallHandle;
    } __except (EXCEPTION_EXECUTE_HANDLER) {

    }

    return S_OK;
}

#ifdef FAXBROADCAST_ENABLED
STDMETHODIMP CFaxDoc::Broadcast(VARIANT pVal)
{
    IDispatch* pDisp;
//    IUnknown* pUnk;
    ADORecordset* prs;
    HRESULT hr;
    long CurrentRow = 0;    
    VARIANT vBookmark, rgvFields;
    VARIANT cRows;
//    VARIANT varField, varNewField;    

    //
    // user must specify a file name.
    //
    if (!m_FileName) {
       return E_INVALIDARG;
    }

    if (pVal.vt != VT_DISPATCH) {
       return E_FAIL;
    }

    pDisp = pVal.pdispVal;

    hr = pDisp->QueryInterface( IID_IADORecordset, (void**) prs );
    if (FAILED(hr)) {
       return hr;
    }

    //
    //Start from the current place
    //
    vBookmark.vt = VT_ERROR;
    vBookmark.scode = DISP_E_PARAMNOTFOUND;
    
    //
    // Get all columns
    //
    rgvFields.vt = VT_ERROR;
    rgvFields.scode = DISP_E_PARAMNOTFOUND;
         
    //
    // get the rows
    //
    hr = prs->GetRows(adGetRowsRest,
                      vBookmark,
                      rgvFields,
                      &cRows );
    if (FAILED(hr)) {
       DebugPrint(( TEXT("GetRows failed, ec = %x\n"), hr ));       
       prs->Release();
       return hr;;
    }
   
    m_pVariant = &cRows;

    //
    // find out the number of rows retreived
    //
    hr = SafeArrayGetUBound(cRows.parray, 2, &TotalRows);
    if (FAILED(hr)) {
       DebugPrint(( TEXT("SafeArrayGetUBound failed, ec=%x\n"), hr ));       
       prs->Release();
       return hr;
    }
   
    DebugPrint(( TEXT("There are %d rows in the datasource\n"), TotalRows ));

        
    if (!FaxSendDocumentForBroadcast(m_pFaxServer->GetFaxHandle(),
                                     m_DocumentName,
                                     &m_JobId,
                                     BroadcastCallback,
                                     (VOID *)this) ) {
        prs->Release();
        return Fax_HRESULT_FROM_WIN32(GetLastError());
    }

    prs->Release();

    return S_OK;
}

LPTSTR
StringDup(
   LPTSTR src
   )
{
   LPTSTR dst;

   if (!src) {
      return NULL;
   }

   dst = (LPTSTR) HeapAlloc( GetProcessHeap(), 0, (lstrlen(src)+1)*sizeof(TCHAR) );
   if (!dst) {
      return NULL;
   }

   lstrcpy(dst, src);

   return dst;

}


BOOL 
CFaxDoc::FreeCoverpageAndJobInfo(PFAX_JOB_PARAMW JobParams,PFAX_COVERPAGE_INFOW CoverpageInfo) {


#define MyFreeString(TargetString) if (TargetString) { \
        HeapFree(GetProcessHeap(), 0, TargetString); \
        }

  MyFreeString(JobParams->RecipientNumber);
  MyFreeString(JobParams->RecipientName);
  MyFreeString(JobParams->Tsid);
  MyFreeString(JobParams->SenderName);
  MyFreeString(JobParams->SenderDept);
  MyFreeString(JobParams->SenderCompany);
  MyFreeString(JobParams->BillingCode);
  MyFreeString(JobParams->DeliveryReportAddress);
  MyFreeString(JobParams->DocumentName);
  
  MyFreeString(CoverpageInfo->CoverPageName);
  MyFreeString(CoverpageInfo->RecName);
  MyFreeString(CoverpageInfo->RecFaxNumber);
  MyFreeString(CoverpageInfo->RecCompany);
  MyFreeString(CoverpageInfo->RecStreetAddress);
  MyFreeString(CoverpageInfo->RecCity);
  MyFreeString(CoverpageInfo->RecState);
  MyFreeString(CoverpageInfo->RecZip);
  MyFreeString(CoverpageInfo->RecCountry);
  MyFreeString(CoverpageInfo->RecTitle);
  MyFreeString(CoverpageInfo->RecDepartment);
  MyFreeString(CoverpageInfo->RecOfficeLocation);
  MyFreeString(CoverpageInfo->RecHomePhone);
  MyFreeString(CoverpageInfo->RecOfficePhone);
  MyFreeString(CoverpageInfo->SdrName);
  MyFreeString(CoverpageInfo->SdrFaxNumber);
  MyFreeString(CoverpageInfo->SdrCompany);
  MyFreeString(CoverpageInfo->SdrAddress);
  MyFreeString(CoverpageInfo->SdrTitle);
  MyFreeString(CoverpageInfo->SdrDepartment);
  MyFreeString(CoverpageInfo->SdrOfficeLocation);
  MyFreeString(CoverpageInfo->SdrHomePhone);
  MyFreeString(CoverpageInfo->SdrOfficePhone);
  MyFreeString(CoverpageInfo->Note);
  MyFreeString(CoverpageInfo->Subject);  
  
  return TRUE;
}



BOOL CALLBACK
BroadcastCallback(
   HANDLE FaxHandle,
   DWORD RecipientNumber,
   LPVOID Context,
   PFAX_JOB_PARAMW JobParams,
   PFAX_COVERPAGE_INFOW CoverpageInfo OPTIONAL
   )
/*++

Routine Description:

    main faxback callback function

Arguments:

    FaxHandle - handle to fax service
    RecipientNumber - number of times this function has been called
    Context - context info (in our case, a ADORecordset pointer)
    JobParams - pointer to a FAX_JOB_PARAM structure to receive our information
    CoverpageInfo - pointer to a FAX_COVERPAGE_INFO structure to receive our information

Return Value:

    TRUE -- use the data we set, FALSE, done sending data back to fax service.                                             

--*/

{
   CFaxDoc* pFaxDoc = (CFaxDoc*) Context;
   VARIANT* theData = pFaxDoc->m_pVariant;

   if (RecipientNumber > (DWORD) TotalRows) {
      return FALSE;
   }

   //
   // get the next recipient
   //
   pFaxDoc->RetrieveRecipientData(theData,RecipientNumber, JobParams, CoverpageInfo);
   pFaxDoc->RetrieveSenderData(JobParams,CoverpageInfo);

   if (!JobParams->RecipientNumber) {
      DebugPrint(( TEXT("required data RecipientNumber not retreived\n") ));
      pFaxDoc->FreeCoverpageAndJobInfo(JobParams, CoverpageInfo);
      return FALSE;
   }

   return TRUE;

}

VOID
CFaxDoc::InsertTextIntoStructure(
   LPTSTR txt,
   long i,
   PFAX_JOB_PARAMW pjp,
   PFAX_COVERPAGE_INFOW pci
   ) 
{

   switch(i) {
      case 0:
         pjp->RecipientNumber = txt;
         pci->RecFaxNumber = txt;
         break;
      case 1:
         pjp->RecipientName = txt;
         pci->RecName;
         break;
      case 2:
         pci->Note = txt;
         break;
      case 3:
         pci->Subject = txt;
         break;      
      case 4:
         pci->CoverPageName = txt;
         break;
      case 5:
         pci->RecCompany = txt;
         break;
      case 6:
         pci->RecStreetAddress = txt;
         break;
      case 7:
         pci->RecCity = txt;
         break;
      case 8:
         pci->RecState = txt;
         break;
      case 9:
         pci->RecZip = txt;
         break;
      case 10:
         pci->RecCountry = txt;
         break;
      case 11:
         pci->RecTitle = txt;
         break;
      case 12:
         pci->RecDepartment = txt;
         break;
      case 13:
         pci->RecOfficeLocation = txt;
         break;
      case 14:
         pci->RecHomePhone = txt;
         break;
      case 15:
         pci->RecOfficePhone = txt;
         break;      

   }

   return;

}


BOOL
CFaxDoc::RetrieveRecipientData(
   VARIANT* theData,
   DWORD DataIndex, 
   PFAX_JOB_PARAMW JobParams,
   PFAX_COVERPAGE_INFOW CoverpageInfo)
{

   long Index[2];
//   BSTR strData;
   VARIANT vData, vNew;
   LPTSTR txtData;
   HRESULT hr;

   Index[1] = DataIndex;
   Index[0] = 0;

   for (Index[0] = 0; Index[0] < IndexMax ; Index[0]++) {  
       hr = SafeArrayGetElement( theData->parray, &Index[0], &vData );
       if (FAILED(hr)) {
          DebugPrint(( TEXT("SafeArrayGetElement failed, ec=hr\n"), hr ));
          return FALSE;
       }

       //
       // make sure it's a string
       //
       hr = VariantChangeType(&vNew, &vData, 0, VT_BSTR);
       if (FAILED(hr)) {
          DebugPrint(( TEXT("VariantChangeType failed, ec=hr\n"), hr ));
          return FALSE;
       }

       txtData = StringDup( vNew.bstrVal );
       InsertTextIntoStructure( txtData, Index[0], JobParams, CoverpageInfo );

   }

   return TRUE;

}

BOOL
CFaxDoc::RetrieveSenderData(
   PFAX_JOB_PARAMW pjp,
   PFAX_COVERPAGE_INFOW pci)
{

   pjp->Tsid = StringDup(m_FaxJobParams->Tsid);
   pjp->SenderName = StringDup(m_FaxJobParams->SenderName);
   pjp->SenderCompany = StringDup(m_FaxJobParams->SenderCompany);
   pjp->SenderDept= StringDup(m_FaxJobParams->SenderDept);
   pjp->BillingCode = StringDup(m_FaxJobParams->BillingCode);
   pjp->ScheduleAction = JSA_NOW; // when to schedule the fax, see JSA defines
   pjp->DeliveryReportAddress = StringDup(m_FaxJobParams->EmailAddress); // email address for delivery report (ndr or dr)
   pjp->DeliveryReportType = DRT_NONE; 
   pjp->DocumentName = StringDup(m_FaxJobParams->DocumentName);
      
   pci->SdrName = StringDup(m_FaxCoverpageInfo->SdrName);
   pci->SdrFaxNumber = StringDup(m_FaxCoverpageInfo->SdrFaxNumber);
   pci->SdrCompany = StringDup(m_FaxCoverpageInfo->SdrCompany);
   pci->SdrAddress = StringDup(m_FaxCoverpageInfo->SdrAddress);
   pci->SdrTitle = StringDup(m_FaxCoverpageInfo->SdrTitle);
   pci->SdrDepartment = StringDup(m_FaxCoverpageInfo->SdrDepartment);
   pci->SdrOfficeLocation = StringDup(m_FaxCoverpageInfo->SdrOfficeLocation);
   pci->SdrHomePhone = StringDup(m_FaxCoverpageInfo->SdrHomePhone);
   pci->SdrOfficePhone = StringDup(m_FaxCoverpageInfo->SdrOfficePhone);

   return TRUE;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\win2k\faxdoc.h ===
// FaxDoc.h : Declaration of the CFaxDoc

#ifndef __FAXDOC_H_
#define __FAXDOC_H_

#include "resource.h"       // main symbols
#include "faxsvr.h"
#include <winfax.h>
#ifdef FAXBROADCAST_ENABLED
   #include "adoid.h"
   #include "adoint.h"
#endif
/////////////////////////////////////////////////////////////////////////////
// CFaxDoc
class ATL_NO_VTABLE CFaxDoc : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CFaxDoc, &CLSID_FaxDoc>,
	public ISupportErrorInfo,
	public IDispatchImpl<IFaxDoc, &IID_IFaxDoc, &LIBID_FAXCOMLib>
{
public:
	CFaxDoc()
	{
        m_DiscountSend = FALSE;
        m_SendCoverpage = FALSE;
        m_FaxCoverpageInfo = NULL;
        m_FaxJobParams = NULL;
        m_FileName = NULL;
        m_JobId = 0;
        m_TapiConnectionObject = NULL;

        CFaxServer* m_pFaxServer = NULL;
        m_FaxNumber = NULL;
        m_Tsid = NULL;
        m_BillingCode = NULL;
        m_EmailAddress = NULL;;
        m_DocumentName = NULL;;    
        m_Note = NULL;
        m_Subject = NULL;
        m_CoverpageName = NULL;
        m_RecipientName = NULL;
        m_RecipientNumber = NULL;
        m_RecipientCompany = NULL;
        m_RecipientAddress = NULL;
        m_RecipientCity = NULL;
        m_RecipientState = NULL;
        m_RecipientZip = NULL;
        m_RecipientCountry = NULL;
        m_RecipientTitle = NULL;
        m_RecipientDepartment = NULL;
        m_RecipientOffice = NULL;
        m_RecipientHomePhone = NULL;
        m_RecipientOfficePhone = NULL;
        m_SenderName = NULL;
        m_SenderCompany = NULL;
        m_SenderAddress = NULL;
        m_SenderTitle = NULL;
        m_SenderDepartment = NULL;
        m_SenderOfficeLocation = NULL;
        m_SenderHomePhone = NULL;
        m_SenderOfficePhone = NULL;
        m_SenderFax = NULL;


        //
        // prefill in the params...
        //

        FaxCompleteJobParams(&m_FaxJobParams,&m_FaxCoverpageInfo);

        if (m_FaxJobParams && m_FaxCoverpageInfo) {
        
            m_CoverpageName        =SysAllocString(m_FaxCoverpageInfo->CoverPageName);
            m_RecipientName        =SysAllocString(m_FaxCoverpageInfo->RecName);
            m_RecipientNumber      =SysAllocString(m_FaxCoverpageInfo->RecFaxNumber);
            m_RecipientCompany     =SysAllocString(m_FaxCoverpageInfo->RecCompany);
            m_RecipientAddress     =SysAllocString(m_FaxCoverpageInfo->RecStreetAddress);
            m_RecipientCity        =SysAllocString(m_FaxCoverpageInfo->RecCity);
            m_RecipientState       =SysAllocString(m_FaxCoverpageInfo->RecState);
            m_RecipientZip         =SysAllocString(m_FaxCoverpageInfo->RecZip);
            m_RecipientCountry     =SysAllocString(m_FaxCoverpageInfo->RecCountry);
            m_RecipientTitle       =SysAllocString(m_FaxCoverpageInfo->RecTitle);
            m_RecipientDepartment  =SysAllocString(m_FaxCoverpageInfo->RecDepartment);
            m_RecipientOffice      =SysAllocString(m_FaxCoverpageInfo->RecOfficeLocation);
            m_RecipientHomePhone   =SysAllocString(m_FaxCoverpageInfo->RecHomePhone);
            m_RecipientOfficePhone =SysAllocString(m_FaxCoverpageInfo->RecOfficePhone);
            m_SenderName           =SysAllocString(m_FaxCoverpageInfo->SdrName);
            m_SenderFax            =SysAllocString(m_FaxCoverpageInfo->SdrFaxNumber);
            m_SenderCompany        =SysAllocString(m_FaxCoverpageInfo->SdrCompany);
            m_SenderAddress        =SysAllocString(m_FaxCoverpageInfo->SdrAddress);
            m_SenderTitle          =SysAllocString(m_FaxCoverpageInfo->SdrTitle);
            m_SenderDepartment     =SysAllocString(m_FaxCoverpageInfo->SdrDepartment);
            m_SenderOfficeLocation =SysAllocString(m_FaxCoverpageInfo->SdrOfficeLocation);
            m_SenderHomePhone      =SysAllocString(m_FaxCoverpageInfo->SdrHomePhone);
            m_SenderOfficePhone    =SysAllocString(m_FaxCoverpageInfo->SdrOfficePhone);
            m_Note                 =SysAllocString(m_FaxCoverpageInfo->Note);
            m_Subject              =SysAllocString(m_FaxCoverpageInfo->Subject);               
            m_Tsid                 =SysAllocString(m_FaxJobParams->Tsid);
            m_BillingCode          =SysAllocString(m_FaxJobParams->BillingCode);
            m_EmailAddress         =SysAllocString(m_FaxJobParams->DeliveryReportAddress);
            m_DocumentName         =SysAllocString(m_FaxJobParams->DocumentName);
        
        }

	}
    

DECLARE_REGISTRY_RESOURCEID(IDR_FAXDOC)

BEGIN_COM_MAP(CFaxDoc)
	COM_INTERFACE_ENTRY(IFaxDoc)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IFaxDoc
public:
    ~CFaxDoc();
	BOOL Init(BSTR FileName,CFaxServer *pFaxServer);
	BOOL SetJob();
	STDMETHOD(get_FaxNumber)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_FaxNumber)(/*[in]*/ BSTR newVal);
	STDMETHOD(Send)(/*[out, retval]*/long *pVal);
	STDMETHOD(get_DisplayName)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_DisplayName)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_EmailAddress)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_EmailAddress)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_BillingCode)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_BillingCode)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_Tsid)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_Tsid)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_CoverpageSubject)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_CoverpageSubject)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_CoverpageNote)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_CoverpageNote)(/*[in]*/ BSTR newVal);
    STDMETHOD(get_SenderFax)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_SenderFax)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_SenderOfficePhone)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_SenderOfficePhone)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_SenderHomePhone)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_SenderHomePhone)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_SenderOffice)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_SenderOffice)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_SenderDepartment)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_SenderDepartment)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_SenderTitle)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_SenderTitle)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_SenderAddress)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_SenderAddress)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_SenderCompany)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_SenderCompany)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_SenderName)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_SenderName)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_RecipientOfficePhone)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_RecipientOfficePhone)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_RecipientHomePhone)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_RecipientHomePhone)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_RecipientOffice)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_RecipientOffice)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_RecipientDepartment)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_RecipientDepartment)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_RecipientTitle)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_RecipientTitle)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_RecipientCountry)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_RecipientCountry)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_RecipientZip)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_RecipientZip)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_RecipientState)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_RecipientState)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_RecipientCity)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_RecipientCity)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_RecipientAddress)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_RecipientAddress)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_RecipientCompany)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_RecipientCompany)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_RecipientName)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_RecipientName)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_DiscountSend)(/*[out, retval]*/ BOOL *pVal);
	STDMETHOD(put_DiscountSend)(/*[in]*/ BOOL newVal);
	STDMETHOD(get_ServerCoverpage)(/*[out, retval]*/ BOOL *pVal);
	STDMETHOD(put_ServerCoverpage)(/*[in]*/ BOOL newVal);
	STDMETHOD(get_SendCoverpage)(/*[out, retval]*/ BOOL *pVal);
	STDMETHOD(put_SendCoverpage)(/*[in]*/ BOOL newVal);
	STDMETHOD(get_CoverpageName)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_CoverpageName)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_FileName)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_FileName)(/*[in]*/ BSTR newVal);
   STDMETHOD(putref_ConnectionObject)(/*[in]*/ IDispatch* newVal);
   STDMETHOD(get_CallHandle)(/*[out, retval]*/ long *pVal);
   STDMETHOD(put_CallHandle)(/*[in]*/ long newVal);
#ifdef FAXBROADCAST_ENABLED
   STDMETHOD(Broadcast)(VARIANT pVal);

   friend BOOL CALLBACK BroadcastCallback(HANDLE FaxHandle,
                                DWORD RecipientNumber,
                                LPVOID Context,
                                PFAX_JOB_PARAMW JobParams,
                                PFAX_COVERPAGE_INFOW CoverpageInfo
                                );
#endif

private:
	CFaxServer* m_pFaxServer;
	BOOL m_DiscountSend;
	BOOL m_SendCoverpage;
	DWORD m_JobId;
	PFAX_COVERPAGE_INFO m_FaxCoverpageInfo;
	PFAX_JOB_PARAM m_FaxJobParams;
	BSTR m_FileName;
   IDispatch* m_TapiConnectionObject;
   
   VARIANT* m_pVariant;

    //
    // job info
    //
    BSTR m_FaxNumber;
    BSTR m_Tsid;
    BSTR m_BillingCode;
    BSTR m_EmailAddress;
    BSTR m_DocumentName;
    //
    // coverpage info
    //
    BSTR m_Note;
    BSTR m_Subject;
    BSTR m_CoverpageName;
    BSTR m_RecipientName;
    BSTR m_RecipientNumber;
    BSTR m_RecipientCompany;
    BSTR m_RecipientAddress;
    BSTR m_RecipientCity;
    BSTR m_RecipientState;
    BSTR m_RecipientZip;
    BSTR m_RecipientCountry;
    BSTR m_RecipientTitle;
    BSTR m_RecipientDepartment;
    BSTR m_RecipientOffice;
    BSTR m_RecipientHomePhone;
    BSTR m_RecipientOfficePhone;
    BSTR m_SenderName;    
    BSTR m_SenderCompany;
    BSTR m_SenderAddress;
    BSTR m_SenderTitle;
    BSTR m_SenderDepartment;
    BSTR m_SenderOfficeLocation;
    BSTR m_SenderHomePhone;
    BSTR m_SenderOfficePhone;
    BSTR m_SenderFax;

#ifdef FAXBROADCAST_ENABLED
    BOOL FreeCoverpageAndJobInfo(PFAX_JOB_PARAMW JobParams,
                              PFAX_COVERPAGE_INFOW CoverpageInfo
                              );    
  
    VOID InsertTextIntoStructure(LPTSTR txt,
                                 long i,
                                 PFAX_JOB_PARAMW pjp,
                                 PFAX_COVERPAGE_INFOW pci
                                 );
    
    BOOL RetrieveRecipientData(VARIANT* theData,
                               DWORD DataIndex, 
                               PFAX_JOB_PARAMW JobParams,
                               PFAX_COVERPAGE_INFOW CoverpageInfo
                               );
    
    BOOL RetrieveSenderData(PFAX_JOB_PARAMW pjp,
                            PFAX_COVERPAGE_INFOW pci
                            );

#endif
};

#endif //__FAXDOC_H_

#ifdef FAXBROADCAST_ENABLED
   BOOL CALLBACK BroadcastCallback(HANDLE FaxHandle,
                                   DWORD RecipientNumber,
                                   LPVOID Context,
                                   PFAX_JOB_PARAMW JobParams,
                                   PFAX_COVERPAGE_INFOW CoverpageInfo
                                   );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\win2k\faxjob.h ===
// FaxJob.h : Declaration of the CFaxJobs

#ifndef __FAXJOBS_H_
#define __FAXJOBS_H_

#include "resource.h"       // main symbols
#include <winfax.h>
#include "faxsvr.h"

/////////////////////////////////////////////////////////////////////////////
// CFaxJobs
class ATL_NO_VTABLE CFaxJobs : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CFaxJobs, &CLSID_FaxJobs>,
	public IDispatchImpl<IFaxJobs, &IID_IFaxJobs, &LIBID_FAXCOMLib>
{
public:
	CFaxJobs()
	{
		m_Jobs = 0;
		m_LastFaxError = 0;
		m_pFaxServer = NULL;
		m_VarVect = NULL;
	}

DECLARE_REGISTRY_RESOURCEID(IDR_FAXJOBS)

BEGIN_COM_MAP(CFaxJobs)
	COM_INTERFACE_ENTRY(IFaxJobs)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IFaxJobs
public:
	STDMETHOD(get_Item)(long Index, /*[out, retval]*/ VARIANT *pVal);
	STDMETHOD(get_Count)(/*[out, retval]*/ long *pVal);
	BOOL Init(CFaxServer *pFaxServer);
	 ~CFaxJobs();
private:
	CComVariant* m_VarVect;
	CFaxServer* m_pFaxServer;
	DWORD m_Jobs;
	DWORD m_LastFaxError;
};


/////////////////////////////////////////////////////////////////////////////
// CFaxJob
class ATL_NO_VTABLE CFaxJob : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CFaxJob, &CLSID_FaxJob>,
	public IDispatchImpl<IFaxJob, &IID_IFaxJob, &LIBID_FAXCOMLib>
{
public:
	CFaxJob()
	{
		m_JobId = 0;
		m_UserName = NULL;
		m_JobType = JT_UNKNOWN;
		m_QueueStatus = 0 ;
		m_DeviceStatus = 0 ;
		m_szQueueStatus = NULL;
		m_szDeviceStatus = NULL;
		m_PageCount=0;
		m_RecipientNumber = NULL;
		m_RecipientName = NULL;
		m_Tsid = NULL;
		m_SenderName = NULL;
		m_SenderCompany = NULL;
		m_SenderDept = NULL;
		m_BillingCode = NULL;
		m_DiscountTime = FALSE;
		m_DisplayName = NULL;
		m_Command = JC_UNKNOWN;
		m_pFaxServer = NULL;
	}

DECLARE_REGISTRY_RESOURCEID(IDR_FAXJOB)

BEGIN_COM_MAP(CFaxJob)
	COM_INTERFACE_ENTRY(IFaxJob)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IFaxJob
public:
	STDMETHOD(Refresh)();
	STDMETHOD(SetStatus)(long Command);
	BOOL SetJob();
	 ~CFaxJob();
	BOOL Initialize(CFaxServer *pFaxServer,DWORD JobId,LPCWSTR UserName,DWORD JobType,DWORD QueueStatus,DWORD DeviceStatus,DWORD PageCount,LPCWSTR RecipientNumber,LPCWSTR RecipientName,LPCWSTR Tsid,LPCWSTR SenderName,LPCWSTR SenderCompany,LPCWSTR SenderDept,LPCWSTR BillingCode,DWORD ScheduleAction,LPCWSTR DisplayName);
	STDMETHOD(get_DiscountSend)(/*[out, retval]*/ BOOL *pVal);
    STDMETHOD(get_DisplayName)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_BillingCode)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_SenderDept)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_SenderCompany)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_SenderName)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_Tsid)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_RecipientName)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_FaxNumber)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_PageCount)(/*[out, retval]*/ long *pVal);
	STDMETHOD(get_DeviceStatus)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_QueueStatus)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_UserName)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_Type)(/*[out, retval]*/ long *pVal);
	STDMETHOD(get_JobId)(/*[out, retval]*/ long *pVal);
private:
	DWORD m_JobId;
	BSTR  m_UserName;
	DWORD m_JobType;
	DWORD m_QueueStatus;
	DWORD m_DeviceStatus;
	BSTR  m_szQueueStatus;
	BSTR  m_szDeviceStatus;
	DWORD m_PageCount;
	BSTR  m_RecipientNumber;
	BSTR  m_RecipientName;
	BSTR  m_Tsid;
	BSTR  m_SenderName;
	BSTR  m_SenderCompany;
	BSTR  m_SenderDept;
	BSTR  m_BillingCode;
	BOOL  m_DiscountTime;
	BSTR  m_DisplayName;
	DWORD m_Command;
	CFaxServer * m_pFaxServer;
};

#endif //__FAXJOBS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\win2k\faxport.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    faxport.cpp

Abstract:

    This module implements the port interface/object.

Author:

    Wesley Witt (wesw) 20-May-1997

Revision History:

--*/

#include "stdafx.h"
#include "faxport.h"
#include "faxroute.h"
#include "status.h"



CFaxPort::CFaxPort()
{
    m_pFaxServer    = NULL;
    m_FaxPortHandle = NULL;
    m_LastFaxError  = NO_ERROR;
    m_DeviceId      = 0;
    m_Rings         = 0;
    m_Send          = FALSE;
    m_Receive       = FALSE;
    m_Name          = NULL;
    m_Csid          = NULL;
    m_Tsid          = NULL;
    m_Modify        = FALSE;
}


CFaxPort::~CFaxPort()
{
    if (m_FaxPortHandle) {
        FaxClose( m_FaxPortHandle );
    }
    if (m_pFaxServer) {
        m_pFaxServer->Release();
    }
    if (m_Name) {
        SysFreeString( m_Name );
    }
    if (m_Csid) {
        SysFreeString( m_Csid );
    }
    if (m_Tsid) {
        SysFreeString( m_Tsid );
    }
}


BOOL
CFaxPort::Initialize(
    CFaxServer *i_pFaxServer,
    DWORD       i_DeviceId,
    DWORD       i_Rings,
    DWORD       i_Priority,
    DWORD       i_Flags,
    LPCWSTR     i_Csid,
    LPCWSTR     i_Tsid,
    LPCWSTR     i_DeviceName
    )
{
    HRESULT hr;
    
    m_pFaxServer = i_pFaxServer;
    m_DeviceId   = i_DeviceId;
    m_Rings      = i_Rings;
    m_Priority   = i_Priority;
    m_Csid       = SysAllocString( i_Csid);
    m_Tsid       = SysAllocString( i_Tsid);
    m_Name       = SysAllocString( i_DeviceName );
    m_Send       = i_Flags & FPF_SEND;
    m_Receive    = i_Flags & FPF_RECEIVE;    

    if ((!m_Csid && i_Csid) ||
        (!m_Tsid && i_Tsid) ||
        (!m_Name && i_DeviceName)) {
        SysFreeString( m_Csid );
        SysFreeString( m_Tsid );
        SysFreeString( m_Name );
        return FALSE;
    }

    if (!m_pFaxServer) {
        return FALSE;
    }

    hr = m_pFaxServer->AddRef();
    if (FAILED(hr)) {
        m_pFaxServer = NULL;
        return FALSE;
    }

    if (!FaxOpenPort( m_pFaxServer->GetFaxHandle(), m_DeviceId, PORT_OPEN_MODIFY | PORT_OPEN_QUERY, &m_FaxPortHandle )) {
        if (GetLastError() == ERROR_ACCESS_DENIED) {
            if (!FaxOpenPort( m_pFaxServer->GetFaxHandle(), m_DeviceId, PORT_OPEN_QUERY, &m_FaxPortHandle )) {
                m_LastFaxError = GetLastError();
                return FALSE;
            }
        } else {
            m_LastFaxError = GetLastError();
            return FALSE;
        }
    } else {
        m_Modify = TRUE;
    }

    return TRUE;
}


STDMETHODIMP CFaxPort::get_CanModify(BOOL * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }

    __try {

        *pVal = m_Modify;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {

    }

    return E_UNEXPECTED;
}


BOOL CFaxPort::ChangePort()
{
    if (!m_Modify) {
        return FALSE;
    }

    //
    // get the current port configuration
    //

    PFAX_PORT_INFOW PortInfo = NULL;
    DWORD PortInfoSize = 0;

    if (!FaxGetPort( m_FaxPortHandle, &PortInfo )) {
        m_LastFaxError = GetLastError();
        return FALSE;
    }

    //
    // set the values
    //

    PortInfo->Rings     = m_Rings;
    PortInfo->Priority  = m_Priority;
    PortInfo->Flags     = (PortInfo->Flags &~ (FPF_SEND | FPF_RECEIVE)) | (m_Send ? FPF_SEND : 0) | (m_Receive ? FPF_RECEIVE : 0);
    PortInfo->Csid      = m_Csid;
    PortInfo->Tsid      = m_Tsid;

    //
    // change the server's port configuration
    //

    if (!FaxSetPort( m_FaxPortHandle, PortInfo )) {
        m_LastFaxError = GetLastError();
        FaxFreeBuffer( PortInfo );
        return FALSE;
    }

    //
    // clean up and bail
    //

    FaxFreeBuffer( PortInfo );

    return TRUE;
}


STDMETHODIMP CFaxPort::get_Name(BSTR *pVal)
{
    if (!pVal) {
        return E_POINTER;
    }

    BSTR Copy = SysAllocString(m_Name);

    if (!Copy  && m_Name) {
        return E_OUTOFMEMORY;
    }

    __try {

        *pVal = Copy;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SysFreeString(Copy);
    }

    return E_UNEXPECTED;
        
}


STDMETHODIMP CFaxPort::get_DeviceId(long * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }

    __try {

        *pVal = m_DeviceId;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {

    }

    return E_UNEXPECTED;
    
}


STDMETHODIMP CFaxPort::get_Rings(long * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }

    __try {

        *pVal = m_Rings;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {

    }

    return E_UNEXPECTED;    
}


STDMETHODIMP CFaxPort::put_Rings(long newVal)
{
    long old = m_Rings;
    
    if (!m_Modify) {
        return E_ACCESSDENIED;
    }
    
    m_Rings = newVal;

    if (!ChangePort()) {
        m_Rings = old;
        return Fax_HRESULT_FROM_WIN32(m_LastFaxError);
    }
    return S_OK;
}


STDMETHODIMP CFaxPort::get_Csid(BSTR * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }

    BSTR Copy = SysAllocString(m_Csid);

    if (!Copy  && m_Csid) {
        return E_OUTOFMEMORY;
    }

    __try {

        *pVal = Copy;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SysFreeString(Copy);
    }

    return E_UNEXPECTED;    
}


STDMETHODIMP CFaxPort::put_Csid(BSTR newVal)
{
    BSTR old = m_Csid;
    if (!m_Modify) {
        return E_ACCESSDENIED;
    }
    
    BSTR tmp = SysAllocString(newVal);
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    m_Csid = tmp;
    
    if (!ChangePort()) {
        m_Csid = old;
        SysFreeString(tmp);
        return Fax_HRESULT_FROM_WIN32(m_LastFaxError);
    }

    SysFreeString(old);

    return S_OK;

}


STDMETHODIMP CFaxPort::get_Tsid(BSTR * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }

    BSTR Copy = SysAllocString(m_Tsid);

    if (!Copy  && m_Tsid) {
        return E_OUTOFMEMORY;
    }

    __try {

        *pVal = Copy;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SysFreeString( m_Csid );
    }

    return E_UNEXPECTED;    
}


STDMETHODIMP CFaxPort::put_Tsid(BSTR newVal)
{
    BSTR old = m_Tsid;
    if (!m_Modify) {
        return E_ACCESSDENIED;
    }
    
    BSTR tmp = SysAllocString(newVal);
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
    
    m_Tsid = tmp;
    
    if (!ChangePort()) {
        m_Tsid = old;
        SysFreeString(tmp);
        return Fax_HRESULT_FROM_WIN32(m_LastFaxError);
    }

    SysFreeString(old);
    return S_OK;

}


STDMETHODIMP CFaxPort::get_Send(BOOL * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }

    __try {

        *pVal = m_Send;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {

    }

    return E_UNEXPECTED;
}


STDMETHODIMP CFaxPort::put_Send(BOOL newVal)
{
    BOOL old = m_Send;

    if (!m_Modify) {
        return E_ACCESSDENIED;
    }
    
    m_Send = newVal;
    
    if (!ChangePort()) {
        m_Send = old;
        return Fax_HRESULT_FROM_WIN32(m_LastFaxError);
    }
    return S_OK;
}


STDMETHODIMP CFaxPort::get_Receive(BOOL * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }

    __try {

        *pVal = m_Receive;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {

    }

    return E_UNEXPECTED;    
}


STDMETHODIMP CFaxPort::put_Receive(BOOL newVal)
{
    BOOL old = m_Receive;
    
    if (!m_Modify) {
        return E_ACCESSDENIED;
    }
    
    m_Receive = newVal;

    if (!ChangePort()) {
        m_Receive = old;
        return Fax_HRESULT_FROM_WIN32(m_LastFaxError);
    }
    return S_OK;

}


STDMETHODIMP CFaxPort::get_Priority(long * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }

    __try {

        *pVal = m_Priority;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {

    }

    return E_UNEXPECTED;    
}


STDMETHODIMP CFaxPort::put_Priority(long newVal)
{
    if (newVal < 0)
    {
        return E_INVALIDARG;
    }

    long old = m_Priority;
    if (!m_Modify) {
        return E_ACCESSDENIED;
    }

    m_Priority = newVal;

    if (!ChangePort()) {
        m_Priority = old;
        return Fax_HRESULT_FROM_WIN32(m_LastFaxError);
    }
    return S_OK;

}


STDMETHODIMP CFaxPort::GetRoutingMethods(VARIANT * retval)
{
    HRESULT hr;

    if (!retval) {
        return E_POINTER;
    }
    
    CComObject<CFaxRoutingMethods>* p = new CComObject<CFaxRoutingMethods>;
    if (!p) {
        return E_OUTOFMEMORY;
    }
    if (!p->Init(this)) {
        delete p;
        return E_FAIL;
    }

    IDispatch* pDisp;
    hr = p->QueryInterface(IID_IDispatch, (void**)&pDisp);
    if (FAILED(hr)) {
        delete p;
        return hr;
    }

    __try {

        VariantInit(retval);
        
        retval->vt = VT_DISPATCH;
        retval->pdispVal = pDisp;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {

    }

    pDisp->Release();
    delete p;

    return E_UNEXPECTED;
}


STDMETHODIMP CFaxPort::GetStatus(VARIANT * retval)
{
    HRESULT hr;

    if (!retval) {
        return E_POINTER;
    }
    
    CComObject<CFaxStatus>* p = new CComObject<CFaxStatus>;
    if (!p) {
        return E_OUTOFMEMORY;
    }
    if (!p->Init(this)) {
        delete p;
        return E_FAIL;
    }

    IDispatch* pDisp;
    hr = p->QueryInterface(IID_IDispatch, (void**)&pDisp);
    if (FAILED(hr)) {
        delete p;
        return hr;
    }

    __try {

        VariantInit(retval);
        
        retval->vt = VT_DISPATCH;
        retval->pdispVal = pDisp;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {

    }

    pDisp->Release();
    delete p;

    return E_UNEXPECTED;           
}


CFaxPorts::CFaxPorts()
{
    m_pFaxServer    = NULL;
    m_LastFaxError  = 0;
    m_PortCount     = 0;
    m_VarVect       = NULL;
}


CFaxPorts::~CFaxPorts()
{
    if (m_pFaxServer) {
        m_pFaxServer->Release();
    }

    if (m_VarVect) {
        delete [] m_VarVect;
    }
    
}


BOOL CFaxPorts::Init(CFaxServer *pFaxServer)
{
    PFAX_PORT_INFOW     PortInfo = NULL;
    DWORD               PortInfoSize = 0;
    HRESULT             hr;

    //
    // get the ports from the server
    //
    if (!pFaxServer) {
        return FALSE;
    }

    m_pFaxServer = pFaxServer;
    hr = m_pFaxServer->AddRef();
    if (FAILED(hr)) {
        m_pFaxServer = NULL;
        return FALSE;
    }

    if (!FaxEnumPortsW( m_pFaxServer->GetFaxHandle(), &PortInfo, &m_PortCount )) {
        m_LastFaxError = GetLastError();
        return FALSE;
    }

    //
    // enumerate the ports
    //

    m_VarVect = new CComVariant[m_PortCount];
    if (!m_VarVect) {
        m_LastFaxError = ERROR_OUTOFMEMORY;
        FaxFreeBuffer( PortInfo );
        return FALSE;
    }

    for (DWORD i=0; i<m_PortCount; i++) {

        //
        // create the object
        //

        CComObject<CFaxPort> *pFaxPort;
        HRESULT hr = CComObject<CFaxPort>::CreateInstance( &pFaxPort );

        if (FAILED(hr)) {
            delete [] m_VarVect;
            m_VarVect = NULL;            
            m_LastFaxError = hr;
            FaxFreeBuffer( PortInfo );
            return FALSE;
        }

        if (!pFaxPort->Initialize(
            pFaxServer,
            PortInfo[i].DeviceId,
            PortInfo[i].Rings,
            PortInfo[i].Priority,
            PortInfo[i].Flags,
            PortInfo[i].Csid,
            PortInfo[i].Tsid,
            PortInfo[i].DeviceName
            ))
        {
            delete [] m_VarVect;
            m_VarVect = NULL;
            m_LastFaxError = GetLastError();
            FaxFreeBuffer( PortInfo );
            return FALSE;
        }

        //
        // get IDispatch pointer
        //

        LPDISPATCH lpDisp = NULL;
        hr = pFaxPort->QueryInterface( IID_IDispatch, (void**)&lpDisp );
        if (FAILED(hr)) {
            delete [] m_VarVect;
            m_VarVect = NULL;
            m_LastFaxError = hr;
            FaxFreeBuffer( PortInfo );
            return FALSE;
        }

        //
        // create a variant and add it to the collection
        //
        __try {
            CComVariant &var = m_VarVect[i];
            var.vt = VT_DISPATCH;
            var.pdispVal = lpDisp;

            hr = S_OK;
        } __except (EXCEPTION_EXECUTE_HANDLER) {
            hr = E_UNEXPECTED;
        }

        if (FAILED(hr)) {
            delete [] m_VarVect;
            m_VarVect = NULL;
            m_LastFaxError = hr;
            FaxFreeBuffer( PortInfo );
            return FALSE;
        }

    }

    FaxFreeBuffer( PortInfo );

    return TRUE;
}


STDMETHODIMP CFaxPorts::get_Count(long * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }

    __try {
        
        *pVal = m_PortCount;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {

    }
    
    return E_UNEXPECTED;
}


STDMETHODIMP CFaxPorts::get_Item(long Index, VARIANT *retval)
{       
    if (!retval) {
        return E_POINTER;
    }

    if ((Index < 1) || (Index > (long) m_PortCount)) {
        return E_INVALIDARG;
    }
    
    

    __try {
        VariantInit( retval );

        retval->vt = VT_UNKNOWN;
        retval->punkVal = NULL;

        //
        // use 1-based index, VB like
        //
    
        return VariantCopy( retval, &m_VarVect[Index-1] );        

    } __except (EXCEPTION_EXECUTE_HANDLER) {

    }

    return E_UNEXPECTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\win2k\faxport.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    faxport.h

Abstract:

    This module contains the port class definitions.

Author:

    Wesley Witt (wesw) 20-May-1997


Revision History:

--*/

#ifndef __FAXPORT_H_
#define __FAXPORT_H_

#include "resource.h"
#include <winfax.h>
#include "faxsvr.h"


class ATL_NO_VTABLE CFaxPorts :
        public CComObjectRootEx<CComSingleThreadModel>,
        public CComCoClass<CFaxPorts, &CLSID_FaxPorts>,
        public IDispatchImpl<IFaxPorts, &IID_IFaxPorts, &LIBID_FAXCOMLib>
{
public:
        CFaxPorts();
        ~CFaxPorts();
        BOOL Init(CFaxServer *pFaxServer);

DECLARE_REGISTRY_RESOURCEID(IDR_FAXPORTS)

BEGIN_COM_MAP(CFaxPorts)
        COM_INTERFACE_ENTRY(IFaxPorts)
        COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IFaxPorts
public:
        STDMETHOD(get_Item)(long Index, /*[out, retval]*/ VARIANT *pVal);
        STDMETHOD(get_Count)(/*[out, retval]*/ long *pVal);

private:
    CFaxServer         *m_pFaxServer;
    DWORD               m_LastFaxError;
    DWORD               m_PortCount;
    CComVariant        *m_VarVect;

};

class ATL_NO_VTABLE CFaxPort :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CFaxPort, &CLSID_FaxPort>,
    public IDispatchImpl<IFaxPort, &IID_IFaxPort, &LIBID_FAXCOMLib>
{
public:
    CFaxPort();
    ~CFaxPort();
    BOOL Initialize(CFaxServer*,DWORD,DWORD,DWORD,DWORD,LPCWSTR,LPCWSTR,LPCWSTR);
    HANDLE GetPortHandle() { return m_FaxPortHandle; };
    DWORD GetDeviceId() { return m_DeviceId; };
    BSTR GetDeviceName() { return m_Name; };

DECLARE_REGISTRY_RESOURCEID(IDR_FAXPORT)

BEGIN_COM_MAP(CFaxPort)
    COM_INTERFACE_ENTRY(IFaxPort)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

public:
    STDMETHOD(GetStatus)(/*[out, retval]*/ VARIANT* retval);
    STDMETHOD(GetRoutingMethods)(VARIANT* retval);
    STDMETHOD(get_CanModify)(/*[out, retval]*/ BOOL *pVal);
    STDMETHOD(get_Priority)(/*[out, retval]*/ long *pVal);
    STDMETHOD(put_Priority)(/*[in]*/ long newVal);
    STDMETHOD(get_Receive)(/*[out, retval]*/ BOOL *pVal);
    STDMETHOD(put_Receive)(/*[in]*/ BOOL newVal);
    STDMETHOD(get_Send)(/*[out, retval]*/ BOOL *pVal);
    STDMETHOD(put_Send)(/*[in]*/ BOOL newVal);
    STDMETHOD(get_Tsid)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_Tsid)(/*[in]*/ BSTR newVal);
    STDMETHOD(get_Csid)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_Csid)(/*[in]*/ BSTR newVal);
    STDMETHOD(get_Rings)(/*[out, retval]*/ long *pVal);
    STDMETHOD(put_Rings)(/*[in]*/ long newVal);
    STDMETHOD(get_DeviceId)(/*[out, retval]*/ long *pVal);
    STDMETHOD(get_Name)(/*[out, retval]*/ BSTR *pVal);

private:
    BOOL ChangePort();

    CFaxServer         *m_pFaxServer;
    HANDLE              m_FaxPortHandle;
    BOOL                m_Send;
    BOOL                m_Receive;
    BOOL                m_Modify;
    BSTR                m_Name;
    BSTR                m_Csid;
    BSTR                m_Tsid;
    DWORD               m_LastFaxError;
    DWORD               m_DeviceId;
    DWORD               m_Rings;
    DWORD               m_Priority;

};

#endif //__FAXPORT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\win2k\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by faxcom.rc
//

#define IDR_FAXTIFF                     101
#define IDR_FAXSERVER                   102
#define IDR_FAXPORT                     103
#define IDR_FAXPORTS                    104
#define IDR_FAXROUTINGMETHOD            105
#define IDR_FAXROUTINGMETHODS           106
#define IDR_FAXSTATUS                   107
#define IDR_FAXDOC                      108
#define IDR_FAXJOBS                     109
#define IDR_FAXJOB                      111

#define IDS_PROJNAME                    100
#define IDS_UNAVAILABLE                 101
#define IDS_JOB_PENDING                 102
#define IDS_JOB_INPROGRESS              103
#define IDS_JOB_DELETING                104
#define IDS_JOB_FAILED                  105
#define IDS_JOB_PAUSED                  106

#define IDS_DEVICE_DIALING              107
#define IDS_DEVICE_SENDING              108
#define IDS_DEVICE_RECEIVING            109
#define IDS_DEVICE_COMPLETED            110
#define IDS_DEVICE_HANDLED              111
#define IDS_DEVICE_UNAVAILABLE          112
#define IDS_DEVICE_BUSY                 113
#define IDS_DEVICE_NOANSWER             114
#define IDS_DEVICE_BADADDRESS           115
#define IDS_DEVICE_NODIALTONE           116
#define IDS_DEVICE_DISCONNECTED         117
#define IDS_DEVICE_FATALERROR           118
#define IDS_DEVICE_NOTFAXCALL           119
#define IDS_DEVICE_CALLDELAYED          120
#define IDS_DEVICE_BLACKLISTED          121
#define IDS_DEVICE_INITIALIZING         122
#define IDS_DEVICE_OFFLINE              123
#define IDS_DEVICE_RINGING              124
#define IDS_DEVICE_AVAILABLE            125
#define IDS_DEVICE_ABORTING             126
#define IDS_DEVICE_ROUTING              127
#define IDS_DEVICE_ANSWERED             128
#define IDS_DEVICE_UNKNOWN              129
#define IDS_JOB_UNKNOWN                 130

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           112
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\win2k\faxjob.cpp ===
// FaxJob.cpp : Implementation of CFaxJobs
#include "stdafx.h"
#include "FaxJob.h"

/////////////////////////////////////////////////////////////////////////////
// CFaxJobs


CFaxJobs::~CFaxJobs()
{
    if (m_pFaxServer) 
    {
        m_pFaxServer->Release();
    }

    if (m_VarVect) 
    {
        delete [] m_VarVect;
    }
}


BOOL CFaxJobs::Init(CFaxServer * pFaxServer)
{
    PFAX_JOB_ENTRYW     JobEntry = NULL;
    DWORD               PortInfoSize = 0;
    HRESULT             hr;

    //
    // get the ports from the server
    //
    if (!pFaxServer) 
    {
        return FALSE;
    }

    m_pFaxServer = pFaxServer;
    hr = m_pFaxServer->AddRef();
    if (FAILED(hr)) 
    {
        m_pFaxServer = NULL;
        return FALSE;
    }

    if (!FaxEnumJobsW( m_pFaxServer->GetFaxHandle(), &JobEntry, &m_Jobs)) 
    {
        m_LastFaxError = GetLastError();        
        return FALSE;
    }

    //
    // enumerate the ports
    //

    m_VarVect = new CComVariant[m_Jobs];
    if (!m_VarVect) 
    {
        FaxFreeBuffer( JobEntry );
        m_LastFaxError = ERROR_OUTOFMEMORY;
        return FALSE;
    }

    for (DWORD i=0; i<m_Jobs; i++) 
    {

        //
        // create the object
        //

        CComObject<CFaxJob> *pFaxJob;
        HRESULT hr = CComObject<CFaxJob>::CreateInstance( &pFaxJob );
        if (FAILED(hr)) 
        {
            delete [] m_VarVect;
            m_VarVect = NULL;
            FaxFreeBuffer( JobEntry );
            return FALSE;
        }

        //
        // set the values
        //

        if (!pFaxJob->Initialize(
            m_pFaxServer,
            JobEntry[i].JobId,
            JobEntry[i].UserName,
            JobEntry[i].JobType,
            JobEntry[i].QueueStatus,
            JobEntry[i].Status,
            JobEntry[i].PageCount,
            JobEntry[i].RecipientNumber,
            JobEntry[i].RecipientName,
            JobEntry[i].Tsid,
            JobEntry[i].SenderName,
            JobEntry[i].SenderCompany,
            JobEntry[i].SenderDept,
            JobEntry[i].BillingCode,
            JobEntry[i].ScheduleAction,
            JobEntry[i].DocumentName
            ))
        {
            delete [] m_VarVect;
            m_VarVect = NULL;
            FaxFreeBuffer( JobEntry );
            return FALSE;
        }

        //
        // get IDispatch pointer
        //

        LPDISPATCH lpDisp = NULL;
        hr = pFaxJob->QueryInterface( IID_IDispatch, (void**)&lpDisp );
        if (FAILED(hr)) 
        {
            delete [] m_VarVect;
            m_VarVect = NULL;
            FaxFreeBuffer( JobEntry );
            return FALSE;
        }

        //
        // create a variant and add it to the collection
        //

        CComVariant &var = m_VarVect[i];
        var.vt = VT_DISPATCH;
        var.pdispVal = lpDisp;
    }

    FaxFreeBuffer( JobEntry );
    return TRUE;
}


STDMETHODIMP CFaxJobs::get_Count(long * pVal)
{
    if (!pVal)
    {
        return E_POINTER;
    }
    
    __try 
    {

        *pVal = m_Jobs;
        return S_OK;

    } 
    __except (EXCEPTION_EXECUTE_HANDLER) 
    {

    }

    return E_UNEXPECTED;
}


STDMETHODIMP CFaxJobs::get_Item(long Index, VARIANT * pVal)
{
    if (!pVal) 
    {
        return E_POINTER;
    }

    //
    // use 1-based index, VB like
    //

    if ((Index < 1) || (Index > (long) m_Jobs)) 
    {
        return E_INVALIDARG;
    }


    __try 
    {                 
        VariantInit( pVal );

        pVal->vt = VT_UNKNOWN;
        pVal->punkVal = NULL;
    
        return VariantCopy( pVal, &m_VarVect[Index-1] );        
    }
    __except (EXCEPTION_EXECUTE_HANDLER) 
    {

    }

    return E_UNEXPECTED;    

}


/////////////////////////////////////////////////////////////////////////////
// CFaxJob


STDMETHODIMP CFaxJob::get_JobId(long * pVal)
{
    if (!pVal) 
    {
        return E_POINTER;
    }
    
    __try 
    {
        *pVal = m_JobId;
        return S_OK;
    } 
    __except (EXCEPTION_EXECUTE_HANDLER) 
    {

    }
        
    return E_UNEXPECTED;
}

STDMETHODIMP CFaxJob::get_Type(long * pVal)
{
    if (!pVal) 
    {
        return E_POINTER;
    }
    
    __try 
    {
        *pVal = m_JobType;
        return S_OK;
    } 
    __except (EXCEPTION_EXECUTE_HANDLER) 
    {
    
    }
        
    return E_UNEXPECTED;
}

STDMETHODIMP CFaxJob::get_UserName(BSTR * pVal)
{
    if (!pVal) 
    {
        return E_POINTER;
    }

    BSTR Copy = SysAllocString(m_UserName);
    if (!Copy  && m_UserName) 
    {
        return E_OUTOFMEMORY;
    }    

    __try 
    {
        *pVal = Copy;
        return S_OK;
    } 
    __except (EXCEPTION_EXECUTE_HANDLER) 
    {
        SysFreeString(Copy);    
    }
        
    return E_UNEXPECTED;
}


STDMETHODIMP CFaxJob::get_QueueStatus(BSTR * pVal)
{
    if (!pVal) 
    {
        return E_POINTER;
    }

    BSTR Copy = SysAllocString(m_szQueueStatus);
    if (!Copy  && m_szQueueStatus) 
    {
        return E_OUTOFMEMORY;
    }
    
    __try 
    {
        *pVal = Copy;
        return S_OK;
    } 
    __except (EXCEPTION_EXECUTE_HANDLER) 
    {
        SysFreeString(Copy);
    }
        
    return E_UNEXPECTED;
}


STDMETHODIMP CFaxJob::get_DeviceStatus(BSTR * pVal)
{
    if (!pVal) 
    {
        return E_POINTER;
    }

    BSTR Copy = SysAllocString(m_szDeviceStatus);
    if (!Copy  && m_szDeviceStatus) 
    {
        return E_OUTOFMEMORY;
    }
    
    __try 
    {
        *pVal = Copy;
        return S_OK;
    } 
    __except (EXCEPTION_EXECUTE_HANDLER) 
    {
        SysFreeString(Copy);
    }
        
    return E_UNEXPECTED;
}


STDMETHODIMP CFaxJob::get_PageCount(long * pVal)
{
    if (!pVal) 
    {
        return E_POINTER;
    }
    
    __try 
    {
        *pVal = m_PageCount;
        return S_OK;
    } 
    __except (EXCEPTION_EXECUTE_HANDLER) 
    {
    
    }
        
    return E_UNEXPECTED;
}


STDMETHODIMP CFaxJob::get_FaxNumber(BSTR * pVal)
{
    if (!pVal) 
    {
        return E_POINTER;
    }

    BSTR Copy = SysAllocString(m_RecipientNumber);
    if (!Copy  && m_RecipientNumber) 
    {
        return E_OUTOFMEMORY;
    }

    __try 
    {
        *pVal = Copy;
        return S_OK;
    } 
    __except (EXCEPTION_EXECUTE_HANDLER) 
    {
        SysFreeString(Copy);
    }
        
    return E_UNEXPECTED;
}


STDMETHODIMP CFaxJob::get_RecipientName(BSTR * pVal)
{
    if (!pVal) 
    {
        return E_POINTER;
    }

    BSTR Copy = SysAllocString(m_RecipientName);
    if (!Copy  && m_RecipientName) 
    {
        return E_OUTOFMEMORY;
    }
    
    __try 
    {
        *pVal = Copy;
        return S_OK;
    } 
    __except (EXCEPTION_EXECUTE_HANDLER) 
    {
        SysFreeString(Copy);
    }
        
    return E_UNEXPECTED;    
}


STDMETHODIMP CFaxJob::get_Tsid(BSTR * pVal)
{
    if (!pVal) 
    {
        return E_POINTER;
    }

    BSTR Copy = SysAllocString(m_Tsid);
    if (!Copy  && m_Tsid) 
    {
        return E_OUTOFMEMORY;
    }
    
    __try 
    {
        *pVal = Copy;
        return S_OK;
    } 
    __except (EXCEPTION_EXECUTE_HANDLER) 
    {
        SysFreeString(Copy);
    }
        
    return E_UNEXPECTED;
}


STDMETHODIMP CFaxJob::get_SenderName(BSTR * pVal)
{
    if (!pVal) 
    {
        return E_POINTER;
    }

    BSTR Copy = SysAllocString(m_SenderName);
    if (!Copy  && m_SenderName) 
    {
        return E_OUTOFMEMORY;
    }
    
    __try 
    {
        *pVal = Copy;
        return S_OK;
    } 
    __except (EXCEPTION_EXECUTE_HANDLER) 
    {
        SysFreeString(Copy);
    }
        
    return E_UNEXPECTED;
}


STDMETHODIMP CFaxJob::get_SenderCompany(BSTR * pVal)
{
    if (!pVal) 
    {
        return E_POINTER;
    }

    BSTR Copy = SysAllocString(m_SenderCompany);
    if (!Copy  && m_SenderCompany) 
    {
        return E_OUTOFMEMORY;
    }
    
    __try 
    {
        *pVal = Copy;
        return S_OK;
    } 
    __except (EXCEPTION_EXECUTE_HANDLER) 
    {
        SysFreeString(Copy);
    }
        
    return E_UNEXPECTED;
}


STDMETHODIMP CFaxJob::get_SenderDept(BSTR * pVal)
{
    if (!pVal) 
    {
        return E_POINTER;
    }

    BSTR Copy = SysAllocString(m_SenderDept);
    if (!Copy  && m_SenderDept) 
    {
        return E_OUTOFMEMORY;
    }
    
    __try 
    {
        *pVal = Copy;
        return S_OK;
    } 
    __except (EXCEPTION_EXECUTE_HANDLER) 
    {
        SysFreeString(Copy);
    }
        
    return E_UNEXPECTED;
}


STDMETHODIMP CFaxJob::get_BillingCode(BSTR * pVal)
{
    if (!pVal) 
    {
        return E_POINTER;
    }

    BSTR Copy = SysAllocString(m_BillingCode);
    if (!Copy  && m_BillingCode) 
    {
        return E_OUTOFMEMORY;
    }

    __try 
    {
        *pVal = Copy;
        return S_OK;
    } 
    __except (EXCEPTION_EXECUTE_HANDLER) 
    {
        SysFreeString(Copy);
    }
        
    return E_UNEXPECTED;
}


STDMETHODIMP CFaxJob::get_DisplayName(BSTR * pVal)
{
    if (!pVal) 
    {
        return E_POINTER;
    }

    BSTR Copy = SysAllocString(m_DisplayName);
    if (!Copy  && m_DisplayName) 
    {
        return E_OUTOFMEMORY;
    }
    
    __try 
    {
        *pVal = Copy;
        return S_OK;
    } 
    __except (EXCEPTION_EXECUTE_HANDLER) 
    {
        SysFreeString(Copy);
    }
        
    return E_UNEXPECTED;
}


STDMETHODIMP CFaxJob::get_DiscountSend(BOOL * pVal)
{
    if (!pVal) 
    {
        return E_POINTER;
    }
    
    __try 
    {
        *pVal = m_DiscountTime;
        return S_OK;
    } 
    __except (EXCEPTION_EXECUTE_HANDLER) 
    {
    
    }
        
    return E_UNEXPECTED;    
}


CFaxJob::~CFaxJob()
{
    SysFreeString(m_UserName);
    SysFreeString(m_szQueueStatus);
    SysFreeString(m_szDeviceStatus);
    SysFreeString(m_RecipientNumber);
    SysFreeString(m_RecipientName);
    SysFreeString(m_Tsid);
    SysFreeString(m_SenderName);
    SysFreeString(m_SenderCompany);
    SysFreeString(m_SenderDept);
    SysFreeString(m_BillingCode);
    SysFreeString(m_DisplayName);

    if (m_pFaxServer) 
    {
        m_pFaxServer->Release();
    }
}


BOOL CFaxJob::Initialize(
    CFaxServer *pFaxServer,
    DWORD JobId,
    LPCWSTR UserName,
    DWORD JobType,
    DWORD QueueStatus,
    DWORD DeviceStatus,
    DWORD PageCount,
    LPCWSTR RecipientNumber,
    LPCWSTR RecipientName,
    LPCWSTR Tsid,
    LPCWSTR SenderName,
    LPCWSTR SenderCompany,
    LPCWSTR SenderDept,
    LPCWSTR BillingCode,
    DWORD ScheduleAction,
    LPCWSTR DisplayName)
{
    if (!pFaxServer) 
    {
        return FALSE;
    }

    m_pFaxServer = pFaxServer;

    if ( FAILED(m_pFaxServer->AddRef()) )
    {
        m_pFaxServer = NULL;
        return FALSE;
    }

    m_UserName = SysAllocString(UserName);
    m_szQueueStatus = GetQueueStatus(m_QueueStatus);
    m_szDeviceStatus = GetDeviceStatus(m_DeviceStatus);
    m_RecipientNumber = SysAllocString(RecipientNumber);
    m_RecipientName = SysAllocString(RecipientName);
    m_Tsid = SysAllocString(Tsid);
    m_SenderName = SysAllocString(SenderName);
    m_SenderCompany = SysAllocString(SenderCompany);
    m_SenderDept = SysAllocString(SenderDept);
    m_BillingCode = SysAllocString(BillingCode);
    m_DisplayName = SysAllocString(DisplayName);

    if ( (!m_UserName && UserName) ||
         (!m_szQueueStatus) ||
         (!m_szDeviceStatus) ||
         (!m_RecipientNumber && RecipientNumber) ||
         (!m_RecipientName && RecipientName) ||
         (!m_Tsid && Tsid) ||
         (!m_SenderName && SenderName) ||
         (!m_SenderCompany && SenderCompany) ||
         (!m_SenderDept && SenderDept) ||
         (!m_BillingCode && BillingCode) ||
         (!m_DisplayName && DisplayName) )
    {
        goto error;
    }

    m_JobId = JobId;
    m_JobType = JobType;
    m_QueueStatus = QueueStatus;
    m_DeviceStatus = DeviceStatus;
    m_PageCount = PageCount;
    m_DiscountTime = (ScheduleAction == JSA_DISCOUNT_PERIOD) ? TRUE : FALSE;

    return TRUE;

error:
    SysFreeString(m_DisplayName);
    SysFreeString(m_BillingCode);
    SysFreeString(m_SenderDept);
    SysFreeString(m_SenderCompany);
    SysFreeString(m_SenderName);
    SysFreeString(m_Tsid);
    SysFreeString(m_RecipientName);
    SysFreeString(m_RecipientNumber);
    SysFreeString(m_szDeviceStatus);
    SysFreeString(m_szQueueStatus);
    SysFreeString(m_UserName);

    m_pFaxServer->Release();
    m_pFaxServer = NULL;
    return FALSE;
}


BOOL CFaxJob::SetJob()
{
    FAX_JOB_ENTRYW FaxJobEntry;

    ZeroMemory(&FaxJobEntry,sizeof(FAX_JOB_ENTRYW) );
    FaxJobEntry.SizeOfStruct = sizeof(FAX_JOB_ENTRYW);
    FaxJobEntry.JobId = m_JobId;
    FaxJobEntry.UserName = m_UserName;
    FaxJobEntry.JobType = m_JobType;
    FaxJobEntry.QueueStatus = m_QueueStatus;
    FaxJobEntry.Status = m_DeviceStatus;
    FaxJobEntry.PageCount = m_PageCount;
    FaxJobEntry.RecipientNumber = m_RecipientNumber;
    FaxJobEntry.RecipientName = m_RecipientName;
    FaxJobEntry.Tsid = m_Tsid;
    FaxJobEntry.SenderName = m_SenderName;
    FaxJobEntry.SenderCompany = m_SenderCompany;
    FaxJobEntry.SenderDept = m_SenderDept;
    FaxJobEntry.BillingCode = m_BillingCode;
    FaxJobEntry.ScheduleAction = m_DiscountTime ? JSA_DISCOUNT_PERIOD : JSA_NOW;
    FaxJobEntry.DocumentName = m_DisplayName;


    if (!FaxSetJobW(m_pFaxServer->GetFaxHandle(),m_JobId,m_Command,&FaxJobEntry) ) 
    {
        return FALSE;
    }

    return TRUE;
}


STDMETHODIMP CFaxJob::SetStatus(long Command)
{
    m_Command = Command;

    if (!SetJob())
    {
        return Fax_HRESULT_FROM_WIN32(GetLastError());
    }

    return S_OK;
}

STDMETHODIMP CFaxJob::Refresh()
{
    PFAX_JOB_ENTRYW FaxJobEntry;
    HRESULT hr = S_OK;

    if (!FaxGetJobW(m_pFaxServer->GetFaxHandle(),m_JobId,&FaxJobEntry) ) 
    {
        return Fax_HRESULT_FROM_WIN32(GetLastError());
    }

    if (m_UserName) 
    {
        SysFreeString(m_UserName);      
    }   
    m_UserName = SysAllocString(FaxJobEntry->UserName);
    
    m_JobType = FaxJobEntry->JobType;
    m_QueueStatus = FaxJobEntry->QueueStatus;
    m_DeviceStatus = FaxJobEntry->Status;

    if (m_szQueueStatus) 
    {
        SysFreeString(m_szQueueStatus);
    }
    m_szQueueStatus = GetQueueStatus(m_QueueStatus);

    if (m_szDeviceStatus) 
    {
        SysFreeString(m_szDeviceStatus);
    }
    m_szDeviceStatus = GetDeviceStatus(m_DeviceStatus);
    
    m_PageCount = FaxJobEntry->PageCount;

    if (m_RecipientNumber ) 
    {
        SysFreeString(m_RecipientNumber);
    }
    m_RecipientNumber = SysAllocString(FaxJobEntry->RecipientNumber);

    if (m_RecipientName ) 
    {
        SysFreeString(m_RecipientName);
    }
    m_RecipientName = SysAllocString(FaxJobEntry->RecipientName);

    if (m_Tsid ) 
    {
        SysFreeString(m_Tsid);
    }
    m_Tsid = SysAllocString(FaxJobEntry->Tsid);

    if (m_SenderName  ) 
    {
        SysFreeString(m_SenderName);
    }
    m_SenderName = SysAllocString(FaxJobEntry->SenderName);

    if (m_SenderCompany) 
    {
        SysFreeString(m_SenderCompany);
    }
    m_SenderCompany = SysAllocString(FaxJobEntry->SenderCompany);

    if (m_SenderDept) 
    {
        SysFreeString(m_SenderDept);
    }
    m_SenderDept = SysAllocString(FaxJobEntry->SenderDept);

    if (m_BillingCode ) 
    {
        SysFreeString(m_BillingCode);
    }
    m_BillingCode = SysAllocString(FaxJobEntry->BillingCode);

    if (m_DisplayName) 
    {
        SysFreeString(m_DisplayName);
    }
    m_DisplayName = SysAllocString(FaxJobEntry->DocumentName);

    m_DiscountTime = (FaxJobEntry->ScheduleAction == JSA_DISCOUNT_PERIOD) ? TRUE : FALSE;

    if (!m_szQueueStatus || !m_szDeviceStatus  ||
        (!m_UserName && FaxJobEntry->UserName) ||
        (!m_RecipientNumber && FaxJobEntry->RecipientNumber) ||
        (!m_RecipientName && FaxJobEntry->RecipientName) ||
        (!m_Tsid && FaxJobEntry->Tsid) ||
        (!m_SenderName && FaxJobEntry->SenderName) ||
        (!m_SenderCompany && FaxJobEntry->SenderCompany) ||
        (!m_SenderDept && FaxJobEntry->SenderDept) ||
        (!m_BillingCode && FaxJobEntry->BillingCode) ||
        (!m_DisplayName && FaxJobEntry->DocumentName) ) 
    {
        
        hr = E_OUTOFMEMORY;

        SysFreeString(m_DisplayName);
        SysFreeString(m_BillingCode);
        SysFreeString(m_SenderDept);
        SysFreeString(m_SenderCompany);
        SysFreeString(m_SenderName);
        SysFreeString(m_Tsid);
        SysFreeString(m_RecipientName);
        SysFreeString(m_RecipientNumber);
        SysFreeString(m_szDeviceStatus);
        SysFreeString(m_szQueueStatus);
        SysFreeString(m_UserName);
    }

    FaxFreeBuffer(FaxJobEntry);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\win2k\status.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    status.h

Abstract:

    This file implements the status interface/object.

Author:

    Wesley Witt (wesw) 13-May-1997

Environment:

    User Mode

--*/

#ifndef __FAXSTATUS_H_
#define __FAXSTATUS_H_

#include "resource.h"
#include "faxport.h"
#include <winfax.h>

class ATL_NO_VTABLE CFaxStatus :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CFaxStatus, &CLSID_FaxStatus>,
    public ISupportErrorInfo,
    public IDispatchImpl<IFaxStatus, &IID_IFaxStatus, &LIBID_FAXCOMLib>
{
public:
    CFaxStatus();
    ~CFaxStatus();
    BOOL Init(CFaxPort *pFaxPort);
    void FreeMemory();

DECLARE_REGISTRY_RESOURCEID(IDR_FAXSTATUS)
DECLARE_NOT_AGGREGATABLE(CFaxStatus)

BEGIN_COM_MAP(CFaxStatus)
    COM_INTERFACE_ENTRY(IFaxStatus)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

public:
    STDMETHOD(Refresh)();
    STDMETHOD(get_ElapsedTime)(/*[out, retval]*/ DATE *pVal);
    STDMETHOD(get_SubmittedTime)(/*[out, retval]*/ DATE *pVal);
    STDMETHOD(get_StartTime)(/*[out, retval]*/ DATE *pVal);
    STDMETHOD(get_Tsid)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_PageCount)(/*[out, retval]*/ long *pVal);
    STDMETHOD(get_Description)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_DocumentSize)(/*[out, retval]*/ long *pVal);
    STDMETHOD(get_RecipientName)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_SenderName)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_RoutingString)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_Address)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_Receive)(/*[out, retval]*/ BOOL *pVal);
    STDMETHOD(get_Send)(/*[out, retval]*/ BOOL *pVal);
    STDMETHOD(get_DocumentName)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_DeviceName)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_DeviceId)(/*[out, retval]*/ long *pVal);
    STDMETHOD(get_CurrentPage)(/*[out, retval]*/ long *pVal);
    STDMETHOD(get_Csid)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_CallerId)(/*[out, retval]*/ BSTR *pVal);

private:
    CFaxPort       *m_pFaxPort;
    BOOL            m_Receive;
    BOOL            m_Send;
    BSTR            m_Tsid;
    BSTR            m_Description;
    BSTR            m_RecipientName;
    BSTR            m_SenderName;
    BSTR            m_RoutingString;
    BSTR            m_Address;
    BSTR            m_DocName;
    BSTR            m_DeviceName;
    BSTR            m_Csid;
    BSTR            m_CallerId;
    DWORD           m_PageCount;
    DWORD           m_DocSize;
    DWORD           m_DeviceId;
    DWORD           m_CurrentPage;
    SYSTEMTIME      m_StartTime;
    SYSTEMTIME      m_SubmittedTime;
    SYSTEMTIME      m_ElapsedTime;

};

#endif //__FAXSTATUS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\win2k\stdafx.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    stdafx.cpp

Abstract:

    This file contains the static support code for the
    atl controls in this project.

Author:

    Wesley Witt (wesw) 13-May-1997

Environment:

    User Mode

--*/

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\win2k\faxsvr.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    faxsvr.h

Abstract:

    This module contains the fax server class definitions.

Author:

    Wesley Witt (wesw) 20-May-1997


Revision History:

--*/

#ifndef __FAXSERVER_H_
#define __FAXSERVER_H_

#include "resource.h"       // main symbols
#include "winfax.h"

class ATL_NO_VTABLE CFaxServer :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CFaxServer, &CLSID_FaxServer>,
    public IDispatchImpl<IFaxServer, &IID_IFaxServer, &LIBID_FAXCOMLib>
{
public:
    CFaxServer();
    ~CFaxServer();
    HANDLE GetFaxHandle() { return m_FaxHandle; };

DECLARE_REGISTRY_RESOURCEID(IDR_FAXSERVER)

BEGIN_COM_MAP(CFaxServer)
    COM_INTERFACE_ENTRY(IFaxServer)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

public:
	STDMETHOD(get_DiscountRateEndMinute)(/*[out, retval]*/ short *pVal);
	STDMETHOD(put_DiscountRateEndMinute)(/*[in]*/ short newVal);
	STDMETHOD(get_DiscountRateEndHour)(/*[out, retval]*/ short *pVal);
	STDMETHOD(put_DiscountRateEndHour)(/*[in]*/ short newVal);
    STDMETHOD(get_DiscountRateStartMinute)(/*[out, retval]*/ short *pVal);
	STDMETHOD(put_DiscountRateStartMinute)(/*[in]*/ short newVal);
	STDMETHOD(get_DiscountRateStartHour)(/*[out, retval]*/ short *pVal);
	STDMETHOD(put_DiscountRateStartHour)(/*[in]*/ short newVal);
	STDMETHOD(get_ServerMapiProfile)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_ServerMapiProfile)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_ArchiveDirectory)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_ArchiveDirectory)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_ArchiveOutboundFaxes)(/*[out, retval]*/ BOOL *pVal);
	STDMETHOD(put_ArchiveOutboundFaxes)(/*[in]*/ BOOL newVal);
	STDMETHOD(get_PauseServerQueue)(/*[out, retval]*/ BOOL *pVal);
	STDMETHOD(put_PauseServerQueue)(/*[in]*/ BOOL newVal);
	STDMETHOD(get_ServerCoverpage)(/*[out, retval]*/ BOOL *pVal);
	STDMETHOD(put_ServerCoverpage)(/*[in]*/ BOOL newVal);
	STDMETHOD(get_UseDeviceTsid)(/*[out, retval]*/ BOOL *pVal);
	STDMETHOD(put_UseDeviceTsid)(/*[in]*/ BOOL newVal);
	STDMETHOD(get_Branding)(/*[out, retval]*/ BOOL *pVal);
	STDMETHOD(put_Branding)(/*[in]*/ BOOL newVal);
	STDMETHOD(get_DirtyDays)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_DirtyDays)(/*[in]*/ long newVal);
	STDMETHOD(get_RetryDelay)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_RetryDelay)(/*[in]*/ long newVal);
	STDMETHOD(get_Retries)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_Retries)(/*[in]*/ long newVal);
	STDMETHOD(GetJobs)(VARIANT *retval);
	STDMETHOD(CreateDocument)(BSTR FileName, VARIANT *retval);
    STDMETHOD(GetPorts)(VARIANT* retval);
    STDMETHOD(Disconnect)();
    STDMETHOD(Connect)(BSTR ServerName);

private:
	BOOL UpdateConfiguration();
	BOOL RetrieveConfiguration();
    DWORD   m_LastFaxError;
    HANDLE  m_FaxHandle;
    BOOL		m_Branding;
	DWORD		m_Retries;
	DWORD		m_RetryDelay;
	DWORD		m_DirtyDays;
	BOOL		m_UseDeviceTsid;
	BOOL		m_ServerCp;
	BOOL		m_PauseServerQueue;
	FAX_TIME	m_StartCheapTime;
	FAX_TIME	m_StopCheapTime;
	BOOL		m_ArchiveOutgoingFaxes;
	BSTR		m_ArchiveDirectory;
};


BSTR GetDeviceStatus(DWORD);
BSTR GetQueueStatus(DWORD);

#endif //__FAXSERVER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\win2k\faxtiff.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    faxtiff.cpp

Abstract:

    This file implements the FaxTiff object.

Author:

    Wesley Witt (wesw) 13-May-1997

Environment:

    User Mode

--*/

#include "stdafx.h"
#include "FaxTiff.h"


CFaxTiff::CFaxTiff()
{
    m_hFile = INVALID_HANDLE_VALUE;
    m_hMap = NULL;
    m_pfPtr = NULL;
}


CFaxTiff::~CFaxTiff()
{
    if (m_hFile != INVALID_HANDLE_VALUE) {
        UnmapViewOfFile( m_pfPtr );
        CloseHandle( m_hMap );
        CloseHandle( m_hFile );
    }
}


BSTR CFaxTiff::GetString( DWORD ResId )
{
    WCHAR   TmpBuf[MAX_PATH] = {0};
    int     iRes;
    
    iRes = ::LoadString(_Module.GetModuleInstance(), ResId, TmpBuf, sizeof(TmpBuf)/sizeof(WCHAR));
    if (0 == iRes)
    {
        //
        //  Load String failed, return empty string
        //
        return NULL;
    }

    return SysAllocString(TmpBuf);

}


LPWSTR
CFaxTiff::AnsiStringToUnicodeString(
    LPSTR AnsiString
    )
{
    DWORD Count;
    LPWSTR UnicodeString;


    //
    // first see how big the buffer needs to be
    //
    Count = MultiByteToWideChar(
        CP_ACP,
        MB_PRECOMPOSED,
        AnsiString,
        -1,
        NULL,
        0
        );

    //
    // i guess the input string is empty
    //
    if (!Count) {
        return NULL;
    }

    //
    // allocate a buffer for the unicode string
    //
    Count += 1;
    UnicodeString = (LPWSTR) LocalAlloc( LPTR, Count * sizeof(UNICODE_NULL) );
    if (!UnicodeString) {
        return NULL;
    }

    //
    // convert the string
    //
    Count = MultiByteToWideChar(
        CP_ACP,
        MB_PRECOMPOSED,
        AnsiString,
        -1,
        UnicodeString,
        Count
        );

    //
    // the conversion failed
    //
    if (!Count) {
        LocalFree( UnicodeString );
        return NULL;
    }

    return UnicodeString;
}

LPSTR
CFaxTiff::UnicodeStringToAnsiString(
    LPWSTR UnicodeString
    )
{
    DWORD Count;
    LPSTR AnsiString;


    //
    // first see how big the buffer needs to be
    //
    Count = WideCharToMultiByte(
        CP_ACP,
        0,
        UnicodeString,
        -1,
        NULL,
        0,
        NULL,
        NULL
        );

    //
    // i guess the input string is empty
    //
    if (!Count) {
        return NULL;
    }

    //
    // allocate a buffer for the unicode string
    //
    Count += 1;
    AnsiString = (LPSTR) LocalAlloc( LPTR, Count );
    if (!AnsiString) {
        return NULL;
    }

    //
    // convert the string
    //
    Count = WideCharToMultiByte(
        CP_ACP,
        0,
        UnicodeString,
        -1,
        AnsiString,
        Count,
        NULL,
        NULL
        );

    //
    // the conversion failed
    //
    if (!Count) {
        LocalFree( AnsiString );
        return NULL;
    }

    return AnsiString;
}



LPWSTR CFaxTiff::GetStringTag(WORD TagId)
{
    for (DWORD i=0; i<m_dwNumDirEntries; i++) {
        if (m_TiffTags[i].TagId == TagId) {
            if (m_TiffTags[i].DataType != TIFF_ASCII) {
                return NULL;
            }
            if (m_TiffTags[i].DataCount > 4) {
                return AnsiStringToUnicodeString( (LPSTR) (m_pfPtr + m_TiffTags[i].DataOffset) );
            }
            return AnsiStringToUnicodeString( (LPSTR) &m_TiffTags[i].DataOffset );
        }
    }

    return NULL;
}


DWORD CFaxTiff::GetDWORDTag(WORD TagId)
{
    for (DWORD i=0; i<m_dwNumDirEntries; i++) {
        if (m_TiffTags[i].TagId == TagId) {
            if (m_TiffTags[i].DataType != TIFF_LONG) {
                return 0;
            }
            return m_TiffTags[i].DataOffset;
        }
    }
    return 0;
}


DWORDLONG CFaxTiff::GetQWORDTag(WORD TagId)
{
    for (DWORD i=0; i<m_dwNumDirEntries; i++) {
        if (m_TiffTags[i].TagId == TagId) {
            if (m_TiffTags[i].DataType != TIFF_SRATIONAL) {
                return 0;
            }
            return *(UNALIGNED DWORDLONG*) (m_pfPtr + m_TiffTags[i].DataOffset);
        }
    }
    return 0;
}


STDMETHODIMP CFaxTiff::InterfaceSupportsErrorInfo(REFIID riid)
{
        static const IID* arr[] =
        {
                &IID_IFaxTiff,
        };
        for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
        {
                if (InlineIsEqualGUID(*arr[i],riid))
                        return S_OK;
        }
        return S_FALSE;
}

STDMETHODIMP CFaxTiff::get_ReceiveTime(BSTR * pVal)
{
    BSTR Copy = NULL;
    DWORD StrSize = 0;
    WCHAR DateStr[256];
    WCHAR TimeStr[128];
    FILETIME LocalTime;
    SYSTEMTIME SystemTime;
    DWORDLONG ReceiveTime;
    BOOL bFail = FALSE;

    if (!pVal) {
        return E_POINTER;
    }
    
    ReceiveTime = GetQWORDTag( TIFFTAG_FAX_END_TIME );
    if (ReceiveTime == 0) {
        Copy = GetString( IDS_UNAVAILABLE );
        bFail = TRUE;
        goto copy;
    }

    

    FileTimeToLocalFileTime( (FILETIME*) &ReceiveTime, &LocalTime );
    FileTimeToSystemTime( &LocalTime, &SystemTime );    

    StrSize = GetY2KCompliantDate (
        LOCALE_USER_DEFAULT,
        0,
        &SystemTime,
        DateStr,
        sizeof(DateStr)/sizeof(DateStr[0])
        );
    if (StrSize == 0) {
        Copy = GetString( IDS_UNAVAILABLE );
        goto copy;
    }

    StrSize = FaxTimeFormat(
        LOCALE_USER_DEFAULT,
        0,
        &SystemTime,
        NULL,
        TimeStr,
        sizeof(TimeStr)
        );
    if (StrSize == 0) {
        Copy = GetString( IDS_UNAVAILABLE );
        goto copy;
    }

    wcscat( DateStr, L" @ " );
    wcscat( DateStr, TimeStr );

    Copy = SysAllocString(DateStr);
                                     
copy:

    if (!Copy) {
        return E_OUTOFMEMORY;
    }

    __try {

        *pVal = Copy;
        if (bFail) {
            return S_FALSE;
        }
        return S_OK;
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SysFreeString( Copy );
    }

    return E_UNEXPECTED;
}

STDMETHODIMP CFaxTiff::get_Image(BSTR *FileName)
{
    if (!FileName) {
        return E_POINTER;
    }
    
    BSTR Copy = SysAllocString(m_wszTiffFileName);

    if (!Copy  && m_wszTiffFileName) {
        return E_OUTOFMEMORY;
    }

    __try {
        *FileName = Copy;
        return S_OK;
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SysFreeString( Copy );
    }

    return E_UNEXPECTED;

}

STDMETHODIMP CFaxTiff::put_Image(BSTR FileName)
{
    if (!FileName) {
        return E_POINTER;
    }    
    
    HRESULT Rslt = E_FAIL;

    //
    // if a file was previously open, then close it
    //

    if (m_hFile != INVALID_HANDLE_VALUE) {
        UnmapViewOfFile( m_pfPtr );
        CloseHandle( m_hMap );
        CloseHandle( m_hFile );
    }

    //
    // open the tiff file
    //

    m_hFile = CreateFile(
        FileName,
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        0,
        NULL
        );
    if (m_hFile == INVALID_HANDLE_VALUE) {
        goto exit;
    }

    m_hMap = CreateFileMapping(
        m_hFile,
        NULL,
        PAGE_READONLY | SEC_COMMIT,
        0,
        0,
        NULL
        );
    if (!m_hMap) {
        goto exit;
    }

    m_pfPtr = (LPBYTE) MapViewOfFile(
        m_hMap,
        FILE_MAP_READ,
        0,
        0,
        0
        );
    if (!m_pfPtr) {
        goto exit;
    }

    m_TiffHeader = (PTIFF_HEADER) m_pfPtr;

    //
    // validate that the file is really a tiff file
    //

    if ((m_TiffHeader->Identifier != TIFF_LITTLEENDIAN) || (m_TiffHeader->Version != TIFF_VERSION)) {
        goto exit;
    }

    //
    // get the tag count
    //

    m_dwNumDirEntries = *(LPWORD)(m_pfPtr + m_TiffHeader->IFDOffset);

    //
    // get a pointer to the tags
    //

    m_TiffTags = (UNALIGNED TIFF_TAG*) (m_pfPtr + m_TiffHeader->IFDOffset + sizeof(WORD));

    //
    // save the file name
    //

    wcscpy( m_wszTiffFileName, FileName );

    //
    // set a good return value
    //

    Rslt = 0;

exit:
    if (Rslt) {
        if (m_hFile != INVALID_HANDLE_VALUE) {
            if (m_pfPtr) {
                UnmapViewOfFile( m_pfPtr );
            }
            if (m_hMap) {
                CloseHandle( m_hMap );
            }
            CloseHandle( m_hFile );
            m_hFile = INVALID_HANDLE_VALUE;
            m_hMap = NULL;
            m_pfPtr = NULL;
        }
    }

    return Rslt;
}

STDMETHODIMP CFaxTiff::get_RecipientName(BSTR * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }
    
    BSTR Copy;
    BOOL bFail = FALSE;

    LPWSTR RecipName = GetStringTag( TIFFTAG_RECIP_NAME );
    if (!RecipName) {
        Copy = GetString( IDS_UNAVAILABLE );
        bFail = FALSE;
    } else {
        Copy = SysAllocString(RecipName);
        LocalFree( RecipName );
    }

    if (!Copy) {
        return E_OUTOFMEMORY;
    }

    __try { 
        
        *pVal = Copy;
        if (bFail) {
            return S_FALSE;
        }
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        
        SysFreeString( Copy );

    }

    return E_UNEXPECTED;

}


STDMETHODIMP CFaxTiff::get_RecipientNumber(BSTR * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }

    BSTR Copy;
    BOOL bFail = FALSE;

    LPWSTR RecipNumber = GetStringTag( TIFFTAG_RECIP_NUMBER );
    if (!RecipNumber) {
        Copy = GetString( IDS_UNAVAILABLE );
        bFail = TRUE;
    } else {
        Copy = SysAllocString(RecipNumber);
        LocalFree( RecipNumber );
    }
    
    if (!Copy) {
        return E_OUTOFMEMORY;
    }

    __try {

        *pVal = Copy;
        if (bFail) {
            return S_FALSE;
        }
        return S_OK;

     } __except (EXCEPTION_EXECUTE_HANDLER) {

         SysFreeString( Copy );

    }

    return E_UNEXPECTED;

}

STDMETHODIMP CFaxTiff::get_SenderName(BSTR * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }

    BSTR Copy;
    BOOL bFail = FALSE;

    LPWSTR SenderName = GetStringTag( TIFFTAG_SENDER_NAME );
    if (!SenderName) {
        Copy = GetString( IDS_UNAVAILABLE );
        bFail = TRUE;
    } else {
        Copy = SysAllocString(SenderName);
        LocalFree( SenderName );
    }

    if (!Copy) {
        return E_OUTOFMEMORY;
    }

    __try {
        
        *pVal = Copy;
        if (bFail) {
            return S_FALSE;
        }
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SysFreeString( Copy );
    }

    return E_UNEXPECTED;

}

STDMETHODIMP CFaxTiff::get_Routing(BSTR * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }
   
    BSTR Copy;
    BOOL bFail = FALSE;

    LPWSTR Routing = GetStringTag( TIFFTAG_ROUTING );
    if (!Routing) {
        Copy = GetString( IDS_UNAVAILABLE );        
        bFail = TRUE;
    } else {
        Copy = SysAllocString(Routing);
        LocalFree( Routing );
    }

    if (!Copy) {
        return E_OUTOFMEMORY;
    }

    __try {
        
        *pVal = Copy;
        if (bFail) {
            return S_FALSE;
        }
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SysFreeString( Copy );
    }

    return E_UNEXPECTED;
}

STDMETHODIMP CFaxTiff::get_CallerId(BSTR * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }

    BSTR Copy;
    BOOL bFail = FALSE;

    LPWSTR CallerId = GetStringTag( TIFFTAG_CALLERID );
    if (!CallerId) {
        Copy = GetString( IDS_UNAVAILABLE );        
        bFail = TRUE;
    } else {
        Copy = SysAllocString( CallerId );
        LocalFree( CallerId );
    }

    if (!Copy) {
        return E_OUTOFMEMORY;
    }

    __try {
        
        *pVal = Copy;
        if (bFail) {
            return S_FALSE;
        }
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SysFreeString( Copy );
    }

    return E_UNEXPECTED;
}

STDMETHODIMP CFaxTiff::get_Csid(BSTR * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }

    BSTR Copy;
    BOOL bFail = FALSE;

    LPWSTR Csid = GetStringTag( TIFFTAG_CSID );
    if (!Csid) {
        Copy = GetString( IDS_UNAVAILABLE );        
        bFail = TRUE;
    } else {
        Copy = SysAllocString( Csid );
        LocalFree( Csid );
    }

    if (!Copy) {
        return E_OUTOFMEMORY;
    }

    __try {
        
        *pVal = Copy;
        if (bFail) {
            return S_FALSE;
        }
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SysFreeString( Copy );
    }

    return E_UNEXPECTED;
}

STDMETHODIMP CFaxTiff::get_Tsid(BSTR * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }

    BSTR Copy;
    BOOL bFail = FALSE;

    LPWSTR Tsid = GetStringTag( TIFFTAG_TSID );
    if (!Tsid) {
        Copy = GetString( IDS_UNAVAILABLE );        
        bFail = TRUE;
    } else {
        Copy = SysAllocString( Tsid );
        LocalFree( Tsid );
    }

    if (!Copy) {
        return E_OUTOFMEMORY;
    }

    __try {
        
        *pVal = Copy;
        if (bFail) {
            return S_FALSE;
        }
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SysFreeString( Copy );
    }

    return E_UNEXPECTED;
}

STDMETHODIMP CFaxTiff::get_RawReceiveTime(VARIANT *pVal)
{
    if (!pVal) {
        return E_POINTER;
    }
    
    VARIANT local;
    DWORDLONG ReceiveTime = GetQWORDTag( TIFFTAG_FAX_END_TIME );
    
    ZeroMemory(&local, sizeof(local));

    local.vt = VT_CY;
    local.cyVal.Lo = (DWORD)(ReceiveTime & 0xFFFFFFFF);
    local.cyVal.Hi = (LONG) (ReceiveTime >> 32);    

    //
    // can't use VariantCopy because this is a caller allocated variant
    //
    __try {
        
        pVal->vt       = local.vt;
        pVal->cyVal.Lo = local.cyVal.Lo;
        pVal->cyVal.Hi = local.cyVal.Hi;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
    
    }
    
    return E_UNEXPECTED;

}   

STDMETHODIMP CFaxTiff::get_TiffTagString(
    int tagID,
    BSTR* pVal
    )
{
    if (!pVal) 
    {
        return E_POINTER;
    }

    LPWSTR  lpwstrValue = NULL;
    BSTR    bstrResult = NULL;
    bool    bFail = FALSE;

    //
    //  This does LocalAlloc and returns LPWSTR
    //
    lpwstrValue = GetStringTag( (WORD)tagID );
    if (!lpwstrValue) 
    {
        //
        //  This does SysAllocString and returns BSTR
        //
        bstrResult = GetString( IDS_UNAVAILABLE );        
        bFail = TRUE;
    } 
    else
    {
        bstrResult = SysAllocString(lpwstrValue);
        LocalFree(lpwstrValue);
    }

    //
    //  Failed to SysAllocString in either case
    //
    if (!bstrResult)
    {
        return E_OUTOFMEMORY;
    }

    //
    //  Now try to return bstrResult
    //
    __try 
    {
        
        *pVal = bstrResult;
        if (bFail) 
        {
            return S_FALSE;
        }
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) 
    {
        //
        //  Failed to return bstrResult
        //
        SysFreeString(bstrResult);
    }

    return E_UNEXPECTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\win2k\faxroute.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    faxroute.cpp

Abstract:

    This file implements the CFaxRoutingMethod and
    CFaxRoutingMethods interfaces.

Author:

    Wesley Witt (wesw) 1-June-1997

Environment:

    User Mode

--*/

#include "stdafx.h"
#include "faxroute.h"



CFaxRoutingMethod::CFaxRoutingMethod()
{
    m_pFaxPort      = NULL;
    m_LastFaxError  = NO_ERROR;
    m_DeviceId      = 0;
    m_Enabled       = FALSE;
    m_DeviceName    = NULL;
    m_Guid          = NULL;
    m_FunctionName  = NULL;
    m_ImageName     = NULL;
    m_FriendlyName  = NULL;
}


CFaxRoutingMethod::~CFaxRoutingMethod()
{
    if (m_pFaxPort) 
    {
        m_pFaxPort->Release();
    }

    SysFreeString( m_DeviceName );
    SysFreeString( m_Guid );
    SysFreeString( m_FunctionName );
    SysFreeString( m_ImageName );
    SysFreeString( m_FriendlyName );
    SysFreeString( m_ExtensionName );
    FaxFreeBuffer( m_RoutingData );
}


BOOL
CFaxRoutingMethod::Initialize(
    CFaxPort *i_pFaxPort,
    DWORD  i_DeviceId,
    BOOL   i_Enabled,
    LPCWSTR i_DeviceName,
    LPCWSTR i_Guid,
    LPCWSTR i_FunctionName,
    LPCWSTR i_FriendlyName,
    LPCWSTR i_ImageName,
    LPCWSTR i_ExtensionName
    )
{
    m_pFaxPort = i_pFaxPort;
    if (!m_pFaxPort) 
    {
        return FALSE;
    }

    if ( FAILED(m_pFaxPort->AddRef()) )
    {
        m_pFaxPort = NULL;
        return FALSE;
    }

    m_DeviceId          = i_DeviceId;
    m_Enabled           = i_Enabled;
    m_DeviceName        = SysAllocString(i_DeviceName);
    m_Guid              = SysAllocString(i_Guid);
    m_FunctionName      = SysAllocString(i_FunctionName);
    m_ImageName         = SysAllocString(i_ImageName);
    m_FriendlyName      = SysAllocString(i_FriendlyName);
    m_ExtensionName     = SysAllocString(i_ExtensionName);
    m_RoutingData       = NULL;

    if ( (!m_DeviceName && i_DeviceName) ||
         (!m_Guid && i_Guid) ||
         (!m_FunctionName && i_FunctionName) ||
         (!m_ImageName && i_ImageName) ||
         (!m_FriendlyName && i_FriendlyName) ||
         (!m_ExtensionName && i_ExtensionName)
       ) 
    {
        m_LastFaxError = E_OUTOFMEMORY;
        goto error;
    }

    DWORD Size = 0;
    if (!FaxGetRoutingInfoW( m_pFaxPort->GetPortHandle(), m_Guid, &m_RoutingData, &Size )) 
    {
        m_RoutingData = NULL;
        m_LastFaxError = GetLastError();
        goto error;
    }

    if (Size == 0) 
    {
        FaxFreeBuffer( m_RoutingData );
        m_RoutingData = NULL;
    }

    return TRUE;

error:
    SysFreeString(m_DeviceName);   
    SysFreeString(m_Guid);         
    SysFreeString(m_FunctionName); 
    SysFreeString(m_ImageName);    
    SysFreeString(m_FriendlyName); 
    SysFreeString(m_ExtensionName);

    m_pFaxPort->Release();
    m_pFaxPort = NULL;

    return FALSE;

}


STDMETHODIMP CFaxRoutingMethod::InterfaceSupportsErrorInfo(REFIID riid)
{
    static const IID* arr[] = { &IID_IFaxRoutingMethod };

    for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++) {
        if (InlineIsEqualGUID(*arr[i],riid)) {
            return S_OK;
        }
    }

    return S_FALSE;
}


STDMETHODIMP CFaxRoutingMethod::get_DeviceId(long * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }

    __try {
        
        *pVal = m_DeviceId;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {

    }

    return E_UNEXPECTED;
}


STDMETHODIMP CFaxRoutingMethod::get_Enable(BOOL * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }

    __try {
        
        *pVal = m_Enabled;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {

    }

    return E_UNEXPECTED;    
    
}


STDMETHODIMP CFaxRoutingMethod::put_Enable(BOOL newVal)
{
    if (!FaxEnableRoutingMethodW( m_pFaxPort->GetPortHandle(), m_Guid, newVal)) {
        return Fax_HRESULT_FROM_WIN32(GetLastError());
    }
    m_Enabled = newVal;
    return S_OK;
}


STDMETHODIMP CFaxRoutingMethod::get_DeviceName(BSTR * pVal)
{
    if (!pVal) 
    {
        return E_POINTER;
    }

    BSTR Copy = SysAllocString(m_DeviceName);
    if (!Copy  && m_DeviceName) 
    {
        return E_OUTOFMEMORY;
    }

    __try 
    {
        *pVal = Copy;
        return S_OK;
    } 
    __except (EXCEPTION_EXECUTE_HANDLER) 
    {
        SysFreeString(Copy);
    }

    return E_UNEXPECTED;    
}


STDMETHODIMP CFaxRoutingMethod::get_Guid(BSTR * pVal)
{
    if (!pVal) 
    {
        return E_POINTER;
    }

    BSTR Copy = SysAllocString(m_Guid);
    if (!Copy  && m_Guid) 
    {
        return E_OUTOFMEMORY;
    }

    __try 
    {
        *pVal = Copy;
        return S_OK;
    } 
    __except (EXCEPTION_EXECUTE_HANDLER) 
    {
        SysFreeString(Copy);
    }

    return E_UNEXPECTED;    
}


STDMETHODIMP CFaxRoutingMethod::get_FunctionName(BSTR * pVal)
{
    if (!pVal) 
    {
        return E_POINTER;
    }

    BSTR Copy = SysAllocString(m_FunctionName);
    if (!Copy && m_FunctionName) 
    {
        return E_OUTOFMEMORY;
    }

    __try 
    {
        *pVal = Copy;
        return S_OK;
    } 
    __except (EXCEPTION_EXECUTE_HANDLER) 
    {
        SysFreeString(Copy);
    }

    return E_UNEXPECTED;    
}


STDMETHODIMP CFaxRoutingMethod::get_ImageName(BSTR * pVal)
{
    if (!pVal) 
    {
        return E_POINTER;
    }

    BSTR Copy = SysAllocString(m_ImageName);
    if (!Copy && m_ImageName) 
    {
        return E_OUTOFMEMORY;
    }

    __try 
    {
        *pVal = Copy;
        return S_OK;
    } 
    __except (EXCEPTION_EXECUTE_HANDLER) 
    {
        SysFreeString(Copy);
    }

    return E_UNEXPECTED;        
}


STDMETHODIMP CFaxRoutingMethod::get_FriendlyName(BSTR * pVal)
{
    if (!pVal) 
    {
        return E_POINTER;
    }

    BSTR Copy = SysAllocString(m_FriendlyName);
    if (!Copy  && m_FriendlyName) 
    {
        return E_OUTOFMEMORY;
    }

    __try 
    {
        *pVal = Copy;
        return S_OK;
    } 
    __except (EXCEPTION_EXECUTE_HANDLER) 
    {
        SysFreeString(Copy);
    }

    return E_UNEXPECTED;            
}


STDMETHODIMP CFaxRoutingMethod::get_ExtensionName(BSTR * pVal)
{
    if (!pVal) 
    {
        return E_POINTER;
    }

    BSTR Copy = SysAllocString(m_ExtensionName);
    if (!Copy  && m_ExtensionName) 
    {
        return E_OUTOFMEMORY;
    }

    __try 
    {
        *pVal = Copy;
        return S_OK;
    } 
    __except (EXCEPTION_EXECUTE_HANDLER) 
    {
        SysFreeString(Copy);
    }

    return E_UNEXPECTED;            
}


STDMETHODIMP CFaxRoutingMethod::get_RoutingData(BSTR * pVal)
{
    if (!pVal) 
    {
        return E_POINTER;
    }

    BSTR Copy = NULL;

    __try 
    {
        if (m_RoutingData == NULL) 
        {        
            Copy = SysAllocString(_T(""));            
            if (!Copy) 
            {
                return E_OUTOFMEMORY;
            }
        } 
        else if (*((LPDWORD)m_RoutingData) == 0 || *((LPDWORD)m_RoutingData) == 1) 
        {
            Copy = SysAllocString((LPWSTR)(m_RoutingData + sizeof(DWORD)) );
            if (!Copy && ((LPWSTR)(m_RoutingData + sizeof(DWORD))) )
            {
                return E_OUTOFMEMORY;
            }
        } 
        else 
        {
            return E_UNEXPECTED;
        }

        *pVal = Copy;
        return S_OK;
    } 
    __except (EXCEPTION_EXECUTE_HANDLER) 
    {
        SysFreeString(Copy);
    }

    return E_UNEXPECTED;
}


CFaxRoutingMethods::CFaxRoutingMethods()
{
    m_pFaxPort      = NULL;
    m_LastFaxError  = 0;
    m_MethodCount   = 0;
    m_VarVect       = NULL;
}


CFaxRoutingMethods::~CFaxRoutingMethods()
{
    if (m_pFaxPort) {
        m_pFaxPort->Release();
    }

    if (m_VarVect) {
        delete [] m_VarVect;
    }
}


BOOL CFaxRoutingMethods::Init(CFaxPort *pFaxPort)
{
    HRESULT hr;
    
    if (!pFaxPort) 
    {
        return FALSE;
    }

    m_pFaxPort = pFaxPort;
    hr = m_pFaxPort->AddRef();
    if (FAILED(hr)) 
    {
        m_pFaxPort = NULL;
        return FALSE;
    }

    PFAX_ROUTING_METHODW RoutingMethod = NULL;
    DWORD Size = 0;

    //
    // get the routing methods from the server
    //

    if (!FaxEnumRoutingMethodsW( m_pFaxPort->GetPortHandle(), &RoutingMethod, &m_MethodCount )) 
    {
        m_LastFaxError = GetLastError();        
        return FALSE;
    }

    //
    // enumerate the methods
    //

    m_VarVect = new CComVariant[m_MethodCount];
    if (!m_VarVect) 
    {
        FaxFreeBuffer( RoutingMethod );
        return FALSE;
    }

    for (DWORD i=0; i<m_MethodCount; i++) 
    {

        //
        // create the object
        //

        CComObject<CFaxRoutingMethod> *pFaxRoutingMethod;
        HRESULT hr = CComObject<CFaxRoutingMethod>::CreateInstance( &pFaxRoutingMethod );
        if (FAILED(hr)) 
        {
            delete [] m_VarVect;
            m_VarVect = NULL;
            FaxFreeBuffer( RoutingMethod );
            return FALSE;
        }

        //
        // set the values
        //

        if (!pFaxRoutingMethod->Initialize(
            m_pFaxPort,
            RoutingMethod[i].DeviceId,
            RoutingMethod[i].Enabled,
            RoutingMethod[i].DeviceName,
            RoutingMethod[i].Guid,
            RoutingMethod[i].FunctionName,
            RoutingMethod[i].FriendlyName,
            RoutingMethod[i].ExtensionImageName,
            RoutingMethod[i].ExtensionFriendlyName
            ))
        {
            delete [] m_VarVect;
            m_VarVect = NULL;
            FaxFreeBuffer( RoutingMethod );
            return FALSE;
        }

        //
        // get IDispatch pointer
        //

        LPDISPATCH lpDisp = NULL;
        hr = pFaxRoutingMethod->QueryInterface( IID_IDispatch, (void**)&lpDisp );
        if (FAILED(hr)) 
        {
            delete [] m_VarVect;
            m_VarVect = NULL;
            FaxFreeBuffer( RoutingMethod );
            return FALSE;
        }

        //
        // create a variant and add it to the collection
        //

        CComVariant &var = m_VarVect[i];
        __try 
        {
            var.vt = VT_DISPATCH;
            var.pdispVal = lpDisp;
            hr = S_OK;
        }
        __except (EXCEPTION_EXECUTE_HANDLER) 
        {
            hr = E_UNEXPECTED;            
        }

        if (FAILED(hr)) 
        {
            delete [] m_VarVect;
            m_VarVect = NULL;
            FaxFreeBuffer( RoutingMethod );
            return FALSE;
        }
    }

    FaxFreeBuffer( RoutingMethod );

    return TRUE;
}


STDMETHODIMP CFaxRoutingMethods::get_Item(long Index, VARIANT * retval)
{
    if (!retval) 
    {
        return E_POINTER;
    }

    //
    // use 1-based index, VB like
    //

    if ((Index < 1) || (Index > (long) m_MethodCount)) {
        return E_INVALIDARG;
    }

    __try 
    {
        VariantInit( retval );
    
        retval->vt = VT_UNKNOWN;
        retval->punkVal = NULL;

        return VariantCopy( retval, &m_VarVect[Index-1] );
        
    } __except (EXCEPTION_EXECUTE_HANDLER) 
    {

    }    

    return E_UNEXPECTED;
}


STDMETHODIMP CFaxRoutingMethods::get_Count(long * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }
    
    __try {
        *pVal = m_MethodCount;
        return S_OK;
    } __except (EXCEPTION_EXECUTE_HANDLER) {

    }

    return E_UNEXPECTED;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\win2k\status.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    status.cpp

Abstract:

    This module implements the status interface/object.

Author:

    Wesley Witt (wesw) 20-May-1997


Revision History:

--*/

#include "stdafx.h"
#include "faxcom.h"
#include "status.h"



CFaxStatus::CFaxStatus()
{
    m_pFaxPort          = NULL;
    m_Tsid              = NULL;
    m_Description       = NULL;
    m_RecipientName     = NULL;
    m_SenderName        = NULL;
    m_RoutingString     = NULL;
    m_Address           = NULL;
    m_DocName           = NULL;
    m_DeviceName        = NULL;
    m_Csid              = NULL;
    m_CallerId          = NULL;

    m_Receive           = FALSE;
    m_Send              = FALSE;

    m_PageCount         = 0;
    m_DocSize           = 0;
    m_DeviceId          = 0;
    m_CurrentPage       = 0;

    ZeroMemory( &m_StartTime, sizeof(m_StartTime) );
    ZeroMemory( &m_SubmittedTime, sizeof(m_SubmittedTime) );
    ZeroMemory( &m_ElapsedTime, sizeof(m_ElapsedTime) );
}


CFaxStatus::~CFaxStatus()
{
    if (m_pFaxPort) {
        m_pFaxPort->Release();
    }

    FreeMemory();
}


void CFaxStatus::FreeMemory()
{
    if (m_Tsid) {
        SysFreeString( m_Tsid );
    }
    if (m_Description) {
        SysFreeString( m_Description );
    }
    if (m_RecipientName) {
        SysFreeString( m_RecipientName );
    }
    if (m_SenderName) {
        SysFreeString( m_SenderName );
    }
    if (m_RoutingString) {
        SysFreeString( m_RoutingString );
    }    
    if (m_Address) {
        SysFreeString( m_Address );
    }
    if (m_DocName) {
        SysFreeString( m_DocName );
    }
    if (m_DeviceName) {
        SysFreeString( m_DeviceName );
    }
    if (m_Csid) {
        SysFreeString( m_Csid );
    }
    if (m_CallerId) {
        SysFreeString( m_CallerId );
    }

    m_Tsid              = NULL;
    m_Description       = NULL;
    m_RecipientName     = NULL;
    m_SenderName        = NULL;
    m_RoutingString     = NULL;    
    m_Address           = NULL;
    m_DocName           = NULL;
    m_DeviceName        = NULL;
    m_Csid              = NULL;
    m_CallerId          = NULL;

    m_Receive           = FALSE;
    m_Send              = FALSE;

    m_PageCount         = 0;
    m_DocSize           = 0;    
    m_DeviceId          = 0;
    m_CurrentPage       = 0;

    ZeroMemory( &m_StartTime, sizeof(m_StartTime) );
    ZeroMemory( &m_SubmittedTime, sizeof(m_SubmittedTime) );
    ZeroMemory( &m_ElapsedTime, sizeof(m_ElapsedTime) );
}


BOOL CFaxStatus::Init(CFaxPort *pFaxPort)
{
    HRESULT hr;
    
    m_pFaxPort = pFaxPort;
    
    hr = m_pFaxPort->AddRef();
    if (FAILED(hr)) {
        m_pFaxPort = NULL;
        return FALSE;
    }

    hr = Refresh();
    if (FAILED(hr)) {
        return FALSE;
    }
    return TRUE;
}


STDMETHODIMP CFaxStatus::Refresh()
{
    PFAX_DEVICE_STATUSW FaxStatus = NULL;
    DWORD Size = 0;
    DWORDLONG ElapsedTime;
    DWORDLONG CurrentFileTime;
    SYSTEMTIME CurrentTime;
    HRESULT hr = S_OK;


    if (!FaxGetDeviceStatusW( m_pFaxPort->GetPortHandle(), &FaxStatus )) {
        return Fax_HRESULT_FROM_WIN32(GetLastError());
    }

    FreeMemory();

    m_PageCount         = FaxStatus->TotalPages;
    m_DocSize           = FaxStatus->Size;
    m_DeviceId          = m_pFaxPort->GetDeviceId();
    m_CurrentPage       = FaxStatus->CurrentPage;

    m_Receive           = FaxStatus->JobType == JT_RECEIVE ? TRUE : FALSE;
    m_Send              = FaxStatus->JobType == JT_SEND ? TRUE : FALSE;

    if (FaxStatus->Tsid) {
        m_Tsid = SysAllocString( FaxStatus->Tsid );
        if (!m_Tsid) {
            hr = E_OUTOFMEMORY;
            goto error;
        }
    }

    if (FaxStatus->StatusString) {
        m_Description = SysAllocString( FaxStatus->StatusString );
        if (!m_Description) {
            hr = E_OUTOFMEMORY;
            goto error;
        }
    }

    if (FaxStatus->RecipientName) {
        m_RecipientName = SysAllocString( FaxStatus->RecipientName );
        if (!m_RecipientName) {
            hr = E_OUTOFMEMORY;
            goto error;
        }
    }

    if (FaxStatus->SenderName) {
        m_SenderName = SysAllocString( FaxStatus->SenderName );
        if (!m_SenderName) {
            hr = E_OUTOFMEMORY;
            goto error;
        }
    }

    if (FaxStatus->RoutingString) {
        m_RoutingString = SysAllocString( FaxStatus->RoutingString );
        if (!m_RoutingString) {
            hr = E_OUTOFMEMORY;
            goto error;
        }
    }

    if (FaxStatus->PhoneNumber) {
        m_Address = SysAllocString( FaxStatus->PhoneNumber );
        if (!m_Address) {
            hr = E_OUTOFMEMORY;
            goto error;
        }
    }

    if (FaxStatus->DocumentName) {
        m_DocName = SysAllocString( FaxStatus->DocumentName );
        if (!m_DocName) {
            hr = E_OUTOFMEMORY;
            goto error;
        }
    }

    if (FaxStatus->DeviceName) {
        m_DeviceName = SysAllocString( FaxStatus->DeviceName );
        if (!m_DeviceName) {
            hr = E_OUTOFMEMORY;
            goto error;
        }
    }

    if (FaxStatus->Csid) {
        m_Csid = SysAllocString( FaxStatus->Csid );
        if (!m_Csid) {
            hr = E_OUTOFMEMORY;
            goto error;
        }
    }

    if (FaxStatus->CallerId) {
        m_CallerId = SysAllocString( FaxStatus->CallerId );
        if (!m_CallerId) {
            hr = E_OUTOFMEMORY;
            goto error;
        }
    }

    m_Description = GetDeviceStatus(FaxStatus->Status);
    if (!m_Description) {
            hr = E_OUTOFMEMORY;
            goto error;
    }

    if (!FileTimeToSystemTime( &FaxStatus->StartTime, &m_StartTime ))
    {
        //
        //  Failed to convert File Time to System Time
        //
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        goto error;
    }

    if (!FileTimeToSystemTime( &FaxStatus->SubmittedTime, &m_SubmittedTime ))
    {
        //
        //  Failed to convert File Time to System Time
        //
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        goto error;
    }

    GetSystemTime( &CurrentTime );

    if (!SystemTimeToFileTime( &CurrentTime, (FILETIME*)&ElapsedTime ))
    {
        //
        //  Failed to convert System Time to File Time
        //
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        goto error;
    }

    if (!SystemTimeToFileTime( &m_StartTime, (FILETIME*)&CurrentFileTime ))
    {
        //
        //  Failed to convert System Time to File Time
        //
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        goto error;
    }

    ElapsedTime = ElapsedTime - CurrentFileTime;

    if (!FileTimeToSystemTime( (FILETIME*)&ElapsedTime, &m_ElapsedTime ))
    {
        //
        //  Failed to convert File Time to System Time
        //
        hr = Fax_HRESULT_FROM_WIN32(GetLastError());
        goto error;
    }

    hr = ERROR_SUCCESS;

error:

    if (FAILED(hr))
    {
        //
        //  Make the object consistent
        //
        FreeMemory();
    }

    FaxFreeBuffer( FaxStatus );
    return hr;
}


STDMETHODIMP CFaxStatus::InterfaceSupportsErrorInfo(REFIID riid)
{
    static const IID* arr[] = { &IID_IFaxStatus };

    for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++) {
        if (InlineIsEqualGUID(*arr[i],riid)) {
            return S_OK;
        }
    }

    return S_FALSE;
}


STDMETHODIMP CFaxStatus::get_CallerId(BSTR * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }
    
    BSTR Copy = SysAllocString(m_CallerId);

    if (!Copy  && m_CallerId) {
        return E_OUTOFMEMORY;
    }

    __try {
        
        *pVal = Copy;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SysFreeString(Copy);
    }

    return E_UNEXPECTED;
}


STDMETHODIMP CFaxStatus::get_Csid(BSTR * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }
    
    BSTR Copy = SysAllocString(m_Csid);

    if (!Copy  && m_Csid) {
        return E_OUTOFMEMORY;
    }

    __try {
        
        *pVal = Copy;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SysFreeString(Copy);
    }

    return E_UNEXPECTED;
}


STDMETHODIMP CFaxStatus::get_CurrentPage(long * pVal)
{
    if (!pVal){
        return E_POINTER;
    }

    __try {
        
        *pVal = m_CurrentPage;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {

    }

    return E_UNEXPECTED;
}


STDMETHODIMP CFaxStatus::get_DeviceId(long * pVal)
{
    if (!pVal){
        return E_POINTER;
    }

    __try {
        
        *pVal = m_DeviceId;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {

    }

    return E_UNEXPECTED;
}


STDMETHODIMP CFaxStatus::get_DeviceName(BSTR * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }
    
    BSTR Copy = SysAllocString(m_DeviceName);

    if (!Copy  && m_DeviceName) {
        return E_OUTOFMEMORY;
    }

    __try {
        
        *pVal = Copy;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SysFreeString(Copy);
    }

    return E_UNEXPECTED;
}


STDMETHODIMP CFaxStatus::get_DocumentName(BSTR * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }
    
    BSTR Copy = SysAllocString(m_DocName);

    if (!Copy  && m_DocName) {
        return E_OUTOFMEMORY;
    }

    __try {
        
        *pVal = Copy;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SysFreeString(Copy);
    }

    return E_UNEXPECTED;
}


STDMETHODIMP CFaxStatus::get_Send(BOOL * pVal)
{
    *pVal = m_Send;
    return S_OK;
}


STDMETHODIMP CFaxStatus::get_Receive(BOOL * pVal)
{
    if (!pVal){
        return E_POINTER;
    }

    __try {
        
        *pVal = m_Receive;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {

    }

    return E_UNEXPECTED;
}


STDMETHODIMP CFaxStatus::get_Address(BSTR * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }
    
    BSTR Copy = SysAllocString(m_Address);

    if (!Copy  && m_Address) {
        return E_OUTOFMEMORY;
    }

    __try {
        
        *pVal = Copy;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SysFreeString(Copy);
    }

    return E_UNEXPECTED;}


STDMETHODIMP CFaxStatus::get_RoutingString(BSTR * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }
    
    BSTR Copy = SysAllocString(m_RoutingString);

    if (!Copy  && m_RoutingString) {
        return E_OUTOFMEMORY;
    }

    __try {
        
        *pVal = Copy;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SysFreeString(Copy);
    }

    return E_UNEXPECTED;
}


STDMETHODIMP CFaxStatus::get_SenderName(BSTR * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }
    
    BSTR Copy = SysAllocString(m_SenderName);

    if (!Copy  && m_SenderName) {
        return E_OUTOFMEMORY;
    }

    __try {
        
        *pVal = Copy;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SysFreeString(Copy);
    }

    return E_UNEXPECTED;
}


STDMETHODIMP CFaxStatus::get_RecipientName(BSTR * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }
    
    BSTR Copy = SysAllocString(m_RecipientName);

    if (!Copy  && m_RecipientName) {
        return E_OUTOFMEMORY;
    }

    __try {
        
        *pVal = Copy;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SysFreeString(Copy);
    }

    return E_UNEXPECTED;
}


STDMETHODIMP CFaxStatus::get_DocumentSize(long * pVal)
{
    if (!pVal){
        return E_POINTER;
    }

    __try {
        
        *pVal = m_DocSize;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {

    }

    return E_UNEXPECTED;
}


STDMETHODIMP CFaxStatus::get_Description(BSTR * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }
    
    BSTR Copy = SysAllocString(m_Description);

    if (!Copy  && m_Description) {
        return E_OUTOFMEMORY;
    }

    __try {
        
        *pVal = Copy;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SysFreeString(Copy);
    }

    return E_UNEXPECTED;
}


STDMETHODIMP CFaxStatus::get_PageCount(long * pVal)
{
    if (!pVal){
        return E_POINTER;
    }

    __try {
        
        *pVal = m_PageCount;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {

    }

    return E_UNEXPECTED;
}


STDMETHODIMP CFaxStatus::get_Tsid(BSTR * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }
    
    BSTR Copy = SysAllocString(m_Tsid);

    if (!Copy  && m_Tsid) {
        return E_OUTOFMEMORY;
    }

    __try {
        
        *pVal = Copy ;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        SysFreeString(Copy);
    }

    return E_UNEXPECTED;
}


STDMETHODIMP CFaxStatus::get_StartTime(DATE * pVal)
{
    if (!SystemTimeToVariantTime( &m_StartTime, pVal )) {
        return E_FAIL;
    }
    return S_OK;
}


STDMETHODIMP CFaxStatus::get_SubmittedTime(DATE * pVal)
{
    if (!SystemTimeToVariantTime( &m_SubmittedTime, pVal )) {
        return E_FAIL;
    }
    return S_OK;
}


STDMETHODIMP CFaxStatus::get_ElapsedTime(DATE * pVal)
{
    if (!SystemTimeToVariantTime( &m_ElapsedTime, pVal )) {
        return E_FAIL;
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\win2k\faxsvr.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    faxsvr.cpp

Abstract:

    This file implements the CFaxServer interface.

Author:

    Wesley Witt (wesw) 1-June-1997

Environment:

    User Mode

--*/

#include "stdafx.h"
#include "faxsvr.h"
#include "faxport.h"
#include "FaxDoc.h"
#include "FaxJob.h"




CFaxServer::CFaxServer()
{
    m_LastFaxError			= NO_ERROR;
    m_FaxHandle				= 0;
	m_Retries				= 0;
	m_RetryDelay			= 0;
	m_DirtyDays				= 0;
	m_UseDeviceTsid			= FALSE;
	m_ServerCp				= FALSE;
	m_PauseServerQueue		= FALSE;;
	m_StartCheapTime.Hour	= 0;
    m_StartCheapTime.Minute	= 0;
	m_StopCheapTime.Hour    = 0;
    m_StartCheapTime.Minute	= 0;
	m_ArchiveOutgoingFaxes  = FALSE;;
	m_ArchiveDirectory		= NULL;
}


CFaxServer::~CFaxServer()
{
    if (m_FaxHandle) 
    {
        FaxClose( m_FaxHandle );
    }

	if (m_ArchiveDirectory)
    {
        SysFreeString(m_ArchiveDirectory);	
    }
}


STDMETHODIMP CFaxServer::Connect(BSTR ServerName)
{
    if (!FaxConnectFaxServer( ServerName, &m_FaxHandle )) {
        m_LastFaxError = GetLastError();
        m_FaxHandle = NULL;
        return E_FAIL;
    }

	if (!RetrieveConfiguration()) {
        return Fax_HRESULT_FROM_WIN32(m_LastFaxError);
    }
	
    return S_OK;
}

STDMETHODIMP CFaxServer::Disconnect()
{
    if (m_FaxHandle == NULL) {
        return E_FAIL;
    }

    if (!FaxClose( m_FaxHandle )) {
        return E_FAIL;
    }

    m_FaxHandle = NULL;
	m_Retries = 0;
	m_RetryDelay = 0;
	m_DirtyDays = 0 ;
	m_Branding = FALSE;
	m_UseDeviceTsid = FALSE;
	m_ServerCp = FALSE;
	m_PauseServerQueue = FALSE;
	m_StartCheapTime.Hour = 0;
	m_StartCheapTime.Minute = 0;
	m_StopCheapTime.Hour = 0;
	m_StopCheapTime.Minute = 0;
	m_StartCheapTime.Hour = 0;
	m_ArchiveOutgoingFaxes = FALSE;

	if (m_ArchiveDirectory)
    {
        SysFreeString(m_ArchiveDirectory);
    }
	m_ArchiveDirectory = NULL;

    return S_OK;
}


STDMETHODIMP CFaxServer::GetPorts(VARIANT * retval)
{
    HRESULT hr;

    if (!retval) {
        return E_POINTER;
    }

    CComObject<CFaxPorts>* p = new CComObject<CFaxPorts>;
    if (!p) {
        return E_OUTOFMEMORY;
    }
    if (!p->Init(this)) {
        delete p;
        return E_FAIL;
    }

    IDispatch* pDisp;
    hr = p->QueryInterface(IID_IDispatch, (void**)&pDisp);
    if (FAILED(hr)) {
        delete p;
        return hr;        
    }

    __try { 

        VariantInit(retval);

        retval->vt = VT_DISPATCH;
        retval->pdispVal = pDisp;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        
    }

    pDisp->Release();
    delete p;    
    return E_UNEXPECTED;
    
}

STDMETHODIMP CFaxServer::CreateDocument(BSTR FileName, VARIANT * retval)
{
    HRESULT hr;

    if (!FileName || !retval) {
        return E_POINTER;
    }

    CComObject<CFaxDoc>* p = new CComObject<CFaxDoc>;
    if (!p) {
        return E_OUTOFMEMORY;
    }
    if (!p->Init(FileName,this)) {
        delete p;
        return E_FAIL;
    }

    IDispatch* pDisp;
    hr = p->QueryInterface(IID_IDispatch, (void**)&pDisp);
    if (FAILED(hr)) {
        delete p;
        return hr;
    }

    
    __try { 

        VariantInit(retval);

        retval->vt = VT_DISPATCH;
        retval->pdispVal = pDisp;
        return S_OK;

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        
    }

    pDisp->Release();
    delete p;    
    return E_UNEXPECTED;
}

STDMETHODIMP CFaxServer::GetJobs(VARIANT * retval)
{
    HRESULT hr;

    if (!retval) {
        return(E_POINTER);
    }
    
    CComObject<CFaxJobs>* p = new CComObject<CFaxJobs>;
    if (!p) {
        return E_OUTOFMEMORY;
    }
    if (!p->Init(this)) {
        delete p;
        return E_FAIL;
    }
    
    IDispatch* pDisp;
    hr = p->QueryInterface(IID_IDispatch, (void**)&pDisp);
    if (FAILED(hr)) {
        delete p;
        return hr;
    }
    
    __try { 

        VariantInit(retval);

        retval->vt = VT_DISPATCH;
        retval->pdispVal = pDisp;
        return S_OK;
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        
    }

    pDisp->Release();
    delete p;    

    return E_UNEXPECTED;
}

STDMETHODIMP CFaxServer::get_Retries(long * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }
    
    __try {
        *pVal = m_Retries;
        return S_OK;
    } __except(EXCEPTION_EXECUTE_HANDLER) {

    }
    
    return E_UNEXPECTED;
	
}

STDMETHODIMP CFaxServer::put_Retries(long newVal)
{
    long oldval = m_Retries;

	m_Retries = newVal;
	
	if (!UpdateConfiguration() ) {
        m_Retries = oldval;
		return Fax_HRESULT_FROM_WIN32(m_LastFaxError);
    }
	else 
		return S_OK;

}

STDMETHODIMP CFaxServer::get_RetryDelay(long * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }
    
    __try {
        *pVal = m_RetryDelay;
        return S_OK;
    } __except(EXCEPTION_EXECUTE_HANDLER) {

    }
    
    return E_UNEXPECTED;
	    
}

STDMETHODIMP CFaxServer::put_RetryDelay(long newVal)
{
    long oldval = m_RetryDelay;
	m_RetryDelay = newVal;
	
    if (!UpdateConfiguration() ) {
        m_RetryDelay = oldval;    
        return Fax_HRESULT_FROM_WIN32(m_LastFaxError);
    }
    else 
        return S_OK;
}

STDMETHODIMP CFaxServer::get_DirtyDays(long * pVal)
{
    if (!pVal) {
    return E_POINTER;
    }

    __try {
        *pVal = m_DirtyDays;
        return S_OK;
    } __except(EXCEPTION_EXECUTE_HANDLER) {
    
    }

    return E_UNEXPECTED;
        
}

STDMETHODIMP CFaxServer::put_DirtyDays(long newVal)
{
	long oldval = m_DirtyDays;
    m_DirtyDays = newVal;
	
    if (!UpdateConfiguration() ) {
        m_DirtyDays = oldval;    
        return Fax_HRESULT_FROM_WIN32(m_LastFaxError);
    }
    else 
        return S_OK;

}

STDMETHODIMP CFaxServer::get_Branding(BOOL * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }
    
    __try {
        *pVal = m_Branding;
        return S_OK;
    } __except(EXCEPTION_EXECUTE_HANDLER) {

    }
    
    return E_UNEXPECTED;
	    
}

STDMETHODIMP CFaxServer::put_Branding(BOOL newVal)
{
	BOOL oldval = m_Branding;
    m_Branding = newVal;
	
    if (!UpdateConfiguration() ) {
        m_Branding = oldval;
        return Fax_HRESULT_FROM_WIN32(m_LastFaxError);
    }
    else 
        return S_OK;

}

STDMETHODIMP CFaxServer::get_UseDeviceTsid(BOOL * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }
    
    __try {
        *pVal = m_UseDeviceTsid;
        return S_OK;
    } __except(EXCEPTION_EXECUTE_HANDLER) {

    }
    
    return E_UNEXPECTED;
	
}

STDMETHODIMP CFaxServer::put_UseDeviceTsid(BOOL newVal)
{
	BOOL oldval = m_UseDeviceTsid;
    m_UseDeviceTsid= newVal;
	
	if (!UpdateConfiguration() ) {
        m_UseDeviceTsid = oldval;
		return Fax_HRESULT_FROM_WIN32(m_LastFaxError);
    }
	else 
		return S_OK;


}

STDMETHODIMP CFaxServer::get_ServerCoverpage(BOOL * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }
    
    __try {
        *pVal = m_ServerCp;
        return S_OK;
    } __except(EXCEPTION_EXECUTE_HANDLER) {

    }
    
    return E_UNEXPECTED;
	
}

STDMETHODIMP CFaxServer::put_ServerCoverpage(BOOL newVal)
{
	BOOL oldval = m_ServerCp;
    m_ServerCp = newVal;
	
	if (!UpdateConfiguration() ) {
		m_ServerCp = oldval;
        return Fax_HRESULT_FROM_WIN32(m_LastFaxError);
    }
	else 
		return S_OK;

}

STDMETHODIMP CFaxServer::get_PauseServerQueue(BOOL * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }
    
    __try {
        *pVal = m_PauseServerQueue;
        return S_OK;
    } __except(EXCEPTION_EXECUTE_HANDLER) {

    }
    
    return E_UNEXPECTED;
	
}

STDMETHODIMP CFaxServer::put_PauseServerQueue(BOOL newVal)
{
	BOOL oldval = m_PauseServerQueue;
    m_PauseServerQueue = newVal;
	
	if (!UpdateConfiguration() ) {
		m_PauseServerQueue = oldval;
        return Fax_HRESULT_FROM_WIN32(m_LastFaxError);
    }
	else 
		return S_OK;

}

STDMETHODIMP CFaxServer::get_ArchiveOutboundFaxes(BOOL * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }
    
    __try {
        *pVal = m_ArchiveOutgoingFaxes;
        return S_OK;
    } __except(EXCEPTION_EXECUTE_HANDLER) {

    }
    
    return E_UNEXPECTED;
}

STDMETHODIMP CFaxServer::put_ArchiveOutboundFaxes(BOOL newVal)
{
	BOOL oldval = m_ArchiveOutgoingFaxes;
    m_ArchiveOutgoingFaxes = newVal;
	
	if (!UpdateConfiguration() ) {
        m_ArchiveOutgoingFaxes = oldval;
		return Fax_HRESULT_FROM_WIN32(m_LastFaxError);
    }
	else 
		return S_OK;


}

STDMETHODIMP CFaxServer::get_ArchiveDirectory(BSTR * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }
    
    BSTR Copy = SysAllocString(m_ArchiveDirectory);

    if (!Copy  && m_ArchiveDirectory) {
        return E_OUTOFMEMORY;
    }
    
    __try {
        
        *pVal = Copy;
        return S_OK;

    } __except(EXCEPTION_EXECUTE_HANDLER) {
        SysFreeString( Copy );
    }
    
    return E_UNEXPECTED;
	    
}

STDMETHODIMP CFaxServer::put_ArchiveDirectory(BSTR newVal)
{
	BSTR tmp = SysAllocString(newVal);
    BSTR old = m_ArchiveDirectory;
    if (!tmp && newVal) {
        return E_OUTOFMEMORY;
    }
        
    m_ArchiveDirectory = tmp;    
	
	if (!UpdateConfiguration() ) {
        SysFreeString(tmp);
        m_ArchiveDirectory = old;
		return Fax_HRESULT_FROM_WIN32(m_LastFaxError);
    } else {
        SysFreeString(old);        
        return S_OK;
    }
}

STDMETHODIMP CFaxServer::get_ServerMapiProfile(BSTR * pVal)
{
    if (!pVal) 
    {
        return E_POINTER;
    }
    
    BSTR Copy = SysAllocString(_T(""));
    if (!Copy) 
    {
        return E_OUTOFMEMORY;
    }
    
    __try 
    {
        *pVal = Copy;
        return S_OK;
    } 
    __except(EXCEPTION_EXECUTE_HANDLER) 
    {
        SysFreeString(Copy);
    }
    
    return E_UNEXPECTED;
}


STDMETHODIMP CFaxServer::put_ServerMapiProfile(BSTR newVal)
{
    return E_NOTIMPL;
}


STDMETHODIMP CFaxServer::get_DiscountRateStartHour(short * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }
    
    __try {
        *pVal = m_StartCheapTime.Hour;
        return S_OK;
    } __except(EXCEPTION_EXECUTE_HANDLER) {

    }
    
    return E_UNEXPECTED;
	
}

STDMETHODIMP CFaxServer::put_DiscountRateStartHour(short newVal)
{
	short old = m_StartCheapTime.Hour;
    m_StartCheapTime.Hour = newVal;

	if (!UpdateConfiguration() ) {
        m_StartCheapTime.Hour = old;
		return Fax_HRESULT_FROM_WIN32(m_LastFaxError);
    }
	else 
		return S_OK;

}

STDMETHODIMP CFaxServer::get_DiscountRateStartMinute(short * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }
    
    __try {
        *pVal = m_StartCheapTime.Minute;
        return S_OK;
    } __except(EXCEPTION_EXECUTE_HANDLER) {

    }
    
    return E_UNEXPECTED;
	
}

STDMETHODIMP CFaxServer::put_DiscountRateStartMinute(short newVal)
{
	short old = m_StartCheapTime.Minute;
    m_StartCheapTime.Minute = newVal;

	if (!UpdateConfiguration() ) {
        m_StartCheapTime.Minute = old;
		return Fax_HRESULT_FROM_WIN32(m_LastFaxError);
    }
	else 
		return S_OK;

}

STDMETHODIMP CFaxServer::get_DiscountRateEndHour(short * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }
    
    __try {
        *pVal = m_StopCheapTime.Hour;
        return S_OK;
    } __except(EXCEPTION_EXECUTE_HANDLER) {

    }
    
    return E_UNEXPECTED;
}

STDMETHODIMP CFaxServer::put_DiscountRateEndHour(short newVal)
{
	short old = m_StopCheapTime.Hour;
    m_StopCheapTime.Hour = newVal;

	if (!UpdateConfiguration() ) {
        m_StopCheapTime.Hour = old;
		return Fax_HRESULT_FROM_WIN32(m_LastFaxError);
    }
	else 
		return S_OK;

}

STDMETHODIMP CFaxServer::get_DiscountRateEndMinute(short * pVal)
{
    if (!pVal) {
        return E_POINTER;
    }
    
    __try {
        *pVal = m_StopCheapTime.Minute;
        return S_OK;
    } __except(EXCEPTION_EXECUTE_HANDLER) {

    }
    
    return E_UNEXPECTED;
}

STDMETHODIMP CFaxServer::put_DiscountRateEndMinute(short newVal)
{
	short old = m_StopCheapTime.Minute;
    m_StopCheapTime.Minute = newVal;

	if (!UpdateConfiguration() ) {
        m_StopCheapTime.Minute = old;
		return Fax_HRESULT_FROM_WIN32(m_LastFaxError);
    }
	else 
		return S_OK;

}


BOOL CFaxServer::RetrieveConfiguration()
{	    
    if (!m_FaxHandle) {
		return FALSE;
	}

	PFAX_CONFIGURATIONW FaxConfig;

	if (!FaxGetConfigurationW(m_FaxHandle,&FaxConfig) ) {
		m_LastFaxError = GetLastError();
		return FALSE;
	}

	m_Retries = FaxConfig->Retries;
	m_RetryDelay =FaxConfig->RetryDelay;
	m_DirtyDays = FaxConfig->DirtyDays;
	m_Branding = FaxConfig->Branding;
	m_UseDeviceTsid = FaxConfig->UseDeviceTsid;
	m_ServerCp = FaxConfig->ServerCp;
	m_PauseServerQueue = FaxConfig->PauseServerQueue;
	m_StartCheapTime.Hour = FaxConfig->StartCheapTime.Hour;
	m_StartCheapTime.Minute = FaxConfig->StartCheapTime.Minute;
	m_StopCheapTime.Hour = FaxConfig->StopCheapTime.Hour;
	m_StopCheapTime.Minute = FaxConfig->StopCheapTime.Minute;
	m_StartCheapTime.Hour = FaxConfig->StartCheapTime.Hour;
	m_ArchiveOutgoingFaxes = FaxConfig->ArchiveOutgoingFaxes;
	m_ArchiveDirectory = SysAllocString(FaxConfig->ArchiveDirectory);
    if ((!m_ArchiveDirectory && FaxConfig->ArchiveDirectory)) {
        m_LastFaxError = ERROR_OUTOFMEMORY;
    }

    FaxFreeBuffer(FaxConfig);    

    return (m_LastFaxError == NO_ERROR) ? TRUE : FALSE;

}

BOOL CFaxServer::UpdateConfiguration()
{
	if (!m_FaxHandle) {
		return FALSE;
	}

	FAX_CONFIGURATIONW FaxConfig;

	ZeroMemory(&FaxConfig,sizeof(FAX_CONFIGURATIONW) );
    FaxConfig.SizeOfStruct = sizeof(FAX_CONFIGURATIONW);
	FaxConfig.Retries = m_Retries;
	FaxConfig.RetryDelay = m_RetryDelay ;
	FaxConfig.DirtyDays = m_DirtyDays;
	FaxConfig.Branding = m_Branding;
	FaxConfig.UseDeviceTsid = m_UseDeviceTsid;
	FaxConfig.ServerCp = m_ServerCp;
	FaxConfig.PauseServerQueue = m_PauseServerQueue;
	FaxConfig.StartCheapTime.Hour = m_StartCheapTime.Hour;
	FaxConfig.StartCheapTime.Minute = m_StartCheapTime.Minute;
	FaxConfig.StopCheapTime.Hour = m_StopCheapTime.Hour;
	FaxConfig.StopCheapTime.Minute = m_StopCheapTime.Minute;
	FaxConfig.StartCheapTime.Hour = m_StartCheapTime.Hour;
	FaxConfig.ArchiveOutgoingFaxes = m_ArchiveOutgoingFaxes;
	FaxConfig.ArchiveDirectory = m_ArchiveDirectory;

	if (!FaxSetConfigurationW(m_FaxHandle,&FaxConfig) ) {
		m_LastFaxError = GetLastError();
		return FALSE;
	}

    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\win2k\faxtiff.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    faxtiff.h

Abstract:

    This file contains the class definition for the faxtiff object.

Author:

    Wesley Witt (wesw) 13-May-1997

Environment:

    User Mode

--*/

#ifndef __FAXTIFF_H_
#define __FAXTIFF_H_

#include "resource.h"       // main symbols
#include "tiff.h"
#include "faxutil.h"


class ATL_NO_VTABLE CFaxTiff :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CFaxTiff, &CLSID_FaxTiff>,
    public ISupportErrorInfo,
    public IDispatchImpl<IFaxTiff, &IID_IFaxTiff, &LIBID_FAXCOMLib>
{
public:
    CFaxTiff();
    ~CFaxTiff();

DECLARE_REGISTRY_RESOURCEID(IDR_FAXTIFF)

BEGIN_COM_MAP(CFaxTiff)
    COM_INTERFACE_ENTRY(IFaxTiff)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

// ISupportsErrorInfo
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IFaxTiff
public:
    STDMETHOD(get_Tsid)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_Csid)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_CallerId)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_Routing)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_SenderName)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_RecipientName)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_RecipientNumber)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_Image)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_Image)(/*[in]*/ BSTR newVal);
    STDMETHOD(get_ReceiveTime)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_RawReceiveTime)(/*[out, retval]*/ VARIANT *pVal);
    STDMETHOD(get_TiffTagString)(/*[in]*/ int tagID, /*[out, retval]*/ BSTR* pVal);       

private:
    LPWSTR      GetStringTag(WORD TagId);
    DWORD       GetDWORDTag(WORD TagId);
    DWORDLONG   GetQWORDTag(WORD TagId);
    BSTR        GetString( DWORD ResId );
    LPWSTR      AnsiStringToUnicodeString(LPSTR AnsiString);
    LPSTR       UnicodeStringToAnsiString(LPWSTR UnicodeString);


private:
    WCHAR                   m_wszTiffFileName[MAX_PATH+1];
    WCHAR                   m_wszStrBuf[128];
    HANDLE                  m_hFile;
    HANDLE                  m_hMap;
    LPBYTE                  m_pfPtr;
    PTIFF_HEADER            m_TiffHeader;
    DWORD                   m_dwNumDirEntries;
    UNALIGNED TIFF_TAG*     m_TiffTags;
};

#endif //__FAXTIFF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\win2k\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__87099227_C7AF_11D0_B225_00C04FB6C2F5__INCLUDED_)
#define AFX_STDAFX_H__87099227_C7AF_11D0_B225_00C04FB6C2F5__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT


//#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include "faxcom.h"
#include "winfax.h"

inline 
HRESULT Fax_HRESULT_FROM_WIN32 (DWORD dwWin32Err)
{
    if (dwWin32Err >= FAX_ERR_START && dwWin32Err <= FAX_ERR_END)
    {
        //
        // Fax specific error code - make a HRESULT using FACILITY_ITF
        //
        return MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, dwWin32Err);
    }
    else
    {
        return HRESULT_FROM_WIN32(dwWin32Err);
    }
}   // Fax_HRESULT_FROM_WIN32

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__87099227_C7AF_11D0_B225_00C04FB6C2F5__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\win2k\util.cpp ===
#include "stdafx.h"
#include "resource.h"
#include <winfax.h>

extern CComModule _Module;

BSTR GetQueueStatus(DWORD QueueStatus) 
{
    WCHAR  szQueueStatus[100];
    szQueueStatus[0] = (WCHAR)'\0';

    DWORD ResourceID;

    if (QueueStatus & JS_INPROGRESS)      {
        ResourceID = IDS_JOB_INPROGRESS;
    } else if (QueueStatus & JS_DELETING) {
        ResourceID = IDS_JOB_DELETING;
    } else if (QueueStatus & JS_FAILED)   {
        ResourceID = IDS_JOB_FAILED;
    } else if (QueueStatus & JS_PAUSED)   {
        ResourceID = IDS_JOB_PAUSED;
    } else if (QueueStatus == JS_PENDING) {
        ResourceID = IDS_JOB_PENDING;
    } else
        ResourceID = IDS_JOB_UNKNOWN;

    LoadString(_Module.GetModuleInstance(),ResourceID,szQueueStatus,100);

    return SysAllocString(szQueueStatus);
}


BSTR GetDeviceStatus(DWORD DeviceStatus)
{
    WCHAR  szDeviceStatus[100];
    szDeviceStatus[0] = (WCHAR)'\0';

    DWORD ResourceID;

    if (DeviceStatus == FPS_DIALING) {
        ResourceID = IDS_DEVICE_DIALING;
    } else if (DeviceStatus == FPS_SENDING) {
        ResourceID = IDS_DEVICE_SENDING;
    } else if (DeviceStatus == FPS_RECEIVING) {
        ResourceID = IDS_DEVICE_RECEIVING;
    } else if (DeviceStatus == FPS_COMPLETED) {
        ResourceID = IDS_DEVICE_COMPLETED;
    } else if (DeviceStatus == FPS_HANDLED) {
        ResourceID = IDS_DEVICE_HANDLED;
    } else if (DeviceStatus == FPS_UNAVAILABLE) {
        ResourceID = IDS_DEVICE_UNAVAILABLE;
    } else if (DeviceStatus == FPS_BUSY) {
        ResourceID = IDS_DEVICE_BUSY;
    } else if (DeviceStatus == FPS_NO_ANSWER) {
        ResourceID = IDS_DEVICE_NOANSWER;
    } else if (DeviceStatus == FPS_BAD_ADDRESS) {
        ResourceID = IDS_DEVICE_BADADDRESS; 
    } else if (DeviceStatus == FPS_NO_DIAL_TONE) {
        ResourceID = IDS_DEVICE_NODIALTONE;
    } else if (DeviceStatus == FPS_DISCONNECTED) {
        ResourceID = IDS_DEVICE_DISCONNECTED;
    } else if (DeviceStatus == FPS_FATAL_ERROR) {
        ResourceID = IDS_DEVICE_FATALERROR;
    } else if (DeviceStatus == FPS_NOT_FAX_CALL) {
        ResourceID = IDS_DEVICE_NOTFAXCALL;
    } else if (DeviceStatus == FPS_CALL_DELAYED) {
        ResourceID = IDS_DEVICE_CALLDELAYED;
    } else if (DeviceStatus == FPS_CALL_BLACKLISTED) {
        ResourceID = IDS_DEVICE_BLACKLISTED;
    } else if (DeviceStatus == FPS_INITIALIZING) {
        ResourceID = IDS_DEVICE_INITIALIZING;
    } else if (DeviceStatus == FPS_OFFLINE) {
        ResourceID = IDS_DEVICE_OFFLINE;
    } else if (DeviceStatus == FPS_RINGING) {
        ResourceID = IDS_DEVICE_RINGING;
    } else if (DeviceStatus == FPS_AVAILABLE) {
        ResourceID = IDS_DEVICE_AVAILABLE;
    } else if (DeviceStatus == FPS_ABORTING) {
        ResourceID = IDS_DEVICE_ABORTING;
    } else if (DeviceStatus == FPS_ROUTING) {
        ResourceID = IDS_DEVICE_ROUTING;
    } else if (DeviceStatus == FPS_ANSWERED) {
        ResourceID = IDS_DEVICE_ANSWERED;
    } else {
        ResourceID = IDS_DEVICE_UNKNOWN;
    }


    LoadString(_Module.GetModuleInstance(),ResourceID,szDeviceStatus,100);

    return SysAllocString(szDeviceStatus);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\exchange\ext\config.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    config.cpp

Abstract:

    This module contains routines for the fax config dialog.

Author:

    Wesley Witt (wesw) 13-Aug-1996

Revision History:

    20/10/99 -danl-
        Fix ConfigDlgProc to view proper printer properties.

    dd/mm/yy -author-
        description

--*/
#include "faxext.h"
#include "faxutil.h"
#include "faxreg.h"
#include "resource.h"
#include "debugex.h"


extern HINSTANCE hInstance;


VOID
AddCoverPagesToList(
    HWND        hwndList,
    LPTSTR      pDirPath,
    BOOL        ServerCoverPage
    )

/*++

Routine Description:

    Add the cover page files in the specified directory to a listbox

Arguments:

    hwndList        - Handle to a list window
    pDirPath        - Directory to look for coverpage files
    ServerCoverPage - TRUE if the dir contains server cover pages

Return Value:

    NONE

--*/

{
    WIN32_FIND_DATA findData;
    TCHAR           tszDirName[MAX_PATH] = {0};
    TCHAR           CpName[MAX_PATH] = {0};
    HANDLE          hFindFile = INVALID_HANDLE_VALUE;
    TCHAR           tszFileName[MAX_PATH] = {0};
    TCHAR           tszPathName[MAX_PATH] = {0};
    TCHAR*          pPathEnd;
    LPTSTR          pExtension;
    INT             listIndex;
    INT             dirLen;
    INT             fileLen;
    INT             flags = 0;
    INT             Cnt = 2;
    DWORD           dwMask = 0;
    BOOL            bGotFile = FALSE;

    DBG_ENTER(TEXT("AddCoverPagesToList"));

    //
    // Copy the directory path to a local buffer
    //

    if (pDirPath == NULL || pDirPath[0] == 0) 
    {
        return;
    }

    if ((dirLen = _tcslen( pDirPath )) >= MAX_PATH - MAX_FILENAME_EXT - 1) 
    {
        return;
    }

    _tcscpy( tszDirName, pDirPath );

    TCHAR* pLast = NULL;
    pLast = _tcsrchr(tszDirName,TEXT('\\'));
    if( !( pLast && (*_tcsinc(pLast)) == '\0' ) )
    {
        // the last character is not a backslash, add one...
        _tcscat(tszDirName, TEXT("\\"));
        dirLen += sizeof(TCHAR);
    }

    _tcsncpy(tszPathName, tszDirName, sizeof(tszPathName)/sizeof(tszPathName[0]));
    pPathEnd = _tcschr(tszPathName, '\0');

    //
    // Go through the following loop twice:
    //  Once to add the files with .cov extension
    //  Again to add the files with .lnk extension
    //
    // Don't chase links for server based cover pages
    //
    TCHAR file_to_find[MAX_PATH] = {0};
    LPCTSTR _extension = NULL; 
        
    while( Cnt ) 
    {
        _tcscpy(file_to_find,tszDirName);
        //
        //*.lnk ext. is possible only for personal cp, other cp are with *.cov ext.
        //
        _extension = ((!ServerCoverPage) && (flags & CPFLAG_LINK)) 
                                ? FAX_LNK_FILE_MASK : FAX_COVER_PAGE_MASK;                      
        _tcscat(file_to_find, _extension );
        //
        // Call FindFirstFile/FindNextFile to enumerate the files
        // matching our specification
        //

        hFindFile = FindFirstFile( file_to_find, &findData );
        if (hFindFile == INVALID_HANDLE_VALUE)
        {
            CALL_FAIL(GENERAL_ERR, TEXT("FindFirstFile"), ::GetLastError());
            bGotFile = FALSE;
        }
        else
        {
            bGotFile = TRUE;
        }
        while (bGotFile) 
        {
            _tcsncpy(pPathEnd, findData.cFileName, MAX_PATH - dirLen);
            if(!IsValidCoverPage(tszPathName))
            {
                goto next;
            }                

            //
            // Exclude directories and hidden files
            //
            if (findData.dwFileAttributes & (FILE_ATTRIBUTE_HIDDEN|FILE_ATTRIBUTE_DIRECTORY)) 
            {
                continue;
            }

            //
            // Make sure we have enough room to store the full pathname
            //
            if ((fileLen = _tcslen( findData.cFileName)) <= MAX_FILENAME_EXT ) 
            {
                continue;
            }

            if (fileLen + dirLen >= MAX_PATH) 
            {
                continue;
            }

            //
            // If we're chasing links, make sure the link refers to
            // a cover page file.
            //

            if (!ServerCoverPage && (flags & CPFLAG_LINK)) 
            {
                _tcscpy(tszFileName, tszDirName);
                _tcscat( tszFileName, findData.cFileName );

                if (!IsCoverPageShortcut(tszFileName)) 
                {
                    continue;
                }
            }

            //
            // Add the cover page name to the list window, 
            // but don't display the filename extension
            //
            _tcscpy( CpName, findData.cFileName );
            
            if (pExtension = _tcsrchr(CpName,TEXT('.'))) 
            {
                *pExtension = NULL;
            }

            if ( ! ServerCoverPage )
            {
                TCHAR szPersonal[30];
                LoadString( hInstance, IDS_PERSONAL, szPersonal, 30 );
                _tcscat( CpName, TEXT(" "));
                _tcscat( CpName, szPersonal );
            }

            listIndex = (INT)SendMessage(
                        hwndList,
                        LB_ADDSTRING,
                        0,
                        (LPARAM) CpName
                        );

            if (listIndex != LB_ERR) 
            {
                dwMask = ServerCoverPage ? SERVER_COVER_PAGE : 0;
                if(!ServerCoverPage)
                {
                    dwMask |= (flags & CPFLAG_LINK) ?  SHORTCUT_COVER_PAGE : 0;
                }
                SendMessage( hwndList, LB_SETITEMDATA, listIndex, dwMask);
            }
next:     
            bGotFile = FindNextFile(hFindFile, &findData);
            if (! bGotFile)
            {
                VERBOSE(DBG_MSG, TEXT("FindNextFile"), ::GetLastError());
                break;
            }            
        }
        
        if(INVALID_HANDLE_VALUE != hFindFile)
        {
            FindClose(hFindFile);
        }

        flags ^= CPFLAG_LINK;
        Cnt -= 1;
        if (ServerCoverPage) 
        {
            break;
            //
            // no need to look again, server cp can only be *.cov, and we've delt with them already.
            //       
        }
    }
}


void EnableCoverPageList(HWND hDlg)
{
    DBG_ENTER(TEXT("EnableCoverPageList"));

    if (IsDlgButtonChecked( hDlg, IDC_USE_COVERPAGE ) == BST_CHECKED) 
    {
        EnableWindow( GetDlgItem( hDlg, IDC_COVERPAGE_LIST ), TRUE  );
        EnableWindow( GetDlgItem( hDlg, IDC_STATIC_COVERPAGE ), TRUE  );
    } 
    else 
    {
        EnableWindow( GetDlgItem( hDlg, IDC_COVERPAGE_LIST ), FALSE );
        EnableWindow( GetDlgItem( hDlg, IDC_STATIC_COVERPAGE ), FALSE );
    }
}


INT_PTR CALLBACK
ConfigDlgProc(
    HWND           hDlg,
    UINT           message,
    WPARAM         wParam,
    LPARAM         lParam
    )


/*++

Routine Description:

    Dialog procedure for the fax mail transport configuration

Arguments:

    hDlg        - Window handle for this dialog
    message     - Message number
    wParam      - Parameter #1
    lParam      - Parameter #2

Return Value:

    TRUE    - Message was handled
    FALSE   - Message was NOT handled

--*/

{
    static PFAXXP_CONFIG FaxConfig = NULL;
    static HWND hwndListPrn = NULL;
    static HWND hwndListCov = NULL;

    PPRINTER_INFO_2 PrinterInfo = NULL;
    DWORD   CountPrinters = 0;
    DWORD   dwSelectedItem = 0;
    DWORD   dwNewSelectedItem = 0;
    TCHAR   Buffer [256] = {0};
    TCHAR   CpDir[MAX_PATH] = {0};
    LPTSTR  p = NULL;
    HANDLE  hFax = NULL;
    DWORD   dwError = 0;
    DWORD   dwMask = 0;
    BOOL    bShortCutCp = FALSE;
    BOOL    bGotFaxPrinter = FALSE;
    BOOL    bIsCpLink = FALSE;

    DBG_ENTER(TEXT("ConfigDlgProc"));

    switch( message ) 
    {
        case WM_INITDIALOG:
            FaxConfig = (PFAXXP_CONFIG) lParam;

            hwndListPrn = GetDlgItem( hDlg, IDC_PRINTER_LIST );
            hwndListCov = GetDlgItem( hDlg, IDC_COVERPAGE_LIST );

            //
            // populate the printers combobox
            //
            PrinterInfo = (PPRINTER_INFO_2) MyEnumPrinters(NULL,
                                                           2,
                                                           &CountPrinters,
                                                           PRINTER_ENUM_LOCAL | PRINTER_ENUM_CONNECTIONS);
            if (NULL != PrinterInfo)
            {
                DWORD j = 0;
                for (DWORD i=0; i < CountPrinters; i++)
                {
                    if ((NULL != PrinterInfo[i].pDriverName) && 
			            (_tcscmp( PrinterInfo[i].pDriverName, FAX_DRIVER_NAME ) == 0)) 
                    {
                        //
                        //if the current printer is a fax printer, add it to the CB list
                        //
                        bGotFaxPrinter = TRUE;
                        SendMessage( hwndListPrn, CB_ADDSTRING, 0, (LPARAM) PrinterInfo[i].pPrinterName );

                        if ((NULL != FaxConfig->PrinterName)      && 
			                (NULL != PrinterInfo[i].pPrinterName) &&
			                (_tcscmp( PrinterInfo[i].pPrinterName, FaxConfig->PrinterName ) == 0))
                        {
                            //
                            //if it is also the default printer according to transport config.
                            //place the default selection on it
                            //
                            dwSelectedItem = j;
                        }

                        if(FaxConfig->PrinterName == NULL || _tcslen(FaxConfig->PrinterName) == 0)
                        {
                            //
                            // There is no default fax printer
                            // Choose the first one
                            //
                            MemFree(FaxConfig->PrinterName);
                            FaxConfig->PrinterName = StringDup(PrinterInfo[i].pPrinterName);
                            if(FaxConfig->PrinterName == NULL)
                            {
                                CALL_FAIL(MEM_ERR, TEXT("StringDup"), ERROR_NOT_ENOUGH_MEMORY);
                                ErrorMsgBox(hInstance, hDlg, IDS_NOT_ENOUGH_MEMORY);
                                EndDialog( hDlg, IDABORT);
                                return FALSE;
                            }

                            if(PrinterInfo[i].pServerName)
                            {
                                MemFree(FaxConfig->ServerName);
                                FaxConfig->ServerName = StringDup(PrinterInfo[i].pServerName);
                                if(FaxConfig->ServerName == NULL)
                                {
                                    CALL_FAIL(MEM_ERR, TEXT("StringDup"), ERROR_NOT_ENOUGH_MEMORY);
                                    ErrorMsgBox(hInstance, hDlg, IDS_NOT_ENOUGH_MEMORY);
                                    EndDialog( hDlg, IDABORT);
                                    return FALSE;
                                }
                            }

                            dwSelectedItem = j;
                        }

                        j += 1;
                    } // if fax printer
                } // for

                MemFree( PrinterInfo );
                PrinterInfo = NULL;
                SendMessage( hwndListPrn, CB_SETCURSEL, (WPARAM)dwSelectedItem, 0 );
            }
            if (! bGotFaxPrinter)
            {
                //
                //  there were no printers at all, or non of the printers is a fax printer.
                //
                CALL_FAIL(GENERAL_ERR, TEXT("MyEnumPrinters"), ::GetLastError());
                ErrorMsgBox(hInstance, hDlg, IDS_NO_FAX_PRINTER);

                EndDialog( hDlg, IDABORT);
                break;
            }


            //            
            // Get the Server CP flag and receipts options
            //
            FaxConfig->ServerCpOnly = FALSE;
            if (FaxConnectFaxServer(FaxConfig->ServerName, &hFax) )
            {
                DWORD dwReceiptOptions;
                BOOL  bEnableReceiptsCheckboxes = FALSE;

                if(!FaxGetPersonalCoverPagesOption(hFax, &FaxConfig->ServerCpOnly))
                {
                    CALL_FAIL(GENERAL_ERR, TEXT("FaxGetPersonalCoverPagesOption"), ::GetLastError());
                    ErrorMsgBox(hInstance, hDlg, IDS_CANT_ACCESS_SERVER);
                }
                else
                {
                    //
                    // Inverse logic
                    //
                    FaxConfig->ServerCpOnly = !FaxConfig->ServerCpOnly;
                }
                if (!FaxGetReceiptsOptions (hFax, &dwReceiptOptions))
                {
                    CALL_FAIL(GENERAL_ERR, TEXT("FaxGetPersonalCoverPagesOption"), GetLastError());
                }
                else
                {
                    if (DRT_EMAIL & dwReceiptOptions)
                    {
                        //
                        // Server supports receipts by email - enable the checkboxes
                        //
                        bEnableReceiptsCheckboxes = TRUE;
                    }
                }
                EnableWindow( GetDlgItem( hDlg, IDC_ATTACH_FAX),          bEnableReceiptsCheckboxes);
                EnableWindow( GetDlgItem( hDlg, IDC_SEND_SINGLE_RECEIPT), bEnableReceiptsCheckboxes);

                FaxClose(hFax);
                hFax = NULL;
            }
            else
            {
                CALL_FAIL(GENERAL_ERR, TEXT("FaxConnectFaxServer"), ::GetLastError())
                ErrorMsgBox(hInstance, hDlg, IDS_CANT_ACCESS_SERVER);
            }

            //
            //send single receipt for a fax sent to multiple recipients?
            //
            if(FaxConfig->SendSingleReceipt)
            {
                CheckDlgButton( hDlg, IDC_SEND_SINGLE_RECEIPT, BST_CHECKED );
            }

            if (FaxConfig->bAttachFax)
            {
                CheckDlgButton( hDlg, IDC_ATTACH_FAX, BST_CHECKED );
            }

            //
            // cover page CB & LB enabling
            //
            if (FaxConfig->UseCoverPage)
            {
                CheckDlgButton( hDlg, IDC_USE_COVERPAGE, BST_CHECKED );
            }
            EnableCoverPageList(hDlg);

            //
            // Emulate printer's selection change, in order to collect printer config info.
            // including cover pages LB population
            //
            ConfigDlgProc(hDlg, WM_COMMAND,MAKEWPARAM(IDC_PRINTER_LIST,CBN_SELCHANGE),(LPARAM)0);
            break;

        case WM_COMMAND:
            if (HIWORD(wParam) == BN_CLICKED)
            {
                if (LOWORD(wParam) == IDC_USE_COVERPAGE)
                {
                    EnableCoverPageList(hDlg);
                    return FALSE;
                }
            }

            if (HIWORD(wParam) == CBN_SELCHANGE && LOWORD(wParam) == IDC_PRINTER_LIST)
            {
                //
                // refresh cover pages list
                //
                TCHAR SelectedPrinter[50];

                //
                //  a new fax printer was selected - delete all old coverpages from the list
                //  because they might include the old fax server's cover pages
                //
                SendMessage(hwndListCov, LB_RESETCONTENT, 0, 0);

                if (CB_ERR != (dwSelectedItem =(DWORD)SendMessage( hwndListPrn, CB_GETCURSEL, 0, 0)))
                //
                // get the 0 based index of the currently pointed printer
                //
                {
                    if (CB_ERR != SendMessage( hwndListPrn, CB_GETLBTEXT, dwSelectedItem, (LPARAM) SelectedPrinter ))
                    //
                    // get that printer's name into SelectedPrinter
                    //
                    {
                        if(NULL != (PrinterInfo = (PPRINTER_INFO_2) MyGetPrinter( SelectedPrinter, 2 )))
                        {
                            LPTSTR lptszServerName = NULL;
                            if (GetServerNameFromPrinterInfo(PrinterInfo,&lptszServerName))
                            {
                                if (GetServerCpDir( lptszServerName, CpDir, sizeof(CpDir)/sizeof(CpDir[0]) ))
                                {
                                    AddCoverPagesToList( hwndListCov, CpDir, TRUE );
                                }
                                if ((NULL == FaxConfig->ServerName) || (NULL == lptszServerName) ||
                                    (_tcscmp(FaxConfig->ServerName,lptszServerName) != 0) )
                                {
                                    //
                                    // the server's name and config are not updated - refresh them
                                    //
                                    MemFree(FaxConfig->ServerName);
                                    FaxConfig->ServerName = lptszServerName;

                                    FaxConfig->ServerCpOnly = FALSE;
                                    if (FaxConnectFaxServer(FaxConfig->ServerName,&hFax) )
                                    {
                                        DWORD dwReceiptOptions;
                                        BOOL  bEnableReceiptsCheckboxes = FALSE;
                                        //
                                        // Get the new server's ServerCpOnly flag
                                        //
                                        if (!FaxGetPersonalCoverPagesOption(hFax,&FaxConfig->ServerCpOnly))
                                        {
                                            CALL_FAIL(GENERAL_ERR, TEXT("FaxGetPersonalCoverPagesOption"), GetLastError());
                                        }
                                        else
                                        {
                                            //
                                            // Inverse logic
                                            //
                                            FaxConfig->ServerCpOnly = !FaxConfig->ServerCpOnly;
                                        }
                                        if (!FaxGetReceiptsOptions (hFax, &dwReceiptOptions))
                                        {
                                            CALL_FAIL(GENERAL_ERR, TEXT("FaxGetPersonalCoverPagesOption"), GetLastError());
                                        }
                                        else
                                        {
                                            if (DRT_EMAIL & dwReceiptOptions)
                                            {
                                                //
                                                // Server supports receipts by email - enable the checkboxes
                                                //
                                                bEnableReceiptsCheckboxes = TRUE;
                                            }
                                        }
                                        EnableWindow( GetDlgItem( hDlg, IDC_ATTACH_FAX),          bEnableReceiptsCheckboxes);
                                        EnableWindow( GetDlgItem( hDlg, IDC_SEND_SINGLE_RECEIPT), bEnableReceiptsCheckboxes);

                                        FaxClose(hFax);
                                        hFax = NULL;
                                    }
                                }
                                else
                                //
                                // the server's name hasn't changed, all details are OK
                                //
                                {
                                    MemFree(lptszServerName);
                                    lptszServerName = NULL;
                                }
                            }
                            else
                            //
                            // GetServerNameFromPrinterInfo failed
                            //
                            {
                                FaxConfig->ServerCpOnly = FALSE;
                            }

                            //
                            // don't add client coverpages if FaxConfig->ServerCpOnly is set to true
                            //
                            if (!FaxConfig->ServerCpOnly)
                            {
                                if(GetClientCpDir( CpDir, sizeof(CpDir) / sizeof(CpDir[0])))
                                {
                                //
                                // if the function failes- the ext. is installed on a machine 
                                // that doesn't have a client on it, 
                                // so we shouldn't look for personal cp
                                //                                
                                    AddCoverPagesToList( hwndListCov, CpDir, FALSE );
                                }
                            }
                            MemFree(PrinterInfo);
                            PrinterInfo = NULL;

                            //
                            // check if we have any cp in the LB, if not-  don't allow the user to 
                            // ask for a cp with he's fax
                            //
                            DWORD dwItemCount = (DWORD)SendMessage(hwndListCov, LB_GETCOUNT, NULL, NULL);
                            if(LB_ERR == dwItemCount)
                            {
                                CALL_FAIL(GENERAL_ERR, TEXT("SendMessage (LB_GETCOUNT)"), ::GetLastError());
                            }
                            else
                            {
                                EnableWindow( GetDlgItem( hDlg, IDC_USE_COVERPAGE ), dwItemCount ? TRUE : FALSE );
                            }

                            if (FaxConfig->CoverPageName)
                            {
                                _tcscpy( Buffer, FaxConfig->CoverPageName );
                            }
                            if ( ! FaxConfig->ServerCoverPage )
                            {
                                TCHAR szPersonal[30] = _T("");
                                LoadString( hInstance, IDS_PERSONAL, szPersonal, 30 );
                                _tcscat( Buffer, _T(" ") );
                                _tcscat( Buffer, szPersonal );
                             }

                            dwSelectedItem = (DWORD)SendMessage( hwndListCov, LB_FINDSTRING, -1, (LPARAM) Buffer );
                            //
                            // get the index of the default CP
                            // if it is supposed to be a link, and the cp that we found is not a link, 
                            // find the next string that matches.
                            // this can happen if there's al ink to a cp named X, and a regular cp named X.
                            //
                            if (dwSelectedItem == LB_ERR) 
                            {
                                dwSelectedItem = 0;
                            }
                            else
                            {
                                dwMask = (DWORD)SendMessage( hwndListCov, LB_GETITEMDATA, dwSelectedItem, 0 );
                                if (dwMask != LB_ERR)
                                {
                                    bIsCpLink = (dwMask & SHORTCUT_COVER_PAGE) == SHORTCUT_COVER_PAGE;
                                    if (bIsCpLink != FaxConfig->LinkCoverPage)
                                    {
                                        //
                                        // we got the wrong cp, search for next compatible string
                                        // starting with the one apearing after the current one
                                        //
                                        dwNewSelectedItem = (DWORD)SendMessage( hwndListCov, LB_FINDSTRING, dwSelectedItem, (LPARAM) Buffer );
                                        if(dwNewSelectedItem == dwSelectedItem)
                                        {
                                            // if there's no other string that's compatible, 
                                            // the searcing will start from the begining of 
                                            // the list again, and will find the same (wrong) 
                                            // string again. 
                                            // so, if it's we got the same index, again, 
                                            // selection on 0 (as we do if we didn't find 
                                            // the chosen cp...)
                                            //
                                            dwSelectedItem = 0;
                                        }
                                        else
                                        {
                                            dwSelectedItem = dwNewSelectedItem;
                                        }
                                    }
                                }                                    

                            }

                            SendMessage( hwndListCov, LB_SETCURSEL, (WPARAM) dwSelectedItem, 0 );
                            //
                            // place the default selection on that CP
                            //

                        }
                    }
                }
                break;
            }

            switch (wParam) 
            {
                case IDOK :

                    //
                    // Update UseCoverPage
                    //
                    FaxConfig->UseCoverPage = (IsDlgButtonChecked( hDlg, IDC_USE_COVERPAGE ) == BST_CHECKED);

                    //
                    //  Update SendSingleReceipt
                    //
                    FaxConfig->SendSingleReceipt = (IsDlgButtonChecked(hDlg, IDC_SEND_SINGLE_RECEIPT) == BST_CHECKED);

                    FaxConfig->bAttachFax = (IsDlgButtonChecked(hDlg, IDC_ATTACH_FAX) == BST_CHECKED);

                    //
                    // Update selected printer
                    //
                    dwSelectedItem = (DWORD)SendMessage( hwndListPrn, CB_GETCURSEL, 0, 0 );
                    if (dwSelectedItem != LB_ERR)
                    {
                        if (LB_ERR != SendMessage( hwndListPrn, CB_GETLBTEXT, dwSelectedItem, (LPARAM) Buffer ))/***/
                        {
                            MemFree( FaxConfig->PrinterName );
                            FaxConfig->PrinterName = StringDup( Buffer );
                            if(!FaxConfig->PrinterName)
                            {
                                CALL_FAIL(MEM_ERR, TEXT("StringDup"), ERROR_NOT_ENOUGH_MEMORY);
                                ErrorMsgBox(hInstance, hDlg, IDS_NOT_ENOUGH_MEMORY);
                                EndDialog( hDlg, IDABORT);
                                return FALSE;
                            }
                        }
                    }
                    
                    //
                    // Update cover page
                    //
                    dwSelectedItem = (DWORD)SendMessage( hwndListCov, LB_GETCURSEL, 0, 0 );
                    if (dwSelectedItem != LB_ERR)// LB_ERR when no items in list
                    {
                        if (LB_ERR != SendMessage( hwndListCov, LB_GETTEXT, dwSelectedItem, (LPARAM) Buffer ))
                        //
                        // get the selected CP name into the buffer
                        //
                        {
                            dwMask = (DWORD)SendMessage( hwndListCov, LB_GETITEMDATA, dwSelectedItem, 0 );
                            if (dwMask != LB_ERR)
                            {
                                FaxConfig->ServerCoverPage = (dwMask & SERVER_COVER_PAGE) == SERVER_COVER_PAGE;
                                if (!FaxConfig->ServerCoverPage)
                                {
                                    //
                                    // if the selected CP in the LB is not a server's CP
                                    // Omit the suffix: "(personal)"
                                    //
                                    p = _tcsrchr( Buffer, '(' );
                                    Assert(p);
                                    if( p )
                                    {
                                        p = _tcsdec(Buffer,p);
                                        if( p )
                                        {
                                            _tcsnset(p,TEXT('\0'),1);
                                        }
                                    }
                                    //
                                    // add the corect ext. to the cp file name
                                    //
                                    FaxConfig->LinkCoverPage = ((dwMask & SHORTCUT_COVER_PAGE) == SHORTCUT_COVER_PAGE)? TRUE : FALSE ;                                
								}
                                else
                                {
                                     FaxConfig->LinkCoverPage = FALSE;
                                }
                            }
                            //
                            // update CP name to the selected one in the LB
                            //
                            MemFree( FaxConfig->CoverPageName );
                            FaxConfig->CoverPageName = StringDup( Buffer );
                            if(!FaxConfig->CoverPageName)
                            {
                                CALL_FAIL(MEM_ERR, TEXT("StringDup"), ERROR_NOT_ENOUGH_MEMORY);
                                ErrorMsgBox(hInstance, hDlg, IDS_NOT_ENOUGH_MEMORY);
                                EndDialog( hDlg, IDABORT);
                                return FALSE;
                            }
                        }            
                    }
                    EndDialog( hDlg, IDOK );
                    break;

                case IDCANCEL:
                    EndDialog( hDlg, IDCANCEL );
                    break;
                }
                break;

        case WM_HELP:
            WinHelpContextPopup(((LPHELPINFO)lParam)->dwContextId, hDlg);
            return TRUE;

        case WM_CONTEXTMENU:
            WinHelpContextPopup(GetWindowContextHelpId((HWND)wParam), hDlg);            
            return TRUE;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\com\win2k\winfax.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    winfax.cpp

Abstract:

    This file implements a pseudo winfax interface.
    The COM interfaces call winfax using the regular
    winfax.h header file and include the cpp file
    as part of the build.  This module provides winfax
    interfaces that talk to the fax server through
    http/ftp via isapi instead of the coventional rpc
    methods.  This allows the COM interfaces to work
    on the internet and across a proxy too.

    If you add any winfax interfaces to this file you
    must be sure to correctly update the faxisapi.h
    header file and add the corresponding function
    in the faxisapi dll.

Author:

    Wesley Witt (wesw) 1-June-1997

Environment:

    User Mode

--*/

#include <windows.h>
#include <wininet.h>
#include <stdio.h>
#include <tchar.h>

#include "faxutil.h"
#include "winfax.h"
#include "faxisapi.h"


#define FixupStringIn(_s,_buf)  if ((_s)) { (_s) = (LPWSTR) ((DWORD)(_s) + (DWORD)(_buf)); }


HINTERNET hInternet;
HINTERNET hConnection;
HANDLE    hHeap;


VOID
StoreString(
    LPWSTR String,
    LPDWORD DestString,
    LPBYTE Buffer,
    LPDWORD Offset
    )
{
    if (String) {
        wcscpy( (LPWSTR) (Buffer+*Offset), String );
        *DestString = *Offset;
        *Offset += StringSize( String );
    } else {
        *DestString = 0;
    }
}


DWORD
PortInfoSize(
    PFAX_PORT_INFOW PortInfo
    )
{
    DWORD Size = sizeof(FAX_PORT_INFOW);

    Size += StringSize( PortInfo->DeviceName );
    Size += StringSize( PortInfo->Tsid );
    Size += StringSize( PortInfo->Csid );

    return Size;
}


VOID
Flush(
    HINTERNET hSession
    )
{
    BOOL Rslt;
    DWORD Size;
    LPBYTE Buffer[32];


    do {
        Size = sizeof(Buffer);
        Rslt = InternetReadFile( hSession, Buffer, Size, &Size );
    } while( Rslt && Size );
}


BOOL
GetResponse(
    HINTERNET hSession,
    LPBYTE Buffer,
    DWORD BufferSize
    )
{
    BOOL Rslt;
    DWORD Size;
    IFAX_RESPONSE_HEADER Response;


    Rslt = InternetReadFile(
        hSession,
        (LPVOID) &Response,
        sizeof(IFAX_RESPONSE_HEADER),
        &Size
        );
    if (!Rslt) {
        return FALSE;
    }

    if (Response.ErrorCode) {
        SetLastError( Response.ErrorCode );
        return FALSE;
    }

    if (Response.Size) {
        Rslt = InternetReadFile(
            hSession,
            Buffer,
            min( BufferSize, Response.Size - sizeof(IFAX_RESPONSE_HEADER)),
            &Size
            );
        if (!Rslt) {
            return FALSE;
        }
    }

    return TRUE;
}


BOOL
GetResponseAlloc(
    HINTERNET hSession,
    LPBYTE *Buffer
    )
{
    BOOL Rslt;
    DWORD Size;
    IFAX_RESPONSE_HEADER Response;


    Rslt = InternetReadFile(
        hSession,
        (LPVOID) &Response,
        sizeof(IFAX_RESPONSE_HEADER),
        &Size
        );
    if (!Rslt) {
        return FALSE;
    }

    if (Response.ErrorCode) {
        SetLastError( Response.ErrorCode );
        return FALSE;
    }

    *Buffer = (LPBYTE) MemAlloc( Response.Size );
    if (*Buffer == NULL) {
        return FALSE;
    }

    Rslt = InternetReadFile(
        hSession,
        *Buffer,
        Response.Size - sizeof(IFAX_RESPONSE_HEADER),
        &Size
        );
    if (!Rslt) {
        MemFree( *Buffer );
        return FALSE;
    }

    return TRUE;
}


HINTERNET
OpenRequest(
    VOID
    )
{
    HINTERNET hSession = HttpOpenRequestA(
        hConnection,
        "GET",
        "/scripts/faxisapi.dll",
        "HTTP/1.0",
        "",
        NULL,
        INTERNET_FLAG_RELOAD | INTERNET_FLAG_NO_CACHE_WRITE,
        0
        );
    if (!hSession) {
        return NULL;
    }

    return hSession;
}


BOOL
SendRequest(
    HINTERNET hSession,
    LPVOID Buffer,
    DWORD BufferSize
    )
{
    BOOL Rslt = HttpSendRequestA(
        hSession,
        NULL,
        0,
        Buffer,
        BufferSize
        );
    if (!Rslt) {
        return FALSE;
    }

    DWORD Code, Size;
    Size = sizeof(DWORD);
    if (!HttpQueryInfoA( hSession, HTTP_QUERY_STATUS_CODE | HTTP_QUERY_FLAG_NUMBER, &Code, &Size, NULL )) {
        return FALSE;
    }

    if (Code != HTTP_STATUS_OK) {
        return FALSE;
    }

    return TRUE;
}


extern "C"
VOID
WINAPI
FaxFreeBuffer(
    LPVOID Buffer
    )
{
    MemFree( Buffer );
}


extern "C"
BOOL
WINAPI
FaxClose(
    IN HANDLE FaxHandle
    )
{
    HINTERNET hSession = OpenRequest();
    if (!hSession) {
        return FALSE;
    }

    IFAX_GENERAL iFaxGeneral;

    iFaxGeneral.Command = ICMD_CLOSE;
    iFaxGeneral.FaxHandle = FaxHandle;

    BOOL Rslt = SendRequest( hSession, (LPVOID) &iFaxGeneral, sizeof(IFAX_GENERAL) );
    if (!Rslt) {
        InternetCloseHandle( hSession );
        return FALSE;
    }

    Rslt = GetResponse( hSession, NULL, 0 );

    Flush( hSession );
    InternetCloseHandle( hSession );

    return Rslt;
}


extern "C"
BOOL
WINAPI
FaxConnectFaxServerW(
    IN  LPWSTR MachineName OPTIONAL,
    OUT LPHANDLE FaxHandle
    )
{
    CHAR MachineNameA[64];


    if (hInternet) {
        InternetCloseHandle( hInternet );
    }

    if (hConnection) {
        InternetCloseHandle( hConnection );
    }

    WideCharToMultiByte(
        CP_ACP,
        0,
        MachineName,
        -1,
        MachineNameA,
        sizeof(MachineNameA),
        NULL,
        NULL
        );

    hInternet = InternetOpenA(
        "FaxCom",
        INTERNET_OPEN_TYPE_PRECONFIG,
        NULL,
        NULL,
        0
        );
    if (!hInternet) {
        return FALSE;
    }

    hConnection = InternetConnectA(
        hInternet,
        MachineNameA,
        INTERNET_DEFAULT_HTTP_PORT,
        NULL,
        NULL,
        INTERNET_SERVICE_HTTP,
        0,
        0
        );
    if (!hConnection) {
        return FALSE;
    }

    HINTERNET hSession = OpenRequest();
    if (!hSession) {
        return FALSE;
    }

    IFAX_CONNECT iFaxConnect;

    iFaxConnect.Command = ICMD_CONNECT;
    wcscpy( iFaxConnect.ServerName, MachineName );

    BOOL Rslt = SendRequest( hSession, (LPVOID) &iFaxConnect, sizeof(IFAX_CONNECT) );
    if (!Rslt) {
        InternetCloseHandle( hSession );
        return FALSE;
    }

    DWORD Code, Size;
    HttpQueryInfo( hSession, HTTP_QUERY_STATUS_CODE | HTTP_QUERY_FLAG_NUMBER, &Code, &Size, NULL );

    Rslt = GetResponse( hSession, (LPBYTE)FaxHandle, sizeof(HANDLE) );

    Flush( hSession );
    InternetCloseHandle( hSession );

    return Rslt;
}


extern "C"
BOOL
WINAPI
FaxEnumPortsW(
    IN  HANDLE FaxHandle,
    OUT LPBYTE *PortInfoBuffer,
    OUT LPDWORD PortsReturned
    )
{
    HINTERNET hSession = OpenRequest();
    if (!hSession) {
        return FALSE;
    }

    IFAX_GENERAL iFaxGeneral;

    iFaxGeneral.Command = ICMD_ENUM_PORTS;
    iFaxGeneral.FaxHandle = FaxHandle;

    BOOL Rslt = SendRequest( hSession, (LPVOID) &iFaxGeneral, sizeof(IFAX_GENERAL) );
    if (!Rslt) {
        InternetCloseHandle( hSession );
        return FALSE;
    }

    Rslt = GetResponse( hSession, (LPBYTE)PortsReturned, sizeof(DWORD) );
    if (Rslt) {
        Rslt = GetResponseAlloc( hSession, PortInfoBuffer );
    }

    if (Rslt) {
        PFAX_PORT_INFOW PortInfo = (PFAX_PORT_INFOW) *PortInfoBuffer;

        for (DWORD i=0; i<*PortsReturned; i++) {
            FixupStringIn( PortInfo[i].DeviceName, PortInfo );
            FixupStringIn( PortInfo[i].Tsid, PortInfo );
            FixupStringIn( PortInfo[i].Csid, PortInfo );
        }
    }

    Flush( hSession );
    InternetCloseHandle( hSession );

    return Rslt;
}


extern "C"
BOOL
WINAPI
FaxOpenPort(
    IN  HANDLE FaxHandle,
    IN  DWORD DeviceId,
    IN  DWORD Flags,
    OUT LPHANDLE FaxPortHandle
    )
{
    HINTERNET hSession = OpenRequest();
    if (!hSession) {
        return FALSE;
    }

    IFAX_OPEN_PORT iFaxOpenPort;

    iFaxOpenPort.Command    = ICMD_OPEN_PORT;
    iFaxOpenPort.FaxHandle  = FaxHandle;
    iFaxOpenPort.DeviceId   = DeviceId;
    iFaxOpenPort.Flags      = Flags;

    BOOL Rslt = SendRequest( hSession, (LPVOID) &iFaxOpenPort, sizeof(IFAX_OPEN_PORT) );
    if (!Rslt) {
        InternetCloseHandle( hSession );
        return FALSE;
    }

    Rslt = GetResponse( hSession, (LPBYTE)FaxPortHandle, sizeof(HANDLE) );

    Flush( hSession );
    InternetCloseHandle( hSession );

    return Rslt;
}


extern "C"
BOOL
WINAPI
FaxGetPortW(
    IN  HANDLE FaxPortHandle,
    OUT LPBYTE *PortInfoBuffer
    )
{
    HINTERNET hSession = OpenRequest();
    if (!hSession) {
        return FALSE;
    }

    IFAX_GENERAL iFaxGeneral;

    iFaxGeneral.Command = ICMD_GET_PORT;
    iFaxGeneral.FaxHandle = FaxPortHandle;

    BOOL Rslt = SendRequest( hSession, (LPVOID) &iFaxGeneral, sizeof(IFAX_GENERAL) );
    if (!Rslt) {
        InternetCloseHandle( hSession );
        return FALSE;
    }

    Rslt = GetResponseAlloc( hSession, PortInfoBuffer );

    if (Rslt) {
        PFAX_PORT_INFOW PortInfo = (PFAX_PORT_INFOW) *PortInfoBuffer;
        FixupStringIn( PortInfo->DeviceName, PortInfo );
        FixupStringIn( PortInfo->Tsid, PortInfo );
        FixupStringIn( PortInfo->Csid, PortInfo );
    }

    Flush( hSession );
    InternetCloseHandle( hSession );

    return Rslt;
}


extern "C"
BOOL
WINAPI
FaxSetPortW(
    IN  HANDLE FaxPortHandle,
    IN  LPBYTE PortInfoBuffer
    )
{
    PFAX_PORT_INFOW PortInfo = (PFAX_PORT_INFOW) PortInfoBuffer;

    HINTERNET hSession = OpenRequest();
    if (!hSession) {
        return FALSE;
    }

    DWORD Size = sizeof(IFAX_SET_PORT) + PortInfoSize( PortInfo );
    DWORD Offset = sizeof(IFAX_SET_PORT);

    PIFAX_SET_PORT iFaxSetPort = (PIFAX_SET_PORT) MemAlloc( Size );
    if (!iFaxSetPort) {
        return FALSE;
    }

    iFaxSetPort->Command                 = ICMD_SET_PORT;
    iFaxSetPort->FaxPortHandle           = FaxPortHandle;
    iFaxSetPort->PortInfo.SizeOfStruct   = PortInfo->SizeOfStruct;
    iFaxSetPort->PortInfo.DeviceId       = PortInfo->DeviceId;
    iFaxSetPort->PortInfo.State          = PortInfo->State;
    iFaxSetPort->PortInfo.Flags          = PortInfo->Flags;
    iFaxSetPort->PortInfo.Rings          = PortInfo->Rings;
    iFaxSetPort->PortInfo.Priority       = PortInfo->Priority;

    StoreString( PortInfo->DeviceName, (LPDWORD)iFaxSetPort->PortInfo.DeviceName, (LPBYTE)iFaxSetPort, &Offset );
    StoreString( PortInfo->Csid, (LPDWORD)iFaxSetPort->PortInfo.Csid, (LPBYTE)iFaxSetPort, &Offset );
    StoreString( PortInfo->Tsid, (LPDWORD)iFaxSetPort->PortInfo.Tsid, (LPBYTE)iFaxSetPort, &Offset );

    BOOL Rslt = SendRequest( hSession, (LPVOID) iFaxSetPort, Size );

    MemFree( iFaxSetPort );

    if (!Rslt) {
        InternetCloseHandle( hSession );
        return FALSE;
    }

    Rslt = GetResponse( hSession, NULL, 0 );

    Flush( hSession );
    InternetCloseHandle( hSession );

    return Rslt;
}


extern "C"
BOOL
WINAPI
FaxGetRoutingInfoW(
    IN  HANDLE FaxPortHandle,
    IN  LPWSTR RoutingGuid,
    OUT LPBYTE *RoutingInfoBuffer,
    OUT LPDWORD RoutingInfoBufferSize
    )
{
    HINTERNET hSession = OpenRequest();
    if (!hSession) {
        return FALSE;
    }

    IFAX_GET_ROUTINGINFO iFaxGetRoutingInfo;

    iFaxGetRoutingInfo.Command = ICMD_GET_ROUTINGINFO;
    iFaxGetRoutingInfo.FaxPortHandle = FaxPortHandle;
    wcsncpy( iFaxGetRoutingInfo.RoutingGuid, RoutingGuid, MAX_GUID_STRING_LEN );

    BOOL Rslt = SendRequest( hSession, (LPVOID) &iFaxGetRoutingInfo, sizeof(IFAX_GET_ROUTINGINFO) );
    if (!Rslt) {
        InternetCloseHandle( hSession );
        return FALSE;
    }

    Rslt = GetResponse( hSession, (LPBYTE)RoutingInfoBufferSize, sizeof(DWORD) );
    if (Rslt) {
        Rslt = GetResponseAlloc( hSession, RoutingInfoBuffer );
    }

    Flush( hSession );
    InternetCloseHandle( hSession );

    return Rslt;
    return TRUE;
}


extern "C"
BOOL
WINAPI
FaxGetDeviceStatusW(
    IN  HANDLE FaxPortHandle,
    OUT LPBYTE *StatusBuffer
    )
{
    HINTERNET hSession = OpenRequest();
    if (!hSession) {
        return FALSE;
    }

    IFAX_GENERAL iFaxGeneral;

    iFaxGeneral.Command = ICMD_GET_DEVICE_STATUS;
    iFaxGeneral.FaxHandle = FaxPortHandle;

    BOOL Rslt = SendRequest( hSession, (LPVOID) &iFaxGeneral, sizeof(IFAX_GENERAL) );
    if (!Rslt) {
        InternetCloseHandle( hSession );
        return FALSE;
    }

    Rslt = GetResponseAlloc( hSession, StatusBuffer );

    PFAX_DEVICE_STATUSW DeviceStatus = (PFAX_DEVICE_STATUSW) *StatusBuffer;

    FixupStringIn( DeviceStatus->CallerId, DeviceStatus );
    FixupStringIn( DeviceStatus->Csid, DeviceStatus );
    FixupStringIn( DeviceStatus->DeviceName, DeviceStatus );
    FixupStringIn( DeviceStatus->DocumentName, DeviceStatus );
    FixupStringIn( DeviceStatus->PhoneNumber, DeviceStatus );
    FixupStringIn( DeviceStatus->RoutingString, DeviceStatus );
    FixupStringIn( DeviceStatus->SenderName, DeviceStatus );
    FixupStringIn( DeviceStatus->RecipientName, DeviceStatus );
    FixupStringIn( DeviceStatus->StatusString, DeviceStatus );
    FixupStringIn( DeviceStatus->Tsid, DeviceStatus );

    Flush( hSession );
    InternetCloseHandle( hSession );

    return Rslt;
}


extern "C"
BOOL
WINAPI
FaxEnumRoutingMethodsW(
    IN  HANDLE FaxPortHandle,
    OUT LPBYTE *RoutingInfoBuffer,
    OUT LPDWORD MethodsReturned
    )
{
    HINTERNET hSession = OpenRequest();
    if (!hSession) {
        return FALSE;
    }

    IFAX_GENERAL iFaxGeneral;

    iFaxGeneral.Command = ICMD_ENUM_ROUTING_METHODS;
    iFaxGeneral.FaxHandle = FaxPortHandle;

    BOOL Rslt = SendRequest( hSession, (LPVOID) &iFaxGeneral, sizeof(IFAX_GENERAL) );
    if (!Rslt) {
        InternetCloseHandle( hSession );
        return FALSE;
    }

    Rslt = GetResponse( hSession, (LPBYTE)MethodsReturned, sizeof(DWORD) );
    if (Rslt) {
        Rslt = GetResponseAlloc( hSession, RoutingInfoBuffer );
    }

    if (Rslt) {
        PFAX_ROUTING_METHODW RoutingMethod = (PFAX_ROUTING_METHODW) *RoutingInfoBuffer;
        for (DWORD i=0; i<*MethodsReturned; i++) {
            FixupStringIn( RoutingMethod[i].DeviceName, RoutingMethod );
            FixupStringIn( RoutingMethod[i].Guid, RoutingMethod );
            FixupStringIn( RoutingMethod[i].FriendlyName, RoutingMethod );
            FixupStringIn( RoutingMethod[i].FunctionName, RoutingMethod );
            FixupStringIn( RoutingMethod[i].ExtensionImageName, RoutingMethod );
            FixupStringIn( RoutingMethod[i].ExtensionFriendlyName, RoutingMethod );
        }
    }

    Flush( hSession );
    InternetCloseHandle( hSession );

    return Rslt;
}


extern "C"
BOOL
WINAPI
FaxEnableRoutingMethodW(
    IN  HANDLE FaxPortHandle,
    IN  LPWSTR RoutingGuid,
    IN  BOOL Enabled
    )
{
    HINTERNET hSession = OpenRequest();
    if (!hSession) {
        return FALSE;
    }

    IFAX_ENABLE_ROUTING_METHOD iFaxEnableRouting;

    iFaxEnableRouting.Command = ICMD_ENABLE_ROUTING_METHOD;
    iFaxEnableRouting.FaxPortHandle = FaxPortHandle;
    iFaxEnableRouting.Enabled = Enabled;

    wcsncpy( iFaxEnableRouting.RoutingGuid, RoutingGuid, MAX_GUID_STRING_LEN );

    BOOL Rslt = SendRequest( hSession, (LPVOID) &iFaxEnableRouting, sizeof(IFAX_ENABLE_ROUTING_METHOD) );
    if (!Rslt) {
        InternetCloseHandle( hSession );
        return FALSE;
    }

    Rslt = GetResponse( hSession, NULL, 0 );

    Flush( hSession );
    InternetCloseHandle( hSession );

    return Rslt;
}


extern "C"
BOOL
WINAPI
FaxGetVersion(
    IN  HANDLE FaxHandle,
    OUT LPDWORD Version
    )
{
    HINTERNET hSession = OpenRequest();
    if (!hSession) {
        return FALSE;
    }

    IFAX_GENERAL iFaxGeneral;

    iFaxGeneral.Command = ICMD_GET_VERSION;
    iFaxGeneral.FaxHandle = FaxHandle;

    BOOL Rslt = SendRequest( hSession, (LPVOID) &iFaxGeneral, sizeof(IFAX_GENERAL) );
    if (!Rslt) {
        InternetCloseHandle( hSession );
        return FALSE;
    }

    Rslt = GetResponse( hSession, (LPBYTE)Version, sizeof(DWORD) );

    Flush( hSession );
    InternetCloseHandle( hSession );

    return Rslt;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\exchange\ext\faxext.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    config.cpp

Abstract:

    This module contains routines for the fax config dialog.

Author:

    Wesley Witt (wesw) 13-Aug-1996

Revision History:

    20/10/99 -danl-
        Handle errors, and get appropriate server name in GetFaxConfig.

    dd/mm/yy -author-
        description
--*/

#define INITGUID
#define USES_IID_IExchExt
#define USES_IID_IExchExtAdvancedCriteria
#define USES_IID_IExchExtAttachedFileEvents
#define USES_IID_IExchExtCommands
#define USES_IID_IExchExtMessageEvents
#define USES_IID_IExchExtPropertySheets
#define USES_IID_IExchExtSessionEvents
#define USES_IID_IExchExtUserEvents
#define USES_IID_IMAPIFolder
#define USES_IID_IProfAdmin
#define USES_IID_IProfSect
#define USES_IID_IMAPISession
#define USES_PS_PUBLIC_STRINGS
#define USES_IID_IDistList

#include "faxext.h"
#include <initguid.h>
#include "debugex.h"
#include <mbstring.h>

HINSTANCE hInstance;

BOOL WINAPI
DllMain(
    HINSTANCE  hinstDLL,
    DWORD  fdwReason,
    LPVOID  lpvReserved
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH) 
    {
        hInstance = hinstDLL;
        HeapInitialize( NULL, MapiMemAlloc, MapiMemFree, HEAPINIT_NO_VALIDATION | HEAPINIT_NO_STRINGS );
    }
    if (fdwReason == DLL_PROCESS_DETACH) 
    {
    }
    return TRUE;
}



BOOL
VerifyDistributionList(
    LPEXCHEXTCALLBACK pmecb,
    DWORD EntryIdSize,
    LPENTRYID EntryId
    )
{
    HRESULT hr = S_OK;
    LPMAPISESSION Session = NULL;
    LPDISTLIST DistList = NULL;
    DWORD ObjType = 0;
    LPMAPITABLE DistTable = NULL;
    LPSRowSet DistRows = NULL;
    LPSPropValue Dist = NULL;
    DWORD i,j;
    BOOL FaxAddress = FALSE;


    hr = pmecb->GetSession( &Session, NULL );
    if (FAILED(hr)) {
        goto exit;
    }

    hr = Session->OpenEntry(
        EntryIdSize,
        EntryId,
        &IID_IDistList,
        MAPI_DEFERRED_ERRORS,
        &ObjType,
        (LPUNKNOWN *) &DistList
        );
    if (FAILED(hr)) 
    {
        goto exit;
    }

    hr = DistList->GetContentsTable(
        MAPI_DEFERRED_ERRORS,
        &DistTable
        );
    if (FAILED(hr)) 
    {
        goto exit;
    }

    hr = HrQueryAllRows( DistTable, NULL, NULL, NULL, 0, &DistRows );
    if (FAILED(hr)) 
    {
        goto exit;
    }

    for (i=0; i<DistRows->cRows; i++) 
    {
        Dist = DistRows->aRow[i].lpProps;
        for (j=0; j<DistRows->aRow[i].cValues; j++) 
        {
            if (Dist[j].ulPropTag == PR_ADDRTYPE_A) 
            {
                if (!strcmp( Dist[j].Value.lpszA, "FAX" )) 
                {
                    FaxAddress = TRUE;
                }
            }
            else if (Dist[j].ulPropTag == PR_ADDRTYPE_W) 
            {
                if (!wcscmp( Dist[j].Value.lpszW, L"FAX" )) 
                {
                    FaxAddress = TRUE;
                }
            }
        }
    }

exit:
    if (Session) {
        Session->Release();
    }
    if (DistList) {
        DistList->Release();
    }
    if (DistTable) {
        MemFree( DistTable );
    }
    if (DistRows) {
        FreeProws( DistRows );
    }

    return FaxAddress;
}




BOOL 
VerifyFaxRecipients(
    LPEXCHEXTCALLBACK pmecb
    )
/*++

Routine name : VerifyFaxRecipients

Routine description:

	Gets the recipients list of the currently open item, and checks wheather there 
    are any fax recipients in it. for a DL recipient - calls VerifyDistributionList 
    to check if there are any fax recipients in the DL. 

Author:

	Keren Ellran (t-KerenE),	Mar, 2000

Arguments:

    pmecb     -- [IN] pointer to Exchange Extension callback function

Return Value:

    BOOL: TRUE if there's one or more fax recipients, FALSE if none

--*/
{
    HRESULT hr = S_OK;
    LPADRLIST AdrList = NULL;
    DWORD i,j;
    BOOL FaxAddress = FALSE;
    BOOL IsDistList = FALSE;
    LPENTRYID EntryId = NULL;
    DWORD EntryIdSize;

	hr = pmecb->GetRecipients( &AdrList );
    if (FAILED(hr)) 
    {
       goto exit;
    }

    if (AdrList) 
    {
        for (i=0; i<AdrList->cEntries; i++) 
        {
            EntryId = NULL;
            IsDistList = FALSE;
            for (j=0; j<AdrList->aEntries[i].cValues; j++)
            {
                if (AdrList->aEntries[i].rgPropVals[j].ulPropTag == PR_ENTRYID) 
                {
                    EntryId = (LPENTRYID) AdrList->aEntries[i].rgPropVals[j].Value.bin.lpb;
                    EntryIdSize = AdrList->aEntries[i].rgPropVals[j].Value.bin.cb;
                } 
                else if (AdrList->aEntries[i].rgPropVals[j].ulPropTag == PR_ADDRTYPE_A) 
                {
                    if (!strcmp(AdrList->aEntries[i].rgPropVals[j].Value.lpszA, "FAX"))
                    {
                        FaxAddress = TRUE;
                        goto exit;
                    } 
                    else if ((!strcmp(AdrList->aEntries[i].rgPropVals[j].Value.lpszA, "MAPIPDL" )))
                    {
                        IsDistList = TRUE;
                    }
                }
                else if (AdrList->aEntries[i].rgPropVals[j].ulPropTag == PR_ADDRTYPE_W) 
                {
                    //
                    // Outlook Beta 2 (10.2202.2202) does not supply PR_ADDRTYPE_A property
                    // so we are looking for a PR_ADDRTYPE_W
                    //
                    if (!wcscmp(AdrList->aEntries[i].rgPropVals[j].Value.lpszW, L"FAX" ))
                    {
                        FaxAddress = TRUE;
                        goto exit;
                    } 
                    else if ((!wcscmp(AdrList->aEntries[i].rgPropVals[j].Value.lpszW, L"MAPIPDL")))
                    {
                        IsDistList = TRUE;
                    }
                }
            }
            //
            // after we finished going over all address's properties, if it is a DL, 
            // and if EntryId was detected, we can check if the DL includes a fax address.
            //
            if ((IsDistList)&&(EntryId))
            {
                FaxAddress = VerifyDistributionList( pmecb, EntryIdSize, EntryId );
                if (FaxAddress == TRUE)
                    goto exit;
            }
        }
    }
exit:   
    if(AdrList)
    {
        FreePadrlist(AdrList);
    }
    return FaxAddress;
}



HRESULT
EnableMenuAndToolbar(
    LPEXCHEXTCALLBACK pmecb,
    HWND hwndToolbar,
    DWORD CmdId
    )
{
    HRESULT hr = S_OK;
    LPADRLIST AdrList = NULL;
    BOOL FaxAddress = FALSE;
    HMENU hMenu;
    LPENTRYID EntryId = NULL;

    DBG_ENTER(TEXT("EnableMenuAndToolbar"));

    FaxAddress = VerifyFaxRecipients(pmecb);
    hr = pmecb->GetMenu( &hMenu );

    if (S_OK != hr)
    {
        goto exit;
    }

    if (FaxAddress) 
    {
        VERBOSE(DBG_MSG, TEXT("Enabling menu") );
        EnableMenuItem( hMenu, CmdId, MF_BYCOMMAND | MF_ENABLED );
        SendMessage( hwndToolbar, TB_ENABLEBUTTON, (WPARAM) CmdId, MAKELONG(TRUE,0) );
    } 
    else 
    {
        VERBOSE(DBG_MSG, TEXT("Disabling menu") );
        EnableMenuItem( hMenu, CmdId, MF_BYCOMMAND | MF_GRAYED );
        SendMessage( hwndToolbar, TB_ENABLEBUTTON, (WPARAM) CmdId, MAKELONG(FALSE,0) );
    }

exit:
    return hr;
}


HRESULT
GetFaxConfig(
    LPEXCHEXTCALLBACK pmecb,
    PFAXXP_CONFIG FaxConfig
    )
{
    HRESULT hr = S_FALSE;
    LPMAPISESSION lpSession = NULL;
    LPPROFSECT pProfileObj = NULL;
    ULONG PropCount = 0;
    LPSPropValue pProps = NULL;
    LPSERVICEADMIN lpServiceAdmin = NULL;
    LPPROVIDERADMIN lpProviderAdmin = NULL;
    LPMAPITABLE ptblSvc = NULL;
    LPSRowSet pSvcRows = NULL;
    LPSPropValue pSvc = NULL;
    DWORD i,j;
    BOOL FoundIt = FALSE;
    LPBYTE FaxXpGuid = NULL;
    MAPIUID FaxGuid = FAX_XP_GUID;


    hr = pmecb->GetSession( &lpSession, NULL );
    if (FAILED(hr)) {
        goto exit;
    }

    hr = lpSession->AdminServices( 0, &lpServiceAdmin );
    if (FAILED(hr)) {
        goto exit;
    }

    hr = lpServiceAdmin->GetMsgServiceTable( 0, &ptblSvc );
    if (FAILED(hr)) {
        goto exit;
    }

    hr = HrQueryAllRows( ptblSvc, NULL, NULL, NULL, 0, &pSvcRows );
    if (FAILED(hr)) {
        goto exit;
    }

    for (i=0; i<pSvcRows->cRows; i++) 
    {
        pSvc = pSvcRows->aRow[i].lpProps;
        for (j=0; j<pSvcRows->aRow[i].cValues; j++) 
        {
            if (pSvc[j].ulPropTag == PR_SERVICE_NAME_A) 
            {
                if (_stricmp( pSvc[j].Value.lpszA, FAX_MESSAGE_SERVICE_NAME) == 0) 
                {
                    FoundIt = TRUE;
                }
            }

            if (pSvc[j].ulPropTag == PR_SERVICE_UID) 
            {
                FaxXpGuid = pSvc[j].Value.bin.lpb;
            }
        }
        if (FoundIt) 
        {
            break;
        }
    }

    if (!FoundIt) 
    {
        goto exit;
    }

    hr = lpServiceAdmin->AdminProviders( (LPMAPIUID) FaxXpGuid, 0, &lpProviderAdmin );
    if (FAILED(hr)) 
    {
        goto exit;
    }

    hr = lpProviderAdmin->OpenProfileSection(
        &FaxGuid,
        NULL,
        0,
        &pProfileObj
        );
    if (FAILED(hr)) {
        goto exit;
    }

    hr = pProfileObj->GetProps(
        (LPSPropTagArray) &sptFaxProps,
		0,
        &PropCount,
        &pProps
        );
    if (FAILED(hr)) {
        goto exit;
    }

    if (!(FaxConfig->PrinterName = StringDup( (LPTSTR)pProps[PROP_FAX_PRINTER_NAME].Value.bin.lpb )))
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }
    if (!(FaxConfig->CoverPageName = StringDup( (LPTSTR)pProps[PROP_COVERPAGE_NAME].Value.bin.lpb )))
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }
    FaxConfig->UseCoverPage = pProps[PROP_USE_COVERPAGE].Value.ul;
    FaxConfig->SendSingleReceipt = pProps[PROP_SEND_SINGLE_RECEIPT].Value.ul;
    FaxConfig->bAttachFax = pProps[PROP_ATTACH_FAX].Value.ul;
    FaxConfig->ServerCoverPage = pProps[PROP_SERVER_COVERPAGE].Value.ul;
    FaxConfig->LinkCoverPage = pProps[PROP_LINK_COVERPAGE].Value.ul;

    if(pProps[PROP_FONT].Value.bin.lpb && sizeof(LOGFONT) == pProps[PROP_FONT].Value.bin.cb)
    {
        if (!memcpy( &FaxConfig->FontStruct, pProps[PROP_FONT].Value.bin.lpb, pProps[PROP_FONT].Value.bin.cb ))
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }
    }
    
    if (!GetServerNameFromPrinterName(FaxConfig->PrinterName,&FaxConfig->ServerName))
    {
        hr = S_FALSE;
        goto exit;
    }
    hr = S_OK;
exit:

    if (pSvcRows) {
        FreeProws( pSvcRows );
    }
    if (pProps) {
        MAPIFreeBuffer( pProps );
    }
    if (pProfileObj) {
        pProfileObj->Release();
    }
    if (ptblSvc) {
        ptblSvc->Release();
    }
    if (lpProviderAdmin) {
        lpProviderAdmin->Release();
    }
    if (lpServiceAdmin) {
        lpServiceAdmin->Release();
    }
    if (lpSession) {
        lpSession->Release();
    }

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//    FUNCTION: ExchEntryPoint
//
//    Parameters - none
//
//    Purpose
//    The entry point which Exchange calls.
//
//    Return Value
//    Pointer to Exchange Extension Object
//
//    Comments
//    This is called for each context entry.  Create a new MyExchExt object
//    every time so each context will get its own MyExchExt interface.
//
LPEXCHEXT CALLBACK ExchEntryPoint(void)
{
    LPEXCHEXT pExt;
    __try 
    {
        pExt = new MyExchExt;
    } 
    __except (EXCEPTION_EXECUTE_HANDLER) 
    {
        pExt = NULL;
    }
    MyExchExt *pMyExt = (MyExchExt *)pExt;
    if (!pMyExt || !pMyExt->IsValid())
    {
        //
        // Creation failed
        //
        if (pMyExt)
        {
            delete pMyExt;
        }
        pExt = NULL;
    }
    return pExt;
}


///////////////////////////////////////////////////////////////////////////////
//    MyExchExt::MyExchExt()
//
//    Parameters - none
//
//    Purpose
//    Constructor. Initialize members and create supporting interface objects
//
//    Comments
//    Each context of Exchange gets its own set of interface objects.
//    Furthermore, interface objects per context are kept track of by Exchange
//    and the interface methods are called in the proper context.
//
MyExchExt::MyExchExt ()
{
    m_cRef = 1;
    m_context = 0;

    m_pExchExtCommands = new MyExchExtCommands;
    m_pExchExtUserEvents = new MyExchExtUserEvents;

    // in MyExchExtUserEvents methods I need a reference to MyExchExt
    if (m_pExchExtUserEvents)
    {
        m_pExchExtUserEvents->SetIExchExt( this );
    }
}


///////////////////////////////////////////////////////////////////////////////
//  IExchExt virtual member functions implementation
//

///////////////////////////////////////////////////////////////////////////////
//    MyExchExt::QueryInterface()
//
//    Parameters
//    riid   -- Interface ID.
//    ppvObj -- address of interface object pointer.
//
//    Purpose
//    Called by Exchage to request for interfaces
//
//    Return Value
//    S_OK  -- interface is supported and returned in ppvObj pointer
//    E_NOINTERFACE -- interface is not supported and ppvObj is NULL
//
//    Comments
//    Exchange client calls QueryInterface for each object.  Only
//    Need to support objects that apply to the extension.  QueryInterface
//    is called onces for each IID for each context.  We support two
//    contexts in this example so QueryInterface is called twice for
//    each IID.
//
STDMETHODIMP
MyExchExt::QueryInterface(
    REFIID riid,
    LPVOID * ppvObj
    )
{
    HRESULT hr = S_OK;

    *ppvObj = NULL;

    if ( (IID_IUnknown == riid) || (IID_IExchExt == riid) ) 
    {
        *ppvObj = (LPUNKNOWN) this;
    } 
    else if ( IID_IExchExtCommands == riid) 
    {
        if (!m_pExchExtCommands) 
        {
            hr = E_UNEXPECTED;
        } 
        else 
        {
            *ppvObj = (LPUNKNOWN)m_pExchExtCommands;
            m_pExchExtCommands->SetContext( m_context );
        }
    } 
    else if ( IID_IExchExtUserEvents == riid) 
    {
        *ppvObj = (LPUNKNOWN)m_pExchExtUserEvents;
        m_pExchExtUserEvents->SetContext( m_context );
    } 
    else 
    {
        hr = E_NOINTERFACE;
    }
    if (NULL != *ppvObj) 
    {
        ((LPUNKNOWN)*ppvObj)->AddRef();
    }

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//    MyExchExt::Install()
//
//    Parameters
//    pmecb     -- pointer to Exchange Extension callback function
//    mecontext -- context code at time of being called.
//    ulFlags   -- flag to say if install is for modal or not
//
//    Purpose
//    Called once for each new contexted that is entered.  Proper version
//    number is checked here.
//
//    Return Value
//    S_OK -- object supported in the requested context
//    S_FALSE -- object is not supported in teh requested context
//
//    Comments
//
STDMETHODIMP
MyExchExt::Install(
    LPEXCHEXTCALLBACK pmecb,
    ULONG mecontext,
    ULONG ulFlags
    )
{
    ULONG ulBuildVersion;
    HRESULT hr;

    m_context = mecontext;

    // make sure this is the right version
    pmecb->GetVersion( &ulBuildVersion, EECBGV_GETBUILDVERSION );

    if (EECBGV_BUILDVERSION_MAJOR != (ulBuildVersion & EECBGV_BUILDVERSION_MAJOR_MASK)) {
        return S_FALSE;
    }

    switch (mecontext) {
        case EECONTEXT_SENDNOTEMESSAGE:
            hr = S_OK;
            break;

        default:
            hr = S_FALSE;
            break;
    }

    return hr;
}



MyExchExtCommands::MyExchExtCommands()
{
    m_cRef = 0;
    m_context = 0;
    m_cmdid = 0;
    m_itbb = 0;
    m_itbm = 0;
    m_hWnd = 0;
    m_hwndToolbar = NULL;
	memset(&m_FaxConfig, 0, sizeof(m_FaxConfig));
}


MyExchExtCommands::~MyExchExtCommands()
{
    MemFree( m_FaxConfig.PrinterName );
    MemFree( m_FaxConfig.CoverPageName );
}

STDMETHODIMP_(ULONG) MyExchExtCommands::AddRef() 
{ 
	++m_cRef; 
	return m_cRef; 
}

 STDMETHODIMP_(ULONG) MyExchExtCommands::Release()
{
	ULONG ulCount = --m_cRef;
	if (!ulCount) 
	{ 
        delete this; 
	}
	return ulCount;
}


///////////////////////////////////////////////////////////////////////////////
//    MyExchExtCommands::QueryInterface()
//
//    Parameters
//    riid   -- Interface ID.
//    ppvObj -- address of interface object pointer.
//
//    Purpose
//    Exchange Client does not call IExchExtCommands::QueryInterface().
//    So return nothing.
//
//    Return Value - none
//

STDMETHODIMP
MyExchExtCommands::QueryInterface(
    REFIID riid,
    LPVOID FAR * ppvObj
    )
{
    *ppvObj = NULL;
    if ( (riid == IID_IExchExtCommands) || (riid == IID_IUnknown) ) 
    {
        *ppvObj = (LPVOID)this;
        // Increase usage count of this object
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}


///////////////////////////////////////////////////////////////////////////////
//    MyExchExtCommands::InstallCommands()
//
//    Parameters
//    pmecb  -- Exchange Callback Interface
//    hWnd   -- window handle to main window of context
//    hMenu  -- menu handle to main menu of context
//    lptbeArray -- array of toolbar button entries
//    ctbe   -- count of button entries in array
//    ulFlags -- reserved
//
//    Purpose
//    This function is called when commands are installed for each context
//    the extension services.
//
//    Return Value
//    S_FALSE means the commands have been handled.
//
//    Comments
//    The hWnd and hMenu are in context.  If the context is for the SENDNOTE
//    dialog, then the hWnd is the window handle to the dialog and the hMenu is
//    the main menu of the dialog.
//
//    Call ResetToolbar so that Exchange will show it's toolbar
//


STDMETHODIMP
MyExchExtCommands::InstallCommands(
    LPEXCHEXTCALLBACK pmecb,
    HWND hWnd,
    HMENU hMenu,
    UINT FAR * pcmdidBase,
    LPTBENTRY lptbeArray,
    UINT ctbe,
    ULONG ulFlags
    )
{
    HRESULT hr = S_FALSE;
    TCHAR MenuItem[64];
    BOOL    bResult = 0;

    DBG_ENTER(TEXT("MyExchExtCommands::InstallCommands"));

    if (m_context == EECONTEXT_SENDNOTEMESSAGE) 
    {

        int tbindx;
        HMENU hMenu;
        
        hr = pmecb->GetMenuPos( EECMDID_ToolsCustomizeToolbar, &hMenu, NULL, NULL, 0 );
        if(FAILED(hr))
        {
            CALL_FAIL(GENERAL_ERR, TEXT("pmecb->GetMenuPos"), 0);
            hr = S_FALSE;
            goto exit;        
        }
        
        bResult = AppendMenu( hMenu, MF_SEPARATOR, 0, NULL );
        if (!bResult)
        {
            CALL_FAIL(GENERAL_ERR, TEXT("AppendMenu"), ::GetLastError);
            hr = S_FALSE;
            goto exit;
        }
        
        LoadString( hInstance, IDS_FAX_ATTRIBUTES_MENU, MenuItem, sizeof(MenuItem)/sizeof(*MenuItem));
        bResult = AppendMenu( hMenu, MF_BYPOSITION | MF_STRING, *pcmdidBase, MenuItem );
        if (!bResult)
        {
            CALL_FAIL(GENERAL_ERR, TEXT("AppendMenu"), ::GetLastError);
            hr = S_FALSE;
            goto exit;
        }
        
        m_hWnd = hWnd;
        m_cmdid = *pcmdidBase;
        (*pcmdidBase)++;
        for (tbindx = ctbe-1; (int) tbindx > -1; --tbindx) 
        {
            if (lptbeArray[tbindx].tbid == EETBID_STANDARD) 
            {
                m_hwndToolbar = lptbeArray[tbindx].hwnd;
                m_itbb = lptbeArray[tbindx].itbbBase;
                lptbeArray[tbindx].itbbBase ++;
                break;
            }
        }
        
        if (m_hwndToolbar) 
        {
            TBADDBITMAP tbab;

            tbab.hInst = hInstance;
            tbab.nID = IDB_EXTBTN;
            m_itbm = (INT)SendMessage( m_hwndToolbar, TB_ADDBITMAP, 1, (LPARAM)&tbab );
            EnableMenuAndToolbar( pmecb, m_hwndToolbar, m_cmdid );
            ResetToolbar( EETBID_STANDARD, 0 );
        }

        hr = GetFaxConfig( pmecb, &m_FaxConfig );
    }

exit:
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//    MyExchExtCommands::DoCommand()
//
//    Parameters
//    pmecb -- pointer to Exchange Callback Interface
//
//    Purpose7
//    This method is called by Exchange for each WM_COMMAND is sent to the
//    window in context.
//
//    Return Value
//    S_OK if command is handled
//    S_FALSE if command is not handled
//
//    Comments
//    Use this function to either respond to the command item (menu or toolbar)
//    added or modify an existing command in Exchange.  Return S_OK to let
//    Exchange know the command was handled.  Return S_OK on commands you are
//    taking over from Exchange.  Return S_FALSE to let Exchange know you want
//    it to carry out its command, even if you modify its action.
//

STDMETHODIMP
MyExchExtCommands::DoCommand(
    LPEXCHEXTCALLBACK pmecb,
    UINT cmdid
    )
{
    HRESULT hr = S_OK;
    HWND hwnd = NULL;
    INT_PTR Rslt;
    LPMESSAGE pMessage = NULL;
    LPMDB pMDB = NULL;
    LPSPropProblemArray lpProblems = NULL;
    SPropValue MsgProps[NUM_FAX_MSG_PROPS];
    LPSPropTagArray MsgPropTags = NULL;
    MAPINAMEID NameIds[NUM_FAX_MSG_PROPS];
    MAPINAMEID *pNameIds[NUM_FAX_MSG_PROPS] = {
                                                &NameIds[0], 
                                                &NameIds[1], 
                                                &NameIds[2], 
                                                &NameIds[3], 
                                                &NameIds[4], 
                                                &NameIds[5],
                                                &NameIds[6]
                                              };
    LPENTRYID EntryId = NULL;

    DBG_ENTER(TEXT("MyExchExtCommands::DoCommand"));

    if (m_cmdid != cmdid) 
    {
        return S_FALSE;
    }

    hr = pmecb->GetWindow( &hwnd );
    if (FAILED(hr)) 
    {
        goto exit;
    }

    Rslt = DialogBoxParam(
        hInstance,
        MAKEINTRESOURCE(FAX_CONFIG_DIALOG),
        hwnd,
        ConfigDlgProc,
        (LPARAM) &m_FaxConfig
        );
    if (Rslt == IDOK) 
    {

        hr = pmecb->GetObject( &pMDB, (LPMAPIPROP *) &pMessage );
        if (FAILED(hr)) {
            goto exit;
        }

        NameIds[MSGPI_FAX_PRINTER_NAME].lpguid = (LPGUID)&PS_PUBLIC_STRINGS;
        NameIds[MSGPI_FAX_PRINTER_NAME].ulKind = MNID_STRING;
        NameIds[MSGPI_FAX_PRINTER_NAME].Kind.lpwstrName = MSGPS_FAX_PRINTER_NAME;

        NameIds[MSGPI_FAX_COVERPAGE_NAME].lpguid = (LPGUID)&PS_PUBLIC_STRINGS;
        NameIds[MSGPI_FAX_COVERPAGE_NAME].ulKind = MNID_STRING;
        NameIds[MSGPI_FAX_COVERPAGE_NAME].Kind.lpwstrName = MSGPS_FAX_COVERPAGE_NAME;

        NameIds[MSGPI_FAX_USE_COVERPAGE].lpguid = (LPGUID)&PS_PUBLIC_STRINGS;
        NameIds[MSGPI_FAX_USE_COVERPAGE].ulKind = MNID_STRING;
        NameIds[MSGPI_FAX_USE_COVERPAGE].Kind.lpwstrName = MSGPS_FAX_USE_COVERPAGE;

        NameIds[MSGPI_FAX_SERVER_COVERPAGE].lpguid = (LPGUID)&PS_PUBLIC_STRINGS;
        NameIds[MSGPI_FAX_SERVER_COVERPAGE].ulKind = MNID_STRING;
        NameIds[MSGPI_FAX_SERVER_COVERPAGE].Kind.lpwstrName = MSGPS_FAX_SERVER_COVERPAGE;

        NameIds[MSGPI_FAX_SEND_SINGLE_RECEIPT].lpguid = (LPGUID)&PS_PUBLIC_STRINGS;
        NameIds[MSGPI_FAX_SEND_SINGLE_RECEIPT].ulKind = MNID_STRING;
        NameIds[MSGPI_FAX_SEND_SINGLE_RECEIPT].Kind.lpwstrName = MSGPS_FAX_SEND_SINGLE_RECEIPT;

        NameIds[MSGPI_FAX_ATTACH_FAX].lpguid = (LPGUID)&PS_PUBLIC_STRINGS;
        NameIds[MSGPI_FAX_ATTACH_FAX].ulKind = MNID_STRING;
        NameIds[MSGPI_FAX_ATTACH_FAX].Kind.lpwstrName = MSGPS_FAX_ATTACH_FAX;

        NameIds[MSGPI_FAX_LINK_COVERPAGE].lpguid = (LPGUID)&PS_PUBLIC_STRINGS;
        NameIds[MSGPI_FAX_LINK_COVERPAGE].ulKind = MNID_STRING;
        NameIds[MSGPI_FAX_LINK_COVERPAGE].Kind.lpwstrName = MSGPS_FAX_LINK_COVERPAGE;

        hr = pMessage->GetIDsFromNames( NUM_FAX_MSG_PROPS, pNameIds, MAPI_CREATE, &MsgPropTags );
        if (FAILED(hr)) {
            goto exit;
        }

        MsgPropTags->aulPropTag[MSGPI_FAX_PRINTER_NAME] = PROP_TAG( PT_BINARY, PROP_ID(MsgPropTags->aulPropTag[MSGPI_FAX_PRINTER_NAME]) );
        MsgPropTags->aulPropTag[MSGPI_FAX_COVERPAGE_NAME] = PROP_TAG( PT_BINARY, PROP_ID(MsgPropTags->aulPropTag[MSGPI_FAX_COVERPAGE_NAME]) );
        MsgPropTags->aulPropTag[MSGPI_FAX_USE_COVERPAGE] = PROP_TAG( PT_LONG,    PROP_ID(MsgPropTags->aulPropTag[MSGPI_FAX_USE_COVERPAGE]) );
        MsgPropTags->aulPropTag[MSGPI_FAX_SERVER_COVERPAGE] = PROP_TAG( PT_LONG,    PROP_ID(MsgPropTags->aulPropTag[MSGPI_FAX_SERVER_COVERPAGE]) );
        MsgPropTags->aulPropTag[MSGPI_FAX_SEND_SINGLE_RECEIPT] = PROP_TAG( PT_LONG,    PROP_ID(MsgPropTags->aulPropTag[MSGPI_FAX_SEND_SINGLE_RECEIPT]) );
        MsgPropTags->aulPropTag[MSGPI_FAX_ATTACH_FAX] = PROP_TAG( PT_LONG,    PROP_ID(MsgPropTags->aulPropTag[MSGPI_FAX_ATTACH_FAX]) );
        MsgPropTags->aulPropTag[MSGPI_FAX_LINK_COVERPAGE] = PROP_TAG( PT_LONG,    PROP_ID(MsgPropTags->aulPropTag[MSGPI_FAX_LINK_COVERPAGE]) );
        
        MsgProps[MSGPI_FAX_PRINTER_NAME].ulPropTag = MsgPropTags->aulPropTag[MSGPI_FAX_PRINTER_NAME];
        MsgProps[MSGPI_FAX_COVERPAGE_NAME].ulPropTag = MsgPropTags->aulPropTag[MSGPI_FAX_COVERPAGE_NAME];
        MsgProps[MSGPI_FAX_USE_COVERPAGE].ulPropTag = MsgPropTags->aulPropTag[MSGPI_FAX_USE_COVERPAGE];
        MsgProps[MSGPI_FAX_SERVER_COVERPAGE].ulPropTag = MsgPropTags->aulPropTag[MSGPI_FAX_SERVER_COVERPAGE];
        MsgProps[MSGPI_FAX_SEND_SINGLE_RECEIPT].ulPropTag = MsgPropTags->aulPropTag[MSGPI_FAX_SEND_SINGLE_RECEIPT];
        MsgProps[MSGPI_FAX_ATTACH_FAX].ulPropTag = MsgPropTags->aulPropTag[MSGPI_FAX_ATTACH_FAX];
        MsgProps[MSGPI_FAX_LINK_COVERPAGE].ulPropTag = MsgPropTags->aulPropTag[MSGPI_FAX_LINK_COVERPAGE];

        MsgProps[MSGPI_FAX_PRINTER_NAME].Value.bin.cb = (_tcslen(m_FaxConfig.PrinterName) + 1) * sizeof(TCHAR);
        MsgProps[MSGPI_FAX_PRINTER_NAME].Value.bin.lpb = (LPBYTE )StringDup(m_FaxConfig.PrinterName);
        if(!MsgProps[MSGPI_FAX_PRINTER_NAME].Value.bin.lpb)
        {
            MsgProps[MSGPI_FAX_PRINTER_NAME].Value.bin.cb = 0;

            CALL_FAIL(MEM_ERR, TEXT("StringDup"), ERROR_NOT_ENOUGH_MEMORY);
            ErrorMsgBox(hInstance, hwnd, IDS_NOT_ENOUGH_MEMORY);
            hr = E_OUTOFMEMORY;
            goto exit;        
        }

        MsgProps[MSGPI_FAX_COVERPAGE_NAME].Value.bin.cb =( _tcslen(m_FaxConfig.CoverPageName) + 1) * sizeof(TCHAR);
        MsgProps[MSGPI_FAX_COVERPAGE_NAME].Value.bin.lpb = (LPBYTE)StringDup(m_FaxConfig.CoverPageName);
        if(!MsgProps[MSGPI_FAX_COVERPAGE_NAME].Value.bin.lpb)
        {
            MsgProps[MSGPI_FAX_COVERPAGE_NAME].Value.bin.cb = 0;

            CALL_FAIL(MEM_ERR, TEXT("StringDup"), ERROR_NOT_ENOUGH_MEMORY);
            ErrorMsgBox(hInstance, hwnd, IDS_NOT_ENOUGH_MEMORY);
            hr = E_OUTOFMEMORY;
            goto exit;        
        }

		MsgProps[MSGPI_FAX_USE_COVERPAGE].Value.ul = m_FaxConfig.UseCoverPage;
		MsgProps[MSGPI_FAX_SERVER_COVERPAGE].Value.ul = m_FaxConfig.ServerCoverPage;

        MsgProps[MSGPI_FAX_SEND_SINGLE_RECEIPT].Value.ul = m_FaxConfig.SendSingleReceipt;
        MsgProps[MSGPI_FAX_ATTACH_FAX].Value.ul = m_FaxConfig.bAttachFax;
		
		MsgProps[MSGPI_FAX_LINK_COVERPAGE].Value.ul = m_FaxConfig.LinkCoverPage;

        hr = pMessage->SetProps( NUM_FAX_MSG_PROPS, MsgProps, &lpProblems );
        if (FAILED(hr)) {
            goto exit;
        }
        if (lpProblems) {
            hr = MAPI_E_NOT_FOUND;
            goto exit;
        }

    }

exit:

    if (MsgPropTags) {
        MemFree( MsgPropTags );
    }
    if (lpProblems) {
        MemFree( lpProblems );
    }
    if (pMessage) {
        pMessage->Release();
    }

	if (pMDB)
	{
		pMDB->Release();
	}


    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//    MyExchExtCommands::InitMenu()
//
//    Parameters
//    pmecb -- pointer to Exchange Callback Interface
//
//    Purpose
//    This method is called by Exchange when the menu of context is about to
//    be activated.  See WM_INITMENU in the Windows API Reference for more
//    information.
//
//    Return Value - none
//

STDMETHODIMP_(VOID)
MyExchExtCommands::InitMenu(
    LPEXCHEXTCALLBACK pmecb
    )
{
    return;
}


///////////////////////////////////////////////////////////////////////////////
//    MyExchExtCommands::Help()
//
//    Parameters
//    pmecb -- pointer to Exchange Callback Interface
//    cmdid -- command id
//
//    Purpose
//    Respond when user presses F1 while custom menu item is selected.
//
//    Return Value
//    S_OK -- recognized the command and provided help
//    S_FALSE -- not our command and we didn't provide help
//

STDMETHODIMP MyExchExtCommands::Help(
    LPEXCHEXTCALLBACK pmecb,
    UINT cmdid
    )
{
    return S_FALSE;
}


///////////////////////////////////////////////////////////////////////////////
//    MyExchExtCommands::QueryHelpText()
//
//    Parameters
//    cmdid -- command id corresponding to menu item activated
//    ulFlags -- identifies either EECQHT_STATUS or EECQHT_TOOLTIP
//    psz -- pointer to buffer to be populated with text to display
//    cch -- count of characters available in psz buffer
//
//    Purpose
//    Exchange calls this function each time it requires to update the status
//    bar text or if it is to display a tooltip on the toolbar.
//
//    Return Value
//    S_OK to indicate our command was handled
//    S_FALSE to tell Exchange it can continue with its function
//

STDMETHODIMP
MyExchExtCommands::QueryHelpText(
    UINT cmdid,
    ULONG ulFlags,
    LPTSTR psz,
    UINT cch
    )
{
    HRESULT hr;
    TCHAR HelpText[64];

    LoadString(hInstance,IDS_FAX_ATTRIBUTES_TOOLTIP,HelpText,sizeof(HelpText)/sizeof(*HelpText));

    if (cmdid == m_cmdid) 
    {
        if (ulFlags == EECQHT_STATUS) 
        {
			_tcsncpy(psz,HelpText,cch/sizeof(TCHAR));
        }

        if (ulFlags == EECQHT_TOOLTIP) 
        {
			_tcsncpy(psz,HelpText,cch/sizeof(TCHAR));
        }

        hr = S_OK;
    } 
    else 
    {
        hr = S_FALSE;
    }

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//    MyExchExtCommands::QueryButtonInfo()
//
//    Parameters
//    tbid    -- toolbar identifier
//    itbb    -- toolbar button index
//    ptbb    -- pointer to toolbar button structure -- see TBBUTTON structure
//    lpsz    -- point to string describing button
//    cch     -- maximum size of lpsz buffer
//    ulFlags -- EXCHEXT_UNICODE may be specified
//
//    Purpose
//    For Exchange to find out about toolbar button information.
//
//    Return Value
//    S_FALSE - not our button
//    S_OK    - we filled information about our button
//
//    Comments
//    Called for every button installed for toolbars when IExchExtCommands
//    is installed for each context. The lpsz text is used when the Customize
//    Toolbar dialog is displayed.  The text will be displayed next to the
//    button.
//

STDMETHODIMP MyExchExtCommands::QueryButtonInfo(
    ULONG tbid,
    UINT itbb,
    LPTBBUTTON ptbb,
    LPTSTR lpsz,
    UINT cch,
    ULONG ulFlags
    )
{
    HRESULT hr = S_FALSE;
    TCHAR CustText[64];

    LoadString(hInstance,IDS_FAX_ATTRIBUTES_CUST,CustText,sizeof(CustText)/sizeof(TCHAR));

    if (m_itbb == itbb) {
        ptbb->iBitmap = m_itbm;
        ptbb->idCommand = m_cmdid;
        ptbb->fsState = TBSTATE_ENABLED;
        ptbb->fsStyle = TBSTYLE_BUTTON;
        ptbb->dwData = 0;
        ptbb->iString = -1;
		_tcsncpy(lpsz,CustText,cch/sizeof(TCHAR));
        hr = S_OK;
    }

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//    MyExchExtCommands::ResetToolbar()
//
//    Parameters
//    tbid
//    ulFlags
//
//    Purpose
//
//    Return Value  S_OK always
//
STDMETHODIMP
MyExchExtCommands::ResetToolbar(
    ULONG tbid,
    ULONG ulFlags
    )
{
    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
//  IExchExtUserEvents virtual member functions implementation
//

///////////////////////////////////////////////////////////////////////////////
//    MyExchExtUserEvents::QueryInterface()
//
//    Parameters
//    riid   -- Interface ID.
//    ppvObj -- address of interface object pointer.
//
//    Purpose
//    Exchange Client does not call IExchExtUserEvents::QueryInterface().
//    So return nothing.
//
//    Return Value - none
//

STDMETHODIMP
MyExchExtUserEvents::QueryInterface(
    REFIID riid,
    LPVOID FAR * ppvObj
    )
{
    *ppvObj = NULL;
    if (( riid == IID_IExchExtUserEvents) || (riid == IID_IUnknown) ) {
        *ppvObj = (LPVOID)this;
        // Increase usage count of this object
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}


///////////////////////////////////////////////////////////////////////////////
//    MyExchExtUserEvents::OnSelectionChange()
//
//    Parameters
//    pmecb  -- pointer to Exchange Callback Object
//
//
//    Purpose
//    This function is called when the selection in the UI is changed.
//
//    Return Value - none
//
//    Comments
//    OnSelectionChange is called whenever the selection changes either within
//    a pane or is changed between panes.
//

STDMETHODIMP_(VOID)
MyExchExtUserEvents::OnSelectionChange(
    LPEXCHEXTCALLBACK pmecb
    )
{
}


///////////////////////////////////////////////////////////////////////////////
//    MyExchExtUserEvents::OnObjectChange()
//
//    Parameters
//    pmecb  -- pointer to Exchange Callback Object
//
//
//    Purpose
//    This function is called when the selection in the UI is to a different
//    of object on the left pane.
//
//    Return Value - none
//
//    Comments
//    OnObjectChange is called whenever the selection is changed between
//    objects in the left pane only.  Change in selection between folders,
//    subfolders or container object in the left pane will be reflected with a
//    call to OnObjectChange.  Change in selection between objects (messages,
//    subfolders) in the right pane will not call OnObjectChange, only
//    OnSelectionChange.
//

STDMETHODIMP_(VOID)
MyExchExtUserEvents::OnObjectChange(
    LPEXCHEXTCALLBACK pmecb
    )
{
}

BOOL
GetServerNameFromPrinterName(
    LPTSTR lptszPrinterName,
    LPTSTR *pptszServerName
    )

/*++

Routine Description:

    retrieve the server name given a printer name

Arguments:

    [in] lptszPrinterName - Identifies the printer in question
    [out] lptszServerName - Address of pointer to output string buffer. 
                            NULL indicates local server.
                            The caller is responsible to free the buffer which 
                            pointer is given in this parameter.

Return Value:

    BOOL: TRUE - operation succeeded , FALSE: failed

--*/
{
    PPRINTER_INFO_2 ppi2 = NULL;
    LPTSTR  lptstrBuffer = NULL;
    BOOL    bRes = FALSE;

    if (lptszPrinterName) 
    {
        if (ppi2 = (PPRINTER_INFO_2) MyGetPrinter(lptszPrinterName,2))
        {
            if (GetServerNameFromPrinterInfo(ppi2,&lptstrBuffer))
            {
                if (lptstrBuffer)
                {
                    bRes = (NULL != (*pptszServerName = StringDup(lptstrBuffer)));
                }
                else
                {
                    bRes = TRUE;
                }
            }
            MemFree(ppi2);
        }
    }
    return bRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\exchange\ext\faxext.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    faxext.h

Abstract:

    Fax exchange client extension header file.

Author:

    Wesley Witt (wesw) 13-Aug-1996

Revision History:

    20/10/99 -danl-
        Add GetServerNameFromPrinterInfo.
        Change GetServerName to GetServerNameFromPrinterName.

    dd/mm/yy -author-
        description
--*/

#ifndef _FAXEXT_H_
#define _FAXEXT_H_

#include <windows.h>
#include <winspool.h>
#include <mapiwin.h>
#include <mapispi.h>
#include <mapiutil.h>
#include <mapicode.h>
#include <mapival.h>
#include <mapiwz.h>
#include <mapix.h>
#include <mapiutil.h>
#include <mapiform.h>
#include <mapiguid.h>
#include <richedit.h>
#include <shlobj.h>
#include <shellapi.h>
#include <commdlg.h>
#include <exchext.h>
#include <tapi.h>
#include <tchar.h>
#include <stdio.h>
#include <fxsapip.h>

#include "resource.h"
#include "faxmapip.h"
#include "faxreg.h"
#include "faxutil.h"

#define FAXUTIL_DEBUG
#define FAXUTIL_MEM
#define FAXUTIL_STRING
#define FAXUTIL_SUITE
#define FAXUTIL_REG
#include <faxutil.h>


#define MAX_FILENAME_EXT                    4
#define CPFLAG_LINK                         0x0100

#define SERVER_COVER_PAGE                   1   
#define SHORTCUT_COVER_PAGE                 2



/*
 -  GetServerNameFromPrinterInfo
 -
 *  Purpose:
 *      Get the Server name, given a PRINTER_INFO_2 structure
 *
 *  Arguments:
 *      [in] ppi2 - Address of PRINTER_INFO_2 structure
 *      [out] lpptszServerName - Address of string pointer for returned name.
 *
 *  Returns:
 *      BOOL - TRUE: sucess , FALSE: failure.
 *
 *  Remarks:
 *      This inline function retrieves the server from a printer info structure
 *      in the appropriate way for win9x and NT. 
 */
_inline BOOL 
GetServerNameFromPrinterInfo(PPRINTER_INFO_2 ppi2,LPTSTR *lpptszServerName)
{   
    if (!ppi2)
    {
        return FALSE;
    }
#ifndef WIN95

    *lpptszServerName = NULL;
    if (ppi2->pServerName)
    {
        if (!(*lpptszServerName = StringDup(_tcsninc(ppi2->pServerName,2))))
        {
            return FALSE;
        }
    }
    return TRUE;

#else //WIN95
    
    //
    // Formatted: \\Server\port
    //
    if (!(ppi2->pPortName))
    {
        return FALSE;
    }
    if (!(*lpptszServerName = StringDup(_tcsninc(ppi2->pPortName,2))))
    {
        return FALSE;
    }
    _tcstok(*lpptszServerName,TEXT("\\"));

#endif //WIN95

    return TRUE;
}

LPVOID
MapiMemAlloc(
    SIZE_T Size
    );

VOID
MapiMemFree(
    LPVOID ptr
    );

INT_PTR CALLBACK
ConfigDlgProc(
    HWND           hDlg,
    UINT           message,
    WPARAM         wParam,
    LPARAM         lParam
    );

PVOID
MyGetPrinter(
    LPTSTR   PrinterName,
    DWORD   level
    );

BOOL
GetServerNameFromPrinterName(
    LPTSTR   PrinterName,
    LPTSTR   *lptszServerName
    );

void
ErrorMsgBox(
    HINSTANCE hInstance,
    HWND      hWnd,
    DWORD     dwMsgId
);

class MyExchExt;
class MyExchExtCommands;
class MyExchExtUserEvents;

extern "C"
{
    LPEXCHEXT CALLBACK ExchEntryPoint(void);
}

class MyExchExt : public IExchExt
{

 public:
    MyExchExt ();
    STDMETHODIMP QueryInterface
                    (REFIID                     riid,
                     LPVOID *                   ppvObj);
    inline STDMETHODIMP_(ULONG) AddRef
                    () { ++m_cRef; return m_cRef; };
    inline STDMETHODIMP_(ULONG) Release
                    () { ULONG ulCount = --m_cRef;
                         if (!ulCount) { delete this; }
                         return ulCount;};
    STDMETHODIMP Install (LPEXCHEXTCALLBACK pmecb,
                        ULONG mecontext, ULONG ulFlags);

    BOOL IsValid()   { return (m_pExchExtUserEvents && m_pExchExtCommands) ? TRUE : FALSE; }


 private:
    ULONG m_cRef;
    UINT  m_context;

    MyExchExtUserEvents * m_pExchExtUserEvents;
    MyExchExtCommands * m_pExchExtCommands;
};

class MyExchExtCommands : public IExchExtCommands
{
 public:
    MyExchExtCommands();
    ~MyExchExtCommands();
    STDMETHODIMP QueryInterface
                    (REFIID                     riid,
                     LPVOID *                   ppvObj);
    inline STDMETHODIMP_(ULONG) AddRef();
    inline STDMETHODIMP_(ULONG) Release();
    STDMETHODIMP InstallCommands(LPEXCHEXTCALLBACK pmecb,
                                HWND hwnd, HMENU hmenu,
                                UINT FAR * cmdidBase, LPTBENTRY lptbeArray,
                                UINT ctbe, ULONG ulFlags);
    STDMETHODIMP DoCommand(LPEXCHEXTCALLBACK pmecb, UINT mni);
    STDMETHODIMP_(VOID) InitMenu(LPEXCHEXTCALLBACK pmecb);
    STDMETHODIMP Help(LPEXCHEXTCALLBACK pmecb, UINT mni);
    STDMETHODIMP QueryHelpText(UINT mni, ULONG ulFlags, LPTSTR sz, UINT cch);
    STDMETHODIMP QueryButtonInfo(ULONG tbid, UINT itbb, LPTBBUTTON ptbb,
                                LPTSTR lpsz, UINT cch, ULONG ulFlags);
    STDMETHODIMP ResetToolbar(ULONG tbid, ULONG ulFlags);

    inline VOID SetContext
                (ULONG eecontext) { m_context = eecontext; };
    inline UINT GetCmdID() { return m_cmdid; };

    inline HWND GetToolbarHWND() { return m_hwndToolbar; }

 private:
    ULONG m_cRef;          //
    ULONG m_context;       //
    UINT  m_cmdid;         // cmdid for menu extension command
    UINT  m_itbb;          // toolbar index
    HWND  m_hwndToolbar;   // toolbar window handle
    UINT  m_itbm;          //
    HWND  m_hWnd;          //
    FAXXP_CONFIG m_FaxConfig;
};


class MyExchExtUserEvents : public IExchExtUserEvents
{
 public:
    MyExchExtUserEvents() { m_cRef = 0; m_context = 0;
                            m_pExchExt = NULL; };
    STDMETHODIMP QueryInterface
                (REFIID                     riid,
                 LPVOID *                   ppvObj);
    inline STDMETHODIMP_(ULONG) AddRef
                () { ++m_cRef; return m_cRef; };
    inline STDMETHODIMP_(ULONG) Release
                () { ULONG ulCount = --m_cRef;
                     if (!ulCount) { delete this; }
                     return ulCount;};

    STDMETHODIMP_(VOID) OnSelectionChange(LPEXCHEXTCALLBACK pmecb);
    STDMETHODIMP_(VOID) OnObjectChange(LPEXCHEXTCALLBACK pmecb);

    inline VOID SetContext
                (ULONG eecontext) { m_context = eecontext; };
    inline VOID SetIExchExt
                (MyExchExt * pExchExt) { m_pExchExt = pExchExt; };

 private:
    ULONG m_cRef;
    ULONG m_context;

    MyExchExt * m_pExchExt;

};

#endif // _FAXEXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\exchange\ext\emsabtag.h ===
/*
** --emsabtag.h---------------------------------------------------------------
**
**  Property tag definitions for standard properties of Exchange Address
**  Book objects.
**
**  Note: These proptags are only valid when talking directly to the
**  Exchange Server Address Book. They are specifically NOT valid when
**  trying to read properties from an object copied into another address
**  book provider (the Personal Address Book, for example).
**
**  Copyright (c) Microsoft Corp. 1986-1996. All rights reserved.
** ---------------------------------------------------------------------------
*/

#ifndef _EMSABTAG_H
#define _EMSABTAG_H

/*
* Flags for ulInterfaceOptions on OpenProperty
*/
#define AB_SHOW_PHANTOMS                      2
#define AB_SHOW_OTHERS                        4

/*
* Flags for ulFlag on ResolveNames
*/
#define EMS_AB_ADDRESS_LOOKUP                 0x01

/*
* Constructed, but externally visible.
*/
#define PR_EMS_AB_SERVER                     PROP_TAG( PT_TSTRING, 0xFFFE)
#define PR_EMS_AB_SERVER_A                   PROP_TAG( PT_STRING8, 0xFFFE)
#define PR_EMS_AB_SERVER_W                   PROP_TAG( PT_UNICODE, 0xFFFE)
#define PR_EMS_AB_CONTAINERID                PROP_TAG( PT_LONG,    0xFFFD)
#define PR_EMS_AB_DOS_ENTRYID                PR_EMS_AB_CONTAINERID
#define PR_EMS_AB_PARENT_ENTRYID             PROP_TAG( PT_BINARY,  0xFFFC)
#define PR_EMS_AB_IS_MASTER                  PROP_TAG(PT_BOOLEAN,  0xFFFB)
#define PR_EMS_AB_OBJECT_OID                 PROP_TAG(PT_BINARY,   0xFFFA)
#define PR_EMS_AB_HIERARCHY_PATH             PROP_TAG(PT_TSTRING,  0xFFF9)
#define PR_EMS_AB_HIERARCHY_PATH_A           PROP_TAG(PT_STRING8,  0xFFF9)
#define PR_EMS_AB_HIERARCHY_PATH_W           PROP_TAG(PT_UNICODE,  0xFFF9)
#define PR_EMS_AB_CHILD_RDNS                  PROP_TAG(PT_MV_STRING8,   0xFFF8)

#define MIN_EMS_AB_CONSTRUCTED_PROP_ID        0xFFF8

#define PR_EMS_AB_OTHER_RECIPS                PROP_TAG(PT_OBJECT,       0xF000)

/*
 * Prop tags defined in the schema.
 */
#define PR_EMS_AB_DISPLAY_NAME_PRINTABLE      PROP_TAG(PT_TSTRING,      0x39FF)
#define PR_EMS_AB_DISPLAY_NAME_PRINTABLE_A    PROP_TAG(PT_STRING8,      0x39FF)
#define PR_EMS_AB_DISPLAY_NAME_PRINTABLE_W    PROP_TAG(PT_UNICODE,      0x39FF)

#define PR_EMS_AB_ACCESS_CATEGORY            PROP_TAG( PT_LONG,          0x8044)
#define PR_EMS_AB_ACTIVATION_SCHEDULE        PROP_TAG( PT_BINARY,        0x8045)
#define PR_EMS_AB_ACTIVATION_STYLE           PROP_TAG( PT_LONG,          0x8046)
#define PR_EMS_AB_ADDRESS_ENTRY_DISPLAY_TABLE PROP_TAG( PT_BINARY,        0x8017)
#define PR_EMS_AB_ADDRESS_ENTRY_DISPLAY_TABLE_MSDOS PROP_TAG( PT_BINARY,        0x8047)
#define PR_EMS_AB_ADDRESS_SYNTAX             PROP_TAG( PT_BINARY,        0x8018)
#define PR_EMS_AB_ADDRESS_TYPE               PROP_TAG( PT_TSTRING,       0x8048)
#define PR_EMS_AB_ADDRESS_TYPE_A             PROP_TAG( PT_STRING8,       0x8048)
#define PR_EMS_AB_ADDRESS_TYPE_W             PROP_TAG( PT_UNICODE,       0x8048)
#define PR_EMS_AB_ADMD                       PROP_TAG( PT_TSTRING,       0x8049)
#define PR_EMS_AB_ADMD_A                     PROP_TAG( PT_STRING8,       0x8049)
#define PR_EMS_AB_ADMD_W                     PROP_TAG( PT_UNICODE,       0x8049)
#define PR_EMS_AB_ADMIN_DESCRIPTION          PROP_TAG( PT_TSTRING,       0x804A)
#define PR_EMS_AB_ADMIN_DESCRIPTION_A        PROP_TAG( PT_STRING8,       0x804A)
#define PR_EMS_AB_ADMIN_DESCRIPTION_W        PROP_TAG( PT_UNICODE,       0x804A)
#define PR_EMS_AB_ADMIN_DISPLAY_NAME         PROP_TAG( PT_TSTRING,       0x804B)
#define PR_EMS_AB_ADMIN_DISPLAY_NAME_A       PROP_TAG( PT_STRING8,       0x804B)
#define PR_EMS_AB_ADMIN_DISPLAY_NAME_W       PROP_TAG( PT_UNICODE,       0x804B)
#define PR_EMS_AB_ADMIN_EXTENSION_DLL        PROP_TAG( PT_TSTRING,       0x804C)
#define PR_EMS_AB_ADMIN_EXTENSION_DLL_A      PROP_TAG( PT_STRING8,       0x804C)
#define PR_EMS_AB_ADMIN_EXTENSION_DLL_W      PROP_TAG( PT_UNICODE,       0x804C)
#define PR_EMS_AB_ALIASED_OBJECT_NAME        PROP_TAG( PT_TSTRING,       0x804D)
#define PR_EMS_AB_ALIASED_OBJECT_NAME_A      PROP_TAG( PT_STRING8,       0x804D)
#define PR_EMS_AB_ALIASED_OBJECT_NAME_W      PROP_TAG( PT_UNICODE,       0x804D)
#define PR_EMS_AB_ALIASED_OBJECT_NAME_O      PROP_TAG( PT_OBJECT,        0x804D)
#define PR_EMS_AB_ALIASED_OBJECT_NAME_T      PROP_TAG( PT_TSTRING,       0x804D)
#define PR_EMS_AB_ALT_RECIPIENT              PROP_TAG( PT_TSTRING,       0x804E)
#define PR_EMS_AB_ALT_RECIPIENT_A            PROP_TAG( PT_STRING8,       0x804E)
#define PR_EMS_AB_ALT_RECIPIENT_W            PROP_TAG( PT_UNICODE,       0x804E)
#define PR_EMS_AB_ALT_RECIPIENT_O            PROP_TAG( PT_OBJECT,        0x804E)
#define PR_EMS_AB_ALT_RECIPIENT_T            PROP_TAG( PT_TSTRING,       0x804E)
#define PR_EMS_AB_ALT_RECIPIENT_BL           PROP_TAG( PT_MV_TSTRING,    0x804F)
#define PR_EMS_AB_ALT_RECIPIENT_BL_A         PROP_TAG( PT_MV_STRING8,    0x804F)
#define PR_EMS_AB_ALT_RECIPIENT_BL_W         PROP_TAG( PT_MV_UNICODE,    0x804F)
#define PR_EMS_AB_ALT_RECIPIENT_BL_O         PROP_TAG( PT_OBJECT,        0x804F)
#define PR_EMS_AB_ALT_RECIPIENT_BL_T         PROP_TAG( PT_MV_TSTRING,    0x804F)
#define PR_EMS_AB_ANCESTOR_ID                PROP_TAG( PT_BINARY,        0x8050)
#define PR_EMS_AB_ASSOC_NT_ACCOUNT           PROP_TAG( PT_BINARY,        0x8027)
#define PR_EMS_AB_ASSOC_REMOTE_DXA           PROP_TAG( PT_MV_TSTRING,    0x8051)
#define PR_EMS_AB_ASSOC_REMOTE_DXA_A         PROP_TAG( PT_MV_STRING8,    0x8051)
#define PR_EMS_AB_ASSOC_REMOTE_DXA_W         PROP_TAG( PT_MV_UNICODE,    0x8051)
#define PR_EMS_AB_ASSOC_REMOTE_DXA_O         PROP_TAG( PT_OBJECT,        0x8051)
#define PR_EMS_AB_ASSOC_REMOTE_DXA_T         PROP_TAG( PT_MV_TSTRING,    0x8051)
#define PR_EMS_AB_ASSOCIATION_LIFETIME       PROP_TAG( PT_LONG,          0x8052)
#define PR_EMS_AB_AUTH_ORIG_BL               PROP_TAG( PT_MV_TSTRING,    0x8053)
#define PR_EMS_AB_AUTH_ORIG_BL_A             PROP_TAG( PT_MV_STRING8,    0x8053)
#define PR_EMS_AB_AUTH_ORIG_BL_W             PROP_TAG( PT_MV_UNICODE,    0x8053)
#define PR_EMS_AB_AUTH_ORIG_BL_O             PROP_TAG( PT_OBJECT,        0x8053)
#define PR_EMS_AB_AUTH_ORIG_BL_T             PROP_TAG( PT_MV_TSTRING,    0x8053)
#define PR_EMS_AB_AUTHORITY_REVOCATION_LIST  PROP_TAG( PT_MV_BINARY,     0x8026)
#define PR_EMS_AB_AUTHORIZED_DOMAIN          PROP_TAG( PT_TSTRING,       0x8054)
#define PR_EMS_AB_AUTHORIZED_DOMAIN_A        PROP_TAG( PT_STRING8,       0x8054)
#define PR_EMS_AB_AUTHORIZED_DOMAIN_W        PROP_TAG( PT_UNICODE,       0x8054)
#define PR_EMS_AB_AUTHORIZED_PASSWORD        PROP_TAG( PT_BINARY,        0x8055)
#define PR_EMS_AB_AUTHORIZED_USER            PROP_TAG( PT_TSTRING,       0x8056)
#define PR_EMS_AB_AUTHORIZED_USER_A          PROP_TAG( PT_STRING8,       0x8056)
#define PR_EMS_AB_AUTHORIZED_USER_W          PROP_TAG( PT_UNICODE,       0x8056)
#define PR_EMS_AB_AUTOREPLY                  PROP_TAG( PT_BOOLEAN,       0x800B)
#define PR_EMS_AB_AUTOREPLY_MESSAGE          PROP_TAG( PT_TSTRING,       0x800A)
#define PR_EMS_AB_AUTOREPLY_MESSAGE_A        PROP_TAG( PT_STRING8,       0x800A)
#define PR_EMS_AB_AUTOREPLY_MESSAGE_W        PROP_TAG( PT_UNICODE,       0x800A)
#define PR_EMS_AB_AUTOREPLY_SUBJECT          PROP_TAG( PT_TSTRING,       0x803E)
#define PR_EMS_AB_AUTOREPLY_SUBJECT_A        PROP_TAG( PT_STRING8,       0x803E)
#define PR_EMS_AB_AUTOREPLY_SUBJECT_W        PROP_TAG( PT_UNICODE,       0x803E)
#define PR_EMS_AB_BRIDGEHEAD_SERVERS         PROP_TAG( PT_MV_TSTRING,    0x8174)
#define PR_EMS_AB_BRIDGEHEAD_SERVERS_A       PROP_TAG( PT_MV_STRING8,    0x8174)
#define PR_EMS_AB_BRIDGEHEAD_SERVERS_W       PROP_TAG( PT_MV_UNICODE,    0x8174)
#define PR_EMS_AB_BRIDGEHEAD_SERVERS_O       PROP_TAG( PT_OBJECT,        0x8174)
#define PR_EMS_AB_BRIDGEHEAD_SERVERS_T       PROP_TAG( PT_MV_TSTRING,    0x8174)
#define PR_EMS_AB_BUSINESS_CATEGORY          PROP_TAG( PT_MV_TSTRING,    0x8057)
#define PR_EMS_AB_BUSINESS_CATEGORY_A        PROP_TAG( PT_MV_STRING8,    0x8057)
#define PR_EMS_AB_BUSINESS_CATEGORY_W        PROP_TAG( PT_MV_UNICODE,    0x8057)
#define PR_EMS_AB_BUSINESS_ROLES             PROP_TAG( PT_BINARY,        0x8023)
#define PR_EMS_AB_CA_CERTIFICATE             PROP_TAG( PT_MV_BINARY,     0x8003)
#define PR_EMS_AB_CAN_CREATE_PF              PROP_TAG( PT_MV_TSTRING,    0x8058)
#define PR_EMS_AB_CAN_CREATE_PF_A            PROP_TAG( PT_MV_STRING8,    0x8058)
#define PR_EMS_AB_CAN_CREATE_PF_W            PROP_TAG( PT_MV_UNICODE,    0x8058)
#define PR_EMS_AB_CAN_CREATE_PF_O            PROP_TAG( PT_OBJECT,        0x8058)
#define PR_EMS_AB_CAN_CREATE_PF_T            PROP_TAG( PT_MV_TSTRING,    0x8058)
#define PR_EMS_AB_CAN_CREATE_PF_BL           PROP_TAG( PT_MV_TSTRING,    0x8059)
#define PR_EMS_AB_CAN_CREATE_PF_BL_A         PROP_TAG( PT_MV_STRING8,    0x8059)
#define PR_EMS_AB_CAN_CREATE_PF_BL_W         PROP_TAG( PT_MV_UNICODE,    0x8059)
#define PR_EMS_AB_CAN_CREATE_PF_BL_O         PROP_TAG( PT_OBJECT,        0x8059)
#define PR_EMS_AB_CAN_CREATE_PF_BL_T         PROP_TAG( PT_MV_TSTRING,    0x8059)
#define PR_EMS_AB_CAN_CREATE_PF_DL           PROP_TAG( PT_MV_TSTRING,    0x805A)
#define PR_EMS_AB_CAN_CREATE_PF_DL_A         PROP_TAG( PT_MV_STRING8,    0x805A)
#define PR_EMS_AB_CAN_CREATE_PF_DL_W         PROP_TAG( PT_MV_UNICODE,    0x805A)
#define PR_EMS_AB_CAN_CREATE_PF_DL_O         PROP_TAG( PT_OBJECT,        0x805A)
#define PR_EMS_AB_CAN_CREATE_PF_DL_T         PROP_TAG( PT_MV_TSTRING,    0x805A)
#define PR_EMS_AB_CAN_CREATE_PF_DL_BL        PROP_TAG( PT_MV_TSTRING,    0x805B)
#define PR_EMS_AB_CAN_CREATE_PF_DL_BL_A      PROP_TAG( PT_MV_STRING8,    0x805B)
#define PR_EMS_AB_CAN_CREATE_PF_DL_BL_W      PROP_TAG( PT_MV_UNICODE,    0x805B)
#define PR_EMS_AB_CAN_CREATE_PF_DL_BL_O      PROP_TAG( PT_OBJECT,        0x805B)
#define PR_EMS_AB_CAN_CREATE_PF_DL_BL_T      PROP_TAG( PT_MV_TSTRING,    0x805B)
#define PR_EMS_AB_CAN_NOT_CREATE_PF          PROP_TAG( PT_MV_TSTRING,    0x805C)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_A        PROP_TAG( PT_MV_STRING8,    0x805C)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_W        PROP_TAG( PT_MV_UNICODE,    0x805C)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_O        PROP_TAG( PT_OBJECT,        0x805C)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_T        PROP_TAG( PT_MV_TSTRING,    0x805C)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_BL       PROP_TAG( PT_MV_TSTRING,    0x805D)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_BL_A     PROP_TAG( PT_MV_STRING8,    0x805D)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_BL_W     PROP_TAG( PT_MV_UNICODE,    0x805D)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_BL_O     PROP_TAG( PT_OBJECT,        0x805D)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_BL_T     PROP_TAG( PT_MV_TSTRING,    0x805D)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL       PROP_TAG( PT_MV_TSTRING,    0x805E)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_A     PROP_TAG( PT_MV_STRING8,    0x805E)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_W     PROP_TAG( PT_MV_UNICODE,    0x805E)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_O     PROP_TAG( PT_OBJECT,        0x805E)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_T     PROP_TAG( PT_MV_TSTRING,    0x805E)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_BL    PROP_TAG( PT_MV_TSTRING,    0x805F)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_BL_A  PROP_TAG( PT_MV_STRING8,    0x805F)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_BL_W  PROP_TAG( PT_MV_UNICODE,    0x805F)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_BL_O  PROP_TAG( PT_OBJECT,        0x805F)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_BL_T  PROP_TAG( PT_MV_TSTRING,    0x805F)
#define PR_EMS_AB_CAN_PRESERVE_DNS           PROP_TAG( PT_BOOLEAN,       0x8060)
#define PR_EMS_AB_CERTIFICATE_REVOCATION_LIST PROP_TAG( PT_BINARY,        0x8016)
#define PR_EMS_AB_CLOCK_ALERT_OFFSET         PROP_TAG( PT_LONG,          0x8061)
#define PR_EMS_AB_CLOCK_ALERT_REPAIR         PROP_TAG( PT_BOOLEAN,       0x8062)
#define PR_EMS_AB_CLOCK_WARNING_OFFSET       PROP_TAG( PT_LONG,          0x8063)
#define PR_EMS_AB_CLOCK_WARNING_REPAIR       PROP_TAG( PT_BOOLEAN,       0x8064)
#define PR_EMS_AB_COMPUTER_NAME              PROP_TAG( PT_TSTRING,       0x8065)
#define PR_EMS_AB_COMPUTER_NAME_A            PROP_TAG( PT_STRING8,       0x8065)
#define PR_EMS_AB_COMPUTER_NAME_W            PROP_TAG( PT_UNICODE,       0x8065)
#define PR_EMS_AB_CONNECTED_DOMAINS          PROP_TAG( PT_MV_TSTRING,    0x8066)
#define PR_EMS_AB_CONNECTED_DOMAINS_A        PROP_TAG( PT_MV_STRING8,    0x8066)
#define PR_EMS_AB_CONNECTED_DOMAINS_W        PROP_TAG( PT_MV_UNICODE,    0x8066)
#define PR_EMS_AB_CONTAINER_INFO             PROP_TAG( PT_LONG,          0x8067)
#define PR_EMS_AB_COST                       PROP_TAG( PT_LONG,          0x8068)
#define PR_EMS_AB_COUNTRY_NAME               PROP_TAG( PT_TSTRING,       0x8069)
#define PR_EMS_AB_COUNTRY_NAME_A             PROP_TAG( PT_STRING8,       0x8069)
#define PR_EMS_AB_COUNTRY_NAME_W             PROP_TAG( PT_UNICODE,       0x8069)
#define PR_EMS_AB_CROSS_CERTIFICATE_PAIR     PROP_TAG( PT_MV_BINARY,     0x8025)
#define PR_EMS_AB_DELIV_CONT_LENGTH          PROP_TAG( PT_LONG,          0x806A)
#define PR_EMS_AB_DELIV_EITS                 PROP_TAG( PT_MV_BINARY,     0x806B)
#define PR_EMS_AB_DELIV_EXT_CONT_TYPES       PROP_TAG( PT_MV_BINARY,     0x806C)
#define PR_EMS_AB_DELIVER_AND_REDIRECT       PROP_TAG( PT_BOOLEAN,       0x806D)
#define PR_EMS_AB_DELIVERY_MECHANISM         PROP_TAG( PT_LONG,          0x806E)
#define PR_EMS_AB_DESCRIPTION                PROP_TAG( PT_MV_TSTRING,    0x806F)
#define PR_EMS_AB_DESCRIPTION_A              PROP_TAG( PT_MV_STRING8,    0x806F)
#define PR_EMS_AB_DESCRIPTION_W              PROP_TAG( PT_MV_UNICODE,    0x806F)
#define PR_EMS_AB_DESTINATION_INDICATOR      PROP_TAG( PT_MV_TSTRING,    0x8070)
#define PR_EMS_AB_DESTINATION_INDICATOR_A    PROP_TAG( PT_MV_STRING8,    0x8070)
#define PR_EMS_AB_DESTINATION_INDICATOR_W    PROP_TAG( PT_MV_UNICODE,    0x8070)
#define PR_EMS_AB_DIAGNOSTIC_REG_KEY         PROP_TAG( PT_TSTRING,       0x8071)
#define PR_EMS_AB_DIAGNOSTIC_REG_KEY_A       PROP_TAG( PT_STRING8,       0x8071)
#define PR_EMS_AB_DIAGNOSTIC_REG_KEY_W       PROP_TAG( PT_UNICODE,       0x8071)
#define PR_EMS_AB_DISPLAY_NAME_OVERRIDE      PROP_TAG( PT_BOOLEAN,       0x8001)
#define PR_EMS_AB_DL_MEM_REJECT_PERMS_BL     PROP_TAG( PT_MV_TSTRING,    0x8072)
#define PR_EMS_AB_DL_MEM_REJECT_PERMS_BL_A   PROP_TAG( PT_MV_STRING8,    0x8072)
#define PR_EMS_AB_DL_MEM_REJECT_PERMS_BL_W   PROP_TAG( PT_MV_UNICODE,    0x8072)
#define PR_EMS_AB_DL_MEM_REJECT_PERMS_BL_O   PROP_TAG( PT_OBJECT,        0x8072)
#define PR_EMS_AB_DL_MEM_REJECT_PERMS_BL_T   PROP_TAG( PT_MV_TSTRING,    0x8072)
#define PR_EMS_AB_DL_MEM_SUBMIT_PERMS_BL     PROP_TAG( PT_MV_TSTRING,    0x8073)
#define PR_EMS_AB_DL_MEM_SUBMIT_PERMS_BL_A   PROP_TAG( PT_MV_STRING8,    0x8073)
#define PR_EMS_AB_DL_MEM_SUBMIT_PERMS_BL_W   PROP_TAG( PT_MV_UNICODE,    0x8073)
#define PR_EMS_AB_DL_MEM_SUBMIT_PERMS_BL_O   PROP_TAG( PT_OBJECT,        0x8073)
#define PR_EMS_AB_DL_MEM_SUBMIT_PERMS_BL_T   PROP_TAG( PT_MV_TSTRING,    0x8073)
#define PR_EMS_AB_DL_MEMBER_RULE             PROP_TAG( PT_MV_BINARY,     0x8074)
#define PR_EMS_AB_DOMAIN_DEF_ALT_RECIP       PROP_TAG( PT_TSTRING,       0x8075)
#define PR_EMS_AB_DOMAIN_DEF_ALT_RECIP_A     PROP_TAG( PT_STRING8,       0x8075)
#define PR_EMS_AB_DOMAIN_DEF_ALT_RECIP_W     PROP_TAG( PT_UNICODE,       0x8075)
#define PR_EMS_AB_DOMAIN_DEF_ALT_RECIP_O     PROP_TAG( PT_OBJECT,        0x8075)
#define PR_EMS_AB_DOMAIN_DEF_ALT_RECIP_T     PROP_TAG( PT_TSTRING,       0x8075)
#define PR_EMS_AB_DOMAIN_NAME                PROP_TAG( PT_TSTRING,       0x8076)
#define PR_EMS_AB_DOMAIN_NAME_A              PROP_TAG( PT_STRING8,       0x8076)
#define PR_EMS_AB_DOMAIN_NAME_W              PROP_TAG( PT_UNICODE,       0x8076)
#define PR_EMS_AB_DSA_SIGNATURE              PROP_TAG( PT_BINARY,        0x8077)
#define PR_EMS_AB_DXA_ADMIN_COPY             PROP_TAG( PT_BOOLEAN,       0x8078)
#define PR_EMS_AB_DXA_ADMIN_FORWARD          PROP_TAG( PT_BOOLEAN,       0x8079)
#define PR_EMS_AB_DXA_ADMIN_UPDATE           PROP_TAG( PT_LONG,          0x807A)
#define PR_EMS_AB_DXA_APPEND_REQCN           PROP_TAG( PT_BOOLEAN,       0x807B)
#define PR_EMS_AB_DXA_CONF_CONTAINER_LIST    PROP_TAG( PT_MV_TSTRING,    0x807C)
#define PR_EMS_AB_DXA_CONF_CONTAINER_LIST_A  PROP_TAG( PT_MV_STRING8,    0x807C)
#define PR_EMS_AB_DXA_CONF_CONTAINER_LIST_W  PROP_TAG( PT_MV_UNICODE,    0x807C)
#define PR_EMS_AB_DXA_CONF_CONTAINER_LIST_O  PROP_TAG( PT_OBJECT,        0x807C)
#define PR_EMS_AB_DXA_CONF_CONTAINER_LIST_T  PROP_TAG( PT_MV_TSTRING,    0x807C)
#define PR_EMS_AB_DXA_CONF_REQ_TIME          PROP_TAG( PT_SYSTIME,       0x807D)
#define PR_EMS_AB_DXA_CONF_SEQ               PROP_TAG( PT_TSTRING,       0x807E)
#define PR_EMS_AB_DXA_CONF_SEQ_A             PROP_TAG( PT_STRING8,       0x807E)
#define PR_EMS_AB_DXA_CONF_SEQ_W             PROP_TAG( PT_UNICODE,       0x807E)
#define PR_EMS_AB_DXA_CONF_SEQ_USN           PROP_TAG( PT_LONG,          0x807F)
#define PR_EMS_AB_DXA_EXCHANGE_OPTIONS       PROP_TAG( PT_LONG,          0x8080)
#define PR_EMS_AB_DXA_EXPORT_NOW             PROP_TAG( PT_BOOLEAN,       0x8081)
#define PR_EMS_AB_DXA_FLAGS                  PROP_TAG( PT_LONG,          0x8082)
#define PR_EMS_AB_DXA_IMP_SEQ                PROP_TAG( PT_TSTRING,       0x8083)
#define PR_EMS_AB_DXA_IMP_SEQ_A              PROP_TAG( PT_STRING8,       0x8083)
#define PR_EMS_AB_DXA_IMP_SEQ_W              PROP_TAG( PT_UNICODE,       0x8083)
#define PR_EMS_AB_DXA_IMP_SEQ_TIME           PROP_TAG( PT_SYSTIME,       0x8084)
#define PR_EMS_AB_DXA_IMP_SEQ_USN            PROP_TAG( PT_LONG,          0x8085)
#define PR_EMS_AB_DXA_IMPORT_NOW             PROP_TAG( PT_BOOLEAN,       0x8086)
#define PR_EMS_AB_DXA_IN_TEMPLATE_MAP        PROP_TAG( PT_MV_TSTRING,    0x8087)
#define PR_EMS_AB_DXA_IN_TEMPLATE_MAP_A      PROP_TAG( PT_MV_STRING8,    0x8087)
#define PR_EMS_AB_DXA_IN_TEMPLATE_MAP_W      PROP_TAG( PT_MV_UNICODE,    0x8087)
#define PR_EMS_AB_DXA_LOCAL_ADMIN            PROP_TAG( PT_TSTRING,       0x8088)
#define PR_EMS_AB_DXA_LOCAL_ADMIN_A          PROP_TAG( PT_STRING8,       0x8088)
#define PR_EMS_AB_DXA_LOCAL_ADMIN_W          PROP_TAG( PT_UNICODE,       0x8088)
#define PR_EMS_AB_DXA_LOCAL_ADMIN_O          PROP_TAG( PT_OBJECT,        0x8088)
#define PR_EMS_AB_DXA_LOCAL_ADMIN_T          PROP_TAG( PT_TSTRING,       0x8088)
#define PR_EMS_AB_DXA_LOGGING_LEVEL          PROP_TAG( PT_LONG,          0x8089)
#define PR_EMS_AB_DXA_NATIVE_ADDRESS_TYPE    PROP_TAG( PT_TSTRING,       0x808A)
#define PR_EMS_AB_DXA_NATIVE_ADDRESS_TYPE_A  PROP_TAG( PT_STRING8,       0x808A)
#define PR_EMS_AB_DXA_NATIVE_ADDRESS_TYPE_W  PROP_TAG( PT_UNICODE,       0x808A)
#define PR_EMS_AB_DXA_OUT_TEMPLATE_MAP       PROP_TAG( PT_MV_TSTRING,    0x808B)
#define PR_EMS_AB_DXA_OUT_TEMPLATE_MAP_A     PROP_TAG( PT_MV_STRING8,    0x808B)
#define PR_EMS_AB_DXA_OUT_TEMPLATE_MAP_W     PROP_TAG( PT_MV_UNICODE,    0x808B)
#define PR_EMS_AB_DXA_PASSWORD               PROP_TAG( PT_TSTRING,       0x808C)
#define PR_EMS_AB_DXA_PASSWORD_A             PROP_TAG( PT_STRING8,       0x808C)
#define PR_EMS_AB_DXA_PASSWORD_W             PROP_TAG( PT_UNICODE,       0x808C)
#define PR_EMS_AB_DXA_PREV_EXCHANGE_OPTIONS  PROP_TAG( PT_LONG,          0x808D)
#define PR_EMS_AB_DXA_PREV_EXPORT_NATIVE_ONLY PROP_TAG( PT_BOOLEAN,       0x808E)
#define PR_EMS_AB_DXA_PREV_IN_EXCHANGE_SENSITIVITY PROP_TAG( PT_LONG,          0x808F)
#define PR_EMS_AB_DXA_PREV_REMOTE_ENTRIES    PROP_TAG( PT_TSTRING,       0x8090)
#define PR_EMS_AB_DXA_PREV_REMOTE_ENTRIES_A  PROP_TAG( PT_STRING8,       0x8090)
#define PR_EMS_AB_DXA_PREV_REMOTE_ENTRIES_W  PROP_TAG( PT_UNICODE,       0x8090)
#define PR_EMS_AB_DXA_PREV_REMOTE_ENTRIES_O  PROP_TAG( PT_OBJECT,        0x8090)
#define PR_EMS_AB_DXA_PREV_REMOTE_ENTRIES_T  PROP_TAG( PT_TSTRING,       0x8090)
#define PR_EMS_AB_DXA_PREV_REPLICATION_SENSITIVITY PROP_TAG( PT_LONG,          0x8091)
#define PR_EMS_AB_DXA_PREV_TEMPLATE_OPTIONS  PROP_TAG( PT_LONG,          0x8092)
#define PR_EMS_AB_DXA_PREV_TYPES             PROP_TAG( PT_LONG,          0x8093)
#define PR_EMS_AB_DXA_RECIPIENT_CP           PROP_TAG( PT_TSTRING,       0x8094)
#define PR_EMS_AB_DXA_RECIPIENT_CP_A         PROP_TAG( PT_STRING8,       0x8094)
#define PR_EMS_AB_DXA_RECIPIENT_CP_W         PROP_TAG( PT_UNICODE,       0x8094)
#define PR_EMS_AB_DXA_REMOTE_CLIENT          PROP_TAG( PT_TSTRING,       0x8095)
#define PR_EMS_AB_DXA_REMOTE_CLIENT_A        PROP_TAG( PT_STRING8,       0x8095)
#define PR_EMS_AB_DXA_REMOTE_CLIENT_W        PROP_TAG( PT_UNICODE,       0x8095)
#define PR_EMS_AB_DXA_REMOTE_CLIENT_O        PROP_TAG( PT_OBJECT,        0x8095)
#define PR_EMS_AB_DXA_REMOTE_CLIENT_T        PROP_TAG( PT_TSTRING,       0x8095)
#define PR_EMS_AB_DXA_REQ_SEQ                PROP_TAG( PT_TSTRING,       0x8096)
#define PR_EMS_AB_DXA_REQ_SEQ_A              PROP_TAG( PT_STRING8,       0x8096)
#define PR_EMS_AB_DXA_REQ_SEQ_W              PROP_TAG( PT_UNICODE,       0x8096)
#define PR_EMS_AB_DXA_REQ_SEQ_TIME           PROP_TAG( PT_SYSTIME,       0x8097)
#define PR_EMS_AB_DXA_REQ_SEQ_USN            PROP_TAG( PT_LONG,          0x8098)
#define PR_EMS_AB_DXA_REQNAME                PROP_TAG( PT_TSTRING,       0x8099)
#define PR_EMS_AB_DXA_REQNAME_A              PROP_TAG( PT_STRING8,       0x8099)
#define PR_EMS_AB_DXA_REQNAME_W              PROP_TAG( PT_UNICODE,       0x8099)
#define PR_EMS_AB_DXA_SVR_SEQ                PROP_TAG( PT_TSTRING,       0x809A)
#define PR_EMS_AB_DXA_SVR_SEQ_A              PROP_TAG( PT_STRING8,       0x809A)
#define PR_EMS_AB_DXA_SVR_SEQ_W              PROP_TAG( PT_UNICODE,       0x809A)
#define PR_EMS_AB_DXA_SVR_SEQ_TIME           PROP_TAG( PT_SYSTIME,       0x809B)
#define PR_EMS_AB_DXA_SVR_SEQ_USN            PROP_TAG( PT_LONG,          0x809C)
#define PR_EMS_AB_DXA_TASK                   PROP_TAG( PT_LONG,          0x809D)
#define PR_EMS_AB_DXA_TEMPLATE_OPTIONS       PROP_TAG( PT_LONG,          0x809E)
#define PR_EMS_AB_DXA_TEMPLATE_TIMESTAMP     PROP_TAG( PT_SYSTIME,       0x809F)
#define PR_EMS_AB_DXA_TYPES                  PROP_TAG( PT_LONG,          0x80A0)
#define PR_EMS_AB_DXA_UNCONF_CONTAINER_LIST  PROP_TAG( PT_MV_TSTRING,    0x80A1)
#define PR_EMS_AB_DXA_UNCONF_CONTAINER_LIST_A PROP_TAG( PT_MV_STRING8,    0x80A1)
#define PR_EMS_AB_DXA_UNCONF_CONTAINER_LIST_W PROP_TAG( PT_MV_UNICODE,    0x80A1)
#define PR_EMS_AB_DXA_UNCONF_CONTAINER_LIST_O PROP_TAG( PT_OBJECT,        0x80A1)
#define PR_EMS_AB_DXA_UNCONF_CONTAINER_LIST_T PROP_TAG( PT_MV_TSTRING,    0x80A1)
#define PR_EMS_AB_ENABLED_PROTOCOLS          PROP_TAG( PT_LONG,          0x817F)
#define PR_EMS_AB_ENCAPSULATION_METHOD       PROP_TAG( PT_LONG,          0x80A2)
#define PR_EMS_AB_ENCRYPT                    PROP_TAG( PT_BOOLEAN,       0x80A3)
#define PR_EMS_AB_ENCRYPT_ALG_LIST_NA        PROP_TAG( PT_MV_TSTRING,    0x8040)
#define PR_EMS_AB_ENCRYPT_ALG_LIST_NA_A      PROP_TAG( PT_MV_STRING8,    0x8040)
#define PR_EMS_AB_ENCRYPT_ALG_LIST_NA_W      PROP_TAG( PT_MV_UNICODE,    0x8040)
#define PR_EMS_AB_ENCRYPT_ALG_LIST_OTHER     PROP_TAG( PT_MV_TSTRING,    0x8041)
#define PR_EMS_AB_ENCRYPT_ALG_LIST_OTHER_A   PROP_TAG( PT_MV_STRING8,    0x8041)
#define PR_EMS_AB_ENCRYPT_ALG_LIST_OTHER_W   PROP_TAG( PT_MV_UNICODE,    0x8041)
#define PR_EMS_AB_ENCRYPT_ALG_SELECTED_NA    PROP_TAG( PT_TSTRING,       0x8043)
#define PR_EMS_AB_ENCRYPT_ALG_SELECTED_NA_A  PROP_TAG( PT_STRING8,       0x8043)
#define PR_EMS_AB_ENCRYPT_ALG_SELECTED_NA_W  PROP_TAG( PT_UNICODE,       0x8043)
#define PR_EMS_AB_ENCRYPT_ALG_SELECTED_OTHER PROP_TAG( PT_TSTRING,       0x803D)
#define PR_EMS_AB_ENCRYPT_ALG_SELECTED_OTHER_A PROP_TAG( PT_STRING8,       0x803D)
#define PR_EMS_AB_ENCRYPT_ALG_SELECTED_OTHER_W PROP_TAG( PT_UNICODE,       0x803D)
#define PR_EMS_AB_EXPAND_DLS_LOCALLY         PROP_TAG( PT_BOOLEAN,       0x80A4)
#define PR_EMS_AB_EXPIRATION_TIME            PROP_TAG( PT_SYSTIME,       0x8028)
#define PR_EMS_AB_EXPORT_CONTAINERS          PROP_TAG( PT_MV_TSTRING,    0x80A5)
#define PR_EMS_AB_EXPORT_CONTAINERS_A        PROP_TAG( PT_MV_STRING8,    0x80A5)
#define PR_EMS_AB_EXPORT_CONTAINERS_W        PROP_TAG( PT_MV_UNICODE,    0x80A5)
#define PR_EMS_AB_EXPORT_CONTAINERS_O        PROP_TAG( PT_OBJECT,        0x80A5)
#define PR_EMS_AB_EXPORT_CONTAINERS_T        PROP_TAG( PT_MV_TSTRING,    0x80A5)
#define PR_EMS_AB_EXPORT_CUSTOM_RECIPIENTS   PROP_TAG( PT_BOOLEAN,       0x80A6)
#define PR_EMS_AB_EXTENDED_CHARS_ALLOWED     PROP_TAG( PT_BOOLEAN,       0x80A7)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_1      PROP_TAG( PT_TSTRING,       0x802D)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_1_A    PROP_TAG( PT_STRING8,       0x802D)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_1_W    PROP_TAG( PT_UNICODE,       0x802D)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_10     PROP_TAG( PT_TSTRING,       0x8036)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_10_A   PROP_TAG( PT_STRING8,       0x8036)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_10_W   PROP_TAG( PT_UNICODE,       0x8036)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_2      PROP_TAG( PT_TSTRING,       0x802E)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_2_A    PROP_TAG( PT_STRING8,       0x802E)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_2_W    PROP_TAG( PT_UNICODE,       0x802E)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_3      PROP_TAG( PT_TSTRING,       0x802F)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_3_A    PROP_TAG( PT_STRING8,       0x802F)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_3_W    PROP_TAG( PT_UNICODE,       0x802F)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_4      PROP_TAG( PT_TSTRING,       0x8030)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_4_A    PROP_TAG( PT_STRING8,       0x8030)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_4_W    PROP_TAG( PT_UNICODE,       0x8030)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_5      PROP_TAG( PT_TSTRING,       0x8031)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_5_A    PROP_TAG( PT_STRING8,       0x8031)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_5_W    PROP_TAG( PT_UNICODE,       0x8031)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_6      PROP_TAG( PT_TSTRING,       0x8032)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_6_A    PROP_TAG( PT_STRING8,       0x8032)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_6_W    PROP_TAG( PT_UNICODE,       0x8032)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_7      PROP_TAG( PT_TSTRING,       0x8033)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_7_A    PROP_TAG( PT_STRING8,       0x8033)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_7_W    PROP_TAG( PT_UNICODE,       0x8033)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_8      PROP_TAG( PT_TSTRING,       0x8034)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_8_A    PROP_TAG( PT_STRING8,       0x8034)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_8_W    PROP_TAG( PT_UNICODE,       0x8034)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_9      PROP_TAG( PT_TSTRING,       0x8035)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_9_A    PROP_TAG( PT_STRING8,       0x8035)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_9_W    PROP_TAG( PT_UNICODE,       0x8035)
#define PR_EMS_AB_EXTENSION_DATA             PROP_TAG( PT_MV_BINARY,     0x80A8)
#define PR_EMS_AB_EXTENSION_NAME             PROP_TAG( PT_MV_TSTRING,    0x80A9)
#define PR_EMS_AB_EXTENSION_NAME_A           PROP_TAG( PT_MV_STRING8,    0x80A9)
#define PR_EMS_AB_EXTENSION_NAME_W           PROP_TAG( PT_MV_UNICODE,    0x80A9)
#define PR_EMS_AB_EXTENSION_NAME_INHERITED   PROP_TAG( PT_MV_TSTRING,    0x80AA)
#define PR_EMS_AB_EXTENSION_NAME_INHERITED_A PROP_TAG( PT_MV_STRING8,    0x80AA)
#define PR_EMS_AB_EXTENSION_NAME_INHERITED_W PROP_TAG( PT_MV_UNICODE,    0x80AA)
#define PR_EMS_AB_FACSIMILE_TELEPHONE_NUMBER PROP_TAG( PT_MV_BINARY,     0x80AB)
#define PR_EMS_AB_FILE_VERSION               PROP_TAG( PT_BINARY,        0x80AC)
#define PR_EMS_AB_FILTER_LOCAL_ADDRESSES     PROP_TAG( PT_BOOLEAN,       0x80AD)
#define PR_EMS_AB_FOLDER_PATHNAME            PROP_TAG( PT_TSTRING,       0x8004)
#define PR_EMS_AB_FOLDER_PATHNAME_A          PROP_TAG( PT_STRING8,       0x8004)
#define PR_EMS_AB_FOLDER_PATHNAME_W          PROP_TAG( PT_UNICODE,       0x8004)
#define PR_EMS_AB_FOLDERS_CONTAINER          PROP_TAG( PT_TSTRING,       0x80AE)
#define PR_EMS_AB_FOLDERS_CONTAINER_A        PROP_TAG( PT_STRING8,       0x80AE)
#define PR_EMS_AB_FOLDERS_CONTAINER_W        PROP_TAG( PT_UNICODE,       0x80AE)
#define PR_EMS_AB_FOLDERS_CONTAINER_O        PROP_TAG( PT_OBJECT,        0x80AE)
#define PR_EMS_AB_FOLDERS_CONTAINER_T        PROP_TAG( PT_TSTRING,       0x80AE)
#define PR_EMS_AB_GARBAGE_COLL_PERIOD        PROP_TAG( PT_LONG,          0x80AF)
#define PR_EMS_AB_GATEWAY_LOCAL_CRED         PROP_TAG( PT_TSTRING,       0x80B0)
#define PR_EMS_AB_GATEWAY_LOCAL_CRED_A       PROP_TAG( PT_STRING8,       0x80B0)
#define PR_EMS_AB_GATEWAY_LOCAL_CRED_W       PROP_TAG( PT_UNICODE,       0x80B0)
#define PR_EMS_AB_GATEWAY_LOCAL_DESIG        PROP_TAG( PT_TSTRING,       0x80B1)
#define PR_EMS_AB_GATEWAY_LOCAL_DESIG_A      PROP_TAG( PT_STRING8,       0x80B1)
#define PR_EMS_AB_GATEWAY_LOCAL_DESIG_W      PROP_TAG( PT_UNICODE,       0x80B1)
#define PR_EMS_AB_GATEWAY_PROXY              PROP_TAG( PT_MV_TSTRING,    0x80B2)
#define PR_EMS_AB_GATEWAY_PROXY_A            PROP_TAG( PT_MV_STRING8,    0x80B2)
#define PR_EMS_AB_GATEWAY_PROXY_W            PROP_TAG( PT_MV_UNICODE,    0x80B2)
#define PR_EMS_AB_GATEWAY_ROUTING_TREE       PROP_TAG( PT_BINARY,        0x80B3)
#define PR_EMS_AB_GWART_LAST_MODIFIED        PROP_TAG( PT_SYSTIME,       0x80B4)
#define PR_EMS_AB_HAS_FULL_REPLICA_NCS       PROP_TAG( PT_MV_TSTRING,    0x80B5)
#define PR_EMS_AB_HAS_FULL_REPLICA_NCS_A     PROP_TAG( PT_MV_STRING8,    0x80B5)
#define PR_EMS_AB_HAS_FULL_REPLICA_NCS_W     PROP_TAG( PT_MV_UNICODE,    0x80B5)
#define PR_EMS_AB_HAS_FULL_REPLICA_NCS_O     PROP_TAG( PT_OBJECT,        0x80B5)
#define PR_EMS_AB_HAS_FULL_REPLICA_NCS_T     PROP_TAG( PT_MV_TSTRING,    0x80B5)
#define PR_EMS_AB_HAS_MASTER_NCS             PROP_TAG( PT_MV_TSTRING,    0x80B6)
#define PR_EMS_AB_HAS_MASTER_NCS_A           PROP_TAG( PT_MV_STRING8,    0x80B6)
#define PR_EMS_AB_HAS_MASTER_NCS_W           PROP_TAG( PT_MV_UNICODE,    0x80B6)
#define PR_EMS_AB_HAS_MASTER_NCS_O           PROP_TAG( PT_OBJECT,        0x80B6)
#define PR_EMS_AB_HAS_MASTER_NCS_T           PROP_TAG( PT_MV_TSTRING,    0x80B6)
#define PR_EMS_AB_HELP_DATA16                PROP_TAG( PT_BINARY,        0x803A)
#define PR_EMS_AB_HELP_DATA32                PROP_TAG( PT_BINARY,        0x8010)
#define PR_EMS_AB_HELP_FILE_NAME             PROP_TAG( PT_TSTRING,       0x803B)
#define PR_EMS_AB_HELP_FILE_NAME_A           PROP_TAG( PT_STRING8,       0x803B)
#define PR_EMS_AB_HELP_FILE_NAME_W           PROP_TAG( PT_UNICODE,       0x803B)
#define PR_EMS_AB_HEURISTICS                 PROP_TAG( PT_LONG,          0x80B7)
#define PR_EMS_AB_HIDE_DL_MEMBERSHIP         PROP_TAG( PT_BOOLEAN,       0x80B8)
#define PR_EMS_AB_HIDE_FROM_ADDRESS_BOOK     PROP_TAG( PT_BOOLEAN,       0x80B9)
#define PR_EMS_AB_HOME_MDB                   PROP_TAG( PT_TSTRING,       0x8006)
#define PR_EMS_AB_HOME_MDB_A                 PROP_TAG( PT_STRING8,       0x8006)
#define PR_EMS_AB_HOME_MDB_W                 PROP_TAG( PT_UNICODE,       0x8006)
#define PR_EMS_AB_HOME_MDB_O                 PROP_TAG( PT_OBJECT,        0x8006)
#define PR_EMS_AB_HOME_MDB_T                 PROP_TAG( PT_TSTRING,       0x8006)
#define PR_EMS_AB_HOME_MDB_BL                PROP_TAG( PT_MV_TSTRING,    0x8014)
#define PR_EMS_AB_HOME_MDB_BL_A              PROP_TAG( PT_MV_STRING8,    0x8014)
#define PR_EMS_AB_HOME_MDB_BL_W              PROP_TAG( PT_MV_UNICODE,    0x8014)
#define PR_EMS_AB_HOME_MDB_BL_O              PROP_TAG( PT_OBJECT,        0x8014)
#define PR_EMS_AB_HOME_MDB_BL_T              PROP_TAG( PT_MV_TSTRING,    0x8014)
#define PR_EMS_AB_HOME_MTA                   PROP_TAG( PT_TSTRING,       0x8007)
#define PR_EMS_AB_HOME_MTA_A                 PROP_TAG( PT_STRING8,       0x8007)
#define PR_EMS_AB_HOME_MTA_W                 PROP_TAG( PT_UNICODE,       0x8007)
#define PR_EMS_AB_HOME_MTA_O                 PROP_TAG( PT_OBJECT,        0x8007)
#define PR_EMS_AB_HOME_MTA_T                 PROP_TAG( PT_TSTRING,       0x8007)
#define PR_EMS_AB_HOME_PUBLIC_SERVER         PROP_TAG( PT_TSTRING,       0x803F)
#define PR_EMS_AB_HOME_PUBLIC_SERVER_A       PROP_TAG( PT_STRING8,       0x803F)
#define PR_EMS_AB_HOME_PUBLIC_SERVER_W       PROP_TAG( PT_UNICODE,       0x803F)
#define PR_EMS_AB_HOME_PUBLIC_SERVER_O       PROP_TAG( PT_OBJECT,        0x803F)
#define PR_EMS_AB_HOME_PUBLIC_SERVER_T       PROP_TAG( PT_TSTRING,       0x803F)
#define PR_EMS_AB_IMPORT_CONTAINER           PROP_TAG( PT_TSTRING,       0x80BA)
#define PR_EMS_AB_IMPORT_CONTAINER_A         PROP_TAG( PT_STRING8,       0x80BA)
#define PR_EMS_AB_IMPORT_CONTAINER_W         PROP_TAG( PT_UNICODE,       0x80BA)
#define PR_EMS_AB_IMPORT_CONTAINER_O         PROP_TAG( PT_OBJECT,        0x80BA)
#define PR_EMS_AB_IMPORT_CONTAINER_T         PROP_TAG( PT_TSTRING,       0x80BA)
#define PR_EMS_AB_IMPORT_SENSITIVITY         PROP_TAG( PT_LONG,          0x80BB)
#define PR_EMS_AB_IMPORTED_FROM              PROP_TAG( PT_TSTRING,       0x8042)
#define PR_EMS_AB_IMPORTED_FROM_A            PROP_TAG( PT_STRING8,       0x8042)
#define PR_EMS_AB_IMPORTED_FROM_W            PROP_TAG( PT_UNICODE,       0x8042)
#define PR_EMS_AB_INBOUND_SITES              PROP_TAG( PT_MV_TSTRING,    0x80BC)
#define PR_EMS_AB_INBOUND_SITES_A            PROP_TAG( PT_MV_STRING8,    0x80BC)
#define PR_EMS_AB_INBOUND_SITES_W            PROP_TAG( PT_MV_UNICODE,    0x80BC)
#define PR_EMS_AB_INBOUND_SITES_O            PROP_TAG( PT_OBJECT,        0x80BC)
#define PR_EMS_AB_INBOUND_SITES_T            PROP_TAG( PT_MV_TSTRING,    0x80BC)
#define PR_EMS_AB_INSTANCE_TYPE              PROP_TAG( PT_LONG,          0x80BD)
#define PR_EMS_AB_INTERNATIONAL_ISDN_NUMBER  PROP_TAG( PT_MV_TSTRING,    0x80BE)
#define PR_EMS_AB_INTERNATIONAL_ISDN_NUMBER_A PROP_TAG( PT_MV_STRING8,    0x80BE)
#define PR_EMS_AB_INTERNATIONAL_ISDN_NUMBER_W PROP_TAG( PT_MV_UNICODE,    0x80BE)
#define PR_EMS_AB_INVOCATION_ID              PROP_TAG( PT_BINARY,        0x80BF)
#define PR_EMS_AB_IS_DELETED                 PROP_TAG( PT_BOOLEAN,       0x80C0)
#define PR_EMS_AB_IS_MEMBER_OF_DL            PROP_TAG( PT_OBJECT,	 0x8008)
#define PR_EMS_AB_IS_MEMBER_OF_DL_A          PROP_TAG( PT_MV_STRING8,    0x8008)
#define PR_EMS_AB_IS_MEMBER_OF_DL_W          PROP_TAG( PT_MV_UNICODE,    0x8008)
#define PR_EMS_AB_IS_MEMBER_OF_DL_O          PROP_TAG( PT_OBJECT,        0x8008)
#define PR_EMS_AB_IS_MEMBER_OF_DL_T          PROP_TAG( PT_MV_TSTRING,    0x8008)
#define PR_EMS_AB_IS_SINGLE_VALUED           PROP_TAG( PT_BOOLEAN,       0x80C1)
#define PR_EMS_AB_KCC_STATUS                 PROP_TAG( PT_MV_BINARY,     0x80C2)
#define PR_EMS_AB_KM_SERVER                  PROP_TAG( PT_TSTRING,       0x800D)
#define PR_EMS_AB_KM_SERVER_A                PROP_TAG( PT_STRING8,       0x800D)
#define PR_EMS_AB_KM_SERVER_W                PROP_TAG( PT_UNICODE,       0x800D)
#define PR_EMS_AB_KM_SERVER_O                PROP_TAG( PT_OBJECT,        0x800D)
#define PR_EMS_AB_KM_SERVER_T                PROP_TAG( PT_TSTRING,       0x800D)
#define PR_EMS_AB_KNOWLEDGE_INFORMATION      PROP_TAG( PT_MV_TSTRING,    0x80C3)
#define PR_EMS_AB_KNOWLEDGE_INFORMATION_A    PROP_TAG( PT_MV_STRING8,    0x80C3)
#define PR_EMS_AB_KNOWLEDGE_INFORMATION_W    PROP_TAG( PT_MV_UNICODE,    0x80C3)
#define PR_EMS_AB_LANGUAGE                   PROP_TAG( PT_LONG,          0x8178)
#define PR_EMS_AB_LDAP_DISPLAY_NAME          PROP_TAG( PT_MV_TSTRING,    0x8171)
#define PR_EMS_AB_LDAP_DISPLAY_NAME_A        PROP_TAG( PT_MV_STRING8,    0x8171)
#define PR_EMS_AB_LDAP_DISPLAY_NAME_W        PROP_TAG( PT_MV_UNICODE,    0x8171)
#define PR_EMS_AB_LINE_WRAP                  PROP_TAG( PT_LONG,          0x80C4)
#define PR_EMS_AB_LINK_ID                    PROP_TAG( PT_LONG,          0x80C5)
#define PR_EMS_AB_LOCAL_BRIDGE_HEAD          PROP_TAG( PT_TSTRING,       0x80C6)
#define PR_EMS_AB_LOCAL_BRIDGE_HEAD_A        PROP_TAG( PT_STRING8,       0x80C6)
#define PR_EMS_AB_LOCAL_BRIDGE_HEAD_W        PROP_TAG( PT_UNICODE,       0x80C6)
#define PR_EMS_AB_LOCAL_BRIDGE_HEAD_ADDRESS  PROP_TAG( PT_TSTRING,       0x80C7)
#define PR_EMS_AB_LOCAL_BRIDGE_HEAD_ADDRESS_A PROP_TAG( PT_STRING8,       0x80C7)
#define PR_EMS_AB_LOCAL_BRIDGE_HEAD_ADDRESS_W PROP_TAG( PT_UNICODE,       0x80C7)
#define PR_EMS_AB_LOCAL_INITIAL_TURN         PROP_TAG( PT_BOOLEAN,       0x80C8)
#define PR_EMS_AB_LOCAL_SCOPE                PROP_TAG( PT_MV_TSTRING,    0x80C9)
#define PR_EMS_AB_LOCAL_SCOPE_A              PROP_TAG( PT_MV_STRING8,    0x80C9)
#define PR_EMS_AB_LOCAL_SCOPE_W              PROP_TAG( PT_MV_UNICODE,    0x80C9)
#define PR_EMS_AB_LOCAL_SCOPE_O              PROP_TAG( PT_OBJECT,        0x80C9)
#define PR_EMS_AB_LOCAL_SCOPE_T              PROP_TAG( PT_MV_TSTRING,    0x80C9)
#define PR_EMS_AB_LOG_FILENAME               PROP_TAG( PT_TSTRING,       0x80CA)
#define PR_EMS_AB_LOG_FILENAME_A             PROP_TAG( PT_STRING8,       0x80CA)
#define PR_EMS_AB_LOG_FILENAME_W             PROP_TAG( PT_UNICODE,       0x80CA)
#define PR_EMS_AB_LOG_ROLLOVER_INTERVAL      PROP_TAG( PT_LONG,          0x80CB)
#define PR_EMS_AB_MAINTAIN_AUTOREPLY_HISTORY PROP_TAG( PT_BOOLEAN,       0x80CC)
#define PR_EMS_AB_MANAGER                    PROP_TAG( PT_OBJECT,        0x8005)
#define PR_EMS_AB_MANAGER_A                  PROP_TAG( PT_STRING8,       0x8005)
#define PR_EMS_AB_MANAGER_W                  PROP_TAG( PT_UNICODE,       0x8005)
#define PR_EMS_AB_MANAGER_O                  PROP_TAG( PT_OBJECT,        0x8005)
#define PR_EMS_AB_MANAGER_T                  PROP_TAG( PT_TSTRING,       0x8005)
#define PR_EMS_AB_MAPI_DISPLAY_TYPE          PROP_TAG( PT_LONG,          0x80CD)
#define PR_EMS_AB_MAPI_ID                    PROP_TAG( PT_LONG,          0x80CE)
#define PR_EMS_AB_MAXIMUM_OBJECT_ID          PROP_TAG( PT_BINARY,        0x8169)
#define PR_EMS_AB_MDB_BACKOFF_INTERVAL       PROP_TAG( PT_LONG,          0x80CF)
#define PR_EMS_AB_MDB_MSG_TIME_OUT_PERIOD    PROP_TAG( PT_LONG,          0x80D0)
#define PR_EMS_AB_MDB_OVER_QUOTA_LIMIT       PROP_TAG( PT_LONG,          0x80D1)
#define PR_EMS_AB_MDB_STORAGE_QUOTA          PROP_TAG( PT_LONG,          0x80D2)
#define PR_EMS_AB_MDB_UNREAD_LIMIT           PROP_TAG( PT_LONG,          0x80D3)
#define PR_EMS_AB_MDB_USE_DEFAULTS           PROP_TAG( PT_BOOLEAN,       0x80D4)
#define PR_EMS_AB_MEMBER                     PROP_TAG( PT_OBJECT,        0x8009)
#define PR_EMS_AB_MEMBER_A                   PROP_TAG( PT_MV_STRING8,    0x8009)
#define PR_EMS_AB_MEMBER_W                   PROP_TAG( PT_MV_UNICODE,    0x8009)
#define PR_EMS_AB_MEMBER_O                   PROP_TAG( PT_OBJECT,        0x8009)
#define PR_EMS_AB_MEMBER_T                   PROP_TAG( PT_MV_TSTRING,    0x8009)
#define PR_EMS_AB_MESSAGE_TRACKING_ENABLED   PROP_TAG( PT_BOOLEAN,       0x80D5)
#define PR_EMS_AB_MONITOR_CLOCK              PROP_TAG( PT_BOOLEAN,       0x80D6)
#define PR_EMS_AB_MONITOR_SERVERS            PROP_TAG( PT_BOOLEAN,       0x80D7)
#define PR_EMS_AB_MONITOR_SERVICES           PROP_TAG( PT_BOOLEAN,       0x80D8)
#define PR_EMS_AB_MONITORED_CONFIGURATIONS   PROP_TAG( PT_MV_TSTRING,    0x80D9)
#define PR_EMS_AB_MONITORED_CONFIGURATIONS_A PROP_TAG( PT_MV_STRING8,    0x80D9)
#define PR_EMS_AB_MONITORED_CONFIGURATIONS_W PROP_TAG( PT_MV_UNICODE,    0x80D9)
#define PR_EMS_AB_MONITORED_CONFIGURATIONS_O PROP_TAG( PT_OBJECT,        0x80D9)
#define PR_EMS_AB_MONITORED_CONFIGURATIONS_T PROP_TAG( PT_MV_TSTRING,    0x80D9)
#define PR_EMS_AB_MONITORED_SERVERS          PROP_TAG( PT_MV_TSTRING,    0x80DA)
#define PR_EMS_AB_MONITORED_SERVERS_A        PROP_TAG( PT_MV_STRING8,    0x80DA)
#define PR_EMS_AB_MONITORED_SERVERS_W        PROP_TAG( PT_MV_UNICODE,    0x80DA)
#define PR_EMS_AB_MONITORED_SERVERS_O        PROP_TAG( PT_OBJECT,        0x80DA)
#define PR_EMS_AB_MONITORED_SERVERS_T        PROP_TAG( PT_MV_TSTRING,    0x80DA)
#define PR_EMS_AB_MONITORED_SERVICES         PROP_TAG( PT_MV_TSTRING,    0x80DB)
#define PR_EMS_AB_MONITORED_SERVICES_A       PROP_TAG( PT_MV_STRING8,    0x80DB)
#define PR_EMS_AB_MONITORED_SERVICES_W       PROP_TAG( PT_MV_UNICODE,    0x80DB)
#define PR_EMS_AB_MONITORING_ALERT_DELAY     PROP_TAG( PT_LONG,          0x80DC)
#define PR_EMS_AB_MONITORING_ALERT_UNITS     PROP_TAG( PT_LONG,          0x80DD)
#define PR_EMS_AB_MONITORING_AVAILABILITY_STYLE PROP_TAG( PT_LONG,          0x80DE)
#define PR_EMS_AB_MONITORING_AVAILABILITY_WINDOW PROP_TAG( PT_BINARY,        0x80DF)
#define PR_EMS_AB_MONITORING_CACHED_VIA_MAIL PROP_TAG( PT_MV_TSTRING,    0x80E0)
#define PR_EMS_AB_MONITORING_CACHED_VIA_MAIL_A PROP_TAG( PT_MV_STRING8,    0x80E0)
#define PR_EMS_AB_MONITORING_CACHED_VIA_MAIL_W PROP_TAG( PT_MV_UNICODE,    0x80E0)
#define PR_EMS_AB_MONITORING_CACHED_VIA_MAIL_O PROP_TAG( PT_OBJECT,        0x80E0)
#define PR_EMS_AB_MONITORING_CACHED_VIA_MAIL_T PROP_TAG( PT_MV_TSTRING,    0x80E0)
#define PR_EMS_AB_MONITORING_CACHED_VIA_RPC  PROP_TAG( PT_MV_TSTRING,    0x80E1)
#define PR_EMS_AB_MONITORING_CACHED_VIA_RPC_A PROP_TAG( PT_MV_STRING8,    0x80E1)
#define PR_EMS_AB_MONITORING_CACHED_VIA_RPC_W PROP_TAG( PT_MV_UNICODE,    0x80E1)
#define PR_EMS_AB_MONITORING_CACHED_VIA_RPC_O PROP_TAG( PT_OBJECT,        0x80E1)
#define PR_EMS_AB_MONITORING_CACHED_VIA_RPC_T PROP_TAG( PT_MV_TSTRING,    0x80E1)
#define PR_EMS_AB_MONITORING_ESCALATION_PROCEDURE PROP_TAG( PT_MV_BINARY,     0x80E2)
#define PR_EMS_AB_MONITORING_HOTSITE_POLL_INTERVAL PROP_TAG( PT_LONG,          0x80E3)
#define PR_EMS_AB_MONITORING_HOTSITE_POLL_UNITS PROP_TAG( PT_LONG,          0x80E4)
#define PR_EMS_AB_MONITORING_MAIL_UPDATE_INTERVAL PROP_TAG( PT_LONG,          0x80E5)
#define PR_EMS_AB_MONITORING_MAIL_UPDATE_UNITS PROP_TAG( PT_LONG,          0x80E6)
#define PR_EMS_AB_MONITORING_NORMAL_POLL_INTERVAL PROP_TAG( PT_LONG,          0x80E7)
#define PR_EMS_AB_MONITORING_NORMAL_POLL_UNITS PROP_TAG( PT_LONG,          0x80E8)
#define PR_EMS_AB_MONITORING_RECIPIENTS      PROP_TAG( PT_MV_TSTRING,    0x80E9)
#define PR_EMS_AB_MONITORING_RECIPIENTS_A    PROP_TAG( PT_MV_STRING8,    0x80E9)
#define PR_EMS_AB_MONITORING_RECIPIENTS_W    PROP_TAG( PT_MV_UNICODE,    0x80E9)
#define PR_EMS_AB_MONITORING_RECIPIENTS_O    PROP_TAG( PT_OBJECT,        0x80E9)
#define PR_EMS_AB_MONITORING_RECIPIENTS_T    PROP_TAG( PT_MV_TSTRING,    0x80E9)
#define PR_EMS_AB_MONITORING_RECIPIENTS_NDR  PROP_TAG( PT_MV_TSTRING,    0x80EA)
#define PR_EMS_AB_MONITORING_RECIPIENTS_NDR_A PROP_TAG( PT_MV_STRING8,    0x80EA)
#define PR_EMS_AB_MONITORING_RECIPIENTS_NDR_W PROP_TAG( PT_MV_UNICODE,    0x80EA)
#define PR_EMS_AB_MONITORING_RECIPIENTS_NDR_O PROP_TAG( PT_OBJECT,        0x80EA)
#define PR_EMS_AB_MONITORING_RECIPIENTS_NDR_T PROP_TAG( PT_MV_TSTRING,    0x80EA)
#define PR_EMS_AB_MONITORING_RPC_UPDATE_INTERVAL PROP_TAG( PT_LONG,          0x80EB)
#define PR_EMS_AB_MONITORING_RPC_UPDATE_UNITS PROP_TAG( PT_LONG,          0x80EC)
#define PR_EMS_AB_MONITORING_WARNING_DELAY   PROP_TAG( PT_LONG,          0x80ED)
#define PR_EMS_AB_MONITORING_WARNING_UNITS   PROP_TAG( PT_LONG,          0x80EE)
#define PR_EMS_AB_MTA_LOCAL_CRED             PROP_TAG( PT_TSTRING,       0x80EF)
#define PR_EMS_AB_MTA_LOCAL_CRED_A           PROP_TAG( PT_STRING8,       0x80EF)
#define PR_EMS_AB_MTA_LOCAL_CRED_W           PROP_TAG( PT_UNICODE,       0x80EF)
#define PR_EMS_AB_MTA_LOCAL_DESIG            PROP_TAG( PT_TSTRING,       0x80F0)
#define PR_EMS_AB_MTA_LOCAL_DESIG_A          PROP_TAG( PT_STRING8,       0x80F0)
#define PR_EMS_AB_MTA_LOCAL_DESIG_W          PROP_TAG( PT_UNICODE,       0x80F0)
#define PR_EMS_AB_N_ADDRESS                  PROP_TAG( PT_BINARY,        0x80F1)
#define PR_EMS_AB_N_ADDRESS_TYPE             PROP_TAG( PT_LONG,          0x80F2)
#define PR_EMS_AB_NETWORK_ADDRESS            PROP_TAG( PT_MV_TSTRING,    0x8170)
#define PR_EMS_AB_NETWORK_ADDRESS_A          PROP_TAG( PT_MV_STRING8,    0x8170)
#define PR_EMS_AB_NETWORK_ADDRESS_W          PROP_TAG( PT_MV_UNICODE,    0x8170)
#define PR_EMS_AB_NNTP_CHARACTER_SET         PROP_TAG( PT_TSTRING,       0x817D)
#define PR_EMS_AB_NNTP_CHARACTER_SET_A       PROP_TAG( PT_STRING8,       0x817D)
#define PR_EMS_AB_NNTP_CHARACTER_SET_W       PROP_TAG( PT_UNICODE,       0x817D)
#define PR_EMS_AB_NNTP_CONTENT_FORMAT        PROP_TAG( PT_TSTRING,       0x8176)
#define PR_EMS_AB_NNTP_CONTENT_FORMAT_A      PROP_TAG( PT_STRING8,       0x8176)
#define PR_EMS_AB_NNTP_CONTENT_FORMAT_W      PROP_TAG( PT_UNICODE,       0x8176)
#define PR_EMS_AB_NT_MACHINE_NAME            PROP_TAG( PT_TSTRING,       0x80F3)
#define PR_EMS_AB_NT_MACHINE_NAME_A          PROP_TAG( PT_STRING8,       0x80F3)
#define PR_EMS_AB_NT_MACHINE_NAME_W          PROP_TAG( PT_UNICODE,       0x80F3)
#define PR_EMS_AB_NT_SECURITY_DESCRIPTOR     PROP_TAG( PT_BINARY,        0x8013)
#define PR_EMS_AB_NUM_OF_OPEN_RETRIES        PROP_TAG( PT_LONG,          0x80F4)
#define PR_EMS_AB_NUM_OF_TRANSFER_RETRIES    PROP_TAG( PT_LONG,          0x80F5)
#define PR_EMS_AB_OBJ_DIST_NAME              PROP_TAG( PT_TSTRING,       0x803C)
#define PR_EMS_AB_OBJ_DIST_NAME_A            PROP_TAG( PT_STRING8,       0x803C)
#define PR_EMS_AB_OBJ_DIST_NAME_W            PROP_TAG( PT_UNICODE,       0x803C)
#define PR_EMS_AB_OBJ_DIST_NAME_O            PROP_TAG( PT_OBJECT,        0x803C)
#define PR_EMS_AB_OBJ_DIST_NAME_T            PROP_TAG( PT_TSTRING,       0x803C)
#define PR_EMS_AB_OBJECT_CLASS_CATEGORY      PROP_TAG( PT_LONG,          0x80F6)
#define PR_EMS_AB_OBJECT_VERSION             PROP_TAG( PT_LONG,          0x80F7)
#define PR_EMS_AB_OFF_LINE_AB_CONTAINERS     PROP_TAG( PT_MV_TSTRING,    0x80F8)
#define PR_EMS_AB_OFF_LINE_AB_CONTAINERS_A   PROP_TAG( PT_MV_STRING8,    0x80F8)
#define PR_EMS_AB_OFF_LINE_AB_CONTAINERS_W   PROP_TAG( PT_MV_UNICODE,    0x80F8)
#define PR_EMS_AB_OFF_LINE_AB_CONTAINERS_O   PROP_TAG( PT_OBJECT,        0x80F8)
#define PR_EMS_AB_OFF_LINE_AB_CONTAINERS_T   PROP_TAG( PT_MV_TSTRING,    0x80F8)
#define PR_EMS_AB_OFF_LINE_AB_SCHEDULE       PROP_TAG( PT_BINARY,        0x80F9)
#define PR_EMS_AB_OFF_LINE_AB_SERVER         PROP_TAG( PT_TSTRING,       0x80FA)
#define PR_EMS_AB_OFF_LINE_AB_SERVER_A       PROP_TAG( PT_STRING8,       0x80FA)
#define PR_EMS_AB_OFF_LINE_AB_SERVER_W       PROP_TAG( PT_UNICODE,       0x80FA)
#define PR_EMS_AB_OFF_LINE_AB_SERVER_O       PROP_TAG( PT_OBJECT,        0x80FA)
#define PR_EMS_AB_OFF_LINE_AB_SERVER_T       PROP_TAG( PT_TSTRING,       0x80FA)
#define PR_EMS_AB_OFF_LINE_AB_STYLE          PROP_TAG( PT_LONG,          0x80FB)
#define PR_EMS_AB_OID_TYPE                   PROP_TAG( PT_LONG,          0x80FC)
#define PR_EMS_AB_OM_OBJECT_CLASS            PROP_TAG( PT_BINARY,        0x80FD)
#define PR_EMS_AB_OM_SYNTAX                  PROP_TAG( PT_LONG,          0x80FE)
#define PR_EMS_AB_OOF_REPLY_TO_ORIGINATOR    PROP_TAG( PT_BOOLEAN,       0x80FF)
#define PR_EMS_AB_OPEN_RETRY_INTERVAL        PROP_TAG( PT_LONG,          0x8100)
#define PR_EMS_AB_ORGANIZATION_NAME          PROP_TAG( PT_MV_TSTRING,    0x8101)
#define PR_EMS_AB_ORGANIZATION_NAME_A        PROP_TAG( PT_MV_STRING8,    0x8101)
#define PR_EMS_AB_ORGANIZATION_NAME_W        PROP_TAG( PT_MV_UNICODE,    0x8101)
#define PR_EMS_AB_ORGANIZATIONAL_UNIT_NAME   PROP_TAG( PT_MV_TSTRING,    0x8102)
#define PR_EMS_AB_ORGANIZATIONAL_UNIT_NAME_A PROP_TAG( PT_MV_STRING8,    0x8102)
#define PR_EMS_AB_ORGANIZATIONAL_UNIT_NAME_W PROP_TAG( PT_MV_UNICODE,    0x8102)
#define PR_EMS_AB_ORIGINAL_DISPLAY_TABLE     PROP_TAG( PT_BINARY,        0x8103)
#define PR_EMS_AB_ORIGINAL_DISPLAY_TABLE_MSDOS PROP_TAG( PT_BINARY,        0x8104)
#define PR_EMS_AB_OUTBOUND_SITES             PROP_TAG( PT_MV_TSTRING,    0x8105)
#define PR_EMS_AB_OUTBOUND_SITES_A           PROP_TAG( PT_MV_STRING8,    0x8105)
#define PR_EMS_AB_OUTBOUND_SITES_W           PROP_TAG( PT_MV_UNICODE,    0x8105)
#define PR_EMS_AB_OUTBOUND_SITES_O           PROP_TAG( PT_OBJECT,        0x8105)
#define PR_EMS_AB_OUTBOUND_SITES_T           PROP_TAG( PT_MV_TSTRING,    0x8105)
#define PR_EMS_AB_OWNER                      PROP_TAG( PT_TSTRING,       0x800C)
#define PR_EMS_AB_OWNER_A                    PROP_TAG( PT_STRING8,       0x800C)
#define PR_EMS_AB_OWNER_W                    PROP_TAG( PT_UNICODE,       0x800C)
#define PR_EMS_AB_OWNER_O                    PROP_TAG( PT_OBJECT,        0x800C)
#define PR_EMS_AB_OWNER_T                    PROP_TAG( PT_TSTRING,       0x800C)
#define PR_EMS_AB_OWNER_BL                   PROP_TAG( PT_TSTRING,       0x8024)
#define PR_EMS_AB_OWNER_BL_A                 PROP_TAG( PT_STRING8,       0x8024)
#define PR_EMS_AB_OWNER_BL_W                 PROP_TAG( PT_UNICODE,       0x8024)
#define PR_EMS_AB_OWNER_BL_O                 PROP_TAG( PT_OBJECT,        0x8024)
#define PR_EMS_AB_OWNER_BL_T                 PROP_TAG( PT_TSTRING,       0x8024)
#define PR_EMS_AB_P_SELECTOR                 PROP_TAG( PT_BINARY,        0x8106)
#define PR_EMS_AB_P_SELECTOR_INBOUND         PROP_TAG( PT_BINARY,        0x8107)
#define PR_EMS_AB_PER_MSG_DIALOG_DISPLAY_TABLE PROP_TAG( PT_BINARY,        0x8108)
#define PR_EMS_AB_PER_RECIP_DIALOG_DISPLAY_TABLE PROP_TAG( PT_BINARY,        0x8109)
#define PR_EMS_AB_PERIOD_REP_SYNC_TIMES      PROP_TAG( PT_BINARY,        0x810A)
#define PR_EMS_AB_PERIOD_REPL_STAGGER        PROP_TAG( PT_LONG,          0x810B)
#define PR_EMS_AB_PF_CONTACTS                PROP_TAG( PT_MV_TSTRING,    0x8038)
#define PR_EMS_AB_PF_CONTACTS_A              PROP_TAG( PT_MV_STRING8,    0x8038)
#define PR_EMS_AB_PF_CONTACTS_W              PROP_TAG( PT_MV_UNICODE,    0x8038)
#define PR_EMS_AB_PF_CONTACTS_O              PROP_TAG( PT_OBJECT,        0x8038)
#define PR_EMS_AB_PF_CONTACTS_T              PROP_TAG( PT_MV_TSTRING,    0x8038)
#define PR_EMS_AB_POP_CHARACTER_SET          PROP_TAG( PT_TSTRING,       0x8179)
#define PR_EMS_AB_POP_CHARACTER_SET_A        PROP_TAG( PT_STRING8,       0x8179)
#define PR_EMS_AB_POP_CHARACTER_SET_W        PROP_TAG( PT_UNICODE,       0x8179)
#define PR_EMS_AB_POP_CONTENT_FORMAT         PROP_TAG( PT_TSTRING,       0x8177)
#define PR_EMS_AB_POP_CONTENT_FORMAT_A       PROP_TAG( PT_STRING8,       0x8177)
#define PR_EMS_AB_POP_CONTENT_FORMAT_W       PROP_TAG( PT_UNICODE,       0x8177)
#define PR_EMS_AB_POSTAL_ADDRESS             PROP_TAG( PT_MV_BINARY,     0x810C)
#define PR_EMS_AB_PREFERRED_DELIVERY_METHOD  PROP_TAG( PT_MV_LONG,       0x810D)
#define PR_EMS_AB_PRMD                       PROP_TAG( PT_TSTRING,       0x810E)
#define PR_EMS_AB_PRMD_A                     PROP_TAG( PT_STRING8,       0x810E)
#define PR_EMS_AB_PRMD_W                     PROP_TAG( PT_UNICODE,       0x810E)
#define PR_EMS_AB_PROXY_ADDRESSES            PROP_TAG( PT_MV_TSTRING,    0x800F)
#define PR_EMS_AB_PROXY_ADDRESSES_A          PROP_TAG( PT_MV_STRING8,    0x800F)
#define PR_EMS_AB_PROXY_ADDRESSES_W          PROP_TAG( PT_MV_UNICODE,    0x800F)
#define PR_EMS_AB_PROXY_GENERATOR_DLL        PROP_TAG( PT_TSTRING,       0x810F)
#define PR_EMS_AB_PROXY_GENERATOR_DLL_A      PROP_TAG( PT_STRING8,       0x810F)
#define PR_EMS_AB_PROXY_GENERATOR_DLL_W      PROP_TAG( PT_UNICODE,       0x810F)
#define PR_EMS_AB_PUBLIC_DELEGATES           PROP_TAG( PT_OBJECT,        0x8015)
#define PR_EMS_AB_PUBLIC_DELEGATES_A         PROP_TAG( PT_MV_STRING8,    0x8015)
#define PR_EMS_AB_PUBLIC_DELEGATES_W         PROP_TAG( PT_MV_UNICODE,    0x8015)
#define PR_EMS_AB_PUBLIC_DELEGATES_O         PROP_TAG( PT_OBJECT,        0x8015)
#define PR_EMS_AB_PUBLIC_DELEGATES_T         PROP_TAG( PT_MV_TSTRING,    0x8015)
#define PR_EMS_AB_PUBLIC_DELEGATES_BL        PROP_TAG( PT_MV_TSTRING,    0x8110)
#define PR_EMS_AB_PUBLIC_DELEGATES_BL_A      PROP_TAG( PT_MV_STRING8,    0x8110)
#define PR_EMS_AB_PUBLIC_DELEGATES_BL_W      PROP_TAG( PT_MV_UNICODE,    0x8110)
#define PR_EMS_AB_PUBLIC_DELEGATES_BL_O      PROP_TAG( PT_OBJECT,        0x8110)
#define PR_EMS_AB_PUBLIC_DELEGATES_BL_T      PROP_TAG( PT_MV_TSTRING,    0x8110)
#define PR_EMS_AB_QUOTA_NOTIFICATION_SCHEDULE PROP_TAG( PT_BINARY,        0x8111)
#define PR_EMS_AB_QUOTA_NOTIFICATION_STYLE   PROP_TAG( PT_LONG,          0x8112)
#define PR_EMS_AB_RANGE_LOWER                PROP_TAG( PT_LONG,          0x8113)
#define PR_EMS_AB_RANGE_UPPER                PROP_TAG( PT_LONG,          0x8114)
#define PR_EMS_AB_RAS_CALLBACK_NUMBER        PROP_TAG( PT_TSTRING,       0x8115)
#define PR_EMS_AB_RAS_CALLBACK_NUMBER_A      PROP_TAG( PT_STRING8,       0x8115)
#define PR_EMS_AB_RAS_CALLBACK_NUMBER_W      PROP_TAG( PT_UNICODE,       0x8115)
#define PR_EMS_AB_RAS_PHONE_NUMBER           PROP_TAG( PT_TSTRING,       0x8116)
#define PR_EMS_AB_RAS_PHONE_NUMBER_A         PROP_TAG( PT_STRING8,       0x8116)
#define PR_EMS_AB_RAS_PHONE_NUMBER_W         PROP_TAG( PT_UNICODE,       0x8116)
#define PR_EMS_AB_RAS_PHONEBOOK_ENTRY_NAME   PROP_TAG( PT_TSTRING,       0x8117)
#define PR_EMS_AB_RAS_PHONEBOOK_ENTRY_NAME_A PROP_TAG( PT_STRING8,       0x8117)
#define PR_EMS_AB_RAS_PHONEBOOK_ENTRY_NAME_W PROP_TAG( PT_UNICODE,       0x8117)
#define PR_EMS_AB_RAS_REMOTE_SRVR_NAME       PROP_TAG( PT_TSTRING,       0x8118)
#define PR_EMS_AB_RAS_REMOTE_SRVR_NAME_A     PROP_TAG( PT_STRING8,       0x8118)
#define PR_EMS_AB_RAS_REMOTE_SRVR_NAME_W     PROP_TAG( PT_UNICODE,       0x8118)
#define PR_EMS_AB_REGISTERED_ADDRESS         PROP_TAG( PT_MV_BINARY,     0x8119)
#define PR_EMS_AB_REMOTE_BRIDGE_HEAD         PROP_TAG( PT_TSTRING,       0x811A)
#define PR_EMS_AB_REMOTE_BRIDGE_HEAD_A       PROP_TAG( PT_STRING8,       0x811A)
#define PR_EMS_AB_REMOTE_BRIDGE_HEAD_W       PROP_TAG( PT_UNICODE,       0x811A)
#define PR_EMS_AB_REMOTE_BRIDGE_HEAD_ADDRESS PROP_TAG( PT_TSTRING,       0x811B)
#define PR_EMS_AB_REMOTE_BRIDGE_HEAD_ADDRESS_A PROP_TAG( PT_STRING8,       0x811B)
#define PR_EMS_AB_REMOTE_BRIDGE_HEAD_ADDRESS_W PROP_TAG( PT_UNICODE,       0x811B)
#define PR_EMS_AB_REMOTE_OUT_BH_SERVER       PROP_TAG( PT_TSTRING,       0x811C)
#define PR_EMS_AB_REMOTE_OUT_BH_SERVER_A     PROP_TAG( PT_STRING8,       0x811C)
#define PR_EMS_AB_REMOTE_OUT_BH_SERVER_W     PROP_TAG( PT_UNICODE,       0x811C)
#define PR_EMS_AB_REMOTE_OUT_BH_SERVER_O     PROP_TAG( PT_OBJECT,        0x811C)
#define PR_EMS_AB_REMOTE_OUT_BH_SERVER_T     PROP_TAG( PT_TSTRING,       0x811C)
#define PR_EMS_AB_REMOTE_SITE                PROP_TAG( PT_TSTRING,       0x811D)
#define PR_EMS_AB_REMOTE_SITE_A              PROP_TAG( PT_STRING8,       0x811D)
#define PR_EMS_AB_REMOTE_SITE_W              PROP_TAG( PT_UNICODE,       0x811D)
#define PR_EMS_AB_REMOTE_SITE_O              PROP_TAG( PT_OBJECT,        0x811D)
#define PR_EMS_AB_REMOTE_SITE_T              PROP_TAG( PT_TSTRING,       0x811D)
#define PR_EMS_AB_REPLICATION_MAIL_MSG_SIZE  PROP_TAG( PT_LONG,          0x8168)
#define PR_EMS_AB_REPLICATION_SENSITIVITY    PROP_TAG( PT_LONG,          0x811E)
#define PR_EMS_AB_REPLICATION_STAGGER        PROP_TAG( PT_LONG,          0x811F)
#define PR_EMS_AB_REPORT_TO_ORIGINATOR       PROP_TAG( PT_BOOLEAN,       0x8120)
#define PR_EMS_AB_REPORT_TO_OWNER            PROP_TAG( PT_BOOLEAN,       0x8121)
#define PR_EMS_AB_REPORTS                    PROP_TAG( PT_OBJECT,        0x800E)
#define PR_EMS_AB_REPORTS_A                  PROP_TAG( PT_MV_STRING8,    0x800E)
#define PR_EMS_AB_REPORTS_W                  PROP_TAG( PT_MV_UNICODE,    0x800E)
#define PR_EMS_AB_REPORTS_O                  PROP_TAG( PT_OBJECT,        0x800E)
#define PR_EMS_AB_REPORTS_T                  PROP_TAG( PT_MV_TSTRING,    0x800E)
#define PR_EMS_AB_REQ_SEQ                    PROP_TAG( PT_LONG,          0x8122)
#define PR_EMS_AB_RESPONSIBLE_LOCAL_DXA      PROP_TAG( PT_TSTRING,       0x8123)
#define PR_EMS_AB_RESPONSIBLE_LOCAL_DXA_A    PROP_TAG( PT_STRING8,       0x8123)
#define PR_EMS_AB_RESPONSIBLE_LOCAL_DXA_W    PROP_TAG( PT_UNICODE,       0x8123)
#define PR_EMS_AB_RESPONSIBLE_LOCAL_DXA_O    PROP_TAG( PT_OBJECT,        0x8123)
#define PR_EMS_AB_RESPONSIBLE_LOCAL_DXA_T    PROP_TAG( PT_TSTRING,       0x8123)
#define PR_EMS_AB_RID_SERVER                 PROP_TAG( PT_TSTRING,       0x8124)
#define PR_EMS_AB_RID_SERVER_A               PROP_TAG( PT_STRING8,       0x8124)
#define PR_EMS_AB_RID_SERVER_W               PROP_TAG( PT_UNICODE,       0x8124)
#define PR_EMS_AB_RID_SERVER_O               PROP_TAG( PT_OBJECT,        0x8124)
#define PR_EMS_AB_RID_SERVER_T               PROP_TAG( PT_TSTRING,       0x8124)
#define PR_EMS_AB_ROLE_OCCUPANT              PROP_TAG( PT_MV_TSTRING,    0x8125)
#define PR_EMS_AB_ROLE_OCCUPANT_A            PROP_TAG( PT_MV_STRING8,    0x8125)
#define PR_EMS_AB_ROLE_OCCUPANT_W            PROP_TAG( PT_MV_UNICODE,    0x8125)
#define PR_EMS_AB_ROLE_OCCUPANT_O            PROP_TAG( PT_OBJECT,        0x8125)
#define PR_EMS_AB_ROLE_OCCUPANT_T            PROP_TAG( PT_MV_TSTRING,    0x8125)
#define PR_EMS_AB_ROUTING_LIST               PROP_TAG( PT_MV_TSTRING,    0x8126)
#define PR_EMS_AB_ROUTING_LIST_A             PROP_TAG( PT_MV_STRING8,    0x8126)
#define PR_EMS_AB_ROUTING_LIST_W             PROP_TAG( PT_MV_UNICODE,    0x8126)
#define PR_EMS_AB_RTS_CHECKPOINT_SIZE        PROP_TAG( PT_LONG,          0x8127)
#define PR_EMS_AB_RTS_RECOVERY_TIMEOUT       PROP_TAG( PT_LONG,          0x8128)
#define PR_EMS_AB_RTS_WINDOW_SIZE            PROP_TAG( PT_LONG,          0x8129)
#define PR_EMS_AB_RUNS_ON                    PROP_TAG( PT_MV_TSTRING,    0x812A)
#define PR_EMS_AB_RUNS_ON_A                  PROP_TAG( PT_MV_STRING8,    0x812A)
#define PR_EMS_AB_RUNS_ON_W                  PROP_TAG( PT_MV_UNICODE,    0x812A)
#define PR_EMS_AB_RUNS_ON_O                  PROP_TAG( PT_OBJECT,        0x812A)
#define PR_EMS_AB_RUNS_ON_T                  PROP_TAG( PT_MV_TSTRING,    0x812A)
#define PR_EMS_AB_S_SELECTOR                 PROP_TAG( PT_BINARY,        0x812B)
#define PR_EMS_AB_S_SELECTOR_INBOUND         PROP_TAG( PT_BINARY,        0x812C)
#define PR_EMS_AB_SCHEMA_FLAGS               PROP_TAG( PT_LONG,          0x8173)
#define PR_EMS_AB_SCHEMA_VERSION             PROP_TAG( PT_MV_LONG,       0x817C)
#define PR_EMS_AB_SEARCH_FLAGS               PROP_TAG( PT_LONG,          0x812D)
#define PR_EMS_AB_SEARCH_GUIDE               PROP_TAG( PT_MV_BINARY,     0x812E)
#define PR_EMS_AB_SECURITY_PROTOCOL          PROP_TAG( PT_MV_BINARY,     0x8037)
#define PR_EMS_AB_SEE_ALSO                   PROP_TAG( PT_MV_TSTRING,    0x812F)
#define PR_EMS_AB_SEE_ALSO_A                 PROP_TAG( PT_MV_STRING8,    0x812F)
#define PR_EMS_AB_SEE_ALSO_W                 PROP_TAG( PT_MV_UNICODE,    0x812F)
#define PR_EMS_AB_SEE_ALSO_O                 PROP_TAG( PT_OBJECT,        0x812F)
#define PR_EMS_AB_SEE_ALSO_T                 PROP_TAG( PT_MV_TSTRING,    0x812F)
#define PR_EMS_AB_SERIAL_NUMBER              PROP_TAG( PT_MV_TSTRING,    0x8130)
#define PR_EMS_AB_SERIAL_NUMBER_A            PROP_TAG( PT_MV_STRING8,    0x8130)
#define PR_EMS_AB_SERIAL_NUMBER_W            PROP_TAG( PT_MV_UNICODE,    0x8130)
#define PR_EMS_AB_SERVICE_ACTION_FIRST       PROP_TAG( PT_LONG,          0x8131)
#define PR_EMS_AB_SERVICE_ACTION_OTHER       PROP_TAG( PT_LONG,          0x8132)
#define PR_EMS_AB_SERVICE_ACTION_SECOND      PROP_TAG( PT_LONG,          0x8133)
#define PR_EMS_AB_SERVICE_RESTART_DELAY      PROP_TAG( PT_LONG,          0x8134)
#define PR_EMS_AB_SERVICE_RESTART_MESSAGE    PROP_TAG( PT_TSTRING,       0x8135)
#define PR_EMS_AB_SERVICE_RESTART_MESSAGE_A  PROP_TAG( PT_STRING8,       0x8135)
#define PR_EMS_AB_SERVICE_RESTART_MESSAGE_W  PROP_TAG( PT_UNICODE,       0x8135)
#define PR_EMS_AB_SESSION_DISCONNECT_TIMER   PROP_TAG( PT_LONG,          0x8136)
#define PR_EMS_AB_SITE_AFFINITY              PROP_TAG( PT_MV_TSTRING,    0x8137)
#define PR_EMS_AB_SITE_AFFINITY_A            PROP_TAG( PT_MV_STRING8,    0x8137)
#define PR_EMS_AB_SITE_AFFINITY_W            PROP_TAG( PT_MV_UNICODE,    0x8137)
#define PR_EMS_AB_SITE_FOLDER_GUID           PROP_TAG( PT_BINARY,        0x8166)
#define PR_EMS_AB_SITE_FOLDER_SERVER         PROP_TAG( PT_TSTRING,       0x8167)
#define PR_EMS_AB_SITE_FOLDER_SERVER_A       PROP_TAG( PT_STRING8,       0x8167)
#define PR_EMS_AB_SITE_FOLDER_SERVER_W       PROP_TAG( PT_UNICODE,       0x8167)
#define PR_EMS_AB_SITE_FOLDER_SERVER_O       PROP_TAG( PT_OBJECT,        0x8167)
#define PR_EMS_AB_SITE_FOLDER_SERVER_T       PROP_TAG( PT_TSTRING,       0x8167)
#define PR_EMS_AB_SITE_PROXY_SPACE           PROP_TAG( PT_MV_TSTRING,    0x8138)
#define PR_EMS_AB_SITE_PROXY_SPACE_A         PROP_TAG( PT_MV_STRING8,    0x8138)
#define PR_EMS_AB_SITE_PROXY_SPACE_W         PROP_TAG( PT_MV_UNICODE,    0x8138)
#define PR_EMS_AB_SPACE_LAST_COMPUTED        PROP_TAG( PT_SYSTIME,       0x8139)
#define PR_EMS_AB_STREET_ADDRESS             PROP_TAG( PT_TSTRING,       0x813A)
#define PR_EMS_AB_STREET_ADDRESS_A           PROP_TAG( PT_STRING8,       0x813A)
#define PR_EMS_AB_STREET_ADDRESS_W           PROP_TAG( PT_UNICODE,       0x813A)
#define PR_EMS_AB_SUB_REFS                   PROP_TAG( PT_MV_TSTRING,    0x813B)
#define PR_EMS_AB_SUB_REFS_A                 PROP_TAG( PT_MV_STRING8,    0x813B)
#define PR_EMS_AB_SUB_REFS_W                 PROP_TAG( PT_MV_UNICODE,    0x813B)
#define PR_EMS_AB_SUB_REFS_O                 PROP_TAG( PT_OBJECT,        0x813B)
#define PR_EMS_AB_SUB_REFS_T                 PROP_TAG( PT_MV_TSTRING,    0x813B)
#define PR_EMS_AB_SUB_SITE                   PROP_TAG( PT_TSTRING,       0x817B)
#define PR_EMS_AB_SUB_SITE_A                 PROP_TAG( PT_STRING8,       0x817B)
#define PR_EMS_AB_SUB_SITE_W                 PROP_TAG( PT_UNICODE,       0x817B)
#define PR_EMS_AB_SUBMISSION_CONT_LENGTH     PROP_TAG( PT_LONG,          0x813C)
#define PR_EMS_AB_SUPPORTED_APPLICATION_CONTEXT PROP_TAG( PT_MV_BINARY,     0x813D)
#define PR_EMS_AB_SUPPORTING_STACK           PROP_TAG( PT_MV_TSTRING,    0x813E)
#define PR_EMS_AB_SUPPORTING_STACK_A         PROP_TAG( PT_MV_STRING8,    0x813E)
#define PR_EMS_AB_SUPPORTING_STACK_W         PROP_TAG( PT_MV_UNICODE,    0x813E)
#define PR_EMS_AB_SUPPORTING_STACK_O         PROP_TAG( PT_OBJECT,        0x813E)
#define PR_EMS_AB_SUPPORTING_STACK_T         PROP_TAG( PT_MV_TSTRING,    0x813E)
#define PR_EMS_AB_SUPPORTING_STACK_BL        PROP_TAG( PT_MV_TSTRING,    0x813F)
#define PR_EMS_AB_SUPPORTING_STACK_BL_A      PROP_TAG( PT_MV_STRING8,    0x813F)
#define PR_EMS_AB_SUPPORTING_STACK_BL_W      PROP_TAG( PT_MV_UNICODE,    0x813F)
#define PR_EMS_AB_SUPPORTING_STACK_BL_O      PROP_TAG( PT_OBJECT,        0x813F)
#define PR_EMS_AB_SUPPORTING_STACK_BL_T      PROP_TAG( PT_MV_TSTRING,    0x813F)
#define PR_EMS_AB_T_SELECTOR                 PROP_TAG( PT_BINARY,        0x8140)
#define PR_EMS_AB_T_SELECTOR_INBOUND         PROP_TAG( PT_BINARY,        0x8141)
#define PR_EMS_AB_TARGET_ADDRESS             PROP_TAG( PT_TSTRING,       0x8011)
#define PR_EMS_AB_TARGET_ADDRESS_A           PROP_TAG( PT_STRING8,       0x8011)
#define PR_EMS_AB_TARGET_ADDRESS_W           PROP_TAG( PT_UNICODE,       0x8011)
#define PR_EMS_AB_TARGET_MTAS                PROP_TAG( PT_MV_TSTRING,    0x8142)
#define PR_EMS_AB_TARGET_MTAS_A              PROP_TAG( PT_MV_STRING8,    0x8142)
#define PR_EMS_AB_TARGET_MTAS_W              PROP_TAG( PT_MV_UNICODE,    0x8142)
#define PR_EMS_AB_TELEPHONE_NUMBER           PROP_TAG( PT_MV_TSTRING,    0x8012)
#define PR_EMS_AB_TELEPHONE_NUMBER_A         PROP_TAG( PT_MV_STRING8,    0x8012)
#define PR_EMS_AB_TELEPHONE_NUMBER_W         PROP_TAG( PT_MV_UNICODE,    0x8012)
#define PR_EMS_AB_TELETEX_TERMINAL_IDENTIFIER PROP_TAG( PT_MV_BINARY,     0x8143)
#define PR_EMS_AB_TEMP_ASSOC_THRESHOLD       PROP_TAG( PT_LONG,          0x8144)
#define PR_EMS_AB_TOMBSTONE_LIFETIME         PROP_TAG( PT_LONG,          0x8145)
#define PR_EMS_AB_TRACKING_LOG_PATH_NAME     PROP_TAG( PT_TSTRING,       0x8146)
#define PR_EMS_AB_TRACKING_LOG_PATH_NAME_A   PROP_TAG( PT_STRING8,       0x8146)
#define PR_EMS_AB_TRACKING_LOG_PATH_NAME_W   PROP_TAG( PT_UNICODE,       0x8146)
#define PR_EMS_AB_TRANS_RETRY_MINS           PROP_TAG( PT_LONG,          0x8147)
#define PR_EMS_AB_TRANS_TIMEOUT_MINS         PROP_TAG( PT_LONG,          0x8148)
#define PR_EMS_AB_TRANSFER_RETRY_INTERVAL    PROP_TAG( PT_LONG,          0x8149)
#define PR_EMS_AB_TRANSFER_TIMEOUT_NON_URGENT PROP_TAG( PT_LONG,          0x814A)
#define PR_EMS_AB_TRANSFER_TIMEOUT_NORMAL    PROP_TAG( PT_LONG,          0x814B)
#define PR_EMS_AB_TRANSFER_TIMEOUT_URGENT    PROP_TAG( PT_LONG,          0x814C)
#define PR_EMS_AB_TRANSLATION_TABLE_USED     PROP_TAG( PT_LONG,          0x814D)
#define PR_EMS_AB_TRANSPORT_EXPEDITED_DATA   PROP_TAG( PT_BOOLEAN,       0x814E)
#define PR_EMS_AB_TRUST_LEVEL                PROP_TAG( PT_LONG,          0x814F)
#define PR_EMS_AB_TURN_REQUEST_THRESHOLD     PROP_TAG( PT_LONG,          0x8150)
#define PR_EMS_AB_TWO_WAY_ALTERNATE_FACILITY PROP_TAG( PT_BOOLEAN,       0x8151)
#define PR_EMS_AB_UNAUTH_ORIG_BL             PROP_TAG( PT_MV_TSTRING,    0x8152)
#define PR_EMS_AB_UNAUTH_ORIG_BL_A           PROP_TAG( PT_MV_STRING8,    0x8152)
#define PR_EMS_AB_UNAUTH_ORIG_BL_W           PROP_TAG( PT_MV_UNICODE,    0x8152)
#define PR_EMS_AB_UNAUTH_ORIG_BL_O           PROP_TAG( PT_OBJECT,        0x8152)
#define PR_EMS_AB_UNAUTH_ORIG_BL_T           PROP_TAG( PT_MV_TSTRING,    0x8152)
#define PR_EMS_AB_USE_SERVER_VALUES          PROP_TAG( PT_BOOLEAN,       0x817E)
#define PR_EMS_AB_USER_PASSWORD              PROP_TAG( PT_MV_BINARY,     0x8153)
#define PR_EMS_AB_USN_CHANGED                PROP_TAG( PT_LONG,          0x8029)
#define PR_EMS_AB_USN_CREATED                PROP_TAG( PT_LONG,          0x8154)
#define PR_EMS_AB_USN_DSA_LAST_OBJ_REMOVED   PROP_TAG( PT_LONG,          0x8155)
#define PR_EMS_AB_USN_INTERSITE              PROP_TAG( PT_LONG,          0x817A)
#define PR_EMS_AB_USN_LAST_OBJ_REM           PROP_TAG( PT_LONG,          0x8156)
#define PR_EMS_AB_USN_SOURCE                 PROP_TAG( PT_LONG,          0x8157)
#define PR_EMS_AB_WWW_HOME_PAGE              PROP_TAG( PT_TSTRING,       0x8175)
#define PR_EMS_AB_WWW_HOME_PAGE_A            PROP_TAG( PT_STRING8,       0x8175)
#define PR_EMS_AB_WWW_HOME_PAGE_W            PROP_TAG( PT_UNICODE,       0x8175)
#define PR_EMS_AB_X121_ADDRESS               PROP_TAG( PT_MV_TSTRING,    0x8158)
#define PR_EMS_AB_X121_ADDRESS_A             PROP_TAG( PT_MV_STRING8,    0x8158)
#define PR_EMS_AB_X121_ADDRESS_W             PROP_TAG( PT_MV_UNICODE,    0x8158)
#define PR_EMS_AB_X25_CALL_USER_DATA_INCOMING PROP_TAG( PT_BINARY,        0x8159)
#define PR_EMS_AB_X25_CALL_USER_DATA_OUTGOING PROP_TAG( PT_BINARY,        0x815A)
#define PR_EMS_AB_X25_FACILITIES_DATA_INCOMING PROP_TAG( PT_BINARY,        0x815B)
#define PR_EMS_AB_X25_FACILITIES_DATA_OUTGOING PROP_TAG( PT_BINARY,        0x815C)
#define PR_EMS_AB_X25_LEASED_LINE_PORT       PROP_TAG( PT_BINARY,        0x815D)
#define PR_EMS_AB_X25_LEASED_OR_SWITCHED     PROP_TAG( PT_BOOLEAN,       0x815E)
#define PR_EMS_AB_X25_REMOTE_MTA_PHONE       PROP_TAG( PT_TSTRING,       0x815F)
#define PR_EMS_AB_X25_REMOTE_MTA_PHONE_A     PROP_TAG( PT_STRING8,       0x815F)
#define PR_EMS_AB_X25_REMOTE_MTA_PHONE_W     PROP_TAG( PT_UNICODE,       0x815F)
#define PR_EMS_AB_X400_ATTACHMENT_TYPE       PROP_TAG( PT_BINARY,        0x8160)
#define PR_EMS_AB_X400_SELECTOR_SYNTAX       PROP_TAG( PT_LONG,          0x8161)
#define PR_EMS_AB_X500_ACCESS_CONTROL_LIST   PROP_TAG( PT_BINARY,        0x8162)
#define PR_EMS_AB_XMIT_TIMEOUT_NON_URGENT    PROP_TAG( PT_LONG,          0x8163)
#define PR_EMS_AB_XMIT_TIMEOUT_NORMAL        PROP_TAG( PT_LONG,          0x8164)
#define PR_EMS_AB_XMIT_TIMEOUT_URGENT        PROP_TAG( PT_LONG,          0x8165)

#endif /* _EMSABTAG_H */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\exchange\ext\resource.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    resource.h

Abstract:

    Fax client extension resource header file.

Author:

    Wesley Witt (wesw) 13-Aug-1996

--*/

#define IDC_STATIC                      -1
#define IDC_PRINTER_LIST               201
#define IDC_USE_COVERPAGE              202
#define IDC_COVERPAGE_LIST             203
#define IDC_STATIC_COVERPAGE_GRP       206
#define IDC_STATIC_COVERPAGE           207
#define IDC_STATIC_PRINTER_LIST        208
#define IDC_SEND_SINGLE_RECEIPT        209
#define IDC_ATTACH_FAX                 210

#define FAX_CONFIG_DIALOG              501

#define IDB_EXTBTN                     801
#define IDI_FAX                        802

#define IDS_MSGBOXCAPTION              900
#define IDS_FAX_ATTRIBUTES_MENU        902
#define IDS_FAX_ATTRIBUTES_TOOLTIP     903
#define IDS_FAX_ATTRIBUTES_CUST        904
#define IDS_PERSONAL                   905
#define IDS_NO_FAX_PRINTER             906
#define IDS_FAX_MESSAGE                907
#define IDS_CANT_ACCESS_SERVER		   908
#define IDS_NOT_ENOUGH_MEMORY          909
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\exchange\ext\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Wesley Witt (wesw)

!ENDIF


!include ..\..\..\faxsrc.inc

TARGETNAME=$(FAXEXT32)
TARGETPATH=obj
TARGETTYPE=DYNLINK
DLLDEF=..\faxext32.def
UMTYPE=windows
DLLENTRY=DllMain

USE_CRTDLL=1

INCLUDES=                       \
  $(INCLUDES);                  \
  $(FAXROOT)\exchange\inc;      \
  $(FAXROOT)\inc;             

!ifndef NOUNICODE
TARGETLIBS = $(FAXROOT)\util\debugex\unicode\obj\*\debugex.lib \
             $(FAXLIB)\*\$(WINFAX).lib
!else
TARGETLIBS = $(FAXROOT)\util\debugex\ansii\obj\*\debugex.lib \
             $(FAXLIB)\win95\*\$(WINFAX).lib 
!endif
  
TARGETLIBS = $(TARGETLIBS)                    \
  $(BASEDIR)\public\sdk\lib\*\kernel32.lib    \
  $(BASEDIR)\public\sdk\lib\*\advapi32.lib    \
  $(BASEDIR)\public\sdk\lib\*\uuid.lib        \
  $(BASEDIR)\public\sdk\lib\*\gdi32.lib       \
  $(BASEDIR)\public\sdk\lib\*\user32.lib      \
  $(BASEDIR)\public\sdk\lib\*\ole32.lib       \
  $(BASEDIR)\public\sdk\lib\*\mapi32.lib      \
  $(BASEDIR)\public\sdk\lib\*\winspool.lib    \
  $(BASEDIR)\public\sdk\lib\*\shell32.lib     \
  $(BASEDIR)\public\sdk\lib\*\comdlg32.lib    

SOURCES=\
  ..\config.cpp  \
  ..\faxext.cpp  \
  ..\util.cpp    \
  ..\faxext.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\exchange\ext\util.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    util.cpp

Abstract:

    This module contains utility routines for the fax transport provider.

Author:

    Wesley Witt (wesw) 13-Aug-1996

--*/

#include "faxext.h"
#include "debugex.h"


//
// globals
//

BOOL oleInitialized;

LPVOID
MapiMemAlloc(
    SIZE_T Size
    )

/*++

Routine Description:

    Memory allocator.

Arguments:

    Size    - Number of bytes to allocate.

Return Value:

    Pointer to the allocated memory or NULL for failure.

--*/

{
    LPVOID ptr=NULL;
    HRESULT hResult;

	// [Win64bug] MAPIAllocateBuffer should accpet size_t as allocating size
    hResult = MAPIAllocateBuffer( DWORD(Size), &ptr );
    if (S_OK == hResult) 
    {
        ZeroMemory( ptr, Size );
    }

    return ptr;
}


VOID
MapiMemFree(
    LPVOID ptr
    )

/*++

Routine Description:

    Memory de-allocator.

Arguments:

    ptr     - Pointer to the memory block.

Return Value:

    None.

--*/

{
    if (ptr) {
        MAPIFreeBuffer( ptr );
    }
}


PVOID
MyGetPrinter(
    LPTSTR  PrinterName,
    DWORD   level
    )

/*++

Routine Description:

    Wrapper function for GetPrinter spooler API

Arguments:

    hPrinter - Identifies the printer in question
    level - Specifies the level of PRINTER_INFO_x structure requested

Return Value:

    Pointer to a PRINTER_INFO_x structure, NULL if there is an error

--*/

{
    HANDLE hPrinter;
    PBYTE pPrinterInfo = NULL;
    DWORD cbNeeded;
    PRINTER_DEFAULTS PrinterDefaults;


    PrinterDefaults.pDatatype     = NULL;
    PrinterDefaults.pDevMode      = NULL;
    PrinterDefaults.DesiredAccess = PRINTER_READ; //PRINTER_ALL_ACCESS;

    if (!OpenPrinter( PrinterName, &hPrinter, &PrinterDefaults )) {
        return NULL;
    }

    if (!GetPrinter( hPrinter, level, NULL, 0, &cbNeeded ) &&
        GetLastError() == ERROR_INSUFFICIENT_BUFFER &&
        (pPrinterInfo = (PBYTE) MemAlloc( cbNeeded )) &&
        GetPrinter( hPrinter, level, pPrinterInfo, cbNeeded, &cbNeeded ))
    {
        ClosePrinter( hPrinter );
        return pPrinterInfo;
    }

    ClosePrinter( hPrinter );
    MemFree( pPrinterInfo );
    return NULL;
}


LPTSTR
RemoveLastNode(
    LPTSTR Path
    )

/*++

Routine Description:

    Removes the last node from a path string.

Arguments:

    Path    - Path string.

Return Value:

    Pointer to the path string.

--*/

{
	LPTSTR Pstr = NULL;

    if (Path == NULL || Path[0] == 0) 
	{
        return Path;
    }

	Pstr = _tcsrchr(Path,TEXT('\\'));
	if( Pstr && (*_tcsinc(Pstr)) == '\0' )
	{
		// the last character is a backslash, truncate it...
		_tcsset(Pstr,TEXT('\0'));
		Pstr = _tcsdec(Path,Pstr);
	}

	Pstr = _tcsrchr(Path,TEXT('\\'));
	if( Pstr )
	{
		_tcsnset(_tcsinc(Pstr),TEXT('\0'),1);
	}

    return Path;
}

void
ErrorMsgBox(
    HINSTANCE hInstance,
    HWND      hWnd,
    DWORD     dwMsgId
)
/*++

Routine Description:

    Display error message box

Arguments:

    hInstance  - [in] resource instance handle
    hWnd       - [in] window handle
    dwMsgId    - [in] string resource ID

Return Value:

    none

--*/
{
    TCHAR* ptCaption=NULL;
    TCHAR  tszCaption[MAX_PATH];
    TCHAR  tszMessage[MAX_PATH];

    DBG_ENTER(TEXT("ErrorMsgBox"));

    if(!LoadString( hInstance, IDS_FAX_MESSAGE, tszCaption, sizeof(tszCaption)/sizeof(TCHAR)))
    {
        CALL_FAIL(GENERAL_ERR, TEXT("LoadString"), ::GetLastError());
    }
    else
    {
        ptCaption = tszCaption;
    }

    if(!LoadString( hInstance, dwMsgId, tszMessage, sizeof(tszMessage)/sizeof(TCHAR)))
    {
        CALL_FAIL(GENERAL_ERR, TEXT("LoadString"), ::GetLastError());
        Assert(FALSE);
        return;
    }

    MessageBeep(MB_ICONEXCLAMATION);
    AlignedMessageBox(hWnd, tszMessage, ptCaption, MB_OK | MB_ICONERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\exchange\inc\faxmapip.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    faxmapi.h

Abstract:

    Contains common fax mapi stuff.

Author:

    Wesley Witt (wesw) 13-Aug-1996

--*/

//
// 4.0;D:\nt\private\fax\faxext32\obj\i386\faxext32.dll;1;00000100000000
//
// \registry\machine\software\microsoft\exchange\client\extensions
//     FaxExtensions = 4.0;d:\winnt\system32\faxext32.dll;1;00000100000000
//

// {49A59282-9F30-11d2-912E-006094EB630B}
#define FAX_XP_GUID { 0x49, 0xa5, 0x92, 0x82, 0x9f, 0x30, 0x11, 0xd2, 0x91, 0x2e, 0x0, 0x60, 0x94, 0xeb, 0x63, 0xb };

//[RB] #define FAX_XP_GUID { 0x61, 0x85, 0x0a, 0x80, 0x0a, 0x47, 0x11, 0xd0, 0x88, 0x77, 0x0, 0xa0, 0x4, 0xff, 0x31, 0x28 }

#define MSGPS_FAX_PRINTER_NAME              L"FAX_PRINTER_NAME"
#define MSGPS_FAX_COVERPAGE_NAME            L"FAX_COVERPAGE_NAME"
#define MSGPS_FAX_USE_COVERPAGE             L"FAX_USE_COVERPAGE"
#define MSGPS_FAX_SERVER_COVERPAGE          L"FAX_SERVER_COVERPAGE"
#define MSGPS_FAX_SEND_SINGLE_RECEIPT       L"FAX_SEND_SINGLE_RECEIPT"
#define MSGPS_FAX_LINK_COVERPAGE            L"FAX_LINK_COVERPAGE"
#define MSGPS_FAX_ATTACH_FAX                L"FAX_ATTACH_FAX"

#define NUM_FAX_MSG_PROPS                   7

#define MSGPI_FAX_PRINTER_NAME              0
#define MSGPI_FAX_COVERPAGE_NAME            1
#define MSGPI_FAX_USE_COVERPAGE             2
#define MSGPI_FAX_SERVER_COVERPAGE          3
#define MSGPI_FAX_SEND_SINGLE_RECEIPT       4
#define MSGPI_FAX_LINK_COVERPAGE            5
#define MSGPI_FAX_ATTACH_FAX                6


#define BASE_PROVIDER_ID                    0x6600

#define NUM_FAX_PROPERTIES                  8

#define PROP_FAX_PRINTER_NAME               0
#define PROP_USE_COVERPAGE                  1
#define PROP_COVERPAGE_NAME                 2
#define PROP_SERVER_COVERPAGE               3
#define PROP_FONT                           4
#define PROP_SEND_SINGLE_RECEIPT            5
#define PROP_LINK_COVERPAGE                 6
#define PROP_ATTACH_FAX                     7


#define PR_FAX_PRINTER_NAME                 PROP_TAG( PT_BINARY,(BASE_PROVIDER_ID + PROP_FAX_PRINTER_NAME) )
#define PR_USE_COVERPAGE                    PROP_TAG( PT_LONG,  (BASE_PROVIDER_ID + PROP_USE_COVERPAGE)    )
#define PR_COVERPAGE_NAME	                PROP_TAG( PT_BINARY,(BASE_PROVIDER_ID + PROP_COVERPAGE_NAME)   )
#define PR_SERVER_COVERPAGE                 PROP_TAG( PT_LONG,	(BASE_PROVIDER_ID + PROP_SERVER_COVERPAGE) )
#define PR_FONT                             PROP_TAG( PT_BINARY,(BASE_PROVIDER_ID + PROP_FONT)             )
#define PR_SEND_SINGLE_RECEIPT              PROP_TAG( PT_LONG,	(BASE_PROVIDER_ID + PROP_SEND_SINGLE_RECEIPT))
#define PR_LINK_COVERPAGE                   PROP_TAG( PT_LONG,	(BASE_PROVIDER_ID + PROP_LINK_COVERPAGE)   )
#define PR_ATTACH_FAX                       PROP_TAG( PT_LONG,	(BASE_PROVIDER_ID + PROP_ATTACH_FAX)       )


typedef struct _FAXXP_CONFIG {
    LPTSTR  PrinterName;
    LPTSTR  CoverPageName;
    BOOL    UseCoverPage;
    BOOL    ServerCoverPage;
    LPTSTR  ServerName;
    BOOL    ServerCpOnly;
    BOOL    LinkCoverPage;
    LOGFONT FontStruct;
    BOOL    SendSingleReceipt;
    BOOL    bAttachFax;
} FAXXP_CONFIG, *PFAXXP_CONFIG;


const static SizedSPropTagArray( NUM_FAX_PROPERTIES, sptFaxProps ) =
{
    NUM_FAX_PROPERTIES,
    {
        PR_FAX_PRINTER_NAME,
        PR_USE_COVERPAGE,
        PR_COVERPAGE_NAME,
        PR_SERVER_COVERPAGE,
        PR_FONT,
        PR_SEND_SINGLE_RECEIPT,
		PR_LINK_COVERPAGE,
        PR_ATTACH_FAX
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\exchange\xport\config.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    config.cpp

Abstract:

    This module contains routines for the fax config dialog.

Author:

    Wesley Witt (wesw) 13-Aug-1996

Revision History:

    20/10/99 -danl-
        Fix ConfigDlgProc to view proper printer properties.

    dd/mm/yy -author-
        description


--*/

#include "faxxp.h"
#include "faxutil.h"
#include "faxreg.h"
#include "resource.h"
#include "debugex.h"
#pragma hdrstop



VOID
AddCoverPagesToList(
    HWND        hwndList,
    LPTSTR      pDirPath,
    BOOL        ServerCoverPage
    )

/*++

Routine Description:

    Add the cover page files in the specified directory to a listbox

Arguments:

    hwndList        - Handle to a list window
    pDirPath        - Directory to look for coverpage files
    ServerCoverPage - TRUE if the dir contains server cover pages

Return Value:

    NONE

--*/

{
    WIN32_FIND_DATA findData;
    TCHAR           tszDirName[MAX_PATH] = {0};
    TCHAR           CpName[MAX_PATH] = {0};
    HANDLE          hFindFile = INVALID_HANDLE_VALUE;
    TCHAR           tszFileName[MAX_PATH] = {0};
    TCHAR           tszPathName[MAX_PATH] = {0};
    TCHAR*          pPathEnd;
    LPTSTR          pExtension;
    INT             listIndex;
    INT             dirLen;
    INT             fileLen;
    INT             flags = 0;
    INT             Cnt = 2;
    DWORD           dwMask = 0;
    BOOL            bGotFile = FALSE;

    DBG_ENTER(TEXT("AddCoverPagesToList"));
    //
    // Copy the directory path to a local buffer
    //

    if (pDirPath == NULL || pDirPath[0] == 0) 
    {
        return;
    }

    if ((dirLen = _tcslen( pDirPath )) >= MAX_PATH - MAX_FILENAME_EXT - 1) 
    {
        return;
    }

    _tcscpy( tszDirName, pDirPath );

	TCHAR* pLast = NULL;
    pLast = _tcsrchr(tszDirName,TEXT('\\'));
    if( !( pLast && (*_tcsinc(pLast)) == '\0' ) )
    {
        // the last character is not a backslash, add one...
        _tcscat(tszDirName, TEXT("\\"));
        dirLen += sizeof(TCHAR);
    }

    _tcsncpy(tszPathName, tszDirName, sizeof(tszPathName)/sizeof(tszPathName[0]));
    pPathEnd = _tcschr(tszPathName, '\0');

    //
    // Go through the following loop twice:
    //  Once to add the files with .cov extension
    //  Again to add the files with .lnk extension
    //
    // Don't chase links for server based cover pages
    //
    TCHAR file_to_find[MAX_PATH] = {0};
    LPCTSTR _extension = NULL; 


    while( Cnt ) 
    {
        _tcscpy(file_to_find,tszDirName);
        //
        //*.lnk ext. is possible only for personal cp, other cp are with *.cov ext.
        //
        _extension = ((!ServerCoverPage) && (flags & CPFLAG_LINK)) 
                                ? FAX_LNK_FILE_MASK : FAX_COVER_PAGE_MASK;                      
        _tcscat(file_to_find, _extension );

        //
        // Call FindFirstFile/FindNextFile to enumerate the files
        // matching our specification
        //
        hFindFile = FindFirstFile( file_to_find, &findData );
        if (hFindFile == INVALID_HANDLE_VALUE)
        {
            CALL_FAIL(GENERAL_ERR, TEXT("FindFirstFile"), ::GetLastError());
            bGotFile = FALSE;
        }
        else
        {
            bGotFile = TRUE;
        }
        while (bGotFile) 
        {
            _tcsncpy(pPathEnd, findData.cFileName, MAX_PATH - dirLen);
            if(!IsValidCoverPage(tszPathName))
            {
                goto next;
            }                

            //
            // Exclude directories and hidden files
            //

            if (findData.dwFileAttributes & (FILE_ATTRIBUTE_HIDDEN|FILE_ATTRIBUTE_DIRECTORY)) 
            {
                continue;
            }

            //
            // Make sure we have enough room to store the full pathname
            //

            if ((fileLen = _tcslen( findData.cFileName)) <= MAX_FILENAME_EXT ) 
            {
                continue;
            }

            if (fileLen + dirLen >= MAX_PATH) 
            {
                continue;
            }

            //
            // If we're chasing links, make sure the link refers to
            // a cover page file.
            //
            if (!ServerCoverPage && (flags & CPFLAG_LINK)) 
            {
                _tcscpy(tszFileName, tszDirName);
                _tcscat( tszFileName, findData.cFileName );

                if (!IsCoverPageShortcut(tszFileName)) 
                {
                    continue;
                }
            }
         
            //
            // Add the cover page name to the list window, 
            // but don't display the filename extension
            //
            _tcscpy( CpName, findData.cFileName );
            
            if (pExtension = _tcsrchr(CpName,TEXT('.'))) 
            {
                *pExtension = NULL;
            }

            if ( ! ServerCoverPage )
            {
                TCHAR szPersonal[30];
                LoadString( g_FaxXphInstance, IDS_PERSONAL, szPersonal, 30 );
                _tcscat( CpName, TEXT(" "));
                _tcscat( CpName, szPersonal );
            }

            listIndex = (INT)SendMessage(
                        hwndList,
                        LB_ADDSTRING,
                        0,
                        (LPARAM) CpName
                        );

            if (listIndex != LB_ERR) 
            {
                dwMask = ServerCoverPage ? SERVER_COVER_PAGE : 0;
                if(!ServerCoverPage)
                {
                    dwMask |= (flags & CPFLAG_LINK) ?  SHORTCUT_COVER_PAGE : 0;
                }
                SendMessage( hwndList, LB_SETITEMDATA, listIndex, dwMask);
            }
next:     
            bGotFile = FindNextFile(hFindFile, &findData);
            if (! bGotFile)
            {
                VERBOSE(DBG_MSG, TEXT("FindNextFile"), ::GetLastError());
                break;
            }            
        }
        
        if(INVALID_HANDLE_VALUE != hFindFile)
        {
            FindClose(hFindFile);
        }

        flags ^= CPFLAG_LINK;
        Cnt -= 1;
        if (ServerCoverPage) 
        {
            break;
            //
            // no need to look again, server cp can only be *.cov, and we've delt with them already.
            //       
        }
    }
}



VOID
DrawSampleText(
    HWND hDlg,
    HDC hDC,
    PFAXXP_CONFIG FaxConfig
    )
{

    int PointSize;
    TCHAR PointSizeBuffer[16];
    TCHAR FontTypeBuffer[32];
    BOOL bItalic = FALSE;
    BOOL bBold = FALSE;

    DBG_ENTER(TEXT("DrawSampleText"));    

    PointSize = abs ( MulDiv((int) FaxConfig->FontStruct.lfHeight, 72, GetDeviceCaps( hDC, LOGPIXELSY)));
    _stprintf( PointSizeBuffer, TEXT("%d"), PointSize );
    SetWindowText( GetDlgItem( hDlg, IDC_FONT_SIZE ), PointSizeBuffer );

    SetWindowText( GetDlgItem( hDlg, IDC_FONT_NAME), FaxConfig->FontStruct.lfFaceName );

    //
    // get the font type
    //
    ZeroMemory(FontTypeBuffer, sizeof(FontTypeBuffer) );
    if (FaxConfig->FontStruct.lfItalic)  
    {
        bItalic = TRUE;
    }

    if ( FaxConfig->FontStruct.lfWeight == FW_BOLD ) 
    {
        bBold = TRUE;
    }

    if (bBold) 
    {
        LoadString(g_FaxXphInstance, IDS_FONT_BOLD, FontTypeBuffer, sizeof(FontTypeBuffer) / sizeof(FontTypeBuffer[0]) );
        // concat "italic"
        if (bItalic) 
        {
            LoadString(g_FaxXphInstance, 
                       IDS_FONT_ITALIC, 
                       &FontTypeBuffer[lstrlen(FontTypeBuffer)],
                       sizeof(FontTypeBuffer) / sizeof(FontTypeBuffer[0]) - lstrlen(FontTypeBuffer) );
        }
    } 
    else if (bItalic) 
    {
        LoadString(g_FaxXphInstance, IDS_FONT_ITALIC, FontTypeBuffer, sizeof(FontTypeBuffer) / sizeof(FontTypeBuffer[0]) );
    } 
    else 
    {
        LoadString(g_FaxXphInstance, IDS_FONT_REGULAR, FontTypeBuffer, sizeof(FontTypeBuffer) / sizeof(FontTypeBuffer[0]) );
    }

    
    SetWindowText( GetDlgItem( hDlg, IDC_FONT_STYLE), FontTypeBuffer );

    
}


void EnableCoverPageList(HWND hDlg)
{

    DBG_ENTER(TEXT("EnableCoverPageList"));   

    if (IsDlgButtonChecked( hDlg, IDC_USE_COVERPAGE ) == BST_CHECKED) 
    {
        EnableWindow( GetDlgItem( hDlg, IDC_COVERPAGE_LIST ), TRUE  );
        EnableWindow( GetDlgItem( hDlg, IDC_COVERPAGE_LIST_LABEL ), TRUE  );
    } 
    else 
    {
        EnableWindow( GetDlgItem( hDlg, IDC_COVERPAGE_LIST ), FALSE );
        EnableWindow( GetDlgItem( hDlg, IDC_COVERPAGE_LIST_LABEL ), FALSE );
    }
}

INT_PTR CALLBACK
ConfigDlgProc(
    HWND           hDlg,
    UINT           message,
    WPARAM         wParam,
    LPARAM         lParam
    )

/*++

Routine Description:

    Dialog procedure for the fax mail transport configuration

Arguments:

    hDlg        - Window handle for this dialog
    message     - Message number
    wParam      - Parameter #1
    lParam      - Parameter #2

Return Value:

    TRUE    - Message was handled
    FALSE   - Message was NOT handled

--*/

{
    static PFAXXP_CONFIG FaxConfig = NULL;
    static HWND hwndListPrn = NULL;
    static HWND hwndListCov = NULL;

    PPRINTER_INFO_2 PrinterInfo = NULL;
    DWORD  CountPrinters = 0;
    DWORD  dwSelectedItem = 0;    
    DWORD  dwNewSelectedItem = 0;    
    TCHAR  Buffer[256] = {0};
    TCHAR  CpDir[MAX_PATH] = {0};
    LPTSTR p = NULL;
    PAINTSTRUCT ps;    
    HANDLE hFax = NULL;
    DWORD   dwError = 0;
    DWORD   dwMask = 0;
    BOOL    bShortCutCp = FALSE;
    BOOL    bGotFaxPrinter = FALSE;
    BOOL    bIsCpLink = FALSE;

    DBG_ENTER(TEXT("ConfigDlgProc"));

	switch( message ) 
    {
        case WM_INITDIALOG:
            FaxConfig = (PFAXXP_CONFIG) lParam;

            hwndListPrn = GetDlgItem( hDlg, IDC_PRINTER_LIST );
            hwndListCov = GetDlgItem( hDlg, IDC_COVERPAGE_LIST );            
            
            //
            // populate the printers combobox
            //
            PrinterInfo = (PPRINTER_INFO_2) MyEnumPrinters(NULL, 
                                                           2, 
                                                           &CountPrinters);
            if (NULL != PrinterInfo) 
            {
                DWORD j = 0;
                for (DWORD i=0; i<CountPrinters; i++) 
                {
                    if ((NULL != PrinterInfo[i].pDriverName) && 
						(_tcscmp( PrinterInfo[i].pDriverName, FAX_DRIVER_NAME ) == 0)) 
                    {
                        //
                        //if the current printer is a fax printer, add it to the CB list
                        //
                        bGotFaxPrinter = TRUE;
                        SendMessage( hwndListPrn, CB_ADDSTRING, 0, (LPARAM) PrinterInfo[i].pPrinterName );

                        if ((NULL != FaxConfig->PrinterName)      && 
                            (NULL != PrinterInfo[i].pPrinterName) &&
                            (_tcscmp( PrinterInfo[i].pPrinterName, FaxConfig->PrinterName ) == 0))
                        {
                            //
                            //if it is also the default printer according to transport config.
                            //place the default selection on it
                            //
                        
                            dwSelectedItem = j;
                        }

                        if(FaxConfig->PrinterName == NULL || _tcslen(FaxConfig->PrinterName) == 0)
                        {
                            //
                            // There is no default fax printer
                            // Choose the first one
                            //
                            MemFree(FaxConfig->PrinterName);
                            FaxConfig->PrinterName = StringDup(PrinterInfo[i].pPrinterName);
                            if(FaxConfig->PrinterName == NULL)
                            {
                                CALL_FAIL(MEM_ERR, TEXT("StringDup"), ERROR_NOT_ENOUGH_MEMORY);
                                ErrorMsgBox(g_FaxXphInstance, IDS_OUT_OF_MEM);
                                EndDialog( hDlg, IDABORT);
                                return FALSE;
                            }

                            if(PrinterInfo[i].pServerName)
                            {
                                MemFree(FaxConfig->ServerName);
                                FaxConfig->ServerName = StringDup(PrinterInfo[i].pServerName);
                                if(FaxConfig->ServerName == NULL)
                                {
                                    CALL_FAIL(MEM_ERR, TEXT("StringDup"), ERROR_NOT_ENOUGH_MEMORY);
                                    ErrorMsgBox(g_FaxXphInstance, IDS_OUT_OF_MEM);
                                    EndDialog( hDlg, IDABORT);
                                    return FALSE;
                                }
                            }

                            dwSelectedItem = j;
                        }

                        j += 1;
                    } // if fax printer
                } // for

                MemFree( PrinterInfo );
                PrinterInfo = NULL;
                SendMessage( hwndListPrn, CB_SETCURSEL, (WPARAM)dwSelectedItem, 0 );
            }
            if (! bGotFaxPrinter)
            {
                //
                //  there were no printers at all, or non of the printers is a fax printer.
                //
                CALL_FAIL(GENERAL_ERR, TEXT("MyEnumPrinters"), ::GetLastError());
                ErrorMsgBox(g_FaxXphInstance, IDS_NO_FAX_PRINTER);
                EndDialog( hDlg, IDABORT);
				break;
            }

            //            
            // Get the Server CP flag and receipts options
            //
            FaxConfig->ServerCpOnly = FALSE;
            if (FaxConnectFaxServer(FaxConfig->ServerName,&hFax))
            {
                DWORD dwReceiptOptions;
                BOOL  bEnableReceiptsCheckboxes = FALSE;

                if(!FaxGetPersonalCoverPagesOption(hFax, &FaxConfig->ServerCpOnly))
                {
                    CALL_FAIL(GENERAL_ERR, TEXT("FaxGetPersonalCoverPagesOption"), ::GetLastError());
                    ErrorMsgBox(g_FaxXphInstance, IDS_CANT_ACCESS_SERVER);
                }
                else
                {
                    //
                    // Inverse logic
                    //
                    FaxConfig->ServerCpOnly = !FaxConfig->ServerCpOnly;
                }
                if (!FaxGetReceiptsOptions (hFax, &dwReceiptOptions))
                {
                    CALL_FAIL(GENERAL_ERR, TEXT("FaxGetPersonalCoverPagesOption"), GetLastError());
                }
                else
                {
                    if (DRT_EMAIL & dwReceiptOptions)
                    {
                        //
                        // Server supports receipts by email - enable the checkboxes
                        //
                        bEnableReceiptsCheckboxes = TRUE;
                    }
                }
                EnableWindow( GetDlgItem( hDlg, IDC_ATTACH_FAX),          bEnableReceiptsCheckboxes);
                EnableWindow( GetDlgItem( hDlg, IDC_SEND_SINGLE_RECEIPT), bEnableReceiptsCheckboxes);

                FaxClose(hFax);
                hFax = NULL;
            }

            else
            {
                CALL_FAIL(GENERAL_ERR, TEXT("FaxConnectFaxServer"), ::GetLastError());
                ErrorMsgBox(g_FaxXphInstance, IDS_CANT_ACCESS_SERVER);
            }
            //
            //send single receipt for a fax sent to multiple recipients?
            //
            if(FaxConfig->SendSingleReceipt)
            {
                CheckDlgButton( hDlg, IDC_SEND_SINGLE_RECEIPT, BST_CHECKED );
            }
            //
            // Attach fax document?
            //
            if (FaxConfig->bAttachFax)
            {
                CheckDlgButton( hDlg, IDC_ATTACH_FAX, BST_CHECKED );
            }
            //
            //cover page CB & LB enabling
            //
            if (FaxConfig->UseCoverPage)
            {
                CheckDlgButton( hDlg, IDC_USE_COVERPAGE, BST_CHECKED );
            }
            EnableCoverPageList(hDlg);

            //
            // Emulate printer's selection change, in order to collect printer config info.
            // including cover pages LB population
            //
            ConfigDlgProc(hDlg, WM_COMMAND,MAKEWPARAM(IDC_PRINTER_LIST,CBN_SELCHANGE),(LPARAM)0);
            break;

        case ( WM_PAINT ) :
            if (BeginPaint( hDlg, &ps )) 
            {
                DrawSampleText( hDlg, ps.hdc, FaxConfig );
                EndPaint( hDlg, &ps );
            }
            break;

        case WM_COMMAND:
            if (HIWORD(wParam) == BN_CLICKED) 
            {
                if (LOWORD(wParam) == IDC_USE_COVERPAGE) 
                {
                    EnableCoverPageList(hDlg);
                    return FALSE;
                }  
            }

            if (HIWORD(wParam) == CBN_SELCHANGE && LOWORD(wParam) == IDC_PRINTER_LIST) 
            {
                //
                // refresh cover pages list
                //

                TCHAR SelectedPrinter[50];
                //
                // a new fax printer was selected - delete all old coverpages from the list
                // because they might include the old fax server's cover pages
                //
                SendMessage(hwndListCov, LB_RESETCONTENT, 0, 0);

                if (CB_ERR != (dwSelectedItem = (DWORD)SendMessage( hwndListPrn, CB_GETCURSEL, 0, 0 )))
                //
                // get the 0 based index of the currently pointed printer
                //
                {
                    if (CB_ERR != SendMessage( hwndListPrn, CB_GETLBTEXT, dwSelectedItem, (LPARAM) SelectedPrinter )) 
                    //
                    // get that printer's name into SelectedPrinter
                    //
                    {
                        if (NULL != (PrinterInfo = (PPRINTER_INFO_2) MyGetPrinter( SelectedPrinter, 2 )))
                        {
                            LPTSTR lptszServerName = NULL;
                            if (GetServerNameFromPrinterInfo(PrinterInfo,&lptszServerName))
                            {
                                if (GetServerCpDir( lptszServerName, CpDir, sizeof(CpDir)/sizeof(CpDir[0]) ))
                                {
                                    AddCoverPagesToList( hwndListCov, CpDir, TRUE );
                                }
                                if ((NULL == FaxConfig->ServerName) ||(NULL == lptszServerName) ||
                                    (_tcscmp(FaxConfig->ServerName,lptszServerName) != 0)) 
                                {
                                    //
                                    // the server's name and config are not updated - refresh them
                                    //
                                    MemFree(FaxConfig->ServerName);
                                    FaxConfig->ServerName = lptszServerName;

                                    //
                                    // get the new server's ServerCpOnly flag
                                    //
                                    FaxConfig->ServerCpOnly = FALSE;
                                    if (FaxConnectFaxServer(FaxConfig->ServerName,&hFax) )
                                    {
                                        DWORD dwReceiptOptions;
                                        BOOL  bEnableReceiptsCheckboxes = FALSE;
                                        if (!FaxGetPersonalCoverPagesOption(hFax,&FaxConfig->ServerCpOnly))
                                        {
                                            CALL_FAIL(GENERAL_ERR, TEXT("FaxGetPersonalCoverPagesOption"), GetLastError());
                                        }
                                        else
                                        {
                                            //
                                            // inverse logic
                                            //
                                            FaxConfig->ServerCpOnly = !FaxConfig->ServerCpOnly;
                                        }
                                        if (!FaxGetReceiptsOptions (hFax, &dwReceiptOptions))
                                        {
                                            CALL_FAIL(GENERAL_ERR, TEXT("FaxGetPersonalCoverPagesOption"), GetLastError());
                                        }
                                        else
                                        {
                                            if (DRT_EMAIL & dwReceiptOptions)
                                            {
                                                //
                                                // Server supports receipts by email - enable the checkboxes
                                                //
                                                bEnableReceiptsCheckboxes = TRUE;
                                            }
                                        }
                                        EnableWindow( GetDlgItem( hDlg, IDC_ATTACH_FAX),          bEnableReceiptsCheckboxes);
                                        EnableWindow( GetDlgItem( hDlg, IDC_SEND_SINGLE_RECEIPT), bEnableReceiptsCheckboxes);

                                        FaxClose(hFax);
                                        hFax = NULL;
                                    }
                                }
                                else 
                                {
                                    //
                                    // The server's name hasn't changed, all details are OK
                                    //
                                    MemFree(lptszServerName);
                                    lptszServerName = NULL;
                                }
                            }
                            else 
                            //
                            // GetServerNameFromPrinterInfo failed
                            //
                            {
                                FaxConfig->ServerCpOnly = FALSE;
                            }

                            //
                            // don't add client coverpages if FaxConfig->ServerCpOnly is set to true
                            //
                            if (! FaxConfig->ServerCpOnly) 
                            {
                                if(GetClientCpDir( CpDir, sizeof(CpDir) / sizeof(CpDir[0])))
                                {
									//
									// if the function failes- the ext. is installed on a machine 
									// that doesn't have a client on it, 
									// so we shouldn't look for personal cp
									//
                                    AddCoverPagesToList( hwndListCov, CpDir, FALSE );
                                }
                            }
                            MemFree( PrinterInfo );
                            PrinterInfo = NULL;

                            //
                            // check if we have any cp in the LB, if not-  don't allow the user to 
                            // ask for a cp with he's fax
                            //
                            DWORD dwItemCount = (DWORD)SendMessage(hwndListCov, LB_GETCOUNT, NULL, NULL);
                            if(LB_ERR == dwItemCount)
                            {
                                CALL_FAIL(GENERAL_ERR, TEXT("SendMessage (LB_GETCOUNT)"), ::GetLastError());
                            }
                            else
                            {
                                EnableWindow( GetDlgItem( hDlg, IDC_USE_COVERPAGE ), dwItemCount ? TRUE : FALSE );
                            }

                            if(FaxConfig->CoverPageName)
                            {
                                _tcscpy( Buffer, FaxConfig->CoverPageName );
                            }
                            if ( ! FaxConfig->ServerCoverPage )
                            {   
                                TCHAR szPersonal[30] = _T("");
                                LoadString( g_FaxXphInstance, IDS_PERSONAL, szPersonal, 30 );
                                _tcscat( Buffer, _T(" ") );
                                _tcscat( Buffer, szPersonal );
                            }

                            dwSelectedItem = (DWORD)SendMessage( hwndListCov, LB_FINDSTRING, -1, (LPARAM) Buffer );
                            //
                            // get the index of the default CP
                            // if it is supposed to be a link, and the cp that we found is not a link, 
                            // find the next string that matches.
                            // this can happen if there's al ink to a cp named X, and a regular cp named X.
                            //
                            if (dwSelectedItem == LB_ERR) 
                            {
                                dwSelectedItem = 0;
                            }
							else
							{
								dwMask = (DWORD)SendMessage( hwndListCov, LB_GETITEMDATA, dwSelectedItem, 0 );
                                if (dwMask != LB_ERR)
                                {
                                    bIsCpLink = (dwMask & SHORTCUT_COVER_PAGE) == SHORTCUT_COVER_PAGE;
                                    if (bIsCpLink != FaxConfig->LinkCoverPage)
                                    {
                                        //
                                        // we got the wrong cp, search for next compatible string
                                        // starting with the one apearing after the current one
                                        //
                                        dwNewSelectedItem = (DWORD)SendMessage( hwndListCov, LB_FINDSTRING, dwSelectedItem, (LPARAM) Buffer );
                                        if(dwNewSelectedItem == dwSelectedItem)
                                        {
                                            // if there's no other string that's compatible, 
                                            // the searcing will start from the begining of 
                                            // the list again, and will find the same (wrong) 
                                            // string again. 
                                            // so, if it's we got the same index, again, 
                                            // selection on 0 (as we do if we didn't find 
                                            // the chosen cp...)
                                            //
                                            dwSelectedItem = 0;
                                        }
                                        else
                                        {
                                            dwSelectedItem = dwNewSelectedItem;
                                        }
                                    }
                                } 
							}
                            SendMessage( hwndListCov, LB_SETCURSEL, (WPARAM) dwSelectedItem, 0 );
                            //
                            // place the default selection on that CP
                            //
                            }
                    }
                }
                break;
            }

            switch (wParam) 
            {
                case IDC_SET_FONT:
                    {
                        CHOOSEFONT  cf;
                        LOGFONT     FontStruct;

                        CopyMemory( &FontStruct, &FaxConfig->FontStruct, sizeof(LOGFONT) );

                        cf.lStructSize = sizeof(CHOOSEFONT);
                        cf.hwndOwner = hDlg;
                        cf.lpLogFont = &FontStruct;
                        cf.Flags = CF_INITTOLOGFONTSTRUCT | CF_SCREENFONTS;
                        cf.rgbColors = 0;
                        cf.lCustData = 0;
                        cf.lpfnHook = NULL;
                        cf.lpTemplateName = NULL;
                        cf.hInstance = NULL;
                        cf.lpszStyle = NULL;
                        cf.nFontType = SCREEN_FONTTYPE;
                        cf.nSizeMin = 0;
                        cf.nSizeMax = 0;

                        if (ChooseFont(&cf)) 
                        {
                            CopyMemory( &FaxConfig->FontStruct, &FontStruct, sizeof(LOGFONT) );
                            InvalidateRect(hDlg, NULL, TRUE);
                            UpdateWindow( hDlg );
                        }
                    }
                    break;

                case IDOK :
                    //
                    // Update UseCoverPage
                    //
                    FaxConfig->UseCoverPage = (IsDlgButtonChecked( hDlg, IDC_USE_COVERPAGE ) == BST_CHECKED);
                    
                    //
                    // Update SendSingleReceipt
                    //
                    FaxConfig->SendSingleReceipt = (IsDlgButtonChecked(hDlg, IDC_SEND_SINGLE_RECEIPT) == BST_CHECKED);
                    
                    //
                    // Update AttachFax
                    //
                    FaxConfig->bAttachFax = (IsDlgButtonChecked(hDlg, IDC_ATTACH_FAX) == BST_CHECKED);

                    //
                    // Update selected printer
                    //
                    dwSelectedItem = (DWORD)SendMessage( hwndListPrn, CB_GETCURSEL, 0, 0 );
                    if (dwSelectedItem != CB_ERR)
                    {
                        if (CB_ERR != SendMessage( hwndListPrn, CB_GETLBTEXT, dwSelectedItem, (LPARAM) Buffer ))
                        {
                            MemFree( FaxConfig->PrinterName );
                            FaxConfig->PrinterName = StringDup( Buffer );
                            if(!FaxConfig->PrinterName)
                            {
                                CALL_FAIL(MEM_ERR, TEXT("StringDup"), ERROR_NOT_ENOUGH_MEMORY);
                                ErrorMsgBox(g_FaxXphInstance, IDS_OUT_OF_MEM);
                                EndDialog( hDlg, IDABORT);
                                break;
                            }                            
                        }
                    }

                    //
                    // Update cover page
                    //
                    dwSelectedItem = (DWORD)SendMessage( hwndListCov, LB_GETCURSEL, 0, 0 );
                    if (dwSelectedItem != LB_ERR) //LB_ERR when no items in list
                    {
                        if (LB_ERR != SendMessage( hwndListCov, LB_GETTEXT, dwSelectedItem, (LPARAM) Buffer ))
                        //
                        // get the selected CP name into the buffer
                        //
                        {
                            dwMask = (DWORD)SendMessage( hwndListCov, LB_GETITEMDATA, dwSelectedItem, 0 );
                            if (dwMask != LB_ERR)
                            {
                                FaxConfig->ServerCoverPage = (dwMask & SERVER_COVER_PAGE) == SERVER_COVER_PAGE;
                                if (!FaxConfig->ServerCoverPage)
                                {
                                    //
                                    // if the selected CP in the LB is not a server's CP
                                    // Omit the suffix: "(personal)"
                                    //
                                    p = _tcsrchr( Buffer, '(' );
                                    Assert(p);
									if( p )
									{
										p = _tcsdec(Buffer,p);
										if( p )
										{
											_tcsnset(p,TEXT('\0'),1);
										}
									}
                                    //
                                    // add the corect ext. to the cp file name
                                    //
                                    FaxConfig->LinkCoverPage = ((dwMask & SHORTCUT_COVER_PAGE) == SHORTCUT_COVER_PAGE)? TRUE : FALSE ;
                                }
                                else
                                {
                                     FaxConfig->LinkCoverPage = FALSE;
                                }
                            }
                            
                            //
                            // update CP name to the selected one in the LB
                            //
                            MemFree( FaxConfig->CoverPageName );
                            FaxConfig->CoverPageName = StringDup( Buffer );
                            if(!FaxConfig->CoverPageName)
                            {
                                CALL_FAIL(MEM_ERR, TEXT("StringDup"), ERROR_NOT_ENOUGH_MEMORY);
                                ErrorMsgBox(g_FaxXphInstance, IDS_OUT_OF_MEM);
                                EndDialog( hDlg, IDABORT);
                                break;
                            }                            
                        }
                    }
                    
                    EndDialog( hDlg, IDOK );
                    break;

                case IDCANCEL:
                    EndDialog( hDlg, IDCANCEL );
                    break;
            }
            break;

        case WM_HELP:
            WinHelpContextPopup(((LPHELPINFO)lParam)->dwContextId, hDlg);
            return TRUE;
        case WM_CONTEXTMENU:
            WinHelpContextPopup(GetWindowContextHelpId((HWND)wParam), hDlg);            
            return TRUE;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\exchange\xport\faxdoc.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    faxdoc.cpp

Abstract:

    This module contains all code necessary to print an
    exchange message as a fax document.

Author:

    Wesley Witt (wesw) 13-Aug-1996

Revision History:

    20/10/99 -danl-
        Connect to appropriate server, get basenote from windir

    dd/mm/yy -author-
        description

--*/
#include "faxxp.h"
#include "emsabtag.h"
#include "mapiutil.h"
#include "debugex.h"

#include <set>
using namespace std;

#pragma hdrstop


struct CRecipCmp
{
/*
    Comparison operator 'less'
    Compare two FAX_PERSONAL_PROFILEs by recipient's name and fax number
*/
    bool operator()(LPCFAX_PERSONAL_PROFILE lpcRecipient1, 
                    LPCFAX_PERSONAL_PROFILE lpcRecipient2) const
    {
        bool bRes = false;
        int  nFaxNumberCpm = 0;

        if(!lpcRecipient1 ||
           !lpcRecipient2 ||
           !lpcRecipient1->lptstrFaxNumber ||
           !lpcRecipient2->lptstrFaxNumber)
        {
            Assert(false);
            return bRes;
        }
       
        nFaxNumberCpm = _tcscmp(lpcRecipient1->lptstrFaxNumber, lpcRecipient2->lptstrFaxNumber);

        if(nFaxNumberCpm < 0)
        {
            bRes = true;
        }
        else if(nFaxNumberCpm == 0)
        {
            //
            // The fax numbers are same
            // lets compare the names
            //
            if(lpcRecipient1->lptstrName && lpcRecipient2->lptstrName)
            {
                bRes = (_tcsicmp(lpcRecipient1->lptstrName, lpcRecipient2->lptstrName) < 0);
            }
            else
            {
                bRes = (lpcRecipient1->lptstrName < lpcRecipient2->lptstrName);
            }
        }

        return bRes;
    }
};

typedef set<LPCFAX_PERSONAL_PROFILE, CRecipCmp> RECIPIENTS_SET;

// prototypes
LPTSTR ConvertAStringToTString(LPCSTR lpcstrSource);

extern "C"
BOOL MergeTiffFiles(
    LPTSTR BaseTiffFile,
    LPTSTR NewTiffFile
    );

extern "C"
BOOL PrintRandomDocument(
    LPCTSTR FaxPrinterName,
    LPCTSTR DocName,
    LPTSTR OutputFile
    );


PVOID
CXPLogon::MyGetPrinter(
    LPTSTR PrinterName,
    DWORD Level
    )

/*++

Routine Description:

    Gets the printer data for a specific printer

Arguments:

    PrinterName - Name of the desired printer

Return Value:

    Pointer to a printer info structure or NULL for failure.

--*/

{
	DBG_ENTER(TEXT("CXPLogon::MyGetPrinter"));

    PVOID PrinterInfo = NULL;
    HANDLE hPrinter = NULL;
    DWORD Bytes;
    PRINTER_DEFAULTS PrinterDefaults;


    PrinterDefaults.pDatatype     = NULL;
    PrinterDefaults.pDevMode      = NULL;
    PrinterDefaults.DesiredAccess = PRINTER_ACCESS_USE;

    if (!OpenPrinter( PrinterName, &hPrinter, &PrinterDefaults )) 
    {
        CALL_FAIL (GENERAL_ERR, TEXT("OpenPrinter"),::GetLastError());
		goto exit;
    }

    
    if ((!GetPrinter( hPrinter, Level, NULL, 0, &Bytes )) && (::GetLastError() != ERROR_INSUFFICIENT_BUFFER)) 
    {
        // we just want to know how much memory we need, so we pass NULL and 0, 
        // this way, the function will fail, but will return us the number of 
        // bytes required in Bytes
        CALL_FAIL (GENERAL_ERR, TEXT("GetPrinter"), ::GetLastError());
		goto exit;
    }

    PrinterInfo = (LPPRINTER_INFO_2) MemAlloc( Bytes );
    if (!PrinterInfo) 
    {
        goto exit;
    }

    if (!GetPrinter( hPrinter, Level, (LPBYTE) PrinterInfo, Bytes, &Bytes )) 
    {
        MemFree(PrinterInfo);
        PrinterInfo = NULL;
        goto exit;
    }
    
exit:
    if(hPrinter)
    {
        ClosePrinter( hPrinter );
    }
    return PrinterInfo;
}

static BOOL
GetFaxTempFileName(
    OUT LPTSTR lpstrTempName
                  )
/*++

Routine Description:

    Generates a temporal file with prefix 'fax' in directory
    designated for temporal files.
Arguments:

    lpstrTempName    - Output paramter. Pointer to the temporal file name.
                       The buffer should be MAX_PATH characters.

Return Value:

    TRUE if success, FALSE otherwise

--*/

{
	BOOL bRes = TRUE;
	DBG_ENTER(TEXT("GetFaxTempFileName"),bRes);

    TCHAR strTempPath[MAX_PATH];
    TCHAR strTempFile[MAX_PATH];
    DWORD ec = ERROR_SUCCESS; // LastError for this function.

    Assert(lpstrTempName);

    if (!GetTempPath( sizeof(strTempPath)/sizeof(TCHAR), strTempPath )) 
    {
        ec=::GetLastError();
        goto Exit;
    }

    if (GetTempFileName( strTempPath, _T("fax"), 0, strTempFile ) == 0)
    {
        ec=::GetLastError();
        goto Exit;

    }
    _tcsncpy(lpstrTempName,strTempFile,sizeof(strTempFile)/sizeof(TCHAR));

Exit:
    if (ERROR_SUCCESS != ec) 
    {
        SetLastError(ec);
        bRes = FALSE;
    }
    return bRes;
}

BOOL
CXPLogon::PrintRichText(
    HWND hWndRichEdit,
    HDC  hDC
    )

/*++

Routine Description:

    Prints the rich text contained in a rich text
    window into a DC.

Arguments:

    hWndRichEdit    - Window handle for the rich text window
    hDC             - Printer device context

Return Value:

    None.

--*/

{
	BOOL bRet = FALSE;
	DBG_ENTER(TEXT("CXPLogon::PrintRichText"),bRet);

    FORMATRANGE fr;
    LONG lTextOut;
    LONG lTextCurr;
    RECT rcTmp;


    fr.hdc           = hDC;
    fr.hdcTarget     = hDC;
    fr.chrg.cpMin    = 0;
    fr.chrg.cpMax    = -1;

    //
    // Set page rect to phys page size in twips
    //
    fr.rcPage.top    = 0;
    fr.rcPage.left   = 0;
    fr.rcPage.right  = MulDiv(GetDeviceCaps(hDC, PHYSICALWIDTH),
                              1440,
                              GetDeviceCaps(hDC, LOGPIXELSX));
    fr.rcPage.bottom = MulDiv(GetDeviceCaps(hDC, PHYSICALHEIGHT),
                              1440,
                              GetDeviceCaps(hDC, LOGPIXELSY));

    //
    // Set up 3/4" horizontal and 1" vertical margins, but leave a minimum of 1"
    // printable space in each direction.  Otherwise, use full page.
    //
    fr.rc = fr.rcPage; // start with full page
    if (fr.rcPage.right > 2*3*1440/4 + 1440) 
    {
        fr.rc.right -= (fr.rc.left = 3*1440/4);
    }
    if (fr.rcPage.bottom > 3*1440) 
    {
        fr.rc.bottom -= (fr.rc.top = 1440);
    }

    //
    // save the formatting rectangle
    //
    rcTmp = fr.rc;

    if (!SetMapMode( hDC, MM_TEXT ))
    {
        CALL_FAIL (GENERAL_ERR, TEXT("SetMapMode"), ::GetLastError());
        goto error;
    }

    lTextOut  = 0;
    lTextCurr = 0;

    while (TRUE) 
    {
        //
        // Just measure the text
        //
        lTextOut = (LONG)SendMessage( hWndRichEdit, EM_FORMATRANGE, FALSE, (LPARAM) &fr );
        if(lTextOut <= lTextCurr)
        {
            //
            // The end of the text
            //
            break;
        }

        lTextCurr = lTextOut;

        if (StartPage( hDC ) <= 0)
        {
            CALL_FAIL (GENERAL_ERR, TEXT("StartPage"), ::GetLastError());
            goto error;
        }

        //
        // Render the page
        //
        lTextOut = (LONG)SendMessage( hWndRichEdit, EM_FORMATRANGE, TRUE, (LPARAM) &fr );

        if (EndPage( hDC ) <= 0)
        {
            CALL_FAIL (GENERAL_ERR, TEXT("EndPage"), ::GetLastError());
            goto error;
        }


        fr.chrg.cpMin = lTextOut;
        fr.chrg.cpMax = -1;


       //
       // EM_FORMATRANGE tends to modify fr.rc.bottom, reset here
       //
       fr.rc = rcTmp;
    }

    bRet = TRUE;

error:
    //
    // flush the cache
    //
    SendMessage( hWndRichEdit, EM_FORMATRANGE, TRUE, (LPARAM) NULL );
    return bRet;
}

DWORD
CXPLogon::PrintPlainText(
    HDC hDC,
    LPSTREAM lpstmT,
    LPTSTR   tszSubject,
    PFAXXP_CONFIG FaxConfig
    )

/*++

Routine Description:

    Prints a stream of plain text into the printer DC provided.
    Note: this code was stolen from notepad.

Arguments:

    hDC         - Printer DC
    lpstmT      - Stream pointer for rich text.
    tszSubject  - Subject
    FaxConfig   - Fax configuration data

Return Value:

    ERROR_SUCCESS - if success
    Error IDS_... code if failed.

--*/

{
	DWORD  rVal = ERROR_SUCCESS;
    LPTSTR BodyText = NULL;
    LPTSTR lpLine;
    LPTSTR pLineEOL;
    LPTSTR pNextLine;
    HRESULT hResult;
    HFONT hFont = NULL;
    HFONT hPrevFont = NULL;
    TEXTMETRIC tm;
    INT nLinesPerPage;
    INT dyTop;              // width of top border (pixels)
    INT dyBottom;           // width of bottom border
    INT dxLeft;             // width of left border
    INT dxRight;            // width of right border
    INT yPrintChar;         // height of a character
    INT tabSize;            // Size of a tab for print device in device units
    INT yCurpos = 0;
    INT xCurpos = 0;
    INT nPixelsLeft = 0;
    INT guess = 0;
    SIZE Size;                 // to see if text will fit in space left
    INT nPrintedLines = 0;
    BOOL fPageStarted = FALSE;
    INT iPageNum = 0;
    INT xPrintRes;          // printer resolution in x direction
    INT yPrintRes;          // printer resolution in y direction
    INT yPixInch;           // pixels/inch
    INT xPixInch;           // pixels/inch
    INT xPixUnit;           // pixels/local measurement unit
    INT yPixUnit;           // pixels/local measurement unit
    BOOL fEnglish;
    DWORD Chars=0;
    DWORD dwBodyLen=0;
    DWORD dwSubjectLen=0;
    STATSTG Stats;
    INT PrevBkMode = 0;

    DBG_ENTER(TEXT("CXPLogon::PrintPlainText"),rVal);

    Assert(hDC);
    Assert(FaxConfig);

    if(lpstmT)
    {
        hResult = lpstmT->Stat( &Stats, 0 );
        if (hResult) 
        {
            rVal = IDS_CANT_ACCESS_MSG_DATA;
            goto exit;
        }
    
        dwBodyLen = (INT) Stats.cbSize.QuadPart;
    }

    if(tszSubject)
    {
        dwSubjectLen = _tcslen(tszSubject);
    }

    BodyText = (LPTSTR) MemAlloc(dwSubjectLen * sizeof(TCHAR) + dwBodyLen + 4 );
    if (!BodyText) 
    {
        rVal = IDS_OUT_OF_MEM;
        goto exit;
    }

    if(tszSubject)
    {
        _tcscpy(BodyText, tszSubject);
        lpLine = _tcsninc(BodyText, dwSubjectLen);
    }
    else
    {
        lpLine = BodyText;
    }

    if(lpstmT)
    {
        hResult = lpstmT->Read( (LPVOID)lpLine, dwBodyLen, (LPDWORD) &dwBodyLen );
        if (hResult) 
        {
            rVal = IDS_CANT_ACCESS_MSG_DATA;
            goto exit;
        }
    }

    lpLine = BodyText;
    Chars  = _tcslen(lpLine);

    //
    // check if the body is not empty
    // if the message length is shorter then 32(arbitrary number) 
    // and all the carachters are control or space.
    //
    if(Chars < 32)
    {
        BOOL bEmpty = TRUE;
        TCHAR* pTchar = lpLine;
        for(DWORD dw = 0; dw < Chars; ++dw)
        {
            if(!_istspace(*pTchar) && !_istcntrl(*pTchar))
            {
                bEmpty = FALSE;
                break;
            }
            pTchar = _tcsinc(pTchar);
        }
        if(bEmpty)
        {
            rVal = IDS_NO_MSG_BODY;
            goto exit;
        }
    }

    fEnglish = GetProfileInt( _T("intl"), _T("iMeasure"), 1 );

    xPrintRes = GetDeviceCaps( hDC, HORZRES );
    yPrintRes = GetDeviceCaps( hDC, VERTRES );
    xPixInch  = GetDeviceCaps( hDC, LOGPIXELSX );
    yPixInch  = GetDeviceCaps( hDC, LOGPIXELSY );
    //
    // compute x and y pixels per local measurement unit
    //
    if (fEnglish) 
    {
        xPixUnit= xPixInch;
        yPixUnit= yPixInch;
    } 
    else 
    {
        xPixUnit= CMToInches( xPixInch );
        yPixUnit= CMToInches( yPixInch );
    }

    SetMapMode( hDC, MM_TEXT );

    //
    // match font size to the device point size
    //
    FaxConfig->FontStruct.lfHeight = -MulDiv(FaxConfig->FontStruct.lfHeight, yPixInch, 72);

    hFont = CreateFontIndirect( &FaxConfig->FontStruct );

    hPrevFont = (HFONT) SelectObject( hDC, hFont );
    SetBkMode( hDC, TRANSPARENT );
    if (!GetTextMetrics( hDC, &tm )) 
    {
        rVal = IDS_CANT_PRINT_BODY;
        goto exit;
    }

    yPrintChar = tm.tmHeight + tm.tmExternalLeading;
    tabSize = tm.tmAveCharWidth * 8;

    //
    // compute margins in pixels
    //
    dxLeft     = LEFT_MARGIN    *  xPixUnit;
    dxRight    = RIGHT_MARGIN   *  xPixUnit;
    dyTop      = TOP_MARGIN     *  yPixUnit;
    dyBottom   = BOTTOM_MARGIN  *  yPixUnit;

    //
    // Number of lines on a page with margins
    //
    nLinesPerPage = ((yPrintRes - dyTop - dyBottom) / yPrintChar);

    while (*lpLine) 
    {
		if ( _tcsncmp(lpLine,TEXT("\r"),1) == 0 ) 
        {
            lpLine = _tcsninc(lpLine,2);
            yCurpos += yPrintChar;
            nPrintedLines++;
            xCurpos= 0;
            continue;
        }

        pLineEOL = lpLine;
		pLineEOL = _tcschr(pLineEOL,TEXT('\r'));

        do 
        {
            if ((nPrintedLines == 0) && (!fPageStarted)) 
            {
                StartPage( hDC );
                fPageStarted = TRUE;
                yCurpos = 0;
                xCurpos = 0;
            }

            if ( _tcsncmp(lpLine,TEXT("\t"),1) == 0 ) 
            {
                //
                // round up to the next tab stop
                // if the current position is on the tabstop, goto next one
                //
                xCurpos = ((xCurpos + tabSize) / tabSize ) * tabSize;
                lpLine = _tcsinc(lpLine);
            } 
            else 
            {
                //
                // find end of line or tab
                //
                pNextLine = lpLine;
                while (*pNextLine &&
                       (pNextLine != pLineEOL) && 
                       ( _tcsncmp(pNextLine,TEXT("\t"),1) ) )
                {
					pNextLine = _tcsinc(pNextLine);
                }

                //
                // find out how many characters will fit on line
                //
                Chars = (INT)(pNextLine - lpLine);
                nPixelsLeft = xPrintRes - dxRight - dxLeft - xCurpos;
                GetTextExtentExPoint( hDC, lpLine, Chars, nPixelsLeft, &guess, NULL, &Size );

                if (guess) 
                {
                    //
                    // at least one character fits - print
                    //
                    TextOut( hDC, dxLeft+xCurpos, yCurpos+dyTop, lpLine, guess );

                    xCurpos += Size.cx;   // account for printing
					lpLine = _tcsninc(lpLine,guess);// printed characters
                } 
                else 
                {
                    //
                    // no characters fit what's left
                    // no characters will fit in space left
                    // if none ever will, just print one
                    // character to keep progressing through
                    // input file.
                    //
                    if (xCurpos == 0) 
                    {
                        if( lpLine != pNextLine ) 
                        {
                            //
                            // print something if not null line
                            // could use exttextout here to clip
                            //
                            TextOut( hDC, dxLeft+xCurpos, yCurpos+dyTop, lpLine, 1 );
							lpLine = _tcsinc(lpLine);
                        }
                    } 
                    else 
                    {
                        //
                        // perhaps the next line will get it
                        //
                        xCurpos = xPrintRes;  // force to next line
                    }
                }

                //
                // move printhead in y-direction
                //
                if ((xCurpos >= (xPrintRes - dxRight - dxLeft) ) || (lpLine == pLineEOL)) 
                {
                   yCurpos += yPrintChar;
                   nPrintedLines++;
                   xCurpos = 0;
                }

                if (nPrintedLines >= nLinesPerPage) 
                {
                   EndPage( hDC );
                   fPageStarted = FALSE;
                   nPrintedLines = 0;
                   xCurpos = 0;
                   yCurpos = 0;
                   iPageNum++;
                }

            }

        } while (*lpLine &&  (lpLine != pLineEOL));

        if ( _tcsncmp(lpLine,TEXT("\r"),1) == 0 ) 
        {
            lpLine = _tcsinc(lpLine);
        }
        if ( _tcsncmp(lpLine,TEXT("\n"),1) == 0 ) 
        {
            lpLine = _tcsinc(lpLine);
        }

    }

    if (fPageStarted) 
    {
        EndPage( hDC );
    }

exit:
    MemFree( BodyText );
    if (hPrevFont) 
    {
        SelectObject( hDC, hPrevFont );
        DeleteObject( hFont );
    }
    if (PrevBkMode) 
    {
        SetBkMode( hDC, PrevBkMode );
    }
    return rVal;
}

extern "C"
DWORD CALLBACK
EditStreamRead(
    DWORD_PTR dwCookie,
    LPBYTE pbBuff,
    LONG cb,
    LONG *pcb
    )

/*++

Routine Description:

    Wrapper function for the IStream read method.
    This function is used to read rich text from
    an exchange stream.

Arguments:

    dwCookie    - This pointer for the IStream object
    pbBuff      - Pointer to the data buffer
    cb          - Size of the data buffer
    pcb         - Returned byte count

Return Value:

    Return code from IStream::Read

--*/

{
    return ((LPSTREAM)dwCookie)->Read( pbBuff, cb, (ULONG*) pcb );
}

DWORD
CXPLogon::PrintAttachmentToFile(
        IN  LPMESSAGE       pMsgObj,
        IN  PFAXXP_CONFIG   pFaxConfig,
        OUT LPTSTR  *       lpptstrOutAttachments
                     )
/*++

Routine Description:

    Prints all attachments to the output file, by itearating
    over the attachment table
Arguments:

    pMsgObj    -  Pointer to message object. Used to get an attachmnet table
    pFaxConfig - Pointer to fax configuration
    lpptstrOutAttachments - Name of the output tiff file. The string should be empty

Return Value:

    0 - if success
    Last error code from if failed.

Comments:
    If this function succeeded it allocates a memory for *lpptstrOutAttachments
    and creates a temporal file *lpptstrOutAttachments.
    It's up to user to free both these allocations, by
        DeleteFile(*lpptstrOutAttachments);
        MemFree(*lpptstrOutAttachments);

--*/
{
	DWORD   rVal = 0;
    DBG_ENTER(TEXT("CXPLogon::PrintAttachmentToFile"),rVal);

    LPSPropValue pPropsAttachTable = NULL;
    LPSPropValue pPropsAttach = NULL;
    LPMAPITABLE AttachmentTable = NULL;
    LPSRowSet pAttachmentRows = NULL;
    LPATTACH lpAttach = NULL;
    LPSTREAM lpstmA = NULL;
    LPTSTR AttachFileName = NULL;
    TCHAR TempPath[MAX_PATH];
    TCHAR TempFile[MAX_PATH];
    TCHAR DocFile[MAX_PATH];
    HANDLE hFile = INVALID_HANDLE_VALUE;
    LPTSTR DocType = NULL;
    LPSTR p = NULL;
    BOOL DeleteAttachFile = FALSE;
    LPTSTR FileName = NULL;
    BOOL AllAttachmentsGood = TRUE;
    TCHAR   strTempTiffFile[MAX_PATH],strMergedTiffFile[MAX_PATH];;
    HRESULT hResult = S_OK;
    DWORD   i = 0;
    ULONG   PropCount = 0;
    DWORD   Bytes;
    LPTSTR  lptstrTempStr = NULL;
    
    ZeroMemory(strTempTiffFile  ,sizeof(TCHAR)*MAX_PATH);
    ZeroMemory(strMergedTiffFile,sizeof(TCHAR)*MAX_PATH);

    Assert(lpptstrOutAttachments);
    Assert(*lpptstrOutAttachments == NULL);
    //
    // get the attachment table, if it is available
    //

    hResult = pMsgObj->GetAttachmentTable( 0, &AttachmentTable );
    if (HR_SUCCEEDED(hResult)) 
    {
        hResult = HrAddColumns(
            AttachmentTable,
            (LPSPropTagArray) &sptAttachTableProps,
            gpfnAllocateBuffer,
            gpfnFreeBuffer
            );
        if (HR_SUCCEEDED(hResult)) 
        {
            hResult = HrQueryAllRows(
                AttachmentTable,
                NULL,
                NULL,
                NULL,
                0,
                &pAttachmentRows
                );
            if (FAILED(hResult)) 
            {
                pAttachmentRows = NULL;
            } 
            else 
            {
                if (pAttachmentRows->cRows == 0) 
                {
                    FreeProws( pAttachmentRows );
                    pAttachmentRows = NULL;
                }
            }
        }
    }

    if (pAttachmentRows) 
    {

        //
        // this loop verifies that each document's attachment registration
        // supports the printto verb.
        //

        AllAttachmentsGood = TRUE;

        for (i = 0; i < pAttachmentRows->cRows; ++i) 
        {

            pPropsAttachTable = pAttachmentRows->aRow[i].lpProps;
            lpAttach = NULL;
            pPropsAttach = NULL;

            if (pPropsAttachTable[MSG_ATTACH_METHOD].Value.ul == NO_ATTACHMENT) 
            {
                goto next_attachment1;
            }

            //
            // open the attachment
            //

            hResult = pMsgObj->OpenAttach( pPropsAttachTable[MSG_ATTACH_NUM].Value.ul, NULL, MAPI_BEST_ACCESS, &lpAttach );
            if (FAILED(hResult)) 
            {
                AllAttachmentsGood = FALSE;
                goto next_attachment1;
            }

            //
            // get the attachment properties
            //

            hResult = lpAttach->GetProps(
                (LPSPropTagArray) &sptAttachProps,
                0,
                &PropCount,
                &pPropsAttach
                );
            if (FAILED(hResult)) 
            {
                AllAttachmentsGood = FALSE;
                goto next_attachment1;
            }

            //
            // try to get the extension if the file.
            // this indicates what type of dicument it is.
            // if we cannot get the document type then it is
            // impossible to print the document.
            //

            if (DocType) 
            {
                MemFree( DocType );
                DocType = NULL;
            }

            if (PROP_TYPE(pPropsAttach[MSG_ATTACH_EXTENSION].ulPropTag) == PT_ERROR) 
            {
                if (PROP_TYPE(pPropsAttach[MSG_ATTACH_LFILENAME].ulPropTag) != PT_ERROR) 
                {
                    p = strrchr( pPropsAttach[MSG_ATTACH_LFILENAME].Value.lpszA, '.' );
                    if (p) 
                    {
                        DocType = ConvertAStringToTString( p );
                        if(!DocType)
                        {
                            rVal = IDS_OUT_OF_MEM;
                            goto exit;
                        }
                    }
                } 
                else if (PROP_TYPE(pPropsAttach[MSG_ATTACH_FILENAME].ulPropTag) != PT_ERROR) 
                {
                    p = strrchr( pPropsAttach[MSG_ATTACH_FILENAME].Value.lpszA, '.' );
                    if (p) 
                    {
                        DocType = ConvertAStringToTString( p );
                        if(!DocType)
                        {
                            rVal = IDS_OUT_OF_MEM;
                            goto exit;
                        }
                    }
                }

            } 
            else 
            {
                DocType = ConvertAStringToTString( pPropsAttach[MSG_ATTACH_EXTENSION].Value.lpszA );
                if(!DocType)
                {
                    rVal = IDS_OUT_OF_MEM;
                    goto exit;
                }
            }

            if (!DocType) 
            {
                AllAttachmentsGood = FALSE;
                goto next_attachment1;
            }

            Bytes = sizeof(TempFile);
            rVal = RegQueryValue( HKEY_CLASSES_ROOT, DocType, TempFile, (PLONG) &Bytes );
            if ((rVal != ERROR_SUCCESS) && (rVal != ERROR_INVALID_DATA))
			{
				VERBOSE (DBG_MSG, TEXT("File Type: %s: isn't associated to any application"), DocType);
                AllAttachmentsGood = FALSE;
                goto next_attachment1;
            }

            wsprintf( TempPath, _T("%s\\shell\\printto\\command"), TempFile );

            Bytes = sizeof(TempFile);
            rVal = RegQueryValue( HKEY_CLASSES_ROOT, TempPath, TempFile, (PLONG) &Bytes );
            if ((rVal != ERROR_SUCCESS) && (rVal != ERROR_INVALID_DATA))
			{
				VERBOSE (DBG_MSG, TEXT("File extension \"*%s\" doesn't have the PrintTo verb"), DocType);
                AllAttachmentsGood = FALSE;
                goto next_attachment1;
            }
    next_attachment1:

            if (lpAttach) 
            {
                lpAttach->Release();
            }

            if (pPropsAttach) 
			{
                MemFree( pPropsAttach );
				pPropsAttach = NULL;
            }

        }

        if (!AllAttachmentsGood) 
        {
            rVal = IDS_BAD_ATTACHMENTS;
            goto exit;
        }

        for (i = 0; i < pAttachmentRows->cRows; ++i) 
        {
            pPropsAttachTable = pAttachmentRows->aRow[i].lpProps;
            lpAttach = NULL;
            pPropsAttach = NULL;

            if (pPropsAttachTable[MSG_ATTACH_METHOD].Value.ul == NO_ATTACHMENT) 
            {
                goto next_attachment2;
            }

            //
            // open the attachment
            //

            hResult = pMsgObj->OpenAttach( pPropsAttachTable[MSG_ATTACH_NUM].Value.ul, NULL, MAPI_BEST_ACCESS, &lpAttach );
            if (FAILED(hResult)) 
            {
                goto next_attachment2;
            }

            //
            // get the attachment properties
            //

            hResult = lpAttach->GetProps(
                (LPSPropTagArray) &sptAttachProps,
                0,
                &PropCount,
                &pPropsAttach
                );
            if (FAILED(hResult)) 
            {
                goto next_attachment2;
            }

            //
            // try to get the extension if the file.
            // this indicates what type of dicument it is.
            // if we cannot get the document type then it is
            // impossible to print the document.
            //

            if (DocType) 
            {
                MemFree( DocType );
                DocType = NULL;
            }

            if (PROP_TYPE(pPropsAttach[MSG_ATTACH_EXTENSION].ulPropTag) == PT_ERROR) 
            {
                if (PROP_TYPE(pPropsAttach[MSG_ATTACH_LFILENAME].ulPropTag) != PT_ERROR) 
                {
                    p = strrchr( pPropsAttach[MSG_ATTACH_LFILENAME].Value.lpszA, '.' );
                    if (p) 
                    {
                        DocType = ConvertAStringToTString( p );
                        if(!DocType)
                        {
                            rVal = IDS_OUT_OF_MEM;
                            goto exit;
                        }
                    }
                } 
                else if (PROP_TYPE(pPropsAttach[MSG_ATTACH_FILENAME].ulPropTag) != PT_ERROR) 
                {
                    p = strrchr( pPropsAttach[MSG_ATTACH_FILENAME].Value.lpszA, '.' );
                    if (p) 
                    {
                        DocType = ConvertAStringToTString( p );
                        if(!DocType)
                        {
                            rVal = IDS_OUT_OF_MEM;
                            goto exit;
                        }
                    }
                }
            } 
            else 
            {
                DocType = ConvertAStringToTString( pPropsAttach[MSG_ATTACH_EXTENSION].Value.lpszA );
                if(!DocType)
                {
                    rVal = IDS_OUT_OF_MEM;
                    goto exit;
                }
            }

            if (!DocType) 
            {
                goto next_attachment2;
            }

            lpstmA = NULL;
            AttachFileName = NULL;
            DeleteAttachFile = FALSE;

            //
            // get the attached file name so that we can resolve any links
            //

            if (FileName)
                MemFree(FileName);

            if (PROP_TYPE(pPropsAttach[MSG_ATTACH_PATHNAME].ulPropTag) != PT_ERROR) 
            {
                FileName = ConvertAStringToTString(pPropsAttach[MSG_ATTACH_PATHNAME].Value.lpszA);
                if(!FileName)
                {
                    rVal = IDS_OUT_OF_MEM;
                    goto exit;
                }
            } 
            else 
            {
                FileName = NULL;
            }

            if (_tcsicmp( DocType, FAX_LNK_FILE_DOT_EXT ) == 0) 
            {
                if (!FileName) 
                {
                    goto next_attachment2;
                }
                if (ResolveShortcut( FileName, DocFile )) 
                {
                    lptstrTempStr = _tcsrchr( DocFile, '.' );
                    if (lptstrTempStr) 
                    {
                        MemFree( DocType );
                        DocType = StringDup( lptstrTempStr );
                        if(!DocType)
                        {
                            rVal = IDS_OUT_OF_MEM;
                            goto exit;
                        }
                        AttachFileName = StringDup( DocFile );
                        if(!AttachFileName)
                        {
                            rVal = IDS_OUT_OF_MEM;
                            goto exit;
                        }
                    }
                }
            } 
            else if (FileName) 
            {
                AttachFileName = StringDup( FileName );
                if(!AttachFileName)
                {
                    rVal = IDS_OUT_OF_MEM;
                    goto exit;
                }
            }

            //
            // get the stream object
            //

            switch( pPropsAttach[MSG_ATTACH_METHOD].Value.ul ) 
            {
                case ATTACH_BY_VALUE:
                            hResult = lpAttach->OpenProperty(
                                PR_ATTACH_DATA_BIN,
                                &IID_IStream,
                                0,
                                0,
                                (LPUNKNOWN*) &lpstmA
                                );
                            if (FAILED(hResult)) 
                            {
                                goto next_attachment2;
                            }
                            break;

                case ATTACH_EMBEDDED_MSG:
                case ATTACH_OLE:
                            hResult = lpAttach->OpenProperty(
                                PR_ATTACH_DATA_OBJ,
                                &IID_IStreamDocfile,
                                0,
                                0,
                                (LPUNKNOWN*) &lpstmA
                                );
                            if (FAILED(hResult)) 
                            {
                                hResult = lpAttach->OpenProperty(
                                    PR_ATTACH_DATA_BIN,
                                    &IID_IStreamDocfile,
                                    0,
                                    0,
                                    (LPUNKNOWN*) &lpstmA
                                    );
                                if (FAILED(hResult)) 
                                {
                                    hResult = lpAttach->OpenProperty(
                                        PR_ATTACH_DATA_OBJ,
                                        &IID_IStorage,
                                        0,
                                        0,
                                        (LPUNKNOWN*) &lpstmA
                                        );
                                    if (FAILED(hResult)) 
                                    {
                                        goto next_attachment2;
                                    }
                                }
                            }
                            break;

            }

            if (lpstmA) 
            {
                DWORD dwSize = GetTempPath( sizeof(TempPath)/sizeof(TCHAR) , TempPath );
                Assert( dwSize != 0);
                GetTempFileName( TempPath, _T("Fax"), 0, TempFile );
                hFile = CreateFile(
                    TempFile,
                    GENERIC_READ | GENERIC_WRITE,
                    0,
                    NULL,
                    CREATE_ALWAYS,
                    0,
                    NULL
                    );
                if (hFile != INVALID_HANDLE_VALUE) 
                {

                    #define BLOCK_SIZE (64*1024)
                    LPBYTE StrmData;
                    DWORD Bytes;
                    DWORD BytesWrite;

                    StrmData = (LPBYTE) MemAlloc( BLOCK_SIZE );
                    if(!StrmData)
                    {
                        rVal = IDS_OUT_OF_MEM;
                        goto exit;
                    }

                    do 
                    {

                        hResult = lpstmA->Read( StrmData, BLOCK_SIZE, &Bytes );
                        if (FAILED(hResult)) 
                        {
                            break;
                        }

                        WriteFile( hFile, StrmData, Bytes, &BytesWrite, NULL );

                    } while (Bytes == BLOCK_SIZE);

                    CloseHandle( hFile );

					if(StrmData)
					{
						MemFree( StrmData );
						StrmData = NULL;
					}

                    if (AttachFileName) 
					{
                        MemFree( AttachFileName );
						AttachFileName = NULL;
                    }

                    _tcscpy( DocFile, TempFile );
                    lptstrTempStr = _tcsrchr( DocFile, '.' );
                    if (lptstrTempStr) 
                    {
                        _tcscpy( lptstrTempStr, DocType );
                        MoveFile( TempFile, DocFile );
                        AttachFileName = StringDup( DocFile );
                        if(!AttachFileName)
                        {
                            rVal = IDS_OUT_OF_MEM;
                            goto exit;
                        }
                    } 
                    else 
                    {
                        AttachFileName = StringDup( TempFile );
                        if(!AttachFileName)
                        {
                            rVal = IDS_OUT_OF_MEM;
                            goto exit;
                        }
                    }

                    DeleteAttachFile = TRUE;

                }

                lpstmA->Release();

            }

            if (AttachFileName) 
            {

                if (!GetFaxTempFileName(strTempTiffFile))
                {
                    rVal = IDS_BAD_ATTACHMENTS;//GetLastError();
                    goto exit;
                }
                //
                // print the attachment
                //
                if (!PrintRandomDocument(   pFaxConfig->PrinterName,
                                            AttachFileName,
                                            strTempTiffFile))
                {
					CALL_FAIL (GENERAL_ERR, TEXT("PrintRandomDocument"), ::GetLastError());
                    rVal = IDS_BAD_ATTACHMENTS;//GetLastError();
                    goto exit;
                }

                if (strMergedTiffFile[0] != 0) 
                {
                    //
                    // merge the attachments
                    //
                    if (!MergeTiffFiles( strMergedTiffFile,
                                         strTempTiffFile))
                    {
						CALL_FAIL (GENERAL_ERR, TEXT("MergeTiffFiles"), ::GetLastError());
						rVal = IDS_BAD_ATTACHMENTS;//GetLastError();
                        goto exit;
                    }
                    if (!DeleteFile( strTempTiffFile ))
					{
						CALL_FAIL (GENERAL_ERR, TEXT("DeleteFile"), ::GetLastError());
					}

                }
                else 
                {  // copies a first attachment
                    _tcscpy(strMergedTiffFile,strTempTiffFile);
                }
                if (DeleteAttachFile) 
                {
                    if (!DeleteFile( AttachFileName ))
					{
						CALL_FAIL (GENERAL_ERR, TEXT("DeleteFile"), ::GetLastError());
					}
                }

				if(AttachFileName)
				{
					MemFree( AttachFileName );
					AttachFileName = NULL;
				}

            }
    next_attachment2:

            if (lpAttach) 
            {
                lpAttach->Release();
            }

            if (pPropsAttach) 
			{
                MAPIFreeBuffer( pPropsAttach ); 
				pPropsAttach = NULL;
            }

        }

    }
    else
    {
        //
        // no attachments
        //
        rVal = IDS_NO_MSG_ATTACHMENTS;
    }

    if (strMergedTiffFile[0] != 0) 
    {
        if (!(*lpptstrOutAttachments = StringDup(strMergedTiffFile)))
        {
            rVal = IDS_OUT_OF_MEM;
        }
    }
exit:
    if (FileName) 
    {
        MemFree( FileName );
    }
    if (DocType) 
    {
        MemFree( DocType );
    }
    if (pAttachmentRows) 
    {
        FreeProws( pAttachmentRows );
    }
    if (AttachmentTable) 
    {
        AttachmentTable->Release();
    }

    if (AttachFileName) 
	{
        MemFree( AttachFileName );
    }

    return rVal;
}

DWORD
CXPLogon::PrintMessageToFile(
        IN  LPSTREAM        lpstmT,
        IN  BOOL            UseRichText,
        IN  PFAXXP_CONFIG   pFaxConfig,
        IN  LPTSTR          tszSubject,
        OUT LPTSTR*         lpptstrOutDocument
)
/*++

Routine Description:

    Prints the message body to the output file.

Arguments:

    lpstmT             - Pointer to the message body stream
    UseRichText        - boolean value. TRUE if the message is in Rich format,
                         FALSE - if this is a plain text
    pFaxConfig         - Pointer to fax configuration (used by plain text printing)
    tszSubject         - Subject
    lpptstrOutDocument - Name of the output tiff file. The string should be empty


Return Value:

    ERROR_SUCCESS - if success
    Error IDS_... code if failed.

Comments:
    If this function succeeded it allocates a memory for *lpptstrOutDocument
    and creates a temporal file *lpptstrOutDocument.
    It's up to user to free both these allocations, by
        DeleteFile(*lpptstrOutDocument);
        MemFree(*lpptstrOutDocument);

--*/
{
	DWORD           rVal = ERROR_SUCCESS;
    LARGE_INTEGER   BigZero = {0};
    LPSTREAM        lpstm = NULL;
    HRESULT         hResult;
    
    HWND       hWndRichEdit = NULL;
    HDC        hDC = NULL;
    EDITSTREAM es = {0};
    TCHAR      strOutputTiffFile[MAX_PATH] = {0};
    TCHAR      DocName[64];

    TCHAR      tszSubjectFormat[64];
    TCHAR*     ptszSubjectText = NULL;
    DWORD      dwSubjectSize = 0;

    DOCINFO  docInfo = 
    {
        sizeof(DOCINFO),
        NULL,
        NULL,
        NULL,
        0,
    };

	DBG_ENTER(TEXT("CXPLogon::PrintMessageToFile"),rVal);

    Assert(pFaxConfig);
    Assert(lpptstrOutDocument);
    Assert(*lpptstrOutDocument==NULL);

    if (!(hDC = CreateDC( NULL,
                        pFaxConfig->PrinterName,
                        NULL,
                        NULL)))
    {
        CALL_FAIL (GENERAL_ERR, TEXT("CreateDC"), ::GetLastError());
		rVal = IDS_CANT_PRINT_BODY; 
        goto exit;
    }

    LoadString(g_FaxXphInstance, IDS_MESSAGE_DOC_NAME, DocName, sizeof(DocName) / sizeof(DocName[0]));
    docInfo.lpszDocName = DocName;

    if (!GetFaxTempFileName(strOutputTiffFile))
    {
        rVal = IDS_CANT_PRINT_BODY; 
        goto exit;

    }
    docInfo.lpszOutput = strOutputTiffFile ;
    docInfo.lpszDatatype = _T("RAW");

    if (StartDoc(hDC, &docInfo) <= 0)
	{
		CALL_FAIL (GENERAL_ERR, TEXT("StartDoc"), ::GetLastError());
		rVal = IDS_CANT_PRINT_BODY; 
        goto exit;
	}

    //
    // position the stream to the beginning
    //
    if(lpstmT)
    {
        hResult = lpstmT->Seek( BigZero, STREAM_SEEK_SET, NULL );
        if (HR_FAILED (hResult)) 
        {
            rVal = IDS_CANT_ACCESS_MSG_DATA;
            goto exit;
        }
    }

    if(!pFaxConfig->UseCoverPage && tszSubject && _tcslen(tszSubject))
    {
        //
        // get subject string
        //
        dwSubjectSize = _tcslen(tszSubject) * sizeof(TCHAR) + sizeof(tszSubjectFormat);
        ptszSubjectText = (TCHAR*)MemAlloc(dwSubjectSize);
        if(!ptszSubjectText)
        {
            rVal = IDS_OUT_OF_MEM;
            goto exit;
        }

        if(!LoadString(g_FaxXphInstance, IDS_SUBJECT_FORMAT, tszSubjectFormat, sizeof(tszSubjectFormat) / sizeof(tszSubjectFormat[0])))
        {
            Assert(FALSE);
            CALL_FAIL (GENERAL_ERR, TEXT("LoadString"), ::GetLastError());
            _tcscpy(tszSubjectFormat, TEXT("%s"));
        }

        _stprintf(ptszSubjectText, tszSubjectFormat, tszSubject);
        dwSubjectSize = _tcslen(ptszSubjectText);
    }

    if (UseRichText)
    {
        if(lpstmT)
        {
            hResult = WrapCompressedRTFStream( lpstmT, 0, &lpstm );
            if (HR_FAILED (hResult)) 
            {
                rVal = IDS_CANT_ACCESS_MSG_DATA;
                goto exit;
            }
        }

        hWndRichEdit = CreateWindowEx(
                                       0,
                                       _T("RICHEDIT"),
                                       _T(""),
                                       ES_MULTILINE,
                                       0, 0,
                                       0, 0,
                                       NULL,
                                       NULL,
                                       g_FaxXphInstance,
                                       NULL
                                      );
        if (!hWndRichEdit) 
        {
            CALL_FAIL (GENERAL_ERR, TEXT("CreateWindowEx"), ::GetLastError());
			rVal = IDS_CANT_PRINT_BODY;
            goto exit;
        }

        if(ptszSubjectText && _tcslen(ptszSubjectText))
        {
            //
            // add subject to body
            //
            SendMessage(hWndRichEdit, 
                        WM_SETTEXT,  
                        0,          
                        (LPARAM)ptszSubjectText);
            //
            // Set the subject's font
            //                                              
            CHARFORMAT CharFormat = {0};
            CharFormat.cbSize = sizeof (CHARFORMAT);
            CharFormat.dwMask = CFM_BOLD        |
                                CFM_CHARSET     |
                                CFM_FACE        |
                                CFM_ITALIC      |
                                CFM_SIZE        |
                                CFM_STRIKEOUT   |
                                CFM_UNDERLINE;
            CharFormat.dwEffects = ((FW_BOLD <= pFaxConfig->FontStruct.lfWeight) ? CFE_BOLD : 0) |
                                   ((pFaxConfig->FontStruct.lfItalic) ? CFE_ITALIC : 0)          |
                                   ((pFaxConfig->FontStruct.lfStrikeOut) ? CFE_STRIKEOUT : 0)    |
                                   ((pFaxConfig->FontStruct.lfUnderline) ? CFE_UNDERLINE : 0);
            //
            // Height is already in point size.
            //
            CharFormat.yHeight =  abs ( pFaxConfig->FontStruct.lfHeight );
            //
            // Convert point to twip
            //
            CharFormat.yHeight *= 20;   

            CharFormat.bCharSet = pFaxConfig->FontStruct.lfCharSet;
            CharFormat.bPitchAndFamily = pFaxConfig->FontStruct.lfPitchAndFamily;
            lstrcpy (CharFormat.szFaceName, pFaxConfig->FontStruct.lfFaceName);

            SendMessage(hWndRichEdit,
                        EM_SETCHARFORMAT,   
                        SCF_ALL,        // Apply font formatting to all the control's text
                        (LPARAM)&CharFormat);   // New font settings
            //
            // Place insertion point at the end of the subject text
            // See MSDN under "HOWTO: Place a Caret After Edit-Control Text"
            //
            SendMessage(hWndRichEdit,
                        EM_SETSEL,   
                        MAKELONG(0xffff,0xffff),
                        MAKELONG(0xffff,0xffff));
        }

        if(lpstm)
        {
            es.pfnCallback = EditStreamRead;
            es.dwCookie = (DWORD_PTR) lpstm;

            SendMessage(hWndRichEdit,
                        EM_STREAMIN,
                        SF_RTF | SFF_SELECTION | SFF_PLAINRTF,
                        (LPARAM) &es);
        }

        //
        // Check if the body is not empty.
        // If the message length is shorter then 32 (arbitrary number) 
        // and all the characters are control or space.
        //
        TCHAR tszText[32] = {0};
        DWORD dwTextSize;
        if (!GetWindowText(hWndRichEdit, tszText, sizeof(tszText)/sizeof(tszText[0])-1))
        {
            if (ERROR_INSUFFICIENT_BUFFER == ::GetLastError ())
            {
                //
                // Subject + Body are longer than 31 characters.
                // We're assuming they have valid printable text and
                // that this is not an empty message.
                //
                goto DoPrintRichText;
            }
            //
            // This is another type of error
            //
            rVal = ::GetLastError ();
            CALL_FAIL (GENERAL_ERR, TEXT("GetWindowText"), rVal);
            goto exit;
        }
        dwTextSize = _tcslen(tszText);
        if(dwTextSize < sizeof(tszText)/sizeof(tszText[0])-2)
        {
            BOOL bEmpty = TRUE;
            TCHAR* pTchar = tszText;
            for(DWORD dw = 0; dw < dwTextSize; ++dw)
            {
                if(!_istspace(*pTchar) && !_istcntrl(*pTchar))
                {
                    bEmpty = FALSE;
                    break;
                }
                pTchar = _tcsinc(pTchar);
            }
            if(bEmpty)
            {
                rVal = IDS_NO_MSG_BODY;
                goto exit;
            }
        }

DoPrintRichText:
        if (!PrintRichText(hWndRichEdit, hDC))
        {
			rVal = IDS_CANT_PRINT_BODY;
            goto exit;
        }

    } 
    else 
    {        
        rVal = PrintPlainText(hDC, lpstmT, ptszSubjectText, pFaxConfig);
        if (rVal)
        {
            goto exit;
        }
    }
    // closes DC
    if (EndDoc(hDC) <=0)
    {
        Assert(FALSE);  // better not to be here
        goto exit;
    }
    if (!DeleteDC(hDC))
    {
        Assert(FALSE);  // better not to be here
        goto exit;
    }
    hDC = NULL;
        

    if (strOutputTiffFile[0] != 0)
    {
        if (!(*lpptstrOutDocument = StringDup(strOutputTiffFile)))
        {
            rVal = IDS_OUT_OF_MEM; //ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }
		VERBOSE (DBG_MSG, TEXT("Attachment File is %s:"), *lpptstrOutDocument);
    }

    rVal = ERROR_SUCCESS;
exit:
    if (lpstm) 
    {
        lpstm->Release();
    }
    if (hDC) 
    {
        DeleteDC(hDC);
    }

    MemFree(ptszSubjectText);

    return rVal;
}

DWORD
CXPLogon::PrintFaxDocumentToFile(
       IN  LPMESSAGE        pMsgObj,
       IN  LPSTREAM         lpstmT,
       IN  BOOL             UseRichText,
       IN  PFAXXP_CONFIG    pFaxConfig,
       IN  LPTSTR           tszSubject,
       OUT LPTSTR*          lpptstrMessageFileName
       )
/*++

Routine Description:

    Runs printing of the message body and attachments to the output file.

Arguments:

    pMsgObj                - Pointer to the message object
    lpstmT                 - Pointer to the message body stream
    UseRichText            - boolean value. TRUE if the message is in Rich format,
                             FALSE - if this is a plain text
    pFaxConfig             - Pointer to fax configuration (used by plain text printing)
    tszSubject             - Subject
    lpptstrMessageFileName - Name of the output tiff file. The string should be empty


Return Value:

    0 - if success
    Error code if failed.
Comments:
    If this function succeeded it returns an allocated memory for
    *lpptstrMessageFileName and a temporal file *lpptstrMessageFileName.
    It's up to user to free both these allocations, by
        DeleteFile(*lpptstrMessageFileName);
        MemFree(*lpptstrMessageFileName);

--*/
{
    DWORD    rVal = 0;
    LPTSTR   lptstrAttachmentsTiff = NULL;
    BOOL     bAttachment = TRUE;
    BOOL     bBody = TRUE;

	DBG_ENTER(TEXT("CXPLogon::PrintFaxDocumentToFile"),rVal);


    Assert(lpptstrMessageFileName);
    Assert(*lpptstrMessageFileName == NULL);

    //
    // prints attachments
    //
    rVal = PrintAttachmentToFile(pMsgObj,
                                 pFaxConfig,
                                 &lptstrAttachmentsTiff);
    if(rVal)
    {
        if(IDS_NO_MSG_ATTACHMENTS == rVal)
        {
            rVal = 0;
            bAttachment = FALSE;
        }
        else
        {
            CALL_FAIL (GENERAL_ERR, TEXT("PrintAttachmentToFile"), 0);
            goto error;
        }            
    }

    //
    // prints the body
    //
    rVal = PrintMessageToFile(lpstmT,
                              UseRichText,
                              pFaxConfig,
                              tszSubject,
                              lpptstrMessageFileName);
    if(rVal)
    {
        if(IDS_NO_MSG_BODY == rVal)
        {
            rVal = 0;
            bBody = FALSE;
        }
        else
        {
            CALL_FAIL (GENERAL_ERR, TEXT("PrintMessageToFile"), 0);
            goto error;
        }            
    }

    if(!bBody && !bAttachment)
    {
        rVal = IDS_EMPTY_MESSAGE; 
        goto error;
    }

    if (!*lpptstrMessageFileName)   // empty body
    {
        if (lptstrAttachmentsTiff)  // the message contains attachments
        {
            if (!(*lpptstrMessageFileName = StringDup(lptstrAttachmentsTiff)))
            {
                rVal = IDS_OUT_OF_MEM; 
                goto error;
            }
        }
    }
    else    // the message contains body
    {
        if (lptstrAttachmentsTiff)  // the message contains attachments
        {
            // merges message and attachements
            if (!MergeTiffFiles( *lpptstrMessageFileName, lptstrAttachmentsTiff))
            {
                rVal = IDS_CANT_PRINT_BODY; 
                goto error;
            }
            // deletes attachements
            if(!DeleteFile(lptstrAttachmentsTiff))
            {
                VERBOSE (DBG_MSG, TEXT("DeleteFile Failed in xport\\faxdoc.cpp"));
            }

            MemFree(lptstrAttachmentsTiff);
			lptstrAttachmentsTiff = NULL;
        }
    }

    return rVal;
error:
    if (lptstrAttachmentsTiff) 
    {
        if(!DeleteFile(lptstrAttachmentsTiff))
        {
            VERBOSE (DBG_MSG, TEXT("DeleteFile Failed in xport\\faxdoc.cpp"));
        }
        
        MemFree(lptstrAttachmentsTiff);
		lptstrAttachmentsTiff = NULL;
    }
    if (*lpptstrMessageFileName) 
    {
        if(!DeleteFile(*lpptstrMessageFileName))
        {
            VERBOSE (DBG_MSG, TEXT("DeleteFile Failed in xport\\faxdoc.cpp"));
        }
        
        MemFree(*lpptstrMessageFileName);
		*lpptstrMessageFileName = NULL;
    }

    return rVal;
}


DWORD
CXPLogon::SendFaxDocument(
    LPMESSAGE pMsgObj,
    LPSTREAM lpstmT,
    BOOL UseRichText,
    LPSPropValue pMsgProps,
    LPSRowSet pRecipRows
    )

/*++

Routine Description:

    Prints an exchange message and attachments to the fax printer.

Arguments:

    pMsgObj     - Pointer to message object
    lpstmT      - Stream pointer for rich text.
    UseRichText - boolean value. TRUE if the message is in Rich format,
                                 FALSE - if this is a plain text
    pMsgProps   - Message properties (those that are defined in sptPropsForHeader)
    pRecipRows  - Properties of recipients

Return Value:

    Zero for success, otherwise error code.

--*/

{
    DWORD dwRetVal = 0;
    PPRINTER_INFO_2 PrinterInfo = NULL;
    PRINTER_DEFAULTS PrinterDefaults;
    HANDLE hPrinter = NULL;
    DWORD ec = 0;
    HRESULT hResult = S_OK;
    EDITSTREAM es = {0};
    LPPROFSECT pProfileObj = NULL;
    ULONG PropCount = 0;
    ULONG PropMsgCount = 0;
    LPSPropValue pProps = NULL;
    LPSPropValue pPropsMsg = NULL;
    FAXXP_CONFIG FaxConfig = {0};
    MAPINAMEID NameIds[NUM_FAX_MSG_PROPS];
    MAPINAMEID *pNameIds[NUM_FAX_MSG_PROPS] = {
                                                &NameIds[0], 
                                                &NameIds[1], 
                                                &NameIds[2], 
                                                &NameIds[3], 
                                                &NameIds[4], 
                                                &NameIds[5],
                                                &NameIds[6]};
    LPSPropTagArray MsgPropTags = NULL;
    HKEY  hKey = 0;
    DWORD RegSize = 0;
    DWORD RegType = 0;
    DWORD CountPrinters = 0;

    LPTSTR lptstrRecipientName   = NULL ;
    LPTSTR lptstrRecipientNumber = NULL ;
    LPTSTR lptstrRecName         = NULL ;
    LPTSTR lptstrRecFaxNumber    = NULL ;
    LPTSTR lptstrSubject         = NULL ;
    LPTSTR lptszServerName       = NULL;

    LPTSTR                  lptstrDocumentFileName = NULL;
    HANDLE                  FaxServer = NULL;
    FAX_COVERPAGE_INFO_EX   CovInfo = {0};
    FAX_PERSONAL_PROFILE    SenderProfile = {0};
    FAX_JOB_PARAM_EX        JobParamsEx = {0};      
    PFAX_PERSONAL_PROFILE   pRecipients = NULL;
    DWORDLONG               dwlParentJobId = 0;
    DWORDLONG*              lpdwlRecipientJobIds = NULL;
    BOOL                    bRslt = FALSE;
    LPSPropValue            pRecipProps = NULL; 
    DWORD                   dwRecipient = 0;

    TCHAR                   strCoverpageName[MAX_PATH] = {0};
    BOOL                    bServerBased = TRUE;
    DWORD                   dwRecipientNumber = 0;

    DWORD                   dwRights = 0;  //access rights of fax sender

    LPADRBOOK               lpAdrBook = NULL; 
    LPTSTR                  lpstrSenderSMTPAdr = NULL;//sender's SMTP adr, including "SMTP:" prefix
    LPTSTR                  lpstrSMTPPrefix = NULL;
    LPTSTR                  lpstrSenderAdr = NULL;//sender's SMTP adr. without prefix
    ULONG                   cValues = 0;
    ULONG                   ulObjType = NULL;
    LPMAILUSER              pMailUser = NULL;
    LPSPropValue            lpPropValue = NULL;
    ULONG                   i, j;
    BOOL                    bGotSenderAdr = FALSE;

    LPTSTR                  lptstrCPFullPath = NULL;
    LPTSTR                  lptstrCPName = NULL;
    DWORD                   dwError = 0;
    BOOL                    bResult = FALSE;
    DWORD                   dwReceiptsOptions = DRT_NONE;

    RECIPIENTS_SET          setRecip; // Recipients set used to remove the duplications

    SizedSPropTagArray(1, sptPropxyAddrProp) = {1, PR_EMS_AB_PROXY_ADDRESSES_A};

    DBG_ENTER(TEXT("CXPLogon::SendFaxDocument"), dwRetVal);    

    //
    // *****************************
    // get the fax config properties
    // *****************************
    //
    hResult = m_pSupObj->OpenProfileSection(
        &g_FaxGuid,
        MAPI_MODIFY,
        &pProfileObj
        );
    if (HR_FAILED (hResult)) 
    {
        CALL_FAIL (GENERAL_ERR, TEXT("OpenProfileSection"), hResult);
        dwRetVal = IDS_CANT_ACCESS_PROFILE;
        goto exit;
    }

    hResult = pProfileObj->GetProps(
                (LPSPropTagArray) &sptFaxProps,
                0,
                &PropCount,
                &pProps
                );
    if ((FAILED(hResult))||(hResult == MAPI_W_ERRORS_RETURNED) )
    {
        CALL_FAIL (GENERAL_ERR, TEXT("GetProps"), hResult);
        dwRetVal = IDS_INTERNAL_ERROR;
        goto exit;
    }
    
  
    FaxConfig.PrinterName = StringDup( (LPTSTR)pProps[PROP_FAX_PRINTER_NAME].Value.bin.lpb );
    if(! FaxConfig.PrinterName)
    {
        dwRetVal = IDS_OUT_OF_MEM;
        goto exit;
    }
    FaxConfig.CoverPageName = StringDup( (LPTSTR)pProps[PROP_COVERPAGE_NAME].Value.bin.lpb );
    if(! FaxConfig.CoverPageName)
    {
        dwRetVal = IDS_OUT_OF_MEM;
        goto exit;
    }
    FaxConfig.UseCoverPage = pProps[PROP_USE_COVERPAGE].Value.ul;
    FaxConfig.ServerCoverPage = pProps[PROP_SERVER_COVERPAGE].Value.ul;
    CopyMemory( 
            &FaxConfig.FontStruct, 
            pProps[PROP_FONT].Value.bin.lpb, 
            pProps[PROP_FONT].Value.bin.cb 
            );
    FaxConfig.SendSingleReceipt= pProps[PROP_SEND_SINGLE_RECEIPT].Value.ul;
    FaxConfig.bAttachFax = pProps[PROP_ATTACH_FAX].Value.ul;
    FaxConfig.LinkCoverPage = pProps[PROP_LINK_COVERPAGE].Value.ul;
    
    //
    // *************************************
    // now get the message config properties
    // *************************************
    // 
    NameIds[MSGPI_FAX_PRINTER_NAME].lpguid = (LPGUID)&PS_PUBLIC_STRINGS;
    NameIds[MSGPI_FAX_PRINTER_NAME].ulKind = MNID_STRING;
    NameIds[MSGPI_FAX_PRINTER_NAME].Kind.lpwstrName = MSGPS_FAX_PRINTER_NAME;

    NameIds[MSGPI_FAX_COVERPAGE_NAME].lpguid = (LPGUID)&PS_PUBLIC_STRINGS;
    NameIds[MSGPI_FAX_COVERPAGE_NAME].ulKind = MNID_STRING;
    NameIds[MSGPI_FAX_COVERPAGE_NAME].Kind.lpwstrName = MSGPS_FAX_COVERPAGE_NAME;

    NameIds[MSGPI_FAX_USE_COVERPAGE].lpguid = (LPGUID)&PS_PUBLIC_STRINGS;
    NameIds[MSGPI_FAX_USE_COVERPAGE].ulKind = MNID_STRING;
    NameIds[MSGPI_FAX_USE_COVERPAGE].Kind.lpwstrName = MSGPS_FAX_USE_COVERPAGE;

    NameIds[MSGPI_FAX_SERVER_COVERPAGE].lpguid = (LPGUID)&PS_PUBLIC_STRINGS;
    NameIds[MSGPI_FAX_SERVER_COVERPAGE].ulKind = MNID_STRING;
    NameIds[MSGPI_FAX_SERVER_COVERPAGE].Kind.lpwstrName = MSGPS_FAX_SERVER_COVERPAGE;

    NameIds[MSGPI_FAX_SEND_SINGLE_RECEIPT].lpguid = (LPGUID)&PS_PUBLIC_STRINGS;
    NameIds[MSGPI_FAX_SEND_SINGLE_RECEIPT].ulKind = MNID_STRING;
    NameIds[MSGPI_FAX_SEND_SINGLE_RECEIPT].Kind.lpwstrName = MSGPS_FAX_SEND_SINGLE_RECEIPT;

    NameIds[MSGPI_FAX_ATTACH_FAX].lpguid = (LPGUID)&PS_PUBLIC_STRINGS;
    NameIds[MSGPI_FAX_ATTACH_FAX].ulKind = MNID_STRING;
    NameIds[MSGPI_FAX_ATTACH_FAX].Kind.lpwstrName = MSGPS_FAX_ATTACH_FAX;

    NameIds[MSGPI_FAX_LINK_COVERPAGE].lpguid = (LPGUID)&PS_PUBLIC_STRINGS;
    NameIds[MSGPI_FAX_LINK_COVERPAGE].ulKind = MNID_STRING;
    NameIds[MSGPI_FAX_LINK_COVERPAGE].Kind.lpwstrName = MSGPS_FAX_LINK_COVERPAGE;

    hResult = pMsgObj->GetIDsFromNames( (ULONG) NUM_FAX_MSG_PROPS, pNameIds, MAPI_CREATE, &MsgPropTags );
    if (HR_FAILED(hResult)) 
	{	
        if(hResult == MAPI_E_NOT_ENOUGH_MEMORY)
        {
            dwRetVal = IDS_OUT_OF_MEM;
        }
        else
        {
            dwRetVal = IDS_INTERNAL_ERROR;
        }
        CALL_FAIL (GENERAL_ERR, TEXT("GetIDsFromNames"), hResult);
        goto exit;
    }
    
    MsgPropTags->aulPropTag[MSGPI_FAX_PRINTER_NAME] = PROP_TAG( PT_BINARY, PROP_ID(MsgPropTags->aulPropTag[MSGPI_FAX_PRINTER_NAME]));
    MsgPropTags->aulPropTag[MSGPI_FAX_COVERPAGE_NAME] = PROP_TAG( PT_BINARY, PROP_ID(MsgPropTags->aulPropTag[MSGPI_FAX_COVERPAGE_NAME]));
    MsgPropTags->aulPropTag[MSGPI_FAX_USE_COVERPAGE] = PROP_TAG( PT_LONG, PROP_ID(MsgPropTags->aulPropTag[MSGPI_FAX_USE_COVERPAGE]));
    MsgPropTags->aulPropTag[MSGPI_FAX_SERVER_COVERPAGE] = PROP_TAG( PT_LONG, PROP_ID(MsgPropTags->aulPropTag[MSGPI_FAX_SERVER_COVERPAGE]));
    MsgPropTags->aulPropTag[MSGPI_FAX_SEND_SINGLE_RECEIPT] = PROP_TAG( PT_LONG, PROP_ID(MsgPropTags->aulPropTag[MSGPI_FAX_SEND_SINGLE_RECEIPT]));
    MsgPropTags->aulPropTag[MSGPI_FAX_ATTACH_FAX] = PROP_TAG( PT_LONG, PROP_ID(MsgPropTags->aulPropTag[MSGPI_FAX_ATTACH_FAX]));
    MsgPropTags->aulPropTag[MSGPI_FAX_LINK_COVERPAGE] = PROP_TAG( PT_LONG, PROP_ID(MsgPropTags->aulPropTag[MSGPI_FAX_LINK_COVERPAGE]));
    
    hResult = pMsgObj->GetProps( MsgPropTags, 0, &PropMsgCount, &pPropsMsg );
    if(hResult == MAPI_W_ERRORS_RETURNED)
    {
        VERBOSE (DBG_MSG, TEXT("GetProps in SendFaxDocument returned MAPI_W_ERRORS_RETURNED"));
    }
	
    if (FAILED(hResult)) 
    //
    // happens if user did not press ok on the "fax attributes" DlgBox - it's not an error!
    //
    {
        CALL_FAIL (GENERAL_ERR, TEXT("GetProps"), hResult);
        hResult = S_OK;
    }
    
    //
    //prefer the config props defined for the message (if they exist) on those defined for the fax.    
    //
    if (PROP_TYPE(pPropsMsg[MSGPI_FAX_PRINTER_NAME].ulPropTag) != PT_ERROR) 
    {
        MemFree( FaxConfig.PrinterName );
        FaxConfig.PrinterName = StringDup((LPTSTR)pPropsMsg[MSGPI_FAX_PRINTER_NAME].Value.bin.lpb);
        if(! FaxConfig.PrinterName)
        {
            dwRetVal = IDS_OUT_OF_MEM;
            goto exit;
        }
    
    }

    if (PROP_TYPE(pPropsMsg[MSGPI_FAX_COVERPAGE_NAME].ulPropTag) != PT_ERROR) 
    {
        MemFree( FaxConfig.CoverPageName);
        FaxConfig.CoverPageName = StringDup((LPTSTR)pPropsMsg[MSGPI_FAX_COVERPAGE_NAME].Value.bin.lpb);
        if(! FaxConfig.CoverPageName)
        {
            dwRetVal = IDS_OUT_OF_MEM;
            goto exit;
        }
    }

    if (PROP_TYPE(pPropsMsg[MSGPI_FAX_USE_COVERPAGE].ulPropTag) != PT_ERROR) 
    {
        FaxConfig.UseCoverPage = pPropsMsg[MSGPI_FAX_USE_COVERPAGE].Value.ul;
    }

    if (PROP_TYPE(pPropsMsg[MSGPI_FAX_SERVER_COVERPAGE].ulPropTag) != PT_ERROR) 
    {
        FaxConfig.ServerCoverPage = pPropsMsg[MSGPI_FAX_SERVER_COVERPAGE].Value.ul;
    }

    if (PROP_TYPE(pPropsMsg[MSGPI_FAX_SEND_SINGLE_RECEIPT].ulPropTag) != PT_ERROR) 
    {
        FaxConfig.SendSingleReceipt = pPropsMsg[MSGPI_FAX_SEND_SINGLE_RECEIPT].Value.ul;
    }
     
    if (PROP_TYPE(pPropsMsg[MSGPI_FAX_ATTACH_FAX].ulPropTag) != PT_ERROR) 
    {
        FaxConfig.bAttachFax = pPropsMsg[MSGPI_FAX_ATTACH_FAX].Value.ul;
    }

    if (PROP_TYPE(pPropsMsg[MSGPI_FAX_LINK_COVERPAGE].ulPropTag) != PT_ERROR) 
    {
        FaxConfig.LinkCoverPage = pPropsMsg[MSGPI_FAX_LINK_COVERPAGE].Value.ul;
    }

    if (PROP_TYPE(pMsgProps[MSG_SUBJECT].ulPropTag) != PT_ERROR) 
    {
        lptstrSubject = ConvertAStringToTString(pMsgProps[MSG_SUBJECT].Value.lpszA);
        if(! lptstrSubject)
        {
            dwRetVal = IDS_OUT_OF_MEM;
            goto exit;
        }
    }

    //
    // ******************************************
    // open the printer, and create the tiff file
    // ******************************************
    //

    //
    // open the printer - first try to get info on the printer in FaxConfig, 
    // if you fail, search all the printers until the first fax printer is found.
    //

    PrinterInfo = (PPRINTER_INFO_2) MyGetPrinter( FaxConfig.PrinterName, 2 );
    if (NULL == PrinterInfo) 
    {
        // if the chosen printer is not accessable, try to locate another SharedFax printer 
        PrinterInfo = (PPRINTER_INFO_2) MyEnumPrinters( NULL, 2, &CountPrinters );
        if (NULL != PrinterInfo) 
        {
            for (i=0; i<(int)CountPrinters; i++) 
            {
                if (_tcscmp( PrinterInfo[i].pDriverName, FAX_DRIVER_NAME ) == 0) 
                {
                    break;
                }
            }
        } 
        else 
        {
            CountPrinters = i = 0; //no printers were found
        }
        if (i == (int)CountPrinters) //if there are no printers, or none of them is a fax printer
        {
            dwRetVal = IDS_NO_FAX_PRINTER;
            goto exit;
        }

        // 
        // if a SharedFax printer was found, update it as the printer that we'll send the fax threw
        //
        MemFree( FaxConfig.PrinterName );
        FaxConfig.PrinterName = StringDup( PrinterInfo[i].pPrinterName );
        if(! FaxConfig.PrinterName)
        {
            dwRetVal = IDS_OUT_OF_MEM;
            goto exit;
        }
        MemFree( PrinterInfo );

        PrinterInfo = (PPRINTER_INFO_2) MyGetPrinter( FaxConfig.PrinterName, 2 );
        if (NULL == PrinterInfo) 
        {
            dwRetVal = IDS_CANT_ACCESS_PRINTER; 
            goto exit;
        }
    }

    PrinterDefaults.pDatatype     = NULL;
    PrinterDefaults.pDevMode      = NULL;
    PrinterDefaults.DesiredAccess = PRINTER_ACCESS_USE;

    if (!OpenPrinter( FaxConfig.PrinterName, &hPrinter, &PrinterDefaults )) 
    {
        dwRetVal = IDS_CANT_ACCESS_PRINTER;
        goto exit;
    }

    dwRetVal = PrintFaxDocumentToFile( pMsgObj,
                                       lpstmT,
                                       UseRichText,
                                       &FaxConfig ,
                                       lptstrSubject,
                                       &lptstrDocumentFileName);                                      
    if (IDS_EMPTY_MESSAGE == dwRetVal)
    {
        //
        // The message is empty. This is not really an error.
        //
        dwRetVal = 0;

        if(!FaxConfig.UseCoverPage)
        {
            //
            // If the message is empty and no cover page is specified there is
            // nothing more to do.
            //
            goto exit;
        }
    }

    if(dwRetVal)
    {
        goto exit;
    }
	
	VERBOSE (DBG_MSG, TEXT("Final Tiff is %s:"), lptstrDocumentFileName);

    //
	// **************************************
    // initializes sender and recipients info
	// **************************************
    //
    
    //
    // sender's info
    //
    SenderProfile.dwSizeOfStruct = sizeof(SenderProfile);
    hResult = FaxGetSenderInformation(&SenderProfile);
    if(S_OK != hResult)
    {
        CALL_FAIL (GENERAL_ERR, TEXT("FaxGetSenderInformation"), hResult);
        if (ERROR_INVALID_PARAMETER == hResult)
        {
            dwRetVal = IDS_INTERNAL_ERROR;
        }
        else if (ERROR_NOT_ENOUGH_MEMORY == hResult )
        {
            dwRetVal = IDS_OUT_OF_MEM;
            goto exit;
        }
    }    
         
    //
    // recipients' info
    // pRecipRows includes rows coresponding only to recipients that their PR_RESPONSIBILITY == FALSE
    // 
    dwRecipientNumber = pRecipRows->cRows;
    pRecipients = (PFAX_PERSONAL_PROFILE)MemAlloc(sizeof(FAX_PERSONAL_PROFILE) * dwRecipientNumber);
    if(! pRecipients)
    {
        dwRetVal = IDS_OUT_OF_MEM;
        goto exit;
    }
    ZeroMemory(pRecipients, sizeof(FAX_PERSONAL_PROFILE) * dwRecipientNumber);
           
    dwRecipient = 0;    
    for (DWORD dwRecipRow=0; dwRecipRow < pRecipRows->cRows ; ++dwRecipRow) 
	{
        pRecipProps = pRecipRows->aRow[dwRecipRow].lpProps;

        lptstrRecipientName = ConvertAStringToTString(pRecipProps[RECIP_NAME].Value.lpszA);
        if(! lptstrRecipientName)
        {
            dwRetVal = IDS_OUT_OF_MEM;
            goto exit;
        }

        lptstrRecipientNumber = ConvertAStringToTString(pRecipProps[RECIP_EMAIL_ADR].Value.lpszA);
        if(! lptstrRecipientNumber)
        {
            dwRetVal = IDS_OUT_OF_MEM;
            goto exit;
        }

        if(_tcsstr(lptstrRecipientName, lptstrRecipientNumber))
        {
            //
            // PR_EMAIL_ADDRESS_A is substring of PR_DISPLAY_NAME_A
            // so we suppose that PR_DISPLAY_NAME_A was not specified.
            // Try to get the recipient name from PR_EMAIL_ADDRESS_A
            //
            MemFree( lptstrRecipientName );
	    	lptstrRecipientName = NULL;    
        }

        //
        // finds a fax number from the name string, 
        // e.g. "Fax Number@+14 (2) 324324" --> +14 (2) 324324)
        //
        LPTSTR pRecipientNumber = _tcschr(lptstrRecipientNumber, '@');
        if (pRecipientNumber)
        {
            //
            //if there was a @, increment the pointer to point to the next char after it. 
            //
            *pRecipientNumber = '\0';
            pRecipientNumber = _tcsinc(pRecipientNumber);

            if(!lptstrRecipientName)
            {
                lptstrRecipientName = StringDup(lptstrRecipientNumber);
                if(! lptstrRecipientName)
                {
                    dwRetVal = IDS_OUT_OF_MEM;
                    goto exit;
                }
            }
        }
        else
        {
            //
            //if there's no @ in the string, it's OK as it was.
            //
            pRecipientNumber = lptstrRecipientNumber;
        }
            
        //
        // initializes recipient info
        //
        pRecipients[dwRecipient].dwSizeOfStruct = sizeof(FAX_PERSONAL_PROFILE);
        
        pRecipients[dwRecipient].lptstrFaxNumber    = StringDup(pRecipientNumber);
        if(! pRecipients[dwRecipient].lptstrFaxNumber)
        {
            dwRetVal = IDS_OUT_OF_MEM;
            goto exit;
        }

        if(lptstrRecipientName)
        {
            pRecipients[dwRecipient].lptstrName = StringDup(lptstrRecipientName);
            if(! pRecipients[dwRecipient].lptstrName)
            {
                dwRetVal = IDS_OUT_OF_MEM;
                goto exit;
            }
        }
        
        __try
        {
            //
            // Insert all the recipients into a set.
            // If there are any duplications insert() failes
            //
            if(setRecip.insert(&pRecipients[dwRecipient]).second == true)
            {
                ++dwRecipient;
            }
            else
            {
                //
                // Such recipients already exists
                //
                MemFree(pRecipients[dwRecipient].lptstrName);
                pRecipients[dwRecipient].lptstrName = NULL;
                MemFree(pRecipients[dwRecipient].lptstrFaxNumber);
                pRecipients[dwRecipient].lptstrFaxNumber = NULL;
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            dwRetVal = IDS_OUT_OF_MEM;
            goto exit;
        }

        if(lptstrRecipientName)
        {
            MemFree( lptstrRecipientName );
            lptstrRecipientName = NULL;    
        }

        if(lptstrRecipientNumber)
        {
            MemFree( lptstrRecipientNumber );
            lptstrRecipientNumber = NULL;
        }       
    } // for

    //
    // Update the recipient number to the actual size without duplications
    //
    dwRecipientNumber = dwRecipient;

    //
    // *******************
    // get cover page info
    // *******************
    //
    if (FaxConfig.UseCoverPage)
	{
        bServerBased = FaxConfig.ServerCoverPage;
	    if(bServerBased)
        {
            _tcscpy(strCoverpageName,FaxConfig.CoverPageName);
        }
        else
        {
            //
            // this is a personal CP, we have to add to it's name the full UNC path
            //
            TCHAR   CpDir[MAX_PATH] = {0};
            TCHAR*  pCpName = NULL;

            bResult = GetClientCpDir( CpDir, sizeof(CpDir) / sizeof(CpDir[0]));
            if(! bResult) 
            {
                CALL_FAIL(GENERAL_ERR, TEXT("GetClientCpDir"), ::GetLastError());
                dwRetVal = IDS_INTERNAL_ERROR;
                goto exit;
            }

            _tcscat(CpDir,FaxConfig.CoverPageName);
            
            //
            // if it is a link to a cp, it's ext is .lnk
            // if it is not a link, it's ext. is .cov
            //
            if(FaxConfig.LinkCoverPage)
            {
                _tcscat(CpDir, FAX_LNK_FILE_DOT_EXT);
                if (IsCoverPageShortcut( CpDir )) 
                {
                    if (!ResolveShortcut( CpDir, strCoverpageName )) 
                    {
                        VERBOSE(DBG_MSG,TEXT("Cover page file is really a link, but resolution is not possible"));
                        dwRetVal = IDS_BAD_ATTACHMENTS;
                        goto exit;
                    } 
                } 
                else 
                {
                    VERBOSE(DBG_MSG,TEXT("Cover page file is not a link, al though it is suppoed to be"));
                    dwRetVal = IDS_BAD_ATTACHMENTS;
                    goto exit;
                }
            }
            else
            {
                if((_tcslen(CpDir)/sizeof(TCHAR) + _tcslen(FAX_COVER_PAGE_FILENAME_EXT)/sizeof(TCHAR) + 1) > MAX_PATH)
                {
                    dwRetVal = IDS_INTERNAL_ERROR;
                    goto exit;
                }
                _tcscat(CpDir, FAX_COVER_PAGE_FILENAME_EXT);
                _tcscpy(strCoverpageName, CpDir);
            }

        }
    	VERBOSE (DBG_MSG, TEXT("Sending Fax with Coverpage: %s"), strCoverpageName);

        //
        // initializes a cover page info
        //
        CovInfo.dwSizeOfStruct          = sizeof( FAX_COVERPAGE_INFO_EX);
        CovInfo.dwCoverPageFormat       = FAX_COVERPAGE_FMT_COV;
        CovInfo.lptstrCoverPageFileName = strCoverpageName; 
        //if it's not a server's CP, should include exact path to the CP file
        CovInfo.bServerBased            = bServerBased ;
        CovInfo.lptstrNote              = NULL;
        CovInfo.lptstrSubject           = lptstrSubject;
    }
    else
    {
        //
        // no cover page
        //
        CovInfo.dwSizeOfStruct          = sizeof( FAX_COVERPAGE_INFO_EX);
        CovInfo.dwCoverPageFormat       = FAX_COVERPAGE_FMT_COV_SUBJECT_ONLY;
        CovInfo.lptstrSubject           = lptstrSubject;
    }


    // 
    // *************************
    // connect to the fax server
    // *************************
    //

    if (!GetServerNameFromPrinterInfo(PrinterInfo ,&lptszServerName ) ||
        !FaxConnectFaxServer(lptszServerName,&FaxServer))   
    {
		CALL_FAIL (GENERAL_ERR, TEXT("FaxConnectFaxServer"), ::GetLastError());
        dwRetVal = IDS_CANT_ACCESS_SERVER;
        goto exit;
    }
	
	VERBOSE (DBG_MSG, TEXT("Connected to Fax Server: %s"), lptszServerName);

    // 
    // *****************************
    // initialize the job parameters
    // *****************************
    //
    JobParamsEx.dwSizeOfStruct = sizeof( FAX_JOB_PARAM_EX);
    VERBOSE (DBG_MSG, TEXT("******************JobParamsEx:***********************"));

    //
    // get the sender's SMTP address
    // pMsgProps hold PropsForHeader properties, including PR_SENDER_ENTRYID
    //
        
    hResult = m_pSupObj->OpenAddressBook(NULL, 0, &lpAdrBook);
    if (FAILED(hResult))
    {
		CALL_FAIL (GENERAL_ERR, TEXT("OpenAddressBook"), ::GetLastError());
    }

    else
    {  
        hResult = lpAdrBook->OpenEntry(
                pMsgProps[MSG_SENDER_ENTRYID].Value.bin.cb, 
                (LPENTRYID)pMsgProps[MSG_SENDER_ENTRYID].Value.bin.lpb, 
                NULL, 
                0, 
                &ulObjType, 
                (LPUNKNOWN*)&pMailUser
                );
        if (FAILED(hResult))
        {
            CALL_FAIL (GENERAL_ERR, TEXT("OpenEntry"), ::GetLastError());
        }
        else
        {
            hResult = pMailUser->GetProps(
                    (LPSPropTagArray)&sptPropxyAddrProp, 
                    0, 
                    &cValues, 
                    &lpPropValue
                    );
            if (!HR_SUCCEEDED(hResult) ||
                PT_ERROR == PROP_TYPE(lpPropValue->ulPropTag))
            {
                //
                // We either failed to get the property or the property retrieved has some error.
                // If we're unable to locate sender's address, we won't be sending a Delivry Receipt,
                // but we won't fail the sending.
                //
                CALL_FAIL (GENERAL_ERR, TEXT("GetProps from MailUser failed, no receipt will be sent!"), hResult);
            }         
            else
            {
                //
                //loop through the proxy multivalue property
                //
                for(j=0;j<lpPropValue->Value.MVszA.cValues; j++)
                {
                    lpstrSenderSMTPAdr = ConvertAStringToTString(lpPropValue->Value.MVszA.lppszA[j]);
                    if(! lpstrSenderSMTPAdr)
                    {
                        dwRetVal = IDS_OUT_OF_MEM;
                        goto exit;
                    }
                    //
                    // check if address begins with "SMTP:":
                    // function returns pointer to begining of second param.'s appearance in first param.
                    // if it does not appear, returns NULL
                    //
                    lpstrSMTPPrefix = _tcsstr(lpstrSenderSMTPAdr, TEXT("SMTP:"));
                    if( lpstrSenderSMTPAdr == lpstrSMTPPrefix) 
                    {
                        //
                        // Remove this prefix from it, and store it in JobParamsEx.
                        //
                        lpstrSenderAdr = lpstrSenderSMTPAdr + _tcslen(TEXT("SMTP:"));
                        JobParamsEx.lptstrReceiptDeliveryAddress = _tcsdup(lpstrSenderAdr);
                        if(! JobParamsEx.lptstrReceiptDeliveryAddress)
                        {
                            dwRetVal = IDS_OUT_OF_MEM;
                            goto exit;
                        }
                        bGotSenderAdr = TRUE;
                        VERBOSE(DBG_MSG, TEXT("Receipt delivery address is %s"), JobParamsEx.lptstrReceiptDeliveryAddress);
                        break;
                    }
                }
            }
        }
    }

    //
    // when to send, sort of delivery receipt
    //
    JobParamsEx.dwScheduleAction = JSA_NOW; 

    if(!FaxGetReceiptsOptions(FaxServer, &dwReceiptsOptions))
    {
        CALL_FAIL(GENERAL_ERR, TEXT("FaxGetReceiptsOptions"), ::GetLastError());
    }

    JobParamsEx.dwReceiptDeliveryType = DRT_NONE;
    if (bGotSenderAdr && (dwReceiptsOptions & DRT_EMAIL))
    {
        if (TRUE == FaxConfig.SendSingleReceipt)
        {
            JobParamsEx.dwReceiptDeliveryType = DRT_EMAIL | DRT_GRP_PARENT;
        }
        else
        {
            JobParamsEx.dwReceiptDeliveryType = DRT_EMAIL;
        }      
        if (FaxConfig.bAttachFax)
        {
            JobParamsEx.dwReceiptDeliveryType |= DRT_ATTACH_FAX;
        }
    }
    VERBOSE(DBG_MSG, TEXT("Receipt Delivery Type = %ld"), JobParamsEx.dwReceiptDeliveryType);

    //
    // priority
    //
	if (pMsgProps[MSG_IMPORTANCE].ulPropTag == PR_IMPORTANCE)
    {
		if(FALSE == (FaxAccessCheckEx(FaxServer, MAXIMUM_ALLOWED, &dwRights)))
		{
            if((hResult = ::GetLastError()) != ERROR_SUCCESS)
            {
                CALL_FAIL(GENERAL_ERR, TEXT("FaxAccessCheckEx"), hResult);
                dwRetVal = IDS_CANT_ACCESS_PROFILE;
                goto exit;
            }        
        }
        //
        //try to give the sender the prio he asked for. if it's not allowed, try a lower prio. 
        //
        switch(pMsgProps[MSG_IMPORTANCE].Value.l)
        {
            case (IMPORTANCE_HIGH):
                if ((FAX_ACCESS_SUBMIT_HIGH & dwRights) == FAX_ACCESS_SUBMIT_HIGH)
                {                
                    JobParamsEx.Priority = FAX_PRIORITY_TYPE_HIGH;
                    break;
                }
                //fall through
            case (IMPORTANCE_NORMAL):
                if ((FAX_ACCESS_SUBMIT_NORMAL & dwRights) == FAX_ACCESS_SUBMIT_NORMAL)
                {
                    JobParamsEx.Priority = FAX_PRIORITY_TYPE_NORMAL;
                    break;
                }
                //fall through
            case (IMPORTANCE_LOW):
                if ((FAX_ACCESS_SUBMIT & dwRights) == FAX_ACCESS_SUBMIT)
                {
                    JobParamsEx.Priority = FAX_PRIORITY_TYPE_LOW;     
                }
                else
                {
                    VERBOSE(ASSERTION_FAILED, TEXT("xport\\faxdoc.cpp\\SendFaxDocument: user has no access rights!"));    
                    //the user has no right to submit faxes, at any priority!
                    dwRetVal = IDS_NO_SUBMIT_RITHTS;
                    goto exit;
                }
                break;
            default: 
                VERBOSE(ASSERTION_FAILED, TEXT("xport\\faxdoc.cpp\\SendFaxDocument: message importance has undefined value"));
                ASSERTION_FAILURE
        }
    }
    else 
    {
       VERBOSE(ASSERTION_FAILED, TEXT("xport\\faxdoc.cpp\\SendFaxDocument: Message had no importance property value!"));
       dwRetVal = IDS_INTERNAL_ERROR;
       ASSERTION_FAILURE;
       goto exit;
    }
    VERBOSE(DBG_MSG, TEXT("Message Priority is %ld (0=low, 1=normal, 2=high)"), JobParamsEx.Priority );
    
    //
    // doc name, number of pages, 
    //    
    TCHAR DocName[64];
    LoadString(g_FaxXphInstance, IDS_MESSAGE_DOC_NAME, DocName, sizeof(DocName) / sizeof (DocName[0]));
    JobParamsEx.lptstrDocumentName = DocName;
    JobParamsEx.dwPageCount = 0; //means the server will count the number of pages in the job

    lpdwlRecipientJobIds = (DWORDLONG*)MemAlloc(sizeof(DWORDLONG)*dwRecipientNumber);
    if(! lpdwlRecipientJobIds)
    {
        dwRetVal = IDS_OUT_OF_MEM;
        goto exit;
    }

	//
    // ************
	// Send the fax
	// ************
	//
	bRslt= FaxSendDocumentEx(
                                FaxServer,
                                (LPCTSTR) lptstrDocumentFileName,
                                &CovInfo,
                                &SenderProfile,
                                dwRecipientNumber,
                                pRecipients,
                                &JobParamsEx,
                                &dwlParentJobId,
                                lpdwlRecipientJobIds
                            );

    if (!bRslt)
    {
		hResult = ::GetLastError();
        CALL_FAIL (GENERAL_ERR, TEXT("FaxSendDocumentEx"), hResult);
        // maybe we should swich possible retruned values from SendFaxDocEx, 
        // and choose a more informative IDS
        switch(hResult)
        {
            case ERROR_NOT_ENOUGH_MEMORY:
                                    dwRetVal = IDS_OUT_OF_MEM;
                                    break;
            case ERROR_NO_SYSTEM_RESOURCES:
                                    dwRetVal = IDS_INTERNAL_ERROR;
                                    break;
            case ERROR_CANT_ACCESS_FILE:
                                    dwRetVal = IDS_PERSONAL_CP_FORBIDDEN;
                                    break;     
            case ERROR_BAD_FORMAT:
                                    dwRetVal = IDS_BAD_CANNONICAL_ADDRESS;
                                    break;     
            default:        
                                    dwRetVal = IDS_CANT_PRINT;
                                    break;
        }
        goto exit;
    }

    FaxClose(FaxServer);
    FaxServer = NULL;

    dwRetVal = 0;

exit:
    if(lpAdrBook)
    {
        lpAdrBook->Release();
    }
    if(pMailUser)
    {
        pMailUser->Release();
    }

    if (FaxServer) 
    {
        FaxClose(FaxServer);
    }

    if (pRecipients) 
    {
        for (dwRecipient=0; dwRecipient<dwRecipientNumber ; dwRecipient++) 
        {
            if (pRecipients[dwRecipient].lptstrName)
			{
                MemFree (pRecipients[dwRecipient].lptstrName);
			}

            if (pRecipients[dwRecipient].lptstrFaxNumber)
			{
                MemFree(pRecipients[dwRecipient].lptstrFaxNumber);
			}
        }
        MemFree(pRecipients);
		pRecipients = NULL;
    }

    if (pProfileObj) 
    {
        pProfileObj->Release();
    }
    if (pProps) 
    {
        MAPIFreeBuffer( pProps );
    }
    if (MsgPropTags) 
    {
        MemFree( MsgPropTags );
    }
    if (pPropsMsg) 
    {
        MAPIFreeBuffer( pPropsMsg );
    }
    if (hPrinter) 
    {
        ClosePrinter( hPrinter );
    }
    if (PrinterInfo) 
    {
        MemFree( PrinterInfo );
    }
    if (FaxConfig.PrinterName) 
    {
        MemFree( FaxConfig.PrinterName );
    }
    if (FaxConfig.CoverPageName) 
    {
        MemFree( FaxConfig.CoverPageName );
    }
    if (lptstrRecipientName) 
    {
        MemFree(lptstrRecipientName);
    }
    if (lptstrRecipientNumber) 
    {
        MemFree(lptstrRecipientNumber);
    }
    if (lptstrRecName) 
    {
        MemFree(lptstrRecName);
    }
    if (lptstrRecFaxNumber) 
    {
        MemFree(lptstrRecFaxNumber);
    }
    if (lptstrSubject) 
    {
        MemFree(lptstrSubject);
    }
    if (lptstrDocumentFileName) 
    {
        MemFree(lptstrDocumentFileName);
    }

    if (lpdwlRecipientJobIds) 
    {
        MemFree(lpdwlRecipientJobIds);
    }
    if (lptszServerName)
    {
        MemFree(lptszServerName);
    }

    FaxFreeSenderInformation(&SenderProfile);

    return dwRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\faxsrv\src\exchange\xport\emsabtag.h ===
/*
** --emsabtag.h---------------------------------------------------------------
**
**  Property tag definitions for standard properties of Exchange Address
**  Book objects.
**
**  Note: These proptags are only valid when talking directly to the
**  Exchange Server Address Book. They are specifically NOT valid when
**  trying to read properties from an object copied into another address
**  book provider (the Personal Address Book, for example).
**
**  Copyright (c) Microsoft Corp. 1986-1996. All rights reserved.
** ---------------------------------------------------------------------------
*/

#ifndef _EMSABTAG_H
#define _EMSABTAG_H

/*
* Flags for ulInterfaceOptions on OpenProperty
*/
#define AB_SHOW_PHANTOMS                      2
#define AB_SHOW_OTHERS                        4

/*
* Flags for ulFlag on ResolveNames
*/
#define EMS_AB_ADDRESS_LOOKUP                 0x01

/*
* Constructed, but externally visible.
*/
#define PR_EMS_AB_SERVER                     PROP_TAG( PT_TSTRING, 0xFFFE)
#define PR_EMS_AB_SERVER_A                   PROP_TAG( PT_STRING8, 0xFFFE)
#define PR_EMS_AB_SERVER_W                   PROP_TAG( PT_UNICODE, 0xFFFE)
#define PR_EMS_AB_CONTAINERID                PROP_TAG( PT_LONG,    0xFFFD)
#define PR_EMS_AB_DOS_ENTRYID                PR_EMS_AB_CONTAINERID
#define PR_EMS_AB_PARENT_ENTRYID             PROP_TAG( PT_BINARY,  0xFFFC)
#define PR_EMS_AB_IS_MASTER                  PROP_TAG(PT_BOOLEAN,  0xFFFB)
#define PR_EMS_AB_OBJECT_OID                 PROP_TAG(PT_BINARY,   0xFFFA)
#define PR_EMS_AB_HIERARCHY_PATH             PROP_TAG(PT_TSTRING,  0xFFF9)
#define PR_EMS_AB_HIERARCHY_PATH_A           PROP_TAG(PT_STRING8,  0xFFF9)
#define PR_EMS_AB_HIERARCHY_PATH_W           PROP_TAG(PT_UNICODE,  0xFFF9)
#define PR_EMS_AB_CHILD_RDNS                  PROP_TAG(PT_MV_STRING8,   0xFFF8)

#define MIN_EMS_AB_CONSTRUCTED_PROP_ID        0xFFF8

#define PR_EMS_AB_OTHER_RECIPS                PROP_TAG(PT_OBJECT,       0xF000)

/*
 * Prop tags defined in the schema.
 */
#define PR_EMS_AB_DISPLAY_NAME_PRINTABLE      PROP_TAG(PT_TSTRING,      0x39FF)
#define PR_EMS_AB_DISPLAY_NAME_PRINTABLE_A    PROP_TAG(PT_STRING8,      0x39FF)
#define PR_EMS_AB_DISPLAY_NAME_PRINTABLE_W    PROP_TAG(PT_UNICODE,      0x39FF)

#define PR_EMS_AB_ACCESS_CATEGORY            PROP_TAG( PT_LONG,          0x8044)
#define PR_EMS_AB_ACTIVATION_SCHEDULE        PROP_TAG( PT_BINARY,        0x8045)
#define PR_EMS_AB_ACTIVATION_STYLE           PROP_TAG( PT_LONG,          0x8046)
#define PR_EMS_AB_ADDRESS_ENTRY_DISPLAY_TABLE PROP_TAG( PT_BINARY,        0x8017)
#define PR_EMS_AB_ADDRESS_ENTRY_DISPLAY_TABLE_MSDOS PROP_TAG( PT_BINARY,        0x8047)
#define PR_EMS_AB_ADDRESS_SYNTAX             PROP_TAG( PT_BINARY,        0x8018)
#define PR_EMS_AB_ADDRESS_TYPE               PROP_TAG( PT_TSTRING,       0x8048)
#define PR_EMS_AB_ADDRESS_TYPE_A             PROP_TAG( PT_STRING8,       0x8048)
#define PR_EMS_AB_ADDRESS_TYPE_W             PROP_TAG( PT_UNICODE,       0x8048)
#define PR_EMS_AB_ADMD                       PROP_TAG( PT_TSTRING,       0x8049)
#define PR_EMS_AB_ADMD_A                     PROP_TAG( PT_STRING8,       0x8049)
#define PR_EMS_AB_ADMD_W                     PROP_TAG( PT_UNICODE,       0x8049)
#define PR_EMS_AB_ADMIN_DESCRIPTION          PROP_TAG( PT_TSTRING,       0x804A)
#define PR_EMS_AB_ADMIN_DESCRIPTION_A        PROP_TAG( PT_STRING8,       0x804A)
#define PR_EMS_AB_ADMIN_DESCRIPTION_W        PROP_TAG( PT_UNICODE,       0x804A)
#define PR_EMS_AB_ADMIN_DISPLAY_NAME         PROP_TAG( PT_TSTRING,       0x804B)
#define PR_EMS_AB_ADMIN_DISPLAY_NAME_A       PROP_TAG( PT_STRING8,       0x804B)
#define PR_EMS_AB_ADMIN_DISPLAY_NAME_W       PROP_TAG( PT_UNICODE,       0x804B)
#define PR_EMS_AB_ADMIN_EXTENSION_DLL        PROP_TAG( PT_TSTRING,       0x804C)
#define PR_EMS_AB_ADMIN_EXTENSION_DLL_A      PROP_TAG( PT_STRING8,       0x804C)
#define PR_EMS_AB_ADMIN_EXTENSION_DLL_W      PROP_TAG( PT_UNICODE,       0x804C)
#define PR_EMS_AB_ALIASED_OBJECT_NAME        PROP_TAG( PT_TSTRING,       0x804D)
#define PR_EMS_AB_ALIASED_OBJECT_NAME_A      PROP_TAG( PT_STRING8,       0x804D)
#define PR_EMS_AB_ALIASED_OBJECT_NAME_W      PROP_TAG( PT_UNICODE,       0x804D)
#define PR_EMS_AB_ALIASED_OBJECT_NAME_O      PROP_TAG( PT_OBJECT,        0x804D)
#define PR_EMS_AB_ALIASED_OBJECT_NAME_T      PROP_TAG( PT_TSTRING,       0x804D)
#define PR_EMS_AB_ALT_RECIPIENT              PROP_TAG( PT_TSTRING,       0x804E)
#define PR_EMS_AB_ALT_RECIPIENT_A            PROP_TAG( PT_STRING8,       0x804E)
#define PR_EMS_AB_ALT_RECIPIENT_W            PROP_TAG( PT_UNICODE,       0x804E)
#define PR_EMS_AB_ALT_RECIPIENT_O            PROP_TAG( PT_OBJECT,        0x804E)
#define PR_EMS_AB_ALT_RECIPIENT_T            PROP_TAG( PT_TSTRING,       0x804E)
#define PR_EMS_AB_ALT_RECIPIENT_BL           PROP_TAG( PT_MV_TSTRING,    0x804F)
#define PR_EMS_AB_ALT_RECIPIENT_BL_A         PROP_TAG( PT_MV_STRING8,    0x804F)
#define PR_EMS_AB_ALT_RECIPIENT_BL_W         PROP_TAG( PT_MV_UNICODE,    0x804F)
#define PR_EMS_AB_ALT_RECIPIENT_BL_O         PROP_TAG( PT_OBJECT,        0x804F)
#define PR_EMS_AB_ALT_RECIPIENT_BL_T         PROP_TAG( PT_MV_TSTRING,    0x804F)
#define PR_EMS_AB_ANCESTOR_ID                PROP_TAG( PT_BINARY,        0x8050)
#define PR_EMS_AB_ASSOC_NT_ACCOUNT           PROP_TAG( PT_BINARY,        0x8027)
#define PR_EMS_AB_ASSOC_REMOTE_DXA           PROP_TAG( PT_MV_TSTRING,    0x8051)
#define PR_EMS_AB_ASSOC_REMOTE_DXA_A         PROP_TAG( PT_MV_STRING8,    0x8051)
#define PR_EMS_AB_ASSOC_REMOTE_DXA_W         PROP_TAG( PT_MV_UNICODE,    0x8051)
#define PR_EMS_AB_ASSOC_REMOTE_DXA_O         PROP_TAG( PT_OBJECT,        0x8051)
#define PR_EMS_AB_ASSOC_REMOTE_DXA_T         PROP_TAG( PT_MV_TSTRING,    0x8051)
#define PR_EMS_AB_ASSOCIATION_LIFETIME       PROP_TAG( PT_LONG,          0x8052)
#define PR_EMS_AB_AUTH_ORIG_BL               PROP_TAG( PT_MV_TSTRING,    0x8053)
#define PR_EMS_AB_AUTH_ORIG_BL_A             PROP_TAG( PT_MV_STRING8,    0x8053)
#define PR_EMS_AB_AUTH_ORIG_BL_W             PROP_TAG( PT_MV_UNICODE,    0x8053)
#define PR_EMS_AB_AUTH_ORIG_BL_O             PROP_TAG( PT_OBJECT,        0x8053)
#define PR_EMS_AB_AUTH_ORIG_BL_T             PROP_TAG( PT_MV_TSTRING,    0x8053)
#define PR_EMS_AB_AUTHORITY_REVOCATION_LIST  PROP_TAG( PT_MV_BINARY,     0x8026)
#define PR_EMS_AB_AUTHORIZED_DOMAIN          PROP_TAG( PT_TSTRING,       0x8054)
#define PR_EMS_AB_AUTHORIZED_DOMAIN_A        PROP_TAG( PT_STRING8,       0x8054)
#define PR_EMS_AB_AUTHORIZED_DOMAIN_W        PROP_TAG( PT_UNICODE,       0x8054)
#define PR_EMS_AB_AUTHORIZED_PASSWORD        PROP_TAG( PT_BINARY,        0x8055)
#define PR_EMS_AB_AUTHORIZED_USER            PROP_TAG( PT_TSTRING,       0x8056)
#define PR_EMS_AB_AUTHORIZED_USER_A          PROP_TAG( PT_STRING8,       0x8056)
#define PR_EMS_AB_AUTHORIZED_USER_W          PROP_TAG( PT_UNICODE,       0x8056)
#define PR_EMS_AB_AUTOREPLY                  PROP_TAG( PT_BOOLEAN,       0x800B)
#define PR_EMS_AB_AUTOREPLY_MESSAGE          PROP_TAG( PT_TSTRING,       0x800A)
#define PR_EMS_AB_AUTOREPLY_MESSAGE_A        PROP_TAG( PT_STRING8,       0x800A)
#define PR_EMS_AB_AUTOREPLY_MESSAGE_W        PROP_TAG( PT_UNICODE,       0x800A)
#define PR_EMS_AB_AUTOREPLY_SUBJECT          PROP_TAG( PT_TSTRING,       0x803E)
#define PR_EMS_AB_AUTOREPLY_SUBJECT_A        PROP_TAG( PT_STRING8,       0x803E)
#define PR_EMS_AB_AUTOREPLY_SUBJECT_W        PROP_TAG( PT_UNICODE,       0x803E)
#define PR_EMS_AB_BRIDGEHEAD_SERVERS         PROP_TAG( PT_MV_TSTRING,    0x8174)
#define PR_EMS_AB_BRIDGEHEAD_SERVERS_A       PROP_TAG( PT_MV_STRING8,    0x8174)
#define PR_EMS_AB_BRIDGEHEAD_SERVERS_W       PROP_TAG( PT_MV_UNICODE,    0x8174)
#define PR_EMS_AB_BRIDGEHEAD_SERVERS_O       PROP_TAG( PT_OBJECT,        0x8174)
#define PR_EMS_AB_BRIDGEHEAD_SERVERS_T       PROP_TAG( PT_MV_TSTRING,    0x8174)
#define PR_EMS_AB_BUSINESS_CATEGORY          PROP_TAG( PT_MV_TSTRING,    0x8057)
#define PR_EMS_AB_BUSINESS_CATEGORY_A        PROP_TAG( PT_MV_STRING8,    0x8057)
#define PR_EMS_AB_BUSINESS_CATEGORY_W        PROP_TAG( PT_MV_UNICODE,    0x8057)
#define PR_EMS_AB_BUSINESS_ROLES             PROP_TAG( PT_BINARY,        0x8023)
#define PR_EMS_AB_CA_CERTIFICATE             PROP_TAG( PT_MV_BINARY,     0x8003)
#define PR_EMS_AB_CAN_CREATE_PF              PROP_TAG( PT_MV_TSTRING,    0x8058)
#define PR_EMS_AB_CAN_CREATE_PF_A            PROP_TAG( PT_MV_STRING8,    0x8058)
#define PR_EMS_AB_CAN_CREATE_PF_W            PROP_TAG( PT_MV_UNICODE,    0x8058)
#define PR_EMS_AB_CAN_CREATE_PF_O            PROP_TAG( PT_OBJECT,        0x8058)
#define PR_EMS_AB_CAN_CREATE_PF_T            PROP_TAG( PT_MV_TSTRING,    0x8058)
#define PR_EMS_AB_CAN_CREATE_PF_BL           PROP_TAG( PT_MV_TSTRING,    0x8059)
#define PR_EMS_AB_CAN_CREATE_PF_BL_A         PROP_TAG( PT_MV_STRING8,    0x8059)
#define PR_EMS_AB_CAN_CREATE_PF_BL_W         PROP_TAG( PT_MV_UNICODE,    0x8059)
#define PR_EMS_AB_CAN_CREATE_PF_BL_O         PROP_TAG( PT_OBJECT,        0x8059)
#define PR_EMS_AB_CAN_CREATE_PF_BL_T         PROP_TAG( PT_MV_TSTRING,    0x8059)
#define PR_EMS_AB_CAN_CREATE_PF_DL           PROP_TAG( PT_MV_TSTRING,    0x805A)
#define PR_EMS_AB_CAN_CREATE_PF_DL_A         PROP_TAG( PT_MV_STRING8,    0x805A)
#define PR_EMS_AB_CAN_CREATE_PF_DL_W         PROP_TAG( PT_MV_UNICODE,    0x805A)
#define PR_EMS_AB_CAN_CREATE_PF_DL_O         PROP_TAG( PT_OBJECT,        0x805A)
#define PR_EMS_AB_CAN_CREATE_PF_DL_T         PROP_TAG( PT_MV_TSTRING,    0x805A)
#define PR_EMS_AB_CAN_CREATE_PF_DL_BL        PROP_TAG( PT_MV_TSTRING,    0x805B)
#define PR_EMS_AB_CAN_CREATE_PF_DL_BL_A      PROP_TAG( PT_MV_STRING8,    0x805B)
#define PR_EMS_AB_CAN_CREATE_PF_DL_BL_W      PROP_TAG( PT_MV_UNICODE,    0x805B)
#define PR_EMS_AB_CAN_CREATE_PF_DL_BL_O      PROP_TAG( PT_OBJECT,        0x805B)
#define PR_EMS_AB_CAN_CREATE_PF_DL_BL_T      PROP_TAG( PT_MV_TSTRING,    0x805B)
#define PR_EMS_AB_CAN_NOT_CREATE_PF          PROP_TAG( PT_MV_TSTRING,    0x805C)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_A        PROP_TAG( PT_MV_STRING8,    0x805C)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_W        PROP_TAG( PT_MV_UNICODE,    0x805C)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_O        PROP_TAG( PT_OBJECT,        0x805C)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_T        PROP_TAG( PT_MV_TSTRING,    0x805C)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_BL       PROP_TAG( PT_MV_TSTRING,    0x805D)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_BL_A     PROP_TAG( PT_MV_STRING8,    0x805D)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_BL_W     PROP_TAG( PT_MV_UNICODE,    0x805D)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_BL_O     PROP_TAG( PT_OBJECT,        0x805D)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_BL_T     PROP_TAG( PT_MV_TSTRING,    0x805D)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL       PROP_TAG( PT_MV_TSTRING,    0x805E)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_A     PROP_TAG( PT_MV_STRING8,    0x805E)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_W     PROP_TAG( PT_MV_UNICODE,    0x805E)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_O     PROP_TAG( PT_OBJECT,        0x805E)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_T     PROP_TAG( PT_MV_TSTRING,    0x805E)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_BL    PROP_TAG( PT_MV_TSTRING,    0x805F)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_BL_A  PROP_TAG( PT_MV_STRING8,    0x805F)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_BL_W  PROP_TAG( PT_MV_UNICODE,    0x805F)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_BL_O  PROP_TAG( PT_OBJECT,        0x805F)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_BL_T  PROP_TAG( PT_MV_TSTRING,    0x805F)
#define PR_EMS_AB_CAN_PRESERVE_DNS           PROP_TAG( PT_BOOLEAN,       0x8060)
#define PR_EMS_AB_CERTIFICATE_REVOCATION_LIST PROP_TAG( PT_BINARY,        0x8016)
#define PR_EMS_AB_CLOCK_ALERT_OFFSET         PROP_TAG( PT_LONG,          0x8061)
#define PR_EMS_AB_CLOCK_ALERT_REPAIR         PROP_TAG( PT_BOOLEAN,       0x8062)
#define PR_EMS_AB_CLOCK_WARNING_OFFSET       PROP_TAG( PT_LONG,          0x8063)
#define PR_EMS_AB_CLOCK_WARNING_REPAIR       PROP_TAG( PT_BOOLEAN,       0x8064)
#define PR_EMS_AB_COMPUTER_NAME              PROP_TAG( PT_TSTRING,       0x8065)
#define PR_EMS_AB_COMPUTER_NAME_A            PROP_TAG( PT_STRING8,       0x8065)
#define PR_EMS_AB_COMPUTER_NAME_W            PROP_TAG( PT_UNICODE,       0x8065)
#define PR_EMS_AB_CONNECTED_DOMAINS          PROP_TAG( PT_MV_TSTRING,    0x8066)
#define PR_EMS_AB_CONNECTED_DOMAINS_A        PROP_TAG( PT_MV_STRING8,    0x8066)
#define PR_EMS_AB_CONNECTED_DOMAINS_W        PROP_TAG( PT_MV_UNICODE,    0x8066)
#define PR_EMS_AB_CONTAINER_INFO             PROP_TAG( PT_LONG,          0x8067)
#define PR_EMS_AB_COST                       PROP_TAG( PT_LONG,          0x8068)
#define PR_EMS_AB_COUNTRY_NAME               PROP_TAG( PT_TSTRING,       0x8069)
#define PR_EMS_AB_COUNTRY_NAME_A             PROP_TAG( PT_STRING8,       0x8069)
#define PR_EMS_AB_COUNTRY_NAME_W             PROP_TAG( PT_UNICODE,       0x8069)
#define PR_EMS_AB_CROSS_CERTIFICATE_PAIR     PROP_TAG( PT_MV_BINARY,     0x8025)
#define PR_EMS_AB_DELIV_CONT_LENGTH          PROP_TAG( PT_LONG,          0x806A)
#define PR_EMS_AB_DELIV_EITS                 PROP_TAG( PT_MV_BINARY,     0x806B)
#define PR_EMS_AB_DELIV_EXT_CONT_TYPES       PROP_TAG( PT_MV_BINARY,     0x806C)
#define PR_EMS_AB_DELIVER_AND_REDIRECT       PROP_TAG( PT_BOOLEAN,       0x806D)
#define PR_EMS_AB_DELIVERY_MECHANISM         PROP_TAG( PT_LONG,          0x806E)
#define PR_EMS_AB_DESCRIPTION                PROP_TAG( PT_MV_TSTRING,    0x806F)
#define PR_EMS_AB_DESCRIPTION_A              PROP_TAG( PT_MV_STRING8,    0x806F)
#define PR_EMS_AB_DESCRIPTION_W              PROP_TAG( PT_MV_UNICODE,    0x806F)
#define PR_EMS_AB_DESTINATION_INDICATOR      PROP_TAG( PT_MV_TSTRING,    0x8070)
#define PR_EMS_AB_DESTINATION_INDICATOR_A    PROP_TAG( PT_MV_STRING8,    0x8070)
#define PR_EMS_AB_DESTINATION_INDICATOR_W    PROP_TAG( PT_MV_UNICODE,    0x8070)
#define PR_EMS_AB_DIAGNOSTIC_REG_KEY         PROP_TAG( PT_TSTRING,       0x8071)
#define PR_EMS_AB_DIAGNOSTIC_REG_KEY_A       PROP_TAG( PT_STRING8,       0x8071)
#define PR_EMS_AB_DIAGNOSTIC_REG_KEY_W       PROP_TAG( PT_UNICODE,       0x8071)
#define PR_EMS_AB_DISPLAY_NAME_OVERRIDE      PROP_TAG( PT_BOOLEAN,       0x8001)
#define PR_EMS_AB_DL_MEM_REJECT_PERMS_BL     PROP_TAG( PT_MV_TSTRING,    0x8072)
#define PR_EMS_AB_DL_MEM_REJECT_PERMS_BL_A   PROP_TAG( PT_MV_STRING8,    0x8072)
#define PR_EMS_AB_DL_MEM_REJECT_PERMS_BL_W   PROP_TAG( PT_MV_UNICODE,    0x8072)
#define PR_EMS_AB_DL_MEM_REJECT_PERMS_BL_O   PROP_TAG( PT_OBJECT,        0x8072)
#define PR_EMS_AB_DL_MEM_REJECT_PERMS_BL_T   PROP_TAG( PT_MV_TSTRING,    0x8072)
#define PR_EMS_AB_DL_MEM_SUBMIT_PERMS_BL     PROP_TAG( PT_MV_TSTRING,    0x8073)
#define PR_EMS_AB_DL_MEM_SUBMIT_PERMS_BL_A   PROP_TAG( PT_MV_STRING8,    0x8073)
#define PR_EMS_AB_DL_MEM_SUBMIT_PERMS_BL_W   PROP_TAG( PT_MV_UNICODE,    0x8073)
#define PR_EMS_AB_DL_MEM_SUBMIT_PERMS_BL_O   PROP_TAG( PT_OBJECT,        0x8073)
#define PR_EMS_AB_DL_MEM_SUBMIT_PERMS_BL_T   PROP_TAG( PT_MV_TSTRING,    0x8073)
#define PR_EMS_AB_DL_MEMBER_RULE             PROP_TAG( PT_MV_BINARY,     0x8074)
#define PR_EMS_AB_DOMAIN_DEF_ALT_RECIP       PROP_TAG( PT_TSTRING,       0x8075)
#define PR_EMS_AB_DOMAIN_DEF_ALT_RECIP_A     PROP_TAG( PT_STRING8,       0x8075)
#define PR_EMS_AB_DOMAIN_DEF_ALT_RECIP_W     PROP_TAG( PT_UNICODE,       0x8075)
#define PR_EMS_AB_DOMAIN_DEF_ALT_RECIP_O     PROP_TAG( PT_OBJECT,        0x8075)
#define PR_EMS_AB_DOMAIN_DEF_ALT_RECIP_T     PROP_TAG( PT_TSTRING,       0x8075)
#define PR_EMS_AB_DOMAIN_NAME                PROP_TAG( PT_TSTRING,       0x8076)
#define PR_EMS_AB_DOMAIN_NAME_A              PROP_TAG( PT_STRING8,       0x8076)
#define PR_EMS_AB_DOMAIN_NAME_W              PROP_TAG( PT_UNICODE,       0x8076)
#define PR_EMS_AB_DSA_SIGNATURE              PROP_TAG( PT_BINARY,        0x8077)
#define PR_EMS_AB_DXA_ADMIN_COPY             PROP_TAG( PT_BOOLEAN,       0x8078)
#define PR_EMS_AB_DXA_ADMIN_FORWARD          PROP_TAG( PT_BOOLEAN,       0x8079)
#define PR_EMS_AB_DXA_ADMIN_UPDATE           PROP_TAG( PT_LONG,          0x807A)
#define PR_EMS_AB_DXA_APPEND_REQCN           PROP_TAG( PT_BOOLEAN,       0x807B)
#define PR_EMS_AB_DXA_CONF_CONTAINER_LIST    PROP_TAG( PT_MV_TSTRING,    0x807C)
#define PR_EMS_AB_DXA_CONF_CONTAINER_LIST_A  PROP_TAG( PT_MV_STRING8,    0x807C)
#define PR_EMS_AB_DXA_CONF_CONTAINER_LIST_W  PROP_TAG( PT_MV_UNICODE,    0x807C)
#define PR_EMS_AB_DXA_CONF_CONTAINER_LIST_O  PROP_TAG( PT_OBJECT,        0x807C)
#define PR_EMS_AB_DXA_CONF_CONTAINER_LIST_T  PROP_TAG( PT_MV_TSTRING,    0x807C)
#define PR_EMS_AB_DXA_CONF_REQ_TIME          PROP_TAG( PT_SYSTIME,       0x807D)
#define PR_EMS_AB_DXA_CONF_SEQ               PROP_TAG( PT_TSTRING,       0x807E)
#define PR_EMS_AB_DXA_CONF_SEQ_A             PROP_TAG( PT_STRING8,       0x807E)
#define PR_EMS_AB_DXA_CONF_SEQ_W             PROP_TAG( PT_UNICODE,       0x807E)
#define PR_EMS_AB_DXA_CONF_SEQ_USN           PROP_TAG( PT_LONG,          0x807F)
#define PR_EMS_AB_DXA_EXCHANGE_OPTIONS       PROP_TAG( PT_LONG,          0x8080)
#define PR_EMS_AB_DXA_EXPORT_NOW             PROP_TAG( PT_BOOLEAN,       0x8081)
#define PR_EMS_AB_DXA_FLAGS                  PROP_TAG( PT_LONG,          0x8082)
#define PR_EMS_AB_DXA_IMP_SEQ                PROP_TAG( PT_TSTRING,       0x8083)
#define PR_EMS_AB_DXA_IMP_SEQ_A              PROP_TAG( PT_STRING8,       0x8083)
#define PR_EMS_AB_DXA_IMP_SEQ_W              PROP_TAG( PT_UNICODE,       0x8083)
#define PR_EMS_AB_DXA_IMP_SEQ_TIME           PROP_TAG( PT_SYSTIME,       0x8084)
#define PR_EMS_AB_DXA_IMP_SEQ_USN            PROP_TAG( PT_LONG,          0x8085)
#define PR_EMS_AB_DXA_IMPORT_NOW             PROP_TAG( PT_BOOLEAN,       0x8086)
#define PR_EMS_AB_DXA_IN_TEMPLATE_MAP        PROP_TAG( PT_MV_TSTRING,    0x8087)
#define PR_EMS_AB_DXA_IN_TEMPLATE_MAP_A      PROP_TAG( PT_MV_STRING8,    0x8087)
#define PR_EMS_AB_DXA_IN_TEMPLATE_MAP_W      PROP_TAG( PT_MV_UNICODE,    0x8087)
#define PR_EMS_AB_DXA_LOCAL_ADMIN            PROP_TAG( PT_TSTRING,       0x8088)
#define PR_EMS_AB_DXA_LOCAL_ADMIN_A          PROP_TAG( PT_STRING8,       0x8088)
#define PR_EMS_AB_DXA_LOCAL_ADMIN_W          PROP_TAG( PT_UNICODE,       0x8088)
#define PR_EMS_AB_DXA_LOCAL_ADMIN_O          PROP_TAG( PT_OBJECT,        0x8088)
#define PR_EMS_AB_DXA_LOCAL_ADMIN_T          PROP_TAG( PT_TSTRING,       0x8088)
#define PR_EMS_AB_DXA_LOGGING_LEVEL          PROP_TAG( PT_LONG,          0x8089)
#define PR_EMS_AB_DXA_NATIVE_ADDRESS_TYPE    PROP_TAG( PT_TSTRING,       0x808A)
#define PR_EMS_AB_DXA_NATIVE_ADDRESS_TYPE_A  PROP_TAG( PT_STRING8,       0x808A)
#define PR_EMS_AB_DXA_NATIVE_ADDRESS_TYPE_W  PROP_TAG( PT_UNICODE,       0x808A)
#define PR_EMS_AB_DXA_OUT_TEMPLATE_MAP       PROP_TAG( PT_MV_TSTRING,    0x808B)
#define PR_EMS_AB_DXA_OUT_TEMPLATE_MAP_A     PROP_TAG( PT_MV_STRING8,    0x808B)
#define PR_EMS_AB_DXA_OUT_TEMPLATE_MAP_W     PROP_TAG( PT_MV_UNICODE,    0x808B)
#define PR_EMS_AB_DXA_PASSWORD               PROP_TAG( PT_TSTRING,       0x808C)
#define PR_EMS_AB_DXA_PASSWORD_A             PROP_TAG( PT_STRING8,       0x808C)
#define PR_EMS_AB_DXA_PASSWORD_W             PROP_TAG( PT_UNICODE,       0x808C)
#define PR_EMS_AB_DXA_PREV_EXCHANGE_OPTIONS  PROP_TAG( PT_LONG,          0x808D)
#define PR_EMS_AB_DXA_PREV_EXPORT_NATIVE_ONLY PROP_TAG( PT_BOOLEAN,       0x808E)
#define PR_EMS_AB_DXA_PREV_IN_EXCHANGE_SENSITIVITY PROP_TAG( PT_LONG,          0x808F)
#define PR_EMS_AB_DXA_PREV_REMOTE_ENTRIES    PROP_TAG( PT_TSTRING,       0x8090)
#define PR_EMS_AB_DXA_PREV_REMOTE_ENTRIES_A  PROP_TAG( PT_STRING8,       0x8090)
#define PR_EMS_AB_DXA_PREV_REMOTE_ENTRIES_W  PROP_TAG( PT_UNICODE,       0x8090)
#define PR_EMS_AB_DXA_PREV_REMOTE_ENTRIES_O  PROP_TAG( PT_OBJECT,        0x8090)
#define PR_EMS_AB_DXA_PREV_REMOTE_ENTRIES_T  PROP_TAG( PT_TSTRING,       0x8090)
#define PR_EMS_AB_DXA_PREV_REPLICATION_SENSITIVITY PROP_TAG( PT_LONG,          0x8091)
#define PR_EMS_AB_DXA_PREV_TEMPLATE_OPTIONS  PROP_TAG( PT_LONG,          0x8092)
#define PR_EMS_AB_DXA_PREV_TYPES             PROP_TAG( PT_LONG,          0x8093)
#define PR_EMS_AB_DXA_RECIPIENT_CP           PROP_TAG( PT_TSTRING,       0x8094)
#define PR_EMS_AB_DXA_RECIPIENT_CP_A         PROP_TAG( PT_STRING8,       0x8094)
#define PR_EMS_AB_DXA_RECIPIENT_CP_W         PROP_TAG( PT_UNICODE,       0x8094)
#define PR_EMS_AB_DXA_REMOTE_CLIENT          PROP_TAG( PT_TSTRING,       0x8095)
#define PR_EMS_AB_DXA_REMOTE_CLIENT_A        PROP_TAG( PT_STRING8,       0x8095)
#define PR_EMS_AB_DXA_REMOTE_CLIENT_W        PROP_TAG( PT_UNICODE,       0x8095)
#define PR_EMS_AB_DXA_REMOTE_CLIENT_O        PROP_TAG( PT_OBJECT,        0x8095)
#define PR_EMS_AB_DXA_REMOTE_CLIENT_T        PROP_TAG( PT_TSTRING,       0x8095)
#define PR_EMS_AB_DXA_REQ_SEQ                PROP_TAG( PT_TSTRING,       0x8096)
#define PR_EMS_AB_DXA_REQ_SEQ_A              PROP_TAG( PT_STRING8,       0x8096)
#define PR_EMS_AB_DXA_REQ_SEQ_W              PROP_TAG( PT_UNICODE,       0x8096)
#define PR_EMS_AB_DXA_REQ_SEQ_TIME           PROP_TAG( PT_SYSTIME,       0x8097)
#define PR_EMS_AB_DXA_REQ_SEQ_USN            PROP_TAG( PT_LONG,          0x8098)
#define PR_EMS_AB_DXA_REQNAME                PROP_TAG( PT_TSTRING,       0x8099)
#define PR_EMS_AB_DXA_REQNAME_A              PROP_TAG( PT_STRING8,       0x8099)
#define PR_EMS_AB_DXA_REQNAME_W              PROP_TAG( PT_UNICODE,       0x8099)
#define PR_EMS_AB_DXA_SVR_SEQ                PROP_TAG( PT_TSTRING,       0x809A)
#define PR_EMS_AB_DXA_SVR_SEQ_A              PROP_TAG( PT_STRING8,       0x809A)
#define PR_EMS_AB_DXA_SVR_SEQ_W              PROP_TAG( PT_UNICODE,       0x809A)
#define PR_EMS_AB_DXA_SVR_SEQ_TIME           PROP_TAG( PT_SYSTIME,       0x809B)
#define PR_EMS_AB_DXA_SVR_SEQ_USN            PROP_TAG( PT_LONG,          0x809C)
#define PR_EMS_AB_DXA_TASK                   PROP_TAG( PT_LONG,          0x809D)
#define PR_EMS_AB_DXA_TEMPLATE_OPTIONS       PROP_TAG( PT_LONG,          0x809E)
#define PR_EMS_AB_DXA_TEMPLATE_TIMESTAMP     PROP_TAG( PT_SYSTIME,       0x809F)
#define PR_EMS_AB_DXA_TYPES                  PROP_TAG( PT_LONG,          0x80A0)
#define PR_EMS_AB_DXA_UNCONF_CONTAINER_LIST  PROP_TAG( PT_MV_TSTRING,    0x80A1)
#define PR_EMS_AB_DXA_UNCONF_CONTAINER_LIST_A PROP_TAG( PT_MV_STRING8,    0x80A1)
#define PR_EMS_AB_DXA_UNCONF_CONTAINER_LIST_W PROP_TAG( PT_MV_UNICODE,    0x80A1)
#define PR_EMS_AB_DXA_UNCONF_CONTAINER_LIST_O PROP_TAG( PT_OBJECT,        0x80A1)
#define PR_EMS_AB_DXA_UNCONF_CONTAINER_LIST_T PROP_TAG( PT_MV_TSTRING,    0x80A1)
#define PR_EMS_AB_ENABLED_PROTOCOLS          PROP_TAG( PT_LONG,          0x817F)
#define PR_EMS_AB_ENCAPSULATION_METHOD       PROP_TAG( PT_LONG,          0x80A2)
#define PR_EMS_AB_ENCRYPT                    PROP_TAG( PT_BOOLEAN,       0x80A3)
#define PR_EMS_AB_ENCRYPT_ALG_LIST_NA        PROP_TAG( PT_MV_TSTRING,    0x8040)
#define PR_EMS_AB_ENCRYPT_ALG_LIST_NA_A      PROP_TAG( PT_MV_STRING8,    0x8040)
#define PR_EMS_AB_ENCRYPT_ALG_LIST_NA_W      PROP_TAG( PT_MV_UNICODE,    0x8040)
#define PR_EMS_AB_ENCRYPT_ALG_LIST_OTHER     PROP_TAG( PT_MV_TSTRING,    0x8041)
#define PR_EMS_AB_ENCRYPT_ALG_LIST_OTHER_A   PROP_TAG( PT_MV_STRING8,    0x8041)
#define PR_EMS_AB_ENCRYPT_ALG_LIST_OTHER_W   PROP_TAG( PT_MV_UNICODE,    0x8041)
#define PR_EMS_AB_ENCRYPT_ALG_SELECTED_NA    PROP_TAG( PT_TSTRING,       0x8043)
#define PR_EMS_AB_ENCRYPT_ALG_SELECTED_NA_A  PROP_TAG( PT_STRING8,       0x8043)
#define PR_EMS_AB_ENCRYPT_ALG_SELECTED_NA_W  PROP_TAG( PT_UNICODE,       0x8043)
#define PR_EMS_AB_ENCRYPT_ALG_SELECTED_OTHER PROP_TAG( PT_TSTRING,       0x803D)
#define PR_EMS_AB_ENCRYPT_ALG_SELECTED_OTHER_A PROP_TAG( PT_STRING8,       0x803D)
#define PR_EMS_AB_ENCRYPT_ALG_SELECTED_OTHER_W PROP_TAG( PT_UNICODE,       0x803D)
#define PR_EMS_AB_EXPAND_DLS_LOCALLY         PROP_TAG( PT_BOOLEAN,       0x80A4)
#define PR_EMS_AB_EXPIRATION_TIME            PROP_TAG( PT_SYSTIME,       0x8028)
#define PR_EMS_AB_EXPORT_CONTAINERS          PROP_TAG( PT_MV_TSTRING,    0x80A5)
#define PR_EMS_AB_EXPORT_CONTAINERS_A        PROP_TAG( PT_MV_STRING8,    0x80A5)
#define PR_EMS_AB_EXPORT_CONTAINERS_W        PROP_TAG( PT_MV_UNICODE,    0x80A5)
#define PR_EMS_AB_EXPORT_CONTAINERS_O        PROP_TAG( PT_OBJECT,        0x80A5)
#define PR_EMS_AB_EXPORT_CONTAINERS_T        PROP_TAG( PT_MV_TSTRING,    0x80A5)
#define PR_EMS_AB_EXPORT_CUSTOM_RECIPIENTS   PROP_TAG( PT_BOOLEAN,       0x80A6)
#define PR_EMS_AB_EXTENDED_CHARS_ALLOWED     PROP_TAG( PT_BOOLEAN,       0x80A7)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_1      PROP_TAG( PT_TSTRING,       0x802D)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_1_A    PROP_TAG( PT_STRING8,       0x802D)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_1_W    PROP_TAG( PT_UNICODE,       0x802D)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_10     PROP_TAG( PT_TSTRING,       0x8036)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_10_A   PROP_TAG( PT_STRING8,       0x8036)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_10_W   PROP_TAG( PT_UNICODE,       0x8036)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_2      PROP_TAG( PT_TSTRING,       0x802E)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_2_A    PROP_TAG( PT_STRING8,       0x802E)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_2_W    PROP_TAG( PT_UNICODE,       0x802E)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_3      PROP_TAG( PT_TSTRING,       0x802F)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_3_A    PROP_TAG( PT_STRING8,       0x802F)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_3_W    PROP_TAG( PT_UNICODE,       0x802F)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_4      PROP_TAG( PT_TSTRING,       0x8030)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_4_A    PROP_TAG( PT_STRING8,       0x8030)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_4_W    PROP_TAG( PT_UNICODE,       0x8030)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_5      PROP_TAG( PT_TSTRING,       0x8031)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_5_A    PROP_TAG( PT_STRING8,       0x8031)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_5_W    PROP_TAG( PT_UNICODE,       0x8031)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_6      PROP_TAG( PT_TSTRING,       0x8032)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_6_A    PROP_TAG( PT_STRING8,       0x8032)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_6_W    PROP_TAG( PT_UNICODE,       0x8032)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_7      PROP_TAG( PT_TSTRING,       0x8033)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_7_A    PROP_TAG( PT_STRING8,       0x8033)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_7_W    PROP_TAG( PT_UNICODE,       0x8033)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_8      PROP_TAG( PT_TSTRING,       0x8034)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_8_A    PROP_TAG( PT_STRING8,       0x8034)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_8_W    PROP_TAG( PT_UNICODE,       0x8034)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_9      PROP_TAG( PT_TSTRING,       0x8035)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_9_A    PROP_TAG( PT_STRING8,       0x8035)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_9_W    PROP_TAG( PT_UNICODE,       0x8035)
#define PR_EMS_AB_EXTENSION_DATA             PROP_TAG( PT_MV_BINARY,     0x80A8)
#define PR_EMS_AB_EXTENSION_NAME             PROP_TAG( PT_MV_TSTRING,    0x80A9)
#define PR_EMS_AB_EXTENSION_NAME_A           PROP_TAG( PT_MV_STRING8,    0x80A9)
#define PR_EMS_AB_EXTENSION_NAME_W           PROP_TAG( PT_MV_UNICODE,    0x80A9)
#define PR_EMS_AB_EXTENSION_NAME_INHERITED   PROP_TAG( PT_MV_TSTRING,    0x80AA)
#define PR_EMS_AB_EXTENSION_NAME_INHERITED_A PROP_TAG( PT_MV_STRING8,    0x80AA)
#define PR_EMS_AB_EXTENSION_NAME_INHERITED_W PROP_TAG( PT_MV_UNICODE,    0x80AA)
#define PR_EMS_AB_FACSIMILE_TELEPHONE_NUMBER PROP_TAG( PT_MV_BINARY,     0x80AB)
#define PR_EMS_AB_FILE_VERSION               PROP_TAG( PT_BINARY,        0x80AC)
#define PR_EMS_