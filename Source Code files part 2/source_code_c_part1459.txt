             {
                case 0:         // disable
                    pRule->SetRuleEnabled( FALSE );
                    break;
                case 1:         // enable
                    pRule->SetRuleEnabled( TRUE );
                    break;
                }

            // set the NT account field of the mapping object
            pRule->SetRuleAccount( T2A ((LPTSTR)(LPCTSTR)mapdlg.m_sz_accountname) );

            // update it in the list control too
            UpdateRuleInDispList( iList, pRule );
            }

        // activate the apply button
        SetModified();
        m_fDirty = TRUE;

        // return true because the user said "OK"
        return TRUE;
        }

    // return FALSE because the user did not say "OK"
    return FALSE;
    }

//---------------------------------------------------------------------------
void CMapWildcardsPge::EnableDependantButtons()
    {
    // the whole purpose of this routine is to gray or activate
    // the edit and delete buttons depending on whether or not anything
    // is selected. So start by getting the selection count
    UINT    cItemsSel = m_clistctrl_list.GetSelectedCount();

    // if there is only one item selected, then possibly activate the up/down buttons
    if ( cItemsSel == 1 )
        {
        m_cbutton_up.EnableWindow( TRUE );
        m_cbutton_down.EnableWindow( TRUE );
        }
    else
        {
        m_cbutton_up.EnableWindow( FALSE );
        m_cbutton_down.EnableWindow( FALSE );
        }

    // now the more general case of multiple selections
    if ( cItemsSel > 0 )
        {
        // there are items selected
        m_cbutton_editrule.EnableWindow( TRUE );
        m_cbutton_delete.EnableWindow( TRUE );
        }
    else
        {
        // nope. Nothing selected
        m_cbutton_editrule.EnableWindow( FALSE );
        m_cbutton_delete.EnableWindow( FALSE );
        }

    // always enable the add button
    m_cbutton_add.EnableWindow( TRUE );
    }


/////////////////////////////////////////////////////////////////////////////
// CMapWildcardsPge message handlers

//---------------------------------------------------------------------------
BOOL CMapWildcardsPge::OnApply()
    {
    BOOL                            f;
    CStoreXBF                       xbf;
    METADATA_HANDLE         hm;

    // if no changes have been made, then don't do anything
    if ( !m_fDirty )
        return TRUE;

    UpdateData( TRUE );

    CWaitCursor wait;

    // set the current value of enable into place
    // get the globals object
    CCertGlobalRuleInfo* pGlob = m_mapper.GetGlobalRulesInfo();
    pGlob->SetRulesEnabled( m_bool_enable );

    // serialize the reference to the mapper itself
    f = m_mapper.Serialize( &xbf );

    // before messing with the metabase, prepare the strings we will need
    CString         szBasePath = m_szMBPath;
    CString         szRelativePath = MB_EXTEND_KEY;
    CString         szObjectPath = m_szMBPath + _T('/') + szRelativePath;

    // prepare the metabase wrapper
    CWrapMetaBase   mbWrap;
    f = mbWrap.FInit(m_pMB);

    // attempt to open the object we want to store into
    f = mbWrap.Open( szObjectPath, METADATA_PERMISSION_WRITE );

    // if that did not work, we need to add the object
    if ( !f )
        {
        // need a slash after the namespace extention now
        szBasePath += _T('/');

        // open the base object
        f = mbWrap.Open( szBasePath, METADATA_PERMISSION_WRITE );
        if ( !f )
            {
            AfxMessageBox(IDS_ERR_ACCESS_MAPPING);
            return FALSE;
            }

        // add the object we want
        f = mbWrap.AddObject( szRelativePath );
        if ( !f )
            {
            AfxMessageBox(IDS_ERR_ACCESS_MAPPING);
            mbWrap.Close();
            return FALSE;
            }

        // close the base object
        f = mbWrap.Close();

        // attempt to open the object we want to store into
        f = mbWrap.Open( szObjectPath, METADATA_PERMISSION_WRITE );
        }

    // set the data into place in the object - IF we were ablt to open it
    if ( f )
        mbWrap.SetData( _T(""), MD_SERIAL_CERTW, IIS_MD_UT_SERVER, BINARY_METADATA, xbf.GetBuff(), xbf.GetUsed(), METADATA_SECURE );

    // close the object
    f = mbWrap.Close();

    // save the changes to the metabase
    f = mbWrap.Save();

    // tell the persistence object to tuck away the reference so that we may find it later
    // f = m_persist.FSave( xbf.GetBuff(), xbf.GetUsed() );

    // deactivate the apply button
    SetModified( FALSE );
    m_fDirty = FALSE;

    //  return f;
    return TRUE;
    }

//---------------------------------------------------------------------------
void CMapWildcardsPge::OnMove( int delta )
    {
    int    iList;

    ASSERT( delta != 0 );

    // make sure there is only one item selected
    ASSERT( m_clistctrl_list.GetSelectedCount() == 1 );

    // Get the list index of the item in question.
    // this is also the index into the rule order array
    iList = m_clistctrl_list.GetNextItem( -1, LVNI_SELECTED );

    // get the globals object
    CCertGlobalRuleInfo* pGlob = m_mapper.GetGlobalRulesInfo();

    // get the number of rules (actually its a number of rule order - but they are the same thing)
    int     cbRules = pGlob->GetRuleOrderCount();

    // test against the edge conditions
    if ( ((iList == 0) && (delta < 0)) | ((iList == (cbRules - 1)) && (delta > 0)) )
        return;

    // get the pointer to the order array
    DWORD * pOrder = pGlob->GetRuleOrderArray();

    // calculate the new position in the array
    int iNewPosition = iList + delta;

    // store away the mapper's iIndex (not the position) of the item
    UINT iIndex = pOrder[iList];

    // swap the positions
    DWORD itemp = pOrder[iNewPosition];
    pOrder[iNewPosition] = pOrder[iList];
    pOrder[iList] = itemp;

    ASSERT( pOrder[iNewPosition] == iIndex );

    // unfortunately, we can't just do that with the display list. We have to remove the
    // the item, then re-insert it. Its a flaw in the CListCtrl object. Arg.
    // we have to get the item too
    CCertMapRule* pRule = m_mapper.GetRule( iIndex );

    // delete the item from the display list
    m_clistctrl_list.DeleteItem( iList );

    // re-insert it
    int iNew = AddRuleToList( pRule, iIndex, iNewPosition );

    // make sure it is visible in the list
    m_clistctrl_list.EnsureVisible( iNew, FALSE );

    // finally, because its been removed and re-inserted, we need to
    // re-select it as well - CListCtrl is such a pain at this
    LV_ITEM         lv;
    ZeroMemory( &lv, sizeof(lv) );
    lv.mask = LVIF_STATE;
    lv.iItem = iNew;
    lv.state = LVIS_SELECTED;
    lv.stateMask = LVIS_SELECTED;
    m_clistctrl_list.SetItem( &lv );

    // activate the apply button
    SetModified();
    m_fDirty = TRUE;
    }

//---------------------------------------------------------------------------
void CMapWildcardsPge::OnMoveDown()
    {
    OnMove( 1 );
    }

//---------------------------------------------------------------------------
void CMapWildcardsPge::OnMoveUp()
    {
    OnMove( -1 );
    }

//---------------------------------------------------------------------------
void CMapWildcardsPge::OnAdd()
    {
    CHAR sz[256];

    // create the new rule
    CCertMapRule * pNewRule = new CCertMapRule();

    if (pNewRule == NULL)
        return;

    // give the new rule some defaults
    LoadStringA(::AfxGetInstanceHandle(), IDS_DEFAULT_RULE, sz, 255 );

    pNewRule->SetRuleName( sz );
    pNewRule->SetRuleEnabled( TRUE );

    // Edit the rule. If it fails, remove it from the list
    if ( !EditOneRule( pNewRule, TRUE ) )
        {
        // kill the rule and return
        delete pNewRule;
        return;
        }

    // make a new mapper & get its index
    DWORD iNewRule = m_mapper.AddRule( pNewRule );

    // add the rule to the end of the display list. - It is added to the
    // end of the rule list by default
    AddRuleToList( pNewRule, iNewRule );

    // make sure it is visible in the list
    m_clistctrl_list.EnsureVisible( iNewRule, FALSE );

    // activate the apply button
    SetModified();
    m_fDirty = TRUE;
    }

//---------------------------------------------------------------------------
void CMapWildcardsPge::OnDelete()
    {
    // ask the user to confirm this decision
    if ( AfxMessageBox(IDS_CONFIRM_DELETE, MB_OKCANCEL) != IDOK )
        return;

    CWaitCursor wait;

    // loop through the selected items, setting each one's mapping
    int     iList = -1;
    while( (iList = m_clistctrl_list.GetNextItem( -1, LVNI_SELECTED )) >= 0 )
        {
        // get the mapper index for the item
        // IA64 - this is OK to cast to DWORD as it is just an index
        DWORD iMapper = (DWORD)m_clistctrl_list.GetItemData( iList );

        // delete the mapping from the mapper
        m_mapper.DeleteRule( iMapper );

        // delete the entry from the list box
        m_clistctrl_list.DeleteItem( iList );


        // because the index in the mapper for all the items below this
        // one changes when it is deleted, we must go and fix them all.
        DWORD numItems = m_clistctrl_list.GetItemCount();
        for ( DWORD iFix = iList; iFix < numItems; iFix++ )
            {
            // get the mapper index for the item to be fixed
            // IA64 - this is OK to cast to DWORD as it is just an index
            iMapper = (DWORD)m_clistctrl_list.GetItemData( iFix );

            // decrement it to reflect the change
            iMapper--;

            // put it back.
            m_clistctrl_list.SetItemData( iFix, iMapper );
            }
        }

    // activate the apply button
    SetModified();
    m_fDirty = TRUE;
    }

//---------------------------------------------------------------------------
void CMapWildcardsPge::OnEdit()
    {
    int             iList;
    DWORD           iRule;
    CCertMapRule*   pUpdateRule;

    // what happens here depends on if just one mapping is selected, or many
    switch( m_clistctrl_list.GetSelectedCount() )
        {
        case 0:         // do nothing - should not get here because button grays out
            ASSERT( FALSE );
            break;

        case 1:         // get the mapping for update and run single edit dialog
            // get index of the selected list item
            iList = m_clistctrl_list.GetNextItem( -1, LVNI_SELECTED );
            ASSERT( iList >= 0 );

            // get the mapper index for the item
            // IA64 - this is OK to cast to DWORD as it is just an index
            iRule = (DWORD)m_clistctrl_list.GetItemData( iList );

            // get the mapping item for updating purposes
            pUpdateRule = m_mapper.GetRule( iRule );

            if ( !pUpdateRule )
                {
                AfxMessageBox( IDS_ERR_ACCESS_MAPPING );
                break;
                }

            // edit the mapping, update it if successful, delete if not
            if ( EditOneRule(pUpdateRule) )
                {
                UpdateRuleInDispList( iList, pUpdateRule );
                // activate the apply button
                SetModified();
                m_fDirty = TRUE;
                }
            break;

        default:        // run the multi edit dialog
            EditMultipleRules();
            break;
        }
    }

//---------------------------------------------------------------------------
void CMapWildcardsPge::OnItemchangedList(NMHDR* pNMHDR, LRESULT* pResult)
    {
    NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
    *pResult = 0;

    // enable the correct items
    EnableDependantButtons();
    }

//---------------------------------------------------------------------------
void CMapWildcardsPge::OnDblclkList(NMHDR* pNMHDR, LRESULT* pResult)
    {
    *pResult = 0;

    // if something in the list was double clicked, edit it
    if ( m_clistctrl_list.GetSelectedCount() > 0 )
       OnEdit();
    }

//---------------------------------------------------------------------------
void CMapWildcardsPge::OnEnable()
    {
    // activate the apply button
    SetModified();
    m_fDirty = TRUE;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certmap\wwzthree.h ===
// WWzThree.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CWildWizThree dialog

class CWildWizThree : public CPropertyPage
{
    DECLARE_DYNCREATE(CWildWizThree)

// Construction
public:
    CWildWizThree();
    ~CWildWizThree();

    // to make the buttons behave right
    BOOL            m_fIsWizard;
    CPropertySheet* m_pPropSheet;

    // the only public member
    CCertMapRule*   m_pRule;

    // base path to the metabase
    CString m_szMBPath;

    virtual BOOL OnWizardFinish();
    virtual BOOL OnApply();
    virtual BOOL OnInitDialog();

    // Dialog Data
    //{{AFX_DATA(CWildWizThree)
    enum { IDD = IDD_WILDWIZ_3 };
    CStatic m_static_password;
    CStatic m_static_account;
    CButton m_btn_browse;
    CEdit   m_cedit_password;
    CEdit   m_cedit_accountname;
    int     m_int_DenyAccess;
    CString m_sz_accountname;
    CString m_sz_password;
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CWildWizThree)
    public:
    virtual BOOL OnSetActive();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CWildWizThree)
    afx_msg void OnBrowse();
    afx_msg void OnChangeNtaccount();
    afx_msg void OnChangePassword();
    afx_msg void OnAcceptLogon();
    afx_msg void OnRefuseLogon();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    void DoHelp();
    void EnableButtons();

    CString m_szOrigPass;
    BOOL    m_bPassTyped;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certmap\wwzone.h ===
// WildWizOne.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CWildWizOne dialog

class CWildWizOne : public CPropertyPage
{
    DECLARE_DYNCREATE(CWildWizOne)

// Construction
public:
    CWildWizOne();
    ~CWildWizOne();

    // to make the buttons behave right
    BOOL            m_fIsWizard;
    CPropertySheet* m_pPropSheet;

    // the only public member
    CCertMapRule*   m_pRule;
    IMSAdminBase*   m_pMB;

    // base path to the metabase
    CString m_szMBPath;

    virtual BOOL OnApply();
    virtual BOOL OnInitDialog();

// Dialog Data
    //{{AFX_DATA(CWildWizOne)
    enum { IDD = IDD_WILDWIZ_1 };
    CString m_sz_description;
    BOOL    m_bool_enable;
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CWildWizOne)
    public:
    virtual BOOL OnSetActive();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CWildWizOne)
    afx_msg void OnChangeDescription();
    afx_msg void OnEnableRule();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    void DoHelp();

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certmap\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently


 
#ifndef   _stdafx_h__2_12_98_
#define   _stdafx_h__2_12_98_

#define VC_EXTRALEAN        // Exclude rarely-used stuff from Windows headers
//
//
//Its never a good idea to hack the following since this will cause problems
//with MFC.
//
//Mail note on the subject:
// We orginally thought that we needed to build with WIN32_IE=0x0400 
// to pick up the new WIZARD97 stuff. MFC42.DLL was built with WIN32_IE=0x0300. 
// Unfortunately, the PROPSHEETPAGE and PROPSHEETHEADER structures (defined in 
// public\sdk\inc\prsht.h) grow between versions 0x0300 and 0x0400. This causes 
// MFC classes to grow, so there is a disconnect between classes in the IIS 
// components and within MFC, and everything quickly goes crazy. So crazy that
// even though some parts of IIS can use it we can not since GetPage(int i)
// from MFC's CPropertySheet will AV.
///////////////////////////
//#define HACK_WIN32IE
///////////////////////////

#ifdef HACK_WIN32IE
// we need to define _WIN32_IE for the new Wizard97 styles
#ifdef _WIN32_IE
# if (_WIN32_IE < 0x0400)
//#pragma warning("we are redefining _WIN32_IE  0x0500 because NT5 headers dont do it")
#  undef  _WIN32_IE
#  define _WIN32_IE  0x0500
# endif
#else
# define _WIN32_IE  0x0500
#endif
#endif /* HACK_WIN32IE */




//#ifndef _WIN32_WINNT
//  #define _WIN32_WINNT 0x0400
//#endif
#include <afxctl.h>         // MFC support for OLE Controls
#include <afxcmn.h>


// Delete the two includes below if you do not wish to use the MFC
//  database classes
#ifndef _UNICODE
#include <afxdb.h>          // MFC database classes
#include <afxdao.h>         // MFC DAO database classes
#endif //_UNICODE

//#include "Global.h"

#define NOT_COMPILING_COMPROP       // we dont want comprop to use
                    // comprop/resource.h -- use our
                    // certmap/resource.h file

//  ../comprop/comprop.h  defines COMDLL and sets it as the following, we want
//  to use '_COMSTATIC' in certmap.   So we define it here.  We included
//  a copy of how comprop will define COMDLL as FYI.
//  We define _MDKEYS_H_ so that ./comprop/comprop.h can be included w/o
//  trouble.  It defines many Unicode string assignments that do not compile
//  in ANSI mode.
//-----------------------------------------------------------------
#ifdef  COMDLL
# undef COMDLL
# define _COMSTATIC
#endif

#ifndef _MDKEYS_H_
#define _MDKEYS_H_
#endif

// #ifdef _COMEXPORT
//     #define COMDLL __declspec(dllexport)
// #elif defined(_COMIMPORT)
//     #define COMDLL __declspec(dllimport)
// #elif defined(_COMSTATIC)
//     #define COMDLL
// #else
//     #error "Must define either _COMEXPORT, _COMIMPORT or _COMSTATIC"
// #endif // _COMEXPORT




//list templates and such
#include <afxtempl.h>
#include <atlconv.h>



#include "resource.h"

/*
#include "Debug.h"
#include "Util.h"
*/



#endif  /* _stdafx_h__2_12_98_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certmap\wrapmaps.cpp ===
/*++

Module Name:

    wrapmaps.cpp

Abstract:

    wrapper classes for the mapper classes provided by phillich. See the headers in iismap.hxx
    These wrappers simplify the code interfaces for accessing the data.

Author:

   Boyd Multerer        boydm
   Boyd Multerer        boydm       4/16/97

--*/

//C:\nt\public\sdk\lib\i386

#include "stdafx.h"
#include "WrapMaps.h"


//#define IISMDB_INDEX_CERT11_CERT        0
//#define IISMDB_INDEX_CERT11_NT_ACCT     1
//#define IISMDB_INDEX_CERT11_NAME        2
//#define IISMDB_INDEX_CERT11_ENABLED     3
//#define IISMDB_INDEX_CERT11_NB          4


//----------------------------------------------------------------
BOOL C11Mapping::GetCertificate( PUCHAR* ppCert, DWORD* pcbCert )
    {
    *ppCert = (PUCHAR)m_pCert;
    *pcbCert = m_cbCert;
    return TRUE;
    }

//----------------------------------------------------------------
BOOL C11Mapping::SetCertificate( PUCHAR pCert, DWORD cbCert )
    {
    // we want to store a copy of the certificate - first free any existing cert
    if ( m_pCert )
        {
        GlobalFree( m_pCert );
        cbCert = 0;
        m_pCert = NULL;
        }
    // copy in the new one
    m_pCert = (PVOID)GlobalAlloc( GPTR, cbCert );
    if ( !m_pCert ) return FALSE;
    CopyMemory( m_pCert, pCert, cbCert );
    m_cbCert = cbCert;
    return TRUE;
    }

//----------------------------------------------------------------
BOOL C11Mapping::GetNTAccount( CString &szAccount )
    {
    szAccount = m_szAccount;
    return TRUE;
    }

//----------------------------------------------------------------
BOOL C11Mapping::SetNTAccount( CString szAccount )
    {
    m_szAccount = szAccount;
    return TRUE;
    }

//----------------------------------------------------------------
BOOL C11Mapping::GetNTPassword( CString &szPassword )
    {
    szPassword = m_szPassword;
    return TRUE;
    }

//----------------------------------------------------------------
BOOL C11Mapping::SetNTPassword( CString szPassword )
    {
    m_szPassword = szPassword;
    return TRUE;
    }

//----------------------------------------------------------------
BOOL C11Mapping::GetMapName( CString &szName )
    {
    szName = m_szName;
    return TRUE;
    }

//----------------------------------------------------------------
BOOL C11Mapping::SetMapName( CString szName )
    {
    m_szName = szName;
    return TRUE;
    }

//----------------------------------------------------------------
// the enabled flag is considered try if the SIZE of data is greater
// than zero. Apparently the content doesn't matter.
BOOL C11Mapping::GetMapEnabled( BOOL* pfEnabled )
    {
    *pfEnabled = m_fEnabled;
    return TRUE;
    }

//----------------------------------------------------------------
// the enabled flag is considered try if the SIZE of data is greater
// than zero. Apparently the content doesn't matter.
BOOL C11Mapping::SetMapEnabled( BOOL fEnabled )
    {
    m_fEnabled = fEnabled;
    return TRUE;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certmap\wwztwo.cpp ===
// WWzTwo.cpp : implementation file
//

#include "stdafx.h"
#include <iadmw.h>
#include "certmap.h"

#include "ListRow.h"
#include "ChkLstCt.h"
extern "C"
    {
    #include <wincrypt.h>
    #include <sslsp.h>
    }
#include "Iismap.hxx"
#include "Iiscmr.hxx"

#include "brwsdlg.h"
#include "EdWldRul.h"
#include "EdtRulEl.h"

#include "WWzTwo.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define COL_CERT_FIELD          0
#define COL_SUB_FIELD           1
#define COL_MATCH_CRITERIA      2

/////////////////////////////////////////////////////////////////////////////
// CWildWizTwo property page

IMPLEMENT_DYNCREATE(CWildWizTwo, CPropertyPage)

CWildWizTwo::CWildWizTwo() : CPropertyPage(CWildWizTwo::IDD)
{
    //{{AFX_DATA_INIT(CWildWizTwo)
    //}}AFX_DATA_INIT
}

CWildWizTwo::~CWildWizTwo()
{
}

void CWildWizTwo::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CWildWizTwo)
    DDX_Control(pDX, IDC_LIST, m_clistctrl_list);
    DDX_Control(pDX, IDC_NEW, m_cbutton_new);
    DDX_Control(pDX, IDC_EDIT, m_cbutton_edit);
    DDX_Control(pDX, IDC_DELETE, m_cbutton_delete);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CWildWizTwo, CPropertyPage)
    //{{AFX_MSG_MAP(CWildWizTwo)
    ON_BN_CLICKED(IDC_DELETE, OnDelete)
    ON_BN_CLICKED(IDC_EDIT, OnEdit)
    ON_NOTIFY(NM_DBLCLK, IDC_LIST, OnDblclkList)
    ON_NOTIFY(LVN_ITEMCHANGED, IDC_LIST, OnItemchangedList)
    ON_BN_CLICKED(IDC_NEW, OnNew)
    //}}AFX_MSG_MAP
    ON_COMMAND(ID_HELP_FINDER,  DoHelp)
    ON_COMMAND(ID_HELP,         DoHelp)
    ON_COMMAND(ID_CONTEXT_HELP, DoHelp)
    ON_COMMAND(ID_DEFAULT_HELP, DoHelp)
END_MESSAGE_MAP()

//---------------------------------------------------------------------------
void CWildWizTwo::DoHelp()
    {
    WinHelp( HIDD_CERTMAP_ADV_RUL_RULES );
    }

//---------------------------------------------------------------------------
BOOL CWildWizTwo::FInitRulesList()
    {
    CString sz;
    int     i;

    // setup the main field
    sz.LoadString( IDS_CERT_FIELD );

    i = m_clistctrl_list.InsertColumn( COL_CERT_FIELD, sz, LVCFMT_LEFT, 100 );

    // setup the sub field
    sz.LoadString( IDS_SUB_FIELD );
    i = m_clistctrl_list.InsertColumn( COL_SUB_FIELD, sz, LVCFMT_LEFT, 70 );

    // setup the match criteria column
    sz.LoadString( IDS_MATCH_CRITERIA );
    i = m_clistctrl_list.InsertColumn( COL_MATCH_CRITERIA, sz, LVCFMT_LEFT, 226 );

    return TRUE;
    }

//---------------------------------------------------------------------------
BOOL CWildWizTwo::FillRulesList()
    {
    CERT_FIELD_ID   idCertField;
    LPBYTE          pContent;
    DWORD           cbContent;
    LPSTR           psz;

    DWORD           flags;

    CString         sz;
    int             i;

    //
    // UNICODE/ANSI conversion -- RonaldM
    //
    USES_CONVERSION;

    // get the number of subfield rules
    DWORD cbRules = m_pRule->GetRuleElemCount();

    // loop the elements, adding each to the list
    for ( DWORD j = 0; j < cbRules; j++ )
        {
        // get the raw data for the rule element
        if ( !m_pRule->GetRuleElem( j, &idCertField, (PCHAR*)&pContent, &cbContent, &psz, &flags ) )
            continue;       // the call failed - try the next

        // start converting the data into readable form and adding it to the list
        sz = MapIdToField( idCertField );
        // create the new entry in the list box.
        i = m_clistctrl_list.InsertItem( j, sz );

        // add the subfield data
        sz = MapAsn1ToSubField( psz );
        m_clistctrl_list.SetItemText( i, COL_SUB_FIELD, sz );

        // add the content data - reuse the psz pointer
        if ( BinaryToMatchRequest( pContent, cbContent, &psz ) )
            m_clistctrl_list.SetItemText( i, COL_MATCH_CRITERIA, A2T(psz) );

        // finally, attach the id cert field as user data to the item
        DWORD   dw;
        BOOL    fMatchCapitalization = !(flags & CMR_FLAGS_CASE_INSENSITIVE);
        dw = ( (fMatchCapitalization << 16) | idCertField );
        m_clistctrl_list.SetItemData( i, dw );
        }

        return TRUE;
    }


//CMR_FLAGS_CASE_INSENSITIVE

// editing and updating

//---------------------------------------------------------------------------
void CWildWizTwo::EnableDependantButtons()
    {
    // the whole purpose of this routine is to gray or activate
    // the edit and delete buttons depending on whether or not anything
    // is selected. So start by getting the selection count
    UINT    cItemsSel = m_clistctrl_list.GetSelectedCount();

    if ( cItemsSel > 0 )
        {
        // there are items selected
        m_cbutton_edit.EnableWindow( TRUE );
        m_cbutton_delete.EnableWindow( TRUE );
        }
    else
        {
        // nope. Nothing selected
        m_cbutton_edit.EnableWindow( FALSE );
        m_cbutton_delete.EnableWindow( FALSE );
        }

    // always enable the new button
    m_cbutton_new.EnableWindow( TRUE );
    }

//---------------------------------------------------------------------------
BOOL CWildWizTwo::EditRule( DWORD iList )
    {
    // declare the editing dialog
    CEditRuleElement    editDlg;
    DWORD               dw;

    // fill in its data
    // IA64 - OK to cast as the data really is just a DWORD
    dw = (DWORD)m_clistctrl_list.GetItemData( iList );
    editDlg.m_bool_match_case = HIWORD( dw );
    editDlg.m_int_field = LOWORD( dw );
    editDlg.m_sz_subfield = m_clistctrl_list.GetItemText( iList, COL_SUB_FIELD );
    editDlg.m_sz_criteria = m_clistctrl_list.GetItemText( iList, COL_MATCH_CRITERIA );

    // run the dialog
    if ( editDlg.DoModal() == IDOK )
        {
        // must convert the field into a string too
        CERT_FIELD_ID id = (CERT_FIELD_ID)editDlg.m_int_field;
        CString sz = MapIdToField( id );
        m_clistctrl_list.SetItemText( iList, COL_CERT_FIELD, sz );

        dw = ( (editDlg.m_bool_match_case << 16) | id);
        m_clistctrl_list.SetItemData( iList, dw );
        m_clistctrl_list.SetItemText( iList, COL_SUB_FIELD, editDlg.m_sz_subfield );
        m_clistctrl_list.SetItemText( iList, COL_MATCH_CRITERIA, editDlg.m_sz_criteria );
 
        // we can now apply
        SetModified();
        }
    return TRUE;
    }


/////////////////////////////////////////////////////////////////////////////
// CWildWizTwo message handlers

//---------------------------------------------------------------------------
BOOL CWildWizTwo::OnInitDialog()
    {
    // call the parental oninitdialog
    BOOL f = CPropertyPage::OnInitDialog();

    // initialize the list
    FInitRulesList();
    FillRulesList();
    EnableDependantButtons();

    // return the answer
    return f;
    }

//---------------------------------------------------------------------------
BOOL CWildWizTwo::OnWizardFinish()
    {
    return OnApply();
    }

//---------------------------------------------------------------------------
BOOL CWildWizTwo::OnApply()
    {
    CERT_FIELD_ID   id;
    CString         szSub, sz;
    LPBYTE          pbBin;
    DWORD           cbBin;
    UINT            cItems;
    UINT            iItem;

    USES_CONVERSION;

    // update the data
    UpdateData( TRUE );

    //======== store the rule elements
    // start by resetting the entire rule - that way we don't have to
    // mess with individual elements in the list, allowing us to cancel. 
    // But that is ok, because we can just spin through
    // the ones in the list very quickly and re-add them

    // remove the existing elements from the list.
    cItems = m_pRule->GetRuleElemCount();
    for ( iItem = 0; iItem < cItems; iItem++ )
        m_pRule->DeleteRuleElem( 0 );

    // add all the items in the list
    cItems = m_clistctrl_list.GetItemCount();
    for ( iItem = 0; iItem < cItems; iItem++ )
        {
        // prepare the field id
        id = (CERT_FIELD_ID)LOWORD(m_clistctrl_list.GetItemData( iItem ));

        // prepare the caps flag
        BOOL    fCaps = HIWORD(m_clistctrl_list.GetItemData( iItem ));
        DWORD   flags = 0;
        if ( !fCaps )
            flags = CMR_FLAGS_CASE_INSENSITIVE;


        // prepare the subfield
        sz = m_clistctrl_list.GetItemText(iItem, COL_SUB_FIELD);

        LPSTR szA = T2A((LPTSTR)(LPCTSTR)sz);
        szSub = MapSubFieldToAsn1( szA );

        // prepare the data
        sz = m_clistctrl_list.GetItemText(iItem, COL_MATCH_CRITERIA);
        szA = T2A((LPTSTR)(LPCTSTR)sz);
        if ( !MatchRequestToBinary( szA, &pbBin, &cbBin) )
            continue;

        // add the element to the rule
        m_pRule->AddRuleElem( 0xffffffff, id, T2A((LPTSTR)(LPCTSTR)szSub), pbBin, cbBin, flags );

        // free the binary match data
        FreeMatchConversion( pbBin );
        }

    // return success
    SetModified( FALSE );
    return TRUE;
    }

//---------------------------------------------------------------------------
void CWildWizTwo::OnDelete() 
    {
    ASSERT( m_clistctrl_list.GetSelectedCount() == 1 );
    DWORD           iList;

    // get index of the selected list item
    iList = m_clistctrl_list.GetNextItem( -1, LVNI_SELECTED );
    ASSERT( iList >= 0 );

    // delete the item from the display list
    m_clistctrl_list.DeleteItem ( iList );

    // we can now apply
    SetModified();
    }

//---------------------------------------------------------------------------
void CWildWizTwo::OnEdit() 
    {
    ASSERT( m_clistctrl_list.GetSelectedCount() == 1 );
    DWORD           iList;

    // get index of the selected list item
    iList = m_clistctrl_list.GetNextItem( -1, LVNI_SELECTED );
    ASSERT( iList >= 0 );

    // edit the item
    EditRule( iList );
    }

//---------------------------------------------------------------------------
void CWildWizTwo::OnNew() 
    {
    // declare the editing dialog
    CEditRuleElement    editDlg;

    // fill in its data
    editDlg.m_bool_match_case = TRUE;
    editDlg.m_int_field = CERT_FIELD_SUBJECT;
    editDlg.m_sz_subfield = "O";

    editDlg.m_sz_criteria.LoadString( IDS_WILDSTRING );

    // run the dialog
    if ( editDlg.DoModal() == IDOK )
        {
        // get the index for adding to the end of the list
        int iEnd = m_clistctrl_list.GetItemCount();

        // Start with the cert field
        CERT_FIELD_ID id = (CERT_FIELD_ID)editDlg.m_int_field;
        CString sz = MapIdToField( id );
        int i = m_clistctrl_list.InsertItem( iEnd, sz );

        DWORD dw = ( (editDlg.m_bool_match_case << 16) | id);
        m_clistctrl_list.SetItemData( i, dw );
//      m_clistctrl_list.SetItemData( i, id );
        m_clistctrl_list.SetItemText( i, COL_SUB_FIELD, editDlg.m_sz_subfield );
        m_clistctrl_list.SetItemText( i, COL_MATCH_CRITERIA, editDlg.m_sz_criteria );

        // we can now apply
        SetModified();
        }
    }

//---------------------------------------------------------------------------
void CWildWizTwo::OnDblclkList(NMHDR* pNMHDR, LRESULT* pResult) 
    {
    *pResult = 0;
    // if something in the list was double clicked, edit it
    if ( m_clistctrl_list.GetSelectedCount() > 0 )
        OnEdit();
    }

//---------------------------------------------------------------------------
void CWildWizTwo::OnItemchangedList(NMHDR* pNMHDR, LRESULT* pResult) 
    {
    NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
    *pResult = 0;

    // enable the correct items
    EnableDependantButtons();
    }

//---------------------------------------------------------------------------
BOOL CWildWizTwo::OnSetActive() 
    {
    // if this is a wizard, gray out the back button
    if ( m_fIsWizard )
        m_pPropSheet->SetWizardButtons( PSWIZB_BACK | PSWIZB_NEXT );
    return CPropertyPage::OnSetActive();
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certmap\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by certmap.rc
//
#define IDS_CERTMAP                     1
#define IDB_CERTMAP                     1
#define IDS_CERTMAP_PPG                 2
#define IDS_KEY_OR_CERT_FILE_FILTER     3
#define IDS_TITLE_CTL_WIZARD            4
#define IDS_OLD_KEYRING_BACKUP_FILE_IMPORT_FILTER 5
#define IDD_MIME_TYPES                  11
#define IDS_DDX_MINIMUM                 28
#define IDS_CERTMAP_PPG_CAPTION         100
#define IDD_PROPPAGE_CERTMAP            100
#define IDS_MAP_SHEET_TITLE             101
#define IDS_INIT_META_ERROR             102
#define IDS_LIST11_NAME                 103
#define IDS_LIST11_ACCOUNT              104
#define IDS_CONFIRM_DELETE              105
#define IDS_ERR_ACCESS_MAPPING          106
#define IDS_NTBROWSE_TITLE              107
#define IDD_PROPPAGE_LARGE_SAMPLE       107
#define IDS_INVALID_ACCOUNT             108
#define IDS_CERTIFICATE_FILTER          109
#define IDS_ERR_INVALID_CERTIFICATE     110
#define IDS_DEFAULT_11MAP               111
#define IDS_ENABLED                     112
#define IDS_ELLIPSIS                    113
#define IDS_WILD_DESCRIPTION            114
#define IDS_WILD_ACCOUNT                115
#define IDS_DEFAULT_RULE                116
#define IDS_CERT_FIELD                  117
#define IDS_MATCH_CRITERIA              118
#define IDS_SUB_FIELD                   119
#define IDS_WILDSTRING                  120
#define IDS_INVALID_SUBFIELD            121
#define IDS_ISSUE_AUTH                  122
#define IDS_ERR_NO_ISSUERS              123
#define IDS_ERR_CANTADD                 124
#define IDS_MATCH_ON_ISSUERS            125
#define IDS_CERTAUTH                    126
#define IDS_CERTAUTH_PPG                127
#define IDS_CERTAUTH_PPG_CAPTION        128
#define IDD_CLEARTEXTWARNING            128
#define IDS_TRUSTED_AUTHORITIES         129
#define IDS_WILDWIZ_TITLE               130
#define IDS_PASS_CONFIRM_FAIL           131
#define IDS_HELPLOC_PWSHELP             132
#define IDD_WZ_CERTGET_1_WELCOME        132
#define IDS_ERR_CERTMAP_TITLE           133
#define IDD_MIME_PROPERTY               133
#define IDS_SHOWN_PASSWORD              134
#define IDS_WANTACCOUNT                 135
#define IDS_DENYACCESS                  136
#define IDD_KEY_VIEWEDIT                137
#define IDR_KEYPROP                     138
#define IDD_CONFIRM_PASSWORD            139
#define IDD_KEY_DATA_VIEW               140
#define IDD_CHOOSE_IPADDRESS            141
#define IDD_NEW_KEY_INFO                142
#define IDI_ICONINFORMATION             143
#define IDD_DIALOG1                     145
#define IDD_CREATING_NEW_KEY            145
#define IDD_ADNIM_INFO                  146
#define IDD_DEFAULT_CONFIRM             147
#define IDR_AVI_CREATING_KEY            149
#define IDD_IMPORT_KEY_PAIR             151
#define IDD_NK_CHOOSE_CA                153
#define IDD_NK_FILE_INFO                154
#define IDD_NK_DN1                      155
#define IDD_NK_KEY_INFO                 157
#define IDD_NK_USER_INFO                158
#define IDD_NK_DN2                      159
#define IDD_CERT_MISMATCH               161
#define IDD_CTL_CREATE_GET_INFO_FROM_USER 188
#define IDD_WZ_CTL_CREATE_GETINFO2      188
#define IDD_WZ_IMPORT_USE_PREEXISTING   198
#define IDC_CAPTIONEDIT                 201
#define IDC_LIST                        202
#define IDD_11CERT_MAPPING              202
#define IDB_CHECK                       202
#define IDC_DELETE                      203
#define IDD_WILDCARDS_1                 203
#define IDD_WILDCARDS_2                 204
#define IDC_ADD                         205
#define IDD_EDIT_RULE_ELEMENT           205
#define IDC_S_O                         206
#define IDC_BTN_HELP                    206
#define IDD_PROPPAGE_CERTAUTH           206
#define IDC_S_OU                        207
#define IDB_CERTAUTH                    207
#define IDC_COMBO1                      208
#define IDC_S_CN                        208
#define IDD_MAP_TO_ACCNT                208
#define IDC_LIST1                       209
#define IDC_COMBO2                      209
#define IDC_S_C                         209
#define IDD_MAP_ONE_TO_ACCNT            209
#define IDC_COMBO3                      210
#define IDC_S_S                         210
#define IDD_WILDCARDS_stored            210
#define IDD_WILDWIZ_1                   210
#define IDC_COMBO4                      211
#define IDC_EDIT_11MAP                  211
#define IDD_SELECT_ISSUERS              211
#define IDC_BUTTON3                     212
#define IDC_S_L                         212
#define IDD_WILDCARDS_Storage           212
#define IDC_I_O                         213
#define IDD_WILDWIZ_2                   213
#define IDC_I_OU                        214
#define IDD_WILDWIZ_3                   214
#define IDC_CHECK1                      215
#define IDC_I_C                         215
#define IDC_CHK_CAPITALIZATION          215
#define IDD_WZ_CERTGET_2_WHAT_TASK      215
#define IDC_CHECK_REMOTE_ONLINE_AUTHORITY 215
#define IDC_ISSUED_TO                   216
#define IDD_WZ_CERTGET_3A_CERT_REQ_INFO 216
#define IDD_WZ_CERTGET_A3_REQ_SHOW_CERTINFO 216
#define IDC_EDIT                        217
#define IDC_ISSUER                      217
#define IDD_WZ_CERTGET_A4_REQ_HOW2CREATE 217
#define IDC_MOVE_UP                     218
#define IDC_MAPNAME                     218
#define IDD_WZ_CERTGET_A5_REQ_WHERE_REQ_GOES 218
#define IDC_MOVE_DOWN                   219
#define IDD_PROPPAGE__FAKE__USED_BY_WixPropPage 219
#define IDC_EDIT1                       220
#define IDC_DESCRIPTION                 220
#define IDC_SUBFIELD                    220
#define IDC_MB_PATH                     220
#define IDC_RADIO1                      221
#define IDC_ALL_ISSUERS                 221
#define IDB_BITMAP_MMC_CTL_4color       221
#define IDC_RADIO2                      222
#define IDC_ENABLE                      222
#define IDC_SOME_ISSUERS                222
#define IDD_MMC_CTL_FYI                 222
#define IDB_BITMAP_TJP2                 222
#define IDC_SELECT_ISSUER               223
#define IDC_EDIT2                       224
#define IDC_PASSWORD2                   224
#define IDD_EDITDIALOG                  224
#define IDC_RADIO5                      225
#define IDC_EDIT3                       225
#define IDC_EDIT4                       226
#define IDB_FYI_MMC_EMPT                226
#define IDD_DIALOG2                     226
#define IDC_RADIO6                      226
#define IDC_EDIT5                       227
#define IDB_FYI_MMC_ADD1                227
#define IDC_CHECK2                      228
#define IDC_ENABLE_RULE                 228
#define IDB_FYI_MMC_ADD2                228
#define IDC_CHECK3                      229
#define IDB_FYI_MMC_ADD3                229
#define IDC_EDIT6                       230
#define IDC_RADIO3                      230
#define IDC_REFUSE_LOGON                230
#define IDB_FYI_MMC_ADD4                230
#define IDC_BROWSE                      231
#define IDB_FYI_MMC_ADD5                231
#define IDC_RADIO4                      232
#define IDC_ACCEPT_LOGON                232
#define IDB_FYI_MMC_ADD6                232
#define IDC_DO_NOT_MATCH                233
#define IDB_FYI_MMC_MCH1                233
#define IDC_NEW                         234
#define IDB_FYI_MMC_MCH2                234
#define IDB_BITMAP_CTL_LEFT             236
#define IDC_FIELDS                      237
#define IDB_BITMAP1                     237
#define IDC_CRITERIA                    238
#define IDC_PASSWORD                    239
#define IDD_PROGRESS_BAR                239
#define IDC_TOGGLE                      240
#define IDD_WZ_INCORRECT_OOB_SAVED      240
#define IDC_CAPTION                     241
#define IDC_STATIC_ACCOUNT              242
#define IDC_STATIC_PASSWORD             243
#define IDC_STATIC_DESC                 244
#define IDC_NK_CA_OFFLINE_COMBO         245
#define IDC_STATIC_DESC_WHERE2MAIL_CERT 246
#define IDC_NTACCOUNT                   248
#define IDC_NK_CA_REMOTE_HOSTNAME       248
#define IDC_LABEL_ERROR_PARAGRAPH1      250
#define IDC_LABEL_ERROR_PARAGRAPH2      251
#define IDC_LABEL_ERROR_PARAGRAPH3      252
#define IDC_LABEL_ERROR_NUMBER          253
#define IDC_PROGRESS1                   254
#define IDB_UP                          505
#define IDB_UPFOC                       506
#define IDB_UPDIS                       507
#define IDB_UPINV                       508
#define IDB_DOWN                        509
#define IDB_DOWNFOC                     510
#define IDB_DOWNDIS                     511
#define IDB_DOWNINV                     512
#define IDC_CONNECT_ServerName          1000
#define IDC_NEW_KEY_NAME                1002
#define IDC_NEW_KEY_REQUEST_FILE        1003
#define IDC_NEW_KEY_BROWSE              1004
#define IDC_STATIC_BOLD                 1006
#define IDC_STATIC_BIGBOLD              1007
#define IDC_NEW_KEY_BITS                1015
#define IDC_NEW_KEY_ORGANIZATION        1017
#define IDC_NEWKEY_COUNTRY              1017
#define IDC_NEW_KEY_UNIT                1018
#define IDC_NEWKEY_ORG                  1018
#define IDC_NEW_KEY_NETADDRESS          1019
#define IDC_NEWKEY_STATE                1019
#define IDC_NEW_KEY_COUNTRY             1020
#define IDC_NEWKEY_ORGUNIT              1020
#define IDC_NEW_KEY_PASSWORD            1021
#define IDC_NEW_NKKI_PASSWORD           1021
#define IDC_INSTALL_PASSWORD            1022
#define IDC_NEWKEY_LOCALITY             1022
#define IDC_NEW_NKKI_PASSWORD2          1022
#define IDC_NEWKEY_COMMONNAME           1023
#define IDC_CONFIRM_PASSWORD            1032
#define IDC_VIEWKEY_STATEPROVINCE       1032
#define IDC_VIEWKEY_LOCALITY            1033
#define IDC_BTN_KEYVIEW_NONE            1034
#define IDC_BTN_KEYVIEW_DEFAULT         1035
#define IDC_BTN_KEYVIEW_IPADDR          1036
#define IDC_KEYDATAVIEW_IPADDRESS       1037
#define IDC_BTN_SELECT_IPADDRESS        1039
#define IDC_GROUP_DN                    1040
#define IDC_GROUP_CONNECTION            1041
#define IDC_STATIC_BITS                 1042
#define IDC_STATIC_ORG                  1043
#define IDC_STATIC_UNIT                 1044
#define IDC_STATIC_NETADDR              1045
#define IDC_STATIC_COUNTRY              1046
#define IDC_STATIC_NAME                 1047
#define IDC_CHOOSER_SERVER_DLG_HELP     1048
#define IDC_STATIC_STATEPROVICE         1048
#define IDC_CHOOSER_HELP_CHOOSE_IP      1048
#define IDC_LIST_IPADDRESSES            1049
#define IDC_STATIC_LOCALITY             1049
#define IDC_HELP_INSTALL_CERTIFICATE    1051
#define IDC_HELP_MORE_NEW_KEY_HELP      1051
#define IDC_BUTTON1                     1052
#define IDC_HELP_CONNECT_SERVER         1052
#define IDC_BROWSE_PRIVATE              1052
#define IDC_BK_CA_PROPERTIES            1052
#define IDC_HOTLINK_CCODES              1052
#define IDC_NEW_KEY_INFO_FILE_PART      1053
#define IDC_DISK_SPACE                  1056
#define IDC_PHYSICAL_MEM                1057
#define IDC_REPDEF_CURRENT              1059
#define IDC_REPDEF_NEW                  1060
#define IDC_STATIC_CREATED              1061
#define IDC_STATIC_EXPIRES              1062
#define IDC_VIEWKEY_CREATED             1063
#define IDC_STATIC_STARTS               1063
#define IDC_VIEWKEY_EXPIRES             1064
#define IDC_VIEWKEY_STARTS              1065
#define IDC_INFO_BASE                   1066
#define IDC_GRINDER_ANIMATION           1067
#define IDC_STATIC_VERIFIER             1068
#define IDC_HELP_CREATE_KEY             1069
#define IDC_BROWSE_CERT                 1070
#define IDC_NK_CA_FILE_RADIO            1070
#define IDC_CERT_FILE                   1071
#define IDC_NK_CA_ONLINE_RADIO          1071
#define IDC_PRIVATE_FILE                1072
#define IDC_NK_CA_ONLINE                1072
#define IDC_NKUI_USER_NAME              1073
#define IDC_BUTTON2                     1074
#define IDC_NK_CA_BROWSE                1074
#define IDC_EDIT_ALIAS                  1079
#define IDC_NK_INFO_FILENAME            1080
#define IDC_NK_CA_FILE                  1082
#define IDC_NKUI_EMAIL_ADDRESS          1083
#define IDC_NKUI_PHONE_NUMBER           1084
#define IDC_NKKI_NAME                   1085
#define IDC_NKKI_BITS                   1086
#define IDC_MESSAGE                     1087
#define IDC_LIST_REQUEST                1088
#define IDC_LIST_CERTIFICATE            1089
#define IDC_IPA_IPADDRESS               1107
#define IDC_EMAIL_ADDRESS               1108
#define IDC_PHONE_NUMBER                1109
#define IDD_FYI_MMC_EMPT                1222
#define IDD_FYI_MMC_ADD1                1223
#define IDD_FYI_MMC_ADD2                1224
#define IDD_FYI_MMC_ADD3                1225
#define IDD_FYI_MMC_ADD4                1226
#define IDD_FYI_MMC_ADD5                1227
#define IDD_FYI_MMC_ADD6                1228
#define IDD_FYI_MMC_MCH1                1229
#define IDD_FYI_MMC_MCH2                1230
#define IDS_ERR_CONNECT                 1446
#define IDS_MACHINE_LOCAL               1447
#define IDS_SERVER_NONE                 1448
#define IDS_CREATE_KEY_NEW_NAME         1449
#define IDS_CREATE_KEY_YOUR_COMPANY     1450
#define IDS_CREATE_KEY_YOUR_UNIT        1451
#define IDS_CREATE_KEY_YOUR_ADDRESS     1453
#define IDS_KEY_DELETE_WARNING          1454
#define IDS_SERVER_COMMIT               1455
#define IDS_ERR_GENERATEPAIR            1456
#define IDS_ERR_WRITEREQUEST            1457
#define IDS_ERR_WRITEKEYS               1458
#define IDS_KEY_STATUS_COMPLETE         1459
#define IDS_KEY_STATUS_INCOMPLETE       1460
#define IDS_KEY_UNKNOWN                 1461
#define IDS_CREATE_KEY_PASSREQUIRED     1462
#define IDS_INCORRECT_PASSWORD          1463
#define IDS_CERT_FILE_EXISTS            1464
#define IDS_REG_SERVER_STORAGE          1465
#define IDS_COMMIT_ERROR                1466
#define IDS_MACHINE_DEFAULT             1467
#define IDS_MACHINE_SELECTED            1468
#define IDS_NEW_KEY_INFO_1              1470
#define IDS_NEW_KEY_INFO_2              1471
#define IDS_ABOUT_MAIN                  1472
#define IDS_ABOUT_SECONDARY             1473
#define IDS_HTTP_COMM_ERROR             1474
#define IDS_NO_VIRT_ROOTS               1475
#define IDS_FOUND_KEYSET_KEYS           1476
#define IDS_UNTITLED                    1477
#define IDS_IMPORT_KEYSET_ERROR         1478
#define IDS_LOCALIZED_DEFAULT_COUNTRY_CODE 1479
#define IDS_GENERATE_KEY_ERROR          1480
#define IDS_INVALID_KEY                 1481
#define IDS_CREATE_KEY_YOUR_STATE       1482
#define IDS_CREATE_KEY_YOUR_LOCALITY    1483
#define IDS_CRED_PASS_ERROR             1484
#define IDS_CRED_PACK_ERROR             1485
#define IDS_KEY_STATUS_EXPIRED          1486
#define IDS_KEY_STATUS_EXPIRES_SOON     1487
#define IDS_EXPIRETIME_FORMAT           1488
#define IDS_RENEW_KEY_INFO_2            1489
#define IDS_NEW_KEY_INFO_BASE           1490
#define IDS_RENEW_KEY_INFO_BASE         1491
#define IDS_CREATING_ANIMATION          1492
#define IDS_CRACKING_ERROR              1493
#define IDS_IMPORT_KEYSET_PRIV_ERROR    1494
#define IDS_IMPORT_KEYSET_PUB_ERROR     1495
#define IDS_IMPORT_KEYSET_PASS_ERROR    1496
#define IDS_KEY_FILE_TYPE               1497
#define IDS_KEY_FILE_INVALID            1498
#define IDS_CERT_FILE_TYPE              1499
#define IDS_REG_USER_INFO               1499
#define IDS_KEYFILE_WARNING             1500
#define IDS_PRIVATE_FILE_TYPE           1501
#define IDD_USER_ACCOUNT                2029
#define IDD_NEW_DIR_ALIAS               2044
#define IDB_WELCOME_COMPLETION          2058
#define IDB_WELCOME_COMPLETION_LEFT     2059
#define ID_SERVER_COMMIT_NOW            2771
#define ID_KEY_CREATE_REQUEST           2772
#define ID_KEY_INSTALL_NEW              2773
#define ID_KEY_DELETE                   2774
#define ID_SERVER_CONNECT               2775
#define ID_KEY_ACTIVATE                 2776
#define IDD_WZwo_CERTSEL_3_CHOOSE_CERT  2776
#define ID_KEY_DEACTIVATE               2777
#define ID_KEY_INSTALL_CERTIFICATE      2778
#define ID_KEY_PROPERTIES               2780
#define ID_KEYPROP_PASTE                2781
#define ID_MAIN_HELP                    2784
#define ID_SERVER_DISCONNECT            2786
#define ID_KEY_SAVE_REQUEST             2787
#define ID_KEYPROP_WRITEKEYREQUEST      2788
#define ID_KEY_CREATE_RENEWAL           2789
#define ID_KEY_IMPORT                   2791
#define ID_KEY_EXPORT                   2792
#define ID_KEY_EXPORT_BACKUP            2793
#define ID_KEY_EXPORT_KEYSET            2794
#define ID_KEY_IMPORT_BACKUP            2795
#define ID_KEY_IMPORT_KEYSET            2796
#define ID_TEST_DATA                    2797
#define ID_SERVPROP_CUT                 2798
#define ID_PROPERTIES                   2799
#define IDS_NEW_CREATE_NEW              2801
#define IDS_ADDONS_LOCATION             2803
#define ID_HELPTOPICS                   2803
#define IDS_NO_SERVICE_MODS             2804
#define IDS_SERVER_INFO_STRING          2806
#define IDS_CA_LOCATION                 2807
#define IDS_LOAD_CA_ERR                 2808
#define IDS_DEFAULT_REQUEST_FILE        2809
#define IDS_GEN_KEYPAIR_ERR             2810
#define IDS_GRIND_GENERATING            2811
#define IDS_GRIND_SUBMITTING            2812
#define IDS_GRIND_SUCCESS               2813
#define IDS_GRIND_DELAYED               2814
#define IDS_GRIND_FILE                  2815
#define IDS_GRIND_ONLINE_FAILURE        2816
#define IDS_GRIND_RESUBMITTING          2818
#define IDS_ILLEGAL_DN_CHARS            2819
#define IDS_BADCHARMSG                  2820
#define IDS_GENERATE_KEY_TITLE          2821
#define IDS_RESTART_PROMPT              2822
#define IDS_IO_ERROR                    2823
#define IDS_BAD_FILE_NAME               2824
#define IDS_FILE_EXISTS                 2825
#define IDS_CHOOSE_COMPUTER             2826
#define IDS_TITLE_CREATE_WIZ            2827
#define IDS_TITLE_RENEW                 2828
#define IDS_INVALID_CA_REQUEST_OLD      2829
#define IDS_CA_NO_INTERFACE             2830
#define IDS_CA_INVALID                  2831
#define IDS_CA_FACTORY_ERR              2832
#define IDS_CA_DENIED                   2833
#define IDS_CA_ERROR                    2834
#define IDS_HELPLOC_KEYRINGHELP         2835
#define IDS_TOTALLY_ILLEGAL_CHARS       2837
#define IDS_CERTERR_INVALID_CERTIFICATE 2838
#define IDS_CERTERR_SCHANNEL_ERR        2840
#define IDS_CERTERROR_PACKAGELOAD_ERROR 2841
#define IDS_CERTERROR_BADPASSWORD       2842
#define IDS_CERTERR_LOMEM               2843
#define IDS_CERTERR_SCHNL_GENERIC       2844
#define EDS_CERTERR_SCHNL_BAD_INIT      2845
#define IDS_OPEN_PRIVATE_KEY            2846
#define IDS_OPEN_PUBLIC_KEY             2847
#define IDS_APP_EXTENSION               2848
#define IDS_APP_EXE_PATH                2849
#define IDS_ERR_GENERIC_ERRCODE         2850
#define IDC_STATIC_WZ_WELCOME           4000
#define IDC_STATIC_WZ_TITLE             4001
#define IDC_STATIC_WZ_SUBTITLE          4002
#define IDS_TRUE                        4003
#define IDS_FALSE                       4004
#define IDS_NOT_AVAILABLE               4005
#define IDS_NONE                        4006
#define IDS_CR_DISP_INCOMPLETE          4007
#define IDS_CR_DISP_ERROR               4008
#define IDS_CR_DISP_DENIED              4009
#define IDS_CR_DISP_ISSUED              4010
#define IDS_CR_DISP_ISSUED_OUT_OF_BAND  4011
#define IDC_ED_BOLD1                    4011
#define IDS_CR_DISP_UNDER_SUBMISSION    4012
#define IDC_ED_BOLD2                    4012
#define IDS_DUPLICATE_CERT              4013
#define IDC_ED_BOLD3                    4013
#define IDS_DESC_CERTMGROBJ             4014
#define IDC_ED_BOLD4                    4014
#define IDS_DESC_CERTIFICATE_STORE      4015
#define IDC_ED_BOLD5                    4015
#define IDS_DESC_CONTAINER              4016
#define IDS_DESC_USAGE                  4017
#define IDS_DESC_CTL                    4018
#define IDS_DESC_CERTIFICATE            4019
#define IDS_ERR_INVALID_FILENAME        4020
#define IDS_ERR_INVALID_FILENAME_0_LEN  4021
#define IDS_CLSID_REGPATH_XENROLL_NONLOCALIZED 4032
#define IDS_MICROSOFT_CERTIFICATE_SERVER_LOCALIZED_DESC_NAME 4033
#define IDS_CertGetConfig_REGPATH_NONLOCALIZED 4035
#define IDS_CertRequest_REGPATH_NONLOCALIZED 4036
#define IDS_XEnroll_REGPATH_NONLOCALIZED 4037
#define IDS_ERR_UNABLE_TO_GET_REQUIRED_CLSID 4038
#define IDS_ERR_UNABLE_TO_BUILD_CLASS_FROM_READ_IN_CLSID 4039
#define IDS_ERR_HAPPENED_DISPLAY_HRESULT 4040
#define IDS_ERR_DISPLAY__HRESULT__S_OK  4041
#define IDS_ERR_DISPLAY__HRESULT__S_FALSE 4042
#define IDS_ERR_DISPLAY__HRESULT__E_FAIL 4043
#define IDS_ERR_DISPLAY__HRESULT__NOERROR 4044
#define IDS_ERR_DISPLAY__HRESULT__CO_E_CLASSSTRING 4045
#define IDS_ERR_DISPLAY__HRESULT__REGDB_E_WRITEREGDB 4046
#define IDS_ERR_DISPLAY__HRESULT__MAYBE_WIN32_ERR 4047
#define IDS_ERR_DISPLAY__HRESULT__CRYPT_E_INVALID_X500_STRING 4048
#define IDS_ERR_DISPLAY__HRESULT__REGDB_E_IIDNOTREG 4049
#define IDS_ERR_DISPLAY__HRESULT__REGDB_E_CLASSNOTREG 4050
#define IDS_ERR_DISPLAY__HRESULT__CLSID_INIT_ERROR 4060
#define IDS_ERR_DISPLAY__HRESULT__CANT_CREATE_XENROLL 4061
#define IDS_ERR_DISPLAY__HRESULT__CANT_CREATE_ICERTREQUEST 4062
#define IDS_ERR_DISPLAY__HRESULT__CANT_CREATE_ICERTGETCONFIG 4063
#define IDS_ERR_DISPLAY__HRESULT__ICERTGETCONFIG_CALL_FAILED 4064
#define IDS_ERR_DISPLAY__HRESULT__EXPORTABLE_KEYS_CALL_FAILED 4065
#define IDS_IISSERVERNAME               4066
#define IDS_ERR_DISPLAY__HRESULT__CREATEPKCS10_CALL_FAILED 4067
#define IDS_ERR_DISPLAY__HRESULT__ACCEPTFILEPKCS7_CALL_FAILED 4068
#define IDS_ERR_DISPLAY__HRESULT__ACCEPTPKCS7_CALL_FAILED 4069
#define IDS_ERR_DISPLAY__HRESULT__PKCS10_ZERO_SIZED 4070
#define IDS_ERR_DISPLAY__HRESULT__ICERTREQUEST_SUBMIT_FAILED 4072
#define IDS_ERR_DISPLAY__HRESULT__ICERTREQUESTGETCERTIFICATE_FAILED 4074
#define IDS_ERR_DISPLAY__HRESULT__CERTAUTH_PLEASE_CALL 4075
#define IDS_ERR_DISPLAY__HRESULT__CERTAUTH_NOT_STARTED 4076
#define IDS_ERR_DISPLAY__HRESULT__CERTAUTH_KEY_NOT_FOUND 4077
#define IDS_ERR_DISPLAY__HRESULT__CERTAUTH_WAS_GIVEN_INVALID_DATA 4078
#define IDS_ERR_DISPLAY__HRESULT__CERTAUTH_REQ_TOO_BIG 4079
#define IDS_ERR_DISPLAY__HRESULT__CERTAUTH_INVALID_REQUEST 4080
#define IDS_ERR_DISPLAY__HRESULT__MYSTOREFLAGS_ACCESS_FAILED 4081
#define IDS_ERR_DISPLAY__HRESULT__ACCEPTPKCS7_ROOTSTORE_NM_SET 4082
#define IDS_INCOMPLETE_BECAUSE_OF_LOW_MEMORY_AVAILABILITY 5001
#define IDS_FILE_PICK_KEYRING_BCKUP     5002
#define IDS_FILE_PICK_CERTFILE2WRITE    5003
#define IDS_MD_CERT_ENROLL_NONE         5005
#define IDS_MD_CERT_ENROLL_ENTERING_DATA_ERROR 5006
#define IDS_MD_CERT_ERROR_DURING_ENROLL_BEFORE_SENDING_TO_CA 5007
#define IDS_MD_CERT_ENROLL_ERR_PROCESSING_PKCS7_OUTOFBAND_B4_XENROLL 5008
#define IDS_MD_CERT_ENROLL_RECVED_ERR_FROM_CA 5009
#define IDS_MD_CERT_ENROLL_RECVED_ERR_FROM_ENROLL 5010
#define IDS_MD_CERT_ENROLL_BAD_PKCS7_RECVED_OUTOFBAND 5011
#define IDS_MD_CERT_ENROLL_RENEWAL_REQ_ERROR 5012
#define IDS_MD_CERT_ENROLL_ENTERING_DATA 5013
#define IDS_MD_CERT_ENROLL_PROCESSING_PKCS7_OUTOFBAND 5014
#define IDS_MD_CERT_ENROLL_SENT_TO_CA   5015
#define IDS_MD_CERT_ENROLL_RECVED_OK_FROM_CA_WAITING4ENROLL 5016
#define IDS_MD_CERT_ENROLL_ENROLL_SUCCESS 5017
#define IDS_MD_CERT_ENROLL_RENEWAL_REQ_STARTED 5018
#define IDS_MD_CERT_ENROLL_IMPORT_OF_KEYRING_BACKUP_FAILED 5019
#define IDS_YOU_ALREADY_HAVE_AN_OOB_CERTIFICATE_REQ 5020
#define IDS_YOU_DONT_HAVE_ANY_OUTSTANDING_OFFLINE_CERTIFICATE_REQUESTS 5021
#define IDS_YOU_CURRENTLY_HAVE_A_CERTIFICATE_INSTALLED_ON_THIS_VIRUTAL_SERVER 5022
#define IDS_WOULD_YOU_LIKE_TO_VIEW_THE_CERTIFICATE_THAT_YOU_JUST_IMPORTED 5023
#define IDS_YOUR_IMPORT_OF_THE_KEYRING_BACKUP_FILE_FAILED 5024
#define IDS_WOULD_YOU_LIKE_TO_VIEW_THE_CERTIFICATE 5025
#define IDS_YOU_ALREADY_HAVE_A_CERTIFICATE 5026
#define IDS_YOU_DO_NOT_CURRENTLY_HAVE_A_CERTIFICATE_TO_RENEW 5027
#define IDS_INTERNAL_ERROR_COULD_NOT_RETRIEVE_CERTIFICATE 5028
#define IDS_INTERNAL_ERROR_COULD_NOT_STORE_CERTIFICATE 5029
#define IDS_CONSTRUCTING_A_NEW_CTL_FOR_YOUR_VIRTUAL_WEB_SERVER 5030
#define IDS_USER_INPUT_CONTAINS_CHARACTERS_THAT_ARE_NOT_ALLOWED 5031
#define IDS_TITLE_CREATE_CTL_WIZ        5032
#define IDS_REVERSE_DNS_NAME_BASED_ON_YOUR_VSERVER_DIFFERS_FROM_REG 5033
#define IDS_CAN_NOT_OPEN_SYSTEM_CERTIFICATE_STORES 5034
#define IDS_CAN_NOT_CLOSE_SYSTEM_CERTIFICATE_STORES 5035
#define IDS_INTERNAL_ERROR_PLEASE_CONTACT_CUSTOMER_HELP 5036
#define IDS_COULD_NOT_ACCESS_THE_METABASE 5037
#define IDS_ERR_CERTWIZ_TITLE           5038
#define IDS_ERR_DISPLAY__OOB_INVALID_FILE_WAS_GIVEN 5039
#define IDS_CHOOSE_PREEXISTING_CERT4THIS_SERVER 5040
#define IDS_ARE_YOU_SURE_YOU_WANT_TO_CANCEL 5041
#define IDS_KEYRING_BACKUP_FILE_IMPORT  5042
#define IDS_SETTING_CONTAINER_NAME_FAILED_IN_XENROLL 5046
#define IDS_YOU_DO_NOT_CURRENTLY_HAVE_A_CERTIFICATE_NEED_ONE4CTL 5048
#define IDS_YOU_ALREADY_HAVE_A_CTL      5049
#define IDS_YOU_DO_NOT_CURRENTLY_HAVE_A_CERTIFICATE_TO_DELETE 5050
#define IDS_ERR_DISPLAY__HRESULT__ACCEPTFILEPKCS7WORKED_BUT_FETCHING_CERT_FAILED 5051
#define IDS_OVERWRITEFILE               5052
#define IDS_WE_COULD_NOT_CREATE_FILE_WS 5053
#define IDS_ERR_DISPLAY__HRESULT__PUT_RENEWALCERTIFICATE_CALL_FAILED 5054
#define IDS_NO_SERVER_INSTANCE_SET      5055
#define IDD_TIPS_BEFORE__CTL_WIZARD     30131
#define IDD_COMPLETION_PAGE             30132
#define IDD_IMP_KEYRING_GET_PASSWD      30133
#define IDD_NK_KEYR_IMPORTFILE_INFO     30134
#define IDD_WZ_CTLADMIN_1_WELCOME       30135
#define IDD_NK_FINCERT_1_GETFILENM      30136
#define IDD_NK_FINCERT_2_FILEDATA       30137
#define IDD_WZ_CTLGET_2_WHAT_TASK       30138
#define IDD_WZ_CTL_CREATE_GETINFO1      30139
#define IDD_WZwo_CERTGET_2_WHAT_TASK    30140
#define IDD_WZwo_CERTGET_3_CHOOSE_CA    30141
#define IDD_WZwo_CERTGET_4_KEY_LENGTH   30142
#define IDD_WZwo_CERTGET_5_ORG_INFO     30143
#define IDD_WZwo_CERTGET_6_DN_INFO      30144
#define IDD_WZwo_CERTGET_7_COUNTRY_INFO 30145
#define IDD_WZwo_CERTGET_8_CONTACT_INFO 30146
#define IDD_WZwo_CERTGET_9_FILE_INFO    30147
#define IDD_WZwo_CERTOOB_1_FINCERT_GETFILENM 30148
#define IDD_WZwo_CERTGET_10_CONGRADS_CERT_INSTALLED 30149
#define IDD_WZerr_CERTWIZ_GENERAL_ERROR_PAGE 30150
#define IDS_DONE                        30151
#define IDD_WZwo_CERTGET_2_WHAT_TASK2   30151
#define IDD_WZw_CERTMOD_2_WHAT_TASK3    30152
#define IDD_WZw_CERTMOD_3_REMOVE_CERT   30153
#define IDS_DONT_HAVE_A_PENDING_CERT_REQUEST 30154
#define IDD_WZ_PROMPT_FOR_FRIENDLY_NAME 30154
#define IDS_ERROR_RESULT_PHRASE         30155
#define IDS_UNKNOWN_ERROR               30156
#define IDS_CAUGHT_AN_UNKNOWN_EXCEPTION 30157
#define IDS_CERTIFICATE_WIZARD_CHOOSE_A_CERTIFICATE 30158
#define IDS_YES                         30159
#define IDS_OK                          30160
#define IDS_CERT_HAS_BEEN_REMOVED       30161
#define IDS_COULDNT_MAP_CERT_TO_VALID_CERT_STORE_NAME 30162
#define IDS_SETTING_CONTAINER_NAME_FAILED 30163
#define IDS_ERR_DISPLAY__HRESULT__USE_MD5_CALL_FAILED 30164
#define IDS_ERROR_GETTING_KEY_CONTAINER_NAME_FOR_THE_CERT 30166
#define IDS_ERROR_STORING_EITHER_THE_KEY_CONTAINER_OR_STORE_NAME_FOR_CERT 30167
#define IDS_COMMON_NAME                 30168
#define IDS_FRIENDLY_NAME               30169
#define IDS_EXPIRATION                  30170
#define IDS_PURPOSE                     30171
#define IDS_ISSUED_BY                   30172
#define IDS_STORE_NAME                  30173
#define IDS_EXPIRED                     30174
#define IDS_NOT_YET_VALID               30175
#define IDS_YOU_MUST_SELECT_A_CERT_THEN_PRESS_FINISH 30176
#define IDS_ANY_PURPOSE                 30177
#define IDS_SERVERCERT__PLUS__CTL_SIGNING 30178
#define IDS_CLOCK_SKEW_PART1            30179
#define IDS_CLOCK_SKEW_PART2            30180
#define IDS_GETHOSTNAME_FAILED_RETURNING_SOCKET 30182
#define IDS_WSAEFAULT                   30183
#define IDS_WSAEFAULT_NAMED_PARAM_NOT_VALID 30184
#define IDS_WSANOTINITIALISED           30185
#define IDS_WSAEINPROGRESS              30186
#define IDS_WE_COULD_NOT_OPEN_FILE_FOR_READING 30187
#define IDS_ERROR_WHILE_READING_FILE__S__ERROR_CODE__D 30188
#define IDS_INSUFFICIENT_MEMORY_WHILE_READING_FILE_S 30189
#define IDS_ERR_DISPLAY__HRESULT__USE_PROV_RSA_SCHANNEL_CALL_FAILED 30191
#define IDS_LOCALHOST                   30193
#define IDS_HRESULT_ERROR_CODE          30194
#define IDS_ERR_DISPLAY__HRESULT__CREATEPKCS10_CALL_FAILED__NTE_EXISTS 30195
#define IDS_NO_SPECIFIC_ERROR_STRING_WAS_FOUND_IN_THE_INTERNATIONALIZED_STRING_TABLE 30196
#define IDS_WE_CURRENTLY_DONT_SUPPORT_REMOTE_CERTSERVER_ONLINE_INTERFACES 30197
#define IDS_WE_CURRENTLY_DONT_SUPPORT_REMOTE_ADMIN_OF_SERVERS 30198
#define IDS_GET_COMPUTER_NAME_FAILED    30199
#define IDS_ERROR_LOADING_RESOURCE_STRING_HAVING_ID 30200
#define IDS_UNKNOWN_ERROR_CODE          30201
#define IDS_ENCRYPTION_NOT_ALLOWED_BASED_ON_THE_MACHINE_CONFIG_DATA 30202
#define IDS__NTE_BAD_FLAGS__ERROR       30203
#define IDS__NTE_BAD_ALGID__ERROR       30204
#define IDS__RPC_E_DISCONNECTED         30205
#define IDS__RPC_E_RETRY                30206
#define IDS_FILE_PICK_CERTFILE2READ     30207
#define IDS_ENTER_COMPUTER_NAME_HERE    30208
#define IDS_AN_ERROR_WAS_ENCOUNTERED_IN_CALL_xxx_PRODUCING_AN_ERROR_CODE_OF 30209
#define IDS_LIMIT_THE_LENGTH_OF_THIS_FIELD 30210
#define IDS_CERTSERVER_IS_PROBABLY_NOT_INSTALLED 30211
#define IDS_PROBLEM_WHEN_RUNNING_X_Y_OPERATION 30212
#define IDS_REGISTER                    30213
#define IDS_UNREGISTER                  30214
#define IDS_PROBLEM_WRITING_TO_FILE_WS_ERROR_D 30215
#define IDS_GETTEMPPATH_FOR_S_PRODUCED_ERROR_D 30216
#define IDS_GETTEMPFILENAME_FOR_S_GAVE_ERROR_D 30217
#define IDS_CREATEFILE_FOR_S_GAVE_ERROR_D 30218
#define IDS_TEMP_FILE_S_NOT_EMPTY_AFTER_WE_CREATED_IT 30219
#define IDS_WRITING_FILE_S_PRODUCED_ERROR_D 30220
#define IDS_CLOSE_FILEHANDLE_FOR_S_GAVE_ERROR_D 30221
#define IDS_CERT_ATTEMPTING_TO_RENEW_VIA_OOB_DOES_NOT_MATCH_CURRENT 30222
#define IDS_PLEASE_CONFIRM__RENEW_CERT_NOT_CURRENTLY_ASSIGNED 30223
#define IDS_CANCELLING_THE_RENEW_OPERATION 30224
#define IDS_WE_COULDNT_FIND_SAVED_OFFLINE_INFO_ABOUT_THIS_CERT_USING_PKCS7 30225
#define IDS_COUNTRY_CODES_ARE_2_LETTERS_LONG 30226
#define IDS_RENEWAL_INFORMATION_FOR_CERT_NOT_AVAILABLE                30227
#define IDS_INTERNAL_ERROR_PLEASE_CONTACT_YOUR_SYSTEM_ADMIN           30228
#define IDS_INTERNAL_ERROR_PLEASE_CONTACT_YOUR_SYSTEM_ADMIN_ERROR__D  30229 
#define IDS_EMPTY_STRING                                              30231

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        241
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         256
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certobj\base64.h ===
//
// base64.h
//
#ifndef _BASE64_H
#define _BASE64_H

DWORD Base64DecodeA(const char * pchIn, DWORD cchIn, BYTE * pbOut, DWORD * pcbOut);
DWORD Base64EncodeA(const BYTE * pbIn, DWORD cbIn, char * pchOut, DWORD * pcchOut);
DWORD Base64EncodeW(BYTE const *pbIn, DWORD cbIn, WCHAR *wszOut, DWORD *pcchOut);
DWORD Base64DecodeW(const WCHAR * wszIn, DWORD cch, BYTE *pbOut, DWORD *pcbOut);

#endif	//_BASE64_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certmap\wwztwo.h ===
// WWzTwo.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CWildWizTwo dialog

class CWildWizTwo : public CPropertyPage
{
    DECLARE_DYNCREATE(CWildWizTwo)

// Construction
public:
    CWildWizTwo();
    ~CWildWizTwo();

    // to make the buttons behave right
    BOOL            m_fIsWizard;
    CPropertySheet* m_pPropSheet;

    // the only public member
    CCertMapRule*   m_pRule;

    // base path to the metabase
    CString m_szMBPath;

    virtual BOOL OnWizardFinish();
    virtual BOOL OnApply();
    virtual BOOL OnInitDialog();

// Dialog Data
    //{{AFX_DATA(CWildWizTwo)
    enum { IDD = IDD_WILDWIZ_2 };
    CListSelRowCtrl m_clistctrl_list;
    CButton m_cbutton_new;
    CButton m_cbutton_edit;
    CButton m_cbutton_delete;
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CWildWizTwo)
    public:
    virtual BOOL OnSetActive();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CWildWizTwo)
    afx_msg void OnDelete();
    afx_msg void OnEdit();
    afx_msg void OnDblclkList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnItemchangedList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnNew();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    void DoHelp();

    BOOL FInitRulesList();
    BOOL FillRulesList();

    // editing and updating
    void EnableDependantButtons();
    BOOL EditRule( DWORD iList );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certmap\wwzthree.cpp ===
// WWzThree.cpp : implementation file
//

#include "stdafx.h"
#include <iadmw.h>
#include "certmap.h"

#include "ListRow.h"
#include "ChkLstCt.h"
extern "C"
    {
    #include <wincrypt.h>
    #include <sslsp.h>
    }
#include "Iismap.hxx"
#include "Iiscmr.hxx"

#include "brwsdlg.h"
#include "EdWldRul.h"
#include "EdtRulEl.h"

#include "WWzThree.h"

#include "cnfrmpsd.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define ACCESS_DENY         0
#define ACCESS_ACCEPT       1

/////////////////////////////////////////////////////////////////////////////
// CWildWizThree property page

IMPLEMENT_DYNCREATE(CWildWizThree, CPropertyPage)

CWildWizThree::CWildWizThree() : CPropertyPage(CWildWizThree::IDD)
{
    //{{AFX_DATA_INIT(CWildWizThree)
    m_int_DenyAccess = -1;
    m_sz_accountname = _T("");
    m_sz_password = _T("");
    //}}AFX_DATA_INIT
    m_bPassTyped = FALSE;
}

CWildWizThree::~CWildWizThree()
{
}

void CWildWizThree::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CWildWizThree)
    DDX_Control(pDX, IDC_STATIC_PASSWORD, m_static_password);
    DDX_Control(pDX, IDC_STATIC_ACCOUNT, m_static_account);
    DDX_Control(pDX, IDC_BROWSE, m_btn_browse);
    DDX_Control(pDX, IDC_PASSWORD, m_cedit_password);
    DDX_Control(pDX, IDC_NTACCOUNT, m_cedit_accountname);
    DDX_Radio(pDX, IDC_REFUSE_LOGON, m_int_DenyAccess);
    DDX_Text(pDX, IDC_NTACCOUNT, m_sz_accountname);
    DDX_Text(pDX, IDC_PASSWORD, m_sz_password);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CWildWizThree, CPropertyPage)
    //{{AFX_MSG_MAP(CWildWizThree)
    ON_BN_CLICKED(IDC_BROWSE, OnBrowse)
    ON_EN_CHANGE(IDC_NTACCOUNT, OnChangeNtaccount)
    ON_EN_CHANGE(IDC_PASSWORD, OnChangePassword)
    ON_BN_CLICKED(IDC_ACCEPT_LOGON, OnAcceptLogon)
    ON_BN_CLICKED(IDC_REFUSE_LOGON, OnRefuseLogon)
    //}}AFX_MSG_MAP
    ON_COMMAND(ID_HELP_FINDER,  DoHelp)
    ON_COMMAND(ID_HELP,         DoHelp)
    ON_COMMAND(ID_CONTEXT_HELP, DoHelp)
    ON_COMMAND(ID_DEFAULT_HELP, DoHelp)
END_MESSAGE_MAP()

//---------------------------------------------------------------------------
void CWildWizThree::DoHelp()
    {
    WinHelp( HIDD_CERTMAP_ADV_RUL_MAPPING );
    }


//---------------------------------------------------------------------------
void CWildWizThree::EnableButtons()
    {
    UpdateData( TRUE );
    
    // if the access is set to refuse access, then disable the account
    // and password stuff.
    if ( m_int_DenyAccess == 0 )
        {
        // deny access
        m_static_password.EnableWindow( FALSE );
        m_static_account.EnableWindow( FALSE );
        m_btn_browse.EnableWindow( FALSE );
        m_cedit_password.EnableWindow( FALSE );
        m_cedit_accountname.EnableWindow( FALSE );
        }
    else
        {
        // give access
        m_static_password.EnableWindow( TRUE );
        m_static_account.EnableWindow( TRUE );
        m_btn_browse.EnableWindow( TRUE );
        m_cedit_password.EnableWindow( TRUE );
        m_cedit_accountname.EnableWindow( TRUE );
        }
    }

/////////////////////////////////////////////////////////////////////////////
// CWildWizThree message handlers

//---------------------------------------------------------------------------
BOOL CWildWizThree::OnApply()
    {
    //
    // UNICODE/ANSI Conversion -- RonaldM
    //
    USES_CONVERSION;

    // update the data
    UpdateData( TRUE );

    // only do the account checks if the option is set to accept
    if ( m_int_DenyAccess == ACCESS_ACCEPT )
        {
        // see if the account name is empty
        if ( m_sz_accountname.IsEmpty() )
            {
            AfxMessageBox( IDS_WANTACCOUNT );
            m_cedit_accountname.SetFocus();
            m_cedit_accountname.SetSel(0, -1);
            return FALSE;
            }
        }

    // confirm the password
    if ( m_bPassTyped && (m_int_DenyAccess == ACCESS_ACCEPT) )
        {
        CConfirmPassDlg dlgPass;
        dlgPass.m_szOrigPass = m_sz_password;
        if ( dlgPass.DoModal() != IDOK )
            {
            m_cedit_password.SetFocus();
            m_cedit_password.SetSel(0, -1);
            return FALSE;
            }
        }
    else
        {
        // restore the original password instead of the
        // standard ****** string
        m_sz_password = m_szOrigPass;
        UpdateData( FALSE );
        }

    // store the deny access radio buttons
    m_pRule->SetRuleDenyAccess( m_int_DenyAccess == ACCESS_DENY );

    // we have to set the account name into place here
    m_pRule->SetRuleAccount( T2A((LPTSTR)(LPCTSTR)m_sz_accountname) );

    // store the password
    m_pRule->SetRulePassword( T2A((LPTSTR)(LPCTSTR)m_sz_password) );

    // reset the password flags
    m_szOrigPass = m_sz_password;
    m_bPassTyped = FALSE;

    SetModified( FALSE );
    return TRUE;
    }

//---------------------------------------------------------------------------
BOOL CWildWizThree::OnInitDialog()
    {
    // call the parental oninitdialog
    BOOL f = CPropertyPage::OnInitDialog();

    // set the easy default strings 
    m_sz_accountname = m_pRule->GetRuleAccount();   // managed by CNTBrowsingDialog from here on

    // set up the deny access radio buttons
    if ( m_pRule->GetRuleDenyAccess() )
        m_int_DenyAccess = ACCESS_DENY;
    else
        m_int_DenyAccess = ACCESS_ACCEPT;

    // initialize the password
    m_sz_password = m_pRule->GetRulePassword();
    m_szOrigPass = m_sz_password;
    if ( !m_sz_password.IsEmpty() )
        m_sz_password.LoadString( IDS_SHOWN_PASSWORD );

    // exchange the data
    UpdateData( FALSE );
    EnableButtons();

    // success
    return TRUE;
    }

//---------------------------------------------------------------------------
BOOL CWildWizThree::OnSetActive() 
    {
    // if this is a wizard, gray out the back button
    if ( m_fIsWizard )
        m_pPropSheet->SetWizardButtons( PSWIZB_BACK | PSWIZB_FINISH );
    return CPropertyPage::OnSetActive();
    }

//---------------------------------------------------------------------------
BOOL CWildWizThree::OnWizardFinish()
    {
    for ( int i = 0; i < m_pPropSheet->GetPageCount( ); i++ )
        {
        if ( !m_pPropSheet->GetPage(i)->OnApply() )
            return FALSE;
        }
    return TRUE;
    }

//---------------------------------------------------------------------------
// run the user browser
void CWildWizThree::OnBrowse() 
    {
    GetIUsrAccount(NULL, this, m_sz_accountname);
    SetModified();
    UpdateData(FALSE);
    }

//---------------------------------------------------------------------------
void CWildWizThree::OnChangeNtaccount() 
    {
    // we can now apply
    SetModified();
    }

//---------------------------------------------------------------------------
void CWildWizThree::OnChangePassword() 
    {
    m_bPassTyped = TRUE;
    // we can now apply
    SetModified();
    }

//---------------------------------------------------------------------------
void CWildWizThree::OnAcceptLogon() 
    {
    EnableButtons();
    // we can now apply
    SetModified();
    }

//---------------------------------------------------------------------------
void CWildWizThree::OnRefuseLogon() 
    {
    EnableButtons();
    // we can now apply
    SetModified();
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certobj\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certobj\dlldatax.c ===
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#define _WIN32_WINNT 0x0400	//for WinNT 4.0 or Win95 with DCOM
#define USE_STUBLESS_PROXY	//defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain				PrxDllMain
#define DllRegisterServer	PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "CertObj_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certobj\base64.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1996
//
// File:        base64.cpp
//
// Contents:    base64 encode/decode implementation
//
// History:     25-Jul-96       vich created
//
//---------------------------------------------------------------------------
//                3-Mar-98   tompop took and modified it.  Building
//                           both Ansi and Wchar versions of Encode/Decode
//                           base 64 for CertWizard, that is in IIS5's UI.
//                           We merged the examples from NT5's base64.cpp
//                           and ubase64.cpp files into this single file.
//					   5-Aug-98	  Sergei Antonov removed above mentioned stuff after tompop
//---------------------------------------------------------------------------
#include "stdafx.h"
#include <malloc.h>
#include <windows.h>
#include "base64.h"

// The following table translates an ascii subset to 6 bit values as follows
// (see rfc 1521):
//
//  input    hex (decimal)
//  'A' --> 0x00 (0)
//  'B' --> 0x01 (1)
//  ...
//  'Z' --> 0x19 (25)
//  'a' --> 0x1a (26)
//  'b' --> 0x1b (27)
//  ...
//  'z' --> 0x33 (51)
//  '0' --> 0x34 (52)
//  ...
//  '9' --> 0x3d (61)
//  '+' --> 0x3e (62)
//  '/' --> 0x3f (63)
//
// Encoded lines must be no longer than 76 characters.
// The final "quantum" is handled as follows:  The translation output shall
// always consist of 4 characters.  'x', below, means a translated character,
// and '=' means an equal sign.  0, 1 or 2 equal signs padding out a four byte
// translation quantum means decoding the four bytes would result in 3, 2 or 1
// unencoded bytes, respectively.
//
//  unencoded size    encoded data
//  --------------    ------------
//     1 byte       "xx=="
//     2 bytes      "xxx="
//     3 bytes      "xxxx"

#define CB_BASE64LINEMAX    64  // others use 64 -- could be up to 76

// Any other (invalid) input character value translates to 0x40 (64)

const BYTE abDecode[256] =
{
    /* 00: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* 10: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* 20: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 62, 64, 64, 64, 63,
    /* 30: */ 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 64, 64, 64, 64, 64, 64,
    /* 40: */ 64,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
    /* 50: */ 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 64, 64, 64, 64, 64,
    /* 60: */ 64, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
    /* 70: */ 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 64, 64, 64, 64, 64,
    /* 80: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* 90: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* a0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* b0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* c0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* d0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* e0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* f0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
};


const UCHAR abEncode[] =
    /*  0 thru 25: */ "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    /* 26 thru 51: */ "abcdefghijklmnopqrstuvwxyz"
    /* 52 thru 61: */ "0123456789"
    /* 62 and 63: */  "+/";


DWORD
Base64DecodeA(const char * pchIn, DWORD cchIn, BYTE * pbOut, DWORD * pcbOut)
{
	DWORD err = ERROR_SUCCESS;
   DWORD cchInDecode, cbOutDecode;
   CHAR const *pchInEnd;
   CHAR const *pchInT;
   BYTE *pbOutT;

   // Count the translatable characters, skipping whitespace & CR-LF chars.
   cchInDecode = 0;
   pchInEnd = &pchIn[cchIn];
   for (pchInT = pchIn; pchInT < pchInEnd; pchInT++)
   {
		if (sizeof(abDecode) < (unsigned) *pchInT || abDecode[*pchInT] > 63)
		{
			// skip all whitespace
			if (	*pchInT == ' ' 
				||	*pchInT == '\t' 
				||	*pchInT == '\r' 
				||	*pchInT == '\n'
				)
			{
				continue;
			}

			if (0 != cchInDecode)
			{
				if ((cchInDecode % 4) == 0)
				{
					break;          // ends on quantum boundary
			}

			// The length calculation may stop in the middle of the last
			// translation quantum, because the equal sign padding
			// characters are treated as invalid input.  If the last
			// translation quantum is not 4 bytes long, it must be 2 or 3
			// bytes long.

			if (*pchInT == '=' && (cchInDecode % 4) != 1)
			{
				break;              // normal termination
			}
		}
      err = ERROR_INVALID_DATA;
      goto error;
	}
   cchInDecode++;
   }
    ATLASSERT(pchInT <= pchInEnd);
    pchInEnd = pchInT;      // don't process any trailing stuff again

    // We know how many translatable characters are in the input buffer, so now
    // set the output buffer size to three bytes for every four (or fraction of
    // four) input bytes.

    cbOutDecode = ((cchInDecode + 3) / 4) * 3;

    pbOutT = pbOut;

    if (NULL == pbOut)
    {
    pbOutT += cbOutDecode;
    }
    else
    {
    // Decode one quantum at a time: 4 bytes ==> 3 bytes

    ATLASSERT(cbOutDecode <= *pcbOut);
    pchInT = pchIn;
    while (cchInDecode > 0)
    {
        DWORD i;
        BYTE ab4[4];

        memset(ab4, 0, sizeof(ab4));
        for (i = 0; i < min(sizeof(ab4)/sizeof(ab4[0]), cchInDecode); i++)
        {
        while (
            sizeof(abDecode) > (unsigned) *pchInT &&
            63 < abDecode[*pchInT])
        {
            pchInT++;
        }
        ATLASSERT(pchInT < pchInEnd);
        ab4[i] = (BYTE) *pchInT++;
        }

        // Translate 4 input characters into 6 bits each, and deposit the
        // resulting 24 bits into 3 output bytes by shifting as appropriate.

        // out[0] = in[0]:in[1] 6:2
        // out[1] = in[1]:in[2] 4:4
        // out[2] = in[2]:in[3] 2:6

        *pbOutT++ =
        (BYTE) ((abDecode[ab4[0]] << 2) | (abDecode[ab4[1]] >> 4));

        if (i > 2)
        {
        *pbOutT++ =
          (BYTE) ((abDecode[ab4[1]] << 4) | (abDecode[ab4[2]] >> 2));
        }
        if (i > 3)
        {
        *pbOutT++ = (BYTE) ((abDecode[ab4[2]] << 6) | abDecode[ab4[3]]);
        }
        cchInDecode -= i;
    }
    ATLASSERT((DWORD) (pbOutT - pbOut) <= cbOutDecode);
    }
    *pcbOut = (DWORD)(pbOutT - pbOut);
error:
    return(err);
}

// Base64EncodeA 
//
// RETURNS  0 (i.e. ERROR_SUCCESS) on success
//


DWORD
Base64EncodeA(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    OUT CHAR *pchOut,
    OUT DWORD *pcchOut)
{
    CHAR *pchOutT;
    DWORD cchOutEncode;

    // Allocate enough memory for full final translation quantum.
    cchOutEncode = ((cbIn + 2) / 3) * 4;

    // and enough for CR-LF pairs for every CB_BASE64LINEMAX character line.
    cchOutEncode +=
		2 * ((cchOutEncode + CB_BASE64LINEMAX - 1) / CB_BASE64LINEMAX);

    pchOutT = pchOut;
	if (NULL == pchOut)
   {
		pchOutT += cchOutEncode;
   }
   else
   {
		DWORD cCol;

      ATLASSERT(cchOutEncode <= *pcchOut);
      cCol = 0;
      while ((long) cbIn > 0) // signed comparison -- cbIn can wrap
      {
         BYTE ab3[3];

         if (cCol == CB_BASE64LINEMAX/4)
         {
            cCol = 0;
            *pchOutT++ = '\r';
            *pchOutT++ = '\n';
         }
         cCol++;
         memset(ab3, 0, sizeof(ab3));

         ab3[0] = *pbIn++;
         if (cbIn > 1)
         {
           ab3[1] = *pbIn++;
           if (cbIn > 2)
           {
               ab3[2] = *pbIn++;
           }
         }

         *pchOutT++ = abEncode[ab3[0] >> 2];
         *pchOutT++ = abEncode[((ab3[0] << 4) | (ab3[1] >> 4)) & 0x3f];
         *pchOutT++ = (cbIn > 1)?
            abEncode[((ab3[1] << 2) | (ab3[2] >> 6)) & 0x3f] : '=';
         *pchOutT++ = (cbIn > 2)? abEncode[ab3[2] & 0x3f] : '=';

         cbIn -= 3;
      }
      *pchOutT++ = '\r';
      *pchOutT++ = '\n';
      ATLASSERT((DWORD) (pchOutT - pchOut) <= cchOutEncode);
   }
   *pcchOut = (DWORD)(pchOutT - pchOut);
   return(ERROR_SUCCESS);
}

// Base64EncodeW 
//
// RETURNS  0 (i.e. ERROR_SUCCESS) on success
//

DWORD Base64EncodeW(
    BYTE const *pbIn,
    DWORD cbIn,
    WCHAR *wszOut,
    DWORD *pcchOut)

{

    DWORD   cchOut;
    char   *pch = NULL;
    DWORD   cch;
    DWORD   err;

    ATLASSERT(pcchOut != NULL);

    // only want to know how much to allocate
    // we know all base64 char map 1-1 with unicode
    if( wszOut == NULL ) {

        // get the number of characters
        *pcchOut = 0;
        err = Base64EncodeA(
                pbIn,
                cbIn,
                NULL,
                pcchOut);
    }

    // otherwise we have an output buffer
    else {

        // char count is the same be it ascii or unicode,
        cchOut = *pcchOut;
        cch = 0;
        err = ERROR_OUTOFMEMORY;
        if( (pch = (char *) malloc(cchOut)) != NULL  &&
        
            (err = Base64EncodeA(
                pbIn,
                cbIn,
                pch,
                &cchOut)) == ERROR_SUCCESS      ) {

            // should not fail!
            cch = MultiByteToWideChar(0, 
                            0, 
                            pch, 
                            cchOut, 
                            wszOut, 
                            *pcchOut);

            // check to make sure we did not fail                            
            ATLASSERT(*pcchOut == 0 || cch != 0);                            
        }
    }

    if(pch != NULL)
        free(pch);

    return(err);
}

// Base64DecodeW 
//
// RETURNS  0 (i.e. ERROR_SUCCESS) on success
//

DWORD Base64DecodeW(
    const WCHAR * wszIn,
    DWORD cch,
    BYTE *pbOut,
    DWORD *pcbOut)
{

    char *pch;
    DWORD err = ERROR_SUCCESS;
    
    if( (pch = (char *) malloc(cch)) == NULL ) 
	 {
        err = ERROR_OUTOFMEMORY;
    }
    else if( WideCharToMultiByte(0, 0, wszIn, cch, pch, cch, 
                        NULL, NULL) == 0 ) 
	 {
        err = ERROR_NO_DATA;
    }
    else if( pbOut == NULL ) 
	 {
        *pcbOut = 0;
        err = Base64DecodeA(pch, cch, NULL, pcbOut);
    }
    else 
	 {
        err = Base64DecodeA(pch, cch, pbOut, pcbOut);
    }
    if(pch != NULL)
        free(pch);
    return(err);
}

#if 0
// sanity tests...  Lets make sure that the encode and decode
//                  works...

BOOL test_Base64EncodeW()
{
    BYTE  pbIn[120];            // for the test we just use the random stack data
    DWORD cbIn = sizeof( pbIn );
    
    WCHAR *wszB64Out;
    DWORD pcchB64Out;

    DWORD  err;
    
    // BASE64 encode pkcs 10
    if( (err = Base64EncodeW(
                pbIn,
                cbIn,
                NULL,
                &pcchB64Out)) != ERROR_SUCCESS     ||
        (wszB64Out = (WCHAR *) _alloca(pcchB64Out * sizeof(WCHAR))) == NULL  ||
        (err = Base64EncodeW(
                pbIn,
                cbIn,
                wszB64Out,
                &pcchB64Out)) != ERROR_SUCCESS ) 
    {
        SetLastError(err);
        return FALSE;  //goto ErrorBase64Encode;
    }


    // well the encode worked lets test the decode
    //
    // pcchB64Out holds the B64 data length
    // wszB64Out  holds the actual data

     DWORD blob_cbData;     // we store in these variables what
     BYTE* blob_pbData;     //  we read in..

    // They should match the stuff stored in:
    //    BYTE  pbIn[120];
    //    DWORD cbIn = sizeof( pbIn );
    // This we be tested after the decode.

    // base64 decode
    if( (err = Base64DecodeW(
            wszB64Out,
            pcchB64Out,
            NULL,
            &blob_cbData)) != ERROR_SUCCESS                    ||
        (blob_pbData = (BYTE *) _alloca(blob_cbData)) == NULL      ||
        (err = Base64DecodeW(
            wszB64Out,
            pcchB64Out,
            blob_pbData,
            &blob_cbData)) != ERROR_SUCCESS ) 
    {
        
        SetLastError(err);
        return(FALSE);  //goto ErrorBase64Decode;
    }



    //do compare

    
    return( (blob_cbData==cbIn)
            &&  (memcmp(blob_pbData, pbIn,cbIn)==0) );
    

 }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certobj\iiscertobj.h ===
// IISCertObj.h : Declaration of the CIISCertObj

#ifndef __IISCERTOBJ_H_
#define __IISCERTOBJ_H_

#include "resource.h"       // main symbols

#ifdef FULL_OBJECT
class CCryptBlob
{
public:
	CCryptBlob()
	{
		m_blob.cbData = 0;
		m_blob.pbData = NULL;
	}
	virtual ~CCryptBlob()
	{
	}
	DWORD GetSize() {return m_blob.cbData;}
	BYTE * GetData() {return m_blob.pbData;}
	void Set(DWORD cb, BYTE * pb)
	{
		Destroy();
		m_blob.cbData = cb;
		m_blob.pbData = pb;
	}
	BOOL Resize(DWORD cb);
	operator CRYPT_DATA_BLOB *()
	{
		return &m_blob;
	}

protected:
	void Destroy()
	{
		if (m_blob.pbData != NULL)
			Free(m_blob.pbData);
	}
	virtual BYTE * Realloc(BYTE * pb, DWORD cb) = 0;
	virtual void Free(BYTE * pb) = 0;
	CRYPT_DATA_BLOB m_blob;
};

class CCryptBlobIMalloc : public CCryptBlob
{
public:
	virtual ~CCryptBlobIMalloc()
	{
		CCryptBlob::Destroy();
	}

protected:
	virtual BYTE * Realloc(BYTE * pb, DWORD cb)
	{
		return (BYTE *)CoTaskMemRealloc(pb, cb);
	}
	virtual void Free(BYTE * pb)
	{
		CoTaskMemFree(pb);
	}
};

class CCryptBlobLocal : public CCryptBlob
{
public:
	virtual ~CCryptBlobLocal()
	{
		CCryptBlob::Destroy();
	}

protected:
	virtual BYTE * Realloc(BYTE * pb, DWORD cb)
	{
		return (BYTE *)realloc(pb, cb);
	}
	virtual void Free(BYTE * pb)
	{
		free(pb);
	}
};
#endif
/////////////////////////////////////////////////////////////////////////////
// CIISCertObj
class ATL_NO_VTABLE CIISCertObj : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CIISCertObj, &CLSID_IISCertObj>,
	public IDispatchImpl<IIISCertObj, &IID_IIISCertObj, &LIBID_CERTOBJLib>
{
public:
#ifdef FULL_OBJECT
   CIISCertObj() :
      m_bInitDone(FALSE),
      m_pEnroll(NULL)
#else
   CIISCertObj()
#endif
	{
	}
   ~CIISCertObj()
   {
#ifdef FULL_OBJECT
      if (m_pEnroll != NULL)
         m_pEnroll->Release();
#endif
   }

DECLARE_REGISTRY_RESOURCEID(IDR_IISCERTOBJ)
DECLARE_NOT_AGGREGATABLE(CIISCertObj)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CIISCertObj)
	COM_INTERFACE_ENTRY(IIISCertObj)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IIISCertObj
public:
   STDMETHOD(Import)(BSTR FileName, BSTR InstanceName, BSTR Password);
   STDMETHOD(ImportFromBlob)(BSTR InstanceName, BSTR Password, BOOL bBase64Encoded, DWORD pcbSize, char * pBlobBinary);

   STDMETHOD(RemoveCert)(BSTR InstanceName, BOOL bPrivateKey);

   STDMETHOD(Export)(BSTR FileName, BSTR InstanceName, BSTR Password, BOOL bPrivateKey, BOOL bCertChain, BOOL bRemoveCert);
   STDMETHOD(ExportToBlob)(BSTR InstanceName, BSTR Password, BOOL bPrivateKey, BOOL bCertChain, BOOL bBase64Encoded, DWORD * pcbSize, char * pBlobBinary);

   STDMETHOD(Copy)(BSTR DestinationServerName, BSTR DestinationServerInstance, BSTR CertificatePassword, VARIANT DestinationServerUserName OPTIONAL, VARIANT DestinationServerPassword OPTIONAL);
   STDMETHOD(Move)(BSTR DestinationServerName, BSTR DestinationServerInstance, BSTR CertificatePassword, VARIANT DestinationServerUserName OPTIONAL, VARIANT DestinationServerPassword OPTIONAL);

   STDMETHOD(IsInstalled)(BSTR InstanceName, VARIANT_BOOL * retval);
   STDMETHOD(IsInstalledRemote)(BSTR InstanceName, VARIANT_BOOL * retval);

#ifdef FULL_OBJECT
	STDMETHOD(CreateRequest)(BSTR FileName);
	STDMETHOD(ProcessResponse)(BSTR FileName);
	STDMETHOD(RequestCert)(BSTR CertAuthority);
	STDMETHOD(LoadSettings)(BSTR ApplicationKey, BSTR SettingsKey);
	STDMETHOD(SaveSettings)(BSTR ApplicationKey, BSTR SettingsKey);
	STDMETHOD(put_SGC_Cert)(/*[in]*/ BOOL newVal);
	STDMETHOD(put_KeySize)(/*[in]*/ int newVal);
	STDMETHOD(put_CertTemplate)(/*[in]*/ BSTR newVal);
	STDMETHOD(put_CertAuthority)(/*[in]*/ BSTR newVal);
	STDMETHOD(put_Country)(/*[in]*/ BSTR newVal);
	STDMETHOD(put_State)(/*[in]*/ BSTR newVal);
	STDMETHOD(put_Locality)(/*[in]*/ BSTR newVal);
	STDMETHOD(put_OrganizationUnit)(/*[in]*/ BSTR newVal);
	STDMETHOD(put_Organization)(/*[in]*/ BSTR newVal);
	STDMETHOD(put_FriendlyName)(/*[in]*/ BSTR newVal);
	STDMETHOD(put_CommonName)(/*[in]*/ BSTR newVal);
	STDMETHOD(put_Password)(/*[in]*/ BSTR newVal);
#endif
    STDMETHOD(put_InstanceName)(/*[in]*/ BSTR newVal);
	STDMETHOD(put_UserName)(/*[in]*/ BSTR newVal);
	STDMETHOD(put_UserPassword)(/*[in]*/ BSTR newVal);
	STDMETHOD(put_ServerName)(/*[in]*/ BSTR newVal);
private:
   IIISCertObj * GetObject(HRESULT * phr);
   IIISCertObj * GetObject(HRESULT * phr, CString csServerName,CString csUserName OPTIONAL,CString csUserPassword OPTIONAL);


#ifdef FULL_OBJECT
   STDMETHOD(Init)();
   STDMETHOD(CreateDNString)(CString& str);
   IEnroll * GetEnroll();
#endif
   CERT_CONTEXT * GetInstalledCert(HRESULT * phResult);
   HRESULT UninstallCert();
   HRESULT ExportToBlobProxy(IIISCertObj * pObj,BSTR InstanceName,BSTR Password,BOOL bPrivateKey,BOOL bCertChain,BOOL * bBase64Encoded,DWORD * pcbSize,char ** pBlobBinary);
   HRESULT ImportFromBlobProxy(IIISCertObj * pObj,BSTR InstanceName,BSTR Password,DWORD count,BYTE *pData);
   HRESULT CopyOrMove(BOOL bRemoveFromCertAfterCopy,BSTR bstrDestinationServerName,BSTR bstrDestinationServerInstance,BSTR bstrCertificatePassword,VARIANT varDestinationServerUserName, VARIANT varDestinationServerPassword);

private:
   CComPtr<IIISCertObj> m_pObj;
   CString m_InstanceName;
   CString m_ServerName;
   CString m_UserName;
   CString m_UserPassword;
#ifdef FULL_OBJECT
   CString m_Password;
   CString m_CommonName;
   CString m_FriendlyName;
   CString m_Organization;
   CString m_OrganizationUnit;
   CString m_Locality;
   CString m_State;
   CString m_Country;
   CString m_CertAuthority;
   CString m_CertTemplate;
   int m_KeySize;
   BOOL m_SGC_Cert;

   BOOL m_bInitDone;
   IEnroll * m_pEnroll;
#endif
};

#endif //__IISCERTOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certobj\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by CertObj.rc
//
#define IDS_PROJNAME                    100
#define IDR_IISCERTOBJ                  101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certobj\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__89EF842D_58E5_4014_9FF4_3C845E2C78F3__INCLUDED_)
#define AFX_DLLDATAX_H__89EF842D_58E5_4014_9FF4_3C845E2C78F3__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__89EF842D_58E5_4014_9FF4_3C845E2C78F3__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certwiz\base64.h ===
//
// base64.h
//
#ifndef _BASE64_H
#define _BASE64_H

DWORD Base64DecodeA(const char * pchIn, DWORD cchIn, BYTE * pbOut, DWORD * pcbOut);
DWORD Base64EncodeA(const BYTE * pbIn, DWORD cbIn, char * pchOut, DWORD * pcchOut);
DWORD Base64EncodeW(BYTE const *pbIn, DWORD cbIn, WCHAR *wszOut, DWORD *pcchOut);
DWORD Base64DecodeW(const WCHAR * wszIn, DWORD cch, BYTE *pbOut, DWORD *pcbOut);

#endif	//_BASE64_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certwiz\bookendpage.cpp ===
//
// BookEndPage.cpp
//
#include "stdafx.h"
#include "BookEndPage.h"

IMPLEMENT_DYNCREATE(CIISWizardBookEnd2, CIISWizardPage)

CIISWizardBookEnd2::CIISWizardBookEnd2(
		HRESULT * phResult,
		UINT nIDWelcomeTxtSuccess,
		UINT nIDWelcomeTxtFailure,
		UINT nIDCaption,
		UINT * pnIDBodyTxtSuccess,
		CString * pBodyTxtSuccess,
		UINT * pnIDBodyTxtFailure,
		CString * pBodyTxtFailure,
		UINT nIDClickTxt,
		UINT nIDTemplate
		)
	: CIISWizardPage(nIDTemplate ? nIDTemplate : CIISWizardBookEnd2::IDD, nIDCaption),
	m_phResult(phResult),
	m_nIDWelcomeTxtSuccess(nIDWelcomeTxtSuccess),
	m_nIDWelcomeTxtFailure(nIDWelcomeTxtFailure),
	m_pnIDBodyTxtSuccess(pnIDBodyTxtSuccess),
	m_pBodyTxtSuccess(pBodyTxtSuccess),
	m_pnIDBodyTxtFailure(pnIDBodyTxtFailure),
	m_pBodyTxtFailure(pBodyTxtFailure),
	m_nIDClickTxt(nIDClickTxt),
	m_bTemplateAvailable(nIDTemplate != 0)
{
    ASSERT(m_phResult != NULL); // Must know success/failure
}

CIISWizardBookEnd2::CIISWizardBookEnd2(
		UINT nIDTemplate,
		UINT nIDCaption,
		UINT * pnIDBodyTxt,
		CString * pBodyTxt,
		UINT nIDWelcomeTxt,        
		UINT nIDClickTxt
		)
	: CIISWizardPage(nIDTemplate ? nIDTemplate : CIISWizardBookEnd2::IDD, nIDCaption),
   m_phResult(NULL),
	m_nIDWelcomeTxtSuccess(nIDWelcomeTxt),
	m_nIDWelcomeTxtFailure(USE_DEFAULT_CAPTION),
	m_pnIDBodyTxtSuccess(pnIDBodyTxt),
	m_pBodyTxtSuccess(pBodyTxt),
	m_pnIDBodyTxtFailure(NULL),
	m_pBodyTxtFailure(NULL),
	m_nIDClickTxt(nIDClickTxt),
	m_bTemplateAvailable(nIDTemplate != 0)
{
}

BOOL
CIISWizardBookEnd2::OnSetActive()
{
   if (!m_strWelcome.IsEmpty())
		SetDlgItemText(IDC_STATIC_WZ_WELCOME, m_strWelcome);
	if (!m_strBody.IsEmpty())
		SetDlgItemText(IDC_STATIC_WZ_BODY, m_strBody);
	if (!m_strClick.IsEmpty())
		SetDlgItemText(IDC_STATIC_WZ_CLICK, m_strClick);
	
	SetWizardButtons(IsWelcomePage() ? PSWIZB_NEXT : PSWIZB_FINISH);
	
	return CIISWizardPage::OnSetActive();
}

//
// Message Map
//
BEGIN_MESSAGE_MAP(CIISWizardBookEnd2, CIISWizardPage)
    //{{AFX_MSG_MAP(CIISWizardBookEnd)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BOOL 
CIISWizardBookEnd2::OnInitDialog() 
{
	CIISWizardPage::OnInitDialog();

   //
   // Make the "Click 'foo' to continue" message bold as well.
   //
//   ApplyFontToControls(this, GetBoldFont(), IDC_STATIC_WZ_CLICK, IDC_STATIC_WZ_CLICK);

	if (m_nIDClickTxt)
	{
		VERIFY(m_strClick.LoadString(m_nIDClickTxt));
	}
   if (IsWelcomePage())
   {
		if (m_nIDWelcomeTxtSuccess)
		{
			VERIFY(m_strWelcome.LoadString(m_nIDWelcomeTxtSuccess));
		}
		if (m_pBodyTxtSuccess != NULL)
		{
			m_strBody = *m_pBodyTxtSuccess;
		}
		else if (m_pnIDBodyTxtSuccess != NULL)
		{
			VERIFY(m_strBody.LoadString(*m_pnIDBodyTxtSuccess));
		}
   }
   else
   {
		CError err(*m_phResult);
		if (err.Succeeded())		
		{
			if (m_nIDWelcomeTxtSuccess)
			{
				VERIFY(m_strWelcome.LoadString(m_nIDWelcomeTxtSuccess));
			}
			if (m_pBodyTxtSuccess != NULL && !m_pBodyTxtSuccess->IsEmpty())
			{
				m_strBody = *m_pBodyTxtSuccess;
			}
			else if (m_pnIDBodyTxtSuccess != NULL && *m_pnIDBodyTxtSuccess != USE_DEFAULT_CAPTION)
			{
				VERIFY(m_strBody.LoadString(*m_pnIDBodyTxtSuccess));
			}
		}
		else
		{
			if (m_nIDWelcomeTxtFailure)
			{
				VERIFY(m_strWelcome.LoadString(m_nIDWelcomeTxtFailure));
			}
			if (m_pBodyTxtFailure != NULL && !m_pBodyTxtFailure->IsEmpty())
			{
				m_strBody = *m_pBodyTxtFailure;
			}
			else if (m_pnIDBodyTxtFailure != NULL && *m_pnIDBodyTxtFailure != USE_DEFAULT_CAPTION)
			{
				VERIFY(m_strBody.LoadString(*m_pnIDBodyTxtFailure));
			}
			else
			{
				// Build body text string and expand error messages
				m_strBody = _T("%h");
				err.TextFromHRESULTExpand(m_strBody);
			}
		}
   }

	SetWizardButtons(IsWelcomePage() ? PSWIZB_NEXT : PSWIZB_FINISH);
	// We don't have documented way to disable Cancel button
   if (!IsWelcomePage())
		GetParent()->GetDlgItem(IDCANCEL)->EnableWindow(FALSE);

   return TRUE;  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certobj\certobj.cpp ===
// CertObj.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file 
//      dlldatax.c to the project.  Make sure precompiled headers 
//      are turned off for this file, and add _MERGE_PROXYSTUB to the 
//      defines for the project.  
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also 
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for CertObj.idl by adding the following 
//      files to the Outputs.
//          CertObj_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL, 
//      run nmake -f CertObjps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "CertObj.h"
#include "dlldatax.h"

#include "CertObj_i.c"
#include "common.h"
#include "IISCertObj.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_IISCertObj, CIISCertObj)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_CERTOBJLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certobj\iiscertobj.cpp ===
// IISCertObj.cpp : Implementation of CIISCertObj
#include "stdafx.h"
#include "CertObj.h"
#include "common.h"
#include "IISCertObj.h"
//#ifdef FULL_OBJECT
   #include "base64.h"
//#endif
#include <wincrypt.h>
#include <cryptui.h>

HRESULT ShutdownSSL(CString& server_name);
HCERTSTORE OpenMyStore(IEnroll * pEnroll, HRESULT * phResult);
BOOL InstallHashToMetabase(CRYPT_HASH_BLOB * pHash,
					  BSTR machine_name, 
					  HRESULT * phResult);
BOOL
TrustIsCertificateSelfSigned(PCCERT_CONTEXT pContext,
                             DWORD dwEncoding, 
                             DWORD dwFlags);
BOOL 
AddChainToStore(
    HCERTSTORE hCertStore,
    PCCERT_CONTEXT	pCertContext,
    DWORD	cStores,
    HCERTSTORE * rghStores,
    BOOL fDontAddRootCert,
    CERT_TRUST_STATUS	* pChainTrustStatus);

/////////////////////////////////////////////////////////////////////////////
// CIISCertObj
STDMETHODIMP CIISCertObj::put_ServerName(BSTR newVal)
{
    m_ServerName = newVal;
    return S_OK;
}

STDMETHODIMP CIISCertObj::put_UserName(BSTR newVal)
{
    m_UserName = newVal;
    return S_OK;
}

STDMETHODIMP CIISCertObj::put_UserPassword(BSTR newVal)
{
    m_UserPassword = newVal;
	return S_OK;
}

STDMETHODIMP CIISCertObj::put_InstanceName(BSTR newVal)
{
    m_InstanceName = newVal;
	return S_OK;
}

#ifdef FULL_OBJECT
STDMETHODIMP CIISCertObj::put_Password(BSTR newVal)
{
    m_Password = newVal;
    return S_OK;
}

STDMETHODIMP CIISCertObj::put_CommonName(BSTR newVal)
{
    m_CommonName = newVal;
    return S_OK;
}

STDMETHODIMP CIISCertObj::put_FriendlyName(BSTR newVal)
{
    m_FriendlyName = newVal;
    return S_OK;
}

STDMETHODIMP CIISCertObj::put_Organization(BSTR newVal)
{
    m_Organization = newVal;
    return S_OK;
}

STDMETHODIMP CIISCertObj::put_OrganizationUnit(BSTR newVal)
{
    m_OrganizationUnit = newVal;
    return S_OK;
}

STDMETHODIMP CIISCertObj::put_Locality(BSTR newVal)
{
    m_Locality = newVal;
    return S_OK;
}

STDMETHODIMP CIISCertObj::put_State(BSTR newVal)
{
    m_State = newVal;
    return S_OK;
}

STDMETHODIMP CIISCertObj::put_Country(BSTR newVal)
{
    m_Country = newVal;
    return S_OK;
}

STDMETHODIMP CIISCertObj::put_CertAuthority(BSTR newVal)
{
    m_CertAuthority = newVal;
    return S_OK;
}

STDMETHODIMP CIISCertObj::put_CertTemplate(BSTR newVal)
{
    m_CertTemplate = newVal;
    return S_OK;
}

STDMETHODIMP CIISCertObj::put_KeySize(int newVal)
{
    m_KeySize = newVal;
    return S_OK;
}

STDMETHODIMP CIISCertObj::put_SGC_Cert(BOOL newVal)
{
    m_SGC_Cert = newVal;
    return S_OK;
}

STDMETHODIMP CIISCertObj::LoadSettings(BSTR ApplicationKey, BSTR SettingsKey)
{
    return S_OK;
}

STDMETHODIMP CIISCertObj::SaveSettings(BSTR ApplicationKey, BSTR SettingsKey)
{
    return S_OK;
}

STDMETHODIMP CIISCertObj::CreateRequest(BSTR FileName)
{
    CString dn;
    HRESULT hr;
    TCHAR usage[] = _T(szOID_PKIX_KP_SERVER_AUTH);
    CCryptBlobIMalloc req_blob;

    if (FAILED(hr = CreateDNString(dn)))
        return hr;
    ATLASSERT(dn.length() > 0);
    if (FAILED(hr = GetEnroll()->createPKCS10WStr(dn, (LPTSTR)usage, req_blob)))
	{
        return hr;
	}
	// BASE64 encode pkcs 10
	DWORD cch; 
	char * psz;
	if (	ERROR_SUCCESS != Base64EncodeA(req_blob.GetData(), req_blob.GetSize(), NULL, &cch)
		||	NULL == (psz = (char *)_alloca(cch+1))
		||	ERROR_SUCCESS != Base64EncodeA(req_blob.GetData(), req_blob.GetSize(), psz, &cch)
		) 
	{
      ATLASSERT(FALSE);
		return E_FAIL;
	}

	return S_OK;
}

STDMETHODIMP CIISCertObj::RequestCert(BSTR CertAuthority)
{
	// TODO: Add your implementation code here

	return S_OK;
}

STDMETHODIMP CIISCertObj::ProcessResponse(BSTR FileName)
{
	// TODO: Add your implementation code here

	return S_OK;
}
#endif

STDMETHODIMP CIISCertObj::IsInstalled(
   BSTR InstanceName, 
   VARIANT_BOOL * retval)
{
    HRESULT hr = S_OK;

    // Check mandatory properties
    if (  InstanceName == NULL 
        || *InstanceName == 0
        || retval == NULL
        )
        return ERROR_INVALID_PARAMETER;

    m_InstanceName = InstanceName;

    if (!m_ServerName.IsEmpty())
    {
        //ASSERT(GetObject(&hr) != NULL);
        IIISCertObj * pObj;

        if (NULL != (pObj = GetObject(&hr)))
        {
            hr = pObj->put_InstanceName(InstanceName);
            hr = pObj->IsInstalledRemote(InstanceName, retval);
        }
    }
    else
    {
        hr = IsInstalledRemote(InstanceName, retval);
    }
    return hr;
}

STDMETHODIMP 
CIISCertObj::IsInstalledRemote(
   BSTR InstanceName, 
   VARIANT_BOOL * retval)
{
    HRESULT hr = S_OK;
    CERT_CONTEXT * pCertContext = NULL;

    // Check mandatory properties
    if (InstanceName == NULL || *InstanceName == 0 || retval == NULL)
        return ERROR_INVALID_PARAMETER;

    pCertContext = GetInstalledCert(&hr);
    if (FAILED(hr) || NULL == pCertContext)
    {
        hr = S_OK;
        *retval = FALSE;
    }
    else
    {
        hr = S_OK;
        *retval = TRUE;
        CertFreeCertificateContext(pCertContext);
    }
    return hr;
}

STDMETHODIMP 
CIISCertObj::RemoveCert(BSTR InstanceName, BOOL bPrivateKey)
{
   HRESULT hr = E_FAIL;
   PCCERT_CONTEXT pCertContext = NULL;

   DWORD	cbKpi = 0;
   PCRYPT_KEY_PROV_INFO pKpi = NULL ;
   HCRYPTPROV hCryptProv = NULL;

   do
   {
      // get the certificate from the server
      pCertContext = GetInstalledCert(&hr);
      if (NULL == pCertContext)
      {
         break;
      }

      if (!CertGetCertificateContextProperty(pCertContext, CERT_KEY_PROV_INFO_PROP_ID, NULL, &cbKpi)) 
      {
         hr = HRESULT_FROM_WIN32(GetLastError());
         break;
      }

      pKpi = ( PCRYPT_KEY_PROV_INFO ) malloc( cbKpi );
      if ( NULL != pKpi )	
      {
         if (!CertGetCertificateContextProperty(pCertContext, CERT_KEY_PROV_INFO_PROP_ID, (void *)pKpi, &cbKpi)) 
         {
            hr = HRESULT_FROM_WIN32(GetLastError());
            break;
         }

         // Delete the key container
         if (!CryptAcquireContext(
            &hCryptProv,
            pKpi->pwszContainerName,
            pKpi->pwszProvName,
            pKpi->dwProvType,
            pKpi->dwFlags | CRYPT_DELETEKEYSET | CRYPT_MACHINE_KEYSET))
         {
            hr = HRESULT_FROM_WIN32(GetLastError());
            break;
         }

         if (NULL != pKpi){free(pKpi);}

         if (!CertSetCertificateContextProperty(pCertContext, CERT_KEY_PROV_INFO_PROP_ID, 0, NULL))
         {
            hr = HRESULT_FROM_WIN32(GetLastError());
            break;
         }

      }

      //    uninstall the certificate from the site, reset SSL flag
      //    if we are exporting the private key, remove the cert from the storage
      //    and delete private key
      UninstallCert();

      // remove ssl key from metabase
      CString str = InstanceName;
      ShutdownSSL(str);

      // delete the private key
      if (bPrivateKey)
      {
         PCCERT_CONTEXT pcDup = NULL ;
         pcDup = CertDuplicateCertificateContext(pCertContext);
         if (pcDup)
         {
            if (!CertDeleteCertificateFromStore(pcDup))
            {
               hr = HRESULT_FROM_WIN32(GetLastError());
               break;
            }
         }
         else
         {
            hr = HRESULT_FROM_WIN32(GetLastError());
         }
      }

      hr = ERROR_SUCCESS;

   } while (FALSE);

   if (pCertContext) {CertFreeCertificateContext(pCertContext);}
   return hr;
}

STDMETHODIMP CIISCertObj::Export(
    BSTR FileName, 
    BSTR InstanceName,
    BSTR Password,
    BOOL bPrivateKey,
    BOOL bCertChain,
    BOOL bRemoveCert)
{
    HRESULT hr = S_OK;
    DWORD  cbEncodedSize = 0;
    char * pszEncodedString = NULL;
    BOOL   bBase64Encoded = TRUE;
    DWORD  blob_cbData;
    BYTE * blob_pbData = NULL;
    BOOL   blob_freeme = FALSE;

    // Check mandatory properties
    if (  FileName == NULL || *FileName == 0
        || InstanceName == NULL || *InstanceName == 0
        || Password == NULL || *Password == 0
    )
    {
        return ERROR_INVALID_PARAMETER;
    }

    m_InstanceName = InstanceName;

    IIISCertObj * pObj = GetObject(&hr);
    if (FAILED(hr))
    {
        goto Export_Exit;
    }

    // Call function go get data from the remote/local iis store
    // and return it back as a blob.  the blob could be returned back as Base64 encoded
    // so check that flag
    hr = ExportToBlobProxy(pObj, InstanceName, Password, bPrivateKey, bCertChain, &bBase64Encoded, &cbEncodedSize, &pszEncodedString);
    if (FAILED(hr))
    {
        goto Export_Exit;
    }

    // check if things are kool
    if (bRemoveCert)
    {
        hr = pObj->RemoveCert(InstanceName, bPrivateKey);
        if (FAILED(hr))
        {
            goto Export_Exit;
        }
    }

    if (SUCCEEDED(hr))
    {
        if (bBase64Encoded)
        {
            int err;

            // The data we got back was Base64 encoded to remove nulls.
            // we need to decode it back to it's original format.
            if( (err = Base64DecodeA(pszEncodedString,cbEncodedSize,NULL,&blob_cbData)) != ERROR_SUCCESS                    ||
                (blob_pbData = (BYTE *) malloc(blob_cbData)) == NULL      ||
                (err = Base64DecodeA(pszEncodedString,cbEncodedSize,blob_pbData,&blob_cbData)) != ERROR_SUCCESS ) 
            {
                SetLastError(err);
                hr = HRESULT_FROM_WIN32(err);
                return hr;
            }
            blob_freeme = TRUE;
        }
        else
        {
            blob_cbData = cbEncodedSize;
            blob_pbData = (BYTE*) pszEncodedString;
        }

        HANDLE hFile = CreateFile(FileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if (INVALID_HANDLE_VALUE == hFile)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            return hr;
        }

        DWORD written = 0;
        if (!WriteFile(hFile, blob_pbData, blob_cbData, &written, NULL))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
        else
        {
            hr = S_OK;
        }
        CloseHandle(hFile);

        // Erase the memory that the private key used to be in!!!
        ZeroMemory(pszEncodedString, sizeof(cbEncodedSize));
        if (bBase64Encoded)
        {
            ZeroMemory(blob_pbData, sizeof(blob_cbData));
        }
    }

Export_Exit:
    if (pObj != NULL)
    {
        if (pObj != this)
        {
            pObj->Release();pObj=NULL;m_pObj = NULL;
        }
    }

    if (blob_freeme){if (blob_pbData != NULL){free(blob_pbData);blob_pbData=NULL;}}
    if (pszEncodedString != NULL){CoTaskMemFree(pszEncodedString);pszEncodedString=NULL;}
    return hr;
}

//
// Proxy to the real call ExportToBlob()
// this function figures out how much space to allocate, and then calls ExportToBlob().
//
// if succeeded and they get the blob back,
// and the caller must call CoTaskMemFree()
//
HRESULT 
CIISCertObj::ExportToBlobProxy(
    IIISCertObj * pObj,
    BSTR InstanceName, 
    BSTR Password, 
    BOOL bPrivateKey, 
    BOOL bCertChain, 
    BOOL *bBase64Encoded, 
    DWORD * pcbSize, 
    char ** pBlobBinary)
{
    HRESULT hr = E_FAIL;
    DWORD  cbEncodedSize = 0;
    char * pszEncodedString = NULL;
    * pBlobBinary = _T('\0');

    // Guestimate how much space we'll need...
    cbEncodedSize = 10;
    pszEncodedString = (char *)::CoTaskMemAlloc(cbEncodedSize);
    if (pszEncodedString == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto ExportToBlobProxy_Exit;
    }
    ZeroMemory(pszEncodedString, sizeof(cbEncodedSize));

    // if its the local machine, then don't need to encode it since
    // it's getting passed in the same memory...
    // but if its on the remote machine, then we need to encode it
    // since this stuff has nulls in it.
    *bBase64Encoded = TRUE;
    if (pObj == this){*bBase64Encoded = FALSE;}

    // call the remote function that will run on the remote/local machine
    // and grab it's certificate from iis and send it back to us
    hr = pObj->ExportToBlob(InstanceName, Password, bPrivateKey, bCertChain, *bBase64Encoded, &cbEncodedSize, (char *) pszEncodedString);
    if (ERROR_INSUFFICIENT_BUFFER == hr)
    {
        // free what we previously asked for and allocate more.
        ::CoTaskMemFree(pszEncodedString);
        pszEncodedString = (char *)::CoTaskMemAlloc(cbEncodedSize);
        if (pszEncodedString == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto ExportToBlobProxy_Exit;
        }
        // i have no idea why it doesn't work it this line is here!
        //ZeroMemory(pszEncodedString, sizeof(cbEncodedSize));
        hr = pObj->ExportToBlob(InstanceName, Password, bPrivateKey, bCertChain, *bBase64Encoded, &cbEncodedSize, (char *) pszEncodedString);
        if (FAILED(hr))
        {
            ::CoTaskMemFree(pszEncodedString);
            goto ExportToBlobProxy_Exit;
        }
        // otherwise hey, we've got our data!
        // copy it back
        *pcbSize = cbEncodedSize;
        *pBlobBinary = pszEncodedString;
          
        hr = S_OK;
    }

ExportToBlobProxy_Exit:
    return hr;
}

STDMETHODIMP 
CIISCertObj::ExportToBlob(
   BSTR InstanceName,
   BSTR Password,
   BOOL bPrivateKey,
   BOOL bCertChain,
   BOOL bBase64Encoded,
   DWORD *cbBufferSize,
   char *pbBuffer
   )
{
   HRESULT hr = E_FAIL;
   PCCERT_CONTEXT pCertContext = NULL;
   BOOL bStatus = FALSE;
   HCERTSTORE hStore = NULL;
   DWORD dwOpenFlags = CERT_STORE_READONLY_FLAG | CERT_STORE_ENUM_ARCHIVED_FLAG;
   CRYPT_DATA_BLOB DataBlob;
   ZeroMemory(&DataBlob, sizeof(CRYPT_DATA_BLOB));

   char *pszB64Out = NULL;
   DWORD pcchB64Out = 0;
   DWORD  err;

   //
   // get the certificate from the server
   //
   pCertContext = GetInstalledCert(&hr);
   if (NULL == pCertContext)
   {
      *cbBufferSize = 0;
      pbBuffer = NULL;
      goto ExportToBlob_Exit;
   }

   //
   // Export cert
   //
   // Open a temporary store to stick the cert in.
   hStore = CertOpenStore(CERT_STORE_PROV_MEMORY,X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,0,dwOpenFlags,NULL);
   if(NULL == hStore)
   {
      *cbBufferSize = 0;
      pbBuffer = NULL;
      ATLTRACE(_T("PFXExportCert:CertOpenStore()  failed Error: %d\n"), GetLastError());
      hr = HRESULT_FROM_WIN32(GetLastError());
      goto ExportToBlob_Exit;
   }

   //
   // get all the certs in the chain if we need to
   //
   if (bCertChain)
   {
      AddChainToStore(hStore, pCertContext, 0, 0, FALSE, NULL);
   }

   if(!CertAddCertificateContextToStore(hStore,pCertContext,CERT_STORE_ADD_REPLACE_EXISTING,NULL))
   {
      *cbBufferSize = 0;
      pbBuffer = NULL;
      ATLTRACE(_T("PFXExportCert:CertAddCertificateContextToStore() failed Error: %d\n"), GetLastError());
      hr = HRESULT_FROM_WIN32(GetLastError());
      goto ExportToBlob_Exit;
   }

   // free cert context since we no longer need to hold it
   if (pCertContext) 
   {
      CertFreeCertificateContext(pCertContext);pCertContext=NULL;
   }

   DataBlob.cbData = 0;
   DataBlob.pbData = NULL;
   if (!PFXExportCertStoreEx(hStore,&DataBlob,Password,NULL,bPrivateKey ? EXPORT_PRIVATE_KEYS : 0))
   {
      ATLTRACE(_T("PFXExportCert:1st PFXExportCertStoreEx() failed\n"));
      hr = HRESULT_FROM_WIN32(GetLastError());
      goto ExportToBlob_Exit;
   }
   if(DataBlob.cbData <= 0)
   {
      hr = HRESULT_FROM_WIN32(GetLastError());
      goto ExportToBlob_Exit;
   }

   //
   // check if the callers space is big enough...
   //
   if (bBase64Encoded)
   {
      pcchB64Out = 0;
      // get the size if we had encoded it.
      err = Base64EncodeA(DataBlob.pbData,DataBlob.cbData,NULL,&pcchB64Out);
      if (err != ERROR_SUCCESS)
      {
         hr = E_FAIL;
         goto ExportToBlob_Exit;
      }
      pcchB64Out = pcchB64Out * sizeof(char);

      if (*cbBufferSize < pcchB64Out)
      {
         *cbBufferSize = pcchB64Out;
         hr = ERROR_INSUFFICIENT_BUFFER;
         goto ExportToBlob_Exit;
      }
   }
   else
   {
      if (*cbBufferSize < DataBlob.cbData)
      {
         *cbBufferSize = DataBlob.cbData;
         hr = ERROR_INSUFFICIENT_BUFFER;
         goto ExportToBlob_Exit;
      }
   }

   // nope looks like they want us to fill in the data.

   if(NULL == (DataBlob.pbData = (PBYTE) ::CoTaskMemAlloc(DataBlob.cbData)))
   {
      hr = E_OUTOFMEMORY;
      goto ExportToBlob_Exit;
   }

   //
   // at this point they have allocated enough memory
   // let's go and get the cert and put it into DataBlob
   //
   if(!PFXExportCertStoreEx(hStore,&DataBlob,Password,NULL,bPrivateKey ? EXPORT_PRIVATE_KEYS : 0))
   {
      if (DataBlob.pbData){free(DataBlob.pbData);DataBlob.pbData = NULL;}
      ATLTRACE(_T("PFXExportCert:2nd PFXExportCertStoreEx() failed Error: %d\n"),GetLastError());
      hr = HRESULT_FROM_WIN32(GetLastError());
      goto ExportToBlob_Exit;
   }

   if (bBase64Encoded)
   {
      // Encode it so that it can be passed back as a string (there are no Nulls in it)
      err = Base64EncodeA(DataBlob.pbData,DataBlob.cbData,NULL,&pcchB64Out);
      if (err != ERROR_SUCCESS)
      {
         hr = E_FAIL;
         goto ExportToBlob_Exit;
      }

      // allocate some space and then try it.
      pcchB64Out = pcchB64Out * sizeof(char);
      pszB64Out = (char *) ::CoTaskMemAlloc(pcchB64Out);
      if (NULL == pszB64Out)
      {
         hr = HRESULT_FROM_WIN32(E_OUTOFMEMORY);
         goto ExportToBlob_Exit;
      }

      err = Base64EncodeA(DataBlob.pbData,DataBlob.cbData,pszB64Out,&pcchB64Out);
      if (err != ERROR_SUCCESS)
      {
         hr = E_FAIL;
         goto ExportToBlob_Exit;
      }

      // copy the new memory to pass back
      *cbBufferSize = pcchB64Out;
      memcpy(pbBuffer,pszB64Out,pcchB64Out);
   }
   else
   {
      // no encoding... this doesn't work right now for the remote case...
      // since there are nulls in there..

      // copy the new memory to pass back
      *cbBufferSize = DataBlob.cbData;
      memcpy(pbBuffer,DataBlob.pbData,DataBlob.cbData);
   }

   hr = ERROR_SUCCESS;

ExportToBlob_Exit:
   if (NULL != pszB64Out){CoTaskMemFree(pszB64Out);pszB64Out = NULL;}
   if (NULL != DataBlob.pbData){::CoTaskMemFree(DataBlob.pbData);DataBlob.pbData = NULL;}
   if (NULL != hStore){CertCloseStore(hStore, 0);hStore=NULL;}
   if (NULL != pCertContext) {CertFreeCertificateContext(pCertContext);pCertContext=NULL;}
   return hr;
}

STDMETHODIMP CIISCertObj::Import(
   BSTR FileName, 
   BSTR InstanceName, 
   BSTR Password)
{
    HRESULT hr = S_OK;
    BYTE * pbData = NULL;
    DWORD actual = 0, cbData = 0;

    HANDLE hFile = CreateFile(FileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        hFile = NULL;
        goto Import_Exit;
    }

    if (-1 == (cbData = ::GetFileSize(hFile, NULL)))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Import_Exit;
    }

    if (NULL == (pbData = (BYTE *)::CoTaskMemAlloc(cbData)))
    {
        hr = E_OUTOFMEMORY;
        goto Import_Exit;
    }
    if (ReadFile(hFile, pbData, cbData, &actual, NULL))
    {
        IIISCertObj * pObj = GetObject(&hr);
        if (SUCCEEDED(hr))
        {
            hr = ImportFromBlobProxy(pObj, InstanceName, Password, actual, pbData);
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Import_Exit;
    }

Import_Exit:
    if (pbData != NULL){::CoTaskMemFree(pbData);}
    if (hFile != NULL){CloseHandle(hFile);}
    return hr;

/*
#if 0
   DWORD flags = CRYPTUI_WIZ_NO_UI|CRYPTUI_WIZ_IMPORT_ALLOW_CERT|CRYPTUI_WIZ_IMPORT_TO_LOCALMACHINE;
   CRYPTUI_WIZ_IMPORT_SRC_INFO ii;
   HRESULT hr = S_OK;

   // Check mandatory properties
   if (  FileName == NULL || *FileName == 0
      || InstanceName == NULL || *InstanceName == 0
      || Password == NULL || *Password == 0
      )
      return ERROR_INVALID_PARAMETER;

   // Check metabase properties
   CComAuthInfo auth;
   CString key_path = SZ_MBN_SEP_STR SZ_MBN_MACHINE SZ_MBN_SEP_STR; // SZ_MBN_WEB SZ_MBN_SEP_STR;
   key_path += InstanceName;
	CMetaKey key(&auth, key_path, METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE);
	if (!key.Succeeded())
	{
      return key.QueryResult();
   }

   HCERTSTORE hStore = CertOpenStore(CERT_STORE_PROV_SYSTEM,
      PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
      NULL,
      CERT_SYSTEM_STORE_LOCAL_MACHINE,
      L"MY"
      );
   HCERTSTORE hTempStore = ::CertOpenStore(
      CERT_STORE_PROV_MEMORY, 0, NULL, CERT_STORE_SET_LOCALIZED_NAME_FLAG, NULL);

#if 0
   DWORD dwContentType = 0, dwFormatType = 0, dwMsgAndCertEncodingType = 0;
   HCERTSTORE hSrcStore = NULL;
   HCRYPTMSG hMsg = NULL;
   void * pvContext = NULL;
   BOOL bRes = CryptQueryObject(CERT_QUERY_OBJECT_FILE,
                                FileName,
                                CERT_QUERY_CONTENT_FLAG_ALL,
                                CERT_QUERY_FORMAT_FLAG_ALL,
                                0,
                                &dwMsgAndCertEncodingType,
                                &dwContentType,
                                &dwFormatType,
                                &hSrcStore,
                                &hMsg,
                                (const void **)&pvContext);
   if (!bRes)
   {
      hr = GetLastError();
   }
#endif

   if (hStore != NULL && hTempStore != NULL)
   {
      ZeroMemory(&ii, sizeof(CRYPTUI_WIZ_IMPORT_SRC_INFO));
      ii.dwSize = sizeof(ii);
      ii.dwSubjectChoice = CRYPTUI_WIZ_IMPORT_SUBJECT_FILE;
      ii.pwszFileName = FileName;
      ii.pwszPassword = Password;
      if (CryptUIWizImport(flags, NULL, NULL, &ii, hTempStore))
      {
         // Now we need to extract CERT_CONTEXT from this temp store and put it to MY store
         // and install to metabase
         PCCERT_CONTEXT pCertContext = CertEnumCertificatesInStore(hTempStore, NULL);
         if (pCertContext != NULL)
         {
            // Put it to My store
            ii.dwSubjectChoice = CRYPTUI_WIZ_IMPORT_SUBJECT_CERT_STORE;
            ii.hCertStore = hTempStore;
            if (CryptUIWizImport(flags, NULL, NULL, &ii, hStore))
            {
               // Install to metabase
               CRYPT_HASH_BLOB hash;
	            if (  CertGetCertificateContextProperty(pCertContext, 
                              CERT_SHA1_HASH_PROP_ID, NULL, &hash.cbData)
                  && NULL != (hash.pbData = (BYTE *)_alloca(hash.cbData))
                  && CertGetCertificateContextProperty(pCertContext, 
                              CERT_SHA1_HASH_PROP_ID, hash.pbData, &hash.cbData)
                  )
	            {
                  InstallHashToMetabase(&hash, InstanceName, &hr);
	            }
               else
               {
                  hr = GetLastError();
               }
            }
            else
            {
               hr = GetLastError();
            }
            CertFreeCertificateContext(pCertContext);
         }
         else
         {
            hr = GetLastError();
         }
      }
      else
      {
         hr = GetLastError();
      }
   }
   if (NULL != hStore)
      CertCloseStore(hStore, 0);
   if (NULL != hTempStore)
      CertCloseStore(hTempStore, 0);
	return hr;
#endif
   */
}

HRESULT
CIISCertObj::ImportFromBlobProxy(
    IIISCertObj * pObj,
    BSTR InstanceName,
    BSTR Password,
    DWORD actual,
    BYTE *pData)
{
    HRESULT hr = E_FAIL;
    BOOL bBase64Encoded = TRUE;
    char *pszB64Out = NULL;
    DWORD pcchB64Out = 0;

    if (pObj == this){bBase64Encoded = FALSE;}
    if (bBase64Encoded)
    {
        // base64 encode the data for transfer to the remote machine
        DWORD  err;
        pcchB64Out = 0;

        // Encode it so that it can be passed back as a string (there are no Nulls in it)
        err = Base64EncodeA(pData,actual,NULL,&pcchB64Out);
        if (err != ERROR_SUCCESS)
        {
            hr = E_FAIL;
            goto ImportFromBlobProxy_Exit;
        }

        // allocate some space and then try it.
        pcchB64Out = pcchB64Out * sizeof(char);
        pszB64Out = (char *) ::CoTaskMemAlloc(pcchB64Out);
        if (NULL == pszB64Out)
        {
            hr = HRESULT_FROM_WIN32(E_OUTOFMEMORY);
            goto ImportFromBlobProxy_Exit;
        }

        err = Base64EncodeA(pData,actual,pszB64Out,&pcchB64Out);
        if (err != ERROR_SUCCESS)
        {
            hr = E_FAIL;
            goto ImportFromBlobProxy_Exit;
        }

        // the data to send are now in these variables
        // pcchB64Out
        // pszB64Out
    }
    else
    {
        pcchB64Out = actual;
        pszB64Out = (char*) pData;
    }

    hr = pObj->ImportFromBlob(InstanceName, Password, bBase64Encoded, pcchB64Out, pszB64Out);
    if (SUCCEEDED(hr))
    {
        // otherwise hey, The data was imported!
     
        hr = S_OK;
    }

ImportFromBlobProxy_Exit:
    if (bBase64Encoded)
    {
        if (NULL != pszB64Out){CoTaskMemFree(pszB64Out);}
    }
    return hr;
}

HRESULT 
CIISCertObj::ImportFromBlob(
    BSTR InstanceName,
    BSTR Password,
    BOOL bBase64Encoded,
    DWORD count,
    char *pData)
{
   HRESULT hr = S_OK;
   CRYPT_DATA_BLOB blob;
   ZeroMemory(&blob, sizeof(CRYPT_DATA_BLOB));
   LPTSTR pPass = Password;
   BOOL   blob_freeme = FALSE;

   if (bBase64Encoded)
   {
      int err;

      // The data we got back was Base64 encoded to remove nulls.
      // we need to decode it back to it's original format.
      if( (err = Base64DecodeA(pData,count,NULL,&blob.cbData)) != ERROR_SUCCESS                    ||
        (blob.pbData = (BYTE *) malloc(blob.cbData)) == NULL      ||
        (err = Base64DecodeA(pData,count,blob.pbData,&blob.cbData)) != ERROR_SUCCESS ) 
      {
          SetLastError(err);
          hr = HRESULT_FROM_WIN32(err);
          return hr;
      }
      blob_freeme = TRUE;
   }
   else
   {
      blob.cbData = count;
      blob.pbData = (BYTE*) pData;
   }

   if (!PFXVerifyPassword(&blob, pPass, 0))
   {
      // Try empty password
      if (pPass == NULL)
      {
         if (!PFXVerifyPassword(&blob, pPass = L'\0', 0))
         {
            hr = ERROR_INVALID_PARAMETER;
         }
      }
      else
      {
         hr = ERROR_INVALID_PARAMETER;
      }
   }
   if (SUCCEEDED(hr))
   {

      HCERTSTORE hStore = PFXImportCertStore(&blob, pPass, CRYPT_MACHINE_KEYSET|CRYPT_EXPORTABLE);
      if (hStore != NULL)
      {
         //add the certificate with private key to my store; and the rest
         //to the ca store
	      PCCERT_CONTEXT	pCertContext = NULL;
	      PCCERT_CONTEXT	pCertPre = NULL;
         while (  SUCCEEDED(hr)
               && NULL != (pCertContext = CertEnumCertificatesInStore(hStore, pCertPre))
               )
         {
            //check if the certificate has the property on it
            //make sure the private key matches the certificate
            //search for both machine key and user keys
            DWORD dwData = 0;
            if (   CertGetCertificateContextProperty(pCertContext,
                     CERT_KEY_PROV_INFO_PROP_ID, NULL, &dwData) 
               &&  CryptFindCertificateKeyProvInfo(pCertContext, 0, NULL)
               )
            {
               // This certificate should go to the My store
               HCERTSTORE hDestStore = CertOpenStore(
                  CERT_STORE_PROV_SYSTEM,
                  PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
                  NULL,
                  CERT_SYSTEM_STORE_LOCAL_MACHINE,
                  L"MY"
                  );
               if (hDestStore != NULL)
               {
                  // Put it to store
		            if (CertAddCertificateContextToStore(hDestStore,
							   pCertContext,
								CERT_STORE_ADD_REPLACE_EXISTING,
								NULL))
                  {
                     // Install to metabase
                     CRYPT_HASH_BLOB hash;
	                  if (  CertGetCertificateContextProperty(pCertContext, 
                                    CERT_SHA1_HASH_PROP_ID, NULL, &hash.cbData)
                        && NULL != (hash.pbData = (BYTE *)_alloca(hash.cbData))
                        && CertGetCertificateContextProperty(pCertContext, 
                                    CERT_SHA1_HASH_PROP_ID, hash.pbData, &hash.cbData)
                        )
	                  {
                        InstallHashToMetabase(&hash, InstanceName, &hr);
	                  }
                     else
                     {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                     }
                  }
                  else
                  {
                     hr = HRESULT_FROM_WIN32(GetLastError());
                  }
                  CertCloseStore(hDestStore, 0);
               }
               else
               {
                  hr = HRESULT_FROM_WIN32(GetLastError());
               }
            }  // my store certificate
            //see if the certificate is self-signed.
            //if it is selfsigned, goes to the root store
            else if (TrustIsCertificateSelfSigned(pCertContext,
                        pCertContext->dwCertEncodingType, 0))
            {
               //Put it to the root store
               HCERTSTORE hDestStore=CertOpenStore(
                     CERT_STORE_PROV_SYSTEM,
                     PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
                     NULL,
                     CERT_SYSTEM_STORE_LOCAL_MACHINE,
							L"ROOT");
               if (hDestStore != NULL)
               {
                  // Put it to store
		            if (!CertAddCertificateContextToStore(hDestStore,
							   pCertContext,
								CERT_STORE_ADD_REPLACE_EXISTING,
								NULL))
                  {
                     hr = HRESULT_FROM_WIN32(GetLastError());
                  }
                  CertCloseStore(hDestStore, 0);
               }
               else
               {
                  hr = HRESULT_FROM_WIN32(GetLastError());
               }
            }
            else
            {
               //Put it to the CA store
               HCERTSTORE hDestStore=CertOpenStore(
                     CERT_STORE_PROV_SYSTEM,
                     PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
                     NULL,
                     CERT_SYSTEM_STORE_LOCAL_MACHINE,
							L"CA");
               if (hDestStore != NULL)
               {
                  // Put it to store
		            if (!CertAddCertificateContextToStore(hDestStore,
							   pCertContext,
								CERT_STORE_ADD_REPLACE_EXISTING,
								NULL))
                  {
                     hr = HRESULT_FROM_WIN32(GetLastError());
                  }
                  CertCloseStore(hDestStore, 0);
               }
               else
               {
                  hr = HRESULT_FROM_WIN32(GetLastError());
               }
            }
            pCertPre = pCertContext;
         } //while

         CertCloseStore(hStore, 0);
      }
      else
         hr = HRESULT_FROM_WIN32(GetLastError());
   }

//ImportFromBlob_Exit:
   if (blob_freeme){if (blob.pbData != NULL){free(blob.pbData);blob.pbData=NULL;}}
   return hr;
}

//////////////////////////////////////////////////////////////////
#ifdef FULL_OBJECT

HRESULT CIISCertObj::Init()
{
   HRESULT hr;
   if (!m_bInitDone)
   {
      do {
         // setup IEnroll object properly
		   DWORD dwFlags;
		   if (FAILED(hr = GetEnroll()->get_MyStoreFlags(&dwFlags)))
            break;
		   dwFlags &= ~CERT_SYSTEM_STORE_LOCATION_MASK;
		   dwFlags |= CERT_SYSTEM_STORE_LOCAL_MACHINE;
		   // following call will change Request store flags also
		   if (FAILED(hr = GetEnroll()->put_MyStoreFlags(dwFlags)))
            break;
		   if (FAILED(hr = GetEnroll()->get_GenKeyFlags(&dwFlags)))
            break;
		   dwFlags |= CRYPT_EXPORTABLE;
		   if (  FAILED(hr = GetEnroll()->put_GenKeyFlags(dwFlags))
		      || FAILED(hr = GetEnroll()->put_KeySpec(AT_KEYEXCHANGE))
		      || FAILED(hr = GetEnroll()->put_ProviderType(PROV_RSA_SCHANNEL))
		      || FAILED(hr = GetEnroll()->put_DeleteRequestCert(TRUE))
            )
            break;
      } while (FALSE);
      m_bInitDone = SUCCEEDED(hr);
   }
   return hr;
}

IEnroll *
CIISCertObj::GetEnroll()
{
   if (m_pEnroll == NULL)
   {
		HRESULT hr = CoCreateInstance(CLSID_CEnroll,
				NULL,
				CLSCTX_INPROC_SERVER,
				IID_IEnroll,
				(void **)&m_pEnroll);
   }
   return m_pEnroll;
}

HCERTSTORE
OpenMyStore(IEnroll * pEnroll, HRESULT * phResult)
{
	ASSERT(NULL != phResult);
	HCERTSTORE hStore = NULL;
   hStore = CertOpenStore(CERT_STORE_PROV_SYSTEM,
      PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
      NULL,
      CERT_SYSTEM_STORE_LOCAL_MACHINE,
      L"MY"
      );

	if (hStore == NULL)
		*phResult = HRESULT_FROM_WIN32(GetLastError());
	return hStore;
}
#endif

HRESULT ShutdownSSL(CString& server_name)
{
   CComAuthInfo auth;
	CString str = server_name;
	str += _T("/root");
	CMetaKey key(&auth, str,
				METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE);
	DWORD dwSslAccess;
	if (!key.Succeeded())
      return key.QueryResult();
   
	if (  SUCCEEDED(key.QueryValue(MD_SSL_ACCESS_PERM, dwSslAccess))
		&&	dwSslAccess > 0
		)
	{
		key.SetValue(MD_SSL_ACCESS_PERM, 0);
	}
	// Now we need to remove SSL setting from any virtual directory below
	CError err;
   CStringListEx data_paths;
	DWORD 
		dwMDIdentifier, 
		dwMDAttributes, 
		dwMDUserType,
		dwMDDataType;

	VERIFY(CMetaKey::GetMDFieldDef(
		MD_SSL_ACCESS_PERM, 
		dwMDIdentifier, 
		dwMDAttributes, 
		dwMDUserType,
		dwMDDataType
		));

   err = key.GetDataPaths( 
      data_paths,
      dwMDIdentifier,
      dwMDDataType
      );

   if (err.Succeeded() && !data_paths.empty())
   {
      CStringListEx::iterator it = data_paths.begin();
	   while (it != data_paths.end())
		{
			CString& str = (*it++);
			if (	SUCCEEDED(key.QueryValue(MD_SSL_ACCESS_PERM, dwSslAccess, NULL, str))
				&&	dwSslAccess > 0
				)
			{
				key.SetValue(MD_SSL_ACCESS_PERM, 0, NULL, str);
			}
		}
	}
	return key.QueryResult();
}

/*
	InstallHashToMetabase

	Function writes hash array to metabase. After that IIS 
	could use certificate with that hash from MY store.
	Function expects server_name in format lm\w3svc\<number>,
	i.e. from root node down to virtual server

 */
BOOL
InstallHashToMetabase(CRYPT_HASH_BLOB * pHash,
					  BSTR InstanceName, 
					  HRESULT * phResult)
{
	BOOL bRes = FALSE;
   CComAuthInfo auth;
   CString key_path = SZ_MBN_SEP_STR SZ_MBN_MACHINE SZ_MBN_SEP_STR; // SZ_MBN_WEB SZ_MBN_SEP_STR;
   key_path += InstanceName;
	CMetaKey key(&auth, key_path, METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE);
	if (key.Succeeded())
	{
		CBlob blob;
		blob.SetValue(pHash->cbData, pHash->pbData, TRUE);
		bRes = SUCCEEDED(*phResult = key.SetValue(MD_SSL_CERT_HASH, blob)) 
			&& SUCCEEDED(*phResult = key.SetValue(MD_SSL_CERT_STORE_NAME, CString(L"MY")));
	}
	else
	{
		ATLTRACE(_T("Failed to open metabase key. Error 0x%x\n"), key.QueryResult());
		*phResult = key.QueryResult();
	}
	return bRes;
}

#ifdef FULL_OBJECT
HRESULT CIISCertObj::CreateDNString(CString& str)
{
   str = _T("");
   str += _T("CN=") + m_CommonName;
   str += _T("\n,OU=") + m_OrganizationUnit;
   str += _T("\n,O=") + m_Organization;
   str += _T("\n,L=") + m_Locality;
   str += _T("\n,S=") + m_State;
   str += _T("\n,C=") + m_Country;
   return S_OK;
}
#endif

CERT_CONTEXT *
CIISCertObj::GetInstalledCert(HRESULT * phResult)
{
//	ATLASSERT(GetEnroll() != NULL);
	ATLASSERT(phResult != NULL);
	CERT_CONTEXT * pCert = NULL;
	*phResult = S_OK;
   CComAuthInfo auth;
   CString key_path = SZ_MBN_SEP_STR SZ_MBN_MACHINE SZ_MBN_SEP_STR;// SZ_MBN_WEB SZ_MBN_SEP_STR;
   key_path += m_InstanceName;

	CMetaKey key(&auth, key_path, METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE);
	if (key.Succeeded())
	{
		CString store_name;
		CBlob hash;
		if (	SUCCEEDED(*phResult = key.QueryValue(MD_SSL_CERT_STORE_NAME, store_name))
			&&	SUCCEEDED(*phResult = key.QueryValue(MD_SSL_CERT_HASH, hash))
			)
		{
			// Open MY store. We assume that store type and flags
			// cannot be changed between installation and unistallation
			// of the sertificate.
         HCERTSTORE hStore = CertOpenStore(CERT_STORE_PROV_SYSTEM,
            PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
            NULL,
            CERT_SYSTEM_STORE_LOCAL_MACHINE,
            store_name
            );
			ASSERT(hStore != NULL);
			if (hStore != NULL)
			{

				// Now we need to find cert by hash
				CRYPT_HASH_BLOB crypt_hash;
				crypt_hash.cbData = hash.GetSize();
				crypt_hash.pbData = hash.GetData();
				pCert = (CERT_CONTEXT *)CertFindCertificateInStore(hStore, 
												X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, 
												0, CERT_FIND_HASH, (LPVOID)&crypt_hash, NULL);
				if (pCert == NULL)
            {
					*phResult = HRESULT_FROM_WIN32(GetLastError());
            }
				VERIFY(CertCloseStore(hStore, 0));
			}
         else
         {
            *phResult = HRESULT_FROM_WIN32(GetLastError());
         }
		}
	}
	else
   {
		*phResult = key.QueryResult();
   }
	return pCert;
}

HRESULT
CIISCertObj::UninstallCert()
{
   CComAuthInfo auth;
   CString key_path = SZ_MBN_SEP_STR SZ_MBN_MACHINE SZ_MBN_SEP_STR;// SZ_MBN_WEB SZ_MBN_SEP_STR;
   key_path += m_InstanceName;
	CMetaKey key(&auth, key_path, METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE);
	if (key.Succeeded())
	{
		CString store_name;
		key.QueryValue(MD_SSL_CERT_STORE_NAME, store_name);
		if (SUCCEEDED(key.DeleteValue(MD_SSL_CERT_HASH)))
			key.DeleteValue(MD_SSL_CERT_STORE_NAME);
	}
	return key.QueryResult();
}

IIISCertObj *
CIISCertObj::GetObject(HRESULT * phr)
{
    TCHAR tszTempString[200];

   if (m_pObj == NULL && !m_ServerName.IsEmpty())
   {
      if (IsServerLocal(m_ServerName))
      {
          _stprintf(tszTempString, _T("GetObject:returns:server is local\n"));OutputDebugString(tszTempString);
         return this;
      }
      else
      {
         CComAuthInfo auth(m_ServerName, m_UserName, m_UserPassword);
         COSERVERINFO * pcsiName = auth.CreateServerInfoStruct();
     
         MULTI_QI res[1] = {
            {&__uuidof(IIISCertObj), NULL, 0}
         };

         _stprintf(tszTempString, _T("GetObject:calling CoCreateInstanceEx\n"));OutputDebugString(tszTempString);
         *phr = CoCreateInstanceEx(CLSID_IISCertObj,NULL,CLSCTX_SERVER,pcsiName,1,res);
         if (SUCCEEDED(*phr))
         {
            m_pObj = (IIISCertObj *)res[0].pItf;
            if (auth.UsesImpersonation())
            {
               OutputDebugString(_T("UsesImpersonation!!!\n"));
               auth.ApplyProxyBlanket(m_pObj);
            }
            else
            {
               OutputDebugString(_T("No use of UsesImpersonation\n"));
            }
         }
         else
         {
            OutputDebugString(_T("CoCreateInstanceEx on CLSID_IISCertObj failed!\n"));
            // *phr that gets returned back is the error...
         }
      
         auth.FreeServerInfoStruct(pcsiName);
      }
   }
   else
   {
      if (m_ServerName.IsEmpty())
      {
          _stprintf(tszTempString, _T("GetObject:returns:server is local\n"));OutputDebugString(tszTempString);
         // object is null, but it's the local machine, so
         // just return back this pointer
         return this;
      }
      else
      {
          _stprintf(tszTempString, _T("GetObject:returns whatever was already there\n"));OutputDebugString(tszTempString);
         // object is not null so, we don't have to pass anything back
         // the m_pObj already contains something...
      }
   }
   //ASSERT(m_pObj != NULL);
   return m_pObj;
}

IIISCertObj *
CIISCertObj::GetObject(HRESULT * phr, CString csServerName,CString csUserName OPTIONAL,CString csUserPassword OPTIONAL)
{
    IIISCertObj * pObj = NULL;

    if (!csUserName.IsEmpty())
    {
        if (IsServerLocal(csServerName))
        {
            return this;
        }
        else
        {
            CComAuthInfo auth(csServerName, csUserName, csUserPassword);
            COSERVERINFO * pcsiName = auth.CreateServerInfoStruct();

            MULTI_QI res[1] = {
            {&__uuidof(IIISCertObj), NULL, 0}
            };

            *phr = CoCreateInstanceEx(CLSID_IISCertObj,NULL,CLSCTX_SERVER,pcsiName,1,res);
            if (SUCCEEDED(*phr))
            {
                pObj = (IIISCertObj *)res[0].pItf;
                if (auth.UsesImpersonation())
                {
                    auth.ApplyProxyBlanket(pObj);
                }
            }
            auth.FreeServerInfoStruct(pcsiName);
        }
    }
   
   return pObj;
}


BOOL 
AddChainToStore(
   HCERTSTORE hCertStore,
   PCCERT_CONTEXT	pCertContext,
   DWORD	cStores,
	HCERTSTORE * rghStores,
	BOOL fDontAddRootCert,
	CERT_TRUST_STATUS	* pChainTrustStatus)
{
   DWORD	i;
   CERT_CHAIN_ENGINE_CONFIG CertChainEngineConfig;
	HCERTCHAINENGINE hCertChainEngine = NULL;
	PCCERT_CHAIN_CONTEXT pCertChainContext = NULL;
	CERT_CHAIN_PARA CertChainPara;
	BOOL fRet = TRUE;
   PCCERT_CONTEXT pTempCertContext = NULL;

	//
	// create a new chain engine, then build the chain
	//
	memset(&CertChainEngineConfig, 0, sizeof(CertChainEngineConfig));
	CertChainEngineConfig.cbSize = sizeof(CertChainEngineConfig);
	CertChainEngineConfig.cAdditionalStore = cStores;
	CertChainEngineConfig.rghAdditionalStore = rghStores;
   CertChainEngineConfig.dwFlags = CERT_CHAIN_USE_LOCAL_MACHINE_STORE;

   if (!CertCreateCertificateChainEngine(&CertChainEngineConfig, &hCertChainEngine))
	{
		goto ErrorReturn;
	}

	memset(&CertChainPara, 0, sizeof(CertChainPara));
	CertChainPara.cbSize = sizeof(CertChainPara);

	if (!CertGetCertificateChain(
				hCertChainEngine,
				pCertContext,
				NULL,
				NULL,
				&CertChainPara,
				0,
				NULL,
				&pCertChainContext))
	{
		goto ErrorReturn;
	}

	//
	// make sure there is atleast 1 simple chain
	//
   if (pCertChainContext->cChain != 0)
	{
		i = 0;
		while (i < pCertChainContext->rgpChain[0]->cElement)
		{
			//
			// if we are supposed to skip the root cert,
			// and we are on the root cert, then continue
			//
			if (fDontAddRootCert &&
                (pCertChainContext->rgpChain[0]->rgpElement[i]->TrustStatus.dwInfoStatus & CERT_TRUST_IS_SELF_SIGNED))
			{
                i++;
                continue;
			}

			CertAddCertificateContextToStore(
					hCertStore,
					pCertChainContext->rgpChain[0]->rgpElement[i]->pCertContext,
					CERT_STORE_ADD_REPLACE_EXISTING,
					&pTempCertContext);

            //
            // remove any private key property the certcontext may have on it.
            //
            if (pTempCertContext)
            {
                CertSetCertificateContextProperty(
                            pTempCertContext, 
                            CERT_KEY_PROV_INFO_PROP_ID, 
                            0, 
                            NULL);

                CertFreeCertificateContext(pTempCertContext);
            }

			i++;
		}
	}
	else
	{
		goto ErrorReturn;
	}

	//
	// if the caller wants the status, then set it
	//
	if (pChainTrustStatus != NULL)
	{
		pChainTrustStatus->dwErrorStatus = pCertChainContext->TrustStatus.dwErrorStatus;
		pChainTrustStatus->dwInfoStatus = pCertChainContext->TrustStatus.dwInfoStatus;
	}

	
Ret:
	if (pCertChainContext != NULL)
	{
		CertFreeCertificateChain(pCertChainContext);
	}

	if (hCertChainEngine != NULL)
	{
		CertFreeCertificateChainEngine(hCertChainEngine);
	}

	return fRet;

ErrorReturn:
	fRet = FALSE;
	goto Ret;
}

// This function is borrowed from trustapi.cpp
//
static BOOL
TrustIsCertificateSelfSigned(PCCERT_CONTEXT pContext,
                             DWORD dwEncoding, 
                             DWORD dwFlags)
{
   if (!(pContext) ||
     (dwFlags != 0))
   {
     SetLastError(ERROR_INVALID_PARAMETER);
     return(FALSE);
   }

   if (!(CertCompareCertificateName(dwEncoding, 
                                  &pContext->pCertInfo->Issuer,
                                  &pContext->pCertInfo->Subject)))
   {
     return(FALSE);
   }

   DWORD   dwFlag;

   dwFlag = CERT_STORE_SIGNATURE_FLAG;

   if (!(CertVerifySubjectCertificateContext(pContext, pContext, &dwFlag)) || 
     (dwFlag & CERT_STORE_SIGNATURE_FLAG))
   {
     return(FALSE);
   }

   return(TRUE);
}

STDMETHODIMP 
CIISCertObj::Copy(
   BSTR bstrDestinationServerName,
   BSTR bstrDestinationServerInstance,
   BSTR bstrCertificatePassword,
   VARIANT varDestinationServerUserName, 
   VARIANT varDestinationServerPassword)
{
    return CopyOrMove(FALSE,bstrDestinationServerName,bstrDestinationServerInstance,bstrCertificatePassword,varDestinationServerUserName,varDestinationServerPassword);
}

STDMETHODIMP 
CIISCertObj::Move(
   BSTR bstrDestinationServerName,
   BSTR bstrDestinationServerInstance,
   BSTR bstrCertificatePassword,
   VARIANT varDestinationServerUserName, 
   VARIANT varDestinationServerPassword)
{
    return CopyOrMove(TRUE,bstrDestinationServerName,bstrDestinationServerInstance,bstrCertificatePassword,varDestinationServerUserName,varDestinationServerPassword);
}


HRESULT
CIISCertObj::CopyOrMove(
    BOOL bRemoveFromCertAfterCopy,
    BSTR bstrDestinationServerName,
    BSTR bstrDestinationServerInstance,
    BSTR bstrCertificatePassword,
    VARIANT varDestinationServerUserName, 
    VARIANT varDestinationServerPassword
    )
{
    HRESULT hr = E_FAIL;
    DWORD  cbEncodedSize = 0;
    char * pszEncodedString = NULL;
    BOOL   bBase64Encoded = TRUE;
    BOOL   bGuessingUserNamePass = FALSE;
    
    DWORD  blob_cbData;
    BYTE * blob_pbData = NULL;
    BOOL   blob_freeme = FALSE;

    BOOL bPrivateKey = TRUE;
    BOOL bCertChain = FALSE;

    CString csDestinationServerName = bstrDestinationServerName;
    CString csDestinationServerUserName;
    CString csDestinationServerUserPassword;

    IIISCertObj * pObj = NULL;
    IIISCertObj * pObj2 = NULL;
    BSTR bstrInstanceName = SysAllocString(m_InstanceName);

    TCHAR tszTempString[200];
    _stprintf(tszTempString, _T("Copy:Start\n"));OutputDebugString(tszTempString);

    // if the optional parameter serverusername isn't empty, use that; otherwise, use...
    if (V_VT(&varDestinationServerUserName) != VT_ERROR)
    {
        _stprintf(tszTempString, _T("Copy:1\n"));OutputDebugString(tszTempString);
		VARIANT varBstrUserName;
        VariantInit(&varBstrUserName);
		HRESULT hr = VariantChangeType(&varBstrUserName, &varDestinationServerUserName, 0, VT_BSTR);
		if (FAILED(hr)){goto Copy_Exit;}
        csDestinationServerUserName = V_BSTR(&varBstrUserName);
		VariantClear(&varBstrUserName);
    }
    else
    {
        _stprintf(tszTempString, _T("Copy:ServerUserName was empty!\n"));OutputDebugString(tszTempString);
        // it's empty so don't use it
        //csDestinationServerUserName = varDestinationServerUserName;
        bGuessingUserNamePass = TRUE;
        csDestinationServerUserName = m_UserName;
    }

    // if the optional parameter serverusername isn't empty, use that; otherwise, use...
    if (V_VT(&varDestinationServerPassword) != VT_ERROR)
    {
        _stprintf(tszTempString, _T("Copy:3\n"));OutputDebugString(tszTempString);
		VARIANT varBstrUserPassword;
        VariantInit(&varBstrUserPassword);
		HRESULT hr = VariantChangeType(&varBstrUserPassword, &varDestinationServerPassword, 0, VT_BSTR);
		if (FAILED(hr)){goto Copy_Exit;}
        csDestinationServerUserName = V_BSTR(&varBstrUserPassword);
		VariantClear(&varBstrUserPassword);
    }
    else
    {
        _stprintf(tszTempString, _T("Copy:ServerUserPassword was empty!\n"));OutputDebugString(tszTempString);
        if (TRUE == bGuessingUserNamePass)
        {
            csDestinationServerUserPassword = m_UserPassword;
        }
        else
        {
            // maybe the password was intended to be empty!
        }
    }

    // --------------------------
    // step 1.
    // 1st of all check if we have access to
    // both the servers!!!!
    // --------------------------

    // 1st we have to get the certblob from the Server#1
    // so call export to get the data
    _stprintf(tszTempString, _T("Copy:5\n"));OutputDebugString(tszTempString);
    hr = S_OK;
    pObj = GetObject(&hr);
    if (FAILED(hr))
    {
        return(hr);
    }

    // Logon to that server's CertObj.dll with the credentials supplied...
    //
    // if there were no credential's supplied then just use the ones that are in our object....
    //
    // if that doesn't work then try just the logged on user.
    _stprintf(tszTempString, _T("Copy:6\n"));OutputDebugString(tszTempString);
    pObj2 = GetObject(&hr,csDestinationServerName,csDestinationServerUserName,csDestinationServerUserPassword);
    if (FAILED(hr))
    {
        _stprintf(tszTempString, _T("Copy:7\n"));OutputDebugString(tszTempString);
        if (TRUE == bGuessingUserNamePass)
        {
            _stprintf(tszTempString, _T("Copy:8\n"));OutputDebugString(tszTempString);
            // try something else.
        }
        goto Copy_Exit;
    }

    // -----------------------------------
    // step 2.
    // okay we have access to both servers
    // Grab the cert from server #1
    // -----------------------------------
    // Get data from the remote/local iis store return it back as a blob.
    // The blob could be returned back as Base64 encoded so check that flag
    hr = ExportToBlobProxy(pObj, bstrInstanceName, bstrCertificatePassword, bPrivateKey, bCertChain, &bBase64Encoded, &cbEncodedSize, &pszEncodedString);
    if (FAILED(hr))
    {
        goto Copy_Exit;
    }

    // if it's passed back to us a encoded then let's decode it
    if (bBase64Encoded)
    {
        int err;
        // The data we got back was Base64 encoded to remove nulls.
        // we need to decode it back to it's original format.
        if( (err = Base64DecodeA(pszEncodedString,cbEncodedSize,NULL,&blob_cbData)) != ERROR_SUCCESS                    ||
            (blob_pbData = (BYTE *) malloc(blob_cbData)) == NULL      ||
            (err = Base64DecodeA(pszEncodedString,cbEncodedSize,blob_pbData,&blob_cbData)) != ERROR_SUCCESS ) 
        {
            SetLastError(err);
            hr = HRESULT_FROM_WIN32(err);
            return hr;
        }
        blob_freeme = TRUE;
    }
    else
    {
        blob_cbData = cbEncodedSize;
        blob_pbData = (BYTE*) pszEncodedString;
    }

    // -----------------------------------
    // step 3.
    // okay we have access to both servers
    // we have the cert blob from server#1 in memory
    // now we need to push this blob into the server#2
    // -----------------------------------
    hr = ImportFromBlobProxy(pObj2, bstrDestinationServerInstance, bstrCertificatePassword, blob_cbData, blob_pbData);
    if (FAILED(hr))
    {
        goto Copy_Exit;
    }
    _stprintf(tszTempString, _T("Copy:ImportFromBlobProxy succeeded\n"));OutputDebugString(tszTempString);

    // we successfully copied the cert from machine #1 to machine #2.
    // lets see if we need to delete the original cert!.
    if (TRUE == bRemoveFromCertAfterCopy)
    {
        hr = pObj->RemoveCert(bstrInstanceName, bPrivateKey);
        if (FAILED(hr))
        {
            goto Copy_Exit;
        }
    }

    hr = S_OK;
   
Copy_Exit:
    if (blob_freeme){if (blob_pbData != NULL){free(blob_pbData);blob_pbData=NULL;}}
    if (pszEncodedString != NULL){CoTaskMemFree(pszEncodedString);pszEncodedString=NULL;}
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certobj\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(_STDAFX_H)
#define _STDAFX_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#endif
#define _ATL_APARTMENT_THREADED

#include <windows.h>

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#include <comdef.h>
#include <xenroll.h>

#define _WTL_NO_CSTRING

#include <atlwin.h>
#include <atlapp.h>
#include <atldlgs.h>
#include <atlmisc.h>
#include <atlctrls.h>
#include <atlddx.h>
#include <atlcrack.h>

#include <list>
#include <map>
#include <stack>
#include <set>
#include <memory>

#include <shlwapi.h>
//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(_STDAFX)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certwiz\certcontentspages.h ===
//
// CertContentsPages.h
//
#ifndef _CERT_CONTENTS_PAGES_H
#define _CERT_CONTENTS_PAGES_H

#include "Certificat.h"

class CCertContentsPage : public CIISWizardPage
{
	DECLARE_DYNCREATE(CCertContentsPage)

// Construction
public:
	CCertContentsPage(UINT id = 0, CCertificate * pCert = NULL);
	~CCertContentsPage();

	CCertificate * GetCertificate() {return m_pCert;}

// Dialog Data
	//{{AFX_DATA(CCertContentsPage)
	//}}AFX_DATA
	CCertificate * m_pCert;

// Overrides
	virtual BOOL GetCertDescription(CERT_DESCRIPTION& cd)
	{
		return FALSE;
	}
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CCertContentsPage)
	public:
	virtual LRESULT OnWizardBack() 
	{
		ASSERT(FALSE);
		return 1;
	}
	virtual LRESULT OnWizardNext() 
	{
		ASSERT(FALSE);
		return 1;
	}
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CCertContentsPage)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

class CInstallCertPage : public CCertContentsPage
{
	enum 
	{
		IDD = IDD_PAGE_WIZ_INSTALL_CERT,
		IDD_PAGE_NEXT = IDD_PAGE_WIZ_FINAL_INSTALL,
		IDD_PAGE_PREV = IDD_PAGE_WIZ_CHOOSE_CERT
	};
	DECLARE_DYNCREATE(CInstallCertPage)

public:
	CInstallCertPage(CCertificate * pCert = NULL)
		: CCertContentsPage(CInstallCertPage::IDD, pCert)
	{
	}

	virtual BOOL GetCertDescription(CERT_DESCRIPTION& cd);
	virtual LRESULT OnWizardBack() {return IDD_PAGE_PREV;}
	virtual LRESULT OnWizardNext();
};

class CReplaceCertPage : public CCertContentsPage
{
	enum
	{
		IDD = IDD_PAGE_WIZ_REPLACE_CERT,
		IDD_PAGE_NEXT = IDD_PAGE_WIZ_FINAL_REPLACE,
		IDD_PAGE_PREV = IDD_PAGE_WIZ_CHOOSE_CERT
	};
	DECLARE_DYNCREATE(CReplaceCertPage)

public:
	CReplaceCertPage(CCertificate * pCert = NULL)
		: CCertContentsPage(CReplaceCertPage::IDD, pCert)
	{
	}

	virtual BOOL GetCertDescription(CERT_DESCRIPTION& cd);
	virtual LRESULT OnWizardBack() {return IDD_PAGE_PREV;}
	virtual LRESULT OnWizardNext();
};

class CInstallKeyPage : public CCertContentsPage
{
	enum 
	{
		IDD = IDD_PAGE_WIZ_INSTALL_KEYCERT,
		IDD_PAGE_NEXT = IDD_PAGE_WIZ_FINAL_INSTALL,
		IDD_PAGE_PREV = IDD_PAGE_WIZ_GET_PASSWORD
	};
	DECLARE_DYNCREATE(CInstallKeyPage)

public:
	CInstallKeyPage(CCertificate * pCert = NULL)
		: CCertContentsPage(CInstallKeyPage::IDD, pCert)
	{
	}

	virtual BOOL GetCertDescription(CERT_DESCRIPTION& cd);
	virtual LRESULT OnWizardBack() {return IDD_PAGE_PREV;}
	virtual LRESULT OnWizardNext();
	virtual BOOL OnSetActive();
};

class CInstallRespPage : public CCertContentsPage
{
	enum 
	{
		IDD = IDD_PAGE_WIZ_INSTALL_RESP,
		IDD_PAGE_NEXT = IDD_PAGE_WIZ_FINAL_INSTALL,
		IDD_PAGE_PREV = IDD_PAGE_WIZ_GETRESP_FILE
	};
	DECLARE_DYNCREATE(CInstallRespPage)

public:
	CInstallRespPage(CCertificate * pCert = NULL)
		: CCertContentsPage(CInstallRespPage::IDD, pCert)
	{
	}

	virtual BOOL GetCertDescription(CERT_DESCRIPTION& cd);
	virtual LRESULT OnWizardBack() {return IDD_PAGE_PREV;}
	virtual LRESULT OnWizardNext();
	virtual BOOL OnSetActive();
};

class CRequestCancelPage : public CCertContentsPage
{
	enum
	{
		IDD = IDD_PAGE_WIZ_CANCEL_REQUEST,
		IDD_PAGE_NEXT = IDD_PAGE_WIZ_FINAL_CANCEL,
		IDD_PAGE_PREV = IDD_PAGE_WIZ_PENDING_WHAT_TODO
	};
	DECLARE_DYNCREATE(CRequestCancelPage)

public:
	CRequestCancelPage(CCertificate * pCert = NULL)
		: CCertContentsPage(CRequestCancelPage::IDD, pCert)
	{
	}

	virtual BOOL GetCertDescription(CERT_DESCRIPTION& cd);
	virtual LRESULT OnWizardBack() {return IDD_PAGE_PREV;}
	virtual LRESULT OnWizardNext();
};

class CRemoveCertPage : public CCertContentsPage
{
	enum
	{
		IDD = IDD_PAGE_WIZ_REMOVE_CERT,
		IDD_PAGE_NEXT = IDD_PAGE_WIZ_FINAL_REMOVE,
		IDD_PAGE_PREV = IDD_PAGE_WIZ_MANAGE_CERT
	};
	DECLARE_DYNCREATE(CRemoveCertPage)

public:
	CRemoveCertPage(CCertificate * pCert = NULL)
		: CCertContentsPage(CRemoveCertPage::IDD, pCert)
	{
	}

	virtual BOOL GetCertDescription(CERT_DESCRIPTION& cd);
	virtual LRESULT OnWizardBack() {return IDD_PAGE_PREV;}
	virtual LRESULT OnWizardNext();
};

class CRequestToFilePage : public CCertContentsPage
{
	enum 
	{
		IDD = IDD_PAGE_WIZ_REQUEST_DUMP,
		IDD_PAGE_NEXT = IDD_PAGE_WIZ_FINAL_TO_FILE,
		IDD_PAGE_PREV = IDD_PAGE_WIZ_CHOOSE_FILENAME
	};
	DECLARE_DYNCREATE(CRequestToFilePage)

public:
	CRequestToFilePage(CCertificate * pCert = NULL)
		: CCertContentsPage(CRequestToFilePage::IDD, pCert)
	{
	}

	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardBack() {return IDD_PAGE_PREV;}
	virtual LRESULT OnWizardNext();
};

class COnlineRequestSubmit : public CCertContentsPage
{
	enum
	{
		IDD = IDD_PAGE_WIZ_ONLINE_DUMP,
		IDD_PAGE_NEXT = IDD_PAGE_WIZ_FINAL_INSTALL,
		IDD_PAGE_PREV = IDD_PAGE_WIZ_CHOOSE_ONLINE
	};
	DECLARE_DYNCREATE(COnlineRequestSubmit)
public:
	COnlineRequestSubmit(CCertificate * pCert = NULL)
		: CCertContentsPage(COnlineRequestSubmit::IDD, pCert)
	{
	}

	virtual BOOL GetCertDescription(CERT_DESCRIPTION& cd);
	virtual LRESULT OnWizardBack() {return IDD_PAGE_PREV;}
	virtual LRESULT OnWizardNext();
	virtual BOOL OnSetActive();
};

#endif	//_CERT_CONTENTS_PAGES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certwiz\bookendpage.h ===
//
// BookEndPage.h
//
#ifndef _BOOKENDPAGE_H
#define _BOOKENDPAGE_H

#include "Wizard.h"

class CIISWizardBookEnd2 : public CIISWizardPage
/*++

Class Description:

    Welcome / Completion Page

Public Interface:

    CIISWizardBookEnd2    : Constructor

Notes:

    The resource template is not required.  If not provided,
    a default template will be used.

    Special control IDs (on the dialog template):
    ---------------------------------------------

        IDC_STATIC_WZ_WELCOME    - Welcome text displayed in bold
        IDC_STATIC_WZ_BODY       - Body text will be placed here
        IDC_STATIC_WZ_CLICK      - Click instructions.

    The click instructions default to something sensible, and body text
    will default to the error text on a failure page and to nothing on 
    success and welcome page.  The body text may include the %h/%H 
    escape sequences for CError on a success/failure page.

--*/
{
    DECLARE_DYNCREATE(CIISWizardBookEnd2)

public:
    //
    // Constructor for success/failure completion page
    //
    CIISWizardBookEnd2(
        HRESULT * phResult,
        UINT nIDWelcomeTxtSuccess	= USE_DEFAULT_CAPTION,
        UINT nIDWelcomeTxtFailure	= USE_DEFAULT_CAPTION,
        UINT nIDCaption					= USE_DEFAULT_CAPTION,
        UINT * nIDBodyTxtSuccess		= NULL,
		  CString * pBodyTxtSuccess	= NULL,
        UINT * nIDBodyTxtFailure		= NULL,
		  CString * pBodyTxtFailure	= NULL,
        UINT nIDClickTxt				= USE_DEFAULT_CAPTION,
        UINT nIDTemplate				= 0
        );

    //
    // Constructor for a welcome page
    //
    CIISWizardBookEnd2(
        UINT nIDTemplate        = 0,
        UINT nIDCaption         = USE_DEFAULT_CAPTION,
        UINT * nIDBodyTxt       = NULL,
		  CString * pBodyTxt		  = NULL,
        UINT nIDWelcomeTxt      = USE_DEFAULT_CAPTION,
        UINT nIDClickTxt        = USE_DEFAULT_CAPTION
        );

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CIISWizardBookEnd2)
    enum { IDD = IDD_WIZARD_BOOKEND };
    //}}AFX_DATA

//
// Overrides
//
protected:
   //{{AFX_VIRTUAL(CIISWizardBookEnd)
   public:
	virtual BOOL OnSetActive();
   //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    // Generated message map functions
    //{{AFX_MSG(CPWTemplate)
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    BOOL IsWelcomePage() const {return m_phResult == NULL;}
	 BOOL IsTemplateAvailable() const {return m_bTemplateAvailable;}

private:
    HRESULT * m_phResult;
	 UINT m_nIDWelcomeTxtSuccess;
	 UINT m_nIDWelcomeTxtFailure;
	 UINT * m_pnIDBodyTxtSuccess;
	 CString * m_pBodyTxtSuccess;
	 UINT * m_pnIDBodyTxtFailure;
	 CString * m_pBodyTxtFailure;
	 UINT m_nIDClickTxt;
	 BOOL m_bTemplateAvailable;

	 CString m_strWelcome, m_strBody, m_strClick;
};

#endif	//_BOOKENDPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certwiz\certificat.cpp ===
//
// Certificat.cpp
//
#include "StdAfx.h"
#include "CertWiz.h"
#include "Certificat.h"
#include "certutil.h"
#include <malloc.h>
#include "base64.h"
#include "resource.h"
#include "certupgr.h"
#include <certca.h>
#include "mru.h"
#include "Shlwapi.h"
#include <cryptui.h>

const CLSID CLSID_CEnroll = 
	{0x43F8F289, 0x7A20, 0x11D0, {0x8F, 0x06, 0x00, 0xC0, 0x4F, 0xC2, 0x95, 0xE1}};

const IID IID_IEnroll = 
	{0xacaa7838, 0x4585, 0x11d1, {0xab, 0x57, 0x00, 0xc0, 0x4f, 0xc2, 0x95, 0xe1}};

const IID IID_ICEnroll2 = 
	{0x704ca730, 0xc90b, 0x11d1, {0x9b, 0xec, 0x00, 0xc0, 0x4f, 0xc2, 0x95, 0xe1}};
const CLSID CLSID_CCertRequest = 
	{0x98aff3f0, 0x5524, 0x11d0, {0x88, 0x12, 0x00, 0xa0, 0xc9, 0x03, 0xb8, 0x3c}};
const IID IID_ICertRequest = 
	{0x014e4840, 0x5523, 0x11d0, {0x88, 0x12, 0x00, 0xa0, 0xc9, 0x03, 0xb8, 0x3c}};

WCHAR * bstrEmpty = L"";

extern CCertWizApp theApp;

BOOL 
CCryptBlob::Resize(DWORD cb)
{
	if (cb > GetSize())
	{
		if (NULL != 
				(m_blob.pbData = Realloc(m_blob.pbData, cb)))
		{
			m_blob.cbData = cb;
			return TRUE;
		}
		return FALSE;
	}
	return TRUE;
}

IMPLEMENT_DYNAMIC(CCertificate, CObject)

CCertificate::CCertificate()
	: m_CAType(CA_OFFLINE), 
	m_KeyLength(512),
	m_pPendingRequest(NULL),
	m_RespCertContext(NULL),
	m_pInstalledCert(NULL),
	m_pKeyRingCert(NULL),
	m_pEnroll(NULL),
	m_status_code(-1),
	m_CreateDirectory(FALSE),
	m_SGCcertificat(FALSE),
   m_DefaultCSP(TRUE),
   m_DefaultProviderType(PROV_RSA_SCHANNEL)
{
}

CCertificate::~CCertificate()
{
	if (m_pPendingRequest != NULL)
		CertFreeCertificateContext(m_pPendingRequest);
	if (m_RespCertContext != NULL)
		CertFreeCertificateContext(m_RespCertContext);
	if (m_pInstalledCert != NULL)
		CertFreeCertificateContext(m_pInstalledCert);
	if (m_pKeyRingCert != NULL)
		CertFreeCertificateContext(m_pKeyRingCert);
	if (m_pEnroll != NULL)
		m_pEnroll->Release();
}

const TCHAR szResponseFileName[] = _T("ResponseFileName");
const TCHAR szKeyRingFileName[] = _T("KeyRingFileName");
const TCHAR szRequestFileName[] = _T("RequestFileName");
const TCHAR szCertificateTemplate[] = _T("CertificateTemplate");
const TCHAR szState[] = _T("State");
const TCHAR szStateMRU[] = _T("StateMRU");
const TCHAR szLocality[] = _T("Locality");
const TCHAR szLocalityMRU[] = _T("LocalityMRU");
const TCHAR szOrganization[] = _T("Organization");
const TCHAR szOrganizationMRU[] = _T("OrganizationMRU");
const TCHAR szOrganizationUnit[] = _T("OrganizationUnit");
const TCHAR szOrganizationUnitMRU[] = _T("OrganizationUnitMRU");

#define QUERY_NAME(x,y)\
	do {\
		if (ERROR_SUCCESS == RegQueryValueEx(hKey, (x), NULL, &dwType, NULL, &cbData))\
		{\
			ASSERT(dwType == REG_SZ);\
			pName = (BYTE *)(y).GetBuffer(cbData);\
			RegQueryValueEx(hKey, (x), NULL, &dwType, pName, &cbData);\
			if (pName != NULL)\
			{\
				(y).ReleaseBuffer();\
				pName = NULL;\
			}\
		}\
	} while (0)


BOOL
CCertificate::Init()
{
	ASSERT(!m_MachineName.IsEmpty());
	ASSERT(!m_WebSiteInstanceName.IsEmpty());
	// get web site description from metabase, it could be empty
	// do not panic in case of error
	if (!GetServerComment(m_MachineName, m_WebSiteInstanceName, m_FriendlyName, &m_hResult))
		m_hResult = S_OK;
	m_CommonName = m_MachineName;
	m_CommonName.MakeLower();

	HKEY hKey = theApp.RegOpenKeyWizard();
	DWORD dwType;
	DWORD cbData;
	if (hKey != NULL)
	{
		BYTE * pName = NULL;
		QUERY_NAME(szRequestFileName, m_ReqFileName);
		QUERY_NAME(szResponseFileName, m_RespFileName);
		QUERY_NAME(szKeyRingFileName, m_KeyFileName);
		QUERY_NAME(szCertificateTemplate, m_CertificateTemplate);
		QUERY_NAME(szState, m_State);
		QUERY_NAME(szLocality, m_Locality);
		QUERY_NAME(szOrganization, m_Organization);
		QUERY_NAME(szOrganizationUnit, m_OrganizationUnit);
		RegCloseKey(hKey);
	}
#ifdef _DEBUG
	else
	{
		TRACE(_T("Failed to open Registry key for Wizard parameters\n"));
	}
#endif
	if (m_CertificateTemplate.IsEmpty())
	{
		// User didn't defined anything -- use standard name
		m_CertificateTemplate = wszCERTTYPE_WEBSERVER;
	}
	return TRUE;
}

#define SAVE_NAME(x,y)\
		do {\
			if (!(y).IsEmpty())\
			{\
				VERIFY(ERROR_SUCCESS == RegSetValueEx(hKey, (x), 0, REG_SZ, \
						(const BYTE *)(LPCTSTR)(y), \
						sizeof(TCHAR) * ((y).GetLength() + 1)));\
			}\
		} while (0)

BOOL
CCertificate::SaveSettings()
{
	HKEY hKey = theApp.RegOpenKeyWizard();
	if (hKey != NULL)
	{
		switch (GetStatusCode())
		{
		case REQUEST_NEW_CERT:
		case REQUEST_RENEW_CERT:
			SAVE_NAME(szState, m_State);
			AddToMRU(szStateMRU, m_State);
			SAVE_NAME(szLocality, m_Locality);
			AddToMRU(szLocalityMRU, m_Locality);
			SAVE_NAME(szOrganization, m_Organization);
			AddToMRU(szOrganizationMRU, m_Organization);
			SAVE_NAME(szOrganizationUnit, m_OrganizationUnit);
			AddToMRU(szOrganizationUnitMRU, m_OrganizationUnit);
			SAVE_NAME(szRequestFileName, m_ReqFileName);
			break;
		case REQUEST_PROCESS_PENDING:
			SAVE_NAME(szResponseFileName, m_RespFileName);
			break;
		case REQUEST_IMPORT_KEYRING:
			SAVE_NAME(szKeyRingFileName, m_KeyFileName);
			break;
		default:
			break;
		}
		RegCloseKey(hKey);
		return TRUE;
	}
#ifdef _DEBUG
	else
	{
		TRACE(_T("Failed to open Registry key for Wizard parameters\n"));
	}
#endif
	return FALSE;
}

BOOL
CCertificate::SetSecuritySettings()
{
	long dwGenKeyFlags;
	if (SUCCEEDED(GetEnrollObject()->get_GenKeyFlags(&dwGenKeyFlags)))
	{
		dwGenKeyFlags &= 0x0000FFFF;
		dwGenKeyFlags |= (m_KeyLength << 16);
		if (m_SGCcertificat)
			dwGenKeyFlags |= CRYPT_SGCKEY;
		return (SUCCEEDED(GetEnrollObject()->put_GenKeyFlags(dwGenKeyFlags)));
	}
	return FALSE;
}

// defines taken from the old KeyGen utility
#define MESSAGE_HEADER  "-----BEGIN NEW CERTIFICATE REQUEST-----\r\n"
#define MESSAGE_TRAILER "-----END NEW CERTIFICATE REQUEST-----\r\n"

BOOL
CCertificate::WriteRequestString(CString& request)
{
	ASSERT(!PathIsRelative(m_ReqFileName));

	BOOL bRes = FALSE;
	try {
		CString strPath;

		strPath = m_ReqFileName;
		LPTSTR pPath = strPath.GetBuffer(strPath.GetLength());
		PathRemoveFileSpec(pPath);
		if (!PathIsDirectory(pPath))
		{
			if (!CreateDirectoryFromPath(strPath, NULL))
			{
				m_hResult = HRESULT_FROM_WIN32(GetLastError());
				SetBodyTextID(USE_DEFAULT_CAPTION);
				return FALSE;
			}
		}
		strPath.ReleaseBuffer();
		HANDLE hFile = ::CreateFile(m_ReqFileName,
			GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
		if (hFile != INVALID_HANDLE_VALUE)
		{
			DWORD cb = request.GetLength();
			char * ascii_buf = (char *)_alloca(cb);
			wcstombs(ascii_buf, request, cb);
			bRes = ::WriteFile(hFile, ascii_buf, cb, &cb, NULL);
			::CloseHandle(hFile);
		}
		else
		{
			m_hResult = HRESULT_FROM_WIN32(GetLastError());
			SetBodyTextID(USE_DEFAULT_CAPTION);
		}
	}
	catch (CFileException * e)
	{
		TCHAR   szCause[255];
		e->GetErrorMessage(szCause, 255);
		TRACE(_T("Got CFileException with error: %s\n"), szCause);
		m_hResult = HRESULT_FROM_WIN32(e->m_lOsError);
	}
	catch (CException * e)
	{
		TCHAR   szCause[255];
		e->GetErrorMessage(szCause, 255);
		TRACE(_T("Got CException with error: %s\n"), szCause);
		m_hResult = HRESULT_FROM_WIN32(GetLastError());
	}
	return bRes;
}

#define HEADER_SERVER_         _T("Server:\t%s\r\n\r\n")
#define HEADER_COMMON_NAME_    _T("Common-name:\t%s\r\n")
#define HEADER_FRIENDLY_NAME_  _T("Friendly name:\t%s\r\n")
#define HEADER_ORG_UNIT_       _T("Organization Unit:\t%s\r\n")
#define HEADER_ORGANIZATION_   _T("Organization:\t%s\r\n")
#define HEADER_LOCALITY_       _T("Locality:\t%s\r\n")
#define HEADER_STATE_          _T("State:\t%s\r\n")
#define HEADER_COUNTRY_        _T("Country:\t%s\r\n")

static void WRITE_LINE(CString& str, TCHAR * format, CString& data)
{
   CString buf;
   buf.Format(format, data);
	str += buf;
}

void
CCertificate::DumpHeader(CString& str)
{
	DumpOnlineHeader(str);
}

void
CCertificate::DumpOnlineHeader(CString& str)
{
	WRITE_LINE(str, HEADER_SERVER_, m_CommonName);
	WRITE_LINE(str, HEADER_FRIENDLY_NAME_, m_FriendlyName);
	WRITE_LINE(str, HEADER_ORG_UNIT_, m_OrganizationUnit);
	WRITE_LINE(str, HEADER_ORGANIZATION_, m_Organization);
	WRITE_LINE(str, HEADER_LOCALITY_, m_Locality);;
	WRITE_LINE(str, HEADER_STATE_, m_State);
	WRITE_LINE(str, HEADER_COUNTRY_, m_Country);
}

BOOL
CCertificate::GetSelectedCertDescription(CERT_DESCRIPTION& cd)
{
	BOOL bRes = FALSE;
	ASSERT(m_pSelectedCertHash != NULL);
	HCERTSTORE hStore = OpenMyStore(GetEnrollObject(), &m_hResult);
	if (hStore != NULL)
	{
		PCCERT_CONTEXT pCert = CertFindCertificateInStore(hStore,
				CRYPT_ASN_ENCODING,
				0,
				CERT_FIND_HASH,
				m_pSelectedCertHash,
				NULL);
		if (pCert != NULL)
		{
			bRes = GetCertDescription(pCert, cd);
			CertFreeCertificateContext(pCert);
		}
		CertCloseStore(hStore, 0);
	}
	return bRes;
}

void CCertificate::CreateDN(CString& str)
{
	str.Empty();
	str += _T("CN=") + m_CommonName;
	str += _T("\n,OU=") + m_OrganizationUnit;
	str += _T("\n,O=") + m_Organization;
	str += _T("\n,L=") + m_Locality;
	str += _T("\n,S=") + m_State;
	str += _T("\n,C=") + m_Country;
}

PCCERT_CONTEXT
CCertificate::GetPendingRequest()
{
	if (m_pPendingRequest == NULL)
	{
		ASSERT(!m_WebSiteInstanceName.IsEmpty());
		m_pPendingRequest = GetPendingDummyCert(m_WebSiteInstanceName, 
						GetEnrollObject(), &m_hResult);
	}
	return m_pPendingRequest;
}

PCCERT_CONTEXT
CCertificate::GetInstalledCert()
{
	if (m_pInstalledCert == NULL)
	{
		m_pInstalledCert = ::GetInstalledCert(m_MachineName,
		      m_WebSiteInstanceName,
				GetEnrollObject(),
				&m_hResult);
	}
	return m_pInstalledCert;
}

PCCERT_CONTEXT
CCertificate::GetKeyRingCert()
{
	ASSERT(!m_KeyFileName.IsEmpty());
	ASSERT(!m_KeyPassword.IsEmpty());
	if (m_pKeyRingCert == NULL)
	{
		int len = m_KeyPassword.GetLength() * 2;
		char * ascii_password = (char *)_alloca(len + 1);
		ASSERT(ascii_password != NULL);
		size_t n;
		VERIFY(-1 != (n = wcstombs(ascii_password, m_KeyPassword, len)));
		ascii_password[n] = '\0';
		m_pKeyRingCert = ::ImportKRBackupToCAPIStore(
										(LPTSTR)(LPCTSTR)m_KeyFileName,
										ascii_password,
										_T("MY"));
		if (m_pKeyRingCert == NULL)
		{
			m_hResult = HRESULT_FROM_WIN32(GetLastError());
		}
		
	}
	return m_pKeyRingCert;
}

/* INTRINSA suppress=null_pointers, uninitialized */
PCCERT_CONTEXT
CCertificate::GetResponseCert()
{
	if (m_RespCertContext == NULL)
	{
		ASSERT(!m_RespFileName.IsEmpty());
		m_RespCertContext = GetCertContextFromPKCS7File(
					m_RespFileName,
					&GetPendingRequest()->pCertInfo->SubjectPublicKeyInfo,
					&m_hResult);
		ASSERT(SUCCEEDED(m_hResult));
	}
	return m_RespCertContext;
}

BOOL 
CCertificate::GetResponseCertDescription(CERT_DESCRIPTION& cd)
{
	CERT_DESCRIPTION cdReq;
	if (GetCertDescription(GetResponseCert(), cd))
	{
		if (GetCertDescription(GetPendingRequest(), cdReq))
		{
			cd.m_FriendlyName = cdReq.m_FriendlyName;
		}
		return TRUE;
	}
	return FALSE;
}

/*------------------------------------------------------------------------------
	IsResponseInstalled

	Function checks if certificate from the response file
	m_RespFileName was istalled to some server. If possible,
	it returns name of this server in str.
	Returns FALSE if certificate is not found in MY store or
	if this store cannot be opened
*/

BOOL
CCertificate::IsResponseInstalled(
						CString& str				// return server instance name (not yet implemented)
						)
{
	BOOL bRes = FALSE;
	// get cert context from response file
	PCCERT_CONTEXT pContext = GetCertContextFromPKCS7File(
		m_RespFileName, NULL, &m_hResult);
	if (pContext != NULL)
	{
		HCERTSTORE hStore = OpenMyStore(GetEnrollObject(), &m_hResult);
		if (hStore != NULL)
		{
			PCCERT_CONTEXT pCert = NULL;
			while (NULL != (pCert = CertEnumCertificatesInStore(hStore, pCert)))
			{
				// do not include installed cert to the list
				if (CertCompareCertificate(X509_ASN_ENCODING,
								pContext->pCertInfo, pCert->pCertInfo))
				{
					bRes = TRUE;
					// Try to find, where is was installed
					break;
				}
			}
			if (pCert != NULL)
				CertFreeCertificateContext(pCert);
		}
	}
	return bRes;
}

BOOL
CCertificate::FindInstanceNameForResponse(CString& str)
{
	BOOL bRes = FALSE;
	// get cert context from response file
	PCCERT_CONTEXT pContext = GetCertContextFromPKCS7File(
		m_RespFileName, NULL, &m_hResult);
	if (pContext != NULL)
	{
		// find dummy cert in REQUEST store that has public key
		// the same as in this context
		PCCERT_CONTEXT pReq = GetReqCertByKey(GetEnrollObject(), 
			&pContext->pCertInfo->SubjectPublicKeyInfo, &m_hResult);
		if (pReq != NULL)
		{
			// get friendly name prop from this dummy cert
			if (!GetFriendlyName(pReq, str, &m_hResult))
			{
				// get instance name prop from this dummy cert
				DWORD cb;
				BYTE * prop;
				if (	CertGetCertificateContextProperty(pReq, CERTWIZ_INSTANCE_NAME_PROP_ID, NULL, &cb)
					&& (NULL != (prop = (BYTE *)_alloca(cb)))
					&& CertGetCertificateContextProperty(pReq, CERTWIZ_INSTANCE_NAME_PROP_ID, prop, &cb)
					)
				{
					// decode this instance name property
					DWORD cbData = 0;
					BYTE * data = NULL;
					if (	CryptDecodeObject(CRYPT_ASN_ENCODING, X509_UNICODE_ANY_STRING,
								prop, cb, 0, NULL, &cbData)
						&&	(NULL != (data = (BYTE *)_alloca(cbData)))
						&& CryptDecodeObject(CRYPT_ASN_ENCODING, X509_UNICODE_ANY_STRING,
								prop, cb, 0, data, &cbData)
						)
					{
						CERT_NAME_VALUE * p = (CERT_NAME_VALUE *)data;
						CString strInstanceName = (LPCTSTR)p->Value.pbData;
						// now try to get comment from this server
						if (GetServerComment(m_MachineName, strInstanceName, str, &m_hResult))
						{
							if (str.IsEmpty())
							{
								// generate something like [Web Site #n]
								str.LoadString(IDS_WEB_SITE_N);
								int len = strInstanceName.GetLength();
								for (int i = len - 1, count = 0; i >= 0; i--, count++)
								{
									if (!_istdigit(strInstanceName.GetAt(i)))
										break;
								}
								ASSERT(count < len);
								AfxFormatString1(str, IDS_WEB_SITE_N, strInstanceName.Right(count));
							}
						}
						m_hResult = S_OK;
						bRes = TRUE;
					}
				}
			}
			CertFreeCertificateContext(pReq);
		}
		else
		{
			// probably this request was deleted from the request store
		}
		CertFreeCertificateContext(pContext);
	}
	return bRes;
}

IEnroll * 
CCertificate::GetEnrollObject()
{
	if (m_pEnroll == NULL)
	{
		m_hResult = CoCreateInstance(CLSID_CEnroll,
				NULL,
				CLSCTX_INPROC_SERVER,
				IID_IEnroll,
				(void **)&m_pEnroll);
		// now we need to change defaults for this
		// object to LOCAL_MACHINE
		if (m_pEnroll != NULL)
		{
			long dwFlags;
			VERIFY(SUCCEEDED(m_pEnroll->get_MyStoreFlags(&dwFlags)));
			dwFlags &= ~CERT_SYSTEM_STORE_LOCATION_MASK;
			dwFlags |= CERT_SYSTEM_STORE_LOCAL_MACHINE;
			// following call will change Request store flags also
			VERIFY(SUCCEEDED(m_pEnroll->put_MyStoreFlags(dwFlags)));
			VERIFY(SUCCEEDED(m_pEnroll->get_GenKeyFlags(&dwFlags)));
			dwFlags |= CRYPT_EXPORTABLE;
			VERIFY(SUCCEEDED(m_pEnroll->put_GenKeyFlags(dwFlags)));
			VERIFY(SUCCEEDED(m_pEnroll->put_KeySpec(AT_KEYEXCHANGE)));
			VERIFY(SUCCEEDED(m_pEnroll->put_ProviderType(m_DefaultProviderType)));
			VERIFY(SUCCEEDED(m_pEnroll->put_DeleteRequestCert(TRUE)));
		}
	}
	ASSERT(m_pEnroll != NULL);
	return m_pEnroll;
}

BOOL
CCertificate::HasInstalledCert()
{
	BOOL bResult = FALSE;
	CMetaKey key(m_MachineName,
				METADATA_PERMISSION_READ,
				METADATA_MASTER_ROOT_HANDLE,
				m_WebSiteInstanceName);
	if (key.Succeeded())
	{
		CString store_name;
		CBlob blob;
		if (	S_OK == key.QueryValue(MD_SSL_CERT_HASH, blob)
			&& S_OK == key.QueryValue(MD_SSL_CERT_STORE_NAME, store_name)
			)
		{
			bResult = TRUE;
		}
	}
	return bResult;
}

HRESULT
CCertificate::UninstallCert()
{
	CMetaKey key(m_MachineName,
				METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
				METADATA_MASTER_ROOT_HANDLE,
				m_WebSiteInstanceName);
	if (key.Succeeded())
	{
		CString store_name;
		key.QueryValue(MD_SSL_CERT_STORE_NAME, store_name);
		if (SUCCEEDED(key.DeleteValue(MD_SSL_CERT_HASH)))
			key.DeleteValue(MD_SSL_CERT_STORE_NAME);
	}
	return m_hResult = key.QueryResult();
}

BOOL CCertificate::WriteRequestBody()
{
	ASSERT(!m_ReqFileName.IsEmpty());

	HRESULT hr;
	BOOL bRes = FALSE;
	CString strDN;
	CreateDN(strDN);
	ASSERT(!strDN.IsEmpty());
	CString strUsage(szOID_PKIX_KP_SERVER_AUTH);
	CCryptBlobIMalloc request;
   GetEnrollObject()->put_ProviderType(m_DefaultCSP ? 
      m_DefaultProviderType : m_CustomProviderType);
   if (!m_DefaultCSP)
   {
      GetEnrollObject()->put_ProviderNameWStr((LPTSTR)(LPCTSTR)m_CspName);
      GetEnrollObject()->put_KeySpec(AT_SIGNATURE);
   }
	if (SUCCEEDED(hr = GetEnrollObject()->createPKCS10WStr((LPTSTR)(LPCTSTR)strDN, 
																		(LPTSTR)(LPCTSTR)strUsage, 
																		request)))
	{
		// BASE64 encode pkcs 10
		DWORD err, cch; 
		char * psz;
		if (	(err = Base64EncodeA(request.GetData(), request.GetSize(), NULL, &cch)) == ERROR_SUCCESS     
			&&	(psz = (char *)_alloca(cch)) != NULL     
			&&	(err = Base64EncodeA(request.GetData(), request.GetSize(), psz, &cch)) == ERROR_SUCCESS 
			) 
		{
			HANDLE hFile = ::CreateFile(m_ReqFileName,
					GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
         if (hFile == NULL)
            return FALSE;

			DWORD written;
			::SetFilePointer(hFile, 0, NULL, FILE_END);
			::WriteFile(hFile, MESSAGE_HEADER, sizeof(MESSAGE_HEADER) - 1, &written, NULL);
			::WriteFile(hFile, psz, cch, &written, NULL);
			::WriteFile(hFile, MESSAGE_TRAILER, sizeof(MESSAGE_TRAILER) - 1, &written, NULL);
			::CloseHandle(hFile);

			// get back request from encoded data
			PCERT_REQUEST_INFO req_info;
			VERIFY(GetRequestInfoFromPKCS10(request, &req_info, &m_hResult));
			// find dummy cert put to request store by createPKCS10 call
			HCERTSTORE hStore = OpenRequestStore(GetEnrollObject(), &m_hResult);
			if (hStore != NULL)
			{
				PCCERT_CONTEXT pDummyCert = CertFindCertificateInStore(hStore,
															CRYPT_ASN_ENCODING,
															0,
															CERT_FIND_PUBLIC_KEY,
															(void *)&req_info->SubjectPublicKeyInfo,
															NULL);
				if (pDummyCert != NULL)
				{
					// now we need to attach web server instance name to this cert
					// encode string into data blob
					CRYPT_DATA_BLOB name;
					CERT_NAME_VALUE name_value;
					name_value.dwValueType = CERT_RDN_BMP_STRING;
					name_value.Value.cbData = 0;
					name_value.Value.pbData = (LPBYTE)(LPCTSTR)m_WebSiteInstanceName;
					{
						if (	!CryptEncodeObject(CRYPT_ASN_ENCODING, X509_UNICODE_ANY_STRING,
									&name_value, NULL, &name.cbData) 
							||	(name.pbData = (BYTE *)_alloca(name.cbData)) == NULL  
							||	!CryptEncodeObject(CRYPT_ASN_ENCODING, X509_UNICODE_ANY_STRING,
									&name_value, name.pbData, &name.cbData) 
							)
						{
							ASSERT(FALSE);
						}
						VERIFY(bRes = CertSetCertificateContextProperty(pDummyCert, 
										CERTWIZ_INSTANCE_NAME_PROP_ID, 0, &name));
					}
					// put friendly name to dummy cert -- we will reuse it later
					m_FriendlyName.ReleaseBuffer();
					AttachFriendlyName(pDummyCert, m_FriendlyName, &m_hResult);
					// we also need to put some flag to show what we are waiting for:
					//	new sertificate or renewing certificate
					CRYPT_DATA_BLOB flag;
					if (	!CryptEncodeObject(CRYPT_ASN_ENCODING, X509_INTEGER,
								&m_status_code, NULL, &flag.cbData) 
						||	(flag.pbData = (BYTE *)_alloca(flag.cbData)) == NULL  
						||	!CryptEncodeObject(CRYPT_ASN_ENCODING, X509_INTEGER,
								&m_status_code, flag.pbData, &flag.cbData) 
						)
					{
						ASSERT(FALSE);
					}
					VERIFY(bRes = CertSetCertificateContextProperty(pDummyCert, 
									CERTWIZ_REQUEST_FLAG_PROP_ID, 0, &flag));
					CertFreeCertificateContext(pDummyCert);
				}
				CertCloseStore(hStore, CERT_CLOSE_STORE_CHECK_FLAG);
			}
			LocalFree(req_info);
		}
		bRes = TRUE;
	}
	return bRes;
}

BOOL
CCertificate::InstallResponseCert()
{
	BOOL bRes = FALSE;
	CCryptBlobLocal blobRequestText;

	// Get all our data attached to dummy cert
	GetFriendlyName(GetPendingRequest(), m_FriendlyName, &m_hResult);
	ASSERT(!m_FriendlyName.IsEmpty());
	GetBlobProperty(GetPendingRequest(), 
		CERTWIZ_REQUEST_TEXT_PROP_ID, blobRequestText, &m_hResult);
	ASSERT(blobRequestText.GetSize() != 0);

	CCryptBlobLocal hash_blob;
	if (::GetHashProperty(GetResponseCert(), hash_blob, &m_hResult))
	{
		if (SUCCEEDED(m_hResult = GetEnrollObject()->acceptFilePKCS7WStr(
				(LPTSTR)(LPCTSTR)m_RespFileName))
		&& InstallCertByHash(hash_blob, m_MachineName, m_WebSiteInstanceName, 
            GetEnrollObject(), &m_hResult)
		)
		{
			// reattach friendly name and request text to installed cert
			m_FriendlyName.ReleaseBuffer();
			AttachFriendlyName(GetInstalledCert(), m_FriendlyName, &m_hResult);
			bRes = CertSetCertificateContextProperty(GetInstalledCert(), 
			   CERTWIZ_REQUEST_TEXT_PROP_ID, 0, blobRequestText);
		}
	}
	if (!bRes)
	{
		SetBodyTextID(USE_DEFAULT_CAPTION);
	}
	return bRes;
}

// We don't have initial request for KeyRing certificate, therefore we will
// not be able to renew this certificate
//
BOOL
CCertificate::InstallKeyRingCert()
{
	BOOL bRes = FALSE;

	CCryptBlobLocal hash_blob;
	if (::GetHashProperty(GetKeyRingCert(), hash_blob, &m_hResult))
	{
		HRESULT hr;
		CString name;
		::GetFriendlyName(GetKeyRingCert(), name, &hr);
		if (CRYPT_E_NOT_FOUND == hr || name.IsEmpty())
		{
			CERT_DESCRIPTION desc;
			if (GetCertDescription(GetKeyRingCert(), desc))
				bRes = AttachFriendlyName(GetKeyRingCert(), desc.m_CommonName, &hr);
		}
		ASSERT(bRes);
		bRes = InstallCertByHash(hash_blob, m_MachineName, m_WebSiteInstanceName, 
						GetEnrollObject(), &m_hResult);
	}
	if (!bRes)
	{
		SetBodyTextID(USE_DEFAULT_CAPTION);
	}
	return bRes;
}

// Instead of renewal we create new certificate based on parameters
// from the current one. After creation we install this certificate in place
// of current one and deleting the old one from store. Even if IIS has an
// opened SSL connection it should get a notification and update the certificate
// data.
//
BOOL
CCertificate::SubmitRenewalRequest()
{
   BOOL bRes = LoadRenewalData();
   if (bRes)
   {
      PCCERT_CONTEXT pCurrent = GetInstalledCert();
      m_pInstalledCert = NULL;
      if (bRes = SubmitRequest())
      {
         CertDeleteCertificateFromStore(pCurrent);
      }
   }
   return bRes;
}

BOOL CCertificate::SubmitRequest()
{
	ASSERT(!m_ConfigCA.IsEmpty());
	BOOL bRes = FALSE;
	ICertRequest * pRequest = NULL;
	if (SUCCEEDED(m_hResult = CoCreateInstance(CLSID_CCertRequest, NULL, 
					CLSCTX_INPROC_SERVER, IID_ICertRequest, (void **)&pRequest)))
	{
		CString strDN;
		CreateDN(strDN);
		BSTR request;
		if (SUCCEEDED(m_hResult = CreateRequest_Base64(
                           (BSTR)(LPCTSTR)strDN, 
									GetEnrollObject(), 
                           m_DefaultCSP ? NULL : (LPTSTR)(LPCTSTR)m_CspName,
                           m_DefaultCSP ? m_DefaultProviderType : m_CustomProviderType,
                           &request)))
		{
			ASSERT(pRequest != NULL);
			CString attrib;
			GetCertificateTemplate(attrib);
			LONG disp;
			m_hResult = pRequest->Submit(CR_IN_BASE64 | CR_IN_PKCS10,
						request, 
						(BSTR)(LPCTSTR)attrib, 
						(LPTSTR)(LPCTSTR)m_ConfigCA, 
						&disp);
#ifdef _DEBUG
			if (FAILED(m_hResult))
				TRACE(_T("Submit request returned HRESULT %x; Disposition %x\n"), 
								m_hResult, disp);
#endif
			if (SUCCEEDED(m_hResult))
			{
				if (disp == CR_DISP_ISSUED)
				{
					BSTR bstrOutCert = NULL;
					if (SUCCEEDED(m_hResult = 
							pRequest->GetCertificate(CR_OUT_BASE64 /*| CR_OUT_CHAIN */, &bstrOutCert)))
					{
						CRYPT_DATA_BLOB blob;
						blob.cbData = SysStringByteLen(bstrOutCert);
						blob.pbData = (BYTE *)bstrOutCert;
						m_hResult = GetEnrollObject()->acceptPKCS7Blob(&blob);
						if (SUCCEEDED(m_hResult))
						{
							PCCERT_CONTEXT pContext = GetCertContextFromPKCS7(blob.pbData, blob.cbData, 
																			NULL, &m_hResult);
							ASSERT(pContext != NULL);
							if (pContext != NULL)
							{
								BYTE HashBuffer[40];                // give it some extra size
								DWORD dwHashSize = sizeof(HashBuffer);
								if (CertGetCertificateContextProperty(pContext,
																			CERT_SHA1_HASH_PROP_ID,
																			(VOID *) HashBuffer,
																			&dwHashSize))
								{
									CRYPT_HASH_BLOB hash_blob = {dwHashSize, HashBuffer};
									if (!(bRes = InstallHashToMetabase(&hash_blob, 
													m_MachineName, 
													m_WebSiteInstanceName, 
													&m_hResult)))
									{
										SetBodyTextID(IDS_CERT_INSTALLATION_FAILURE);
									}
								}
								CertFreeCertificateContext(pContext);
							}
							// now put extra properties to the installed cert
							if (NULL != (pContext = GetInstalledCert()))
							{
								if (!(bRes = AttachFriendlyName(pContext, m_FriendlyName, &m_hResult)))
								{
									SetBodyTextID(IDS_CERT_INSTALLATION_FAILURE);
								}
							}
						}
						SysFreeString(bstrOutCert);
					}
				}
				else
				{
					switch (disp) 
					{
						case CR_DISP_INCOMPLETE:           
						case CR_DISP_ERROR:                
						case CR_DISP_DENIED:               
						case CR_DISP_ISSUED_OUT_OF_BAND:   
						case CR_DISP_UNDER_SUBMISSION:
							{
								BSTR bstr;
								if (SUCCEEDED(pRequest->GetDispositionMessage(&bstr)))
								{
									SetBodyTextString(CString(bstr));
									SysFreeString(bstr);
								}
								m_hResult = !S_OK;
							}
							break;
						default:                           
							SetBodyTextID(IDS_INTERNAL_ERROR);
							break;
					} 
				}
			}
			else	// !SUCCEEDED
			{
				// clear out any error IDs and strings
				// we will use default processing of m_hResult
				SetBodyTextID(USE_DEFAULT_CAPTION);
			}
			SysFreeString(request);
		}
		pRequest->Release();
	}
	return bRes;
}

BOOL 
CCertificate::PrepareRequestString(CString& request_text, CCryptBlob& request_blob)
{
	CString strDN;
	TCHAR szUsage[] = _T(szOID_PKIX_KP_SERVER_AUTH);

   if (m_status_code == REQUEST_RENEW_CERT)
   {
      if (  FALSE == LoadRenewalData()
         || FALSE == SetSecuritySettings()
         )
         return FALSE;
   }
	CreateDN(strDN);
	ASSERT(!strDN.IsEmpty());
   GetEnrollObject()->put_ProviderType(m_DefaultCSP ? 
      m_DefaultProviderType : m_CustomProviderType);
   if (!m_DefaultCSP)
   {
      GetEnrollObject()->put_ProviderNameWStr((LPTSTR)(LPCTSTR)m_CspName);
      // We are supporting only these two types of CSP, it is pretty safe to
      // have just two options, because we are using the same two types when
      // we are populating CSP selection list.
      if (m_CustomProviderType == PROV_DH_SCHANNEL)
         GetEnrollObject()->put_KeySpec(AT_SIGNATURE);
      else if (m_CustomProviderType == PROV_RSA_SCHANNEL)
         GetEnrollObject()->put_KeySpec(AT_KEYEXCHANGE);
   }
	if (FAILED(m_hResult = GetEnrollObject()->createPKCS10WStr((LPTSTR)(LPCTSTR)strDN, 
							szUsage, request_blob))
      )
	{
		SetBodyTextID(USE_DEFAULT_CAPTION);
		return FALSE;
	}

	// BASE64 encode pkcs 10
	DWORD err, cch; 
	char * psz;
	if (	ERROR_SUCCESS != (err = Base64EncodeA(request_blob.GetData(), request_blob.GetSize(), NULL, &cch))
		||	NULL == (psz = (char *)_alloca(cch+1))
		||	ERROR_SUCCESS != (err = Base64EncodeA(request_blob.GetData(), request_blob.GetSize(), psz, &cch))
		) 
	{
		return FALSE;
	}
	psz[cch] = '\0';
	request_text = MESSAGE_HEADER;
	request_text += psz;
	request_text += MESSAGE_TRAILER;

	return TRUE;
}

BOOL
CCertificate::PrepareRequest()
{
	BOOL bRes = FALSE;
	CString request_text;
	CCryptBlobIMalloc request_blob;
	if (PrepareRequestString(request_text, request_blob))
	{
		if (WriteRequestString(request_text))
		{
			CCryptBlobLocal name_blob, request_store_blob, status_blob;
			// prepare data we want to attach to dummy request
			if (	EncodeString(m_WebSiteInstanceName, name_blob, &m_hResult)
				&& EncodeInteger(m_status_code, status_blob, &m_hResult)
				)
			{
				// get back request from encoded data
            PCERT_REQUEST_INFO pReqInfo;
            bRes = GetRequestInfoFromPKCS10(request_blob, &pReqInfo, &m_hResult);
            if (bRes)
				{
					// find dummy cert put to request store by createPKCS10 call
					HCERTSTORE hStore = OpenRequestStore(GetEnrollObject(), &m_hResult);
					if (hStore != NULL)
					{
						PCCERT_CONTEXT pDummyCert = CertFindCertificateInStore(hStore,
															CRYPT_ASN_ENCODING,
															0,
															CERT_FIND_PUBLIC_KEY,
                                             (void *)&pReqInfo->SubjectPublicKeyInfo,
															NULL);
						if (pDummyCert != NULL)
						{
							if (	CertSetCertificateContextProperty(pDummyCert, 
											CERTWIZ_INSTANCE_NAME_PROP_ID, 0, name_blob)
								&&	CertSetCertificateContextProperty(pDummyCert, 
											CERTWIZ_REQUEST_FLAG_PROP_ID, 0, status_blob)
								// put friendly name to dummy cert -- we will reuse it later
								&&	AttachFriendlyName(pDummyCert, m_FriendlyName, &m_hResult)
								)
							{
								bRes = TRUE;
			               // put certificate text to the clipboard
			               if (OpenClipboard(GetFocus()))
			               {
                           size_t len = request_text.GetLength() + 1;
				               HANDLE hMem = GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE, len);
				               LPSTR pMem = (LPSTR)GlobalLock(hMem);
                           if (pMem != NULL)
                           {
                              wcstombs(pMem, request_text, len);
				                  GlobalUnlock(hMem);
				                  SetClipboardData(CF_TEXT, hMem);
                           }
				               CloseClipboard();
			               }
							}
							else
							{
								m_hResult = HRESULT_FROM_WIN32(GetLastError());
							}
							CertFreeCertificateContext(pDummyCert);
						}
						CertCloseStore(hStore, CERT_CLOSE_STORE_CHECK_FLAG);
					}
               LocalFree(pReqInfo);
				}
			}
		}
	}
   if (!bRes)
		SetBodyTextID(USE_DEFAULT_CAPTION);

	return bRes;
}

BOOL CCertificate::LoadRenewalData()
{
   // we need to obtain data from the installed cert
	CERT_DESCRIPTION desc;
	ASSERT(GetInstalledCert() != NULL);
   BOOL res = FALSE;

	if (GetCertDescription(GetInstalledCert(), desc))
   {
		m_CommonName = desc.m_CommonName;
		m_FriendlyName = desc.m_FriendlyName;
		m_Country = desc.m_Country;
		m_State = desc.m_State;
		m_Locality = desc.m_Locality;
		m_Organization = desc.m_Organization;
		m_OrganizationUnit = desc.m_OrganizationUnit;
      DWORD len = CertGetPublicKeyLength(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
         &GetInstalledCert()->pCertInfo->SubjectPublicKeyInfo);
      if (len == 0)
      {
         m_hResult = HRESULT_FROM_WIN32(GetLastError());
         goto ErrorExit;
      }
      m_KeyLength = len;

      BYTE pbData[1024];
      CRYPT_KEY_PROV_INFO * pProvInfo = (CRYPT_KEY_PROV_INFO *)pbData;
      DWORD dwData = 1000;
      if (!CertGetCertificateContextProperty(GetInstalledCert(), 
                  CERT_KEY_PROV_INFO_PROP_ID, pProvInfo, &dwData))
      {
         m_hResult = HRESULT_FROM_WIN32(GetLastError());
         goto ErrorExit;
      }
      if (pProvInfo->dwProvType != m_DefaultProviderType)
      {
         m_DefaultCSP = FALSE;
         m_CustomProviderType = pProvInfo->dwProvType;
         m_CspName = pProvInfo->pwszProvName;
      }
		CArray<LPCSTR, LPCSTR> uses;
		uses.Add(szOID_SERVER_GATED_CRYPTO);
		uses.Add(szOID_SGC_NETSCAPE);
      m_SGCcertificat = ContainsKeyUsageProperty(GetInstalledCert(), uses, &m_hResult);

      res = TRUE;
	}
ErrorExit:
   return res;
}

#if 0
BOOL
CCertificate::WriteRenewalRequest()
{
	BOOL bRes = FALSE;
	if (GetInstalledCert() != NULL)
	{
		BSTR bstrRequest;
		if (	SUCCEEDED(m_hResult = GetEnrollObject()->put_RenewalCertificate(GetInstalledCert()))
			&& SUCCEEDED(m_hResult = CreateRequest_Base64(bstrEmpty, 
                     GetEnrollObject(), 
                     m_DefaultCSP ? NULL : (LPTSTR)(LPCTSTR)m_CspName,
                     m_DefaultCSP ? m_DefaultProviderType : m_CustomProviderType,
                     &bstrRequest))
			)
		{
			CString str = MESSAGE_HEADER;
			str += bstrRequest;
			str += MESSAGE_TRAILER;
			if (WriteRequestString(str))
			{
				CCryptBlobLocal name_blob, status_blob;
				CCryptBlobIMalloc request_blob;
				request_blob.Set(SysStringLen(bstrRequest), (BYTE *)bstrRequest);
				// prepare data we want to attach to dummy request
				if (	EncodeString(m_WebSiteInstanceName, name_blob, &m_hResult)
					&& EncodeInteger(m_status_code, status_blob, &m_hResult)
					)
				{
					// get back request from encoded data
					PCERT_REQUEST_INFO req_info;
					if (GetRequestInfoFromPKCS10(request_blob, &req_info, &m_hResult))
					{
						// find dummy cert put to request store by createPKCS10 call
						HCERTSTORE hStore = OpenRequestStore(GetEnrollObject(), &m_hResult);
						if (hStore != NULL)
						{
							PCCERT_CONTEXT pDummyCert = CertFindCertificateInStore(hStore,
																	CRYPT_ASN_ENCODING,
																	0,
																	CERT_FIND_PUBLIC_KEY,
																	(void *)&req_info->SubjectPublicKeyInfo,
																	NULL);
							if (pDummyCert != NULL)
							{
								if (	CertSetCertificateContextProperty(pDummyCert, 
													CERTWIZ_INSTANCE_NAME_PROP_ID, 0, name_blob)
									&&	CertSetCertificateContextProperty(pDummyCert, 
													CERTWIZ_REQUEST_FLAG_PROP_ID, 0, status_blob)
  									// put friendly name to dummy cert -- we will reuse it later
									&&	AttachFriendlyName(pDummyCert, m_FriendlyName, &m_hResult)
									)
								{
									bRes = TRUE;
								}
								else
								{
									m_hResult = HRESULT_FROM_WIN32(GetLastError());
								}
								CertFreeCertificateContext(pDummyCert);
							}
							CertCloseStore(hStore, CERT_CLOSE_STORE_CHECK_FLAG);
						}
						LocalFree(req_info);
					}
				}
			}
		}
	}
	return bRes;
}
#endif

CCertDescList::~CCertDescList()
{
	POSITION pos = GetHeadPosition();
	while (pos != NULL)
	{
		CERT_DESCRIPTION * pDesc = GetNext(pos);
		delete pDesc;
	}
}

BOOL
CCertificate::GetCertDescription(PCCERT_CONTEXT pCert,
											CERT_DESCRIPTION& desc)
{
	BOOL bRes = FALSE;
	DWORD cb;
	UINT i, j;
	CERT_NAME_INFO * pNameInfo;

	if (pCert == NULL)
		goto ErrExit;

	if (	!CryptDecodeObject(X509_ASN_ENCODING, X509_UNICODE_NAME,
					pCert->pCertInfo->Subject.pbData,
					pCert->pCertInfo->Subject.cbData,
					0, NULL, &cb)
		||	NULL == (pNameInfo = (CERT_NAME_INFO *)_alloca(cb))
		|| !CryptDecodeObject(X509_ASN_ENCODING, X509_UNICODE_NAME,
					pCert->pCertInfo->Subject.pbData,
					pCert->pCertInfo->Subject.cbData,
					0, 
					pNameInfo, &cb)
					)
	{
		goto ErrExit;
	}

	for (i = 0; i < pNameInfo->cRDN; i++)
	{
		CERT_RDN rdn = pNameInfo->rgRDN[i];
		for (j = 0; j < rdn.cRDNAttr; j++)
		{
			CERT_RDN_ATTR attr = rdn.rgRDNAttr[j];
			if (strcmp(attr.pszObjId, szOID_COMMON_NAME) == 0)
			{
				FormatRdnAttr(desc.m_CommonName, attr.dwValueType, attr.Value);
			}
			else if (strcmp(attr.pszObjId, szOID_COUNTRY_NAME) == 0)
			{
				FormatRdnAttr(desc.m_Country, attr.dwValueType, attr.Value);
			}
			else if (strcmp(attr.pszObjId, szOID_LOCALITY_NAME) == 0)
			{
				FormatRdnAttr(desc.m_Locality, attr.dwValueType, attr.Value);
			}
			else if (strcmp(attr.pszObjId, szOID_STATE_OR_PROVINCE_NAME) == 0)
			{
				FormatRdnAttr(desc.m_State, attr.dwValueType, attr.Value);
			}
			else if (strcmp(attr.pszObjId, szOID_ORGANIZATION_NAME) == 0)
			{
				FormatRdnAttr(desc.m_Organization, attr.dwValueType, attr.Value);
			}
			else if (strcmp(attr.pszObjId, szOID_ORGANIZATIONAL_UNIT_NAME) == 0)
			{
				FormatRdnAttr(desc.m_OrganizationUnit, attr.dwValueType, attr.Value);
			}
		}
	}
	// issued to
	if (!GetNameString(pCert, CERT_NAME_SIMPLE_DISPLAY_TYPE, CERT_NAME_ISSUER_FLAG, 
								desc.m_CAName, &m_hResult))
		goto ErrExit;

	// expiration date
	if (!FormatDateString(desc.m_ExpirationDate, pCert->pCertInfo->NotAfter, FALSE, FALSE))
	{
		goto ErrExit;
	}

	// purpose
	if (!FormatEnhancedKeyUsageString(desc.m_Usage, pCert, FALSE, FALSE, &m_hResult))
	{
		// According to local experts, we should also use certs without this property set
		ASSERT(FALSE);
		//goto ErrExit;
	}

	// friendly name
	if (!GetFriendlyName(pCert, desc.m_FriendlyName, &m_hResult))
	{
		desc.m_FriendlyName.LoadString(IDS_FRIENDLYNAME_NONE);
	}

	bRes = TRUE;

ErrExit:
	return bRes;
}

int
CCertificate::MyStoreCertCount()
{
	int count = 0;
	HCERTSTORE hStore = OpenMyStore(GetEnrollObject(), &m_hResult);
	if (hStore != NULL)
	{
		PCCERT_CONTEXT pCert = NULL;
		CArray<LPCSTR, LPCSTR> uses;
		uses.Add(szOID_PKIX_KP_SERVER_AUTH);
		uses.Add(szOID_SERVER_GATED_CRYPTO);
		uses.Add(szOID_SGC_NETSCAPE);
		while (NULL != (pCert = CertEnumCertificatesInStore(hStore, pCert)))
		{
			// do not include installed cert to the list
			if (	GetInstalledCert() != NULL 
				&&	CertCompareCertificate(X509_ASN_ENCODING,
							GetInstalledCert()->pCertInfo, pCert->pCertInfo)
				)
				continue;
			if (!ContainsKeyUsageProperty(pCert, uses, &m_hResult))
			{
				continue;
			}
			count++;
		}
		if (pCert != NULL)
			CertFreeCertificateContext(pCert);
		VERIFY(CertCloseStore(hStore, 0));
	}
	return count;
}

BOOL
CCertificate::GetCertDescList(CCertDescList& list)
{
	ASSERT(list.GetCount() == 0);
	BOOL bRes = FALSE;
	// we are looking to MY store only
	HCERTSTORE hStore = OpenMyStore(GetEnrollObject(), &m_hResult);
	if (hStore != NULL)
	{
		PCCERT_CONTEXT pCert = NULL;
		// do not include certs with improper usage
		CArray<LPCSTR, LPCSTR> uses;
		uses.Add(szOID_PKIX_KP_SERVER_AUTH);
		uses.Add(szOID_SERVER_GATED_CRYPTO);
		uses.Add(szOID_SGC_NETSCAPE);
		while (NULL != (pCert = CertEnumCertificatesInStore(hStore, pCert)))
		{
			// do not include installed cert to the list
			if (	GetInstalledCert() != NULL 
				&&	CertCompareCertificate(X509_ASN_ENCODING,
							GetInstalledCert()->pCertInfo, pCert->pCertInfo)
				)
				continue;
			if (!ContainsKeyUsageProperty(pCert, uses, &m_hResult))
			{
				if (SUCCEEDED(m_hResult) || m_hResult == CRYPT_E_NOT_FOUND)
					continue;
				else
					goto ErrExit;
			}
			CERT_DESCRIPTION * pDesc = new CERT_DESCRIPTION;
			pDesc->m_hash_length = CERT_HASH_LENGTH;
			if (!GetCertDescription(pCert, *pDesc))
			{
				delete pDesc;
				if (m_hResult == CRYPT_E_NOT_FOUND)
					continue;
				goto ErrExit;
			}
			if (!CertGetCertificateContextProperty(pCert, 
										CERT_SHA1_HASH_PROP_ID, 
										(VOID *)pDesc->m_hash, 
										&pDesc->m_hash_length))
			{
				delete pDesc;
				m_hResult = HRESULT_FROM_WIN32(GetLastError());
				goto ErrExit;
			}
			list.AddTail(pDesc);
		}
		bRes = TRUE;
ErrExit:
		if (pCert != NULL)
			CertFreeCertificateContext(pCert);
		VERIFY(CertCloseStore(hStore, 0));
	}
	return bRes;
}

BOOL 
CCertificate::ReplaceInstalled()
{
	// Current cert will be left in the store for next use
	// Selected cert will be installed instead
	return InstallSelectedCert();
}

BOOL 
CCertificate::CancelRequest()
{
	// we are just removing dummy cert from the REQUEST store
	if (NULL != GetPendingRequest())
	{
		BOOL bRes = CertDeleteCertificateFromStore(GetPendingRequest());
		if (!bRes)
		{
			m_hResult = HRESULT_FROM_WIN32(GetLastError());
			SetBodyTextID(USE_DEFAULT_CAPTION);
		}
		else
			m_pPendingRequest = NULL;
		return bRes;
	}
	return FALSE;
}

BOOL 
CCertificate::InstallSelectedCert()
{
	BOOL bRes = FALSE;
	HRESULT hr;
	// local authorities required that cert should have some
	// friendly name. We will put common name when friendly name is not available
	HCERTSTORE hStore = OpenMyStore(GetEnrollObject(), &hr);
	if (hStore != NULL)
	{
		PCCERT_CONTEXT pCert = CertFindCertificateInStore(hStore, 
												X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, 
												0, CERT_FIND_HASH, 
												(LPVOID)m_pSelectedCertHash, 
												NULL);
		if (pCert != NULL)
		{
			CString name;
			::GetFriendlyName(pCert, name, &hr);
			if (CRYPT_E_NOT_FOUND == hr || name.IsEmpty())
			{
				CERT_DESCRIPTION desc;
				if (GetCertDescription(pCert, desc))
					bRes = AttachFriendlyName(pCert, desc.m_CommonName, &hr);
			}
		}
		VERIFY(CertCloseStore(hStore, 0));
	}
	ASSERT(bRes);
	// we are just rewriting current settings
	// current cert will be left in MY store
	bRes = ::InstallCertByHash(m_pSelectedCertHash,
							m_MachineName, 
							m_WebSiteInstanceName, 
							GetEnrollObject(),
							&m_hResult);
	if (!bRes)
	{
		SetBodyTextID(USE_DEFAULT_CAPTION);
	}
	return bRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certwiz\base64.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1996
//
// File:        base64.cpp
//
// Contents:    base64 encode/decode implementation
//
// History:     25-Jul-96       vich created
//
//---------------------------------------------------------------------------
//               3-Mar-98   tompop took and modified it.  Building
//                          both Ansi and Wchar versions of Encode/Decode
//                          base 64 for CertWizard, that is in IIS5's UI.
//                          We merged the examples from NT5's base64.cpp
//                          and ubase64.cpp files into this single file.
//						5-Aug-98	 Sergei Antonov removed above mentioned stuff after tompop
//---------------------------------------------------------------------------
#include "stdafx.h"
#include <malloc.h>
#include <windows.h>
#include "base64.h"

// The following table translates an ascii subset to 6 bit values as follows
// (see rfc 1521):
//
//  input    hex (decimal)
//  'A' --> 0x00 (0)
//  'B' --> 0x01 (1)
//  ...
//  'Z' --> 0x19 (25)
//  'a' --> 0x1a (26)
//  'b' --> 0x1b (27)
//  ...
//  'z' --> 0x33 (51)
//  '0' --> 0x34 (52)
//  ...
//  '9' --> 0x3d (61)
//  '+' --> 0x3e (62)
//  '/' --> 0x3f (63)
//
// Encoded lines must be no longer than 76 characters.
// The final "quantum" is handled as follows:  The translation output shall
// always consist of 4 characters.  'x', below, means a translated character,
// and '=' means an equal sign.  0, 1 or 2 equal signs padding out a four byte
// translation quantum means decoding the four bytes would result in 3, 2 or 1
// unencoded bytes, respectively.
//
//  unencoded size    encoded data
//  --------------    ------------
//     1 byte       "xx=="
//     2 bytes      "xxx="
//     3 bytes      "xxxx"

#define CB_BASE64LINEMAX    64  // others use 64 -- could be up to 76

// Any other (invalid) input character value translates to 0x40 (64)

const BYTE abDecode[256] =
{
    /* 00: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* 10: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* 20: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 62, 64, 64, 64, 63,
    /* 30: */ 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 64, 64, 64, 64, 64, 64,
    /* 40: */ 64,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
    /* 50: */ 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 64, 64, 64, 64, 64,
    /* 60: */ 64, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
    /* 70: */ 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 64, 64, 64, 64, 64,
    /* 80: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* 90: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* a0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* b0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* c0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* d0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* e0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    /* f0: */ 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
};


const UCHAR abEncode[] =
    /*  0 thru 25: */ "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    /* 26 thru 51: */ "abcdefghijklmnopqrstuvwxyz"
    /* 52 thru 61: */ "0123456789"
    /* 62 and 63: */  "+/";


DWORD
Base64DecodeA(const char * pchIn, DWORD cchIn, BYTE * pbOut, DWORD * pcbOut)
{
	DWORD err = ERROR_SUCCESS;
   DWORD cchInDecode, cbOutDecode;
   CHAR const *pchInEnd;
   CHAR const *pchInT;
   BYTE *pbOutT;

   // Count the translatable characters, skipping whitespace & CR-LF chars.
   cchInDecode = 0;
   pchInEnd = &pchIn[cchIn];
   for (pchInT = pchIn; pchInT < pchInEnd; pchInT++)
   {
		if (sizeof(abDecode) < (unsigned) *pchInT || abDecode[*pchInT] > 63)
		{
			// skip all whitespace
			if (	*pchInT == ' ' 
				||	*pchInT == '\t' 
				||	*pchInT == '\r' 
				||	*pchInT == '\n'
				)
			{
				continue;
			}

			if (0 != cchInDecode)
			{
				if ((cchInDecode % 4) == 0)
				{
					break;          // ends on quantum boundary
			}

			// The length calculation may stop in the middle of the last
			// translation quantum, because the equal sign padding
			// characters are treated as invalid input.  If the last
			// translation quantum is not 4 bytes long, it must be 2 or 3
			// bytes long.

			if (*pchInT == '=' && (cchInDecode % 4) != 1)
			{
				break;              // normal termination
			}
		}
      err = ERROR_INVALID_DATA;
      goto error;
	}
   cchInDecode++;
   }
    ASSERT(pchInT <= pchInEnd);
    pchInEnd = pchInT;      // don't process any trailing stuff again

    // We know how many translatable characters are in the input buffer, so now
    // set the output buffer size to three bytes for every four (or fraction of
    // four) input bytes.

    cbOutDecode = ((cchInDecode + 3) / 4) * 3;

    pbOutT = pbOut;

    if (NULL == pbOut)
    {
    pbOutT += cbOutDecode;
    }
    else
    {
    // Decode one quantum at a time: 4 bytes ==> 3 bytes

    ASSERT(cbOutDecode <= *pcbOut);
    pchInT = pchIn;
    while (cchInDecode > 0)
    {
        DWORD i;
        BYTE ab4[4];

        memset(ab4, 0, sizeof(ab4));
        for (i = 0; i < min(sizeof(ab4)/sizeof(ab4[0]), cchInDecode); i++)
        {
        while (
            sizeof(abDecode) > (unsigned) *pchInT &&
            63 < abDecode[*pchInT])
        {
            pchInT++;
        }
        ASSERT(pchInT < pchInEnd);
        ab4[i] = (BYTE) *pchInT++;
        }

        // Translate 4 input characters into 6 bits each, and deposit the
        // resulting 24 bits into 3 output bytes by shifting as appropriate.

        // out[0] = in[0]:in[1] 6:2
        // out[1] = in[1]:in[2] 4:4
        // out[2] = in[2]:in[3] 2:6

        *pbOutT++ =
        (BYTE) ((abDecode[ab4[0]] << 2) | (abDecode[ab4[1]] >> 4));

        if (i > 2)
        {
        *pbOutT++ =
          (BYTE) ((abDecode[ab4[1]] << 4) | (abDecode[ab4[2]] >> 2));
        }
        if (i > 3)
        {
        *pbOutT++ = (BYTE) ((abDecode[ab4[2]] << 6) | abDecode[ab4[3]]);
        }
        cchInDecode -= i;
    }
    ASSERT((DWORD) (pbOutT - pbOut) <= cbOutDecode);
    }
    *pcbOut = (DWORD)(pbOutT - pbOut);
error:
    return(err);
}

// Base64EncodeA 
//
// RETURNS  0 (i.e. ERROR_SUCCESS) on success
//


DWORD
Base64EncodeA(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    OUT CHAR *pchOut,
    OUT DWORD *pcchOut)
{
    CHAR *pchOutT;
    DWORD cchOutEncode;

    // Allocate enough memory for full final translation quantum.
    cchOutEncode = ((cbIn + 2) / 3) * 4;

    // and enough for CR-LF pairs for every CB_BASE64LINEMAX character line.
    cchOutEncode +=
		2 * ((cchOutEncode + CB_BASE64LINEMAX - 1) / CB_BASE64LINEMAX);

    pchOutT = pchOut;
	if (NULL == pchOut)
   {
		pchOutT += cchOutEncode;
   }
   else
   {
		DWORD cCol;

    ASSERT(cchOutEncode <= *pcchOut);
    cCol = 0;
    while ((long) cbIn > 0) // signed comparison -- cbIn can wrap
    {
        BYTE ab3[3];

        if (cCol == CB_BASE64LINEMAX/4)
        {
        cCol = 0;
        *pchOutT++ = '\r';
        *pchOutT++ = '\n';
        }
        cCol++;
        memset(ab3, 0, sizeof(ab3));

        ab3[0] = *pbIn++;
        if (cbIn > 1)
        {
        ab3[1] = *pbIn++;
        if (cbIn > 2)
        {
            ab3[2] = *pbIn++;
        }
        }

        *pchOutT++ = abEncode[ab3[0] >> 2];
        *pchOutT++ = abEncode[((ab3[0] << 4) | (ab3[1] >> 4)) & 0x3f];
        *pchOutT++ = (cbIn > 1)?
            abEncode[((ab3[1] << 2) | (ab3[2] >> 6)) & 0x3f] : '=';
        *pchOutT++ = (cbIn > 2)? abEncode[ab3[2] & 0x3f] : '=';

        cbIn -= 3;
    }
    *pchOutT++ = '\r';
    *pchOutT++ = '\n';
    ASSERT((DWORD) (pchOutT - pchOut) <= cchOutEncode);
    }
    *pcchOut = (DWORD)(pchOutT - pchOut);
    return(ERROR_SUCCESS);
}

// Base64EncodeW 
//
// RETURNS  0 (i.e. ERROR_SUCCESS) on success
//

DWORD Base64EncodeW(
    BYTE const *pbIn,
    DWORD cbIn,
    WCHAR *wszOut,
    DWORD *pcchOut)

{

    DWORD   cchOut;
    char   *pch = NULL;
    DWORD   cch;
    DWORD   err;

    ASSERT(pcchOut != NULL);

    // only want to know how much to allocate
    // we know all base64 char map 1-1 with unicode
    if( wszOut == NULL ) {

        // get the number of characters
        *pcchOut = 0;
        err = Base64EncodeA(
                pbIn,
                cbIn,
                NULL,
                pcchOut);
    }

    // otherwise we have an output buffer
    else {

        // char count is the same be it ascii or unicode,
        cchOut = *pcchOut;
        cch = 0;
        err = ERROR_OUTOFMEMORY;
        if( (pch = (char *) malloc(cchOut)) != NULL  &&
        
            (err = Base64EncodeA(
                pbIn,
                cbIn,
                pch,
                &cchOut)) == ERROR_SUCCESS      ) {

            // should not fail!
            cch = MultiByteToWideChar(0, 
                            0, 
                            pch, 
                            cchOut, 
                            wszOut, 
                            *pcchOut);

            // check to make sure we did not fail                            
            ASSERT(*pcchOut == 0 || cch != 0);                            
        }
    }

    if(pch != NULL)
        free(pch);

    return(err);
}

// Base64DecodeW 
//
// RETURNS  0 (i.e. ERROR_SUCCESS) on success
//

DWORD Base64DecodeW(
    const WCHAR * wszIn,
    DWORD cch,
    BYTE *pbOut,
    DWORD *pcbOut)
{

    char *pch;
    DWORD err = ERROR_SUCCESS;
    
    if( (pch = (char *) malloc(cch)) == NULL ) 
	 {
        err = ERROR_OUTOFMEMORY;
    }
    else if( WideCharToMultiByte(0, 0, wszIn, cch, pch, cch, 
                        NULL, NULL) == 0 ) 
	 {
        err = ERROR_NO_DATA;
    }
    else if( pbOut == NULL ) 
	 {
        *pcbOut = 0;
        err = Base64DecodeA(pch, cch, NULL, pcbOut);
    }
    else 
	 {
        err = Base64DecodeA(pch, cch, pbOut, pcbOut);
    }
    if(pch != NULL)
        free(pch);
    return(err);
}

#if 0
// sanity tests...  Lets make sure that the encode and decode
//                  works...

BOOL test_Base64EncodeW()
{
    BYTE  pbIn[120];            // for the test we just use the random stack data
    DWORD cbIn = sizeof( pbIn );
    
    WCHAR *wszB64Out;
    DWORD pcchB64Out;

    DWORD  err;
    
    // BASE64 encode pkcs 10
    if( (err = Base64EncodeW(
                pbIn,
                cbIn,
                NULL,
                &pcchB64Out)) != ERROR_SUCCESS     ||
        (wszB64Out = (WCHAR *) _alloca(pcchB64Out * sizeof(WCHAR))) == NULL  ||
        (err = Base64EncodeW(
                pbIn,
                cbIn,
                wszB64Out,
                &pcchB64Out)) != ERROR_SUCCESS ) 
    {
        SetLastError(err);
        return FALSE;  //goto ErrorBase64Encode;
    }


    // well the encode worked lets test the decode
    //
    // pcchB64Out holds the B64 data length
    // wszB64Out  holds the actual data

     DWORD blob_cbData;     // we store in these variables what
     BYTE* blob_pbData;     //  we read in..

    // They should match the stuff stored in:
    //    BYTE  pbIn[120];
    //    DWORD cbIn = sizeof( pbIn );
    // This we be tested after the decode.

    // base64 decode
    if( (err = Base64DecodeW(
            wszB64Out,
            pcchB64Out,
            NULL,
            &blob_cbData)) != ERROR_SUCCESS                    ||
        (blob_pbData = (BYTE *) _alloca(blob_cbData)) == NULL      ||
        (err = Base64DecodeW(
            wszB64Out,
            pcchB64Out,
            blob_pbData,
            &blob_cbData)) != ERROR_SUCCESS ) 
    {
        
        SetLastError(err);
        return(FALSE);  //goto ErrorBase64Decode;
    }



    //do compare

    
    return( (blob_cbData==cbIn)
            &&  (memcmp(blob_pbData, pbIn,cbIn)==0) );
    

 }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certwiz\certificat.h ===
//
// Certificat.h
//
#ifndef _CERTIFICAT_H
#define _CERTIFICAT_H

#include <xenroll.h>

#define CERTWIZ_INSTANCE_NAME_PROP_ID   (CERT_FIRST_USER_PROP_ID + 0x1000)
#define CERTWIZ_REQUEST_FLAG_PROP_ID   (CERT_FIRST_USER_PROP_ID + 0x1001)
#define CERTWIZ_REQUEST_TEXT_PROP_ID   (CERT_FIRST_USER_PROP_ID + 0x1002)

#define CERT_HASH_LENGTH		40
typedef struct _CERT_DESCRIPTION
{
	CString m_CommonName;
	CString m_FriendlyName;
	CString m_Country;
	CString m_State;
	CString m_Locality;
	CString m_Organization;
	CString m_OrganizationUnit;
	CString m_CAName;
	CString m_ExpirationDate;
	CString m_Usage;
	BYTE m_hash[CERT_HASH_LENGTH];
	DWORD m_hash_length;
} CERT_DESCRIPTION;

class CCertDescList : public CList<CERT_DESCRIPTION *, CERT_DESCRIPTION *&>
{
public:
	CCertDescList() {}
	~CCertDescList();
};

class CCryptBlob
{
public:
	CCryptBlob()
	{
		m_blob.cbData = 0;
		m_blob.pbData = NULL;
	}
	virtual ~CCryptBlob()
	{
	}
	DWORD GetSize() {return m_blob.cbData;}
	BYTE * GetData() {return m_blob.pbData;}
	void Set(DWORD cb, BYTE * pb)
	{
		Destroy();
		m_blob.cbData = cb;
		m_blob.pbData = pb;
	}
	BOOL Resize(DWORD cb);
	operator CRYPT_DATA_BLOB *()
	{
		return &m_blob;
	}

protected:
	void Destroy()
	{
		if (m_blob.pbData != NULL)
			Free(m_blob.pbData);
	}
	virtual BYTE * Realloc(BYTE * pb, DWORD cb) = 0;
	virtual void Free(BYTE * pb) = 0;
	CRYPT_DATA_BLOB m_blob;
};

class CCryptBlobIMalloc : public CCryptBlob
{
public:
	virtual ~CCryptBlobIMalloc()
	{
		CCryptBlob::Destroy();
	}

protected:
	virtual BYTE * Realloc(BYTE * pb, DWORD cb)
	{
		return (BYTE *)CoTaskMemRealloc(pb, cb);
	}
	virtual void Free(BYTE * pb)
	{
		CoTaskMemFree(pb);
	}
};

class CCryptBlobLocal : public CCryptBlob
{
public:
	virtual ~CCryptBlobLocal()
	{
		CCryptBlob::Destroy();
	}

protected:
	virtual BYTE * Realloc(BYTE * pb, DWORD cb)
	{
		return (BYTE *)realloc(pb, cb);
	}
	virtual void Free(BYTE * pb)
	{
		free(pb);
	}
};

extern const TCHAR szState[];
extern const TCHAR szStateMRU[];
extern const TCHAR szLocality[];
extern const TCHAR szLocalityMRU[];
extern const TCHAR szOrganization[];
extern const TCHAR szOrganizationMRU[];
extern const TCHAR szOrganizationUnit[];
extern const TCHAR szOrganizationUnitMRU[];

class CCertificate : public CObject
{
	DECLARE_DYNCREATE(CCertificate)
public:
	CCertificate();
	~CCertificate();

	enum
	{
		CA_OFFLINE = 0,
		CA_ONLINE = 1
	};
	enum
	{
		REQUEST_UNDEFINED,
		REQUEST_NEW_CERT,				// if we generating fresh new certificate
		REQUEST_RENEW_CERT,			// if we generating cert for renewal
		REQUEST_REPLACE_CERT,		// replace currect cert by someone from MY store
		REQUEST_INSTALL_CERT,		// get existing certificate for empty web server
		REQUEST_PROCESS_PENDING,	// accept and install response from CA
		REQUEST_IMPORT_KEYRING,
		STATUS_CODE_LAST
	};
	enum
	{
		USE_ERROR_STRING_PARAM = -2,
		USE_ERROR_STRING_ID = -1,
		USE_ERROR_STRING_DEFAULT = USE_DEFAULT_CAPTION
	};
	BOOL Init();
	BOOL SaveSettings();
	BOOL SetSecuritySettings();
	BOOL WriteRequest();
	BOOL PrepareRequest();
	BOOL PrepareRequestString(CString& request_text, CCryptBlob& request_blob);
	BOOL WriteRequestString(CString& request);
	BOOL SubmitRequest();
	BOOL SubmitRenewalRequest();
	BOOL WriteRenewalRequest();
	void DumpHeader(CString& str);
	void DumpOnlineHeader(CString& str);
	BOOL GetSelectedCertDescription(CERT_DESCRIPTION& cd);
	BOOL GetKeyCertDescription(CERT_DESCRIPTION& cd)
	{
		return GetCertDescription(GetKeyRingCert(), cd);
	}
	BOOL GetInstalledCertDescription(CERT_DESCRIPTION& cd)
	{
		return GetCertDescription(GetInstalledCert(), cd);
	}
	BOOL GetResponseCertDescription(CERT_DESCRIPTION& cd);
	BOOL HasPendingRequest()
	{
		return (NULL != GetPendingRequest());
	}
	BOOL HasInstalledCert();
	BOOL InstallResponseCert();
	HRESULT UninstallCert();
	BOOL InstallSelectedCert();
	BOOL InstallKeyRingCert();
	BOOL ReplaceInstalled();
	BOOL CancelRequest();
	PCCERT_CONTEXT GetPendingRequest();
	PCCERT_CONTEXT GetResponseCert();
	PCCERT_CONTEXT GetInstalledCert();
	PCCERT_CONTEXT GetKeyRingCert();
	void DeleteKeyRingCert()
	{
		if (m_pKeyRingCert != NULL)
		{
			CertFreeCertificateContext(m_pKeyRingCert);
			m_pKeyRingCert = NULL;
		}
	}
	IEnroll * GetEnrollObject();
	int GetStatusCode() 
	{
		return m_status_code;
	}
	void SetStatusCode(int code) 
	{
		ASSERT(code >= 0 && code < STATUS_CODE_LAST);
		m_status_code = code;
	}
	BOOL FindInstanceNameForResponse(CString& str);
	BOOL IsResponseInstalled(CString& str);
	BOOL GetCertDescList(CCertDescList& list);
	BOOL LoadRenewalData();
	int MyStoreCertCount();

	void SetBodyTextID(int nID)
	{
		m_idErrorText = nID;
		m_strErrorText.Empty();
	}
	void SetBodyTextString(const CString& str)
	{
		m_strErrorText = str;
		m_idErrorText = USE_ERROR_STRING_PARAM;
	}
	void GetCertificateTemplate(CString& str)
	{
		str = _T("CertificateTemplate:");
		str += m_CertificateTemplate;
	}

protected:
	void CreateDN(CString& str);
	BOOL WriteHeader();
	BOOL WriteRequestBody();
	BOOL GetCertDescription(PCCERT_CONTEXT pCert,
									CERT_DESCRIPTION& desc);

public:
	int		m_CAType;
	CString	m_ConfigCA;
	CString	m_CertificateTemplate;

	CString	m_FriendlyName;
	int		m_KeyLength;
	CString	m_CommonName;
	CString	m_OrganizationUnit;
	CString	m_Organization;
	CString	m_Locality;
	CString	m_State;
	CString	m_Country;

	CStringList m_OnlineCAList;
	CString	m_MachineName;
	CString	m_WebSiteInstanceName;
	CString	m_ReqFileName;
	CString	m_RespFileName;
	CString	m_KeyFileName;
	CString	m_KeyPassword;
   BOOL     m_DefaultCSP;
   DWORD    m_DefaultProviderType;
   DWORD    m_CustomProviderType;
   CString  m_CspName;
	CRYPT_HASH_BLOB * m_pSelectedCertHash;

	UINT		m_idErrorText;
	CString	m_strErrorText;
	CString  m_strRenewalRequest;
	HRESULT	m_hResult;

	BOOL m_CreateDirectory;
	BOOL m_SGCcertificat;

protected:
	PCCERT_CONTEXT m_pPendingRequest;
	PCCERT_CONTEXT m_RespCertContext;
	PCCERT_CONTEXT m_pInstalledCert;
	PCCERT_CONTEXT m_pKeyRingCert;
	IEnroll * m_pEnroll;
	int m_status_code;				// what we are doing in this session
};

#endif	// _CERTIFICAT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certwiz\certwiz.h ===
#if !defined(AFX_CERTWIZ_H__D4BE8638_0C85_11D2_91B1_00C04F8C8761__INCLUDED_)
#define AFX_CERTWIZ_H__D4BE8638_0C85_11D2_91B1_00C04F8C8761__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// CertWiz.h : main header file for CERTWIZ.DLL

#if !defined( __AFXCTL_H__ )
	#error include 'afxctl.h' before including this file
#endif

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CCertWizApp : See CertWiz.cpp for implementation.

class CCertWizApp : public COleControlModule
{
public:
	BOOL InitInstance();
	int ExitInstance();
	HKEY RegOpenKeyWizard();
	void GetRegistryPath(CString& str);
};

// Implemented in orginfopage.cpp
void DDV_MaxCharsCombo(CDataExchange* pDX, UINT ControlID, CString const& value, int nChars);

extern const GUID CDECL _tlid;
extern const WORD _wVerMajor;
extern const WORD _wVerMinor;

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CERTWIZ_H__D4BE8638_0C85_11D2_91B1_00C04F8C8761__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certwiz\certcontentspages.cpp ===
//
// CertContentsPages.cpp
//
#include "stdafx.h"
#include "resource.h"
#include "CertContentsPages.h"
#include "Certificat.h"
#include "CertUtil.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

////////////////////// Local helper functions ////////////////////////
static void
AppendField(CString& str, UINT id, const CString& text)
{
	CString strName;
	if (!text.IsEmpty())
	{
		if (strName.LoadString(id))
		{
			str += strName;
			str += _T("\t");
			str += text;
			str += _T("\r\n");
		}
	}
}

static void 
FormatCertDescription(CERT_DESCRIPTION& desc, CString& str)
{
	AppendField(str, IDS_ISSUED_TO, desc.m_CommonName);
	AppendField(str, IDS_ISSUED_BY, desc.m_CAName);
	AppendField(str, IDS_EXPIRATION_DATE, desc.m_ExpirationDate);
	AppendField(str, IDS_PURPOSE, desc.m_Usage);
	AppendField(str, IDS_FRIENDLY_NAME, desc.m_FriendlyName);
	AppendField(str, IDS_COUNTRY, desc.m_Country);
	AppendField(str, IDS_STATE, desc.m_State);
	AppendField(str, IDS_LOCALITY, desc.m_Locality);
	AppendField(str, IDS_ORGANIZATION, desc.m_Organization);
	AppendField(str, IDS_ORGANIZATION_UNIT, desc.m_OrganizationUnit);
}

#if 0
static void
FormatCertContactInfo(CCertificate * pCert, CString& str)
{
	AppendField(str, IDS_CONTACT_NAME, pCert->m_ContactName);
	AppendField(str, IDS_CONTACT_ADDRESS, pCert->m_ContactAddress);
	CString strPhone = pCert->m_ContactPhone;
	if (!pCert->m_ContactPhoneExt.IsEmpty())
	{
		strPhone += _T("x");
		strPhone += pCert->m_ContactPhoneExt;
	}
	AppendField(str, IDS_CONTACT_PHONE, strPhone);
}
#endif

static BOOL
ExtractDescription(CCertificate * pCert, CERT_DESCRIPTION& cd)
{
	ASSERT(pCert != NULL);
	cd.m_CommonName = pCert->m_CommonName;
	cd.m_FriendlyName = pCert->m_FriendlyName;
	cd.m_Country = pCert->m_Country;
	cd.m_State = pCert->m_State;
	cd.m_Locality = pCert->m_Locality;
	cd.m_Organization = pCert->m_Organization;
	cd.m_OrganizationUnit = pCert->m_OrganizationUnit;
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CCertContentsPage base property page

IMPLEMENT_DYNCREATE(CCertContentsPage, CIISWizardPage)

CCertContentsPage::CCertContentsPage(UINT id, CCertificate * pCert) 
	: CIISWizardPage(id, IDS_CERTWIZ, TRUE),
	m_pCert(pCert)
{
	ASSERT(id != 0);
}

CCertContentsPage::~CCertContentsPage()
{
}

void CCertContentsPage::DoDataExchange(CDataExchange* pDX)
{
	CIISWizardPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CCertContentsPage)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CCertContentsPage, CIISWizardPage)
	//{{AFX_MSG_MAP(CCertContentsPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

// OnSetActive we format cert contents and put it to edit
// control with predefined ID. We should do it here, because
// if user will get back and reselect certificate, text should 
// also be changed
//
BOOL
CCertContentsPage::OnSetActive()
{
	CERT_DESCRIPTION cd;
	if (CIISWizardPage::OnSetActive())
	{
		// If page defines GetCertDescription() then it want this
		// data to be displayed
		if (GetCertDescription(cd))
		{
			ASSERT(NULL != GetDlgItem(IDC_CERT_CONTENTS));
			CString str;
			FormatCertDescription(cd, str);
			GetDlgItem(IDC_CERT_CONTENTS)->SetWindowText(str);
		}
		return TRUE;
	}
	return FALSE;
}

BOOL CCertContentsPage::OnInitDialog() 
{
	ASSERT(m_pCert != NULL);
	CIISWizardPage::OnInitDialog();
	ASSERT(NULL != GetDlgItem(IDC_CERT_CONTENTS));
	CEdit * pEdit = (CEdit *)CWnd::FromHandle(GetDlgItem(IDC_CERT_CONTENTS)->m_hWnd);
	CRect rcEdit;
	pEdit->GetClientRect(&rcEdit);
	int baseunitX = LOWORD(GetDialogBaseUnits());
	int width_units = MulDiv(rcEdit.Width(), 4, baseunitX);
	pEdit->SetTabStops(MulDiv(45, width_units, 100));
	return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////////
// CInstallCertPage

IMPLEMENT_DYNCREATE(CInstallCertPage, CCertContentsPage)

BOOL 
CInstallCertPage::GetCertDescription(CERT_DESCRIPTION& cd)
{
	return GetCertificate()->GetSelectedCertDescription(cd);
}

LRESULT
CInstallCertPage::OnWizardNext()
{
	GetCertificate()->InstallSelectedCert();
	return IDD_PAGE_NEXT;
}

////////////////////////////////////////////////////////////////////////////////////////
// CReplaceCertPage

IMPLEMENT_DYNCREATE(CReplaceCertPage, CCertContentsPage)

BOOL 
CReplaceCertPage::GetCertDescription(CERT_DESCRIPTION& cd)
{
	return GetCertificate()->GetSelectedCertDescription(cd);
}

LRESULT
CReplaceCertPage::OnWizardNext()
{
	GetCertificate()->InstallSelectedCert();
	return IDD_PAGE_NEXT;
}

////////////////////////////////////////////////////////////////////////////////////////
// CInstallKeyPage

IMPLEMENT_DYNCREATE(CInstallKeyPage, CCertContentsPage)

BOOL
CInstallKeyPage::OnSetActive()
{
	ASSERT(NULL != GetDlgItem(IDC_CERT_CONTENTS));
	ASSERT(NULL != GetDlgItem(IDC_FILE_NAME));
	if (CCertContentsPage::OnSetActive())
	{
		CString strPath = GetCertificate()->m_KeyFileName;
		CompactPathToWidth(GetDlgItem(IDC_FILE_NAME), strPath);
		SetDlgItemText(IDC_FILE_NAME, strPath);
		return TRUE;
	}
	return FALSE;
}

BOOL 
CInstallKeyPage::GetCertDescription(CERT_DESCRIPTION& cd)
{
	return GetCertificate()->GetKeyCertDescription(cd);
}

LRESULT
CInstallKeyPage::OnWizardNext()
{
	GetCertificate()->InstallKeyRingCert();
	return IDD_PAGE_NEXT;
}

////////////////////////////////////////////////////////////////////////////////////////
// CInstallRespPage

IMPLEMENT_DYNCREATE(CInstallRespPage, CCertContentsPage)

BOOL
CInstallRespPage::OnSetActive()
{
	ASSERT(NULL != GetDlgItem(IDC_CERT_CONTENTS));
	ASSERT(NULL != GetDlgItem(IDC_FILE_NAME));
	if (CCertContentsPage::OnSetActive())
	{
		CString strPath = GetCertificate()->m_RespFileName;
		CompactPathToWidth(GetDlgItem(IDC_FILE_NAME), strPath);
		SetDlgItemText(IDC_FILE_NAME, strPath);
		return TRUE;
	}
	return FALSE;
}

BOOL 
CInstallRespPage::GetCertDescription(CERT_DESCRIPTION& cd)
{
	return GetCertificate()->GetResponseCertDescription(cd);
}

LRESULT
CInstallRespPage::OnWizardNext()
{
	GetCertificate()->InstallResponseCert();
	return IDD_PAGE_NEXT;
}

////////////////////////////////////////////////////////////////////////////////////////
// CRemoveCertPage

IMPLEMENT_DYNCREATE(CRemoveCertPage, CCertContentsPage)

BOOL 
CRemoveCertPage::GetCertDescription(CERT_DESCRIPTION& cd)
{
	CCertificate * pCert = GetCertificate();
	ASSERT(NULL != pCert);
	return pCert->GetInstalledCertDescription(cd);
}

LRESULT
CRemoveCertPage::OnWizardNext()
{
	CCertificate * pCert = GetCertificate();
	ASSERT(NULL != pCert);
	if (	FAILED(pCert->UninstallCert())
		||	FAILED(ShutdownSSL(pCert->m_MachineName, pCert->m_WebSiteInstanceName))
		)
		GetCertificate()->SetBodyTextID(IDS_REMOVE_CERT_FAILED);
	return IDD_PAGE_NEXT;
}

////////////////////////////////////////////////////////////////////////////////////////
// CRequestCancelPage

IMPLEMENT_DYNCREATE(CRequestCancelPage, CCertContentsPage)

//
// In this case we should get request from the dummy cert in REQUEST store,
// because we dropping request without any connection to response.
//
BOOL 
CRequestCancelPage::GetCertDescription(CERT_DESCRIPTION& cd)
{
	return FALSE;
}

LRESULT
CRequestCancelPage::OnWizardNext()
{
	GetCertificate()->CancelRequest();
	return IDD_PAGE_NEXT;
}

/////////////////////////////////////////////////////////////////////////////
// CRequestToFilePage property page

IMPLEMENT_DYNCREATE(CRequestToFilePage, CCertContentsPage)

// This page prepares and shows contents itself
// We should format contact info first, then description
// default method could do only description
//
BOOL CRequestToFilePage::OnSetActive() 
{
	if (CCertContentsPage::OnSetActive())
	{
		ASSERT(GetCertificate() != NULL);
		ASSERT(GetDlgItem(IDC_CERT_CONTENTS) != NULL);
		ASSERT(GetDlgItem(IDC_FILE_NAME) != NULL);

		if (GetCertificate()->GetStatusCode() == CCertificate::REQUEST_RENEW_CERT)
		{
			GetCertificate()->LoadRenewalData();
		}
		
		CString str;
//		FormatCertContactInfo(m_pCert, str);

		CERT_DESCRIPTION cd;
		ExtractDescription(GetCertificate(), cd);
		FormatCertDescription(cd, str);
		
		SetDlgItemText(IDC_CERT_CONTENTS, str);
		
		CString strPath = m_pCert->m_ReqFileName;
		CompactPathToWidth(GetDlgItem(IDC_FILE_NAME), strPath);
		SetDlgItemText(IDC_FILE_NAME, strPath);

		return TRUE;
	}
	return FALSE;
}

LRESULT CRequestToFilePage::OnWizardNext() 
{
	GetCertificate()->PrepareRequest();
	return IDD_PAGE_NEXT;
}

/////////////////////////////////////////////////////////////////////////////
// COnlineRequestSubmit property page

IMPLEMENT_DYNCREATE(COnlineRequestSubmit, CCertContentsPage)

BOOL 
COnlineRequestSubmit::GetCertDescription(CERT_DESCRIPTION& cd)
{
	// we have all data in CCertificate
	return ExtractDescription(GetCertificate(), cd);
}

LRESULT COnlineRequestSubmit::OnWizardNext() 
{
	LRESULT id = IDD_PAGE_NEXT;
	BeginWaitCursor();
	if (GetCertificate()->GetStatusCode() == CCertificate::REQUEST_RENEW_CERT)
		GetCertificate()->SubmitRenewalRequest();
	else if (m_pCert->GetStatusCode() == CCertificate::REQUEST_NEW_CERT)
		GetCertificate()->SubmitRequest();
	else
		id = 1;
	EndWaitCursor();
	return id;
}

BOOL COnlineRequestSubmit::OnSetActive() 
{
	ASSERT(GetCertificate() != NULL);
	ASSERT(GetDlgItem(IDC_CA_NAME) != NULL);
	if (CCertContentsPage::OnSetActive())
	{
		SetDlgItemText(IDC_CA_NAME, GetCertificate()->m_ConfigCA);
		return TRUE;
	}
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certwiz\certutil.cpp ===
//
// CertUtil.cpp
//
#include "StdAfx.h"
#include "CertUtil.h"
#include "base64.h"
#include <malloc.h>
#include "Certificat.h"
#include <wincrypt.h>
#include "Resource.h"
#include "Shlwapi.h"
#include "CertCA.h"

const CLSID CLSID_CCertConfig =
	{0x372fce38, 0x4324, 0x11d0, {0x88, 0x10, 0x00, 0xa0, 0xc9, 0x03, 0xb8, 0x3c}};

const GUID IID_ICertConfig = 
	{0x372fce34, 0x4324, 0x11d0, {0x88, 0x10, 0x00, 0xa0, 0xc9, 0x03, 0xb8, 0x3c}};

#define	CRYPTUI_MAX_STRING_SIZE		768
#define  ARRAYSIZE(x)\
	(sizeof(x)/sizeof(x[0]))

BOOL
GetOnlineCAList(CStringList& list, const CString& certType, HRESULT * phRes)
{
	BOOL bRes = TRUE;
   HRESULT hr = S_OK;
   DWORD errBefore = GetLastError();
   DWORD dwCACount = 0;

   HCAINFO hCurCAInfo = NULL;
   HCAINFO hPreCAInfo = NULL;
   
   if (certType.IsEmpty())
		return FALSE;

   *phRes = CAFindByCertType(certType, NULL, 0, &hCurCAInfo);
   if (FAILED(*phRes) || NULL == hCurCAInfo)
   {
		if (S_OK == hr)
         hr=E_FAIL;   
		return FALSE;
   }

   //get the CA count
   if (0 == (dwCACount = CACountCAs(hCurCAInfo)))
   {
      *phRes = E_FAIL;
		return FALSE;
   }
	WCHAR ** ppwstrName, ** ppwstrMachine;
   while (hCurCAInfo)
   {
		//get the CA information
      if (	SUCCEEDED(CAGetCAProperty(hCurCAInfo, CA_PROP_DISPLAY_NAME, &ppwstrName))
			&& SUCCEEDED(CAGetCAProperty(hCurCAInfo, CA_PROP_DNSNAME, &ppwstrMachine))
			)
      {
			CString config;
			config = *ppwstrMachine;
			config += L"\\";
			config += *ppwstrName;
			list.AddTail(config);
			CAFreeCAProperty(hCurCAInfo, ppwstrName);
			CAFreeCAProperty(hCurCAInfo, ppwstrMachine);
      }
		else
		{
			bRes = FALSE;
			break;
		}

      hPreCAInfo = hCurCAInfo;
		if (FAILED(*phRes = CAEnumNextCA(hPreCAInfo, &hCurCAInfo)))
		{
			bRes = FALSE;
			break;
		}
      CACloseCA(hPreCAInfo);
	  hPreCAInfo = NULL;
   }
   
   if (hPreCAInfo)
      CACloseCA(hPreCAInfo);
   if (hCurCAInfo)
      CACloseCA(hCurCAInfo);

   SetLastError(errBefore);

	return bRes;
}

PCCERT_CONTEXT
GetRequestContext(CCryptBlob& pkcs7, HRESULT * phRes)
{
	ASSERT(phRes != NULL);
	BOOL bRes = FALSE;
   HCERTSTORE hStoreMsg = NULL;
   PCCERT_CONTEXT pCertContextMsg = NULL;

   if (!CryptQueryObject(CERT_QUERY_OBJECT_BLOB,
            (PCERT_BLOB)pkcs7,
            (CERT_QUERY_CONTENT_FLAG_CERT |
            CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED |
            CERT_QUERY_CONTENT_FLAG_SERIALIZED_STORE |
            CERT_QUERY_CONTENT_FLAG_PKCS7_UNSIGNED) ,
            CERT_QUERY_FORMAT_FLAG_ALL,
            0,
            NULL,
            NULL,
            NULL,
            &hStoreMsg,
            NULL,
            NULL)
      || NULL == (pCertContextMsg = CertFindCertificateInStore(
            hStoreMsg,
            X509_ASN_ENCODING,
            0,
            CERT_FIND_ANY,
            NULL,
            NULL)) 
      )
   {
		*phRes = HRESULT_FROM_WIN32(GetLastError());
   }
   return pCertContextMsg;
}


BOOL GetRequestInfoFromPKCS10(CCryptBlob& pkcs10, 
										PCERT_REQUEST_INFO * pReqInfo,
										HRESULT * phRes)
{
	ASSERT(pReqInfo != NULL);
	ASSERT(phRes != NULL);
	BOOL bRes = FALSE;
	DWORD req_info_size;
	if (!(bRes = CryptDecodeObjectEx(
							X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, 
							X509_CERT_REQUEST_TO_BE_SIGNED,
							pkcs10.GetData(), 
							pkcs10.GetSize(), 
							CRYPT_DECODE_ALLOC_FLAG,
							NULL,
							pReqInfo, 
							&req_info_size)))
	{
		TRACE(_T("Error from CryptDecodeObjectEx: %xd\n"), GetLastError());
		*phRes = HRESULT_FROM_WIN32(GetLastError());
	}
	return bRes;
}

#if 0
// This function extracts data from pkcs7 format
BOOL GetRequestInfoFromRenewalRequest(CCryptBlob& renewal_req,
                              PCCERT_CONTEXT * pSignerCert,
                              HCERTSTORE hStore,
										PCERT_REQUEST_INFO * pReqInfo,
										HRESULT * phRes)
{
   BOOL bRes;
   CRYPT_DECRYPT_MESSAGE_PARA decr_para;
   CRYPT_VERIFY_MESSAGE_PARA ver_para;

   decr_para.cbSize = sizeof(decr_para);
   decr_para.dwMsgAndCertEncodingType = X509_ASN_ENCODING | PKCS_7_ASN_ENCODING;
   decr_para.cCertStore = 1;
   decr_para.rghCertStore = &hStore;

   ver_para.cbSize = sizeof(ver_para);
   ver_para.dwMsgAndCertEncodingType = X509_ASN_ENCODING | PKCS_7_ASN_ENCODING;
   ver_para.hCryptProv = 0;
   ver_para.pfnGetSignerCertificate = NULL;
   ver_para.pvGetArg = NULL;

   DWORD dwMsgType;
   DWORD dwInnerContentType;
   DWORD cbDecoded;

   if (bRes = CryptDecodeMessage(
                  CMSG_SIGNED_FLAG,
                  &decr_para,
                  &ver_para,
                  0,
                  renewal_req.GetData(),
                  renewal_req.GetSize(),
                  0,
                  &dwMsgType,
                  &dwInnerContentType,
                  NULL,
                  &cbDecoded,
                  NULL,
                  pSignerCert))
   {
      CCryptBlobLocal decoded_req;
      decoded_req.Resize(cbDecoded);
      if (bRes = CryptDecodeMessage(
                  CMSG_SIGNED_FLAG,
                  &decr_para,
                  &ver_para,
                  0,
                  renewal_req.GetData(),
                  renewal_req.GetSize(),
                  0,
                  &dwMsgType,
                  &dwInnerContentType,
                  decoded_req.GetData(),
                  &cbDecoded,
                  NULL,
                  pSignerCert))
      {
         bRes = GetRequestInfoFromPKCS10(decoded_req,
                  pReqInfo, phRes);
      }
   }
   if (!bRes)
   {
	   *phRes = HRESULT_FROM_WIN32(GetLastError());
   }
   return bRes;
}
#endif

HCERTSTORE
OpenRequestStore(IEnroll * pEnroll, HRESULT * phResult)
{
	ASSERT(NULL != phResult);
	HCERTSTORE hStore = NULL;
	WCHAR * bstrStoreName, * bstrStoreType;
	long dwStoreFlags;
	VERIFY(SUCCEEDED(pEnroll->get_RequestStoreNameWStr(&bstrStoreName)));
	VERIFY(SUCCEEDED(pEnroll->get_RequestStoreTypeWStr(&bstrStoreType)));
	VERIFY(SUCCEEDED(pEnroll->get_RequestStoreFlags(&dwStoreFlags)));
	size_t store_type_len = _tcslen(bstrStoreType);
	char * szStoreProvider = (char *)_alloca(store_type_len + 1);
	ASSERT(szStoreProvider != NULL);
	size_t n = wcstombs(szStoreProvider, bstrStoreType, store_type_len);
	szStoreProvider[n] = '\0';
	hStore = CertOpenStore(
		szStoreProvider,
      PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
		NULL,
		dwStoreFlags,
		bstrStoreName
		);
	CoTaskMemFree(bstrStoreName);
	CoTaskMemFree(bstrStoreType);
	if (hStore == NULL)
		*phResult = HRESULT_FROM_WIN32(GetLastError());
	return hStore;
}

HCERTSTORE
OpenMyStore(IEnroll * pEnroll, HRESULT * phResult)
{
	ASSERT(NULL != phResult);
	HCERTSTORE hStore = NULL;
	BSTR bstrStoreName, bstrStoreType;
	long dwStoreFlags;
	VERIFY(SUCCEEDED(pEnroll->get_MyStoreNameWStr(&bstrStoreName)));
	VERIFY(SUCCEEDED(pEnroll->get_MyStoreTypeWStr(&bstrStoreType)));
	VERIFY(SUCCEEDED(pEnroll->get_MyStoreFlags(&dwStoreFlags)));
	size_t store_type_len = _tcslen(bstrStoreType);
	char * szStoreProvider = (char *)_alloca(store_type_len + 1);
	ASSERT(szStoreProvider != NULL);
	size_t n = wcstombs(szStoreProvider, bstrStoreType, store_type_len);
	ASSERT(n != -1);
	// this converter doesn't set zero byte!!!
	szStoreProvider[n] = '\0';
	hStore = CertOpenStore(
		szStoreProvider,
      PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
		NULL,
		dwStoreFlags,
		bstrStoreName
		);
	CoTaskMemFree(bstrStoreName);
	CoTaskMemFree(bstrStoreType);
	if (hStore == NULL)
		*phResult = HRESULT_FROM_WIN32(GetLastError());
	return hStore;
}

BOOL
GetStringProperty(PCCERT_CONTEXT pCertContext,
						DWORD propId,
						CString& str,
						HRESULT * phRes)
{
	BOOL bRes = FALSE;
	DWORD cb;
	BYTE * prop;
	// compare property value
	if (	CertGetCertificateContextProperty(pCertContext, propId, NULL, &cb)
		&& (NULL != (prop = (BYTE *)_alloca(cb)))
		&& CertGetCertificateContextProperty(pCertContext, propId, prop, &cb)
		)
	{
		// decode this instance name property
		DWORD cbData = 0;
		void * pData = NULL;
		if (	CryptDecodeObject(CRYPT_ASN_ENCODING, X509_UNICODE_ANY_STRING,
							prop, cb, 0, NULL, &cbData)
			&&	NULL != (pData = _alloca(cbData))
			&& CryptDecodeObject(CRYPT_ASN_ENCODING, X509_UNICODE_ANY_STRING,
							prop, cb, 0, pData, &cbData)
			)
		{
			CERT_NAME_VALUE * pName = (CERT_NAME_VALUE *)pData;
			DWORD cch = pName->Value.cbData/sizeof(TCHAR);
			void * p = str.GetBuffer(cch);
			memcpy(p, pName->Value.pbData, pName->Value.cbData);
			str.ReleaseBuffer(cch);
			bRes = TRUE;
		}
	}
	if (!bRes)
		*phRes = HRESULT_FROM_WIN32(GetLastError());
	return bRes;
}

BOOL
GetBlobProperty(PCCERT_CONTEXT pCertContext,
					 DWORD propId,
					 CCryptBlob& blob,
					 HRESULT * phRes)
{
	BOOL bRes = FALSE;
	DWORD cb;
	// compare property value
	if (	CertGetCertificateContextProperty(pCertContext, propId, NULL, &cb)
		&& blob.Resize(cb)
		&& CertGetCertificateContextProperty(pCertContext, propId, blob.GetData(), &cb)
		)
	{
		bRes = TRUE;
	}
	if (!bRes)
		*phRes = HRESULT_FROM_WIN32(GetLastError());
	return bRes;
}

PCCERT_CONTEXT
GetPendingDummyCert(const CString& inst_name, 
						  IEnroll * pEnroll, 
						  HRESULT * phRes)
{
	PCCERT_CONTEXT pRes = NULL;
	HCERTSTORE hStore = OpenRequestStore(pEnroll, phRes);
	if (hStore != NULL)
	{
		DWORD dwPropId = CERTWIZ_INSTANCE_NAME_PROP_ID;
		PCCERT_CONTEXT pDummyCert = NULL;
		while (NULL != (pDummyCert = CertFindCertificateInStore(hStore, 
													X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
													0, CERT_FIND_PROPERTY, 
													(LPVOID)&dwPropId, pDummyCert)))
		{
			CString str;
			if (GetStringProperty(pDummyCert, dwPropId, str, phRes))
			{
				if (str.CompareNoCase(inst_name) == 0)
				{
					pRes = pDummyCert;
					break;
				}
			}
		}
		CertCloseStore(hStore, CERT_CLOSE_STORE_CHECK_FLAG);
	}
	return pRes;
}

PCCERT_CONTEXT
GetReqCertByKey(IEnroll * pEnroll, CERT_PUBLIC_KEY_INFO * pKeyInfo, HRESULT * phResult)
{
	PCCERT_CONTEXT pRes = NULL;
	HCERTSTORE hStore = OpenRequestStore(pEnroll, phResult);
	if (hStore != NULL)
	{
		if (NULL != (pRes = CertFindCertificateInStore(hStore, 
				X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, 
				0, CERT_FIND_PUBLIC_KEY, (LPVOID)pKeyInfo, NULL)))
		{
			*phResult = S_OK;
		}
		VERIFY(SUCCEEDED(CertCloseStore(hStore, CERT_CLOSE_STORE_CHECK_FLAG)));
	}
	return pRes;
}

#define CERT_QUERY_CONTENT_FLAGS\
								CERT_QUERY_CONTENT_FLAG_CERT\
								|CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED\
								|CERT_QUERY_CONTENT_FLAG_SERIALIZED_STORE\
								|CERT_QUERY_CONTENT_FLAG_PKCS7_UNSIGNED

PCCERT_CONTEXT
GetCertContextFromPKCS7File(const CString& resp_file_name, 
									CERT_PUBLIC_KEY_INFO * pKeyInfo,
									HRESULT * phResult)
{
	ASSERT(phResult != NULL);
	PCCERT_CONTEXT pRes = NULL;
	HANDLE hFile;

	if (INVALID_HANDLE_VALUE != (hFile = CreateFile(resp_file_name,
						GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 
						FILE_ATTRIBUTE_NORMAL, NULL)))
	{
		// find the length of the buffer
		DWORD cbData = GetFileSize(hFile, NULL);
		BYTE * pbData;
		// alloc temp buffer
		if ((pbData = (BYTE *)_alloca(cbData)) != NULL) 
		{
			DWORD cb = 0;
			if (ReadFile(hFile, pbData, cbData, &cb, NULL))
			{
				ASSERT(cb == cbData);
				pRes = GetCertContextFromPKCS7(pbData, cb, pKeyInfo, phResult);
			}
			else
				*phResult = HRESULT_FROM_WIN32(GetLastError());
		}
		CloseHandle(hFile);
	}
	else
		*phResult = HRESULT_FROM_WIN32(GetLastError());
	return pRes;
}

PCCERT_CONTEXT
GetCertContextFromPKCS7(const BYTE * pbData,
								DWORD cbData,
								CERT_PUBLIC_KEY_INFO * pKeyInfo,
								HRESULT * phResult)
{
	ASSERT(phResult != NULL);
	PCCERT_CONTEXT pRes = NULL;
	CRYPT_DATA_BLOB blob;
	memset(&blob, 0, sizeof(CRYPT_DATA_BLOB));
	blob.cbData = cbData;
	blob.pbData = (BYTE *)pbData;

   HCERTSTORE hStoreMsg = NULL;

	if(CryptQueryObject(CERT_QUERY_OBJECT_BLOB, 
            &blob,
            (CERT_QUERY_CONTENT_FLAG_CERT |
            CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED |
            CERT_QUERY_CONTENT_FLAG_SERIALIZED_STORE |
            CERT_QUERY_CONTENT_FLAG_PKCS7_UNSIGNED) ,
            CERT_QUERY_FORMAT_FLAG_ALL,
            0, 
            NULL, 
            NULL, 
            NULL, 
            &hStoreMsg, 
            NULL, 
            NULL))
	{
		if (pKeyInfo != NULL)
			pRes = CertFindCertificateInStore(hStoreMsg, 
                        X509_ASN_ENCODING,
								0, 
                        CERT_FIND_PUBLIC_KEY, 
                        pKeyInfo, 
                        NULL);
		else
			pRes = CertFindCertificateInStore(hStoreMsg, 
                        X509_ASN_ENCODING,
								0, 
                        CERT_FIND_ANY, 
                        NULL, 
                        NULL);
		if (pRes == NULL)
			*phResult = HRESULT_FROM_WIN32(GetLastError());
		CertCloseStore(hStoreMsg, CERT_CLOSE_STORE_CHECK_FLAG);
	}
	else
		*phResult = HRESULT_FROM_WIN32(GetLastError());
	return pRes;
}

BOOL 
FormatDateString(CString& str, FILETIME ft, BOOL fIncludeTime, BOOL fLongFormat)
{
	int cch;
   int cch2;
   LPWSTR psz;
   SYSTEMTIME st;
   FILETIME localTime;
    
   if (!FileTimeToLocalFileTime(&ft, &localTime))
   {
		return FALSE;
   }
    
   if (!FileTimeToSystemTime(&localTime, &st)) 
   {
		//
      // if the conversion to local time failed, then just use the original time
      //
      if (!FileTimeToSystemTime(&ft, &st)) 
      {
			return FALSE;
      }
   }

   cch = (GetTimeFormat(LOCALE_SYSTEM_DEFAULT, 0, &st, NULL, NULL, 0) +
          GetDateFormat(LOCALE_SYSTEM_DEFAULT, fLongFormat ? DATE_LONGDATE : 0, &st, NULL, NULL, 0) + 5);

   if (NULL == (psz = str.GetBuffer((cch+5) * sizeof(WCHAR))))
   {
		return FALSE;
   }
    
   cch2 = GetDateFormat(LOCALE_SYSTEM_DEFAULT, fLongFormat ? DATE_LONGDATE : 0, &st, NULL, psz, cch);

   if (fIncludeTime)
   {
		psz[cch2-1] = ' ';
      GetTimeFormat(LOCALE_SYSTEM_DEFAULT, TIME_NOSECONDS, &st, NULL, &psz[cch2], cch-cch2);
   }
	str.ReleaseBuffer();  
   return TRUE;
}

BOOL MyGetOIDInfo(LPWSTR string, DWORD stringSize, LPSTR pszObjId)
{   
    PCCRYPT_OID_INFO pOIDInfo;
            
    if (NULL != (pOIDInfo = CryptFindOIDInfo(CRYPT_OID_INFO_OID_KEY, pszObjId, 0)))
    {
        if ((DWORD)wcslen(pOIDInfo->pwszName)+1 <= stringSize)
        {
            wcscpy(string, pOIDInfo->pwszName);
        }
        else
        {
            return FALSE;
        }
    }
    else
    {
        return (MultiByteToWideChar(CP_ACP, 0, pszObjId, -1, string, stringSize) != 0);
    }
    return TRUE;
}

BOOL
GetKeyUsageProperty(PCCERT_CONTEXT pCertContext, 
						  CERT_ENHKEY_USAGE ** pKeyUsage, 
						  BOOL fPropertiesOnly, 
						  HRESULT * phRes)
{
	DWORD cb = 0;
	BOOL bRes = FALSE;
   if (!CertGetEnhancedKeyUsage(pCertContext,
                                fPropertiesOnly ? CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG : 0,
                                NULL,
                                &cb))
   {
		*phRes = HRESULT_FROM_WIN32(GetLastError());
		goto ErrExit;
   }
   if (NULL == (*pKeyUsage = (CERT_ENHKEY_USAGE *)malloc(cb)))
   {
		*phRes = E_OUTOFMEMORY;
		goto ErrExit;
   }
   if (!CertGetEnhancedKeyUsage (pCertContext,
                                 fPropertiesOnly ? CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG : 0,
                                 *pKeyUsage,
                                 &cb))
   {
		free(*pKeyUsage);
		*phRes = HRESULT_FROM_WIN32(GetLastError());
		goto ErrExit;
   }
	*phRes = S_OK;
	bRes = TRUE;
ErrExit:
	return bRes;
}

BOOL
GetFriendlyName(PCCERT_CONTEXT pCertContext,
					 CString& name,
					 HRESULT * phRes)
{
	BOOL bRes = FALSE;
	DWORD cb;
	BYTE * pName = NULL;

	if (	CertGetCertificateContextProperty(pCertContext, CERT_FRIENDLY_NAME_PROP_ID, NULL, &cb)
		&&	NULL != (pName = (BYTE *)name.GetBuffer((cb + 1)/sizeof(TCHAR)))
		&&	CertGetCertificateContextProperty(pCertContext, CERT_FRIENDLY_NAME_PROP_ID, pName, &cb)
		)
	{
		pName[cb] = 0;
		bRes = TRUE;
	}
	else
	{
		*phRes = HRESULT_FROM_WIN32(GetLastError());
	}
	if (pName != NULL && name.IsEmpty())
	{
		name.ReleaseBuffer();
	}
	return bRes;
}

BOOL
GetNameString(PCCERT_CONTEXT pCertContext,
				  DWORD type,
				  DWORD flag,
				  CString& name,
				  HRESULT * phRes)
{
	BOOL bRes = FALSE;
	LPTSTR pName;
	DWORD cchName = CertGetNameString(pCertContext, type, flag, NULL, NULL, 0);
	if (cchName > 1 && (NULL != (pName = name.GetBuffer(cchName))))
	{
		bRes = (1 != CertGetNameString(pCertContext, type, flag, NULL, pName, cchName));
		name.ReleaseBuffer();
	}
	else
	{
		*phRes = HRESULT_FROM_WIN32(GetLastError());
	}
	return bRes;
}

BOOL
ContainsKeyUsageProperty(PCCERT_CONTEXT pCertContext, 
						 CArray<LPCSTR, LPCSTR>& uses,
						 HRESULT * phRes
						 )
{
	BOOL bRes = FALSE;
	CERT_ENHKEY_USAGE * pKeyUsage = NULL;
	if (	uses.GetSize() > 0
		&&	GetKeyUsageProperty(pCertContext, &pKeyUsage, FALSE, phRes)
		)
	{
		if (pKeyUsage->cUsageIdentifier == 0)
		{
			bRes = TRUE;
		}
		else
		{
			for (DWORD i = 0; i < pKeyUsage->cUsageIdentifier; i++)
			{
				// Our friends from CAPI made this property ASCII even for 
				// UNICODE program
				for (int n = 0; n < uses.GetSize(); n++)
				{
					if (strstr(pKeyUsage->rgpszUsageIdentifier[i], uses[n]) != NULL)
					{
						bRes = TRUE;
						break;
					}
				}
			}
		}
		free(pKeyUsage);
	}
	return bRes;
}

BOOL 
FormatEnhancedKeyUsageString(CString& str, 
									  PCCERT_CONTEXT pCertContext, 
									  BOOL fPropertiesOnly, 
									  BOOL fMultiline,
									  HRESULT * phRes)
{
	CERT_ENHKEY_USAGE * pKeyUsage = NULL;
	WCHAR szText[CRYPTUI_MAX_STRING_SIZE];
	BOOL bRes = FALSE;

	if (GetKeyUsageProperty(pCertContext, &pKeyUsage, fPropertiesOnly, phRes))
	{
		// loop for each usage and add it to the display string
		for (DWORD i = 0; i < pKeyUsage->cUsageIdentifier; i++)
		{
			if (!(bRes = MyGetOIDInfo(szText, ARRAYSIZE(szText), pKeyUsage->rgpszUsageIdentifier[i])))
				break;
			// add delimeter if not first iteration
			if (i != 0)
			{
				str += fMultiline ? L"\n" : L", ";
			}
			// add the enhanced key usage string
			str += szText;
		}
		free (pKeyUsage);
	}
	else
	{
		str.LoadString(IDS_ANY);
		bRes = TRUE;
	}
	return bRes;
}

BOOL
GetServerComment(const CString& machine_name,
					  const CString& server_name,
					  CString& comment,
					  HRESULT * phResult)
{
	ASSERT(!machine_name.IsEmpty());
	ASSERT(!server_name.IsEmpty());
	*phResult = S_OK;
	CMetaKey key(machine_name,
				METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
				METADATA_MASTER_ROOT_HANDLE,
				server_name);
	if (key.Succeeded())
	{
		return SUCCEEDED(*phResult = key.QueryValue(MD_SERVER_COMMENT, comment));
	}
	else
	{
		*phResult = key.QueryResult();
		return FALSE;
	}
}

/*
		GetInstalledCert

		Function reads cert hash attribute from metabase
		using machine_name and server name as server instance
		description, then looks in MY store for a certificate
		with hash equal found in metabase.
		Return is cert context pointer or NULL, if cert wasn't
		found or certificate store wasn't opened.
		On return HRESULT * is filled by error code.
 */
PCCERT_CONTEXT
GetInstalledCert(const CString& machine_name, 
					  const CString& server_name,
					  IEnroll * pEnroll,
					  HRESULT * phResult)
{
	ASSERT(pEnroll != NULL);
	ASSERT(phResult != NULL);
	ASSERT(!machine_name.IsEmpty());
	ASSERT(!server_name.IsEmpty());
	PCCERT_CONTEXT pCert = NULL;
	*phResult = S_OK;
	CMetaKey key(machine_name,
				METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
				METADATA_MASTER_ROOT_HANDLE,
				server_name);
	if (key.Succeeded())
	{
		CString store_name;
		CBlob hash;
		if (	SUCCEEDED(*phResult = key.QueryValue(MD_SSL_CERT_STORE_NAME, store_name))
			&&	SUCCEEDED(*phResult = key.QueryValue(MD_SSL_CERT_HASH, hash))
			)
		{
			// Open MY store. We assume that store type and flags
			// cannot be changed between installation and unistallation
			// of the sertificate.
			HCERTSTORE hStore = OpenMyStore(pEnroll, phResult);
			ASSERT(hStore != NULL);
			if (hStore != NULL)
			{
				// Now we need to find cert by hash
				CRYPT_HASH_BLOB crypt_hash;
				crypt_hash.cbData = hash.GetSize();
				crypt_hash.pbData = hash.GetData();
				pCert = CertFindCertificateInStore(hStore, 
												X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, 
												0, CERT_FIND_HASH, (LPVOID)&crypt_hash, NULL);
				if (pCert == NULL)
					*phResult = HRESULT_FROM_WIN32(GetLastError());
				VERIFY(CertCloseStore(hStore, 0));
			}
		}
	}
	else
		*phResult = key.QueryResult();
	return pCert;
}

/*
	InstallHashToMetabase

	Function writes hash array to metabase. After that IIS 
	could use certificate with that hash from MY store.
	Function expects server_name in format lm\w3svc\<number>,
	i.e. from root node down to virtual server

 */
BOOL
InstallHashToMetabase(CRYPT_HASH_BLOB * pHash,
					  const CString& machine_name, 
					  const CString& server_name,
					  HRESULT * phResult)
{
	BOOL bRes = FALSE;
	CMetaKey key(machine_name,
						METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
						METADATA_MASTER_ROOT_HANDLE,
						server_name);
	if (key.Succeeded())
	{
		CBlob blob;
		blob.SetValue(pHash->cbData, pHash->pbData, TRUE);
		bRes = SUCCEEDED(*phResult = key.SetValue(MD_SSL_CERT_HASH, blob)) 
			&& SUCCEEDED(*phResult = key.SetValue(MD_SSL_CERT_STORE_NAME, CString(L"MY")));
	}
	else
	{
		TRACE(_T("Failed to open metabase key. Error 0x%x\n"), key.QueryResult());
		*phResult = key.QueryResult();
	}
	return bRes;
}

/*
	InstallCertByHash

	Function looks in MY store for certificate which has hash
	equal to pHash parameter. If cert is found, it is installed
	to metabase.
	This function is used after xenroll accept() method, which
	puts certificate to store

 */
BOOL 
InstallCertByHash(CRYPT_HASH_BLOB * pHash,
					  const CString& machine_name, 
					  const CString& server_name,
					  IEnroll * pEnroll,
					  HRESULT * phResult)

{
	BOOL bRes = FALSE;
	// we are looking to MY store only
	HCERTSTORE hStore = OpenMyStore(pEnroll, phResult);
	if (hStore != NULL)
	{
		PCCERT_CONTEXT pCert = CertFindCertificateInStore(hStore, 
												X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, 
												0, CERT_FIND_HASH, (LPVOID)pHash, NULL);
		// now install cert info to IIS MetaBase
		if (pCert != NULL)
		{
			bRes = InstallHashToMetabase(pHash, 
							machine_name, server_name, phResult);
			CertFreeCertificateContext(pCert);
		}
		else
		{
			TRACE(_T("FAILED: certificate installation, error 0x%x\n"), GetLastError());
			// We definitely need to store the hash of the cert, so error out
			*phResult = HRESULT_FROM_WIN32(GetLastError());
		}
		VERIFY(CertCloseStore(hStore, 0));
	}
	return bRes;
}

HRESULT
CreateRequest_Base64(const BSTR bstr_dn, 
                     IEnroll * pEnroll, 
                     BSTR csp_name,
                     DWORD csp_type,
                     BSTR * pOut)
{
	ASSERT(pOut != NULL);
	ASSERT(bstr_dn != NULL);
	HRESULT hRes = S_OK;
	CString strUsage(szOID_PKIX_KP_SERVER_AUTH);
	CRYPT_DATA_BLOB request = {0, NULL};
   pEnroll->put_ProviderType(csp_type);
   pEnroll->put_ProviderNameWStr(csp_name);
	if (SUCCEEDED(hRes = pEnroll->createPKCS10WStr(
									bstr_dn, 
									(LPTSTR)(LPCTSTR)strUsage, 
									&request)))
	{
		WCHAR * wszRequestB64 = NULL;
		DWORD cch = 0;
		DWORD err = ERROR_SUCCESS;
		// BASE64 encode pkcs 10
		if (	(err = Base64EncodeW(request.pbData, request.cbData, NULL, &cch)) == ERROR_SUCCESS 
			&&	(wszRequestB64 = (WCHAR *)_alloca(cch * sizeof(WCHAR))) != NULL     
			&&	(err = Base64EncodeW(request.pbData, request.cbData, wszRequestB64, &cch)) == ERROR_SUCCESS 
			) 
		{
			if ((*pOut = SysAllocStringLen(wszRequestB64, cch)) == NULL ) 
			{
				hRes = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
			}
		}
		else
			hRes = HRESULT_FROM_WIN32(err);
		if (request.pbData != NULL)
         CoTaskMemFree(request.pbData);
	}
	return hRes;	
}

BOOL
AttachFriendlyName(PCCERT_CONTEXT pContext, 
						 const CString& name,
						 HRESULT * phRes)
{
	BOOL bRes = TRUE;
	CRYPT_DATA_BLOB blob_name;
	blob_name.pbData = (LPBYTE)(LPCTSTR)name;
	blob_name.cbData = (name.GetLength() + 1) * sizeof(WCHAR);
	if (!(bRes = CertSetCertificateContextProperty(pContext,
						CERT_FRIENDLY_NAME_PROP_ID, 0, &blob_name)))
	{
		ASSERT(phRes != NULL);
		*phRes = HRESULT_FROM_WIN32(GetLastError());
	}
	return bRes;
}

BOOL GetHashProperty(PCCERT_CONTEXT pCertContext, 
							CCryptBlob& blob, 
							HRESULT * phRes)
{
	DWORD cb;
	if (CertGetCertificateContextProperty(pCertContext, CERT_SHA1_HASH_PROP_ID, NULL, &cb))
	{
		if (blob.Resize(cb))
		{
			if (CertGetCertificateContextProperty(pCertContext, 
								CERT_SHA1_HASH_PROP_ID, blob.GetData(), &cb))
				return TRUE;
		}
	}
	*phRes = HRESULT_FROM_WIN32(GetLastError());
	return FALSE;
}

BOOL 
EncodeString(CString& str, 
				 CCryptBlob& blob, 
				 HRESULT * phRes)
{
	BOOL bRes = FALSE;
	DWORD cb;
	CERT_NAME_VALUE name_value;
	name_value.dwValueType = CERT_RDN_BMP_STRING;
	name_value.Value.cbData = 0;
	name_value.Value.pbData = (LPBYTE)(LPCTSTR)str;
	if (	CryptEncodeObject(CRYPT_ASN_ENCODING, X509_UNICODE_ANY_STRING,
										&name_value, NULL, &cb) 
		&&	blob.Resize(cb)
		&&	CryptEncodeObject(CRYPT_ASN_ENCODING, X509_UNICODE_ANY_STRING,
										&name_value, blob.GetData(), &cb) 
		)
	{
		bRes = TRUE;
	}
	else
		*phRes = HRESULT_FROM_WIN32(GetLastError());
	return bRes;
}

#define CERTWIZ_RENEWAL_DATA	((LPCSTR)1000)

BOOL 
EncodeBlob(CCryptBlob& in, 
			  CCryptBlob& out, 
			  HRESULT * phRes)
{
	BOOL bRes = FALSE;
	DWORD cb;
	if (	CryptEncodeObject(CRYPT_ASN_ENCODING, CERTWIZ_RENEWAL_DATA, in, NULL, &cb) 
		&&	out.Resize(cb)
		&&	CryptEncodeObject(CRYPT_ASN_ENCODING, CERTWIZ_RENEWAL_DATA, in, out.GetData(), &cb) 
		)
	{
		bRes = TRUE;
	}
	else
		*phRes = HRESULT_FROM_WIN32(GetLastError());
	return bRes;
}

BOOL
DecodeBlob(CCryptBlob& in,
			  CCryptBlob& out,
			  HRESULT * phRes)
{
	BOOL bRes = FALSE;
	DWORD cb;
	if (	CryptDecodeObject(CRYPT_ASN_ENCODING, CERTWIZ_RENEWAL_DATA, 
						in.GetData(),
						in.GetSize(), 
						0, 
						NULL, &cb) 
		&&	out.Resize(cb)
		&&	CryptDecodeObject(CRYPT_ASN_ENCODING, CERTWIZ_RENEWAL_DATA, 
						in.GetData(),
						in.GetSize(), 
						0, 
						out.GetData(), 
						&cb) 
		)
	{
		bRes = TRUE;
	}
	else
		*phRes = HRESULT_FROM_WIN32(GetLastError());
	return bRes;
}

BOOL 
EncodeInteger(int number, 
				 CCryptBlob& blob, 
				 HRESULT * phRes)
{
	BOOL bRes = FALSE;
	DWORD cb;
	if (	CryptEncodeObject(CRYPT_ASN_ENCODING, X509_INTEGER,
										&number, NULL, &cb) 
		&&	blob.Resize(cb)
		&&	CryptEncodeObject(CRYPT_ASN_ENCODING, X509_INTEGER,
										&number, blob.GetData(), &cb) 
		)
	{
		bRes = TRUE;
	}
	else
		*phRes = HRESULT_FROM_WIN32(GetLastError());
	return bRes;
}

const WCHAR     RgwchHex[] = {'0', '1', '2', '3', '4', '5', '6', '7',
                              '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};

static BOOL 
FormatMemBufToString(CString& str, LPBYTE pbData, DWORD cbData)
{   
    DWORD   i = 0;
    LPBYTE  pb;
    DWORD   numCharsInserted = 0;
	 LPTSTR pString;
    
    //
    // calculate the size needed
    //
    pb = pbData;
    while (pb <= &(pbData[cbData-1]))
    {   
        if (numCharsInserted == 4)
        {
            i += sizeof(WCHAR);
            numCharsInserted = 0;
        }
        else
        {
            i += 2 * sizeof(WCHAR);
            pb++;
            numCharsInserted += 2;  
        }
    }

    if (NULL == (pString = str.GetBuffer(i)))
    {
        return FALSE;
    }

    //
    // copy to the buffer
    //
    i = 0;
    numCharsInserted = 0;
    pb = pbData;
    while (pb <= &(pbData[cbData-1]))
    {   
        if (numCharsInserted == 4)
        {
            pString[i++] = L' ';
            numCharsInserted = 0;
        }
        else
        {
            pString[i++] = RgwchHex[(*pb & 0xf0) >> 4];
            pString[i++] = RgwchHex[*pb & 0x0f];
            pb++;
            numCharsInserted += 2;  
        }
    }
    pString[i] = 0;
	 str.ReleaseBuffer();
    return TRUE;
}


void FormatRdnAttr(CString& str, DWORD dwValueType, CRYPT_DATA_BLOB& blob)
{
	if (	CERT_RDN_ENCODED_BLOB == dwValueType 
		||	CERT_RDN_OCTET_STRING == dwValueType
		)
	{
		// translate the buffer to a text string
      FormatMemBufToString(str, blob.pbData, blob.cbData);
   }
	else 
   {
      // buffer is already a string so just copy it
		str += (LPTSTR)blob.pbData;
   }
}

BOOL
CreateDirectoryFromPath(LPCTSTR szPath, LPSECURITY_ATTRIBUTES lpSA)
/*++

Routine Description:

    Creates the directory specified in szPath and any other "higher"
        directories in the specified path that don't exist.

Arguments:

    IN  LPCTSTR szPath
        directory path to create (assumed to be a DOS path, not a UNC)

    IN  LPSECURITY_ATTRIBUTES   lpSA
        pointer to security attributes argument used by CreateDirectory


Return Value:

    TRUE    if directory(ies) created
    FALSE   if error (GetLastError to find out why)

--*/
{
	LPTSTR pLeftHalf, pNext;
	CString RightHalf;
	// 1. We are supporting only absolute paths. Caller should decide which
	//		root to use and build the path
	if (PathIsRelative(szPath))
	{
		ASSERT(FALSE);
		return FALSE;
	}

	pLeftHalf = (LPTSTR)szPath;
	pNext = PathSkipRoot(pLeftHalf);

	do {
		// copy the chunk between pLeftHalf and pNext to the
		// local buffer
		while (pLeftHalf < pNext)
			RightHalf += *pLeftHalf++;
		// check if new path exists
		int index = RightHalf.GetLength() - 1;
		BOOL bBackslash = FALSE, bContinue = FALSE;
		if (bBackslash = (RightHalf[index] == L'\\'))
		{
			RightHalf.SetAt(index, 0);
		}
		bContinue = PathIsUNCServerShare(RightHalf);
		if (bBackslash)
			RightHalf.SetAt(index, L'\\');
		if (bContinue || PathIsDirectory(RightHalf))
			continue;
		else if (PathFileExists(RightHalf))
		{
			// we cannot create this directory 
			// because file with this name already exists
			SetLastError(ERROR_ALREADY_EXISTS);
			return FALSE;
		}
		else
		{
			// no file no directory, create
			if (!CreateDirectory(RightHalf, lpSA))
				return FALSE;
		}
	}
   while (NULL != (pNext = PathFindNextComponent(pLeftHalf)));
	return TRUE;
}

BOOL
CompactPathToWidth(CWnd * pControl, CString& strPath)
{
	BOOL bRes;
	CRect rc;
	CFont * pFont = pControl->GetFont(), * pFontTmp;
	CDC * pdc = pControl->GetDC(), dc;
	LPTSTR pPath = strPath.GetBuffer(MAX_PATH);

	dc.CreateCompatibleDC(pdc);
	pFontTmp = dc.SelectObject(pFont);
	pControl->GetClientRect(&rc);
	
	bRes = PathCompactPath(dc.GetSafeHdc(), pPath, rc.Width());
	
	dc.SelectObject(pFontTmp);
	pControl->ReleaseDC(pdc);
	strPath.ReleaseBuffer();

	return bRes;
}

BOOL
GetKeySizeLimits(IEnroll * pEnroll, 
					  DWORD * min, DWORD * max, DWORD * def, 
					  BOOL bGSC,
					  HRESULT * phRes)
{
   HCRYPTPROV hProv = NULL;
	long dwProviderType;
   DWORD dwFlags, cbData;
	BSTR bstrProviderName;
   PROV_ENUMALGS_EX paramData;
	BOOL bRes = FALSE;
	
	VERIFY(SUCCEEDED(pEnroll->get_ProviderNameWStr(&bstrProviderName)));
	VERIFY(SUCCEEDED(pEnroll->get_ProviderType(&dwProviderType)));

	if (!CryptAcquireContext(
                &hProv,
                NULL,
                bstrProviderName,
                dwProviderType,
                CRYPT_VERIFYCONTEXT))
   {
		*phRes = GetLastError();
		return FALSE;
   }

   for (int i = 0; ; i++)
   {
		dwFlags = 0 == i ? CRYPT_FIRST : 0;
      cbData = sizeof(paramData);
      if (!CryptGetProvParam(hProv, PP_ENUMALGS_EX, (BYTE*)&paramData, &cbData, dwFlags))
      {
         if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == GetLastError())
         {
				// out of for loop
				*phRes = S_OK;
				bRes = TRUE;
         }
			else
			{
				*phRes = GetLastError();
			}
         break;
      }
      if (ALG_CLASS_KEY_EXCHANGE == GET_ALG_CLASS(paramData.aiAlgid))
      {
			*min = paramData.dwMinLen;
         *max = paramData.dwMaxLen;
			*def = paramData.dwDefaultLen;
			bRes = TRUE;
			*phRes = S_OK;
         break;
      }
   }
	if (NULL != hProv)
   {
		CryptReleaseContext(hProv, 0);
   }
	return bRes;
}

HRESULT ShutdownSSL(CString& machine_name, CString& server_name)
{
	CString str = server_name;
	str += _T("/root");
	CMetaKey key(machine_name,
				METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
				METADATA_MASTER_ROOT_HANDLE,
				str);
	DWORD dwSslAccess;
	if (	key.Succeeded() 
		&&  SUCCEEDED(key.QueryValue(MD_SSL_ACCESS_PERM, dwSslAccess))
		&&	dwSslAccess > 0
		)
	{
		key.SetValue(MD_SSL_ACCESS_PERM, 0);
       key.DeleteValue(MD_SECURE_BINDINGS);
	}
	// Now we need to remove SSL setting from any virtual directory below
	CError err;
   CStringListEx strlDataPaths;
	DWORD 
		dwMDIdentifier, 
		dwMDAttributes, 
		dwMDUserType,
		dwMDDataType;

	VERIFY(CMetaKey::GetMDFieldDef(
		MD_SSL_ACCESS_PERM, 
		dwMDIdentifier, 
		dwMDAttributes, 
		dwMDUserType,
		dwMDDataType
		));

    err = key.GetDataPaths( 
        strlDataPaths,
        dwMDIdentifier,
        dwMDDataType
        );

    if (err.Succeeded() && !strlDataPaths.IsEmpty())
    {
		POSITION pos = strlDataPaths.GetHeadPosition();
		while (pos)
		{
			CString& str = strlDataPaths.GetNext(pos);
			if (	SUCCEEDED(key.QueryValue(MD_SSL_ACCESS_PERM, 
							dwSslAccess, NULL, str))
				&&	dwSslAccess > 0
				)
			{
				key.SetValue(MD_SSL_ACCESS_PERM, 0, NULL, str);
               key.DeleteValue(MD_SECURE_BINDINGS, str);
			}
		}
	}
	return key.QueryResult();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certwiz\certutil.h ===
//
// CertUtil.h
//
#ifndef _CERTUTIL_H
#define _CERTUTIL_H

#include <wincrypt.h>
#include <CertCli.h>
#include <xenroll.h>
#include "Certificat.h"

BOOL GetOnlineCAList(CStringList& list, const CString& certType, HRESULT * phRes);
BOOL GetRequestInfoFromPKCS10(CCryptBlob& pkcs10, 
										PCERT_REQUEST_INFO * pReqInfo,
										HRESULT * phRes);
PCCERT_CONTEXT GetPendingDummyCert(const CString& inst_name, 
											  IEnroll * pEnroll,
											  HRESULT * phRes);
HCERTSTORE OpenRequestStore(IEnroll * pEnroll, HRESULT * phResult);
HCERTSTORE OpenMyStore(IEnroll * pEnroll, HRESULT * phResult);
PCCERT_CONTEXT GetCertContextFromPKCS7File(const CString& resp_file_name, 
														CERT_PUBLIC_KEY_INFO * pKeyInfo,
														HRESULT * phResult);
PCCERT_CONTEXT GetCertContextFromPKCS7(const BYTE * pbData, DWORD cbData,
													CERT_PUBLIC_KEY_INFO * pKeyInfo,
													HRESULT * phResult);
PCCERT_CONTEXT GetRequestContext(CCryptBlob& pkcs10, HRESULT * phRes);
BOOL GetRequestInfoFromPKCS10(CCryptBlob& pkcs10, 
										PCERT_REQUEST_INFO * pReqInfo,
										HRESULT * phRes);
//BOOL GetRequestInfoFromRenewalRequest(CCryptBlob& renewal_req,
//                              PCCERT_CONTEXT * pSignerCert,
//                              HCERTSTORE hStore,
//										PCERT_REQUEST_INFO * pReqInfo,
//										HRESULT * phRes);
PCCERT_CONTEXT GetReqCertByKey(IEnroll * pEnroll, 
										 CERT_PUBLIC_KEY_INFO * pKeyInfo, 
										 HRESULT * phResult);

BOOL FormatDateString(CString& str, 
							 FILETIME ft, 
							 BOOL fIncludeTime, 
							 BOOL fLongFormat);
BOOL
GetKeyUsageProperty(PCCERT_CONTEXT pCertContext, 
						  CERT_ENHKEY_USAGE ** pKeyUsage, 
						  BOOL fPropertiesOnly, 
						  HRESULT * phRes);
BOOL
ContainsKeyUsageProperty(PCCERT_CONTEXT pCertContext, 
						 CArray<LPCSTR, LPCSTR>& uses, 
						 HRESULT * phRes);
BOOL FormatEnhancedKeyUsageString(CString& str, 
											 PCCERT_CONTEXT pCertContext, 
											 BOOL fPropertiesOnly, 
											 BOOL fMultiline,
											 HRESULT * phRes);
PCCERT_CONTEXT
GetInstalledCert(const CString& machine_name, 
					  const CString& server_name,
					  IEnroll * pEnroll,
					  HRESULT * phResult);
BOOL 
InstallCertByHash(CRYPT_HASH_BLOB * pHash,
					  const CString& machine_name, 
					  const CString& server_name,
					  IEnroll * pEnroll,
					  HRESULT * phResult);
BOOL
InstallHashToMetabase(CRYPT_HASH_BLOB * pHash,
					  const CString& machine_name, 
					  const CString& server_name,
					  HRESULT * phResult);
HRESULT CreateRequest_Base64(const BSTR bstr_dn, 
                             IEnroll * pEnroll,
                             BSTR csp_name,
                             DWORD csp_type,
                             BSTR * pOut);
BOOL AttachFriendlyName(PCCERT_CONTEXT pContext, const CString& name, HRESULT * phRes);
BOOL GetFriendlyName(PCCERT_CONTEXT pCertContext,
					 CString& name,
					 HRESULT * phRes);
BOOL GetNameString(PCCERT_CONTEXT pCertContext,
				  DWORD type,
				  DWORD flag,
				  CString& name,
				  HRESULT * phRes);
BOOL GetHashProperty(PCCERT_CONTEXT pCertContext, CCryptBlob& hash_blob, HRESULT * phRes);
BOOL GetStringProperty(PCCERT_CONTEXT pCertContext, DWORD propId, CString& str, HRESULT * phRes);
BOOL GetBlobProperty(PCCERT_CONTEXT pCertContext,
					 DWORD propId,
					 CCryptBlob& blob,
					 HRESULT * phRes);

BOOL EncodeString(CString& str, CCryptBlob& blob, HRESULT * phRes);
BOOL EncodeInteger(int number, CCryptBlob& blob, HRESULT * phRes);
BOOL EncodeBlob(CCryptBlob& in, CCryptBlob& out, HRESULT * phRes);
BOOL DecodeBlob(CCryptBlob& in, CCryptBlob& out, HRESULT * phRes);
BOOL GetServerComment(const CString& machine_name, const CString& server_name,
					  CString& comment, HRESULT * phResult);
void FormatRdnAttr(CString& str, DWORD dwValueType, CRYPT_DATA_BLOB& blob);

BOOL CreateDirectoryFromPath(LPCTSTR szPath, LPSECURITY_ATTRIBUTES lpSA);

BOOL CompactPathToWidth(CWnd * pControl, CString& strPath);

BOOL GetKeySizeLimits(IEnroll * pEnroll, 
					  DWORD * min, DWORD * max, DWORD * def, 
					  BOOL bGSC,
					  HRESULT * phRes);
HRESULT ShutdownSSL(CString& machine_name, CString& server_name);

#endif	//_CERTUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certwiz\choosecertpage.cpp ===
// ReplaceChooseCert.cpp : implementation file
//

#include "stdafx.h"
#include "CertWiz.h"
#include "ChooseCertPage.h"
#include "Certificat.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define COL_COMMON_NAME				0
#define COL_CA_NAME					1
#define COL_EXPIRATION_DATE		2
#define COL_PURPOSE					3
#define COL_FRIENDLY_NAME			4
#define COL_COMMON_NAME_WID		100
#define COL_CA_NAME_WID				100
#define COL_EXPIRATION_DATE_WID	100
#define COL_PURPOSE_WID				100
#define COL_FRIENDLY_NAME_WID		100

int
CCertListCtrl::GetSelectedIndex()
{
#if _AFX_VER >= 0x0600
	POSITION pos = GetFirstSelectedItemPosition();
	return pos != NULL ? GetNextSelectedItem(pos) : -1;
#else
	// I guess we should do it in a hard way
	int count = GetItemCount();
	int index = -1;
	for (int i = 0; i < count; i++)
	{
		if (GetItemState(i, LVIS_SELECTED))
		{
			index = i;
			break;
		}
	}
	return index;
#endif
}

void
CCertListCtrl::AdjustStyle()
{
#if _AFX_VER >= 0x0600
	DWORD dwStyle = m_CertList.GetExtendedStyle();
	m_CertList.SetExtendedStyle(dwStyle | LVS_EX_FULLROWSELECT | LVS_EX_HEADERDRAGDROP);
#else
	ASSERT(m_hWnd != NULL);
	DWORD dwStyle = ListView_GetExtendedListViewStyle(m_hWnd);
	ListView_SetExtendedListViewStyle(m_hWnd,
		dwStyle | LVS_EX_FULLROWSELECT | LVS_EX_HEADERDRAGDROP);
#endif
}

/////////////////////////////////////////////////////////////////////////////
// CChooseCertPage property page

IMPLEMENT_DYNCREATE(CChooseCertPage, CIISWizardPage)

CChooseCertPage::CChooseCertPage(CCertificate * pCert)
	: CIISWizardPage(CChooseCertPage::IDD, IDS_CERTWIZ, TRUE),
	m_pCert(pCert)
{
	//{{AFX_DATA_INIT(CChooseCertPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CChooseCertPage::~CChooseCertPage()
{
}

void CChooseCertPage::DoDataExchange(CDataExchange* pDX)
{
	CIISWizardPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CChooseCertPage)
	DDX_Control(pDX, IDC_CERT_LIST, m_CertList);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CChooseCertPage, CIISWizardPage)
	//{{AFX_MSG_MAP(CChooseCertPage)
	ON_NOTIFY(NM_CLICK, IDC_CERT_LIST, OnClickCertList)
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CChooseCertPage message handlers

LRESULT CChooseCertPage::OnWizardBack()
{
	LRESULT id = 1;
	switch (m_pCert->GetStatusCode())
	{
	case CCertificate::REQUEST_REPLACE_CERT:
		id = IDD_PAGE_PREV_REPLACE;
		break;
	case CCertificate::REQUEST_INSTALL_CERT:
		id = IDD_PAGE_PREV_INSTALL;
		break;
	default:
		ASSERT(FALSE);
	}
	return id;
}

LRESULT CChooseCertPage::OnWizardNext()
{
	// get hash pointer for selected cert
	int index = m_CertList.GetSelectedIndex();
	ASSERT(index != -1);
	// find cert in store
	CRYPT_HASH_BLOB * pHash = (CRYPT_HASH_BLOB *)m_CertList.GetItemData(index);
	ASSERT(pHash != NULL);
	
	m_pCert->m_pSelectedCertHash = pHash;

	LRESULT id = 1;
	switch (m_pCert->GetStatusCode())
	{
	case CCertificate::REQUEST_REPLACE_CERT:
		id = IDD_PAGE_NEXT_REPLACE;
		break;
	case CCertificate::REQUEST_INSTALL_CERT:
		id = IDD_PAGE_NEXT_INSTALL;
		break;
	default:
		ASSERT(FALSE);
	}
	return id;
}

BOOL CChooseCertPage::OnSetActive()
{
	// If nothing is selected -- stay here
	SetWizardButtons(-1 == m_CertList.GetSelectedIndex() ?
					PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);
	return CIISWizardPage::OnSetActive();
}

BOOL CChooseCertPage::OnInitDialog()
{
	ASSERT(m_pCert != NULL);

	CIISWizardPage::OnInitDialog();

	CString str;
	str.LoadString(IDS_ISSUED_TO);
	m_CertList.InsertColumn(COL_COMMON_NAME, str, LVCFMT_LEFT, COL_COMMON_NAME_WID);
	str.LoadString(IDS_ISSUED_BY);
	m_CertList.InsertColumn(COL_CA_NAME, str, LVCFMT_LEFT, COL_CA_NAME_WID);
	str.LoadString(IDS_EXPIRATION_DATE);
	m_CertList.InsertColumn(COL_EXPIRATION_DATE, str, LVCFMT_LEFT, COL_EXPIRATION_DATE_WID);
	str.LoadString(IDS_PURPOSE);
	m_CertList.InsertColumn(COL_PURPOSE, str, LVCFMT_LEFT, COL_PURPOSE_WID);
	str.LoadString(IDS_FRIENDLY_NAME);
	m_CertList.InsertColumn(COL_FRIENDLY_NAME, str, LVCFMT_LEFT, COL_FRIENDLY_NAME_WID);

	m_CertList.AdjustStyle();

	if (m_pCert->GetCertDescList(m_DescList))
	{
		int item = 0;
		POSITION pos = m_DescList.GetHeadPosition();
		LV_ITEMW lvi;
		//
		// set up the fields in the list view item struct that don't change from item to item
		//
		memset(&lvi, 0, sizeof(LV_ITEMW));
		lvi.mask = LVIF_TEXT;

		m_CertList.SetItemCount((int)m_DescList.GetCount());

		while (pos != NULL)
		{
			CERT_DESCRIPTION * pDesc = m_DescList.GetNext(pos);
			int i;

			lvi.iItem = item;
			lvi.iSubItem = 0;
			lvi.pszText = (LPTSTR)(LPCTSTR)pDesc->m_CommonName;
			lvi.cchTextMax = pDesc->m_CommonName.GetLength();
			i = m_CertList.InsertItem(&lvi);
			ASSERT(i != -1);

			lvi.iItem = i;
			lvi.iSubItem = COL_CA_NAME;
			lvi.pszText = (LPTSTR)(LPCTSTR)pDesc->m_CAName;
			lvi.cchTextMax = pDesc->m_CAName.GetLength();
			VERIFY(m_CertList.SetItem(&lvi));

			lvi.iSubItem = COL_EXPIRATION_DATE;
			lvi.pszText = (LPTSTR)(LPCTSTR)pDesc->m_ExpirationDate;
			lvi.cchTextMax = pDesc->m_ExpirationDate.GetLength();
			VERIFY(m_CertList.SetItem(&lvi));

			lvi.iSubItem = COL_PURPOSE;
			lvi.pszText = (LPTSTR)(LPCTSTR)pDesc->m_Usage;
			lvi.cchTextMax = pDesc->m_Usage.GetLength();
			VERIFY(m_CertList.SetItem(&lvi));

			lvi.iSubItem = COL_FRIENDLY_NAME;
			lvi.pszText = (LPTSTR)(LPCTSTR)pDesc->m_FriendlyName;
			lvi.cchTextMax = pDesc->m_FriendlyName.GetLength();
			VERIFY(m_CertList.SetItem(&lvi));

			// create CRYPT_HASH_BLOB from desc data and put it to list item
			CRYPT_HASH_BLOB * pHashBlob = new CRYPT_HASH_BLOB;
			ASSERT(pHashBlob != NULL);
			pHashBlob->cbData = pDesc->m_hash_length;
			pHashBlob->pbData = pDesc->m_hash;
			VERIFY(m_CertList.SetItemData(item, (LONG_PTR)pHashBlob));

			item++;
		}
	}
	return TRUE;
}

void CChooseCertPage::OnClickCertList(NMHDR* pNMHDR, LRESULT* pResult)
{
	SetWizardButtons(-1 == m_CertList.GetSelectedIndex() ?
					PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);
	*pResult = 0;
}

void CChooseCertPage::OnDestroy()
{
	// before dialog will be desroyed we need to delete all
	// the item data pointers
	int count = m_CertList.GetItemCount();
	for (int index = 0; index < count; index++)
	{
		CRYPT_HASH_BLOB * pData = (CRYPT_HASH_BLOB *)m_CertList.GetItemData(index);
		delete pData;
	}
	CIISWizardPage::OnDestroy();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certwiz\certwiz.cpp ===
// CertWiz.cpp : Implementation of CCertWizApp and DLL registration.

#include "stdafx.h"
#include "CertWiz.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CCertWizApp NEAR theApp;

const GUID CDECL BASED_CODE _tlid =
		{ 0xd4be862f, 0xc85, 0x11d2, { 0x91, 0xb1, 0, 0xc0, 0x4f, 0x8c, 0x87, 0x61 } };
const WORD _wVerMajor = 1;
const WORD _wVerMinor = 0;

const TCHAR szRegistryKey[] = _T("SOFTWARE\\Microsoft\\InetMgr");
const TCHAR szWizardKey[] = _T("CertWiz");

///////////////////////////////////////////////////////////////////////////
// CCertWizApp::InitInstance - DLL initialization

BOOL CCertWizApp::InitInstance()
{
	BOOL bInit = COleControlModule::InitInstance();
	if (bInit)
	{
		AfxEnableControlContainer();
		InitIISUIDll();

        CString sz;
        // set the name of the application correctly
        sz.LoadString(IDS_CERTWIZ);
        // free the existing name, and copy in the new one
        free((void*)m_pszAppName);
        m_pszAppName = _tcsdup(sz);
	}
	return bInit;
}

////////////////////////////////////////////////////////////////////////////
// CCertWizApp::ExitInstance - DLL termination

int CCertWizApp::ExitInstance()
{
	// TODO: Add your own module termination code here.

	return COleControlModule::ExitInstance();
}

HKEY
CCertWizApp::RegOpenKeyWizard()
{
	HKEY hKey = NULL;
	
	CString strKey;
	GetRegistryPath(strKey);
    
	VERIFY(ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, strKey, 0, KEY_ALL_ACCESS, &hKey));
	return hKey;
}

void
CCertWizApp::GetRegistryPath(CString& str)
{
	str = szRegistryKey;
	str += _T("\\");
	str += szWizardKey;
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (!AfxOleRegisterTypeLib(AfxGetInstanceHandle(), _tlid))
		return ResultFromScode(SELFREG_E_TYPELIB);
	if (!COleObjectFactoryEx::UpdateRegistryAll(TRUE))
		return ResultFromScode(SELFREG_E_CLASS);
	
	HKEY hKey;
	int rc = NOERROR;
	if (ERROR_SUCCESS == (rc = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
							szRegistryKey, 0, KEY_CREATE_SUB_KEY, &hKey)))
	{
		HKEY hWizardKey;
		if (ERROR_SUCCESS == (rc = RegCreateKey(hKey, szWizardKey, &hWizardKey)))
		{
			RegCloseKey(hWizardKey);
		}
		RegCloseKey(hKey);
	}

	return rc;
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (!AfxOleUnregisterTypeLib(_tlid, _wVerMajor, _wVerMinor))
		return ResultFromScode(SELFREG_E_TYPELIB);
	if (!COleObjectFactoryEx::UpdateRegistryAll(FALSE))
		return ResultFromScode(SELFREG_E_CLASS);
	// remove CertWiz data from the Registry
	HKEY hKey;
	if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
								szRegistryKey, 0, KEY_ALL_ACCESS, &hKey))
	{
		RegDeleteKey(hKey, szWizardKey);
		RegCloseKey(hKey);
	}

	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certwiz\certwizctl.h ===
#if !defined(AFX_CERTWIZCTL_H__D4BE863F_0C85_11D2_91B1_00C04F8C8761__INCLUDED_)
#define AFX_CERTWIZCTL_H__D4BE863F_0C85_11D2_91B1_00C04F8C8761__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// CertWizCtl.h : Declaration of the CCertWizCtrl ActiveX Control class.

/////////////////////////////////////////////////////////////////////////////
// CCertWizCtrl : See CertWizCtl.cpp for implementation.

class CCertWizCtrl : public COleControl
{
	DECLARE_DYNCREATE(CCertWizCtrl)

// Constructor
public:
	CCertWizCtrl();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CCertWizCtrl)
	public:
	virtual void OnDraw(CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid);
	virtual void DoPropExchange(CPropExchange* pPX);
	virtual void OnResetState();
	virtual DWORD GetControlFlags();
	virtual void OnClick(USHORT iButton);
	//}}AFX_VIRTUAL

// Implementation
protected:
	~CCertWizCtrl();

	DECLARE_OLECREATE_EX(CCertWizCtrl)    // Class factory and guid
	DECLARE_OLETYPELIB(CCertWizCtrl)      // GetTypeInfo
//	DECLARE_PROPPAGEIDS(CCertWizCtrl)     // Property page IDs
	DECLARE_OLECTLTYPE(CCertWizCtrl)		// Type name and misc status

	// Subclassed control support
	BOOL PreCreateWindow(CREATESTRUCT& cs);
	BOOL IsSubclassedControl();
	LRESULT OnOcmCommand(WPARAM wParam, LPARAM lParam);

// Message maps
	//{{AFX_MSG(CCertWizCtrl)
		// NOTE - ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

// Dispatch maps
	//{{AFX_DISPATCH(CCertWizCtrl)
	afx_msg void SetMachineName(LPCTSTR MachineName);
	afx_msg void SetServerInstance(LPCTSTR InstanceName);
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()

// Event maps
	//{{AFX_EVENT(CCertWizCtrl)
	//}}AFX_EVENT
	DECLARE_EVENT_MAP()

// Dispatch and event IDs
public:
	enum {
	//{{AFX_DISP_ID(CCertWizCtrl)
	dispidSetMachineName = 1L,
	dispidSetServerInstance = 2L,
	//}}AFX_DISP_ID
	};
// This project will build only for Unicode
#ifdef _UNICODE
protected:
	CString m_MachineName, m_InstanceName;
#endif
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CERTWIZCTL_H__D4BE863F_0C85_11D2_91B1_00C04F8C8761__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certwiz\choosecsppage.cpp ===
// ChooseCspPage.cpp : implementation file
//

#include "stdafx.h"
#include "CertWiz.h"
#include "ChooseCspPage.h"
#include "Certificat.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CChooseCertPage property page

IMPLEMENT_DYNCREATE(CChooseCspPage, CIISWizardPage)

CChooseCspPage::CChooseCspPage(CCertificate * pCert)
	: CIISWizardPage(CChooseCspPage::IDD, IDS_CERTWIZ, TRUE),
	m_pCert(pCert)
{
	//{{AFX_DATA_INIT(CChooseCspPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CChooseCspPage::~CChooseCspPage()
{
}

void CChooseCspPage::DoDataExchange(CDataExchange* pDX)
{
	CIISWizardPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CChooseCspPage)
	DDX_Control(pDX, IDC_CSP_LIST, m_List);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CChooseCspPage, CIISWizardPage)
	//{{AFX_MSG_MAP(CChooseCspPage)
	ON_LBN_SELCHANGE(IDC_CSP_LIST, OnListSelChange)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CChooseCspPage message handlers

LRESULT CChooseCspPage::OnWizardBack()
{
   return IDD_PREV_PAGE;
}

LRESULT CChooseCspPage::OnWizardNext()
{
	int index = m_List.GetCurSel();
	ASSERT(index != LB_ERR);
	m_List.GetText(index, m_pCert->m_CspName);
   m_pCert->m_CustomProviderType = (DWORD) m_List.GetItemData(index);
   return IDD_NEXT_PAGE;
}

BOOL CChooseCspPage::OnSetActive()
{
	// If nothing is selected -- stay here
   if (!m_pCert->m_CspName.IsEmpty())
   {
      m_List.SelectString(-1, m_pCert->m_CspName);
   }
	SetWizardButtons(LB_ERR == m_List.GetCurSel() ?
					PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);
	return CIISWizardPage::OnSetActive();
}

BOOL CChooseCspPage::OnInitDialog()
{
	ASSERT(m_pCert != NULL);

	CIISWizardPage::OnInitDialog();

	CString str;
   BSTR bstrProvName = NULL;
   DWORD dwType, nProv;
   int j;
   HRESULT hr;

   // array of compatible CSP provider types (see wincrypt.h)
   DWORD IISProvType[] = 
   { 
      PROV_RSA_SCHANNEL,
      PROV_DH_SCHANNEL
   };

   IEnroll * pEnroll = m_pCert->GetEnrollObject();
   ASSERT(pEnroll != NULL);

   // Loop, for each Prov Type
   for (j = 0; j < (sizeof(IISProvType)/sizeof(DWORD)); j++)
   {
      nProv = 0;
    
      // check specific prov type
      dwType = IISProvType[j];
      // pEnroll is previously instantiated ICEnroll interface pointer
      hr = pEnroll->put_ProviderType(dwType);
      if (FAILED(hr))
      {
         TRACE(_T("Failed put_ProviderType - %x\n"), hr);
         goto error;
      }
      // enumerate the CSPs of this type
      int idx;
      while (S_OK == (hr  = pEnroll->enumProvidersWStr(nProv, 0, &bstrProvName)))
      {
         TRACE(_T("Provider %ws (type %d )\n"), bstrProvName, dwType );
         // increment the index
         nProv++;
         // Free this string, so it can be re-used.
         idx = m_List.AddString(bstrProvName);
         m_List.SetItemData(idx, dwType);
         if (NULL != bstrProvName)
         {
            SysFreeString(bstrProvName);
            bstrProvName = NULL;
         }
      }
      // Print message if provider type doesn't have any CSPs.
      if (0 == nProv)
      {
         TRACE(_T("There were no CSPs of type %d\n"), dwType );
      }
   }

error:
   // Clean up resources, etc.
   if (NULL != bstrProvName)
      SysFreeString(bstrProvName);

	return TRUE;
}

void CChooseCspPage::OnListSelChange()
{
	SetWizardButtons(-1 == m_List.GetCurSel() ?
					PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certwiz\choosecatype.cpp ===
// ChooseCAType.cpp : implementation file
//

#include "stdafx.h"
#include "CertWiz.h"
#include "ChooseCAType.h"
#include "CertUtil.H"
#include "Certificat.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CChooseCAType property page

IMPLEMENT_DYNCREATE(CChooseCAType, CIISWizardPage)

CChooseCAType::CChooseCAType(CCertificate * pCert) 
	: CIISWizardPage(CChooseCAType::IDD, IDS_CERTWIZ, TRUE),
	m_pCert(pCert)

{
	//{{AFX_DATA_INIT(CChooseCAType)
	m_Index = -1;
	//}}AFX_DATA_INIT
}

CChooseCAType::~CChooseCAType()
{
}

void CChooseCAType::DoDataExchange(CDataExchange* pDX)
{
	CIISWizardPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CChooseCAType)
	DDX_Radio(pDX, IDC_OFFLINE_RADIO, m_Index);
	//}}AFX_DATA_MAP
}

LRESULT 
CChooseCAType::OnWizardBack()
/*++
Routine Description:
    Prev button handler

Arguments:
    None

Return Value:
	0 to automatically advance to the prev page;
	1 to prevent the page from changing. 
	To jump to a page other than the prev one, 
	return the identifier of the dialog to be displayed.
--*/
{
	if (m_pCert->GetStatusCode() == CCertificate::REQUEST_RENEW_CERT)
		return IDD_PAGE_PREV_RENEW;
	else if (m_pCert->GetStatusCode() == CCertificate::REQUEST_NEW_CERT)
		return IDD_PAGE_PREV_NEW;
	ASSERT(FALSE);
	return 1;
}

LRESULT 
CChooseCAType::OnWizardNext()
/*++
Routine Description:
    Next button handler

Arguments:
    None

Return Value:
	0 to automatically advance to the next page;
	1 to prevent the page from changing. 
	To jump to a page other than the next one, 
	return the identifier of the dialog to be displayed.
--*/
{
	LRESULT id = 1;
	UpdateData();
	m_pCert->m_CAType = m_Index == 0 ? 
		CCertificate::CA_OFFLINE : CCertificate::CA_ONLINE;
	if (m_pCert->GetStatusCode() == CCertificate::REQUEST_RENEW_CERT)
	{
		if (m_pCert->m_CAType == CCertificate::CA_OFFLINE)
			id = IDD_PAGE_NEXT_RENEW_OFFLINE;
		else if (m_pCert->m_CAType == CCertificate::CA_ONLINE)
			id = IDD_PAGE_NEXT_RENEW_ONLINE;
	}
	else if (m_pCert->GetStatusCode() == CCertificate::REQUEST_NEW_CERT)
		id = IDD_PAGE_NEXT_NEW;
	return id;
}

BEGIN_MESSAGE_MAP(CChooseCAType, CIISWizardPage)
	//{{AFX_MSG_MAP(CChooseCAType)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CChooseCAType message handlers

//#define _NO_DISABLE

BOOL CChooseCAType::OnInitDialog() 
{
	CIISWizardPage::OnInitDialog();
	ASSERT(m_pCert != NULL);
	m_Index = m_pCert->m_CAType == CCertificate::CA_OFFLINE ? 0 : 1;
	CString temp;
	m_pCert->GetCertificateTemplate(temp);
#ifdef _NO_DISABLE
	VERIFY(GetOnlineCAList(m_pCert->m_OnlineCAList, L"WebServer", &m_pCert->m_hResult));
#else
	if (!GetOnlineCAList(m_pCert->m_OnlineCAList, L"WebServer", &m_pCert->m_hResult))
	{
		// none online CA present: disable online CA button
		GetDlgItem(IDC_ONLINE_RADIO)->EnableWindow(FALSE);
		m_Index = 0;
	}
#endif
	UpdateData(FALSE);
	return FALSE;
}

BOOL CChooseCAType::OnSetActive() 
{
	SetWizardButtons(PSWIZB_BACK | PSWIZB_NEXT);
	return CIISWizardPage::OnSetActive();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certwiz\certwizctl.cpp ===
// CertWizCtl.cpp : Implementation of the CCertWizCtrl ActiveX Control class.

#include "stdafx.h"
#include "CertWiz.h"
#include "CertWizCtl.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CCertWizCtrl, COleControl)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CCertWizCtrl, COleControl)
	//{{AFX_MSG_MAP(CCertWizCtrl)
	// NOTE - ClassWizard will add and remove message map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG_MAP
	ON_MESSAGE(OCM_COMMAND, OnOcmCommand)
	ON_OLEVERB(AFX_IDS_VERB_PROPERTIES, OnProperties)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Dispatch map

BEGIN_DISPATCH_MAP(CCertWizCtrl, COleControl)
	//{{AFX_DISPATCH_MAP(CCertWizCtrl)
	DISP_FUNCTION(CCertWizCtrl, "SetMachineName", SetMachineName, VT_EMPTY, VTS_BSTR)
	DISP_FUNCTION(CCertWizCtrl, "SetServerInstance", SetServerInstance, VT_EMPTY, VTS_BSTR)
	DISP_STOCKFUNC_DOCLICK()
	//}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()


/////////////////////////////////////////////////////////////////////////////
// Event map

BEGIN_EVENT_MAP(CCertWizCtrl, COleControl)
	//{{AFX_EVENT_MAP(CCertWizCtrl)
	//}}AFX_EVENT_MAP
END_EVENT_MAP()


/////////////////////////////////////////////////////////////////////////////
// Property pages

// TODO: Add more property pages as needed.  Remember to increase the count!
//BEGIN_PROPPAGEIDS(CCertWizCtrl, 1)
//	PROPPAGEID(CCertWizPropPage::guid)
//END_PROPPAGEIDS(CCertWizCtrl)


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CCertWizCtrl, "CERTWIZ.CertWizCtrl.1",
	0xd4be8632, 0xc85, 0x11d2, 0x91, 0xb1, 0, 0xc0, 0x4f, 0x8c, 0x87, 0x61)


/////////////////////////////////////////////////////////////////////////////
// Type library ID and version

IMPLEMENT_OLETYPELIB(CCertWizCtrl, _tlid, _wVerMajor, _wVerMinor)


/////////////////////////////////////////////////////////////////////////////
// Interface IDs

const IID BASED_CODE IID_DCertWiz =
		{ 0xd4be8630, 0xc85, 0x11d2, { 0x91, 0xb1, 0, 0xc0, 0x4f, 0x8c, 0x87, 0x61 } };
const IID BASED_CODE IID_DCertWizEvents =
		{ 0xd4be8631, 0xc85, 0x11d2, { 0x91, 0xb1, 0, 0xc0, 0x4f, 0x8c, 0x87, 0x61 } };


/////////////////////////////////////////////////////////////////////////////
// Control type information

static const DWORD BASED_CODE _dwCertWizOleMisc =
	OLEMISC_INVISIBLEATRUNTIME |
	OLEMISC_SETCLIENTSITEFIRST |
	OLEMISC_INSIDEOUT |
	OLEMISC_CANTLINKINSIDE |
	OLEMISC_RECOMPOSEONRESIZE;

IMPLEMENT_OLECTLTYPE(CCertWizCtrl, IDS_CERTWIZ, _dwCertWizOleMisc)


/////////////////////////////////////////////////////////////////////////////
// CCertWizCtrl::CCertWizCtrlFactory::UpdateRegistry -
// Adds or removes system registry entries for CCertWizCtrl

BOOL CCertWizCtrl::CCertWizCtrlFactory::UpdateRegistry(BOOL bRegister)
{
	// TODO: Verify that your control follows apartment-model threading rules.
	// Refer to MFC TechNote 64 for more information.
	// If your control does not conform to the apartment-model rules, then
	// you must modify the code below, changing the 6th parameter from
	// afxRegApartmentThreading to 0.

	if (bRegister)
		return AfxOleRegisterControlClass(
			AfxGetInstanceHandle(),
			m_clsid,
			m_lpszProgID,
			IDS_CERTWIZ,
			IDB_CERTWIZ,
			afxRegApartmentThreading,
			_dwCertWizOleMisc,
			_tlid,
			_wVerMajor,
			_wVerMinor);
	else
		return AfxOleUnregisterClass(m_clsid, m_lpszProgID);
}


/////////////////////////////////////////////////////////////////////////////
// CCertWizCtrl::CCertWizCtrl - Constructor

CCertWizCtrl::CCertWizCtrl()
{
	InitializeIIDs(&IID_DCertWiz, &IID_DCertWizEvents);

	// TODO: Initialize your control's instance data here.
}


/////////////////////////////////////////////////////////////////////////////
// CCertWizCtrl::~CCertWizCtrl - Destructor

CCertWizCtrl::~CCertWizCtrl()
{
	// TODO: Cleanup your control's instance data here.
}


/////////////////////////////////////////////////////////////////////////////
// CCertWizCtrl::OnDraw - Drawing function

void CCertWizCtrl::OnDraw(
			CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid)
{
	DoSuperclassPaint(pdc, rcBounds);
}


/////////////////////////////////////////////////////////////////////////////
// CCertWizCtrl::DoPropExchange - Persistence support

void CCertWizCtrl::DoPropExchange(CPropExchange* pPX)
{
	ExchangeVersion(pPX, MAKELONG(_wVerMinor, _wVerMajor));
	COleControl::DoPropExchange(pPX);

	// TODO: Call PX_ functions for each persistent custom property.

}


/////////////////////////////////////////////////////////////////////////////
// CCertWizCtrl::GetControlFlags -
// Flags to customize MFC's implementation of ActiveX controls.
//
// For information on using these flags, please see MFC technical note
// #nnn, "Optimizing an ActiveX Control".
DWORD CCertWizCtrl::GetControlFlags()
{
	DWORD dwFlags = COleControl::GetControlFlags();


	// The control can activate without creating a window.
	// TODO: when writing the control's message handlers, avoid using
	//		the m_hWnd member variable without first checking that its
	//		value is non-NULL.
	dwFlags |= windowlessActivate;
	return dwFlags;
}


/////////////////////////////////////////////////////////////////////////////
// CCertWizCtrl::OnResetState - Reset control to default state

void CCertWizCtrl::OnResetState()
{
	COleControl::OnResetState();  // Resets defaults found in DoPropExchange

	// TODO: Reset any other control state here.
}


/////////////////////////////////////////////////////////////////////////////
// CCertWizCtrl::PreCreateWindow - Modify parameters for CreateWindowEx

BOOL CCertWizCtrl::PreCreateWindow(CREATESTRUCT& cs)
{
	cs.lpszClass = _T("BUTTON");
	return COleControl::PreCreateWindow(cs);
}


/////////////////////////////////////////////////////////////////////////////
// CCertWizCtrl::IsSubclassedControl - This is a subclassed control

BOOL CCertWizCtrl::IsSubclassedControl()
{
	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CCertWizCtrl::OnOcmCommand - Handle command messages

LRESULT CCertWizCtrl::OnOcmCommand(WPARAM wParam, LPARAM lParam)
{
#ifdef _WIN32
	WORD wNotifyCode = HIWORD(wParam);
#else
	WORD wNotifyCode = HIWORD(lParam);
#endif

	// TODO: Switch on wNotifyCode here.

	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CCertWizCtrl message handlers

#include "WelcomePage.h"
#include "FinalPages.h"
#include "CertContentsPages.h"
#include "GetWhatPage.h"
#include "ChooseCAType.h"
#include "SecuritySettingsPage.h"
#include "ChooseCspPage.h"
#include "OrgInfoPage.h"
#include "SiteNamePage.h"
#include "GeoInfoPage.h"
#include "ChooseFileName.h"
#include "ChooseOnlinePage.h"
#include "WhatToDoPendingPage.h"
#include "ManageCertPage.h"
#include "ChooseCertPage.h"
#include "KeyPasswordPage.h"
#include "Certificat.h"

void CCertWizCtrl::OnClick(USHORT iButton) 
{
	CIISWizardSheet propsheet(IDB_WIZ_LEFT, IDB_WIZ_TOP);

	CCertificate * cert = new CCertificate;

	ASSERT(!m_InstanceName.IsEmpty());
	cert->m_WebSiteInstanceName = m_InstanceName;
	cert->m_MachineName = m_MachineName;
	VERIFY(cert->Init());

	CWelcomePage welcome_page(cert);
	CGetWhatPage get_what_page(cert);
	CChooseCAType choose_ca_page(cert);
	CSecuritySettingsPage security_settings_page(cert);
   CChooseCspPage csp_page(cert);
	COrgInfoPage org_info_page(cert);
	CSiteNamePage site_name_page(cert);
	CGeoInfoPage geo_info_page(cert);
	CChooseReqFile choose_reqfile_name(cert);
	CChooseRespFile choose_respfile_name(cert);
	CChooseKeyFile choose_keyfile_name(cert);
	CRequestToFilePage check_request(cert);
	CFinalToFilePage final_tofile_page(&cert->m_hResult, cert);
	CChooseOnlinePage choose_online(cert);
	COnlineRequestSubmit online_request_dump(cert);
	CWhatToDoPendingPage what_pending(cert);
	CInstallRespPage install_resp(cert);
	CManageCertPage manage_cert(cert);
	CFinalInstalledPage final_install(&cert->m_hResult, cert);
	CRemoveCertPage remove_cert(cert);
	CFinalRemovePage final_remove(&cert->m_hResult, cert);
	CReplaceCertPage replace_cert(cert);
	CFinalReplacedPage final_replace(&cert->m_hResult, cert);
	CChooseCertPage choose_cert(cert);
	CInstallCertPage install_cert(cert);
	CRequestCancelPage cancel_request(cert);
	CFinalCancelPage final_cancel(&cert->m_hResult, cert);
	CKeyPasswordPage key_password_page(cert);
	CInstallKeyPage install_key(cert);

	propsheet.AddPage(&welcome_page);
	propsheet.AddPage(&get_what_page);
	propsheet.AddPage(&choose_ca_page);
	propsheet.AddPage(&security_settings_page);
   propsheet.AddPage(&csp_page);
	propsheet.AddPage(&org_info_page);
	propsheet.AddPage(&site_name_page);
	propsheet.AddPage(&geo_info_page);
	propsheet.AddPage(&choose_reqfile_name);
	propsheet.AddPage(&choose_respfile_name);
	propsheet.AddPage(&choose_keyfile_name);
	propsheet.AddPage(&check_request);
	propsheet.AddPage(&final_tofile_page);
	propsheet.AddPage(&choose_online);
	propsheet.AddPage(&online_request_dump);
	propsheet.AddPage(&what_pending);
	propsheet.AddPage(&install_resp);
	propsheet.AddPage(&manage_cert);
	propsheet.AddPage(&final_install);
	propsheet.AddPage(&remove_cert);
	propsheet.AddPage(&final_remove);
	propsheet.AddPage(&choose_cert);
	propsheet.AddPage(&replace_cert);
	propsheet.AddPage(&final_replace);
	propsheet.AddPage(&install_cert);
	propsheet.AddPage(&cancel_request);
	propsheet.AddPage(&final_cancel);
	propsheet.AddPage(&key_password_page);
	propsheet.AddPage(&install_key);

	if (IDCANCEL != propsheet.DoModal())
	{
		// save our settings to the Registry
		VERIFY(cert->SaveSettings());
	}
   delete cert;
}

void CCertWizCtrl::SetMachineName(LPCTSTR MachineName) 
{
	m_MachineName = MachineName;
}

void CCertWizCtrl::SetServerInstance(LPCTSTR InstanceName) 
{
	m_InstanceName = InstanceName;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certwiz\choosecertpage.h ===
#if !defined(AFX_REPLACECHOOSECERT_H__F126182F_4039_11D2_9318_0060088FF80E__INCLUDED_)
#define AFX_REPLACECHOOSECERT_H__F126182F_4039_11D2_9318_0060088FF80E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ChooseCertPage.h : header file
//
#include "Certificat.h"
/////////////////////////////////////////////////////////////////////////////
// CChooseCertPage dialog

class CCertListCtrl : public CListCtrl
{
public:
	int GetSelectedIndex();
	void AdjustStyle();
};

class CChooseCertPage : public CIISWizardPage
{
	DECLARE_DYNCREATE(CChooseCertPage)

// Construction
public:
	CChooseCertPage(CCertificate * pCert = NULL);
	~CChooseCertPage();

	enum
	{
		IDD_PAGE_NEXT_REPLACE = IDD_PAGE_WIZ_REPLACE_CERT,
		IDD_PAGE_NEXT_INSTALL = IDD_PAGE_WIZ_INSTALL_CERT,
		IDD_PAGE_PREV_REPLACE = IDD_PAGE_WIZ_MANAGE_CERT,
		IDD_PAGE_PREV_INSTALL = IDD_PAGE_WIZ_GET_WHAT
	};
// Dialog Data
	//{{AFX_DATA(CChooseCertPage)
	enum { IDD = IDD_PAGE_WIZ_CHOOSE_CERT };
	CCertListCtrl	m_CertList;
	//}}AFX_DATA
	CCertificate * m_pCert;
	CCertDescList m_DescList;


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CChooseCertPage)
	public:
	virtual LRESULT OnWizardBack();
	virtual LRESULT OnWizardNext();
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CChooseCertPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnClickCertList(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_REPLACECHOOSECERT_H__F126182F_4039_11D2_9318_0060088FF80E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certwiz\choosecatype.h ===
#if !defined(AFX_CHOOSECATYPE_H__1FE282A3_29AD_11D2_97AD_000000000000__INCLUDED_)
#define AFX_CHOOSECATYPE_H__1FE282A3_29AD_11D2_97AD_000000000000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ChooseCAType.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CChooseCAType dialog
class CCertificate;

class CChooseCAType : public CIISWizardPage
{
	DECLARE_DYNCREATE(CChooseCAType)

// Construction
public:
	CChooseCAType(CCertificate * pCert = NULL);
	~CChooseCAType();

	enum
	{
		IDD_PAGE_NEXT_NEW = IDD_PAGE_WIZ_SECURITY_SETTINGS,
		IDD_PAGE_PREV_NEW = IDD_PAGE_WIZ_GET_WHAT,
		IDD_PAGE_NEXT_RENEW_OFFLINE = IDD_PAGE_WIZ_CHOOSE_FILENAME,
		IDD_PAGE_NEXT_RENEW_ONLINE = IDD_PAGE_WIZ_CHOOSE_ONLINE,
		IDD_PAGE_PREV_RENEW = IDD_PAGE_WIZ_MANAGE_CERT
	};
// Dialog Data
	//{{AFX_DATA(CChooseCAType)
	enum { IDD = IDD_PAGE_WIZ_CHOOSE_CATYPE };
	int		m_Index;
	//}}AFX_DATA
	CCertificate * m_pCert;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CChooseCAType)
	public:
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CChooseCAType)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CHOOSECATYPE_H__1FE282A3_29AD_11D2_97AD_000000000000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certwiz\choosecsppage.h ===
#if !defined(_CHOOSECSPPAGE_H)
#define _CHOOSECSPPAGE_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ChooseCertPage.h : header file
//
#include "Certificat.h"
/////////////////////////////////////////////////////////////////////////////
// CChooseCertPage dialog

class CChooseCspPage : public CIISWizardPage
{
	DECLARE_DYNCREATE(CChooseCspPage)

// Construction
public:
	CChooseCspPage(CCertificate * pCert = NULL);
	~CChooseCspPage();

	enum
	{
		IDD_PREV_PAGE = IDD_PAGE_WIZ_SECURITY_SETTINGS,
		IDD_NEXT_PAGE = IDD_PAGE_WIZ_ORG_INFO,
	};
// Dialog Data
	//{{AFX_DATA(CChooseCspPage)
	enum { IDD = IDD_PAGE_WIZ_CHOOSE_CSP };
	CListBox	m_List;
	//}}AFX_DATA
	CCertificate * m_pCert;


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CChooseCspPage)
	public:
	virtual LRESULT OnWizardBack();
	virtual LRESULT OnWizardNext();
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CChooseCspPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnListSelChange();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(_CHOOSECSPPAGE_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certwiz\chooseonlinepage.h ===
#if !defined(AFX_CHOOSEONLINEPAGE_H__5760F32A_144F_11D2_8A1E_000000000000__INCLUDED_)
#define AFX_CHOOSEONLINEPAGE_H__5760F32A_144F_11D2_8A1E_000000000000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ChooseOnlinePage.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CChooseCAPage dialog
class CCertificate;

class CChooseOnlinePage : public CIISWizardPage
{
	DECLARE_DYNCREATE(CChooseOnlinePage)

// Construction
public:
	CChooseOnlinePage(CCertificate * pCert = NULL);
	~CChooseOnlinePage();

	enum
	{
		IDD_PAGE_NEXT = IDD_PAGE_WIZ_ONLINE_DUMP,
		IDD_PAGE_PREV_NEW = IDD_PAGE_WIZ_GEO_INFO,
		IDD_PAGE_PREV_RENEW = IDD_PAGE_WIZ_CHOOSE_CATYPE
	};
// Dialog Data
	//{{AFX_DATA(CChooseCAPage)
	enum { IDD = IDD_PAGE_WIZ_CHOOSE_ONLINE };
	int		m_CAIndex;
	//}}AFX_DATA
	CCertificate * m_pCert;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CChooseOnlinePage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	public:
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CChooseOnlinePage)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CHOOSEONLINEPAGE_H__5760F32A_144F_11D2_8A1E_000000000000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certwiz\choosefilename.cpp ===
// ChooseFileNamePage.cpp : implementation file
//

#include "stdafx.h"
#include "CertWiz.h"
#include "ChooseFileName.h"
#include "Certificat.h"
#include "Shlwapi.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CChooseFileNamePage property page

IMPLEMENT_DYNCREATE(CChooseFileNamePage, CIISWizardPage)

CChooseFileNamePage::CChooseFileNamePage(UINT id, 
													  UINT defaultID,
													  UINT extID,
													  UINT filterID,
													  CString * pOutFileName) 
	: CIISWizardPage(id, IDS_CERTWIZ, TRUE),
	m_id(id),
	m_defaultID(defaultID),
	m_DoReplaceFile(FALSE),
	m_pOutFileName(pOutFileName)
{
	//{{AFX_DATA_INIT(CChooseFileNamePage)
	m_FileName = _T("");
	//}}AFX_DATA_INIT
	if (extID != 0)
		ext.LoadString(extID);
	if (filterID != 0)
		filter.LoadString(filterID);
	// replace '!'s in this string to null chars
	for (int i = 0; i < filter.GetLength(); i++)
	{
		if (filter[i] == L'!')
			filter.SetAt(i, L'\0');
	}
}

CChooseFileNamePage::~CChooseFileNamePage()
{
}

void CChooseFileNamePage::DoDataExchange(CDataExchange* pDX)
{
	CIISWizardPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CChooseFileNamePage)
	DDX_Text(pDX, IDC_FILE_NAME, m_FileName);
	//}}AFX_DATA_MAP
}

LRESULT 
CChooseFileNamePage::OnWizardBack()
{
	ASSERT(FALSE);
	return 1;
}

static BOOL
AnswerIsYes(UINT id, CString& file)
{
	CString strMessage;
	AfxFormatString1(strMessage, id, file);
	return (IDYES == AfxMessageBox(strMessage, MB_ICONEXCLAMATION | MB_YESNO));
}

#if 0
#define SHOW_MESSAGE_BOX(id,str)\
	do {\
		CString strMessage;\
		AfxFormatString1(strMessage, (id), (str));\
		if (IDNO == AfxMessageBox(strMessage, MB_ICONEXCLAMATION | MB_YESNO))\
		{\
			CEdit * pEdit = (CEdit *)CWnd::FromHandle(GetDlgItem(IDC_FILE_NAME)->m_hWnd);\
			pEdit->SetSel(0, -1);\
			pEdit->SetFocus();\
			return 1;\
		}\
	} while(FALSE)
#endif

LRESULT CChooseFileNamePage::DoWizardNext(LRESULT id)
{
	if (id != 1)
	{
		ASSERT(m_pOutFileName != NULL);
		*m_pOutFileName = m_FileName;
	}
	else
	{
		UpdateData(FALSE);
		SetWizardButtons(PSWIZB_BACK);
		GetDlgItem(IDC_FILE_NAME)->SendMessage(EM_SETSEL, 0, -1);
		GetDlgItem(IDC_FILE_NAME)->SetFocus();
		MessageBeep(MB_ICONQUESTION);
	}
	return id;
}

BOOL CChooseFileNamePage::OnSetActive()
{
	SetWizardButtons(m_FileName.IsEmpty() ? 
			PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);
   return CIISWizardPage::OnSetActive();
}

BEGIN_MESSAGE_MAP(CChooseFileNamePage, CIISWizardPage)
	//{{AFX_MSG_MAP(CChooseCAPage)
	ON_BN_CLICKED(IDC_BROWSE_BTN, OnBrowseBtn)
	ON_EN_CHANGE(IDC_FILE_NAME, OnChangeFileName)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CChooseCAPage message handlers

void CChooseFileNamePage::OnBrowseBtn() 
{
	ASSERT(FALSE);
}

void CChooseFileNamePage::Browse(CString& strPath, CString& strFile)
{
	if (strPath.IsEmpty())
	{
		::GetCurrentDirectory(MAX_PATH, strPath.GetBuffer(MAX_PATH + 1));
		strPath.ReleaseBuffer();
	}

	CFileDialog fileName(IsReadFileDlg());
	fileName.m_ofn.Flags |= OFN_NOCHANGEDIR | OFN_OVERWRITEPROMPT;
	if (IsReadFileDlg())
		fileName.m_ofn.Flags |= OFN_PATHMUSTEXIST;
	else
		fileName.m_ofn.Flags |= OFN_NOREADONLYRETURN;
	// We need to disable hook to show new style of File Dialog
	fileName.m_ofn.Flags &= ~(OFN_ENABLEHOOK);
	CString strExt = _T("*");
	strExt += ext;
	fileName.m_ofn.lpstrDefExt = strExt;
	fileName.m_ofn.lpstrFile = strFile.GetBuffer(MAX_PATH+1);
	fileName.m_ofn.nMaxFile = MAX_PATH;
	fileName.m_ofn.lpstrInitialDir = strPath.IsEmpty() ? NULL : (LPCTSTR)strPath;
	fileName.m_ofn.lpstrFilter = filter;
	fileName.m_ofn.nFilterIndex = 0;
	if (IDOK == fileName.DoModal())
	{
		ASSERT(NULL != GetDlgItem(IDC_FILE_NAME));
		CString strPrev;
		GetDlgItemText(IDC_FILE_NAME, strPrev);
		if (strPrev.CompareNoCase(strFile) != 0)
		{
			SetDlgItemText(IDC_FILE_NAME, strFile);
			m_DoReplaceFile = TRUE;
			FileNameChanged();
		}
	}
	strFile.ReleaseBuffer();
}

BOOL CChooseFileNamePage::OnInitDialog() 
{
	CIISWizardPage::OnInitDialog();
	
	SHAutoComplete(GetDlgItem(IDC_FILE_NAME)->m_hWnd, SHACF_FILESYSTEM);
	GetDlgItem(IDC_FILE_NAME)->SetFocus();
	SetWizardButtons(m_FileName.IsEmpty() ? 
			PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);
	return FALSE;
}

void CChooseFileNamePage::OnChangeFileName() 
{
	UpdateData(TRUE);
	//
	// Our replacement flag is not valid now:
	// It may be set to TRUE only when name was entered through
	// FileOpen dialog box which asks user about replacing itself
	//
	m_DoReplaceFile = FALSE;
	SetWizardButtons(m_FileName.IsEmpty() ? 
			PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);
	// call virtual handler to notify inherited classes
	FileNameChanged();
}

void
CChooseFileNamePage::GetDefaultFileName(CString& str)
{
	if (m_defaultID != 0)
		str.LoadString(m_defaultID);
	// set system disk letter to the string
	TCHAR sz[MAX_PATH];
	if (MAX_PATH >= GetSystemDirectory(sz, MAX_PATH))
	{
		str.SetAt(0, sz[0]);
		str.MakeLower();
	}
}

/////////////////////////////////////////////////////////////////////////////
// CChooseReadFileName property page
IMPLEMENT_DYNCREATE(CChooseReadFileName, CChooseFileNamePage)

CChooseReadFileName::CChooseReadFileName(UINT id,
											UINT defaultID,
											UINT extID,
											UINT filterID,
											CString * pOutFileName
											)
	: CChooseFileNamePage(id, defaultID, extID, filterID, pOutFileName)
{
}

BEGIN_MESSAGE_MAP(CChooseReadFileName, CChooseFileNamePage)
	//{{AFX_MSG_MAP(CChooseReadFileName)
	ON_BN_CLICKED(IDC_BROWSE_BTN, OnBrowseBtn)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BOOL
CChooseReadFileName::OnInitDialog()
{
	GetDefaultFileName(m_FileName);
	// check if this default file exists
	if (!PathFileExists(m_FileName))
	{
		// try to find first file with this extension
		CString find_str = m_FileName;
		WIN32_FIND_DATA find_data;
		PathRemoveFileSpec(find_str.GetBuffer(MAX_PATH));
		find_str.ReleaseBuffer();
		find_str += _T("*");
		find_str += ext;
		HANDLE hFind = FindFirstFile(find_str, &find_data);
		if (	hFind != INVALID_HANDLE_VALUE 
			&& (find_data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0
			)
		{
			PathRemoveFileSpec(m_FileName.GetBuffer(MAX_PATH));
			m_FileName.ReleaseBuffer();
			m_FileName += find_data.cFileName;
			FindClose(hFind);
		}
		else
		{
			// if nothing found, just attach *.exe to the path
			// it will prevent user from just clicking Next
			m_FileName = find_str;
		}
	}
	return CChooseFileNamePage::OnInitDialog();
}

LRESULT
CChooseReadFileName::OnWizardNext()
{
	LRESULT id = 0;
	CString buf;

	UpdateData();
	// check if this file exists
	if (	!PathFileExists(m_FileName) 
		&&	!PathIsDirectory(m_FileName)
		)
	{
		// try with default extension if it is just filename
		CString str = m_FileName;
		LPTSTR p = PathFindExtension(str);
		if (p != NULL && *p == 0)
		{
			str += ext;
			if (PathFileExists(str))
			{
				m_FileName = str;
				goto DoNext;
			}
		}
		AfxFormatString1(buf, IDS_FILE_DOES_NOT_EXIST, m_FileName);
		AfxMessageBox(buf, MB_OK);
		id = 1;
	}
	else if (PathIsDirectory(m_FileName))
	{
		AfxFormatString1(buf, IDS_FILE_IS_DIRECTORY, m_FileName);
		AfxMessageBox(buf, MB_OK);
		if (m_FileName.Right(1) != L'\\')
			m_FileName += _T("\\");
		id = 1;
	}
DoNext:
	return DoWizardNext(id);
}

void CChooseReadFileName::OnBrowseBtn() 
{
	CString strFile, strPath;
	GetDlgItemText(IDC_FILE_NAME, m_FileName);

	if (!PathFileExists(m_FileName))
	{
		int n = m_FileName.ReverseFind(_T('\\'));
		if (n != -1)
		{
			strPath = m_FileName.Left(n);
			if (!PathFileExists(strPath))
			{
				strPath.Empty();
				strFile = m_FileName.Right(m_FileName.GetLength() - n - 1);
			}
			else if (PathIsDirectory(strPath))
			{
				strFile = m_FileName.Right(m_FileName.GetLength() - n - 1);
			}
		}
		else
			strFile = m_FileName;
	} 
	else if (PathIsDirectory(m_FileName)) 
	{
		strPath = m_FileName;
	}
	else
	{
		// split filename and path
		strPath = m_FileName;
		PathRemoveFileSpec(strPath.GetBuffer(0));
		strPath.ReleaseBuffer();
		strFile = PathFindFileName(m_FileName);
	}
	CChooseFileNamePage::Browse(strPath, strFile);
}

/////////////////////////////////////////////////////////////////////////////
// CChooseWriteFileName

IMPLEMENT_DYNCREATE(CChooseWriteFileName, CChooseFileNamePage)

CChooseWriteFileName::CChooseWriteFileName(UINT id,
											UINT defaultID,
											UINT extID,
											UINT filterID,
											CString * pOutFileName
											)
	: CChooseFileNamePage(id, defaultID, extID, filterID, pOutFileName)
{
}

BEGIN_MESSAGE_MAP(CChooseWriteFileName, CChooseFileNamePage)
	//{{AFX_MSG_MAP(CChooseWriteFileName)
	ON_BN_CLICKED(IDC_BROWSE_BTN, OnBrowseBtn)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BOOL
CChooseWriteFileName::OnInitDialog()
{
	GetDefaultFileName(m_FileName);
	return CChooseFileNamePage::OnInitDialog();
}

LRESULT 
CChooseWriteFileName::OnWizardNext()
{
	LRESULT id = 0;
	UpdateData();
	CString fileName = m_FileName, strPathOnly;
	if (PathIsURL(fileName))
	{
		// we cannot use URLs
		id = 1;
		goto ExitPoint;
	}
	if (PathIsUNC(fileName))
	{
		if (PathIsUNCServer(fileName))
		{
			// path is incomplete
			id = 1;
			goto ExitPoint;
		}
		if (PathIsUNCServerShare(fileName))
		{
			// path is incomplete
			id = 1;
			goto ExitPoint;
		}
	}
	// If it is not an UNC, then make sure we have absolute path
	else if (PathIsRelative(fileName))
	{
		// We will make path from default drive root, 
		// not from current directory
		CString path;
		if (0 != GetCurrentDirectory(MAX_PATH, path.GetBuffer(MAX_PATH)))
		{
			TCHAR szRoot[5];
			fileName = PathBuildRoot(szRoot, PathGetDriveNumber(path));
			PathAppend(fileName.GetBuffer(MAX_PATH), m_FileName);
			fileName.ReleaseBuffer();
		}
		else
			ASSERT(FALSE);
	}

	// Check if we already have file with this name
	if (PathFileExists(fileName))
	{
		// if it is directory, do nothing, file spec is incomplete
		if (PathIsDirectory(fileName))
			id = 1;
		else
		{
			if (!m_DoReplaceFile)
				id = AnswerIsYes(IDS_REPLACE_FILE, fileName) ? 0 : 1;
		}
		goto ExitPoint;
	}

	// File does not exists
	//
	// we should check, if target directory exists
	strPathOnly = fileName;
	if (strPathOnly.Right(1) != _T('\\'))
	{
		if (PathRemoveFileSpec(strPathOnly.GetBuffer(MAX_PATH)))
		{
			if (PathIsUNCServerShare(strPathOnly))
			{
				// check if we have write access to this
				if (GetFileAttributes(strPathOnly) & FILE_ATTRIBUTE_READONLY)
				{
					id = 1; 
					goto ExitPoint;
				}
			}
			if (!PathIsDirectory(strPathOnly))
			{
				id = AnswerIsYes(IDS_ASK_CREATE_DIR, strPathOnly) ? 0 : 1;
				goto ExitPoint;
			}
		}
		strPathOnly.ReleaseBuffer();
		// If user entered filename with dot only (qqqq.) it means
		// that no extension should be used
		if (fileName.Right(1) == _T("."))
		{
			// remove this dot and check if this file exists
			fileName.ReleaseBuffer(fileName.GetLength() - 1);
			if (PathIsDirectory(fileName))
			{
				id = 1;
			}
			else if (PathFileExists(fileName))
			{
				id = AnswerIsYes(IDS_REPLACE_FILE, fileName) ? 0 : 1;
			}
			goto ExitPoint;
		}
	}
	else
	{
		// not clear, what to do with this
		id = 1;
		goto ExitPoint;
	}
	// It could be just a file name, without extension, try
	// with default extension now
	if (PathFindExtension(fileName) == NULL)
	{
		fileName += ext;
		if (PathIsDirectory(fileName))
		{
			id = 1;
		}
		else if (PathFileExists(fileName))
		{
			id = AnswerIsYes(IDS_REPLACE_FILE, fileName) ? 0 : 1;
		}
		goto ExitPoint;
	}

ExitPoint:

	fileName.MakeLower();
	m_FileName = fileName;
	// prepare to go to the next page
	return DoWizardNext(id);
}

// I try to start FileOpen dialog in some reasonable directory
// 
void CChooseWriteFileName::OnBrowseBtn()
{
	CString strPath, strFile;
	UpdateData();
	strPath = m_FileName;
	if (!PathIsDirectory(strPath))
	{
		LPTSTR pPath = strPath.GetBuffer(strPath.GetLength());
		if (PathRemoveFileSpec(pPath))
		{
			// check if path part of filename exists
			if (PathIsDirectory(pPath))
			{
				// we will use non-path part of spec as a filename
				strFile = PathFindFileName(m_FileName);
			}
			else
			{
				// it is wrong path, use default one
				// TODO: actually I need to take from filespec all existent
				// chunks of path and filename, for example c:\aa\bb\cc\dd.txt,
				// if c:\aa\bb exists, then strPath should be set to c:\aa\bb,
				// and strFile to dd.txt
				strPath.Empty();
			}
		}
		else
		{
			// it is filename only
			strFile = m_FileName;
			strPath.Empty();
		}
		strPath.ReleaseBuffer();
	}
	CChooseFileNamePage::Browse(strPath, strFile);
}

/////////////////////////////////////////////////////////////////////////////
// CChooseRespFile property page

IMPLEMENT_DYNCREATE(CChooseRespFile, CChooseFileNamePage)

CChooseRespFile::CChooseRespFile(CCertificate * pCert) 
	: CChooseReadFileName(CChooseRespFile::IDD,
								 IDS_RESP_FILE_DEFAULT,
								 IDS_RESP_FILE_EXT,
								 IDS_RESP_FILE_FILTER,
								 &pCert->m_RespFileName),
	m_pCert(pCert)
{
	//{{AFX_DATA_INIT(CChooseRespFile)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CChooseRespFile::~CChooseRespFile()
{
}

void CChooseRespFile::FileNameChanged()
{
	// we should remove any error messages now
	SetDlgItemText(IDC_ERROR_MSG, _T(""));
	GetDlgItem(IDC_ERROR_MSG)->InvalidateRect(NULL, TRUE);
	GetDlgItem(IDC_ERROR_MSG)->UpdateWindow();
}

void CChooseRespFile::DoDataExchange(CDataExchange* pDX)
{
	CChooseReadFileName::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CChooseRespFile)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CChooseRespFile, CChooseReadFileName)
	//{{AFX_MSG_MAP(CChooseRespFile)
    ON_WM_CTLCOLOR()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CChooseRespFile message handlers

HBRUSH 
CChooseRespFile::OnCtlColor(
    IN CDC * pDC, 
    IN CWnd * pWnd, 
    IN UINT nCtlColor
    )
{
	if (pWnd->GetDlgCtrlID() == IDC_ERROR_MSG)
	{
		//
		// Default processing...
		//
		return CPropertyPage::OnCtlColor(pDC, pWnd, nCtlColor);
	}
	else
		return CIISWizardPage::OnCtlColor(pDC, pWnd, nCtlColor);
}

LRESULT CChooseRespFile::OnWizardNext() 
{
	LRESULT id = 1;
	// Parent class will check all about files
	if (1 != CChooseReadFileName::OnWizardNext())
	{
		m_pCert->m_RespFileName = m_FileName;
		if (m_pCert->GetResponseCert() == NULL)
		{
			CString strInstanceName;
			CString str;
			// it is possible, that this is wrong response file
			// we will try to inform user, for which site this response
			// file was created
			if (m_pCert->FindInstanceNameForResponse(strInstanceName))
			{
				AfxFormatString1(str, IDS_CERTKEY_MISMATCH_ERROR1, strInstanceName);
			}
			// it is possible that this certificate response file already have been processed
			// in this case it should be in MY store
			else if (m_pCert->IsResponseInstalled(strInstanceName))
			{
				if (!strInstanceName.IsEmpty())
					AfxFormatString1(str, 
						IDS_CERTKEY_ALREADY_INSTALLED_WHERE, strInstanceName);
				else
					str.LoadString(IDS_CERTKEY_ALREADY_INSTALLED);
			}
			else
			{
				// request probably was canceled
				str.LoadString(IDS_CERTKEY_MISMATCH_ERROR2);
			}
			SetDlgItemText(IDC_ERROR_MSG, str);
			SetWizardButtons(PSWIZB_BACK);
		}
		else
			id = IDD_PAGE_NEXT;
	}
	return id;
}

LRESULT 
CChooseRespFile::OnWizardBack()
{
	return IDD_PAGE_PREV;
}

/////////////////////////////////////////////////////////////////////////////
// CChooseReqFile property page

IMPLEMENT_DYNCREATE(CChooseReqFile, CChooseWriteFileName)

CChooseReqFile::CChooseReqFile(CCertificate * pCert) 
	: CChooseWriteFileName(CChooseReqFile::IDD,
								 IDS_REQ_FILE_DEFAULT,
								 IDS_REQ_FILE_EXT,
								 IDS_REQ_FILE_FILTER,
								 &pCert->m_ReqFileName),
	m_pCert(pCert)
{
	//{{AFX_DATA_INIT(CChooseRespFile)
	//}}AFX_DATA_INIT
}

CChooseReqFile::~CChooseReqFile()
{
}

void CChooseReqFile::DoDataExchange(CDataExchange* pDX)
{
	CChooseWriteFileName::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CChooseRespFile)
	//}}AFX_DATA_MAP
}

LRESULT 
CChooseReqFile::OnWizardBack()
{
	return IDD_PAGE_PREV;
}

LRESULT 
CChooseReqFile::OnWizardNext()
{
	if (CChooseWriteFileName::OnWizardNext() != 1)
		return IDD_PAGE_NEXT;
	return 1;
}

BEGIN_MESSAGE_MAP(CChooseReqFile, CChooseWriteFileName)
	//{{AFX_MSG_MAP(CChooseReqFile)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CChooseReqFile message handlers

/////////////////////////////////////////////////////////////////////////////
// CChooseKeyFile property page

IMPLEMENT_DYNCREATE(CChooseKeyFile, CChooseReadFileName)

CChooseKeyFile::CChooseKeyFile(CCertificate * pCert) 
	: CChooseReadFileName(CChooseKeyFile::IDD,
								 IDS_KEY_FILE_DEFAULT,
								 IDS_KEY_FILE_EXT,
								 IDS_KEY_FILE_FILTER,
								 &pCert->m_KeyFileName),
	m_pCert(pCert)
{
}

CChooseKeyFile::~CChooseKeyFile()
{
}

void CChooseKeyFile::DoDataExchange(CDataExchange* pDX)
{
	CChooseReadFileName::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CChooseRespFile)
	//}}AFX_DATA_MAP
}

LRESULT 
CChooseKeyFile::OnWizardBack()
{
	return IDD_PAGE_PREV;
}

LRESULT 
CChooseKeyFile::OnWizardNext()
{
	CString strFileName = m_pCert->m_KeyFileName;
	if (CChooseReadFileName::OnWizardNext() != 1)
	{
		// if file name was changed then probably password is wrong now
		// and if cert context was imported before -- it is also invalid
		//
		if (m_pCert->m_KeyFileName.CompareNoCase(strFileName))
		{
			m_pCert->m_KeyPassword.Empty();
			m_pCert->DeleteKeyRingCert();
		}
		return IDD_PAGE_NEXT;
	}
	return 1;
}

BEGIN_MESSAGE_MAP(CChooseKeyFile, CChooseReadFileName)
	//{{AFX_MSG_MAP(CChooseKeyFile)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CChooseKeyFile message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certwiz\countrycombobox.cpp ===
// CountryComboBox.cpp : implementation file
//

#include "stdafx.h"
#include "CertWiz.h"
#include "CountryComboBox.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

BEGIN_MESSAGE_MAP(CComboEdit, CEdit)
	ON_WM_CHAR()
END_MESSAGE_MAP()

void CComboEdit::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	if (m_pParent->OnEditChar(nChar))
		CEdit::OnChar(nChar, nRepCnt, nFlags);
}

BOOL CComboEdit::SubclassDlgItem(UINT nID, CCountryComboBox * pParent)
{
	ASSERT(pParent != NULL);
	m_pParent = pParent;
	return CEdit::SubclassDlgItem(nID, pParent);
}

BOOL CCountryComboBox::OnEditChar(UINT nChar)
{
	int index;
	int len = m_strInput.GetLength();
	if (nChar == VK_ESCAPE)
	{
		if (len == 0)
		{
			MessageBeep(MB_ICONQUESTION);
			return FALSE;
		}
		m_strInput.Empty();
		len = 0;
	}
	else if (nChar == VK_BACK)
	{
		if (len == 0)
		{
			MessageBeep(MB_ICONQUESTION);
			return FALSE;
		}
		m_strInput.ReleaseBuffer(--len);
	}
	else if (_istalpha((TCHAR) nChar) || VK_SPACE == nChar)
	{
		m_strInput += (TCHAR)nChar;
		len++;
	}
	else
	{
		MessageBeep(MB_ICONQUESTION);
		return FALSE;
	}
	if (len > 0 && len <= 2)
	{
		if (CB_ERR != (index = FindString(-1, m_strInput)))
		{
			m_Index = index;
			SetCurSel(m_Index);
			SetEditSel(0, m_strInput.GetLength());
		}
		else
		{
			// try to find it in country names list
			index = -1;
			POSITION pos = m_map_name_code.GetStartPosition();
			int i = 0;
			while (pos != NULL)
			{
				CString name, code;
				m_map_name_code.GetNextAssoc(pos, name, code);
				if (0 == _tcsnicmp(name, m_strInput, len))
				{
					index = i;
					break;
				}
				i++;
			}
			if (index != -1)
			{
				m_Index = index;
				SetCurSel(m_Index);
				SetEditSel(4, len);
			}
			else
			{
				m_strInput.ReleaseBuffer(--len);
				MessageBeep(MB_ICONQUESTION);
			}
		}
	}
	else if (len > 2)
	{
		// try to find it in country names list
		index = -1;
		POSITION pos = m_map_name_code.GetStartPosition();
		while (pos != NULL)
		{
			CString name, code;
			m_map_name_code.GetNextAssoc(pos, name, code);
			if (0 == _tcsnicmp(name, m_strInput, len))
			{
				index = FindString(-1, code);
				break;
			}
		}
		if (index != -1)
		{
			m_Index = index;
			SetCurSel(m_Index);
			SetEditSel(4, 4+len);
		}
		else
		{
			m_strInput.ReleaseBuffer(--len);
			MessageBeep(MB_ICONQUESTION);
		}
	}
	else
	{
		// just remove selection
		SetEditSel(-1, 0);
	}
	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// CCountryComboBox

CCountryComboBox::CCountryComboBox()
{
}

CCountryComboBox::~CCountryComboBox()
{
}

#define IDC_COMBOEDIT 1001

BOOL
CCountryComboBox::SubclassDlgItem(UINT nID, CWnd * pParent)
{
	return CComboBox::SubclassDlgItem(nID, pParent)
		&& m_edit.SubclassDlgItem(IDC_COMBOEDIT, this);
}

BOOL
CCountryComboBox::Init()
{
	BOOL rc = FALSE;
   CString strData, strCode, strName, str;
   for (int i = IDS_COUNTRIES_FIRST;; i++)
   {
      if (!strData.LoadString(i))
      {
         break;
      }
      if (strData.IsEmpty())
      {
         rc = TRUE;
         break;
      }
      strCode = strData.Left(2);
      strName = strData.Right(strData.GetLength() - 2);
      str = strCode;
      str += _T(" (");
      str += strName;
      str += _T(")");
	  if (CB_ERR == AddString(str))
	     break;
	  m_map_name_code.SetAt(strName, strCode);
   }
	return rc;
}

#define MAX_COUNTRY_NAME	64
#define MAX_COUNTRY_CODE	3

void CCountryComboBox::SetSelectedCountry(CString& country_code)
{
	int index;
	if (country_code.IsEmpty())
	{
		TCHAR szCountryName[MAX_COUNTRY_NAME+1];
		VERIFY(GetLocaleInfo(LOCALE_SYSTEM_DEFAULT, 
			LOCALE_SCOUNTRY, szCountryName, MAX_COUNTRY_NAME));
		m_map_name_code.Lookup(szCountryName, country_code);
	}
	if (!country_code.IsEmpty() && CB_ERR != (index = FindString(-1, country_code)))
	{
		SetCurSel(index);
	}
	else
		SetCurSel(0);
}

void CCountryComboBox::GetSelectedCountry(CString& country_code)
{
	CString str;
	GetLBText(GetCurSel(), str);
	country_code = str.Left(2);
}

BEGIN_MESSAGE_MAP(CCountryComboBox, CComboBox)
	//{{AFX_MSG_MAP(CCountryComboBox)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCountryComboBox message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certwiz\countrycombobox.h ===
#if !defined(AFX_COUNTRYCOMBOBOX_H__8F522A56_3E30_11D2_9313_0060088FF80E__INCLUDED_)
#define AFX_COUNTRYCOMBOBOX_H__8F522A56_3E30_11D2_9313_0060088FF80E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// CountryComboBox.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CCountryComboBox window
class CCountryComboBox;

class CComboEdit : public CEdit
{
	CCountryComboBox * m_pParent;
public:
	BOOL SubclassDlgItem(UINT nID, CCountryComboBox * pParent);

	afx_msg void OnChar(UINT nChar, UINT nRepCnt, UINT nFlags);
	DECLARE_MESSAGE_MAP()
};

typedef struct _COUNTRY_DATA 
{
	TCHAR * code;
	TCHAR * name;
} COUNTRY_DATA;

class CCountryComboBox : public CComboBox
{
	CComboEdit m_edit;
	CMapStringToString m_map_name_code;
	CString m_strInput;
	int m_Index;

// Construction
public:
	CCountryComboBox();

// Attributes
public:

// Operations
public:
	BOOL SubclassDlgItem(UINT nID, CWnd * pParent);
	BOOL Init();
	BOOL OnEditChar(UINT nChar);
	void SetSelectedCountry(CString& country_code);
	void GetSelectedCountry(CString& country_code);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CCountryComboBox)
	public:
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CCountryComboBox();

	// Generated message map functions
protected:
	//{{AFX_MSG(CCountryComboBox)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_COUNTRYCOMBOBOX_H__8F522A56_3E30_11D2_9313_0060088FF80E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certwiz\geoinfopage.h ===
#if !defined(_GEOINFOPAGE_H)
#define _GEOINFOPAGE_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// GeoInfoPage.h : header file
//
#include "CountryComboBox.h"

class CCertificate;

/////////////////////////////////////////////////////////////////////////////
// CGeoInfoPage dialog

class CGeoInfoPage : public CIISWizardPage
{
	DECLARE_DYNCREATE(CGeoInfoPage)

// Construction
public:
	CGeoInfoPage(CCertificate * pCert = NULL);
	~CGeoInfoPage();

	enum
	{
		IDD_PAGE_PREV = IDD_PAGE_WIZ_SITE_NAME,
		IDD_PAGE_NEXT_FILE = IDD_PAGE_WIZ_CHOOSE_FILENAME,
		IDD_PAGE_NEXT_ONLINE = IDD_PAGE_WIZ_CHOOSE_ONLINE
	};
// Dialog Data
	//{{AFX_DATA(CGeoInfoPage)
	enum { IDD = IDD_PAGE_WIZ_GEO_INFO };
	CString	m_Locality;
	CString	m_State;
	CString	m_Country;
	//}}AFX_DATA
	CCertificate * m_pCert;
	CCountryComboBox m_countryCombo;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CGeoInfoPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	public:
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardPrev();
	virtual BOOL OnSetActive();
//	virtual BOOL OnKillActive();
	//}}AFX_VIRTUAL

// Implementation
protected:
	void SetButtons();
	void GetSelectedCountry(CString& str);
	void SetSelectedCountry(CString& str);
	// Generated message map functions
	//{{AFX_MSG(CGeoInfoPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeNewkeyLocality();
	afx_msg void OnChangeNewkeyState();
	afx_msg void OnEditchangeNewkeyCountry();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(_GEOINFOPAGE_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certwiz\finalpages.cpp ===
// FinalInstalledPage.cpp : implementation file
//

#include "stdafx.h"
#include "CertWiz.h"
#include "FinalPages.h"
#include "Certificat.h"
#include "Certutil.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CFinalInstalledPage property page

IMPLEMENT_DYNCREATE(CFinalInstalledPage, CIISWizardBookEnd2)

CFinalInstalledPage::CFinalInstalledPage(HRESULT * phResult, CCertificate * pCert) 
	: CIISWizardBookEnd2(phResult,
		USE_DEFAULT_CAPTION,
		IDS_INSTALL_CERT_FAILURE_HEADER,
		IDS_CERTWIZ,
		&m_idBodyText,
		NULL,
		&pCert->m_idErrorText,
		&pCert->m_strErrorText,
		USE_DEFAULT_CAPTION,
		CFinalInstalledPage::IDD),
		m_pCert(pCert)
{
	m_idBodyText = IDS_CERT_INSTALLED_SUCCESS;
}

CFinalInstalledPage::~CFinalInstalledPage()
{
}

BEGIN_MESSAGE_MAP(CFinalInstalledPage, CIISWizardBookEnd2)
	//{{AFX_MSG_MAP(CFinalInstalledPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFinalInstalledPage message handlers


/////////////////////////////////////////////////////////////////////////////
// CFinalReplacedPage property page

IMPLEMENT_DYNCREATE(CFinalReplacedPage, CIISWizardBookEnd2)

CFinalReplacedPage::CFinalReplacedPage(HRESULT * phResult, CCertificate * pCert) 
	: CIISWizardBookEnd2(phResult,
		USE_DEFAULT_CAPTION,
		IDS_INSTALL_CERT_FAILURE_HEADER,
		IDS_CERTWIZ,
		&m_idBodyText,
		NULL,
		&pCert->m_idErrorText,
		&pCert->m_strErrorText,
		USE_DEFAULT_CAPTION,
		CFinalReplacedPage::IDD),
		m_pCert(pCert)
{
	m_idBodyText = IDS_CERT_REPLACE_SUCCESS;
}

CFinalReplacedPage::~CFinalReplacedPage()
{
}

BEGIN_MESSAGE_MAP(CFinalReplacedPage, CIISWizardBookEnd2)
	//{{AFX_MSG_MAP(CFinalReplacedPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFinalInstalledPage message handlers


/////////////////////////////////////////////////////////////////////////////
// CFinalRemovePage property page

IMPLEMENT_DYNCREATE(CFinalRemovePage, CIISWizardBookEnd2)

CFinalRemovePage::CFinalRemovePage(HRESULT * phResult, CCertificate * pCert) 
	: CIISWizardBookEnd2(phResult,
		USE_DEFAULT_CAPTION,
		IDS_REMOVE_CERT_FAILURE_HEADER,
		IDS_CERTWIZ,
		&m_idBodyText,
		NULL,
		&pCert->m_idErrorText,
		&pCert->m_strErrorText,
		USE_DEFAULT_CAPTION,
		CFinalRemovePage::IDD),
		m_pCert(pCert)
{
	m_idBodyText = IDS_CERT_REMOVE_SUCCESS;
}

CFinalRemovePage::~CFinalRemovePage()
{
}

void CFinalRemovePage::DoDataExchange(CDataExchange* pDX)
{
	CIISWizardBookEnd2::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFinalRemovePage)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CFinalRemovePage, CIISWizardBookEnd2)
	//{{AFX_MSG_MAP(CFinalRemovePage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFinalRemovePage message handlers

BOOL CFinalRemovePage::OnInitDialog() 
{
	CIISWizardBookEnd2::OnInitDialog();
	ASSERT(m_pCert != NULL);
	if (m_pCert->m_hResult != S_OK)
	{
		// we need to replace text in template to error message
		CString str;
		str.LoadString(m_pCert->m_idErrorText);
		SetDlgItemText(IDC_STATIC_WZ_BODY, str);
	}
	GetParent()->GetDlgItem(IDCANCEL)->EnableWindow(FALSE);
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CFinalCancelPage property page

IMPLEMENT_DYNCREATE(CFinalCancelPage, CIISWizardBookEnd2)

CFinalCancelPage::CFinalCancelPage(HRESULT * phResult, CCertificate * pCert) 
	: CIISWizardBookEnd2(phResult,
		USE_DEFAULT_CAPTION,
		IDS_CANCEL_CERT_FAILURE_HEADER,
		IDS_CERTWIZ,
		&m_idBodyText,
		NULL,
		&pCert->m_idErrorText,
		&pCert->m_strErrorText,
		USE_DEFAULT_CAPTION,
		CFinalCancelPage::IDD),
		m_pCert(pCert)
{
	m_idBodyText = IDS_CERT_CANCEL_SUCCESS;
}

CFinalCancelPage::~CFinalCancelPage()
{
}

void CFinalCancelPage::DoDataExchange(CDataExchange* pDX)
{
	CIISWizardBookEnd2::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFinalRemovePage)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CFinalCancelPage, CIISWizardBookEnd2)
	//{{AFX_MSG_MAP(CFinalCancelPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFinalCancelPage message handlers

BOOL CFinalCancelPage::OnInitDialog() 
{
	CIISWizardBookEnd2::OnInitDialog();
	ASSERT(m_pCert != NULL);
	if (m_pCert->m_hResult != S_OK)
	{
		// we need to replace text in template to error message
		CString str;
		str.LoadString(m_pCert->m_idErrorText);
		SetDlgItemText(IDC_STATIC_WZ_BODY, str);
	}
	GetParent()->GetDlgItem(IDCANCEL)->EnableWindow(FALSE);
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CFinalToFilePage property page

IMPLEMENT_DYNCREATE(CFinalToFilePage, CIISWizardBookEnd2)

CFinalToFilePage::CFinalToFilePage(HRESULT * phResult, CCertificate * pCert) 
	: CIISWizardBookEnd2(phResult,
			USE_DEFAULT_CAPTION,
			IDS_FINAL_TO_FILE_FAILURE_HEADER,
			IDS_CERTWIZ,
			NULL,
			NULL,
			&pCert->m_idErrorText,
			&pCert->m_strErrorText,
			USE_DEFAULT_CAPTION,
			CFinalToFilePage::IDD),
	m_pCert(pCert)
{
}

CFinalToFilePage::~CFinalToFilePage()
{
}

void CFinalToFilePage::DoDataExchange(CDataExchange* pDX)
{
	CIISWizardBookEnd2::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFinalToFilePage)
	DDX_Control(pDX, IDC_HOTLINK_CCODES, m_hotlink_codessite);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CFinalToFilePage, CIISWizardBookEnd2)
	//{{AFX_MSG_MAP(CFinalToFilePage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFinalToFilePage message handlers

BOOL CFinalToFilePage::OnInitDialog() 
{
	ASSERT(NULL != m_pCert);
	CIISWizardBookEnd2::OnInitDialog();
	// in case of success we should prepare text and include
	// request file name into
	if (SUCCEEDED(m_pCert->m_hResult))
	{
		CString str, strPath;
      
      	strPath = m_pCert->m_ReqFileName;
		// If filename is too long, it will look ugly, we could
		// limit it to our static control width.
		VERIFY(CompactPathToWidth(GetDlgItem(IDC_STATIC_WZ_BODY), strPath));
// This MFC helper limits the format internally 
// to 256 characters: cannot use it here
//		AfxFormatString1(str, IDS_FINAL_TO_FILE_BODY_SUCCESS, m_pCert->m_ReqFileName);
		str.Format(IDS_CERT_REQUEST_SUCCESS, strPath);
		SetDlgItemText(IDC_STATIC_WZ_BODY, str);
		// setup the link to CA list
		m_hotlink_codessite.SetLink(IDS_MICROSOFT_CA_LINK);
	}
	else
	{
		// hide controls that are not for error message
		GetDlgItem(IDC_HOTLINK_CCODES)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_STATIC_WZ_BODY2)->ShowWindow(SW_HIDE);
	}
	SetWizardButtons(PSWIZB_FINISH);	
	GetParent()->GetDlgItem(IDCANCEL)->EnableWindow(FALSE);
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certwiz\chooseonlinepage.cpp ===
// ChooseCAPage.cpp : implementation file
//

#include "stdafx.h"
#include "CertWiz.h"
#include "ChooseOnlinePage.h"
#include "Certificat.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CChooseOnlinePage property page

IMPLEMENT_DYNCREATE(CChooseOnlinePage, CIISWizardPage)

CChooseOnlinePage::CChooseOnlinePage(CCertificate * pCert) 
	: CIISWizardPage(CChooseOnlinePage::IDD, IDS_CERTWIZ, TRUE),
	m_pCert(pCert)
{
	//{{AFX_DATA_INIT(CChooseOnlinePage)
	m_CAIndex = -1;
	//}}AFX_DATA_INIT
}

CChooseOnlinePage::~CChooseOnlinePage()
{
}

void CChooseOnlinePage::DoDataExchange(CDataExchange* pDX)
{
	CIISWizardPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CChooseOnlinePage)
	DDX_CBIndex(pDX, IDC_CA_ONLINE_LIST, m_CAIndex);
	//}}AFX_DATA_MAP
}

LRESULT 
CChooseOnlinePage::OnWizardBack()
/*++
Routine Description:
    Prev button handler

Arguments:
    None

Return Value:
	0 to automatically advance to the prev page;
	1 to prevent the page from changing. 
	To jump to a page other than the prev one, 
	return the identifier of the dialog to be displayed.
--*/
{
	if (m_pCert->GetStatusCode() == CCertificate::REQUEST_RENEW_CERT)
		return IDD_PAGE_PREV_RENEW;
	else if (m_pCert->GetStatusCode() == CCertificate::REQUEST_NEW_CERT)
		return IDD_PAGE_PREV_NEW;
	else
		return 1;
}

LRESULT 
CChooseOnlinePage::OnWizardNext()
/*++
Routine Description:
    Next button handler

Arguments:
    None

Return Value:
	0 to automatically advance to the next page;
	1 to prevent the page from changing. 
	To jump to a page other than the next one, 
	return the identifier of the dialog to be displayed.
--*/
{
	UpdateData();
	CComboBox * pCombo = (CComboBox *)CWnd::FromHandle(
		GetDlgItem(IDC_CA_ONLINE_LIST)->m_hWnd);
	pCombo->GetLBText(m_CAIndex, m_pCert->m_ConfigCA);
	return IDD_PAGE_NEXT;
}

BEGIN_MESSAGE_MAP(CChooseOnlinePage, CIISWizardPage)
	//{{AFX_MSG_MAP(CChooseCAPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CChooseCAPage message handlers

BOOL CChooseOnlinePage::OnInitDialog() 
{
	m_CAIndex = 0;
	// We need to create controls first
	CIISWizardPage::OnInitDialog();
	ASSERT(m_pCert != NULL);
	GetDlgItem(IDC_CA_ONLINE_LIST)->SetFocus();
	CComboBox * pCombo = (CComboBox *)CWnd::FromHandle(
		GetDlgItem(IDC_CA_ONLINE_LIST)->m_hWnd);
	CString str;
	POSITION pos = m_pCert->m_OnlineCAList.GetHeadPosition();
	while (pos != NULL)
	{
		str = m_pCert->m_OnlineCAList.GetNext(pos);
		pCombo->AddString(str);
	}
	int idx;
	if (	!m_pCert->m_ConfigCA.IsEmpty()
		&&	CB_ERR != (idx = pCombo->FindString(-1, m_pCert->m_ConfigCA))
		)
	{
		pCombo->SetCurSel(idx);
	}
	else
		pCombo->SetCurSel(0);
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certwiz\hotlink.h ===
// HotLink.h : header file
//
#ifndef _HOTLINK_H
#define _HOTLINK_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

/////////////////////////////////////////////////////////////////////////////
// CHotLink window

class CHotLink : public CButton
{
// Construction
public:
	CHotLink();

// Attributes
public:
    BOOL    m_fBrowse;
    BOOL    m_fExplore;
    BOOL    m_fOpen;

// Operations
public:
    void Browse();
    void Explore();
    void Open();

    virtual void DrawItem( LPDRAWITEMSTRUCT lpDrawItemStruct );

    // set the title string
    void SetTitle( CString sz );
	void SetLink(const CString& sz)
	{
		m_strLink = sz;
	}
	void SetLink(UINT id)
	{
		VERIFY(m_strLink.LoadString(id));
	}

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CHotLink)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CHotLink();

	// Generated message map functions
protected:
	//{{AFX_MSG(CHotLink)
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnCaptureChanged(CWnd *pWnd);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()

    // height and width of the displayed text
    void GetTextRect( CRect &rect );
    CSize   m_cpTextExtents;
	CRect m_rcText;
	COLORREF m_clrText;
	// URL for link could be not the same as caption
	CString m_strLink;

    // tracking the mouse flag
    BOOL    m_CapturedMouse;

    // init the font
    BOOL    m_fInitializedFont;
};

/////////////////////////////////////////////////////////////////////////////
#endif // _HOTLINK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certwiz\hotlink.cpp ===
// HotLink.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "HotLink.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define COLOR_BLUE			RGB(0, 0, 0xFF)
#define COLOR_YELLOW		RGB(0xff, 0x80, 0)

/////////////////////////////////////////////////////////////////////////////
// CHotLink

CHotLink::CHotLink():
    m_CapturedMouse(FALSE),
    m_fBrowse(FALSE),
    m_fExplore(FALSE),
    m_fOpen(TRUE),
    m_fInitializedFont(FALSE)
{
}

CHotLink::~CHotLink()
{
}

BEGIN_MESSAGE_MAP(CHotLink, CButton)
	//{{AFX_MSG_MAP(CHotLink)
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONUP()
	ON_WM_MOUSEMOVE()
	ON_WM_CAPTURECHANGED()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

//------------------------------------------------------------------------
// set the title string
void CHotLink::SetTitle( CString sz )
{
    // set the title
    SetWindowText( sz );
    // force the window to redraw
    Invalidate( TRUE );
}

/////////////////////////////////////////////////////////////////////////////
// CHotLink message handlers

//------------------------------------------------------------------------
void CHotLink::DrawItem( LPDRAWITEMSTRUCT lpDrawItemStruct )
{
	// prep the device context
	CDC* pdc = CDC::FromHandle(lpDrawItemStruct->hDC);

	// get the drawing rect
	CRect rect = lpDrawItemStruct->rcItem;
	CString sz;
	GetWindowText(sz);

	if (!m_fInitializedFont)
	{
		// get the window font
		LOGFONT logfont;
		HFONT hFont = (HFONT)SendMessage(WM_GETFONT, 0, 0);
		ASSERT(hFont != NULL);
		VERIFY(0 < GetObject(hFont, sizeof(LOGFONT), &logfont));

		// modify the font  - add underlining
		logfont.lfUnderline = TRUE;

        // set the font back
		HFONT hNewFont = ::CreateFontIndirect(&logfont);
		ASSERT(hNewFont != NULL);
		SendMessage(WM_SETFONT, (WPARAM)hNewFont, MAKELPARAM(TRUE, 0));
		// get the extents fo the text for later reference
		m_cpTextExtents = pdc->GetOutputTextExtent(sz);
		// get the main rect
		GetClientRect(m_rcText);

		// reduce it by the width of the text
		m_rcText.left = m_rcText.left + (m_rcText.Width() - m_cpTextExtents.cx) / 2;
		m_rcText.right = m_rcText.left + m_cpTextExtents.cx;
		m_rcText.top = m_rcText.top + (m_rcText.Height() - m_cpTextExtents.cy) / 2;
		m_rcText.bottom = m_rcText.top + m_cpTextExtents.cy;
		m_clrText = COLOR_BLUE;
		m_fInitializedFont = TRUE;
	}

	// draw the text in color that was set outside
	pdc->SetTextColor(m_clrText);
	
	// draw the text
	pdc->DrawText(sz, &rect, DT_CENTER|DT_SINGLELINE|DT_VCENTER);
}

//------------------------------------------------------------------------
// calculate the rectangle that surrounds the text
void CHotLink::GetTextRect( CRect &rect )
{
    // get the main rect
    GetClientRect( rect );

    // reduce it by margins
	// Calculations below are for centered text. To locate it inside
	// the dialog just make it tight and move control itself
	rect.left = rect.left + (rect.Width() - m_cpTextExtents.cx) / 2;
    rect.right = rect.left + m_cpTextExtents.cx;
	rect.top = rect.top + (rect.Height() - m_cpTextExtents.cy) / 2;
	rect.bottom = rect.top + m_cpTextExtents.cy;
}

//------------------------------------------------------------------------
void CHotLink::OnLButtonDown(UINT nFlags, CPoint point)
{
   	// don't do the hotlink thing if there is no text
	if (!m_strLink.IsEmpty() && !m_CapturedMouse && m_rcText.PtInRect(point))
   	{
		SetCapture();
      	m_CapturedMouse = TRUE;
   	}
}

//------------------------------------------------------------------------
void CHotLink::OnLButtonUp(UINT nFlags, CPoint point)
{
	// only bother if we have the capture
   if (m_CapturedMouse)
   {
		ReleaseCapture();
      	if ( m_fBrowse )
			Browse();
      	else if ( m_fExplore )
			Explore();
      	else if ( m_fOpen )
			Open();
	}
}

//------------------------------------------------------------------------
void CHotLink::Browse()
{
    ShellExecute(
        NULL,			// handle to parent window
        NULL,			// pointer to string that specifies operation to perform
        m_strLink,		// pointer to filename or folder name string
        NULL,			// pointer to string that specifies executable-file parameters
        NULL,			// pointer to string that specifies default directory
        SW_SHOW 		// whether file is shown when opened
       );
}

//------------------------------------------------------------------------
void CHotLink::Explore()
{
    ShellExecute(
        NULL,			// handle to parent window
        _T("explore"),	// pointer to string that specifies operation to perform
        m_strLink,		// pointer to filename or folder name string
        NULL,			// pointer to string that specifies executable-file parameters
        NULL,			// pointer to string that specifies default directory
        SW_SHOW 		// whether file is shown when opened
       );
}

//------------------------------------------------------------------------
void CHotLink::Open()
{
    ShellExecute(
        NULL,			// handle to parent window
        _T("open"),		// pointer to string that specifies operation to perform
        m_strLink,		// pointer to filename or folder name string
        NULL,			// pointer to string that specifies executable-file parameters
        NULL,			// pointer to string that specifies default directory
        SW_SHOW 		// whether file is shown when opened
       );
}

//------------------------------------------------------------------------
void CHotLink::OnMouseMove(UINT nFlags, CPoint point)
{
	CRect   rect;
	GetTextRect(rect);
	// if the mouse is over the hot area, show the right cursor
	if (rect.PtInRect(point))
	{
		::SetCursor(AfxGetApp()->LoadCursor(IDC_BROWSE_CUR));
		// also reset text color to *yellow*
		if (m_clrText != COLOR_YELLOW)
		{
			m_clrText = COLOR_YELLOW;
			InvalidateRect(m_rcText, FALSE);
			UpdateWindow();
		}
	}
	else 
	{
		if (m_clrText != COLOR_BLUE)
		// we are not pointing to text, render it in *blue*
		{
			m_clrText = COLOR_BLUE;
			InvalidateRect(m_rcText, FALSE);
			UpdateWindow();
		}
		// also remove capture and reset the cursor
		ReleaseCapture();
		::SetCursor(AfxGetApp()->LoadCursor(IDC_ARROW));
	}
}

void CHotLink::OnCaptureChanged(CWnd *pWnd) 
{
	m_clrText = COLOR_BLUE;
	InvalidateRect(m_rcText, FALSE);
	UpdateWindow();
	m_CapturedMouse = FALSE;
	CButton::OnCaptureChanged(pWnd);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certwiz\choosefilename.h ===
#if !defined(_CHOOSEFILENAMEPAGE_H)
#define _CHOOSEFILENAMEPAGE_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ChooseFileNamePage.h : header file
//
#include "Certificat.h"

/////////////////////////////////////////////////////////////////////////////
// CChooseFileNamePage dialog
//class CCertificate;

class CChooseFileNamePage : public CIISWizardPage
{
	DECLARE_DYNCREATE(CChooseFileNamePage)

// Construction
public:
	CChooseFileNamePage(	UINT id = 0, 
							   UINT defaultID = 0,
								UINT extID = 0,
								UINT filterID = 0,
								CString * pOutFileName = NULL
								);
	~CChooseFileNamePage();

// Dialog Data
	//{{AFX_DATA(CChooseCAPage)
	CString	m_FileName;
	//}}AFX_DATA
	BOOL m_DoReplaceFile;
	UINT m_id, m_defaultID;
	CString ext, filter;
	CString * m_pOutFileName;

// Overrides
	virtual void FileNameChanged() 
	{
	}
	virtual BOOL IsReadFileDlg()
	{
		ASSERT(FALSE);
		return FALSE;
	}
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CChooseCAPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	public:
	virtual LRESULT OnWizardNext()
		{
			ASSERT(FALSE);
			return 1;
		}
	virtual LRESULT OnWizardBack();
	virtual BOOL OnSetActive();
	//}}AFX_VIRTUAL

// Implementation
protected:
	void GetDefaultFileName(CString& str);
	void Browse(CString& strPath, CString& strFile);
	LRESULT DoWizardNext(LRESULT id);
	// Generated message map functions
	//{{AFX_MSG(CChooseCAPage)
	afx_msg void OnBrowseBtn();
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeFileName();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

class CChooseReadFileName : public CChooseFileNamePage
{
	DECLARE_DYNCREATE(CChooseReadFileName)
// Construction
public:
	CChooseReadFileName(	UINT id = 0, 
							   UINT defaultID = 0,
								UINT extID = 0,
								UINT filterID = 0,
								CString * pOutFileName = NULL
								);
	~CChooseReadFileName() 
	{
	}
// Overrides
	virtual void FileNameChanged() 
	{
	}
	virtual BOOL IsReadFileDlg()
	{
		return TRUE;
	}
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CChooseCAPage)
	protected:
//	virtual void DoDataExchange(CDataExchange* pDX)
//		{
//			CChooseFileNamePage::DoDataExchange(pDX);
//		}
	public:
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack() {return 1;}
	virtual BOOL OnSetActive()
		{
			return CChooseFileNamePage::OnSetActive();
		}
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CChooseCAPage)
	afx_msg void OnBrowseBtn();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

class CChooseWriteFileName : public CChooseFileNamePage
{
	DECLARE_DYNCREATE(CChooseWriteFileName)
// Construction
public:
	CChooseWriteFileName(UINT id = 0, 
							   UINT defaultID = 0,
								UINT extID = 0,
								UINT filterID = 0,
								CString * pOutFileName = NULL
								);
	~CChooseWriteFileName() {}
// Overrides
	virtual void FileNameChanged() {}
	virtual BOOL IsReadFileDlg()
	{
		return FALSE;
	}
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CChooseCAPage)
	protected:
//	virtual void DoDataExchange(CDataExchange* pDX)
//		{
//			CChooseFileNamePage::DoDataExchange(pDX);
//		}
	public:
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack() {return 1;}
	virtual BOOL OnSetActive()
		{
			return CChooseFileNamePage::OnSetActive();
		}
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CChooseCAPage)
	afx_msg void OnBrowseBtn();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

class CChooseRespFile : public CChooseReadFileName
{
	DECLARE_DYNCREATE(CChooseRespFile)

// Construction
public:
	CChooseRespFile(CCertificate * pCert = NULL);
	~CChooseRespFile();

	enum
	{
		IDD_PAGE_PREV	=	IDD_PAGE_WIZ_PENDING_WHAT_TODO,
		IDD_PAGE_NEXT	= IDD_PAGE_WIZ_INSTALL_RESP,
	};
// Dialog Data
	//{{AFX_DATA(CChooseRespFile)
	enum { IDD = IDD_PAGE_WIZ_GETRESP_FILE };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA
	CCertificate * m_pCert;


// Overrides
	virtual void FileNameChanged();
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CChooseRespFile)
	public:
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CChooseRespFile)
    afx_msg HBRUSH OnCtlColor(CDC * pDC, CWnd * pWnd, UINT nCtlColor);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

class CChooseReqFile : public CChooseWriteFileName
{
	DECLARE_DYNCREATE(CChooseReqFile)

// Construction
public:
	CChooseReqFile(CCertificate * pCert = NULL);
	~CChooseReqFile();

	enum
	{
		IDD_PAGE_PREV = IDD_PAGE_WIZ_GEO_INFO,
		IDD_PAGE_NEXT = IDD_PAGE_WIZ_REQUEST_DUMP,
	};
// Dialog Data
	//{{AFX_DATA(CChooseReqFile)
	enum { IDD = IDD_PAGE_WIZ_CHOOSE_FILENAME };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA
	CCertificate * m_pCert;


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CChooseReqFile)
	public:
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CChooseReqFile)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

class CChooseKeyFile : public CChooseReadFileName
{
	DECLARE_DYNCREATE(CChooseKeyFile)

// Construction
public:
	CChooseKeyFile(CCertificate * pCert = NULL);
	~CChooseKeyFile();

	enum
	{
		IDD_PAGE_PREV	= IDD_PAGE_WIZ_GET_WHAT,
		IDD_PAGE_NEXT	= IDD_PAGE_WIZ_GET_PASSWORD,
	};
// Dialog Data
	//{{AFX_DATA(CChooseKeyFile)
	enum { IDD = IDD_PAGE_WIZ_GETKEY_FILE };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA
	CCertificate * m_pCert;


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CChooseKeyFile)
	public:
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CChooseKeyFile)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(_CHOOSEFILENAMEPAGE_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certwiz\keypasswordpage.cpp ===
// KeyPasswordPage.cpp : implementation file
//

#include "stdafx.h"
#include "CertWiz.h"
#include "KeyPasswordPage.h"
#include "Certificat.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CKeyPasswordPage property page

IMPLEMENT_DYNCREATE(CKeyPasswordPage, CIISWizardPage)

CKeyPasswordPage::CKeyPasswordPage(CCertificate * pCert) 
	: CIISWizardPage(CKeyPasswordPage::IDD, IDS_CERTWIZ, TRUE),
	m_pCert(pCert)
{
	//{{AFX_DATA_INIT(CKeyPasswordPage)
	m_Password = _T("");
	//}}AFX_DATA_INIT
}

CKeyPasswordPage::~CKeyPasswordPage()
{
}

void CKeyPasswordPage::DoDataExchange(CDataExchange* pDX)
{
	CIISWizardPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CKeyPasswordPage)
	DDX_Text(pDX, IDC_KEYPASSWORD, m_Password);
	DDV_MaxChars(pDX, m_Password, 64);
	//}}AFX_DATA_MAP
}

LRESULT 
CKeyPasswordPage::OnWizardBack()
/*++
Routine Description:
    Prev button handler

Arguments:
    None

Return Value:
	0 to automatically advance to the prev page;
	1 to prevent the page from changing. 
	To jump to a page other than the prev one, 
	return the identifier of the dialog to be displayed.
--*/
{
	return IDD_PAGE_PREV;
}

LRESULT 
CKeyPasswordPage::OnWizardNext()
{
	UpdateData(TRUE);
	if (0 != m_Password.Compare(m_pCert->m_KeyPassword))
	{
		m_pCert->DeleteKeyRingCert();
		m_pCert->m_KeyPassword = m_Password;
	}
	if (NULL == m_pCert->GetKeyRingCert())
	{
		// probably password was wrong
		CString txt;
		txt.LoadString(IDS_FAILED_IMPORT_KEY_FILE);
		ASSERT(GetDlgItem(IDC_ERROR_TEXT) != NULL);
		SetDlgItemText(IDC_ERROR_TEXT, txt);
		GetDlgItem(IDC_KEYPASSWORD)->SetFocus();
		GetDlgItem(IDC_KEYPASSWORD)->SendMessage(EM_SETSEL, 0, -1);
		SetWizardButtons(PSWIZB_BACK);
		return 1;
	}
	return IDD_PAGE_NEXT;
}

BOOL 
CKeyPasswordPage::OnSetActive() 
{
	ASSERT(m_pCert != NULL);
	m_Password = m_pCert->m_KeyPassword;
	UpdateData(FALSE);
	SetWizardButtons(m_Password.IsEmpty() || m_pCert->GetKeyRingCert() == NULL ?
			PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);
	return CIISWizardPage::OnSetActive();
}

BOOL
CKeyPasswordPage::OnKillActive()
{
	UpdateData();
	m_pCert->m_KeyPassword = m_Password;
	return CIISWizardPage::OnKillActive();
}

BEGIN_MESSAGE_MAP(CKeyPasswordPage, CIISWizardPage)
	//{{AFX_MSG_MAP(CKeyPasswordPage)
	ON_EN_CHANGE(IDC_KEYPASSWORD, OnEditchangePassword)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSiteNamePage message handlers

void CKeyPasswordPage::OnEditchangePassword() 
{
	UpdateData(TRUE);	
	SetWizardButtons(m_Password.IsEmpty() ? 
			PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);
	CString str;
	SetDlgItemText(IDC_ERROR_TEXT, str);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certwiz\finalpages.h ===
#if !defined(AFX_FINALPAGES_H__98544A13_3C60_11D2_8180_0000F87A921B__INCLUDED_)
#define AFX_FINALPAGES_H__98544A13_3C60_11D2_8180_0000F87A921B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// FinalPages.h : header file
//
#include "HotLink.h"
#include "BookEndPage.h"

class CCertificate;

/////////////////////////////////////////////////////////////////////////////
// CFinalInstalledPage dialog
class CFinalInstalledPage : public CIISWizardBookEnd2
{
	DECLARE_DYNCREATE(CFinalInstalledPage)

	enum
	{
		IDD_PAGE_PREV = IDD_PAGE_WIZ_INSTALL_RESP
	};
// Construction
public:
	CFinalInstalledPage(HRESULT * phResult = NULL, CCertificate * pCert = NULL);
	~CFinalInstalledPage();

// Dialog Data
	//{{AFX_DATA(CFinalInstalledPage)
	enum { IDD = IDD_PAGE_WIZ_FINAL_INSTALL };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA
	CCertificate * m_pCert;
	UINT m_idBodyText;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CFinalInstalledPage)
	public:
	protected:
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CFinalInstalledPage)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

/////////////////////////////////////////////////////////////////////////////
// CFinalReplacedPage dialog
class CFinalReplacedPage : public CIISWizardBookEnd2
{
	DECLARE_DYNCREATE(CFinalReplacedPage)

	enum
	{
		IDD_PAGE_PREV = IDD_PAGE_WIZ_REPLACE_CERT
	};
// Construction
public:
	CFinalReplacedPage(HRESULT * phResult = NULL, CCertificate * pCert = NULL);
	~CFinalReplacedPage();

// Dialog Data
	//{{AFX_DATA(CFinalReplacedPage)
	enum { IDD = IDD_PAGE_WIZ_FINAL_REPLACE };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA
	CCertificate * m_pCert;
	UINT m_idBodyText;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CFinalReplacedPage)
	public:
	protected:
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CFinalReplacedPage)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

/////////////////////////////////////////////////////////////////////////////
// CFinalRemovePage dialog
class CFinalRemovePage : public CIISWizardBookEnd2
{
	DECLARE_DYNCREATE(CFinalRemovePage)

// Construction
public:
	CFinalRemovePage(HRESULT * phResult = NULL, CCertificate * pCert = NULL);
	~CFinalRemovePage();

	enum
	{
		IDD_PAGE_PREV = IDD_PAGE_WIZ_REMOVE_CERT,
	};
// Dialog Data
	//{{AFX_DATA(CFinalRemovePage)
	enum { IDD = IDD_PAGE_WIZ_FINAL_REMOVE };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA
	CCertificate * m_pCert;
	UINT m_idBodyText;


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CFinalRemovePage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CFinalRemovePage)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

/////////////////////////////////////////////////////////////////////////////
// CFinalToFilePage dialog

class CFinalToFilePage : public CIISWizardBookEnd2
{
	DECLARE_DYNCREATE(CFinalToFilePage)

// Construction
public:
	CFinalToFilePage(HRESULT * phResult = NULL, CCertificate * pCert = NULL);
	~CFinalToFilePage();

	enum
	{
		IDD_PAGE_PREV = IDD_PAGE_WIZ_REQUEST_DUMP
	};
// Dialog Data
	//{{AFX_DATA(CFinalToFilePage)
	enum { IDD = IDD_PAGE_WIZ_FINAL_TO_FILE };
	CHotLink	m_hotlink_codessite;
	//}}AFX_DATA
	CCertificate * m_pCert;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CFinalToFilePage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	public:
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CFinalToFilePage)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

/////////////////////////////////////////////////////////////////////////////
// CFinalCancelPage dialog
class CFinalCancelPage : public CIISWizardBookEnd2
{
	DECLARE_DYNCREATE(CFinalCancelPage)

// Construction
public:
	CFinalCancelPage(HRESULT * phResult = NULL, CCertificate * pCert = NULL);
	~CFinalCancelPage();

	enum
	{
		IDD_PAGE_PREV = IDD_PAGE_WIZ_CANCEL_REQUEST,
	};
// Dialog Data
	//{{AFX_DATA(CFinalCancelPage)
	enum { IDD = IDD_PAGE_WIZ_FINAL_CANCEL };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA
	CCertificate * m_pCert;
	UINT m_idBodyText;


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CFinalCancelPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CFinalCancelPage)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_FINALPAGES_H__98544A13_3C60_11D2_8180_0000F87A921B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certwiz\managecertpage.cpp ===
// ManageCertPage.cpp : implementation file
//

#include "stdafx.h"
#include "CertWiz.h"
#include "ManageCertPage.h"
#include "Certificat.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CManageCertPage property page

IMPLEMENT_DYNCREATE(CManageCertPage, CIISWizardPage)

CManageCertPage::CManageCertPage(CCertificate * pCert) 
	: CIISWizardPage(CManageCertPage::IDD, IDS_CERTWIZ, TRUE),
	m_pCert(pCert)
{
	//{{AFX_DATA_INIT(CManageCertPage)
	m_Index = -1;
	//}}AFX_DATA_INIT
}

CManageCertPage::~CManageCertPage()
{
}

void CManageCertPage::DoDataExchange(CDataExchange* pDX)
{
	CIISWizardPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CManageCertPage)
	DDX_Radio(pDX, IDC_RENEW_CERT, m_Index);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CManageCertPage, CIISWizardPage)
	//{{AFX_MSG_MAP(CManageCertPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CManageCertPage message handlers

LRESULT CManageCertPage::OnWizardBack() 
{
	return IDD_PAGE_PREV;
}

LRESULT CManageCertPage::OnWizardNext() 
{
	LRESULT res = 1;
	UpdateData();
	switch (m_Index)
	{
	case CONTINUE_RENEW:
		m_pCert->SetStatusCode(CCertificate::REQUEST_RENEW_CERT);
		res = IDD_PAGE_NEXT_RENEW;
		break;
	case CONTINUE_REMOVE:
		res = IDD_PAGE_NEXT_REMOVE;
		break;
	case CONTINUE_REPLACE:
		m_pCert->SetStatusCode(CCertificate::REQUEST_REPLACE_CERT);
		res = IDD_PAGE_NEXT_REPLACE;
		break;
	}
	return res;
}

BOOL CManageCertPage::OnSetActive() 
{
	m_pCert->SetStatusCode(CCertificate::REQUEST_UNDEFINED);
	SetWizardButtons(PSWIZB_BACK | PSWIZB_NEXT);
	return CIISWizardPage::OnSetActive();
}

BOOL CManageCertPage::OnInitDialog() 
{
	m_Index = 0;
	CIISWizardPage::OnInitDialog();
	// we should make some checks and disable some buttons
	if (m_pCert->MyStoreCertCount() == 0)
	{
		ASSERT(NULL != GetDlgItem(IDC_REPLACE_CERT));
		GetDlgItem(IDC_REPLACE_CERT)->EnableWindow(FALSE);
	}
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certwiz\geoinfopage.cpp ===
// GeoInfoPage.cpp : implementation file
//

#include "stdafx.h"
#include "CertWiz.h"
#include "GeoInfoPage.h"
#include "Certificat.h"
#include "mru.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CGeoInfoPage property page

IMPLEMENT_DYNCREATE(CGeoInfoPage, CIISWizardPage)

CGeoInfoPage::CGeoInfoPage(CCertificate * pCert) 
	: CIISWizardPage(CGeoInfoPage::IDD, IDS_CERTWIZ, TRUE),
	m_pCert(pCert)
{
	//{{AFX_DATA_INIT(CGeoInfoPage)
	m_Locality = _T("");
	m_State = _T("");
	m_Country = _T("");
	//}}AFX_DATA_INIT
}

CGeoInfoPage::~CGeoInfoPage()
{
}

void CGeoInfoPage::DoDataExchange(CDataExchange* pDX)
{
	CIISWizardPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CGeoInfoPage)
	DDX_Text(pDX, IDC_NEWKEY_LOCALITY, m_Locality);
	DDV_MaxCharsCombo(pDX, IDC_NEWKEY_LOCALITY, m_Locality, 64);
	DDX_Text(pDX, IDC_NEWKEY_STATE, m_State);
	DDV_MaxCharsCombo(pDX, IDC_NEWKEY_STATE, m_State, 64);
	DDX_CBString(pDX, IDC_NEWKEY_COUNTRY, m_Country);
	//}}AFX_DATA_MAP
}

LRESULT 
CGeoInfoPage::OnWizardPrev()
{
	return IDD_PAGE_PREV;
//	return m_pCert->m_CAType == CCertificate::CA_OFFLINE ?
//		IDD_PAGE_PREV_FILE : IDD_PAGE_PREV_ONLINE;
}

LRESULT 
CGeoInfoPage::OnWizardNext()
{
	ASSERT(m_pCert != NULL);
	UpdateData(TRUE);
	m_pCert->m_Locality = m_Locality;
	m_pCert->m_State = m_State;
	m_countryCombo.GetSelectedCountry(m_pCert->m_Country);
	return m_pCert->m_CAType == CCertificate::CA_OFFLINE ?
		IDD_PAGE_NEXT_FILE : IDD_PAGE_NEXT_ONLINE;
}

BOOL CGeoInfoPage::OnSetActive()
{
	SetButtons();
	return CIISWizardPage::OnSetActive();
}

void CGeoInfoPage::SetButtons()
{
	UpdateData(TRUE);	
	SetWizardButtons(m_Country.IsEmpty() || m_Locality.IsEmpty() || m_State.IsEmpty() ? 
			PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);
}

BEGIN_MESSAGE_MAP(CGeoInfoPage, CIISWizardPage)
	//{{AFX_MSG_MAP(CGeoInfoPage)
	ON_CBN_EDITCHANGE(IDC_NEWKEY_LOCALITY, OnChangeNewkeyLocality)
	ON_CBN_EDITCHANGE(IDC_NEWKEY_STATE, OnChangeNewkeyState)
	ON_CBN_EDITCHANGE(IDC_NEWKEY_COUNTRY, OnEditchangeNewkeyCountry)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CGeoInfoPage message handlers

BOOL CGeoInfoPage::OnInitDialog() 
{
	ASSERT(m_pCert != NULL);
	m_Locality = m_pCert->m_Locality;
	m_State = m_pCert->m_State;
	m_countryCombo.SubclassDlgItem(IDC_NEWKEY_COUNTRY, this);
	CIISWizardPage::OnInitDialog();
	m_countryCombo.Init();
	m_countryCombo.SetSelectedCountry(m_pCert->m_Country);
	// Load MRU names
	LoadMRUToCombo(this, IDC_NEWKEY_STATE, szStateMRU, m_State, MAX_MRU);
	LoadMRUToCombo(this, IDC_NEWKEY_LOCALITY, szLocalityMRU, m_Locality, MAX_MRU);
	SetButtons();
	GetDlgItem(IDC_NEWKEY_COUNTRY)->SetFocus();
	return FALSE;
}

void CGeoInfoPage::OnChangeNewkeyLocality() 
{
	SetButtons();
}

void CGeoInfoPage::OnChangeNewkeyState() 
{
	SetButtons();
}

void CGeoInfoPage::OnEditchangeNewkeyCountry() 
{
	SetButtons();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certwiz\getwhatpage.cpp ===
// GetWhatPage.cpp : implementation file
//

#include "stdafx.h"
#include "CertWiz.h"
#include "GetWhatPage.h"
#include "Certificat.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CGetWhatPage property page

IMPLEMENT_DYNCREATE(CGetWhatPage, CIISWizardPage)

CGetWhatPage::CGetWhatPage(CCertificate * pCert) 
	: CIISWizardPage(CGetWhatPage::IDD, IDS_CERTWIZ, TRUE),
	m_pCert(pCert)
{
	//{{AFX_DATA_INIT(CGetWhatPage)
	m_Index = -1;
	//}}AFX_DATA_INIT
}

CGetWhatPage::~CGetWhatPage()
{
}

void CGetWhatPage::DoDataExchange(CDataExchange* pDX)
{
	CIISWizardPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CGetWhatPage)
	DDX_Radio(pDX, IDC_RADIO0, m_Index);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CGetWhatPage, CIISWizardPage)
	//{{AFX_MSG_MAP(CGetWhatPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWelcomePage message handlers

BOOL 
CGetWhatPage::OnSetActive() 
{
	m_pCert->SetStatusCode(CCertificate::REQUEST_UNDEFINED);
   SetWizardButtons(PSWIZB_BACK | PSWIZB_NEXT);
   return CIISWizardPage::OnSetActive();
}

enum 
{
	REQUEST_NEW_CERT = 0,
	INSTALL_EXISTING_CERT,
	IMPORT_KEYRING_CERT
};

LRESULT 
CGetWhatPage::OnWizardPrev()
{
	return IDD_PAGE_PREV;
}

LRESULT 
CGetWhatPage::OnWizardNext()
{
	UpdateData();
	switch (m_Index)
	{
	case REQUEST_NEW_CERT:
		m_pCert->SetStatusCode(CCertificate::REQUEST_NEW_CERT);
		return IDD_PAGE_NEXT_NEW;
	case INSTALL_EXISTING_CERT:
		m_pCert->SetStatusCode(CCertificate::REQUEST_INSTALL_CERT);
		return IDD_PAGE_NEXT_EXISTING;
	case IMPORT_KEYRING_CERT:
		m_pCert->SetStatusCode(CCertificate::REQUEST_IMPORT_KEYRING);
		return IDD_PAGE_NEXT_IMPORT;
	default:
		ASSERT(FALSE);
	}
	return 1;
}

BOOL CGetWhatPage::OnInitDialog() 
{
	ASSERT(m_pCert != NULL);
	m_Index = 0;
	CIISWizardPage::OnInitDialog();
	GetDlgItem(IDC_RADIO0)->SetFocus();
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certwiz\keypasswordpage.h ===
#if !defined(AFX_KEYPASSWORDPAGE_H__7209C46A_15CB_11D2_91BB_00C04F8C8761__INCLUDED_)
#define AFX_KEYPASSWORDPAGE_H__7209C46A_15CB_11D2_91BB_00C04F8C8761__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// KeyPassword.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CKeyPasswordPage dialog
class CCertificate;

class CKeyPasswordPage : public CIISWizardPage
{
	DECLARE_DYNCREATE(CKeyPasswordPage)

// Construction
public:
	CKeyPasswordPage(CCertificate * pCert = NULL);
	~CKeyPasswordPage();

	enum
	{
		IDD_PAGE_PREV = IDD_PAGE_WIZ_GETKEY_FILE,
		IDD_PAGE_NEXT = IDD_PAGE_WIZ_INSTALL_KEYCERT
	};
// Dialog Data
	//{{AFX_DATA(CKeyPasswordPage)
	enum { IDD = IDD_PAGE_WIZ_GET_PASSWORD };
	CString	m_Password;
	//}}AFX_DATA
	CCertificate * m_pCert;


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CKeyPasswordPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	public:
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
	virtual BOOL OnSetActive();
	virtual BOOL OnKillActive();
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CKeyPasswordPage)
	afx_msg void OnEditchangePassword();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_KEYPASSWORDPAGE_H__7209C46A_15CB_11D2_91BB_00C04F8C8761__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certwiz\netutil.h ===
//
// NetUtil.h
//
#ifndef _NETUTIL_H
#define _NETUTIL_H

BOOL GetCurrentUserFullName(CString& name);

#define WIZ_CERT_REQUEST_STATUS_CONNECTION_FAILED		1
#define WIZ_CERT_REQUEST_STATUS_REQUEST_DENIED			2
#define WIZ_CERT_REQUEST_STATUS_CERT_ISSUED				3
#define WIZ_CERT_REQUEST_STATUS_ISSUED_SEPARATELY		4
#define WIZ_CERT_REQUEST_STATUS_UNDER_SUBMISSION		5
#define WIZ_CERT_REQUEST_STATUS_REQUEST_ERROR			6
#define WIZ_CERT_REQUEST_STATUS_INSTALL_FAILED			7



#endif	// _NETUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certwiz\getwhatpage.h ===
#if !defined(AFX_GETWHATPAGE_H__E8F5A02F_1372_11D2_8A1D_000000000000__INCLUDED_)
#define AFX_GETWHATPAGE_H__E8F5A02F_1372_11D2_8A1D_000000000000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// GetWhatPage.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CGetWhatPage window
class CCertificate;

class CGetWhatPage : public CIISWizardPage
{
	DECLARE_DYNCREATE(CGetWhatPage)
// Construction
public:
	CGetWhatPage(CCertificate * pCert = NULL);
	~CGetWhatPage();

	enum
	{
		IDD_PAGE_PREV = IDD_PAGE_WELCOME_START,
		IDD_PAGE_NEXT_NEW = IDD_PAGE_WIZ_CHOOSE_CATYPE,
		IDD_PAGE_NEXT_EXISTING = IDD_PAGE_WIZ_CHOOSE_CERT,
		IDD_PAGE_NEXT_IMPORT = IDD_PAGE_WIZ_GETKEY_FILE
	};
// Dialog Data
	//{{AFX_DATA(CGetWhatPage)
	enum { IDD = IDD_PAGE_WIZ_GET_WHAT };
	int		m_Index;
	//}}AFX_DATA
	CCertificate * m_pCert;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CGetWhatPage)
   public:
   virtual BOOL OnSetActive();
	virtual LRESULT OnWizardPrev();
	virtual LRESULT OnWizardNext();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CGetWhatPage)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_GETWHATPAGE_H__E8F5A02F_1372_11D2_8A1D_000000000000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certwiz\managecertpage.h ===
#if !defined(AFX_MANAGECERTPAGE_H__A57C38A8_3B7F_11D2_817E_0000F87A921B__INCLUDED_)
#define AFX_MANAGECERTPAGE_H__A57C38A8_3B7F_11D2_817E_0000F87A921B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ManageCertPage.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CManageCertPage dialog
class CCertificate;

class CManageCertPage : public CIISWizardPage
{
	DECLARE_DYNCREATE(CManageCertPage)

// Construction
public:
	CManageCertPage(CCertificate * pCert = NULL);
	~CManageCertPage();

	enum
	{
		IDD_PAGE_NEXT_RENEW = IDD_PAGE_WIZ_CHOOSE_CATYPE,
		IDD_PAGE_NEXT_REMOVE = IDD_PAGE_WIZ_REMOVE_CERT,
		IDD_PAGE_NEXT_REPLACE = IDD_PAGE_WIZ_CHOOSE_CERT,
		IDD_PAGE_PREV = IDD_PAGE_WELCOME_START
	};
	enum
	{
		CONTINUE_RENEW = 0,
		CONTINUE_REMOVE,
		CONTINUE_REPLACE
	};
// Dialog Data
	//{{AFX_DATA(CManageCertPage)
	enum { IDD = IDD_PAGE_WIZ_MANAGE_CERT };
	int		m_Index;
	//}}AFX_DATA
	CCertificate * m_pCert;


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CManageCertPage)
	public:
	virtual LRESULT OnWizardBack();
	virtual LRESULT OnWizardNext();
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CManageCertPage)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MANAGECERTPAGE_H__A57C38A8_3B7F_11D2_817E_0000F87A921B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certwiz\mru.h ===
//
// mru.h
//
#define MAX_MRU   10
BOOL LoadMRU(LPCTSTR mru_name, CComboBox * pCombo, int nMax);
BOOL AddToMRU(LPCTSTR mru_name, CString& str);
BOOL LoadMRUToCombo(CWnd * pDlg, int id, LPCTSTR mru_name, LPCTSTR str, int mru_size);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certwiz\orginfopage.cpp ===
// OrgInfoPage.cpp : implementation file
//

#include "stdafx.h"
#include "CertWiz.h"
#include "OrgInfoPage.h"
#include "Certificat.h"
#include "mru.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

void DDV_MaxCharsCombo(CDataExchange* pDX, UINT ControlID, CString const& value, int nChars)
{
	ASSERT(nChars >= 1);        // allow them something
	if (pDX->m_bSaveAndValidate && value.GetLength() > nChars)
	{
		DDV_MaxChars(pDX, value, nChars);
	}
	else
	{
	  // limit the control max-chars automatically
	  pDX->m_pDlgWnd->SendDlgItemMessage(ControlID, CB_LIMITTEXT, nChars, 0);
	}
}

/////////////////////////////////////////////////////////////////////////////
// COrgInfoPage property page

IMPLEMENT_DYNCREATE(COrgInfoPage, CIISWizardPage)

COrgInfoPage::COrgInfoPage(CCertificate * pCert) 
	: CIISWizardPage(COrgInfoPage::IDD, IDS_CERTWIZ, TRUE),
	m_pCert(pCert)
{
	//{{AFX_DATA_INIT(COrgInfoPage)
	m_OrgName = _T("");
	m_OrgUnit = _T("");
	//}}AFX_DATA_INIT
}

COrgInfoPage::~COrgInfoPage()
{
}

void COrgInfoPage::DoDataExchange(CDataExchange* pDX)
{
	CIISWizardPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(COrgInfoPage)
	DDX_Text(pDX, IDC_NEWKEY_ORG, m_OrgName);
	DDV_MaxCharsCombo(pDX, IDC_NEWKEY_ORG, m_OrgName, 64);
	DDX_Text(pDX, IDC_NEWKEY_ORGUNIT, m_OrgUnit);
	DDV_MaxCharsCombo(pDX, IDC_NEWKEY_ORGUNIT, m_OrgUnit, 64);
	//}}AFX_DATA_MAP
}

LRESULT 
COrgInfoPage::OnWizardBack()
{
   return m_pCert->m_DefaultCSP ? IDD_PAGE_PREV : IDD_PREV_CSP;
}

LRESULT 
COrgInfoPage::OnWizardNext()
{
	UpdateData(TRUE);
	m_pCert->m_Organization = m_OrgName;
	m_pCert->m_OrganizationUnit = m_OrgUnit;
	return IDD_PAGE_NEXT;
}

BOOL 
COrgInfoPage::OnSetActive() 
{
	SetButtons();
   return CIISWizardPage::OnSetActive();
}

void COrgInfoPage::SetButtons()
{
	UpdateData(TRUE);	
	SetWizardButtons(m_OrgName.IsEmpty() || m_OrgUnit.IsEmpty() ? 
			PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);
}

BEGIN_MESSAGE_MAP(COrgInfoPage, CIISWizardPage)
	//{{AFX_MSG_MAP(COrgInfoPage)
	ON_CBN_EDITCHANGE(IDC_NEWKEY_ORG, OnChangeName)
	ON_CBN_EDITCHANGE(IDC_NEWKEY_ORGUNIT, OnChangeName)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// COrgInfoPage message handlers

BOOL COrgInfoPage::OnInitDialog() 
{
	ASSERT(m_pCert != NULL);
	m_OrgName = m_pCert->m_Organization;
	m_OrgUnit = m_pCert->m_OrganizationUnit;
	
	CIISWizardPage::OnInitDialog();
		
	// Load MRU names
	LoadMRUToCombo(this, IDC_NEWKEY_ORG, szOrganizationMRU, m_OrgName, MAX_MRU);
	LoadMRUToCombo(this, IDC_NEWKEY_ORGUNIT, szOrganizationUnitMRU, m_OrgUnit, MAX_MRU);

	GetDlgItem(IDC_NEWKEY_ORG)->SetFocus();
	return FALSE;
}

void COrgInfoPage::OnChangeName() 
{
	SetButtons();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certwiz\orginfopage.h ===
#if !defined(AFX_ORGINFOPAGE_H__549054D7_1561_11D2_8A1F_000000000000__INCLUDED_)
#define AFX_ORGINFOPAGE_H__549054D7_1561_11D2_8A1F_000000000000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// OrgInfoPage.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// COrgInfoPage dialog

class CCertificate;

class COrgInfoPage : public CIISWizardPage
{
	DECLARE_DYNCREATE(COrgInfoPage)

// Construction
public:
	COrgInfoPage(CCertificate * pCert = NULL);
	~COrgInfoPage();

	enum
	{
		IDD_PAGE_PREV = IDD_PAGE_WIZ_SECURITY_SETTINGS,
      IDD_PREV_CSP = IDD_PAGE_WIZ_CHOOSE_CSP,
		IDD_PAGE_NEXT = IDD_PAGE_WIZ_SITE_NAME
	};
// Dialog Data
	//{{AFX_DATA(COrgInfoPage)
	enum { IDD = IDD_PAGE_WIZ_ORG_INFO };
	CString	m_OrgName;
	CString	m_OrgUnit;
	//}}AFX_DATA
	CCertificate * m_pCert;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(COrgInfoPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	public:
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
	virtual BOOL OnSetActive();
	//}}AFX_VIRTUAL

// Implementation
protected:
	void SetButtons();
	// Generated message map functions
	//{{AFX_MSG(COrgInfoPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeName();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ORGINFOPAGE_H__549054D7_1561_11D2_8A1F_000000000000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certwiz\notdefined.h ===
//
// notdefined.h
//
// This is temporal header file. We should use it until we will switch
// to latest version of MFC

// From WinUser.h
#if(WINVER < 0x0500)
#define IDC_HAND            MAKEINTRESOURCE(32649)
#endif /* WINVER < 0x0500 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certwiz\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by CertWiz.rc
//
#define IDS_CERTWIZ                     1
#define IDB_CERTWIZ                     1
#define IDS_CERTWIZ_PPG                 2
#define IDD_PAGE_WELCOME_START          132
#define IDS_CERTWIZ_PPG_CAPTION         200
#define IDD_PROPPAGE_CERTWIZ            200
#define IDB_WIZ_LEFT                    201
#define IDS_WELCOME_PAGE_CAPTION        201
#define IDC_COUNTRY_CODE_FILE           201
#define IDB_WIZ_TOP                     202
#define IDS_CHOOSE_CA_PAGE_CAPTION      202
#define IDC_CERT_LIST                   202
#define IDC_BROWSE_CUR                  203
#define IDC_INFO_FILENAME               203
#define IDS_REPLACE_FILE                203
#define IDC_OFFLINE_RADIO               204
#define IDS_PENDING_REQUEST             204
#define IDC_ONLINE_RADIO                205
#define IDS_NEW_CERT                    205
#define IDC_FILE_NAME                   206
#define IDS_REQ_FILE_EXT                206
#define IDC_REQUEST_DUMP                207
#define IDS_RESP_FILE_EXT               207
#define IDC_STATUS_TEXT                 208
#define IDS_REQ_FILE_FILTER             208
#define IDC_BROWSE_BTN                  209
#define IDS_RESP_FILE_FILTER            209
#define IDC_RESP_DUMP                   210
#define IDS_INSTALLED_CERT              210
#define IDS_CERT_INSTALLATION_FAILURE   211
#define IDS_METABASE_OPEN_FAILURE       212
#define IDS_INSTALL_CERT_SUCCESS_HEADER 213
#define IDC_CA_NAME                     213
#define IDS_INSTALL_CERT_FAILURE_HEADER 214
#define IDC_TARGET_INSTANCE_NAME        214
#define IDS_REMOVE_CERT_FAILED          215
#define IDC_CERT_DUMP                   215
#define IDS_CR_DISP_INCOMPLETE          216
#define IDS_CR_DISP_ERROR               217
#define IDC_KEYPASSWORD                 217
#define IDS_CR_DISP_DENIED              218
#define IDC_ERROR_TEXT                  218
#define IDS_CR_DISP_ISSUED_OUT_OF_BAND  219
#define IDS_CR_DISP_UNDER_SUBMISSION    220
#define IDC_CERT_CONTENTS               220
#define IDC_RADIO0                      221
#define IDC_PROCESS_PENDING             221
#define IDC_RENEW_CERT                  221
#define IDS_INTERNAL_ERROR              221
#define IDC_RADIO1                      222
#define IDC_KILL_PENDING                222
#define IDC_REMOVE_CERT                 222
#define IDS_RESPONSE_CERT_KEY_MISMATCH  222
#define IDS_ISSUED_TO                   223
#define IDC_ERROR_MSG                   223
#define IDS_ISSUED_BY                   224
#define IDC_SGC_CERT                    224
#define IDC_RADIO2                      225
#define IDS_EXPIRATION_DATE             225
#define IDS_PURPOSE                     226
#define IDS_FRIENDLY_NAME               227
#define IDS_FRIENDLYNAME_NONE           228
#define IDS_REMOVE_CERT_SUCCESS_HEADER  229
#define IDC_REPLACE_CERT                230
#define IDS_REMOVE_CERT_FAILURE_HEADER  230
#define IDS_RESP_FILE_DEFAULT           231
#define IDS_REQ_FILE_DEFAULT            232
#define IDC_STATIC_WZ_BODY2             232
#define IDS_CANCEL_CERT_SUCCESS_HEADER  233
#define IDC_PHONE_EXT                   233
#define IDS_CANCEL_CERT_FAILURE_HEADER  234
#define IDC_STATUS_LINE                 234
#define IDS_ASK_CREATE_DIR              235
#define IDC_PROVIDER_SELECT             235
#define IDS_FINAL_TO_FILE_SUCCESS_HEADER 236
#define IDS_FINAL_TO_FILE_FAILURE_HEADER 237
#define IDC_CSP_LIST                    237
#define IDS_CERTKEY_MISMATCH_ERROR1     238
#define IDS_CERTKEY_MISMATCH_ERROR2     239
#define IDS_WEB_SITE_N                  240
#define IDS_KEY_FILE_EXT                241
#define IDS_KEY_FILE_FILTER             242
#define IDS_KEY_FILE_DEFAULT            243
#define IDC_STATIC_DESC                 244
#define IDS_FAILED_IMPORT_KEY_FILE      244
#define IDS_COUNTRY                     245
#define IDC_STATIC_DESC_WHERE2MAIL_CERT 246
#define IDS_STATE                       246
#define IDS_LOCALITY                    247
#define IDS_ORGANIZATION                248
#define IDS_ORGANIZATION_UNIT           249
#define IDS_ANY                         250
#define IDS_CERTKEY_ALREADY_INSTALLED   251
#define IDS_CERTKEY_ALREADY_INSTALLED_WHERE 252
#define IDS_FINAL_TO_FILE_BODY_SUCCESS  253
#define IDS_CONTACT_NAME                254
#define IDS_CONTACT_ADDRESS             255
#define IDS_CONTACT_PHONE               256
#define IDS_FILE_DOES_NOT_EXIST         257
#define IDS_FILE_IS_DIRECTORY           258
#define IDS_CERT_REPLACE_SUCCESS        259
#define IDS_CERT_INSTALLED_SUCCESS      260
#define IDS_CERT_CANCEL_SUCCESS         261
#define IDS_CERT_REMOVE_SUCCESS         262
#define IDS_CERT_REQUEST_SUCCESS        263
#define IDS_MICROSOFT_CA_LINK           264
#define IDS_ALL                         265
#define IDS_WRONG_PHONE_NUMBER          266
#define IDC_NEWKEY_COUNTRY              1017
#define IDC_NEWKEY_ORG                  1018
#define IDC_NEWKEY_STATE                1019
#define IDC_NEWKEY_ORGUNIT              1020
#define IDC_NEWKEY_LOCALITY             1022
#define IDC_NEWKEY_COMMONNAME           1023
#define IDC_HOTLINK_CCODES              1052
#define IDC_NK_CA_FILE_RADIO            1070
#define IDC_NK_CA_ONLINE_RADIO          1071
#define IDC_NK_CA_ONLINE                1072
#define IDC_CA_ONLINE_LIST              1072
#define IDC_NKUI_USER_NAME              1073
#define IDC_CONTACT_NAME                1073
#define IDC_NK_CA_BROWSE                1074
#define IDC_NK_INFO_FILENAME            1080
#define IDC_NK_CA_FILE                  1082
#define IDC_NKUI_EMAIL_ADDRESS          1083
#define IDC_EMAIL_ADDRESS               1083
#define IDC_NKUI_PHONE_NUMBER           1084
#define IDC_PHONE_NUMBER                1084
#define IDC_NKKI_NAME                   1085
#define IDC_FRIENDLY_NAME               1085
#define IDC_NKKI_BITS                   1086
#define IDC_BIT_LENGTH                  1086
#define IDD_PAGE_WIZ_CHOOSE_CERT        2776
#define IDC_STATIC_WZ_WELCOME           4000
#define IDC_STATIC_WZ_TITLE             4001
#define IDC_STATIC_WZ_SUBTITLE          4002
#define IDC_STATIC_WZ_BODY              4003
#define IDC_STATIC_WZ_CLICK             4004
#define IDC_STATIC_WZ_HEADER_DIVIDER    4005
#define IDD_PAGE_WIZ_GET_WHAT           30140
#define IDD_PAGE_WIZ_CHOOSE_CA          30141
#define IDD_PAGE_WIZ_CHOOSE_ONLINE      30141
#define IDD_PAGE_WIZ_SECURITY_SETTINGS  30142
#define IDD_PAGE_WIZ_ORG_INFO           30143
#define IDD_PAGE_WIZ_SITE_NAME          30144
#define IDD_PAGE_WIZ_GEO_INFO           30145
#define IDD_PAGE_WIZ_CONTACT_INFO       30146
#define IDD_PAGE_WIZ_FILE_INFO          30147
#define IDD_PAGE_WIZ_FINAL_TO_FILE      30148
#define IDD_PAGE_WIZ_CHOOSE_CATYPE      30149
#define IDD_PAGE_WIZ_CHOOSE_FILENAME    30150
#define IDD_PAGE_WIZ_REQUEST_DUMP       30151
#define IDD_PAGE_WIZ_PENDING_WHAT_TODO  30152
#define IDD_PAGE_WIZ_GETRESP_FILE       30153
#define IDD_PAGE_WIZ_INSTALL_RESP       30154
#define IDD_PAGE_WIZ_MANAGE_CERT        30155
#define IDD_PAGE_WIZ_FINAL_INSTALL      30156
#define IDD_PAGE_WIZ_REMOVE_CERT        30157
#define IDD_PAGE_WIZ_FINAL_REMOVE       30158
#define IDD_PAGE_WIZ_ONLINE_DUMP        30159
#define IDD_PAGE_WIZ_ERROR_KEY_MISMATCH 30160
#define IDD_PAGE_WIZ_REPLACE_CERT       30161
#define IDD_PAGE_WIZ_INSTALL_CERT       30162
#define IDD_PAGE_WIZ_CANCEL_REQUEST     30163
#define IDD_PAGE_WIZ_FINAL_CANCEL       30164
#define IDD_PAGE_WIZ_GETKEY_FILE        30165
#define IDD_PAGE_WIZ_GET_PASSWORD       30166
#define IDD_PAGE_WIZ_INSTALL_KEYCERT    30167
#define IDD_PAGE_WIZ_FINAL_REPLACE      30168
#define IDD_PAGE_WIZ_CHOOSE_CSP         30169
#define IDS_COUNTRIES_FIRST             61000
#define ID_STATIC                       65535

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        204
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         238
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certwiz\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certwiz\netutil.cpp ===
//
// NetUtil.cpp
//
#include "stdafx.h"
#include <lm.h>
#include "NetUtil.h"

#include <wincrypt.h>
#include <certrpc.h>
#include <certcli.h>
#include <malloc.h>

#define LEVEL_1						1
#define LEVEL_2						2

BOOL GetCurrentUserFullName(CString& name)
{
	BOOL bRes = FALSE;
	NET_API_STATUS nas;
	WKSTA_USER_INFO_1 * pWksInfo = NULL;
	if (NERR_Success == (nas = NetWkstaUserGetInfo(NULL, 
										LEVEL_1, (BYTE **)&pWksInfo)))
	{
		USER_INFO_2 * pUserInfo = NULL;
		CString strServerName = _T("\\\\");
		ASSERT(pWksInfo->wkui1_logon_server[0] != 0);
		strServerName += pWksInfo->wkui1_logon_server;
		if (NERR_Success == (nas = NetUserGetInfo(
					(LPCWSTR)strServerName,
					(LPCWSTR)pWksInfo->wkui1_username,
					LEVEL_2,
					(BYTE **)&pUserInfo)))
		{
			name = pUserInfo->usri2_full_name;
			if (pUserInfo != NULL)
				NetApiBufferFree(pUserInfo);
			bRes = TRUE;
		}
		if (pWksInfo != NULL)
			NetApiBufferFree(pWksInfo);
	}
	return bRes;
}

#if 0
/*********************************** Direct Cert Request *********************************/

typedef struct _RPC_BINDING_LIST
{
	LPTSTR pszProtSeq;
   LPTSTR pszEndpoint;
} RPC_BINDING_LIST;

RPC_BINDING_LIST g_BindingList[] =
{
	{_T("ncacn_ip_tcp"), NULL},
   {_T("ncacn_np"), _T("\\pipe\\cert")}
};
DWORD g_BindingListSize = sizeof(g_BindingList)/sizeof(g_BindingList[0]);

typedef struct _RPC_ATHN_LIST
{
   DWORD dwAuthnLevel;
   DWORD dwAuthnService;
} RPC_ATHN_LIST;

RPC_ATHN_LIST g_AthnList[] =
{
   { RPC_C_AUTHN_LEVEL_PKT_INTEGRITY, RPC_C_AUTHN_GSS_NEGOTIATE},
   { RPC_C_AUTHN_LEVEL_NONE, RPC_C_AUTHN_NONE }
};
DWORD g_AthnListSize = sizeof(g_AthnList)/sizeof(g_AthnList[0]);

//-----------------------------------------------------------------------
//
// RetrivePKCS7FromCA
//
//------------------------------------------------------------------------
HRESULT 
RetrievePKCS7FromCA(CString& strCALocation,
                    CString& strCAName,
                    LPWSTR pwszRequestString,
                    CRYPT_DATA_BLOB * pPKCS10Blob,
                    CRYPT_DATA_BLOB * pPKCS7Blob,
                    DWORD * pdwStatus,
						  BOOL bRenew)
{
   HRESULT hr = E_FAIL;
   UINT id = 0;
	DWORD dwDisposition = 0;
	DWORD dwErr = 0;
	DWORD dwStatus = 0;
   RPC_STATUS rpcStatus = 0;

	CERTTRANSBLOB tbRequest = {0, NULL};
   CERTTRANSBLOB tbCert = {0, NULL};
   CERTTRANSBLOB tbCertChain = {0, NULL};
   CERTTRANSBLOB tbAttrib = {0, NULL};
   CERTTRANSBLOB tbDispositionMessage = {0, NULL};

   LPTSTR szStringBinding = NULL;
   RPC_BINDING_HANDLE hCARPCBinding = NULL;
   LPTSTR pszCAPrinceName = NULL;

   //input checking
   if (!pPKCS10Blob || !pPKCS7Blob)
      return E_INVALIDARG;

	for (DWORD i = 0; i < g_BindingListSize; i++)
   {
		if (RPC_S_OK != RpcNetworkIsProtseqValid(g_BindingList[i].pszProtSeq))
			continue;
		rpcStatus = RpcStringBindingCompose(NULL, 
										g_BindingList[i].pszProtSeq,
                              (LPTSTR)(LPCTSTR)strCALocation,
                              g_BindingList[i].pszEndpoint,
                              NULL,
                              &szStringBinding);
      if(rpcStatus != RPC_S_OK)
			continue;
		rpcStatus = RpcBindingFromStringBinding(szStringBinding, &hCARPCBinding);
      if (szStringBinding)
			RpcStringFree(&szStringBinding);
      if (rpcStatus != RPC_S_OK)
			continue;
      rpcStatus = RpcEpResolveBinding(hCARPCBinding, ICertPassage_v0_0_c_ifspec);
      if (rpcStatus == RPC_S_OK)
			break;
	}
   if (rpcStatus != RPC_S_OK)
   {
      dwStatus = WIZ_CERT_REQUEST_STATUS_CONNECTION_FAILED;
		hr = E_FAIL;
      goto CLEANUP;
   }

	//add the attribute to the request
   if (pwszRequestString)
   {
		tbAttrib.cb = (wcslen(pwszRequestString) + 1) * sizeof(WCHAR);
      tbAttrib.pb = (BYTE *)pwszRequestString;
   }

   //submit the request
   tbRequest.cb = pPKCS10Blob->cbData;
   tbRequest.pb = pPKCS10Blob->pbData;

   //set the RPC connect as the SNEGO connect, which can authenticate
   //a machine if supported by the system
   //do not need to check the return value since not supported by NT4/Win9x

   for (i = 0; i < g_AthnListSize; i++)
   {
		pszCAPrinceName = NULL;
      if (g_AthnList[i].dwAuthnService != RPC_C_AUTHN_NONE)
      {
			dwErr = RpcMgmtInqServerPrincNameA(hCARPCBinding, 
										g_AthnList[i].dwAuthnService,
                              (PBYTE *)&pszCAPrinceName);
         if (dwErr == RPC_S_UNKNOWN_AUTHN_SERVICE)
				continue;
		}
		dwErr = RpcBindingSetAuthInfo(hCARPCBinding,
										pszCAPrinceName,
                              g_AthnList[i].dwAuthnLevel,
                              g_AthnList[i].dwAuthnService,
                              NULL,
                              RPC_C_AUTHZ_NONE);
		if (pszCAPrinceName)
			RpcStringFree(&pszCAPrinceName);
		if (dwErr == RPC_S_UNKNOWN_AUTHN_SERVICE)
			continue;
      if (dwErr != RPC_S_OK)
			break;
		//determine the format flag
		DWORD dwFlags = CR_IN_BINARY | bRenew ? CR_IN_PKCS7 : CR_IN_PKCS10;
		DWORD dwRequestId = 0;
		__try
      {
			dwErr = CertServerRequest(
			    hCARPCBinding,
             dwFlags,
			    strCAName,
			    &dwRequestId,
			    &dwDisposition,
			    &tbAttrib,
			    &tbRequest,
			    &tbCertChain,
			    &tbCert,
			    &tbDispositionMessage);
		}
      __except(dwErr = GetExceptionCode(), EXCEPTION_EXECUTE_HANDLER)
      {
      }

      if (dwErr != RPC_S_UNKNOWN_AUTHN_SERVICE)
			break;
	}

	if (	dwErr == RPC_S_UNKNOWN_AUTHN_SERVICE 
		||	dwErr == RPC_S_SERVER_UNAVAILABLE 
		||	dwErr == RPC_S_SERVER_TOO_BUSY
		)
	{
      // We tried all of our auth services, but just couldn't connect
      dwStatus = WIZ_CERT_REQUEST_STATUS_CONNECTION_FAILED;
		hr = E_FAIL;
      goto CLEANUP;
	}

   //get the return code
   hr = HRESULT_FROM_WIN32(dwErr);

   //we want to detect the case when hr is S_OK and the
   //request is denied.  In this case, dwDispotion
   //is the REAL hresult code.
   if (hr == S_OK)
   {
		if(FAILED(dwDisposition))
      {
			hr = dwDisposition;
         dwDisposition = CR_DISP_DENIED;
      }
   }
   else
   {
		dwDisposition=CR_DISP_ERROR;
   }

   //map the dwDisposition
	switch (dwDisposition)
   {
   case CR_DISP_DENIED:
		dwStatus = WIZ_CERT_REQUEST_STATUS_REQUEST_DENIED;
		if (!FAILED(hr))
         hr = E_FAIL;
		break;

	case CR_DISP_ISSUED:
		dwStatus = WIZ_CERT_REQUEST_STATUS_CERT_ISSUED;
      break;

	case CR_DISP_ISSUED_OUT_OF_BAND:
		dwStatus = WIZ_CERT_REQUEST_STATUS_ISSUED_SEPARATELY;
      break;

	case CR_DISP_UNDER_SUBMISSION:
		dwStatus = WIZ_CERT_REQUEST_STATUS_UNDER_SUBMISSION;
      break;

	//we should never get CR_DISP_INCOMPLETE or CR_DISP_REVOKED
   //case    CR_DISP_INCOMPLETE:
   //case    CR_DISP_REVOKED:
   case CR_DISP_ERROR:
   default:
		dwStatus = WIZ_CERT_REQUEST_STATUS_REQUEST_ERROR;
		if (!FAILED(hr))
         hr=E_FAIL;
      break;
	}

   if (hr != S_OK)
      goto CLEANUP;

   //copy the PKCS7 blob
   pPKCS7Blob->cbData = tbCertChain.cb;
	pPKCS7Blob->pbData = new BYTE[tbCertChain.cb];

   if (NULL == pPKCS7Blob->pbData)
   {
		hr = E_OUTOFMEMORY;
      dwStatus = WIZ_CERT_REQUEST_STATUS_INSTALL_FAILED;
      goto CLEANUP;
   }
   memcpy(pPKCS7Blob->pbData,tbCertChain.pb,tbCertChain.cb);

   hr = S_OK;

CLEANUP:

	if (pdwStatus)
		*pdwStatus = dwStatus;

	if (tbCert.pb)
		CoTaskMemFree(tbCert.pb);

	if (tbCertChain.pb)
		CoTaskMemFree(tbCertChain.pb);

	if (tbDispositionMessage.pb)
		CoTaskMemFree(tbDispositionMessage.pb);

	if (hCARPCBinding)
		RpcBindingFree(&hCARPCBinding);

	return hr;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certwiz\welcomepage.cpp ===
// WelcomePage.cpp : implementation file
//

#include "stdafx.h"
#include "CertWiz.h"
#include "WelcomePage.h"
#include "Certificat.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWelcomePage property page

IMPLEMENT_DYNCREATE(CWelcomePage, CIISWizardBookEnd2)

CWelcomePage::CWelcomePage(CCertificate * pCert) 
	: CIISWizardBookEnd2(CWelcomePage::IDD, IDS_WELCOME_PAGE_CAPTION, &pCert->m_idErrorText),
	m_pCert(pCert),
	m_ContinuationFlag(CONTINUE_UNDEFINED)
{
	//{{AFX_DATA_INIT(CWelcomePage)
	//}}AFX_DATA_INIT
}

CWelcomePage::~CWelcomePage()
{
}

void CWelcomePage::DoDataExchange(CDataExchange* pDX)
{
	CIISWizardBookEnd2::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CWelcomePage)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CWelcomePage, CIISWizardBookEnd2)
	//{{AFX_MSG_MAP(CWelcomePage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWelcomePage message handlers

LRESULT 
CWelcomePage::OnWizardNext()
/*++
Routine Description:
    Next button handler

Arguments:
    None

Return Value:
	0 to automatically advance to the next page;
	1 to prevent the page from changing. 
	To jump to a page other than the next one, 
	return the identifier of the dialog to be displayed.
--*/
{
	ASSERT(m_pCert != NULL);
	int id;
	switch (m_ContinuationFlag)
	{
	case CONTINUE_NEW_CERT:
		id = IDD_PAGE_NEXT_NEW;
		break;
	case CONTINUE_PENDING_CERT:
		id = IDD_PAGE_NEXT_PENDING;
		break;
	case CONTINUE_INSTALLED_CERT:
		id = IDD_PAGE_NEXT_INSTALLED;
		break;
	default:
		id = 1;
	}
	return id;
}

BOOL 
CWelcomePage::OnSetActive() 
/*++
Routine Description:
    Activation handler

Arguments:
    None

Return Value:
    TRUE for success, FALSE for failure
--*/
{
   SetWizardButtons(PSWIZB_NEXT);
   return CIISWizardBookEnd2::OnSetActive();
}

BOOL CWelcomePage::OnInitDialog() 
{
	ASSERT(!m_pCert->m_MachineName.IsEmpty());
	ASSERT(!m_pCert->m_WebSiteInstanceName.IsEmpty());
	// check status of web server
	// set status flag
	UINT id;
	if (m_pCert->HasPendingRequest())
	{
		m_ContinuationFlag = CONTINUE_PENDING_CERT;
		id = IDS_PENDING_REQUEST;
	}
	else if (m_pCert->HasInstalledCert())
	{
		m_ContinuationFlag = CONTINUE_INSTALLED_CERT;
		id = IDS_INSTALLED_CERT;
	}
	else
	{
		m_ContinuationFlag = CONTINUE_NEW_CERT;
		id = IDS_NEW_CERT;
	}
	m_pCert->SetBodyTextID(id);
	return CIISWizardBookEnd2::OnInitDialog();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certwiz\mru.cpp ===
//
// mru.cpp
//
#include "stdafx.h"
#include "CertWiz.h"

#include <commctrl.h>
#include <comctrlp.h>
#include <shlwapi.h>
#include "mru.h"

extern CCertWizApp NEAR theApp;

/***********************************************************************
	Thunks to internal functions in ComCtl32
 */

const TCHAR szComCtl32[] = _T("comctl32.dll");

#ifdef UNICODE
#define CREATE_LIST_ORD			400
#define ADD_MRU_STRING_ORD		401
#define ENUM_MRU_LIST_ORD		403
#define FIND_MRU_STRING_ORD	402
#else
#define CREATE_LIST_ORD			151
#define ADD_MRU_STRING_ORD		153
#define ENUM_MRU_LIST_ORD		154
#define FIND_MRU_STRING_ORD	155
#endif
#define FREE_LIST_ORD			152
#define DEL_MRU_STRING_ORD		156
#define DPA_SET_PTR_ORD			335

typedef HANDLE (CALLBACK *CREATE_MRU_LIST)(LPMRUINFO);
typedef void (CALLBACK *FREE_MRU_LIST)(HANDLE);
typedef int (CALLBACK *ADD_MRU_STRING)(HANDLE, LPCTSTR);
typedef int (CALLBACK *DEL_MRU_STRING)(HANDLE, int);
typedef int (CALLBACK *FIND_MRU_STRING)(HANDLE, LPCTSTR, LPINT);
typedef int (CALLBACK *ENUM_MRU_LIST)(HANDLE, int, LPVOID, UINT);

typedef struct _DPA * HDPA;
typedef BOOL (CALLBACK *DPA_SET_PTR)(HDPA hdpa, int i, LPVOID p);

static HINSTANCE
_GetComCtlInstance()
{
	static HANDLE g_hInst;
	if (g_hInst == NULL)
	{
		g_hInst = GetModuleHandle(szComCtl32);
		if (NULL == g_hInst)
			g_hInst = LoadLibrary(szComCtl32);
		ASSERT(NULL != g_hInst);
	}
	return (HINSTANCE)g_hInst;
}

static HANDLE 
_CreateMRUList(LPMRUINFO pmi)
{
	static CREATE_MRU_LIST pfnCreateMRUList;
	if (pfnCreateMRUList == NULL)
	{
		pfnCreateMRUList = (CREATE_MRU_LIST)GetProcAddress(
			_GetComCtlInstance(), (LPCSTR)CREATE_LIST_ORD);
	}
	ASSERT(pfnCreateMRUList != NULL);
	return pfnCreateMRUList(pmi);
}

static void
_FreeMRUList(HANDLE hMru)
{
	static FREE_MRU_LIST pfnFreeMRUList;
	if (pfnFreeMRUList == NULL)
	{
		pfnFreeMRUList = (FREE_MRU_LIST)GetProcAddress(
			_GetComCtlInstance(), (LPCSTR)FREE_LIST_ORD);
	}
	ASSERT(pfnFreeMRUList != NULL);
	pfnFreeMRUList(hMru);
}

static int
_AddMRUString(HANDLE hMru, LPCTSTR szString)
{
	static ADD_MRU_STRING pfnAddMRUString;
	if (pfnAddMRUString == NULL)
	{
		pfnAddMRUString = (ADD_MRU_STRING)GetProcAddress(
			_GetComCtlInstance(), (LPCSTR)ADD_MRU_STRING_ORD);
	}
	ASSERT(pfnAddMRUString != NULL);
	return pfnAddMRUString(hMru, szString);
}

static int
_DelMRUString(HANDLE hMru, int item)
{
	static DEL_MRU_STRING pfnDelMRUString;
	if (pfnDelMRUString == NULL)
	{
		pfnDelMRUString = (DEL_MRU_STRING)GetProcAddress(
			_GetComCtlInstance(), (LPCSTR)DEL_MRU_STRING_ORD);
	}
	ASSERT(pfnDelMRUString != NULL);
	return pfnDelMRUString(hMru, item);
}

static int
_EnumMRUList(HANDLE hMru, int nItem, LPVOID lpData, UINT uLen)
{
	static ENUM_MRU_LIST pfnEnumMRUList;
	if (pfnEnumMRUList == NULL)
	{
		pfnEnumMRUList = (ENUM_MRU_LIST)GetProcAddress(
			_GetComCtlInstance(), (LPCSTR)ENUM_MRU_LIST_ORD);
	}
	ASSERT(pfnEnumMRUList != NULL);
	return pfnEnumMRUList(hMru, nItem, lpData, uLen);
}

#if 0
static BOOL
_DPA_SetPtr(HDPA hdpa, int i, LPVOID p)
{
	static DPA_SET_PTR pfnDPASetPtr;
	if (pfnDPASetPtr == NULL)
	{
		pfnDPASetPtr = (DPA_SET_PTR)GetProcAddress(
			_GetComCtlInstance(), (LPCSTR)DPA_SET_PTR_ORD);
	}
	ASSERT(pfnDPASetPtr != NULL);
	return pfnDPASetPtr(hdpa, i, p);
}
#endif
/****************************************************************************/

HANDLE 
CreateMRU(const CString& mru_name, int nMax)
{
	MRUINFO mi =  
	{
		sizeof(MRUINFO),
      nMax,
      MRU_CACHEWRITE,
      theApp.RegOpenKeyWizard(),
      mru_name,
      NULL        // NOTE: use default string compare
   };

   //Call the comctl32 mru implementation to load the MRU from
   //the registry
   HANDLE hMRU = _CreateMRUList(&mi);
	RegCloseKey(mi.hKey);
	return hMRU;
}

BOOL 
GetMRUEntry(HANDLE hMRU, int iIndex, CString& str)
{
	BOOL bRes= FALSE;
   //Check for valid parameters
	ASSERT(hMRU != NULL);
     
	//Check for valid index
   if (iIndex >= 0 && iIndex <= _EnumMRUList(hMRU, -1, NULL, 0))
   {
		LPTSTR p = str.GetBuffer(MAX_PATH);
		bRes = (_EnumMRUList(hMRU, iIndex, p, MAX_PATH) > 0);
		str.ReleaseBuffer();
	}
	return bRes;
}

BOOL 
LoadMRU(LPCTSTR mru_name, CComboBox * pCombo, int nMax)
{   
	BOOL fRet = FALSE;
	HANDLE hMRU;
    
	ASSERT(mru_name != NULL && mru_name[0] != 0);
	ASSERT(nMax > 0);

   if (NULL != (hMRU = CreateMRU(mru_name, nMax)))
	{
		//First reset the hwndCombo
		pCombo->ResetContent();

		//Now load the hwndcombo with file list from MRU.
		int i = 0;
		while (nMax > 0)
		{
			CString name;
			if (GetMRUEntry(hMRU, i++, name))
			{
				pCombo->AddString(name);
				nMax--;
				fRet = TRUE;
			}
			else
				break;
		}
		_FreeMRUList(hMRU);
	}
   return fRet;
}

BOOL 
AddToMRU(LPCTSTR mru_name, CString& name)
{
   HANDLE hMRU = CreateMRU(mru_name, 10);
   if (hMRU)
   {
      _AddMRUString(hMRU, name);
		_FreeMRUList(hMRU);
		return TRUE;
	}
   return FALSE;
}

BOOL
LoadMRUToCombo(CWnd * pDlg, int id, LPCTSTR mru_name, LPCTSTR str, int mru_size)
{
	ASSERT(mru_name != NULL);
	ASSERT(str != NULL);
	CComboBox * pCombo = (CComboBox *)CComboBox::FromHandle(pDlg->GetDlgItem(id)->m_hWnd);
	if (LoadMRU(mru_name, pCombo, mru_size))
	{
		// select LRU name in combobox
		if (	CB_ERR == pCombo->SelectString(-1, str)
			&& !str[0] == 0
			)
		{
			// put our default to combobox edit
			pCombo->AddString(str);
			pCombo->SelectString(-1, str);
		}
		return TRUE;
	}
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certwiz\securitysettingspage.h ===
#if !defined(AFX_SECURITYSETTINGSPAGE_H__549054D4_1561_11D2_8A1F_000000000000__INCLUDED_)
#define AFX_SECURITYSETTINGSPAGE_H__549054D4_1561_11D2_8A1F_000000000000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// SecuritySettingsPage.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CSecuritySettingsPage dialog
class CCertificate;

typedef struct _KEY_LIMITS
{
	DWORD min, max, def;
} KEY_LIMITS;

class CSecuritySettingsPage : public CIISWizardPage
{
	DECLARE_DYNCREATE(CSecuritySettingsPage)

// Construction
public:
	CSecuritySettingsPage(CCertificate * pCert = NULL);
	~CSecuritySettingsPage();

	enum
	{
		IDD_PREV_PAGE = IDD_PAGE_WIZ_CHOOSE_CA,
		IDD_NEXT_PAGE = IDD_PAGE_WIZ_ORG_INFO,
      IDD_NEXT_CSP = IDD_PAGE_WIZ_CHOOSE_CSP
	};
// Dialog Data
	//{{AFX_DATA(CSecuritySettingsPage)
	enum { IDD = IDD_PAGE_WIZ_SECURITY_SETTINGS };
	int		m_BitLengthIndex;
	CString	m_FriendlyName;
	BOOL	m_SGC_cert;
   BOOL  m_choose_CSP;
   CButton m_check_csp;
	//}}AFX_DATA
	CCertificate * m_pCert;
	CList<int, int> m_regkey_size_list;
	CList<int, int> m_sgckey_size_list;
	KEY_LIMITS	m_regkey_limits, m_sgckey_limits;
	int m_lru_reg, m_lru_sgc;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CSecuritySettingsPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardPrev();
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CSecuritySettingsPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeFriendlyName();
	afx_msg void OnSgcCert();
	afx_msg void OnSelectCsp();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SECURITYSETTINGSPAGE_H__549054D4_1561_11D2_8A1F_000000000000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certwiz\securitysettingspage.cpp ===
// SecuritySettingsPage.cpp : implementation file
//

#include "stdafx.h"
#include "CertWiz.h"
#include "SecuritySettingsPage.h"
#include "Certificat.h"
#include "CertUtil.h"
#include "Shlwapi.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSecuritySettingsPage property page

IMPLEMENT_DYNCREATE(CSecuritySettingsPage, CIISWizardPage)

CSecuritySettingsPage::CSecuritySettingsPage(CCertificate * pCert) 
	: CIISWizardPage(CSecuritySettingsPage::IDD, IDS_CERTWIZ, TRUE),
	m_pCert(pCert)
{
	//{{AFX_DATA_INIT(CSecuritySettingsPage)
	m_BitLengthIndex = -1;
	m_FriendlyName = _T("");
	m_SGC_cert = FALSE;
   m_choose_CSP = FALSE;
	//}}AFX_DATA_INIT
	m_lru_reg = m_lru_sgc = 0;
}

CSecuritySettingsPage::~CSecuritySettingsPage()
{
}

void CSecuritySettingsPage::DoDataExchange(CDataExchange* pDX)
{
	CIISWizardPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSecuritySettingsPage)
	DDX_CBIndex(pDX, IDC_BIT_LENGTH, m_BitLengthIndex);
	DDX_Text(pDX, IDC_FRIENDLY_NAME, m_FriendlyName);
	DDV_MaxChars(pDX, m_FriendlyName, 256);
	DDX_Check(pDX, IDC_SGC_CERT, m_SGC_cert);
	DDX_Check(pDX, IDC_PROVIDER_SELECT, m_choose_CSP);
   DDX_Control(pDX, IDC_PROVIDER_SELECT, m_check_csp);
	//}}AFX_DATA_MAP
}

BOOL 
CSecuritySettingsPage::OnSetActive() 
{
	SetWizardButtons(m_FriendlyName.IsEmpty() ? 
			PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);
	return CIISWizardPage::OnSetActive();
}

LRESULT 
CSecuritySettingsPage::OnWizardPrev()
/*++
Routine Description:
    Prev button handler

Arguments:
    None

Return Value:
	0 to automatically advance to the prev page;
	1 to prevent the page from changing. 
	To jump to a page other than the prev one, 
	return the identifier of the dialog to be displayed.
--*/
{
	return CSecuritySettingsPage::IDD_PREV_PAGE;
}

LRESULT 
CSecuritySettingsPage::OnWizardNext()
{
	TCHAR buf[6];
	UpdateData();
	
	m_pCert->m_FriendlyName = m_FriendlyName;
	GetDlgItem(IDC_BIT_LENGTH)->SendMessage(CB_GETLBTEXT, m_BitLengthIndex, (LPARAM)buf);
	m_pCert->m_KeyLength = StrToInt(buf);
	m_pCert->m_SGCcertificat = m_SGC_cert;
	if (m_SGC_cert)
	{
		// it was a smart move, but xenroll makes 512 bits default for SGC,
		// so we always creating 512 certs
//		if (m_pCert->m_KeyLength == (int)m_sgckey_limits.def)
//			m_pCert->m_KeyLength = 0;
	}
	else
	{
		if (m_pCert->m_KeyLength == (int)m_regkey_limits.def)
			m_pCert->m_KeyLength = 0;
	}

	VERIFY(m_pCert->SetSecuritySettings());
   m_pCert->m_DefaultCSP = !m_choose_CSP;
   return m_choose_CSP ? IDD_NEXT_CSP : IDD_NEXT_PAGE;
}

BEGIN_MESSAGE_MAP(CSecuritySettingsPage, CIISWizardPage)
	//{{AFX_MSG_MAP(CSecuritySettingsPage)
	ON_EN_CHANGE(IDC_FRIENDLY_NAME, OnChangeFriendlyName)
	ON_BN_CLICKED(IDC_SGC_CERT, OnSgcCert)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSecuritySettingsPage message handlers

DWORD dwPredefinedKeyLength[] =
{
    0,    // 0 means default
    512,
    1024,
    2048,
    4096,
    8192,
    16384
};
#define COUNT_KEYLENGTH sizeof(dwPredefinedKeyLength)/sizeof(dwPredefinedKeyLength[0])

BOOL CSecuritySettingsPage::OnInitDialog() 
{
	ASSERT(m_pCert != NULL);
	m_FriendlyName = m_pCert->m_FriendlyName;
	CIISWizardPage::OnInitDialog();
	OnChangeFriendlyName();

	HRESULT hr;
	CString str;
	if (GetKeySizeLimits(m_pCert->GetEnrollObject(),
				&m_regkey_limits.min, 
				&m_regkey_limits.max, 
				&m_regkey_limits.def, 
				FALSE, 
				&hr))
	{
		for (int i = 0; i < COUNT_KEYLENGTH; i++)
		{
			if (	dwPredefinedKeyLength[i] >= m_regkey_limits.min 
				&& dwPredefinedKeyLength[i] <= m_regkey_limits.max
				)
			{
				m_regkey_size_list.AddTail(dwPredefinedKeyLength[i]);
				if (m_pCert->m_KeyLength == (int)dwPredefinedKeyLength[i])
					m_BitLengthIndex = i + 1;
			}
		}
	}
	else
	{
		ASSERT(FALSE);
		m_pCert->m_hResult = hr;
	}
	if (m_BitLengthIndex == -1)
		m_BitLengthIndex = 0;

	// for SGC temporarily set only one size
	m_sgckey_limits.min = 1024;
	m_sgckey_limits.max = 1024;
	m_sgckey_limits.def = 1024;
	m_sgckey_size_list.AddTail(1024);
	
	m_SGC_cert = m_pCert->m_SGCcertificat;
   m_choose_CSP = !m_pCert->m_DefaultCSP;

	UpdateData(FALSE);
	
	if (m_SGC_cert)
		GetDlgItem(IDC_SGC_CERT)->SendMessage(
			BM_SETCHECK, m_SGC_cert ? BST_CHECKED : BST_UNCHECKED, 0);
	OnSgcCert();

	GetDlgItem(IDC_FRIENDLY_NAME)->SetFocus();
	return FALSE;
}

void CSecuritySettingsPage::OnChangeFriendlyName() 
{
	UpdateData(TRUE);
	SetWizardButtons(m_FriendlyName.IsEmpty() ? 
			PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);
}

void CSecuritySettingsPage::OnSgcCert() 
{
	// Currently, only one key size works with SGC flag:
	// 1024, so we need to limit combobox to this length, if 
	// button is checked
	CButton * pCheckBox = (CButton *)CWnd::FromHandle(GetDlgItem(IDC_SGC_CERT)->m_hWnd);
	CComboBox * pCombo = (CComboBox *)CWnd::FromHandle(GetDlgItem(IDC_BIT_LENGTH)->m_hWnd);
	int check_state = pCheckBox->GetCheck();
	int lru_index, count;
	CList<int, int> * pList;
	if (check_state == 1)
	{
		// switch combo to previously selected SGC size
		m_lru_reg = pCombo->GetCurSel();
		lru_index = m_lru_sgc;
		pList = &m_sgckey_size_list;
	}
	else
	{
		// switch combo to previously selected regular size
		m_lru_sgc = pCombo->GetCurSel();
		lru_index = m_lru_reg;
		pList = &m_regkey_size_list;
	}
	// now refill the combo with key length and select the relevant last one
	pCombo->ResetContent();
	CString str;
	POSITION pos = pList->GetHeadPosition();
	while (pos != NULL)
	{
		str.Format(L"%d", pList->GetNext(pos));
		pCombo->AddString(str);
	}
	count = pCombo->GetCount();
	pCombo->SetCurSel(count > 1 ? lru_index : 0);
	pCombo->EnableWindow(count > 1);
}

void CSecuritySettingsPage::OnSelectCsp() 
{
   m_pCert->m_DefaultCSP = m_check_csp.GetCheck() == 0;
   m_choose_CSP = !m_pCert->m_DefaultCSP;
   if (m_pCert->m_DefaultCSP)
      m_pCert->m_CspName.Empty();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certwiz\welcomepage.h ===
#if !defined(AFX_WELCOMEPAGE_H__D4BE8672_0C85_11D2_91B1_00C04F8C8761__INCLUDED_)
#define AFX_WELCOMEPAGE_H__D4BE8672_0C85_11D2_91B1_00C04F8C8761__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// WelcomePage.h : header file
//
#include "BookEndPage.h"

/////////////////////////////////////////////////////////////////////////////
// CWelcomePage dialog
class CCertificate;

class CWelcomePage : public CIISWizardBookEnd2
{
	DECLARE_DYNCREATE(CWelcomePage)

// Construction
public:
	CWelcomePage(CCertificate * pCert = NULL);
	~CWelcomePage();

	enum
	{
		CONTINUE_UNDEFINED = 0,
		CONTINUE_NEW_CERT = 1,
		CONTINUE_PENDING_CERT = 2,
		CONTINUE_INSTALLED_CERT = 3
	};
	enum
	{
		IDD_PAGE_NEXT_NEW = IDD_PAGE_WIZ_GET_WHAT,
		IDD_PAGE_NEXT_PENDING = IDD_PAGE_WIZ_PENDING_WHAT_TODO,
		IDD_PAGE_NEXT_INSTALLED = IDD_PAGE_WIZ_MANAGE_CERT
	};
// Dialog Data
	//{{AFX_DATA(CWelcomePage)
	enum { IDD = IDD_PAGE_WELCOME_START };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA
	CCertificate * m_pCert;
	int m_ContinuationFlag;


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CWelcomePage)
   public:
   virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CWelcomePage)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WELCOMEPAGE_H__D4BE8672_0C85_11D2_91B1_00C04F8C8761__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certwiz\whattodopendingpage.h ===
#if !defined(AFX_WHATTODOPENDINGPAGE_H__6BF86387_2E29_11D2_816C_0000F87A921B__INCLUDED_)
#define AFX_WHATTODOPENDINGPAGE_H__6BF86387_2E29_11D2_816C_0000F87A921B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// WhatToDoPendingPage.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CWhatToDoPendingPage dialog
class CCertificate;

class CWhatToDoPendingPage : public CIISWizardPage
{
	DECLARE_DYNCREATE(CWhatToDoPendingPage)

// Construction
public:
	CWhatToDoPendingPage(CCertificate * pCert = NULL);
	~CWhatToDoPendingPage();

	enum
	{
		IDD_PAGE_NEXT_PROCESS = IDD_PAGE_WIZ_GETRESP_FILE,
		IDD_PAGE_NEXT_CANCEL = IDD_PAGE_WIZ_CANCEL_REQUEST,
		IDD_PAGE_PREV = IDD_PAGE_WELCOME_START
	};

// Dialog Data
	//{{AFX_DATA(CWhatToDoPendingPage)
	enum { IDD = IDD_PAGE_WIZ_PENDING_WHAT_TODO };
	int		m_Index;
	//}}AFX_DATA
	CCertificate * m_pCert;


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CWhatToDoPendingPage)
	public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardBack();
	virtual LRESULT OnWizardNext();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CWhatToDoPendingPage)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};


#endif // !defined(AFX_WHATTODOPENDINGPAGE_H__6BF86387_2E29_11D2_816C_0000F87A921B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certwiz\sitenamepage.h ===
#if !defined(AFX_SITENAMEPAGE_H__7209C46A_15CB_11D2_91BB_00C04F8C8761__INCLUDED_)
#define AFX_SITENAMEPAGE_H__7209C46A_15CB_11D2_91BB_00C04F8C8761__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// SiteNamePage.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CSiteNamePage dialog
class CCertificate;

class CSiteNamePage : public CIISWizardPage
{
	DECLARE_DYNCREATE(CSiteNamePage)

// Construction
public:
	CSiteNamePage(CCertificate * pCert = NULL);
	~CSiteNamePage();

	enum
	{
		IDD_PAGE_PREV = IDD_PAGE_WIZ_ORG_INFO,
		IDD_PAGE_NEXT = IDD_PAGE_WIZ_GEO_INFO
	};
// Dialog Data
	//{{AFX_DATA(CSiteNamePage)
	enum { IDD = IDD_PAGE_WIZ_SITE_NAME };
	CString	m_CommonName;
	//}}AFX_DATA
	CCertificate * m_pCert;


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CSiteNamePage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	public:
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardPrev();
	virtual BOOL OnSetActive();
	virtual BOOL OnKillActive();
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CSiteNamePage)
	afx_msg void OnEditchangeNewkeyCommonname();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SITENAMEPAGE_H__7209C46A_15CB_11D2_91BB_00C04F8C8761__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certwiz\sitenamepage.cpp ===
// SiteNamePage.cpp : implementation file
//

#include "stdafx.h"
#include "CertWiz.h"
#include "SiteNamePage.h"
#include "Certificat.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSiteNamePage property page

IMPLEMENT_DYNCREATE(CSiteNamePage, CIISWizardPage)

CSiteNamePage::CSiteNamePage(CCertificate * pCert) 
	: CIISWizardPage(CSiteNamePage::IDD, IDS_CERTWIZ, TRUE),
	m_pCert(pCert)
{
	//{{AFX_DATA_INIT(CSiteNamePage)
	m_CommonName = _T("");
	//}}AFX_DATA_INIT
}

CSiteNamePage::~CSiteNamePage()
{
}

void CSiteNamePage::DoDataExchange(CDataExchange* pDX)
{
	CIISWizardPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSiteNamePage)
	DDX_Text(pDX, IDC_NEWKEY_COMMONNAME, m_CommonName);
	DDV_MaxChars(pDX, m_CommonName, 64);
	//}}AFX_DATA_MAP
}

LRESULT 
CSiteNamePage::OnWizardPrev()
/*++
Routine Description:
    Prev button handler

Arguments:
    None

Return Value:
	0 to automatically advance to the prev page;
	1 to prevent the page from changing. 
	To jump to a page other than the prev one, 
	return the identifier of the dialog to be displayed.
--*/
{
	return IDD_PAGE_PREV;
}

LRESULT 
CSiteNamePage::OnWizardNext()
/*++
Routine Description:
    Next button handler

Arguments:
    None

Return Value:
	0 to automatically advance to the next page;
	1 to prevent the page from changing. 
	To jump to a page other than the next one, 
	return the identifier of the dialog to be displayed.
--*/
{
	UpdateData(TRUE);
	m_pCert->m_CommonName = m_CommonName;
	return IDD_PAGE_NEXT;
}

BOOL 
CSiteNamePage::OnSetActive() 
/*++
Routine Description:
    Activation handler
	We could have empty name field on entrance, so we should
	disable Back button

Arguments:
    None

Return Value:
    TRUE for success, FALSE for failure
--*/
{
	ASSERT(m_pCert != NULL);
	m_CommonName = m_pCert->m_CommonName;
	UpdateData(FALSE);
	SetWizardButtons(m_CommonName.IsEmpty() ? 
			PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);
   return CIISWizardPage::OnSetActive();
}

BOOL 
CSiteNamePage::OnKillActive() 
/*++
Routine Description:
    Activation handler
	We could leave this page only if we have good names
	entered or when Back button is clicked. In both cases
	we should enable both buttons

Arguments:
    None

Return Value:
    TRUE for success, FALSE for failure
--*/
{
	SetWizardButtons(PSWIZB_BACK | PSWIZB_NEXT);
   return CIISWizardPage::OnSetActive();
}

BEGIN_MESSAGE_MAP(CSiteNamePage, CIISWizardPage)
	//{{AFX_MSG_MAP(CSiteNamePage)
	ON_EN_CHANGE(IDC_NEWKEY_COMMONNAME, OnEditchangeNewkeyCommonname)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSiteNamePage message handlers

void CSiteNamePage::OnEditchangeNewkeyCommonname() 
{
	UpdateData(TRUE);	
	SetWizardButtons(m_CommonName.IsEmpty() ? 
			PSWIZB_BACK : PSWIZB_BACK | PSWIZB_NEXT);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certwiz\whattodopendingpage.cpp ===
// WhatToDoPendingPage.cpp : implementation file
//

#include "stdafx.h"
#include "CertWiz.h"
#include "WhatToDoPendingPage.h"
#include "Certificat.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWhatToDoPendingPage property page

IMPLEMENT_DYNCREATE(CWhatToDoPendingPage, CIISWizardPage)

CWhatToDoPendingPage::CWhatToDoPendingPage(CCertificate * pCert) 
	: CIISWizardPage(CWhatToDoPendingPage::IDD, IDS_CERTWIZ, TRUE),
	m_pCert(pCert)
{
	//{{AFX_DATA_INIT(CWhatToDoPendingPage)
	m_Index = -1;
	//}}AFX_DATA_INIT
}

CWhatToDoPendingPage::~CWhatToDoPendingPage()
{
}

void CWhatToDoPendingPage::DoDataExchange(CDataExchange* pDX)
{
	CIISWizardPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CWhatToDoPendingPage)
	DDX_Radio(pDX, IDC_PROCESS_PENDING, m_Index);
	//}}AFX_DATA_MAP
}

BOOL 
CWhatToDoPendingPage::OnSetActive() 
{
	m_pCert->SetStatusCode(CCertificate::REQUEST_UNDEFINED);
   SetWizardButtons(PSWIZB_BACK | PSWIZB_NEXT);
   return CIISWizardPage::OnSetActive();
}

LRESULT 
CWhatToDoPendingPage::OnWizardNext()
{
	UpdateData();
	switch (m_Index)
	{
	case 0:
		m_pCert->SetStatusCode(CCertificate::REQUEST_PROCESS_PENDING);
		return IDD_PAGE_NEXT_PROCESS;
	case 1:
		return IDD_PAGE_NEXT_CANCEL;
	default:
		ASSERT(FALSE);
	}
	return 1;
}

LRESULT 
CWhatToDoPendingPage::OnWizardBack()
{
	return IDD_PAGE_PREV;
}

BEGIN_MESSAGE_MAP(CWhatToDoPendingPage, CIISWizardPage)
	//{{AFX_MSG_MAP(CWhatToDoPendingPage)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWhatToDoPendingPage message handlers
BOOL CWhatToDoPendingPage::OnInitDialog() 
{
	m_Index = 0;
	CIISWizardPage::OnInitDialog();
	GetDlgItem(IDC_PROCESS_PENDING)->SetFocus();
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\certwiz\stdafx.h ===
#if !defined(AFX_STDAFX_H__D4BE8636_0C85_11D2_91B1_00C04F8C8761__INCLUDED_)
#define AFX_STDAFX_H__D4BE8636_0C85_11D2_91B1_00C04F8C8761__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers
#include <afxtempl.h>
#include <afxctl.h>         // MFC support for ActiveX Controls
#include <afxcmn.h>

// from \NT\PUBLIC\sdk\inc
#include "basetsd.h"		
#include "accctrl.h"

// from ..\ComProp
#include "ComProp.h"
#include "Wizard.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__D4BE8636_0C85_11D2_91B1_00C04F8C8761__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\cnfgprts\appedmpd.h ===
// AppEdMpD.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CAppEditMapDlg dialog

class CAppEditMapDlg : public CDialog
{
// Construction
public:
    CAppEditMapDlg(CWnd* pParent = NULL);   // standard constructor
    virtual BOOL OnInitDialog();

    // the flags
    DWORD       m_dwFlags;

    // flag indicating if this is a new mapping
    BOOL        m_fNewMapping;

    // are we editing the local machine?
    BOOL        m_fLocalMachine;

    // the target listbox
    CListCtrl*  m_pList;

// Dialog Data
    //{{AFX_DATA(CAppEditMapDlg)
    enum { IDD = IDD_APP_EDITMAP };
    CButton m_radio_LimitedTo;
    CButton m_radio_All;
    CEdit   m_edit_Exclusions;
    CEdit   m_cedit_extension;
    CEdit   m_cedit_executable;
    CButton m_cbttn_browse;
    BOOL    m_bool_file_exists;
    BOOL    m_bool_script_engine;
    CString m_sz_executable;
    CString m_sz_extension;
    CString m_sz_exclusions;
    int     m_nAllLimited;
    //}}AFX_DATA

protected:
    //
    // Radio button values (RONALDM)
    //
    enum 
    {
        RADIO_ALL_VERBS,
        RADIO_LIMITED_VERBS,
    };

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAppEditMapDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CAppEditMapDlg)
    virtual void OnOK();
    afx_msg void OnBrowse();
    afx_msg void OnHelpbtn();
    afx_msg void OnRadioAllVerbs();
    afx_msg void OnRadioLimitVerbs();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    void DoHelp();

    CString m_sz_extensionOrig;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\cnfgprts\appedmpd.cpp ===
// AppEdMpD.cpp : implementation file
//

#include "stdafx.h"
#include "cnfgprts.h"
#include "AppEdMpD.h"

#include <iiscnfg.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAppEditMapDlg dialog

//----------------------------------------------------------------
CAppEditMapDlg::CAppEditMapDlg(CWnd* pParent /*=NULL*/)
    : CDialog(CAppEditMapDlg::IDD, pParent),
    m_pList( NULL ),
    m_fNewMapping( FALSE ),
    m_fLocalMachine( TRUE )
    {
    //{{AFX_DATA_INIT(CAppEditMapDlg)
    m_bool_file_exists = FALSE;
    m_bool_script_engine = FALSE;
    m_sz_executable = _T("");
    m_sz_extension = _T("");
    m_sz_exclusions = _T("");
    m_nAllLimited = RADIO_LIMITED_VERBS;
    //}}AFX_DATA_INIT
    }

//----------------------------------------------------------------
void CAppEditMapDlg::DoDataExchange(CDataExchange* pDX)
    {
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAppEditMapDlg)
    DDX_Control(pDX, IDC_RADIO_LIMIT_VERBS, m_radio_LimitedTo);
    DDX_Control(pDX, IDC_RADIO_ALL_VERBS, m_radio_All);
    DDX_Control(pDX, IDC_EDT_EXCLUSIONS, m_edit_Exclusions);
    DDX_Control(pDX, IDC_EDT_EXTENSION, m_cedit_extension);
    DDX_Control(pDX, IDC_EDT_EXECUTABLE, m_cedit_executable);
    DDX_Control(pDX, IDC_BROWSE, m_cbttn_browse);
    DDX_Check(pDX, IDC_CHK_FILE_EXISTS, m_bool_file_exists);
    DDX_Check(pDX, IDC_CHK_SCRIPT_ENGINE, m_bool_script_engine);
    DDX_Text(pDX, IDC_EDT_EXECUTABLE, m_sz_executable);
    DDX_Text(pDX, IDC_EDT_EXTENSION, m_sz_extension);
    DDX_Text(pDX, IDC_EDT_EXCLUSIONS, m_sz_exclusions);
    DDX_Radio(pDX, IDC_RADIO_ALL_VERBS, m_nAllLimited);
    //}}AFX_DATA_MAP
    }

//----------------------------------------------------------------
BEGIN_MESSAGE_MAP(CAppEditMapDlg, CDialog)
    //{{AFX_MSG_MAP(CAppEditMapDlg)
    ON_BN_CLICKED(IDC_BROWSE, OnBrowse)
    ON_BN_CLICKED(ID_HELPBTN, OnHelpbtn)
    ON_BN_CLICKED(IDC_RADIO_ALL_VERBS, OnRadioAllVerbs)
    ON_BN_CLICKED(IDC_RADIO_LIMIT_VERBS, OnRadioLimitVerbs)
    //}}AFX_MSG_MAP

    ON_COMMAND(ID_HELP_FINDER,  DoHelp)
    ON_COMMAND(ID_HELP,         DoHelp)
    ON_COMMAND(ID_CONTEXT_HELP, DoHelp)
    ON_COMMAND(ID_DEFAULT_HELP, DoHelp)
END_MESSAGE_MAP()

//---------------------------------------------------------------------------
void CAppEditMapDlg::DoHelp()
    {
    WinHelp( HIDD_APPMAPS_EDIT_MAP );
    }

/////////////////////////////////////////////////////////////////////////////
// CAppEditMapDlg message handlers

//---------------------------------------------------------------------------
BOOL CAppEditMapDlg::OnInitDialog()
    {
    // we can deal with the flags right here
    if ( m_dwFlags & MD_SCRIPTMAPFLAG_SCRIPT ) m_bool_script_engine = TRUE;
    if ( m_dwFlags & MD_SCRIPTMAPFLAG_CHECK_PATH_INFO ) m_bool_file_exists = TRUE;

    m_sz_extensionOrig = m_sz_extension;

    //call the parental oninitdialog
    BOOL fAnswer = CDialog::OnInitDialog();

    // if this is not the local machine we are editing, then disable browsing
    if ( fAnswer && (!m_fLocalMachine) )
        {
        m_cbttn_browse.EnableWindow( FALSE );
        }

    //
    // Set All/Limited radio button
    //
    
    if (m_sz_exclusions.IsEmpty())
    {
        m_radio_All.SetCheck(1);
        m_radio_LimitedTo.SetCheck(0);
        OnRadioAllVerbs();
    }
    else
    {
        m_radio_All.SetCheck(0);
        m_radio_LimitedTo.SetCheck(1);
        OnRadioLimitVerbs();
    }

    // return the answer
    return fAnswer;
    }

//---------------------------------------------------------------------------
void CAppEditMapDlg::OnOK()
    {
    UpdateData( TRUE );
    CString szFile;

    CString     sz;
    DWORD       attrib;

    // clean up the strings
    m_sz_executable.TrimLeft();
    m_sz_extension.TrimLeft();
    m_sz_executable.TrimRight();
    m_sz_extension.TrimRight();

    //--------------------------------------------------
    //
    // RONALDM -- handle all/limited to verbs situations
    //
    m_sz_exclusions.TrimLeft();
    m_sz_exclusions.TrimRight();

    if (m_nAllLimited == RADIO_ALL_VERBS)
    {
        //
        // "All" supported, empty the list
        //
        m_sz_exclusions.Empty();
    }
    else if (m_sz_exclusions.IsEmpty())
    {
        //
        // Now, it CAN'T be empty, complain about it.
        //
        AfxMessageBox(IDS_ERR_NO_VERBS);
        m_edit_Exclusions.SetFocus();
        m_edit_Exclusions.SetSel(0, -1);

        //
        // Don't dismiss the dialog
        //
        return;
    }
    //--------------------------------------------------


    // the extension is a required field
    if ( m_sz_extension.IsEmpty() || m_sz_extension == _T(".") )
        {
        AfxMessageBox( IDS_APP_ERR_EXT_REQUIRED );
        m_cedit_extension.SetFocus();
        m_cedit_extension.SetSel( 0 , -1 );
        return;
        }
    // if the file starts with a quote then there may be spaces in the name.
    // Extract the file up to the second quote
    if ( m_sz_executable[0] == _T('\"') )
        {
        szFile = m_sz_executable.Right(m_sz_executable.GetLength()-1);
        szFile = szFile.Left(szFile.Find('\"'));
        }
    else if ( m_sz_executable.Find(' ') >= 0 )
        {
        // in case there are parameters after the file name, just take it to the first space
        szFile = m_sz_executable.Left( m_sz_executable.Find(' ') );
        }
    else
        szFile = m_sz_executable;


    // we do NOT allow UNC names in script mappings. Get the drive letter
    // first we test the drive to see if it is local or remote
    // but before that we need to get the drive letter
    _tsplitpath( (LPCTSTR)szFile, sz.GetBuffer(_MAX_DRIVE+1), NULL, NULL, NULL );
    sz.ReleaseBuffer();

    // it can't be a unc path
    if ( sz.IsEmpty() )
        {
        AfxMessageBox( IDS_APP_MAP_USE_VALID_DRIVE );
        m_cedit_executable.SetFocus();
        m_cedit_executable.SetSel( 0 , -1 );
        return;
        }

    // perform extra local-machine tests
    if ( m_fLocalMachine )
        {
        // if local, the drive can't be redirected
        // test the drive and only accept valid, non-remote drives
        attrib = GetDriveType( (LPCTSTR)sz );
        if ( (attrib == DRIVE_REMOTE) )
            {
            AfxMessageBox( IDS_APP_MAP_USE_VALID_DRIVE );
            m_cedit_executable.SetFocus();
            m_cedit_executable.SetSel( 0 , -1 );
            return;
            }

        // check that the file exists
        if ( ::GetFileAttributes(szFile) & FILE_ATTRIBUTE_DIRECTORY )
            {
            AfxMessageBox( IDS_APP_MAP_INVALID_PATH );
            m_cedit_executable.SetFocus();
            m_cedit_executable.SetSel( 0 , -1 );
            return;
            }
        }

    // make sure the extension is valid
    if ( m_sz_extension.ReverseFind('.') > 0 )
    {
        AfxMessageBox( IDS_APP_MAP_INVALID_EXT );
        m_cedit_extension.SetFocus();
        m_cedit_extension.SetSel( 0 , -1 );
        return;
    }
	const TCHAR szBadChars[] = _T(" ,:<>?*/\\");
	if (m_sz_extension != _T("*") && m_sz_extension != _T(".*"))
	{
		if (0 != m_sz_extension.SpanExcluding(szBadChars).Compare(m_sz_extension))
		{
	        AfxMessageBox( IDS_APP_MAP_INVALID_EXT );
	        m_cedit_extension.SetFocus();
	        m_cedit_extension.SetSel( 0 , -1 );
	        return;
		}
	}
	if (m_sz_extension[0] == '*')
	{
		m_sz_extension.SetAt(1, '\0');
	}
	else if (m_sz_extension == _T(".*"))
	{
		m_sz_extension = _T("*");
	}
	else
	{
	    // clean up the extensions string
	    if ( m_sz_extension[0] != '.' )
	        m_sz_extension = '.' + m_sz_extension;
	}
    // there can be only one copy of an extension in the listbox
    // only check this if it is a new mapping, or if the mapping extension has changed
    if ( m_pList && ((m_sz_extensionOrig != m_sz_extension) || m_fNewMapping) )
        {
        DWORD nItems = m_pList->GetItemCount();
        for ( DWORD i = 0; i < nItems; i++ )
            {
            if ( m_pList->GetItemText(i,0) == m_sz_extension )
                {
                AfxMessageBox( IDS_APP_ONLY_ONE );
                m_cedit_extension.SetFocus();
                m_cedit_extension.SetSel( 0 , -1 );
                return;
                }
            }
        }

    // rebuild the flags
    m_dwFlags = 0;
    if ( m_bool_script_engine )
        {
        m_dwFlags |= MD_SCRIPTMAPFLAG_SCRIPT;
        }
    if ( m_bool_file_exists )
        {
        m_dwFlags |= MD_SCRIPTMAPFLAG_CHECK_PATH_INFO;
        }

    // make sure the data goes back
    UpdateData( FALSE );

    CDialog::OnOK();
    }

//---------------------------------------------------------------------------
void CAppEditMapDlg::OnBrowse()
    {
    // prepare the file dialog variables
    CFileDialog             cfdlg(TRUE);
    CString                 szFilter;
    WORD                    i = 0;
    LPTSTR                  lpszBuffer;

    // prepare the filter string
    szFilter.LoadString( IDS_APP_MAP_FILTER );

    // replace the "!" characters with nulls
    lpszBuffer = szFilter.GetBuffer(MAX_PATH+1);
    while( lpszBuffer[i] )
        {
        if ( lpszBuffer[i] == _T('!') )
        lpszBuffer[i] = _T('\0');                       // yes, set \0 on purpose
        i++;
        }

    // prep the dialog
    cfdlg.m_ofn.lpstrFilter = lpszBuffer;

    // run the dialog
    if ( cfdlg.DoModal() == IDOK )
        {
        UpdateData( TRUE );
        m_sz_executable = cfdlg.GetPathName();
        UpdateData( FALSE );
        }

    // release the buffer in the filter string
    szFilter.ReleaseBuffer(-1);
    }

//---------------------------------------------------------------------------
void CAppEditMapDlg::OnHelpbtn() 
    {
    DoHelp();
    }




void 
CAppEditMapDlg::OnRadioAllVerbs() 
/*++

Routine Description:

    "All" radio button handler

Arguments:

    None

Return Value:

    None

Notes:

    Routine by RonaldM

--*/
{
    //
    // No need for the exclusions to be specified by name.
    // Move focus elsewhere to prevent disabled control from
    // having focus.
    //
    m_edit_Exclusions.EnableWindow(FALSE);
    m_radio_All.SetFocus();
}



void 
CAppEditMapDlg::OnRadioLimitVerbs() 
/*++

Routine Description:

    "Limited to" radio button handler

Arguments:

    None

Return Value:

    None

Notes:

    Routine by RonaldM

--*/
{
    //
    // User wants to specify exclusions by name, so
    // focus on exclusions edit box.
    //
    m_edit_Exclusions.EnableWindow(TRUE);
    m_edit_Exclusions.SetFocus();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\cnfgprts\appmappg.cpp ===
// AppMapPg.cpp : implementation file
//

#include "stdafx.h"
#include <iadmw.h>
#include "cnfgprts.h"

#include "ListRow.h"
#include "AppMapPg.h"
#include "AppEdMpD.h"

#include "wrapmb.h"
#include "metatool.h"
#include <iiscnfg.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

enum {
    COL_EXTENSION = 0,
    COL_PATH,
    COL_EXCLUSIONS
    };


#define SZ_ROOT     _T("/lm/w3svc")

/////////////////////////////////////////////////////////////////////////////
// CAppMapPage property page

IMPLEMENT_DYNCREATE(CAppMapPage, CPropertyPage)

//----------------------------------------------------------------
CAppMapPage::CAppMapPage() : CPropertyPage(CAppMapPage::IDD),
        m_fInitialized( FALSE ),
        m_fLocalMachine( FALSE )
    {
    //{{AFX_DATA_INIT(CAppMapPage)
    m_bool_cache_isapi = FALSE;
    //}}AFX_DATA_INIT
    }

//----------------------------------------------------------------
CAppMapPage::~CAppMapPage()
    {
    }

//----------------------------------------------------------------
void CAppMapPage::DoDataExchange(CDataExchange* pDX)
    {
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAppMapPage)
    DDX_Control(pDX, IDC_CHK_CACHE_ISAPI, m_btn_cache_isapi);
    DDX_Check(pDX, IDC_CHK_CACHE_ISAPI, m_bool_cache_isapi);
    DDX_Control(pDX, IDC_REMOVE, m_btn_remove);
    DDX_Control(pDX, IDC_EDIT, m_btn_edit);
    DDX_Control(pDX, IDC_LIST, m_clist_list);
    //}}AFX_DATA_MAP
    }

//----------------------------------------------------------------
BEGIN_MESSAGE_MAP(CAppMapPage, CPropertyPage)
    //{{AFX_MSG_MAP(CAppMapPage)
    ON_BN_CLICKED(IDC_CHK_CACHE_ISAPI, OnChkCacheIsapi)
    ON_BN_CLICKED(IDC_ADD, OnAdd)
    ON_BN_CLICKED(IDC_EDIT, OnEdit)
    ON_BN_CLICKED(IDC_REMOVE, OnRemove)
    ON_NOTIFY(LVN_ITEMCHANGED, IDC_LIST, OnItemchangedList)
    ON_NOTIFY(NM_DBLCLK, IDC_LIST, OnDblclkList)
    //}}AFX_MSG_MAP
    ON_COMMAND(ID_HELP_FINDER,  DoHelp)
    ON_COMMAND(ID_HELP,         DoHelp)
    ON_COMMAND(ID_CONTEXT_HELP, DoHelp)
    ON_COMMAND(ID_DEFAULT_HELP, DoHelp)
END_MESSAGE_MAP()

//---------------------------------------------------------------------------
void CAppMapPage::DoHelp()
    {
    WinHelp( HIDD_APPMAPS_MAPS );
    }

//----------------------------------------------------------------
void CAppMapPage::Init()
    {
    CString sz;
    DWORD   dw = 0;
    WCHAR*  pData = NULL;
    CString szMap;
    CString szSection;
    int     i = 0;

    UpdateData( TRUE );

    //
    // RONALDM: The word "ALL" is displayed for empty verb lists,
    //          though it should not be written to the metabase.
    //
    VERIFY(m_szAll.LoadString(IDS_VERBS_ALL));

    // prepare the list for use
    sz.LoadString( IDS_APP_EXTENSION );
    i = m_clist_list.InsertColumn( COL_EXTENSION, sz, LVCFMT_LEFT, 58 );
    sz.LoadString( IDS_APP_EXE_PATH );
    i = m_clist_list.InsertColumn( COL_PATH, sz, LVCFMT_LEFT, 204 );
    sz.LoadString( IDS_APP_EXCLUSIONS );
    i = m_clist_list.InsertColumn( COL_EXCLUSIONS, sz, LVCFMT_LEFT, 72 );

    // we will just be pulling stuff out of the metabase here
    // prepare the metabase wrapper
    CWrapMetaBase   mbWrap;
    if ( !mbWrap.FInit(m_pMB) ) return;


    // arg arg arg. For things like directories, the metapath may not exist
    // seperate the partial path from the base - the root is always SZ_ROOT
    sz = SZ_ROOT;
    m_szPartial = m_szMeta.Right(m_szMeta.GetLength() - sz.GetLength() );
    
    // open the target
    if ( mbWrap.Open( SZ_ROOT, METADATA_PERMISSION_READ ) )
        {
        // read the session timeout information
        if ( mbWrap.GetDword( m_szPartial, MD_CACHE_EXTENSIONS, IIS_MD_UT_FILE, &dw, METADATA_INHERIT | METADATA_PARTIAL_PATH ) )
            m_bool_cache_isapi = (BOOL)dw;
        else
            m_bool_cache_isapi = FALSE;   // default

        // get the big script map string
        dw = 0;
        pData = (WCHAR*)mbWrap.GetData( m_szPartial, MD_SCRIPT_MAPS, IIS_MD_UT_FILE, MULTISZ_METADATA, &dw, METADATA_INHERIT | METADATA_PARTIAL_PATH );

        // close the metabase
        mbWrap.Close();
        }

    // set the data into place
    UpdateData( FALSE );

    // if we got the mappings string, parse it now - no need to keep the metabase open
    if ( pData )
        {
        WCHAR*  pstr = (WCHAR*)pData;
        // loop through the sub-strings in the multi-sz
        i = -1;
        while( pstr[0] )
            {
            // get the sub-string
            szMap = pstr;

            // Get the sub-sections of the sub-string
            szSection = szMap.Left( szMap.Find(',') );
            szMap = szMap.Right( szMap.GetLength() - szSection.GetLength() - 1 );

            // add the extension to the list
            i = m_clist_list.InsertItem( i+1, szSection );

            // Get the sub-sections of the sub-string
            szSection = szMap.Left( szMap.Find(',') );
            szMap = szMap.Right( szMap.GetLength() - szSection.GetLength() - 1 );

            // add the path to the list
            m_clist_list.SetItemText( i, COL_PATH, szSection );

            // Get the sub-sections of the sub-string
            if ( szMap.Find(',') >= 0 )
                szSection = szMap.Left( szMap.Find(',') );
            else
                szSection = szMap;
            szMap = szMap.Right( szMap.GetLength() - szSection.GetLength() - 1 );

            // convert the flags string into a ddword
            swscanf( (PTCHAR)(LPCTSTR)szSection, _T("%d"), &dw );

            // save the dword on the list item
            m_clist_list.SetItemData( i, dw );

            // the remainder of the list is the list of ISAPI method exclusions
            // add the exclusions to the list

            //
            // RONALDM Change, Bug 178423: If no exclusions (and they're
            // now inclusions, rather than exclusions) are present, the word
            // "ALL" should be placed in the exclusions column.
            //
            m_clist_list.SetItemText(i, COL_EXCLUSIONS, (szMap.IsEmpty() ? m_szAll : szMap));

            // advance the pstr
            pstr += wcslen(pstr) + 1;
            }

        // now we can release the buffer
        mbWrap.FreeWrapData( pData );
        }

    // according to bug #152234 the cache ISAPI extensions should only be exposed on the 
    // master properties or the virtual server level. So - we need to detect if we are on
    // this level and if we are NOT, then disable the control
    //
    // The easiest way to determin if we are deeper than the virtual server is to count
    // the slash characters. If there are more than 3, then we are at a virt dir or phys dir
    DWORD nLevels = 0;
    int iSlash;
    CString szPath = m_szMeta;
    while ( (iSlash = szPath.Find( _T('/') )) >= 0 )
        {
        nLevels++;
        szPath = szPath.Right( szPath.GetLength() - (iSlash + 1) );
        }

    // if the number of levels is greater than 3 then it is a virt dir. Disable the isapi cache option
    if ( nLevels > 3 )
        m_btn_cache_isapi.EnableWindow( FALSE );
    }

//---------------------------------------------------------------------------
void CAppMapPage::EnableItems()
    {
    UpdateData( TRUE );
    if ( m_clist_list.GetSelectedCount() == 1 )
        {
        m_btn_edit.EnableWindow( TRUE );
        m_btn_remove.EnableWindow( TRUE );
        }
    else
        {
        m_btn_edit.EnableWindow( FALSE );
        m_btn_remove.EnableWindow( FALSE );
        }
    }

//----------------------------------------------------------------
// blow away the parameters
void CAppMapPage::BlowAwayParameters()
    {
    // prepare the metabase wrapper
    CWrapMetaBase   mbWrap;
    if ( !mbWrap.FInit(m_pMB) ) return;
    // open the target
    if ( mbWrap.Open( m_szMeta, METADATA_PERMISSION_WRITE ) )
        {
        mbWrap.DeleteData( _T(""), MD_CACHE_EXTENSIONS, DWORD_METADATA );
        mbWrap.DeleteData( _T(""), MD_SCRIPT_MAPS, DWORD_METADATA );
//        mbWrap.DeleteData( _T(""), MD_CACHE_EXTENSIONS, IIS_MD_UT_FILE, DWORD_METADATA );
//        mbWrap.DeleteData( _T(""), MD_SCRIPT_MAPS, IIS_MD_UT_FILE, DWORD_METADATA );
        // close the metabase
        mbWrap.Close();
        }
    }

/////////////////////////////////////////////////////////////////////////////
// CAppMapPage message handlers

//----------------------------------------------------------------
BOOL CAppMapPage::OnApply()
    {
    LPTSTR          lpszBuffer;
    DWORD           dwSize;
    DWORD           i;
    BOOL            f;
    CString         szExclude;

    CString szNewMap;
    CString szExtension;
    CString szPath;
    DWORD   dw;

    UpdateData( TRUE );

    // build the multisz string. Use the * character as a seperator for now, then replace it with nulls
    CString szMappings;

    // build the string
    DWORD   nItems = m_clist_list.GetItemCount();
    for ( i = 0; i < nItems; i++ )
        {
        // prep the optional ISAPI exclution string
        szExclude = m_clist_list.GetItemText(i, COL_EXCLUSIONS);

        //----------------------------------------------------------------------------------------
        //
        // RONALDM: The word "ALL" is a visual indicator that should be replaced
        //          with an empty exclusion list.
        //
        szExclude.TrimLeft();
        szExclude.TrimRight();

        if (szExclude.CompareNoCase(m_szAll) == 0)
        {
            szExclude.Empty();
        }
        //----------------------------------------------------------------------------------------

        if ( !szExclude.IsEmpty() )
            szExclude = _T(',') + szExclude;

        szNewMap;
        szExtension = m_clist_list.GetItemText(i, COL_EXTENSION);
        szPath = m_clist_list.GetItemText(i, COL_PATH);
        // IA64 - OK to cast to DWORD as it is a small numerical flag
        dw = (DWORD)m_clist_list.GetItemData(i);

        szNewMap.Format( _T("%s,%s,%d%s\n"), szExtension, szPath, dw, szExclude );
        szMappings += szNewMap;
        }

    // put on the last delimiter
    szMappings += _T('\n');

    // record the length
    dwSize = szMappings.GetLength();

    // transform it into a multisz
    lpszBuffer = szMappings.GetBuffer(MAX_PATH+1);
    while( lpszBuffer[i] )
        {
        if ( lpszBuffer[i] == _T('\n') )
        lpszBuffer[i] = _T('\0');                       // yes, set \0 on purpose
        i++;
        }

    // prepare the metabase wrapper
    CWrapMetaBase   mbWrap;
    if ( !mbWrap.FInit(m_pMB) ) return FALSE;


    // script file size
    f = SetMetaDword(m_pMB, m_szServer, m_szMeta, _T(""), MD_CACHE_EXTENSIONS, IIS_MD_UT_FILE,
                        m_bool_cache_isapi, TRUE);

    // script mappings
    f = SetMetaMultiSz(m_pMB, m_szServer, m_szMeta, _T(""), MD_SCRIPT_MAPS, IIS_MD_UT_FILE,
                       lpszBuffer, dwSize, TRUE );

    
    // close the metabase
    mbWrap.Close();

    // clean up
    szMappings.ReleaseBuffer(-1);

    SetModified( FALSE );
    return CPropertyPage::OnApply();
    }

//----------------------------------------------------------------
BOOL CAppMapPage::OnSetActive()
    {
    if ( !m_fInitialized )
        {
        Init();
        m_fInitialized = TRUE;
        }
    return CPropertyPage::OnSetActive();
    }

//----------------------------------------------------------------
void CAppMapPage::OnChkCacheIsapi()
    {
    SetModified();
    }

//----------------------------------------------------------------
void CAppMapPage::OnAdd()
    {
    // set up a default edit box
    CAppEditMapDlg  dlg;
    dlg.m_pList = &m_clist_list;
    dlg.m_fNewMapping = TRUE;
    dlg.m_fLocalMachine = m_fLocalMachine;

    dlg.m_dwFlags = MD_SCRIPTMAPFLAG_SCRIPT;

    // ask the user to edit the mapping
    if ( dlg.DoModal() == IDOK )
        {
        // we want to add the extension to the end of the list. So get the number that
        // are already there.
        DWORD numExtensions = m_clist_list.GetItemCount();

        // add the extension to the list
        DWORD i = m_clist_list.InsertItem( numExtensions, dlg.m_sz_extension );
        // add the path to the list
        m_clist_list.SetItemText( i, COL_PATH, dlg.m_sz_executable );
        // save the dword on the list item
        m_clist_list.SetItemData( i, dlg.m_dwFlags );
        // set the exclusion list
        m_clist_list.SetItemText(
            i, 
            COL_EXCLUSIONS, 
            (dlg.m_sz_exclusions.IsEmpty() ? m_szAll : dlg.m_sz_exclusions)
            );
        SetModified();
        }
    }

//----------------------------------------------------------------
void CAppMapPage::OnEdit()
    {
    // make sure something is selcted
    if ( m_clist_list.GetSelectedCount() != 1 )
        return;

    // get the index of the selected item
    int iSel = m_clist_list.GetNextItem( -1, LVNI_SELECTED );

    // set up a default edit box
    CAppEditMapDlg  dlg;
    dlg.m_fLocalMachine = m_fLocalMachine;
    dlg.m_fNewMapping = FALSE;
    dlg.m_pList = &m_clist_list;
    // IA64 - OK to cast as this is a numerical flag 1,2,3,4 etc...
    dlg.m_dwFlags = (DWORD)m_clist_list.GetItemData( iSel );
    dlg.m_sz_extension = m_clist_list.GetItemText( iSel, COL_EXTENSION );
    dlg.m_sz_executable = m_clist_list.GetItemText( iSel, COL_PATH );
    dlg.m_sz_exclusions = m_clist_list.GetItemText( iSel, COL_EXCLUSIONS );

    //
    // RONALDM: Handle "(all)" exclusions cleanly
    //
    if (dlg.m_sz_exclusions.CompareNoCase(m_szAll) == 0)
    {
        dlg.m_sz_exclusions.Empty();
    }

    // run the edit box
    if ( dlg.DoModal() == IDOK )
        {
        // set the path to the list
        m_clist_list.SetItemText( iSel, COL_EXTENSION, dlg.m_sz_extension );
        // set the path to the list
        m_clist_list.SetItemText( iSel, COL_PATH, dlg.m_sz_executable );
        // set the dword on the list item
        m_clist_list.SetItemData( iSel, dlg.m_dwFlags );
        //
        // set the exclusion list
        //
        // RONALDM: blank == "(all)"
        //
        m_clist_list.SetItemText(
            iSel, 
            COL_EXCLUSIONS, 
            (dlg.m_sz_exclusions.IsEmpty() ? m_szAll : dlg.m_sz_exclusions)
            );

        SetModified();
        }
    }

//----------------------------------------------------------------
void CAppMapPage::OnRemove()
    {
    // make sure something is selcted
    if ( m_clist_list.GetSelectedCount() != 1 )
        return;

    // ask the user if that is what they really want to do
    if ( AfxMessageBox(IDS_APP_MAP_REMOVE_CONFIRM, MB_YESNO) != IDYES )
        return;

    // get the index of the selected item
    int iSel = m_clist_list.GetNextItem( -1, LVNI_SELECTED );

    // delete the item
    m_clist_list.DeleteItem( iSel );
    SetModified();
    }

//----------------------------------------------------------------
void CAppMapPage::OnItemchangedList(NMHDR* pNMHDR, LRESULT* pResult)
    {
    NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
    EnableItems();
    *pResult = 0;
    }

//----------------------------------------------------------------
void CAppMapPage::OnDblclkList(NMHDR* pNMHDR, LRESULT* pResult)
    {
    OnEdit();
    *pResult = 0;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\cnfgprts\appmappg.h ===
// AppMapPg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CAppMapPage dialog

class CAppMapPage : public CPropertyPage
{
    DECLARE_DYNCREATE(CAppMapPage)

// Construction
public:
    CAppMapPage();
    ~CAppMapPage();

    IMSAdminBase* m_pMB;

    // the target metabase path
    CString     m_szMeta;
    CString     m_szServer;

    // are we editing the local machine?
    BOOL        m_fLocalMachine;

    // blow away the parameters
    void BlowAwayParameters();

// Dialog Data
    //{{AFX_DATA(CAppMapPage)
    enum { IDD = IDD_APP_APPMAP };
    CButton m_btn_cache_isapi;
    BOOL    m_bool_cache_isapi;
    CButton m_btn_remove;
    CButton m_btn_edit;
    CListSelRowCtrl m_clist_list;
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CAppMapPage)
    public:
    virtual BOOL OnSetActive();
    virtual BOOL OnApply();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CAppMapPage)
    afx_msg void OnChkCacheIsapi();
    afx_msg void OnAdd();
    afx_msg void OnEdit();
    afx_msg void OnRemove();
    afx_msg void OnItemchangedList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnDblclkList(NMHDR* pNMHDR, LRESULT* pResult);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    void DoHelp();

    void Init();
    void EnableItems();

    BOOL    m_fInitialized;


    // cache the path parts
    CString m_szPartial;
    CString m_szAll; // RONALDM --> "ALL"
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\cnfgprts\approcpg.h ===
#if !defined(AFX_PROCPAGE_H__DFD8F146_FE0C_11D0_8AEC_00C04FB6678B__INCLUDED_)
#define AFX_PROCPAGE_H__DFD8F146_FE0C_11D0_8AEC_00C04FB6678B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// ProcPage.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CAppProcPage dialog

class CAppProcPage : public CPropertyPage
{
	DECLARE_DYNCREATE(CAppProcPage)

// Construction
public:
	CAppProcPage();   // standard constructor

    // the target metabase path
    CString     m_szMeta;
    CString     m_szServer;
    IMSAdminBase* m_pMB;

    // blow away the parameters
    void BlowAwayParameters();


// Dialog Data
	//{{AFX_DATA(CAppProcPage)
	enum { IDD = IDD_APP_PROC };
	CEdit	m_cedit_cache_size;
	DWORD	m_dw_cache_size;
	BOOL	m_bool_write_fail_parent;
	DWORD	m_dw_engine_cache_max;
	int		m_int_scriptcache;
	DWORD	m_dw_cgiseconds;
	BOOL	m_bool_catch_exceptions;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAppProcPage)
	public:
	virtual BOOL OnSetActive();
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CAppProcPage)
	afx_msg void OnRdoCacheAll();
	afx_msg void OnRdoCacheSize();
	afx_msg void OnChangeEdtCacheSize();
	afx_msg void OnChkWriteFailToLog();
	afx_msg void OnChangeEdtNumEngines();
	afx_msg void OnRdoCacheNone();
	afx_msg void OnChangeCgiSeconds();
	afx_msg void OnChkExceptionCatch();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

    void DoHelp();

    // utilities
    void Init();
    void EnableItems();

    BOOL    m_fInitialized;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PROCPAGE_H__DFD8F146_FE0C_11D0_8AEC_00C04FB6678B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\cnfgprts\approcpg.cpp ===
// approcpg.cpp : implementation file
//

#include "stdafx.h"
#include <iadmw.h>
#include "cnfgprts.h"

#include "wrapmb.h"
#include "metatool.h"
#include <iiscnfg.h>

#include "approcpg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

enum
    {
    SCRIPTCHACHE_NONE = 0,
    SCRIPTCHACHE_ALL,
    SCRIPTCHACHE_SOME
    };

/////////////////////////////////////////////////////////////////////////////
// CAppProcPage dialog

IMPLEMENT_DYNCREATE(CAppProcPage, CPropertyPage)

//---------------------------------------------------------------------------
CAppProcPage::CAppProcPage() : CPropertyPage(CAppProcPage::IDD),
    m_fInitialized( FALSE )
    {
	//{{AFX_DATA_INIT(CAppProcPage)
	m_dw_cache_size = 0;
    m_bool_write_fail_parent = FALSE;
    m_dw_engine_cache_max = 0;
	m_int_scriptcache = -1;
    m_dw_cgiseconds = 0;
	m_bool_catch_exceptions = FALSE;
	//}}AFX_DATA_INIT
    }

//---------------------------------------------------------------------------
void CAppProcPage::DoDataExchange(CDataExchange* pDX)
    {
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAppProcPage)
	DDX_Control(pDX, IDC_EDT_CACHE_SIZE, m_cedit_cache_size);
	DDX_Text(pDX, IDC_EDT_CACHE_SIZE, m_dw_cache_size);
	DDV_MinMaxDWord(pDX, m_dw_cache_size, 0, 4095);
	DDX_Check(pDX, IDC_CHK_WRITE_FAIL_TO_LOG, m_bool_write_fail_parent);
	DDX_Text(pDX, IDC_EDT_NUM_ENGINES, m_dw_engine_cache_max);
	DDX_Radio(pDX, IDC_RDO_CACHE_NONE, m_int_scriptcache);
    DDX_Text(pDX, IDC_CGI_SECONDS, m_dw_cgiseconds);
	DDX_Check(pDX, IDC_CHK_EXCEPTION_CATCH, m_bool_catch_exceptions);
	//}}AFX_DATA_MAP
    }

//---------------------------------------------------------------------------
BEGIN_MESSAGE_MAP(CAppProcPage, CDialog)
	//{{AFX_MSG_MAP(CAppProcPage)
	ON_BN_CLICKED(IDC_RDO_CACHE_ALL, OnRdoCacheAll)
	ON_BN_CLICKED(IDC_RDO_CACHE_SIZE, OnRdoCacheSize)
	ON_EN_CHANGE(IDC_EDT_CACHE_SIZE, OnChangeEdtCacheSize)
	ON_BN_CLICKED(IDC_CHK_WRITE_FAIL_TO_LOG, OnChkWriteFailToLog)
	ON_EN_CHANGE(IDC_EDT_NUM_ENGINES, OnChangeEdtNumEngines)
	ON_BN_CLICKED(IDC_RDO_CACHE_NONE, OnRdoCacheNone)
	ON_EN_CHANGE(IDC_CGI_SECONDS, OnChangeCgiSeconds)
	ON_BN_CLICKED(IDC_CHK_EXCEPTION_CATCH, OnChkExceptionCatch)
	//}}AFX_MSG_MAP
    ON_COMMAND(ID_HELP_FINDER,  DoHelp)
    ON_COMMAND(ID_HELP,         DoHelp)
    ON_COMMAND(ID_CONTEXT_HELP, DoHelp)
    ON_COMMAND(ID_DEFAULT_HELP, DoHelp)
END_MESSAGE_MAP()

//---------------------------------------------------------------------------
void CAppProcPage::DoHelp()
    {
    // go to the appropriate helpmapping
//    if ( m_fInProcGlobal )
//        WinHelp( HIDD_APPMAPS_IN_PROC_GLOBAL );
//    else
        WinHelp( HIDD_APPMAPS_OUT_OF_PROC );
    }

//---------------------------------------------------------------------------
void CAppProcPage::EnableItems()
    {
    UpdateData( TRUE );

    if ( m_int_scriptcache == SCRIPTCHACHE_SOME )
        {
        m_cedit_cache_size.EnableWindow( TRUE );
        }
    else
        {
        m_cedit_cache_size.EnableWindow( FALSE );
        }
    }

//---------------------------------------------------------------------------
void CAppProcPage::Init() 
    {
    UpdateData( TRUE );
    DWORD   dw;

    // we will just be pulling stuff out of the metabase here
    // prepare the metabase wrapper
    CWrapMetaBase   mbWrap;
    if ( !mbWrap.FInit(m_pMB) ) return;

    // open the target
    if ( mbWrap.Open( m_szMeta, METADATA_PERMISSION_READ ) )
        {
        // CGI Timeout
        m_dw_cgiseconds = 0;
        if ( mbWrap.GetDword( _T(""), MD_SCRIPT_TIMEOUT, IIS_MD_UT_FILE, &dw, METADATA_INHERIT ) )
            {
            m_dw_cgiseconds = dw;
            }
        else
            m_dw_cgiseconds = 900;

        // script file cache
        m_dw_cache_size = 0xFFFFFFFF;
        if ( mbWrap.GetDword( _T(""), MD_ASP_SCRIPTFILECACHESIZE, IIS_MD_UT_WAM, &dw, METADATA_INHERIT ) )
            {
            if ( dw == 0 )
                {
                m_int_scriptcache = SCRIPTCHACHE_NONE;
                m_dw_cache_size = 1000;
                }
            else if ( dw != 0xFFFFFFFF )
                {
                m_int_scriptcache = SCRIPTCHACHE_SOME;
                m_dw_cache_size = dw;
                }
            }

        // if the cache size is -1 (0xFFFFFFFF)
        if ( m_dw_cache_size == 0xFFFFFFFF )
            {
            m_int_scriptcache = SCRIPTCHACHE_ALL;
            m_dw_cache_size = 1000;
            }

        // read the write errors flag
        if ( mbWrap.GetDword( _T(""), MD_ASP_LOGERRORREQUESTS, IIS_MD_UT_WAM, &dw, METADATA_INHERIT ) )
            m_bool_write_fail_parent = dw;
        else
            m_bool_write_fail_parent = TRUE;   // default

        // read the max engine cache
        if ( mbWrap.GetDword( _T(""), MD_ASP_SCRIPTENGINECACHEMAX, IIS_MD_UT_WAM, &dw, METADATA_INHERIT ) )
            m_dw_engine_cache_max = dw;
        else
            m_dw_engine_cache_max = 30;   // default

        // get the exception catching
        if ( mbWrap.GetDword( _T(""), MD_ASP_EXCEPTIONCATCHENABLE, IIS_MD_UT_WAM, &dw, METADATA_INHERIT ) )
            m_bool_catch_exceptions = dw;
        else
            m_bool_catch_exceptions = 0;

        // close the metabase
        mbWrap.Close();
        }

    // set the data into place
    UpdateData( FALSE );

    // enable the approprieate items
    EnableItems();
    }

//----------------------------------------------------------------
// blow away the parameters
void CAppProcPage::BlowAwayParameters()
    {
     // prepare the metabase wrapper
    CWrapMetaBase   mbWrap;
    if ( !mbWrap.FInit(m_pMB) ) return;
   // open the target
    if ( mbWrap.Open( m_szMeta, METADATA_PERMISSION_WRITE ) )
        {
        mbWrap.DeleteData( _T(""), MD_SCRIPT_TIMEOUT, DWORD_METADATA );
        mbWrap.DeleteData( _T(""), MD_ASP_SCRIPTFILECACHESIZE, DWORD_METADATA );
        mbWrap.DeleteData( _T(""), MD_ASP_LOGERRORREQUESTS, DWORD_METADATA );
        mbWrap.DeleteData( _T(""), MD_ASP_SCRIPTENGINECACHEMAX, DWORD_METADATA );
        mbWrap.DeleteData( _T(""), MD_ASP_EXCEPTIONCATCHENABLE, DWORD_METADATA );

/*
        mbWrap.DeleteData( _T(""), MD_SCRIPT_TIMEOUT, IIS_MD_UT_FILE, DWORD_METADATA );
        mbWrap.DeleteData( _T(""), MD_ASP_SCRIPTFILECACHESIZE, IIS_MD_UT_WAM, DWORD_METADATA );
        mbWrap.DeleteData( _T(""), MD_ASP_LOGERRORREQUESTS, IIS_MD_UT_WAM, DWORD_METADATA );
        mbWrap.DeleteData( _T(""), MD_ASP_SCRIPTENGINECACHEMAX, IIS_MD_UT_WAM, DWORD_METADATA );
        mbWrap.DeleteData( _T(""), MD_ASP_EXCEPTIONCATCHENABLE, IIS_MD_UT_WAM, DWORD_METADATA );
*/
        // close the metabase
        mbWrap.Close();
        }
    }

/////////////////////////////////////////////////////////////////////////////
// CAppProcPage message handlers

//----------------------------------------------------------------
BOOL CAppProcPage::OnSetActive() 
    {
    // if this is the first time, init the parameters
    if ( !m_fInitialized )
        {
        Init();
        m_fInitialized = TRUE;
        }
    return CPropertyPage::OnSetActive();
    }

//----------------------------------------------------------------
BOOL CAppProcPage::OnApply() 
    {
    DWORD   dwCache = 0;        // local cache reference
    BOOL    f;

    UpdateData( TRUE );

    // set the correct cache size
    switch( m_int_scriptcache )
        {
        case SCRIPTCHACHE_NONE:
            dwCache = 0;
            break;
        case SCRIPTCHACHE_ALL:
            dwCache = 0xFFFFFFFF;
            break;
        case SCRIPTCHACHE_SOME:
            dwCache = m_dw_cache_size;
            break;
        };


    // exception catching
    f = SetMetaDword( m_pMB, m_szServer, m_szMeta, _T(""), MD_ASP_EXCEPTIONCATCHENABLE,
                    IIS_MD_UT_WAM, m_bool_catch_exceptions, TRUE );
    // cgi timeout
    f = SetMetaDword( m_pMB, m_szServer, m_szMeta, _T(""), MD_SCRIPT_TIMEOUT,
                    IIS_MD_UT_FILE, m_dw_cgiseconds, TRUE );
    // script file size
    f = SetMetaDword( m_pMB, m_szServer, m_szMeta, _T(""), MD_ASP_SCRIPTFILECACHESIZE,
                    IIS_MD_UT_WAM, dwCache, TRUE );
    // write errors
    f = SetMetaDword( m_pMB, m_szServer, m_szMeta, _T(""), MD_ASP_LOGERRORREQUESTS,
                    IIS_MD_UT_WAM, m_bool_write_fail_parent, TRUE );
    // max engine cache
    f = SetMetaDword( m_pMB, m_szServer, m_szMeta, _T(""), MD_ASP_SCRIPTENGINECACHEMAX,
                    IIS_MD_UT_WAM, m_dw_engine_cache_max, TRUE );


    SetModified( FALSE );
    return CPropertyPage::OnApply();
    }

//----------------------------------------------------------------
void CAppProcPage::OnRdoCacheNone() 
    {
    EnableItems();
    SetModified();
    }

//----------------------------------------------------------------
void CAppProcPage::OnRdoCacheAll() 
    {
    EnableItems();
    SetModified();
    }

//----------------------------------------------------------------
void CAppProcPage::OnRdoCacheSize() 
    {
    EnableItems();
    SetModified();
    }

//----------------------------------------------------------------
void CAppProcPage::OnChangeEdtCacheSize() 
    {
    SetModified();
    }

//----------------------------------------------------------------
void CAppProcPage::OnChkWriteFailToLog() 
    {
    SetModified();
    }

//----------------------------------------------------------------
void CAppProcPage::OnChangeEdtNumEngines() 
    {
    SetModified();
    }

//----------------------------------------------------------------
void CAppProcPage::OnChangeCgiSeconds() 
    {
    SetModified();
    }

//----------------------------------------------------------------
void CAppProcPage::OnChkExceptionCatch() 
    {
    SetModified();
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\cnfgprts\appsctl.cpp ===
// AppsCtl.cpp : Implementation of the CAppsCtrl OLE control class.

#include "stdafx.h"
#include <iadmw.h>
#include "cnfgprts.h"
#include "AppsCtl.h"
#include "AppsPpg.h"
#include "AspDbgPg.h"
#include "AspMnPg.h"
#include "approcpg.h"
#include "RecycleOptPage.h"

#include "ListRow.h"
#include "AppMapPg.h"

#include "wrapmb.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CAppsCtrl, COleControl)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CAppsCtrl, COleControl)
    //{{AFX_MSG_MAP(CAppsCtrl)
    //}}AFX_MSG_MAP
    ON_MESSAGE(OCM_COMMAND, OnOcmCommand)
    ON_OLEVERB(AFX_IDS_VERB_PROPERTIES, OnProperties)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Dispatch map

BEGIN_DISPATCH_MAP(CAppsCtrl, COleControl)
    //{{AFX_DISPATCH_MAP(CAppsCtrl)
    DISP_FUNCTION(CAppsCtrl, "DeleteParameters", DeleteParameters, VT_EMPTY, VTS_NONE)
    DISP_FUNCTION(CAppsCtrl, "SetAdminTarget", SetAdminTarget, VT_EMPTY, VTS_BSTR VTS_BSTR VTS_BOOL)
    DISP_FUNCTION(CAppsCtrl, "SetShowProcOptions", SetShowProcOptions, VT_EMPTY, VTS_BOOL)
    DISP_FUNCTION(CAppsCtrl, "DeleteProcParameters", DeleteProcParameters, VT_EMPTY, VTS_NONE)
    DISP_STOCKFUNC_DOCLICK()
    DISP_STOCKPROP_BORDERSTYLE()
    DISP_STOCKPROP_CAPTION()
    DISP_STOCKPROP_ENABLED()
    DISP_STOCKPROP_FONT()
    //}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()


/////////////////////////////////////////////////////////////////////////////
// Event map

BEGIN_EVENT_MAP(CAppsCtrl, COleControl)
    //{{AFX_EVENT_MAP(CAppsCtrl)
    EVENT_STOCK_CLICK()
    EVENT_STOCK_KEYUP()
    //}}AFX_EVENT_MAP
END_EVENT_MAP()


/////////////////////////////////////////////////////////////////////////////
// Property pages

BEGIN_PROPPAGEIDS(CAppsCtrl, 2)
    PROPPAGEID(CAppsPropPage::guid)
    PROPPAGEID(CLSID_CFontPropPage)
END_PROPPAGEIDS(CAppsCtrl)


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CAppsCtrl, "CNFGPRTS.AppsCtrl.1",
    0xba63460b, 0xb771, 0x11d0, 0x92, 0x96, 0, 0xc0, 0x4f, 0xb6, 0x67, 0x8b)


/////////////////////////////////////////////////////////////////////////////
// Type library ID and version

IMPLEMENT_OLETYPELIB(CAppsCtrl, _tlid, _wVerMajor, _wVerMinor)


/////////////////////////////////////////////////////////////////////////////
// Interface IDs

const IID BASED_CODE IID_DApps =
        { 0xba634609, 0xb771, 0x11d0, { 0x92, 0x96, 0, 0xc0, 0x4f, 0xb6, 0x67, 0x8b } };
const IID BASED_CODE IID_DAppsEvents =
        { 0xba63460a, 0xb771, 0x11d0, { 0x92, 0x96, 0, 0xc0, 0x4f, 0xb6, 0x67, 0x8b } };


/////////////////////////////////////////////////////////////////////////////
// Control type information

static const DWORD BASED_CODE _dwAppsOleMisc =
    OLEMISC_ACTIVATEWHENVISIBLE |
    OLEMISC_SETCLIENTSITEFIRST |
    OLEMISC_INSIDEOUT |
    OLEMISC_CANTLINKINSIDE |
    OLEMISC_ACTSLIKEBUTTON |
    OLEMISC_RECOMPOSEONRESIZE;

IMPLEMENT_OLECTLTYPE(CAppsCtrl, IDS_APPS, _dwAppsOleMisc)


/////////////////////////////////////////////////////////////////////////////
// CAppsCtrl::CAppsCtrlFactory::UpdateRegistry -
// Adds or removes system registry entries for CAppsCtrl

BOOL CAppsCtrl::CAppsCtrlFactory::UpdateRegistry(BOOL bRegister)
    {
    // TODO: Verify that your control follows apartment-model threading rules.
    // Refer to MFC TechNote 64 for more information.
    // If your control does not conform to the apartment-model rules, then
    // you must modify the code below, changing the 6th parameter from
    // afxRegApartmentThreading to 0.

    if (bRegister)
        return AfxOleRegisterControlClass(
            AfxGetInstanceHandle(),
            m_clsid,
            m_lpszProgID,
            IDS_APPS,
            IDB_APPS,
            afxRegApartmentThreading,
            _dwAppsOleMisc,
            _tlid,
            _wVerMajor,
            _wVerMinor);
    else
        return AfxOleUnregisterClass(m_clsid, m_lpszProgID);
    }


/////////////////////////////////////////////////////////////////////////////
// CAppsCtrl::CAppsCtrl - Constructor

CAppsCtrl::CAppsCtrl():
    m_fUpdateFont( FALSE ),
    m_fLocalMachine( FALSE ),
    m_fShowProcOptions( FALSE ),
    m_hAccel( NULL ),
    m_cAccel( 0 )
    {
    InitializeIIDs(&IID_DApps, &IID_DAppsEvents);
    }


/////////////////////////////////////////////////////////////////////////////
// CAppsCtrl::~CAppsCtrl - Destructor

CAppsCtrl::~CAppsCtrl()
    {
    if ( m_hAccel )
        DestroyAcceleratorTable( m_hAccel );
    m_hAccel = NULL;
    }


/////////////////////////////////////////////////////////////////////////////
// CAppsCtrl::OnDraw - Drawing function

void CAppsCtrl::OnDraw(
            CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid)
    {
    DoSuperclassPaint(pdc, rcBounds);
    }


/////////////////////////////////////////////////////////////////////////////
// CAppsCtrl::DoPropExchange - Persistence support

void CAppsCtrl::DoPropExchange(CPropExchange* pPX)
    {
    ExchangeVersion(pPX, MAKELONG(_wVerMinor, _wVerMajor));
    COleControl::DoPropExchange(pPX);
    }


/////////////////////////////////////////////////////////////////////////////
// CAppsCtrl::OnResetState - Reset control to default state

void CAppsCtrl::OnResetState()
    {
    COleControl::OnResetState();  // Resets defaults found in DoPropExchange
    }


/////////////////////////////////////////////////////////////////////////////
// CAppsCtrl::PreCreateWindow - Modify parameters for CreateWindowEx

BOOL CAppsCtrl::PreCreateWindow(CREATESTRUCT& cs)
    {
    if ( cs.style & WS_CLIPSIBLINGS )
        cs.style ^= WS_CLIPSIBLINGS;
    cs.lpszClass = _T("BUTTON");
    return COleControl::PreCreateWindow(cs);
    }


/////////////////////////////////////////////////////////////////////////////
// CAppsCtrl::IsSubclassedControl - This is a subclassed control

BOOL CAppsCtrl::IsSubclassedControl()
    {
    return TRUE;
    }


/////////////////////////////////////////////////////////////////////////////
// CAppsCtrl::OnOcmCommand - Handle command messages

LRESULT CAppsCtrl::OnOcmCommand(WPARAM wParam, LPARAM lParam)
    {
#ifdef _WIN32
    WORD wNotifyCode = HIWORD(wParam);
#else
    WORD wNotifyCode = HIWORD(lParam);
#endif

    return 0;
    }


/////////////////////////////////////////////////////////////////////////////
// CAppsCtrl message handlers

//---------------------------------------------------------------------------
void CAppsCtrl::OnClick(USHORT iButton)
    {
    CWaitCursor wait;

    // in case there are any errors, prepare the error string
    CString sz;
    // set the name of the application correctly
    sz.LoadString( IDS_APP_ERR_TITLE );
    // free the existing name, and copy in the new one
    free((void*)AfxGetApp()->m_pszAppName);
    AfxGetApp()->m_pszAppName = _tcsdup(sz);
        
    // initialize the metabase wrappings - pass in the name of the target machine
    // if one has been specified
    IMSAdminBase* pMB = FInitMetabaseWrapper( (LPTSTR)(LPCTSTR)m_szMachine );
    if ( !pMB )
        {
        MessageBeep(0);
        return;
        }

    // if there is no set metabase path - give it a test path
    if ( m_szMetaObject.IsEmpty() )
        m_szMetaObject = _T("/lm/w3svc/1/Root/iisadmin");

    // pointers to the pages
    CAppMapPage             pageMap;
    CRecycleOptPage         pageRecycle;
    CAppAspMainPage         pageASPMain;
    CAppAspDebugPage        pageASPDebug;
    CAppProcPage            pageProc;

    // declare the property sheet
    CPropertySheet  propsheet( IDS_APP_SHEETTITLE );


    // set up the metabase com pointer
    pageMap.m_pMB = pMB;
    pageASPMain.m_pMB = pMB;
    pageASPDebug.m_pMB = pMB;
    pageProc.m_pMB = pMB;

    // prepare the pages
    pageMap.m_szMeta = m_szMetaObject;
    pageASPMain.m_szMeta = m_szMetaObject;
    pageASPDebug.m_szMeta = m_szMetaObject;
    pageProc.m_szMeta = m_szMetaObject;

    // prepare the server name
    pageMap.m_szServer = m_szMachine;
    pageASPMain.m_szServer = m_szMachine;
    pageASPDebug.m_szServer = m_szMachine;
    pageProc.m_szServer = m_szMachine;

    // set the local machine for the script mappings
    pageMap.m_fLocalMachine = m_fLocalMachine;

    // add the pages to the sheet
    propsheet.AddPage( &pageMap );
    propsheet.AddPage( &pageRecycle );
    propsheet.AddPage( &pageASPMain );

    // only show the proc page if it is appropriate
    if ( m_fShowProcOptions )
        propsheet.AddPage( &pageProc );

    // finish added the pages to the sheet
    propsheet.AddPage( &pageASPDebug );

    // turn on help
    propsheet.m_psh.dwFlags |= PSH_HASHELP;
    pageMap.m_psp.dwFlags |= PSP_HASHELP;
    pageASPMain.m_psp.dwFlags |= PSP_HASHELP;
    pageASPDebug.m_psp.dwFlags |= PSP_HASHELP;
    pageProc.m_psp.dwFlags |= PSP_HASHELP;

    // Things could (potentially maybe) throw here, so better protect it.
    try
        {
        // run the propdsheet dialog
        // let the host container know that we are putting up a modal dialog
        PreModalDialog();
        // run the dialog
        propsheet.DoModal();
        // let the host container know we are done with the modality
        PostModalDialog();
        }
    catch ( CException e )
        {
        }

    // close the metabase wrappings
    FCloseMetabaseWrapper(pMB);

    // don't fire anything off
    COleControl::OnClick(iButton);
    }

//---------------------------------------------------------------------------
void CAppsCtrl::OnFontChanged()
    {
    m_fUpdateFont = TRUE;
    COleControl::OnFontChanged();
    }

//---------------------------------------------------------------------------
// The thing about applications is that if one gets stopped, we should blow away
// all of that applications parameters
void CAppsCtrl::DeleteParameters()
    {
    CWaitCursor wait;

    // initialize the metabase wrappings - pass in the name of the target machine
    // if one has been specified
    IMSAdminBase* pMB = FInitMetabaseWrapper( (LPTSTR)(LPCTSTR)m_szMachine );
    if ( !pMB )
        {
        MessageBeep(0);
        return;
        }

    // pointers to the pages (construction may throw, so we need to be careful)
    CAppMapPage             pageMap;
    CAppAspMainPage         pageASPMain;
    CAppAspDebugPage        pageASPDebug;
    CAppProcPage            pageProc;

    // set up the metabase com pointer
    pageMap.m_pMB = pMB;
    pageASPMain.m_pMB = pMB;
    pageASPDebug.m_pMB = pMB;
    pageProc.m_pMB = pMB;

    // prepare the pages
    pageMap.m_szMeta = m_szMetaObject;
    pageASPMain.m_szMeta = m_szMetaObject;
    pageASPDebug.m_szMeta = m_szMetaObject;
    pageProc.m_szMeta = m_szMetaObject;

    // tell each page to blow away its parameters
    pageMap.BlowAwayParameters();
    pageASPMain.BlowAwayParameters();
    pageASPDebug.BlowAwayParameters();
    pageProc.BlowAwayParameters();

    // close the metabase wrappings
    FCloseMetabaseWrapper(pMB);
    }

//---------------------------------------------------------------------------
void CAppsCtrl::SetAdminTarget(LPCTSTR szMachineName, LPCTSTR szMetaTarget, BOOL fLocalMachine)
    {
    m_szMachine = szMachineName;
    m_szMetaObject = szMetaTarget;
    m_fLocalMachine = fLocalMachine;
    }

//---------------------------------------------------------------------------
void CAppsCtrl::SetShowProcOptions(BOOL fShowProcOptions)
    {
    m_fShowProcOptions = fShowProcOptions;
    }

//---------------------------------------------------------------------------
// delete just the process level parameters in the metabase. This is used when
// the use has done editing as if it is an out-of-proc application, then changed
// their mind and made it in proc. If this wasn't called then there would be extra
// things in the metabase messing up inheritance, yet they would not be reflected
// anywhere in the UI. This should never be called on the master properites.
void CAppsCtrl::DeleteProcParameters()
    {
    CWaitCursor wait;
        
    // initialize the metabase wrappings - pass in the name of the target machine
    // if one has been specified
    IMSAdminBase* pMB = FInitMetabaseWrapper( (LPTSTR)(LPCTSTR)m_szMachine );
    if ( !pMB )
        {
        MessageBeep(0);
        return;
        }

    // pointers to the pages (construction may throw, so we need to be careful)
    CAppProcPage            pageProc;

    // set up the metabase com pointer
    pageProc.m_pMB = pMB;

    // prepare the pages
    pageProc.m_szMeta = m_szMetaObject;

    // tell each page to blow away its parameters
    pageProc.BlowAwayParameters();

    // close the metabase wrappings
    FCloseMetabaseWrapper(pMB);
    }

//---------------------------------------------------------------------------
void CAppsCtrl::OnAmbientPropertyChange(DISPID dispid)
    {
    BOOL    flag;
    UINT    style;

    // do the right thing depending on the dispid
    switch ( dispid )
        {
        case DISPID_AMBIENT_DISPLAYASDEFAULT:
            if ( GetAmbientProperty( DISPID_AMBIENT_DISPLAYASDEFAULT, VT_BOOL, &flag ) )
                {
                style = GetWindowLong(
                        GetSafeHwnd(), // handle of window
                        GWL_STYLE  // offset of value to retrieve
                        );
                if ( flag )
                    style |= BS_DEFPUSHBUTTON;
                else
                    style ^= BS_DEFPUSHBUTTON;
                SetWindowLong(
                        GetSafeHwnd(), // handle of window
                        GWL_STYLE,  // offset of value to retrieve
                        style
                        );
                Invalidate(TRUE);
                }
            break;
        };

    COleControl::OnAmbientPropertyChange(dispid);
    }

//---------------------------------------------------------------------------
// an important method where we tell the container how to deal with us.
// pControlInfo is passed in by the container, although we are responsible
// for maintining the hAccel structure
void CAppsCtrl::OnGetControlInfo(LPCONTROLINFO pControlInfo)
    {
    // do a rudimentary check to see if we understand pControlInfo
    if ( !pControlInfo || pControlInfo->cb < sizeof(CONTROLINFO) )
        return;

    // set the accelerator handle into place
    pControlInfo->hAccel = m_hAccel;
    pControlInfo->cAccel = m_cAccel;

    // when we have focus, we do want the enter key
    pControlInfo->dwFlags = CTRLINFO_EATS_RETURN;
    }

//---------------------------------------------------------------------------
// the ole control container object specifically filters out the space
// key so we do not get it as a OnMnemonic call. Thus we need to look
// for it ourselves
void CAppsCtrl::OnKeyUpEvent(USHORT nChar, USHORT nShiftState)
    {
    if ( nChar == _T(' ') )
        {
        OnClick((USHORT)GetDlgCtrlID());
        }
    COleControl::OnKeyUpEvent(nChar, nShiftState);
    }

//---------------------------------------------------------------------------
void CAppsCtrl::OnMnemonic(LPMSG pMsg)
    {
    OnClick((USHORT)GetDlgCtrlID());
    COleControl::OnMnemonic(pMsg);
    }

//---------------------------------------------------------------------------
void CAppsCtrl::OnTextChanged()
    {
    ACCEL   accel;
    int     iAccel;

    // get the new text
    CString sz = InternalGetText();
    sz.MakeLower();

    // if the handle has already been allocated, free it
    if ( m_hAccel )
        {
        DestroyAcceleratorTable( m_hAccel );
        m_hAccel = NULL;
        m_cAccel = 0;
        }

    // if there is a & character, then declare the accelerator
    iAccel = sz.Find(_T('&'));
    if ( iAccel >= 0 )
        {
        // fill in the accererator record
        accel.fVirt = FALT;
        accel.key = sz.GetAt(iAccel + 1);
        accel.cmd = (USHORT)GetDlgCtrlID();

        m_hAccel = CreateAcceleratorTable( &accel, 1 );
        if ( m_hAccel )
            m_cAccel = 1;

        // make sure the new accelerator table gets loaded
        ControlInfoChanged();
        }

    // finish with the default handling.
    COleControl::OnTextChanged();
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\cnfgprts\appsctl.h ===
// AppsCtl.h : Declaration of the CAppsCtrl OLE control class.

/////////////////////////////////////////////////////////////////////////////
// CAppsCtrl : See AppsCtl.cpp for implementation.

class CAppsCtrl : public COleControl
{
	DECLARE_DYNCREATE(CAppsCtrl)

// Constructor
public:
	CAppsCtrl();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAppsCtrl)
	public:
	virtual void OnDraw(CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid);
	virtual void DoPropExchange(CPropExchange* pPX);
	virtual void OnResetState();
	virtual void OnClick(USHORT iButton);
	virtual void OnFontChanged();
	virtual void OnAmbientPropertyChange(DISPID dispid);
	virtual void OnGetControlInfo(LPCONTROLINFO pControlInfo);
	virtual void OnKeyUpEvent(USHORT nChar, USHORT nShiftState);
	virtual void OnMnemonic(LPMSG pMsg);
	virtual void OnTextChanged();
	protected:
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
protected:
	~CAppsCtrl();

	DECLARE_OLECREATE_EX(CAppsCtrl)    // Class factory and guid
	DECLARE_OLETYPELIB(CAppsCtrl)      // GetTypeInfo
	DECLARE_PROPPAGEIDS(CAppsCtrl)     // Property page IDs
	DECLARE_OLECTLTYPE(CAppsCtrl)		// Type name and misc status

	// Subclassed control support
	BOOL IsSubclassedControl();
	LRESULT OnOcmCommand(WPARAM wParam, LPARAM lParam);

// Message maps
	//{{AFX_MSG(CAppsCtrl)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

// Dispatch maps
	//{{AFX_DISPATCH(CAppsCtrl)
	afx_msg void DeleteParameters();
	afx_msg void SetAdminTarget(LPCTSTR szMachineName, LPCTSTR szMetaTarget, BOOL fLocalMachine);
	afx_msg void SetShowProcOptions(BOOL fShowProcOptions);
	afx_msg void DeleteProcParameters();
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()

// Event maps
	//{{AFX_EVENT(CAppsCtrl)
	//}}AFX_EVENT
	DECLARE_EVENT_MAP()

// Dispatch and event IDs
public:
	enum {
	//{{AFX_DISP_ID(CAppsCtrl)
	dispidDeleteParameters = 1L,
	dispidSetAdminTarget = 2L,
	dispidSetShowProcOptions = 3L,
	dispidDeleteProcParameters = 4L,
	//}}AFX_DISP_ID
	};
protected:
    BOOL 	m_fUpdateFont;
    CString m_szMachine;
    CString m_szMetaObject;
    BOOL    m_fLocalMachine;
    BOOL    m_fShowProcOptions;

    // the accelerator table
    HACCEL  m_hAccel;
    WORD    m_cAccel;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\cnfgprts\cnfgprts.cpp ===
// cnfgprts.cpp : Implementation of CCnfgprtsApp and DLL registration.

#include "stdafx.h"
#include "cnfgprts.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CCnfgprtsApp NEAR theApp;

const GUID CDECL BASED_CODE _tlid =
		{ 0xba634600, 0xb771, 0x11d0, { 0x92, 0x96, 0, 0xc0, 0x4f, 0xb6, 0x67, 0x8b } };
const WORD _wVerMajor = 1;
const WORD _wVerMinor = 0;


////////////////////////////////////////////////////////////////////////////
// CCnfgprtsApp::InitInstance - DLL initialization

BOOL CCnfgprtsApp::InitInstance()
{
	BOOL bInit = COleControlModule::InitInstance();
    AfxEnableControlContainer( );

	if (bInit)
	    {
        // finally, we need to redirect the winhelp file location to something more desirable
        CString sz;
        CString szHelpLocation;
        sz.LoadString( IDS_HELPLOC_HELP );

        // expand the path
        ExpandEnvironmentStrings(
            sz,	                                        // pointer to string with environment variables 
            szHelpLocation.GetBuffer(MAX_PATH + 1),   // pointer to string with expanded environment variables  
            MAX_PATH                                    // maximum characters in expanded string 
           );
        szHelpLocation.ReleaseBuffer();

        // free the existing path, and copy in the new one
        if ( m_pszHelpFilePath )
            free((void*)m_pszHelpFilePath);
        m_pszHelpFilePath = _tcsdup(szHelpLocation);
	    }

	return bInit;
}


////////////////////////////////////////////////////////////////////////////
// CCnfgprtsApp::ExitInstance - DLL termination

int CCnfgprtsApp::ExitInstance()
{
	return COleControlModule::ExitInstance();
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (!AfxOleRegisterTypeLib(AfxGetInstanceHandle(), _tlid))
		return ResultFromScode(SELFREG_E_TYPELIB);

	if (!COleObjectFactoryEx::UpdateRegistryAll(TRUE))
		return ResultFromScode(SELFREG_E_CLASS);

	return NOERROR;
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (!AfxOleUnregisterTypeLib(_tlid, _wVerMajor, _wVerMinor))
		return ResultFromScode(SELFREG_E_TYPELIB);

	if (!COleObjectFactoryEx::UpdateRegistryAll(FALSE))
		return ResultFromScode(SELFREG_E_CLASS);

	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\cnfgprts\aspdbgpg.cpp ===
// AspDbgPg.cpp : implementation file
//

#include "stdafx.h"
#include <iadmw.h>
#include "cnfgprts.h"
#include "AspDbgPg.h"

#include "wrapmb.h"
#include "metatool.h"
#include <iiscnfg.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CAppAspDebugPage property page

IMPLEMENT_DYNCREATE(CAppAspDebugPage, CPropertyPage)

//---------------------------------------------------------------------------
CAppAspDebugPage::CAppAspDebugPage() : CPropertyPage(CAppAspDebugPage::IDD),
    m_fInitialized( FALSE )
    {
    //{{AFX_DATA_INIT(CAppAspDebugPage)
	m_sz_error = _T("");
	m_bool_client_debug = FALSE;
	m_bool_server_debug = FALSE;
	m_int_SendError = -1;
	//}}AFX_DATA_INIT
    }

//---------------------------------------------------------------------------
CAppAspDebugPage::~CAppAspDebugPage()
    {
    }

//---------------------------------------------------------------------------
void CAppAspDebugPage::DoDataExchange(CDataExchange* pDX)
    {
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAppAspDebugPage)
	DDX_Control(pDX, IDC_DEFAULT_ERROR, m_cedit_error);
	DDX_Text(pDX, IDC_DEFAULT_ERROR, m_sz_error);
	DDX_Check(pDX, IDC_CHK_CLIENT_DEBUG, m_bool_client_debug);
	DDX_Check(pDX, IDC_CHK_SERVER_DEBUG, m_bool_server_debug);
	DDX_Radio(pDX, IDC_RDO_SEND_DETAILED_ERROR, m_int_SendError);
	//}}AFX_DATA_MAP
    }

//---------------------------------------------------------------------------
BEGIN_MESSAGE_MAP(CAppAspDebugPage, CPropertyPage)
    //{{AFX_MSG_MAP(CAppAspDebugPage)
	ON_BN_CLICKED(IDC_RDO_SEND_DEF_ERROR, OnRdoSendDefError)
	ON_BN_CLICKED(IDC_RDO_SEND_DETAILED_ERROR, OnRdoSendDetailedError)
	ON_EN_CHANGE(IDC_DEFAULT_ERROR, OnChangeDefaultError)
	ON_BN_CLICKED(IDC_CHK_CLIENT_DEBUG, OnChkClientDebug)
	ON_BN_CLICKED(IDC_CHK_SERVER_DEBUG, OnChkServerDebug)
	//}}AFX_MSG_MAP
    ON_COMMAND(ID_HELP_FINDER,  DoHelp)
    ON_COMMAND(ID_HELP,         DoHelp)
    ON_COMMAND(ID_CONTEXT_HELP, DoHelp)
    ON_COMMAND(ID_DEFAULT_HELP, DoHelp)
END_MESSAGE_MAP()

//---------------------------------------------------------------------------
void CAppAspDebugPage::DoHelp()
    {
    WinHelp( HIDD_APPMAPS_ASP_DEBUG );
    }

//---------------------------------------------------------------------------
void CAppAspDebugPage::Init() 
    {
    UpdateData( TRUE );
    DWORD   dw;
    WCHAR*  pstr;

    // we will just be pulling stuff out of the metabase here
    // prepare the metabase wrapper
    CWrapMetaBase   mbWrap;
    if ( !mbWrap.FInit(m_pMB) ) return;

    // open the target
    if ( mbWrap.Open( m_szMeta, METADATA_PERMISSION_READ ) )
        {
        // first the server debug
        if ( mbWrap.GetDword( _T(""), MD_ASP_ENABLESERVERDEBUG, ASP_MD_UT_APP, &dw, METADATA_INHERIT ) )
            {
            m_bool_server_debug = dw;
            }
        else
            m_bool_server_debug = 0;

        // then the client debug
        if ( mbWrap.GetDword( _T(""), MD_ASP_ENABLECLIENTDEBUG, ASP_MD_UT_APP, &dw, METADATA_INHERIT ) )
            {
            m_bool_client_debug = dw;
            }
        else
            m_bool_client_debug = 0;

        // now the truncate size
        m_int_SendError = 1;
        if ( mbWrap.GetDword( _T(""), MD_ASP_SCRIPTERRORSSENTTOBROWSER, ASP_MD_UT_APP, &dw, METADATA_INHERIT ) )
            {
            if ( dw == 1 )
            m_int_SendError = 0;
            }

        // default error string
        pstr = (WCHAR*)mbWrap.GetData( _T(""), MD_ASP_SCRIPTERRORMESSAGE, ASP_MD_UT_APP, STRING_METADATA, &dw, METADATA_INHERIT );
        if ( pstr )
            {
            m_sz_error = pstr;
            // free it
            mbWrap.FreeWrapData( (PVOID)pstr );
            }
        else
            {
            // load a default string
            m_sz_error.LoadString( IDS_APP_DEFAULT_ERROR );
            }

        // close the metabase
        mbWrap.Close();
        }

    // set the data into place
    UpdateData( FALSE );

    // enable the approprieate items
    EnableItems();
    }

//---------------------------------------------------------------------------
void CAppAspDebugPage::EnableItems()
    {
    UpdateData( TRUE );
    if ( m_int_SendError == 1 )
        {
        m_cedit_error.EnableWindow( TRUE );
        }
    else
        {
        m_cedit_error.EnableWindow( FALSE );
        }
    }

//----------------------------------------------------------------
// blow away the parameters
void CAppAspDebugPage::BlowAwayParameters()
    {
     // prepare the metabase wrapper
    CWrapMetaBase   mbWrap;
    if ( !mbWrap.FInit(m_pMB) ) return;
    // open the target
    if ( mbWrap.Open( m_szMeta, METADATA_PERMISSION_WRITE ) )
        {
        mbWrap.DeleteData( _T(""), MD_ASP_ENABLESERVERDEBUG, DWORD_METADATA );
        mbWrap.DeleteData( _T(""), MD_ASP_ENABLECLIENTDEBUG, DWORD_METADATA );
        mbWrap.DeleteData( _T(""), MD_ASP_SCRIPTERRORSSENTTOBROWSER, DWORD_METADATA );
        mbWrap.DeleteData( _T(""), MD_ASP_SCRIPTERRORMESSAGE, STRING_METADATA );
//        mbWrap.DeleteData( _T(""), MD_ASP_ENABLESERVERDEBUG, ASP_MD_UT_APP, DWORD_METADATA );
//        mbWrap.DeleteData( _T(""), MD_ASP_ENABLECLIENTDEBUG, ASP_MD_UT_APP, DWORD_METADATA );
//        mbWrap.DeleteData( _T(""), MD_ASP_SCRIPTERRORSSENTTOBROWSER, ASP_MD_UT_APP, DWORD_METADATA );
//        mbWrap.DeleteData( _T(""), MD_ASP_SCRIPTERRORMESSAGE, ASP_MD_UT_APP, STRING_METADATA );
        // close the metabase
        mbWrap.Close();
        }
    }

/////////////////////////////////////////////////////////////////////////////
// CAppAspDebugPage message handlers

//---------------------------------------------------------------------------
BOOL CAppAspDebugPage::OnApply() 
    {
    // build the save flags first
    BOOL    f;

    UpdateData( TRUE );

    // prepare the metabase wrapper
    CWrapMetaBase   mbWrap;
    if ( !mbWrap.FInit(m_pMB) ) return FALSE;

    // server side debug 
    f = SetMetaDword( m_pMB, m_szServer, m_szMeta, _T(""), MD_ASP_ENABLESERVERDEBUG,
                    ASP_MD_UT_APP, m_bool_server_debug, TRUE );
    // client side debug 
    f = SetMetaDword( m_pMB, m_szServer, m_szMeta, _T(""), MD_ASP_ENABLECLIENTDEBUG,
                    ASP_MD_UT_APP, m_bool_client_debug, TRUE );
    // errors sent to browser
    if ( m_int_SendError )
        f = SetMetaDword( m_pMB, m_szServer, m_szMeta, _T(""), MD_ASP_SCRIPTERRORSSENTTOBROWSER,
                        ASP_MD_UT_APP, 0, TRUE );
    else
        f = SetMetaDword( m_pMB, m_szServer, m_szMeta, _T(""), MD_ASP_SCRIPTERRORSSENTTOBROWSER,
                        ASP_MD_UT_APP, 1, TRUE );

    // error message string to browser
    f = SetMetaString( m_pMB, m_szServer, m_szMeta, _T(""), MD_ASP_SCRIPTERRORMESSAGE,
                    ASP_MD_UT_APP, m_sz_error, TRUE);

    return CPropertyPage::OnApply();
    }

//---------------------------------------------------------------------------
BOOL CAppAspDebugPage::OnSetActive() 
    {
    // if this is the first time, init the parameters
    if ( !m_fInitialized )
        {
        Init();
        m_fInitialized = TRUE;
        }
    return CPropertyPage::OnSetActive();
    }

//---------------------------------------------------------------------------
void CAppAspDebugPage::OnRdoSendDefError() 
    {
    EnableItems();
    SetModified();
    }

//---------------------------------------------------------------------------
void CAppAspDebugPage::OnRdoSendDetailedError() 
    {
    EnableItems();
    SetModified();
    }

//---------------------------------------------------------------------------
void CAppAspDebugPage::OnChangeDefaultError() 
    {
    SetModified();
    }

//---------------------------------------------------------------------------
void CAppAspDebugPage::OnChkClientDebug() 
    {
    SetModified();
    }

//---------------------------------------------------------------------------
void CAppAspDebugPage::OnChkServerDebug() 
    {
    SetModified();
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\cnfgprts\cnfgprts.h ===
// cnfgprts.h : main header file for CNFGPRTS.DLL

#if !defined( __AFXCTL_H__ )
	#error include 'afxctl.h' before including this file
#endif

#include "resource.h"       // main symbols
#include "helpmap.h"       // main symbols

#define REGKEY_STP          _T("SOFTWARE\\Microsoft\\INetStp")
#define REGKEY_INSTALLKEY   _T("InstallPath")

/////////////////////////////////////////////////////////////////////////////
// CCnfgprtsApp : See cnfgprts.cpp for implementation.

class CCnfgprtsApp : public COleControlModule
{
public:
	BOOL InitInstance();
	int ExitInstance();
};

extern const GUID CDECL _tlid;
extern const WORD _wVerMajor;
extern const WORD _wVerMinor;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\cnfgprts\appsppg.h ===
// AppsPpg.h : Declaration of the CAppsPropPage property page class.

////////////////////////////////////////////////////////////////////////////
// CAppsPropPage : See AppsPpg.cpp.cpp for implementation.

class CAppsPropPage : public COlePropertyPage
{
	DECLARE_DYNCREATE(CAppsPropPage)
	DECLARE_OLECREATE_EX(CAppsPropPage)

// Constructor
public:
	CAppsPropPage();

// Dialog Data
	//{{AFX_DATA(CAppsPropPage)
	enum { IDD = IDD_PROPPAGE_APPS };
	CString	m_sz_caption;
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Message maps
protected:
	//{{AFX_MSG(CAppsPropPage)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\cnfgprts\aspdbgpg.h ===
// AspDbgPg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CAppAspDebugPage dialog

class CAppAspDebugPage : public CPropertyPage
{
	DECLARE_DYNCREATE(CAppAspDebugPage)

// Construction
public:
	CAppAspDebugPage();
	~CAppAspDebugPage();

    // the target metabase path
    CString     m_szMeta;
    CString     m_szServer;
    IMSAdminBase* m_pMB;

    // blow away the parameters
    void BlowAwayParameters();

// Dialog Data
	//{{AFX_DATA(CAppAspDebugPage)
	enum { IDD = IDD_APP_ASPDEBUG };
	CEdit	m_cedit_error;
	CString	m_sz_error;
	BOOL	m_bool_client_debug;
	BOOL	m_bool_server_debug;
	int		m_int_SendError;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CAppAspDebugPage)
	public:
	virtual BOOL OnApply();
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CAppAspDebugPage)
	afx_msg void OnRdoSendDefError();
	afx_msg void OnRdoSendDetailedError();
	afx_msg void OnChangeDefaultError();
	afx_msg void OnChkClientDebug();
	afx_msg void OnChkServerDebug();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

    void DoHelp();

    // utilities
    void Init();
    void EnableItems();

    BOOL    m_fInitialized;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\cnfgprts\appsppg.cpp ===
// AppsPpg.cpp : Implementation of the CAppsPropPage property page class.

#include "stdafx.h"
#include "cnfgprts.h"
#include "AppsPpg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CAppsPropPage, COlePropertyPage)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CAppsPropPage, COlePropertyPage)
	//{{AFX_MSG_MAP(CAppsPropPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CAppsPropPage, "CNFGPRTS.AppsPropPage.1",
	0xba63460c, 0xb771, 0x11d0, 0x92, 0x96, 0, 0xc0, 0x4f, 0xb6, 0x67, 0x8b)


/////////////////////////////////////////////////////////////////////////////
// CAppsPropPage::CAppsPropPageFactory::UpdateRegistry -
// Adds or removes system registry entries for CAppsPropPage

BOOL CAppsPropPage::CAppsPropPageFactory::UpdateRegistry(BOOL bRegister)
{
	if (bRegister)
		return AfxOleRegisterPropertyPageClass(AfxGetInstanceHandle(),
			m_clsid, IDS_APPS_PPG);
	else
		return AfxOleUnregisterClass(m_clsid, NULL);
}


/////////////////////////////////////////////////////////////////////////////
// CAppsPropPage::CAppsPropPage - Constructor

CAppsPropPage::CAppsPropPage() :
	COlePropertyPage(IDD, IDS_APPS_PPG_CAPTION)
{
	//{{AFX_DATA_INIT(CAppsPropPage)
	m_sz_caption = _T("");
	//}}AFX_DATA_INIT
}


/////////////////////////////////////////////////////////////////////////////
// CAppsPropPage::DoDataExchange - Moves data between page and properties

void CAppsPropPage::DoDataExchange(CDataExchange* pDX)
{
	//{{AFX_DATA_MAP(CAppsPropPage)
	DDP_Text(pDX, IDC_CAPTIONEDIT, m_sz_caption, _T("Caption") );
	DDX_Text(pDX, IDC_CAPTIONEDIT, m_sz_caption);
	//}}AFX_DATA_MAP
	DDP_PostProcessing(pDX);
}


/////////////////////////////////////////////////////////////////////////////
// CAppsPropPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\cnfgprts\font.cpp ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "stdafx.h"
#include "font.h"


/////////////////////////////////////////////////////////////////////////////
// COleFont properties

CString COleFont::GetName()
{
	CString result;
	GetProperty(0x0, VT_BSTR, (void*)&result);
	return result;
}

void COleFont::SetName(LPCTSTR propVal)
{
	SetProperty(0x0, VT_BSTR, propVal);
}

CY COleFont::GetSize()
{
	CY result;
	GetProperty(0x2, VT_CY, (void*)&result);
	return result;
}

void COleFont::SetSize(const CY& propVal)
{
	SetProperty(0x2, VT_CY, &propVal);
}

BOOL COleFont::GetBold()
{
	BOOL result;
	GetProperty(0x3, VT_BOOL, (void*)&result);
	return result;
}

void COleFont::SetBold(BOOL propVal)
{
	SetProperty(0x3, VT_BOOL, propVal);
}

BOOL COleFont::GetItalic()
{
	BOOL result;
	GetProperty(0x4, VT_BOOL, (void*)&result);
	return result;
}

void COleFont::SetItalic(BOOL propVal)
{
	SetProperty(0x4, VT_BOOL, propVal);
}

BOOL COleFont::GetUnderline()
{
	BOOL result;
	GetProperty(0x5, VT_BOOL, (void*)&result);
	return result;
}

void COleFont::SetUnderline(BOOL propVal)
{
	SetProperty(0x5, VT_BOOL, propVal);
}

BOOL COleFont::GetStrikethrough()
{
	BOOL result;
	GetProperty(0x6, VT_BOOL, (void*)&result);
	return result;
}

void COleFont::SetStrikethrough(BOOL propVal)
{
	SetProperty(0x6, VT_BOOL, propVal);
}

short COleFont::GetWeight()
{
	short result;
	GetProperty(0x7, VT_I2, (void*)&result);
	return result;
}

void COleFont::SetWeight(short propVal)
{
	SetProperty(0x7, VT_I2, propVal);
}

short COleFont::GetCharset()
{
	short result;
	GetProperty(0x8, VT_I2, (void*)&result);
	return result;
}

void COleFont::SetCharset(short propVal)
{
	SetProperty(0x8, VT_I2, propVal);
}

/////////////////////////////////////////////////////////////////////////////
// COleFont operations
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\cnfgprts\font.h ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.

/////////////////////////////////////////////////////////////////////////////
// COleFont wrapper class

class COleFont : public COleDispatchDriver
{
public:
	COleFont() {}		// Calls COleDispatchDriver default constructor
	COleFont(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
	COleFont(const COleFont& dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

// Attributes
public:
	CString GetName();
	void SetName(LPCTSTR);
	CY GetSize();
	void SetSize(const CY&);
	BOOL GetBold();
	void SetBold(BOOL);
	BOOL GetItalic();
	void SetItalic(BOOL);
	BOOL GetUnderline();
	void SetUnderline(BOOL);
	BOOL GetStrikethrough();
	void SetStrikethrough(BOOL);
	short GetWeight();
	void SetWeight(short);
	short GetCharset();
	void SetCharset(short);

// Operations
public:
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\cnfgprts\guid.cpp ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

        guid.cpp

   Abstract:

        Initialization as required by initguid

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include <stdafx.h>

#include <objbase.h>
#include <initguid.h>
#include <iadmw.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\cnfgprts\loguictl.h ===
// LogUICtl.h : Declaration of the CLogUICtrl OLE control class.

/////////////////////////////////////////////////////////////////////////////
// CLogUICtrl : See LogUICtl.cpp for implementation.

class CLogUICtrl : public COleControl
{
	DECLARE_DYNCREATE(CLogUICtrl)

// Constructor
public:
	CLogUICtrl();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CLogUICtrl)
	public:
	virtual void OnDraw(CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid);
	virtual void DoPropExchange(CPropExchange* pPX);
	virtual void OnResetState();
	virtual void OnClick(USHORT iButton);
	virtual void OnFontChanged();
	virtual void OnAmbientPropertyChange(DISPID dispid);
	virtual void OnGetControlInfo(LPCONTROLINFO pControlInfo);
	virtual void OnKeyUpEvent(USHORT nChar, USHORT nShiftState);
	virtual void OnMnemonic(LPMSG pMsg);
	virtual void OnTextChanged();
	//}}AFX_VIRTUAL

// Implementation
protected:
	~CLogUICtrl();

	DECLARE_OLECREATE_EX(CLogUICtrl)    // Class factory and guid
	DECLARE_OLETYPELIB(CLogUICtrl)      // GetTypeInfo
	DECLARE_PROPPAGEIDS(CLogUICtrl)     // Property page IDs
	DECLARE_OLECTLTYPE(CLogUICtrl)		// Type name and misc status

	// Subclassed control support
	BOOL PreCreateWindow(CREATESTRUCT& cs);
	BOOL IsSubclassedControl();
	LRESULT OnOcmCommand(WPARAM wParam, LPARAM lParam);

// Message maps
	//{{AFX_MSG(CLogUICtrl)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

// Dispatch maps
	//{{AFX_DISPATCH(CLogUICtrl)
	afx_msg void SetAdminTarget(LPCTSTR szMachineName, LPCTSTR szMetaTarget);
	afx_msg void ApplyLogSelection();
	afx_msg void SetComboBox(HWND hComboBox);
	afx_msg void Terminate();
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()

// Event maps
	//{{AFX_EVENT(CLogUICtrl)
	//}}AFX_EVENT
	DECLARE_EVENT_MAP()

// Dispatch and event IDs
public:
	enum {
	//{{AFX_DISP_ID(CLogUICtrl)
	dispidSetAdminTarget = 1L,
	dispidApplyLogSelection = 2L,
	dispidSetComboBox = 3L,
	dispidTerminate = 4L,
	//}}AFX_DISP_ID
	};

protected:
    void ActivateLogProperties( OLECHAR* pocMachineName, REFIID clsidUI );

    BOOL GetSelectedStringIID( CString &szIID );

    BOOL GetServerDirectory( CString &sz );
//    BOOL RegisterMSLogUI();

    BOOL SetAccelTable( LPCTSTR pszCaption );

    BOOL 	m_fUpdateFont;
    CString m_szMachine;
    CString m_szMetaObject;

    BOOL        m_fComboInit;
    CComboBox   m_comboBox;

    
    // the accelerator table
    HACCEL  m_hAccel;
    WORD    m_cAccel;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\cnfgprts\loguippg.h ===
// LogUIPpg.h : Declaration of the CLogUIPropPage property page class.

////////////////////////////////////////////////////////////////////////////
// CLogUIPropPage : See LogUIPpg.cpp.cpp for implementation.

class CLogUIPropPage : public COlePropertyPage
{
	DECLARE_DYNCREATE(CLogUIPropPage)
	DECLARE_OLECREATE_EX(CLogUIPropPage)

// Constructor
public:
	CLogUIPropPage();

// Dialog Data
	//{{AFX_DATA(CLogUIPropPage)
	enum { IDD = IDD_PROPPAGE_LOGUI };
	CString	m_sz_caption;
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Message maps
protected:
	//{{AFX_MSG(CLogUIPropPage)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\cnfgprts\aspmnpg.cpp ===
// AspMnPg.cpp : implementation file
//

#include "stdafx.h"
#include <iadmw.h>
#include "cnfgprts.h"

#include "wrapmb.h"
#include "metatool.h"
#include <iiscnfg.h>

#include "AspMnPg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define     SIZE_MBYTE          1048576


/////////////////////////////////////////////////////////////////////////////
// CAppAspMainPage property page

IMPLEMENT_DYNCREATE(CAppAspMainPage, CPropertyPage)

//---------------------------------------------------------------------------
CAppAspMainPage::CAppAspMainPage() : CPropertyPage(CAppAspMainPage::IDD),
    m_fInitialized( FALSE )
    {
    //{{AFX_DATA_INIT(CAppAspMainPage)
	m_dw_session_timeout = 0;
	m_bool_enable_session = FALSE;
	m_bool_enable_parents = FALSE;
	m_bool_enable_buffering = FALSE;
	m_sz_default_language = _T("");
	m_dw_script_timeout = 1;
	//}}AFX_DATA_INIT
    }

//---------------------------------------------------------------------------
CAppAspMainPage::~CAppAspMainPage()
    {
    }

//---------------------------------------------------------------------------
void CAppAspMainPage::DoDataExchange(CDataExchange* pDX)
    {
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAppAspMainPage)
	DDX_Control(pDX, IDC_LANG_TITLE, m_cstatic_lang_title);
	DDX_Control(pDX, IDC_SESSION_UNITS, m_cstatic_session_units);
	DDX_Control(pDX, IDC_SESSION_TITLE, m_cstatic_session_title);
	DDX_Control(pDX, IDC_EDT_SESSION_TIMEOUT, m_cedit_session_timeout);
	DDX_Text(pDX, IDC_EDT_SESSION_TIMEOUT, m_dw_session_timeout);
	DDX_Text(pDX, IDC_EDT_SCRIPT_TIMEOUT, m_dw_script_timeout);
	DDV_MinMaxDWord(pDX, m_dw_script_timeout, 1, 2147483647);
	DDX_Check(pDX, IDC_CHK_ENABLE_BUFFERING, m_bool_enable_buffering);
	DDX_Check(pDX, IDC_CHK_ENABLE_SESSION, m_bool_enable_session);
	DDX_Check(pDX, IDC_CHK_ENABLE_PARENTS, m_bool_enable_parents);
	DDX_Text(pDX, IDC_EDT_LANGUAGES, m_sz_default_language);
	//}}AFX_DATA_MAP
    }

//---------------------------------------------------------------------------
BEGIN_MESSAGE_MAP(CAppAspMainPage, CPropertyPage)
    //{{AFX_MSG_MAP(CAppAspMainPage)
	ON_EN_CHANGE(IDC_EDT_SESSION_TIMEOUT, OnChangeEdtSessionTimeout)
	ON_BN_CLICKED(IDC_CHK_ENABLE_SESSION, OnChkEnableSession)
	ON_BN_CLICKED(IDC_CHK_ENABLE_PARENTS, OnChkEnableParents)
	ON_BN_CLICKED(IDC_CHK_POOL_ODBC, OnChkPoolOdbc)
	ON_BN_CLICKED(IDC_CHK_ENABLE_BUFFERING, OnChkEnableBuffering)
	ON_CBN_SELCHANGE(IDC_CMBO_LANGUAGES, OnSelchangeCmboLanguages)
	ON_EN_CHANGE(IDC_EDT_LANGUAGES, OnChangeEdtLanguages)
	ON_EN_CHANGE(IDC_EDT_SCRIPT_TIMEOUT, OnChangeEdtScriptTimeout)
	//}}AFX_MSG_MAP
    ON_COMMAND(ID_HELP_FINDER,  DoHelp)
    ON_COMMAND(ID_HELP,         DoHelp)
    ON_COMMAND(ID_CONTEXT_HELP, DoHelp)
    ON_COMMAND(ID_DEFAULT_HELP, DoHelp)
END_MESSAGE_MAP()

//---------------------------------------------------------------------------
void CAppAspMainPage::DoHelp()
    {
    WinHelp( HIDD_APPMAPS_ASP_MAIN );
    }

//---------------------------------------------------------------------------
void CAppAspMainPage::EnableItems()
    {
    UpdateData( TRUE );
    if ( m_bool_enable_session )
        {
        m_cstatic_session_units.EnableWindow( TRUE );
        m_cstatic_session_title.EnableWindow( TRUE );
        m_cedit_session_timeout.EnableWindow( TRUE );
        }
    else
        {
        m_cstatic_session_units.EnableWindow( FALSE );
        m_cstatic_session_title.EnableWindow( FALSE );
        m_cedit_session_timeout.EnableWindow( FALSE );
        }
    }

//---------------------------------------------------------------------------
void CAppAspMainPage::Init() 
    {
    UpdateData( TRUE );
    DWORD   dw;

    // we will just be pulling stuff out of the metabase here
    // prepare the metabase wrapper
    CWrapMetaBase   mbWrap;
    if ( !mbWrap.FInit(m_pMB) ) return;

    // open the target
    if ( mbWrap.Open( m_szMeta, METADATA_PERMISSION_READ ) )
        {
        // read the enable buffering flag
        if ( mbWrap.GetDword( _T(""), MD_ASP_BUFFERINGON, ASP_MD_UT_APP, &dw, METADATA_INHERIT ) )
            m_bool_enable_buffering = dw;
        else
            m_bool_enable_buffering = FALSE;   // default

        // read the session state information
        if ( mbWrap.GetDword( _T(""), MD_ASP_ALLOWSESSIONSTATE, ASP_MD_UT_APP, &dw, METADATA_INHERIT ) )
            m_bool_enable_session = dw;
        else
            m_bool_enable_session = TRUE;   // default

        // read the script timeout
        if ( mbWrap.GetDword( _T(""), MD_ASP_SCRIPTTIMEOUT, ASP_MD_UT_APP, &dw, METADATA_INHERIT ) )
            m_dw_script_timeout = dw;
        else
            m_dw_script_timeout = 90;   // default

        // read the session timeout information
        if ( mbWrap.GetDword( _T(""), MD_ASP_SESSIONTIMEOUT, ASP_MD_UT_APP, &dw, METADATA_INHERIT ) )
            m_dw_session_timeout = dw;
        else
            m_dw_session_timeout = 20;   // default

        // read the enable parent paths flag
        if ( mbWrap.GetDword( _T(""), MD_ASP_ENABLEPARENTPATHS, ASP_MD_UT_APP, &dw, METADATA_INHERIT ) )
            m_bool_enable_parents = dw;
        else
            m_bool_enable_parents = TRUE;   // default

        // now get the currently selected language and choose it in the combo box
        WCHAR* pstr = (WCHAR*)mbWrap.GetData( _T(""), MD_ASP_SCRIPTLANGUAGE, ASP_MD_UT_APP, STRING_METADATA, &dw, METADATA_INHERIT );
        if ( pstr )
            {
            m_sz_default_language = pstr;
            mbWrap.FreeWrapData( (PVOID)pstr );
            }

        // close the metabase
        mbWrap.Close();
        }

    // set the data into place
    UpdateData( FALSE );

    // enable the approprieate items
    EnableItems();
    }

//----------------------------------------------------------------
// blow away the parameters
void CAppAspMainPage::BlowAwayParameters()
    {
     // prepare the metabase wrapper
    CWrapMetaBase   mbWrap;
    if ( !mbWrap.FInit(m_pMB) ) return;
   // open the target
    if ( mbWrap.Open( m_szMeta, METADATA_PERMISSION_WRITE ) )
        {
        mbWrap.DeleteData( _T(""), MD_ASP_BUFFERINGON, DWORD_METADATA );
        mbWrap.DeleteData( _T(""), MD_ASP_ALLOWSESSIONSTATE, DWORD_METADATA );
        mbWrap.DeleteData( _T(""), MD_ASP_SESSIONTIMEOUT, DWORD_METADATA );
        mbWrap.DeleteData( _T(""), MD_ASP_ENABLEPARENTPATHS, DWORD_METADATA );
        mbWrap.DeleteData( _T(""), MD_ASP_SCRIPTLANGUAGE, STRING_METADATA );
        mbWrap.DeleteData( _T(""), MD_ASP_SCRIPTTIMEOUT, DWORD_METADATA );
/*
        mbWrap.DeleteData( _T(""), MD_ASP_BUFFERINGON, ASP_MD_UT_APP, DWORD_METADATA );
        mbWrap.DeleteData( _T(""), MD_ASP_ALLOWSESSIONSTATE, ASP_MD_UT_APP, DWORD_METADATA );
        mbWrap.DeleteData( _T(""), MD_ASP_SESSIONTIMEOUT, ASP_MD_UT_APP, DWORD_METADATA );
        mbWrap.DeleteData( _T(""), MD_ASP_ENABLEPARENTPATHS, ASP_MD_UT_APP, DWORD_METADATA );
        mbWrap.DeleteData( _T(""), MD_ASP_SCRIPTLANGUAGE, ASP_MD_UT_APP, STRING_METADATA );
        mbWrap.DeleteData( _T(""), MD_ASP_SCRIPTTIMEOUT, ASP_MD_UT_APP, DWORD_METADATA );
*/
        // close the metabase
        mbWrap.Close();
        }
    }

/////////////////////////////////////////////////////////////////////////////
// CAppAspMainPage message handlers

//----------------------------------------------------------------
BOOL CAppAspMainPage::OnSetActive() 
    {
    // if this is the first time, init the parameters
    if ( !m_fInitialized )
        {
        Init();
        m_fInitialized = TRUE;
        }
    return CPropertyPage::OnSetActive();
    }

//----------------------------------------------------------------
BOOL CAppAspMainPage::OnApply() 
    {
    DWORD   dwCache = 0;        // local cache reference
    BOOL    f;

    UpdateData( TRUE );

    // clean up the script string
    m_sz_default_language.TrimLeft();
    m_sz_default_language.TrimRight();

    // prepare the metabase wrapper
    CWrapMetaBase   mbWrap;
    if ( !mbWrap.FInit(m_pMB) ) return FALSE;

    // session state
    f = SetMetaDword( m_pMB, m_szServer, m_szMeta, _T(""), MD_ASP_ALLOWSESSIONSTATE,
                    ASP_MD_UT_APP, m_bool_enable_session, TRUE );
    // session timeout
    f = SetMetaDword( m_pMB, m_szServer, m_szMeta, _T(""), MD_ASP_SESSIONTIMEOUT,
                    ASP_MD_UT_APP, m_dw_session_timeout, TRUE );
    // enable parent paths
    f = SetMetaDword( m_pMB, m_szServer, m_szMeta, _T(""), MD_ASP_ENABLEPARENTPATHS,
                    ASP_MD_UT_APP, m_bool_enable_parents, TRUE );
    // enable buffering
    f = SetMetaDword( m_pMB, m_szServer, m_szMeta, _T(""), MD_ASP_BUFFERINGON,
                    ASP_MD_UT_APP, m_bool_enable_buffering, TRUE );
    // script timeout
    f = SetMetaDword( m_pMB, m_szServer, m_szMeta, _T(""), MD_ASP_SCRIPTTIMEOUT,
                    ASP_MD_UT_APP, m_dw_script_timeout, TRUE );

    // script language
    f = SetMetaString( m_pMB, m_szServer, m_szMeta, _T(""), MD_ASP_SCRIPTLANGUAGE,
                    ASP_MD_UT_APP, m_sz_default_language, TRUE );

    SetModified( FALSE );
    return CPropertyPage::OnApply();
    }

//----------------------------------------------------------------
void CAppAspMainPage::OnChangeEdtSessionTimeout() 
    {
    SetModified();
    }


//----------------------------------------------------------------
void CAppAspMainPage::OnChkEnableSession() 
    {
    EnableItems();
    SetModified();
    }

//----------------------------------------------------------------
void CAppAspMainPage::OnChkEnableParents() 
    {
    SetModified();
    }

//----------------------------------------------------------------
void CAppAspMainPage::OnChkPoolOdbc() 
    {
    SetModified();
    }

//----------------------------------------------------------------
void CAppAspMainPage::OnChkEnableBuffering() 
    {
    SetModified();
    }

//----------------------------------------------------------------
void CAppAspMainPage::OnSelchangeCmboLanguages() 
    {
    SetModified();
    }

//----------------------------------------------------------------
void CAppAspMainPage::OnChangeEdtLanguages() 
    {
    SetModified();
    }

//----------------------------------------------------------------
void CAppAspMainPage::OnChangeEdtScriptTimeout() 
    {
    SetModified();
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\cnfgprts\mdobjs.h ===
#define SZ_W3_ROOT     _T("/lm/w3svc")
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\cnfgprts\helpmap.h ===
// helpmaps for the logui project - handmade

#define HIDD_RATINGS_SERVICE                    0x50300
#define HIDD_RATINGS_RATING                     0x50301

#define HIDD_APPMAPS_MAPS                       0x50310
#define HIDD_APPMAPS_ASP_MAIN                   0x50311
#define HIDD_APPMAPS_ASP_DEBUG                  0x50312
#define HIDD_APPMAPS_OTHER                      0x50313
#define HIDD_APPMAPS_OUT_OF_PROC				0x50314
#define HIDD_APPMAPS_IN_PROC_GLOBAL				0x50315
#define HIDD_APPMAPS_EDIT_MAP                   0x50318
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\cnfgprts\metatool.h ===
BOOL SetMetaDword(IMSAdminBase* pMB, LPCTSTR pszServer, LPCTSTR pszMetaRoot, LPCTSTR pszSub, DWORD idData, DWORD iType, DWORD dwValue, BOOL fCheckInheritence);
BOOL SetMetaString(IMSAdminBase* pMB, LPCTSTR pszServer, LPCTSTR pszMetaRoot, LPCTSTR pszSub, DWORD idData, DWORD iType, CString sz, BOOL fCheckInheritence);
BOOL SetMetaData(IMSAdminBase* pMB, LPCTSTR pszServer, LPCTSTR pszMetaRoot, LPCTSTR pszSub, DWORD idData, DWORD iType, DWORD iDataType, PVOID pData, DWORD cbData, BOOL fCheckInheritence );
BOOL SetMetaMultiSz(IMSAdminBase* pMB, LPCTSTR pszServer, LPCTSTR pszMetaRoot, LPCTSTR pszSub, DWORD idData, DWORD iType, PVOID pData, DWORD cchmsz, BOOL fCheckInheritence );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\cnfgprts\aspmnpg.h ===
// AspMnPg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CAppAspMainPage dialog

class CAppAspMainPage : public CPropertyPage
{
	DECLARE_DYNCREATE(CAppAspMainPage)

// Construction
public:
	CAppAspMainPage();
	~CAppAspMainPage();

    // the target metabase path
    CString     m_szMeta;
    CString     m_szServer;
    IMSAdminBase* m_pMB;

    // blow away the parameters
    void BlowAwayParameters();

// Dialog Data
	//{{AFX_DATA(CAppAspMainPage)
	enum { IDD = IDD_APP_ASPMAIN };
	CStatic	m_cstatic_lang_title;
	CStatic	m_cstatic_session_units;
	CStatic	m_cstatic_session_title;
	CEdit	m_cedit_session_timeout;
	DWORD	m_dw_session_timeout;
	DWORD	m_dw_script_timeout;
	BOOL	m_bool_enable_buffering;
	BOOL	m_bool_enable_session;
	BOOL	m_bool_enable_parents;
	CString	m_sz_default_language;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CAppAspMainPage)
	public:
	virtual BOOL OnSetActive();
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CAppAspMainPage)
	afx_msg void OnChkEnableBuffering();
	afx_msg void OnChangeEdtSessionTimeout();
	afx_msg void OnChkEnableSession();
	afx_msg void OnChkEnableParents();
	afx_msg void OnChkPoolOdbc();
	afx_msg void OnSelchangeCmboLanguages();
	afx_msg void OnChangeEdtLanguages();
	afx_msg void OnChangeEdtScriptTimeout();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

    void DoHelp();

    // utilities
    void Init();
    void EnableItems();

    BOOL    m_fInitialized;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\cnfgprts\listrow.h ===
// ListRow.h : header file
//


#ifndef _LISTROW_
#define _LISTROW_

/////////////////////////////////////////////////////////////////////////////
// CListSelRowCtrl window

class CListSelRowCtrl : public CListCtrl
{
// Construction
public:
	CListSelRowCtrl();

	virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CListSelRowCtrl)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CListSelRowCtrl();

	// Generated message map functions
protected:
	//{{AFX_MSG(CListSelRowCtrl)
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	void GetHiliteColors();

	void HiliteSelectedCells();
	void HiliteSelectedCell( int iCell, BOOL fHilite = TRUE );
	BOOL FGetCellRect( LONG iRow, LONG iCol, CRect *pcrect );

	void FitString( CString &sz, int cpWidth, CDC* pcdc );

	CBitmap		m_bitmapCheck;
	COLORREF	m_colorHiliteText;
	COLORREF	m_colorHilite;

	DWORD		m_StartDrawingCol;

};

/////////////////////////////////////////////////////////////////////////////
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\cnfgprts\loguictl.cpp ===
// LogUICtl.cpp : Implementation of the CLogUICtrl OLE control class.

#include "stdafx.h"
#include <iadmw.h>
#include "cnfgprts.h"
#include "LogUICtl.h"
#include "LogUIPpg.h"

#include "wrapmb.h"
#include "metatool.h"
#include <iiscnfg.h>

#include "initguid.h"
#include <inetcom.h>
#include <logtype.h>
#include <ilogobj.hxx>


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CLogUICtrl, COleControl)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CLogUICtrl, COleControl)
    //{{AFX_MSG_MAP(CLogUICtrl)
    //}}AFX_MSG_MAP
    ON_MESSAGE(OCM_COMMAND, OnOcmCommand)
    ON_OLEVERB(AFX_IDS_VERB_PROPERTIES, OnProperties)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Dispatch map

BEGIN_DISPATCH_MAP(CLogUICtrl, COleControl)
    //{{AFX_DISPATCH_MAP(CLogUICtrl)
    DISP_FUNCTION(CLogUICtrl, "SetAdminTarget", SetAdminTarget, VT_EMPTY, VTS_BSTR VTS_BSTR)
    DISP_FUNCTION(CLogUICtrl, "ApplyLogSelection", ApplyLogSelection, VT_EMPTY, VTS_NONE)
    DISP_FUNCTION(CLogUICtrl, "SetComboBox", SetComboBox, VT_EMPTY, VTS_HANDLE)
    DISP_FUNCTION(CLogUICtrl, "Terminate", Terminate, VT_EMPTY, VTS_NONE)
    DISP_STOCKFUNC_DOCLICK()
    DISP_STOCKPROP_CAPTION()
    DISP_STOCKPROP_FONT()
    DISP_STOCKPROP_ENABLED()
    DISP_STOCKPROP_BORDERSTYLE()
    //}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()


/////////////////////////////////////////////////////////////////////////////
// Event map

BEGIN_EVENT_MAP(CLogUICtrl, COleControl)
    //{{AFX_EVENT_MAP(CLogUICtrl)
    EVENT_STOCK_CLICK()
    EVENT_STOCK_KEYUP()
    EVENT_STOCK_KEYDOWN()
    EVENT_STOCK_KEYPRESS()
    //}}AFX_EVENT_MAP
END_EVENT_MAP()


/////////////////////////////////////////////////////////////////////////////
// Property pages

BEGIN_PROPPAGEIDS(CLogUICtrl, 2)
    PROPPAGEID(CLogUIPropPage::guid)
    PROPPAGEID(CLSID_CFontPropPage)
END_PROPPAGEIDS(CLogUICtrl)


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CLogUICtrl, "CNFGPRTS.LogUICtrl.1",
    0xba634603, 0xb771, 0x11d0, 0x92, 0x96, 0, 0xc0, 0x4f, 0xb6, 0x67, 0x8b)


/////////////////////////////////////////////////////////////////////////////
// Type library ID and version

IMPLEMENT_OLETYPELIB(CLogUICtrl, _tlid, _wVerMajor, _wVerMinor)


/////////////////////////////////////////////////////////////////////////////
// Interface IDs

const IID BASED_CODE IID_DLogUI =
        { 0xba634601, 0xb771, 0x11d0, { 0x92, 0x96, 0, 0xc0, 0x4f, 0xb6, 0x67, 0x8b } };
const IID BASED_CODE IID_DLogUIEvents =
        { 0xba634602, 0xb771, 0x11d0, { 0x92, 0x96, 0, 0xc0, 0x4f, 0xb6, 0x67, 0x8b } };


/////////////////////////////////////////////////////////////////////////////
// Control type information

static const DWORD BASED_CODE _dwLogUIOleMisc =
    OLEMISC_ACTIVATEWHENVISIBLE |
    OLEMISC_SETCLIENTSITEFIRST |
    OLEMISC_INSIDEOUT |
    OLEMISC_CANTLINKINSIDE |
    OLEMISC_ACTSLIKEBUTTON |
    OLEMISC_RECOMPOSEONRESIZE;

IMPLEMENT_OLECTLTYPE(CLogUICtrl, IDS_LOGUI, _dwLogUIOleMisc)


/////////////////////////////////////////////////////////////////////////////
// CLogUICtrl::CLogUICtrlFactory::UpdateRegistry -
// Adds or removes system registry entries for CLogUICtrl

BOOL CLogUICtrl::CLogUICtrlFactory::UpdateRegistry(BOOL bRegister)
    {
    // TODO: Verify that your control follows apartment-model threading rules.
    // Refer to MFC TechNote 64 for more information.
    // If your control does not conform to the apartment-model rules, then
    // you must modify the code below, changing the 6th parameter from
    // afxRegApartmentThreading to 0.

    if (bRegister)
        return AfxOleRegisterControlClass(
            AfxGetInstanceHandle(),
            m_clsid,
            m_lpszProgID,
            IDS_LOGUI,
            IDB_LOGUI,
            afxRegApartmentThreading,
            _dwLogUIOleMisc,
            _tlid,
            _wVerMajor,
            _wVerMinor);
    else
        return AfxOleUnregisterClass(m_clsid, m_lpszProgID);
    }


/////////////////////////////////////////////////////////////////////////////
// CLogUICtrl::CLogUICtrl - Constructor

CLogUICtrl::CLogUICtrl():
        m_fUpdateFont( FALSE ),
        m_fComboInit( FALSE ),
        m_hAccel( NULL ),
        m_cAccel( 0 )
    {
    InitializeIIDs(&IID_DLogUI, &IID_DLogUIEvents);
    }


/////////////////////////////////////////////////////////////////////////////
// CLogUICtrl::~CLogUICtrl - Destructor

CLogUICtrl::~CLogUICtrl()
    {
    if ( m_hAccel )
        DestroyAcceleratorTable( m_hAccel );
    m_hAccel = NULL;
    }


/////////////////////////////////////////////////////////////////////////////
// CLogUICtrl::OnDraw - Drawing function

void CLogUICtrl::OnDraw(
            CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid)
    {
    DoSuperclassPaint(pdc, rcBounds);
    }


/////////////////////////////////////////////////////////////////////////////
// CLogUICtrl::DoPropExchange - Persistence support

void CLogUICtrl::DoPropExchange(CPropExchange* pPX)
    {
    ExchangeVersion(pPX, MAKELONG(_wVerMinor, _wVerMajor));
    COleControl::DoPropExchange(pPX);

    }


/////////////////////////////////////////////////////////////////////////////
// CLogUICtrl::OnResetState - Reset control to default state

void CLogUICtrl::OnResetState()
    {
    COleControl::OnResetState();  // Resets defaults found in DoPropExchange
    }


/////////////////////////////////////////////////////////////////////////////
// CLogUICtrl::PreCreateWindow - Modify parameters for CreateWindowEx

BOOL CLogUICtrl::PreCreateWindow(CREATESTRUCT& cs)
    {
    if ( cs.style & WS_CLIPSIBLINGS )
        cs.style ^= WS_CLIPSIBLINGS;
    cs.lpszClass = _T("BUTTON");
    return COleControl::PreCreateWindow(cs);
    }


/////////////////////////////////////////////////////////////////////////////
// CLogUICtrl::IsSubclassedControl - This is a subclassed control

BOOL CLogUICtrl::IsSubclassedControl()
    {
    return TRUE;
    }


/////////////////////////////////////////////////////////////////////////////
// CLogUICtrl::OnOcmCommand - Handle command messages

LRESULT CLogUICtrl::OnOcmCommand(WPARAM wParam, LPARAM lParam)
{
#ifdef _WIN32
    WORD wNotifyCode = HIWORD(wParam);
#else
    WORD wNotifyCode = HIWORD(lParam);
#endif

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
// CLogUICtrl message handlers

//---------------------------------------------------------------------------
// OLE Interfaced Routine
void CLogUICtrl::OnClick(USHORT iButton)
    {
    CWaitCursor wait;
    IID     iid;
    HRESULT h;
    OLECHAR* poch = NULL;

    // in case there are any errors, prepare the error string
    CString sz;
    // set the name of the application correctly
    sz.LoadString( IDS_LOG_ERR_TITLE );
    // free the existing name, and copy in the new one
    free((void*)AfxGetApp()->m_pszAppName);
    AfxGetApp()->m_pszAppName = _tcsdup(sz);

     // get the string IID of the current item in the combo box
    CString szIID;
    if ( GetSelectedStringIID( szIID ) )
        {
        // convert the string to an IID that we can use
        h = CLSIDFromString( (LPTSTR)(LPCTSTR)szIID, &iid );

        // do it to it
        ActivateLogProperties( (LPTSTR)(LPCTSTR)m_szMachine, iid );
        }

    // don't fire anything off
    COleControl::OnClick(iButton);
    }

//---------------------------------------------------------------------------
void CLogUICtrl::OnFontChanged()
    {
    m_fUpdateFont = TRUE;
    COleControl::OnFontChanged();
    }

//---------------------------------------------------------------------------
void CLogUICtrl::SetAdminTarget(LPCTSTR szMachineName, LPCTSTR szMetaTarget)
    {
    m_szMachine = szMachineName;
    m_szMetaObject = szMetaTarget;
    }

//---------------------------------------------------------------------------
void CLogUICtrl::ActivateLogProperties( OLECHAR* pocMachineName, REFIID clsidUI )
    {
    IClassFactory*      pcsfFactory = NULL;
    HRESULT             hresError;

    ILogUIPlugin*        pUI;

    hresError = CoGetClassObject( clsidUI, CLSCTX_INPROC, NULL,
                            IID_IClassFactory, (void**) &pcsfFactory);
    if (FAILED(hresError))
                return;

        // create the instance of the interface
        hresError = pcsfFactory->CreateInstance(NULL, IID_LOGGINGUI, (void **)&pUI);
        if (FAILED(hresError))
                {
                return;
                }

        // release the factory
        pcsfFactory->Release();

    // activate the logging ui
    hresError = pUI->OnProperties( (LPTSTR)(LPCTSTR)m_szMachine, (LPTSTR)(LPCTSTR)m_szMetaObject );

    // release the logging ui
    pUI->Release();
    }

//---------------------------------------------------------------------------
// OLE Interfaced Routine
// first we get the appropriate module IID string from the logging tree. Then
// we put it into place in the metabase target
void CLogUICtrl::ApplyLogSelection()
    {
    TCHAR   buff[MAX_PATH];
    DWORD   dw;
    BOOL    fGotIt;
    CString szGUID;

    // start with the current string in the combo box
    CString szName;
    m_comboBox.GetWindowText( szName );
    // if nothing is selected, fail
    if ( szName.IsEmpty() ) return;

    // prep the metabase
    IMSAdminBase* pMB = FInitMetabaseWrapper( (LPTSTR)(LPCTSTR)m_szMachine );
    if ( !pMB )
        return;
    CWrapMetaBase   mbWrap;
    if ( !mbWrap.FInit(pMB) ) return;

    // open the root logging node
    if ( mbWrap.Open( _T("/lm/logging"), METADATA_PERMISSION_READ ) )
        {
        // get the guid ui string
        dw = sizeof( buff );
        fGotIt = mbWrap.GetString( szName, MD_LOG_PLUGIN_MOD_ID, IIS_MD_UT_SERVER, buff, &dw);
        mbWrap.Close();
        if ( fGotIt )
            szGUID = buff;
        }

    // open the target metabase location for writing
    if ( fGotIt )
        {
        SetMetaString(pMB, m_szMachine, m_szMetaObject, _T(""), MD_LOG_PLUGIN_ORDER,
                    IIS_MD_UT_SERVER, szGUID, TRUE);
        }

    // clean up
    FCloseMetabaseWrapper(pMB);
    }

//---------------------------------------------------------------------------
BOOL CLogUICtrl::GetSelectedStringIID( CString &szIID )
    {
    if ( !m_fComboInit ) return FALSE;

    // start with the current string in the combo box
    CString szName;
    m_comboBox.GetWindowText( szName );
    // if nothing is selected, fail
    if ( szName.IsEmpty() ) return FALSE;

    // prep the metabase
    IMSAdminBase* pMB = FInitMetabaseWrapper( (LPTSTR)(LPCTSTR)m_szMachine );
    if ( !pMB )
        return FALSE;
    CWrapMetaBase   mbWrap;
    if ( !mbWrap.FInit(pMB) ) return FALSE;

    // open the root logging node
    if ( mbWrap.Open( _T("/lm/logging"), METADATA_PERMISSION_READ ) )
        {
        // get the guid ui string
        TCHAR   buff[MAX_PATH];
        DWORD   dw;
        dw = sizeof( buff );
        if ( mbWrap.GetString( szName, MD_LOG_PLUGIN_UI_ID, IIS_MD_UT_SERVER, buff, &dw) )
            szIID = buff;
        mbWrap.Close();
        }

    // clean up
    FCloseMetabaseWrapper(pMB);

    // return the answer
    return !szIID.IsEmpty();
    }

//---------------------------------------------------------------------------
// OLE Interfaced Routine
void CLogUICtrl::SetComboBox(HWND hComboBox)
    {
    TCHAR   buff[MAX_PATH];
    DWORD   dw;
    BOOL    f;

    CString szAvailableList;
    CString szCurrentModGuid;
    CString szCurrentModName;

    // in case there are any errors, prepare the error string
    // set the name of the application correctly
    szAvailableList.LoadString( IDS_LOG_ERR_TITLE );
    // free the existing name, and copy in the new one
    free((void*)AfxGetApp()->m_pszAppName);
    AfxGetApp()->m_pszAppName = _tcsdup(szAvailableList);
    szAvailableList.Empty();

    // attach the combo box
    m_comboBox.Attach(hComboBox);
    m_fComboInit = TRUE;

    // fill in the combo box
    // prepare the metabase wrapper
    IMSAdminBase* pMB = FInitMetabaseWrapper( (LPTSTR)(LPCTSTR)m_szMachine );
    if ( !pMB )
        return;
    CWrapMetaBase   mbWrap;
    if ( !mbWrap.FInit(pMB) ) return;

    // get the guid string of the currently selected logging module
    if ( mbWrap.Open( m_szMetaObject, METADATA_PERMISSION_READ ) )
        {
        dw = sizeof(buff);
        // start by getting the current module ID
        f = mbWrap.GetString( _T(""), MD_LOG_PLUGIN_ORDER, IIS_MD_UT_SERVER, buff, &dw);
        szCurrentModGuid = buff;

        // if we couldn't get the value, then there is a problem
        if ( !f )
            {
            DWORD   err;
            err = GetLastError();
            AfxMessageBox( IDS_ERR_LOG_PLUGIN );
            }
        mbWrap.Close();
        }

    // unfortunately, we need to chop off the end to get the plugins available location
    DWORD   chFirst = m_szMetaObject.Find(_T('/')) + 1;
    CString szService = m_szMetaObject.Right(m_szMetaObject.GetLength() - chFirst);
    // be careful of the master properties node
    INT iSlash = szService.Find(_T('/'));
    if ( iSlash < 0 )
        szService = m_szMetaObject;     // it is the root node already
    else
        szService = m_szMetaObject.Left( szService.Find(_T('/')) + chFirst );

    // get the list of available modues
    if ( mbWrap.Open( szService, METADATA_PERMISSION_READ ) )
        {
        // get thelist of available ui modules
        WCHAR* pstr = (WCHAR*)mbWrap.GetData( _T("/info"), MD_LOG_PLUGINS_AVAILABLE, IIS_MD_UT_SERVER, STRING_METADATA, &dw, METADATA_INHERIT );
        if ( pstr )
            {
            szAvailableList = pstr;
            mbWrap.FreeWrapData( (PVOID)pstr );
            }

        // close the metabase
        mbWrap.Close();
        };

    // open the root logging node
    if ( !mbWrap.Open( _T("/lm/logging"), METADATA_PERMISSION_READ ) )
        return;

    // enumerate the sub-items, adding each to the combo-box - if it is in the avail list
    // the reason we are checking against the logging module GUID is that is how we
    // can tell which is the currently selected item
    DWORD   index = 0;
    BOOL    fFoundCurrent = FALSE;
    while ( mbWrap.EnumObjects(_T(""), buff, index) )
        {
        CString szName = buff;

        // make sure it is in the list of available modules
        if ( szAvailableList.Find(szName) < 0 )
            {
            index++;
            continue;
            }

        // check against the current item's guid
        dw = sizeof(buff);
        f = mbWrap.GetString( szName, MD_LOG_PLUGIN_MOD_ID, IIS_MD_UT_SERVER, buff, &dw);
        if ( !fFoundCurrent && f )
            {
            if ( szCurrentModGuid == buff )
                {
                szCurrentModName = szName;
                fFoundCurrent = TRUE;
                }
            }

        // add the item to the combo box
        m_comboBox.AddString( szName );

        // increment the index
        index++;
        }

    // select the current item in the combo box
    m_comboBox.SelectString( -1, szCurrentModName );

    // close the metabase
    mbWrap.Close();

    // clean up
    FCloseMetabaseWrapper(pMB);
    }

//---------------------------------------------------------------------------
// OLE Interfaced Routine
void CLogUICtrl::Terminate()
    {
    if ( m_fComboInit )
        m_comboBox.Detach();
    m_fComboInit = FALSE;
    }

//------------------------------------------------------------------------
// get the inetinfo path
BOOL CLogUICtrl::GetServerDirectory( CString &sz )
    {
        HKEY        hKey;
        TCHAR       chBuff[MAX_PATH+1];
        DWORD       err, type;
        DWORD       cbBuff;

    // get the server install path from the registry
    // open the registry key, if it exists
    err = RegOpenKeyEx(
            HKEY_LOCAL_MACHINE, // handle of open key
            REGKEY_STP,         // address of name of subkey to open
            0,                  // reserved
            KEY_READ,           // security access mask
            &hKey               // address of handle of open key
           );

    // if we did not open the key for any reason (say... it doesn't exist)
    // then leave right away
    if ( err != ERROR_SUCCESS )
        return FALSE;

    cbBuff = sizeof(chBuff);
    type = REG_SZ;
    err = RegQueryValueEx(
            hKey,               // handle of key to query
            REGKEY_INSTALLKEY,  // address of name of value to query
            NULL,               // reserved
            &type,              // address of buffer for value type
            (PUCHAR)chBuff,     // address of data buffer
            &cbBuff             // address of data buffer size
           );

    // close the key
    RegCloseKey( hKey );

    // if we did get the key for any reason (say... it doesn't exist)
    // then leave right away
    if ( err != ERROR_SUCCESS )
        return FALSE;

    // set the string
    sz = chBuff;

    // success
    return TRUE;
    }

//------------------------------------------------------------------------
void CLogUICtrl::OnAmbientPropertyChange(DISPID dispid)
    {
    BOOL    flag;
    UINT    style;

    // do the right thing depending on the dispid
    switch ( dispid )
        {
        case DISPID_AMBIENT_DISPLAYASDEFAULT:
            if ( GetAmbientProperty( DISPID_AMBIENT_DISPLAYASDEFAULT, VT_BOOL, &flag ) )
                {
                style = GetWindowLong(
                        GetSafeHwnd(), // handle of window
                        GWL_STYLE  // offset of value to retrieve
                        );
                if ( flag )
                    style |= BS_DEFPUSHBUTTON;
                else
                    style ^= BS_DEFPUSHBUTTON;
                SetWindowLong(
                        GetSafeHwnd(), // handle of window
                        GWL_STYLE,  // offset of value to retrieve
                        style
                        );
                Invalidate(TRUE);
                }
            break;
        };

    COleControl::OnAmbientPropertyChange(dispid);
    }

//------------------------------------------------------------------------
// an important method where we tell the container how to deal with us.
// pControlInfo is passed in by the container, although we are responsible
// for maintining the hAccel structure
void CLogUICtrl::OnGetControlInfo(LPCONTROLINFO pControlInfo)
    {
    // do a rudimentary check to see if we understand pControlInfo
    if ( !pControlInfo || pControlInfo->cb < sizeof(CONTROLINFO) )
        return;

    // set the accelerator handle into place
    pControlInfo->hAccel = m_hAccel;
    pControlInfo->cAccel = m_cAccel;

    // when we have focus, we do want the enter key
    pControlInfo->dwFlags = CTRLINFO_EATS_RETURN;
    }

//------------------------------------------------------------------------
// the ole control container object specifically filters out the space
// key so we do not get it as a OnMnemonic call. Thus we need to look
// for it ourselves
void CLogUICtrl::OnKeyUpEvent(USHORT nChar, USHORT nShiftState)
    {
    if ( nChar == _T(' ') )
        {
        OnClick((USHORT)GetDlgCtrlID());
        }
    COleControl::OnKeyUpEvent(nChar, nShiftState);
    }

//------------------------------------------------------------------------
void CLogUICtrl::OnMnemonic(LPMSG pMsg)
    {
    OnClick((USHORT)GetDlgCtrlID());
    COleControl::OnMnemonic(pMsg);
    }

//------------------------------------------------------------------------
void CLogUICtrl::OnTextChanged()
    {
    // get the new text
    CString sz = InternalGetText();

    // set the accelerator table
    SetAccelTable((LPCTSTR)sz);
    if ( SetAccelTable((LPCTSTR)sz) )
        // make sure the new accelerator table gets loaded
        ControlInfoChanged();

    // finish with the default handling.
    COleControl::OnTextChanged();
    }

//------------------------------------------------------------------------
BOOL CLogUICtrl::SetAccelTable( LPCTSTR pszCaption )
    {
    BOOL    fAnswer = FALSE;
    ACCEL   accel;
    int     iAccel;

    // get the new text
    CString sz = pszCaption;
    sz.MakeLower();

    // if the handle has already been allocated, free it
    if ( m_hAccel )
        {
        DestroyAcceleratorTable( m_hAccel );
        m_hAccel = NULL;
        m_cAccel = 0;
        }

    // if there is a & character, then declare the accelerator
    iAccel = sz.Find(_T('&'));
    if ( iAccel >= 0 )
        {
        // fill in the accererator record
        accel.fVirt = FALT;
        accel.key = sz.GetAt(iAccel + 1);
        accel.cmd = (USHORT)GetDlgCtrlID();

        m_hAccel = CreateAcceleratorTable( &accel, 1 );
        if ( m_hAccel )
            m_cAccel = 1;

        fAnswer = TRUE;
        }

    // return the answer
    return fAnswer;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\cnfgprts\loguippg.cpp ===
// LogUIPpg.cpp : Implementation of the CLogUIPropPage property page class.

#include "stdafx.h"
#include "cnfgprts.h"
#include "LogUIPpg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CLogUIPropPage, COlePropertyPage)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CLogUIPropPage, COlePropertyPage)
	//{{AFX_MSG_MAP(CLogUIPropPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CLogUIPropPage, "CNFGPRTS.LogUIPropPage.1",
	0xba634604, 0xb771, 0x11d0, 0x92, 0x96, 0, 0xc0, 0x4f, 0xb6, 0x67, 0x8b)


/////////////////////////////////////////////////////////////////////////////
// CLogUIPropPage::CLogUIPropPageFactory::UpdateRegistry -
// Adds or removes system registry entries for CLogUIPropPage

BOOL CLogUIPropPage::CLogUIPropPageFactory::UpdateRegistry(BOOL bRegister)
{
	if (bRegister)
		return AfxOleRegisterPropertyPageClass(AfxGetInstanceHandle(),
			m_clsid, IDS_LOGUI_PPG);
	else
		return AfxOleUnregisterClass(m_clsid, NULL);
}


/////////////////////////////////////////////////////////////////////////////
// CLogUIPropPage::CLogUIPropPage - Constructor

CLogUIPropPage::CLogUIPropPage() :
	COlePropertyPage(IDD, IDS_LOGUI_PPG_CAPTION)
{
	//{{AFX_DATA_INIT(CLogUIPropPage)
	m_sz_caption = _T("");
	//}}AFX_DATA_INIT
}


/////////////////////////////////////////////////////////////////////////////
// CLogUIPropPage::DoDataExchange - Moves data between page and properties

void CLogUIPropPage::DoDataExchange(CDataExchange* pDX)
{
	//{{AFX_DATA_MAP(CLogUIPropPage)
	DDP_Text(pDX, IDC_CAPTIONEDIT, m_sz_caption, _T("Caption") );
	DDX_Text(pDX, IDC_CAPTIONEDIT, m_sz_caption);
	//}}AFX_DATA_MAP
	DDP_PostProcessing(pDX);
}


/////////////////////////////////////////////////////////////////////////////
// CLogUIPropPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\cnfgprts\ratadvpg.h ===
// RatAdvPg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CRatAdvancedPage dialog

class CRatAdvancedPage : public CPropertyPage
{
	DECLARE_DYNCREATE(CRatAdvancedPage)

// Construction
public:
	CRatAdvancedPage();
	~CRatAdvancedPage();

    // the data
    CRatingsData*   m_pRatData;

// Dialog Data
	//{{AFX_DATA(CRatAdvancedPage)
	enum { IDD = IDD_RAT_ADVANCED };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CRatAdvancedPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CRatAdvancedPage)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
    void DoHelp();
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\cnfgprts\ratadvpg.cpp ===
// RatAdvPg.cpp : implementation file
//

#include "stdafx.h"
#include <iadmw.h>
#include "cnfgprts.h"

#include "parserat.h"
#include "RatData.h"

#include "RatAdvPg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CRatAdvancedPage property page

IMPLEMENT_DYNCREATE(CRatAdvancedPage, CPropertyPage)

CRatAdvancedPage::CRatAdvancedPage() : CPropertyPage(CRatAdvancedPage::IDD)
{
	//{{AFX_DATA_INIT(CRatAdvancedPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CRatAdvancedPage::~CRatAdvancedPage()
{
}

void CRatAdvancedPage::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CRatAdvancedPage)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CRatAdvancedPage, CPropertyPage)
	//{{AFX_MSG_MAP(CRatAdvancedPage)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
    ON_COMMAND(ID_HELP_FINDER,  DoHelp)
    ON_COMMAND(ID_HELP,         DoHelp)
    ON_COMMAND(ID_CONTEXT_HELP, DoHelp)
    ON_COMMAND(ID_DEFAULT_HELP, DoHelp)
END_MESSAGE_MAP()

//---------------------------------------------------------------------------
void CRatAdvancedPage::DoHelp()
    {
    }

/////////////////////////////////////////////////////////////////////////////
// CRatAdvancedPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\cnfgprts\listrow.cpp ===
// ListRow.cpp : implementation file
//

#include "stdafx.h"
#include "cnfgprts.h"
#include "ListRow.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


#define	SZ_RES_COLOR_PREFS		_T("Control Panel\\Colors")
#define	SZ_RES_COLOR_HILITE		_T("Hilight")
#define	SZ_RES_COLOR_HILITETEXT	_T("HilightText")


/////////////////////////////////////////////////////////////////////////////
// CListSelRowCtrl
//-----------------------------------------------------------------------------------
CListSelRowCtrl::CListSelRowCtrl():
		m_StartDrawingCol( 0 )
	{
	}

//-----------------------------------------------------------------------------------
CListSelRowCtrl::~CListSelRowCtrl()
	{
	}


//-----------------------------------------------------------------------------------
BEGIN_MESSAGE_MAP(CListSelRowCtrl, CListCtrl)
	//{{AFX_MSG_MAP(CListSelRowCtrl)
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONDBLCLK()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

//-----------------------------------------------------------------------------------
void CListSelRowCtrl::GetHiliteColors()
	{
    // get the hilite color
    m_colorHilite = GetSysColor( COLOR_HIGHLIGHT );

    // get the hilited text color
    m_colorHiliteText = GetSysColor( COLOR_HIGHLIGHTTEXT );
	}



/////////////////////////////////////////////////////////////////////////////
// CListSelRowCtrl message handlers

//-----------------------------------------------------------------------------------
void CListSelRowCtrl::DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct)
	{
	CRect		rcItem = lpDrawItemStruct->rcItem;
	CRect		rcSection;
	UINT		itemID = lpDrawItemStruct->itemID;
	UINT		cpLeft = rcItem.left;
	CString		sz;
	LV_COLUMN	colData;
	COLORREF	colorTextOld;
	COLORREF	colorBackOld;

	// setup the CDC object
	CDC			cdc;
	cdc.Attach( lpDrawItemStruct->hDC );

#ifdef _DEBUG
	if ( m_StartDrawingCol == 0 )
		sz.Empty();
#endif

	// clear the columnd buffer
	ZeroMemory( &colData, sizeof(colData) );
	colData.mask = LVCF_WIDTH;

	// if this is the selected item, prepare the background and the text color
	BOOL fSelected = lpDrawItemStruct->itemState & ODS_SELECTED;
	if ( fSelected )
		{
		GetHiliteColors();
		colorTextOld = cdc.SetTextColor( m_colorHiliteText );
		colorBackOld = cdc.SetBkColor( m_colorHilite );
		}


	// starting with the m_StartDrawingCol column, draw the columns
	// do it in a loop, just skipping until we hit m_StartDrawingCol
	DWORD iCol = 0;
	while ( GetColumn(iCol, &colData) )
		{
		// see if we are ready yet
		if ( iCol < m_StartDrawingCol )
			{
			// set the new left.
			cpLeft += colData.cx;
			// increment the column counter
			iCol++;
			continue;
			}

		// prepare the background but once
		if ( iCol == m_StartDrawingCol )
			{
			// prepare the background
			rcSection = rcItem;
			rcSection.left = cpLeft;
			rcSection.right--;
			CBrush	brush;
			if ( lpDrawItemStruct->itemState & ODS_SELECTED )
				brush.CreateSolidBrush( m_colorHilite );
			else
				brush.CreateSolidBrush( GetSysColor( COLOR_WINDOW ) );
			cdc.FillRect( &rcSection, &brush );
			}


		// display the name
		sz = GetItemText( itemID, iCol );
		if ( !sz.IsEmpty() )
			{
			// figure out the sectional rect
			rcSection = rcItem;
			rcSection.left = cpLeft + 2;
			rcSection.right = cpLeft + colData.cx - 1;
			
			// fit the string into the required space
			FitString( sz, rcSection.right - rcSection.left, &cdc );

			//draw the string
			cdc.DrawText( sz, &rcSection, DT_SINGLELINE|DT_LEFT|DT_BOTTOM|DT_NOPREFIX );
			}

		// set the new left.
		cpLeft += colData.cx;
		// increment the column counter
		iCol++;
		}

	// if this is the selected item, restore the colors
	if ( fSelected )
		{
		cdc.SetTextColor( colorTextOld );
		cdc.SetBkColor( colorBackOld );
		}

	// cleanup the CDC object
	cdc.Detach();
	}


//------------------------------------------------------------------------
void CListSelRowCtrl::FitString( CString &sz, int cpWidth, CDC* pcdc )
	{
	CSize		size;
	UINT		cch;
	CString		szEllipsis;

	// start by testing the existing width
	size = pcdc->GetTextExtent( sz );
	if ( size.cx <= cpWidth ) return;

	// initialize szTrunc and szEllipsis
	cch = sz.GetLength();
	szEllipsis.LoadString( IDS_ELLIPSIS );

	// while we are too big, truncate one letter and add an ellipsis
	while( (size.cx > cpWidth) && (cch > 1) )
		{
		// chop off the last letter of the string - not counting the ...
		cch--;
		sz = sz.Left( cch );

		// add the elipsis (spelling?)
		sz += szEllipsis;

		// get the length
		size = pcdc->GetTextExtent( sz );
		}
	}







//------------------------------------------------------------------------
void CListSelRowCtrl::HiliteSelectedCells()
	{
	int	iList = -1;
	while( (iList = GetNextItem( iList, LVNI_SELECTED )) >= 0 )
		HiliteSelectedCell( iList );
	}

//------------------------------------------------------------------------
void CListSelRowCtrl::HiliteSelectedCell( int iCell, BOOL fHilite )
	{
	// if there is no selected cell, do nothing
	if ( iCell < 0 )
		return;

	// get the rect to draw
	CRect	rect;
	if ( !FGetCellRect(iCell, -1, &rect) )
		{
		ASSERT(FALSE);
		return;
		}

	// get the client rect
	CRect	rectClient;
	GetClientRect( rectClient );

	// make sure it fits ok (problems can occur here when scrolled)
	// don't want it to draw in the column titles
	if ( rect.top < (rect.bottom - rect.top) )
		return;

	// now prepare to draw
	CDC	*pdc = GetDC();

	// clip to the client area
	pdc->IntersectClipRect( rectClient );

	// set up the brush
	CBrush	cbrush;
	if ( fHilite )
		cbrush.CreateSolidBrush( RGB(192,192,192) );
	else
		cbrush.CreateSolidBrush( RGB(0xFF,0xFF,0xFF) );

	// draw the hilite rect
	pdc->FrameRect( rect, &cbrush );

	// cleanup
	ReleaseDC( pdc );
	}

//------------------------------------------------------------------------
BOOL	CListSelRowCtrl::FGetCellRect( LONG iRow, LONG iCol, CRect *pcrect )
	{
	// first, get the rect that the list thinks is appropriate
	if ( !GetItemRect(iRow, pcrect, LVIR_BOUNDS) )
		return FALSE;

	// if iCol < 0, then return the total size of the row
	if ( iCol < 0 )
		return TRUE;

	// trim the horizontal dimension to the correct column positioning
	LONG	cpLeft;
	LONG	cpRight = 0;
	for ( WORD i = 0; i <= iCol; i++ )
		{
		// set the left side
		cpLeft = cpRight;

		// get the right
		LONG cpWidth = GetColumnWidth(i);
		if ( cpWidth < 0 ) return FALSE;
		cpRight += cpWidth;
		}

	// well, now trim it seeing as we have the right values
	pcrect->left = cpLeft;
	pcrect->right = cpRight;
	
	// success!
	return TRUE;
	}

#define MAKE_LPARAM(x,y) ( ((unsigned long)(y)<<16) | ((unsigned long)(x)) )

//------------------------------------------------------------------------
void CListSelRowCtrl::OnLButtonDblClk(UINT nFlags, CPoint point) 
	{
	// force the point to be in the right place
	point.x = 6;
	LPARAM lp = MAKE_LPARAM(point.x, point.y);
//	DefWindowProc(WM_LBUTTONDBLCLK, nFlags, lp );
	CListCtrl::OnLButtonDblClk( nFlags, point);
	}

//------------------------------------------------------------------------
void CListSelRowCtrl::OnLButtonDown(UINT nFlags, CPoint point) 
	{
	point.x = 6;
	LPARAM lp = MAKE_LPARAM(point.x, point.y);
//	DefWindowProc(WM_LBUTTONDOWN, nFlags, lp );
	CListCtrl::OnLButtonDown( nFlags, point);
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\cnfgprts\metatool.cpp ===
// metatool.cpp : implementation file
//

// some common tools used for "smart" writing to the metabase

#include "stdafx.h"
#include <iadmw.h>

#define _COMSTATIC
#include <comprop.h>
#include <idlg.h>

#include "wrapmb.h"
#include "metatool.h"


//----------------------------------------------------------------
// open the metabase with an option to create the directory if it doesn't
// exist. It would be nice to move this into wrapmb, but that is too big
// a change for now. Maybe we can do that later.
BOOL OpenAndCreate( CWrapMetaBase* pmb, LPCTSTR pszTarget, DWORD perm, BOOL fCreate )
    {
    BOOL    f;
    CString szTarget = pszTarget;

    // start by just trying to open it. easy easy.
    if ( pmb->Open(szTarget, perm) )
        return TRUE;

    // if requested, try to create the key if it doesn't exist
    if ( fCreate )
        {
        // find the nearest openable parent directory and open it
        CString szPartial;
        CString szBase = szTarget;
        do
            {
            szBase = szBase.Left( szBase.ReverseFind(_T('/')) );
            szPartial = szTarget.Right( szTarget.GetLength() - szBase.GetLength() - 1 );
            f = pmb->Open( szBase, METADATA_PERMISSION_WRITE | perm );
            } while (!f && !szBase.IsEmpty());

        // if all that failed, fail
        if ( !f ) return FALSE;

        // create the key that we really want
        f = pmb->AddObject( szPartial );
        pmb->Close();

        // if all that failed, fail
        if ( !f ) return FALSE;

        // try again
        if ( pmb->Open(szTarget, perm) )
            return TRUE;
        }

    // total washout
    return FALSE;
    }

//----------------------------------------------------------------
// starting at the root, check for values set on sub-keys that may need to be overridden
// and propmt the user for what to do
void CheckInheritence( LPCTSTR pszServer, LPCTSTR pszInheritRoot, DWORD idData )
    {
    CInheritanceDlg dlgInherit(
            idData,
            FROM_WRITE_PROPERTY,
            pszServer,
            pszInheritRoot
            );

    // if it worked, then run the dialog
    if ( !dlgInherit.IsEmpty() )
        dlgInherit.DoModal();
    }

// notice that the dwords and generic blobs are handled seperately even though
// we count route the dwords through the blob mechanisms. This is done for two
// reasone. 1) Handling dwords is much more efficient than handling blobs.
// and 2) Most of the values are dwords.

//----------------------------------------------------------------
// opens the metabase, writes out the value, then uses the inheritence
// checking functionality from the iisui.dll to check for the inherited
// properties and propt the user for what to do
BOOL SetMetaDword(IMSAdminBase* pMB, LPCTSTR pszServer, LPCTSTR pszMetaRoot, LPCTSTR pszSub, DWORD idData, DWORD iType, DWORD dwValue, BOOL fCheckInheritence)
    {
    BOOL    fAnswer = FALSE;
    BOOL    fChanged = TRUE;
    DWORD   dword;

    CWrapMetaBase   mbWrap;
    if ( !mbWrap.FInit(pMB) ) return FALSE;

      // open the target
    if ( OpenAndCreate( &mbWrap, pszMetaRoot, 
            METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ, TRUE ) )
        {
        // attempt to get the current value - no inheritence
        if ( mbWrap.GetDword(pszSub, idData, iType, &dword) )
            {
            // set the changed flag
            fChanged = (dwValue != dword);
            }

        // save it out, if it changed or is not there
        if ( fChanged )
            fAnswer = mbWrap.SetDword( pszSub, idData, iType, dwValue );

        // close the metabase
        mbWrap.Close();
        }
    else
        fChanged = FALSE;
  
    // set up and run the inheritence checking dialog
    if ( fCheckInheritence && fChanged )
        {
        CString szInheritRoot = pszMetaRoot;
        szInheritRoot += pszSub;
        CheckInheritence( pszServer, szInheritRoot, idData );
        }
    
    return fAnswer;
    }

//----------------------------------------------------------------
// assumes that the metabase is actually open to the parent of the one we are interested
// and that the real target name is passed into szSub
BOOL SetMetaData(IMSAdminBase* pMB, LPCTSTR pszServer, LPCTSTR pszMetaRoot, LPCTSTR pszSub, DWORD idData, DWORD iType, DWORD iDataType, PVOID pData, DWORD cbData, BOOL fCheckInheritence )
    {
    BOOL    fAnswer = FALSE;
    BOOL    fChanged = TRUE;
    DWORD   cbTestData;

    CWrapMetaBase   mbWrap;
    if ( !mbWrap.FInit(pMB) ) return FALSE;

      // open the target
    if ( OpenAndCreate( &mbWrap, pszMetaRoot,
            METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ, TRUE ) )
        {
        // attempt to get the current value - no inheritence
        PVOID pTestData = mbWrap.GetData( pszSub, idData, iType,
                            iDataType, &cbTestData );
        if ( pTestData )
            {
            // set the changed flag
            if ( cbData == cbTestData )
                {
                fChanged = (memcmp(pData, pTestData, cbData) != 0);
                }            
            mbWrap.FreeWrapData( pTestData );
            }

        // save it out, if it changed or is not there
        if ( fChanged )
            fAnswer = mbWrap.SetData( pszSub, idData, iType, iDataType, pData, cbData );

        // close the metabase
        mbWrap.Close();
        }
    else
        fChanged = FALSE;

    // set up and run the inheritence checking dialog
    if ( fCheckInheritence && fChanged )
        {
        CString szInheritRoot = pszMetaRoot;
        szInheritRoot += pszSub;
        CheckInheritence( pszServer, szInheritRoot, idData );
        }
    
    return fAnswer;
    }

//----------------------------------------------------------------
// assumes that the metabase is actually open to the parent of the one we are interested
// and that the real target name is passed into szSub
BOOL SetMetaString(IMSAdminBase* pMB, LPCTSTR pszServer, LPCTSTR pszMetaRoot, LPCTSTR pszSub, DWORD idData, DWORD iType, CString sz, BOOL fCheckInheritence)
    {
    return SetMetaData(pMB, pszServer, pszMetaRoot, pszSub, idData,
            iType, STRING_METADATA, (LPTSTR)(LPCTSTR)sz,
            (sz.GetLength()+1)*sizeof(TCHAR), fCheckInheritence );
    }

//----------------------------------------------------------------
// assumes that the metabase is actually open to the parent of the one we are interested
// and that the real target name is passed into szSub
// the cchmsz is the total count of characters in the multi string including the nulls
BOOL SetMetaMultiSz(IMSAdminBase* pMB, LPCTSTR pszServer, LPCTSTR pszMetaRoot, LPCTSTR pszSub, DWORD idData, DWORD iType, PVOID pData, DWORD cchmsz, BOOL fCheckInheritence )
    {
    return SetMetaData(pMB, pszServer, pszMetaRoot, pszSub, idData,
            iType, MULTISZ_METADATA, pData, (cchmsz+1)*sizeof(TCHAR), fCheckInheritence );
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\cnfgprts\ratctl.h ===
// RatCtl.h : Declaration of the CRatCtrl OLE control class.

/////////////////////////////////////////////////////////////////////////////
// CRatCtrl : See RatCtl.cpp for implementation.

class CRatCtrl : public COleControl
{
	DECLARE_DYNCREATE(CRatCtrl)

// Constructor
public:
	CRatCtrl();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CRatCtrl)
	public:
	virtual void OnDraw(CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid);
	virtual void DoPropExchange(CPropExchange* pPX);
	virtual void OnResetState();
	virtual void OnClick(USHORT iButton);
	virtual void OnFontChanged();
	virtual void OnGetControlInfo(LPCONTROLINFO pControlInfo);
	virtual void OnTextChanged();
	virtual void OnMnemonic(LPMSG pMsg);
	virtual void OnAmbientPropertyChange(DISPID dispid);
	virtual void OnKeyUpEvent(USHORT nChar, USHORT nShiftState);
	//}}AFX_VIRTUAL

// Implementation
protected:
	~CRatCtrl();

	DECLARE_OLECREATE_EX(CRatCtrl)    // Class factory and guid
	DECLARE_OLETYPELIB(CRatCtrl)      // GetTypeInfo
	DECLARE_PROPPAGEIDS(CRatCtrl)     // Property page IDs
	DECLARE_OLECTLTYPE(CRatCtrl)		// Type name and misc status

	// Subclassed control support
	BOOL PreCreateWindow(CREATESTRUCT& cs);
	BOOL IsSubclassedControl();
	LRESULT OnOcmCommand(WPARAM wParam, LPARAM lParam);

// Message maps
	//{{AFX_MSG(CRatCtrl)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

// Dispatch maps
	//{{AFX_DISPATCH(CRatCtrl)
	afx_msg void SetAdminTarget(LPCTSTR szMachineName, LPCTSTR szMetaTarget);
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()

// Event maps
	//{{AFX_EVENT(CRatCtrl)
	//}}AFX_EVENT
	DECLARE_EVENT_MAP()

// Dispatch and event IDs
public:
	enum {
	//{{AFX_DISP_ID(CRatCtrl)
	dispidSetAdminTarget = 1L,
	//}}AFX_DISP_ID
	};

protected:
    BOOL 	m_fUpdateFont;
    CString m_szMachine;
    CString m_szMetaObject;

    // the accelerator table
    HACCEL  m_hAccel;
    WORD    m_cAccel;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\cnfgprts\ratdata.h ===
// ratings data class


class CRatingsData : public CObject
    {
    public:
        CRatingsData(IMSAdminBase* pMB);
        ~CRatingsData();

        IMSAdminBase*   m_pMB;


    // other data for/from the metabase
        BOOL    m_fEnabled;
        CString m_szEmail;

    // start date
        WORD    m_start_minute;
        WORD    m_start_hour;
        WORD    m_start_day;
        WORD    m_start_month;
        WORD    m_start_year;

    // expire date
        WORD    m_expire_minute;
        WORD    m_expire_hour;
        WORD    m_expire_day;
        WORD    m_expire_month;
        WORD    m_expire_year;

    // generate the label and save it into the metabase
        void SaveTheLable();

    // initialization
        BOOL    FInit( CString szServer, CString szMeta );

    // variables shared between the various pages
        // index of the currently selected rat parser
        DWORD   iRat;

        // the list of parsed rat files
        CTypedPtrArray<CObArray, PicsRatingSystem*> rgbRats;

    protected:
        // load a ratings file
        BOOL    FLoadRatingsFile( CString szFilePath );
        void    LoadMetabaseValues();
        void    ParseMetaRating( CString szRating );
        void    ParseMetaPair( TCHAR chCat, TCHAR chVal );

        // interpret the ratings file
        BOOL    FParseRatingsFile( LPSTR pData, CString szPath );

        // create the URL for the the item supplied for the metabase
        BOOL    FCreateURL( CString &sz );

        // create a date string
        void    CreateDateSz( CString &sz, WORD day, WORD month, WORD year, WORD hour, WORD minute );

        // read a date string
        void    ReadDateSz( CString sz, WORD* pDay, WORD* pMonth, WORD* pYear, WORD* pHour, WORD* pMinute );

        // target metabase location
        CString     m_szMeta;
        CString     m_szServer;

        CString     m_szMetaPartial;
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\cnfgprts\ratexprd.cpp ===
// RatExprD.cpp : implementation file
//

#include "stdafx.h"
#include "cnfgprts.h"
#include "RatExprD.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CRatExpireDlg dialog


//--------------------------------------------------------------------------
CRatExpireDlg::CRatExpireDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CRatExpireDlg::IDD, pParent),
        m_day( 0 ),
        m_month( 0 ),
        m_year( 0 )
    {
    //{{AFX_DATA_INIT(CRatExpireDlg)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
    }

//--------------------------------------------------------------------------
void CRatExpireDlg::DoDataExchange(CDataExchange* pDX)
    {
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CRatExpireDlg)
    DDX_Control(pDX, IDC_MSACALCTRL, m_calendar);
    //}}AFX_DATA_MAP
    }


//--------------------------------------------------------------------------
BEGIN_MESSAGE_MAP(CRatExpireDlg, CDialog)
    //{{AFX_MSG_MAP(CRatExpireDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRatExpireDlg message handlers


//--------------------------------------------------------------------------
BOOL CRatExpireDlg::IsSystemDBCS( void )
    {
    WORD wPrimaryLangID = PRIMARYLANGID( GetSystemDefaultLangID() );

    return ( wPrimaryLangID == LANG_JAPANESE ||
        wPrimaryLangID == LANG_CHINESE ||
        wPrimaryLangID == LANG_KOREAN );
    } 

//--------------------------------------------------------------------------
BOOL CRatExpireDlg::OnInitDialog( )
    {
    SYSTEMTIME  time;

    // get the base class going
    BOOL f = CDialog::OnInitDialog();

    // set up the calendar in DBCS mode as appropriate - suggested by the japanese guys
    if ( IsSystemDBCS() )
        {
        m_calendar.SetDayLength( 0 );    // 0: localized one
        m_calendar.SetMonthLength( 0 );  // 0: localized one
        m_calendar.SetDayFont( NULL );   // use default
        m_calendar.SetGridFont( NULL );  // use default
        m_calendar.SetTitleFont( NULL ); // use default
        }

    //
    // Background colour looks weird if the dialog
    // is not gray
    //
    m_calendar.SetBackColor(GetSysColor(COLOR_BTNFACE));

    // now tell the calendar to focus on one year from today, or the supplied date
    // if there is one
    if ( m_year )
        {
 	    m_calendar.SetYear( m_year );
	    m_calendar.SetMonth( m_month );
	    m_calendar.SetDay( m_day );
       }
    else
        {
        // the default case - use one year from today
        GetLocalTime( &time );
 	    m_calendar.SetYear( time.wYear + 1 );
	    m_calendar.SetMonth( time.wMonth );
	    m_calendar.SetDay( time.wDay );
        }

    // return the answer
    return f;
    }

//--------------------------------------------------------------------------
void CRatExpireDlg::OnOK() 
    {
    // get the date
    m_day = m_calendar.GetDay();
    m_month = m_calendar.GetMonth();
    m_year = m_calendar.GetYear();

    // test if nothing is selected - check if the year is 0
    if ( m_year == 0 )
        {
        AfxMessageBox(IDS_NO_DATE_SELECTED);
        return;
        }

    // put it into a CTime so we can compare
    CTime  timeCal(m_year,m_month,m_day,12,0,0);

    // compare
    if ( timeCal < CTime::GetCurrentTime() )
        {
        if ( AfxMessageBox(IDS_EXPIRE_SET_PAST,MB_YESNO) == IDNO )
            return;
        }

    // let the dialog close
    CDialog::OnOK();
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\cnfgprts\msacal70.cpp ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "stdafx.h"
#include "msacal70.h"

// Dispatch interfaces referenced by this interface
#include "font.h"

/////////////////////////////////////////////////////////////////////////////
// CMsacal70

IMPLEMENT_DYNCREATE(CMsacal70, CWnd)

/////////////////////////////////////////////////////////////////////////////
// CMsacal70 properties

OLE_COLOR CMsacal70::GetBackColor()
{
	OLE_COLOR result;
	GetProperty(DISPID_BACKCOLOR, VT_I4, (void*)&result);
	return result;
}

void CMsacal70::SetBackColor(OLE_COLOR propVal)
{
	SetProperty(DISPID_BACKCOLOR, VT_I4, propVal);
}

short CMsacal70::GetDay()
{
	short result;
	GetProperty(0x11, VT_I2, (void*)&result);
	return result;
}

void CMsacal70::SetDay(short propVal)
{
	SetProperty(0x11, VT_I2, propVal);
}

COleFont CMsacal70::GetDayFont()
{
	LPDISPATCH pDispatch;
	GetProperty(0x1, VT_DISPATCH, (void*)&pDispatch);
	return COleFont(pDispatch);
}

void CMsacal70::SetDayFont(LPDISPATCH propVal)
{
	SetProperty(0x1, VT_DISPATCH, propVal);
}

unsigned long CMsacal70::GetDayFontColor()
{
	unsigned long result;
	GetProperty(0x2, VT_I4, (void*)&result);
	return result;
}

void CMsacal70::SetDayFontColor(unsigned long propVal)
{
	SetProperty(0x2, VT_I4, propVal);
}

short CMsacal70::GetDayLength()
{
	short result;
	GetProperty(0x12, VT_I2, (void*)&result);
	return result;
}

void CMsacal70::SetDayLength(short propVal)
{
	SetProperty(0x12, VT_I2, propVal);
}

short CMsacal70::GetFirstDay()
{
	short result;
	GetProperty(0x13, VT_I2, (void*)&result);
	return result;
}

void CMsacal70::SetFirstDay(short propVal)
{
	SetProperty(0x13, VT_I2, propVal);
}

long CMsacal70::GetGridCellEffect()
{
	long result;
	GetProperty(0x14, VT_I4, (void*)&result);
	return result;
}

void CMsacal70::SetGridCellEffect(long propVal)
{
	SetProperty(0x14, VT_I4, propVal);
}

COleFont CMsacal70::GetGridFont()
{
	LPDISPATCH pDispatch;
	GetProperty(0x3, VT_DISPATCH, (void*)&pDispatch);
	return COleFont(pDispatch);
}

void CMsacal70::SetGridFont(LPDISPATCH propVal)
{
	SetProperty(0x3, VT_DISPATCH, propVal);
}

unsigned long CMsacal70::GetGridFontColor()
{
	unsigned long result;
	GetProperty(0x4, VT_I4, (void*)&result);
	return result;
}

void CMsacal70::SetGridFontColor(unsigned long propVal)
{
	SetProperty(0x4, VT_I4, propVal);
}

unsigned long CMsacal70::GetGridLinesColor()
{
	unsigned long result;
	GetProperty(0xd, VT_I4, (void*)&result);
	return result;
}

void CMsacal70::SetGridLinesColor(unsigned long propVal)
{
	SetProperty(0xd, VT_I4, propVal);
}

short CMsacal70::GetMonth()
{
	short result;
	GetProperty(0x10, VT_I2, (void*)&result);
	return result;
}

void CMsacal70::SetMonth(short propVal)
{
	SetProperty(0x10, VT_I2, propVal);
}

short CMsacal70::GetMonthLength()
{
	short result;
	GetProperty(0x15, VT_I2, (void*)&result);
	return result;
}

void CMsacal70::SetMonthLength(short propVal)
{
	SetProperty(0x15, VT_I2, propVal);
}

BOOL CMsacal70::GetShowDateSelectors()
{
	BOOL result;
	GetProperty(0x5, VT_BOOL, (void*)&result);
	return result;
}

void CMsacal70::SetShowDateSelectors(BOOL propVal)
{
	SetProperty(0x5, VT_BOOL, propVal);
}

BOOL CMsacal70::GetShowDays()
{
	BOOL result;
	GetProperty(0x6, VT_BOOL, (void*)&result);
	return result;
}

void CMsacal70::SetShowDays(BOOL propVal)
{
	SetProperty(0x6, VT_BOOL, propVal);
}

BOOL CMsacal70::GetShowHorizontalGrid()
{
	BOOL result;
	GetProperty(0x7, VT_BOOL, (void*)&result);
	return result;
}

void CMsacal70::SetShowHorizontalGrid(BOOL propVal)
{
	SetProperty(0x7, VT_BOOL, propVal);
}

BOOL CMsacal70::GetShowTitle()
{
	BOOL result;
	GetProperty(0x8, VT_BOOL, (void*)&result);
	return result;
}

void CMsacal70::SetShowTitle(BOOL propVal)
{
	SetProperty(0x8, VT_BOOL, propVal);
}

BOOL CMsacal70::GetShowVerticalGrid()
{
	BOOL result;
	GetProperty(0x9, VT_BOOL, (void*)&result);
	return result;
}

void CMsacal70::SetShowVerticalGrid(BOOL propVal)
{
	SetProperty(0x9, VT_BOOL, propVal);
}

COleFont CMsacal70::GetTitleFont()
{
	LPDISPATCH pDispatch;
	GetProperty(0xa, VT_DISPATCH, (void*)&pDispatch);
	return COleFont(pDispatch);
}

void CMsacal70::SetTitleFont(LPDISPATCH propVal)
{
	SetProperty(0xa, VT_DISPATCH, propVal);
}

unsigned long CMsacal70::GetTitleFontColor()
{
	unsigned long result;
	GetProperty(0xb, VT_I4, (void*)&result);
	return result;
}

void CMsacal70::SetTitleFontColor(unsigned long propVal)
{
	SetProperty(0xb, VT_I4, propVal);
}

VARIANT CMsacal70::GetValue()
{
	VARIANT result;
	GetProperty(0xc, VT_VARIANT, (void*)&result);
	return result;
}

void CMsacal70::SetValue(const VARIANT& propVal)
{
	SetProperty(0xc, VT_VARIANT, &propVal);
}

BOOL CMsacal70::GetValueIsNull()
{
	BOOL result;
	GetProperty(0xe, VT_BOOL, (void*)&result);
	return result;
}

void CMsacal70::SetValueIsNull(BOOL propVal)
{
	SetProperty(0xe, VT_BOOL, propVal);
}

short CMsacal70::GetYear()
{
	short result;
	GetProperty(0xf, VT_I2, (void*)&result);
	return result;
}

void CMsacal70::SetYear(short propVal)
{
	SetProperty(0xf, VT_I2, propVal);
}

/////////////////////////////////////////////////////////////////////////////
// CMsacal70 operations

void CMsacal70::NextDay()
{
	InvokeHelper(0x16, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CMsacal70::NextMonth()
{
	InvokeHelper(0x17, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CMsacal70::NextWeek()
{
	InvokeHelper(0x18, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CMsacal70::NextYear()
{
	InvokeHelper(0x19, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CMsacal70::PreviousDay()
{
	InvokeHelper(0x1a, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CMsacal70::PreviousMonth()
{
	InvokeHelper(0x1b, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CMsacal70::PreviousWeek()
{
	InvokeHelper(0x1c, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CMsacal70::PreviousYear()
{
	InvokeHelper(0x1d, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CMsacal70::Refresh()
{
	InvokeHelper(DISPID_REFRESH, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CMsacal70::Today()
{
	InvokeHelper(0x1e, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CMsacal70::AboutBox()
{
	InvokeHelper(0xfffffdd8, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\cnfgprts\msacal70.h ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


// Dispatch interfaces referenced by this interface
class COleFont;

/////////////////////////////////////////////////////////////////////////////
// CMsacal70 wrapper class

class CMsacal70 : public CWnd
{
protected:
	DECLARE_DYNCREATE(CMsacal70)
public:
	CLSID const& GetClsid()
	{
		static CLSID const clsid
			= { 0x8e27c92b, 0x1264, 0x101c, { 0x8a, 0x2f, 0x4, 0x2, 0x24, 0x0, 0x9c, 0x2 } };
		return clsid;
	}
	virtual BOOL Create(LPCTSTR lpszClassName,
		LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect,
		CWnd* pParentWnd, UINT nID,
		CCreateContext* pContext = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID); }

    BOOL Create(LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect, CWnd* pParentWnd, UINT nID,
		CFile* pPersist = NULL, BOOL bStorage = FALSE,
		BSTR bstrLicKey = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID,
		pPersist, bStorage, bstrLicKey); }

// Attributes
public:
	OLE_COLOR GetBackColor();
	void SetBackColor(OLE_COLOR);
	short GetDay();
	void SetDay(short);
	COleFont GetDayFont();
	void SetDayFont(LPDISPATCH);
	unsigned long GetDayFontColor();
	void SetDayFontColor(unsigned long);
	short GetDayLength();
	void SetDayLength(short);
	short GetFirstDay();
	void SetFirstDay(short);
	long GetGridCellEffect();
	void SetGridCellEffect(long);
	COleFont GetGridFont();
	void SetGridFont(LPDISPATCH);
	unsigned long GetGridFontColor();
	void SetGridFontColor(unsigned long);
	unsigned long GetGridLinesColor();
	void SetGridLinesColor(unsigned long);
	short GetMonth();
	void SetMonth(short);
	short GetMonthLength();
	void SetMonthLength(short);
	BOOL GetShowDateSelectors();
	void SetShowDateSelectors(BOOL);
	BOOL GetShowDays();
	void SetShowDays(BOOL);
	BOOL GetShowHorizontalGrid();
	void SetShowHorizontalGrid(BOOL);
	BOOL GetShowTitle();
	void SetShowTitle(BOOL);
	BOOL GetShowVerticalGrid();
	void SetShowVerticalGrid(BOOL);
	COleFont GetTitleFont();
	void SetTitleFont(LPDISPATCH);
	unsigned long GetTitleFontColor();
	void SetTitleFontColor(unsigned long);
	VARIANT GetValue();
	void SetValue(const VARIANT&);
	BOOL GetValueIsNull();
	void SetValueIsNull(BOOL);
	short GetYear();
	void SetYear(short);

// Operations
public:
	void NextDay();
	void NextMonth();
	void NextWeek();
	void NextYear();
	void PreviousDay();
	void PreviousMonth();
	void PreviousWeek();
	void PreviousYear();
	void Refresh();
	void Today();
	void AboutBox();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\cnfgprts\parserat.h ===
/****************************************************************************\
 *
 *   PARSERAT.H --Structures for holding pics information
 *
 *   Created:   Jason Thomas
 *   Updated:   Ann McCurdy
 *   
\****************************************************************************/

#ifndef _PARSERAT_H_
#define _PARSERAT_H_




// output defines ---------------------------------------
#define OUTPUT_PICS




/*Array template---------------------------------------------------*/

/*Interface-------------------------------------------------------------------*/
template <class T>
class array {
    private:
        int nLen, nMax;
        T   *pData;
        void Destruct();
    public:
        array();
        ~array();

        BOOL Append(T v);
        int  Length() const;
        void ClearAll();
        void DeleteAll();

        T& operator[](int index);
};

/*definitions of everything*/

#ifndef ARRAY_CXX
#define ARRAY_CXX

/*Implementation------------------------------------------------------------*/
template <class T>
array<T>::array(){
    nLen  = nMax = 0;
    pData = NULL;
}

template <class T>
inline array<T>::~array() {
    if (pData) ::MemFree(pData);
    pData = NULL;
    nMax  = nLen = 0;
}

template <class T>
inline int array<T>::Length() const{
    return nLen;
}

template <class T>
inline T& array<T>::operator[](int index){
    assert(index<Length());
    assert(index>=0);
    assert(pData);
    return pData[index];
}

template <class T>
BOOL array<T>::Append(T v) {
    if (nLen == nMax){
        nMax  = nMax + 8;           /* grow by bigger chunks */
        T* pNew = (T*)::MemReAlloc(pData, sizeof(T)*nMax);
        if (pNew == NULL)
            return FALSE;
        pData = pNew;
    }
    assert(pData);
    assert(nMax);
    pData[nLen++] = v;
    return TRUE;
}

template <class T>
void array<T>::Destruct(){
    while (nLen){
        delete pData[--nLen];
    }
}

template <class T>
inline void array<T>::ClearAll() {
    nLen = 0;
}

template <class T>
inline void array<T>::DeleteAll() {
    Destruct();
}

#endif 
/* ARRAY_CXX */


#define P_INFINITY           9999
#define N_INFINITY          -9999

/*Simple PICS types------------------------------------------------*/

#if 0
class ET{
    private:
        BOOL m_fInit;
    public:
        ET();
        void Init();
        void UnInit();
        BOOL fIsInit();
};
#endif

class ETN
{
    private:
        INT_PTR r;
        BOOL m_fInit;
    public:
        ETN() { m_fInit = FALSE; }

        void Init() { m_fInit = TRUE; }
        void UnInit() { m_fInit = FALSE; }
        BOOL fIsInit() { return m_fInit; }

#ifdef DEBUG
        void  Set(INT_PTR rIn);
        INT_PTR Get();
#else
        void  Set(INT_PTR rIn) { Init(); r = rIn; }
        INT_PTR Get() { return r; }
#endif

        ETN*  Duplicate();
};

const UINT ETB_VALUE = 0x01;
const UINT ETB_ISINIT = 0x02;
class ETB
{
    private:
        UINT m_nFlags;
    public:
        ETB() { m_nFlags = 0; }

#ifdef DEBUG
        INT_PTR Get();
        void Set(INT_PTR b);
#else
        INT_PTR Get() { return m_nFlags & ETB_VALUE; }
        void Set(INT_PTR b) { m_nFlags = ETB_ISINIT | (b ? ETB_VALUE : 0); }
#endif

        ETB   *Duplicate();
        BOOL fIsInit() { return m_nFlags & ETB_ISINIT; }
};

class ETS
{
    private:
        char *pc;
    public:
        ETS() { pc = NULL; }
        ~ETS();
#ifdef DEBUG
        char* Get();
#else
        char *Get() { return pc; }
#endif
        void  Set(const char *pIn);
        ETS*  Duplicate();
        void  SetTo(char *pIn);

        BOOL fIsInit() { return pc != NULL; }
};

/*Complex PICS types-----------------------------------------------*/


enum RatObjectID
{
    ROID_INVALID,           /* dummy entry for terminating arrays */
    ROID_PICSDOCUMENT,      /* value representing the entire document (i.e., no token) */
    ROID_PICSVERSION,
    ROID_RATINGSYSTEM,
    ROID_RATINGSERVICE,
    ROID_RATINGBUREAU,
    ROID_BUREAUREQUIRED,
    ROID_CATEGORY,
    ROID_TRANSMITAS,
    ROID_LABEL,
    ROID_VALUE,
    ROID_DEFAULT,
    ROID_DESCRIPTION,
    ROID_EXTENSION,
    ROID_MANDATORY,
    ROID_OPTIONAL,
    ROID_ICON,
    ROID_INTEGER,
    ROID_LABELONLY,
    ROID_MAX,
    ROID_MIN,
    ROID_MULTIVALUE,
    ROID_NAME,
    ROID_UNORDERED
};

/* A RatObjectHandler parses the contents of a parenthesized object and
 * spits out a binary representation of that data, suitable for passing
 * to an object's AddItem function.  It does not consume the ')' which
 * closes the object.
 */
class RatFileParser;
typedef HRESULT (*RatObjectHandler)(LPSTR *ppszIn, LPVOID *ppOut, RatFileParser *pParser);


class PicsCategory;

class PicsObjectBase : public CObject
{
public:
    virtual HRESULT AddItem(RatObjectID roid, LPVOID pData) = 0;
    virtual HRESULT InitializeMyDefaults(PicsCategory *pCategory) = 0;
    virtual void Dump( void ) = 0;
};


const DWORD AO_SINGLE = 0x01;
const DWORD AO_SEEN = 0x02;
const DWORD AO_MANDATORY = 0x04;

struct AllowableOption
{
    RatObjectID roid;
    DWORD fdwOptions;
};


class PicsEnum : public PicsObjectBase
{
    private:
    public:
        ETS etstrName, etstrIcon, etstrDesc;
        ETN etnValue;

        PicsEnum() {}
        ~PicsEnum() {}

        HRESULT AddItem(RatObjectID roid, LPVOID pData);
        HRESULT InitializeMyDefaults(PicsCategory *pCategory);
        void Dump( void );
};

class PicsRatingSystem;

class PicsCategory : public PicsObjectBase
{
    public:
        PicsCategory():currentValue(0) {;}
        ~PicsCategory()
        {
            arrpPC.DeleteAll();
            arrpPE.DeleteAll();
        }

    private:
    public:
        array<PicsCategory*> arrpPC;
        array<PicsEnum*>     arrpPE;
        ETS   etstrTransmitAs, etstrName, etstrIcon, etstrDesc;
        ETN   etnMin,   etnMax;
        ETB   etfMulti, etfInteger, etfLabelled, etfUnordered;
        PicsRatingSystem *pPRS;

        WORD  currentValue;

        void FixupLimits();
        void SetParents(PicsRatingSystem *pOwner);

        HRESULT AddItem(RatObjectID roid, LPVOID pData);
        HRESULT InitializeMyDefaults(PicsCategory *pCategory);

        void Dump( void );

        // boydm
        void OutputLabel( CString &sz );
        BOOL FSetValuePair( CHAR chCat, WORD value );
};


class PicsDefault : public PicsObjectBase
{
public:
    ETB etfInteger, etfLabelled, etfMulti, etfUnordered;
    ETN etnMax, etnMin;

    PicsDefault() {}
    ~PicsDefault() {}

    HRESULT AddItem(RatObjectID roid, LPVOID pData);
    HRESULT InitializeMyDefaults(PicsCategory *pCategory);

    void Dump( void );
};


class PicsExtension : public PicsObjectBase
{
public:
    LPSTR m_pszRatingBureau;

    PicsExtension();
    ~PicsExtension();

    HRESULT AddItem(RatObjectID roid, LPVOID pData);
    HRESULT InitializeMyDefaults(PicsCategory *pCategory);

    void Dump( void );
};


class PicsRatingSystem : public PicsObjectBase
{
    private:
    public:
        array<PicsCategory*> arrpPC;
        ETS                  etstrFile, etstrName, etstrIcon, etstrDesc, 
                             etstrRatingService, etstrRatingSystem, etstrRatingBureau;
        ETN                  etnPicsVersion;
        ETB                  etbBureauRequired;
        PicsDefault *        m_pDefaultOptions;
        DWORD                dwFlags;
        UINT                 nErrLine;

        PicsRatingSystem() :
            m_pDefaultOptions( NULL ),
            dwFlags( 0 ),
            nErrLine( 0 ) {}
        
        ~PicsRatingSystem()
        {
            arrpPC.DeleteAll();
            if (m_pDefaultOptions != NULL)
                delete m_pDefaultOptions;
        }
            
        HRESULT Parse(LPSTR pStreamIn);

        HRESULT AddItem(RatObjectID roid, LPVOID pData);
        HRESULT InitializeMyDefaults(PicsCategory *pCategory);
        VOID Dump();
        void ReportError(HRESULT hres);

        void OutputLabels( CString &sz, CString szURL,CString szName, CString szStart, CString szEnd );
};

void SkipWhitespace(LPSTR *ppsz);
BOOL IsEqualToken(LPCSTR pszTokenStart, LPCSTR pszTokenEnd, LPCSTR pszTokenToMatch);
LPSTR FindTokenEnd(LPSTR pszStart);
HRESULT GetBool(LPSTR *ppszToken, BOOL *pfOut);
HRESULT ParseNumber(LPSTR *ppszNumber, INT *pnOut);

/*Memory utility functions-----------------------------------------------*/

inline void * WINAPI MemAlloc(long cb)
{
    return (void *)::LocalAlloc(LPTR, cb);
}
    
inline void * WINAPI MemReAlloc(void * pb, long cb)
{
    if (pb == NULL)
        return MemAlloc(cb);

    return (void *)::LocalReAlloc((HLOCAL)pb, cb, LMEM_MOVEABLE | LMEM_ZEROINIT);
}

inline BOOL WINAPI MemFree(void * pb)
{
    return (BOOL)HandleToUlong(::LocalFree((HLOCAL)pb));
}

/*String manipulation wrappers---------------------------------------------*/

#ifdef __cplusplus
extern "C" {
#endif

#define memcmpf(d,s,l)  memcmp((d),(s),(l))
#define memcpyf(d,s,l)  memcpy((d),(s),(l))
#define memmovef(d,s,l) MoveMemory((d),(s),(l))
#define memsetf(s,c,l)  memset((s),(c),(l))
#define strcatf(d,s)    strcat((d),(s))
#define strcmpf(s1,s2)  lstrcmp(s1,s2)
#define strcpyf(d,s)    strcpy((d),(s))
#define stricmpf(s1,s2) lstrcmpi(s1,s2)
#define strlenf(s)      strlen((s))
#define strchrf(s,c)    strchr((s),(c))
#define strrchrf(s,c)   strrchr((s),(c))
#define strspnf(s1,s2)  strspn((s1),(s2))
#define strnicmpf(s1,s2,i)  _strnicmp((s1),(s2),(i))
#define strncpyf(s1,s2,i)   strncpy((s1),(s2),(i))
#define strcspnf(s1,s2) strcspn((s1),(s2))
#define strtokf(s1,s2)  strtok((s1),(s2))
#define strstrf(s1,s2)  strstr((s1),(s2))


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\cnfgprts\parserat.cpp ===
/****************************************************************************\
 *
 *   PARSERAT.C -- Code to parse .RAT files
 *
 *   Created:   Greg Jones
 *
\****************************************************************************/

/*Includes------------------------------------------------------------------*/
#include "stdafx.h"
#include "cnfgprts.h"

#include "parserat.h"
#include <iis64.h>

/****************************************************************************
Some design notes on how this parser works:

A ParenThing is:

'(' identifier [stuff] ')'

where [stuff] could be:
    a quoted string
    a number
    a boolean
    a series of ParenThings
    in the case of extensions:
        a quoted string, followed by
        one or more quoted strings and/or ParenThings

The entire .RAT file is a ParenThing, except that it has no identifier, just
a list of ParenThings inside it.


**********************************************************************
We pass the parser a schema for what things it expects -- we have
a big array listing identifiers for each different possible keyword, and
each parser call receives a smaller array containing only those indices
that are valid to occur within that object.

We make PicsRatingSystem, PicsCategory, and PicsEnum derive from a common
base class which supports a virtual function AddItem(ID,data).  So at the
top level, we construct an (empty) PicsRatingSystem.  We call the parser,
giving it a pointer to that guy, and a structure describing what to parse --
the ParenObject's token is a null string (since the global structure is the
one that doesn't start with a token before its first embedded ParenThing),
and we give a list saying the allowable things in a PicsRatingSystem are
PICS-version, rating-system, rating-service, default, description, extension,
icon, name, category.  There is a global table indicating a handler function
for every type of ParenThing, which knows how to create a data structure
completely describing that ParenThing.  (That data structure could be as
simple as a number or as complex as allocating and parsing a complete
PicsCategory object.)

The parser walks along, and for each ParenThing he finds, he identifies it
by looking up its token in the list provided by the caller. Each entry in
that list should include a field which indicates whether multiple things
of that identity are allowed (e.g., 'category') or not (e.g., rating-system).
If only one is allowed, then when the parser finds one he marks it as having
been found.

When the parser identifies the ParenThing, he calls its handler function to
completely parse the data in the ParenThing and return that object into an
LPVOID provided by the parser.  If that is successful, the parser then calls
its object's AddItem(ID,data) virtual function to add the specified item to
the object, relying on the object itself to know what type "data" points to --
a number, a pointer to a heap string which can be given to ETS::SetTo, a
pointer to a PicsCategory object which can be appended to an array, etc.

The RatFileParser class exists solely to provide a line number shared by
all the parsing routines.  This line number is updated as the parser walks
through the file, and is frozen as soon as an error is found.  This line
number can later be reported to the user to help localize errors in RAT files.

*****************************************************************************/

/*Globals-------------------------------------------------------------------*/

#define EXTTEXT(n) const CHAR n[]
#define TEXTCONST(name,text) EXTTEXT(name) = (text)

/* Text strings used in parsing rating labels. */

TEXTCONST(szNULL,"");
TEXTCONST(szDoubleCRLF,"\r\n\r\n");
TEXTCONST(szPicsOpening,"(PICS-");
TEXTCONST(szWhitespace," \t\r\n");
TEXTCONST(szExtendedAlphaNum,"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+-.,;:&=?!*~@#/");
TEXTCONST(szSingleCharTokens,"()\"");
TEXTCONST(szLeftParen,"(");
TEXTCONST(szRightParen,")");
TEXTCONST(szOptional,"optional");
TEXTCONST(szMandatory,"mandatory");
TEXTCONST(szAtOption,"at");
TEXTCONST(szByOption,"by");
TEXTCONST(szCommentOption,"comment");
TEXTCONST(szCompleteLabelOption,"complete-label");
TEXTCONST(szFullOption,"full");
TEXTCONST(szExtensionOption,"extension");
TEXTCONST(szGenericOption,"generic");
TEXTCONST(szShortGenericOption,"gen");
TEXTCONST(szForOption,"for");
TEXTCONST(szMICOption,"MIC-md5");
TEXTCONST(szMD5Option,"md5");
TEXTCONST(szOnOption,"on");
TEXTCONST(szSigOption,"signature-PKCS");
TEXTCONST(szUntilOption,"until");
TEXTCONST(szExpOption,"exp");
TEXTCONST(szRatings,"ratings");
TEXTCONST(szShortRatings,"r");
TEXTCONST(szError,"error");
TEXTCONST(szNoRatings,"no-ratings");
TEXTCONST(szLabelWord,"labels");
TEXTCONST(szShortLabelWord,"l");
TEXTCONST(szShortTrue,"t");
TEXTCONST(szTrue,"true");
TEXTCONST(szShortFalse,"f");
TEXTCONST(szFalse,"false");

TEXTCONST(szNegInf,"-INF");
TEXTCONST(szPosInf,"+INF");
TEXTCONST(szLabel,"label");
TEXTCONST(szName,"name");
TEXTCONST(szValue,"value");
TEXTCONST(szIcon,"icon");
TEXTCONST(szDescription, "description");
TEXTCONST(szCategory, "category");
TEXTCONST(szTransmitAs, "transmit-as");
TEXTCONST(szMin,"min");
TEXTCONST(szMax,"max");
TEXTCONST(szMultivalue,"multivalue");
TEXTCONST(szInteger,"integer");
TEXTCONST(szLabelOnly, "label-only");
TEXTCONST(szPicsVersion,"PICS-version");
TEXTCONST(szRatingSystem,"rating-system");
TEXTCONST(szRatingService,"rating-service");
TEXTCONST(szRatingBureau,"rating-bureau");
TEXTCONST(szBureauRequired,"bureau-required");
TEXTCONST(szDefault,"default");
TEXTCONST(szMultiValue,"multivalue");
TEXTCONST(szUnordered,"unordered");
TEXTCONST(szRatingBureauExtension,"www.w3.org/PICS/service-extensions/label-bureau");

/* define some error codes */
const HRESULT RAT_E_BASE = 0x80050000;                  /* just a guess at a free area for internal use */
const HRESULT RAT_E_EXPECTEDLEFT    = RAT_E_BASE + 1;   /* expected left paren */
const HRESULT RAT_E_EXPECTEDRIGHT   = RAT_E_BASE + 2;   /* expected right paren */
const HRESULT RAT_E_EXPECTEDTOKEN   = RAT_E_BASE + 3;   /* expected unquoted token */
const HRESULT RAT_E_EXPECTEDSTRING  = RAT_E_BASE + 4;   /* expected quoted string */
const HRESULT RAT_E_EXPECTEDNUMBER  = RAT_E_BASE + 5;   /* expected number */
const HRESULT RAT_E_EXPECTEDBOOL    = RAT_E_BASE + 6;   /* expected boolean */
const HRESULT RAT_E_DUPLICATEITEM   = RAT_E_BASE + 7;   /* AO_SINGLE item appeared twice */
const HRESULT RAT_E_MISSINGITEM     = RAT_E_BASE + 8;   /* AO_MANDATORY item not found */
const HRESULT RAT_E_UNKNOWNITEM     = RAT_E_BASE + 9;   /* unrecognized token */
const HRESULT RAT_E_UNKNOWNMANDATORY= RAT_E_BASE + 10;  /* unrecognized mandatory extension */

char PicsDelimChar='/';

class RatFileParser
{
public:
    UINT m_nLine;

    RatFileParser() { m_nLine = 1; }

    LPSTR EatQuotedString(LPSTR pIn);
    HRESULT ParseToOpening(LPSTR *ppIn, AllowableOption *paoExpected,
                           AllowableOption **ppFound);
    HRESULT ParseParenthesizedObject(
        LPSTR *ppIn,                    /* where we are in the text stream */
        AllowableOption aao[],          /* allowable things inside this object */
        PicsObjectBase *pObject         /* object to set parameters into */
    );
    char* FindNonWhite(char *pc);
};



/* White returns a pointer to the first whitespace character starting at pc.
 */
char* White(char *pc){
    assert(pc);
    while (1){
        if (*pc == '\0' ||
            *pc ==' ' ||
            *pc == '\t' ||
            *pc == '\r' ||
            *pc == '\n')
        {
            return pc;
        }
        pc++;
    }
}


/* NonWhite returns a pointer to the first non-whitespace character starting
 * at pc.
 */
char* NonWhite(char *pc){
    assert(pc);
    while (1){
        if (*pc != ' ' &&
            *pc != '\t' &&
            *pc != '\r' &&
            *pc != '\n')            /* includes null terminator */
        {
            return pc;
        }
        pc++;
    }
}


/* FindNonWhite returns a pointer to the first non-whitespace character starting
 * at pc.
 */
char* RatFileParser::FindNonWhite(char *pc)
{
    assert(pc);
    while (1)
    {
        if (*pc != ' ' &&
            *pc != '\t' &&
            *pc != '\r' &&
            *pc != '\n')            /* includes null terminator */
        {
            return pc;
        }
        if (*pc == '\n')
            m_nLine++;
        pc++;
    }
}

/* AppendSlash forces pszString to end in a single slash if it doesn't
 * already.  This may produce a technically invalid URL (for example,
 * "http://gregj/default.htm/", but we're only using the result for
 * comparisons against other paths similarly mangled.
 */
void AppendSlash(LPSTR pszString)
{
    LPSTR pszSlash = ::strrchrf(pszString, '/');

    if (pszSlash == NULL || *(pszSlash + 1) != '\0')
        ::strcatf(pszString, "/");
}

/* SkipWhitespace(&pszString)
 *
 * advances pszString past whitespace characters
 */
void SkipWhitespace(LPSTR *ppsz)
{
    UINT cchWhitespace = ::strspnf(*ppsz, szWhitespace);

    *ppsz += cchWhitespace;
}


/* FindTokenEnd(pszStart)
 *
 * Returns a pointer to the end of a contiguous range of similarly-typed
 * characters (whitespace, quote mark, punctuation, or alphanumerics).
 */
LPSTR FindTokenEnd(LPSTR pszStart)
{
    LPSTR pszEnd = pszStart;

    if (*pszEnd == '\0') {
        return pszEnd;
    }
    else if (strchr(szSingleCharTokens, *pszEnd)) {
        return ++pszEnd;
    }

    UINT cch;
    cch = ::strspnf(pszEnd, szWhitespace);
    if (cch > 0)
        return pszEnd + cch;

    cch = ::strspnf(pszEnd, szExtendedAlphaNum);
    if (cch > 0)
        return pszEnd + cch;

    return pszEnd;              /* unrecognized characters */
}


/* GetBool(LPSTR *ppszToken, BOOL *pfOut)
 *
 * Parses a boolean value at the given token and returns its value in *pfOut.
 * Legal values are 't', 'f', 'true', and 'false'.  If success, *ppszToken
 * is advanced past the boolean token and any following whitespace.  If failure,
 * *ppszToken is not modified.
 *
 * pfOut may be NULL if the caller just wants to eat the token and doesn't
 * care about its value.
 */
HRESULT GetBool(LPSTR *ppszToken, BOOL *pfOut)
{
    BOOL bValue;

    LPSTR pszTokenEnd = FindTokenEnd(*ppszToken);

    if (IsEqualToken(*ppszToken, pszTokenEnd, szShortTrue) ||
        IsEqualToken(*ppszToken, pszTokenEnd, szTrue)) {
        bValue = TRUE;
    }
    else if (IsEqualToken(*ppszToken, pszTokenEnd, szShortFalse) ||
        IsEqualToken(*ppszToken, pszTokenEnd, szFalse)) {
        bValue = FALSE;
    }
    else
        return ResultFromScode(MK_E_SYNTAX);

    if (pfOut != NULL)
        *pfOut = bValue;

    *ppszToken = pszTokenEnd;
    SkipWhitespace(ppszToken);

    return NOERROR;
}


/* GetQuotedToken(&pszThisToken, &pszQuotedToken)
 *
 * Sets pszQuotedToken to point to the contents of the doublequotes.
 * pszQuotedToken may be NULL if the caller just wants to eat the token.
 * Sets pszThisToken to point to the first character after the closing
 *   doublequote.
 * Fails if pszThisToken doesn't start with a doublequote or doesn't
 *   contain a closing doublequote.
 * The closing doublequote is replaced with a null terminator, iff the
 *   function does not fail.
 */
HRESULT GetQuotedToken(LPSTR *ppszThisToken, LPSTR *ppszQuotedToken)
{
    HRESULT hres = ResultFromScode(MK_E_SYNTAX);

    LPSTR pszStart = *ppszThisToken;
    if (*pszStart != '\"')
        return hres;

    pszStart++;
    LPSTR pszEndQuote = strchrf(pszStart, '\"');
    if (pszEndQuote == NULL)
        return hres;

    *pszEndQuote = '\0';
    if (ppszQuotedToken != NULL)
        *ppszQuotedToken = pszStart;
    *ppszThisToken = pszEndQuote+1;

    return NOERROR;
}


BOOL IsEqualToken(LPCSTR pszTokenStart, LPCSTR pszTokenEnd, LPCSTR pszTokenToMatch)
{
    UINT cbToken = strlenf(pszTokenToMatch);

    if (cbToken != (UINT)(pszTokenEnd - pszTokenStart) || strnicmpf(pszTokenStart, pszTokenToMatch, cbToken))
        return FALSE;

    return TRUE;
}


/* ParseLiteralToken(ppsz, pszToken) tries to match *ppsz against pszToken.
 * If they don't match, an error is returned.  If they do match, then *ppsz
 * is advanced past the token and any following whitespace.
 *
 * If ppszInvalid is NULL, then the function is non-destructive in the error
 * path, so it's OK to call ParseLiteralToken just to see if a possible literal
 * token is what's next; if the token isn't found, whatever was there didn't
 * get eaten or anything.
 *
 * If ppszInvalid is not NULL, then if the token doesn't match, *ppszInvalid
 * will be set to *ppsz.
 */
HRESULT ParseLiteralToken(LPSTR *ppsz, LPCSTR pszToken, LPCSTR *ppszInvalid)
{
    LPSTR pszTokenEnd = FindTokenEnd(*ppsz);

    if (!IsEqualToken(*ppsz, pszTokenEnd, pszToken)) {
        if (ppszInvalid != NULL)
            *ppszInvalid = *ppsz;
        return ResultFromScode(MK_E_SYNTAX);
    }

    *ppsz = pszTokenEnd;

    SkipWhitespace(ppsz);

    return NOERROR;
}


/* ParseNumber parses a numeric token at the specified position.  If the
 * number makes sense, the pointer is advanced to the end of the number
 * and past any following whitespace, and the numeric value is returned
 * in *pnOut.  Any non-numeric characters are considered to terminate the
 * number without error;  it is assumed that higher-level parsing code
 * will eventually reject such characters if they're not supposed to be
 * there.
 *
 * pnOut may be NULL if the caller doesn't care about the number being
 * returned and just wants to eat it.
 *
 * Floating point numbers of the form nnn.nnn are rounded to the next
 * higher integer and returned as such.
 */
HRESULT ParseNumber(LPSTR *ppszNumber, INT *pnOut)
{
    HRESULT hres = ResultFromScode(MK_E_SYNTAX);
    BOOL fNegative = FALSE;
    INT nAccum = 0;
    BOOL fNonZeroDecimal = FALSE;
    BOOL fInDecimal = FALSE;
    BOOL fFoundDigits = FALSE;

    LPSTR pszCurrent = *ppszNumber;

    /* Handle one sign character. */
    if (*pszCurrent == '+') {
        pszCurrent++;
    }
    else if (*pszCurrent == '-') {
        pszCurrent++;
        fNegative = TRUE;
    }

    for (;;) {
        if (*pszCurrent == '.') {
            fInDecimal = TRUE;
        }
        else if (*pszCurrent >= '0' && *pszCurrent <= '9') {
            fFoundDigits = TRUE;
            if (fInDecimal) {
                if (*pszCurrent > '0') {
                    fNonZeroDecimal = TRUE;
                }
            }
            else {
                nAccum = nAccum * 10 + (*pszCurrent - '0');
            }
        }
        else
            break;

        pszCurrent++;
    }

    if (fFoundDigits) {
        hres = NOERROR;
        if (fNonZeroDecimal)
            nAccum++;           /* round away from zero if decimal present */
        if (fNegative)
            nAccum = -nAccum;
    }

    if (SUCCEEDED(hres)) {
        if (pnOut != NULL)
            *pnOut = nAccum;
        *ppszNumber = pszCurrent;
        SkipWhitespace(ppszNumber);
    }

    return hres;
}

HRESULT ParsePseudoFloat(LPSTR *ppszNumber, INT *pnOut)
{
    HRESULT hres = ResultFromScode(MK_E_SYNTAX);
    INT val1, val2;
    BOOL fInDecimal = FALSE;
    CHAR achBuffer[ 256 ];      // ugly

    LPSTR pszCurrent = *ppszNumber;

    *achBuffer = '\0';

    /* Handle one sign character. */
    if (*pszCurrent == '+') {
        pszCurrent++;
    }
    else if (*pszCurrent == '-') {
        strcatf( achBuffer, "-" );
        pszCurrent++;
    }

    for (;;) {
        if (*pszCurrent == '.') {
            if ( fInDecimal ) break;
            fInDecimal = TRUE;
            strcatf( achBuffer, "." );
        }
        else if (*pszCurrent >= '0' && *pszCurrent <= '9') {
            CHAR achFoo[ 2 ] = { '\0', '\0' };
            achFoo[ 0 ] = *pszCurrent;
            strcatf( achBuffer, achFoo );
        }
        else
            break;

        pszCurrent++;
    }

    if ( !fInDecimal )
    {
        strcatf( achBuffer, ".0" );
    }

    if ( sscanf( achBuffer, "%d.%d", &val1, &val2 ) == 2 )
    {
        hres = NOERROR;
    }

    if (SUCCEEDED(hres)) {
        if (pnOut != NULL)
            *pnOut = ( ( val1 << 16 ) & 0xFFFF0000 ) | ( val2 & 0x0000FFFF );
        *ppszNumber = pszCurrent;
        SkipWhitespace(ppszNumber);
    }

    return hres;
}

const char szPicsVersionLabel[] = "PICS-";
const UINT cchLabel = (sizeof(szPicsVersionLabel)-1) / sizeof(szPicsVersionLabel[0]);

/* Returns a pointer to the closing doublequote of a quoted string, counting
 * linefeeds as we go.  Returns NULL if no closing doublequote found.
 */
LPSTR RatFileParser::EatQuotedString(LPSTR pIn)
{
    LPSTR pszQuote = strchrf(pIn, '\"');
    if (pszQuote == NULL)
        return NULL;

    pIn = strchrf(pIn, '\n');
    while (pIn != NULL && pIn < pszQuote) {
        m_nLine++;
        pIn = strchrf(pIn+1, '\n');
    }

    return pszQuote;
}

/***************************************************************************
    Member functions for ET* classes
***************************************************************************/

/* ETN */
#ifdef DEBUG
void  ETN::Set(int rIn){
    Init();
    r = rIn;
}
int ETN::Get(){
    assert(fIsInit());
    return r;
}
#endif

ETN* ETN::Duplicate(){
    ETN *pETN=new ETN;
    if (fIsInit()) pETN->Set(Get());
    return pETN;
}

/* ETB */
#ifdef DEBUG
BOOL ETB::Get()
{
    assert(fIsInit());
    return m_nFlags & ETB_VALUE;
}

void ETB::Set(BOOL b)
{
    m_nFlags = ETB_ISINIT | (b ? ETB_VALUE : 0);
}
#endif

ETB* ETB::Duplicate()
{
    assert(fIsInit());

    ETB *pETB = new ETB;
    if (pETB != NULL)
        pETB->m_nFlags = m_nFlags;
    return pETB;
}

/* ETS */

ETS::~ETS()
{
    if (pc != NULL) {
        delete pc;
        pc = NULL;
    }
}

#ifdef DEBUG
char* ETS::Get()
{
    assert(fIsInit());
    return pc;
}
#endif

void ETS::Set(const char *pIn)
{
    if (pc != NULL)
        delete pc;

    if (pIn != NULL) {
        pc = new char[strlenf(pIn) + 1];
        if (pc != NULL) {
            strcpyf(pc, pIn);
        }
    }
    else {
        pc = NULL;
    }
}


void ETS::SetTo(char *pIn)
{
    if (pc != NULL)
        delete pc;

    pc = pIn;
}


ETS* ETS::Duplicate()
{
    ETS *pETS=new ETS;
    if (pETS != NULL)
        pETS->Set(Get());
    return pETS;
}

/***************************************************************************
    Worker functions for inheriting category properties and other
    miscellaneous category stuff.
***************************************************************************/

HRESULT PicsCategory::InitializeMyDefaults(PicsCategory *pCategory)
    {
    if (!pCategory->etnMin.fIsInit()      && etnMin.fIsInit())
        pCategory->etnMin.Set(etnMin.Get());

    if (!pCategory->etnMax.fIsInit()      && etnMax.fIsInit())
        pCategory->etnMax.Set(etnMax.Get());

    if (!pCategory->etfMulti.fIsInit()    && etfMulti.fIsInit())
        pCategory->etfMulti.Set(etfMulti.Get());

    if (!pCategory->etfInteger.fIsInit()  && etfInteger.fIsInit())
        pCategory->etfInteger.Set(etfInteger.Get());

    if (!pCategory->etfLabelled.fIsInit() && etfLabelled.fIsInit())
        pCategory->etfLabelled.Set(etfLabelled.Get());

    if (!pCategory->etfUnordered.fIsInit() && etfUnordered.fIsInit())
        pCategory->etfUnordered.Set(etfUnordered.Get());

    return NOERROR;
    }


HRESULT PicsRatingSystem::InitializeMyDefaults(PicsCategory *pCategory)
{
    if (m_pDefaultOptions != NULL)
        return m_pDefaultOptions->InitializeMyDefaults(pCategory);

    return NOERROR;             /* no defaults to initialize */
}


HRESULT PicsDefault::InitializeMyDefaults(PicsCategory *pCategory)
{
    if (!pCategory->etnMin.fIsInit()      && etnMin.fIsInit())
        pCategory->etnMin.Set(etnMin.Get());

    if (!pCategory->etnMax.fIsInit()      && etnMax.fIsInit())
        pCategory->etnMax.Set(etnMax.Get());

    if (!pCategory->etfMulti.fIsInit()    && etfMulti.fIsInit())
        pCategory->etfMulti.Set(etfMulti.Get());

    if (!pCategory->etfInteger.fIsInit()  && etfInteger.fIsInit())
        pCategory->etfInteger.Set(etfInteger.Get());

    if (!pCategory->etfLabelled.fIsInit() && etfLabelled.fIsInit())
        pCategory->etfLabelled.Set(etfLabelled.Get());

    if (!pCategory->etfUnordered.fIsInit() && etfUnordered.fIsInit())
        pCategory->etfUnordered.Set(etfUnordered.Get());

    return NOERROR;
}


HRESULT PicsEnum::InitializeMyDefaults(PicsCategory *pCategory)
{
    return E_NOTIMPL;       /* should never have a category inherit from an enum */
}


PicsExtension::PicsExtension()
    : m_pszRatingBureau(NULL)
{
    /* nothing else */
}


PicsExtension::~PicsExtension()
{
    delete m_pszRatingBureau;
}


HRESULT PicsExtension::InitializeMyDefaults(PicsCategory *pCategory)
{
    return E_NOTIMPL;       /* should never have a category inherit from an extension */
}


void PicsCategory::FixupLimits()
{
    BOOL fLabelled = (etfLabelled.fIsInit() && etfLabelled.Get());

    /*fix up max and min values*/
    if (fLabelled ||
        (arrpPE.Length()>0 && (!etnMax.fIsInit() || !etnMax.fIsInit())))
    {
        if (arrpPE.Length() > 0)
        {
            if (!etnMax.fIsInit())
                etnMax.Set(N_INFINITY);
            if (!etnMin.fIsInit())
                etnMin.Set(P_INFINITY);
            for (int z=0;z<arrpPE.Length();++z)
            {
                if (arrpPE[z]->etnValue.Get() > etnMax.Get()) etnMax.Set(arrpPE[z]->etnValue.Get());
                if (arrpPE[z]->etnValue.Get() < etnMin.Get()) etnMin.Set(arrpPE[z]->etnValue.Get());
            }
        }
        else {
            etfLabelled.Set(FALSE); /* no enum labels?  better not have labelled flag then */
            fLabelled = FALSE;
        }
    }

    /*sort labels by value*/
    if (fLabelled)
    {
        int x,y;
        PicsEnum *pPE;
        for (x=0;x<arrpPE.Length()-1;++x){
            for (y=x+1;y<arrpPE.Length();++y){
                if (arrpPE[y]->etnValue.Get() < arrpPE[x]->etnValue.Get()){
                    pPE = arrpPE[x];
                    arrpPE[x] = arrpPE[y];
                    arrpPE[y] = pPE;
                }
            }
        }
    }
}


void PicsCategory::SetParents(PicsRatingSystem *pOwner)
{
    pPRS = pOwner;
    UINT cSubCategories = arrpPC.Length();
    for (UINT i = 0; i < cSubCategories; i++) {
        InitializeMyDefaults(arrpPC[i]);    /* subcategory inherits our defaults */
        arrpPC[i]->SetParents(pOwner);      /* process all subcategories */
    }
    FixupLimits();      /* inheritance is done, make sure limits make sense */
}


/***************************************************************************
    Handler functions which know how to parse the various kinds of content
    which can occur within a parenthesized object.
***************************************************************************/

HRESULT RatParseString(LPSTR *ppszIn, LPVOID *ppOut, RatFileParser *pParser)
{
    *ppOut = NULL;

    LPSTR pszCurrent = *ppszIn;

    if (*pszCurrent != '\"')
        return RAT_E_EXPECTEDSTRING;

    pszCurrent++;

    LPSTR pszEnd = pParser->EatQuotedString(pszCurrent);
    if (pszEnd == NULL)
        return RAT_E_EXPECTEDSTRING;

    UINT cbString = DIFF(pszEnd - pszCurrent);
    LPSTR pszNew = new char[cbString + 1];
    if (pszNew == NULL)
        return E_OUTOFMEMORY;

    memcpyf(pszNew, pszCurrent, cbString);
    pszNew[cbString] = '\0';

    *ppOut = (LPVOID)pszNew;
    *ppszIn = pParser->FindNonWhite(pszEnd + 1);

    return NOERROR;
}


HRESULT RatParseNumber(LPSTR *ppszIn, LPVOID *ppOut, RatFileParser *pParser)
{
    int n;

    LPSTR pszCurrent = *ppszIn;
    HRESULT hres = ::ParseNumber(&pszCurrent, &n);

    if (FAILED(hres))
        return RAT_E_EXPECTEDNUMBER;

    *(int *)ppOut = n;

    LPSTR pszNewline = strchrf(*ppszIn, '\n');
    while (pszNewline != NULL && pszNewline < pszCurrent) {
        pParser->m_nLine++;
        pszNewline = strchrf(pszNewline+1, '\n');
    }
    *ppszIn = pszCurrent;

    return NOERROR;
}

HRESULT RatParsePseudoFloat(LPSTR *ppszIn, LPVOID *ppOut, RatFileParser *pParser)
{
    INT n;

    LPSTR pszCurrent = *ppszIn;
    HRESULT hres = ::ParsePseudoFloat(&pszCurrent, &n);

    if (FAILED(hres))
        return RAT_E_EXPECTEDNUMBER;

    *(INT *)ppOut = n;

    LPSTR pszNewline = strchrf(*ppszIn, '\n');
    while (pszNewline != NULL && pszNewline < pszCurrent) {
        pParser->m_nLine++;
        pszNewline = strchrf(pszNewline+1, '\n');
    }
    *ppszIn = pszCurrent;

    return NOERROR;
}

HRESULT RatParseBool(LPSTR *ppszIn, LPVOID *ppOut, RatFileParser *pParser)
{
    BOOL b;

    /* PICS spec allows a terse way of specifying a TRUE boolean -- leaving
     * out the value entirely.  In a .RAT file, the result looks like
     *
     * (unordered)
     * (multivalue)
     *
     * and so on.  Called has pointed us at non-whitespace, so if we see
     * a closing paren, we know the .RAT file author used this syntax.
     */
    if (**ppszIn == ')') {
        b = TRUE;
    }
    else {
        LPSTR pszCurrent = *ppszIn;
        HRESULT hres = ::GetBool(&pszCurrent, &b);

        if (FAILED(hres))
            return RAT_E_EXPECTEDBOOL;

        LPSTR pszNewline = strchrf(*ppszIn, '\n');
        while (pszNewline != NULL && pszNewline < pszCurrent) {
            pParser->m_nLine++;
            pszNewline = strchrf(pszNewline+1, '\n');
        }
        *ppszIn = pszCurrent;
    }

    *(LPBOOL)ppOut = b;

    return NOERROR;
}


AllowableOption aaoPicsCategory[] = {
    { ROID_TRANSMITAS, AO_SINGLE | AO_MANDATORY },
    { ROID_NAME, AO_SINGLE },
    { ROID_DESCRIPTION, AO_SINGLE },
    { ROID_ICON, AO_SINGLE },
    { ROID_EXTENSION, 0 },
    { ROID_INTEGER, AO_SINGLE },
    { ROID_LABELONLY, AO_SINGLE },
    { ROID_MIN, AO_SINGLE },
    { ROID_MAX, AO_SINGLE },
    { ROID_MULTIVALUE, AO_SINGLE },
    { ROID_UNORDERED, AO_SINGLE },
    { ROID_LABEL, 0 },
    { ROID_CATEGORY, 0 },
    { ROID_INVALID, 0 }
};
const UINT caoPicsCategory = sizeof(aaoPicsCategory) / sizeof(aaoPicsCategory[0]);

HRESULT RatParseCategory(LPSTR *ppszIn, LPVOID *ppOut, RatFileParser *pParser)
{
    /* We must make a copy of the allowable options array because the
     * parser will fiddle with the flags in the entries -- specifically,
     * setting AO_SEEN.  It wouldn't be thread-safe to do this to a
     * static array.
     */
    AllowableOption aao[caoPicsCategory];

    ::memcpyf(aao, ::aaoPicsCategory, sizeof(aao));

    PicsCategory *pCategory = new PicsCategory;
    if (pCategory == NULL)
        return E_OUTOFMEMORY;

    HRESULT hres = pParser->ParseParenthesizedObject(
                        ppszIn,                 /* var containing current ptr */
                        aao,                    /* what's legal in this object */
                        pCategory);             /* object to add items back to */

    if (FAILED(hres)) {
        delete pCategory;
        return hres;
    }

    *ppOut = (LPVOID)pCategory;
    return NOERROR;
}


AllowableOption aaoPicsEnum[] = {
    { ROID_NAME, AO_SINGLE },
    { ROID_DESCRIPTION, AO_SINGLE },
    { ROID_VALUE, AO_SINGLE | AO_MANDATORY },
    { ROID_ICON, AO_SINGLE },
    { ROID_INVALID, 0 }
};
const UINT caoPicsEnum = sizeof(aaoPicsEnum) / sizeof(aaoPicsEnum[0]);

HRESULT RatParseLabel(LPSTR *ppszIn, LPVOID *ppOut, RatFileParser *pParser)
{
    /* We must make a copy of the allowable options array because the
     * parser will fiddle with the flags in the entries -- specifically,
     * setting AO_SEEN.  It wouldn't be thread-safe to do this to a
     * static array.
     */
    AllowableOption aao[caoPicsEnum];

    ::memcpyf(aao, ::aaoPicsEnum, sizeof(aao));

    PicsEnum *pEnum = new PicsEnum;
    if (pEnum == NULL)
        return E_OUTOFMEMORY;

    HRESULT hres = pParser->ParseParenthesizedObject(
                        ppszIn,                 /* var containing current ptr */
                        aao,                    /* what's legal in this object */
                        pEnum);                 /* object to add items back to */

    if (FAILED(hres)) {
        delete pEnum;
        return hres;
    }

    *ppOut = (LPVOID)pEnum;
    return NOERROR;
}


AllowableOption aaoPicsDefault[] = {
    { ROID_EXTENSION, 0 },
    { ROID_INTEGER, AO_SINGLE },
    { ROID_LABELONLY, AO_SINGLE },
    { ROID_MAX, AO_SINGLE },
    { ROID_MIN, AO_SINGLE },
    { ROID_MULTIVALUE, AO_SINGLE },
    { ROID_UNORDERED, AO_SINGLE },
    { ROID_INVALID, 0 }
};
const UINT caoPicsDefault = sizeof(aaoPicsDefault) / sizeof(aaoPicsDefault[0]);

HRESULT RatParseDefault(LPSTR *ppszIn, LPVOID *ppOut, RatFileParser *pParser)
{
    /* We must make a copy of the allowable options array because the
     * parser will fiddle with the flags in the entries -- specifically,
     * setting AO_SEEN.  It wouldn't be thread-safe to do this to a
     * static array.
     */
    AllowableOption aao[caoPicsDefault];

    ::memcpyf(aao, ::aaoPicsDefault, sizeof(aao));

    PicsDefault *pDefault = new PicsDefault;
    if (pDefault == NULL)
        return E_OUTOFMEMORY;

    HRESULT hres = pParser->ParseParenthesizedObject(
                        ppszIn,                 /* var containing current ptr */
                        aao,                    /* what's legal in this object */
                        pDefault);              /* object to add items back to */

    if (FAILED(hres)) {
        delete pDefault;
        return hres;
    }

    *ppOut = (LPVOID)pDefault;
    return NOERROR;
}


AllowableOption aaoPicsExtension[] = {
    { ROID_MANDATORY, AO_SINGLE },
    { ROID_OPTIONAL, AO_SINGLE },
    { ROID_INVALID, 0 }
};
const UINT caoPicsExtension = sizeof(aaoPicsExtension) / sizeof(aaoPicsExtension[0]);

HRESULT RatParseExtension(LPSTR *ppszIn, LPVOID *ppOut, RatFileParser *pParser)
{
    /* We must make a copy of the allowable options array because the
     * parser will fiddle with the flags in the entries -- specifically,
     * setting AO_SEEN.  It wouldn't be thread-safe to do this to a
     * static array.
     */
    AllowableOption aao[caoPicsExtension];

    ::memcpyf(aao, ::aaoPicsExtension, sizeof(aao));

    PicsExtension *pExtension = new PicsExtension;
    if (pExtension == NULL)
        return E_OUTOFMEMORY;

    HRESULT hres = pParser->ParseParenthesizedObject(
                        ppszIn,                 /* var containing current ptr */
                        aao,                    /* what's legal in this object */
                        pExtension);            /* object to add items back to */

    if (FAILED(hres)) {
        delete pExtension;
        return hres;
    }

    *ppOut = (LPVOID)pExtension;
    return NOERROR;
}


/* Since the only extension we support right now is the one for a label
 * bureau, we just return the first quoted string we find if the caller
 * wants it.  If ppOut is NULL, then it's some other extension and the
 * caller doesn't care about the data, he just wants it eaten.
 */
HRESULT ParseRatExtensionData(LPSTR *ppszIn, RatFileParser *pParser, LPSTR *ppOut)
{
    HRESULT hres = NOERROR;

    LPSTR pszCurrent = *ppszIn;

    /* Must look for closing ')' ourselves to terminate */
    while (*pszCurrent != ')') {
        if (*pszCurrent == '(') {
            pszCurrent = pParser->FindNonWhite(pszCurrent+1);       /* skip paren and whitespace */
            hres = ParseRatExtensionData(&pszCurrent, pParser, ppOut);  /* parentheses contain data */
            if (FAILED(hres))
                return hres;
            if (*pszCurrent != ')')
                return RAT_E_EXPECTEDRIGHT;

            pszCurrent = pParser->FindNonWhite(pszCurrent+1);   /* skip close ) and whitespace */
        }
        else if (*pszCurrent == '\"') {             /* should be just a quoted string */
            if (ppOut != NULL && *ppOut == NULL) {
                hres = RatParseString(&pszCurrent, (LPVOID *)ppOut, pParser);
            }
            else {
                ++pszCurrent;
                LPSTR pszEndQuote = pParser->EatQuotedString(pszCurrent);
                if (pszEndQuote == NULL)
                    return RAT_E_EXPECTEDSTRING;
                pszCurrent = pParser->FindNonWhite(pszEndQuote+1);  /* skip close " and whitespace */
            }
        }
        else
            return RAT_E_UNKNOWNITEM;               /* general bad syntax */
    }

    /* Caller will skip over final ')' for us. */

    *ppszIn = pszCurrent;

    return NOERROR;
}


HRESULT RatParseMandatory(LPSTR *ppszIn, LPVOID *ppOut, RatFileParser *pParser)
{
    LPSTR pszCurrent = *ppszIn;

    /* First thing better be a quoted URL identifying the extension. */
    if (*pszCurrent != '\"')
        return RAT_E_EXPECTEDSTRING;

    pszCurrent++;
    LPSTR pszEnd = pParser->EatQuotedString(pszCurrent);
    if (pszCurrent == NULL)
        return RAT_E_EXPECTEDSTRING;            /* missing closing " */

    /* See if it's the extension for a label bureau. */

    LPSTR pszBureau = NULL;
    LPSTR *ppData = NULL;
    if (IsEqualToken(pszCurrent, pszEnd, ::szRatingBureauExtension)) {
        ppData = &pszBureau;
    }

    pszCurrent = pParser->FindNonWhite(pszEnd+1);       /* skip closing " and whitespace */

    HRESULT hres = ParseRatExtensionData(&pszCurrent, pParser, ppData);
    if (FAILED(hres))
        return hres;

    *ppOut = pszBureau;     /* return label bureau string if that's what we found */
    *ppszIn = pszCurrent;

    if (ppData == NULL)
        return RAT_E_UNKNOWNMANDATORY;      /* we didn't recognize it */
    else
        return NOERROR;
}


/* RatParseOptional uses the code in RatParseMandatory to parse the extension
 * data, in case an extension that should be optional comes in as mandatory.
 * We then detect RatParseMandatory rejecting the thing as unrecognized and
 * allow it through, since here it's optional.
 */
HRESULT RatParseOptional(LPSTR *ppszIn, LPVOID *ppOut, RatFileParser *pParser)
{
    HRESULT hres = RatParseMandatory(ppszIn, ppOut, pParser);
    if (hres == RAT_E_UNKNOWNMANDATORY)
        hres = S_OK;

    return hres;
}


/***************************************************************************
    Code to identify the opening keyword of a parenthesized object and
    associate it with content.
***************************************************************************/

/* The following array is indexed by RatObjectID values. */
struct {
    LPCSTR pszToken;            /* token by which we identify it */
    RatObjectHandler pHandler;  /* function which parses the object's contents */
} aObjectDescriptions[] = {
    { szNULL, NULL },
    { NULL, NULL },             /* placeholder for comparing against no token */
    { szPicsVersion, RatParsePseudoFloat },
    { szRatingSystem, RatParseString },
    { szRatingService, RatParseString },
    { szRatingBureau, RatParseString },
    { szBureauRequired, RatParseBool },
    { szCategory, RatParseCategory },
    { szTransmitAs, RatParseString },
    { szLabel, RatParseLabel },
    { szValue, RatParseNumber },
    { szDefault, RatParseDefault },
    { szDescription, RatParseString },
    { szExtensionOption, RatParseExtension },
    { szMandatory, RatParseMandatory },
    { szOptional, RatParseOptional },
    { szIcon, RatParseString },
    { szInteger, RatParseBool },
    { szLabelOnly, RatParseBool },
    { szMax, RatParseNumber },
    { szMin, RatParseNumber },
    { szMultiValue, RatParseBool },
    { szName, RatParseString },
    { szUnordered, RatParseBool }
};


/* ParseToOpening eats the opening '(' of a parenthesized object, and
 * verifies that the token just inside it is one of the expected ones.
 * If so, *ppIn is advanced past that token to the next non-whitespace
 * character;  otherwise, an error is returned.
 *
 * For example, if *ppIn is pointing at "(PICS-version 1.1)", and
 * ROID_PICSVERSION is in the allowable option table supplied, then
 * NOERROR is returned and *ppIn will point at "1.1)".
 *
 * If the function is successful, *ppFound is set to point to the element
 * in the allowable-options table which matches the type of thing this
 * object actually is.
 */
HRESULT RatFileParser::ParseToOpening(LPSTR *ppIn, AllowableOption *paoExpected,
                                      AllowableOption **ppFound)
{
    LPSTR pszCurrent = *ppIn;

    pszCurrent = FindNonWhite(pszCurrent);
    if (*pszCurrent != '(')
        return RAT_E_EXPECTEDLEFT;

    pszCurrent = FindNonWhite(pszCurrent+1);    /* skip '(' and whitespace */
    LPSTR pszTokenEnd = FindTokenEnd(pszCurrent);

    for (; paoExpected->roid != ROID_INVALID; paoExpected++) {
        LPCSTR pszThisToken = aObjectDescriptions[paoExpected->roid].pszToken;

        /* Special case for beginning of RAT file structure: no token at all. */
        if (pszThisToken == NULL) {
            if (*pszCurrent == '(') {
                *ppIn = pszCurrent;
                *ppFound = paoExpected;
                return NOERROR;
            }
            else {
                return RAT_E_EXPECTEDLEFT;
            }
        }
        else if (IsEqualToken(pszCurrent, pszTokenEnd, pszThisToken))
            break;

    }

    if (paoExpected->roid != ROID_INVALID) {
        *ppIn = FindNonWhite(pszTokenEnd);  /* skip token and whitespace */
        *ppFound = paoExpected;
        return NOERROR;
    }
    else
        return RAT_E_UNKNOWNITEM;
}


/***************************************************************************
    The top-level entrypoint for parsing out a whole rating system.
***************************************************************************/

AllowableOption aaoPicsRatingSystem[] = {
    { ROID_PICSVERSION, AO_SINGLE | AO_MANDATORY },
    { ROID_RATINGSYSTEM, AO_SINGLE | AO_MANDATORY },
    { ROID_RATINGSERVICE, AO_SINGLE | AO_MANDATORY },
    { ROID_RATINGBUREAU, AO_SINGLE },
    { ROID_BUREAUREQUIRED, AO_SINGLE },
    { ROID_DEFAULT, 0 },
    { ROID_DESCRIPTION, AO_SINGLE },
    { ROID_EXTENSION, 0 },
    { ROID_ICON, AO_SINGLE },
    { ROID_NAME, AO_SINGLE },
    { ROID_CATEGORY, AO_MANDATORY },
    { ROID_INVALID, 0 }
};
const UINT caoPicsRatingSystem = sizeof(aaoPicsRatingSystem) / sizeof(aaoPicsRatingSystem[0]);

HRESULT PicsRatingSystem::Parse(LPSTR pIn)
{
    /* This guy is small enough to just init directly on the stack */
    AllowableOption aaoRoot[] = { { ROID_PICSDOCUMENT, 0 }, { ROID_INVALID, 0 } };
    AllowableOption aao[caoPicsRatingSystem];

    ::memcpyf(aao, ::aaoPicsRatingSystem, sizeof(aao));

    AllowableOption *pFound;

    RatFileParser parser;

    HRESULT hres = parser.ParseToOpening(&pIn, aaoRoot, &pFound);
    if (FAILED(hres))
        return hres;                        /* some error early on */

    hres = parser.ParseParenthesizedObject(
                        &pIn,                   /* var containing current ptr */
                        aao,                    /* what's legal in this object */
                        this);                  /* object to add items back to */

    if (FAILED(hres))
        nErrLine = parser.m_nLine;

    return hres;
}


/***************************************************************************
    Callbacks into the various class objects to add parsed properties.
***************************************************************************/

HRESULT PicsRatingSystem::AddItem(RatObjectID roid, LPVOID pData)
{
    HRESULT hres = S_OK;

    switch (roid) {
    case ROID_PICSVERSION:
        etnPicsVersion.Set((INT_PTR)pData);
        break;

    case ROID_RATINGSYSTEM:
        etstrRatingSystem.SetTo((LPSTR)pData);
        break;

    case ROID_RATINGSERVICE:
        etstrRatingService.SetTo((LPSTR)pData);
        break;

    case ROID_RATINGBUREAU:
        etstrRatingBureau.SetTo((LPSTR)pData);
        break;

    case ROID_BUREAUREQUIRED:
        etbBureauRequired.Set((INT_PTR)pData);
        break;

    case ROID_DEFAULT:
        m_pDefaultOptions = (PicsDefault *)pData;
        break;

    case ROID_DESCRIPTION:
        etstrDesc.SetTo((LPSTR)pData);
        break;

    case ROID_EXTENSION:
        {
            /* just eat extensions for now */
            PicsExtension *pExtension = (PicsExtension *)pData;
            if (pExtension != NULL) {
                /* If this is a rating bureau extension, take his bureau
                 * string and store it in this PicsRatingSystem.  We now
                 * own the memory, so NULL out the extension's pointer to
                 * it so he won't delete it.
                 */
                if (pExtension->m_pszRatingBureau != NULL) {
                    etstrRatingBureau.SetTo(pExtension->m_pszRatingBureau);
                    pExtension->m_pszRatingBureau = NULL;
                }
                delete pExtension;
            }
        }
        break;

    case ROID_ICON:
        etstrIcon.SetTo((LPSTR)pData);
        break;

    case ROID_NAME:
        etstrName.SetTo((LPSTR)pData);
        break;

    case ROID_CATEGORY:
        {
            PicsCategory *pCategory = (PicsCategory *)pData;
            hres = arrpPC.Append(pCategory) ? S_OK : E_OUTOFMEMORY;
            if (FAILED(hres)) {
                delete pCategory;
            }
            else {
                InitializeMyDefaults(pCategory);    /* category inherits default settings */
                pCategory->SetParents(this);    /* set pPRS fields in whole tree */
            }
        }
        break;

    default:
        assert(FALSE);  /* shouldn't have been given a ROID that wasn't in
                         * the table we passed to the parser! */
        hres = E_UNEXPECTED;
        break;
    }

    return hres;
}

void PicsRatingSystem::Dump( void )
{
    fprintf( stdout,
             "Rating system: %s\n"
             "Version: %d.%d\n"
             "Rating Service: %s\n"
             "Rating bureau: %s\n"
             "Bureau required: %s\n"
             "Description: %s\n"
             "Icon: %s\n"
             "Name: %s\n"
             "Number of categories: %d\n",
             etstrRatingSystem.Get(),
             ( etnPicsVersion.Get() & 0xFFFF0000 ) >> 16,
             etnPicsVersion.Get() & 0x0000FFFF,
             etstrRatingService.Get(),
             etstrRatingBureau.Get(),
             etbBureauRequired.Get() ? "TRUE" : "FALSE",
             etstrDesc.Get(),
             etstrIcon.Get(),
             etstrName.Get(),
             arrpPC.Length() );

    int iCounter = 0;
    for( ; iCounter < arrpPC.Length(); iCounter++ )
    {
        arrpPC[ iCounter ]->Dump();
    }
}

//---------------------------------------------------------------
// boydm
void PicsRatingSystem::OutputLabels( CString &sz, CString szURL, CString szName, CString szStart, CString szEnd )
    {
    CString szScratch;
    CString szTemp;

    INT_PTR   dwVersion = etnPicsVersion.Get();

    // start with the name, and the version number
    szTemp = szPicsOpening;
    szScratch.Format( _T("%s%d.%d"), szTemp, HIWORD(dwVersion), LOWORD(dwVersion) );
    sz += szScratch;

    // add in the URL string - surrounded by quotes and a return
    sz += _T(" \"http://www.rsac.org/ratingsv01.html\" ");

    // start the labels
    sz += szShortLabelWord;
    sz += _T(" ");

    // if it is there, add the by name string
    if ( !szName.IsEmpty() )
        {
        sz += szByOption;
        sz += _T(" \"");
        sz += szName;
        sz += _T("\" ");
        }

    // if it is there, add the start string
    if ( !szStart.IsEmpty() )
        {
        sz += szOnOption;
        sz += _T(" \"");
        sz += szStart;
        sz += _T("\" ");
        }

    // if it is there, add the expiration string
    if ( !szEnd.IsEmpty() )
        {
        sz += szExpOption;
        sz += _T(" \"");
        sz += szEnd;
        sz += _T("\" ");
        }

    // add in the categorical ratings
    DWORD   nCat = arrpPC.Length();
    sz += szShortRatings;
    sz += _T(" (");
    for ( DWORD iCat = 0; iCat < nCat; iCat++ )
        {
        arrpPC[iCat]->OutputLabel( sz );
        }
    // trim any trailing whitespace
    sz.TrimRight();
    // close with a parenthesis
    sz += _T(')');

    // end with the closing parenthesis
    sz += _T(")");
    }



//---------------------------------------------------------------
HRESULT PicsCategory::AddItem(RatObjectID roid, LPVOID pData)
{
    HRESULT hres = S_OK;

    switch (roid) {
    case ROID_TRANSMITAS:
        etstrTransmitAs.SetTo((LPSTR)pData);
        break;

    case ROID_NAME:
        etstrName.SetTo((LPSTR)pData);
        break;

    case ROID_DESCRIPTION:
        etstrDesc.SetTo((LPSTR)pData);
        break;

    case ROID_ICON:
        etstrIcon.SetTo((LPSTR)pData);
        break;

    case ROID_EXTENSION:
        {           /* we support no extensions below the rating system level */
            PicsExtension *pExtension = (PicsExtension *)pData;
            if (pExtension != NULL)
                delete pExtension;
        }
        break;

    case ROID_INTEGER:
        etfInteger.Set((INT_PTR)pData);
        break;

    case ROID_LABELONLY:
        etfLabelled.Set((INT_PTR)pData);
        break;

    case ROID_MULTIVALUE:
        etfMulti.Set((INT_PTR)pData);
        break;

    case ROID_UNORDERED:
        etfUnordered.Set((INT_PTR)pData);
        break;

    case ROID_MIN:
        etnMin.Set((INT_PTR)pData);
        break;

    case ROID_MAX:
        etnMax.Set((INT_PTR)pData);
        break;

    case ROID_LABEL:
        {
            PicsEnum *pEnum = (PicsEnum *)pData;
            hres = arrpPE.Append(pEnum) ? S_OK : E_OUTOFMEMORY;
            if (FAILED(hres))
                delete pEnum;
        }
        break;

    case ROID_CATEGORY:
        {
            PicsCategory *pCategory = (PicsCategory *)pData;

            /* For a nested category, synthesize the transmit-name from
             * ours and the child's (e.g., parent category 'color' plus
             * child category 'hue' becomes 'color/hue'.
             *
             * Note that the memory we allocate for the new name will be
             * owned by pCategory->etstrTransmitAs.  There is no memory
             * leak there.
             */
            UINT cbCombined = strlenf(etstrTransmitAs.Get()) +
                              strlenf(pCategory->etstrTransmitAs.Get()) +
                              2;        /* for PicsDelimChar + null */
            LPSTR pszTemp = new char[cbCombined];
            if (pszTemp == NULL)
                hres = E_OUTOFMEMORY;
            else {
                sprintf(pszTemp, "%s%c%s", etstrTransmitAs.Get(),
                         PicsDelimChar, pCategory->etstrTransmitAs.Get());
                pCategory->etstrTransmitAs.SetTo(pszTemp);
                hres = arrpPC.Append(pCategory) ? S_OK : E_OUTOFMEMORY;
            }

            if (FAILED(hres)) {
                delete pCategory;
            }
        }
        break;

    default:
        assert(FALSE);  /* shouldn't have been given a ROID that wasn't in
                         * the table we passed to the parser! */
        hres = E_UNEXPECTED;
        break;
    }

    return hres;
}

void PicsCategory::Dump( void )
{
    fprintf( stdout,
             "  Transmit As: %s  Name: %s  Description: %s  Icon: %s\n",
             etstrTransmitAs.Get(),
             etstrName.Get(),
             etstrDesc.Get(),
             etstrIcon.Get() );

    int iCounter = 0;
    for( ; iCounter < arrpPE.Length(); iCounter++ )
    {
        arrpPE[ iCounter ]->Dump();
    }
}

//---------------------------------------------------------------
void PicsCategory::OutputLabel( CString &sz )
    {
    CString szCat;
    CString szTransmit = etstrTransmitAs.Get();
    // prepare the category string
    szCat.Format( _T("%s %d "), szTransmit, currentValue );
    sz += szCat;
    }

//---------------------------------------------------------------
BOOL PicsCategory::FSetValuePair( CHAR chCat, WORD value )
    {
    CString szCat = etstrTransmitAs.Get();

    // first check to see if this is the right category
    if ( szCat == chCat )
        {
        // success! set the value and return
        currentValue = value;
        return TRUE;
        }

    // try its categorical children
    DWORD nCat = arrpPC.Length();
    for ( DWORD iCat = 0; iCat < nCat; iCat++ )
        {
        // stop at the first successful setting
        if ( arrpPC[iCat]->FSetValuePair(chCat, value) )
            return TRUE;
        }

    // nope
    return FALSE;
    }

//---------------------------------------------------------------
HRESULT PicsEnum::AddItem(RatObjectID roid, LPVOID pData)
{
    HRESULT hres = S_OK;

    switch (roid) {
    case ROID_NAME:
        etstrName.SetTo((LPSTR)pData);
        break;

    case ROID_DESCRIPTION:
        etstrDesc.SetTo((LPSTR)pData);
        break;

    case ROID_ICON:
        etstrIcon.SetTo((LPSTR)pData);
        break;

    case ROID_VALUE:
        etnValue.Set((INT_PTR)pData);
        break;

    default:
        assert(FALSE);  /* shouldn't have been given a ROID that wasn't in
                         * the table we passed to the parser! */
        hres = E_UNEXPECTED;
        break;
    }

    return hres;
}

void PicsEnum::Dump( void )
{
    fprintf( stdout,
             "    %s %s %s %d\n",
             etstrName.Get(),
             etstrDesc.Get(),
             etstrIcon.Get(),
             etnValue.Get() );
}

HRESULT PicsDefault::AddItem(RatObjectID roid, LPVOID pData)
{
    HRESULT hres = S_OK;

    switch (roid) {
    case ROID_EXTENSION:
        {           /* we support no extensions below the rating system level */
            PicsExtension *pExtension = (PicsExtension *)pData;
            if (pExtension != NULL)
                delete pExtension;
        }
        break;

    case ROID_INTEGER:
        etfInteger.Set((INT_PTR)pData);
        break;

    case ROID_LABELONLY:
        etfLabelled.Set((INT_PTR)pData);
        break;

    case ROID_MULTIVALUE:
        etfMulti.Set((INT_PTR)pData);
        break;

    case ROID_UNORDERED:
        etfUnordered.Set((INT_PTR)pData);
        break;

    case ROID_MIN:
        etnMin.Set((INT_PTR)pData);
        break;

    case ROID_MAX:
        etnMax.Set((INT_PTR)pData);
        break;

    default:
        assert(FALSE);  /* shouldn't have been given a ROID that wasn't in
                         * the table we passed to the parser! */
        hres = E_UNEXPECTED;
        break;
    }

    return hres;
}

void PicsDefault::Dump( void )
{
    fprintf( stdout,
             "  Default?\n" );
}

HRESULT PicsExtension::AddItem(RatObjectID roid, LPVOID pData)
{
    HRESULT hres = S_OK;

    switch (roid) {
    case ROID_OPTIONAL:
    case ROID_MANDATORY:
        /* Only data we should get is a label bureau string. */
        if (pData != NULL)
            m_pszRatingBureau = (LPSTR)pData;
        break;

    default:
        assert(FALSE);  /* shouldn't have been given a ROID that wasn't in
                         * the table we passed to the parser! */
        hres = E_UNEXPECTED;
        break;
    }

    return hres;
}

void PicsExtension::Dump( void )
{
    fprintf( stdout,
             "  Extension?\n" );
}

/***************************************************************************
    The main loop of the parser.
***************************************************************************/

/* ParseParenthesizedObjectContents is called with a text pointer pointing at
 * the first non-whitespace thing following the token identifying the type of
 * object.  It parses the rest of the contents of the object, up to and
 * including the ')' which closes it.  The array of AllowableOption structures
 * specifies which understood options are allowed to occur within this object.
 */
HRESULT RatFileParser::ParseParenthesizedObject(
    LPSTR *ppIn,                    /* where we are in the text stream */
    AllowableOption aao[],          /* allowable things inside this object */
    PicsObjectBase *pObject         /* object to set parameters into */
)
{
    HRESULT hres = S_OK;

    LPSTR pszCurrent = *ppIn;
    AllowableOption *pFound;

    for (pFound = aao; pFound->roid != ROID_INVALID; pFound++) {
        pFound->fdwOptions &= ~AO_SEEN;
    }

    pFound = NULL;

    while (*pszCurrent != ')' && *pszCurrent != '\0' && SUCCEEDED(hres)) {
        hres = ParseToOpening(&pszCurrent, aao, &pFound);
        if (SUCCEEDED(hres)) {
            LPVOID pData;
            hres = (*(aObjectDescriptions[pFound->roid].pHandler))(&pszCurrent, &pData, this);
            if (SUCCEEDED(hres)) {
                if ((pFound->fdwOptions & (AO_SINGLE | AO_SEEN)) == (AO_SINGLE | AO_SEEN))
                    hres = RAT_E_DUPLICATEITEM;
                else {
                    pFound->fdwOptions |= AO_SEEN;
                    hres = pObject->AddItem(pFound->roid, pData);
                    if (SUCCEEDED(hres)) {
                        if (*pszCurrent != ')')
                            hres = RAT_E_EXPECTEDRIGHT;
                        else
                            pszCurrent = FindNonWhite(pszCurrent+1);
                    }
                }
            }
        }
    }

    if (FAILED(hres))
        return hres;

    for (pFound = aao; pFound->roid != ROID_INVALID; pFound++) {
        if ((pFound->fdwOptions & (AO_MANDATORY | AO_SEEN)) == AO_MANDATORY)
            return RAT_E_MISSINGITEM;       /* mandatory item not found */
    }

    *ppIn = pszCurrent;

    return hres;
}


/*
int __cdecl main(int argc, char **argv)
{
    PicsRatingSystem            Rating;
    HANDLE                      hFile;
    HANDLE                      hFileMapping;
    VOID *                      pMem;

    assert( argc > 1 );

    hFile = CreateFile( argv[ 1 ],
                        GENERIC_READ,
                        0,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL );

    if ( hFile == INVALID_HANDLE_VALUE )
    {
        fprintf( stderr, "Error opening file %s\n", argv[ 1 ] );
        return 1;
    }

    hFileMapping = CreateFileMapping( hFile,
                                      NULL,
                                      PAGE_READONLY,
                                      0,
                                      0,
                                      NULL );

    if ( hFileMapping == NULL )
    {
        fprintf( stderr, "Error creating mapping for %s\n", argv[ 1 ] );
        CloseHandle( hFile );
        return 2;
    }

    pMem = MapViewOfFile( hFileMapping,
                          FILE_MAP_READ,
                          0,
                          0,
                          0 );

    if ( pMem == NULL )
    {
        fprintf( stderr, "Error mapping view to file %s\n", argv [1 ] );
        CloseHandle( hFileMapping );
        CloseHandle( hFile );
        return 3;
    }

    Rating.Parse( argv[ 1 ], (LPSTR) pMem );

    fprintf( stdout,
             "Dumping contents of RAT\n" );

    Rating.Dump();

    UnmapViewOfFile( pMem );
    CloseHandle( hFileMapping );
    CloseHandle( hFile );

    return 0;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\cnfgprts\ratsrvpg.cpp ===
// RatSrvPg.cpp : implementation file
//

#include "stdafx.h"
#include <iadmw.h>
#include "cnfgprts.h"

#include "parserat.h"
#include "RatData.h"

#include "RatSrvPg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CRatServicePage property page

IMPLEMENT_DYNCREATE(CRatServicePage, CPropertyPage)

CRatServicePage::CRatServicePage() : CPropertyPage(CRatServicePage::IDD)
{
	//{{AFX_DATA_INIT(CRatServicePage)
	m_sz_description = _T("");
	//}}AFX_DATA_INIT
}

CRatServicePage::~CRatServicePage()
{
}

void CRatServicePage::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CRatServicePage)
	DDX_Text(pDX, IDC_DESCRIPTION, m_sz_description);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CRatServicePage, CPropertyPage)
	//{{AFX_MSG_MAP(CRatServicePage)
	ON_BN_CLICKED(IDC_QUESTIONAIRE, OnQuestionaire)
	ON_BN_CLICKED(IDC_MOREINFO, OnMoreinfo)
	//}}AFX_MSG_MAP
    ON_COMMAND(ID_HELP_FINDER,  DoHelp)
    ON_COMMAND(ID_HELP,         DoHelp)
    ON_COMMAND(ID_CONTEXT_HELP, DoHelp)
    ON_COMMAND(ID_DEFAULT_HELP, DoHelp)
END_MESSAGE_MAP()

//---------------------------------------------------------------------------
void CRatServicePage::DoHelp()
    {
    WinHelp( HIDD_RATINGS_SERVICE );
    }

/////////////////////////////////////////////////////////////////////////////
// CRatServicePage message handlers

//--------------------------------------------------------------------------
void CRatServicePage::OnQuestionaire() 
    {
    // sometimes it takes a few moments of IE to get going
    CWaitCursor waitcursor;

    // get the URL of the ratings service place
    CString     szURL;
    szURL.LoadString( IDS_RATING_URL );

    // launch IE with the URL of the ratings service place
    ShellExecute(
        NULL,	// handle to parent window
        NULL,	// pointer to string that specifies operation to perform
        szURL,	// pointer to filename or folder name string
        NULL,	// pointer to string that specifies executable-file parameters 
        NULL,	// pointer to string that specifies default directory
        SW_SHOW 	// whether file is shown when opened
       );
    }

//--------------------------------------------------------------------------
void CRatServicePage::OnMoreinfo() 
    {
    // sometimes it takes a few moments of IE to get going
    CWaitCursor waitcursor;

    // if the string isn't there, fail
    if ( m_szMoreInfoURL.IsEmpty() )
        return;

    // go to the URL
    ShellExecute(
        NULL,	// handle to parent window
        NULL,	// pointer to string that specifies operation to perform
        m_szMoreInfoURL,	// pointer to filename or folder name string
        NULL,	// pointer to string that specifies executable-file parameters 
        NULL,	// pointer to string that specifies default directory
        SW_SHOW 	// whether file is shown when opened
       );
   }

//--------------------------------------------------------------------------
BOOL CRatServicePage::OnSetActive() 
    {
    UpdateData( TRUE );

    // put the proper display string into place
    m_sz_description = m_pRatData->rgbRats[m_pRatData->iRat]->etstrDesc.Get();
    // get the more info URL too
    m_szMoreInfoURL = m_pRatData->rgbRats[m_pRatData->iRat]->etstrRatingService.Get();

    UpdateData( FALSE );
    
    return CPropertyPage::OnSetActive();
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\cnfgprts\ratppg.cpp ===
// RatPpg.cpp : Implementation of the CRatPropPage property page class.

#include "stdafx.h"
#include "cnfgprts.h"
#include "RatPpg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CRatPropPage, COlePropertyPage)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CRatPropPage, COlePropertyPage)
	//{{AFX_MSG_MAP(CRatPropPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CRatPropPage, "CNFGPRTS.RatPropPage.1",
	0xba634608, 0xb771, 0x11d0, 0x92, 0x96, 0, 0xc0, 0x4f, 0xb6, 0x67, 0x8b)


/////////////////////////////////////////////////////////////////////////////
// CRatPropPage::CRatPropPageFactory::UpdateRegistry -
// Adds or removes system registry entries for CRatPropPage

BOOL CRatPropPage::CRatPropPageFactory::UpdateRegistry(BOOL bRegister)
{
	if (bRegister)
		return AfxOleRegisterPropertyPageClass(AfxGetInstanceHandle(),
			m_clsid, IDS_RAT_PPG);
	else
		return AfxOleUnregisterClass(m_clsid, NULL);
}


/////////////////////////////////////////////////////////////////////////////
// CRatPropPage::CRatPropPage - Constructor

CRatPropPage::CRatPropPage() :
	COlePropertyPage(IDD, IDS_RAT_PPG_CAPTION)
{
	//{{AFX_DATA_INIT(CRatPropPage)
	m_sz_caption = _T("");
	//}}AFX_DATA_INIT
}


/////////////////////////////////////////////////////////////////////////////
// CRatPropPage::DoDataExchange - Moves data between page and properties

void CRatPropPage::DoDataExchange(CDataExchange* pDX)
{
	//{{AFX_DATA_MAP(CRatPropPage)
	DDP_Text(pDX, IDC_CAPTIONEDIT, m_sz_caption, _T("Caption") );
	DDX_Text(pDX, IDC_CAPTIONEDIT, m_sz_caption);
	//}}AFX_DATA_MAP
	DDP_PostProcessing(pDX);
}


/////////////////////////////////////////////////////////////////////////////
// CRatPropPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\cnfgprts\ratexprd.h ===
// RatExprD.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CRatExpireDlg dialog
//{{AFX_INCLUDES()
#include "msacal70.h"
//}}AFX_INCLUDES

class CRatExpireDlg : public CDialog
{
// Construction
public:
	CRatExpireDlg(CWnd* pParent = NULL);   // standard constructor
virtual  BOOL OnInitDialog( );

    WORD    m_day;
    WORD    m_month;
    WORD    m_year;

// Dialog Data
	//{{AFX_DATA(CRatExpireDlg)
	enum { IDD = IDD_RAT_EXPIRE };
	CMsacal70	m_calendar;
	//}}AFX_DATA


// Overrides

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CRatExpireDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

    BOOL IsSystemDBCS( void );

	// Generated message map functions
	//{{AFX_MSG(CRatExpireDlg)
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\cnfgprts\ratctl.cpp ===
// RatCtl.cpp : Implementation of the CRatCtrl OLE control class.

#include "stdafx.h"
#include <iadmw.h>
#include "cnfgprts.h"
#include "RatCtl.h"
#include "RatPpg.h"

#include "parserat.h"
#include "RatData.h"
#include "RatAdvPg.h"
#include "RatGenPg.h"
#include "RatSrvPg.h"

#include "wrapmb.h"
#include <isvctrl.h>
#include <winsock2.h>


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CRatCtrl, COleControl)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CRatCtrl, COleControl)
    //{{AFX_MSG_MAP(CRatCtrl)
    //}}AFX_MSG_MAP
    ON_MESSAGE(OCM_COMMAND, OnOcmCommand)
    ON_OLEVERB(AFX_IDS_VERB_PROPERTIES, OnProperties)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Dispatch map

BEGIN_DISPATCH_MAP(CRatCtrl, COleControl)
    //{{AFX_DISPATCH_MAP(CRatCtrl)
    DISP_FUNCTION(CRatCtrl, "SetAdminTarget", SetAdminTarget, VT_EMPTY, VTS_BSTR VTS_BSTR)
    DISP_STOCKFUNC_DOCLICK()
    DISP_STOCKPROP_BORDERSTYLE()
    DISP_STOCKPROP_ENABLED()
    DISP_STOCKPROP_FONT()
    DISP_STOCKPROP_CAPTION()
    //}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()


/////////////////////////////////////////////////////////////////////////////
// Event map

BEGIN_EVENT_MAP(CRatCtrl, COleControl)
    //{{AFX_EVENT_MAP(CRatCtrl)
    EVENT_STOCK_CLICK()
    EVENT_STOCK_KEYUP()
    //}}AFX_EVENT_MAP
END_EVENT_MAP()


/////////////////////////////////////////////////////////////////////////////
// Property pages

BEGIN_PROPPAGEIDS(CRatCtrl, 2)
    PROPPAGEID(CRatPropPage::guid)
    PROPPAGEID(CLSID_CFontPropPage)
END_PROPPAGEIDS(CRatCtrl)


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CRatCtrl, "CNFGPRTS.RatCtrl.1",
    0xba634607, 0xb771, 0x11d0, 0x92, 0x96, 0, 0xc0, 0x4f, 0xb6, 0x67, 0x8b)


/////////////////////////////////////////////////////////////////////////////
// Type library ID and version

IMPLEMENT_OLETYPELIB(CRatCtrl, _tlid, _wVerMajor, _wVerMinor)


/////////////////////////////////////////////////////////////////////////////
// Interface IDs

const IID BASED_CODE IID_DRat =
        { 0xba634605, 0xb771, 0x11d0, { 0x92, 0x96, 0, 0xc0, 0x4f, 0xb6, 0x67, 0x8b } };
const IID BASED_CODE IID_DRatEvents =
        { 0xba634606, 0xb771, 0x11d0, { 0x92, 0x96, 0, 0xc0, 0x4f, 0xb6, 0x67, 0x8b } };


/////////////////////////////////////////////////////////////////////////////
// Control type information

static const DWORD BASED_CODE _dwRatOleMisc =
    OLEMISC_ACTIVATEWHENVISIBLE |
    OLEMISC_SETCLIENTSITEFIRST |
    OLEMISC_INSIDEOUT |
    OLEMISC_CANTLINKINSIDE |
    OLEMISC_ACTSLIKEBUTTON |
    OLEMISC_RECOMPOSEONRESIZE;

IMPLEMENT_OLECTLTYPE(CRatCtrl, IDS_RAT, _dwRatOleMisc)


/////////////////////////////////////////////////////////////////////////////
// CRatCtrl::CRatCtrlFactory::UpdateRegistry -
// Adds or removes system registry entries for CRatCtrl

BOOL CRatCtrl::CRatCtrlFactory::UpdateRegistry(BOOL bRegister)
{
    // TODO: Verify that your control follows apartment-model threading rules.
    // Refer to MFC TechNote 64 for more information.
    // If your control does not conform to the apartment-model rules, then
    // you must modify the code below, changing the 6th parameter from
    // afxRegApartmentThreading to 0.

    if (bRegister)
        return AfxOleRegisterControlClass(
            AfxGetInstanceHandle(),
            m_clsid,
            m_lpszProgID,
            IDS_RAT,
            IDB_RAT,
            afxRegApartmentThreading,
            _dwRatOleMisc,
            _tlid,
            _wVerMajor,
            _wVerMinor);
    else
        return AfxOleUnregisterClass(m_clsid, m_lpszProgID);
}

/////////////////////////////////////////////////////////////////////////////
// CRatCtrl::CRatCtrl - Constructor

CRatCtrl::CRatCtrl():
    m_fUpdateFont( FALSE ),
    m_hAccel( NULL ),
    m_cAccel( 0 )
    {
    InitializeIIDs(&IID_DRat, &IID_DRatEvents);
    }

/////////////////////////////////////////////////////////////////////////////
// CRatCtrl::~CRatCtrl - Destructor

CRatCtrl::~CRatCtrl()
    {
    if ( m_hAccel )
        DestroyAcceleratorTable( m_hAccel );
    m_hAccel = NULL;
    }

/////////////////////////////////////////////////////////////////////////////
// CRatCtrl::OnDraw - Drawing function

void CRatCtrl::OnDraw(
            CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid)
    {
    DoSuperclassPaint(pdc, rcBounds);
    }

/////////////////////////////////////////////////////////////////////////////
// CRatCtrl::DoPropExchange - Persistence support

void CRatCtrl::DoPropExchange(CPropExchange* pPX)
    {
    ExchangeVersion(pPX, MAKELONG(_wVerMinor, _wVerMajor));
    COleControl::DoPropExchange(pPX);
    }

/////////////////////////////////////////////////////////////////////////////
// CRatCtrl::OnResetState - Reset control to default state

void CRatCtrl::OnResetState()
    {
    COleControl::OnResetState();  // Resets defaults found in DoPropExchange
    }

/////////////////////////////////////////////////////////////////////////////
// CRatCtrl::PreCreateWindow - Modify parameters for CreateWindowEx

BOOL CRatCtrl::PreCreateWindow(CREATESTRUCT& cs)
    {
    if ( cs.style & WS_CLIPSIBLINGS )
        cs.style ^= WS_CLIPSIBLINGS;
    cs.lpszClass = _T("BUTTON");
    return COleControl::PreCreateWindow(cs);
    }


/////////////////////////////////////////////////////////////////////////////
// CRatCtrl::IsSubclassedControl - This is a subclassed control

BOOL CRatCtrl::IsSubclassedControl()
    {
    return TRUE;
    }


/////////////////////////////////////////////////////////////////////////////
// CRatCtrl::OnOcmCommand - Handle command messages

LRESULT CRatCtrl::OnOcmCommand(WPARAM wParam, LPARAM lParam)
{
#ifdef _WIN32
    WORD wNotifyCode = HIWORD(wParam);
#else
    WORD wNotifyCode = HIWORD(lParam);
#endif

    return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CRatCtrl message handlers

//---------------------------------------------------------------------------
void CRatCtrl::OnClick(USHORT iButton)
    {
    WSADATA wsaData;

    // in case there are any errors, prepare the error string
    CString sz;
    // set the name of the application correctly
    sz.LoadString( IDS_RAT_ERR_TITLE );
    // free the existing name, and copy in the new one
    free((void*)AfxGetApp()->m_pszAppName);
    AfxGetApp()->m_pszAppName = _tcsdup(sz);

    // start up WSA services
    if ( WSAStartup(MAKEWORD(1, 1), &wsaData) )
        return;

//DebugBreak();
    CWaitCursor wait;

    // initialize the metabase wrappings - pass in the name of the target machine
    // if one has been specified
    IMSAdminBase* pMB = FInitMetabaseWrapper( (LPTSTR)(LPCTSTR)m_szMachine );
    if ( !pMB )
        {
        MessageBeep(0);
        WSACleanup();
        return;
        }

    // if there is no set metabase path - give it a test path
    if ( m_szMetaObject.IsEmpty() )
        m_szMetaObject = _T("/lm/w3svc/1/Root");

    // we have to be able to initialize the ratings data object
    CRatingsData            dataRatings(pMB);
    if ( !dataRatings.FInit(m_szMachine, m_szMetaObject) )
        {
        AfxMessageBox( IDS_RAT_READFILE_ERROR );
        FCloseMetabaseWrapper(pMB);
        WSACleanup();
        return;
        }

    // pointers to the pages (construction may throw, so we need to be careful)
    CRatServicePage         pageService;
    CRatGenPage             pageSetRatings;
    CRatAdvancedPage        pageAdvanced;

    // declare the property sheet
    CPropertySheet  propsheet( IDS_RAT_SHEETTITLE );

    // prepare the pages
    pageService.m_pRatData = &dataRatings;
    pageSetRatings.m_pRatData = &dataRatings;
    pageAdvanced.m_pRatData = &dataRatings;

    // add the pages to the sheet
    propsheet.AddPage( &pageService );
    propsheet.AddPage( &pageSetRatings );
//    propsheet.AddPage( &pageAdvanced );

    // turn on help
    propsheet.m_psh.dwFlags |= PSH_HASHELP;
    pageService.m_psp.dwFlags |= PSP_HASHELP;
    pageSetRatings.m_psp.dwFlags |= PSP_HASHELP;
//  pageAdvanced.m_psp.dwFlags |= PSP_HASHELP;


    // Things could (potentially maybe) throw here, so better protect it.
    try
        {
        // run the propdsheet dialog
        // let the host container know that we are putting up a modal dialog
        PreModalDialog();
        // run the dialog
        if ( propsheet.DoModal() == IDOK )
            {
            // generate the label and save it into the metabase
//            dataRatings.SaveTheLable();
            }
        // let the host container know we are done with the modality
        PostModalDialog();
        }
    catch ( CException e )
        {
        }

    // close the metabase wrappings
    FCloseMetabaseWrapper(pMB);
    WSACleanup();

    // don't fire anything off
    COleControl::OnClick(iButton);
    }

//---------------------------------------------------------------------------
void CRatCtrl::OnFontChanged()
    {
    m_fUpdateFont = TRUE;
    COleControl::OnFontChanged();
    }

//---------------------------------------------------------------------------
void CRatCtrl::SetAdminTarget(LPCTSTR szMachineName, LPCTSTR szMetaTarget)
    {
    m_szMachine = szMachineName;
    m_szMetaObject = szMetaTarget;
    }

//---------------------------------------------------------------------------
// an important method where we tell the container how to deal with us.
// pControlInfo is passed in by the container, although we are responsible
// for maintining the hAccel structure
void CRatCtrl::OnGetControlInfo(LPCONTROLINFO pControlInfo)
    {
    // do a rudimentary check to see if we understand pControlInfo
    if ( !pControlInfo || pControlInfo->cb < sizeof(CONTROLINFO) )
        return;

    // set the accelerator handle into place
    pControlInfo->hAccel = m_hAccel;
    pControlInfo->cAccel = m_cAccel;

    // when we have focus, we do want the enter key
    pControlInfo->dwFlags = CTRLINFO_EATS_RETURN;
    }

//---------------------------------------------------------------------------
// when the caption text has changed, we need to rebuild the accelerator handle
void CRatCtrl::OnTextChanged()
    {
    ACCEL   accel;
    int     iAccel;

    // get the new text
    CString sz = InternalGetText();
    sz.MakeLower();

    // if the handle has already been allocated, free it
    if ( m_hAccel )
        {
        DestroyAcceleratorTable( m_hAccel );
        m_hAccel = NULL;
        m_cAccel = 0;
        }

    // if there is a & character, then declare the accelerator
    iAccel = sz.Find(_T('&'));
    if ( iAccel >= 0 )
        {
        // fill in the accererator record
        accel.fVirt = FALT;
        accel.key = sz.GetAt(iAccel + 1);
        accel.cmd = (USHORT)GetDlgCtrlID();

        m_hAccel = CreateAcceleratorTable( &accel, 1 );
        if ( m_hAccel )
            m_cAccel = 1;

        // make sure the new accelerator table gets loaded
        ControlInfoChanged();
        }

    // finish with the default handling.
    COleControl::OnTextChanged();
    }

//---------------------------------------------------------------------------
void CRatCtrl::OnMnemonic(LPMSG pMsg)
    {
    OnClick((USHORT)GetDlgCtrlID());
    COleControl::OnMnemonic(pMsg);
    }

//---------------------------------------------------------------------------
void CRatCtrl::OnAmbientPropertyChange(DISPID dispid)
    {
    BOOL    flag;
    UINT    style;

    // do the right thing depending on the dispid
    switch ( dispid )
        {
        case DISPID_AMBIENT_DISPLAYASDEFAULT:
            if ( GetAmbientProperty( DISPID_AMBIENT_DISPLAYASDEFAULT, VT_BOOL, &flag ) )
                {
                style = GetWindowLong(
                        GetSafeHwnd(), // handle of window
                        GWL_STYLE  // offset of value to retrieve
                        );
                if ( flag )
                    style |= BS_DEFPUSHBUTTON;
                else
                    style ^= BS_DEFPUSHBUTTON;
                SetWindowLong(
                        GetSafeHwnd(), // handle of window
                        GWL_STYLE,  // offset of value to retrieve
                        style
                        );
                Invalidate(TRUE);
                }
            break;
        };

    COleControl::OnAmbientPropertyChange(dispid);
    }

//---------------------------------------------------------------------------
// the ole control container object specifically filters out the space
// key so we do not get it as a OnMnemonic call. Thus we need to look
// for it ourselves
void CRatCtrl::OnKeyUpEvent(USHORT nChar, USHORT nShiftState)
    {
    if ( nChar == _T(' ') )
        {
        OnClick((USHORT)GetDlgCtrlID());
        }
    COleControl::OnKeyUpEvent(nChar, nShiftState);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\cnfgprts\ratgenpg.h ===
// RatGenPg.h : header file
//
#define COMDLL
#include <dtp.h>

/////////////////////////////////////////////////////////////////////////////
// CRatGenPage dialog

class CRatGenPage : public CPropertyPage
{
	DECLARE_DYNCREATE(CRatGenPage)

// Construction
public:
	CRatGenPage();
	~CRatGenPage();
    
    // the data
    CRatingsData*   m_pRatData;

// Dialog Data
	//{{AFX_DATA(CRatGenPage)
	enum { IDD = IDD_RAT_SETRATING };
	CStatic	m_cstatic_moddate;
	CStatic	m_cstatic_moddate_title;
	CButton	m_cbutton_optional;
	CTreeCtrl	m_ctree_tree;
	CStatic	m_cstatic_title;
	CStatic	m_cstatic_rating;
	CStatic	m_cstatic_icon;
	CStatic	m_cstatic_expires;
	CStatic	m_cstatic_email;
	CStatic	m_cstatic_category;
	CSliderCtrl	m_cslider_slider;
	CEdit	m_cedit_person;
	CStatic	m_cstatic_description;
	CString	m_sz_description;
	BOOL	m_bool_enable;
	CString	m_sz_moddate;
	CString	m_sz_person;
	//}}AFX_DATA

    CDateTimePicker m_dtpDate;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CRatGenPage)
	public:
	virtual BOOL OnSetActive();
	virtual BOOL OnApply();
	virtual void OnOK();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult);
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CRatGenPage)
	afx_msg void OnEnable();
	afx_msg void OnSelchangedTree(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnChangeNamePerson();
	afx_msg void OnChangeModDate();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

    void DoHelp();

    // tell it to query the metabase and get any defaults
    BOOL    FInit();
    // load the parsed rat files into the tree
    BOOL    FLoadRatFiles();

    // utilities
    void EnableButtons();
    void UpdateRatingItems();
    void SetCurrentModDate();
    void UdpateDescription();
    void UpdateDateStrings();
    void SetModifiedTime();

    PicsCategory* GetTreeItemCategory( HTREEITEM hItem );
    void LoadSubCategories( PicsCategory* pParentCat, HTREEITEM hParent );

    // initialized flag
    BOOL        m_fInititialized;
    CImageList	m_imageList;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\cnfgprts\ratdata.cpp ===
// a class to maintain the PICS data. It reads and write it to the metabase and
// reads the file and all that. It also serves as a wrapper for the PICS parsing
// objects that have already been written elsewhere
// Created 4/18/97  by  BoydM


#include "stdafx.h"
#include <iadmw.h>
#include "cnfgprts.h"
#include "parserat.h"
#include "RatData.h"

#include <iiscnfg.h>
#include <wrapmb.h>
#include "metatool.h"

#include <isvctrl.h>

#include "mdobjs.h"
#include <winsock2.h>

// Here is the plan. First, we scan the local directory - looking for all
// the .rat files, load them and parse them


//----------------------------------------------------------------
CRatingsData::CRatingsData(IMSAdminBase* pMB):
        iRat(0),
        m_fEnabled( FALSE ),
        m_start_minute(0),
        m_start_hour(0),
        m_start_day(0),
        m_start_month(0),
        m_start_year(0),
        m_expire_minute(0),
        m_expire_hour(0),
        m_expire_day(0),
        m_expire_month(0),
        m_expire_year(0),
        m_pMB( pMB )
    {
    }

//----------------------------------------------------------------
CRatingsData::~CRatingsData()
    {
    // delete the rating systems
    DWORD nRats = (DWORD)rgbRats.GetSize();
    for ( DWORD iRat = 0; iRat < nRats; iRat++ )
        delete rgbRats[iRat];
    }


//----------------------------------------------------------------
BOOL CRatingsData::FCreateURL( CString &sz )
    {
    CHAR nameBuf[MAX_PATH+1];

    // start it off with the mandatory http header
    sz.LoadString( IDS_HTTP_HEADER );
    // get the host name of the machine
    if ( gethostname( nameBuf, sizeof(nameBuf)) )
        return FALSE;
    sz += nameBuf;

    // next, we need to add on the virtual path supplied by the metabase location
    // but that means starting by finding the root portion of the string
    CString szVir = m_szMeta;
    CString szRoot = _T("/Root");
    szVir = szVir.Right( szVir.GetLength() - szVir.Find(szRoot) );
    szVir = szVir.Right( szVir.GetLength() - szRoot.GetLength() );

    // concatenate and done
    sz += szVir;

    return TRUE;
    }


//----------------------------------------------------------------
// generate the label and save it into the metabase
void CRatingsData::SaveTheLable()
    {
    BOOL    fBuiltLabel = FALSE;
    BOOL    f;

    // prepare the metabase wrapper
    CWrapMetaBase   mbWrap;
    f = mbWrap.FInit(m_pMB);
    if ( !f ) return;

    // if the rating is NOT enabled, delete any existing label and return
    if ( !m_fEnabled )
        {
        // attempt to open the object we want to store into
        if ( mbWrap.Open( m_szMeta, METADATA_PERMISSION_WRITE ) )
            {
            // delete any existing PICS metaobject
//            f = mbWrap.DeleteData( _T(""), MD_HTTP_PICS, IIS_MD_UT_FILE, MULTISZ_METADATA );
            f = mbWrap.DeleteData( _T(""), MD_HTTP_PICS, MULTISZ_METADATA );
            // close the metabase
            mbWrap.Close();
            }
        //leave
        return;
        }
    else
        {
        CString szLabel;

        // first, we add the actual HTTP header to the header
//        szLabel = _T("Protocol: {PICS-1.0 {headers PICS-Label}}\nPICS-Label: ");
        szLabel = _T("PICS-Label: ");

        // create the URL string for this label
        CString szURL;
        FCreateURL( szURL );

        // create the modified string for this label
        CString szMod;
        CreateDateSz( szMod, m_start_day, m_start_month, m_start_year, m_start_hour, m_start_minute );

        // create the exipres string for this label
        CString szExpire;
        CreateDateSz( szExpire, m_expire_day, m_expire_month, m_expire_year, m_expire_hour, m_expire_minute );

        // tell each ratings system object to add its label to the string
        DWORD   nRatingSystems = (DWORD)rgbRats.GetSize();
        for ( DWORD iRat = 0; iRat < nRatingSystems; iRat++ )
            {
            // build the label string
            rgbRats[iRat]->OutputLabels( szLabel, szURL, m_szEmail, szMod, szExpire );
            }


        // the data gets saved as a multisz, so prep it up
        PTCHAR psz = szLabel.GetBuffer( szLabel.GetLength()+4 );

        DWORD   dw = szLabel.GetLength();

        // add the second null
        psz[dw + 1] = 0;
        psz[dw + 2] = 0;

        // save the data
        // save the PICS header string
    //            f = SetMetaData(&mbWrap, szPartial, MD_HTTP_PICS, IIS_MD_UT_FILE,
    //                psz, szLabel.GetLength()+2 );
//        f = SetMetaMultiSz( &mbWrap, m_szMeta, MD_HTTP_PICS, IIS_MD_UT_FILE,
//            psz, dw+2 );

        f = SetMetaMultiSz(m_pMB, m_szServer, m_szMeta, _T(""), MD_HTTP_PICS,
                    IIS_MD_UT_FILE, psz, dw+2, TRUE );


        // release the buffer
        szLabel.ReleaseBuffer();

        // these changes are permanent - so write them out
        if ( f )
            mbWrap.Save();
        }
    }

//----------------------------------------------------------------
BOOL CRatingsData::FInit( CString szServer, CString szMeta )
    {
    CWinApp*    pApp = AfxGetApp();
    CString     sz;
    BOOL        fGotSomething = FALSE;
    BOOL        fFoundAFile = FALSE;

    // store the target metabase location
    m_szServer = szServer;
    m_szMeta = szMeta;

    // build the search string
    CString szSearch;

    // the ratings files are in the system32 directory. First, get that
    // directory from the system. The first call is to get the size of the buffer.
    // add one for the terminating NULL
    DWORD cchSysDir = GetSystemDirectory( NULL, 0 ) + 1;
    // if we didn't get one - fail
    if ( cchSysDir == 1 ) return FALSE;

    // Now get it for real
    cchSysDir = GetSystemDirectory( szSearch.GetBuffer(cchSysDir), cchSysDir );
    szSearch.ReleaseBuffer();
    // if we didn't get one - fail
    if ( !cchSysDir ) return FALSE;

    // finish making it a proper search string

    //
    // RONALDM -- add .rat to only find rat files.
    //
    szSearch += _T("\\*.rat");

    // scan the local files looking for rat files. For each we find, load
    // them into the list of rat files
    BOOL        fKeepGoing = TRUE;
    CFileFind   finder;
    fFoundAFile = finder.FindFile( szSearch );
    while ( fFoundAFile )
        {
        // get rid of the directories right away
        if ( finder.MatchesMask( FILE_ATTRIBUTE_DIRECTORY ) )
            {
            // get the next file
            fFoundAFile = finder.FindNextFile();
            continue;
            }

        // get and normalize the path
        sz = finder.GetFilePath();
        sz.MakeLower();

        // if it is a rat file, go for it

        //
        // RONALDM -- changed the mask so that this is all that's necc.
        //
        //if ( sz.Find(_T(".rat")) > 0 )
            {
            // set the found flag based on if we can load it
            fGotSomething |= FLoadRatingsFile( sz );
            }

        // get the next file
        if ( !fKeepGoing )
            {
            fFoundAFile = FALSE;
            }
        else
            {
            fKeepGoing = finder.FindNextFile();
            }
        }

    // if we loaded a file, check what is in the metabase and load the values
    if ( fGotSomething )
        {
        LoadMetabaseValues();
        }
    else
        {
        // if we didn't find any rat files, tell the user and return
        AfxMessageBox( IDS_RAT_FINDFILE_ERROR );
        }

    // return the answer
    return fGotSomething;
    }

//----------------------------------------------------------------
// load a ratings file
BOOL CRatingsData::FLoadRatingsFile( CString szFilePath )
    {
    HANDLE                      hFile;
    HANDLE                      hFileMapping;
    VOID *                      pMem;
    BOOL                        fParsed = FALSE;

    hFile = CreateFile( szFilePath,
                                GENERIC_READ,
                                0,
                                NULL,
                                OPEN_EXISTING,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL );

    if ( hFile == INVALID_HANDLE_VALUE )
        {
        return FALSE;
        }

    hFileMapping = CreateFileMapping( hFile,
                                NULL,
                                PAGE_READONLY,
                                0,
                                0,
                                NULL );

    if ( hFileMapping == NULL )
        {
        CloseHandle( hFile );
        return FALSE;
        }

    pMem = MapViewOfFile( hFileMapping,
                                FILE_MAP_READ,
                                0,
                                0,
                                0 );

    if ( pMem == NULL )
        {
        CloseHandle( hFileMapping );
        CloseHandle( hFile );
        return FALSE;
        }

    // parse this and load it in and all that stuff
    fParsed = FParseRatingsFile( (LPSTR) pMem, szFilePath );

    UnmapViewOfFile( pMem );
    CloseHandle( hFileMapping );
    CloseHandle( hFile );

    // return the answer
    return fParsed;
    }


//----------------------------------------------------------------
BOOL CRatingsData::FParseRatingsFile( LPSTR pData, CString szPath )
    {
    HRESULT hres;
    BOOL fSuccess = FALSE;

    // first, try and parse the data
    PicsRatingSystem*   pRating = new PicsRatingSystem();

    // parse the data
    hres = pRating->Parse( pData );
    fSuccess = (hres == 0);

    // if it didn't parse, leave now
    if ( !fSuccess )
        {
        delete pRating;
        return FALSE;
        }

    // add the rat to the list of parsed rats
    rgbRats.Add( pRating );

    return fSuccess;
    }


//----------------------------------------------------------------
// create a date string
void CRatingsData::CreateDateSz( CString &sz, WORD day, WORD month, WORD year, WORD hour, WORD minute )
    {
    // get the local time zone
    TIME_ZONE_INFORMATION   tZone;
    INT                     hrZone, mnZone;
    DWORD                   dwDaylight = GetTimeZoneInformation( &tZone );
	// Fix for 339525: Boyd, this could be negative and must be signed type!
    LONG					tBias;

    // First, calculate the correct bias - depending whether or not
    // we are in daylight savings time.
    if ( dwDaylight == TIME_ZONE_ID_DAYLIGHT )
    {
        tBias = tZone.Bias + tZone.DaylightBias;
    }
    else
    {
        tBias = tZone.Bias + tZone.StandardBias;
    }

    // calculate the hours and minutes offset for the time-zone
    hrZone = tBias / 60;
    mnZone = tBias % 60;

    // need to handle time zones east of GMT
    if ( hrZone < 0 )
        {
        hrZone *= (-1);
        mnZone *= (-1);
        // make the string
        sz.Format( _T("%04d.%02d.%02dT%02d:%02d+%02d%02d"), year, month, day, hour, minute, hrZone, mnZone );
        }
    else
        {
        // make the string
        sz.Format( _T("%04d.%02d.%02dT%02d:%02d-%02d%02d"), year, month, day, hour, minute, hrZone, mnZone );
        }
    }

//----------------------------------------------------------------
// read a date string
void CRatingsData::ReadDateSz( CString sz, WORD* pDay, WORD* pMonth, WORD* pYear, WORD* pHour, WORD* pMinute )
    {
    CString szNum;
    WORD    i;
    DWORD   dw;

    // year
    szNum = sz.Left( sz.Find(_T('.')) );
    i = (WORD)swscanf( szNum, _T("%d"), &dw );
    *pYear = (WORD)dw;
    sz = sz.Right( sz.GetLength() - szNum.GetLength() - 1 );

    // month
    szNum = sz.Left( sz.Find(_T('.')) );
    i = (WORD)swscanf( szNum, _T("%d"), &dw );
    *pMonth = (WORD)dw;
    sz = sz.Right( sz.GetLength() - szNum.GetLength() - 1 );

    // day
    szNum = sz.Left( sz.Find(_T('T')) );
    i = (WORD)swscanf( szNum, _T("%d"), &dw );
    *pDay = (WORD)dw;
    sz = sz.Right( sz.GetLength() - szNum.GetLength() - 1 );

    // hour
    szNum = sz.Left( sz.Find(_T(':')) );
    i = (WORD)swscanf( szNum, _T("%d"), &dw );
    *pHour = (WORD)dw;
    sz = sz.Right( sz.GetLength() - szNum.GetLength() - 1 );

    // minute
    szNum = sz.Left( 2 );
    i = (WORD)swscanf( szNum, _T("%d"), &dw );
    *pMinute = (WORD)dw;
    }

//----------------------------------------------------------------
// for simplicity's sake (and for the sake of gettings done) only check the
// metabase values against the first loaded ratings system. Everything I've
// been hearing is that there will be only one.
void CRatingsData::LoadMetabaseValues()
    {
    CString szRating;
    BOOL    f;

    // prepare the metabase wrapper
    CWrapMetaBase   mbWrap;
    f = mbWrap.FInit(m_pMB);
    if ( !f ) return;

    // if we succeded in building the lables, save it in the metabase
    // attempt to open the object we want to store into
    CString szMeta;

    // arg arg arg. For things like directories, the metapath may not exist
    // seperate the partial path from the base - the root is always SZ_ROOT
    szMeta = SZ_W3_ROOT;
    m_szMetaPartial = m_szMeta.Right(m_szMeta.GetLength() - szMeta.GetLength() );

    // save the data
    if ( mbWrap.Open( szMeta, METADATA_PERMISSION_READ ) )
        {
        DWORD   cbData;
        // attempt to read the data from the metabase
        WCHAR* pData= (WCHAR*)mbWrap.GetData( m_szMetaPartial, MD_HTTP_PICS, IIS_MD_UT_FILE, MULTISZ_METADATA,
                    &cbData, METADATA_INHERIT | METADATA_PARTIAL_PATH );

        // copy the string into place
        if ( pData )
            szRating = pData;
        // free the buffer
        mbWrap.FreeWrapData( pData );
        // close the metabase
        mbWrap.Close();

        // if we got the string, parse it and all that jazz
        if ( !szRating.IsEmpty() )
            ParseMetaRating( szRating );
        }
    }

//----------------------------------------------------------------
// NOTE: this is a pretty fragile reading of the PICS file. If things are
// not in the order that this file would write them back out in, it will fail.
// however, This will work on PICS ratings that this module has written out,
// which should pretty much be all of them
// it also assumes that one-letter abbreviations are used just about everywhere
#define RAT_PERSON_DETECTOR     _T("by \"")
#define RAT_LABEL_DETECTOR      _T("l ")
#define RAT_ON_DETECTOR         _T("on \"")
#define RAT_EXPIRE_DETECTOR     _T("exp \"")
#define RAT_RAT_DETECTOR        _T("r (")
void CRatingsData::ParseMetaRating( CString szRating )
    {
    CString     szScratch;

    // if we got here, then we know that the rating system is enabled
    m_fEnabled = TRUE;

    // operate on a copy of the data
    CString     szRat;

    // skip past the http headerpart
    szRat = szRating.Right( szRating.GetLength() - szRating.Find(_T("\"http://")) - 1 );
    szRat = szRat.Right( szRat.GetLength() - szRat.Find(_T('\"')) - 1 );
    szRat.TrimLeft();

    // the next bit should be the label indicator. Skip over it
    if ( szRat.Left(wcslen(RAT_LABEL_DETECTOR)) == RAT_LABEL_DETECTOR )
        szRat = szRat.Right( szRat.GetLength() - wcslen(RAT_LABEL_DETECTOR) );

    // we should now be at the author part. If it is there, load it in
    if ( szRat.Left(wcslen(RAT_PERSON_DETECTOR)) == RAT_PERSON_DETECTOR )
        {
        szRat = szRat.Right( szRat.GetLength() - wcslen(RAT_PERSON_DETECTOR) );
        m_szEmail = szRat.Left( szRat.Find(_T('\"')) );
        szRat = szRat.Right( szRat.GetLength() - m_szEmail.GetLength() - 1 );
        szRat.TrimLeft();
        }

    // next should be the modification date
    // we should now be at the author part. If we are, load it in
    if ( szRat.Left(wcslen(RAT_ON_DETECTOR)) == RAT_ON_DETECTOR )
        {
        szRat = szRat.Right( szRat.GetLength() - wcslen(RAT_ON_DETECTOR) );
        szScratch = szRat.Left( szRat.Find(_T('\"')) );
        szRat = szRat.Right( szRat.GetLength() - szScratch.GetLength() - 1 );
        szRat.TrimLeft();
        ReadDateSz( szScratch, &m_start_day, &m_start_month, &m_start_year,
                    &m_start_hour, &m_start_minute );
        }

    // next should be the expiration date
    // we should now be at the author part. If we are, load it in
    if ( szRat.Left(wcslen(RAT_EXPIRE_DETECTOR)) == RAT_EXPIRE_DETECTOR )
        {
        szRat = szRat.Right( szRat.GetLength() - wcslen(RAT_EXPIRE_DETECTOR) );
        szScratch = szRat.Left( szRat.Find(_T('\"')) );
        szRat = szRat.Right( szRat.GetLength() - szScratch.GetLength() - 1 );
        szRat.TrimLeft();
        ReadDateSz( szScratch, &m_expire_day, &m_expire_month, &m_expire_year,
                    &m_expire_hour, &m_expire_minute );
        }

    // we should now be at the actual ratings part. If we are, load it in as one string first
    if ( szRat.Left(wcslen(RAT_RAT_DETECTOR)) == RAT_RAT_DETECTOR )
        {
        szRat = szRat.Right( szRat.GetLength() - wcslen(RAT_RAT_DETECTOR) );
        szScratch = szRat.Left( szRat.Find(_T(')')) );
        szRat = szRat.Right( szRat.GetLength() - szScratch.GetLength() - 1 );
        szRat.TrimLeft();

        // loop through all the value pairs in the ratings string
        while ( szScratch.GetLength() )
            {
            // this part goes <ch> sp <ch> so that we know we can use chars 0 and 2
            ParseMetaPair( szScratch[0], szScratch[2] );

            // cut down the string
            szScratch = szScratch.Right( szScratch.GetLength() - 3 );
            szScratch.TrimLeft();
            }
        }

    }

//----------------------------------------------------------------
void CRatingsData::ParseMetaPair( TCHAR chCat, TCHAR chVal )
    {
    // check validity of the value character
    if ( (chVal < _T('0')) || (chVal > _T('9')) )
        return;

    // convert the value into a number - the quick way
    WORD    value = chVal - _T('0');

    // try all the categories
    DWORD nCat = rgbRats[0]->arrpPC.Length();
    for ( DWORD iCat = 0; iCat < nCat; iCat++ )
        {
        // stop at the first successful setting
        if ( rgbRats[0]->arrpPC[iCat]->FSetValuePair((CHAR)chCat, (CHAR)value) )
            break;
        }
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\cnfgprts\ratsrvpg.h ===
// RatSrvPg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CRatServicePage dialog

class CRatServicePage : public CPropertyPage
{
	DECLARE_DYNCREATE(CRatServicePage)

// Construction
public:
	CRatServicePage();
	~CRatServicePage();

    // the data
    CRatingsData*   m_pRatData;


// Dialog Data
	//{{AFX_DATA(CRatServicePage)
	enum { IDD = IDD_RAT_SERVICE };
	CString	m_sz_description;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CRatServicePage)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CRatServicePage)
	afx_msg void OnQuestionaire();
	afx_msg void OnMoreinfo();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

    void DoHelp();

    CString m_szMoreInfoURL;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\cnfgprts\ratppg.h ===
// RatPpg.h : Declaration of the CRatPropPage property page class.

////////////////////////////////////////////////////////////////////////////
// CRatPropPage : See RatPpg.cpp.cpp for implementation.

class CRatPropPage : public COlePropertyPage
{
	DECLARE_DYNCREATE(CRatPropPage)
	DECLARE_OLECREATE_EX(CRatPropPage)

// Constructor
public:
	CRatPropPage();

// Dialog Data
	//{{AFX_DATA(CRatPropPage)
	enum { IDD = IDD_PROPPAGE_RAT };
	CString	m_sz_caption;
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Message maps
protected:
	//{{AFX_MSG(CRatPropPage)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\cnfgprts\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\cnfgprts\ratgenpg.cpp ===
// RatGenPg.cpp : implementation file
//

#include "stdafx.h"
#include <iadmw.h>
#include "cnfgprts.h"

#include "parserat.h"
#include "RatData.h"

#include "RatGenPg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


// enumerate the tree icon indexes
enum
    {
    IMAGE_SERVICE = 0,
    IMAGE_CATEGORY
    };

/////////////////////////////////////////////////////////////////////////////
// CRatGenPage property page

IMPLEMENT_DYNCREATE(CRatGenPage, CPropertyPage)

//--------------------------------------------------------------------------
CRatGenPage::CRatGenPage() : CPropertyPage(CRatGenPage::IDD),
        m_fInititialized( FALSE )
    {
    //{{AFX_DATA_INIT(CRatGenPage)
    m_sz_description = _T("");
    m_bool_enable = FALSE;
    m_sz_moddate = _T("");
    m_sz_person = _T("");
	//}}AFX_DATA_INIT
    }

//--------------------------------------------------------------------------
CRatGenPage::~CRatGenPage()
    {
    }

//--------------------------------------------------------------------------
void CRatGenPage::DoDataExchange(CDataExchange* pDX)
    {
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CRatGenPage)
    DDX_Control(pDX, IDC_MOD_DATE, m_cstatic_moddate);
    DDX_Control(pDX, IDC_STATIC_MOD_DATE, m_cstatic_moddate_title);
    DDX_Control(pDX, IDC_TREE, m_ctree_tree);
    DDX_Control(pDX, IDC_TITLE, m_cstatic_title);
    DDX_Control(pDX, IDC_STATIC_RATING, m_cstatic_rating);
    DDX_Control(pDX, IDC_STATIC_ICON, m_cstatic_icon);
    DDX_Control(pDX, IDC_STATIC_EXPIRES, m_cstatic_expires);
    DDX_Control(pDX, IDC_STATIC_EMAIL, m_cstatic_email);
    DDX_Control(pDX, IDC_STATIC_CATEGORY, m_cstatic_category);
    DDX_Control(pDX, IDC_SLIDER, m_cslider_slider);
    DDX_Control(pDX, IDC_NAME_PERSON, m_cedit_person);
    DDX_Control(pDX, IDC_DESCRIPTION, m_cstatic_description);
    DDX_Text(pDX, IDC_DESCRIPTION, m_sz_description);
    DDX_Check(pDX, IDC_ENABLE, m_bool_enable);
    DDX_Text(pDX, IDC_MOD_DATE, m_sz_moddate);
    DDX_Text(pDX, IDC_NAME_PERSON, m_sz_person);
    DDV_MaxChars(pDX, m_sz_person, 200);
	//}}AFX_DATA_MAP

    DDX_Control(pDX, IDC_DTP_ABS_DATE, m_dtpDate);
    }


//--------------------------------------------------------------------------
BEGIN_MESSAGE_MAP(CRatGenPage, CPropertyPage)
    //{{AFX_MSG_MAP(CRatGenPage)
    ON_BN_CLICKED(IDC_ENABLE, OnEnable)
    ON_NOTIFY(TVN_SELCHANGED, IDC_TREE, OnSelchangedTree)
    ON_WM_HSCROLL()
    ON_EN_CHANGE(IDC_NAME_PERSON, OnChangeNamePerson)
    ON_EN_CHANGE(IDC_MOD_DATE, OnChangeModDate)
	//}}AFX_MSG_MAP
    ON_COMMAND(ID_HELP_FINDER,  DoHelp)
    ON_COMMAND(ID_HELP,         DoHelp)
    ON_COMMAND(ID_CONTEXT_HELP, DoHelp)
    ON_COMMAND(ID_DEFAULT_HELP, DoHelp)
END_MESSAGE_MAP()

//---------------------------------------------------------------------------
void CRatGenPage::DoHelp()
    {
    WinHelp( HIDD_RATINGS_RATING );
    }


//--------------------------------------------------------------------------
void CRatGenPage::EnableButtons()
    {
    UpdateData( TRUE );

    // enabling is based on whether or not things are enabled
    if ( m_bool_enable )
        {
        m_ctree_tree.EnableWindow( TRUE );
        m_cstatic_title.EnableWindow( TRUE );
        m_cstatic_rating.EnableWindow( TRUE );
        m_cstatic_icon.EnableWindow( TRUE );
        m_cstatic_expires.EnableWindow( TRUE );
        m_cstatic_email.EnableWindow( TRUE );
        m_cstatic_category.EnableWindow( TRUE );
        m_cslider_slider.EnableWindow( TRUE );
        m_cedit_person.EnableWindow( TRUE );
        m_cstatic_moddate.EnableWindow( TRUE );
        m_cstatic_moddate_title.EnableWindow( TRUE );
        m_cstatic_description.EnableWindow( TRUE );
        m_dtpDate.EnableWindow(TRUE);

        // also need to take care of the slider bar
        UpdateRatingItems();
        }
    else
        {
        // not enabled
        m_ctree_tree.EnableWindow( FALSE );
        m_cstatic_title.EnableWindow( FALSE );
        m_cstatic_rating.EnableWindow( FALSE );
        m_cstatic_icon.EnableWindow( FALSE );
        m_cstatic_email.EnableWindow( FALSE );
        m_cstatic_category.EnableWindow( FALSE );
        m_cedit_person.EnableWindow( FALSE );
        m_cstatic_moddate.EnableWindow( FALSE );
        m_cstatic_moddate_title.EnableWindow( FALSE );
        m_dtpDate.EnableWindow(FALSE);

        // don't just disable the slider and description - hide them!
        m_cslider_slider.ShowWindow( SW_HIDE );
        m_cstatic_description.ShowWindow( SW_HIDE );
        }
    }

//--------------------------------------------------------------------------
void CRatGenPage::UpdateRatingItems()
    {
    // get the selected item in the tree
    HTREEITEM hItem = m_ctree_tree.GetSelectedItem();

    // get the item category
    PicsCategory* pCat = GetTreeItemCategory( hItem );

    // if there is no item, or it is the root, hide the sliders
    if ( !pCat )
        {
        // don't just disable the slider and description - hide them!
        m_cslider_slider.ShowWindow( SW_HIDE );
        m_cstatic_description.ShowWindow( SW_HIDE );
        }
    else
        {
        // make sure the windows are showing and enabled
        m_cslider_slider.ShowWindow( SW_SHOW );
        m_cstatic_description.ShowWindow( SW_SHOW );
        m_cslider_slider.EnableWindow( TRUE );
        m_cstatic_description.EnableWindow( TRUE );

        // get the item category
        PicsCategory* pCat = GetTreeItemCategory( hItem );

        // set up the slider
        m_cslider_slider.SetRangeMin( 0 );
        m_cslider_slider.SetRangeMax( pCat->arrpPE.Length() - 1, TRUE );

        // set current value of the slider
        m_cslider_slider.SetPos( pCat->currentValue );

        // set up the description
        UdpateDescription();
        }
    }

//--------------------------------------------------------------------------
PicsCategory* CRatGenPage::GetTreeItemCategory( HTREEITEM hItem )
    {
    DWORD   iRat;
    DWORD   iCat = 0;

    // get the item's parent in the tree
    HTREEITEM hParent = m_ctree_tree.GetParentItem(hItem);

    // get the cat
    // IA64 - OK to cast as this is an index
    iCat = (DWORD)m_ctree_tree.GetItemData( hItem );

    // if the parent is null, return NULL to indicate that this is a root item
    if ( !hParent )
        return NULL;

    // if the parent is a root though, we can simply return the category
    if ( !m_ctree_tree.GetParentItem(hParent) )
        {
        // get the rat and the cat
    // IA64 - OK to cast as this is an index
        iRat = (DWORD)m_ctree_tree.GetItemData( hParent );
        // return the category
        return m_pRatData->rgbRats[iRat]->arrpPC[iCat];
        }
    else
        {
        // we are deeper in the tree. Get the parent category first
        PicsCategory* pParentCat = GetTreeItemCategory( hParent );
        // return the category
        return pParentCat->arrpPC[iCat];
        }
    // shouldn't get here
    return NULL;
    }

//--------------------------------------------------------------------------
void CRatGenPage::UpdateDateStrings()
    {
    CString sz;
    TCHAR    chBuff[MAX_PATH];
    int     i;

    SYSTEMTIME  sysTime;

    UpdateData( TRUE );

    // start with the epxiration date
    ZeroMemory( chBuff, sizeof(chBuff) );
    ZeroMemory( &sysTime, sizeof(sysTime) );
    sysTime.wDay = m_pRatData->m_expire_day;
    sysTime.wMonth = m_pRatData->m_expire_month;
    sysTime.wYear = m_pRatData->m_expire_year;

    m_dtpDate.SetSystemTime(&sysTime);


    // now the modified date and time
    ZeroMemory( chBuff, sizeof(chBuff) );
    ZeroMemory( &sysTime, sizeof(sysTime) );
    sysTime.wDay = m_pRatData->m_start_day;
    sysTime.wMonth = m_pRatData->m_start_month;
    sysTime.wYear = m_pRatData->m_start_year;
    sysTime.wMinute = m_pRatData->m_start_minute;
    sysTime.wHour = m_pRatData->m_start_hour;

    i = GetDateFormat(
        LOCALE_USER_DEFAULT,    // locale for which date is to be formatted
        DATE_LONGDATE,  // flags specifying function options
        &sysTime,   // date to be formatted
        NULL,   // date format string
        chBuff, // buffer for storing formatted string
        sizeof(chBuff)  // size of buffer
       );
    m_sz_moddate = chBuff;

    ZeroMemory( chBuff, sizeof(chBuff) );
    i = GetTimeFormat(
        LOCALE_USER_DEFAULT,    // locale for which time is to be formatted
        TIME_NOSECONDS, // flags specifying function options
        &sysTime,   // time to be formatted
        NULL,   // time format string
        chBuff, // buffer for storing formatted string
        sizeof(chBuff)  // size, in bytes or characters, of the buffer
       );
    m_sz_moddate += ", ";
    m_sz_moddate += chBuff;

//    CTime timeModified( sysTime );
//    m_sz_moddate = timeModified.Format( "%#c" );

    // put it back
    UpdateData( FALSE );
    }

//--------------------------------------------------------------------------
// Update the text displayed in the description
void CRatGenPage::UdpateDescription()
    {
    // get the selected item in the tree
    HTREEITEM hItem = m_ctree_tree.GetSelectedItem();
    if ( !hItem ) return;

    // get the selected category object
    PicsCategory* pCat = GetTreeItemCategory( hItem );

    // shouldn't be any problem, but might as well check
    if ( !pCat )
        return;

    // get the current value
    WORD value = pCat->currentValue;

    // build the description string
    m_sz_description = pCat->arrpPE[value]->etstrName.Get();
    UpdateData( FALSE );
    }

//--------------------------------------------------------------------------
// tell it to query the metabase and get any defaults
BOOL CRatGenPage::FInit()
    {
    UpdateData( TRUE );

    // init the image list first
    // prepare the list's image list
    if ( m_imageList.Create( IDB_RATLIST, 16, 3, 0x00FF00FF ) )
        // set the image list into the list control
        m_ctree_tree.SetImageList( &m_imageList, TVSIL_NORMAL );

    // start with the parsed rat files
    if ( !FLoadRatFiles() )
        return FALSE;

    // do the right thing based on the ratings being enabled
    if ( m_pRatData->m_fEnabled )
        {
        // ratings are enabled.
        m_bool_enable = TRUE;
        m_sz_person = m_pRatData->m_szEmail;
        }
    else
        {
        // ratings are not enabled.
        m_bool_enable = FALSE;
        }

    // do the dates
    // if the mod date is not set give date today's as a default moddate
    if ( m_pRatData->m_start_year == 0 )
        {
        SetCurrentModDate();
        }



    //
    // Set the minimum of the date picker to today
    // and the maximum to Dec 31, 2035.
    // taken from Ron's code
    //
    CTime m_tmNow(CTime::GetCurrentTime());
    SYSTEMTIME stmRange[2] =
    {
        {
            (WORD)m_tmNow.GetYear(),
            (WORD)m_tmNow.GetMonth(),
            (WORD)m_tmNow.GetDayOfWeek(),
            (WORD)m_tmNow.GetDay(),
            (WORD)m_tmNow.GetHour(),
            (WORD)m_tmNow.GetMinute(),
            (WORD)m_tmNow.GetSecond(),
            0
        },
        {
            2035,
            12,
            1,      // A Monday as it turns out
            31,
            23,
            59,
            59,
        }
    };

    m_dtpDate.SetRange(GDTR_MIN | GDTR_MAX, stmRange);

    // if there is no expire date, set it for one year after the mod date
    if ( m_pRatData->m_expire_year == 0 )
        {
        m_pRatData->m_expire_minute = 0;
        m_pRatData->m_expire_hour = 12;
        m_pRatData->m_expire_day = m_pRatData->m_start_day;
        m_pRatData->m_expire_month = m_pRatData->m_start_month;
        m_pRatData->m_expire_year = m_pRatData->m_start_year + 1;
        }

    // update the date strings
    UpdateDateStrings();

    // update the name string and the enabled switch as well
    m_sz_person = m_pRatData->m_szEmail;
    m_bool_enable = m_pRatData->m_fEnabled;

    // put the data back
    UpdateData( FALSE );

    EnableButtons();

    // success
    return TRUE;
    }

//--------------------------------------------------------------------------
// load the parsed rat files into the tree
BOOL CRatGenPage::FLoadRatFiles()
    {
    HTREEITEM   hRoot;
    HTREEITEM   hItem;
    CString     sz;

    // how many rat files are there?
    DWORD   nRatFiles = (DWORD)m_pRatData->rgbRats.GetSize();
    // loop them
    for ( DWORD iRat = 0; iRat < nRatFiles; iRat++ )
        {
        // get the rating system
        PicsRatingSystem*   pRating = m_pRatData->rgbRats[iRat];

        // get the root node name
        sz = pRating->etstrName.Get();

        // add the root node to the tree
        hRoot = m_ctree_tree.InsertItem( sz );
        // because the list is alphabetized, embed the iRat number in the item
        m_ctree_tree.SetItemData( hRoot, iRat );
        m_ctree_tree.SetItemImage( hRoot, IMAGE_SERVICE, IMAGE_SERVICE );

        // add the subnodes to the tree as well
        DWORD nCats = pRating->arrpPC.Length();
        // loop them
        for ( DWORD iCat = 0; iCat < nCats; iCat++ )
            {
            // get the category node name
            sz = pRating->arrpPC[iCat]->etstrName.Get();

            // add the category node to the tree
            hItem = m_ctree_tree.InsertItem( sz, hRoot );

            // because the list is alphabetized, embed the iCat number in the item
            m_ctree_tree.SetItemData( hItem, iCat );
            m_ctree_tree.SetItemImage( hItem, IMAGE_CATEGORY, IMAGE_CATEGORY );

            // even though there aren't any now, add any sub-categories
            LoadSubCategories( pRating->arrpPC[iCat], hItem );
            }

        // expand the rat node
        m_ctree_tree.Expand( hRoot, TVE_EXPAND );
        }

    return TRUE;
    }

//--------------------------------------------------------------------------
void CRatGenPage::LoadSubCategories( PicsCategory* pParentCat, HTREEITEM hParent )
    {
    CString sz;
    HTREEITEM hItem;

    // add the subnodes to the tree as well
    DWORD nCats = pParentCat->arrpPC.Length();
    // loop them
    for ( DWORD iCat = 0; iCat < nCats; iCat++ )
        {
        // get the category node name
        sz = pParentCat->arrpPC[iCat]->etstrName.Get();

        // add the category node to the tree
        hItem = m_ctree_tree.InsertItem( sz, hParent );

        // because the list is alphabetized, embed the iCat number in the item
        m_ctree_tree.SetItemData( hItem, iCat );
        m_ctree_tree.SetItemImage( hItem, IMAGE_CATEGORY, IMAGE_CATEGORY );

        // even though there aren't any now, add any sub-categories
        LoadSubCategories( pParentCat->arrpPC[iCat], hItem );
        }

    // if there were sub-categories, expand the parental node in the tree
    if ( nCats > 0 )
        m_ctree_tree.Expand( hParent, TVE_EXPAND );
    }


//--------------------------------------------------------------------------
void CRatGenPage::SetModifiedTime()
    {
    SetCurrentModDate();
    UpdateDateStrings();
    SetModified();
    }


/////////////////////////////////////////////////////////////////////////////
// CRatGenPage message handlers

//--------------------------------------------------------------------------
void CRatGenPage::OnEnable()
    {
    EnableButtons();
    SetModified();
    }

//--------------------------------------------------------------------------
BOOL CRatGenPage::OnSetActive()
    {
    // if it hasn't been initialized yet, do so
    if ( !m_fInititialized )
        {
        FInit();
        m_fInititialized = TRUE;
        }

    // enable the button appropriately
    EnableButtons();

    return CPropertyPage::OnSetActive();
    }

//--------------------------------------------------------------------------
void CRatGenPage::OnOK()
    {
    CPropertyPage::OnOK();
    }

//--------------------------------------------------------------------------
BOOL CRatGenPage::OnApply()
    {
    UpdateData( TRUE );

    // make sure there are no quote symbols in the name
    if ( m_sz_person.Find(_T('\"')) >= 0 )
        {
        AfxMessageBox( IDS_RAT_NAME_ERROR );
        return FALSE;
        }

    // put the data into place
    m_pRatData->m_fEnabled = m_bool_enable;
    m_pRatData->m_szEmail = m_sz_person;

    // set the expire date
    SYSTEMTIME  sysTime;
    ZeroMemory( &sysTime, sizeof(sysTime) );
    // get the date from the control
    m_dtpDate.GetSystemTime(&sysTime);
    // set the date into place
    m_pRatData->m_expire_day = sysTime.wDay;
    m_pRatData->m_expire_month = sysTime.wMonth;
    m_pRatData->m_expire_year = sysTime.wYear;

    // generate the label and save it into the metabase
    m_pRatData->SaveTheLable();

    // we can now apply
    SetModified( FALSE );
    return CPropertyPage::OnApply();
    }

//--------------------------------------------------------------------------
void CRatGenPage::SetCurrentModDate()
    {
    SYSTEMTIME time;
    GetLocalTime( &time );

    m_pRatData->m_start_day = time.wDay;
    m_pRatData->m_start_month = time.wMonth;
    m_pRatData->m_start_year = time.wYear;
    m_pRatData->m_start_minute = time.wMinute;
    m_pRatData->m_start_hour = time.wHour;
    }

//--------------------------------------------------------------------------
void CRatGenPage::OnSelchangedTree(NMHDR* pNMHDR, LRESULT* pResult)
    {
    NM_TREEVIEW* pNMTreeView = (NM_TREEVIEW*)pNMHDR;
    UpdateRatingItems();
    *pResult = 0;
    }

//--------------------------------------------------------------------------
void CRatGenPage::OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar)
    {
    // get the value of the slider
    WORD iPos = (WORD)m_cslider_slider.GetPos();

    // get the current item
    HTREEITEM   hItem = m_ctree_tree.GetSelectedItem();

    // get the selected category object
    PicsCategory* pCat = GetTreeItemCategory( hItem );

    // shouldn't be any problem, but might as well check
    if ( !pCat )
        return;

    // set the category value
    pCat->currentValue = iPos;

    // update the description
    UdpateDescription();

    // we can now apply
    SetModifiedTime();

    // update the mod date
    SetCurrentModDate();
    CPropertyPage::OnHScroll(nSBCode, nPos, pScrollBar);
    }

//--------------------------------------------------------------------------
void CRatGenPage::OnChangeNamePerson()
    {
    // we can now apply
    SetModifiedTime();
    }

//--------------------------------------------------------------------------
void CRatGenPage::OnChangeModDate()
    {
    // we can now apply
    SetModifiedTime();
    }


//--------------------------------------------------------------------------
// Stolen from w3scfg - the httppage.cpp file
BOOL
CRatGenPage::OnNotify(
    WPARAM wParam,
    LPARAM lParam,
    LRESULT * pResult
    )
/*++

Routine Description:

    Handle notification changes

Arguments:

    WPARAM wParam           : Control ID
    LPARAM lParam           : NMHDR *
    LRESULT * pResult       : Result pointer

Return Value:

    TRUE if handled, FALSE if not

--*/
{
    //
    // Message cracker crashes - so checking this here instead
    //
    if (wParam == IDC_DTP_ABS_DATE)
    {
        NMHDR * pHdr = (NMHDR *)lParam;
        if (pHdr->code == DTN_DATETIMECHANGE)
        {
            SetModified();
        }
    }

    //
    // Default behaviour -- go to the message map
    //
    return CPropertyPage::OnNotify(wParam, lParam, pResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\cnfgprts\recycleoptpage.h ===
#if !defined(AFX_RECYCLEOPTPAGE_H__F8EFE742_FAF8_415C_BA2A_603DB2C64F1B__INCLUDED_)
#define AFX_RECYCLEOPTPAGE_H__F8EFE742_FAF8_415C_BA2A_603DB2C64F1B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// RecycleOptPage.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CRecycleOptPage dialog

class CRecycleOptPage : public CPropertyPage
{
	DECLARE_DYNCREATE(CRecycleOptPage)

// Construction
public:
	CRecycleOptPage();
	~CRecycleOptPage();

// Dialog Data
	//{{AFX_DATA(CRecycleOptPage)
	enum { IDD = IDD_APP_RECYCLE };
	CButton	m_btnTimespan;
	CButton	m_btnTimer;
	CButton	m_btnResuests;
	CButton	m_btnAddTime;
	CEdit	m_editReqLimit;
	CEdit	m_editTimeSpan;
	UINT	m_ReqLimit;
	UINT	m_TimeSpan;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CRecycleOptPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CRecycleOptPage)
	afx_msg void OnAddTime();
	afx_msg void OnRecycleRequests();
	afx_msg void OnRecycleTimespan();
	afx_msg void OnRecycleTimer();
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_RECYCLEOPTPAGE_H__F8EFE742_FAF8_415C_BA2A_603DB2C64F1B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\cnfgprts\recycleoptpage.cpp ===
// RecycleOptPage.cpp : implementation file
//

#include "stdafx.h"
#include "cnfgprts.h"
#include "RecycleOptPage.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CRecycleOptPage property page

IMPLEMENT_DYNCREATE(CRecycleOptPage, CPropertyPage)

CRecycleOptPage::CRecycleOptPage() : CPropertyPage(CRecycleOptPage::IDD)
{
	//{{AFX_DATA_INIT(CRecycleOptPage)
	m_ReqLimit = 0;
	m_TimeSpan = 0;
	//}}AFX_DATA_INIT
}

CRecycleOptPage::~CRecycleOptPage()
{
}

void CRecycleOptPage::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CRecycleOptPage)
	DDX_Control(pDX, IDC_RECYCLE_TIMESPAN, m_btnTimespan);
	DDX_Control(pDX, IDC_RECYCLE_TIMER, m_btnTimer);
	DDX_Control(pDX, IDC_RECYCLE_REQUESTS, m_btnResuests);
	DDX_Control(pDX, IDC_ADD_TIME, m_btnAddTime);
	DDX_Control(pDX, IDC_REQUEST_LIMIT, m_editReqLimit);
	DDX_Control(pDX, IDC_TIMESPAN, m_editTimeSpan);
	DDX_Text(pDX, IDC_REQUEST_LIMIT, m_ReqLimit);
	DDV_MinMaxUInt(pDX, m_ReqLimit, 1, 10000000);
	DDX_Text(pDX, IDC_TIMESPAN, m_TimeSpan);
	DDV_MinMaxUInt(pDX, m_TimeSpan, 1, 10000);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CRecycleOptPage, CPropertyPage)
	//{{AFX_MSG_MAP(CRecycleOptPage)
	ON_BN_CLICKED(IDC_ADD_TIME, OnAddTime)
	ON_BN_CLICKED(IDC_RECYCLE_REQUESTS, OnRecycleRequests)
	ON_BN_CLICKED(IDC_RECYCLE_TIMESPAN, OnRecycleTimespan)
	ON_BN_CLICKED(IDC_RECYCLE_TIMER, OnRecycleTimer)
	ON_WM_KEYDOWN()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRecycleOptPage message handlers

void CRecycleOptPage::OnAddTime() 
{
}

void CRecycleOptPage::OnRecycleRequests() 
{
}

void CRecycleOptPage::OnRecycleTimespan() 
{
}

void CRecycleOptPage::OnRecycleTimer() 
{
}

void CRecycleOptPage::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags) 
{
   DebugBreak();
	CPropertyPage::OnKeyDown(nChar, nRepCnt, nFlags);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\cnfgprts\wrapmb.h ===
#ifndef _WRAPMB_
#define _WRAPMB_

#include "iadmw.h"

//--------------------------------------------------------
// startup & closeing utilities
IMSAdminBase* FInitMetabaseWrapper( OLECHAR* pocMachineName );
BOOL    FCloseMetabaseWrapper( IMSAdminBase* pMBCom );


//--------------------------------------------------------
class CWrapMetaBase
    {
    public:
    WORD m_count;
    // construct - destruct
    CWrapMetaBase();
    ~CWrapMetaBase();

    // second stage initialization
    BOOL FInit( PVOID pMBCom );

    // open, close and save the object and such
    BOOL Open( LPCTSTR pszPath, DWORD dwFlags = METADATA_PERMISSION_READ );
    BOOL Open( METADATA_HANDLE hOpenRoot, LPCTSTR pszPath,
                                            DWORD dwFlags = METADATA_PERMISSION_READ );
    BOOL Close( void );
    BOOL Save( void );

    // enumerate the objects
    BOOL EnumObjects( LPCTSTR pszPath, LPTSTR Name, DWORD Index );

    // Add and delete objects
    BOOL AddObject( LPCTSTR pszPath );
    BOOL DeleteObject( LPCTSTR pszPath );

    // rename an object
    BOOL RenameObject( LPCTSTR pszPathOld, LPCTSTR pszNewName );

    // access the metahandle
    METADATA_HANDLE QueryHandle();

    // setting values
    BOOL SetDword( LPCTSTR pszPath, DWORD dwPropID, DWORD dwUserType, DWORD dwValue, DWORD dwFlags = METADATA_INHERIT );
    BOOL SetString( LPCTSTR pszPath, DWORD dwPropID, DWORD dwUserType, LPCTSTR dwValue, DWORD dwFlags = METADATA_INHERIT );
    BOOL SetData( LPCTSTR pszPath, DWORD dwPropID, DWORD dwUserType, DWORD dwDataType,
                            PVOID pData, DWORD cbData, DWORD dwFlags = METADATA_INHERIT );

    // getting values
    BOOL GetDword( LPCTSTR pszPath, DWORD dwPropID, DWORD dwUserType, DWORD* dwValue, DWORD dwFlags = METADATA_INHERIT );
    BOOL GetString( LPCTSTR pszPath, DWORD dwPropID, DWORD dwUserType, LPTSTR pszValue, DWORD* pcchValue,
                            DWORD dwFlags = METADATA_INHERIT );
    BOOL GetData( LPCTSTR pszPath, DWORD dwPropID, DWORD dwUserType, DWORD dwDataType,
                            PVOID pData, DWORD* pcbData, DWORD dwFlags = METADATA_INHERIT );
    PVOID GetData( LPCTSTR pszPath, DWORD dwPropID, DWORD dwUserType, DWORD dwDataType,
                            DWORD* pcbData, DWORD dwFlags = METADATA_INHERIT );

    // deleting values
    BOOL DeleteData( LPCTSTR pszPath, DWORD dwPropID, DWORD dwDataType );

	// free memory returned by GetData
	void FreeWrapData( PVOID pData );

    protected:
    // pointer to the real metabase object as defined in mb.hxx
    // by casting it PVOID, those files including this will not have to include mb.hxx, which
    // is the whole point of wrapping it like this.
//        PVOID   m_pvMB;

    // pointer to the dcom interface it should use
    IMSAdminBase*       m_pMetabase;

    // the open metabase handle
    METADATA_HANDLE     m_hMeta;

    // size of the local buffer
    #define BUFFER_SIZE		2000

    // local buffer - allocated once, used many times
    PVOID	m_pBuffer;
    DWORD	m_cbBuffer;


    // path conversion utilities
    WCHAR* PrepPath( LPCTSTR psz );
    void UnprepPath();

    WCHAR*  m_pPathBuffer;
    DWORD   m_cchPathBuffer;
    };


#endif //_WRAPMB_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\common2\common.h ===
/*++

   Copyright    (c)    1994-2000   Microsoft Corporation

   Module  Name :

        common.h

   Abstract:

        Common properties header file

   Author:

        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:

        Internet Services Manager

   Revision History:
        2/17/2000    sergeia     removed dependency on MFC

--*/



#ifndef __COMPROP_H__
#define __COMPROP_H__


#include <lmcons.h>
#include <wincrypt.h>
#include <iis64.h>
#include "inetcom.h"
#include "iisinfo.h"
#include "svcloc.h"

#include "resource.h"

#ifndef _DLLEXP
    #define _EXPORT              __declspec(dllimport)
#else
    #define _EXPORT              __declspec(dllexport)
#endif


//
// Memory Allocation Macros
//
//#define AllocMem(cbSize)\
//    ::LocalAlloc(LPTR, cbSize)

//#define FreeMem(lp)\
//    ::LocalFree(lp)

//#define AllocMemByType(citems, type)\
//    (type *)AllocMem(citems * sizeof(type))



//
// Program flow macros
//
#define FOREVER for(;;)

#define BREAK_ON_ERR_FAILURE(err)\
    if (err.Failed()) break;

#define BREAK_ON_NULL_PTR(lp)\
    if (lp == NULL) break;

#define BREAK_ON_FAILURE(hr)\
    if (FAILED(hr)) break

//
// Safe allocators
//
#define SAFE_DELETE(obj)\
    if (obj != NULL) do { delete obj; obj = NULL; } while(0)

#define SAFE_DELETE_OBJECT(obj)\
    if (obj != NULL) do { DeleteObject(obj); obj = NULL; } while(0)

#define SAFE_FREEMEM(lp)\
    if (lp != NULL) do { FreeMem(lp); lp = NULL; } while(0)

#define SAFE_SYSFREESTRING(lp)\
    if (lp != NULL) do { ::SysFreeString(lp); lp = NULL; } while(0)

#define SAFE_RELEASE(lpInterface)\
    if (lpInterface != NULL) do { lpInterface->Release(); lpInterface = NULL; } while(0)


#define IS_NETBIOS_NAME(lpstr) (*lpstr == _T('\\'))
//
// Return the portion of a computer name without the backslashes
//
#define PURE_COMPUTER_NAME(lpstr) (IS_NETBIOS_NAME(lpstr) ? lpstr + 2 : lpstr)

#define ARRAY_SIZE(a)    (sizeof(a)/sizeof(a[0]))
#define STRSIZE(str)     (ARRAY_SIZE(str)-1)
#define ARRAY_BYTES(a)   (sizeof(a) * sizeof(a[0]))
#define STRBYTES(str)    (ARRAY_BYTES(str) - sizeof(str[0]))

//
// General purpose files
//
#include "iiscstring.h"
typedef IIS::CString CString;

#include "debugatl.h"
#include "utcls.h"
//#include "objplus.h"
//#include "strfn.h"
//#include "odlbox.h"
#include "error.h"
#include "mdkeys.h"
//#include "ipa.h"
//#include "wizard.h"
//#include "registry.h"
//#include "ddxv.h"
//#include "objpick.h"
//#include "accentry.h"
//#include "sitesecu.h"
//#include "ipctl.h"
//#include "dtp.h"
//#include "dirbrows.h"
#include "FileChooser.h"



#endif // __COMPROP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\cnfgprts\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxctl.h>         // MFC support for OLE Controls

// Delete the two includes below if you do not wish to use the MFC
//  database classes
#ifndef _UNICODE
#include <afxdb.h>			// MFC database classes
#include <afxdao.h>			// MFC DAO database classes
#endif //_UNICODE

#include <afxcmn.h>			// MFC support for Windows Common Controls
#include <afxtempl.h>

#include <assert.h>

#include <aclapi.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\cnfgprts\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by cnfgprts.rc
//
#define IDS_LOGUI                       1
#define IDB_LOGUI                       1
#define IDS_LOGUI_PPG                   2
#define IDB_RAT                         2
#define IDS_RAT                         3
#define IDB_APPS                        3
#define IDS_RAT_PPG                     4
#define IDS_APPS                        5
#define IDS_APPS_PPG                    6
#define IDC_DTP_ABS_DATE                3826
#define IDC_DTP_ABS_TIME                3827
#define IDS_LOGUI_PPG_CAPTION           10100
#define IDD_PROPPAGE_LOGUI              10100
#define IDS_RAT_PPG_CAPTION             10101
#define IDD_PROPPAGE_RAT                10101
#define IDS_APPS_PPG_CAPTION            10102
#define IDD_PROPPAGE_APPS               10102
#define IDS_RATING_URL                  10103
#define IDS_RAT_SHEETTITLE              10104
#define IDS_RAT_READFILE_ERROR          10105
#define IDS_RAT_FINDFILE_ERROR          10106
#define IDS_RAT_NAME_ERROR              10107
#define IDS_HTTP_HEADER                 10108
#define IDS_APP_SHEETTITLE              10109
#define IDS_LOG_INVALID_DIR             10110
#define IDS_APP_DEFAULT_ERROR           10110
#define IDS_APP_EXTENSION               10111
#define IDS_APP_EXE_PATH                10112
#define IDS_APP_MAP_REMOVE_CONFIRM      10113
#define IDS_APP_MAP_INVALID_PATH        10114
#define IDS_APP_MAP_INVALID_EXT         10115
#define IDS_ELLIPSIS                    10116
#define IDS_APP_MAP_FILTER              10117
#define IDS_HELPLOC_HELP                10118
#define IDS_APP_ONLY_ONE                10119
#define IDS_EXPIRE_SET_PAST             10120
#define IDS_LOGUI_DLL                   10121
#define IDS_APP_EXCLUSIONS              10122
#define IDS_APP_ERR_TITLE               10123
#define IDS_RAT_ERR_TITLE               10124
#define IDS_LOG_ERR_TITLE               10125
#define IDS_APP_ERR_EXT_REQUIRED        10126
#define IDS_SCRIPTS                     10127
#define IDS_NO_DATE_SELECTED            10128
#define IDS_ERR_LOG_PLUGIN              10129
#define IDS_APP_MAP_USE_VALID_DRIVE     10130
#define IDS_VERBS_ALL                   10131
#define IDS_ERR_NO_VERBS                10132
#define IDC_CAPTIONEDIT                 10201
#define IDD_LOG_GENERAL                 10201
#define IDC_LOG_AUTO_OPEN               10201
#define IDC_LOG_DAILY                   10202
#define IDD_RAT_SETRATING               10202
#define IDC_LOG_WEEKLY                  10203
#define IDD_RAT_SERVICE                 10203
#define IDI_ICON1                       10203
#define IDI_GLOBE                       10203
#define IDC_LOG_MONTHLY                 10204
#define IDD_RAT_ADVANCED                10204
#define IDC_LOG_WHENSIZE                10205
#define IDD_RAT_EXPIRE                  10205
#define IDC_SPIN                        10207
#define IDC_LOG_SIZE                    10208
#define IDC_LOG_DIRECTORY               10209
#define IDB_RATLIST                     10209
#define IDC_BROWSE                      10210
#define IDC_LOG_SIZE_UNITS              10211
#define IDC_LOG_FILE_SAMPLE             10212
#define IDC_TREE                        10213
#define IDD_APP_ASPMAIN                 10214
#define IDC_SLIDER                      10215
#define IDD_APP_ASPDEBUG                10215
#define IDC_DESCRIPTION                 10216
#define IDD_APP_APPMAP                  10216
#define IDD_APP_OTHER                   10217
#define IDC_NAME_PERSON                 10218
#define IDD_APP_EDITMAP                 10218
#define IDC_MOD_DATE                    10219
#define IDD_PROPPAGE_SCRIPTS            10219
#define IDC_EXPIRES                     10220
#define IDD_APP_PROC                    10220
#define IDC_DATE_BUTTON                 10221
#define IDD_APP_RECYCLE                 10221
#define IDC_ENABLE                      10222
#define IDD_TIME_PICKER                 10222
#define IDC_QUESTIONAIRE                10223
#define IDC_MOREINFO                    10224
#define IDC_RATSYSTEM                   10225
#define IDC_TITLE                       10226
#define IDC_STATIC_ICON                 10227
#define IDC_STATIC_CATEGORY             10228
#define IDC_STATIC_RATING               10229
#define IDC_STATIC_OPTIONAL             10230
#define IDC_STATIC_EMAIL                10231
#define IDC_STATIC_MOD_DATE             10232
#define IDC_STATIC_EXPIRES              10233
#define IDC_MSACALCTRL                  10234
#define IDC_CHECK1                      10235
#define IDC_CHK_SCRIPT_ENGINE           10235
#define IDC_CHK_EXCEPTION_CATCH         10235
#define IDC_RECYCLE_TIMER               10235
#define IDC_CHECK2                      10236
#define IDC_CHK_ENABLE_BUFFERING        10236
#define IDC_CHK_FILE_EXISTS             10236
#define IDC_CHK_JAVA_DEBUG              10236
#define IDC_CHECK3                      10237
#define IDC_CHK_ENABLE_PARENTS          10237
#define IDC_CHECK4                      10238
#define IDC_CHK_WRITE_FAIL_TO_LOG       10238
#define IDC_CHECK5                      10239
#define IDC_EDIT1                       10240
#define IDC_EDT_SESSION_TIMEOUT         10240
#define IDC_EDT_EXECUTABLE              10240
#define IDC_TIMESPAN                    10240
#define IDC_EDIT2                       10241
#define IDC_EDT_NUM_ENGINES             10241
#define IDC_EDT_EXTENSION               10241
#define IDC_REQUEST_LIMIT               10241
#define IDC_COMBO1                      10242
#define IDC_CMBO_LANGUAGES              10242
#define IDC_EDIT3                       10243
#define IDC_EDT_SCRIPT_TIMEOUT          10243
#define IDC_EDT_EXCLUSIONS              10243
#define IDC_RADIO1                      10244
#define IDC_RDO_CACHE_ALL               10244
#define IDC_RADIO_ALL_VERBS             10244
#define IDC_RADIO2                      10245
#define IDC_RDO_CACHE_SIZE              10245
#define IDC_RADIO_LIMIT_VERBS           10245
#define IDC_EDIT4                       10246
#define IDC_EDT_CACHE_SIZE              10246
#define IDC_LIST1                       10247
#define IDC_LIST                        10247
#define IDC_RDO_CACHE_NONE              10247
#define IDC_BUTTON1                     10248
#define IDC_ADD                         10248
#define IDC_ADD_TIME                    10248
#define IDC_BUTTON2                     10249
#define IDC_REMOVE                      10249
#define IDC_BUTTON3                     10250
#define IDC_EDIT                        10250
#define IDC_CHK_ENABLE                  10251
#define IDC_CHK_SERVER_DEBUG            10251
#define IDC_CHK_BREAK                   10252
#define IDC_CHK_CLIENT_DEBUG            10252
#define IDC_RDO_SEND_DETAILED_ERROR     10253
#define IDC_RDO_SEND_DEF_ERROR          10254
#define IDC_DEFAULT_ERROR               10255
#define IDC_CHK_POOL_ODBC               10256
#define IDC_ODBC_TIMEOUT                10257
#define IDC_CGI_SECONDS                 10258
#define IDC_ODBC_TITLE                  10259
#define IDC_ODBC_SECONDS                10260
#define IDC_CGI_UNITS                   10261
#define IDC_ODBC_UNITS                  10262
#define IDC_CHK_ENABLE_SESSION          10263
#define IDC_SESSION_TITLE               10264
#define IDC_SESSION_UNITS               10265
#define IDC_CACHE_UNITS                 10266
#define IDC_LANG_TITLE                  10267
#define IDC_CHK_CACHE_ISAPI             10268
#define ID_HELPBTN                      10269
#define IDC_EDT_LANGUAGES               10270
#define IDC_RECYCLE_TIMESPAN            10271
#define IDC_RECYCLE_REQUESTS            10272
#define IDC_TIMES_LIST                  10273
#define IDC_TIME_PICKER                 10274

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        10223
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         10275
#define _APS_NEXT_SYMED_VALUE           10101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\cnfgprts\wrapmb.cpp ===
/*++

Module Name:

    wrapmb.cpp

Abstract:

    wrapper classes for the metabase class. Yes, I am wrapping a wrapper. Why?
        because including mb.hxx totally screws up the headers in my stdafx based
        MFC files. This way they can just include wrapmb.h and not have to worry
        about including all the other stuff. Also, I can set INITGUID here. That
        way I can use precompiled headers in the main project to Greatly increase
        compile times. If that isn't reason enough, then I can also manage the pointer
        to the interface object itself here.

Author:

   Boyd Multerer boydm

--*/

//C:\nt\public\sdk\lib\i386

#include "stdafx.h"

/*
#define INITGUID

#ifdef __cplusplus
extern "C" {
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <lm.h>

#include <stdio.h>
#include <stdlib.h>

#ifdef __cplusplus
} // extern "C"
#endif // __cplusplus

#include <ole2.h>
#include <coguid.h>

*/
#include <iadmw.h>

#include "iiscnfg.h"
#include "wrapmb.h"

#ifdef _NO_TRACING_
DECLARE_DEBUG_PRINTS_OBJECT();
#endif

#define     MB_TIMEOUT          5000


// a macro to automatically cast the pointer to the mb object
//#define _pmb    ((MB*)m_pvMB)


// globals
//IMSAdminBase*                g_pMBCom = NULL;


//              $(BASEDIR)\private\iis\svcs\lib\*\isdebug.lib \
//              $(BASEDIR)\private\iis\svcs\lib\*\tsstr.lib \
//              $(BASEDIR)\private\iis\svcs\lib\*\tsres.lib
//TARGETLIBS=\
//         ..\..\..\svcs\lib\*\isdebug.lib \
//         ..\..\..\svcs\lib\*\tsstr.lib


//----------------------------------------------------------------
IMSAdminBase*   FInitMetabaseWrapper( OLECHAR* pocMachineName )
    {
    IClassFactory*  pcsfFactory = NULL;
    COSERVERINFO        csiMachineName;
    COSERVERINFO*       pcsiParam = NULL;
    HRESULT             hresError;
    IMSAdminBase*       pMBCom = NULL;

    //fill the structure for CoGetClassObject
    ZeroMemory( &csiMachineName, sizeof(csiMachineName) );
    // csiMachineName.pAuthInfo = NULL;
    // csiMachineName.dwFlags = 0;
    // csiMachineName.pServerInfoExt = NULL;
    csiMachineName.pwszName = pocMachineName;
    pcsiParam = &csiMachineName;

    hresError = CoGetClassObject(GETAdminBaseCLSID(TRUE), CLSCTX_SERVER, pcsiParam,
                            IID_IClassFactory, (void**) &pcsfFactory);
    if (FAILED(hresError))
                return FALSE;

        // create the instance of the interface
        hresError = pcsfFactory->CreateInstance(NULL, IID_IMSAdminBase, (void **)&pMBCom);

        // release the factory
        pcsfFactory->Release();

        // success
        return pMBCom;
        }

//----------------------------------------------------------------
BOOL    FCloseMetabaseWrapper( IMSAdminBase* pMBCom )
        {
        if ( !pMBCom )
            return FALSE;
        if ( pMBCom )
                {
                pMBCom->Release();
                pMBCom = NULL;
                }
        return TRUE;
        }


//=================================================================== The wrapper class

//----------------------------------------------------------------
CWrapMetaBase::CWrapMetaBase():
                m_pMetabase( NULL ),
                m_hMeta( NULL ),
                m_count(0),
                m_pBuffer( NULL ),
                m_cbBuffer(0),
                m_pPathBuffer( NULL ),
                m_cchPathBuffer( 0 )
    {
    // attempt to allocate the general buffer
    m_pBuffer = GlobalAlloc( GPTR, BUFFER_SIZE );
    if ( m_pBuffer )
        m_cbBuffer = BUFFER_SIZE;
    }

//----------------------------------------------------------------
CWrapMetaBase::~CWrapMetaBase()
    {
    // make sure the metabase handle is closed
    Close();

    // free the buffer
    if ( m_pBuffer )
        GlobalFree( m_pBuffer );
    m_pBuffer = NULL;
    }

//----------------------------------------------------------------
BOOL CWrapMetaBase::FInit( PVOID pMBCom )
    {
    BOOL            fAnswer = FALSE;

    // NULL was passed in, use the global reference - most cases will do this
    if ( pMBCom )
        m_pMetabase = (IMSAdminBase*)pMBCom;

    // if the interface is not there, fail
    if ( !m_pMetabase )
        return FALSE;

    // return success
    return TRUE;
    }


//==========================================================================================
// open, close and save the object and such

//----------------------------------------------------------------
BOOL CWrapMetaBase::Open( LPCTSTR pszPath, DWORD dwFlags )
        {
        return Open( METADATA_MASTER_ROOT_HANDLE, pszPath, dwFlags );
        }

//----------------------------------------------------------------
BOOL CWrapMetaBase::Open( METADATA_HANDLE hOpenRoot, LPCTSTR pszPath, DWORD dwFlags )
    {
    m_count++;
    HRESULT hRes;

    // if a metabase handle is already open, close it
    if ( m_hMeta )
        Close();

    hRes = m_pMetabase->OpenKey( hOpenRoot, pszPath, dwFlags, MB_TIMEOUT, &m_hMeta );

    if ( SUCCEEDED( hRes ))
        return TRUE;
    SetLastError( HRESULTTOWIN32( hRes ) );
    return FALSE;
    }

//----------------------------------------------------------------
BOOL CWrapMetaBase::Close( void )
        {
        if ( m_hMeta )
            {
            m_count--;
            m_pMetabase->CloseKey( m_hMeta );
            }
        m_hMeta = NULL;
        return TRUE;
        }

//----------------------------------------------------------------
BOOL CWrapMetaBase::Save( void )
        {
        HRESULT hRes = m_pMetabase->SaveData();

        if ( SUCCEEDED( hRes ))
            return TRUE;
        SetLastError( HRESULTTOWIN32( hRes ));
        return FALSE;
        }

// enumerate the objects
//----------------------------------------------------------------
// fortunately, we know that there is a max length to the name of any individual
// key in the metabase of 256 characters
BOOL CWrapMetaBase::EnumObjects( LPCTSTR pszPath, LPTSTR pName, DWORD Index )
    {
    // enumerate into the wide character buffer
    HRESULT hRes = m_pMetabase->EnumKeys( m_hMeta, pszPath, pName, Index );

    // Check for success
    if ( SUCCEEDED( hRes ))
        {
        return TRUE;
        }

    SetLastError( HRESULTTOWIN32( hRes ));
    return FALSE;
    }


//==========================================================================================
// Add and delete objects
//----------------------------------------------------------------
BOOL CWrapMetaBase::AddObject( LPCTSTR pszPath )
    {
    HRESULT hRes = m_pMetabase->AddKey( m_hMeta, pszPath );

    if ( SUCCEEDED( hRes ))
        return TRUE;
    SetLastError( HRESULTTOWIN32( hRes ));
    return FALSE;
    }

//----------------------------------------------------------------
BOOL CWrapMetaBase::DeleteObject( LPCTSTR pszPath )
    {
    HRESULT hRes = m_pMetabase->DeleteKey( m_hMeta, pszPath );

    if ( SUCCEEDED( hRes ))
        return TRUE;
    SetLastError( HRESULTTOWIN32( hRes ));
    return FALSE;
    }


//==========================================================================================
// access the metahandle
//----------------------------------------------------------------
METADATA_HANDLE CWrapMetaBase::QueryHandle()
        {
        return m_hMeta;
        }


//==========================================================================================
// setting values
//----------------------------------------------------------------
BOOL CWrapMetaBase::SetDword( LPCTSTR pszPath, DWORD dwPropID, DWORD dwUserType,
                                DWORD dwValue, DWORD dwFlags )
    {
    return SetData( pszPath,
            dwPropID,
            dwUserType,
            DWORD_METADATA,
            (PVOID) &dwValue,
            sizeof( DWORD ),
            dwFlags );
    }

//----------------------------------------------------------------
BOOL CWrapMetaBase::SetString( LPCTSTR pszPath, DWORD dwPropID, DWORD dwUserType,
                              LPCTSTR pszValue, DWORD dwFlags )
    {
    int len = wcslen( pszValue )+1;
    DWORD cbWide = len * sizeof(WCHAR);

    // set the string into place
    BOOL fAnswer = SetData( pszPath,
            dwPropID,
            dwUserType,
            STRING_METADATA,
            (PVOID)pszValue,
            cbWide,            // string length ignored for inprocess clients
            dwFlags );

    // return the answer
    return fAnswer;
    }

//==========================================================================================
// getting values
//----------------------------------------------------------------
BOOL CWrapMetaBase::GetDword( LPCTSTR pszPath, DWORD dwPropID, DWORD dwUserType,
                             DWORD* pdwValue, DWORD dwFlags )
    {
    DWORD cb = sizeof(DWORD);
    return GetData( pszPath,
            dwPropID,
            dwUserType,
            DWORD_METADATA,
            pdwValue,
            &cb,
            dwFlags );
    }

//----------------------------------------------------------------
BOOL CWrapMetaBase::GetString( LPCTSTR pszPath, DWORD dwPropID, DWORD dwUserType,
                              LPTSTR pszValue, DWORD* pcchValue, DWORD dwFlags )
    {
    BOOL    fAnswer = FALSE;

    // get the data and put it right into the buffer - this is the wide version
    if ( GetData( pszPath,
            dwPropID,
            dwUserType,
            STRING_METADATA,
            pszValue,
            pcchValue,
            dwFlags ) )
        {
        fAnswer = TRUE;
        }

    // return the answer
    return fAnswer;
    }

//==========================================================================================
// deleting values
//----------------------------------------------------------------
BOOL CWrapMetaBase::DeleteData( LPCTSTR pszPath, DWORD dwPropID, DWORD dwDataType )
    {
    // go right ahead and delete it
    HRESULT hRes = m_pMetabase->DeleteData( m_hMeta, pszPath, dwPropID, dwDataType );

    // test for success
    if ( SUCCEEDED( hRes ))
        return TRUE;

    // clean up after a failure
    SetLastError( HRESULTTOWIN32( hRes ));
    return(FALSE);
    }

//----------------------------------------------------------------
BOOL CWrapMetaBase::RenameObject( LPCTSTR pszPathOld, LPCTSTR pszNewName )
    {
    // rename the key
    HRESULT hRes = m_pMetabase->RenameKey( m_hMeta, pszPathOld, pszNewName );

    // test for success
    if ( SUCCEEDED( hRes ))
        return TRUE;

    // clean up after a failure
    SetLastError( HRESULTTOWIN32( hRes ));
    return FALSE;
    }

//=====================================================================================

//----------------------------------------------------------------
BOOL CWrapMetaBase::SetData( LPCTSTR pszPath, DWORD dwPropID, DWORD dwUserType, DWORD dwDataType,
                                        PVOID pData, DWORD cbData, DWORD dwFlags )
    {
    METADATA_RECORD mdRecord;
    HRESULT         hRes;

    // prepare the set data record
    mdRecord.dwMDIdentifier  = dwPropID;
    mdRecord.dwMDAttributes  = dwFlags;
    mdRecord.dwMDUserType    = dwUserType;
    mdRecord.dwMDDataType    = dwDataType;
    mdRecord.dwMDDataLen     = cbData;
    mdRecord.pbMDData        = (PBYTE)pData;

    // set the data
    hRes = m_pMetabase->SetData( m_hMeta, pszPath, &mdRecord );

    // test for success
    if ( SUCCEEDED( hRes ))
        return TRUE;

    // there was an error, clean up
    SetLastError( HRESULTTOWIN32( hRes ) );
    return FALSE;
    }

//----------------------------------------------------------------
BOOL CWrapMetaBase::GetData( LPCTSTR pszPath, DWORD dwPropID, DWORD dwUserType, DWORD dwDataType,
                                        PVOID pData, DWORD* pcbData, DWORD dwFlags )
    {
    METADATA_RECORD mdRecord;
    HRESULT         hRes;
    DWORD           dwRequiredLen;

    // prepare the get data record
    mdRecord.dwMDIdentifier  = dwPropID;
    mdRecord.dwMDAttributes  = dwFlags;
    mdRecord.dwMDUserType    = dwUserType;
    mdRecord.dwMDDataType    = dwDataType;
    mdRecord.dwMDDataLen     = *pcbData;
    mdRecord.pbMDData        = (PBYTE)pData;

    // get the data
    hRes = m_pMetabase->GetData( m_hMeta, pszPath, &mdRecord, &dwRequiredLen );

    // test for success
    if ( SUCCEEDED( hRes ))
        {
        *pcbData = mdRecord.dwMDDataLen;
        return TRUE;
        }

    // there was a failure - clean up
    *pcbData = dwRequiredLen;
    SetLastError( HRESULTTOWIN32( hRes ) );
    return FALSE;
    }

//----------------------------------------------------------------
// another form of GetData that automatically allocates the buffer. It should then be
// freed using GlobalFree(p);
PVOID CWrapMetaBase::GetData( LPCTSTR pszPath, DWORD dwPropID, DWORD dwUserType, DWORD dwDataType,
                                        DWORD* pcbData, DWORD dwFlags )
    {
    PVOID           pData = m_pBuffer;
    DWORD           cbData = m_cbBuffer;
    DWORD           err = 0;
    BOOL            f;

    // first - attempt to get the data in the buffer that has already been allocated;
    f = GetData( pszPath, dwPropID, dwUserType, dwDataType, pData, &cbData, dwFlags );

    // if the get data function worked, we can pretty much leave
    if ( f )
        {
        // set the data size
        *pcbData = cbData;
        // return the allocated buffer
        return pData;
        }

    // check the error - it could be some sort of memory error
    err = GetLastError();

    // it is ok that the GetData failed, but the reason had better be ERROR_INSUFFICIENT_BUFFER
    // otherwise, it is something we can't handle
    if ( err != ERROR_INSUFFICIENT_BUFFER )
        return NULL;

    // allocate the buffer
    pData = GlobalAlloc( GPTR, cbData );
    if ( !pData )
        return NULL;

    // first, get the size of the data that we are looking for
    f = GetData( pszPath, dwPropID, dwUserType, dwDataType, pData, &cbData, dwFlags );

    // if that getting failed, we need to cleanup
    if ( !f )
        {
        GlobalFree( pData );
        pData = NULL;
        }

    // set the data size
    *pcbData = cbData;

    // return the allocated buffer
    return pData;
    }

//----------------------------------------------------------------
// free memory returned by GetData
void CWrapMetaBase::FreeWrapData( PVOID pData )
    {
    // if it is trying to free the local buffer, do nothing
    if ( pData == m_pBuffer )
        return;

    // ah - but it was not the local buffer - we should dispose of it
    if ( pData )
        GlobalFree( pData );
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\common2\debugatl.h ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        debugafx.h

   Abstract:

        Debugging routines using ATL extensions

   Author:

        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:

        Internet Services Manager

   Revision History:
        3/20/2000    sergeia        Made this compatible to ATL, not MFC

--*/
#ifndef _DEBUGATL_H
#define _DEBUGATL_H

#if defined(_DEBUG) || DBG

    #undef ATLASSERT
    #undef ASSERT
    #undef _ASSERTE
    #undef VERIFY

    #define _ASSERTE(expr)\
            do { if (!(expr) &&\
                    (IISUIFireAssert(__FILE__, __TIMESTAMP__, __LINE__, #expr)==1))\
                 DebugBreak(); } while (0)

    #define ASSERT(expr)    _ASSERTE(expr)

    #define VERIFY(expr)    _ASSERTE(expr)
    #define ATLASSERT(expr) _ASSERTE(expr)

    #define ASSERT_PTR(ptr)                 _ASSERTE(ptr != NULL);
    #define ASSERT_READ_PTR(ptr)            _ASSERTE(ptr != NULL && !IsBadReadPtr(ptr, sizeof(*ptr)));
    #define ASSERT_READ_PTR2(ptr, cb)       _ASSERTE(ptr != NULL && !IsBadReadPtr(ptr, cb));
    #define ASSERT_WRITE_PTR(ptr)           _ASSERTE(ptr != NULL && !IsBadWritePtr(ptr, sizeof(*ptr)));
    #define ASSERT_WRITE_PTR2(ptr, cb)      _ASSERTE(ptr != NULL && !IsBadWritePtr(ptr, cb));
    #define ASSERT_READ_WRITE_PTR(ptr)      ASSERT_READ_PTR(ptr); ASSERT_WRITE_PTR(ptr);
    #define ASSERT_READ_WRITE_PTR2(ptr, cb) ASSERT_READ_PTR2(ptr, cb); && ASSERT_WRITE_PTR2(ptr, cb);
    #define ASSERT_MSG(msg)\
            do { if (IISUIFireAssert(__FILE__, __TIMESTAMP__, __LINE__, msg)==1)\
                 DebugBreak(); } while (0)

    int _EXPORT
    IISUIFireAssert(
        const char * filename,
        const char * timestamp,
        int linenum,
        const char * expr
        );

#else
    //
    // Retail
    //
    #undef ATLASSERT
    #undef ASSERT
    #undef VERIFY

    #define ATLASSERT
    #define ASSERT
    #define VERIFY(exp)    (exp)
    #define ASSERT_PTR(ptr)           
    #define ASSERT_READ_PTR(ptr)
    #define ASSERT_READ_PTR2(ptr, cb)
    #define ASSERT_WRITE_PTR(ptr)
    #define ASSERT_WRITE_PTR2(ptr, cb)
    #define ASSERT_READ_WRITE_PTR(ptr)
    #define ASSERT_READ_WRITE_PTR2(ptr, cb)
    #define ASSERT_MSG(msg)                 

#endif // _DEBUG || DBG


#ifndef TRACE
   #define TRACE                   ATLTRACE
#endif

#ifndef TRACE0
  #ifdef _DEBUG
    #define TRACE0(fmt) TRACE(fmt)
    #define TRACE1(fmt, a1) TRACE(fmt, a1)
    #define TRACE2(fmt, a1, a2) TRACE(fmt, a1, a2)
    #define TRACE3(fmt, a1, a2, a3) TRACE(fmt, a1, a2, a3)
    #define TRACE4(fmt, a1, a2, a3, a4) TRACE(fmt, a1, a2, a3, a4)
  #else // _DEBUG
    #define TRACE0(fmt)
    #define TRACE1(fmt, a1)
    #define TRACE2(fmt, a1, a2)
    #define TRACE3(fmt, a1, a2, a3)
    #define TRACE4(fmt, a1, a2, a3, a4)
  #endif // _DEBUG
#endif // TRACE0

#if defined(_DEBUG) || DBG
   #define TRACEEOLID(msg)\
      do {TRACE("%s %d %s\n", __FILE__, __LINE__, msg); } while (FALSE)
   #define TRACEEOLERR(err,x) { if (err) TRACEEOLID(x) }
   #define TRACEEOL(msg)\
       do {TRACE("%s\n", msg);} while (FALSE)
#else
   #define TRACEEOLID(msg)
   #define TRACEEOLERR(err,x)
   #define TRACEEOL(msg)
#endif

#define TRACE_RETURN(msg, err) TRACEEOLID(msg); return err;
#define TRACE_NOTIMPL(msg)     TRACE_RETURN(msg, E_NOTIMPL);
#define TRACE_NOINTERFACE(msg) TRACE_RETURN(msg, E_NOINTERFACE);
#define TRACE_UNEXPECTED(msg)  TRACE_RETURN(msg, E_UNEXPECTED);
#define TRACE_POINTER(msg)     TRACE_RETURN(msg, E_POINTER);

#endif // _DEBUGATL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\common2\debugatl.cpp ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :
        debugafx.cpp

   Abstract:
        Debugging routines using AFX/MFC extensions

   Author:
        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:
        3/20/2000    sergeia        Made this compatible to ATL, not MFC
--*/



//
// Include Files
//
#include "stdafx.h"
#include "common.h"

#if defined(_DEBUG) || DBG

int 
IISUIFireAssert(
    const char * filename,
    const char * timestamp,
    int linenum,
    const char * expr
    )
{
    char sz[4096];
    char * pch = sz;

    pch += wsprintfA(pch, 
        "-------------------------------------------------------------------------------\n"
        "ASSERT FAILURE!\n"
        "-------------------------------------------------------------------------------\n"
        "File:\t\t%s\n"
        "Line:\t\t%u\n"
        "Time Stamp:\t%s\n"
        "-------------------------------------------------------------------------------\n",
        filename, linenum, timestamp
        );
        
    if (expr)
    {
        wsprintfA(pch, "Expression:\t%s\n"
        "-------------------------------------------------------------------------------\n",
        expr
        );
    } 

    TRACEEOL(sz);

    int nReturn = MessageBoxA(
        NULL, 
        sz, 
        "ASSERT FAILURE!", 
        MB_ABORTRETRYIGNORE | MB_DEFBUTTON1 | MB_ICONHAND
        );
    
    if (nReturn == IDABORT)
    {
        exit(-1);
    }
    
    //
    // Return 1 to break, 0 to ignore
    //
    return (nReturn == IDRETRY);
}


#endif // _DEBUG || DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\common2\iiscstring.h ===
//
//    IISCString.h
//
//////////////////////////////////////////////////////////////////////////////

#if !defined(IISCSTRING_H)
#define IISCSTRING_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

//////////////////////////////////////////////////////////////////////////////
#pragma warning(disable:4786) // Disable warning for names > 256
#pragma warning(disable:4275) // Disable warning for non dll-interface class used as a base class

#include <string>
#include <cstring>
#include "common.h"

//////////////////////////////////////////////////////////////////////////////

namespace IIS
{
   class _EXPORT CString : public std::basic_string<TCHAR>
   {
   public:
      // Constructors
      CString();
      CString(const CString& strInput);
      CString(const std::basic_string<TCHAR>& strInput);
      CString(TCHAR ch, int nRepeat = 1);
#ifdef _UNICODE
	   CString(LPCSTR lpsz);
#endif
#ifndef _UNICODE
	   CString(LPCWSTR lpsz);
#endif
      CString(LPCTSTR p);
	   CString(LPCTSTR lpch, int nLength);
	   CString(const unsigned char * psz);
      CString(const CComBSTR& bstr);

      ~CString();

      int GetLength() const;
      bool IsEmpty() const;
      void Empty();
      TCHAR GetAt(int nIndex) const;
	   TCHAR operator[](int nIndex) const;
      void SetAt(int nIndex, TCHAR ch);
	   operator LPCTSTR() const;           // as a C string

	   const CString& operator=(const CString& stringSrc);
	   const CString& operator=(TCHAR ch);
      const CString& operator=(LPCTSTR p);
#ifdef _UNICODE
	   const CString& operator=(char ch);
	   const CString& operator=(LPCSTR lpsz);
	   const CString& operator=(const unsigned char* psz);
#endif
#ifndef _UNICODE
	   const CString& operator=(WCHAR ch);
	   const CString& operator=(LPCWSTR lpsz);
#endif

	   // string concatenation
	   const CString& operator+=(const CString& string);
	   const CString& operator+=(TCHAR ch);
#ifdef _UNICODE
   	const CString& operator+=(char ch);
#endif
	   const CString& operator+=(LPCTSTR lpsz);

	   friend CString __stdcall operator+(const CString& string1, const CString& string2);
	   friend CString __stdcall operator+(const CString& string, TCHAR ch);
	   friend CString __stdcall operator+(TCHAR ch, const CString& string);
#ifdef _UNICODE
   	friend CString __stdcall operator+(const CString& string, char ch);
	   friend CString __stdcall operator+(char ch, const CString& string);
#endif
	   friend CString __stdcall operator+(const CString& string, LPCTSTR lpsz);
	   friend CString __stdcall operator+(LPCTSTR lpsz, const CString& string);

	   int Compare(LPCTSTR lpsz) const;         // straight character
	   int CompareNoCase(LPCTSTR lpsz) const;   // ignore case
	   int Collate(LPCTSTR lpsz) const;         // NLS aware

	   // simple sub-string extraction
	   CString Mid(int nFirst, int nCount) const;
	   CString Mid(int nFirst) const;
	   CString Left(int nCount) const;
	   CString Right(int nCount) const;

	   CString SpanIncluding(LPCTSTR lpszCharSet) const;
	   CString SpanExcluding(LPCTSTR lpszCharSet) const;

	   // upper/lower/reverse conversion
	   void MakeUpper();
	   void MakeLower();
	   void MakeReverse();

	   // trimming whitespace (either side)
	   void TrimRight();
	   void TrimLeft();

	   // advanced manipulation
	   // replace occurrences of chOld with chNew
	   int Replace(TCHAR chOld, TCHAR chNew);
	   // replace occurrences of substring lpszOld with lpszNew;
	   // empty lpszNew removes instances of lpszOld
	   int Replace(LPCTSTR lpszOld, LPCTSTR lpszNew);
	   // remove occurrences of chRemove
	   int Remove(TCHAR chRemove);
	   // insert character at zero-based index; concatenates
	   // if index is past end of string
	   int Insert(int nIndex, TCHAR ch);
	   // insert substring at zero-based index; concatenates
	   // if index is past end of string
	   int Insert(int nIndex, LPCTSTR pstr);
	   // delete nCount characters starting at zero-based index
	   int Delete(int nIndex, int nCount = 1);

	   // searching (return starting index, or -1 if not found)
	   // look for a single character match
	   int Find(TCHAR ch) const;               // like "C" strchr
	   int ReverseFind(TCHAR ch) const;
	   int FindOneOf(LPCTSTR lpszCharSet) const;

	   // look for a specific sub-string
	   int Find(LPCTSTR lpszSub) const;        // like "C" strstr

	   // Concatentation for non strings
//	   const CString& Append(int n)
//	   {
//		   TCHAR szBuffer[10];
//		   wsprintf(szBuffer,_T("%d"),n);
//		   ConcatInPlace(SafeStrlen(szBuffer), szBuffer);
//		   return *this;
//	   }

   	// simple formatting
      void __cdecl FormatV(LPCTSTR lpszFormat, va_list argList);
	   void __cdecl Format(LPCTSTR lpszFormat, ...);
	   void __cdecl Format(HINSTANCE hInst, UINT nFormatID, ...);

	   // formatting for localization (uses FormatMessage API)
	   BOOL __cdecl FormatMessage(LPCTSTR lpszFormat, ...);
	   BOOL __cdecl FormatMessage(HINSTANCE hInst, UINT nFormatID, ...);

	   // Windows support
	   BOOL LoadString(HINSTANCE hInstance, UINT nID);
#ifndef _UNICODE
   	// ANSI <-> OEM support (convert string in place)
	   void AnsiToOem();
	   void OemToAnsi();
#endif

#ifndef _ATL_NO_COM
	   // OLE BSTR support (use for OLE automation)
	   BSTR AllocSysString() const;
	   BSTR SetSysString(BSTR* pbstr) const;
#endif //!_ATL_NO_COM

   };

   //////////////////////////////////////////////////////////////////////////////
inline bool operator==(const CString& s1, const CString& s2)
	{ return s1.compare(s2) == 0; }
inline bool operator==(const CString& s1, const TCHAR * s2)
	{ return s1.compare(s2) == 0; }
inline bool operator==(const TCHAR * s1, const CString& s2)
	{ return s2.compare(s1) == 0; }

inline bool operator!=(const CString& s1, const CString& s2)
	{ return s1.compare(s2) != 0; }
inline bool operator!=(const CString& s1, const TCHAR * s2)
	{ return s1.compare(s2) != 0; }
inline bool operator!=(const TCHAR * s1, const CString& s2)
	{ return s2.compare(s1) != 0; }

inline bool operator<(const CString& s1, const CString& s2)
	{ return s1.compare(s2) < 0; }
inline bool operator<(const CString& s1, const TCHAR * s2)
	{ return s1.compare(s2) < 0; }
inline bool operator<(const TCHAR * s1, const CString& s2)
	{ return s2.compare(s1) > 0; }

inline bool operator>(const CString& s1, const CString& s2)
	{ return s1.compare(s2) > 0; }
inline bool operator>(const CString& s1, const TCHAR * s2)
	{ return s1.compare(s2) > 0; }
inline bool operator>(const TCHAR * s1, const CString& s2)
	{ return s2.compare(s1) < 0; }

inline bool operator<=(const CString& s1, const CString& s2)
	{ return s1.compare(s2) <= 0; }
inline bool operator<=(const CString& s1, const TCHAR * s2)
	{ return s1.compare(s2) <= 0; }
inline bool operator<=(const TCHAR * s1, const CString& s2)
	{ return s2.compare(s1) >= 0; }

inline bool operator>=(const CString& s1, const CString& s2)
	{ return s1.compare(s2) >= 0; }
inline bool operator>=(const CString& s1, const TCHAR * s2)
	{ return s1.compare(s2) >= 0; }
inline bool operator>=(const TCHAR * s1, const CString& s2)
	{ return s2.compare(s1) <= 0; }

inline CString __stdcall operator+(const CString& string1, const CString& string2)
{
   CString s = string1;
   s += string2;
   return s;
}

inline CString __stdcall operator+(const CString& string, LPCTSTR lpsz)
{
	ATLASSERT(lpsz == NULL);
	CString s = string;
	s += lpsz;
	return s;
}

inline CString __stdcall operator+(LPCTSTR lpsz, const CString& string)
{
	ATLASSERT(lpsz == NULL);
	CString s = lpsz;;
	s += string;
	return s;
}

inline CString __stdcall operator+(const CString& string, TCHAR c)
{
	CString s = string;
	s += c;
	return s;
}

inline CString __stdcall operator+(TCHAR c, const CString& string)
{
	CString s;
	s += c;
   s += string;
	return s;
}

}; // namespace IIS

#pragma warning(default:4786) // Enable warning for names > 256
#pragma warning(default:4275) 

#endif // !defined(IISCSTRING_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\common2\guid.cpp ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        guid.cpp

   Abstract:

        Initialization as required by initguid

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager (cluster edition)

   Revision History:

--*/

//
// Include Files
//
#include <stdafx.h>
#include <winsvc.h>

#include <objbase.h>
#include <initguid.h>

#include <iwamreg.h>
#include <iadmw.h>
#include <iisrsta.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\common2\iiscstring.cpp ===
//
//    IISCStringImpl.cpp
//
//////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"

#pragma warning(disable:4786) // Disable warning for names > 256

#include "common.h"
#include <algorithm>
#include <deque>
#include <TCHAR.h>
#include "IISCString.h"

//////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////
// Constructors
///////////////////////////////////////////////////////////////////////////
CString::CString()
      :  std::basic_string<TCHAR>() 
{
}

CString::CString(const CString& strInput)
      :  std::basic_string<TCHAR>(strInput) 
{
}

CString::CString(const std::basic_string<TCHAR>& strInput)
      :  std::basic_string<TCHAR>(strInput) 
{
}

CString::CString(TCHAR ch, int nRepeat /* = 1*/)
      :  std::basic_string<TCHAR>(nRepeat, ch) 
{
}

CString::CString(LPCTSTR p)
      :  std::basic_string<TCHAR>(p) 
{
}

#ifdef _UNICODE
CString::CString(LPCSTR strInput)
{
   int len = strlen(strInput);
   TCHAR * buf = (TCHAR *)_alloca(len * (sizeof(TCHAR) + 1));
   if (0 != MultiByteToWideChar(CP_THREAD_ACP, MB_PRECOMPOSED,
      strInput, len, buf, len))
   {
      assign(buf);
   }
   else
   {
      ATLASSERT(FALSE);
   }
}
#endif

#ifndef _UNICODE
CString::CString(LPCWSTR strInput)
{
   int len = wstrlen(strInput);
   int buflen = len * (sizeof(TCHAR) + 1);
   TCHAR * buf = (TCHAR *)_alloca(buflen);
   if (0 != WideCharToMultiByte(CP_THREAD_ACP, 0,
      strInput, len, buf, buflen))
   {
      assign(buf);
   }
   else
   {
      ATLASSERT(FALSE);
   }
}
#endif

CString::CString(const CComBSTR& bstr)
{
   assign((LPCTSTR)bstr.m_str);
}

CString::~CString()
{
}

///////////////////////////////////////////////////////////////////////////
// The string as an array
///////////////////////////////////////////////////////////////////////////

int CString::GetLength() const
{
   return length();
};

bool CString::IsEmpty() const
{
   return empty();
};

void CString::Empty()
{
   erase();
};

TCHAR CString::GetAt(int nIndex) const
{
	ATLASSERT(nIndex >= 0);
   return at(nIndex);
};

TCHAR CString::operator[](int nIndex) const
{
	// same as GetAt
	ATLASSERT(nIndex >= 0);
	return at(nIndex);
}

void CString::SetAt(int nIndex, TCHAR ch)
{
   at(nIndex) = ch;
};

const CString& CString::operator=(const CString& stringSrc)
{
   assign(stringSrc);
	return *this;
}

const CString& CString::operator=(LPCTSTR p)
{
   // Here we will have a problem if NULL pointer is passed because
   // later STL will call wcslen(NULL) which uses *p without test.
   // We will emulate the result by erasing current string
   if (p == NULL)
      erase();
   // another problem is when we assign string to self, like str = str.c_str()
   // STL deletes data and then assign it resulting in garbage
   else if (p != this->data())
      assign(p);
   return *this;
}

#ifdef _UNICODE
const CString& CString::operator=(const unsigned char * lpsz)
{ 
   int len = strlen((const char *)lpsz);
   TCHAR * buf = (TCHAR *)_alloca(len * (sizeof(TCHAR) + 1));
   if (0 != MultiByteToWideChar(CP_THREAD_ACP, MB_PRECOMPOSED, (const char *)lpsz, -1, buf, len))
   {
      assign(buf);
   }
   else
   {
      ATLASSERT(FALSE);
   }
   return *this; 
}
#endif

const CString& CString::operator=(TCHAR c)
{
   assign(1, c);
   return *this;
}

#ifdef _UNICODE
const CString& CString::operator+=(char ch)
{ 
   *this += (TCHAR)ch; 
   return *this; 
}

const CString& CString::operator=(char ch)
{ 
   *this = (TCHAR)ch; 
   return *this; 
}

CString __stdcall operator+(const CString& string, char ch)
{ 
   return string + (TCHAR)ch; 
}

CString __stdcall operator+(char ch, const CString& string)
{ 
   return (TCHAR)ch + string; 
}
#endif

const CString& CString::operator+=(TCHAR ch)
{ 
   append(1, ch);
   return *this;
}

const CString& CString::operator+=(const CString& s)
{ 
   append(s); 
   return *this; 
}

const CString& CString::operator+=(LPCTSTR p)
{ 
   append(p); 
   return *this; 
}

static int __stdcall _LoadString(HINSTANCE hInstance, UINT nID, LPTSTR lpszBuf, UINT nMaxBuf)
{
#ifdef _DEBUG
	// LoadString without annoying warning from the Debug kernel if the
	//  segment containing the string is not present
	if (::FindResource(hInstance, MAKEINTRESOURCE((nID>>4)+1), RT_STRING) == NULL)
	{
		lpszBuf[0] = '\0';
		return 0; // not found
	}
#endif //_DEBUG
	int nLen = ::LoadString(hInstance, nID, lpszBuf, nMaxBuf);
	if (nLen == 0)
		lpszBuf[0] = '\0';
	return nLen;
}

#ifdef _UNICODE
#define CHAR_FUDGE 1    // one TCHAR unused is good enough
#else
#define CHAR_FUDGE 2    // two BYTES unused for case of DBC last char
#endif

#define INITIAL_SIZE    256

BOOL CString::LoadString(HINSTANCE hInstance, UINT id)
{
	// try fixed buffer first (to avoid wasting space in the heap)
	TCHAR szTemp[INITIAL_SIZE];
	int nCount =  sizeof(szTemp) / sizeof(szTemp[0]);
	int nLen = _LoadString(hInstance, id, szTemp, nCount);
	if (nCount - nLen > CHAR_FUDGE)
	{
		*this = szTemp;
		return nLen > 0;
	}

	// try buffer size of 512, then larger size until entire string is retrieved
	int nSize = INITIAL_SIZE;
   LPTSTR p = NULL;
	do
	{
		nSize += INITIAL_SIZE;
      p = get_allocator().allocate(nSize, p);
		nLen = _LoadString(hInstance, id, p, nSize - 1);
	} while (nSize - nLen <= CHAR_FUDGE);
   if (nLen > 0)
      assign(p, nLen);

	return nLen > 0;
}

///////////////////////////////////////////////////////////////////////////
// Comparison
///////////////////////////////////////////////////////////////////////////

int CString::Compare(const TCHAR * psz) const
{
   if (psz == NULL)
      return this->empty() ? 0 : 1;
   return compare(psz);
};

int CString::CompareNoCase(const TCHAR * psz) const
{
   if (psz == NULL)
      return this->empty() ? 0 : 1;
   return _tcsicmp(c_str(), psz);
};

int CString::Collate(const TCHAR * psz) const
{
   if (psz == NULL)
      return this->empty() ? 0 : 1;
   return _tcscoll(c_str(), psz);
};

///////////////////////////////////////////////////////////////////////////
// Extraction
///////////////////////////////////////////////////////////////////////////

CString CString::Mid(int nFirst) const
{
   return substr(nFirst);
};

CString CString::Mid(int nFirst, int nCount) const
{
   return substr(nFirst, nCount);
};

CString CString::Left(int nCount) const
{
   return substr(0, nCount);
};

CString CString::Right(int nCount) const
{
   return substr(length() - nCount, nCount);
};

CString CString::SpanIncluding(const TCHAR * pszCharSet) const
{
   return substr(0, find_first_not_of(pszCharSet));
};

CString CString::SpanExcluding(const TCHAR * pszCharSet) const
{
   return substr(0, find_first_of(pszCharSet));
};

///////////////////////////////////////////////////////////////////////////
// Other Conversions
///////////////////////////////////////////////////////////////////////////

void CString::MakeUpper()
{
   std::for_each(begin(), end(), _totupper);
};

void CString::MakeLower()
{
   std::for_each(begin(), end(), _totlower);
};

void CString::MakeReverse()
{
   std::reverse(begin(), end());
};

void CString::TrimLeft()
{
   while (_istspace(at(0)))
	   erase(0, 1);
};

void CString::TrimRight()
{
   while (_istspace(at(length() - 1)))
	   erase(length() - 1, 1);
};

#define BUFFER_SIZE     1024

void __cdecl CString::FormatV(LPCTSTR lpszFormat, va_list argList)
{
   TCHAR buf[BUFFER_SIZE];
   if (-1 != _vsntprintf(buf, BUFFER_SIZE, lpszFormat, argList))
   {
      assign(buf);
   }
}

// formatting (using wsprintf style formatting)
void __cdecl CString::Format(LPCTSTR lpszFormat, ...)
{
	va_list argList;
	va_start(argList, lpszFormat);
	FormatV(lpszFormat, argList);
	va_end(argList);
}

void __cdecl CString::Format(HINSTANCE hInst, UINT nFormatID, ...)
{
	CString strFormat;
	BOOL bRet = strFormat.LoadString(hInst, nFormatID);
	bRet;	// ref
	ATLASSERT(bRet != 0);

	va_list argList;
	va_start(argList, nFormatID);
	FormatV(strFormat, argList);
	va_end(argList);
}

// formatting (using FormatMessage style formatting)
BOOL CString::FormatMessage(LPCTSTR lpszFormat, ...)
{
	// format message into temporary buffer lpszTemp
	va_list argList;
	va_start(argList, lpszFormat);
	LPTSTR lpszTemp;
	BOOL bRet = TRUE;

	if (::FormatMessage(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ALLOCATE_BUFFER,
		lpszFormat, 0, 0, (LPTSTR)&lpszTemp, 0, &argList) == 0 ||
		lpszTemp == NULL)
		bRet = FALSE;

	// assign lpszTemp into the resulting string and free the temporary
	*this = lpszTemp;
	LocalFree(lpszTemp);
	va_end(argList);
	return bRet;
}

BOOL CString::FormatMessage(HINSTANCE hInst, UINT nFormatID, ...)
{
	// get format string from string table
	CString strFormat;
	BOOL bRetTmp = strFormat.LoadString(hInst, nFormatID);
	bRetTmp;	// ref
	ATLASSERT(bRetTmp != 0);

	// format message into temporary buffer lpszTemp
	va_list argList;
	va_start(argList, nFormatID);
	LPTSTR lpszTemp;
	BOOL bRet = TRUE;

	if (::FormatMessage(
            FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ALLOCATE_BUFFER,
		      strFormat, 0, 0, (LPTSTR)&lpszTemp, 0, &argList) == 0 || lpszTemp == NULL
      )
		bRet = FALSE;

	// assign lpszTemp into the resulting string and free lpszTemp
	*this = lpszTemp;
	LocalFree(lpszTemp);
	va_end(argList);
	return bRet;
}

///////////////////////////////////////////////////////////////////////////
// Searching
///////////////////////////////////////////////////////////////////////////
int CString::Find(TCHAR ch) const
{
   return find(ch);
};

int CString::Find(const TCHAR * psz) const
{
   if (psz == NULL)
      return -1;
   return find(psz);
};

int CString::ReverseFind(TCHAR ch) const
{
   return rfind(ch);
};

int CString::FindOneOf(const TCHAR * psz) const
{
   if (psz == NULL)
      return -1;
   return find_first_of(psz);
};

///////////////////////////////////////////////////////////////////////////
// Operators
///////////////////////////////////////////////////////////////////////////

CString::operator const TCHAR *() const
{ 
   return c_str(); 
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\common2\filechooser.h ===
//
// FileChooser.h
//
#ifndef _FILE_CHOOSER_H
#define _FILE_CHOOSER_H

#pragma warning(disable : 4275)

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CFileChooser;
class CFileChooserEdit;

class CFilterEntry
{
public:
   CFilterEntry() 
   {
   }
   CFilterEntry(LPCTSTR text, LPCTSTR ext)
      : m_text(text), m_ext(ext)
   {
   }
   CString m_text;
   CString m_ext;
};

#define FC_UNDEFINED             0x00000000
#define FC_FORWRITE              0x00000001
#define FC_AUTOCOMPLETION        0x00000002
// Put "*.ext" to edit initially if no file with default
// extensions was found in the initial directory
#define FC_WILDCARD_DEFAULT      0x00000004
// Set "description (*.ext)" to FileDialog filter
#define FC_WILDCARD_DESC         0x00000008
// prefill the path edit with default file name
#define FC_PREPARE_DEFAULT       0x00000010
// supress file existance check
#define FC_PATH_CHECK            0x00000020
// Check if entered filename with any of default extensions
// are available in the current directory. If yes, choose it
#define FC_CHECK_FILENAME_ONLY   0x00000040
#define FC_DIRECTORY_ONLY        0x00000080
#define FC_HIDEREADONLY          0x00000100
#define FC_COMMANDLINE           0x00000200

#define FC_DEFAULT\
   FC_AUTOCOMPLETION | FC_WILDCARD_DESC | FC_WILDCARD_DEFAULT | FC_PATH_CHECK
#define FC_DEFAULT_READ\
   FC_DEFAULT | FC_HIDEREADONLY
#define FC_DEFAULT_WRITE\
   FC_DEFAULT | FC_FORWRITE

#define FC_SUCCESS               0x00000000
#define FC_FILE_DOES_NOT_EXIST   0x00000001
#define FC_FILENAME_IS_DIRECTORY 0x00000002
#define FC_FILENAME_IS_FILE      0x00000003
#define FC_TEXT_IS_INVALID       0x00000004
#define FC_WRONG_FORMAT          0x00000005
#define FC_NO_CLOSING_QUOTE      0x00000006

class _EXPORT CFileChooser : 
   public CWindowImpl<CFileChooser>
{
   friend class CFileChooserEdit;
   friend class CFileChooserButton;
public:
   CFileChooser()
      :  m_pParent(NULL),
         m_bDoReplaceFile(FALSE),
         m_bEditDirty(FALSE),
         m_bTextValid(TRUE),
         m_bDialogActive(FALSE),
         m_dwStyle(FC_UNDEFINED),
         m_ofn_Flags(0),
         m_edit(NULL),
         m_button(NULL)
   {
   }
   ~CFileChooser();

BEGIN_MSG_MAP_EX(CFileChooser)
END_MSG_MAP()

   BOOL Init(CWindow * pParent, DWORD dwStyle, UINT idEdit, UINT idButton);
   DWORD GetStyle() const
   {
      return m_dwStyle;
   }
   DWORD SetStyle(DWORD dwStyle)
   {
      DWORD dw = m_dwStyle;
      m_dwStyle = dwStyle;
      return dw;
   }
   BOOL StyleBitSet(DWORD bit)
   {
      return 0 != (m_dwStyle & bit);
   }
   BOOL OpenForRead()
   {
      return !StyleBitSet(FC_FORWRITE);
   }
   void AddStyle(DWORD dwStyle)
   {
      m_dwStyle |= dwStyle;
   }
   void RemoveStyle(DWORD dwStyle)
   {
      m_dwStyle &= ~dwStyle;
   }
   void SetOfnFlags(DWORD flags)
   {
      m_ofn_Flags = flags;
   }
   DWORD GetOfnFlags()
   {
      return m_ofn_Flags;
   }
   void SetDialogTitle(LPCTSTR strTitle)
   {
      m_strTitle = strTitle;
   }
   DWORD GetFileName(CString& str);
   void SetPath(const CString& str);
   void AddExtension(LPCTSTR text, LPCTSTR ext);
   void AddExtension(HINSTANCE hInst, UINT idText, UINT idExt);
   int BrowseForFolderCallback(HWND hwnd, UINT uMsg, LPARAM lParam);

protected:
   void OnBrowseBtn();
   void CreateFilter(CString& strFilter, CString& strDefExt);
   void CreateDefaultPathForRead();
   BOOL BrowseForFile(CString& strPath, CString& strFile);
   BOOL BrowseForFolder(CString& strPath);
   BOOL OnChar(UINT nChar, UINT nRepCnt, UINT nFlags);
   void OnPaste();
   void OnSetEditFocus();
   void OnKillEditFocus();
   BOOL HasEditFocus();
   BOOL IsValidChar(UINT nChar, BOOL bExcludeWildcards = FALSE);
   BOOL IsValidPath(LPCTSTR);
   void SetCompactedPath(LPCTSTR path);
   void SetPathToEdit(LPCTSTR path);
   int ExtractPath(LPTSTR path);
   int ExtractArgs(LPTSTR buf);
   void GetText(LPTSTR buf);
   int GetFilterIndex(const CString& fileName);

protected:
   DWORD m_ofn_Flags;
   CWindow * m_pParent;
   CFileChooserEdit * m_edit;
   CFileChooserButton * m_button;
   DWORD m_dwStyle;
   CString m_strPath;
   LPTSTR m_pPathTemp;
   CString m_strTitle;
   std::list<CFilterEntry> m_ext;
   BOOL m_bDoReplaceFile;
   BOOL m_bEditDirty;
   BOOL m_bTextValid;
   BOOL m_bDialogActive;
};

#endif   //_FILE_CHOOSER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\common2\filechooser.cpp ===
//
// FileChooser.cpp
//
#include "stdafx.h"
#include "common.h"
#include "FileChooser.h"
#include <Shlwapi.h>
#include <ShlObj.h>
#include <CommDlg.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

const TCHAR QuotMark = _T('\"');
const TCHAR AllExt[] = _T(".*");

class CFileChooserControl : 
   public CWindowImpl<CFileChooserControl>
{
public:
   CFileChooserControl()
      :  m_pParent(NULL), 
         m_pCtlParent(NULL),
         m_id(0)
   {
   }
   BOOL SubclassDlgItem(UINT id, CWindow * pParent)
   {
      HWND hwnd = pParent->GetDlgItem(id);
      ASSERT(hwnd != NULL);
      if (SubclassWindow(hwnd))
      {
         m_id = id;
         m_pCtlParent = pParent;
         return TRUE;
      }
      return FALSE;
   }
   void SetParent(CFileChooser * pParent)
   {
      ASSERT(pParent != NULL);
      m_pParent = pParent;
   }
protected:
   UINT m_id;
   CWindow * m_pCtlParent;
   CFileChooser * m_pParent;
};

class CFileChooserEdit : 
   public CFileChooserControl
{
public:

BEGIN_MSG_MAP_EX(CFileChooserEdit)
	MESSAGE_HANDLER_EX(WM_CHAR, OnChar)
	MESSAGE_HANDLER_EX(WM_PASTE, OnPaste)
	MESSAGE_HANDLER_EX(WM_SETFOCUS, OnSetFocus)
	MESSAGE_HANDLER_EX(WM_KILLFOCUS, OnKillFocus)
END_MSG_MAP()

	LRESULT OnChar(UINT nMsg, WPARAM, LPARAM);
	LRESULT OnPaste(UINT nMsg, WPARAM, LPARAM);
	LRESULT OnSetFocus(UINT nMsg, WPARAM, LPARAM);
	LRESULT OnKillFocus(UINT nMsg, WPARAM, LPARAM);
};

class CFileChooserButton : 
   public CFileChooserControl
{
public:

BEGIN_MSG_MAP_EX(CFileChooserButton)
   MESSAGE_HANDLER_EX(BM_SETSTATE, OnSetState)
   MSG_WM_LBUTTONDOWN(OnLButtonDown)
   MSG_WM_LBUTTONUP(OnLButtonUp)
END_MSG_MAP()

   LRESULT OnSetState(UINT nMsg, WPARAM, LPARAM);
   void OnLButtonDown(UINT nFlags, CPoint point);
   void OnLButtonUp(UINT nFlags, CPoint point);
};

//----------------------

LRESULT 
CFileChooserEdit::OnChar(UINT nMsg, WPARAM wParam, LPARAM lParam)
{
   LRESULT res = 0;
   if (m_pParent->OnChar(wParam, (UINT)lParam & 0xFFFF, (UINT)((lParam & 0xFFFF0000) >> 16)))
   {
      res = DefWindowProc(nMsg, wParam, lParam);
   }
   return res;
}

LRESULT
CFileChooserEdit::OnPaste(UINT nMsg, WPARAM wParam, LPARAM lParam)
{
   LRESULT res = m_pCtlParent->SendDlgItemMessage(WM_PASTE, wParam, lParam);
   m_pParent->OnPaste();
   return res;
}

LRESULT 
CFileChooserEdit::OnSetFocus(UINT nMsg, WPARAM wParam, LPARAM lParam)
{
   m_pParent->OnSetEditFocus();
   return DefWindowProc(nMsg, wParam, lParam);
}

LRESULT 
CFileChooserEdit::OnKillFocus(UINT nMsg, WPARAM wParam, LPARAM lParam)
{
   m_pParent->OnKillEditFocus();
   return DefWindowProc(nMsg, wParam, lParam);
}

//---------------------

LRESULT 
CFileChooserButton::OnSetState(UINT nMsg, WPARAM wParam, LPARAM lParam)
{
   // We are producing dialog on the way back
   if (!wParam)
      m_pParent->OnBrowseBtn();
   return DefWindowProc(nMsg, wParam, lParam);
}

void 
CFileChooserButton::OnLButtonDown(UINT nFlags, CPoint point)
{
   m_pCtlParent->SendDlgItemMessage(m_id, BM_SETSTATE, TRUE, 0);
}

void 
CFileChooserButton::OnLButtonUp(UINT nFlags, CPoint point)
{
   m_pCtlParent->SendDlgItemMessage(m_id, BM_SETSTATE, FALSE, 0);
}

//---------------------

CFileChooser::~CFileChooser()
{
//   ASSERT(m_edit != NULL || m_edit->m_hWnd == NULL);
//   ASSERT(m_button != NULL || m_button->m_hWnd == NULL);
   delete m_edit;
   delete m_button;
}

BOOL 
CFileChooser::Init(CWindow * pParent, DWORD dwStyle, UINT idEdit, UINT idButton)
{
   ASSERT(NULL != pParent);
   ASSERT(NULL != pParent->GetDlgItem(idEdit));
   ASSERT(NULL != pParent->GetDlgItem(idButton));
   
   m_pParent = pParent;
   SetStyle(dwStyle);

   m_edit = new CFileChooserEdit;
   m_button = new CFileChooserButton;
 
   if (m_edit != NULL && m_button != NULL)
   {
      m_edit->SetParent(this);
      m_button->SetParent(this);

      if (StyleBitSet(FC_AUTOCOMPLETION))
	      SHAutoComplete(pParent->GetDlgItem(idEdit), SHACF_FILESYSTEM);

      return m_edit->SubclassDlgItem(idEdit, pParent) 
         && m_button->SubclassDlgItem(idButton, pParent);
   }
   return FALSE;
}

// External SetPath
void 
CFileChooser::SetPath(const CString& path)
{
   ASSERT(m_edit->m_hWnd != NULL);
   m_strPath = path;
   if (OpenForRead() && StyleBitSet(FC_PREPARE_DEFAULT))
      CreateDefaultPathForRead();
   SetPathToEdit(m_strPath);
   m_bEditDirty = FALSE;
}

BOOL 
CFileChooser::HasEditFocus()
{
   ASSERT(m_edit->m_hWnd != NULL);
   return GetFocus() == m_edit->m_hWnd;
}

void 
CFileChooser::SetPathToEdit(LPCTSTR path)
{
   if (HasEditFocus())
   {
      m_edit->SetWindowText(path);
   }
   else
   {
      SetCompactedPath(path);
   }
}

void 
CFileChooser::CreateDefaultPathForRead()
{
	if (!PathFileExists(m_strPath))
	{
		// try to find first file with the first extension
      // from the extensions list
      BOOL bDefaultSet = FALSE;
      BOOL bPathEmpty = m_strPath.IsEmpty();
      TCHAR find_str[MAX_PATH];
		WIN32_FIND_DATA find_data;
      if (bPathEmpty)
      {
         GetCurrentDirectory(MAX_PATH, find_str);
         m_strPath = find_str;
      }
      else
      {
         StrCpy(find_str, m_strPath);
         if (!PathIsDirectory(find_str))
         {
		      PathRemoveFileSpec(find_str);
         }
      }
		PathAppend(find_str, _T("*"));
      std::list<CFilterEntry>::iterator it;
      for (it = m_ext.begin(); it != m_ext.end(); it++)
      {
         CString ext = (*it).m_ext;
		   PathAddExtension(find_str, ext);
		   HANDLE hFind = FindFirstFile(find_str, &find_data);
		   if (	hFind != INVALID_HANDLE_VALUE 
			   && (find_data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0
			   )
		   {
            if (!bPathEmpty)
            {
               TCHAR buf[MAX_PATH];
               StrCpy(buf, m_strPath);
			      PathRemoveFileSpec(buf);
               m_strPath = buf;
            }
			   m_strPath += find_data.cFileName;
			   FindClose(hFind);
            bDefaultSet = TRUE;
            break;
		   }
      }
      if (!bDefaultSet && StyleBitSet(FC_WILDCARD_DEFAULT))
		{
			// if nothing found, just attach *.ext to the path
         // find_str was prepared before as xxx\*.
		   m_strPath = find_str;
         if (!m_ext.empty())
         {
            m_strPath += m_ext.front().m_ext;
         }
         else
         {
            m_strPath += _T("*");
         }
		}
	}
}

BOOL 
CFileChooser::IsValidChar(UINT nChar, BOOL bExcludeWildcards)
{
   switch (PathGetCharType((TCHAR)nChar))
   {
   case GCT_INVALID:
      return FALSE;
   case GCT_WILD:
      return !bExcludeWildcards;
   case GCT_LFNCHAR:
   case GCT_SEPARATOR:
   case GCT_SHORTCHAR:
      break;
   }
   return TRUE;
}

BOOL 
CFileChooser::IsValidPath(LPCTSTR path)
{
   UINT len = lstrlen(path);
   BOOL bRes = TRUE;
//   BOOL quotOpen = FALSE;
   for (UINT i = 0; i < len; i++)
   {
      TCHAR c = path[i];
/*
      if (c == QuotMark)
      {
         if (i == 0)
         {
            quotOpen = TRUE;
            continue;
         }
         else
         {
            if (!quotOpen)
            {
               bRes = FALSE;
            }
            break;
         }
      }
*/
      if (!IsValidChar(c, TRUE))
      {
         bRes = FALSE;
         break;
      }
   }
   return bRes;
}

// Character filtering routine for the edit control.
// Returns TRUE if character should be passed to the CEdit
//
BOOL 
CFileChooser::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags)
{
   if (IsValidChar(nChar))
   {
      m_bEditDirty = TRUE;
      return TRUE;
   }
   else
   {
      switch (nChar)
      {
      case VK_DELETE:
      case VK_BACK:
      case _T('/'):
         return TRUE;
      }
      return FALSE;
   }
}

// Text was pasted to edit control
void 
CFileChooser::OnPaste()
{
   TCHAR buf[MAX_PATH];
   int len = m_edit->GetWindowText(buf, MAX_PATH);
   for (int i = 0; i < len || IsValidChar(buf[i]); i++)
      ;
   if (i < len)
   {
      m_edit->SendMessage(EM_SETSEL, i, len - 1);
      m_bTextValid = FALSE;
   }
   else
   {
      m_strPath = buf;
      SetPathToEdit(buf);
      m_bEditDirty = FALSE;
   }
   m_bEditDirty = TRUE;
}

void 
CFileChooser::OnSetEditFocus()
{
   m_edit->SetWindowText(m_strPath);
}

void 
CFileChooser::OnKillEditFocus()
{
   // update internal string buffer with path
   TCHAR buf[MAX_PATH];
   ZeroMemory(buf, MAX_PATH);
   if (m_bEditDirty)
   {
      m_edit->GetWindowText(buf, MAX_PATH);
      m_strPath = buf;
   }
   SetCompactedPath(m_strPath);
   m_bEditDirty = FALSE;
}

void 
CFileChooser::SetCompactedPath(LPCTSTR path)
{
   // compact path before writing to edit
   CRect rc;
   m_edit->GetClientRect(&rc);
   HDC dc = m_edit->GetDC();
   TCHAR buf[MAX_PATH] = {0};
   StrCpy(buf, path);
   PathMakePretty(buf);
   PathCompactPath(dc, buf, rc.Width());
   m_edit->ReleaseDC(dc);
   m_edit->SetWindowText(buf);
}

DWORD 
CFileChooser::GetFileName(CString& strFile)
{
   DWORD dwRes = FC_SUCCESS;
   TCHAR str[MAX_PATH];
   if (  !m_bTextValid
      || FC_SUCCESS != ExtractPath(str)
      || !IsValidPath(str)
      )
      return FC_TEXT_IS_INVALID;
   if (StyleBitSet(FC_PATH_CHECK))
   {
      if (OpenForRead())
      {
	      if (!PathFileExists(str) && !PathIsDirectory(str))
	      {
            BOOL bFound = FALSE;
            if (StyleBitSet(FC_CHECK_FILENAME_ONLY))
            {
		         // try with default extension(s) if it is just filename
               // without any extensions
               LPTSTR p = PathFindExtension(str);
               if (p != NULL && *p == 0)
               {
                  CString strExt, strTest = str;
                  std::list<CFilterEntry>::iterator it;
                  for (it = m_ext.begin(); it != m_ext.end(); it++)
                  {
                     strExt = (*it).m_ext;
		               if (PathFileExists(strTest + strExt))
                     {
                        StrCat(str, strExt);
                        bFound = TRUE;
                        break;
                     }
                  }
               }
            }
            if (!bFound)
               dwRes = FC_FILE_DOES_NOT_EXIST;
	      }
	      else if (PathIsDirectory(str))
	      {
            if (!StyleBitSet(FC_DIRECTORY_ONLY))
            {
               PathAddBackslash(str);
               dwRes = FC_FILENAME_IS_DIRECTORY;
            }
	      }
         else if (StyleBitSet(FC_DIRECTORY_ONLY))
         {
            if (PathFileExists(str))
               dwRes = FC_FILENAME_IS_FILE;
         }
      }
      else if (StyleBitSet(FC_FORWRITE))
      {
         // TODO: make sure we have write access to this path
      }
   }
   if (dwRes == FC_SUCCESS)
   {
      if (StyleBitSet(FC_COMMANDLINE))
      {
         // We are returning whole command line, get it again
         GetText(str);
      }
      strFile = str;
   }
   return dwRes;
}

BOOL 
CFileChooser::BrowseForFile(CString& strPath, CString& strFile)
{
   BOOL bRes = FALSE;
   OPENFILENAME ofn;
   TCHAR buf[MAX_PATH];

   ZeroMemory(&ofn, sizeof(OPENFILENAME));
   StrCpy(buf, strFile);
   ofn.lStructSize = sizeof(OPENFILENAME);
   // We are not using template
   ofn.hInstance = NULL;
   ofn.Flags |= m_ofn_Flags;
	ofn.Flags |= OFN_NOCHANGEDIR | OFN_OVERWRITEPROMPT;
	if (OpenForRead())
		ofn.Flags |= OFN_FILEMUSTEXIST;
	else
		ofn.Flags |= (OFN_NOREADONLYRETURN | OFN_NOTESTFILECREATE | OFN_HIDEREADONLY);
#if (_WIN32_WINNT >= 0x0500)
   ofn.FlagsEx &= ~(OFN_EX_NOPLACESBAR);
#endif
   // Create filter using our extensions list
   CString strFilter, strDefExt;
   CreateFilter(strFilter, strDefExt);
	ofn.lpstrDefExt = strDefExt;
	ofn.lpstrFile = buf;
	ofn.nMaxFile = MAX_PATH;
	ofn.lpstrInitialDir = strPath.IsEmpty() ? NULL : (LPCTSTR)strPath;
	ofn.lpstrFilter = strFilter;
	ofn.nFilterIndex = GetFilterIndex(strFile);
   // We better set the owner, or this dialog will be visible on task bar
   ofn.hwndOwner = m_pParent->m_hWnd;
   ofn.lpstrTitle = m_strTitle; 

   if (StyleBitSet(FC_HIDEREADONLY))
      ofn.Flags |= OFN_HIDEREADONLY;
   if (!StyleBitSet(FC_FORWRITE))
      bRes = GetOpenFileName(&ofn);
   else
      bRes = GetSaveFileName(&ofn);
	if (bRes)
	{
		m_bDoReplaceFile = TRUE;
	}
   else
   {
#ifdef _DEBUG
      DWORD dwError;
      ASSERT(0 == (dwError = CommDlgExtendedError()));
#endif
   }

	strFile = buf;

   return bRes;
}


static int CALLBACK 
FileChooserCallback(HWND hwnd, UINT uMsg, LPARAM lParam, LPARAM lpData)
{
   CFileChooser * pThis = (CFileChooser *)lpData;
   ASSERT(pThis != NULL);
   return pThis->BrowseForFolderCallback(hwnd, uMsg, lParam);
}

int CFileChooser::BrowseForFolderCallback(HWND hwnd, UINT uMsg, LPARAM lParam)
{
   switch (uMsg)
   {
   case BFFM_INITIALIZED:
      ASSERT(m_pPathTemp != NULL);
      if (::PathIsNetworkPath(m_pPathTemp))
         return 0;
      while (!::PathIsDirectory(m_pPathTemp))
      {
         if (0 == ::PathRemoveFileSpec(m_pPathTemp) && !::PathIsRoot(m_pPathTemp))
         {
            return 0;
         }
         DWORD attr = GetFileAttributes(m_pPathTemp);
         if (StyleBitSet(FC_FORWRITE) && (attr & FILE_ATTRIBUTE_READONLY) == 0)
            break;
      }
      ::SendMessage(hwnd, BFFM_SETSELECTION, TRUE, (LPARAM)m_pPathTemp);
      break;
   case BFFM_SELCHANGED:
      {
         LPITEMIDLIST pidl = (LPITEMIDLIST)lParam;
         TCHAR path[MAX_PATH];
         if (SHGetPathFromIDList(pidl, path))
         {
            ::SendMessage(hwnd, BFFM_ENABLEOK, 0, !PathIsNetworkPath(path));
         }
      }
      break;
   case BFFM_VALIDATEFAILED:
      break;
   }
   return 0;
}

BOOL 
CFileChooser::BrowseForFolder(CString& strPath)
{
   LPITEMIDLIST  pidl = NULL;
   HRESULT hr;
   BOOL bRes = FALSE;

   if (SUCCEEDED(hr = CoInitialize(NULL)))
   {
      if (SUCCEEDED(SHGetFolderLocation(NULL, CSIDL_DRIVES, NULL, 0, &pidl)))
      {
         LPITEMIDLIST pidList = NULL;
         BROWSEINFO bi;
         TCHAR buf[MAX_PATH];
         ZeroMemory(&bi, sizeof(bi));
         StrCpy(buf, strPath);
         
         bi.hwndOwner = m_pParent->m_hWnd;
         bi.pidlRoot = pidl;
         bi.pszDisplayName = m_pPathTemp = buf;
         bi.lpszTitle = m_strTitle;
         bi.ulFlags |= BIF_USENEWUI | BIF_RETURNONLYFSDIRS | BIF_EDITBOX;
         bi.lpfn = FileChooserCallback;
         bi.lParam = (LPARAM)this;

         pidList = SHBrowseForFolder(&bi);
         if (  pidList != NULL
            && SHGetPathFromIDList(pidList, buf)
            )
         {
            strPath = buf;
            bRes = TRUE;
         }
         IMalloc * pMalloc;
         VERIFY(SUCCEEDED(SHGetMalloc(&pMalloc)));
         if (pidl != NULL)
            pMalloc->Free(pidl);
         pMalloc->Release();
      }
      CoUninitialize();
   }
   return bRes;
}

void
CFileChooser::AddExtension(HINSTANCE hInst, UINT idText, UINT idExt)
{
   CString text, ext;
   if (text.LoadString(hInst, idText) && ext.LoadString(hInst, idExt))
   {
      AddExtension(text, ext);
   }
}

void 
CFileChooser::AddExtension(LPCTSTR text, LPCTSTR ext)
{
   ASSERT(ext != NULL && *ext == _T('.'));
   CFilterEntry entry(text, ext);
   m_ext.push_back(entry);
}

const TCHAR cDelimiter = _T('\n');

void 
CFileChooser::CreateFilter(CString& strFilter, CString& strDefExt)
{
   strFilter.Empty();
   strDefExt.Empty();
   BOOL bExtDone = FALSE;
   std::list<CFilterEntry>::iterator it;
   for (it = m_ext.begin(); it != m_ext.end(); it++)
   {
      CFilterEntry entry = (*it);
      strFilter += entry.m_text;
      if (m_dwStyle & FC_WILDCARD_DESC)
      {
         strFilter += _T(" (*");
         strFilter += entry.m_ext;
         strFilter += _T(")");
      }
      strFilter += cDelimiter;
      strFilter += _T('*');
      strFilter += entry.m_ext;
      strFilter += cDelimiter;
      if (!bExtDone)
      {
         LPCTSTR pExt = entry.m_ext;
         strDefExt = 
            *pExt == _T('.') ? pExt + 1 : pExt;
         bExtDone = TRUE;
      }
   }
   if (!strFilter.IsEmpty())
   {
      strFilter += cDelimiter;
      for (int i = 0; i < strFilter.GetLength(); i++)
      {
         if (strFilter[i] == cDelimiter)
            strFilter.SetAt(i, 0);
      }
   }
}

int
CFileChooser::GetFilterIndex(const CString& fileName)
{
   LPTSTR p = PathFindExtension(fileName);
   if (p == NULL)
      p = (LPTSTR)AllExt;
   std::list<CFilterEntry>::iterator it;
   int idx = 1;
   for (it = m_ext.begin(); it != m_ext.end(); it++, idx++)
   {
      if (StrCmpI((*it).m_ext, p) == 0)
         return idx;
   }
   return 0;
}

void
CFileChooser::GetText(LPTSTR buf)
{
   ASSERT(buf != NULL);

   if (m_bEditDirty)
   {
      m_edit->GetWindowText(buf, MAX_PATH);
   }
   else
   {
      StrCpy(buf, m_strPath);
   }
}

int
CFileChooser::ExtractPath(LPTSTR path)
{
   ASSERT(path != NULL);
   int rc = FC_SUCCESS;
   TCHAR buf[MAX_PATH] = {0};
   LPTSTR start = buf;

   GetText(buf);

   if (StyleBitSet(FC_COMMANDLINE))
   {
      if (*buf == QuotMark)
      {
         LPTSTR end = StrChr(++start, QuotMark);
         if (end == NULL)
         {
            // Wrong format, closing quotation mark is not set
            rc = FC_NO_CLOSING_QUOTE;
            // Return part of the path up to first space
            PathRemoveArgs(buf);
         }
         else
         {
            ++end;
            *end = 0;
            PathUnquoteSpaces(buf);
            start = buf;
         }
      }
      else
      {
         PathRemoveArgs(buf);
      }
   }

   StrCpy(path, start);

   return rc;
}

int
CFileChooser::ExtractArgs(LPTSTR buf)
{
   ASSERT(buf != NULL);

   int rc = FC_SUCCESS;

   GetText(buf);
   LPTSTR p = PathGetArgs(buf);
   if (p != NULL)
   {
      StrCpy(buf, p);
   }
   else
   {
      *buf = 0;
   }
   return rc;
}

void 
CFileChooser::OnBrowseBtn()
{
   BOOL bRes = FALSE;
   if (m_bDialogActive)
      return;
   m_bDialogActive = TRUE;
   TCHAR path[MAX_PATH] = {0};
   TCHAR args[MAX_PATH] = {0};

   int rc = ExtractPath(path);
   if (StyleBitSet(FC_COMMANDLINE))
   {
      ExtractArgs(args);
   }
	CString strFile, strBuffer;
//	m_strPath = path;
   strBuffer = path;

   if (StyleBitSet(FC_FORWRITE))
   {
	   if (!PathIsDirectory(path))
	   {
		   if (PathRemoveFileSpec(path))
		   {
			   // check if path part of filename exists
			   if (PathIsDirectory(path))
			   {
				   // we will use non-path part of spec as a filename
				   strFile = PathFindFileName(strBuffer);
			   }
			   else
			   {
				   // it is wrong path, use default one
				   // TODO: actually I need to take from filespec all existent
				   // chunks of path and filename, for example c:\aa\bb\cc\dd.txt,
				   // if c:\aa\bb exists, then strPath should be set to c:\aa\bb,
				   // and strFile to dd.txt
				   path[0] = 0;
			   }
		   }
		   else
		   {
			   // it is filename only
			   strFile = strBuffer;
			   path[0] = 0;
		   }
	   }
   }
   else
   {
      if (!PathIsDirectory(path))
      {
	      strFile = PathFindFileName(path);
	      PathRemoveFileSpec(path);
      }
   }
   CString strPath(path);
   if (StyleBitSet(FC_DIRECTORY_ONLY))
   {
      bRes = BrowseForFolder(strPath);
      if (bRes)
      {
         StrCpy(path, strPath);
      }
   }
   else
   {
      bRes = BrowseForFile(strPath, strFile);
      if (bRes)
      {
         StrCpy(path, strFile);
      }
   }
   if (bRes)
   {
      if (StyleBitSet(FC_COMMANDLINE))
      {
         PathQuoteSpaces(path);
         m_strPath = path;
         if (*args != 0)
         {
            m_strPath += _T(' ');
            m_strPath += args;
         }
      }
      else
         m_strPath = path;
      SetPathToEdit(m_strPath);
      m_bEditDirty = FALSE;
   }
   m_bDialogActive = FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\common2\iisuihelper.cpp ===
#include "stdafx.h"
#include "resource.h"
#include <initguid.h>

#include "common.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
        InitErrorFunctionality();
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        TerminateErrorFunctionality();
        _Module.Term();
    }
    return TRUE;    // ok
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\common2\error.cpp ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        msg.cpp

   Abstract:

        Message Functions

   Author:

        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:

        Internet Services Manager (cluster edition)

   Revision History:
        2/18/2000    sergeia     removed dependency on MFC

--*/

#include "stdafx.h"
#include <lmerr.h>
#include <lmcons.h>
#include "common.h"

extern CComModule _Module;

#ifdef _MT

    //
    // Thread protected stuff
    //
    #define RaiseThreadProtection() \
        do {\
            EnterCriticalSection(&_csSect);\
        } while(0)
    #define LowerThreadProtection() \
        do {\
            LeaveCriticalSection(&_csSect);\
        } while (0)

    static CRITICAL_SECTION _csSect;

#else

    #pragma message("Module is not thread-safe.")

    #define RaiseThreadProtection()
    #define LowerThreadProtection()

#endif // _MT

BOOL
InitErrorFunctionality()
/*++

Routine Description:

    Initialize CError class, and allocate static objects

Arguments:

    None:

Return Value:

    TRUE for success, FALSE for failure

--*/
{
#ifdef _MT
   InitializeCriticalSection(&_csSect);
#endif // _MT

    BOOL fOK = CError::AllocateStatics();

    if (fOK)
    {
//        REGISTER_FACILITY(FACILITY_APPSERVER, "iisui2.dll");
    }

    return fOK;
}



void
TerminateErrorFunctionality()
/*++

Routine Description:

    De-initialize CError class, freeing up static objects

Arguments:

    None

Return Value:

    None

--*/
{
    CError::DeAllocateStatics();

#ifdef _MT
    DeleteCriticalSection(&_csSect);
#endif // _MT
}

//
// Static Initialization:
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

const TCHAR g_cszNull[] = _T("(Null)");
const TCHAR CError::s_chEscape = _T('%');        // Error text escape
const TCHAR CError::s_chEscText = _T('h');       // Escape code for text
const TCHAR CError::s_chEscNumber = _T('H');     // Escape code for error code
LPCTSTR CError::s_cszLMDLL = _T("netmsg.dll");   // LM Error File
LPCTSTR CError::s_cszWSDLL = _T("iisui2.dll");   // Winsock error file
LPCTSTR CError::s_cszFacility[] = 
{
    /* FACILITY_NULL        */ NULL,
    /* FACILITY_RPC         */ NULL,
    /* FACILITY_DISPATCH    */ NULL,            
    /* FACILITY_STORAGE     */ NULL,
    /* FACILITY_ITF         */ NULL,
    /* FACILITY_DS          */ NULL,
    /* 6                    */ NULL,
    /* FACILITY_WIN32       */ NULL,
    /* FACILITY_WINDOWS     */ NULL,
    /* FACILITY_SSPI        */ NULL,
    /* FACILITY_CONTROL     */ NULL,
    /* FACILITY_CERT        */ NULL,
    /* FACILITY_INTERNET    */ _T("metadata.dll"),
    /* FACILITY_MEDIASERVER */ NULL,
    /* FACILITY_MSMQ        */ NULL,
    /* FACILITY_SETUPAPI    */ NULL,
    /* FACILITY_SCARD       */ NULL,
    /* 17 (MTX)             */ _T("iisui2.dll"),
};

HRESULT CError::s_cdwMinLMErr = NERR_BASE; 
HRESULT CError::s_cdwMaxLMErr = MAX_NERR;
HRESULT CError::s_cdwMinWSErr = WSABASEERR;    
HRESULT CError::s_cdwMaxWSErr = WSABASEERR + 2000;    
DWORD   CError::s_cdwFacilities = (sizeof(CError::s_cszFacility)\
    / sizeof(CError::s_cszFacility[0]));

//
// Allocated objects
//
CString * CError::s_pstrDefError;
CString * CError::s_pstrDefSuccs;
CFacilityMap * CError::s_pmapFacilities;
BOOL CError::s_fAllocated = FALSE;



/* protected */
/* static */
BOOL
CError::AllocateStatics()
/*++

Routine Description:

    Allocate static objects

Arguments:

    None

Return Value:

    TRUE for successfull allocation, FALSE otherwise

--*/
{
    RaiseThreadProtection();

    if (!AreStaticsAllocated())
    {
        try
        {
            CError::s_pstrDefError   = new CString;
            CError::s_pstrDefSuccs   = new CString(_T("0x%08lx"));
            CError::s_pmapFacilities = new CFacilityMap;
            s_fAllocated = TRUE;

            if (!CError::s_pstrDefError->LoadString(_Module.GetResourceInstance(), IDS_NO_MESSAGE))
            {
                //
                // Just in case we didn't load this message from the resources
                //
                ASSERT_MSG("Unable to load resource message");
                *s_pstrDefError = _T("Error Code: 0x%08lx");
            }
        }
        catch(std::bad_alloc)
        {
            ASSERT_MSG("Initialization Failed");
        }
    }

    LowerThreadProtection();

    return AreStaticsAllocated();
}



/* protected */
/* static */
void
CError::DeAllocateStatics()
/*++

Routine Description:

    Clean up allocations

Arguments:

    N/A

Return Value:

    N/A

--*/
{

    RaiseThreadProtection();

    if (AreStaticsAllocated())
    {
        SAFE_DELETE(CError::s_pstrDefError);
        SAFE_DELETE(CError::s_pstrDefSuccs);
        SAFE_DELETE(CError::s_pmapFacilities);

        s_fAllocated = FALSE;
    }

    LowerThreadProtection();
}


/*static*/ BOOL 
CError::AreStaticsAllocated() 
{ 
   return s_fAllocated; 
}

/* static */
HRESULT 
CError::CvtToInternalFormat(
    IN HRESULT hrCode
    )
/*++

Routine Description:

    Convert WIN32 or HRESULT code to internal (HRESULT) format.

Arguments:

    DWORD dwCode        Error code

Return Value:

    HRESULT

Notes:

    HRESULTS are left as is.  Lanman and Winsock errors are converted
    to HRESULTS using private facility codes.

--*/
{
    if (IS_HRESULT(hrCode))
    {
        return hrCode;
    }

    if(hrCode >= s_cdwMinLMErr && hrCode <= s_cdwMaxLMErr)
    {
        return MAKE_HRESULT(SEVERITY_ERROR, FACILITY_LANMAN, (DWORD)hrCode);
    }

    if (hrCode >= s_cdwMinWSErr && hrCode <= s_cdwMaxWSErr)
    {
        return MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WINSOCK, (DWORD)hrCode);
    }

    return HResult(hrCode);    
}



/* static */ 
void 
CError::RegisterFacility(
    IN DWORD dwFacility,
    IN LPCSTR lpDLL         OPTIONAL
    )
/*++

Routine Description:

    Register a DLL for a given facility code.  Use NULL to unregister
    the DLL name.

Arguments:

    DWORD dwFacility : Facility code
    LPCSTR lpDLL     : DLL Name.

Return Value:

    None

--*/
{
    RaiseThreadProtection();

    ASSERT(AreStaticsAllocated());

    if (lpDLL == NULL)
    {
        //
        // Remove the facility
        //
        s_pmapFacilities->erase(dwFacility);
    }
    else
    {
        CString str(lpDLL);

        //
        // Register facility
        //
        s_pmapFacilities->insert(s_pmapFacilities->begin(), 
           CFacilityMap::value_type(dwFacility, str));
    }

    LowerThreadProtection();
}


        
/* static */
LPCTSTR 
CError::FindFacility(
    IN DWORD dwFacility
    )
/*++

Routine Description:

    Determine if a DLL name has been registered for the given facility
    code.

Arguments:

    DWORD dwFacility        : Facility code

Return Value:

    Returns the DLL name, or NULL.

--*/
{
    RaiseThreadProtection();

    ASSERT(AreStaticsAllocated());

    LPCTSTR pRes = NULL;
    CFacilityMap::iterator it = s_pmapFacilities->find(dwFacility);
    if (it != s_pmapFacilities->end())
    {
        pRes = (*it).second;
    }

    LowerThreadProtection();

    return pRes;
}



CError::~CError()
/*++

Routine Description:

    Destructor

Arguments:

    None

Return Value:

    N/A

--*/
{
}



const CError & 
CError::Construct(
    IN HRESULT hr
    )
/*++

Routine Description:

    construct with new value.

Arguments:
    
    HRESULT hr : New value, either an HRESULT or a WIN32
                 error code.

Return Value:

    Reference to current object

--*/
{
    ASSERT(AreStaticsAllocated());

    m_hrCode = CvtToInternalFormat(hr);

    return *this;
}



const CError & 
CError::Construct(
    IN const CError & err
    )
/*++

Routine Description:

    Assign new value.

Arguments:
    
    CError & err    : Error code

Return Value:

    Reference to current object

--*/
{
    ASSERT(AreStaticsAllocated());

    m_hrCode = err.m_hrCode;

    return *this;
}



int
CError::MessageBox(
    IN UINT    nType,
    IN UINT    nHelpContext OPTIONAL
    ) const
/*++

Routine Description:

    Display error message in a message box

Arguments:

    HRESULT hrCode       : HRESULT error code
    UINT    nType        : See AfxMessageBox for documentation
    UINT    nHelpContext : See AfxMessageBox for documentation

Return Value:

    AfxMessageBox return code

--*/
{
    CString strMsg;
    TextFromHRESULT(strMsg);
    return ::MessageBox(::GetAncestor(::GetFocus(), GA_ROOT), strMsg, NULL, nType);
}




//
// Extend CString just to get at FormatV publically
//
class CStringEx : public CString
{
public:
    void FormatV(LPCTSTR lpszFormat, va_list argList)
    {
        CString::FormatV(lpszFormat, argList);
    }
};



int 
CError::MessageBoxFormat(
    IN HINSTANCE hInst,
    IN UINT nFmt,
    IN UINT nType,
    IN UINT nHelpContext,
    ...
    ) const
/*++

Routine Description:

    Display formatted error message in messagebox.  The format
    string (given as a resource ID) is a normal printf-style
    string, with the additional parameter of %h, which takes
    the text equivalent of the error message, or %H, which takes
    the error return code itself.

Arguments:

    UINT    nFmt         : Resource format
    UINT    nType        : See AfxMessageBox for documentation
    UINT    nHelpContext : See AfxMessageBox for documentation
    ...                    More as needed for sprintf

Return Value:

    AfxMessageBox return code
    
--*/
{
    CString strFmt;
    CStringEx strMsg;

    strFmt.LoadString(hInst, nFmt);

    //
    // First expand the error
    //
    TextFromHRESULTExpand(strFmt);

    va_list marker;
    va_start(marker, nHelpContext);
    strMsg.FormatV(strFmt, marker);
    va_end(marker);

    return ::MessageBox(::GetFocus(), strMsg, NULL, nType);
}


BOOL 
CError::MessageBoxOnFailure(
    IN UINT nType,
    IN UINT nHelpContext    OPTIONAL
    ) const
/*++

Routine Description:

    Display message box if the current error is a failure
    condition, else do nothing

Arguments:

    UINT    nType        : See AfxMessageBox for documentation
    UINT    nHelpContext : See AfxMessageBox for documentation

Return Value:

    TRUE if a messagebox was shown, FALSE otherwise

--*/
{
    if (Failed())
    {
        MessageBox(nType, nHelpContext);
        return TRUE;
    }

    return FALSE;
}



BOOL 
CError::HasOverride(
    OUT UINT * pnMessage        OPTIONAL
    ) const
/*++

Routine Description:

    Check to see if a given HRESULT has an override

Arguments:

    HRESULT hrCode              : HRESULT to check for
    UINT * pnMessage            : Optionally returns the override

Return Value:

    TRUE if there is an override, FALSE if there is not.

--*/
{
   ASSERT(AreStaticsAllocated());

   HRESULT hrCode = CvtToInternalFormat(m_hrCode);
   COverridesMap::const_iterator it = mapOverrides.find(hrCode);
   if (it == mapOverrides.end())
   {
      return FALSE;
   }
   if (pnMessage != NULL)
      *pnMessage = (*it).second;
   return TRUE;
}



UINT
CError::AddOverride(
    IN HRESULT    hrCode,
    IN UINT       nMessage
    )
/*++

Routine Description:

    Add an override for a specific HRESULT.

Arguments:

    HRESULT    hrCode       : HRESULT to override
    UINT       nMessage     : New message, or -1 to remove override

Return Value:

    The previous override, or -1

--*/
{
    ASSERT(AreStaticsAllocated());

    UINT nPrev;
    hrCode = CvtToInternalFormat(hrCode);

    //
    // Fetch the current override
    //
    COverridesMap::iterator it = mapOverrides.find(hrCode);
    nPrev = (it == mapOverrides.end()) ? REMOVE_OVERRIDE : (*it).second;

    if (nMessage == REMOVE_OVERRIDE)
    {
        //
        // Remove the override
        //
        mapOverrides.erase(hrCode);
    }
    else
    {
        //
        // Set new override
        //
        mapOverrides[hrCode] = nMessage;
    }

    return nPrev;
}



void
CError::RemoveAllOverrides()
/*++

Routine Description:

    Remove all overrides

Arguments:

    None

Return Value:

    None

--*/
{
    ASSERT(AreStaticsAllocated());
    mapOverrides.clear();
}



HRESULT
CError::TextFromHRESULT(
    OUT LPTSTR  szBuffer,
    OUT DWORD   cchBuffer
    ) const
/*++

Routine Description:

    Get text from the given HRESULT.  Based on the range that the HRESULT
    falls in and the facility code, find the location of the message,
    and fetch it.

Arguments:

    HRESULT hrCode      HRESULT or (DWORD WIN32 error) whose message to get
    LPTSTR  szBuffer    Buffer to load message text into
    DWORD   cchBuffer   Size of buffer in characters.

Return Value:

    HRESULT error code depending on whether the message was
    found.  If the message was not found, some generic message
    is synthesized in the buffer if a buffer is provided.

    ERROR_FILE_NOT_FOUND        No message found
    ERROR_INSUFFICIENT_BUFFER   Buffer is a NULL pointer or too small

--*/
{
    HRESULT hrReturn = ERROR_SUCCESS;

    //
    // First check to see if this message is overridden
    //
    UINT nID;
    HRESULT hrCode = m_hrCode;

    if (HasOverride(&nID))
    {
        //
        // Message overridden.  Load replacement message
        // instead.
        //
        BOOL fSuccess;

        //
        // Attempt to load from calling process first
        //
        if (!(fSuccess = ::LoadString(
            ::GetModuleHandle(NULL), 
            nID, 
            szBuffer, 
            cchBuffer
            )))
        {
            //
            // Try this dll
            //
            fSuccess = ::LoadString(
                _Module.GetResourceInstance(), 
                nID, 
                szBuffer, 
                cchBuffer
                );
        }

        if (fSuccess)
        {
            //
            // Everything ok
            //
            return hrReturn;
        }

        //
        // Message didn't exist, skip the override, and 
        // load as normal.
        //
        TRACE("Couldn't load %d\n", nID);
        ASSERT_MSG("Attempted override failed");
    }

    LPCTSTR lpDll    = NULL;
    HINSTANCE hDll   = NULL;
    DWORD dwFacility = HRESULT_FACILITY(hrCode);
    DWORD dwSeverity = HRESULT_SEVERITY(hrCode);
    DWORD dwCode     = HRESULT_CODE(hrCode);
    BOOL  fSuccess   = Succeeded(hrCode);

    //
    // Strip off meaningless internal facility codes
    //
    if (dwFacility == FACILITY_LANMAN || dwFacility == FACILITY_WINSOCK)
    {
        dwFacility = FACILITY_NULL;
        hrCode   = (HRESULT)dwCode;
    }

    DWORD dwFlags = FORMAT_MESSAGE_IGNORE_INSERTS | 
                    FORMAT_MESSAGE_MAX_WIDTH_MASK;

    //
    // Since we allow both HRESULTS and WIN32 codes to be
    // used here, we can't rely on the private FACILITY code 
    // for lanman and winsock.
    //
    if(hrCode >= s_cdwMinLMErr && hrCode <= s_cdwMaxLMErr)
    {
        //
        // Lanman error
        //
        lpDll = s_cszLMDLL;
    }
    else if (hrCode >= s_cdwMinWSErr && hrCode <= s_cdwMaxWSErr)
    {
        //
        // Winsock error
        //
        lpDll = s_cszWSDLL;
    }
    else
    {
        //
        // Attempt to determine message location from facility code.
        // Check for registered facility first.
        //
        lpDll = FindFacility(dwFacility);

        if (lpDll == NULL)
        {
            if (dwFacility < s_cdwFacilities)
            {
                lpDll = s_cszFacility[dwFacility];
            }
            else
            {
                ASSERT_MSG("Bogus FACILITY code encountered.");
                lpDll = NULL;
            }
        }
    }

    do
    {
        if (szBuffer == NULL || cchBuffer <= 0)
        {
            hrReturn = HResult(ERROR_INSUFFICIENT_BUFFER);
            break;
        }

        if (lpDll)
        {
            //
            // Load message file
            //
            hDll = ::LoadLibraryEx(
                lpDll,
                NULL,
                LOAD_LIBRARY_AS_DATAFILE
                );

            if (hDll == NULL)
            {
                hrReturn = ::GetLastHRESULT();
                break;
            }

            dwFlags |= FORMAT_MESSAGE_FROM_HMODULE;
        }
        else
        {
            dwFlags |= FORMAT_MESSAGE_FROM_SYSTEM;
        }

        DWORD dwResult = 0L;
        DWORD dwID = hrCode;
        HINSTANCE hSource = hDll;

        while(!dwResult)
        {
            dwResult = ::FormatMessage(
                dwFlags,
                (LPVOID)hSource,
                dwID,
                0,
                szBuffer,
                cchBuffer,
                NULL
                );

            if (dwResult > 0)
            {
                //
                // Successfully got a message
                //
                hrReturn = ERROR_SUCCESS;
                break;
            } 

            hrReturn = ::GetLastHRESULT();
    
            if (dwID != dwCode && !fSuccess)
            {
                //
                // Try the SCODE portion of the error from win32
                // if this is an error message
                //
                dwID = dwCode;
                hSource = NULL;
                continue;
            }

            //
            // Failed to obtain a message
            //
            hrReturn = HResult(ERROR_FILE_NOT_FOUND);
            break;
        }
    }
    while(FALSE);

    if(hDll != NULL)
    {
        ::FreeLibrary(hDll);
    }

    if (Failed(hrReturn))
    {
        //
        // Unable to find the message, synthesize something with
        // the code in it if there's room (+8 for the number)
        //
        CString & strMsg = (fSuccess ? *s_pstrDefSuccs : *s_pstrDefError);

        if (cchBuffer > (DWORD)strMsg.GetLength() + 8)
        {
            TRACE("Substituting default message for %d\n", (DWORD)m_hrCode);
            wsprintf(szBuffer, (LPCTSTR)strMsg, m_hrCode);
        }
        else
        {
            //
            // Not enough room for message code
            //
            ASSERT_MSG("Buffer too small for default message -- left blank");
            *szBuffer = _T('\0');
        }
    }

    return hrReturn;
}



HRESULT 
CError::TextFromHRESULT(
    OUT CString & strBuffer
    ) const
/*++

Routine Description:

    Similar to the function above, but use a CString

Arguments:

    HRESULT hrCode         HRESULT or (DWORD WIN32 error) whose message to get
    CString & strBuffer    Buffer to load message text into

Return Value:

    HRESULT error code depending on whether the message was
    found.  If the message was not found, some generic message
    is synthesized in the buffer if a buffer is provided.

    ERROR_FILE_NOT_FOUND   No message found

--*/
{
   DWORD cchBuffer = 255;
   HRESULT hr = S_OK;
   LPTSTR p = NULL;

   for (;;)
   {
      p = strBuffer.get_allocator().allocate(cchBuffer, p);
      if (p == NULL)
      {
         return HResult(ERROR_NOT_ENOUGH_MEMORY);
      }

      hr = TextFromHRESULT(p, cchBuffer - 1);
      if (Win32Error(hr) != ERROR_INSUFFICIENT_BUFFER)
      {
         //
         // Done!
         //
         strBuffer.assign(p);
         break;
      }

      //
      // Insufficient buffer, enlarge and try again
      //
      cchBuffer *= 2;
   }
   if (p != NULL)
   {
      strBuffer.get_allocator().deallocate(p, cchBuffer);
   }
   return hr;
}



BOOL
CError::ExpandEscapeCode(
    IN  LPTSTR szBuffer,
    IN  DWORD cchBuffer,
    OUT IN LPTSTR & lp,
    IN  CString & strReplacement,
    OUT HRESULT & hr
    ) const
/*++

Routine Description:

    Expand escape code

Arguments:

    LPTSTR szBuffer             Buffer
    DWORD cchBuffer             Size of buffer
    LPTSTR & lp                 Pointer to escape code
    CString & strReplacement    Message to replace the escape code
    HRESULT & hr                Returns HRESULT in case of failure

Return Value:

    TRUE if the replacement was successful, FALSE otherwise.
    In the case of failure, hr will return an HRESULT.
    In the case of success, lp will be advanced past the
    replacement string.

--*/
{
    //
    // Make sure there's room (account for terminating NULL)
    // Free up 2 spaces for the escape code.
    //
    int cchFmt = lstrlen(szBuffer) - 2;
    int cchReplacement = strReplacement.GetLength();
    int cchRemainder = lstrlen(lp + 2);

    if ((DWORD)(cchReplacement + cchFmt) < cchBuffer)
    {
        //
        // Put it in
        //
        MoveMemory(
            lp + cchReplacement,
            lp + 2,
            (cchRemainder + 1) * sizeof(TCHAR)
            );
        CopyMemory(lp, strReplacement, cchReplacement * sizeof(TCHAR));
        lp += cchReplacement;
        
        return TRUE;
    }

    hr = HResult(ERROR_INSUFFICIENT_BUFFER);

    return FALSE;
}



LPCTSTR 
CError::TextFromHRESULTExpand(
    OUT LPTSTR  szBuffer,
    OUT DWORD   cchBuffer,
    OUT HRESULT * phResult  OPTIONAL
    ) const
/*++

Routine Description:

    Expand %h/%H strings in szBuffer to text from HRESULT,
    or error code respectively within the limits of szBuffer.

Arguments:

    LPTSTR  szBuffer    Buffer to load message text into
    DWORD   cchBuffer   Buffer size in characters
    HRESULT * phResult  Optional return code

Return Value:

    Pointer to string.

--*/
{
    HRESULT hr = S_OK;

    if (szBuffer == NULL || cchBuffer <= 0)
    {
        hr = HResult(ERROR_INSUFFICIENT_BUFFER);
    }
    else
    {
        //
        // Look for the escape sequence
        //
        int cReplacements = 0;
        CString strMessage;
        LPTSTR lp = szBuffer;

        while (*lp)
        {
            if (*lp == s_chEscape)
            {
                switch(*(lp + 1))
                {
                case s_chEscText:
                    //
                    // Replace escape code with text message
                    //
                    hr = TextFromHRESULT(strMessage);

                    if (ExpandEscapeCode(
                        szBuffer,
                        cchBuffer,
                        lp,
                        strMessage,
                        hr
                        ))
                    {
                        ++cReplacements;
                    }
                    break;

                case s_chEscNumber:
                    //
                    // Replace escape code with numeric error code
                    //
                    strMessage.Format(_T("0x%08x"), m_hrCode);

                    if (ExpandEscapeCode(
                        szBuffer,
                        cchBuffer,
                        lp,
                        strMessage,
                        hr
                        ))
                    {
                        ++cReplacements;
                    }
                    break;

                default:
                    //
                    // Regular printf-style escape sequence.
                    //
                    break;
                }
            }

            ++lp;
        }

        if (!cReplacements)
        {
            //
            // Got to the end without finding any escape codes.
            //
            hr = HResult(ERROR_INVALID_PARAMETER);
        }
    }

    if (phResult)
    {
        *phResult = hr;
    }

    return szBuffer;
}



LPCTSTR 
CError::TextFromHRESULTExpand(
    OUT CString & strBuffer
    ) const
/*++

Routine Description:

    Expand %h string in strBuffer to text from HRESULT

Arguments:

    CString & strBuffer Buffer to load message text into

Return Value:

    Pointer to string.

--*/
{
   DWORD cchBuffer = strBuffer.GetLength() + 1024;
   LPTSTR p = NULL;
   for (;;)
   {
      p = strBuffer.get_allocator().allocate(cchBuffer, p);

      if (p != NULL)
      {
         HRESULT hr;

         TextFromHRESULTExpand(p, cchBuffer - 1, &hr);

         if (Win32Error(hr) != ERROR_INSUFFICIENT_BUFFER)
         {
            //
            // Done!
            //
            strBuffer.assign(p);
            break;
         }

         //
         // Insufficient buffer, enlarge and try again
         //
         cchBuffer *= 2;
      }
   }
   if (p != NULL)
   {
      strBuffer.get_allocator().deallocate(p, cchBuffer);
   }

   return strBuffer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\common2\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\common2\error.h ===
/*++

   Copyright    (c)    1994-2000    Microsoft Corporation

   Module  Name :

        error.h

   Abstract:

        Message Functions Definitions

   Author:

        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:

        Internet Services Manager

   Revision History:
        2/17/2000    sergeia     removed dependency on MFC

--*/

#ifndef _ERROR_H
#define _ERROR_H

#pragma warning(disable:4786) // Disable warning for names > 256

//
// Slightly easier syntax to register a facility
//
#define REGISTER_FACILITY(dwCode, lpSource)\
    CError::RegisterFacility(dwCode, lpSource)

//
// Helper Function
//
HRESULT GetLastHRESULT();
BOOL InitErrorFunctionality();
void TerminateErrorFunctionality();


typedef struct tagFACILITY
{
    LPCTSTR lpszDll;
    UINT    nTextID;
} FACILITY;

#pragma warning(disable : 4231)
#pragma warning(disable : 4251)

//typedef std::map<DWORD, CString> CMapDWORDtoCString;
//typedef std::map<HRESULT, UINT> CMapHRESULTtoUINT;

class CFacilityMap : public std::map<DWORD, CString>
{
};

class COverridesMap : public std::map<HRESULT, UINT>
{
public:
   COverridesMap()
   {
   }
   ~COverridesMap()
   {
   }
};

class _EXPORT CError
/*++

Class Description:

    Error handling class, works for both HRESULT and old-style DWORD
    error codes.  Construct with or assign a DWORD or HRESULT error
    return code, and the object can then be used to determine success
    or failure, and the object provides text for the error code either
    directly, in a message, or formatted with additional text.  Also,
    the CError object understands the range of winsock errors and
    lanman errors, and looks for them in the appropriate places.
    The object can be referenced as a BOOL, a DWORD, an HRESULT, or
    a LPCTSTR as a success/failure, a WIN32 error, and HRESULT or
    the text equivalent respectively.

    Example of typical programme flow:

    CError err(FunctionWhichReturnsHresult());

    //
    // Use IDS_MY_ERROR for access denied errors for the
    // duration of this scope.
    //
    err.AddOverride(ERROR_ACCESS_DENIED, IDS_MY_ERROR);

    if (!err.MessageBoxOnFailure())
    {
        //
        // If we failed, this already displayed the error
        // message in a messagebox.  Only when we succeed
        // we get here.
        //
        ... stuff ...
    }

    SomeWinApiWhichSetsLastError();
    err.GetLastWinError();
    if (err.Failed())
    {
        printf("WIN32 Error code %ld\nHRESULT %ld\nText: %s\n",
            (DWORD)err,
            (HRESULT)err,
            (LPCTSTR)err
            );
    }

Public Interface:

    TextFromHRESULT         : Convert HRESULT to text
    TextFromHRESULTExpand   : Expand %h string to error text, %H to error code
    MessageBox              : Display error in a messagebox
    MessageBoxFormat        : Use %h string as format in messagebox
    MessageBoxOnFailure     : Display message if error is a failure
    AddOverride             : Add message override with string ID
    RemoveOverride          : Remove message override
    RegisterFacility        : Register facility
    UnregisterFacility      : Unregister facility
    Succeeded               : Determine if the error code indicates a success
    Failed                  : Determine if the error code indicates a failure

    CError                  : Constructors
    Reset                   : Reset error code
    GetLastWinError         : Assign internal code to GetLastError
    SetLastWinError         : Set last error from internal code

    operator =              : Assignment operators
    operator ==             : Comparison operators
    operator !=             : Comparison operators
    operator LPOLESTR       : Conversion operator
    operator LPCTSTR        : Conversion operator
    operator HRESULT        : Conversion operator
    operator DWORD          : Conversion operator
    operator BOOL           : Conversion operator

--*/
{
#define IS_HRESULT(hr)  (hr & 0xffff0000)
#define REMOVE_OVERRIDE ((UINT)-1)
#define NO_HELP_CONTEXT ((UINT)-1)
#define USE_LAST_ERROR  (TRUE)

//
// Private Internal FACILITY codes
//
#define FACILITY_WINSOCK    (0xffe)
#define FACILITY_LANMAN     (0xfff)

//
// Static Helpers
//
public:
    //
    // Success/Failure determinants, works regardless
    // of whether hrCode is a DWORD or HRESULT
    //
    static BOOL Succeeded(HRESULT hrCode);
    static BOOL Failed(HRESULT hrCode);

    //
    // Guarantee return is WIN32 error code
    //
    static DWORD Win32Error(HRESULT hrCode) { return HRESULT_CODE(hrCode); }

    //
    // Guarantee return is a true HRESULT
    //
    static HRESULT HResult(HRESULT hrCode) { return HRESULT_FROM_WIN32(hrCode); }

    //
    // Register a DLL for a given facility code.
    // Use NULL to unregister the facility
    //
    static void RegisterFacility(
        IN DWORD dwFacility,
        IN LPCSTR lpDLL = NULL
        );

    static void UnregisterFacility(
        IN DWORD dwFacility
        );

//
// Constructor/Destructor
//
public:
    //
    // If constructed with TRUE, the object is initialized to
    // last error.  It's set to ERROR_SUCCESS otherwise (default case)
    //
    CError();
    CError(HRESULT hrCode);
    CError(DWORD   dwCode);
    ~CError();

//
// Helpers
//
public:
    BOOL Succeeded() const { return SUCCEEDED(m_hrCode); }
    BOOL Failed() const { return FAILED(m_hrCode); }

    HRESULT TextFromHRESULT(
        OUT LPTSTR szBuffer,
        OUT DWORD  cchBuffer
        ) const;

    HRESULT TextFromHRESULT(
        OUT CString & strMsg
        ) const;

    LPCTSTR TextFromHRESULTExpand(
        OUT LPTSTR  szBuffer,
        OUT DWORD   cchBuffer,
        OUT HRESULT * phResult = NULL
        ) const;

    LPCTSTR TextFromHRESULTExpand(
        OUT CString & strBuffer
        ) const;

    int MessageBox(
        IN UINT nType = MB_OK | MB_ICONWARNING,
        IN UINT nHelpContext = NO_HELP_CONTEXT
        ) const;

    BOOL MessageBoxOnFailure(
        IN UINT nType = MB_OK | MB_ICONWARNING,
        IN UINT nHelpContext = NO_HELP_CONTEXT
        ) const;

    int MessageBoxFormat(
        IN HINSTANCE hInst,
        IN UINT nFmt,
        IN UINT nType,
        IN UINT nHelpContext,
        ...
        ) const;

    void Reset();
    void GetLastWinError();
    void SetLastWinError() const;
    DWORD Win32Error() const;
    HRESULT HResult() const { return m_hrCode; }

    //
    // Add override for specific error code.
    // Use -1 to remove the override.  This function
    // will return the previous override (or -1)
    //
    UINT AddOverride(
        IN HRESULT hrCode,
        IN UINT    nMessage = REMOVE_OVERRIDE
        );         

    void RemoveOverride(
        IN HRESULT hrCode
        );
        
    void RemoveAllOverrides();   

protected:
    //
    // Expand escape code
    //
    BOOL ExpandEscapeCode(
        IN  LPTSTR szBuffer,
        IN  DWORD cchBuffer,
        OUT IN LPTSTR & lp,
        IN  CString & strReplacement,
        OUT HRESULT & hr
        ) const;

    //
    // Check for override message
    //
    BOOL HasOverride(
        OUT UINT * pnMessage = NULL
        ) const;

//
// Assignment Operators
//
public:
    const CError & operator =(HRESULT hr);
    const CError & operator =(const CError & err);

// 
// Comparison Operators
//
public:
    const BOOL operator ==(HRESULT hr);
    const BOOL operator ==(CError & err);
    const BOOL operator !=(HRESULT hr);
    const BOOL operator !=(CError & err);

//
// Conversion Operators
//
public:
    operator const HRESULT() const { return m_hrCode; }
    operator const DWORD() const;
    operator const BOOL() const;
    operator LPOLESTR();
    operator LPCTSTR();

protected:
    static HRESULT CvtToInternalFormat(HRESULT hrCode);

    //
    // Check for FACILITY dll
    //
    static LPCTSTR FindFacility(
        IN DWORD dwFacility
        );

protected:
    friend BOOL InitErrorFunctionality();
    friend void TerminateErrorFunctionality();
    static BOOL AllocateStatics();
    static void DeAllocateStatics();
    static BOOL AreStaticsAllocated();

protected:
    static const TCHAR s_chEscape;    // Escape character
    static const TCHAR s_chEscText;   // Escape code for text
    static const TCHAR s_chEscNumber; // Escape code for error code
    static LPCTSTR s_cszLMDLL;        // Lanman Message DLL
    static LPCTSTR s_cszWSDLL;        // Winsock Message DLL
    static LPCTSTR s_cszFacility[];   // Facility Table
    static HRESULT s_cdwMinLMErr;     // Lanman Error Range
    static HRESULT s_cdwMaxLMErr;     // Lanman Error Range
    static HRESULT s_cdwMinWSErr;     // Winsock Error Range
    static HRESULT s_cdwMaxWSErr;     // Winsock Error Range
    static DWORD   s_cdwFacilities;   // Number of facility items

    //
    // Allocated objects 
    //
    static CString * s_pstrDefError;  // Default Error String
    static CString * s_pstrDefSuccs;  // Default Success String
    static CFacilityMap * s_pmapFacilities;
    static BOOL s_fAllocated;

protected:
    const CError & Construct(HRESULT hr);
    const CError & Construct(const CError & err);
    COverridesMap mapOverrides;

private:
    HRESULT m_hrCode;
    CString m_str;
};



//
// Inline Expansions
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline HRESULT GetLastHRESULT()
{
    return CError::HResult(::GetLastError());
}

inline /* static */ BOOL CError::Succeeded(HRESULT hrCode)
{
    //
    // Works with either HRESULT or WIN32 error code
    //
    return IS_HRESULT(hrCode)
        ? SUCCEEDED(hrCode)
        : hrCode == ERROR_SUCCESS;
}

inline /* static */ BOOL CError::Failed(HRESULT hrCode)
{
    //
    // Works with either HRESULT or WIN32 error code
    //
    return IS_HRESULT(hrCode)
        ? FAILED(hrCode)
        : hrCode != ERROR_SUCCESS;
}

inline /* static */ void CError::UnregisterFacility(
    IN DWORD dwFacility
    )
{
    RegisterFacility(dwFacility, NULL);
}

inline CError::CError()
{
    Construct(S_OK);
}

inline CError::CError(HRESULT hrCode)
{
    Construct(hrCode);
}

inline CError::CError(DWORD dwCode)
{
    Construct((HRESULT)dwCode);
}

inline DWORD CError::Win32Error() const
{
    return CError::Win32Error(m_hrCode);
}

inline void CError::Reset()
{
    m_hrCode = S_OK;
}

inline void CError::GetLastWinError()
{
    Construct(::GetLastError());
}

inline void CError::SetLastWinError() const
{
    ::SetLastError(Win32Error(m_hrCode));
}

inline void CError::RemoveOverride(
    IN HRESULT hrCode
    )
{
    (void)CError::AddOverride(hrCode, REMOVE_OVERRIDE);
}

inline const CError & CError::operator =(HRESULT hr)
{
    return Construct(hr);
}

inline const CError & CError::operator =(const CError & err)
{
    return Construct(err);
}

inline const BOOL CError::operator ==(HRESULT hr)
{
    return m_hrCode == hr;
}

inline const BOOL CError::operator ==(CError & err)
{
    return m_hrCode == err.m_hrCode;
}

inline const BOOL CError::operator !=(HRESULT hr)
{
    return m_hrCode != hr;
}

inline const BOOL CError::operator !=(CError & err)
{
    return m_hrCode != err.m_hrCode;
}

inline CError::operator const DWORD() const
{
    return Win32Error();
}

inline CError::operator const BOOL() const
{
    return Succeeded();
}

//inline CError::operator LPOLESTR()
//{
//    TextFromHRESULT(m_str);
//    return m_str.c_str();
//}
    
inline CError::operator LPCTSTR()
{
    TextFromHRESULT(m_str);
    return m_str;
}

//
// AfxMessageBox helpers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline BOOL NoYesMessageBox(CString& str)
{
   CString strCaption;
   strCaption.LoadString(_Module.GetResourceInstance(), IDS_APP_TITLE);
   return ::MessageBox(::GetFocus(), str, strCaption, MB_YESNO|MB_ICONQUESTION|MB_DEFBUTTON2) == IDYES;
}

inline BOOL NoYesMessageBox(UINT nID)
{
   CString strText;
   strText.LoadString(_Module.GetResourceInstance(), nID);
   return NoYesMessageBox(strText);
}

inline BOOL YesNoMessageBox(CString& str)
{
   CString strCaption;
   strCaption.LoadString(_Module.GetResourceInstance(), IDS_APP_TITLE);
   return ::MessageBox(::GetFocus(), str, strCaption, MB_YESNO|MB_ICONQUESTION|MB_DEFBUTTON1) == IDYES;
}

inline BOOL YesNoMessageBox(UINT nID)
{
   CString strText;
   strText.LoadString(_Module.GetResourceInstance(), nID);
   return YesNoMessageBox(strText);
}

#endif // _ERROR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\common2\inheritancedlg.cpp ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        idlg.cpp

   Abstract:

        Inheritance Dialog

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager (cluster edition)

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include "common.h"
#include "inheritancedlg.h"



//
// Inheritance dialog
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

CInheritanceDlg::CInheritanceDlg(
    DWORD dwMetaID,
    BOOL fWrite,
    CComAuthInfo * pAuthInfo,
    LPCTSTR lpstrMetaRoot,
    CStringListEx& strlMetaChildNodes,
    LPCTSTR lpstrPropertyName,
    HWND hwndParent
    )
/*++

Routine Description:

    Inheritance dialog constructor.  This constructor assumes GetDataPaths()
    has already been called.

Arguments:

    DWORD dwMetaID                      : Meta ID
    BOOL fWrite                         : TRUE from write, FALSE from delete
    CIISServer * pAuthInfo              : Auth info object or NULL
    LPCTSTR lpstrMetaRoot               : Meta root
    CStringList & strlMetaChildNodes    : List of child nodes from GetDataPaths
    LPCTSTR lpstrPropertyName           : Optional text string for the property
    CWnd * pParent                      : Optional parent window

Return Value:

    None

--*/
    : m_fWrite(fWrite),
      m_fEmpty(TRUE),
      m_fUseTable(TRUE),
      m_strMetaRoot(lpstrMetaRoot),
      m_strPropertyName(lpstrPropertyName ? lpstrPropertyName : _T("")),
      m_mk(pAuthInfo)
//      CDialog(CInheritanceDlg::IDD, hwndParent)
{
    m_strlMetaChildNodes = strlMetaChildNodes;

    VERIFY(CMetaKey::GetMDFieldDef(
        dwMetaID, 
        m_dwMDIdentifier, 
        m_dwMDAttributes, 
        m_dwMDUserType,
        m_dwMDDataType
        ));

    Initialize();
}



CInheritanceDlg::CInheritanceDlg(
    DWORD dwMetaID,
    BOOL fWrite,
    CComAuthInfo * pAuthInfo,
    LPCTSTR lpstrMetaRoot,
    LPCTSTR lpstrPropertyName,
    HWND hwndParent
    )
/*++

Routine Description:

    Inheritance dialog constructor.  This constructor will call GetDataPaths().

Arguments:

    DWORD dwMetaID                      : Meta ID
    BOOL fWrite                         : TRUE from write, FALSE from delete
    CComAuthInfo * pAuthInfo            : Auth info or NULL
    LPCTSTR lpstrMetaRoot               : Meta root
    LPCTSTR lpstrPropertyName           : Optional text string for the property
    CWnd * pParent                      : Optional parent window

Return Value:

    None

--*/
    : m_fWrite(fWrite),
      m_fEmpty(TRUE),
      m_fUseTable(TRUE),
      m_strMetaRoot(lpstrMetaRoot),
      m_strlMetaChildNodes(),
      m_strPropertyName(lpstrPropertyName ? lpstrPropertyName : _T("")),
      m_mk(pAuthInfo)
//      CDialog(CInheritanceDlg::IDD, pParent)
{
    //
    // Specify the resources to use
    //
//    HINSTANCE hOldRes = AfxGetResourceHandle();
//    AfxSetResourceHandle(hDLLInstance);

    VERIFY(CMetaKey::GetMDFieldDef(
        dwMetaID, 
        m_dwMDIdentifier, 
        m_dwMDAttributes, 
        m_dwMDUserType,
        m_dwMDDataType
        ));

    //
    // Need to do our own GetDataPaths()
    //
    CError err(GetDataPaths());

    if (!err.MessageBoxOnFailure())
    {
        Initialize();
    }

    //
    // Restore the resources
    //
//    AfxSetResourceHandle(hOldRes);
}



CInheritanceDlg::CInheritanceDlg(
    BOOL    fTryToFindInTable,
    DWORD   dwMDIdentifier,
    DWORD   dwMDAttributes,
    DWORD   dwMDUserType,
    DWORD   dwMDDataType,
    LPCTSTR lpstrPropertyName,
    BOOL    fWrite,
    CComAuthInfo * pAuthInfo,
    LPCTSTR lpstrMetaRoot,
    HWND hwndParent
    )
/*++

Routine Description:

    Inheritance dialog constructor.  This constructor will call GetDataPaths(),
    and will use the specified parameters if the property ID does not exist
    in the property table

Arguments:

    BOOL    fTryToFindInTable           : If TRUE, first look in table
    DWORD   dwMDIdentifier              : Metadata identifier
    DWORD   dwMDAttributes              : Metadata attributes
    DWORD   dwMDUserType                : Metadata user type
    DWORD   dwMDDataType                : Metadata data type
    LPCTSTR lpstrPropertyName           : Text string for the property
    BOOL    fWrite                      : TRUE from write, FALSE from delete
    CComAuthInfo * pAuthInfo            : Authentication info or NULL.
    LPCTSTR lpstrMetaRoot               : Meta root
    CWnd *  pParent                     : Optional parent window

Return Value:

    None

--*/
    : m_fWrite(fWrite),
      m_fEmpty(TRUE),
      m_fUseTable(FALSE),
      m_strMetaRoot(lpstrMetaRoot),
      m_strlMetaChildNodes(),
      m_mk(pAuthInfo)
//      CDialog(CInheritanceDlg::IDD, pParent)
{
    //
    // Specify the resources to use
    //
//    HINSTANCE hOldRes = AfxGetResourceHandle();
//    AfxSetResourceHandle(hDLLInstance);

    if (fTryToFindInTable && !CMetaKey::GetMDFieldDef(
        dwMDIdentifier, 
        m_dwMDIdentifier, 
        m_dwMDAttributes, 
        m_dwMDUserType,
        m_dwMDDataType
        ))
    {
        //
        // Did not exist in the table, use specified parameters
        //
        m_dwMDIdentifier  = dwMDIdentifier;
        m_dwMDAttributes  = dwMDAttributes;
        m_dwMDUserType    = dwMDUserType;
        m_dwMDDataType    = dwMDDataType;
        m_strPropertyName = lpstrPropertyName;
    }


    //
    // Need to do our own GetDataPaths()
    //
    CError err(GetDataPaths());

    if (!err.MessageBoxOnFailure())
    {
        Initialize();
    }

    //
    // Restore the resources
    //
//    AfxSetResourceHandle(hOldRes);
}



HRESULT
CInheritanceDlg::GetDataPaths()
/*++

Routine Description:

    GetDataPaths()

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    //ASSERT(!m_strServer.IsEmpty());

    CError err(m_mk.QueryResult());

    if (err.Succeeded())
    {
        err = m_mk.GetDataPaths( 
            m_strlMetaChildNodes,
            m_dwMDIdentifier,
            m_dwMDDataType,
            m_strMetaRoot
            );
    }

    return err;
}



void
CInheritanceDlg::Initialize()
/*++

Routine Description:

    Initialize data members.  Set the m_fEmpty flag to determine if
    it is necessary to proceed.

Arguments:

    None

Return Value:

    None

--*/
{
    CMetabasePath::CleanMetaPath(m_strMetaRoot);

    if (m_fUseTable && !CMetaKey::IsPropertyInheritable(m_dwMDIdentifier))
    {
        //
        // No point in displaying non-inheritable properties
        //
        return;
    }

    switch(m_dwMDIdentifier)
    {
    //
    // Ignore these properties, even though they are inheritable
    //
    case MD_VR_PATH:
    case MD_APP_ISOLATED:
    case MD_APP_FRIENDLY_NAME:
        return;
    }

    //
    // Check to see if the current metabase path contains an instance
    //
    CString strTmp;
    m_fHasInstanceInMaster = FriendlyInstance(m_strMetaRoot, strTmp);

    //
    // If property name was not specified in the constructor, load default
    // one from table.
    //
    if (m_strPropertyName.IsEmpty())
    {
        ASSERT(m_fUseTable);

        //
        // Specify the resources to use
        //
//        HINSTANCE hOldRes = AfxGetResourceHandle();
//        AfxSetResourceHandle(hDLLInstance);

        VERIFY(CMetaKey::GetPropertyDescription(
            m_dwMDIdentifier, 
            m_strPropertyName
            ));

//        AfxSetResourceHandle(hOldRes);
    }

    //
    // Go through the list of metapaths, and clean them
    // up.
    //
    CStringListEx::iterator it = m_strlMetaChildNodes.begin();
    while (it != m_strlMetaChildNodes.end())
    {
        CString& strMetaPath = (*it++);
        CMetabasePath::CleanMetaPath(strMetaPath);
    }

    //
    // If the special info key (lm/service/info) is in the list, remove it.
    // We only need to this if the key that is getting the
    // change (m_strMetaRoot) is the service master property (lm/service).
    // If it is anything else, then the special "info" key cannot be below
    // it so we don't need to check. Thus the first test is to see if there
    // is only one "/" character. If there is only one, then we know it is
    // the service and we can go ahead and do the test.  In some ways,
    // mfc is a pain, so we limited to the CString methods to do this
    // copy the root into the temp string.
    //
    int iSlash = m_strMetaRoot.ReverseFind(SZ_MBN_SEP_CHAR);

    if (iSlash >= 0)
    {
        strTmp = m_strMetaRoot.Left(iSlash);

        //
        // Now make sure that there aren't any more slashes
        //
        if (strTmp.Find(SZ_MBN_SEP_CHAR) == -1)
        {
            //
            // Now build the path to the special info key by adding it
            // to the meta root
            //
            strTmp = m_strMetaRoot + SZ_MBN_SEP_CHAR + IIS_MD_SVC_INFO_PATH;

            TRACE("Removing any descendants of %s\n", strTmp);

            //
            // Search the list for the info key and remove it if we find it
            //
            it = m_strlMetaChildNodes.begin();
            while (it != m_strlMetaChildNodes.end())
            {
                CString & strMetaPath = (*it);
                if (strTmp.CompareNoCase(strMetaPath.Left(strTmp.GetLength())) == 0)
                {
                    TRACEEOLID("Removing service/info metapath from list");
                    m_strlMetaChildNodes.erase(it);
                }
                it++;
            }
        }
    }

    //
    // Remove the first item if it's the current metapath
    //
    it = m_strlMetaChildNodes.begin();
    if (it != m_strlMetaChildNodes.end())
    {
        TRACE("Stripping %s\n", m_strMetaRoot);

        CString & strMetaPath = (*it);
        if (strMetaPath.CompareNoCase(m_strMetaRoot) == 0)
        {
            TRACEEOLID("Removing current metapath from list");
            m_strlMetaChildNodes.pop_front();
        }
    }

    m_fEmpty = m_strlMetaChildNodes.size() == 0;
}

#if 0
int
CInheritanceDlg::DoModal()
/*++

Routine Description:

    Display the dialog.

Arguments:

    None

Return Value:

    IDOK if the OK button was pressed, IDCANCEL otherwise.

--*/
{
    //
    // Specify the resources to use
    //
//    HINSTANCE hOldRes = AfxGetResourceHandle();
//    AfxSetResourceHandle(hDLLInstance);

    int answer = CDialog::DoModal();

    //
    // restore the resources
    //
//    AfxSetResourceHandle(hOldRes);

    return answer;
}
#endif


#if 0

void
CInheritanceDlg::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CDialog::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CInheritanceDlg)
    DDX_Control(pDX, IDC_LIST_CHILD_NODES, m_list_ChildNodes);
    //}}AFX_DATA_MAP
}


//
// Message Map
//
BEGIN_MESSAGE_MAP(CInheritanceDlg, CDialog)
    //{{AFX_MSG_MAP(CInheritanceDlg)
    ON_BN_CLICKED(IDC_BUTTON_SELECT_ALL, OnButtonSelectAll)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()
#endif


BOOL
CInheritanceDlg::FriendlyInstance(CString& strMetaRoot, CString& strFriendly)
/*++

Routine Description:

    Replace the instance number with its descriptive name.

Arguments:

    CString & strMetaRoot       : Metabase path
    CString & strFriendly       : Converted output friendly path.

Return Value:

    TRUE if the path contained an instance number.

--*/
{
    //
    // Break into fields
    //
    // CODEWORK: make static like BuildMetaPath
    //
   int n = CMetabasePath::GetInstanceNumber(strMetaRoot);
   if (n == 0)
   {
      // Master instance
      return FALSE;
   }
   CString service, instance;
   if (CMetabasePath::GetServicePath(strMetaRoot, service, NULL))
   {
      int len = strMetaRoot.GetLength();
      int pos = strMetaRoot.Find(SZ_MBN_SEP_CHAR);
      if (pos != -1)
      {
         HRESULT hr = m_mk.Open(METADATA_PERMISSION_READ, CMetabasePath(service, n));
         if (SUCCEEDED(hr))
         {
            CString comment;
            hr = m_mk.QueryValue(MD_SERVER_COMMENT, comment);
            m_mk.Close();

            if (FAILED(hr) || comment.IsEmpty())
            {
               strFriendly.Format(
                    SZ_MBN_MACHINE SZ_MBN_SEP_STR _T("%s") SZ_MBN_SEP_STR _T("%d"),
                    service,
                    n
                    );
            }
            else
            {
               strFriendly.Format(
                    SZ_MBN_MACHINE SZ_MBN_SEP_STR _T("%s") SZ_MBN_SEP_STR _T("%s"),
                    service,
                    comment
                    );
            }

            TRACEEOLID(strFriendly);

            //
            // Append the rest of the path
            //
            CString tail;
            CMetabasePath::SplitMetaPathAtInstance(strMetaRoot, instance, tail);
            strFriendly += tail;
   
            return TRUE;
         }
      }
   }
   return FALSE;
}



CString&
CInheritanceDlg::CleanDescendantPath(CString& strMetaPath)
/*++

Routine Description:

    Clean the descendant metabase path.  The path is shown
    as a descendant of the current metabase root, and instance
    numbers are replaced with their description names.

Arguments:

    CString & strMetaPath   : Metabase path to be treated

Return Value:

    Reference to the cleaned-up path.

--*/
{
    //
    // This better be a descendant!
    //
    ASSERT(strMetaPath.GetLength() >= m_strMetaRoot.GetLength());
    ASSERT(!::_tcsnicmp(strMetaPath, m_strMetaRoot, m_strMetaRoot.GetLength()));

    if (!m_fHasInstanceInMaster)
    {
        //
        // Need to replace the instance number with the friendly
        // name.
        //
        CString strTmp;
        VERIFY(FriendlyInstance(strMetaPath, strTmp));
        strMetaPath = strTmp;
    }

    strMetaPath = strMetaPath.Mid(m_strMetaRoot.GetLength() + 1);

    return strMetaPath;
}



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



LRESULT
CInheritanceDlg::OnInitDialog(HWND hwnd, LPARAM lParam)
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    //
    // Get friendly name for the property, and set the text.
    //
    CString strPrompt; 
    strPrompt.Format(_Module.GetResourceInstance(), 
       IDS_INHERITANCE_PROMPT, (LPCTSTR)m_strPropertyName);
    ::SetWindowText(GetDlgItem(IDC_STATIC_PROMPT), strPrompt);

    //
    // Turn inherited nodes into friendly paths, and add them
    // to the listbox.  Note the "current" node should have been
    // deleted at this stage.
    //
    CStringListEx::iterator pos = m_strlMetaChildNodes.begin();

    while (pos != m_strlMetaChildNodes.end())
    {
        CString strNode = (*pos++);
        m_list_ChildNodes.AddString(CleanDescendantPath(strNode));
    }
    return TRUE;
}



void
CInheritanceDlg::OnButtonSelectAll(WORD wNotifyCode, WORD wID, HWND hwndCtrl)
/*++

Routine Description:

    'Select All' button handler

Arguments:

    None

Return Value:

    None

--*/
{
   ASSERT(wNotifyCode == BN_CLICKED);
   ASSERT(wID == IDC_BUTTON_SELECT_ALL);
    //
    // Select all entries
    //
    if (m_list_ChildNodes.GetCount() == 1)
    {
        //
        // SelItemRange refuses to do a single member
        //
        m_list_ChildNodes.SetSel(0, TRUE);
    }
    else
    {
        m_list_ChildNodes.SelItemRange(TRUE, 0, m_list_ChildNodes.GetCount() - 1);
    }
}



void
CInheritanceDlg::OnOK(WORD wNotifyCode, WORD wID, HWND hwndCtrl)
/*++

Routine Description:

    'OK' button handler

Arguments:

    None

Return Value:

    None

--*/
{
   ASSERT(wNotifyCode == BN_CLICKED);
   ASSERT(wID == IDOK);
    //
    // Now delete the property for all selected child nodes.
    // Grab from the orginal list, and not the listbox
    // as the latter have been frienly-fied, and is no longer
    // usable.
    //
    int cItems = m_list_ChildNodes.GetCount();
    ASSERT(cItems > 0);

    CString strMetaPath;
    CError err(m_mk.QueryResult());

    if (err.Succeeded())
    {
        int i = 0;
        CStringListEx::iterator pos = m_strlMetaChildNodes.begin();
        while (pos != m_strlMetaChildNodes.end())
        {
            strMetaPath = (*pos++);

            if (m_list_ChildNodes.GetSel(i++) > 0)
            {
                TRACE("Deleting property on %s\n", strMetaPath);

                err = m_mk.Open(METADATA_PERMISSION_WRITE, strMetaPath);

                if (err.Failed())
                {
                    break;
                }

                err = m_mk.DeleteValue(m_dwMDIdentifier);

                m_mk.Close();

                if (err.Failed())
                {
                    break;
                }
            }
        }
    }

    if (!err.MessageBoxOnFailure())
    {
        //
        // Dialog can be dismissed
        //
        EndDialog(IDOK);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\common2\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(_STDAFX_H)
#define _STDAFX_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;

#define _WTL_NO_CSTRING

#include <atlcom.h>
#include <atlwin.h>
#include <atlapp.h>
#include <atlmisc.h>
#include <atlctrls.h>
#include <atlddx.h>
#include <atlcrack.h>

#include <map>
#include <list>
#include <stack>
#include <memory>
#include <shlwapi.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(_STDAFX_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\comprop\accessdl.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        accessdl.cpp

   Abstract:

        Access Dialog

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include "comprop.h"
#include "sitesecu.h"
#include "accessdl.h"
#include "dnsnamed.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif // _DEBUG




CIPAccessDlg::CIPAccessDlg(
    IN BOOL fDenyAccessMode,
    IN OUT CIPAccessDescriptor *& pAccess,
    IN CObListPlus * poblAccessList         OPTIONAL,
    IN CWnd * pParent                       OPTIONAL,
    IN BOOL fAllowDomains
    )
/*++

Routine Description:

    Constructor for the access descriptor editor dialog.  If constructed
    with a NULL access descriptor pointer, the access descriptor will
    be allocated, otherwise the dialog will edit the existing one in
    place.

Arguments:

    BOOL fDenyAccessMode         : If TRUE, we're denying access, if FALSE,
                                   we're granting access.
    CIPAccessDescriptor *& pAccess : Object being edited, or NULL to allocate 
                                   a new access descriptor
    CObListPlus * poblAccessList : List of already existing entries to check
                                   for duplicates, or NULL
    CWnd * pParent,              : Pointer to parent window or NULL
    BOOL fAllowDomains           : If TRUE, domain names are valid, otherwise
                                   they will not be available

Return Value:

    N/A

--*/
    : CDialog(CIPAccessDlg::IDD, pParent),
      m_pAccess(pAccess),
      m_poblAccessList(poblAccessList),
      m_fNew(pAccess == NULL),
      m_fDenyAccessMode(fDenyAccessMode),
      m_fAllowDomains(fAllowDomains)
{
#if 0   // Keep Class Wizard happy

    //{{AFX_DATA_INIT(CIPAccessDlg)
    m_nStyle = RADIO_SINGLE;
    //}}AFX_DATA_INIT

#endif // 0

    if (m_pAccess == NULL)
    {
        //
        // Allocate new one
        //
        m_pAccess = new CIPAccessDescriptor;
        if (m_pAccess)
        {
            m_pAccess->GrantAccess(!m_fDenyAccessMode);
        }
    }

    if (m_pAccess == NULL)
    {
        TRACEEOLID("Invalid access object -- possible memory failure");
        return;
    }
    
    if (m_pAccess->IsDomainName())
    {
        m_nStyle = RADIO_DOMAIN;
    }
    else
    {
        m_nStyle = m_pAccess->IsSingle() ? RADIO_SINGLE : RADIO_MULTIPLE;
    }

    //
    // We can only look at granted items when
    // deny by default is on and vice versa
    //
    ASSERT(m_pAccess->HasAccess() == !m_fDenyAccessMode);

    //
    // Load static strings
    //
    VERIFY(m_strIPAddress.LoadString(IDS_PROMPT_IP_ADDRESS));
    VERIFY(m_strNetworkID.LoadString(IDS_PROMPT_NETWORK_ID));
    VERIFY(m_strDomainName.LoadString(IDS_PROMPT_DOMAIN));
}



void
CIPAccessDlg::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CIPAccessDlg)
    DDX_Control(pDX, IDOK, m_button_OK);
    DDX_Control(pDX, IDC_EDIT_DOMAIN, m_edit_Domain);
    DDX_Control(pDX, IDC_STATIC_IP_ADDRESS, m_static_IpAddress);
    DDX_Control(pDX, IDC_STATIC_SUBNET_MASK, m_static_SubnetMask);
    DDX_Control(pDX, IDC_BUTTON_DNS, m_button_DNS);
    DDX_Radio(pDX, IDC_RADIO_SINGLE, m_nStyle);
    //}}AFX_DATA_MAP

    DDX_Control(pDX, IDC_RADIO_DOMAIN, m_radio_Domain);
    DDX_Control(pDX, IDC_IPA_IPADDRESS, m_ipa_IPAddress);
    DDX_Control(pDX, IDC_IPA_SUBNET_MASK, m_ipa_SubnetMask);
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CIPAccessDlg, CDialog)
    //{{AFX_MSG_MAP(CIPAccessDlg)
    ON_BN_CLICKED(IDC_RADIO_MULTIPLE, OnRadioMultiple)
    ON_BN_CLICKED(IDC_RADIO_SINGLE, OnRadioSingle)
    ON_BN_CLICKED(IDC_RADIO_DOMAIN, OnRadioDomain)
    ON_BN_CLICKED(IDC_BUTTON_DNS, OnButtonDns)
    //}}AFX_MSG_MAP

    ON_EN_CHANGE(IDC_IPA_IPADDRESS, OnItemChanged)
    ON_EN_CHANGE(IDC_IPA_SUBNET_MASK, OnItemChanged)
    ON_EN_CHANGE(IDC_EDIT_DOMAIN, OnItemChanged)

END_MESSAGE_MAP()



void
CIPAccessDlg::SetControlStates(
    IN int nStyle
    )
/*++

Routine Description:

    Show/hide controls depending on the type of access descriptor we're
    editing.

Arguments:

    int nStyle : Radio button style

Return Value:

    None

--*/
{
    m_nStyle = nStyle;

    ActivateControl(m_ipa_IPAddress,     m_nStyle != RADIO_DOMAIN);
    ActivateControl(m_static_SubnetMask, m_nStyle == RADIO_MULTIPLE);
    ActivateControl(m_ipa_SubnetMask,    m_nStyle == RADIO_MULTIPLE);
    ActivateControl(m_button_DNS,        m_nStyle == RADIO_SINGLE);
    ActivateControl(m_edit_Domain,       m_nStyle == RADIO_DOMAIN);

    //
    // Change the prompt over the editbox/ip address box to explain
    // what's supposed to be edited.
    //
    switch(m_nStyle)
    {
    case RADIO_SINGLE:
        m_static_IpAddress.SetWindowText(m_strIPAddress);
        break;

    case RADIO_MULTIPLE:
        m_static_IpAddress.SetWindowText(m_strNetworkID);
        break;

    case RADIO_DOMAIN:
        ASSERT(m_fAllowDomains);
        m_static_IpAddress.SetWindowText(m_strDomainName);
        break;
    }
}



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BOOL
CIPAccessDlg::OnInitDialog()
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CDialog::OnInitDialog();

    ASSERT(m_pAccess != NULL);
    if (m_pAccess == NULL)
    {
        TRACEEOLID("access descriptor is NULL -- aborting dialog");
        CError::MessageBox(ERROR_NOT_ENOUGH_MEMORY);
        EndDialog(IDCANCEL);

        return FALSE;
    }

    //
    // Domain selection not always available
    //
    ASSERT(!(!m_fAllowDomains && m_pAccess->IsDomainName()));
    ActivateControl(m_radio_Domain, m_fAllowDomains);

    //
    // Use an appropriate title for the dialog depending on
    // whether we're editing a 'grant' item or a 'deny' item
    //
    CString strTitle;
    
    VERIFY(strTitle.LoadString(m_fDenyAccessMode
        ? IDS_DENY
        : IDS_GRANT));
    SetWindowText(strTitle);

    //
    // Set fields to be edited
    //
    if (m_pAccess->IsDomainName())
    {
        m_edit_Domain.SetWindowText(m_pAccess->QueryDomainName());    
    }
    else
    {
        DWORD dwIP = m_pAccess->QueryIPAddress();

        if (dwIP != 0L)
        {
            m_ipa_IPAddress.SetAddress(m_pAccess->QueryIPAddress());
        }

        if (!m_pAccess->IsSingle())
        {
            m_ipa_SubnetMask.SetAddress(m_pAccess->QuerySubnetMask());
        }
    }

    //
    // Configure the dialog appropriately
    //
    SetControlStates(m_nStyle);

    //
    // No changes made yet
    //
    m_button_OK.EnableWindow(FALSE);

    return TRUE;
}



void
CIPAccessDlg::OnRadioSingle()
/*++

Routine Description:

    'Single' radio button has been pressed. Change dialog style 
    appropriately.

Arguments:

    None

Return Value:

    None

--*/
{
    SetControlStates(RADIO_SINGLE);
    OnItemChanged();
}



void
CIPAccessDlg::OnRadioMultiple()
/*++

Routine Description:

    'Multiple' radio button has been pressed. Change dialog style 
    appropriately.

Arguments:

    None

Return Value:

    None

--*/
{
    SetControlStates(RADIO_MULTIPLE);
    OnItemChanged();
}



void 
CIPAccessDlg::OnRadioDomain() 
/*++

Routine Description:

    'Domain' radio button has been pressed. Change dialog style 
    appropriately.  If this the first time domain has been pressed,
    put up a warning about the performance implications of using
    domain filtering.

Arguments:

    None

Return Value:

    None

--*/
{
    ASSERT(m_fAllowDomains);

    static BOOL fShownWarning = FALSE;

    if (!fShownWarning)
    {
        fShownWarning = TRUE;
        ::AfxMessageBox(IDS_DOMAIN_PERF);
    }

    SetControlStates(RADIO_DOMAIN);
    OnItemChanged();
}



void 
CIPAccessDlg::OnItemChanged()
/*++

Routine Description:

    Control data has changed.  Check to see if sufficient data have been
    entered given the type of access descriptor being edited, and enable
    or disable the OK button based on that result.

Arguments:

    None

Return Value:

    None

--*/
{
    DWORD dwIP;
    DWORD dwMask;
    BOOL fOK = FALSE;
    CString strDomain;

    switch(m_nStyle)
    {
    case RADIO_DOMAIN:
        m_edit_Domain.GetWindowText(strDomain);
        fOK = !strDomain.IsEmpty();
        break;

    case RADIO_SINGLE:
        m_ipa_IPAddress.GetAddress(&dwIP);
        fOK = (dwIP != 0L);
        break;

    case RADIO_MULTIPLE:
        m_ipa_IPAddress.GetAddress(&dwIP);
        m_ipa_SubnetMask.GetAddress(&dwMask);
        fOK = (dwIP != 0L && dwMask != 0L);
        break;
    }
    
    m_button_OK.EnableWindow(fOK);
}



void 
CIPAccessDlg::OnButtonDns() 
/*++

Routine Description:

    'DNS' Button was pressed.  Bring up the DNS name resolver dialog
    which will set the value in the associated IP address control.

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Ask for a DNS name to resolve to an IP address.  The ip address
    // control is passed along to the dns name dialog which will manage
    // the ip addresses in it automatically.
    //
    CDnsNameDlg dlg(&m_ipa_IPAddress);
    dlg.DoModal();
}



void
CIPAccessDlg::OnCancel()
/*++

Routine Description:

    IDCANCEL handler.  If we had allocated the access descriptor, throw it
    away now.

Arguments:

    None

Return Value:

    None

--*/
{
    if (m_fNew && m_pAccess != NULL)
    {
        delete m_pAccess;
        m_pAccess = NULL;
    }

    CDialog::OnCancel();
}



void
CIPAccessDlg::OnOK()
/*++

Routine Description:

    Handler for IDOK.  Save control data to the access descriptor object
    being edited.  If we have a list of access descriptors, check for
    duplicates.

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Must have been allocated by now.
    //
    ASSERT(m_pAccess != NULL);

    UpdateData(TRUE);

    if (m_nStyle == RADIO_DOMAIN)
    {
        CString strDomain;
        m_edit_Domain.GetWindowText(strDomain);

        //
        // Ensure that wildcards are used only in the first char
        // of the name, or not at all.
        //
        int nWildCard;
        if ((nWildCard = strDomain.ReverseFind(_T('*'))) != -1)
        {
            if (nWildCard != 0 
                || strDomain.GetLength() < 3 
                || strDomain[1] != _T('.'))
            {
                //
                // Don't dismiss
                //
                m_edit_Domain.SetFocus();
                m_edit_Domain.SetSel(0,-1);
                ::AfxMessageBox(IDS_INVALID_DOMAIN_NAME);
                return;
            }
        }

        m_pAccess->SetValues(!m_fDenyAccessMode, strDomain);
    }
    else 
    {
        DWORD dwIP;
        m_ipa_IPAddress.GetAddress(&dwIP);

        //
        // Filter out bogus ip addresses
        //
        if (dwIP == 0L || dwIP == (DWORD)-1L)
        {
            //
            // Don't dismiss the dialog
            //
            m_ipa_IPAddress.SetFocus(0);
            ::AfxMessageBox(IDS_IP_INVALID);
            return;
        }

        if (m_nStyle == RADIO_SINGLE)
        {
            m_pAccess->SetValues(!m_fDenyAccessMode, dwIP);
        }
        else // Multiple
        {
            DWORD dwMask;
            m_ipa_SubnetMask.GetAddress(&dwMask);

            m_pAccess->SetValues(!m_fDenyAccessMode, dwIP, dwMask);
        }
    }

    //
    // Check for duplicates in the list
    //
    if (m_poblAccessList)
    {
        if (m_pAccess->DuplicateInList(*m_poblAccessList))
        {
            //
            // Found duplicate; don't dismiss the dialog
            //
            ::AfxMessageBox(IDS_DUPLICATE_ENTRY);
            return;
        }
    }

    //
    // Everything ok -- dismiss the dialog.
    //
    CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\common2\utcls.h ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        utcls.h

   Abstract:

        Some utility functions and classes.

   Author:

        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:

        Internet Services Manager

   Revision History:

--*/

#ifndef _UTCLS_H_
#define _UTCLS_H_

#pragma warning(disable : 4275)

//
// CDialog parameters
//
#define USE_DEFAULT_CAPTION (0)

//
// Determine if the given server name refers to the local machine
//
BOOL _EXPORT
IsServerLocal(
    IN LPCTSTR lpszServer       
    );

//
// Get volume information system flags for the given path
//
BOOL _EXPORT
GetVolumeInformationSystemFlags(
    IN  LPCTSTR lpszPath,
    OUT DWORD * pdwSystemFlags
    );

//
// Build registry key name
//
LPCTSTR _EXPORT GenerateRegistryKey(
    OUT CString & strBuffer,    
    IN  LPCTSTR lpszSubKey = NULL
    );


class _EXPORT CStringListEx : public std::list<CString>
{
public:
   CStringListEx();
   ~CStringListEx();

   void PushBack(LPCTSTR str);
   void Clear();

   DWORD ConvertFromDoubleNullList(LPCTSTR lpstrSrc, int cChars = -1);
   DWORD ConvertToDoubleNullList(DWORD & cchDest, LPTSTR & lpstrDest);
};


class _EXPORT CBlob
/*++

Class Description:

    Binary large object class, which owns its pointer

Public Interface:

    CBlob           : Constructors
    ~CBlob          : Destructor

    SetValue        : Assign the value
    GetSize         : Get the byte size
    GetData         : Get pointer to the byte stream

--*/
{
//
// Constructors/Destructor
//
public:
    //
    // Initialize empty blob
    //
    CBlob();

    //
    // Initialize with binary data
    //
    CBlob(
        IN DWORD dwSize,
        IN PBYTE pbItem,
        IN BOOL fMakeCopy = TRUE
        );

    //
    // Copy constructor
    //
    CBlob(IN const CBlob & blob);

    //
    // Destructor destroys the pointer
    //    
    ~CBlob();

//
// Operators
//
public:
    CBlob & operator =(const CBlob & blob);
    BOOL operator ==(const CBlob & blob) const;
    BOOL operator !=(const CBlob & blob) const { return !operator ==(blob); }

//
// Access
//
public: 
    //
    // Clean up internal data
    //
    void CleanUp();

    //
    // Set the current value of the blob
    //
    void SetValue(
        IN DWORD dwSize,
        IN PBYTE pbItem,
        IN BOOL fMakeCopy = TRUE
        );

    //
    // TRUE if the blob is currently empty
    //
    BOOL IsEmpty() const { return m_dwSize == 0L; }

    //
    // Return the size of the blob in bytes
    //
    DWORD GetSize() const { return m_dwSize; }

    //
    // Get a pointer to the byte stream
    //
    PBYTE GetData();

private:
    DWORD m_dwSize;
    PBYTE m_pbItem;
};

// Blob for use in CryptoAPI functions
//
class CCryptBlob
{
public:
	CCryptBlob()
	{
		m_blob.cbData = 0;
		m_blob.pbData = NULL;
	}
	virtual ~CCryptBlob()
	{
	}
	DWORD GetSize() {return m_blob.cbData;}
	BYTE * GetData() {return m_blob.pbData;}
	void Set(DWORD cb, BYTE * pb)
	{
		Destroy();
		m_blob.cbData = cb;
		m_blob.pbData = pb;
	}
	BOOL Resize(DWORD cb)
   {
      BOOL res = TRUE;
      BYTE * p = m_blob.pbData;
      if (NULL != (m_blob.pbData = Realloc(m_blob.pbData, cb)))
      {
         m_blob.cbData = cb;
      }
      else
      {
         m_blob.pbData = p;
         res = FALSE;
      }
      return res;
   }
	operator CRYPT_DATA_BLOB *()
	{
		return &m_blob;
	}

protected:
	void Destroy()
	{
		if (m_blob.pbData != NULL)
			Free(m_blob.pbData);
	}
	virtual BYTE * Realloc(BYTE * pb, DWORD cb) = 0;
	virtual void Free(BYTE * pb) = 0;
	CRYPT_DATA_BLOB m_blob;
};

class CCryptBlobIMalloc : public CCryptBlob
{
public:
	virtual ~CCryptBlobIMalloc()
	{
		CCryptBlob::Destroy();
	}

protected:
	virtual BYTE * Realloc(BYTE * pb, DWORD cb)
	{
		return (BYTE *)CoTaskMemRealloc(pb, cb);
	}
	virtual void Free(BYTE * pb)
	{
		CoTaskMemFree(pb);
	}
};

class CCryptBlobLocal : public CCryptBlob
{
public:
	virtual ~CCryptBlobLocal()
	{
		CCryptBlob::Destroy();
	}

protected:
	virtual BYTE * Realloc(BYTE * pb, DWORD cb)
	{
		return (BYTE *)realloc(pb, cb);
	}
	virtual void Free(BYTE * pb)
	{
		free(pb);
	}
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline CBlob::~CBlob()
{
    CleanUp();
}

inline PBYTE CBlob::GetData()
{
    return m_pbItem;
}





#endif // _UTCLS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\common2\mdkeys.cpp ===
/*++

   Copyright    (c)    1994-2000    Microsoft Corporation

   Module  Name :

        mdkeys.cpp

   Abstract:

        Metabase key wrapper class

   Author:

        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:

        Internet Services Manager

   Revision History:
        2/17/2000    sergeia     removed dependency on MFC

--*/

//
// Include Files
//
#include "stdafx.h"
#include "common.h"
#include "inheritancedlg.h"
#include "mdkeys.h"


//
// Constants
//
#define MB_TIMEOUT          (15000)     // Timeout in milliseconds 
#define MB_INIT_BUFF_SIZE   (  256)     // Initial buffer size


//
// CComAuthInfo implementation
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

/* static */
BOOL
CComAuthInfo::SplitUserNameAndDomain(
    IN OUT CString & strUserName,
    IN CString & strDomainName
    )
/*++

Routine Description:

    Split the user name and domain from the given
    username, which is in the format "domain\user".

    Return TRUE if the user name contained a domain
    FALSE if it did not

Arguments:

    CString & strUserName   : User name which may contain a domain name
    CString & strDomainName : Output domain name ("." if local)

Return Value:

    TRUE if a domain is split off

--*/
{
    //
    // Assume local
    //
    strDomainName = _T(".");
    int nSlash = strUserName.Find(_T("\\"));

    if (nSlash >= 0)
    {
        strDomainName = strUserName.Left(nSlash);
        strUserName = strUserName.Mid(nSlash + 1);

        return TRUE;
    }

    return FALSE;
}


/* static */
DWORD
CComAuthInfo::VerifyUserPassword(
    IN LPCTSTR lpstrUserName,
    IN LPCTSTR lpstrPassword
    )
/*++

Routine Description:

    Verify the usernamer password combo checks out

Arguments:

    LPCTSTR lpstrUserName   : Domain/username combo
    LPCTSTR lpstrPassword   : Password

Return Value:

    ERROR_SUCCESS if the password checks out, an error code
    otherwise.

--*/
{
    CString strDomain;
    CString strUser(lpstrUserName);
    CString strPassword(lpstrPassword);

    SplitUserNameAndDomain(strUser, strDomain);

    //
    // In order to look up an account name, this process
    // must first be granted the privilege of doing so.
    //
    CError err;
    {
        HANDLE hToken;
        LUID AccountLookupValue;
        TOKEN_PRIVILEGES tkp;

        do
        {
            if (!::OpenProcessToken(GetCurrentProcess(),
                  TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                  &hToken)
               )
            {
                err.GetLastWinError();
                break;
            }

            if (!::LookupPrivilegeValue(NULL, SE_TCB_NAME, &AccountLookupValue))
            {
                err.GetLastWinError();
                break;
            }

            tkp.PrivilegeCount = 1;
            tkp.Privileges[0].Luid = AccountLookupValue;
            tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

            ::AdjustTokenPrivileges(
                hToken,
                FALSE,
                &tkp,
                sizeof(TOKEN_PRIVILEGES),
                (PTOKEN_PRIVILEGES)NULL,
                (PDWORD)NULL
                );

            err.GetLastWinError();

            if (err.Failed())
            {
                break;
            }

            HANDLE hUser = NULL;

            if (::LogonUser(
                (LPTSTR)(LPCTSTR)strUser,
                (LPTSTR)(LPCTSTR)strDomain,
                (LPTSTR)(LPCTSTR)strPassword,
                LOGON32_LOGON_NETWORK,
                LOGON32_PROVIDER_DEFAULT,
                &hUser
                ))
            {
                //
                // Success!
                //
                CloseHandle(hUser);
            }
            else
            {
                err.GetLastWinError();
            }

            //
            // Remove the privilege
            //
        }
        while(FALSE);
    }

    HANDLE hUser = NULL;

    if (::LogonUser(
        (LPTSTR)(LPCTSTR)strUser,
        (LPTSTR)(LPCTSTR)strDomain,
        (LPTSTR)(LPCTSTR)strPassword,
        LOGON32_LOGON_NETWORK,
        LOGON32_PROVIDER_DEFAULT,
        &hUser))
    {
        //
        // Success!
        //
        CloseHandle(hUser);
    }
    else
    {
        err.GetLastWinError();
    }

    return err;
}



CComAuthInfo::CComAuthInfo(
    IN LPCOLESTR lpszServerName     OPTIONAL,
    IN LPCOLESTR lpszUserName       OPTIONAL,
    IN LPCOLESTR lpszPassword       OPTIONAL
    )
/*++

Routine Description:

    Construct CIIServer object

Argument:

    LPCOLESTR lpszServerName     : Server name or NULL for local computer
    LPCOLESTR lpszUserName       : User name of blank for no impersonation
    LPCOLESTR lpszPassword       : Password (might be blank or NULL)

Return Value:

    N/A

--*/
    : m_bstrServerName(),
      m_bstrUserName(lpszUserName),
      m_bstrPassword(lpszPassword),
      m_fLocal(FALSE)
{
    SetComputerName(lpszServerName);
}



CComAuthInfo::CComAuthInfo(
    IN CComAuthInfo & auth
    )
/*++

Routine Description:

    Copy constructor

Arguments:

    CComAuthInfo & auth    : Source object to copy from

Return Value:

    N/A

--*/
    : m_bstrServerName(auth.m_bstrServerName),
      m_bstrUserName(auth.m_bstrUserName),
      m_bstrPassword(auth.m_bstrPassword),
      m_fLocal(auth.m_fLocal)
{
}



CComAuthInfo::CComAuthInfo(
    IN CComAuthInfo * pAuthInfo        OPTIONAL
    )
/*++

Routine Description:

    Copy constructor

Arguments:

    CComAuthInfo * pAuthInfo    : Source object to copy from (or NULL)

Return Value:

    N/A

--*/
    : m_bstrServerName(),
      m_bstrUserName(),
      m_bstrPassword(),
      m_fLocal(FALSE)
{
    if (pAuthInfo)
    {
        //
        // Full authentication information available
        //
        m_bstrUserName = pAuthInfo->m_bstrUserName;
        m_bstrPassword = pAuthInfo->m_bstrPassword;
        m_bstrServerName = pAuthInfo->m_bstrServerName;
        m_fLocal = pAuthInfo->m_fLocal;
    }
    else
    {
        //
        // Local computer w/o impersonation
        //
        SetComputerName(NULL);
    }
}



CComAuthInfo & 
CComAuthInfo::operator =(
    IN CComAuthInfo & auth
    )
/*++

Routine Description:

    Assignment operator

Arguments:

    CComAuthInfo & auth     : Source object to copy from

Return Value:

    Reference to current object

--*/
{
    m_bstrServerName = auth.m_bstrServerName;
    m_bstrUserName   = auth.m_bstrUserName;
    m_bstrPassword   = auth.m_bstrPassword;
    m_fLocal         = auth.m_fLocal;

    return *this;
}



CComAuthInfo & 
CComAuthInfo::operator =(
    IN CComAuthInfo * pAuthInfo       OPTIONAL
    )
/*++

Routine Description:

    Assignment operator

Arguments:

    CComAuthInfo * pAuthInfo : Source object to copy from (or NULL)

Return Value:

    Reference to current object

--*/
{
    if (pAuthInfo)
    {
        m_bstrUserName = pAuthInfo->m_bstrUserName;
        m_bstrPassword = pAuthInfo->m_bstrPassword;
        SetComputerName(pAuthInfo->m_bstrServerName);
    }
    else
    {
        //
        // Local computer w/o impersonation
        //
        m_bstrUserName.Empty();
        m_bstrPassword.Empty();
        SetComputerName(NULL);
    }

    return *this;
}


CComAuthInfo & 
CComAuthInfo::operator =(
    IN LPCTSTR lpszServerName
    )
/*++

Routine Description:

    Assignment operator.  Assign computer name w/o impersonation

Arguments:

    LPCTSTR lpszServerName      : Source server name

Return Value:

    Reference to current object

--*/
{
    RemoveImpersonation();
    SetComputerName(lpszServerName);

    return *this;
}



void
CComAuthInfo::SetComputerName(
    IN LPCOLESTR lpszServerName   OPTIONAL
    )
/*++

Routine Description:

    Store the computer name.  Determine if its local.

Arguments:

    LPCOLESTR lpszServername  : Server name.  NULL indicates the local computer

Return Value:

    None

--*/
{
    if (lpszServerName && *lpszServerName)
    {
        //
        // Specific computer name specified
        //
        m_bstrServerName = lpszServerName;
        m_fLocal = ::IsServerLocal(lpszServerName);
    }
    else
    {
        //
        // Use local computer name
        //
        // CODEWORK: Cache static version of computername maybe?
        // 
        TCHAR szLocalServer[MAX_PATH + 1];
        DWORD dwSize = MAX_PATH;

        VERIFY(::GetComputerName(szLocalServer, &dwSize));
        m_bstrServerName = szLocalServer;
        m_fLocal = TRUE;
    }
}



void     
CComAuthInfo::SetImpersonation(
    IN LPCOLESTR lpszUser, 
    IN LPCOLESTR lpszPassword
    )
/*++

Routine Description:

    Set impersonation parameters

Arguments:

    LPCOLESTR lpszUser          : User name
    LPCOLESTR lpszPassword      : Password

Return Value:

    None

--*/
{
    m_bstrUserName = lpszUser;
    StorePassword(lpszPassword);
}



void     
CComAuthInfo::RemoveImpersonation()
/*++

Routine Description:

    Remove impersonation parameters

Arguments:

    None

Return Value:

    None

--*/
{
    m_bstrUserName.Empty();
    m_bstrPassword.Empty();
}



COSERVERINFO * 
CComAuthInfo::CreateServerInfoStruct() const
/*++

Routine Description:

    Create the server info structure.  Might return NULL for the no frills case.

Arguments:

    NULL

Return Value:

    A COSERVERINFO structure, or NULL if the computer is local, and no
    impersonation is required.

Notes:

    Caller must call FreeServerInfoStruct() to prevent memory leaks

--*/
{
    //
    // Be smart about the server name; optimize for local
    // computer name.
    //
    if (m_fLocal && !UsesImpersonation())
    {
        //
        // Special, no-frills case. 
        //
        return NULL;
    }

    //
    // Create the COM server info for CoCreateInstanceEx
    //
    COSERVERINFO * pcsiName = NULL;

    do
    {
        pcsiName = new COSERVERINFO;

        if (!pcsiName)
        {
            break;
        }
        ZeroMemory(pcsiName, sizeof(COSERVERINFO));
        pcsiName->pwszName = m_bstrServerName;

        //
        // Set impersonation 
        //
        if (UsesImpersonation())
        {
            COAUTHINFO * pAuthInfo = new COAUTHINFO;

            if (!pAuthInfo)
            {
                break;
            }
            ZeroMemory(pAuthInfo, sizeof(COAUTHINFO));

            COAUTHIDENTITY * pAuthIdentityData = new COAUTHIDENTITY;

            if (!pAuthIdentityData)
            {
                break;
            }
            ZeroMemory(pAuthIdentityData, sizeof(COAUTHIDENTITY));

            CString strUserName(m_bstrUserName);
            CString strPassword(m_bstrPassword);
            CString strDomain;

            //
            // Break up domain\username combo
            //
            SplitUserNameAndDomain(strUserName, strDomain);

            pAuthIdentityData->UserLength = strUserName.GetLength();

            if (pAuthIdentityData->UserLength != 0)
            {
                pAuthIdentityData->User = StrDup(strUserName);
            }

            pAuthIdentityData->DomainLength = strDomain.GetLength();

            if (pAuthIdentityData->DomainLength != 0)
            {
                pAuthIdentityData->Domain = StrDup(strDomain);
            }

            pAuthIdentityData->PasswordLength = strPassword.GetLength();

            if (pAuthIdentityData->PasswordLength)
            {
                pAuthIdentityData->Password = StrDup(strPassword);
            }

            pAuthIdentityData->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;
            pAuthInfo->dwAuthnLevel = RPC_C_AUTHN_LEVEL_CONNECT;
            pAuthInfo->dwImpersonationLevel = RPC_C_IMP_LEVEL_IMPERSONATE;
            pAuthInfo->dwAuthnSvc = RPC_C_AUTHN_WINNT;
            pAuthInfo->dwAuthzSvc = RPC_C_AUTHZ_NONE;
            pAuthInfo->pwszServerPrincName = NULL;
            pAuthInfo->dwCapabilities = EOAC_NONE;
            pAuthInfo->pAuthIdentityData = pAuthIdentityData;
            pcsiName->pAuthInfo = pAuthInfo;
        }
    }
    while(FALSE);

    return pcsiName;
}



void 
CComAuthInfo::FreeServerInfoStruct(
    IN COSERVERINFO * pServerInfo
    ) const
/*++

Routine Description:

    As mentioned above -- free the server info structure

Arguments:

    COSERVERINFO * pServerInfo  : Server info structure

Return Value:

    None

--*/
{
    if (pServerInfo)
    {
        if (pServerInfo->pAuthInfo)
        {
            if (pServerInfo->pAuthInfo->pAuthIdentityData)
            {
                if (pServerInfo->pAuthInfo->pAuthIdentityData)
                {
                    LocalFree(pServerInfo->pAuthInfo->pAuthIdentityData->User);
                    LocalFree(pServerInfo->pAuthInfo->pAuthIdentityData->Domain);
                    LocalFree(pServerInfo->pAuthInfo->pAuthIdentityData->Password);
                    delete pServerInfo->pAuthInfo->pAuthIdentityData;
                }
            }

            delete pServerInfo->pAuthInfo;
        }

        delete pServerInfo;
    }
}



HRESULT
CComAuthInfo::ApplyProxyBlanket(
    IN OUT IUnknown * pInterface
    )
/*++

Routine Description:

    Set security information on the interface.  The user name is of the form
    domain\username.

Arguments:

    IUnknown * pInterface       : Interface

Return Value:

    HRESULT

--*/
{
    HRESULT hr = S_OK;

    COSERVERINFO * pcsiName = CreateServerInfoStruct();

    //
    // This method should only be called if we're using impersonation.
    // so the pcsiName returned should never be NULL.
    //
    ATLASSERT(pcsiName && pcsiName->pAuthInfo);

    DWORD dwAuthSvc, dwAuthzSvc, dwAuthnLevel, dwImplLevel, dwCaps;
    OLECHAR * pServerPrincName;
    RPC_AUTH_IDENTITY_HANDLE pAuthInfo;

    hr = ::CoQueryProxyBlanket(
       pInterface,
       &dwAuthSvc,
       &dwAuthzSvc,
       &pServerPrincName,
       &dwAuthnLevel,
       &dwImplLevel,
       &pAuthInfo,
       &dwCaps);

    if (pcsiName && pcsiName->pAuthInfo)
    {
        hr =  ::CoSetProxyBlanket(
            pInterface,
            pcsiName->pAuthInfo->dwAuthnSvc,
            pcsiName->pAuthInfo->dwAuthzSvc,
            pcsiName->pAuthInfo->pwszServerPrincName,
            pcsiName->pAuthInfo->dwAuthnLevel,
            pcsiName->pAuthInfo->dwImpersonationLevel,
            pcsiName->pAuthInfo->pAuthIdentityData,
            pcsiName->pAuthInfo->dwCapabilities    
            );

        FreeServerInfoStruct(pcsiName);
    }

    return hr;
}


//
// CMetabasePath implemention
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



const LPCTSTR CMetabasePath::_cszMachine = SZ_MBN_MACHINE;
const LPCTSTR CMetabasePath::_cszRoot    = SZ_MBN_ROOT;
const LPCTSTR CMetabasePath::_cszSep     = SZ_MBN_SEP_STR;
const TCHAR   CMetabasePath::_chSep      = SZ_MBN_SEP_CHAR;
const CString CMetabasePath::_anySep     = SZ_MBN_ANYSEP_STR;

/*static*/
BOOL
CMetabasePath::IsSeparator(TCHAR c)
{
   return _anySep.find(c) != CString::npos;
}

/* static */
LPCTSTR
CMetabasePath::ConvertToParentPath(
    CString& strMetaPath
    )
/*++

Routine Description:

    Given the path, convert it to the parent path
    e.g. "foo/bar/etc" returns "foo/bar"

Arguments:

    CString & strMetaPath    : Path to be converted

Return value:

    Pointer to the converted path, or NULL in case of error

--*/
{
//   TRACE(_T("Getting parent path of %s\n"), strMetaPath);

   CString::size_type pos, pos_head;
   if ((pos = strMetaPath.find_last_of(SZ_MBN_ANYSEP_STR)) == strMetaPath.length() - 1)
   {
      strMetaPath.erase(pos);
   }
   pos = strMetaPath.find_last_of(SZ_MBN_ANYSEP_STR);
   if (pos == CString::npos)
      return strMetaPath;
   pos_head = strMetaPath.find_first_of(SZ_MBN_ANYSEP_STR);
   if (pos_head != pos)
   {
      strMetaPath.erase(pos);
   }

//   TRACE(_T("Parent path should be %s\n"), strMetaPath);

   return strMetaPath;
}

LPCTSTR
CMetabasePath::ConvertToParentPath(
    CMetabasePath& path
    )
{
   return CMetabasePath::ConvertToParentPath(path.m_strMetaPath);
}

/* static */
LPCTSTR
CMetabasePath::TruncatePath(
    int nLevel,          
    LPCTSTR lpszMDPath,
    CString & strNewPath,
    CString * pstrRemainder     OPTIONAL
    )
/*++

Routine Description:

    Truncate the given metabase path at the given level, that is, 
    the nLevel'th separator in the path, starting at 0, where 0 will
    always give lpszPath back whether it started with a separator or not.

    Examples: 

        "/lm/w3svc/1/foo" at level 2 returns "/lm/w3svc" as does
        "lm/w3svc/1/foo".
    
Arguments:

    int     nLevel             0-based separator count to truncate at.
    LPTSTR lpszMDPath          Fully-qualified metabase path
    CString & strNewPath       Returns truncated path
    CString * pstrRemainder    Optionally returns the remainder past
                               the nLevel'th separator.

Return Value:

    The truncated path at the level requested.  See examples above. *pstrRemainder
    returns the remainder of the path.  If the path does not contain nLevel
    worth of separators, the entire path is returned, and the remainder will be
    blank. 

--*/
{
//    ASSERT_PTR(lpszMDPath);
    ATLASSERT(nLevel >= 0);

    if (!lpszMDPath || nLevel < 0)
    {
//        TRACE(_T("TruncatePath: Invalid parameter\n"));
        return NULL;
    }

//    TRACE(_T("Source Path: %s\n"), lpszMDPath);

    //
    // Skip the first sep whether it exists or not
    //
    LPCTSTR lp = IsSeparator(*lpszMDPath) ? lpszMDPath + 1 : lpszMDPath;
    LPCTSTR lpRem = NULL;
    int cSeparators = 0;

    if (nLevel)
    {
        //
        // Advance to the requested separator level
        //
        while (*lp)
        {
            if (IsSeparator(*lp))
            {
                if (++cSeparators == nLevel)
                {
                    break;
                }
            }

            ++lp;
        }

        if (!*lp)
        {
            //
            // End of path is considered a separator
            //
            ++cSeparators;
        }

        ATLASSERT(cSeparators <= nLevel);

        if (cSeparators == nLevel)
        {
            //
            // Break up the strings
            //
            strNewPath = lpszMDPath;
            strNewPath.erase(lp - lpszMDPath);

//            TRACE(_T("Path truncated at level %d : %s\n"), nLevel, strNewPath);

            if (*lp)
            {
                lpRem = ++lp;
//                TRACE(_T("Remainder: %s\n"), lpRem);
            }
        }
    }

    //
    // Return remainder
    //
    if (pstrRemainder && lpRem)
    {
//        ASSERT_WRITE_PTR(pstrRemainder);
        *pstrRemainder = lpRem;
    }

    return strNewPath;
}



/* static */
DWORD 
CMetabasePath::GetInstanceNumber(
    IN LPCTSTR lpszMDPath
    )
/*++

Routine Description:

    Get the number of the instance referred to in the given metabase
    path.  
    
    Examples:  "lm/w3svc/1/foo/bar" will return 1
               "lm/w3svc/"          will return 0 (master instance)
               "lm/bogus/path/"     will return 0xffffffff (error)

Arguments:

    LPCTSTR lpszMDPath      : A metabase path.

Return Value:

    Instance number (0 indicates master instance)
    or 0xffffffff if the path is in error.

--*/
{
//    TRACE(_T("Determining instance number of %s\n"), lpszMDPath);
    DWORD dwInstance = 0xffffffff;

    CString strService, strInst;

    if (GetServicePath(lpszMDPath, strService, &strInst))
    {
        if (strInst.IsEmpty())
        {
            dwInstance = MASTER_INSTANCE;
        }
        else
        {
            if (_istdigit(strInst.GetAt(0)))  
            {
                dwInstance = _ttol(strInst);
            }
        }
    }

    return dwInstance;
}



/* static */
LPCTSTR
CMetabasePath::GetLastNodeName(
    IN  LPCTSTR lpszMDPath,
    OUT CString & strNodeName
    )
/*++

Routine Description:

    Get the last nodename off the metabase path

    Example:

        "/lm/foo/bar/"      returns "bar"

Arguments:

    LPCTSTR lpszMDPath      : Metabase path

Return Value:

    Pointer to the node name or NULL in case of a malformed path.

--*/
{
//    ASSERT_PTR(lpszMDPath);

    if (!lpszMDPath || !*lpszMDPath)
    {
        return NULL;
    }

//    TRACE(_T("Getting last node name from %s\n"), lpszMDPath);

    LPCTSTR lp;
    LPCTSTR lpTail;
    lp = lpTail = lpszMDPath + lstrlen(lpszMDPath) - 1;

    //
    // Skip trailing separator
    //
    if (IsSeparator(*lp))
    {
        --lpTail;
        --lp;
    }

    strNodeName.Empty();

    while (*lp && !IsSeparator(*lp))
    {
        strNodeName += *(lp--);
    }

    strNodeName.MakeReverse();

//    TRACE(_T("Node is %s\n"), strNodeName);
    
    return strNodeName;    
}



/* static */
void
CMetabasePath::SplitMetaPathAtInstance(
    LPCTSTR lpszMDPath,
    CString & strParent,
    CString & strAlias
    )
/*++

Routine Description:

    Split the given path into parent metabase root and alias, with the root
    being the instance path, and the alias everything following the
    instance.

Arguments:

    LPCTSTR lpszMDPath  : Input path
    CString & strParent : Outputs the parent path
    CString & strAlias  : Outputs the alias name

Return Value:

    None.

--*/
{
//    ASSERT_PTR(lpszMDPath);

//    TRACE(_T("Source Path %s\n"), lpszMDPath);

    strParent = lpszMDPath;
    strAlias.Empty();

    LPTSTR lp = (LPTSTR)lpszMDPath;

    if (lp == NULL)
    {
       return;
    }

    int cSeparators = 0;
    int iChar = 0;

    //
    // Looking for "LM/sss/ddd/" <-- 3d slash:
    //
    while (*lp && cSeparators < 2)
    {
        if (IsSeparator(*lp))
        {
            ++cSeparators;
        }

        ++iChar;
    }

    if (!*lp)
    {
        //
        // Bogus format
        //
        ASSERT_MSG("Bogus Format");
        return;
    }

    if (_istdigit(*lp))
    {
        //
        // Not at the master instance, skip one more.
        //
        while (*lp)
        {
            ++iChar;

            if (IsSeparator(*lp++))
            {
                break;
            }
        }

        if (!*lp)
        {
            //
            // Bogus format
            //
            ASSERT_MSG("Bogus Format");
            return;
        }
    }

    strAlias = strParent.Mid(iChar);
    strParent.erase(iChar);

//    TRACE(_T("Broken up into %s\n"), strParent);
//    TRACE(_T("           and %s\n"), strAlias);
}



/* static */
BOOL 
CMetabasePath::IsHomeDirectoryPath(
    IN LPCTSTR lpszMetaPath
    )
/*++

Routine Description:

    Determine if the path given describes a root directory

Arguments:

    LPCTSTR lpszMetaPath        : Metabase path

Return Value:

    TRUE if the path describes a root directory, 
    FALSE if it does not

--*/
{
//    ASSERT_READ_PTR(lpszMetaPath);

    LPTSTR lpNode = lpszMetaPath ? StrPBrk(lpszMetaPath, _anySep) : NULL;

    if (lpNode)
    {
        return _tcsicmp(++lpNode, _cszRoot) == 0;
    }

    return FALSE;
}



/* static */
BOOL 
CMetabasePath::IsMasterInstance(
    IN LPCTSTR lpszMDPath
    )
/*++

Routine Description:

    Determine if the given metabase path points to the master instance
    (site).  This is essentially the service path.

Arguments:

    LPCTSTR lpszMDPath  : Metabase path.

Return Value:

    TRUE if the path is the master instance,
    FALSE otherwise.

--*/
{
//    ASSERT_READ_PTR(lpszMDPath);

    if (!lpszMDPath || !*lpszMDPath)
    {
        return FALSE;
    }

//    TRACE(_T("Checking path %s\n"), lpszMDPath);

    CString strService;
    CString strRemainder;

    LPCTSTR lpPath = TruncatePath(2, lpszMDPath, strService, &strRemainder);

    return lpPath && !strService.IsEmpty() && strRemainder.IsEmpty();
}



/* static */
LPCTSTR
CMetabasePath::GetServiceInfoPath(
    IN  LPCTSTR lpszMDPath,
    OUT CString & strInfoPath,   
    IN  LPCTSTR lpszDefService      OPTIONAL
    )
/*++

Routine Description:

    Generate the appropriate metabase service info path for the given
    metabase path.  

    For example:

        "lm/w3svc/1/foo/bar"    Generates "lm/w3svc/info"

Arguments:

    LPCTSTR lpszMDPath      : Input metabase path
    CString & strInfoPath   : Returns the info path
    LPCTSTR lpszDefService  : Optionally specifies the default service to
                              use (e.g "w3svc") if no service could be found
                              in the path.
    
Return Value:

    The info metabase path or NULL if one could not be generated.

--*/
{
    //
    // Capability info stored off the service path ("lm/w3svc").
    //
    CString strService;
    CString strRem;
   
    //
    // Strip off everything past the service
    //
    if (!TruncatePath(2, lpszMDPath, strService, &strRem)
      || strService.IsEmpty())
    {
        if (!lpszDefService)
        {
//            TRACEEOLID("Unable to generate info path");
            return NULL;
        }

        TRACEEOLID("Using default service for info path");

        //
        // Machine path (no service).  Use web as default service to
        // look for capability and version info.
        //
        strService = CMetabasePath(TRUE, lpszDefService);
    }

    strInfoPath = CMetabasePath(FALSE, strService, SZ_MBN_INFO);
//    TRACE("Using %s to look for capability info\n", strInfoPath);

    return strInfoPath;
}
 


/* static */
LPCTSTR
CMetabasePath::CleanMetaPath(
    IN OUT CString & strMetaRoot
    )
/*++

Routine Description:

    Clean up the metabase path to one valid for internal consumption.
    This removes the beginning and trailing slashes off the path.

Arguments:

    CString & strMetaRoot       : Metabase path to be cleaned up.

Return Value:

    Pointer to the metabase path

--*/
{
   if (!strMetaRoot.IsEmpty())
   {
      int hd = strMetaRoot.find_first_not_of(SZ_MBN_ANYSEP_STR);
      int tl = strMetaRoot.find_last_not_of(SZ_MBN_ANYSEP_STR);
      if (hd == CString::npos && tl == CString::npos)
      {
         // path contains only separators
         strMetaRoot.erase();
         return strMetaRoot;
      }
      else if (hd != CString::npos)
      {
         if (tl != CString::npos)
            tl++;
         strMetaRoot = strMetaRoot.substr(hd, tl - hd);
      }
#if 0
        while (strMetaRoot.GetLength() > 0 
            && IsSeparator(strMetaRoot[strMetaRoot.GetLength() - 1]))
        {
            strMetaRoot.erase(strMetaRoot.GetLength() - 1);
        }

        while (strMetaRoot.GetLength() > 0 
           && IsSeparator(strMetaRoot[0]))
        {
            strMetaRoot = strMetaRoot.Right(strMetaRoot.GetLength() - 1);
        }
#endif
        // looks like IISAdmin works only with separators "/"
       for (int i = 0; i < strMetaRoot.GetLength(); i++)
       {
          if (IsSeparator(strMetaRoot[i]))
             strMetaRoot.SetAt(i, _chSep);
       }
   }
   return strMetaRoot;
}


/* static */
LPCTSTR
CMetabasePath::CleanMetaPath(
    IN OUT CMetabasePath & path
    )
{
   return CleanMetaPath(path.m_strMetaPath);
}

CMetabasePath::CMetabasePath(
    IN BOOL    fAddBasePath,
    IN LPCTSTR lpszMDPath,
    IN LPCTSTR lpszMDPath2  OPTIONAL,
    IN LPCTSTR lpszMDPath3  OPTIONAL,
    IN LPCTSTR lpszMDPath4  OPTIONAL
    )
/*++

Routine Description:

    Constructor.

Arguments:

    BOOL    fAddBasePath    : TRUE to prepend base path ("LM")
                              FALSE if the path is complete
    LPCTSTR lpszMDPath      : Metabase path
    LPCTSTR lpszMDPath2     : Optional child path
    LPCTSTR lpszMDPath3     : Optional child path
    LPCTSTR lpszMDPath4     : Optional child path

Return Value:

    N/A

--*/
    : m_strMetaPath()
{
    ASSERT_READ_PTR(lpszMDPath);

    if (fAddBasePath)
    {
        m_strMetaPath = _cszMachine;
        AppendPath(lpszMDPath);
    }
    else
    {
        m_strMetaPath = lpszMDPath;
    }

    //
    // Add optional path components
    //    
    AppendPath(lpszMDPath2);
    AppendPath(lpszMDPath3);
    AppendPath(lpszMDPath4);
}



CMetabasePath::CMetabasePath(
    IN  LPCTSTR lpszSvc,        OPTIONAL
    IN  DWORD   dwInstance,     OPTIONAL
    IN  LPCTSTR lpszParentPath, OPTIONAL
    IN  LPCTSTR lpszAlias       OPTIONAL
    )
/*++

Routine Description:

    Constructor.  Construct with path components.

Arguments:

    LPCTSTR lpszSvc         : Service (may be NULL or "")
    DWORD   dwInstance      : Instance number (may be 0 for master)
    LPCTSTR lpszParentPath  : Parent path (may be NULL or "")
    LPCTSTR lpszAlias       : Alias (may be NULL or "")

Return Value:

    N/A

--*/
    : m_strMetaPath()
{
    BuildMetaPath(lpszSvc, dwInstance, lpszParentPath, lpszAlias);
}



void 
CMetabasePath::AppendPath(
    IN LPCTSTR lpszPath
    )
/*++

Routine Description:

    Append path to current metabase path

Arguments:

    LPCTSTR lpszPath        : Metabase path

Return Value:

    None

--*/
{
    if (lpszPath && *lpszPath)
    {
        m_strMetaPath += _cszSep;
        m_strMetaPath += lpszPath;
    }
}



void 
CMetabasePath::AppendPath(
    IN DWORD dwInstance
    )
/*++

Routine Description:

    Append path to current metabase path

Arguments:

    DWORD dwInstance        : Instance path

Return Value:

    None

--*/
{
//    ASSERT(dwInstance >= 0);

    if (!IS_MASTER_INSTANCE(dwInstance))
    {
        TCHAR szInstance[] = _T("4000000000");
        _ltot(dwInstance, szInstance, 10);

        m_strMetaPath += _cszSep;
        m_strMetaPath += szInstance;
    }
}



void
CMetabasePath::BuildMetaPath(
    IN  LPCTSTR lpszSvc            OPTIONAL,
    IN  LPCTSTR lpszInstance       OPTIONAL,
    IN  LPCTSTR lpszParentPath     OPTIONAL,
    IN  LPCTSTR lpszAlias          OPTIONAL
    )
/*++

Routine Description:

    Build a complete metapath with the given service name, instance
    number and optional path components.

Arguments:

    LPCTSTR lpszSvc         : Service (may be NULL or "")
    LPCTSTR lpszInstance    : Instance (may be NULL or "")
    LPCTSTR lpszParentPath  : Parent path (may be NULL or "")
    LPCTSTR lpszAlias       : Alias (may be NULL or "")

Return Value:

    Pointer to internal buffer containing the path.

--*/
{
    m_strMetaPath = _cszMachine;

    AppendPath(lpszSvc);
    AppendPath(lpszInstance);
    AppendPath(lpszParentPath);

    if (lpszAlias && *lpszAlias)
    {
        //
        // Special case: If the alias is root, but we're
        // at the master instance, ignore this.
        //
        if (lpszInstance || ::lstrcmpi(_cszRoot, lpszAlias))
        {
            m_strMetaPath += _cszSep;
            m_strMetaPath += lpszAlias;
        }
    }

//    TRACE(_T("Generated metapath: %s\n"), m_strMetaPath );
}




void
CMetabasePath::BuildMetaPath(
    IN  LPCTSTR lpszSvc            OPTIONAL,
    IN  DWORD   dwInstance         OPTIONAL,
    IN  LPCTSTR lpszParentPath     OPTIONAL,
    IN  LPCTSTR lpszAlias          OPTIONAL
    )
/*++

Routine Description:

    Build a complete metapath with the given service name, instance
    number and optional path components.

Arguments:

    LPCTSTR lpszSvc         : Service (may be NULL or "")
    DWORD   dwInstance      : Instance number (may be 0 for master)
    LPCTSTR lpszParentPath  : Parent path (may be NULL or "")
    LPCTSTR lpszAlias       : Alias (may be NULL or "")

Return Value:

    Pointer to internal buffer containing the path.

--*/
{
    m_strMetaPath = _cszMachine;

    AppendPath(lpszSvc);
    AppendPath(dwInstance);
    AppendPath(lpszParentPath);

    if (lpszAlias && *lpszAlias)
    {
        //
        // Special case: If the alias is root, but we're
        // at the master instance, ignore this.
        //
        if (!IS_MASTER_INSTANCE(dwInstance) || ::lstrcmpi(_cszRoot, lpszAlias))
        {
            m_strMetaPath += _cszSep;
            m_strMetaPath += lpszAlias;
        }
    }

//    TRACE(_T("Generated metapath: %s\n"), m_strMetaPath);
}


//
// CIISInterface class
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



CIISInterface::CIISInterface(
    IN CComAuthInfo * pAuthInfo,    OPTIONAL
    IN HRESULT hrInterface          OPTIONAL
    )
/*++

Routine Description:

    Base class constructor.  

Arguments:

    CComAuthInfo * pAuthInfo : Auth info or NULL for local computer
    HRESULT hrInterface      : Initial error code. S_OK by default.

Return Value:

    N/A

--*/
    : m_auth(pAuthInfo),
      m_hrInterface(hrInterface)
{
}



HRESULT 
CIISInterface::Create(
    IN  int   cInterfaces,       
    IN  const IID rgIID[],      
    IN  const GUID rgCLSID[],    
    OUT int * pnInterface,          OPTIONAL
    OUT IUnknown ** ppInterface 
    )
/*++

Routine Description:

    Create interface.  This will try a range of interfaces in order of priority.

Arguments:

    int   cInterfaces       : Number of interfaces in array.
    const IID * rgIID       : Array if IIDs
    const GUID * rgCLSID    : Array of CLSIDs
    int * pnInterface       : Returns the interface index that was successful.
                              or NULL if not interested.
    IUnknown ** ppInterface : Returns pointer to the interface.

Return Value:

    HRESULT

Notes:

    This will attempt to create an interface, in order of declaration in 
    the IID and CLSIS arrays.  The first successful interface to be created
    will have its index returned in *pnInterfaces.

--*/
{
    ASSERT(cInterfaces > 0);
    ASSERT(rgIID && rgCLSID && ppInterface);
    
    COSERVERINFO * pcsiName = m_auth.CreateServerInfoStruct();

    MULTI_QI rgmqResults;
    
    CError err;
    int    nInterface;

    //
    // Try to create the interface in order
    //
    for (nInterface = 0; nInterface < cInterfaces; ++nInterface)
    {
        ZeroMemory(&rgmqResults, sizeof(rgmqResults));
        rgmqResults.pIID = &rgIID[nInterface];

//        TRACE("Attempting to create interface #%d\n", nInterface);
        err = ::CoCreateInstanceEx(
            rgCLSID[nInterface],
            NULL,
            CLSCTX_SERVER,
            pcsiName,
            1,
            &rgmqResults
            );

        if (err.Succeeded() || err.Win32Error() == ERROR_ACCESS_DENIED)
        {
            break;
        }
    }

    if(err.Succeeded())
    {
        //
        // Save the interface pointer
        //
        ASSERT_PTR(rgmqResults.pItf);
        *ppInterface = rgmqResults.pItf;

        if (pnInterface)
        {
            //
            // Store successful interface index
            //
            *pnInterface = nInterface;
        }

        //
        // Strangely enough, I now have still have to apply
        // the proxy blanket.  Apparently this is by design.
        //
        if (m_auth.UsesImpersonation())
        {
            ApplyProxyBlanket();
        }
    }

    //
    // Clean up
    //
    m_auth.FreeServerInfoStruct(pcsiName);

    return err;
}


//
// CMetaInterface class
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

CMetaInterface::CMetaInterface(
    IN CComAuthInfo * pAuthInfo        OPTIONAL
    )
/*++

Routine Description:

    Construct and initialize the interface

Arguments:

    CComAuthInfo * pAuthInfo    : Authentication info.  NULL indicates 
                                  the local computer.

Return Value:

    N/A

--*/
    : CIISInterface(pAuthInfo),
      m_pInterface(NULL),
      m_iTimeOutValue(MB_TIMEOUT)
{
    //
    // Initialize the interface
    //
    m_hrInterface = Create();
}



CMetaInterface::CMetaInterface(
    IN CMetaInterface * pInterface
    )
/*++

Routine Description:

    Construct from existing interface (Copy Constructor)

Arguments:

    CMetaInterface * pInterface : Existing interface

Return Value:

    N/A

Notes:
        
    Object will not take ownership of the interface,
    it will merely add to the reference count, and 
    release it upon destruction

BUGBUG:

    if pInterface is NULL, this will AV.

--*/
    : CIISInterface(&pInterface->m_auth, pInterface->m_hrInterface),
      m_pInterface(pInterface->m_pInterface),
      m_iTimeOutValue(pInterface->m_iTimeOutValue)
{
    ASSERT_READ_PTR(m_pInterface);
    m_pInterface->AddRef();
}



CMetaInterface::~CMetaInterface()
/*++

Routine Description:

    Destructor -- releases the interface

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    SAFE_RELEASE(m_pInterface);
}


HRESULT 
CMetaInterface::Create()
{
    return CIISInterface::Create(
        1,
        &IID_IMSAdminBase, 
        &CLSID_MSAdminBase, 
        NULL,
        (IUnknown **)&m_pInterface
        );
}

//
// CMetaKey class
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

//
// Helper macros
//
#define ASSURE_PROPER_INTERFACE()\
    if (!HasInterface()) { ASSERT_MSG("No interface"); return MD_ERROR_NOT_INITIALIZED; }

#define ASSURE_OPEN_KEY()\
    if (!m_hKey && !m_fAllowRootOperations) { ASSERT_MSG("No open key"); return HRESULT_FROM_WIN32(ERROR_INVALID_HANDLE); }

#define FETCH_PROPERTY_DATA_OR_FAIL(dwID, md)\
    ZeroMemory(&md, sizeof(md)); \
    if (!GetMDFieldDef(dwID, md.dwMDIdentifier, md.dwMDAttributes, md.dwMDUserType, md.dwMDDataType))\
    { ASSERT_MSG("Bad property ID"); return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER); }

//
// Static Initialization
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



#define MD_SERVER_PLATFORM              (IIS_MD_SERVER_BASE+100 )
#define MD_SERVER_VERSION_MAJOR         (IIS_MD_SERVER_BASE+101 )
#define MD_SERVER_VERSION_MINOR         (IIS_MD_SERVER_BASE+102 )
#define MD_SERVER_CAPABILITIES          (IIS_MD_SERVER_BASE+103 )

#ifndef MD_APP_PERIODIC_RESTART_TIME
#define MD_APP_PERIODIC_RESTART_TIME         2111
#endif
#ifndef MD_APP_PERIODIC_RESTART_REQUESTS
#define MD_APP_PERIODIC_RESTART_REQUESTS     2112
#endif
#ifndef MD_APP_PERIODIC_RESTART_SCHEDULE
#define MD_APP_PERIODIC_RESTART_SCHEDULE     2113
#endif
#ifndef MD_ASP_DISKTEMPLATECACHEDIRECTORY
#define MD_ASP_DISKTEMPLATECACHEDIRECTORY    7036
#endif
#ifndef MD_ASP_MAXDISKTEMPLATECACHEFILES
#define MD_ASP_MAXDISKTEMPLATECACHEFILES     7040
#endif
//
// Metabase table
//
const CMetaKey::MDFIELDDEF CMetaKey::s_rgMetaTable[] =
{
    ///////////////////////////////////////////////////////////////////////////
    //
    // !!!IMPORTANT!!! This table must be sorted on dwMDIdentifier.  (Will
    // ASSERT if not not sorted)
    //
    { MD_MAX_BANDWIDTH,                   METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_KEY_TYPE,                        METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_SERVER_COMMAND,                  METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_CONNECTION_TIMEOUT,              METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_CONNECTION_TIMEOUT          },
    { MD_MAX_CONNECTIONS,                 METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_MAX_CONNECTIONS             },
    { MD_SERVER_COMMENT,                  METADATA_INHERIT,                          IIS_MD_UT_SERVER, STRING_METADATA,  IDS_MD_SERVER_COMMENT              },
    { MD_SERVER_STATE,                    METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_SERVER_AUTOSTART,                METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_SERVER_SIZE,                     METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_SERVER_SIZE                 },
    { MD_SERVER_LISTEN_BACKLOG,           METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_SERVER_LISTEN_BACKLOG       },
    { MD_SERVER_LISTEN_TIMEOUT,           METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_SERVER_LISTEN_TIMEOUT       },
    { MD_SERVER_BINDINGS,                 METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, MULTISZ_METADATA, 0                                  },
    { MD_WIN32_ERROR,                     METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_FILE,   DWORD_METADATA,   0                                  },
    { MD_SERVER_PLATFORM,                 METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_SERVER_VERSION_MAJOR,            METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_SERVER_VERSION_MINOR,            METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_SERVER_CAPABILITIES,             METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_SECURE_BINDINGS,                 METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, MULTISZ_METADATA, 0                                  },
    { MD_FILTER_LOAD_ORDER,               METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_FILTER_IMAGE_PATH,               METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_FILTER_STATE,                    METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_FILTER_ENABLED,                  METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_FILTER_FLAGS,                    METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_AUTH_CHANGE_URL,                 METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_AUTH_EXPIRED_URL,                METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_AUTH_NOTIFY_PWD_EXP_URL,         METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_ADV_NOTIFY_PWD_EXP_IN_DAYS,      METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_ADV_CACHE_TTL,                   METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_NET_LOGON_WKS,                   METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_USE_HOST_NAME,                   METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_AUTH_EXPIRED_UNSECUREURL,        METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_AUTH_CHANGE_FLAGS,               METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_AUTH_NOTIFY_PWD_EXP_UNSECUREURL, METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_FRONTPAGE_WEB,                   METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_MAPCERT,                         METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_MAPNTACCT,                       METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_MAPNAME,                         METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_MAPENABLED,                      METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_MAPREALM,                        METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_MAPPWD,                          METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_ITACCT,                          METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_CPP_CERT11,                      METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, BINARY_METADATA,  0                                  },
    { MD_SERIAL_CERT11,                   METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, BINARY_METADATA,  0                                  },
    { MD_CPP_CERTW,                       METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, BINARY_METADATA,  0                                  },
    { MD_SERIAL_CERTW,                    METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, BINARY_METADATA,  0                                  },
    { MD_CPP_DIGEST,                      METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, BINARY_METADATA,  0                                  },
    { MD_SERIAL_DIGEST,                   METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, BINARY_METADATA,  0                                  },
    { MD_CPP_ITA,                         METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, BINARY_METADATA,  0                                  },
    { MD_SERIAL_ITA,                      METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, BINARY_METADATA,  0                                  },
    { MD_APP_FRIENDLY_NAME,               METADATA_INHERIT,                          IIS_MD_UT_WAM,    STRING_METADATA,  IDS_MD_APP_FRIENDLY_NAME           },
    { MD_APP_ROOT,                        METADATA_INHERIT,                          IIS_MD_UT_WAM,    STRING_METADATA,  IDS_MD_APP_ROOT                    },
    { MD_APP_ISOLATED,                    METADATA_INHERIT,                          IIS_MD_UT_WAM,    DWORD_METADATA,   IDS_MD_APP_ISOLATED                },
// new stuff
    { MD_APP_PERIODIC_RESTART_TIME,       METADATA_INHERIT,                          IIS_MD_UT_WAM,    DWORD_METADATA,   0                                  },
    { MD_APP_PERIODIC_RESTART_REQUESTS,   METADATA_INHERIT,                          IIS_MD_UT_WAM,    DWORD_METADATA,   0                                  },
    { MD_APP_PERIODIC_RESTART_SCHEDULE,   METADATA_INHERIT,                          IIS_MD_UT_WAM,    MULTISZ_METADATA, 0                                  },
// end new stuff
    { MD_CPU_LIMITS_ENABLED,              METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_CPU_LIMITS_ENABLED          },
    { MD_CPU_LIMIT_LOGEVENT,              METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_CPU_LIMIT_LOGEVENT          },
    { MD_CPU_LIMIT_PRIORITY,              METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_CPU_LIMIT_PRIORITY          },
    { MD_CPU_LIMIT_PROCSTOP,              METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_CPU_LIMIT_PROCSTOP          },
    { MD_CPU_LIMIT_PAUSE,                 METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_CPU_LIMIT_PAUSE             },
    { MD_HC_COMPRESSION_DIRECTORY,        METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_HC_DO_DYNAMIC_COMPRESSION,       METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_HC_DO_STATIC_COMPRESSION,        METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_HC_DO_DISK_SPACE_LIMITING,       METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_HC_MAX_DISK_SPACE_USAGE,         METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_VR_PATH,                         METADATA_INHERIT,                          IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_VR_PATH                     },
    { MD_VR_USERNAME,                     METADATA_INHERIT,                          IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_VR_USERNAME                 },
    { MD_VR_PASSWORD,                     METADATA_INHERIT | METADATA_SECURE,        IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_VR_PASSWORD                 },
    { MD_VR_ACL,                          METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_FILE,   BINARY_METADATA,  0                                  },
    { MD_VR_UPDATE,                       METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_FILE,   DWORD_METADATA,   0                                  },
    { MD_LOG_TYPE,                        METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_LOG_TYPE                    },
    { MD_LOGFILE_DIRECTORY,               METADATA_INHERIT,                          IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_LOGFILE_DIRECTORY           },
    { MD_LOGFILE_PERIOD,                  METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_LOGFILE_PERIOD              },
    { MD_LOGFILE_TRUNCATE_SIZE,           METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_LOGFILE_TRUNCATE_SIZE       },
    { MD_LOGSQL_DATA_SOURCES,             METADATA_INHERIT,                          IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_LOGSQL_DATA_SOURCES         },
    { MD_LOGSQL_TABLE_NAME,               METADATA_INHERIT,                          IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_LOGSQL_TABLE_NAME           },
    { MD_LOGSQL_USER_NAME,                METADATA_INHERIT,                          IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_LOGSQL_USER_NAME            },
    { MD_LOGSQL_PASSWORD,                 METADATA_INHERIT | METADATA_SECURE,        IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_LOGSQL_PASSWORD             },
    { MD_LOG_PLUGIN_ORDER,                METADATA_INHERIT,                          IIS_MD_UT_SERVER, STRING_METADATA,  IDS_MD_LOG_PLUGIN_ORDER            },
    { MD_LOGEXT_FIELD_MASK,               METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_LOGEXT_FIELD_MASK           },
    { MD_LOGFILE_LOCALTIME_ROLLOVER,      METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_LOGFILE_LOCALTIME_ROLLOVER  },
    { MD_CPU_LOGGING_MASK,                METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_CPU_LOGGING_MASK            },
    { MD_EXIT_MESSAGE,                    METADATA_INHERIT,                          IIS_MD_UT_SERVER, STRING_METADATA,  IDS_MD_EXIT_MESSAGE                },
    { MD_GREETING_MESSAGE,                METADATA_INHERIT,                          IIS_MD_UT_SERVER, MULTISZ_METADATA, IDS_MD_GREETING_MESSAGE            },
    { MD_MAX_CLIENTS_MESSAGE,             METADATA_INHERIT,                          IIS_MD_UT_SERVER, STRING_METADATA,  IDS_MD_MAX_CLIENTS_MESSAGE         },
    { MD_MSDOS_DIR_OUTPUT,                METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_MSDOS_DIR_OUTPUT            },
    { MD_ALLOW_ANONYMOUS,                 METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_ALLOW_ANONYMOUS             },
    { MD_ANONYMOUS_ONLY,                  METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_ANONYMOUS_ONLY              },
    { MD_LOG_ANONYMOUS,                   METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_LOG_ANONYMOUS               },
    { MD_LOG_NONANONYMOUS,                METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_LOG_NONANONYMOUS            },
    { MD_SSL_PUBLIC_KEY,                  METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, BINARY_METADATA,  0                                  },
    { MD_SSL_PRIVATE_KEY,                 METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, BINARY_METADATA,  0                                  },
    { MD_SSL_KEY_PASSWORD,                METADATA_SECURE,                           IIS_MD_UT_SERVER, BINARY_METADATA,  0                                  },
    { MD_SSL_CERT_HASH,                   METADATA_INHERIT,                          IIS_MD_UT_SERVER, BINARY_METADATA,  0                                  },
    { MD_SSL_CERT_STORE_NAME,             METADATA_INHERIT,                          IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_SSL_CTL_IDENTIFIER,              METADATA_INHERIT,                          IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_SSL_CTL_STORE_NAME,              METADATA_INHERIT,                          IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_SSL_USE_DS_MAPPER,               METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_AUTHORIZATION,                   METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_AUTHORIZATION               },
    { MD_REALM,                           METADATA_INHERIT,                          IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_REALM                       },
    { MD_HTTP_EXPIRES,                    METADATA_INHERIT,                          IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_HTTP_EXPIRES                },
    { MD_HTTP_PICS,                       METADATA_INHERIT,                          IIS_MD_UT_FILE,   MULTISZ_METADATA, IDS_MD_HTTP_PICS                   },
    { MD_HTTP_CUSTOM,                     METADATA_INHERIT,                          IIS_MD_UT_FILE,   MULTISZ_METADATA, IDS_MD_HTTP_CUSTOM                 },
    { MD_DIRECTORY_BROWSING,              METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_DIRECTORY_BROWSING          },
    { MD_DEFAULT_LOAD_FILE,               METADATA_INHERIT,                          IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_DEFAULT_LOAD_FILE           },
    { MD_CONTENT_NEGOTIATION,             METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_CONTENT_NEGOTIATION         },
    { MD_CUSTOM_ERROR,                    METADATA_INHERIT,                          IIS_MD_UT_FILE,   MULTISZ_METADATA, IDS_MD_CUSTOM_ERROR                },
    { MD_FOOTER_DOCUMENT,                 METADATA_INHERIT,                          IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_FOOTER_DOCUMENT             },
    { MD_FOOTER_ENABLED,                  METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_FOOTER_ENABLED              },
    { MD_HTTP_REDIRECT,                   METADATA_INHERIT,                          IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_HTTP_REDIRECT               },
    { MD_DEFAULT_LOGON_DOMAIN,            METADATA_INHERIT,                          IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_DEFAULT_LOGON_DOMAIN        },
    { MD_LOGON_METHOD,                    METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_LOGON_METHOD                },
    { MD_SCRIPT_MAPS,                     METADATA_INHERIT,                          IIS_MD_UT_FILE,   MULTISZ_METADATA, IDS_MD_SCRIPT_MAPS                 },
    { MD_MIME_MAP,                        METADATA_INHERIT,                          IIS_MD_UT_FILE,   MULTISZ_METADATA, IDS_MD_MIME_MAP                    },
    { MD_ACCESS_PERM,                     METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_ACCESS_PERM                 },
    { MD_IP_SEC,                          METADATA_INHERIT | METADATA_REFERENCE,     IIS_MD_UT_FILE,   BINARY_METADATA,  IDS_MD_IP_SEC                      },
    { MD_ANONYMOUS_USER_NAME,             METADATA_INHERIT,                          IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_ANONYMOUS_USER_NAME         },
    { MD_ANONYMOUS_PWD,                   METADATA_INHERIT | METADATA_SECURE,        IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_ANONYMOUS_PWD               },
    { MD_ANONYMOUS_USE_SUBAUTH,           METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_ANONYMOUS_USE_SUBAUTH       },
    { MD_DONT_LOG,                        METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_DONT_LOG                    },
    { MD_ADMIN_ACL,                       METADATA_INHERIT | METADATA_SECURE | METADATA_REFERENCE,IIS_MD_UT_SERVER, BINARY_METADATA,  IDS_MD_ADMIN_ACL      },
    { MD_SSI_EXEC_DISABLED,               METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_SSI_EXEC_DISABLED           },
    { MD_SSL_ACCESS_PERM,                 METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_SSL_ACCESS_PERM             },
    { MD_NTAUTHENTICATION_PROVIDERS,      METADATA_INHERIT,                          IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_NTAUTHENTICATION_PROVIDERS  },
    { MD_SCRIPT_TIMEOUT,                  METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_SCRIPT_TIMEOUT              },
    { MD_CACHE_EXTENSIONS,                METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_CACHE_EXTENSIONS            },
    { MD_CREATE_PROCESS_AS_USER,          METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_CREATE_PROCESS_AS_USER      },
    { MD_CREATE_PROC_NEW_CONSOLE,         METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_CREATE_PROC_NEW_CONSOLE     },
    { MD_POOL_IDC_TIMEOUT,                METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_POOL_IDC_TIMEOUT            },
    { MD_ALLOW_KEEPALIVES,                METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_ALLOW_KEEPALIVES            },
    { MD_IS_CONTENT_INDEXED,              METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_IS_CONTENT_INDEXED          },
    { MD_ISM_ACCESS_CHECK,                METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_FILE,   DWORD_METADATA,   0                                  },
    { MD_ASP_BUFFERINGON,                 METADATA_INHERIT,                          ASP_MD_UT_APP,    DWORD_METADATA,   IDS_ASP_BUFFERINGON                },
    { MD_ASP_LOGERRORREQUESTS,            METADATA_INHERIT,                          IIS_MD_UT_WAM,    DWORD_METADATA,   IDS_ASP_LOGERRORREQUESTS           },
    { MD_ASP_SCRIPTERRORSSENTTOBROWSER,   METADATA_INHERIT,                          ASP_MD_UT_APP,    DWORD_METADATA,   IDS_ASP_SCRIPTERRORSSENTTOBROWSER  },
    { MD_ASP_SCRIPTERRORMESSAGE,          METADATA_INHERIT,                          ASP_MD_UT_APP,    STRING_METADATA,  IDS_ASP_SCRIPTERRORMESSAGE         },
    { MD_ASP_SCRIPTFILECACHESIZE,         METADATA_INHERIT,                          IIS_MD_UT_WAM,    DWORD_METADATA,   IDS_ASP_SCRIPTFILECACHESIZE        },
    { MD_ASP_SCRIPTENGINECACHEMAX,        METADATA_INHERIT,                          IIS_MD_UT_WAM,    DWORD_METADATA,   IDS_ASP_SCRIPTENGINECACHEMAX       },
    { MD_ASP_SCRIPTTIMEOUT,               METADATA_INHERIT,                          ASP_MD_UT_APP,    DWORD_METADATA,   IDS_ASP_SCRIPTTIMEOUT              },
    { MD_ASP_SESSIONTIMEOUT,              METADATA_INHERIT,                          ASP_MD_UT_APP,    DWORD_METADATA,   IDS_ASP_SESSIONTIMEOUT             },
    { MD_ASP_ENABLEPARENTPATHS,           METADATA_INHERIT,                          ASP_MD_UT_APP,    DWORD_METADATA,   IDS_ASP_ENABLEPARENTPATHS          },
    { MD_ASP_ALLOWSESSIONSTATE,           METADATA_INHERIT,                          ASP_MD_UT_APP,    DWORD_METADATA,   IDS_ASP_ALLOWSESSIONSTATE          },
    { MD_ASP_SCRIPTLANGUAGE,              METADATA_INHERIT,                          ASP_MD_UT_APP,    STRING_METADATA,  IDS_ASP_SCRIPTLANGUAGE             },
    { MD_ASP_EXCEPTIONCATCHENABLE,        METADATA_INHERIT,                          IIS_MD_UT_WAM,    DWORD_METADATA,   IDS_ASP_EXCEPTIONCATCHENABLE       },
    { MD_ASP_ENABLESERVERDEBUG,           METADATA_INHERIT,                          ASP_MD_UT_APP,    DWORD_METADATA,   IDS_ASP_ENABLESERVERDEBUG          },
    { MD_ASP_ENABLECLIENTDEBUG,           METADATA_INHERIT,                          ASP_MD_UT_APP,    DWORD_METADATA,   IDS_ASP_ENABLECLIENTDEBUG          },
    { MD_ASP_DISKTEMPLATECACHEDIRECTORY,  METADATA_INHERIT,                          IIS_MD_UT_WAM,    STRING_METADATA,  0                                  },
    { MD_ASP_MAXDISKTEMPLATECACHEFILES,   METADATA_INHERIT,                          IIS_MD_UT_WAM,    DWORD_METADATA,  0                                   },
};



#define NUM_ENTRIES (sizeof(CMetaKey::s_rgMetaTable) / sizeof(CMetaKey::s_rgMetaTable[0]))



/* static */
int
CMetaKey::MapMDIDToTableIndex(
    IN DWORD dwID
    )
/*++

Routine Description:

    Map MD id value to table index.  Return -1 if not found

Arguments:

    DWORD dwID : MD id value

Return Value:

    Index into the table that coresponds to the MD id value

--*/
{
#ifdef _DEBUG

    {
        //
        // Do a quick verification that our metadata
        // table is sorted correctly.
        //
        static BOOL fTableChecked = FALSE;

        if (!fTableChecked)
        {
            for (int n = 1; n < NUM_ENTRIES; ++n)
            {
                if (s_rgMetaTable[n].dwMDIdentifier
                    <= s_rgMetaTable[n - 1].dwMDIdentifier)
                {
//                    TRACE("MD ID Table is out of order: Item is %d %s\n", n, s_rgMetaTable[n].dwMDIdentifier);
                    ASSERT_MSG("MD ID Table out of order");
                }
            }

            //
            // But only once.
            //
            ++fTableChecked;
        }
    }

#endif // _DEBUG

    //
    // Look up the ID in the table using a binary search
    //
    int nRange = NUM_ENTRIES;
    int nLow = 0;
    int nHigh = nRange - 1;
    int nMid;
    int nHalf;

    while (nLow <= nHigh)
    {
        if (nHalf = nRange / 2)
        {
            nMid  = nLow + (nRange & 1 ? nHalf : (nHalf - 1));

            if (s_rgMetaTable[nMid].dwMDIdentifier == dwID)
            {
                return nMid;
            }
            else if (s_rgMetaTable[nMid].dwMDIdentifier > dwID)
            {
                nHigh  = --nMid;
                nRange = nRange & 1 ? nHalf : nHalf - 1;
            }
            else
            {
                nLow   = ++nMid;
                nRange = nHalf;
            }
        }
        else if (nRange)
        {
            return s_rgMetaTable[nLow].dwMDIdentifier == dwID ? nLow : -1;
        }
        else
        {
            break;
        }
    }

    return -1;
}



/* static */
BOOL
CMetaKey::GetMDFieldDef(
    IN  DWORD dwID,
    OUT DWORD & dwMDIdentifier,
    OUT DWORD & dwMDAttributes,
    OUT DWORD & dwMDUserType,
    OUT DWORD & dwMDDataType
    )
/*++

Routine Description:

    Get information about metabase property

Arguments:

    DWORD dwID                  : Meta ID
    DWORD & dwMDIdentifier      : Meta parms
    DWORD & dwMDAttributes      : Meta parms
    DWORD & dwMDUserType        : Meta parms
    DWORD & dwMDDataType        : Meta parms

Return Value:

    TRUE for success, FALSE for failure.

--*/
{
    int nID = MapMDIDToTableIndex(dwID);

    if (nID == -1)
    {
        //
        // Unrecognized meta data ID
        //
        ASSERT_MSG("Unrecognized meta data id");
        return FALSE;
    }

    dwMDIdentifier = s_rgMetaTable[nID].dwMDIdentifier;
    dwMDAttributes = s_rgMetaTable[nID].dwMDAttributes;
    dwMDUserType   = s_rgMetaTable[nID].dwMDUserType;
    dwMDDataType   = s_rgMetaTable[nID].dwMDDataType;

    return TRUE;
}



/* static */
BOOL
CMetaKey::IsPropertyInheritable(
    IN DWORD dwID
    )
/*++

Routine Description:

    Check to see if the given property is inheritable

Arguments:

    DWORD dwID      : Metabase ID

Return Value:

    TRUE if the metabase ID is inheritable, FALSE otherwise.

--*/
{
    int nID = MapMDIDToTableIndex(dwID);

    if (nID == -1)
    {
        //
        // Unrecognized meta data ID
        //
        ASSERT_MSG("Unrecognized meta data ID");
        return FALSE;
    }

    return (s_rgMetaTable[nID].dwMDAttributes & METADATA_INHERIT) != 0;
}



/* static */
BOOL
CMetaKey::GetPropertyDescription(
    IN  DWORD dwID,
    OUT CString & strName
    )
/*++

Routine Description:

    Get a description for the given property

Arguments:

    DWORD dwID            : Property ID
    CString & strName     : Returns friendly property name

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    int nID = MapMDIDToTableIndex(dwID);

    if (nID == -1)
    {
        //
        // Unrecognized meta data ID
        //
        ASSERT_MSG("Unrecognized meta data ID");
        return FALSE;
    }

    UINT uID = s_rgMetaTable[nID].uStringID;

    BOOL fResult = TRUE;

    if (uID > 0)
    {
        fResult = (strName.LoadString(_Module.GetResourceInstance(), uID) != 0);
    }
    else
    {
        //
        // Don't have a friendly name -- fake it
        //
        CComBSTR bstrFmt;
        VERIFY(bstrFmt.LoadString(_Module.GetResourceInstance(), IDS_INHERITANCE_NO_NAME));

        strName.Format(bstrFmt, dwID);
    }

    return fResult;
}



CMetaKey::CMetaKey(
    IN CComAuthInfo * pAuthInfo     OPTIONAL
    )
/*++

Routine Description:

    Constructor that creates the interface, but does not open the key.
    This is the ONLY constructor that allows operations from
    METDATA_MASTER_ROOT_HANDLE (read operations obviously)

Arguments:

    CComAuthInfo * pAuthInfo  : If NULL, opens interface on local machine

Return Value:

    N/A

--*/
    : CMetaInterface(pAuthInfo),
      m_hKey(METADATA_MASTER_ROOT_HANDLE),
      m_hBase(NULL),
      m_hrKey(S_OK),
      m_dwFlags(0L),
      m_cbInitialBufferSize(MB_INIT_BUFF_SIZE),
      m_strMetaPath(),
      m_fAllowRootOperations(TRUE),
      m_fOwnKey(TRUE)
{
    m_hrKey = CMetaInterface::QueryResult(); 

    //
    // Do not open key
    //
}



CMetaKey::CMetaKey(
    IN CMetaInterface * pInterface
    )
/*++

Routine Description:

    Construct with pre-existing interface.  Does not
    open any keys

Arguments:

    CMetaInterface * pInterface       : Preexisting interface

Return Value:

    N/A

--*/
    : CMetaInterface(pInterface),
      m_hKey(NULL),
      m_hBase(NULL),
      m_strMetaPath(),
      m_dwFlags(0L),
      m_cbInitialBufferSize(MB_INIT_BUFF_SIZE),
      m_fAllowRootOperations(TRUE),
      m_fOwnKey(TRUE)
{
    m_hrKey = CMetaInterface::QueryResult(); 
}        



CMetaKey::CMetaKey(
    IN CComAuthInfo * pAuthInfo,    OPTIONAL
    IN LPCTSTR lpszMDPath,          OPTIONAL
    IN DWORD   dwFlags,               
    IN METADATA_HANDLE hkBase
    )
/*++

Routine Description:

    Fully defined constructor that opens a key

Arguments:

    CComAuthInfo * pAuthInfo : Auth info or NULL
    LPCTSTR lpszMDPath       : Path or NULL
    DWORD   dwFlags          : Open permissions
    METADATA_HANDLE hkBase   : Base key

Return Value:

    N/A

--*/
    : CMetaInterface(pAuthInfo),
//    : CMetaInterface((CComAuthInfo *)NULL),
      m_hKey(NULL),
      m_hBase(NULL),
      m_dwFlags(0L),
      m_cbInitialBufferSize(MB_INIT_BUFF_SIZE),
      m_fAllowRootOperations(FALSE),
      m_strMetaPath(),
      m_fOwnKey(TRUE)
{
    m_hrKey = CMetaInterface::QueryResult(); 

    if (SUCCEEDED(m_hrKey))
    {
        m_hrKey = Open(dwFlags, lpszMDPath, hkBase);
    }
}



CMetaKey::CMetaKey(
    IN CMetaInterface * pInterface,
    IN LPCTSTR lpszMDPath,              OPTIONAL
    IN DWORD   dwFlags,               
    IN METADATA_HANDLE hkBase
    )
/*++

Routine Description:

    Fully defined constructor that opens a key

Arguments:

    CMetaInterface * pInterface : Existing interface
    DWORD   dwFlags             : Open permissions
    METADATA_HANDLE hkBase      : Base key
    LPCTSTR lpszMDPath          : Path or NULL

Return Value:

    N/A

--*/
    : CMetaInterface(pInterface),
      m_hKey(NULL),
      m_hBase(NULL),
      m_strMetaPath(),
      m_dwFlags(0L),
      m_cbInitialBufferSize(MB_INIT_BUFF_SIZE),
      m_fAllowRootOperations(FALSE),
      m_fOwnKey(TRUE)
{
    m_hrKey = CMetaInterface::QueryResult(); 

    if (SUCCEEDED(m_hrKey))
    {
        m_hrKey = Open(dwFlags, lpszMDPath, hkBase);
    }
}



CMetaKey::CMetaKey(
    IN BOOL  fOwnKey,
    IN CMetaKey * pKey
    )
/*++

Routine Description:

    Copy constructor. 

Arguments:

    BOOL  fOwnKey               : TRUE to take ownership of the key
    const CMetaKey * pKey       : Existing key

Return Value:

    N/A

--*/
    : CMetaInterface(pKey),
      m_hKey(pKey->m_hKey),
      m_hBase(pKey->m_hBase),
      m_dwFlags(pKey->m_dwFlags),
      m_cbInitialBufferSize(pKey->m_cbInitialBufferSize),
      m_fAllowRootOperations(pKey->m_fAllowRootOperations),
      m_hrKey(pKey->m_hrKey),
      m_strMetaPath(pKey->m_strMetaPath),
      m_fOwnKey(fOwnKey)
{
    //
    // No provisions for anything else at the moment
    //
    ASSERT(!m_fOwnKey);
}



CMetaKey::~CMetaKey()
/*++

Routine Description:

    Destructor -- Close the key.

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    if (IsOpen() && m_fOwnKey)
    {
        Close();
    }
}



/* virtual */
BOOL 
CMetaKey::Succeeded() const
/*++

Routine Description:

    Determine if object was constructed successfully

Arguments:

    None

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    return SUCCEEDED(m_hrKey);
}



/* virtual */
HRESULT 
CMetaKey::QueryResult() const
/*++

Routine Description:

    Return the construction error for this object

Arguments:

    None

Return Value:

    HRESULT from construction errors

--*/
{
    return m_hrKey;
}



HRESULT 
CMetaKey::Open(
    IN DWORD dwFlags,                
    IN LPCTSTR lpszMDPath,          OPTIONAL
    IN METADATA_HANDLE hkBase
    )
/*++

Routine Description:

    Attempt to open a metabase key

Arguments:

    DWORD dwFlags           : Permission flags
    LPCTSTR lpszMDPath      : Optional path
    METADATA_HANDLE hkBase  : Base metabase key

Return Value:

    HRESULT

--*/
{
    ASSURE_PROPER_INTERFACE();

    if (m_hKey != NULL)
    {
        ASSERT_MSG("Attempting to open key that already has an open handle");

//        TRACEEOLID("Closing that key");
        Close();
    }

    //
    // Base key is stored for reopen purposes only
    //
    m_hBase = hkBase;
    m_strMetaPath = lpszMDPath;
    m_dwFlags = dwFlags;

    return OpenKey(m_hBase, m_strMetaPath, m_dwFlags, &m_hKey);
}



HRESULT 
CMetaKey::CreatePathFromFailedOpen()
/*++

Routine Description:

    If the path doesn't exist, create it.  This method should be
    called after an Open call failed (because it will have initialized
    m_strMetaPath.

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CString strParentPath;
    CString strObjectName;
    CString strSavePath(m_strMetaPath);

    CMetabasePath::SplitMetaPathAtInstance(
        m_strMetaPath, 
        strParentPath, 
        strObjectName
        );

    CError err(Open(
        METADATA_PERMISSION_WRITE,
        strParentPath
        ));

    if (err.Succeeded())
    {
        //
        // This really should never fail, because we're opening
        // the path at the instance.
        //
        err = AddKey(strObjectName);
    }

    if (IsOpen())
    {
        Close();
    }

    //
    // The previous open wiped out the path...
    //
    m_strMetaPath = strSavePath;

    return err;
}



HRESULT
CMetaKey::Close()
/*++

Routine Description:

    Close the currently open key.

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    ASSURE_PROPER_INTERFACE();

    HRESULT hr = S_OK;

    ASSERT(m_hKey != NULL);
    ASSERT(m_fOwnKey);

    if (m_hKey)
    {
        hr = CloseKey(m_hKey);

        if (SUCCEEDED(hr))
        {
            m_hKey = NULL;
        }
    }

    return hr;
}



HRESULT
CMetaKey::ConvertToParentPath(
    IN  BOOL fImmediate
    )
/*++

Routine Description:

    Change the path to the parent path.

Arguments:

    BOOL fImmediate     : If TRUE, the immediate parent's path will be used
                          if FALSE, the first parent that really exists

Return Value:

    HRESULT

        ERROR_INVALID_PARAMETER if there is no valid path

--*/
{
    BOOL fIsOpen = IsOpen();

    if (fIsOpen)
    {
        Close();
    }

    CError err;

    FOREVER
    {
        if (!CMetabasePath::ConvertToParentPath(m_strMetaPath))
        {
            //
            // There is no parent path
            //
            err = ERROR_INVALID_PARAMETER;
            break;
        }

        err = ReOpen();

        //
        // Path not found is the only valid error
        // other than success.
        //
        if (fImmediate 
            || err.Succeeded() 
            || err.Win32Error() != ERROR_PATH_NOT_FOUND)
        {
            break;
        }
    }

    //
    // Remember to reset the construction error
    // which referred to the parent path.
    //
    m_hrKey = err;

    return err;
}




/* protected */
HRESULT
CMetaKey::GetPropertyValue(
    IN  DWORD dwID,
    OUT IN DWORD & dwSize,               OPTIONAL
    OUT IN void *& pvData,               OPTIONAL
    OUT IN DWORD * pdwDataType,          OPTIONAL
    IN  BOOL * pfInheritanceOverride,    OPTIONAL
    IN  LPCTSTR lpszMDPath,              OPTIONAL
    OUT DWORD * pdwAttributes            OPTIONAL
    )
/*++

Routine Description:

    Get metadata on the currently open key.

Arguments:

    DWORD dwID                      : Property ID number
    DWORD & dwSize                  : Buffer size (could be 0)
    void *& pvData                  : Buffer -- will allocate if NULL
    DWORD * pdwDataType             : NULL or on in  contains valid data types,
                                    :         on out contains actual data type
    BOOL * pfInheritanceOverride    : NULL or on forces inheritance on/off
    LPCTSTR lpszMDPath              : Optional path off the open key
    DWORD * pdwAttributes           : Optionally returns attributes    

Return Value:

    HRESULT 

    ERROR_INVALID_HANDLE        : If the handle is not open
    ERROR_INVALID_PARAMETER     : If the property id is not found,
                                  or the data type doesn't match requested type
    ERROR_OUTOFMEMORY           : Out of memory

--*/
{
    ASSURE_PROPER_INTERFACE();
    ASSURE_OPEN_KEY();

    METADATA_RECORD mdRecord;
    FETCH_PROPERTY_DATA_OR_FAIL(dwID, mdRecord);

    //
    // If unable to find this property ID in our table, or
    // if we specified a desired type, and this type doesn't 
    // match it, give up.
    //
    if (pdwDataType && *pdwDataType != ALL_METADATA 
        && *pdwDataType != mdRecord.dwMDDataType)
    {
        ASSERT_MSG("Invalid parameter");
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    //
    // Check to see if inheritance behaviour is overridden
    //
    if (pfInheritanceOverride)
    {
        if (*pfInheritanceOverride)
        {
            mdRecord.dwMDAttributes |= METADATA_INHERIT;
        }
        else
        {
            mdRecord.dwMDAttributes &= ~METADATA_INHERIT;
        }
    }

    //
    // This causes a bad parameter error on input otherwise
    //
    mdRecord.dwMDAttributes &= ~METADATA_REFERENCE;

    //
    // If we're looking for inheritable properties, the path
    // doesn't have to be completely specified.
    //
    if (mdRecord.dwMDAttributes & METADATA_INHERIT)
    {
        mdRecord.dwMDAttributes |= (METADATA_PARTIAL_PATH | METADATA_ISINHERITED);
    }

    ASSERT(dwSize > 0 || pvData == NULL);
    
    mdRecord.dwMDDataLen = dwSize;
    mdRecord.pbMDData = (LPBYTE)pvData;

    //
    // If no buffer provided, allocate one.
    //
    HRESULT hr = S_OK;
    BOOL fBufferTooSmall = FALSE;
    BOOL fAllocatedMemory = FALSE;
    DWORD dwInitSize = m_cbInitialBufferSize;

    do
    {
        if(mdRecord.pbMDData == NULL)
        {
            mdRecord.dwMDDataLen = dwInitSize;
            mdRecord.pbMDData = new BYTE[dwInitSize];

            if(mdRecord.pbMDData == NULL && dwInitSize > 0)
            {
                hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
                break;
            }

            ++fAllocatedMemory;
        }

        //
        // Get the data
        //
        DWORD dwRequiredDataLen = 0;
        hr = GetData(m_hKey, lpszMDPath, &mdRecord, &dwRequiredDataLen);

        //
        // Re-fetch the buffer if it's too small.
        //
        fBufferTooSmall = 
            (HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER) && fAllocatedMemory;

        if(fBufferTooSmall)
        {
            //
            // Delete the old buffer, and set up for a re-fetch.
            //
            delete [] mdRecord.pbMDData;
            mdRecord.pbMDData = NULL;
            dwInitSize = dwRequiredDataLen;
        }
    }
    while(fBufferTooSmall);

    //
    // Failed
    //
   if (FAILED(hr) && fAllocatedMemory)
   {
       delete [] mdRecord.pbMDData;
       mdRecord.pbMDData = NULL;
   }

   dwSize = mdRecord.dwMDDataLen;
   pvData = mdRecord.pbMDData;

   if (pdwDataType != NULL)
   {
      //
      // Return actual data type
      //
      *pdwDataType = mdRecord.dwMDDataType;
   }

   if (pdwAttributes != NULL)
   {
      //
      // Return data attributes
      //
      *pdwAttributes =  mdRecord.dwMDAttributes;
   }

   return hr;
}



/* protected */
HRESULT 
CMetaKey::GetDataPaths( 
    OUT CStringListEx & strlDataPaths,
    IN  DWORD   dwMDIdentifier,
    IN  DWORD   dwMDDataType,
    IN  LPCTSTR lpszMDPath              OPTIONAL
    )
/*++

Routine Description:

    Get data paths

Arguments:


Return Value:

    HRESULT

--*/
{
    ASSURE_PROPER_INTERFACE();
    ASSURE_OPEN_KEY();

    //
    // Start with a small buffer
    //
    DWORD  dwMDBufferSize = 1024;
    LPTSTR lpszBuffer = NULL;
    CError err;

    do
    {
        delete [] lpszBuffer;
        lpszBuffer = new TCHAR[dwMDBufferSize];

        if (lpszBuffer == NULL)
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        err = CMetaInterface::GetDataPaths(
            m_hKey,
            lpszMDPath,
            dwMDIdentifier,
            dwMDDataType,
            dwMDBufferSize,
            lpszBuffer,
            &dwMDBufferSize
            );
    }
    while(err.Win32Error() == ERROR_INSUFFICIENT_BUFFER);

    if (err.Win32Error() == ERROR_PATH_NOT_FOUND)
    {
        //
        // That's ok... this is some sort of physical directory
        // that doesn't currently exist in the metabase, and
        // which therefore doesn't have any descendants anyway.
        //
        ZeroMemory(lpszBuffer, dwMDBufferSize);
        err.Reset();
    }

    if (err.Succeeded())
    {
        strlDataPaths.ConvertFromDoubleNullList(lpszBuffer);
        delete [] lpszBuffer;
    }

    return err;
}



HRESULT
CMetaKey::CheckDescendants(
    IN DWORD   dwID,
    IN CComAuthInfo * pAuthInfo, OPTIONAL
    IN LPCTSTR lpszMDPath         OPTIONAL
    )
/*++

Routine Description:

    Check for descendant overrides;  If there are any, bring up a dialog
    that displays them, and give the user the opportunity the remove
    the overrides.

Arguments:

    DWORD dwID               : Property ID
    CComAuthInfo * pAuthInfo : Server or NULL
    LPCTSTR lpszMDPath       : Metabase path or NULL

Return Value:

    HRESULT

--*/
{
    ASSURE_PROPER_INTERFACE();

    HRESULT hr = S_OK;

    METADATA_RECORD mdRecord;
    FETCH_PROPERTY_DATA_OR_FAIL(dwID, mdRecord);

    if (mdRecord.dwMDAttributes & METADATA_INHERIT)
    {
        CStringListEx strlDataPaths;

        hr = GetDataPaths( 
            strlDataPaths,
            mdRecord.dwMDIdentifier,
            mdRecord.dwMDDataType,
            lpszMDPath
            );

        if (SUCCEEDED(hr) && !strlDataPaths.empty())
        {
            //
            // Bring up the inheritance override dialog
            //
            CInheritanceDlg dlg(
                dwID,
                FROM_WRITE_PROPERTY,
                pAuthInfo,
                lpszMDPath,
                strlDataPaths
                );

            if (!dlg.IsEmpty())
            {
                dlg.DoModal();
            }
        }
    }

    return hr;
}



/* protected */
HRESULT
CMetaKey::SetPropertyValue(
    IN DWORD dwID,
    IN DWORD dwSize,
    IN void * pvData,
    IN BOOL * pfInheritanceOverride,    OPTIONAL
    IN LPCTSTR lpszMDPath               OPTIONAL
    )
/*++

Routine Description:

    Set metadata on the open key.  The key must have been opened with
    write permission.

Arguments:

    DWORD dwID                      : Property ID
    DWORD dwSize                    : Size of data
    void * pvData                   : Data buffer
    BOOL * pfInheritanceOverride    : NULL or forces inheritance on/off
    LPCTSTR lpszMDPath              : Optional path off the open key

Return Value:

    HRESULT 

    ERROR_INVALID_HANDLE            : If the handle is not open
    ERROR_INVALID_PARAMETER         : If the property id is not found,
                                      or the buffer is NULL or of size 0

--*/
{
    ASSURE_PROPER_INTERFACE();
    ASSURE_OPEN_KEY();

    if (pvData == NULL && dwSize != 0)
    {
        ASSERT_MSG("No Data");
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    METADATA_RECORD mdRecord;
    FETCH_PROPERTY_DATA_OR_FAIL(dwID, mdRecord);

    if (pfInheritanceOverride)
    {
        if (*pfInheritanceOverride)
        {
            mdRecord.dwMDAttributes |= METADATA_INHERIT;
        }
        else
        {
            mdRecord.dwMDAttributes &= ~METADATA_INHERIT;
        }
    }

    mdRecord.dwMDDataLen = dwSize;
    mdRecord.pbMDData = (LPBYTE)pvData;

    return SetData(m_hKey, lpszMDPath, &mdRecord);
}



/* protected */
HRESULT 
CMetaKey::GetAllData(
    IN  DWORD dwMDAttributes,
    IN  DWORD dwMDUserType,
    IN  DWORD dwMDDataType,
    OUT DWORD * pdwMDNumEntries,
    OUT DWORD * pdwMDDataLen,
    OUT PBYTE * ppbMDData,
    IN  LPCTSTR lpszMDPath              OPTIONAL
    )
/*++

Routine Description:

    Get all data off the open key.  Buffer is created automatically.

Arguments:

    DWORD dwMDAttributes            : Attributes
    DWORD dwMDUserType              : User type to fetch
    DWORD dwMDDataType              : Data type to fetch
    DWORD * pdwMDNumEntries         : Returns number of entries read
    DWORD * pdwMDDataLen            : Returns size of data buffer
    PBYTE * ppbMDData               : Returns data buffer
    LPCTSTR lpszMDPath              : Optional data path        

Return Value:

    HRESULT

--*/
{
    ASSURE_PROPER_INTERFACE();
    ASSURE_OPEN_KEY();

    //
    // Check for valid parameters
    //
    if(!pdwMDDataLen || !ppbMDData || !pdwMDNumEntries)
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    HRESULT hr = S_OK;
    BOOL fBufferTooSmall = FALSE;
    DWORD dwMDDataSetNumber;
    DWORD dwRequiredBufferSize;
    DWORD dwInitSize = m_cbInitialBufferSize;
    *ppbMDData = NULL;

    do
    {
        *pdwMDDataLen = dwInitSize;
        *ppbMDData = new BYTE[dwInitSize];

        if (ppbMDData == NULL && dwInitSize > 0)
        {
            hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
            break;
        }

        hr = CMetaInterface::GetAllData(
            m_hKey,
            lpszMDPath,
            dwMDAttributes,
            dwMDUserType,
            dwMDDataType,
            pdwMDNumEntries,
            &dwMDDataSetNumber,
            *pdwMDDataLen,
            *ppbMDData,
            &dwRequiredBufferSize
            );

        //
        // Re-fetch the buffer if it's too small.
        //
        fBufferTooSmall = (HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER);

        if(fBufferTooSmall)
        {
            //
            // Delete the old buffer, and set up for a re-fetch.
            //
            delete [] *ppbMDData;
            dwInitSize = dwRequiredBufferSize;
        }
    }
    while (fBufferTooSmall);

    if (FAILED(hr))
    {
        //
        // No good, be sure we don't leak anything
        //
        delete [] *ppbMDData;
        dwInitSize = 0L;
    }

    return hr;
}



HRESULT
CMetaKey::QueryValue(
    IN  DWORD dwID,
    IN  OUT DWORD & dwValue,
    IN  BOOL * pfInheritanceOverride, OPTIONAL
    IN  LPCTSTR lpszMDPath,           OPTIONAL
    OUT DWORD * pdwAttributes         OPTIONAL
    )
/*++

Routine Description:

    Fetch data as a DWORD

Arguments:

    DWORD dwID                      : Property ID
    DWORD & dwValue                 : Returns the value read in
    BOOL * pfInheritanceOverride    : NULL or forces inheritance on/off
    LPCTSTR lpszMDPath              : Optional path off the open key
    DWORD * pdwAttributes           : Optionally returns attributes    

Return Value:

    HRESULT

--*/
{
    DWORD dwSize = sizeof(dwValue);
    DWORD dwDataType = DWORD_METADATA;
    void * pvData = &dwValue;

    return GetPropertyValue(
        dwID, 
        dwSize, 
        pvData, 
        &dwDataType, 
        pfInheritanceOverride,
        lpszMDPath,
        pdwAttributes
        );
}



HRESULT
CMetaKey::QueryValue(
    IN  DWORD dwID,
    IN  OUT CString & strValue,
    IN  BOOL * pfInheritanceOverride, OPTIONAL
    IN  LPCTSTR lpszMDPath,           OPTIONAL
    OUT DWORD * pdwAttributes         OPTIONAL
    )
/*++

Routine Description:

    Fetch data as a string

Arguments:

    DWORD dwID                      : Property ID
    DWORD & strValue                : Returns the value read in
    BOOL * pfInheritanceOverride    : NULL or forces inheritance on/off
    LPCTSTR lpszMDPath              : Optional path off the open key
    DWORD * pdwAttributes           : Optionally returns attributes    

Return Value:

    HRESULT

--*/
{
   //
   // Get GetData allocate the buffer for us
   //
   DWORD dwSize = 0;
   DWORD dwDataType = ALL_METADATA;
   LPTSTR lpData = NULL;

   HRESULT hr = GetPropertyValue(
        dwID, 
        dwSize, 
        (void *&)lpData, 
        &dwDataType,
        pfInheritanceOverride,
        lpszMDPath,
        pdwAttributes
        );

   if (SUCCEEDED(hr))
   {
      //
      // Notes: consider optional auto-expansion on EXPANDSZ_METADATA
      // (see registry functions), and data type conversions for DWORD
      // or MULTISZ_METADATA or BINARY_METADATA
      //
      if (dwDataType == EXPANDSZ_METADATA || dwDataType == STRING_METADATA)
      {
         try
         {
            strValue = lpData;
         }
         catch(std::bad_alloc)
         {
            hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
         }
      }
      else
      {
         hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
      }
   }

   if (lpData)
   {
      delete [] lpData;
   }
   return hr;
}



HRESULT
CMetaKey::QueryValue(
    IN  DWORD dwID,
    IN  OUT CComBSTR & strValue,
    IN  BOOL * pfInheritanceOverride, OPTIONAL
    IN  LPCTSTR lpszMDPath,           OPTIONAL
    OUT DWORD * pdwAttributes         OPTIONAL
    )
/*++

Routine Description:

    Fetch data as a string

Arguments:

    DWORD dwID                      : Property ID
    DWORD & CComBSTR                : Returns the value read in
    BOOL * pfInheritanceOverride    : NULL or forces inheritance on/off
    LPCTSTR lpszMDPath              : Optional path off the open key
    DWORD * pdwAttributes           : Optionally returns attributes    

Return Value:

    HRESULT

--*/
{
    //
    // Get GetData allocate the buffer for us
    //
    DWORD dwSize = 0;
    DWORD dwDataType = ALL_METADATA;
    LPTSTR lpData = NULL;

    HRESULT hr = GetPropertyValue(
        dwID, 
        dwSize, 
        (void *&)lpData, 
        &dwDataType,
        pfInheritanceOverride,
        lpszMDPath,
        pdwAttributes
        );

    if (SUCCEEDED(hr))
    {
        //
        // Notes: consider optional auto-expansion on EXPANDSZ_METADATA
        // (see registry functions), and data type conversions for DWORD
        // or MULTISZ_METADATA or BINARY_METADATA
        //
        if (dwDataType == EXPANDSZ_METADATA || dwDataType == STRING_METADATA)
        {
            strValue = lpData;
        }
        else
        {
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        }
    }

    if (lpData)
    {
        delete [] lpData;
    }

    return hr;
}




HRESULT
CMetaKey::QueryValue(
    IN  DWORD dwID,
    IN  OUT CStringListEx & strlValue,
    IN  BOOL * pfInheritanceOverride, OPTIONAL
    IN  LPCTSTR lpszMDPath,           OPTIONAL
    OUT DWORD * pdwAttributes         OPTIONAL
    )
/*++

Routine Description:

    Fetch data as a stringlist

Arguments:

    DWORD dwID                      : Property ID
    DWORD & strlValue               : Returns the value read in
    BOOL * pfInheritanceOverride    : NULL or forces inheritance on/off
    LPCTSTR lpszMDPath              : Optional path off the open key
    DWORD * pdwAttributes           : Optionally returns attributes    

Return Value:

    HRESULT

--*/
{
    //
    // Get GetData allocate the buffer for us
    //
    DWORD dwSize = 0;
    DWORD dwDataType = MULTISZ_METADATA;
    LPTSTR lpData = NULL;

    HRESULT hr = GetPropertyValue(
        dwID, 
        dwSize, 
        (void *&)lpData, 
        &dwDataType,
        pfInheritanceOverride,
        lpszMDPath,
        pdwAttributes
        );

    if (SUCCEEDED(hr))
    {
        //
        // Notes: Consider accepting a single STRING
        //
        ASSERT(dwDataType == MULTISZ_METADATA);

        DWORD err = strlValue.ConvertFromDoubleNullList(lpData, dwSize / sizeof(TCHAR));
        hr = HRESULT_FROM_WIN32(err);
    }

    if (lpData)
    {
        delete [] lpData;
    }

    return hr;
}



HRESULT
CMetaKey::QueryValue(
    IN  DWORD dwID,
    IN  OUT CBlob & blValue,
    IN  BOOL * pfInheritanceOverride, OPTIONAL
    IN  LPCTSTR lpszMDPath,           OPTIONAL
    OUT DWORD * pdwAttributes         OPTIONAL
    )
/*++

Routine Description:

    Fetch data as a binary blob

Arguments:

    DWORD dwID                      : Property ID
    DWORD CBlob & blValue           : Returns the binary blob
    BOOL * pfInheritanceOverride    : NULL or forces inheritance on/off
    LPCTSTR lpszMDPath              : Optional path off the open key
    DWORD * pdwAttributes           : Optionally returns attributes    

Return Value:

    HRESULT

--*/
{
    //
    // Get GetData allocate the buffer for us
    //
    DWORD dwSize = 0;
    DWORD dwDataType = BINARY_METADATA;
    LPBYTE pbData = NULL;

    HRESULT hr = GetPropertyValue(
        dwID, 
        dwSize, 
        (void *&)pbData, 
        &dwDataType,
        pfInheritanceOverride,
        lpszMDPath,
        pdwAttributes
        );

    if (SUCCEEDED(hr))
    {
        //
        // Blob takes ownership of the data, so don't free it...
        //
        ASSERT_READ_PTR2(pbData, dwSize);
        blValue.SetValue(dwSize, pbData, FALSE);
    }

    return hr;
}



HRESULT 
CMetaKey::SetValue(
    IN DWORD dwID,
    IN CStringListEx & strlValue,
    IN BOOL * pfInheritanceOverride,        OPTIONAL
    IN LPCTSTR lpszMDPath                   OPTIONAL
    )
/*++

Routine Description:

    Store data as string

Arguments:

    DWORD dwID                   : Property ID
    CStringListEx & strlValue    : Value to be written
    BOOL * pfInheritanceOverride : NULL or forces inheritance on/off
    LPCTSTR lpszMDPath           : Optional path (or NULL or "")

Return Value:

    HRESULT

--*/
{
    DWORD cCharacters;
    LPTSTR lpstr = NULL;

    //
    // Flatten value
    //
    strlValue.ConvertToDoubleNullList(cCharacters, lpstr);

    HRESULT hr = SetPropertyValue(
        dwID,
        cCharacters * sizeof(TCHAR),
        (void *)lpstr,
        pfInheritanceOverride,
        lpszMDPath
        );

    delete [] lpstr;

    return hr;
}


HRESULT 
CMetaKey::SetValue(
    IN DWORD dwID,
    IN CBlob & blValue,
    IN BOOL * pfInheritanceOverride,    OPTIONAL     
    IN LPCTSTR lpszMDPath               OPTIONAL        
    )
/*++

Routine Description:

    Store data as binary

Arguments:

    DWORD dwID                   : Property ID
    CBlob & blValue              : Value to be written
    BOOL * pfInheritanceOverride : NULL or forces inheritance on/off
    LPCTSTR lpszMDPath           : Optional path (or NULL or "")

Return Value:

    HRESULT

--*/
{
    return SetPropertyValue(
        dwID,
        blValue.GetSize(),
        (void *)blValue.GetData(),
        pfInheritanceOverride,
        lpszMDPath
        );
}



HRESULT
CMetaKey::DeleteValue(
    DWORD   dwID,
    LPCTSTR lpszMDPath      OPTIONAL
    )
/*++

Routine Description:

    Delete data

Arguments:

    DWORD   dwID            : Property ID of property to be deleted
    LPCTSTR lpszMDPath      : Optional path (or NULL or "")

Return Value:

    HRESULT

--*/
{
    ASSURE_PROPER_INTERFACE();
    ASSURE_OPEN_KEY();

    METADATA_RECORD mdRecord;
    FETCH_PROPERTY_DATA_OR_FAIL(dwID, mdRecord);

    return DeleteData(
        m_hKey,
        lpszMDPath,
        mdRecord.dwMDIdentifier,
        mdRecord.dwMDDataType
        );
}



HRESULT 
CMetaKey::DoesPathExist(
    IN LPCTSTR lpszMDPath
    )
/*++

Routine Description:

    Determine if the path exists

Arguments:

    LPCTSTR lpszMDPath      : Relative path off the open key

Return Value:

    HRESULT, or S_OK if the path exists.

--*/
{
    ASSURE_PROPER_INTERFACE();
    ASSURE_OPEN_KEY();

    FILETIME ft;

    return GetLastChangeTime(m_hKey, lpszMDPath, &ft, FALSE);
}



HRESULT
CMetaInterface::Regenerate()
/*++

Routine Description:

    Attempt to recreate the interface pointer.  This assumes that the interface
    had been successfully created before, but has become invalid at some
    point afterwards.

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    ASSERT_PTR(m_pInterface);           // Must have been initialised

    SAFE_RELEASE(m_pInterface);

    m_hrInterface = Create();

    return m_hrInterface;
}



//
// CWamInterface class
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



CWamInterface::CWamInterface(
    IN CComAuthInfo * pAuthInfo         OPTIONAL
    )
/*++

Routine Description:

    Construct and initialize the interface.

Arguments:

    CComAuthInfo * pAuthInfo   : Auth info.  NULL indicates the local computer.

Return Value:

    N/A

--*/
    : CIISInterface(pAuthInfo),
      m_pInterface(NULL),
      m_fSupportsPooledProc(FALSE)
{
    //
    // Initialize the interface
    //
    m_hrInterface = Create();
}



CWamInterface::CWamInterface(
    IN CWamInterface * pInterface
    )
/*++

Routine Description:

    Construct from existing interface (copy constructor)

Arguments:

    CWamInterface * pInterface  : Existing interface

Return Value:

    N/A

--*/
    : CIISInterface(&pInterface->m_auth, pInterface->m_hrInterface),
      m_pInterface(pInterface->m_pInterface),
      m_fSupportsPooledProc(FALSE)
{
    ASSERT_PTR(m_pInterface);
    m_pInterface->AddRef();
}



CWamInterface::~CWamInterface()
/*++

Routine Description:

    Destructor -- releases the interface.

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    SAFE_RELEASE(m_pInterface);
}



/* protected */
HRESULT
CWamInterface::Create()
/*++

Routine Description:

    Create the interface with DCOM

Arguments:

    None

Return Value:

    HRESULT 

Notes:

    First, it will attempt to create the new interface, if it
    fails, it will attempt to create the downlevel interface

--*/
{
    CLSID rgCLSID[2];
    IID   rgIID[2];

    rgCLSID[1] = rgCLSID[0] = CLSID_WamAdmin;
    rgIID[0] = IID_IWamAdmin2;
    rgIID[1] = IID_IWamAdmin;
    
    ASSERT(ARRAY_SIZE(rgCLSID) == ARRAY_SIZE(rgIID));
    int cInterfaces = ARRAY_SIZE(rgCLSID);
    int iInterface;
    
    HRESULT hr = CIISInterface::Create(
        cInterfaces,
        rgIID, 
        rgCLSID, 
        &iInterface, 
        (IUnknown **)&m_pInterface
        );

    if (SUCCEEDED(hr))
    {
        //
        // Only supported on IWamAdmin2
        //
        m_fSupportsPooledProc = (rgIID[iInterface] == IID_IWamAdmin2);
    }

    return hr;
}



HRESULT 
CWamInterface::AppCreate( 
    IN LPCTSTR szMDPath,
    IN DWORD   dwAppProtection
    )
/*++

Routine Description:

    Create  application

Arguments:

    LPCTSTR szMDPath      : Metabase path
    DWORD dwAppProtection : APP_INPROC     to create in-proc app
                            APP_OUTOFPROC  to create out-of-proc app
                            APP_POOLEDPROC to create a pooled-proc app

Return Value:

    HRESULT (ERROR_INVALID_PARAMETER if unsupported protection state is requested)

--*/
{
    if (m_fSupportsPooledProc)
    {
        //
        // Interface pointer is really IWamAdmin2, so call the new method
        //
        return ((IWamAdmin2 *)m_pInterface)->AppCreate2(szMDPath, dwAppProtection);
    }

    //
    // Call the downlevel API
    //
    if (dwAppProtection == APP_INPROC || dwAppProtection == APP_OUTOFPROC)
    {
        BOOL fInProc = (dwAppProtection == APP_INPROC);
    
        ASSERT_PTR(m_pInterface);
        return m_pInterface->AppCreate(szMDPath, fInProc);
    }

    return CError(ERROR_INVALID_PARAMETER);
}



//
// CMetaback Class
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


const LPCTSTR CMetaBack::s_szMasterAppRoot =\
    SZ_MBN_SEP_STR SZ_MBN_MACHINE SZ_MBN_SEP_STR SZ_MBN_WEB;


CMetaBack::CMetaBack(
    IN CComAuthInfo * pAuthInfo        OPTIONAL
    )
/*++

Routine Description:

    Constructor for metabase backup/restore operations class.  This object
    is both a WAM interface and a METABASE interface.

Arguments:

    CComAuthInfo * pAuthInfo    : Auth info.  NULL indicates the local computer.

Return Value:

    N/A

--*/
    : m_dwIndex(0),
      CMetaInterface(pAuthInfo),
      CWamInterface(pAuthInfo)
{
}



/* virtual */
BOOL 
CMetaBack::Succeeded() const
/*++

Routine Description:

    Determine if object was constructed successfully.

Arguments:

    None

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    return CMetaInterface::Succeeded() && CWamInterface::Succeeded();
}



/* virtual */
HRESULT 
CMetaBack::QueryResult() const
/*++

Routine Description:

    Return the construction error for this object

Arguments:

    None

Return Value:

    HRESULT from construction errors

--*/
{
    //
    // Both interfaces must have constructed successfully
    //
    HRESULT hr = CMetaInterface::QueryResult();

    if (SUCCEEDED(hr))
    {
        hr = CWamInterface::QueryResult();
    }    

    return hr;
}



HRESULT 
CMetaBack::Restore(
    IN LPCTSTR lpszLocation,
    IN DWORD dwVersion
    )
/*++

Routine Description:

    Restore metabase

Arguments:

    DWORD dwVersion         : Backup version
    LPCTSTR lpszLocation    : Backup location

Return Value:

    HRESULT

--*/
{
    //
    // Backup and restore the application information from a restore
    //
    CString strPath(s_szMasterAppRoot);
    HRESULT hr = AppDeleteRecoverable(strPath, TRUE);

    if (SUCCEEDED(hr))
    {
        hr = CMetaInterface::Restore(lpszLocation, dwVersion, 0);

        if (SUCCEEDED(hr))
        {
            hr = AppRecover(strPath, TRUE);
        }
    }

    return hr;
}



//
// CIISSvcControl class
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



CIISSvcControl::CIISSvcControl(
    IN CComAuthInfo * pAuthInfo        OPTIONAL
    )
/*++

Routine Description:

    Construct and initialize the interface.

Arguments:

    CComAuthInfo * pAuthInfo    : Auth info.  NULL indicates the local computer.

Return Value:

    N/A

--*/
    : CIISInterface(pAuthInfo),
      m_pInterface(NULL)
{
    //
    // Initialize the interface
    //
    m_hrInterface = Create();
}



CIISSvcControl::CIISSvcControl(
    IN CIISSvcControl * pInterface
    )
/*++

Routine Description:

    Construct from existing interface (copy constructor)

Arguments:

    CIISSvcControl * pInterface  : Existing interface

Return Value:

    N/A

--*/
    : CIISInterface(&pInterface->m_auth, pInterface->m_hrInterface),
      m_pInterface(pInterface->m_pInterface)
{
    ASSERT_PTR(m_pInterface);
    m_pInterface->AddRef();
}



CIISSvcControl::~CIISSvcControl()
/*++

Routine Description:

    Destructor -- releases the interface.

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    SAFE_RELEASE(m_pInterface);
}


#ifdef KEVLAR
//
// CWebCluster class
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



CWebCluster::CWebCluster(
    IN CComAuthInfo * pAuthInfo        OPTIONAL
    )
/*++

Routine Description:

    Construct and initialize the interface.

Arguments:

    CComAuthInfo * pAuthInfo : Authentication information.  
                               NULL indicates the local computer
    
Return Value:

    N/A

--*/
    : CIISInterface(pAuthInfo),
      m_pInterface(NULL)
{
    //
    // Initialize the interface
    //
    m_hrInterface = Create();
}



/* virtual */
CWebCluster::~CWebCluster()
/*++

Routine Description:

    Destructor -- releases the interface.

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    SAFE_RELEASE(m_pInterface);
}

#endif // KEVLAR

//
// CMetaEnumerator Clas
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



CMetaEnumerator::CMetaEnumerator(
    IN CComAuthInfo * pAuthInfo     OPTIONAL,
    IN LPCTSTR lpszMDPath           OPTIONAL,
    IN METADATA_HANDLE hkBase       OPTIONAL
    )
/*++

Routine Description:

    Metabase enumerator constructor.  This constructor creates a new interface
    and opens a key.

Arguments:

    CComAuthInfo * pAuthInfo : Auth info.  NULL indicates the local computer.
    LPCTSTR lpszMDPath       : Metabase path
    METADATA_HANDLE hkBase   : Metabase handle

Return Value:

    N/A

--*/
    : CMetaKey(pAuthInfo, lpszMDPath, METADATA_PERMISSION_READ, hkBase),
      m_dwIndex(0L)
{
}



CMetaEnumerator::CMetaEnumerator(
    IN CMetaInterface * pInterface,
    IN LPCTSTR lpszMDPath,                  OPTIONAL
    IN METADATA_HANDLE hkBase               OPTIONAL
    )
/*++

Routine Description:

    Metabase enumerator constructor.  This constructor uses an existing
    interface and opens a key.

Arguments:

    CMetaInterface * pInterface : Existing interface
    LPCTSTR lpszMDPath          : Metabase path
    METADATA_HANDLE hkBase      : Metabase handle

Return Value:

    N/A

--*/
    : CMetaKey(pInterface, lpszMDPath, METADATA_PERMISSION_READ, hkBase),
      m_dwIndex(0L)
{
}



CMetaEnumerator::CMetaEnumerator(
    IN BOOL fOwnKey,
    IN CMetaKey * pKey
    )
/*++

Routine Description:

    Metabase enumerator constructor.  This constructor uses an existing
    interface and open key.

Arguments:

    BOOL fOwnKey            : TRUE if we own the key (destructor will close)
    CMetaKey * pKey         : Open key

Return Value:

    N/A

--*/
    : CMetaKey(fOwnKey, pKey),
      m_dwIndex(0L)
{
}



HRESULT
CMetaEnumerator::Next(
    OUT CString & strKey,
    IN  LPCTSTR lpszMDPath      OPTIONAL
    )
/*++

Routine Description:

    Get the next subkey

Arguments:

    CString & str           Returns keyname
    LPCTSTR lpszMDPath      Optional subpath

Return Value:

    HRESULT

--*/
{
    ASSURE_PROPER_INTERFACE();
    ASSURE_OPEN_KEY();

    TCHAR buf[MAX_PATH];
    HRESULT hr = EnumKeys(m_hKey, lpszMDPath, buf, m_dwIndex++);
    if (SUCCEEDED(hr))
       strKey = buf;

    return hr;        
}



HRESULT
CMetaEnumerator::Next(
    OUT DWORD & dwKey,
    OUT CString & strKey,
    IN  LPCTSTR lpszMDPath      OPTIONAL
    )
/*++

Routine Description:

    Get the next subkey as a DWORD.  This skips non-numeric
    keynames (including 0) until the first numeric key name 

Arguments:

    DWORD & dwKey           Numeric key
    CString & strKey        Same key in string format
    LPCTSTR lpszMDPath      Optional subpath

Return Value:

    HRESULT

--*/
{
    ASSURE_PROPER_INTERFACE();
    ASSURE_OPEN_KEY();

    HRESULT hr;
    TCHAR buf[MAX_PATH];

    while (TRUE)
    {
        if (SUCCEEDED(hr = EnumKeys(m_hKey, lpszMDPath, buf, m_dwIndex++)))
        {
            if (0 != (dwKey = _ttoi(buf)))
            {
               strKey = buf;
               break;
            }
        }
        else
           break;
    }
    
    return hr;        
}


// This method moved from inline to remove dependency on IIDs and CLSIDs
HRESULT 
CIISSvcControl::Create()
{
    return CIISInterface::Create(
        1,
        &IID_IIisServiceControl, 
        &CLSID_IisServiceControl, 
        NULL, 
        (IUnknown **)&m_pInterface
        );
}


//
// CIISApplication class
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<</



CIISApplication::CIISApplication(
    IN CComAuthInfo * pAuthInfo   OPTIONAL,
    IN LPCTSTR lpszMetapath
    )
/*++

Routine Description:

    Construct IIS application.        

Arguments:

    CComAuthInfo * pAuthInfo : Authentication info.  NULL indicates the
                               local computer.
    LPCTSTR lpszMetapath     : Metabase path

Return Value:

    N/A

--*/
    : CWamInterface(pAuthInfo),
      CMetaKey(pAuthInfo),
      m_dwProcessProtection(APP_INPROC),
      m_dwAppState(APPSTATUS_NOTDEFINED),
      m_strFriendlyName(),
      m_strAppRoot(),
      m_strWamPath(lpszMetapath)
{
    CommonConstruct();
}



void
CIISApplication::CommonConstruct()
/*++

Routine Description:

    Perform common construction

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Munge the metapath so that WAM doesn't cough up a hairball.
    //


    //
    // BUGBUG: CleanMetaPath() disabled currently
    //

    if (m_strWamPath[0] != SZ_MBN_SEP_CHAR)
    {
        m_strWamPath = SZ_MBN_SEP_CHAR + m_strWamPath;
    }

    do
    {
        m_hrApp = CWamInterface::QueryResult();

        if (FAILED(m_hrApp))
        {
            break;
        }

        m_hrApp = RefreshAppState();

        if (HRESULT_CODE(m_hrApp) == ERROR_PATH_NOT_FOUND)
        {
            //
            // "Path Not Found" errors are acceptable, since
            // the application may not yet exist.
            //
            m_hrApp = S_OK;
        }
    }
    while(FALSE);
}



/* virtual */
BOOL 
CIISApplication::Succeeded() const
/*++

Routine Description:

    Determine if object was constructed successfully

Arguments:

    None

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    return CMetaInterface::Succeeded() 
        && CWamInterface::Succeeded()
        && SUCCEEDED(m_hrApp);
}



/* virtual */
HRESULT 
CIISApplication::QueryResult() const
/*++

Routine Description:

    Return the construction error for this object

Arguments:

    None

Return Value:

    HRESULT from construction errors

--*/
{
    //
    // Both interfaces must have constructed successfully
    //
    HRESULT hr = CMetaInterface::QueryResult();

    if (SUCCEEDED(hr))
    {
        hr = CWamInterface::QueryResult();

        if (SUCCEEDED(hr))
        {
            hr = m_hrApp;
        }
    }    

    return hr;
}



HRESULT 
CIISApplication::RefreshAppState()
/*++

Routine Description:

    Refresh the application state

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    ASSERT(!m_strWamPath.IsEmpty());

    HRESULT hr, hrKeys;

    hr = AppGetStatus(m_strWamPath, &m_dwAppState);

    if (FAILED(hr))
    {
        m_dwAppState = APPSTATUS_NOTDEFINED;
    }

    m_strAppRoot.Empty();
    hrKeys = QueryValue(MD_APP_ROOT, m_strAppRoot, NULL, m_strWamPath);

    m_dwProcessProtection = APP_INPROC;
    hrKeys = QueryValue(
        MD_APP_ISOLATED, 
        m_dwProcessProtection, 
        NULL, 
        m_strWamPath
        );

    m_strFriendlyName.Empty();
    hrKeys = QueryValue(
        MD_APP_FRIENDLY_NAME, 
        m_strFriendlyName, 
        NULL, 
        m_strWamPath
        );

    return hr;
}



HRESULT 
CIISApplication::Create(
    IN LPCTSTR lpszName,        OPTIONAL
    IN DWORD dwAppProtection
    )
/*++

Routine Description:

    Create the application

Arguments:

    LPCTSTR lpszName      : Application name
    DWORD dwAppProtection : APP_INPROC     to create in-proc app
                            APP_OUTOFPROC  to create out-of-proc app
                            APP_POOLEDPROC to create a pooled-proc app

Return Value:

    HRESULT

--*/
{
    ASSERT(!m_strWamPath.IsEmpty());
    HRESULT hr = AppCreate(m_strWamPath, dwAppProtection);

    if (SUCCEEDED(hr))
    {
        //
        // Write the friendly app name, which we maintain
        // ourselves.  Empty it first, because we might
        // have picked up a name from inheritance.
        //
        m_strFriendlyName.Empty(); 
        hr = WriteFriendlyName(lpszName);

        RefreshAppState();
    }

    return hr;
}



HRESULT 
CIISApplication::WriteFriendlyName(
    IN LPCTSTR lpszName
    )
/*++

Routine Description:

    Write the friendly name.  This will not write anything
    if the name is the same as it was

Arguments:

    LPCTSTR lpszName        : New friendly name

Return Value:

    HRESULT

--*/
{
    HRESULT hr = S_OK;    

    if (m_strFriendlyName.CompareNoCase(lpszName) != 0)
    {
        hr = Open(METADATA_PERMISSION_WRITE, m_strWamPath);

        if (SUCCEEDED(hr))
        {
            ASSERT_PTR(lpszName);

            CString str(lpszName);    
            hr = SetValue(MD_APP_FRIENDLY_NAME, str);
            Close();

            if (SUCCEEDED(hr))
            {
                m_strFriendlyName = lpszName;
            }
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\common2\mdkeys.h ===
/*++

   Copyright    (c)    1994-2000    Microsoft Corporation

   Module Name :

        mdkeys.h

   Abstract:

        Metabase key wrapper classes

   Author:

        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:

        Internet Services Manager

   Revision History:
        2/17/2000    sergeia     removed dependency on MFC

--*/

#ifndef _MDKEYS_H_
#define _MDKEYS_H_

//
// Include Files
//
#include <iadmw.h>
#include <iwamreg.h>
#include <iiscnfgp.h>
#include <winsvc.h>
#include <iisrsta.h>

//
// Forward definitions
//
class CBlob;

//
// Use this instance number to denote the master
//
#define MASTER_INSTANCE       (0)
#define IS_MASTER_INSTANCE(i) (i == MASTER_INSTANCE)

//
// Metabase node constants, used for static initialization of const
// strings further down.  Defined here with #defines for easier 
// concatenation later.
//
#define SZ_MBN_MACHINE      _T("LM")
#define SZ_MBN_FILTERS      _T("Filters")
#define SZ_MBN_MIMEMAP      _T("MimeMap")
#define SZ_MBN_TEMPLATES    _T("Templates")
#define SZ_MBN_INFO         _T("Info")
#define SZ_MBN_ROOT         _T("Root")
#define SZ_MBN_COMPRESSION  _T("Compression")
#define SZ_MBN_PARAMETERS   _T("Parameters")
#define SZ_MBN_SEP_CHAR     _T('/')
#define SZ_MBN_SEP_STR      _T("/")
#define SZ_MBN_ANYSEP_STR   _T("/\\")
#define SZ_MBN_WEB          _T("W3SVC")
#define SZ_MBN_FTP          _T("MSFTPSVC")


class CIISInterface;

class _EXPORT CComAuthInfo
/*++

Class Description:

    Server/authentication information.  Contains optional 
    impersonation parameters. Typically used in the construction in 
    CIISInterface.

Public Interface:

    CComAuthInfo            : Constructor.  Impersonation optional
    operator=               : Assignment operators
    CreateServerInfoStruct  : Helper function for use in COM
    FreeServerInfoStruct    : As above.

Notes:

    Because there's an operator for a pointer to itself and because
    CIISInterface copies the information at construction time, a 
    CComAuthInfo can safely be constructed on the stack as a parameter
    to CIISInterface derived classes.

--*/
{
//
// Constructor/Destructor
//
public:
    //
    // Standard Constructor.  NULL for servername indicates
    // local computer.
    //
    CComAuthInfo(
        LPCOLESTR lpszServerName  = NULL,    
        LPCOLESTR lpszUserName    = NULL,
        LPCOLESTR lpszPassword    = NULL
        );

    //
    // Copy Constructors
    //
    CComAuthInfo(
        CComAuthInfo & auth
        );

    CComAuthInfo(
        CComAuthInfo * pAuthInfo OPTIONAL
        );

//
// Assignment operators
//
public:
    CComAuthInfo & operator =(CComAuthInfo & auth);
    CComAuthInfo & operator =(CComAuthInfo * pAuthInfo);
    CComAuthInfo & operator =(LPCTSTR lpszServerName);

//
// Access
//
public:
    COSERVERINFO * CreateServerInfoStruct() const;
    void FreeServerInfoStruct(COSERVERINFO * pServerInfo) const;

    LPOLESTR QueryServerName() const { return m_bstrServerName; }
    LPOLESTR QueryUserName() const { return m_bstrUserName; }
    LPOLESTR QueryPassword() const { return m_bstrPassword; }
    BOOL     IsLocal() const { return m_fLocal; }
    BOOL     UsesImpersonation() const { return m_bstrUserName.Length() > 0; }
    void     SetImpersonation(LPCOLESTR lpszUser, LPCOLESTR lpszPassword);
    void     RemoveImpersonation();
    void     StorePassword(LPCOLESTR lpszPassword);

public:
    HRESULT  ApplyProxyBlanket(IUnknown * pInterface);
    
//
// Conversion Operators
//
public:
    operator LPOLESTR() { return QueryServerName(); }
    operator CComAuthInfo *() { return this; }

//
// Static Helpers
//
public:
    //
    // Given domain\username, split into user name and domain
    //
    static BOOL SplitUserNameAndDomain(
        CString & strUserName,
        CString & strDomainName
        );

    //
    // Verify username and password are correct
    //
    static DWORD VerifyUserPassword(
        LPCTSTR lpstrUserName,
        LPCTSTR lpstrPassword
        );

protected:
    //
    // Store the computer name (NULL for local computer)
    //
    void SetComputerName(
        LPCOLESTR lpszServerName   OPTIONAL
        );

private:
    CComBSTR    m_bstrServerName;
    CComBSTR    m_bstrUserName;
    CComBSTR    m_bstrPassword;
    BOOL        m_fLocal;
};

class _EXPORT CMetabasePath
/*++

Class Description:

    Metabase path class.  This is a helper class to build complete
    metabase paths out of various components.

    Example: CMetaKey(CComAuthInfo("ronaldm3"), CMetabasePath(SZ_WEBSVC, dwInstance, _T("root")));

--*/
{
    //
    // Metabase components in order
    //
    enum
    {
        iBlank,                    // Sep 0
        iMachine,                  // LM
        iService,                  // e.g. lm/w3svc
        iInstance,                 // e.g. lm/w3svc/1
        iRootDirectory,            // e.g. lm/w3svc/1/root
        iSubDirectory,             // e.g. lm/w3vsc/1/root/foobar
    };

//
// Metabase helper functions.
//
public:
    //
    // Clean metabase path
    //
    static LPCTSTR CleanMetaPath(
        CString & strMetaRoot
        );

    static LPCTSTR CleanMetaPath(
        CMetabasePath & path
        );

    //
    // Find the instance number from the given metabase path
    //
    static DWORD GetInstanceNumber(LPCTSTR lpszMDPath);

    //
    // Get the last nodename in the given metabase path
    //
    static LPCTSTR GetLastNodeName(
         LPCTSTR lpszMDPath,
        CString & strNodeName
        );

    //
    // Truncate the path at a given sub path
    //
    static LPCTSTR TruncatePath(
        int     nLevel,          
        LPCTSTR lpszMDPath,
        CString & strNewPath,
        CString * pstrRemainder = NULL
        );

    static LPCTSTR GetMachinePath(
        LPCTSTR lpszMDPath,
        CString & strNewPath,
        CString * pstrRemainder = NULL
        );

    static LPCTSTR GetServicePath(
        LPCTSTR lpszMDPath,
        CString & strNewPath,
        CString * pstrRemainder = NULL
        );

    static LPCTSTR GetInstancePath(
        LPCTSTR lpszMDPath,
        CString & strNewPath,
        CString * pstrRemainder = NULL
        );

    static LPCTSTR GetRootPath(
        LPCTSTR lpszMDPath,
        CString & strNewPath,
        CString * pstrRemainder = NULL
        );

    //
    // Determine the path to the info node that's relevant
    // to this metabase path.
    //
    static LPCTSTR GetServiceInfoPath(
        LPCTSTR lpszMDPath,
        CString & strInfoPath,   
        LPCTSTR lpszDefService  = SZ_MBN_WEB
        );

    //
    // Change path to parent node
    //
    static LPCTSTR ConvertToParentPath(
        CString & strMetaPath
        );

    static LPCTSTR ConvertToParentPath(
        CMetabasePath& path
        );

    //
    // Determine if the path describes a home directory path
    //
    static BOOL IsHomeDirectoryPath(
        LPCTSTR lpszMDPath
        );

    //
    // Determine if the path describes the 'master' instance (site)
    //
    static BOOL IsMasterInstance(
        LPCTSTR lpszMDPath
        );

    //
    // Split the metapath at the instance border
    //
    static void SplitMetaPathAtInstance(
        LPCTSTR lpszMDPath,
        CString & strParent,
        CString & strAlias
        );

    static BOOL IsSeparator(TCHAR c);
 

//
// Constructor/Destructor
//
public:
    CMetabasePath(
        BOOL    fAddBasePath,
        LPCTSTR lpszMDPath,
        LPCTSTR lpszMDPath2 = NULL,
        LPCTSTR lpszMDPath3 = NULL,
        LPCTSTR lpszMDPath4 = NULL
        );

    //
    // Construct with path components
    //
    CMetabasePath(
         LPCTSTR lpszSvc        = NULL,    
         DWORD   dwInstance     = MASTER_INSTANCE,
         LPCTSTR lpszParentPath = NULL,        
         LPCTSTR lpszAlias      = NULL    
        );

//
// Access
//
public:
    BOOL    IsHomeDirectoryPath() const { return IsHomeDirectoryPath(m_strMetaPath); }
    LPCTSTR QueryMetaPath() const { return m_strMetaPath; }

//
// Conversion Operators
//
public:
    operator LPCTSTR() const { return QueryMetaPath(); }

//
// Helpers
//
protected:
    void BuildMetaPath(  
        LPCTSTR lpszSvc,
        LPCTSTR szInstance,
        LPCTSTR lpszParentPath,
        LPCTSTR lpszAlias           
        );

    void BuildMetaPath(  
        LPCTSTR lpszSvc,
        DWORD   dwInstance,
        LPCTSTR lpszParentPath,
        LPCTSTR lpszAlias           
        );

    void AppendPath(LPCTSTR lpszPath);
    void AppendPath(DWORD dwInstance);

protected:
    //
    // Metabase path components
    //
    static const LPCTSTR _cszMachine;     
    static const LPCTSTR _cszRoot;        
    static const LPCTSTR _cszSep;         
    static const TCHAR   _chSep;          
    static const CString _anySep;

private:
    CString m_strMetaPath;
};

class _EXPORT CIISInterface
/*++

Class Description:

    Base interface class for IIS interfaces.  Most client COM-wrappers
    should derive from this class so that they can easily pick up
    share authentication and proxy blanket information methods.

Virtual Interface:

    Succeeded           : Return TRUE if item constructed successfully
    QueryResult         : Return construction error code

Public Interface:

    operator BOOL       : Cast to TRUE/FALSE depending on success
    operator HRESULT    : Cast to the HRESULT status

    QueryServerName     : Get the server name
    IsLocal             : Determine if the interface is on the local machine

--*/
{
//
// Constructor/Destructor
//
public:
    CIISInterface(
        CComAuthInfo * pAuthInfo,
        HRESULT hrInterface    = S_OK
        );

//
// Interface:
//
public:
    CComAuthInfo * QueryAuthInfo() { return &m_auth; }
    LPCOLESTR QueryServerName() const { return m_auth.QueryServerName(); }
    BOOL IsLocal() const { return m_auth.IsLocal(); }

//
// Virtual Interface:
//
public:
    virtual BOOL Succeeded() const { return SUCCEEDED(m_hrInterface); }
    virtual HRESULT QueryResult() const { return m_hrInterface; }
    virtual HRESULT ChangeProxyBlanket(
        LPCOLESTR lpszUserName, 
        LPCOLESTR lpszPassword
        );

//
// Conversion Operators
//
public:
    operator BOOL() const { return Succeeded(); }
    operator HRESULT() const { return m_hrInterface; }

protected:
    virtual HRESULT ApplyProxyBlanket() = 0;
    HRESULT Create(
        int   cInterfaces,       
        const IID rgIID[],      
        const GUID rgCLSID[],    
        int * pnInterface,          OPTIONAL
        IUnknown ** ppInterface 
        );

protected:
    CComAuthInfo m_auth;
    HRESULT    m_hrInterface;
};


class _EXPORT CMetaInterface : public CIISInterface
/*++

Class description:

    Metabase interface class.

Virtual Interface:

    Succeeded           : Return TRUE if item constructed successfully
    QueryResult         : Return construction error code

Public Interface:

    Regenerate          : Recreate the interface

--*/
{
public:
    //
    // Destructor destroys the interface
    //
    virtual ~CMetaInterface();

//
// Constructor/Destructor
//
protected:
    //
    // Fully defined constructor that creates the interface.
    // Use NULL to indicate the local computer name
    //
    CMetaInterface(
        CComAuthInfo * pServer
        );

    //
    // Construct from existing interface
    //
    CMetaInterface(
        CMetaInterface * pInterface
        );

public:
    //
    // Rebuild the interface
    //
    HRESULT Regenerate();

protected:
    virtual HRESULT ApplyProxyBlanket();

    //
    // Create a metadata object in this server. This function initializes the
    // metadata object with DCOM.
    //
    HRESULT Create();

    //
    // Make sure the interface has been created
    //
    BOOL HasInterface() const { return m_pInterface != NULL; }

//
// IADMW Interface -- all methods defines as inline at the end of this file.
//
protected:
    HRESULT OpenKey(
        METADATA_HANDLE hkBase,
        LPCTSTR lpszMDPath,
        DWORD dwFlags,
        METADATA_HANDLE * phMDNewHandle
        );

    HRESULT CloseKey(
        METADATA_HANDLE hKey
        );

    HRESULT SetLastChangeTime( 
        METADATA_HANDLE hMDHandle,
        LPCTSTR pszMDPath,
        FILETIME * pftMDLastChangeTime,
        BOOL bLocalTime
        );
        
    HRESULT GetLastChangeTime( 
        METADATA_HANDLE hMDHandle,
        LPCTSTR lpszMDPath,
        FILETIME * pftMDLastChangeTime,
        BOOL bLocalTime
        );

    HRESULT AddKey( 
        METADATA_HANDLE hKey,
        LPCTSTR lpszMDPath
        );

    HRESULT DeleteKey(
        METADATA_HANDLE hKey,
        LPCTSTR lpszMDPath
        );

    HRESULT DeleteChildKeys(
        METADATA_HANDLE hKey,
        LPCTSTR lpszMDPath
        );

    HRESULT EnumKeys(
        METADATA_HANDLE hKey,
        LPCTSTR lpszMDPath,
        LPTSTR lpszMDName,
        DWORD dwIndex
        );

    HRESULT CopyKey(
        METADATA_HANDLE hSourceKey,
        LPCTSTR lpszMDSourcePath,
        METADATA_HANDLE hDestKey,
        LPCTSTR lpszMDDestPath,
        BOOL fOverwrite,
        BOOL fCopy
        );

    HRESULT RenameKey(
        METADATA_HANDLE hKey,
        LPCTSTR lpszMDPath,
        LPCTSTR lpszNewName
        );

    HRESULT GetData(
        METADATA_HANDLE hKey,
        LPCTSTR lpszMDPath,
        METADATA_RECORD * pmdRecord,
        DWORD * pdwRequiredDataLen
        );

    HRESULT SetData(
        METADATA_HANDLE hKey,
        LPCTSTR lpszMDPath,
        METADATA_RECORD * pmdRecord
        );

    HRESULT DeleteData(
        METADATA_HANDLE hKey,
        LPCTSTR lpszMDPath,
        DWORD dwMDIdentifier,
        DWORD dwMDDataType
        );

    HRESULT EnumData(
        METADATA_HANDLE hKey,
        LPCTSTR lpszMDPath,
        METADATA_RECORD * pmdRecord,
        DWORD dwIndex,
        DWORD * pdwRequiredDataLen
        );

    HRESULT GetAllData(
        METADATA_HANDLE hKey,
        LPCTSTR lpszMDPath,
        DWORD dwMDAttributes,
        DWORD dwMDUserType,
        DWORD dwMDDataType,
        DWORD * pdwMDNumDataEntries,
        DWORD * pdwMDDataSetNumber,
        DWORD dwMDBufferSize,
        LPBYTE pbMDBuffer,
        DWORD * pdwRequiredBufferSize
        );

    HRESULT DeleteAllData( 
        METADATA_HANDLE hKey,
        LPCTSTR lpszMDPath,
        DWORD dwMDUserType,
        DWORD dwMDDataType
        );

    HRESULT CopyData( 
        METADATA_HANDLE hMDSourceKey,
        LPCTSTR lpszMDSourcePath,
        METADATA_HANDLE hMDDestKey,
        LPCTSTR lpszMDDestPath,
        DWORD dwMDAttributes,
        DWORD dwMDUserType,
        DWORD dwMDDataType,
        BOOL fCopy
        );

    HRESULT GetDataPaths( 
        METADATA_HANDLE hKey,
        LPCTSTR lpszMDPath,
        DWORD dwMDIdentifier,
        DWORD dwMDDataType,
        DWORD dwMDBufferSize,
        LPTSTR lpszBuffer,
        DWORD * pdwMDRequiredBufferSize
        );

    HRESULT Backup( 
        LPCTSTR lpszBackupLocation,
        DWORD dwMDVersion,
        DWORD dwMDFlags
        );

    HRESULT Restore(    
        LPCTSTR lpszBackupLocation,
        DWORD dwMDVersion,
        DWORD dwMDFlags
        );

    HRESULT EnumBackups(
        LPTSTR lpszBackupLocation,
        DWORD * pdwMDVersion,
        FILETIME * pftMDBackupTime,
        DWORD dwIndex
        );

    HRESULT DeleteBackup(
        LPCTSTR lpszBackupLocation,
        DWORD dwMDVersion
        );

protected:
    IMSAdminBase * m_pInterface; 

private:
    int  m_iTimeOutValue;         
};



class _EXPORT CMetaKey : public CMetaInterface
/*++

Class Description:

    Metabase key wrapper class

Public Interface:

    CMetaKey                    : Constructor
    ~CMetaKey                   : Destructor

    Succeeded                   : TRUE if key opened successfully.
    QueryResult                 : Get the HRESULT status

    QueryValue                  : Various overloaded methods to get values
    SetValue                    : Various overloaded methods to set values
    DeleteValue                 : Delete a value
    Open                        : Open key
    ReOpen                      : Re key that was opened before
    Close                       : Close key
    ConvertToParentPath         : Change path to parent path

    operator METADATA_HANDLE    : Cast to a metadata handle
    operator LPCTSTR            : Cast to the metabase path
    operator BOOL               : Cast to TRUE if the key is open, FALSE if not

    GetHandle                   : Obtain metadata handle
    IsOpen                      : TRUE if a key is open
    QueryMetaPath               : Get the relative metabase path
    QueryFlags                  : Get the open permissions

--*/
{
//
// Constructor/Destructor
//
public:
    //
    // Null constructor that only creates the interface.
    // A key constructed this way may read from META_ROOT_HANDLE.
    // This is not true of other constructors.
    //
    CMetaKey(
        CComAuthInfo * pServer
        );

    //
    // As above, using an existing interface
    //
    CMetaKey(
        CMetaInterface * pInterface
        );

    //
    // Fully defined constructor that opens a key
    //
    CMetaKey(
        CComAuthInfo * pServer,
        LPCTSTR lpszMDPath,
        DWORD   dwFlags        = METADATA_PERMISSION_READ,
        METADATA_HANDLE hkBase = METADATA_MASTER_ROOT_HANDLE
        );

    //
    // As above, using an existing interface
    //
    CMetaKey(
        CMetaInterface * pInterface,
        LPCTSTR lpszMDPath,
        DWORD   dwFlags        = METADATA_PERMISSION_READ,
        METADATA_HANDLE hkBase = METADATA_MASTER_ROOT_HANDLE
        );

    //
    // Copy constructor, might or might not own the key
    //
    CMetaKey(
        BOOL fOwnKey,
        CMetaKey * pKey
        );

    //
    // Destructor -- closes key.
    //
    virtual ~CMetaKey();

//
// Interface
//
public:
    //
    // Fetch a DWORD
    //
    HRESULT QueryValue(
        DWORD dwID, 
        DWORD & dwValue,
        BOOL * pfInheritanceOverride = NULL,
        LPCTSTR lpszMDPath           = NULL,
        DWORD * pdwAttributes        = NULL
        );

    //
    // Fetch a boolean
    //
    HRESULT QueryValue(
        DWORD dwID, 
        BOOL & fValue,
        BOOL * pfInheritanceOverride = NULL,
        LPCTSTR lpszMDPath           = NULL,
        DWORD * pdwAttributes        = NULL
        );

    //
    // Fetch a string
    //
    HRESULT QueryValue(
        DWORD dwID, 
        CString & strValue, 
        BOOL * pfInheritanceOverride = NULL,
        LPCTSTR lpszMDPath           = NULL,
        DWORD * pdwAttributes        = NULL
        );

    //
    // Fetch a BSTR
    //
    HRESULT QueryValue(
        DWORD dwID, 
        CComBSTR & strValue, 
        BOOL * pfInheritanceOverride = NULL,
        LPCTSTR lpszMDPath           = NULL,
        DWORD * pdwAttributes        = NULL
        );

    //
    // Fetch a string list
    //
    HRESULT QueryValue(
        DWORD dwID, 
        CStringListEx & strlValue, 
        BOOL * pfInheritanceOverride = NULL,
        LPCTSTR lpszMDPath           = NULL,
        DWORD * pdwAttributes        = NULL
        );

    //
    // Fetch binary blob
    //
    HRESULT QueryValue(
        DWORD dwID, 
        CBlob & blValue, 
        BOOL * pfInheritanceOverride = NULL,
        LPCTSTR lpszMDPath           = NULL,
        DWORD * pdwAttributes        = NULL
        );

    //
    // Store a DWORD
    //
    HRESULT SetValue(
        DWORD dwID,
        DWORD dwValue,
        BOOL * pfInheritanceOverride = NULL,
        LPCTSTR lpszMDPath           = NULL
        );

    //
    // Store a BOOL
    //
    HRESULT SetValue(
        DWORD dwID,
        BOOL fValue,
        BOOL * pfInheritanceOverride = NULL,
        LPCTSTR lpszMDPath           = NULL
        );

    //
    // Store a string
    //
    HRESULT SetValue(
        DWORD dwID,
        CString & strValue,
        BOOL * pfInheritanceOverride = NULL,
        LPCTSTR lpszMDPath           = NULL
        );

    //
    // Store a BSTR
    //
    HRESULT SetValue(
        DWORD dwID,
        CComBSTR & strValue,
        BOOL * pfInheritanceOverride = NULL,
        LPCTSTR lpszMDPath           = NULL
        );


    //
    // Store a stringlist
    //
    HRESULT SetValue(
        DWORD dwID,
        CStringListEx & strlValue,
        BOOL * pfInheritanceOverride  = NULL,
        LPCTSTR lpszMDPath            = NULL
        );

    //
    // Store a binary blob
    //
    HRESULT SetValue(
        DWORD dwID,
        CBlob & blValue,
        BOOL * pfInheritanceOverride  = NULL,
        LPCTSTR lpszMDPath            = NULL
        );

    //
    // Delete Value:
    //
    HRESULT DeleteValue(
        DWORD   dwID,
        LPCTSTR lpszMDPath = NULL
        );

    //
    // Check for path existance
    //
    HRESULT DoesPathExist(
        LPCTSTR lpszMDPath
        );

    //
    // Create current path (which we attempted to open, and got
    // a path not found error on).
    //
    HRESULT CreatePathFromFailedOpen();

    //
    // Check for descendant overrides
    //
    HRESULT CheckDescendants(
        DWORD   dwID,
        CComAuthInfo * pServer,
        LPCTSTR lpszMDPath       = NULL
        );

    //
    // Open key
    //
    HRESULT Open(
        DWORD   dwFlags,
        LPCTSTR lpszMDPath       = NULL,
        METADATA_HANDLE hkBase   = METADATA_MASTER_ROOT_HANDLE 
        );

    //
    // Re-open previously opened key
    //
    HRESULT ReOpen(
        DWORD   dwFlags
        );

    //
    // As above using the same permissions as before
    //
    HRESULT ReOpen();

    //
    // Open the parent object
    // 
    HRESULT ConvertToParentPath(
        BOOL fImmediate
        );

    //
    // Close key, set it to NULL, but doesn't destroy the interface
    //
    HRESULT Close();

    //
    // Add key
    //
    HRESULT AddKey(
        LPCTSTR lpszMDPath
        );

    //
    // Delete key off currently open key
    //
    HRESULT DeleteKey(
        LPCTSTR lpszMDPath
        );

    //
    // Rename key off currently open key
    //
    HRESULT RenameKey(
        LPCTSTR lpszMDPath,
        LPCTSTR lpszNewName
        );

    //
    // Get list of descendant nodes that override
    // a specific value
    //
    HRESULT GetDataPaths( 
        CStringListEx & strlNodes,
        DWORD dwMDIdentifier,
        DWORD dwMDDataType,
        LPCTSTR lpszMDPath = NULL
        );


//
// Access
//
public:
    METADATA_HANDLE GetHandle() const { return m_hKey; }
    METADATA_HANDLE GetBase() const   { return m_hBase; }
    LPCTSTR QueryMetaPath() const     { return m_strMetaPath; }
    DWORD QueryFlags() const          { return m_dwFlags; }
    BOOL IsOpen() const               { return m_hKey != NULL; }
    BOOL IsHomeDirectoryPath() const ;

//
// Conversion operators
//
public:
    operator METADATA_HANDLE() const  { return GetHandle(); }
    operator LPCTSTR() const          { return QueryMetaPath(); }
    operator BOOL() const             { return IsOpen(); }

//
// Virtual Interface:
//
public:
    virtual BOOL Succeeded() const;
    virtual HRESULT QueryResult() const;

//
// Protected members
//
protected:
    //
    // Get data
    //
    HRESULT GetPropertyValue(
        DWORD dwID,
        DWORD & dwSize,
        void *& pvData,
        DWORD * pdwDataType           = NULL,
        BOOL * pfInheritanceOverride     = NULL,
        LPCTSTR lpszMDPath               = NULL,
        DWORD * pdwAttributes            = NULL
        );

    //
    // Store data
    //
    HRESULT SetPropertyValue(
        DWORD dwID,
        DWORD dwSize,
        void * pvData,
        BOOL * pfInheritanceOverride = NULL,
        LPCTSTR lpszMDPath           = NULL
        );

    //
    // Get All Data off the open key
    //
    HRESULT GetAllData(
        DWORD dwMDAttributes,
        DWORD dwMDUserType,
        DWORD dwMDDataType,
        DWORD * pdwMDNumEntries,
        DWORD * pdwMDDataLen,
        PBYTE * ppbMDData,
        LPCTSTR lpszMDPath  = NULL
        );

//
// Property Table Methods
//
protected:
    //
    // Metabase table entry definition
    //
    typedef struct tagMDFIELDDEF
    {
        DWORD dwMDIdentifier;
        DWORD dwMDAttributes;
        DWORD dwMDUserType;
        DWORD dwMDDataType;
        UINT  uStringID;
    } MDFIELDDEF;

    static const MDFIELDDEF s_rgMetaTable[];

//
// CODEWORK: Ideally, these should be protected, but are used
//           by idlg.
//
public:
    static BOOL GetMDFieldDef(
        DWORD dwID,
        DWORD & dwMDIdentifier,
        DWORD & dwMDAttributes,
        DWORD & dwMDUserType,
        DWORD & dwMDDataType
        );

    //
    // Map metabase ID value to table index
    //
    static int MapMDIDToTableIndex(
        DWORD dwID
        );

//
// Allow limited access to the table
//
public:
    static BOOL IsPropertyInheritable(
        DWORD dwID
        );

    static BOOL GetPropertyDescription(
        DWORD dwID, 
        CString & strName
        );

protected:
    BOOL    m_fAllowRootOperations;
    BOOL    m_fOwnKey;
    DWORD   m_cbInitialBufferSize;    
    DWORD   m_dwFlags;
    HRESULT m_hrKey;
    CString m_strMetaPath;
    METADATA_HANDLE m_hKey;
    METADATA_HANDLE m_hBase;
};



class _EXPORT CWamInterface : public CIISInterface
/*++

Class description:

    WAM interface class

Virtual Interface:

    Succeeded           : Return TRUE if item constructed successfully
    QueryResult         : Return construction error code

Public Interface:

    SupportsPooledProc  : Check to see if pooled out of proc is supported.

--*/
{
//
// App Protection States:
//
public:
    enum
    {
        //
        // Note: order must match MD_APP_ISOLATED values
        //
        APP_INPROC,
        APP_OUTOFPROC,
        APP_POOLEDPROC,
    };

//
// Constructor/Destructor
//
public:
    //
    // Destructor destroys the interface
    //
    virtual ~CWamInterface();

protected:
    //
    // Fully defined constructor that creates the interface.
    // Use NULL to create the interface on the local computer
    //
    CWamInterface(
        CComAuthInfo * pServer
        );

    //
    // Construct from existing interface.  
    //
    CWamInterface(
        CWamInterface * pInterface
        );

//
// Access
//
public:
    BOOL SupportsPooledProc() const { return m_fSupportsPooledProc; }

protected:
    virtual HRESULT ApplyProxyBlanket();

    //
    // Create a wam object in this server. This function initializes the
    // object with DCOM.
    //
    HRESULT Create();

    //
    // Make sure the interface has been created
    //
    BOOL HasInterface() const { return m_pInterface != NULL; }

//
// IWAM Interface
//
protected:
    HRESULT AppCreate( 
        LPCTSTR szMDPath,
        DWORD dwAppProtection
        );
    
    HRESULT AppDelete( 
        LPCTSTR szMDPath,
        BOOL fRecursive
        );
    
    HRESULT AppUnLoad( 
        LPCTSTR szMDPath,
        BOOL fRecursive
        );
    
    HRESULT AppGetStatus( 
        LPCTSTR szMDPath,
        DWORD * pdwAppStatus
        );
    
    HRESULT AppDeleteRecoverable( 
        LPCTSTR szMDPath,
        BOOL fRecursive
        );
    
    HRESULT AppRecover( 
        LPCTSTR szMDPath,
        BOOL fRecursive
        );

protected:
    IWamAdmin * m_pInterface; 

private:
    BOOL m_fSupportsPooledProc;
};



class _EXPORT CMetaBack : public CMetaInterface, public CWamInterface
/*++

Class Description:

    Metabase backup/restore class

Virtual Interface:

    Succeeded           : Return TRUE if item constructed successfully
    QueryResult         : Return construction error code

Public Interface:

    Reset               : Enum first existing backup
    Next                : Enum next existing backup
    Backup              : Create new backup
    Delete              : Delete existing backup
    Restore             : Restore from existing backup

--*/
{
public:
    //
    // Construct and create the interfaces.  Use NULL to create
    // on the local computer.
    //
    CMetaBack(
        CComAuthInfo * pServer
        );

//
// Virtual Interface
//
public:
    virtual BOOL Succeeded() const;
    virtual HRESULT QueryResult() const;

//
// Interface
//
public:
    //
    // Reset counter
    //
    void Reset() { m_dwIndex = 0L; }

    HRESULT Next(
        DWORD * pdwVersion,
        LPTSTR lpszLocation,
        FILETIME * pftBackupTime
        );

    HRESULT Backup(
        LPCTSTR lpszLocation
        );

    HRESULT Delete(
        LPCTSTR lpszLocation,
        DWORD dwVersion
        );

    HRESULT Restore(
        LPCTSTR lpszLocation,
        DWORD dwVersion
        );

protected:
    virtual HRESULT ApplyProxyBlanket();

protected:
    static const LPCTSTR s_szMasterAppRoot;

private:
    DWORD m_dwIndex;
};



class _EXPORT CMetaEnumerator : public CMetaKey
/*++

Class Description:

    Metabase key enumerator

Public Interface:

    CMetaEnumerator     : Constructor
    
    Reset               : Reset the enumerator
    Next                : Get next key

--*/
{
public:
    //
    // Constructor creates a new interface and opens a key
    //
    CMetaEnumerator(
        CComAuthInfo * pServer,
        LPCTSTR lpszMDPath     = NULL,
        METADATA_HANDLE hkBase = METADATA_MASTER_ROOT_HANDLE
        );

    //
    // Constructor which uses an existing interface and opens
    // a new key
    //
    CMetaEnumerator(
        CMetaInterface * pInterface,
        LPCTSTR lpszMDPath     = NULL,
        METADATA_HANDLE hkBase = METADATA_MASTER_ROOT_HANDLE
        );

    //
    // Constructor which uses an open key
    //
    CMetaEnumerator(
        BOOL fOwnKey,
        CMetaKey * pKey
        );

//
// Interface:
//
public:
    //
    // Reset counter
    //
    void Reset(DWORD counter = 0L) { m_dwIndex = counter; }
    DWORD GetIndex() { return m_dwIndex; }
    // Index stack operators, used for recursive enums
    void Push()
    {
       m_stack.push(m_dwIndex);
    }
    void Pop()
    {
       ASSERT(!m_stack.empty());
       m_dwIndex = m_stack.top();
       m_stack.pop();
    }

    //
    // Get next key as string.
    //
    HRESULT Next(
        CString & strKey,
        LPCTSTR lpszMDPath = NULL
        );

    //
    // Get next key as a DWORD (numeric keys only)
    //
    HRESULT Next(
        DWORD & dwKey,
        CString & strKey,
        LPCTSTR lpszMDPath = NULL
        );

private:
    DWORD m_dwIndex;
    std::stack<DWORD> m_stack;
};



class _EXPORT CIISApplication : public CWamInterface, public CMetaKey
/*++

Class Description:

    IIS Application class

Virtual Interface:

    Succeeded           : Return TRUE if item constructed successfully
    QueryResult         : Return construction error code

Public Interface:

    RefreshState        : Refresh application state
    QueryAppState       : Return current application state
    IsEnabledApplication: Return TRUE if appplication is enabled. 
    Create              : Create app
    Delete              : Delete app
    Unload              : Unload app
    DeleteRecoverable   : Delete w. recovery allowed
    Recover             : Recover
    WriteFriendlyName   : Write friendly name to metabase

--*/
{
//
// Constructor/Destructor
//
public:
    CIISApplication(
        CComAuthInfo * pServer,
        LPCTSTR lpszMetapath
        );

//
// Virtual Interface:
//
public:
    virtual BOOL Succeeded() const;
    virtual HRESULT QueryResult() const;

//
// Interface
//
public:
    DWORD   QueryAppState() const { return m_dwAppState; }
    LPCTSTR QueryWamPath() const { return m_strWamPath; }
    BOOL    IsEnabledApplication() const;
    HRESULT RefreshAppState();
    HRESULT Create(LPCTSTR lpszName, DWORD dwAppProtection);
    HRESULT Delete(BOOL fRecursive = FALSE);
    HRESULT Unload(BOOL fRecursive = FALSE);
    HRESULT DeleteRecoverable(BOOL fRecursive = FALSE);
    HRESULT Recover(BOOL fRecursive = FALSE);
    HRESULT WriteFriendlyName(LPCTSTR lpszName);

public:
    BOOL IsInproc() const { return m_dwProcessProtection == APP_INPROC; }
    BOOL IsOutOfProc() const { return m_dwProcessProtection == APP_OUTOFPROC; }
    BOOL IsPooledProc() const { return m_dwProcessProtection == APP_POOLEDPROC; }

public:
    DWORD   m_dwProcessProtection;
    CString m_strFriendlyName;
    CString m_strAppRoot;

protected:
    void CommonConstruct();

private:
    DWORD   m_dwAppState;
    CString m_strWamPath;
    HRESULT m_hrApp;
};



class _EXPORT CIISSvcControl : public CIISInterface
/*++

Class description:

    IIS Service control

Virtual Interface:

    Succeeded           : Return TRUE if item constructed successfully
    QueryResult         : Return construction error code

--*/
{
//
// Constructor/Destructor
//
public:
    //
    // Fully defined constructor that creates the interface.
    // Use NULL to create the interface on the local computer
    //
    CIISSvcControl(
        CComAuthInfo * pServer
        );

    //
    // Construct from existing interface.  
    //
    CIISSvcControl(
        CIISSvcControl * pInterface
        );

    //
    // Destructor destroys the interface
    //
    virtual ~CIISSvcControl();

protected:
    //
    // Create an object in this server. This function initializes the
    // object with DCOM.
    //
    HRESULT Create();

    //
    // Make sure the interface has been created
    //
    BOOL HasInterface() const { return m_pInterface != NULL; }

//
// Interface
//
public:
    //
    // Stop services
    //
    HRESULT Stop(
        DWORD dwTimeoutMsecs,
        BOOL fForce
        );

    //
    // Start services
    //
    HRESULT Start(
        DWORD dwTimeoutMsecs
        );

    //
    // Reboot
    //
    HRESULT Reboot(
        DWORD dwTimeouMsecs,
        BOOL fForceAppsClosed
        );

    //
    // Status
    //
    HRESULT Status(
        DWORD dwBufferSize,
        LPBYTE pbBuffer,
        DWORD * MDRequiredBufferSize,
        DWORD * pdwNumServices
        );

    //
    // Kill
    //
    HRESULT Kill();

protected:
    virtual HRESULT ApplyProxyBlanket();

protected:
    IIisServiceControl * m_pInterface; 
};


#ifdef KEVLAR
class _EXPORT CWebCluster : public CIISInterface
/*++

Class description:

    IWebCluster warpper

Virtual Interface:

    Succeeded           : Return TRUE if item constructed successfully
    QueryResult         : Return construction error code

--*/
{
//
// Constructor/Destructor
//
public:
    //
    // Fully defined constructor that creates the interface.
    // Use NULL to create the interface on the local computer
    //
    CWebCluster(
        CComAuthInfo * pServer
        );

    //
    // Destructor destroys the interface
    //
    virtual ~CWebCluster();

protected:
    //
    // Create an object in this server. This function initializes the
    // object with DCOM.
    //
    HRESULT Create();

    //
    // Make sure the interface has been created
    //
    BOOL HasInterface() const { return m_pInterface != NULL; }

//
// Interface
//
public:
#if (0) // dantra: 8/17/99 legacy code, not supported by new IWebCluster interfaces
    HRESULT GetParameter( 
        LONG lParamId,
        BSTR bstrParamInfo,
        VARIANT * lpvarParam
        );
    
    HRESULT SetParameter( 
        LONG lParam,
        BSTR bstrParamInfo,
        VARIANT * lpvarResults
        );
#endif
protected:
    virtual HRESULT ApplyProxyBlanket();

protected:
    IWebCluster * m_pInterface; 
};
#endif


//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline void 
CComAuthInfo::StorePassword(LPCOLESTR lpszPassword)
{
    m_bstrPassword = lpszPassword;
}

inline /* virtual */ HRESULT 
CIISInterface::ChangeProxyBlanket(
    LPCOLESTR lpszUserName, 
    LPCOLESTR lpszPassword
    )
{
    m_auth.SetImpersonation(lpszUserName, lpszPassword);
    return ApplyProxyBlanket();
}

inline /*static */ LPCTSTR 
CMetabasePath::GetMachinePath(
    LPCTSTR lpszMDPath,
    CString & strNewPath,
    CString * pstrRemainder
    )
{
    return TruncatePath(iMachine, lpszMDPath, strNewPath, pstrRemainder);
}

inline /* static */ LPCTSTR 
CMetabasePath::GetServicePath(
    LPCTSTR lpszMDPath,
    CString & strNewPath,
    CString * pstrRemainder
    )
{
    return TruncatePath(iService, lpszMDPath, strNewPath, pstrRemainder);
}

inline /* static */ LPCTSTR 
CMetabasePath::GetInstancePath(
    LPCTSTR lpszMDPath,
    CString & strNewPath,
    CString * pstrRemainder
    )
{
    return TruncatePath(iInstance, lpszMDPath, strNewPath, pstrRemainder);
}

inline /* static */ LPCTSTR 
CMetabasePath::GetRootPath(
    LPCTSTR lpszMDPath,
    CString & strNewPath,
    CString * pstrRemainder
    )
{
    return TruncatePath(iRootDirectory, lpszMDPath, strNewPath, pstrRemainder);
}

inline /* virtual */ HRESULT 
CMetaInterface::ApplyProxyBlanket()
{
    return m_auth.ApplyProxyBlanket(m_pInterface);
}

inline HRESULT 
CMetaInterface::OpenKey(
    METADATA_HANDLE hkBase,
    LPCTSTR lpszMDPath,
    DWORD dwFlags,
    METADATA_HANDLE * phMDNewHandle
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->OpenKey(
        hkBase,
        lpszMDPath,
        dwFlags,
        m_iTimeOutValue,
        phMDNewHandle
        );
}

inline HRESULT 
CMetaInterface::CloseKey(
    METADATA_HANDLE hKey
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->CloseKey(hKey);
}

inline HRESULT 
CMetaInterface::SetLastChangeTime( 
    METADATA_HANDLE hMDHandle,
    LPCTSTR pszMDPath,
    FILETIME * pftMDLastChangeTime,
    BOOL bLocalTime
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->SetLastChangeTime(
        hMDHandle,
        pszMDPath,
        pftMDLastChangeTime,
        bLocalTime
        );
}
        
inline HRESULT 
CMetaInterface::GetLastChangeTime( 
     METADATA_HANDLE hMDHandle,
     LPCTSTR lpszMDPath,
    FILETIME * pftMDLastChangeTime,
     BOOL bLocalTime
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->GetLastChangeTime(
        hMDHandle,
        lpszMDPath,
        pftMDLastChangeTime,
        bLocalTime
        );
}

inline HRESULT 
CMetaInterface::AddKey( 
    METADATA_HANDLE hKey,
    LPCTSTR lpszMDPath
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->AddKey(hKey, lpszMDPath);
}

inline HRESULT 
CMetaInterface::DeleteKey(
    METADATA_HANDLE hKey,
    LPCTSTR lpszMDPath
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->DeleteKey(hKey, lpszMDPath);
}

inline HRESULT 
CMetaInterface::DeleteChildKeys(
    METADATA_HANDLE hKey,
    LPCTSTR lpszMDPath
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->DeleteChildKeys(hKey, lpszMDPath);
}

inline HRESULT 
CMetaInterface::EnumKeys(
    METADATA_HANDLE hKey,
    LPCTSTR lpszMDPath,
    LPTSTR lpszMDName,
    DWORD dwIndex
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->EnumKeys(hKey, lpszMDPath, lpszMDName, dwIndex);
}        

inline HRESULT 
CMetaInterface::CopyKey(
    METADATA_HANDLE hSourceKey,
    LPCTSTR lpszMDSourcePath,
    METADATA_HANDLE hDestKey,
    LPCTSTR lpszMDDestPath,
    BOOL fOverwrite,
    BOOL fCopy
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->CopyKey(
        hSourceKey,
        lpszMDSourcePath,
        hDestKey,
        lpszMDDestPath,
        fOverwrite,
        fCopy
        );        
}

inline HRESULT 
CMetaInterface::RenameKey(
    METADATA_HANDLE hKey,
    LPCTSTR lpszMDPath,
    LPCTSTR lpszNewName
    )
{   
    ASSERT_PTR(m_pInterface);     
    return m_pInterface->RenameKey(hKey, lpszMDPath, lpszNewName);
}

inline HRESULT 
CMetaInterface::GetData(
    METADATA_HANDLE hKey,
    LPCTSTR lpszMDPath,
    METADATA_RECORD * pmdRecord,
    DWORD * pdwRequiredDataLen
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->GetData(
        hKey,
        lpszMDPath,
        pmdRecord,
        pdwRequiredDataLen
        );
}

inline HRESULT 
CMetaInterface::SetData(
    METADATA_HANDLE hKey,
    LPCTSTR lpszMDPath,
    METADATA_RECORD * pmdRecord
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->SetData(
        hKey,
        lpszMDPath,
        pmdRecord
        );
}

inline HRESULT 
CMetaInterface::DeleteData(
    METADATA_HANDLE hKey,
    LPCTSTR lpszMDPath,
    DWORD dwMDIdentifier,
    DWORD dwMDDataType
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->DeleteData(
        hKey,
        lpszMDPath,
        dwMDIdentifier,
        dwMDDataType
        );
}

inline HRESULT 
CMetaInterface::EnumData(
    METADATA_HANDLE hKey,
    LPCTSTR lpszMDPath,
    METADATA_RECORD * pmdRecord,
    DWORD dwIndex,
    DWORD * pdwRequiredDataLen
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->EnumData(
        hKey,
        lpszMDPath,
        pmdRecord,
        dwIndex,
        pdwRequiredDataLen
        );
}

inline HRESULT 
CMetaInterface::GetAllData(
    METADATA_HANDLE hKey,
    LPCTSTR lpszMDPath,
    DWORD dwMDAttributes,
    DWORD dwMDUserType,
    DWORD dwMDDataType,
    DWORD * pdwMDNumDataEntries,
    DWORD * pdwMDDataSetNumber,
    DWORD dwMDBufferSize,
    LPBYTE pbMDBuffer,
    DWORD * pdwRequiredBufferSize
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->GetAllData(
        hKey,
        lpszMDPath,
        dwMDAttributes,
        dwMDUserType,
        dwMDDataType,
        pdwMDNumDataEntries,
        pdwMDDataSetNumber,
        dwMDBufferSize,
        pbMDBuffer,
        pdwRequiredBufferSize
        );
}    

inline HRESULT 
CMetaInterface::DeleteAllData( 
    METADATA_HANDLE hKey,
    LPCTSTR lpszMDPath,
    DWORD dwMDUserType,
    DWORD dwMDDataType
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->DeleteAllData(
        hKey, 
        lpszMDPath, 
        dwMDUserType, 
        dwMDDataType
        );
}

inline HRESULT 
CMetaInterface::CopyData( 
    METADATA_HANDLE hMDSourceKey,
    LPCTSTR lpszMDSourcePath,
    METADATA_HANDLE hMDDestKey,
    LPCTSTR lpszMDDestPath,
    DWORD dwMDAttributes,
    DWORD dwMDUserType,
    DWORD dwMDDataType,
    BOOL fCopy
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->CopyData(
        hMDSourceKey,
        lpszMDSourcePath,
        hMDDestKey,
        lpszMDDestPath,
        dwMDAttributes,
        dwMDUserType,
        dwMDDataType,
        fCopy
        );
}

inline HRESULT 
CMetaInterface::GetDataPaths( 
    METADATA_HANDLE hKey,
    LPCTSTR lpszMDPath,
    DWORD dwMDIdentifier,
    DWORD dwMDDataType,
    DWORD dwMDBufferSize,
    LPTSTR lpszBuffer,
    DWORD * pdwMDRequiredBufferSize
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->GetDataPaths(
        hKey,
        lpszMDPath,
        dwMDIdentifier,
        dwMDDataType,
        dwMDBufferSize,
        lpszBuffer,
        pdwMDRequiredBufferSize
        );
}

inline HRESULT 
CMetaInterface::Backup( 
    LPCTSTR lpszBackupLocation,
    DWORD dwMDVersion,
    DWORD dwMDFlags
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->Backup(lpszBackupLocation, dwMDVersion, dwMDFlags);
}

inline HRESULT 
CMetaInterface::Restore(    
    LPCTSTR lpszBackupLocation,
    DWORD dwMDVersion,
    DWORD dwMDFlags
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->Restore(lpszBackupLocation, dwMDVersion, dwMDFlags);
}

inline HRESULT 
CMetaInterface::EnumBackups(
    LPTSTR lpszBackupLocation,
    DWORD * pdwMDVersion,
    FILETIME * pftMDBackupTime,
     DWORD dwIndex
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->EnumBackups(
        lpszBackupLocation,
        pdwMDVersion,
        pftMDBackupTime,
        dwIndex
        );    
}

inline HRESULT 
CMetaInterface::DeleteBackup(
    LPCTSTR lpszBackupLocation,
    DWORD dwMDVersion
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->DeleteBackup(lpszBackupLocation, dwMDVersion);
}        

inline HRESULT 
CMetaKey::AddKey(
    LPCTSTR lpszMDPath
    )
{
    return CMetaInterface::AddKey(m_hKey, lpszMDPath);    
}

inline HRESULT 
CMetaKey::DeleteKey(
    LPCTSTR lpszMDPath
    )
{
    return CMetaInterface::DeleteKey(m_hKey, lpszMDPath);    
}

inline HRESULT 
CMetaKey::RenameKey(
    LPCTSTR lpszMDPath,
    LPCTSTR lpszNewName
    )
{
    return CMetaInterface::RenameKey(m_hKey, lpszMDPath, lpszNewName);    
}

inline HRESULT 
CMetaKey::ReOpen()
{
    return Open(m_dwFlags, m_strMetaPath, m_hBase);
}

inline HRESULT 
CMetaKey::ReOpen(DWORD dwFlags)
{
    return Open(dwFlags, m_strMetaPath, m_hBase);
}

inline BOOL 
CMetaKey::IsHomeDirectoryPath() const
{ 
    return CMetabasePath::IsHomeDirectoryPath(m_strMetaPath); 
}

inline HRESULT 
CMetaKey::QueryValue(
    DWORD dwID, 
    BOOL & fValue,
    BOOL * pfInheritanceOverride,
    LPCTSTR lpszMDPath,
    DWORD * pdwAttributes        
    )
{
    ASSERT(sizeof(DWORD) == sizeof(BOOL));
    return CMetaKey::QueryValue(
        dwID, 
        (DWORD &)fValue, 
        pfInheritanceOverride, 
        lpszMDPath,
        pdwAttributes
        );
}

inline HRESULT 
CMetaKey::SetValue(
    DWORD dwID,
    DWORD dwValue,
    BOOL * pfInheritanceOverride,    OPTIONAL
    LPCTSTR lpszMDPath               OPTIONAL
    )
{
    return SetPropertyValue(
        dwID, 
        sizeof(dwValue), 
        &dwValue, 
        pfInheritanceOverride,
        lpszMDPath
        );
}

inline HRESULT 
CMetaKey::SetValue(
    DWORD dwID,
    BOOL fValue,
    BOOL * pfInheritanceOverride,
    LPCTSTR lpszMDPath
    )
{
    ASSERT(sizeof(DWORD) == sizeof(BOOL));
    return CMetaKey::SetValue(
        dwID,
        (DWORD)fValue,
        pfInheritanceOverride,
        lpszMDPath
        );
}

inline HRESULT 
CMetaKey::SetValue(
    DWORD dwID,
    CString & strValue,
    BOOL * pfInheritanceOverride,    OPTIONAL
    LPCTSTR lpszMDPath               OPTIONAL
    )
{
    return SetPropertyValue(
        dwID,
        (strValue.GetLength() + 1) * sizeof(TCHAR),
        (void *)(LPCTSTR)strValue,
        pfInheritanceOverride,
        lpszMDPath
        );
}

inline HRESULT 
CWamInterface::AppDelete( 
    LPCTSTR szMDPath,
    BOOL fRecursive
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->AppDelete(szMDPath, fRecursive);
}

inline HRESULT 
CWamInterface::AppUnLoad( 
    LPCTSTR szMDPath,
    BOOL fRecursive
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->AppUnLoad(szMDPath, fRecursive);
}

inline HRESULT 
CWamInterface::AppGetStatus( 
    LPCTSTR szMDPath,
    DWORD * pdwAppStatus
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->AppGetStatus(szMDPath, pdwAppStatus);
}

inline HRESULT 
CWamInterface::AppDeleteRecoverable( 
    LPCTSTR szMDPath,
    BOOL fRecursive
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->AppDeleteRecoverable(szMDPath, fRecursive);
}

inline HRESULT 
CWamInterface::AppRecover( 
    LPCTSTR szMDPath,
    BOOL fRecursive
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->AppRecover(szMDPath, fRecursive);
}

inline /* virtual */ HRESULT 
CWamInterface::ApplyProxyBlanket()
{
    return m_auth.ApplyProxyBlanket(m_pInterface);
}

inline /* virtual */ HRESULT 
CMetaBack::ApplyProxyBlanket()
{
    HRESULT hr = CMetaInterface::ApplyProxyBlanket();
    return SUCCEEDED(hr) ? CWamInterface::ApplyProxyBlanket() : hr;
}

inline HRESULT 
CMetaBack::Next(
    DWORD * pdwVersion,
    LPTSTR lpszLocation,
    FILETIME * pftBackupTime
    )
{
    return EnumBackups(
        lpszLocation,
        pdwVersion,
        pftBackupTime,
        m_dwIndex++
        );
}

inline HRESULT 
CMetaBack::Backup(
    LPCTSTR lpszLocation
    )
{
    return CMetaInterface::Backup(
        lpszLocation, 
        MD_BACKUP_NEXT_VERSION, 
        MD_BACKUP_SAVE_FIRST
        );
}

inline HRESULT 
CMetaBack::Delete(
    LPCTSTR lpszLocation,
    DWORD dwVersion
    )
{
    return DeleteBackup(lpszLocation, dwVersion);
}

inline BOOL 
CIISApplication::IsEnabledApplication() const
{
    return m_dwAppState == APPSTATUS_STOPPED 
        || m_dwAppState == APPSTATUS_RUNNING;
}

inline HRESULT 
CIISApplication::Delete(
    BOOL fRecursive
    )
{
    ASSERT(!m_strWamPath.IsEmpty());
    return AppDelete(m_strWamPath, fRecursive);
}

inline HRESULT 
CIISApplication::Unload(
    BOOL fRecursive
    )
{
    ASSERT(!m_strWamPath.IsEmpty());
    return AppUnLoad(m_strWamPath, fRecursive);
}

inline HRESULT 
CIISApplication::DeleteRecoverable(
    BOOL fRecursive
    )
{
    ASSERT(!m_strWamPath.IsEmpty());
    return AppDeleteRecoverable(m_strWamPath, fRecursive);
}

inline HRESULT 
CIISApplication::Recover(
    BOOL fRecursive
    )
{
    ASSERT(!m_strWamPath.IsEmpty());
    return AppRecover(m_strWamPath, fRecursive);
}

inline HRESULT 
CIISSvcControl::Stop(
    DWORD dwTimeoutMsecs,
    BOOL fForce
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->Stop(dwTimeoutMsecs, (DWORD)fForce);
}

inline HRESULT 
CIISSvcControl::Start(
    DWORD dwTimeoutMsecs
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->Start(dwTimeoutMsecs);
}

inline HRESULT 
CIISSvcControl::Reboot(
    DWORD dwTimeouMsecs,
    BOOL fForceAppsClosed
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->Reboot(dwTimeouMsecs, (DWORD)fForceAppsClosed);
}

inline HRESULT 
CIISSvcControl::Status(
    DWORD dwBufferSize,
    LPBYTE pbBuffer,
    DWORD * MDRequiredBufferSize,
    DWORD * pdwNumServices
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->Status(
        dwBufferSize, 
        pbBuffer,
        MDRequiredBufferSize,
        pdwNumServices
        );
}

inline HRESULT 
CIISSvcControl::Kill()
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->Kill();
}

inline /* virtual */ HRESULT 
CIISSvcControl::ApplyProxyBlanket()
{
    return m_auth.ApplyProxyBlanket(m_pInterface);
}

#ifdef KEVLAR
inline HRESULT 
CWebCluster::Create()
{
    return CIISInterface::Create(
        1,
        &IID_IWebCluster, 
        &CLSID_WebCluster, 
        NULL, 
        (IUnknown **)&m_pInterface
        );
}

inline /* virtual */ HRESULT 
CWebCluster::ApplyProxyBlanket()
{
    return m_auth.ApplyProxyBlanket(m_pInterface);
}
#if (0)  // dantra: 8/17/99 - legacy
inline HRESULT 
CWebCluster::GetParameter( 
    LONG lParamId,
    BSTR bstrParamInfo,
    VARIANT * lpvarParam
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->GetParameter(lParamId, bstrParamInfo, lpvarParam);
}
    
inline HRESULT 
CWebCluster::SetParameter( 
    LONG lParam,
    BSTR bstrParamInfo,
    VARIANT * lpvarResults
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->SetParameter(lParam, bstrParamInfo, lpvarResults);
}

#endif // 0
#endif // KEVLAR

#endif // _MDKEYS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\common2\inheritancedlg.h ===
/*++

   Copyright    (c)    1994-2000    Microsoft Corporation

   Module  Name :

        inheritancedlg.h

   Abstract:

        Inheritance Dialog Definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

#ifndef __INHERITANCEDLG__H__
#define __INHERITANCEDLG__H__


class CListBoxNodes : public CWindowImpl<CListBoxNodes, CListBox>
{
public:
   BEGIN_MSG_MAP(CListBoxNodes)
   END_MSG_MAP()
};

/*++

Class Description:

    Inheritance override checker dialog.

Public Interface:

    CInheritanceDlg         : Constructor
    IsEmpty                 : Check to see if there are overrides.

Notes:

    There are two constructors.  One which assumes GetDataPaths() has
    already been called, and which takes the results from GetDataPaths()
    as a CStringList, and a second constructor which will make the GetDataPaths
    automatically.

    In either case, the calling process should check IsEmpty() right after
    constructing the dialog to see if DoModal() needs to be called.  If
    IsEmpty() returns TRUE, there's no reason to call DoModal().

--*/
class CInheritanceDlg : 
   public CDialogImpl<CInheritanceDlg>,
   public CWinDataExchange<CInheritanceDlg>
{
//
// fWrite parameter helper definitions
//
#define FROM_WRITE_PROPERTY     (TRUE)
#define FROM_DELETE_PROPERTY    (FALSE)

//
// Construction
//
public:
   CInheritanceDlg() :
      m_fWrite(FALSE), m_fEmpty(FALSE), m_fHasInstanceInMaster(FALSE), m_fUseTable(FALSE),
      m_dwMDIdentifier(0), m_dwMDAttributes(0), m_dwMDUserType(0), m_dwMDDataType(0),
      m_mk((CComAuthInfo *)NULL)
   {
   }
   //
   // Standard constructor (GetDataPaths() already called)
   //
   CInheritanceDlg(
         DWORD dwMetaID,
         BOOL fWrite,
         CComAuthInfo * pAuthInfo,
         LPCTSTR lpstrMetaRoot,
         CStringListEx & strlMetaChildNodes,
         LPCTSTR lpstrPropertyName = NULL,
         HWND hwndParent = NULL
         );

    //
    // Constructor which will call GetDataPaths()
    //
    CInheritanceDlg(
         DWORD dwMetaID,
         BOOL fWrite,
         CComAuthInfo * pAuthInfo,
         LPCTSTR lpstrMetaRoot,
         LPCTSTR lpstrPropertyName            = NULL,
         HWND hwndParent                      = NULL
         );

    //
    // Constructor which will call GetDataPaths(), and which
    // does not use the predefined property table unless
    // fTryToFindInTable is TRUE, in which case it will attempt
    // to use the table first, and use the specified parameters
    // only if the property ID is not found in the table.
    //
    CInheritanceDlg(
         BOOL    fTryToFindInTable,
         DWORD   dwMDIdentifier,
         DWORD   dwMDAttributes,
         DWORD   dwMDUserType,
         DWORD   dwMDDataType,
         LPCTSTR lpstrPropertyName,
         BOOL    fWrite,
         CComAuthInfo * pAuthInfo,
         LPCTSTR lpstrMetaRoot,
         HWND    hwndParent = NULL                     
         );
public:
    enum { IDD = IDD_INHERITANCE };
    //
    // Check to see if there's a reason to continue displaying
    // the dialog.
    //
    BOOL IsEmpty() const { return m_fEmpty; }

//
// Dialog Data
//
protected:
    CListBoxNodes m_list_ChildNodes;

//
// Implementation
//
protected:
   BEGIN_MSG_MAP_EX(CInheritanceDlg)
      MSG_WM_INITDIALOG(OnInitDialog)
      COMMAND_HANDLER_EX(IDOK, BN_CLICKED, OnOK)
      COMMAND_HANDLER_EX(IDC_BUTTON_SELECT_ALL, BN_CLICKED, OnButtonSelectAll)
   END_MSG_MAP()

   LRESULT OnInitDialog(HWND hwnd, LPARAM lParam);
   void OnOK(WORD wNotifyCode, WORD wID, HWND hwndCtrl);
   void OnButtonSelectAll(WORD wNotifyCode, WORD wID, HWND hwndCtrl);

   BEGIN_DDX_MAP(CInheritanceDlg)
      DDX_CONTROL(IDC_LIST_CHILD_NODES, m_list_ChildNodes)
   END_DDX_MAP()

   void Initialize();
   HRESULT GetDataPaths();

   BOOL FriendlyInstance(
        IN  CString & strMetaRoot,
        OUT CString & strFriendly
        );

   CString & CleanDescendantPath(
        IN OUT CString & strMetaPath
        );

private:
   BOOL    m_fWrite;
   BOOL    m_fEmpty;
   BOOL    m_fHasInstanceInMaster;
   BOOL    m_fUseTable;
   DWORD   m_dwMDIdentifier;
   DWORD   m_dwMDAttributes;
   DWORD   m_dwMDUserType;
   DWORD   m_dwMDDataType;
   CString m_strMetaRoot;
   //CString m_strServer;
   CString m_strPropertyName;
   CStringListEx m_strlMetaChildNodes;
   CMetaKey m_mk;
};


#endif // __INHERITANCEDLG__H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\common2\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by iisuihelper.rc
//
#define IDS_PROJNAME                    100
#define IDS_APP_TITLE                   101
#define IDS_NO_MESSAGE                  102
#define IDR_AUTHINFO                    103
#define IDC_LIST_CHILD_NODES            11042
#define IDC_BUTTON_SELECT_ALL           11043
#define IDC_STATIC_PROMPT               11044
#define IDD_INHERITANCE                 15012
#define IDS_INHERITANCE_NO_NAME         20112
#define IDS_INHERITANCE_PROMPT          20113
#define IDS_FMT_SECURITY                20127
#define IDS_MD_CONNECTION_TIMEOUT       20200
#define IDS_MD_MAX_CONNECTIONS          20201
#define IDS_MD_SERVER_COMMENT           20202
#define IDS_MD_SERVER_SIZE              20203
#define IDS_MD_SERVER_LISTEN_BACKLOG    20204
#define IDS_MD_SERVER_LISTEN_TIMEOUT    20205
#define IDS_MD_APP_FRIENDLY_NAME        20207
#define IDS_MD_APP_ROOT                 20208
#define IDS_MD_APP_ISOLATED             20209
#define IDS_MD_VR_PATH                  20210
#define IDS_MD_VR_USERNAME              20211
#define IDS_MD_VR_PASSWORD              20212
#define IDS_MD_EXIT_MESSAGE             20213
#define IDS_MD_GREETING_MESSAGE         20214
#define IDS_MD_MAX_CLIENTS_MESSAGE      20215
#define IDS_MD_MSDOS_DIR_OUTPUT         20216
#define IDS_MD_ALLOW_ANONYMOUS          20217
#define IDS_MD_ANONYMOUS_ONLY           20218
#define IDS_MD_LOG_ANONYMOUS            20219
#define IDS_MD_LOG_NONANONYMOUS         20220
#define IDS_MD_AUTHORIZATION            20221
#define IDS_MD_REALM                    20222
#define IDS_MD_HTTP_EXPIRES             20223
#define IDS_MD_HTTP_PICS                20224
#define IDS_MD_HTTP_CUSTOM              20225
#define IDS_MD_DIRECTORY_BROWSING       20226
#define IDS_MD_DEFAULT_LOAD_FILE        20227
#define IDS_MD_CONTENT_NEGOTIATION      20228
#define IDS_MD_CUSTOM_ERROR             20229
#define IDS_MD_FOOTER_DOCUMENT          20230
#define IDS_MD_FOOTER_ENABLED           20231
#define IDS_MD_HTTP_REDIRECT            20232
#define IDS_MD_DEFAULT_LOGON_DOMAIN     20233
#define IDS_MD_LOGON_METHOD             20234
#define IDS_MD_SCRIPT_MAPS              20235
#define IDS_MD_MIME_MAP                 20236
#define IDS_MD_ACCESS_PERM              20237
#define IDS_MD_HEADER_DOCUMENT          20238
#define IDS_MD_HEADER_ENABLED           20239
#define IDS_MD_IP_SEC                   20240
#define IDS_MD_ANONYMOUS_USER_NAME      20241
#define IDS_MD_ANONYMOUS_PWD            20242
#define IDS_MD_ANONYMOUS_USE_SUBAUTH    20243
#define IDS_MD_DONT_LOG                 20244
#define IDS_MD_ADMIN_ACL                20245
#define IDS_MD_SSI_EXEC_DISABLED        20246
#define IDS_MD_SSL_ACCESS_PERM          20247
#define IDS_MD_NTAUTHENTICATION_PROVIDERS 20248
#define IDS_MD_SCRIPT_TIMEOUT           20249
#define IDS_MD_CACHE_EXTENSIONS         20250
#define IDS_MD_CREATE_PROCESS_AS_USER   20251
#define IDS_MD_CREATE_PROC_NEW_CONSOLE  20252
#define IDS_MD_POOL_IDC_TIMEOUT         20253
#define IDS_MD_ALLOW_KEEPALIVES         20254
#define IDS_MD_IS_CONTENT_INDEXED       20255
#define IDS_ASP_BUFFERINGON             20256
#define IDS_ASP_LOGERRORREQUESTS        20257
#define IDS_ASP_SCRIPTERRORSSENTTOBROWSER 20258
#define IDS_ASP_SCRIPTERRORMESSAGE      20259
#define IDS_ASP_SCRIPTFILECACHESIZE     20260
#define IDS_ASP_SCRIPTENGINECACHEMAX    20261
#define IDS_ASP_SCRIPTTIMEOUT           20262
#define IDS_ASP_SESSIONTIMEOUT          20263
#define IDS_ASP_ENABLEPARENTPATHS       20264
#define IDS_ASP_ALLOWSESSIONSTATE       20265
#define IDS_ASP_SCRIPTLANGUAGE          20266
#define IDS_ASP_EXCEPTIONCATCHENABLE    20267
#define IDS_ASP_ENABLESERVERDEBUG       20268
#define IDS_ASP_ENABLECLIENTDEBUG       20269
#define IDS_MD_LOG_PLUGIN_ORDER         20270
#define IDS_MD_LOGEXT_FIELD_MASK        20271
#define IDS_MD_LOG_TYPE                 20272
#define IDS_MD_LOGFILE_DIRECTORY        20273
#define IDS_MD_LOGFILE_PERIOD           20274
#define IDS_MD_LOGFILE_TRUNCATE_SIZE    20275
#define IDS_MD_LOGSQL_DATA_SOURCES      20276
#define IDS_MD_LOGSQL_TABLE_NAME        20277
#define IDS_MD_LOGSQL_USER_NAME         20278
#define IDS_MD_LOGSQL_PASSWORD          20279
#define IDS_MD_CPU_LIMITS_ENABLED       20280
#define IDS_MD_CPU_LIMIT_LOGEVENT       20281
#define IDS_MD_CPU_LIMIT_PRIORITY       20282
#define IDS_MD_CPU_LIMIT_PAUSE          20283
#define IDS_MD_CPU_LIMIT_PROCSTOP       20284
#define IDS_MD_LOGFILE_LOCALTIME_ROLLOVER 20285
#define IDS_MD_CPU_LOGGING_MASK         20286
#define ID_HELP                         0xE146

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           104
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\common2\utcls.cpp ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        utcls.cpp

   Abstract:

        Internet Properties base classes

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager (cluster edition)

   Revision History:

--*/


//
// Include Files
//
#include "stdafx.h"
#include "common.h"
//#include "idlg.h"

#include "mmc.h"

extern "C"
{
    #include <lm.h>
}

#define SZ_REG_KEY_BASE  _T("Software\\Microsoft\\%s")


BOOL
IsServerLocal(
    IN LPCTSTR lpszServer
    )
/*++

Routine Description:

    Check to see if the given name refers to the local machine

Arguments:

    LPCTSTR lpszServer   : Server name

Return Value:

    TRUE if the given name refers to the local computer, FALSE otherwise

Note:

    Doesn't work if the server is an ip address

--*/
{
    TCHAR szComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD dwSize = sizeof(szComputerName);

    //
    // CODEWORK(?): we're not checking for all the ip addresses
    //              on the local box or full dns names.
    //
    //              Try GetComputerNameEx when we're building with NT5 
    //              settings.
    //
    return (!lstrcmpi(_T("localhost"), PURE_COMPUTER_NAME(lpszServer))
         || !lstrcmp( _T("127.0.0.1"), PURE_COMPUTER_NAME(lpszServer)))
         || (GetComputerName(szComputerName, &dwSize) 
             && !lstrcmpi(szComputerName, PURE_COMPUTER_NAME(lpszServer)));
}



BOOL
GetVolumeInformationSystemFlags(
    IN  LPCTSTR lpszPath,
    OUT DWORD * pdwSystemFlags
    )
/*++

Routine Description:

    Get the system flags for the path in question

Arguments:

    LPCTSTR lpszPath            : Path
    DWORD * pdwSystemFlags      : Returns system flags

Return Value:

    TRUE for success, FALSE for failure.

--*/
{
    ASSERT_WRITE_PTR(pdwSystemFlags);

    TRACE("Getting system flags for %s\n", lpszPath);

    DWORD dwMaxComponentLength;
    TCHAR szRoot[MAX_PATH + 1];
    TCHAR szFileSystem[MAX_PATH + 1];

    //
    // Generating root path
    //
    if (PathIsUNC(lpszPath))
    {
        //
        // Root path of a UNC path is \\foo\bar\
        //
        ASSERT(lstrlen(lpszPath) < MAX_PATH);

        int cSlashes = 0;
        LPCTSTR lpszSrc = lpszPath;
        LPTSTR lpszDst = szRoot;

        while (cSlashes < 4 && *lpszSrc)
        {
            if ((*lpszDst++ = *lpszSrc++) == '\\')
            {
                ++cSlashes;
            }
        }    

        if (!*lpszSrc)
        {
            *lpszDst++ = '\\';
        }

        *lpszDst = '\0';
    }
    else
    {
        ::wsprintf(szRoot, _T("%c:\\"), *lpszPath);
    }

    TRACE("Root path is %s\n", szRoot);
    
    return ::GetVolumeInformation(
        szRoot,
        NULL,
        0,
        NULL,
        &dwMaxComponentLength,
        pdwSystemFlags,
        szFileSystem,
        sizeof(szFileSystem) / sizeof(TCHAR)
        );
}



LPCTSTR
GenerateRegistryKey(
    OUT CString & strBuffer,
    IN  LPCTSTR lpszSubKey OPTIONAL
    )
/*++

Routine Description:

    Generate a registry key name based on the current app, and a
    provided subkey (optional)

Arguments:

    CString & strBuffer : Buffer to create registry key name into.
    LPCTSTR lpszSubKey  : Subkey name or NULL

Return Value:

    Pointer to the registry key value 

--*/
{
    try
    {
        //
        // Use the app name as the primary registry name
        //
       CString app_name;
       app_name.LoadString(_Module.GetResourceInstance(), IDS_APP_TITLE);
       strBuffer.Format(SZ_REG_KEY_BASE, app_name);

        if (lpszSubKey)
        {
            strBuffer += _T("\\");
            strBuffer += lpszSubKey;
        }

        TRACE("Registry key is %s\n", strBuffer);
    }
    catch(std::bad_alloc)
    {
        TRACEEOLID("!!!exception building regkey");
        return NULL;
    }

    return strBuffer;
}


static int
CountCharsToDoubleNull(
    IN LPCTSTR lp
    )
/*++

Routine Description:

    Count TCHARS up to and including the double NULL.

Arguments:

    LPCTSTR lp       : TCHAR Stream

Return Value:

    Number of chars up to and including the double NULL

--*/
{
    int cChars = 0;

    for(;;)
    {
        ++cChars;

        if (lp[0] == _T('\0') && lp[1] == _T('\0'))
        {
            return ++cChars;
        }

        ++lp;
    }
}

CStringListEx::CStringListEx() : std::list<CString> ()
{
}

CStringListEx::~CStringListEx()
{
}

void
CStringListEx::PushBack(LPCTSTR str)
{
   push_back(str);
}

void
CStringListEx::Clear()
{
   clear();
}

DWORD
CStringListEx::ConvertFromDoubleNullList(LPCTSTR lpstrSrc, int cChars)
/*++

Routine Description:

    Convert a double null terminate list of null terminated strings to a more
    manageable CStringList

Arguments:

    LPCTSTR lpstrSrc       : Source list of strings
    int cChars             : Number of characters in double NULL list. if
                             -1, autodetermine length

Return Value:

    ERROR_SUCCESS           if the list was converted properly
    ERROR_INVALID_PARAMETER if the list was empty
    ERROR_NOT_ENOUGH_MEMORY if there was a mem exception

--*/
{
    DWORD err = ERROR_SUCCESS;

    if (lpstrSrc == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (cChars < 0)
    {
        //
        // Calculate our own size.  This might be off if multiple
        // blank linkes (0) appear in the multi_sz, so the character
        // size is definitely preferable
        //
        cChars = CountCharsToDoubleNull(lpstrSrc);
    }

    try
    {
        clear();

        if (cChars == 2 && *lpstrSrc == _T('\0'))
        {
            //
            // Special case: MULTI_SZ containing only
            // a double NULL are in fact blank entirely.
            //
            // N.B. IMHO this is a metabase bug -- RonaldM
            //
            --cChars;
        }

        //
        // Grab strings until only the final NULL remains
        //
        while (cChars > 1)
        {
            CString strTmp = lpstrSrc;
            push_back(strTmp);
            lpstrSrc += (strTmp.GetLength() + 1);
            cChars -= (strTmp.GetLength() + 1);
        }
    }
    catch(std::bad_alloc)
    {
        TRACEEOLID("!!! exception building stringlist");
        err = ERROR_NOT_ENOUGH_MEMORY;
    }

    return err;
}



DWORD
CStringListEx::ConvertToDoubleNullList(
    OUT DWORD & cchDest,
    OUT LPTSTR & lpstrDest
    )
/*++

Routine Description:

    Flatten the string list into a double null terminated list
    of null terminated strings.

Arguments:

    CStringList & strlSrc : Source string list
    DWORD & cchDest       : Size in characters of the resultant array
                            (including terminating NULLs)
    LPTSTR & lpstrDest    : Allocated flat array.

Return Value:

    ERROR_SUCCESS           if the list was converted properly
    ERROR_INVALID_PARAMETER if the list was empty
    ERROR_NOT_ENOUGH_MEMORY if there was a mem exception

--*/
{
    cchDest = 0;
    lpstrDest = NULL;
    BOOL fNullPad = FALSE;

    //
    // Compute total size in characters
    //
    CStringListEx::iterator it = begin();

    while (it != end())
    {
        CString & str = (*it++);

//        TRACEEOLID(str);

        cchDest += str.GetLength() + 1;
    }

    if (!cchDest)
    {
        //
        // Special case: A totally empty MULTI_SZ
        // in fact consists of 2 (final) NULLS, instead
        // of 1 (final) NULL.  This is required by the
        // metabase, but should be a bug.  See note
        // at reversal function above.
        //
        ++cchDest;
        fNullPad = TRUE;
    }

    //
    // Remember final NULL
    //
    cchDest += 1;

    lpstrDest = new TCHAR[cchDest];
    if (lpstrDest == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    LPTSTR pch = lpstrDest;
    it = begin();
    while (it != end())
    {
        CString & str = (*it++);

        lstrcpy(pch, (LPCTSTR)str);
        pch += str.GetLength();
        *pch++ = _T('\0');
    }

    *pch++ = _T('\0');

    if (fNullPad)
    {
        *pch++ = _T('\0');
    }

    return ERROR_SUCCESS;
}






//
// CBlob Implementation
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


CBlob::CBlob() 
/*++

Routine Description:

    NULL constructor

Arguments:

    None

Return Value:

    N/A

--*/
    : m_pbItem(NULL), 
      m_dwSize(0L)
{
}



CBlob::CBlob(
    IN DWORD dwSize,
    IN PBYTE pbItem,
    IN BOOL fMakeCopy
    )
/*++

Routine Description:

    Constructor

Arguments:

    DWORD dwSize        : Size of memory block
    PBYTE pbItem        : Pointer to memory block
    BOOL fMakeCopy      : If TRUE, makes a copy of the memory block.
                          If FALSE, takes ownership of the pointer.

Return Value:

    N/A

--*/
    : m_pbItem(NULL),
      m_dwSize(0L)
{
    SetValue(dwSize, pbItem, fMakeCopy);
}



CBlob::CBlob(
    IN const CBlob & blob
    )
/*++

Routine Description:

    Copy constructor

Arguments:

    const CBlob & blob      : Source blob

Return Value:

    N/A

Notes:

    This contructor makes a copy of the memory block in question.

--*/
    : m_pbItem(NULL),
      m_dwSize(0L)
{
    SetValue(blob.GetSize(), blob.m_pbItem, TRUE);
}



void
CBlob::SetValue(
    IN DWORD dwSize,
    IN PBYTE pbItem,
    IN BOOL fMakeCopy OPTIONAL
    )
/*++

Routine Description:

    Assign the value to this binary object.  If fMakeCopy is FALSE,
    the blob will take ownership of the pointer, otherwise a copy
    will be made.

Arguments:

    DWORD dwSize        : Size in bytes
    PBYTE pbItem        : Byte streadm
    BOOL fMakeCopy      : If true, make a copy, else assign pointer

Return Value:

    None

--*/
{
    ASSERT_READ_PTR2(pbItem, dwSize);

    if (!IsEmpty())
    {
        TRACEEOLID("Assigning value to non-empty blob.  Cleaning up");
        CleanUp();
    }

    if (dwSize > 0L)
    {
        //
        // Make private copy
        //
        m_dwSize = dwSize;

        if (fMakeCopy)
        {
            m_pbItem = new BYTE[m_dwSize];
            if (NULL != m_pbItem)
               CopyMemory(m_pbItem, pbItem, dwSize);
        }
        else
        {
            m_pbItem = pbItem;
        }
    }
}



void 
CBlob::CleanUp()
/*++

Routine Description:

    Delete data pointer, and reset pointer and size.

Arguments:

    None

Return Value:

    None

--*/
{
    if (m_pbItem)
    {
        delete [] m_pbItem;
    }

    m_pbItem = NULL;
    m_dwSize = 0L;
}



CBlob & 
CBlob::operator =(
    IN const CBlob & blob
    )
/*++

Routine Description:

    Assign values from another CBlob. 

Arguments:

    const CBlob & blob      : Source blob

Return Value:

    Reference to this object

--*/
{
    //
    // Make copy of data
    //
    SetValue(blob.GetSize(), blob.m_pbItem, TRUE);

    return *this;
}



BOOL 
CBlob::operator ==(
    IN const CBlob & blob
    ) const
/*++

Routine Description:
    
    Compare two binary large objects.  In order to match, the objects
    must be the same size, and byte identical.

Arguments:

    const CBlob & blob      : Blob to compare against.

Return Value:

    TRUE if the objects match, FALSE otherwise.

--*/
{
    if (GetSize() != blob.GetSize())
    {
        return FALSE;
    }

    return memcmp(m_pbItem, blob.m_pbItem, GetSize()) == 0;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\comprop\comprop.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        comprop.h

   Abstract:

        Common properties header file

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

#ifndef __COMPROP_H__
#define __COMPROP_H__

#ifdef _COMEXPORT
    #define COMDLL __declspec(dllexport)
#elif defined(_COMIMPORT)
    #define COMDLL __declspec(dllimport)
#elif defined(_COMSTATIC)
    #define COMDLL
#else
    #error "Must define either _COMEXPORT, _COMIMPORT or _COMSTATIC"
#endif // _COMEXPORT

#pragma warning(disable: 4275)
#pragma warning(disable: 4251)


#include "..\comprop\resource.h"    // Be specific...

#include <lmcons.h>
#include <iis64.h>
#include "inetcom.h"
#include "iisinfo.h"
#include "apiutil.h"
#include "svcloc.h"
#include "svrinfo.h"

//
// Memory Allocation Macros
//
#define AllocMem(cbSize)\
    ::LocalAlloc(LPTR, cbSize)

#define FreeMem(lp)\
    ::LocalFree(lp)

#define AllocMemByType(citems, type)\
    (type *)AllocMem(citems * sizeof(type))

//
// Program flow macros
//
#define FOREVER for(;;)

#define BREAK_ON_ERR_FAILURE(err)\
    if (err.Failed()) break;

#define BREAK_ON_NULL_PTR(lp)\
    if (lp == NULL) break;

#define SAFE_DELETE(obj)\
    if (obj != NULL) do { delete obj; obj = NULL; } while(0)

#define SAFE_FREEMEM(lp)\
    if (lp != NULL) do { FreeMem(lp); lp = NULL; } while(0)

#define SAFE_SYSFREESTRING(lp)\
    if (lp != NULL) do { ::SysFreeString(lp); lp = NULL; } while(0)

#define SAFE_AFXFREELIBRARY(hLib)\
    if (hLib != NULL) do { ::AfxFreeLibrary(hLib); hLib = NULL; } while(0)

#define SAFE_RELEASE(lpInterface)\
    if (lpInterface != NULL) do { lpInterface->Release(); } while(0)

#define SAFE_RELEASE_SETTONULL(lpInterface)\
    if (lpInterface != NULL) do { lpInterface->Release(); lpInterface = NULL; } while(0)

//
// General purpose files
//
#include "strfn.h"
#include "objplus.h"
#include "odlbox.h"
#include "msg.h"
#include "debugafx.h"
#include "mdkeys.h"
#include "ipa.h"
#include "inetprop.h"
#include "wizard.h"
#include "pwiz.h"
#include "registry.h"
#include "ddxv.h"
#include "mime.h"
#include "usrbrows.h"
#include "sitesecu.h"
#include "ipctl.h"
#include "dtp.h"

#ifdef _COMSTATIC
#define COMPROP_DLL_NAME (NULL)
#else
#define COMPROP_DLL_NAME _T("IISUI.DLL")
#endif // _COMSTATIC

extern "C" void WINAPI InitIISUIDll();
extern HINSTANCE hDLLInstance;

#endif // __COMPROP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\comprop\debugafx.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        debugafx.h

   Abstract:

        Debugging routines using AFX/MFC extensions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

#ifndef _DEBUGAFX_H
#define _DEBUGAFX_H

//
// ENUM for special debug output control tokens
//
enum ENUM_DEBUG_AFX 
{ 
    EDBUG_AFX_EOL = -1 
};

//
// Debug Formatting Macros
//
#if defined(_DEBUG)

   #define TRACEFMTPGM        DbgFmtPgm( THIS_FILE, __LINE__ )
   #define TRACEOUT(x)        { afxDump << x; }
   #define TRACEEOL(x)        { afxDump << x << EDBUG_AFX_EOL; }
   #define TRACEEOLID(x)      { afxDump << TRACEFMTPGM << x << EDBUG_AFX_EOL; }
   #define TRACEEOLERR(err,x) { if (err) TRACEEOLID(x) }

#else

   #define TRACEOUT(x)        { ; }
   #define TRACEEOL(x)        { ; }
   #define TRACEEOLID(x)      { ; }
   #define TRACEEOLERR(err,x) { ; }

#endif

//
// Append an EOL onto the debug output stream
//
COMDLL CDumpContext & operator <<(
    IN CDumpContext & out,
    IN ENUM_DEBUG_AFX edAfx
    );

#ifndef UNICODE

COMDLL CDumpContext & operator <<(
    IN CDumpContext & out,
    IN LPCWSTR pwchStr
    );

#endif UNICODE

//
// Format a program name and line number for output (removes the path info)
//
COMDLL extern LPCSTR
DbgFmtPgm (
    IN LPCSTR szFn,
    IN int line
    );

COMDLL CDumpContext & operator <<(
    IN CDumpContext & out,
    IN const GUID & guid
    );

#endif // _DEBUGAFX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\comprop\ddxv.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        ddxv.h

   Abstract:

        DDX/DDV Routine definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

#ifndef _DDXV_H_
#define _DDXV_H_

//
// Helper macro to convert ID of dialog child control to window handle
//
#define CONTROL_HWND(nID) (::GetDlgItem(m_hWnd, nID))

//
// Dummy password
//
COMDLL extern LPCTSTR g_lpszDummyPassword;

//
// Enforce minimum string length of a CString
//
COMDLL void 
AFXAPI DDV_MinChars(
    IN CDataExchange * pDX, 
    IN CString const & value, 
    IN int nChars
    );

//
// Enforce minimum and maximum string lengths of a CString
//
COMDLL void 
AFXAPI DDV_MinMaxChars(
    IN CDataExchange * pDX, 
    IN CString const & value,
    IN int nMinChars,
    IN int nMaxChars
    );

//
// Spin control ddx
//
COMDLL void 
AFXAPI DDX_Spin(
    IN CDataExchange * pDX, 
    IN int nIDC, 
    IN OUT int & value
    );

//
// Enforce min/max spin control range
//
COMDLL void 
AFXAPI DDV_MinMaxSpin(
    IN CDataExchange * pDX, 
    IN HWND hWndControl,
    IN int nLowerRange,
    IN int nUpperRange
    );

//
// Similar to DDX_Text -- but always display a dummy string.
//
COMDLL void 
AFXAPI DDX_Password(
    IN CDataExchange * pDX, 
    IN int nIDC, 
    IN OUT CString & value,
    IN LPCTSTR lpszDummy
    );

//
// DDX_Text for CILong
//
COMDLL void 
AFXAPI DDX_Text(
    IN CDataExchange * pDX, 
    IN int nIDC, 
    IN OUT CILong & value
    );



class COMDLL CConfirmDlg : public CDialog
/*++

Class Description:

    Confirmation dialog -- brought up by the password ddx whenever
    password confirmation is necessary.

Public Interface:

    CConfirmDlg   : Constructor

    GetPassword   : Password entered in the dialog

--*/
{
//
// Construction
//
public:
    CConfirmDlg(
        IN CWnd * pParent = NULL
        );

public:
    //
    // Get the password that was entered in the dialog
    //
    CString & GetPassword() { return m_strPassword; }

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CConfirmDlg)
    enum { IDD = IDD_CONFIRM_PASSWORD };
    CString m_strPassword;
    //}}AFX_DATA

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CConfirmDlg)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CConfirmDlg)
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};



#endif // _DDXV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\comprop\accessdl.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        accessdl.h

   Abstract:

        Access Dialog definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/




class COMDLL CIPAccessDlg : public CDialog
/*++

Class Description:

    Access description editor dialog.  If constructed with a NULL access
    descriptor pointer, the access descriptor object will be allocated.
    Otherwise, the dialog will work with the given access descriptor

Public Interface:

    CIPAccessDlg : Constructor

--*/
{
//
// Construction
//
public:
    //
    // standard constructor
    //
    CIPAccessDlg(
        IN BOOL fDenyAccessMode,
        IN OUT CIPAccessDescriptor *& pAccess,
        IN CObListPlus * poblAccessList = NULL,
        IN CWnd * pParent = NULL,
        IN BOOL fAllowDomains = FALSE
        );

//
// Dialog Data
//
protected:
    //
    // Must match type order
    //
    enum
    {
        RADIO_SINGLE,
        RADIO_MULTIPLE,
        RADIO_DOMAIN,
    };

    //{{AFX_DATA(CIPAccessDlg)
    enum { IDD = IDD_IP_ACCESS };
    int     m_nStyle;
    CEdit   m_edit_Domain;
    CStatic m_static_IpAddress;
    CStatic m_static_SubnetMask;
    CButton m_button_DNS;
    CButton m_button_OK;
    //}}AFX_DATA

    CButton       m_radio_Domain;
    CIPAddressCtl m_ipa_IPAddress;
    CIPAddressCtl m_ipa_SubnetMask;

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CIPAccessDlg)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    // Generated message map functions
    //{{AFX_MSG(CIPAccessDlg)
    virtual BOOL OnInitDialog();
    virtual void OnOK();
    virtual void OnCancel();
    afx_msg void OnRadioMultiple();
    afx_msg void OnRadioSingle();
    afx_msg void OnRadioDomain();
    afx_msg void OnButtonDns();
    //}}AFX_MSG

    afx_msg void OnItemChanged();

    DECLARE_MESSAGE_MAP()

    void SetControlStates(
        IN int nStyle
        );

private:
    BOOL m_fNew;
    BOOL m_fDenyAccessMode;
    BOOL m_fAllowDomains;
    CString m_strIPAddress;
    CString m_strNetworkID;
    CString m_strDomainName;
    CIPAccessDescriptor *& m_pAccess;
    CObListPlus * m_poblAccessList;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\comprop\dirbrows.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module Name :

        dirbrows.cpp

   Abstract:

        Directory Browser Dialog.  Allow browsing for directories only.
        optionally allows UNC conversions for remote paths.

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include "comprop.h"
#include "dirbrows.h"
#include <dlgs.h>

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif



static
int 
BrowseCallbackProc(
   IN HWND hwnd,    
   IN UINT uMsg,    
   IN LPARAM lParam,    
   IN LPARAM lpData 
   )
/*++

Routine Description:

    Callback function for the folder browser

Arguments:

    hwnd     : Handle to the browse dialog box. The callback function can 
               send the following messages to this window:

               BFFM_ENABLEOK      Enables the OK button if the wParam parameter 
                                  is nonzero or disables it if wParam is zero.
               BFFM_SETSELECTION  Selects the specified folder. The lParam 
                                  parameter is the PIDL of the folder to select 
                                  if wParam is FALSE, or it is the path of the 
                                  folder otherwise.
               BFFM_SETSTATUSTEXT Sets the status text to the null-terminated 
                                  string specified by the lParam parameter.
 
    uMsg     : Value identifying the event. This parameter can be one of the 
               following values:

               0                  Initialize dir path.  lParam is the path.

               BFFM_INITIALIZED   The browse dialog box has finished 
                                  initializing. lpData is NULL.
               BFFM_SELCHANGED    The selection has changed. lpData 
                                  is a pointer to the item identifier list for 
                                  the newly selected folder.
 
    lParam   : Message-specific value. For more information, see the 
               description of uMsg.

    lpData   : Application-defined value that was specified in the lParam 
               member of the BROWSEINFO structure.

Return Value:

    0

--*/
{
    static LPCTSTR lpstrDir = NULL;

    switch(uMsg)
    {
    case 0:
        lpstrDir = (LPCTSTR)lParam;
        break;

    case BFFM_INITIALIZED:
        //
        // Dialog initialized -- select desired folder
        //
        if (lpstrDir != NULL)
        {
            ::SendMessage(hwnd, BFFM_SETSELECTION, TRUE, (LPARAM)lpstrDir);
        }
        break;
    }

    return 0;
}



CDirBrowseDlg::CDirBrowseDlg(
    IN CWnd * pParent         OPTIONAL,
    IN LPCTSTR lpszInitialDir OPTIONAL
    )
/*++

Routine Description:

    Constructor for directory browser dialog

Arguments:

    CWnd * pParent         : Parent window or NULL
    LPCTSTR lpszInitialDir : Initial directory, or NULL for current directory

Return Value:

    N/A

--*/
    : m_strInitialDir(lpszInitialDir)
{
    VERIFY(m_strTitle.LoadString(IDS_BROWSE_DIRECTORY));

    m_bi.pidlRoot = NULL;
    m_bi.hwndOwner = pParent ? pParent->m_hWnd : NULL;
    m_bi.pszDisplayName = m_szBuffer;
    m_bi.lpszTitle = m_strTitle;
    m_bi.ulFlags = BIF_RETURNFSANCESTORS | BIF_RETURNONLYFSDIRS,
    m_bi.lpfn = BrowseCallbackProc;
    m_bi.lParam = 0;

    //
    // Let the callback function know the default dir is
    //
    lpszInitialDir = !m_strInitialDir.IsEmpty() 
        ? (LPCTSTR)m_strInitialDir 
        : NULL;
    BrowseCallbackProc(m_bi.hwndOwner, 0, (LPARAM)lpszInitialDir, NULL);
}



CDirBrowseDlg::~CDirBrowseDlg()
/*++

Routine Description:

    Destructor for directory browser dialog

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    if (m_bi.pidlRoot != NULL)
    {
        LPITEMIDLIST pidl = (LPITEMIDLIST)m_bi.pidlRoot;

        //
        // Free using shell allocator
        //
        LPMALLOC pMalloc;
        if (::SHGetMalloc(&pMalloc) == NOERROR)
        {
            pMalloc->Free(pidl);
            pMalloc->Release();
        }
    }
}



/* virtual */
int 
CDirBrowseDlg::DoModal()
/*++

Routine Description:

    Display the browser dialog, and fill in the selected directory path.

Arguments:

    None

Return Value:

    IDOK if the OK button was pressed, IDCANCEL otherwise.

--*/
{
    BOOL fSelectionMade = FALSE;

    //
    // Get the Shell's default allocator
    //
    LPMALLOC pMalloc;
    if (::SHGetMalloc(&pMalloc) == NOERROR)
    {
        LPITEMIDLIST pidl;

        if ((pidl = ::SHBrowseForFolder(&m_bi)) != NULL)
        {
            if (::SHGetPathFromIDList(pidl, m_szBuffer))
            {
                fSelectionMade = TRUE;
            }
            else
            {
                //
                // OK Pressed, but no path found
                //
                ::AfxMessageBox(IDS_BAD_BROWSE);
            }

            //
            // Free the PIDL allocated by SHBrowseForFolder.
            //
            pMalloc->Free(pidl);
        }

        //
        // Release the shell's allocator.
        //
        pMalloc->Release();
    }

    return fSelectionMade ? IDOK : IDCANCEL;
}



LPCTSTR
CDirBrowseDlg::GetFullPath(
    OUT CString & strName,
    IN  BOOL fConvertToUNC
    ) const
/*++

Routine Description:

    Get the full path selected.  Optionally allow a remote path to be
    converted to a UNC path.

Arguments:

    CString & strName  : String in which to return the directory path
    BOOL fConvertToUNC : If TRUE, then if the drive selected is a network
                         drive, convert the path to a UNC path.

Return Value:

    A pointer to the directory path string or NULL in case of error.

Notes:

    This function should be called only after the dialog has been dismissed.

--*/
{
    LPCTSTR lp = NULL;

    try
    {
        strName = m_szBuffer;
        lp = strName;

        if (fConvertToUNC && lp != NULL)
        {
            //
            // If it's network drive, convert it to a UNC path
            //
            CString strDrive, strUNC;
            if (IsNetworkPath(strName, &strDrive, &strUNC))
            {
                strUNC += (lp + 2);
                strName = strUNC;
            }


            /*
            ASSERT(strName[1] == _T(':'));
            if (strName[1] == _T(':'))
            {
                TCHAR szDrive[] = _T("?:");
                //
                // Fill in actual drive letter
                //
                szDrive[0] = strName[0];
                if (::GetDriveType(szDrive) == DRIVE_REMOTE)
                {
                    //
                    // Yes, it's remote.  Replace drive letter
                    // with UNC path
                    //
                    TCHAR szUNC[_MAX_PATH + 1];
                    DWORD dwSize = _MAX_PATH;
                    TRACEEOLID("Converting drive path to UNC");
                    if (::WNetGetConnection(szDrive, 
                        szUNC, &dwSize) == NO_ERROR)
                    {
                        ::_tcscat(szUNC, lp + 2);
                        strName = szUNC;
                    }
                }
            }
            */

            lp = strName;
        }
    }
    catch(CMemoryException * e)
    {
        TRACEEOLID("!!!exception getting path");
        strName.Empty();
        e->ReportError();
        e->Delete();
    }

    return lp;
}



#if 0



// ***************************************************************************
// *                                                                         *
// * The code below is pre-WIN95 shell directory browsing.  It is OBSOLETE   *
// *                                                                         *
// ***************************************************************************

//
// new look commdlg style (not defined on older systems)
//
#ifndef OFN_EXPLORER
#define OFN_EXPLORER                 0x00080000
#endif // OFN_EXPLORER

#ifndef _COMSTATIC
//
// Externally available DLL handle
//
extern HINSTANCE hDLLInstance;
#endif // _COMSTATIC



CDirBrowseDlg::CDirBrowseDlg(
    IN CWnd * pParent         OPTIONAL,
    IN LPCTSTR lpszInitialDir OPTIONAL,
    IN BOOL bOpenFileDialog,
    IN LPCTSTR lpszDefExt     OPTIONAL,
    IN DWORD dwFlags,
    IN LPCTSTR lpszFilter     OPTIONAL
    )
/*++

Routine Description:

    Constructor for directory browser dialog

Arguments:

    CWnd * pParent         : Parent window or NULL
    LPCTSTR lpszInitialDir : Initial directory, or NULL for current directory
    BOOL bOpenFileDialog   : TRUE for open dialog, FALSE for save dialog
    LPCTSTR lpszDefExt     : Default extention string or NULL
    DWORD dwFlags          : OPENFILE flags
    LPCTSTR lpszFilter     : File filters

Return Value:

    N/A

--*/
    //
    // Use a dummy filename here to allow CFileOpenDialog to
    // dismiss itself.  If this matches an existing directory
    // name we're in trouble, so make that an unlikely event.
    // It would be nice if there were a file name that
    // cannot exist as a directory name.
    //
    : CFileDialog(
        bOpenFileDialog,
        lpszDefExt,
        _T(" JU$NK#\t^"),
        dwFlags,
        lpszFilter,
        pParent
        ),
      m_strNewDirectoryName()
{

#if 0 // Keep Class Wizard happy

    //{{AFX_DATA_INIT(CDirBrowseDlg)
    m_strNewDirectoryName = _T("");
    //}}AFX_DATA_INIT

#endif // 0

    m_ofn.Flags |= OFN_ENABLETEMPLATE | OFN_NONETWORKBUTTON;

#ifdef _COMSTATIC

    m_ofn.hInstance = ::AfxGetResourceHandle();

#else

    m_ofn.hInstance = hDLLInstance;

#endif // _COMSTATIC

    m_ofn.lpstrInitialDir = lpszInitialDir;
    m_ofn.lpTemplateName = MAKEINTRESOURCE(IDD_DIRBROWSE);

    //
    // Explicitly re-set the explorer flag which is set by
    // default
    //
    m_ofn.Flags &= (~OFN_EXPLORER);
}



CDirBrowseDlg::~CDirBrowseDlg()
/*++

Routine Description:

    Destructor for directory browser dialog

Arguments:

    N/A

Return Value:

    N/A

--*/
{
}



/* protected */
void
CDirBrowseDlg::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CFileDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CDirBrowseDlg)
    DDX_Control(pDX, IDC_EDIT_NEW_DIRECTORY_NAME, m_edit_NewDirectoryName);
    DDX_Control(pDX, stc1, m_static_stc1);
    DDX_Control(pDX, IDC_STATIC_DIR_NAME, m_static_stc2);
    DDX_Text(pDX, IDC_EDIT_NEW_DIRECTORY_NAME, m_strNewDirectoryName);
    DDV_MaxChars(pDX, m_strNewDirectoryName, _MAX_PATH);
    //}}AFX_DATA_MAP
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CDirBrowseDlg, CFileDialog)
    //{{AFX_MSG_MAP(CDirBrowseDlg)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BOOL
CDirBrowseDlg::OnInitDialog()
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CFileDialog::OnInitDialog();

    return TRUE;
}



LPCTSTR
CDirBrowseDlg::GetFullPath(
    OUT CString & strName,
    IN  BOOL fConvertToUNC
    ) const
/*++

Routine Description:

    Get the full path selected.

Arguments:

    CString & strName  : String in which to return the directory path
    BOOL fConvertToUNC : If TRUE, then if the drive selected is a network
                         drive, convert the path to a UNC path.

Return Value:

    A pointer to the directory path string or NULL in case of error.

Notes:

    This function should be called only after the dialog has been dismissed.

--*/
{
    LPCTSTR lp = NULL;

    try
    {
        m_ofn.lpstrFile[m_ofn.nFileOffset-1] = _T('\0');
        strName = m_ofn.lpstrFile;
        if (!m_strNewDirectoryName.IsEmpty())
        {
            //
            // Append the name of the newly created directory, unless
            // it has a colon or backslash in it, in which case it is
            // treated as a fully qualified path name
            //
            if (m_strNewDirectoryName.Find(_T(':')) != -1 ||
                m_strNewDirectoryName.Find(_T('\\')) != -1)
            {
                strName = m_strNewDirectoryName;
            }
            else
            {
                strName += _T("\\");
                strName += m_strNewDirectoryName;
            }
        }

        lp = strName;

        if (fConvertToUNC && lp != NULL)
        {
            //
            // If it's network drive, convert it to a UNC path
            //
            CString strDrive, strUNC;
            if (IsNetworkPath(strName, &strDrive, &strUNC))
            {
                strUNC += (lp + 2);
                strName = strUNC;
            }

            /*
            ASSERT(strName[1] == _T(':'));
            if (strName[1] == _T(':'))
            {
                TCHAR szDrive[] = _T("?:");
                //
                // Fill in actual drive letter
                //
                szDrive[0] = strName[0];
                if (::GetDriveType(szDrive) == DRIVE_REMOTE)
                {
                    //
                    // Yes, it's remote.  Replace drive letter
                    // with UNC path
                    //
                    TCHAR szUNC[_MAX_PATH + 1];
                    DWORD dwSize = _MAX_PATH;
                    TRACEEOLID("Converting drive path to UNC");
                    if (::WNetGetConnection(szDrive, 
                        szUNC, &dwSize) == NO_ERROR)
                    {
                        ::_tcscat(szUNC, lp + 2);
                        strName = szUNC;
                    }
                }
            }
            */

            lp = strName;
        }
    }
    catch(CMemoryException * e)
    {
        TRACEEOLID("!!!exception getting path");
        strName.Empty();
        e->ReportError();
        e->Delete();
    }

    return lp;
}



/* protected */
void
CDirBrowseDlg::OnOK()
/*++

Routine Description:

    Handler for IDOK.  Called when the OK button has been pressed.
    At this point, set the directory path string to the selected
    string.  If a new directory is entered, create it now.  Do not
    dismiss the dialog if the path is invalid.

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Update control data
    //
    if (UpdateData())
    {
        //
        // If a new directory name was entered, create it
        // here.
        //
        if (!m_strNewDirectoryName.IsEmpty())
        {
            if (!::CreateDirectory(m_strNewDirectoryName, NULL))
            {
                //
                // Failed to create the directory -- let the user
                // know why, and don't dismiss the dialog box
                //
                ::DisplayMessage(::GetLastError());
                m_edit_NewDirectoryName.SetSel(0,-1);

                return;
            }
        }

        //
        // Dismiss the dialog.
        //
        CFileDialog::OnOK();
    }
}

#endif // 0 (Obsolete)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\comprop\ddxv.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        ddxv.cpp

   Abstract:

        DDX/DDV Routines

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include "comprop.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

//
// Prototype for external function
//
void AFXAPI AfxSetWindowText(HWND hWndCtrl, LPCTSTR lpszNew);

//
// Numeric strings cannot be longer than 32 digits
//
#define NUMERIC_BUFF_SIZE (32)

//
// Dummy password used for display purposes
//
LPCTSTR g_lpszDummyPassword = _T("**********");



void 
AFXAPI DDV_MinChars(
    IN CDataExchange * pDX,
    IN CString const & value,
    IN int nChars
    )
/*++

Routine Description:

    Validate CString using a minimum string length

Arguments:

    CDataExchange * pDX   : Data exchange structure
    CString const & value : String to be validated
    int nChars            : Minimum length of string

Return Value:

    None

--*/
{
    if (pDX->m_bSaveAndValidate && value.GetLength() < nChars)
    {
        TCHAR szT[NUMERIC_BUFF_SIZE + 1];
        wsprintf(szT, _T("%d"), nChars);
        CString prompt;
        ::AfxFormatString1(prompt, IDS_DDX_MINIMUM, szT);
        ::AfxMessageBox(prompt, MB_ICONEXCLAMATION, IDS_DDX_MINIMUM);
        //
        // exception prep
        //
        prompt.Empty(); 
        pDX->Fail();
    }
}



void 
AFXAPI DDV_MinMaxChars(
    IN CDataExchange * pDX,
    IN CString const & value,
    IN int nMinChars,
    IN int nMaxChars
    )
/*++

Routine Description:

    Validate CString using a minimum and maximum string length.

Arguments:

    CDataExchange * pDX   : Data exchange structure
    CString const & value : String to be validated
    int nMinChars         : Minimum length of string
    int nMaxChars         : Maximum length of string

Return Value:

    None

--*/
{
    if (pDX->m_bSaveAndValidate)
    {
        UINT nID;
        TCHAR szT[NUMERIC_BUFF_SIZE + 1];

        if (value.GetLength() < nMinChars)
        {
            nID = IDS_DDX_MINIMUM;
            ::wsprintf(szT, _T("%d"), nMinChars);
        }
        else if (value.GetLength() > nMaxChars)
        {
            nID = AFX_IDP_PARSE_STRING_SIZE;
            ::wsprintf(szT, _T("%d"), nMaxChars);
        }
        else
        {
            //
            // Passes both our tests, it's ok.
            //
            return;
        }

        CString prompt;
        ::AfxFormatString1(prompt, nID, szT);
        ::AfxMessageBox(prompt, MB_ICONEXCLAMATION, nID);

        //
        // exception prep
        //
        prompt.Empty(); 

        pDX->Fail();
    }
    else if (pDX->m_hWndLastControl != NULL && pDX->m_bEditLastControl)
    {
        //
        // limit the control max-chars automatically
        //
        ::SendMessage(pDX->m_hWndLastControl, EM_LIMITTEXT, nMaxChars, 0);
    }
}



void 
AFXAPI DDX_Spin(
    IN CDataExchange * pDX,
    IN int nIDC,
    IN OUT int & value
    )
/*++

Routine Description:

    Save/store data from spinbutton control

Arguments:

    CDataExchange * pDX : Data exchange structure
    int nIDC            : Control ID of the spinbutton control
    int & value         : Value to be saved or stored

Return Value:

    None

--*/
{
    HWND hWndCtrl = pDX->PrepareCtrl(nIDC);
    if (pDX->m_bSaveAndValidate)
    {
        value = (int)LOWORD(::SendMessage(hWndCtrl, UDM_GETPOS, 0, 0L));
    }
    else
    {
        ::SendMessage(hWndCtrl, UDM_SETPOS, 0, MAKELPARAM(value, 0));
    }
}



void 
AFXAPI DDV_MinMaxSpin(
    IN CDataExchange * pDX,
    IN HWND hWndControl,
    IN int minVal,
    IN int maxVal
    )
/*++

Routine Description:

    Enforce minimum/maximum spin button range

Arguments:

    CDataExchange * pDX : Data exchange structure
    HWND hWndControl    : Control window handle
    int minVal          : Minimum value
    int maxVal          : Maximum value

Return Value:

    None

Note:

    Unlike most data validation routines, this one
    MUST be used prior to an accompanying DDX_Spin()
    function.  This is because spinbox controls have a
    native limit of 0-100.  Also, this function requires
    a window handle to the child control.  The
    CONTROL_HWND macro can be used for this.

--*/
{
    ASSERT(minVal <= maxVal);
    if (!pDX->m_bSaveAndValidate && hWndControl != NULL)
    {
        //
        // limit the control range automatically
        //
        ::SendMessage(hWndControl, UDM_SETRANGE, 0, MAKELPARAM(maxVal, minVal));
    }
}



void 
AFXAPI DDX_Password(
    IN CDataExchange * pDX,
    IN int nIDC,
    IN OUT CString & value,
    IN LPCTSTR lpszDummy
    )
/*++

Routine Description:

    DDX_Text for passwords.  Always display a dummy string
    instead of the real password, and ask for confirmation
    if the password has changed

Arguments:

    CDataExchange * pDX : Data exchange structure
    int nIDC            : Control ID
    CString & value     : value
    LPCTSTR lpszDummy   : Dummy password string to be displayed

Return Value:

    None

--*/
{
    HWND hWndCtrl = pDX->PrepareEditCtrl(nIDC);
    if (pDX->m_bSaveAndValidate)
    {
        if (!::SendMessage(hWndCtrl, EM_GETMODIFY, 0, 0))
        {
            TRACEEOLID("No changes -- skipping");
            return;
        }

        CString strNew;
        int nLen = ::GetWindowTextLength(hWndCtrl);
        ::GetWindowText(hWndCtrl, strNew.GetBufferSetLength(nLen), nLen + 1);
        strNew.ReleaseBuffer();

        /*
        if (strNew == value)
        {
            TRACEEOLID("Password already matches -- skipping");
            return;
        }
        */

        //
        // Password has changed -- ask for confirmation
        //
        CConfirmDlg dlg;
        if (dlg.DoModal() == IDOK)
        {
            if (strNew.Compare(dlg.GetPassword()) == 0)
            {
                //
                // Password ok, pass it on
                //
                value = strNew;
                return;
            }
            else
            {
                //
                // No match, bad password
                //
                ::AfxMessageBox(IDS_PASSWORD_NO_MATCH);
            }
        }

        //
        // throw exception
        //
        pDX->Fail();        
    }
    else
    {
        //
        // Put the dummy password string in the edit control
        //
        if (!value.IsEmpty())
        {
            ::AfxSetWindowText(hWndCtrl, lpszDummy);
        }
    }
}



void 
AFXAPI DDX_Text(
    IN CDataExchange * pDX,
    IN int nIDC,
    IN OUT CILong & value
    )
/*++

Routine Description:

    DDX_Text for CILong class.  CILong takes care of all the dirty
    work for output and input.

Arguments:

    CDataExchange * pDX : Data exchange structure
    int nIDC            : Control ID code
    CILong & value      : value

Return Value:

    None

--*/
{
    HWND hWndCtrl = pDX->PrepareEditCtrl(nIDC);
    pDX->m_bEditLastControl = TRUE;

    TCHAR szT[NUMERIC_BUFF_SIZE + 1];

    if (pDX->m_bSaveAndValidate)
    {
        LONG l;

        ::GetWindowText(hWndCtrl, szT, NUMERIC_BUFF_SIZE);
        
        if (CINumber::ConvertStringToLong(szT, l))
        {
            value = l;
        }
        else
        {
            HINSTANCE hOld = AfxGetResourceHandle();
            AfxSetResourceHandle(GetModuleHandle(COMPROP_DLL_NAME));

            ::AfxMessageBox(IDS_INVALID_NUMBER);

            AfxSetResourceHandle(hOld);

            //
            // Throw exception
            //
            pDX->Fail();
        }
    }
    else
    {
        ::wsprintf(szT, _T("%s"), (LPCTSTR)value);
        ::AfxSetWindowText(hWndCtrl, szT);
    }
}



CConfirmDlg::CConfirmDlg(
    IN CWnd * pParent OPTIONAL
    )
/*++

Routine Description:

    Constructor for the confirmation dialog -- brought up by the password ddx
    whenever password confirmation is necessary.

Arguments:

    CWnd * pParent : Optional parent window

Return Value:

    None

--*/
    : CDialog(CConfirmDlg::IDD, pParent)
{
    //{{AFX_DATA_INIT(CConfirmDlg)
    m_strPassword = _T("");
    //}}AFX_DATA_INIT
}



void 
CConfirmDlg::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange* pDX - DDX/DDV control structure

Return Value:

    N/A

--*/
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CConfirmDlg)
    DDX_Text(pDX, IDC_EDIT_CONFIRM_PASSWORD, m_strPassword);
    //}}AFX_DATA_MAP
}



//
// Message Handlers
//
BEGIN_MESSAGE_MAP(CConfirmDlg, CDialog)
    //{{AFX_MSG_MAP(CConfirmDlg)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\comprop\debugafx.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        debugafx.cpp

   Abstract:

        Debugging routines using AFX/MFC extensions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include "comprop.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#define new DEBUG_NEW

#ifdef _DEBUG



LPCSTR
DbgFmtPgm (
    IN LPCSTR szFn,
    IN int line
    )
/*++

Routine Description:

    Format debugging string containing file name and line number.  Remove
    the path portion of the file name if present.

Arguments:

    LPCSTR szFn : File name (ANSI)
    int line    : Line number

Return Value:

    Pointer to the internal buffer

--*/
{
    LPCSTR pszTail = szFn + ::lstrlenA(szFn);
    static CHAR szBuff[MAX_PATH+1];

    for ( /**/; pszTail > szFn; --pszTail)
    {
        if (*pszTail == '\\' || *pszTail == ':')
        {
            ++pszTail;
            break;
        }
    }

    ::wsprintfA(szBuff, "[%s:%d] ", pszTail, line);

    return szBuff;
}



CDumpContext & operator << (
    IN OUT CDumpContext & out,
    IN ENUM_DEBUG_AFX edAfx
    )
/*++

Routine Description:

    Output debugging control character to the debug context

Arguments:

    CDumpContext & out : Output debugging context
    edAfx              : Control character

Return Value:

    Output debugging context reference

--*/
{
    static CHAR * szEol = "\r\n";

    switch (edAfx)
    {
    case EDBUG_AFX_EOL:
        out << szEol;
        break;

    default:
        break;
    }

    return out;
}



#ifndef UNICODE



CDumpContext & operator << (
    IN OUT CDumpContext & out,
    IN LPCWSTR pwchStr
    )
/*++

Routine Description:

    Insert a wide-character string into the output stream. For non-UNICODE only,
    as this functions would be handled by the generic 'T' function otherwise.

Arguments:

    CDumpContext & out : Output debugging context
    pwchStr            : Wide character string

Return Value:

    Output debugging context reference

--*/
{
    size_t cwch ;

    if (pwchStr == NULL)
    {
        out << "<null>";
    }
    else if ((cwch = ::wcslen(pwchStr )) > 0)
    {
        CHAR * pszTemp = (LPSTR)AllocMem(cwch + 2);
        if (pszTemp != NULL)
        {
            for (int i = 0; pwchStr[i]; ++i)
            {
                pszTemp[i] = (CHAR)pwchStr[i];
            }

            pszTemp[i] = 0;
            out << pszTemp;
            FreeMem(pszTemp);
        }
        else
        {
            out << "<memerr>";
        }
    }
    else
    {
        out << "\"\"";
    }

    return out;
}

#endif // UNICODE

CDumpContext & operator <<(
    IN CDumpContext & out,
    IN const GUID & guid
    )
/*++

Routine Description:

    Dump a GUID to the debugger

Arguments:

    CDumpContext & out : Output debugging context
    GUID & guid        : GUID

Return Value:

    Output debugging context reference

--*/
{
    out << "{ "
        << guid.Data1 
        << "," 
        << guid.Data2
        << "," 
        << guid.Data3 
        << "," 
        << guid.Data4 
        << "}";

    return out;
}


#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\comprop\dirbrows.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module Name :

        dirbrows.h

   Abstract:

        Directory Browser Dialog definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

#ifndef _DIRBROWS_H
#define _DIRBROWS_H

#ifndef _SHLOBJ_H_
#include <shlobj.h>
#endif // _SHLOBJ_H_



class COMDLL CDirBrowseDlg
/*++

Class Description:

    Directory browsing dialog.  Use the shell browser functionality to
    return a folder.  Optionally allow conversion of remote paths to 
    UNC paths.

Public Interface:

    CDirBrowseDlg   : Construct the dialog
    ~CDirBrowseDlg  : Destruct the dialog
    GetFullPath     : Get the full path selected

--*/
{
//
// Construction
//
public:
    //
    // standard constructor
    //
    CDirBrowseDlg(
        IN CWnd * pParent = NULL,
        IN LPCTSTR lpszInitialDir = NULL
        );

    ~CDirBrowseDlg();

public:
    LPCTSTR GetFullPath(
        OUT CString & str,
        IN  BOOL fConvertToUNC = TRUE
        ) const;

    virtual int DoModal();

protected:
    TCHAR m_szBuffer[MAX_PATH+1];
    CString m_strTitle;
    CString m_strInitialDir;
    BROWSEINFO m_bi;
};

#if 0



// ***************************************************************************
// *                                                                         *
// * The code below is pre-WIN95 shell directory browsing.  It is OBSOLETE   *
// *                                                                         *
// ***************************************************************************

class COMDLL CDirBrowseDlg : public CFileDialog
/*++

Class Description:

    Directory browsing dialog.  Derived from file browser, but subclassed
    so as to allow only directories to be browsed for.  Additionally,
    it is possible to create new directories, and to network directory
    paths to UNC paths.

Public Interface:

    CDirBrowseDlg   : Construct the dialog
    ~CDirBrowseDlg  : Destruct the dialog
    GetFullPath     : Get the full path selected

--*/
{
//
// Construction
//
public:
    //
    // standard constructor
    //
    CDirBrowseDlg(
        IN LPCTSTR lpszInitialDir = NULL,
        IN BOOL bOpenFileDialog = TRUE,
        IN LPCTSTR lpszDefExt = NULL,
        IN DWORD dwFlags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT,
        IN LPCTSTR lpszFilter = NULL,
        IN CWnd * pParent = NULL
        );

    ~CDirBrowseDlg();

//
// Dialog Data
//
    //{{AFX_DATA(CDirBrowseDlg)
    enum { IDD = IDD_DIRBROWSE };
    CEdit   m_edit_NewDirectoryName;
    CStatic m_static_stc1;
    CStatic m_static_stc2;
    CString m_strNewDirectoryName;
    //}}AFX_DATA

public:
    LPCTSTR GetFullPath(
        OUT CString & str,
        IN  BOOL fConvertToUNC = TRUE
        ) const;

//
// Implementation
//
protected:
    //
    // DDX/DDV support
    //
    virtual void DoDataExchange(
        IN CDataExchange* pDX
        );

    // Generated message map functions
    //{{AFX_MSG(CDirBrowseDlg)
    virtual BOOL OnInitDialog();
    virtual void OnOK();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

#endif // 0

#endif // _DIRBROWS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\comprop\dnsnamed.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        dnsnamed.cpp

   Abstract:

        DNS name resolution dialog

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

#include "stdafx.h"
#include <winsock2.h>

#include "comprop.h"
#include "dnsnamed.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif



CDnsNameDlg::CDnsNameDlg(
    IN CIPAddressCtl * pIpControl OPTIONAL,
    IN CWnd * pParent OPTIONAL
    )
/*++

Routine Description:

    Construct with optional associated IP address control

Arguments:

    CWndIpAddress * pIpControl : Associated IP control
    CWnd * pParent             : Pointer to parent window

Return Value:

    N/A

--*/
    : m_pIpControl(pIpControl),
      m_dwIPValue(0L),
      CDialog(CDnsNameDlg::IDD, pParent)
{
#if 0 // Keep class wizard happy

    //{{AFX_DATA_INIT(CDnsNameDlg)
    //}}AFX_DATA_INIT

#endif // 0

    if (m_pIpControl)
    {
        m_pIpControl->GetAddress(&m_dwIPValue);
    }
}



CDnsNameDlg::CDnsNameDlg(
    IN DWORD dwIPValue,
    IN CWnd * pParent OPTIONAL
    )
/*++

Routine Description:

    Construct with associated IP value

Arguments:

    DWORD dwIPValue : IP Value
    CWnd * pParent  : Pointer to parent window

Return Value:

    N/A

--*/
    : m_pIpControl(NULL),
      m_dwIPValue(dwIPValue),
      CDialog(CDnsNameDlg::IDD, pParent)
{
}



void
CDnsNameDlg::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CDnsNameDlg)
    DDX_Control(pDX, IDC_EDIT_DNS_NAME, m_edit_DNSName);
    DDX_Control(pDX, IDOK, m_button_OK);
    //}}AFX_DATA_MAP
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CDnsNameDlg, CDialog)
    //{{AFX_MSG_MAP(CDnsNameDlg)
    ON_EN_CHANGE(IDC_EDIT_DNS_NAME, OnChangeEditDnsName)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



DWORD 
CDnsNameDlg::FillIpControlFromName()
/*++

Routine Description:

    Do a DNS lookup from the hostname in the edit control, and place
    the ip value in the ip control if we have one.

Arguments:

    None

Return Value:

    Error return code

--*/
{
    CString str;
    DWORD err = 0;
    HOSTENT * pHostent = NULL;

    m_edit_DNSName.GetWindowText(str);

    BeginWaitCursor();

#ifdef _UNICODE

    CHAR * pAnsi = AllocAnsiString(str);

    if (pAnsi == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    
    pHostent = ::gethostbyname(pAnsi);

#else

    pHostent = ::gethostbyname((LPCTSTR)str);

#endif // _UNICODE;

    if (pHostent != NULL)
    {
        //
        // Got a valid lookup.  Convert the value to host order,
        // optionally set the value in the associated ip control
        //
        m_dwIPValue = ::ntohl(*((u_long *)pHostent->h_addr_list[0]));
        if (m_pIpControl)
        {
            m_pIpControl->SetAddress(m_dwIPValue);
        }
    }
    else
    {
        err = ::WSAGetLastError();
    }

    EndWaitCursor();

#ifdef _UNICODE

    FreeMem(pAnsi);

#endif // _UNICODE

    return err;
}



DWORD
CDnsNameDlg::FillNameFromIpValue()
/*++

Routine Description:

    Given the ip value, fill, do a reverse lookup, and fill the name in
    the edit control.

Arguments:

    None

Return Value:

    Error return code

--*/
{
    DWORD err = ERROR_SUCCESS;

    if (m_dwIPValue == 0L)
    {
        //
        // Don't bother filling this
        // one in -- not an error, though
        //
        return err;
    }

    //
    // Call the Winsock API to get host name and alias information.
    //
    u_long ulAddrInNetOrder = ::htonl((u_long)m_dwIPValue);

    BeginWaitCursor();
    HOSTENT * pHostInfo = ::gethostbyaddr(
        (CHAR *)&ulAddrInNetOrder,
        sizeof ulAddrInNetOrder, 
        PF_INET 
        );
    EndWaitCursor();

    if (pHostInfo == NULL)
    {
        return ::WSAGetLastError();
    }

    try
    {
        CString str(pHostInfo->h_name);
        m_edit_DNSName.SetWindowText(str);
    }
    catch(CException * e)
    {
        err = ::GetLastError();
        e->Delete();
    }

    return err;
}

//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

void
CDnsNameDlg::OnOK()
/*++

Routine Description:

    Attempt to resolve the the IP address in response to the OK button
    being pressed.  Don't dismiss the dialog if the name is not
    resolvable.

Arguments:

    None

Return Value:

    None

--*/
{
    CError err(FillIpControlFromName());
    if (err.MessageBoxOnFailure())
    {
        //
        // Failed, don't dismiss the dialog
        //
        return;
    }

    //
    // Dismiss the dialog
    //
    CDialog::OnOK();
}



void
CDnsNameDlg::OnChangeEditDnsName()
/*++

Routine Description:

    Enable/disable the ok button depending on the contents of the edit control.

Arguments:

    None

Return Value:

    None

--*/
{
    m_button_OK.EnableWindow(m_edit_DNSName.GetWindowTextLength() > 0);
}



BOOL 
CDnsNameDlg::OnInitDialog() 
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CDialog::OnInitDialog();

    //
    // If an address has been pre-set do a reverse lookup
    //
    if (m_dwIPValue)
    {
        CError err(FillNameFromIpValue());
        err.MessageBoxOnFailure();
    }

    OnChangeEditDnsName();

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\comprop\guid.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        guid.cpp

   Abstract:

        Initialization as required by initguid

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include <stdafx.h>
#include <winsvc.h>

#include <objbase.h>
#include <initguid.h>

#include <iwamreg.h>
#include <iadmw.h>
#include <iisrsta.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\comprop\dnsnamed.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        dnsnamed.h

   Abstract:

        DNS name resolution dialog definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/


#ifndef _DNSNAMED_H
#define _DNSNAMED_H



class COMDLL CDnsNameDlg : public CDialog
{
/*++

Class Description:

    DNS Name resolution dialog.  Enter a DNS name, and this will be
    resolved to an IP address.  Optionally set the value in associated
    ip control.

Public Interface:

    CDnsNameDlg   : Construct the dialog

    QueryIPValue  : Find out the resolved IP address (only set when OK
                    is pressed).

--*/
//
// Construction
//
public:
    //
    // Construct with associated IP address control
    //
    CDnsNameDlg(
        IN CIPAddressCtl * pIpControl = NULL,
        IN CWnd * pParent = NULL
        );

    //
    // Construct with IP value
    //
    CDnsNameDlg(
        IN DWORD dwIPValue,
        IN CWnd * pParent = NULL
        );

    DWORD QueryIPValue() const;

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CDnsNameDlg)
    enum { IDD = IDD_DNS };
    CEdit   m_edit_DNSName;
    CButton m_button_OK;
    //}}AFX_DATA


//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CDnsNameDlg)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CDnsNameDlg)
    virtual void OnOK();
    virtual BOOL OnInitDialog();
    afx_msg void OnChangeEditDnsName();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    DWORD FillIpControlFromName();
    DWORD FillNameFromIpValue();

private:
    CIPAddressCtl * m_pIpControl;
    DWORD m_dwIPValue;
};

//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline DWORD CDnsNameDlg::QueryIPValue() const
{
    return m_dwIPValue;
}


#endif // _DNSNAMED_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\comprop\dtp.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        dtp.h

   Abstract:

        DateTimePicker common control MFC wrapper definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

#ifndef _DTP_H
#define _DTP_H


//
// Notification Handler Macros
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

#define ON_DATETIMECHANGE(id, memberFxn)\
    ON_NOTIFY(DTN_DATETIMECHANGE, id, memberFxn)

#define ON_USERSTRING(id, memberFxn)\
    ON_NOTIFY(DTN_USERSTRING, id, memberFxn)



class COMDLL CDateTimePicker : public CWnd
/*--

Class Description:

    DateTimePicker MFC control wrapper.

Public Interface:

    CDateTimePicker         : Constructor
    ~CDateTimePicker        : Destructor    

    Create                  : Create the control
    GetSystemTime           : Get systemtime struct value from control
    SetSystemTime           : Set control time value from systemtime struct
    GetRange                : Get the min/max time range
    SetRange                : Set the min/max time range
    SetFormat               : Set display formatting string
    GetMonthCalColor        : Get the month calendar colour
    SetMonthCalColor        : Set the month calendar colour

Notes:

    Either create control dynamically with Create method, or put in resource
    template as a user control of name "SysDateTimePick32".  In this case,
    common style DWORDs as follows:

    WS_BORDER | WS_CHILD | WS_VISIBLE     0x50800000

                      DTS_UPDOWN              0x0001
                      DTS_SHOWNONE            0x0002
                      DTS_SHORTDATEFORMAT     0x0000
                      DTS_LONGDATEFORMAT      0x0004
                      DTS_TIMEFORMAT          0x0009
                      DTS_APPCANPARSE         0x0010
                      DTS_RIGHTALIGN          0x0020

    Time and date format changes are automatically picked up by the control

--*/
{
    DECLARE_DYNAMIC(CDateTimePicker)

//
// Constructor/Destructor
//
public:
    CDateTimePicker();
    ~CDateTimePicker();

//
// Interface
//
public:
    //
    // Create the control
    //
    BOOL Create(
        IN LPCTSTR lpszName,
        IN DWORD dwStyle, 
        IN const RECT & rect, 
        IN CWnd * pParentWnd, 
        IN UINT nID
        );

    //
    // Returns GDT_NONE if "none" is selected (DTS_SHOWNONE only)
    // Returns GDT_VALID and modifies *pst to be the currently selected value
    //
    DWORD GetSystemTime(
        OUT LPSYSTEMTIME pst
        );

    //
    // Sets datetimepick to None (DTS_SHOWNONE only)
    // Returns TRUE on success, FALSE on error (such as bad params)
    //
    BOOL SetSystemTime();

    //
    // Sets datetimepick to *pst
    // Returns TRUE on success, FALSE on error (such as bad params)
    //
    BOOL SetSystemTime(
        IN LPSYSTEMTIME pst
        );

    //
    // Modifies rgst[0] to be the minimum ALLOWABLE systemtime (or 0 if no min)
    // Modifies rgst[1] to be the maximum ALLOWABLE systemtime (or 0 if no max)
    // Returns GDTR_MIN | GDTR_MAX if there is a minimum | maximum limit
    //
    DWORD GetRange(
        OUT LPSYSTEMTIME rgst
        );

    //
    // If GDTR_MIN, sets the minimum ALLOWABLE systemtime to rgst[0], 
    //      otherwise removes minimum
    //
    // If GDTR_MAX, sets the maximum ALLOWABLE systemtime to rgst[1], 
    //      otherwise removes maximum
    //
    // Returns TRUE on success, FALSE on error (such as invalid parameters)
    //
    BOOL SetRange(
        IN DWORD gdtr,
        IN LPSYSTEMTIME rgst
        );

    // 
    // Sets the display formatting string to sz (see GetDateFormat and 
    //      GetTimeFormat for valid formatting chars)
    //
    // NOTE: 'X' is a valid formatting character which indicates that 
    //       the application will determine how to display information. 
    //       Such apps must support DTN_WMKEYDOWN, DTN_FORMAT, 
    //       and DTN_FORMATQUERY.
    // 
    BOOL SetFormat(
        IN LPCTSTR sz
        );

    //
    // Sets the month calendar colour
    //
    BOOL SetMonthCalColor(
        IN int iColor,
        IN COLORREF clr
        );

    //
    // Returns the month calendar colour
    //
    COLORREF GetMonthCalColor(
        IN int iColor
        );

protected:
    //
    // Register the control if not yet registered.
    //
    static BOOL RegisterClass();

private:
    static BOOL m_fClassRegistered;
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline BOOL CDateTimePicker::Create(
    IN LPCTSTR lpszName,
    IN DWORD dwStyle, 
    IN const RECT & rect, 
    IN CWnd * pParentWnd, 
    IN UINT nID
    )
{
    //
    // Create the control
    //
    return CWnd::Create(
        DATETIMEPICK_CLASS, 
        lpszName, 
        dwStyle, 
        rect, 
        pParentWnd, 
        nID
        );
}

inline DWORD CDateTimePicker::GetSystemTime(
    OUT LPSYSTEMTIME pst
    )
{
    return DateTime_GetSystemtime(m_hWnd, pst);
}

inline BOOL CDateTimePicker::SetSystemTime()
{
    return DateTime_SetSystemtime(m_hWnd, GDT_NONE, NULL);
}

inline BOOL CDateTimePicker::SetSystemTime(
    IN LPSYSTEMTIME pst
    )
{
    ASSERT(pst != NULL);
    return DateTime_SetSystemtime(m_hWnd, GDT_VALID, pst);
}

inline DWORD CDateTimePicker::GetRange(
    OUT LPSYSTEMTIME rgst
    )
{
    ASSERT(rgst != NULL);
    return DateTime_GetRange(m_hWnd, rgst);
}

inline BOOL CDateTimePicker::SetRange(
    IN DWORD gdtr,
    IN LPSYSTEMTIME rgst
    )
{
    ASSERT(rgst != NULL);
    ASSERT(gdtr & (GDTR_MIN | GDTR_MAX));
    return DateTime_SetRange(m_hWnd, gdtr, rgst);
}

inline BOOL CDateTimePicker::SetFormat(
    IN LPCTSTR sz
    )
{
    ASSERT(sz != NULL);
    return DateTime_SetFormat(m_hWnd, sz);
}

inline BOOL CDateTimePicker::SetMonthCalColor(
    IN int iColor,
    IN COLORREF clr
    )
{
    return (BOOL)DateTime_SetMonthCalColor(m_hWnd, iColor, clr);
}

inline COLORREF CDateTimePicker::GetMonthCalColor(
    IN int iColor
    )
{
    return (COLORREF)DateTime_GetMonthCalColor(m_hWnd, iColor);
}

#endif // _DTP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\comprop\idlg.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        idlg.cpp

   Abstract:

        Inheritance Dialog

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include "comprop.h"
#include "idlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


extern HINSTANCE hDLLInstance;


//
// Inheritance dialog
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

CInheritanceDlg::CInheritanceDlg(
    IN DWORD dwMetaID,
    IN BOOL fWrite,
    IN LPCTSTR lpstrServer,
    IN LPCTSTR lpstrMetaRoot,
    IN CStringList & strlMetaChildNodes,
    IN LPCTSTR lpstrPropertyName,           OPTIONAL
    IN CWnd * pParent                       OPTIONAL
    )
/*++

Routine Description:

    Inheritance dialog constructor.  This constructor assumes GetDataPaths()
    has already been called.

Arguments:

    DWORD dwMetaID                      : Meta ID
    BOOL fWrite                         : TRUE from write, FALSE from delete
    LPCTSTR lpstrServer                 : Server
    LPCTSTR lpstrMetaRoot               : Meta root
    CStringList & strlMetaChildNodes    : List of child nodes from GetDataPaths
    LPCTSTR lpstrPropertyName           : Optional text string for the property
    CWnd * pParent                      : Optional parent window

Return Value:

    None

--*/
    : m_fWrite(fWrite),
      m_fEmpty(TRUE),
      m_fUseTable(TRUE),
      m_strServer(lpstrServer),
      m_strMetaRoot(lpstrMetaRoot),
      m_strPropertyName(lpstrPropertyName ? lpstrPropertyName : _T("")),
      m_mk(lpstrServer),
      CDialog(CInheritanceDlg::IDD, pParent)
{
    m_strlMetaChildNodes = strlMetaChildNodes;

    VERIFY(CMetaKey::GetMDFieldDef(
        dwMetaID, 
        m_dwMDIdentifier, 
        m_dwMDAttributes, 
        m_dwMDUserType,
        m_dwMDDataType
        ));

    Initialize();
}



CInheritanceDlg::CInheritanceDlg(
    IN DWORD dwMetaID,
    IN BOOL fWrite,
    IN LPCTSTR lpstrServer,
    IN LPCTSTR lpstrMetaRoot,
    IN LPCTSTR lpstrPropertyName,           OPTIONAL
    IN CWnd * pParent                       OPTIONAL
    )
/*++

Routine Description:

    Inheritance dialog constructor.  This constructor will call GetDataPaths().

Arguments:

    DWORD dwMetaID                      : Meta ID
    BOOL fWrite                         : TRUE from write, FALSE from delete
    LPCTSTR lpstrServer                 : Server
    LPCTSTR lpstrMetaRoot               : Meta root
    LPCTSTR lpstrPropertyName           : Optional text string for the property
    CWnd * pParent                      : Optional parent window

Return Value:

    None

--*/
    : m_fWrite(fWrite),
      m_fEmpty(TRUE),
      m_fUseTable(TRUE),
      m_strServer(lpstrServer),
      m_strMetaRoot(lpstrMetaRoot),
      m_strlMetaChildNodes(),
      m_strPropertyName(lpstrPropertyName ? lpstrPropertyName : _T("")),
      m_mk(lpstrServer),
      CDialog(CInheritanceDlg::IDD, pParent)
{
    //
    // Specify the resources to use
    //
    HINSTANCE hOldRes = AfxGetResourceHandle();
    AfxSetResourceHandle(hDLLInstance);

    VERIFY(CMetaKey::GetMDFieldDef(
        dwMetaID, 
        m_dwMDIdentifier, 
        m_dwMDAttributes, 
        m_dwMDUserType,
        m_dwMDDataType
        ));

    //
    // Need to do our own GetDataPaths()
    //
    CError err(GetDataPaths());
    if (!err.MessageBoxOnFailure())
    {
        Initialize();
    }

    //
    // Restore the resources
    //
    AfxSetResourceHandle(hOldRes);
}



CInheritanceDlg::CInheritanceDlg(
    IN BOOL    fTryToFindInTable,
    IN DWORD   dwMDIdentifier,
    IN DWORD   dwMDAttributes,
    IN DWORD   dwMDUserType,
    IN DWORD   dwMDDataType,
    IN LPCTSTR lpstrPropertyName,
    IN BOOL    fWrite,
    IN LPCTSTR lpstrServer,
    IN LPCTSTR lpstrMetaRoot,
    IN CWnd *  pParent                      OPTIONAL
    )
/*++

Routine Description:

    Inheritance dialog constructor.  This constructor will call GetDataPaths(),
    and will use the specified parameters if the property ID does not exist
    in the property table

Arguments:

    BOOL    fTryToFindInTable           : If TRUE, first look in table
    DWORD   dwMDIdentifier              : Metadata identifier
    DWORD   dwMDAttributes              : Metadata attributes
    DWORD   dwMDUserType                : Metadata user type
    DWORD   dwMDDataType                : Metadata data type
    LPCTSTR lpstrPropertyName           : Text string for the property
    BOOL    fWrite                      : TRUE from write, FALSE from delete
    LPCTSTR lpstrServer                 : Server
    LPCTSTR lpstrMetaRoot               : Meta root
    CWnd *  pParent                     : Optional parent window

Return Value:

    None

--*/
    : m_fWrite(fWrite),
      m_fEmpty(TRUE),
      m_fUseTable(FALSE),
      m_strServer(lpstrServer),
      m_strMetaRoot(lpstrMetaRoot),
      m_strlMetaChildNodes(),
      m_mk(lpstrServer),
      CDialog(CInheritanceDlg::IDD, pParent)
{
    //
    // Specify the resources to use
    //
    HINSTANCE hOldRes = AfxGetResourceHandle();
    AfxSetResourceHandle(hDLLInstance);

    if (fTryToFindInTable && !CMetaKey::GetMDFieldDef(
        dwMDIdentifier, 
        m_dwMDIdentifier, 
        m_dwMDAttributes, 
        m_dwMDUserType,
        m_dwMDDataType
        ))
    {
        //
        // Did not exist in the table, use specified parameters
        //
        m_dwMDIdentifier  = dwMDIdentifier;
        m_dwMDAttributes  = dwMDAttributes;
        m_dwMDUserType    = dwMDUserType;
        m_dwMDDataType    = dwMDDataType;
        m_strPropertyName = lpstrPropertyName;
    }


    //
    // Need to do our own GetDataPaths()
    //
    CError err(GetDataPaths());
    if (!err.MessageBoxOnFailure())
    {
        Initialize();
    }

    //
    // Restore the resources
    //
    AfxSetResourceHandle(hOldRes);
}



HRESULT
CInheritanceDlg::GetDataPaths()
/*++

Routine Description:

    GetDataPaths()

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    ASSERT(!m_strServer.IsEmpty());

    CError err(m_mk.QueryResult());
    if (err.Succeeded())
    {
        err = m_mk.GetDataPaths( 
            m_strlMetaChildNodes,
            m_dwMDIdentifier,
            m_dwMDDataType,
            m_strMetaRoot
            );
    }

    return err;
}



void
CInheritanceDlg::Initialize()
/*++

Routine Description:

    Initialize data members.  Set the m_fEmpty flag to determine if
    it is necessary to proceed.

Arguments:

    None

Return Value:

    None

--*/
{
    //{{AFX_DATA_INIT(CInheritanceDlg)
    //}}AFX_DATA_INIT

    CMetaKey::CleanMetaPath(m_strMetaRoot);

    if (m_fUseTable && !CMetaKey::IsPropertyInheritable(m_dwMDIdentifier))
    {
        //
        // No point in displaying non-inheritable properties
        //
        return;
    }

    switch(m_dwMDIdentifier)
    {
    //
    // Ignore these properties, even though they are inheritable
    //
    case MD_VR_PATH:
    case MD_APP_ISOLATED:
    case MD_APP_FRIENDLY_NAME:
        return;
    }

    //
    // Check to see if the current metabase path contains an instance
    //
    CString strTmp;
    m_fHasInstanceInMaster = FriendlyInstance(m_strMetaRoot, strTmp);

    //
    // If property name was not specified in the constructor, load default
    // one from table.
    //
    if (m_strPropertyName.IsEmpty())
    {
        ASSERT(m_fUseTable);
        VERIFY(CMetaKey::GetPropertyDescription(
            m_dwMDIdentifier, 
            m_strPropertyName
            ));
    }

    //
    // Go through the list of metapaths, and clean them
    // up.
    //
    POSITION pos = m_strlMetaChildNodes.GetHeadPosition();
    while(pos)
    {
        CString & strMetaPath = m_strlMetaChildNodes.GetNext(pos);
        CMetaKey::CleanMetaPath(strMetaPath);
    }

    //
    // If the special info key (lm/service/info) is in the list, remove it.
    // We only need to this if the key that is getting the
    // change (m_strMetaRoot) is the service master property (lm/service).
    // If it is anything else, then the special "info" key cannot be below
    // it so we don't need to check. Thus the first test is to see if there
    // is only one "/" character. If there is only one, then we know it is
    // the service and we can go ahead and do the test.  In some ways,
    // mfc is a pain, so we limited to the CString methods to do this
    // copy the root into the temp string.
    //
    INT iSlash = m_strMetaRoot.ReverseFind(SZ_MBN_SEP_CHAR);
    if (iSlash >= 0)
    {
        strTmp = m_strMetaRoot.Left(iSlash);

        //
        // Now make sure that there aren't any more slashes
        //
        if (strTmp.Find(SZ_MBN_SEP_CHAR) == -1)
        {
            //
            // Now build the path to the special info key by adding it
            // to the meta root
            //
            strTmp = m_strMetaRoot + SZ_MBN_SEP_CHAR + IIS_MD_SVC_INFO_PATH;

            TRACEEOLID("Removing any descendants of " << strTmp);

            //
            // Search the list for the info key and remove it if we find it
            //
            pos = m_strlMetaChildNodes.GetHeadPosition();
            while(pos)
            {
                POSITION pos2 = pos;
                CString & strMetaPath = m_strlMetaChildNodes.GetNext(pos);
                TRACEEOLID("Checking " << strMetaPath);
                if (strTmp.CompareNoCase(
                    strMetaPath.Left(strTmp.GetLength())) == 0)
                {
                    TRACEEOLID("Removing service/info metapath from list");
                    m_strlMetaChildNodes.RemoveAt(pos2);
                }
            }
        }
    }

    //
    // Remove the first item if it's the current metapath
    //
    pos = m_strlMetaChildNodes.GetHeadPosition();
    if (pos)
    {
        TRACEEOLID("Stripping " << m_strMetaRoot);

        CString & strMetaPath = m_strlMetaChildNodes.GetAt(pos);

        if (strMetaPath.CompareNoCase(m_strMetaRoot) == 0)
        {
            TRACEEOLID("Removing current metapath from list");
            m_strlMetaChildNodes.RemoveHead();
        }
    }

    m_fEmpty = m_strlMetaChildNodes.GetCount() == 0;
}



INT_PTR
CInheritanceDlg::DoModal()
/*++

Routine Description:

    Display the dialog.

Arguments:

    None

Return Value:

    IDOK if the OK button was pressed, IDCANCEL otherwise.

--*/
{
    //
    // Specify the resources to use
    //
    HINSTANCE hOldRes = AfxGetResourceHandle();
    AfxSetResourceHandle(hDLLInstance);

    INT_PTR answer = CDialog::DoModal();

    //
    // restore the resources
    //
    AfxSetResourceHandle(hOldRes);

    return answer;
}




void
CInheritanceDlg::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CDialog::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CInheritanceDlg)
    DDX_Control(pDX, IDC_LIST_CHILD_NODES, m_list_ChildNodes);
    //}}AFX_DATA_MAP
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CInheritanceDlg, CDialog)
    //{{AFX_MSG_MAP(CInheritanceDlg)
    ON_BN_CLICKED(IDC_BUTTON_SELECT_ALL, OnButtonSelectAll)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



BOOL
CInheritanceDlg::FriendlyInstance(
    IN  CString & strMetaRoot,
    OUT CString & strFriendly
    )
/*++

Routine Description:

    Replace the instance number with its descriptive name.

Arguments:

    CString & strMetaRoot       : Metabase path
    CString & strFriendly       : Converted output friendly path.

Return Value:

    TRUE if the path contained an instance number.

--*/
{
    //
    // Break into fields
    //
    // CODEWORK: make static like BuildMetaPath
    //
    LPCTSTR lp = _tcschr(strMetaRoot, SZ_MBN_SEP_CHAR); // lm
    if (lp != NULL)
    {
        LPCTSTR lp2 = lp;
        CString strService(++lp2);
        lp = _tcschr(++lp, SZ_MBN_SEP_CHAR);  // service name
        if (lp == NULL)
        {
            //
            // Master Instance (can never be a descendant)
            //
            //strFriendly = m_strWebMaster;
            return FALSE;
        }
        else
        {
            strService.ReleaseBuffer(DIFF(lp - lp2));
        }
        TRACEEOLID(strService);

        DWORD dwInstance = _ttol(++lp);
        TRACEEOLID(dwInstance);
        lp = _tcschr(lp, SZ_MBN_SEP_CHAR);       // Instance #
        if (lp != NULL)
        {
            lp = _tcschr(++lp, SZ_MBN_SEP_CHAR); // Skip "ROOT"
        }

        HRESULT hr = m_mk.Open(METADATA_PERMISSION_READ, strService, dwInstance);
        if (SUCCEEDED(hr))
        {
            CString strComment;
            hr = m_mk.QueryValue(MD_SERVER_COMMENT, strComment);
            m_mk.Close();

            if (FAILED(hr) || strComment.IsEmpty())
            {
                strFriendly.Format(
                    SZ_MBN_MACHINE SZ_MBN_SEP_STR _T("%s") SZ_MBN_SEP_STR _T("%d"),
                    (LPCTSTR)strService,
                    dwInstance
                    );
            }
            else
            {
                strFriendly.Format(
                    SZ_MBN_MACHINE SZ_MBN_SEP_STR _T("%s") SZ_MBN_SEP_STR _T("%s"),
                    (LPCTSTR)strService,
                    (LPCTSTR)strComment
                    );
            }

            TRACEEOLID(strFriendly);

            //
            // Append the rest of the path
            //
            if (lp != NULL)
            {
                strFriendly += lp;
            }

            return TRUE;
        }
    }

    return FALSE;
}



CString &
CInheritanceDlg::CleanDescendantPath(
    IN OUT CString & strMetaPath
    )
/*++

Routine Description:

    Clean the descendant metabase path.  The path is shown
    as a descendant of the current metabase root, and instance
    numbers are replaced with their description names.

Arguments:

    CString & strMetaPath   : Metabase path to be treated

Return Value:

    Reference to the cleaned-up path.

--*/
{
    //
    // This better be a descendant!
    //
    ASSERT(strMetaPath.GetLength() >= m_strMetaRoot.GetLength());
    ASSERT(!::_tcsnicmp(strMetaPath, m_strMetaRoot, m_strMetaRoot.GetLength()));

    if (!m_fHasInstanceInMaster)
    {
        //
        // Need to replace the instance number with the friendly
        // name.
        //
        CString strTmp;
        VERIFY(FriendlyInstance(strMetaPath, strTmp));
        strMetaPath = strTmp;
    }

    strMetaPath = strMetaPath.Mid(m_strMetaRoot.GetLength() + 1);

    return strMetaPath;
}



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BOOL
CInheritanceDlg::OnInitDialog()
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CDialog::OnInitDialog();

    //
    // Get friendly name for the property, and set the text.
    //
    CString strPrompt, strFmt;
    VERIFY(strFmt.LoadString(IDS_INHERITANCE_PROMPT));
    strPrompt.Format(strFmt, (LPCTSTR)m_strPropertyName);
    GetDlgItem(IDC_STATIC_PROMPT)->SetWindowText(strPrompt);

    //
    // Turn inherited nodes into friendly paths, and add them
    // to the listbox.  Note the "current" node should have been
    // deleted at this stage.
    //
    POSITION pos = m_strlMetaChildNodes.GetHeadPosition();
    while(pos)
    {
        CString strNode = m_strlMetaChildNodes.GetNext(pos);
        m_list_ChildNodes.AddString(CleanDescendantPath(strNode));
    }

    return TRUE;
}



void
CInheritanceDlg::OnButtonSelectAll()
/*++

Routine Description:

    'Select All' button handler

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Select all entries
    //
    if (m_list_ChildNodes.GetCount() == 1)
    {
        //
        // SelItemRange refuses to do a single member
        //
        m_list_ChildNodes.SetSel(0, TRUE);
    }
    else
    {
        m_list_ChildNodes.SelItemRange(
            TRUE, 
            0, 
            m_list_ChildNodes.GetCount() - 1
            );
    }
}



void
CInheritanceDlg::OnOK()
/*++

Routine Description:

    'OK' button handler

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Now delete the property for all selected child nodes.
    // Grab from the orginal list, and not the listbox
    // as the latter have been frienly-fied, and is no longer
    // usable.
    //
    int cItems = m_list_ChildNodes.GetCount();
    ASSERT(cItems > 0);

    CString strMetaPath;
    CError err(m_mk.QueryResult());

    if (err.Succeeded())
    {
        int i = 0;
        POSITION pos = m_strlMetaChildNodes.GetHeadPosition();

        while(pos)
        {
            strMetaPath = m_strlMetaChildNodes.GetNext(pos);
            if (m_list_ChildNodes.GetSel(i++) > 0)
            {
                TRACEEOLID("Deleting property on " << strMetaPath);

                err = m_mk.Open(
                    METADATA_PERMISSION_WRITE, 
                    METADATA_MASTER_ROOT_HANDLE,
                    strMetaPath
                    );

                if (err.Failed())
                {
                    break;
                }

                err = m_mk.DeleteValue(m_dwMDIdentifier);

                m_mk.Close();

                if (err.Failed())
                {
                    break;
                }
            }
        }
    }

    if (!err.MessageBoxOnFailure())
    {
        //
        // Dialog can be dismissed
        //
        CDialog::OnOK();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\comprop\dtp.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        dtp.cpp

   Abstract:

        DateTimePicker common control MFC wrapper

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include "comprop.h"
#include "dtp.h"



//
// Static Initialization
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BOOL CDateTimePicker::m_fClassRegistered = FALSE;



/* static */
BOOL
CDateTimePicker::RegisterClass()
/*++

Routine Description:

    Ensure that the date-time class is registered.

Arguments:

    None

Return Value:

    TRUE for success, FALSE otherwise.

--*/
{
    if (!m_fClassRegistered)
    {
        //
        // Class not registed, register now
        //
        INITCOMMONCONTROLSEX icex;    
        icex.dwSize = sizeof(icex);
        icex.dwICC = ICC_DATE_CLASSES;    

        m_fClassRegistered = ::InitCommonControlsEx(&icex);
    }        

    return m_fClassRegistered;
}



IMPLEMENT_DYNAMIC(CDateTimePicker, CWnd)



CDateTimePicker::CDateTimePicker()
/*++

Routine Description:

    Constructor

Arguments:

    None

Return Value:

    N/A

--*/
{
    VERIFY(RegisterClass());
}



CDateTimePicker::~CDateTimePicker()
/*++

Routine Description:

    Destructor -- destroy the control

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    DestroyWindow();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\comprop\idlg.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        idlg.h

   Abstract:

        Inheritance Dialog Definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

#ifndef __IDLG__H__
#define __IDLG__H__



class COMDLL CInheritanceDlg : public CDialog
/*++

Class Description:

    Inheritance override checker dialog.

Public Interface:

    CInheritanceDlg         : Constructor

    IsEmpty                 : Check to see if there are overrides.

Notes:

    There are two constructors.  One which assumes GetDataPaths() has
    already been called, and which takes the results from GetDataPaths()
    as a CStringList, and a second constructor which will make the GetDataPaths
    automatically.

    In either case, the calling process should check IsEmpty() right after
    constructing the dialog to see if DoModal() needs to be called.  If
    IsEmpty() returns TRUE, there's no reason to call DoModal().

--*/
{
//
// fWrite parameter helper definitions
//
#define FROM_WRITE_PROPERTY     (TRUE)
#define FROM_DELETE_PROPERTY    (FALSE)

//
// Construction
//
public:
    //
    // Standard constructor (GetDataPaths() already called)
    //
    CInheritanceDlg(
        IN DWORD dwMetaID,
        IN BOOL fWrite,
        IN LPCTSTR lpstrServer,
        IN LPCTSTR lpstrMetaRoot,
        IN CStringList & strlMetaChildNodes,
        IN LPCTSTR lpstrPropertyName            = NULL,
        IN CWnd * pParent                       = NULL
        );

    //
    // Constructor which will call GetDataPaths()
    //
    CInheritanceDlg(
        IN DWORD dwMetaID,
        IN BOOL fWrite,
        IN LPCTSTR lpstrServer,
        IN LPCTSTR lpstrMetaRoot,
        IN LPCTSTR lpstrPropertyName            = NULL,
        IN CWnd * pParent                       = NULL
        );

    //
    // Constructor which will call GetDataPaths(), and which
    // does not use the predefined property table unless
    // fTryToFindInTable is TRUE, in which case it will attempt
    // to use the table first, and use the specified parameters
    // only if the property ID is not found in the table.
    //
    CInheritanceDlg(
        IN BOOL    fTryToFindInTable,
        IN DWORD   dwMDIdentifier,
        IN DWORD   dwMDAttributes,
        IN DWORD   dwMDUserType,
        IN DWORD   dwMDDataType,
        IN LPCTSTR lpstrPropertyName,
        IN BOOL    fWrite,
        IN LPCTSTR lpstrServer,
        IN LPCTSTR lpstrMetaRoot,
        IN CWnd *  pParent                      = NULL                     
        );

//
// Access
//
public:
    virtual INT_PTR DoModal();
    
    //
    // Check to see if there's a reason to continue displaying
    // the dialog.
    //
    BOOL IsEmpty() const { return m_fEmpty; }

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CInheritanceDlg)
    enum { IDD = IDD_INHERITANCE };
    CListBox m_list_ChildNodes;
    //}}AFX_DATA

//
// Overrides
//
protected:
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CInheritanceDlg)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    // Generated message map functions
    //{{AFX_MSG(CInheritanceDlg)
    virtual BOOL OnInitDialog();
    virtual void OnOK();
    afx_msg void OnButtonSelectAll();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    void Initialize();
    HRESULT GetDataPaths();

    BOOL FriendlyInstance(
        IN  CString & strMetaRoot,
        OUT CString & strFriendly
        );

    CString & CleanDescendantPath(
        IN OUT CString & strMetaPath
        );

private:
    BOOL    m_fWrite;
    BOOL    m_fEmpty;
    BOOL    m_fHasInstanceInMaster;
    BOOL    m_fUseTable;
    DWORD   m_dwMDIdentifier;
    DWORD   m_dwMDAttributes;
    DWORD   m_dwMDUserType;
    DWORD   m_dwMDDataType;
    CString m_strMetaRoot;
    CString m_strServer;
    CString m_strPropertyName;
    CStringListEx m_strlMetaChildNodes;
    CMetaKey m_mk;
};


#endif // __IDLG__H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\comprop\inetprop.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        inetprop.cpp

   Abstract:

        Internet Properties base classes

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"

#include "comprop.h"
#include "inetprop.h"
#include "idlg.h"

#include "mmc.h"

extern "C"
{
    #include <lm.h>
}

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

//
// Period to sleep while waiting for service to attain desired state
//
#define SLEEP_INTERVAL (500L)

//
// Maximum time to wait for service to attain desired state
//
#define MAX_SLEEP        (180000)       // For a service
#define MAX_SLEEP_INST   ( 30000)       // For an instance

//
// Instance numbers
//
#define FIRST_INSTANCE      (1)
#define LAST_INSTANCE       (0xffffffff)
#define MAX_INSTANCE_LEN    (32)



//
// Calling instance
//
HINSTANCE hDLLInstance;



//
// Utility Functions
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


//
// Base registry key definition
//
#define SZ_REG_KEY_BASE  _T("Software\\Microsoft\\%s")

const LPCTSTR g_cszTemplates   = SZ_MBN_INFO SZ_MBN_SEP_STR SZ_MBN_TEMPLATES;
const LPCTSTR g_cszCompression = SZ_MBN_FILTERS SZ_MBN_SEP_STR SZ_MBN_COMPRESSION SZ_MBN_SEP_STR SZ_MBN_PARAMETERS;
const LPCTSTR g_cszMachine     = SZ_MBN_MACHINE;
const LPCTSTR g_cszMimeMap     = SZ_MBN_MIMEMAP;
const LPCTSTR g_cszRoot        = SZ_MBN_ROOT;
const LPCTSTR g_cszSep         = SZ_MBN_SEP_STR;
const LPCTSTR g_cszInfo        = SZ_MBN_INFO;
const TCHAR g_chSep            = SZ_MBN_SEP_CHAR;



LPCTSTR
GenerateRegistryKey(
    OUT CString & strBuffer,
    IN  LPCTSTR lpszSubKey OPTIONAL
    )
/*++

Routine Description:

    Generate a registry key name based on the current app, and a
    provided subkey (optional)

Arguments:

    CString & strBuffer : Buffer to create registry key name into.
    LPCTSTR lpszSubKey  : Subkey name or NULL

Return Value:

    Pointer to the registry key value 

--*/
{
    try
    {
        //
        // Use the app name as the primary registry name
        //
        CWinApp * pApp = ::AfxGetApp();
        if (!pApp)
        {
            TRACEEOLID("No app object -- can't generate registry key name");
            ASSERT(FALSE);

            return NULL;
        }

        strBuffer.Format(SZ_REG_KEY_BASE, pApp->m_pszAppName);

        if (lpszSubKey)
        {
            strBuffer += _T("\\");
            strBuffer += lpszSubKey;
        }

        TRACEEOLID("Registry key is " << strBuffer);
    }
    catch(CMemoryException * e)
    {
        TRACEEOLID("!!!exception building regkey");
        e->ReportError();
        e->Delete();
        return NULL;
    }

    return strBuffer;
}



NET_API_STATUS
QueryInetServiceStatus(
    IN  LPCTSTR lpszServer,
    IN  LPCTSTR lpszService,
    OUT int * pnState
    )
/*++

Routine Description:

    Determine the status of the given service on the given machine.

Arguments:

    LPCTSTR lpszServer  : Server name
    LPCTSTR lpszService : Service name
    int * pnState       : Returns the service state

Return Value:

    Error return code

--*/
{

#ifdef NO_SERVICE_CONTROLLER

    *pnState = INetServiceUnknown;

    return ERROR_SUCCESS;

#else

    SC_HANDLE hScManager;
    NET_API_STATUS err = ERROR_SUCCESS;

    hScManager = ::OpenSCManager(lpszServer, NULL, SC_MANAGER_ENUMERATE_SERVICE);

    if (hScManager == NULL)
    {
        return ::GetLastError();
    }

    SC_HANDLE hService = ::OpenService(hScManager,
        lpszService, SERVICE_QUERY_STATUS);

    if (hService == NULL)
    {
        err = ::GetLastError();
    }
    else
    {
        SERVICE_STATUS ss;

        VERIFY(::QueryServiceStatus(hService, &ss));
        VERIFY(::QueryServiceStatus(hService, &ss));

        switch(ss.dwCurrentState)
        {
        case SERVICE_STOPPED:
        case SERVICE_STOP_PENDING:
            *pnState = INetServiceStopped;
            break;

        case SERVICE_RUNNING:
        case SERVICE_START_PENDING:
        case SERVICE_CONTINUE_PENDING:
            *pnState = INetServiceRunning;
            break;

        case SERVICE_PAUSE_PENDING:
        case SERVICE_PAUSED:
            *pnState = INetServicePaused;
            break;

        default:
            *pnState = INetServiceUnknown;
        }

        //
        // Make sure this is a controllable service
        //
        if ( (*pnState == INetServiceRunning || *pnState == INetServicePaused)
           && !(ss.dwControlsAccepted & SERVICE_ACCEPT_SHUTDOWN))
        {
            TRACEEOLID("Service not controllable -- ignored");
            ::CloseServiceHandle(hService);
            ::CloseServiceHandle(hScManager);

            return ERROR_SERVICE_START_HANG;
        }

        ::CloseServiceHandle(hService);
    }

    ::CloseServiceHandle(hScManager);

    return err;

#endif // NO_SERVICE_CONTROLLER
}



NET_API_STATUS
ChangeInetServiceState(
    IN  LPCTSTR lpszServer,
    IN  LPCTSTR lpszService,
    IN  int nNewState,
    OUT int * pnCurrentState
    )
/*++

Routine Description:

    Start/stop/pause or continue a _service_

Arguments:

    LPCTSTR lpszServer   : Server name
    LPCTSTR lpszService  : Service name
    int nNewState        : INetService* definition.
    int * pnCurrentState : Ptr to current state (will be changed)

Return Value:

    Error return code

--*/
{
#ifdef NO_SERVICE_CONTROLLER

    *pnCurrentState = INetServiceUnknown;

    return ERROR_SERVICE_REQUEST_TIMEOUT;

#else

    SC_HANDLE hService = NULL;
    SC_HANDLE hScManager = NULL;
    NET_API_STATUS err = ERROR_SUCCESS;

    do
    {
        hScManager = ::OpenSCManager(lpszServer, NULL, SC_MANAGER_ALL_ACCESS);

        if (hScManager == NULL)
        {
            err = ::GetLastError();
            break;
        }

        hService = ::OpenService(hScManager, lpszService, SERVICE_ALL_ACCESS);
        if (hService == NULL)
        {
            err = ::GetLastError();
            break;
        }

        BOOL fSuccess = FALSE;
        DWORD dwTargetState;
        DWORD dwPendingState = 0;
        SERVICE_STATUS ss;

        switch(nNewState)
        {
        case INetServiceStopped:
            dwTargetState = SERVICE_STOPPED;
            dwPendingState = SERVICE_STOP_PENDING;
            fSuccess = ::ControlService(hService, SERVICE_CONTROL_STOP, &ss);
            break;

        case INetServiceRunning:
            dwTargetState = SERVICE_RUNNING;
            if (*pnCurrentState == INetServicePaused)
            {
                dwPendingState = SERVICE_CONTINUE_PENDING;
                fSuccess = ::ControlService(hService,
                    SERVICE_CONTROL_CONTINUE, &ss);
            }
            else
            {
                dwPendingState = SERVICE_START_PENDING;
                fSuccess = ::StartService(hService, 0, NULL);
            }
            break;

        case INetServicePaused:
            dwTargetState = SERVICE_PAUSED;
            dwPendingState = SERVICE_PAUSE_PENDING;
            fSuccess = ::ControlService(hService, SERVICE_CONTROL_PAUSE, &ss);
            break;

        default:
            ASSERT(FALSE && "Invalid service state requested");
            err = ERROR_INVALID_PARAMETER;
        }

        if (!fSuccess && err == ERROR_SUCCESS)
        {
            err = ::GetLastError();
        }

        if (err != ERROR_SUCCESS) {
            break;
        }

        //
        // Wait for the service to attain desired state, timeout
        // after 3 minutes.
        //
        DWORD dwSleepTotal = 0L;

        while (dwSleepTotal < MAX_SLEEP)
        {
            if (!::QueryServiceStatus(hService, &ss))
            {
                err = ::GetLastError();
                break;
            }

            if (ss.dwCurrentState != dwPendingState)
            {
                //
                // Done one way or another
                //
                if (ss.dwCurrentState != dwTargetState)
                {
                    //
                    // Did not achieve desired result. Something went
                    // wrong.
                    //
                    if (ss.dwWin32ExitCode)
                    {
                        err = ss.dwWin32ExitCode;
                    }
                }

                break;
            }

            //
            // Still pending...
            //
            ::Sleep(SLEEP_INTERVAL);

            dwSleepTotal += SLEEP_INTERVAL;
        }

        if (dwSleepTotal >= MAX_SLEEP)
        {
            err = ERROR_SERVICE_REQUEST_TIMEOUT;
        }

        //
        // Update state information
        //
        switch(ss.dwCurrentState)
        {
        case SERVICE_STOPPED:
        case SERVICE_STOP_PENDING:
            *pnCurrentState = INetServiceStopped;
            break;

        case SERVICE_RUNNING:
        case SERVICE_START_PENDING:
        case SERVICE_CONTINUE_PENDING:
            *pnCurrentState = INetServiceRunning;
            break;

        case SERVICE_PAUSE_PENDING:
        case SERVICE_PAUSED:
            *pnCurrentState = INetServicePaused;
            break;

        default:
            *pnCurrentState = INetServiceUnknown;
        }
    }
    while(FALSE);

    if (hService)
    {
        ::CloseServiceHandle(hService);
    }

    if (hScManager)
    {
        ::CloseServiceHandle(hScManager);
    }

    return err;

#endif // NO_SERVICE_CONTROLLER
}



BOOL
IsServerLocal(
    IN LPCTSTR lpszServer
    )
/*++

Routine Description:

    Check to see if the given name refers to the local machine

Arguments:

    LPCTSTR lpszServer   : Server name

Return Value:

    TRUE if the given name refers to the local computer, FALSE otherwise

Note:

    Doesn't work if the server is an ip address

--*/
{
    TCHAR szComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD dwSize = sizeof(szComputerName);

    if (GetComputerName(szComputerName, &dwSize)
        && !lstrcmpi(szComputerName, PURE_COMPUTER_NAME(lpszServer)))
    {
        return TRUE;
    }

    return FALSE;
}



BOOL
DoesServerExist(
    IN LPCTSTR lpszServer
    )
/*++

Routine Description:

    Check to make sure the machine exists

Arguments:

    LPCTSTR lpszServer      : machine name

Return Value:

    TRUE if the server exists, FALSE otherwise.

--*/
{
#ifdef NO_SERVICE_CONTROLLER

    //
    // Assume it exists
    //
    return TRUE;

#else

    //
    // CODEWORK: This is not the best way to do this, especially
    //           not across proxies and what not.
    //
    SC_HANDLE hScManager;
    NET_API_STATUS err = ERROR_SUCCESS;

    hScManager = ::OpenSCManager(lpszServer, NULL, SC_MANAGER_CONNECT);
    if (hScManager == NULL)
    {
        err = ::GetLastError();
    }

    ::CloseServiceHandle(hScManager);

    return err != RPC_S_SERVER_UNAVAILABLE;

#endif // NO_SERVICE_CONTROLLER

}



BOOL
GetVolumeInformationSystemFlags(
    IN  LPCTSTR lpszPath,
    OUT DWORD * pdwSystemFlags
    )
/*++

Routine Description:

    Get the system flags for the path in question

Arguments:

    LPCTSTR lpszPath            : Path
    DWORD * pdwSystemFlags      : Returns system flags

Return Value:

    TRUE for success, FALSE for failure.

--*/
{
    ASSERT(pdwSystemFlags != NULL);

    TRACEEOLID("Getting system flags for " << lpszPath);

    DWORD dwMaxComponentLength;
    TCHAR szRoot[MAX_PATH + 1];
    TCHAR szFileSystem[MAX_PATH + 1];

    //
    // Generating root path
    //
    if (IsUNCName(lpszPath))
    {
        //
        // Root path of a UNC path is \\foo\bar\
        //
        ASSERT(lstrlen(lpszPath) < MAX_PATH);

        int cSlashes = 0;
        LPCTSTR lpszSrc = lpszPath;
        LPTSTR lpszDst = szRoot;

        while (cSlashes < 4 && *lpszSrc)
        {
            if ((*lpszDst++ = *lpszSrc++) == '\\')
            {
                ++cSlashes;
            }
        }    

        if (!*lpszSrc)
        {
            *lpszDst++ = '\\';
        }

        *lpszDst = '\0';
    }
    else
    {
        ::wsprintf(szRoot, _T("%c:\\"), *lpszPath);
    }

    TRACEEOLID("Root path is " << szRoot);
    
    return ::GetVolumeInformation(
        szRoot,
        NULL,
        0,
        NULL,
        &dwMaxComponentLength,
        pdwSystemFlags,
        szFileSystem,
        STRSIZE(szFileSystem)
        );
}



LPTSTR
ISMAllocString(
    IN CString & str
    )
/*++

Routine Description:

    Allocate and copy string using ISM allocator

Arguments:

    CString & str       : string

Return Value:

    Pointer to the allocated string

--*/
{
    LPTSTR lp = (LPTSTR)ISMAllocMem((str.GetLength() + 1)* sizeof(TCHAR));

    if (lp != NULL)
    {
        lstrcpy(lp, str);
    }

    return lp;
}



//
// Utility classes
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


CBlob::CBlob() 
/*++

Routine Description:

    NULL constructor

Arguments:

    None

Return Value:

    N/A

--*/
    : m_pbItem(NULL), 
      m_dwSize(0L)
{
}



CBlob::CBlob(
    IN DWORD dwSize,
    IN PBYTE pbItem,
    IN BOOL fMakeCopy
    )
/*++

Routine Description:

    Constructor

Arguments:

    DWORD dwSize        : Size of memory block
    PBYTE pbItem        : Pointer to memory block
    BOOL fMakeCopy      : If TRUE, makes a copy of the memory block.
                          If FALSE, takes ownership of the pointer.

Return Value:

    N/A

--*/
    : m_pbItem(NULL),
      m_dwSize(0L)
{
    SetValue(dwSize, pbItem, fMakeCopy);
}



CBlob::CBlob(
    IN const CBlob & blob
    )
/*++

Routine Description:

    Copy constructor

Arguments:

    const CBlob & blob      : Source blob

Return Value:

    N/A

Notes:

    This contructor makes a copy of the memory block in question.

--*/
    : m_pbItem(NULL),
      m_dwSize(0L)
{
    SetValue(blob.GetSize(), blob.m_pbItem, TRUE);
}



void
CBlob::SetValue(
    IN DWORD dwSize,
    IN PBYTE pbItem,
    IN BOOL fMakeCopy OPTIONAL
    )
/*++

Routine Description:

    Assign the value to this binary object.  If fMakeCopy is FALSE,
    the blob will take ownership of the pointer, otherwise a copy
    will be made.

Arguments:

    DWORD dwSize        : Size in bytes
    PBYTE pbItem        : Byte streadm
    BOOL fMakeCopy      : If true, make a copy, else assign pointer

Return Value:

    None

--*/
{
    if (!IsEmpty())
    {
        TRACEEOLID("Assigning value to non-empty blob.  Cleaning up");
        CleanUp();
    }

    if (dwSize > 0L)
    {
        //
        // Make private copy
        //
        m_dwSize = dwSize;
        if (fMakeCopy)
        {
            m_pbItem = (PBYTE)AllocMem(m_dwSize);
            if (m_pbItem != NULL)
               CopyMemory(m_pbItem, pbItem, dwSize);
        }
        else
        {
            m_pbItem = pbItem;
        }
    }
}



void 
CBlob::CleanUp()
/*++

Routine Description:

    Delete data pointer, and reset pointer and size.

Arguments:

    None

Return Value:

    None

--*/
{
    if (m_pbItem)
    {
        FreeMem(m_pbItem);
    }

    m_pbItem = NULL;
    m_dwSize = 0L;
}



CBlob & 
CBlob::operator =(
    IN const CBlob & blob
    )
/*++

Routine Description:

    Assign values from another CBlob. 

Arguments:

    const CBlob & blob      : Source blob

Return Value:

    Reference to this object

--*/
{
    //
    // Make copy of data
    //
    SetValue(blob.GetSize(), blob.m_pbItem, TRUE);

    return *this;
}



BOOL 
CBlob::operator ==(
    IN const CBlob & blob
    ) const
/*++

Routine Description:
    
    Compare two binary large objects.  In order to match, the objects
    must be the same size, and byte identical.

Arguments:

    const CBlob & blob      : Blob to compare against.

Return Value:

    TRUE if the objects match, FALSE otherwise.

--*/
{
    if (GetSize() != blob.GetSize())
    {
        return FALSE;
    }

    return memcmp(m_pbItem, blob.m_pbItem, GetSize()) == 0;    
}



CMetaProperties::CMetaProperties(
    IN LPCTSTR lpszServerName,
    IN LPCTSTR lpszService,         OPTIONAL
    IN DWORD   dwInstance,          OPTIONAL
    IN LPCTSTR lpszParentPath,      OPTIONAL
    IN LPCTSTR lpszAlias            OPTIONAL
    )
/*++

Routine Description:

    Constructor -- creates the interface

Arguments:

    LPCTSTR lpszServerName      : Server name  
    LPCTSTR lpszService         : Service name or NULL
    DWORD   dwInstance          : Instance number or 0
    LPCTSTR lpszParentPath      : Parent path or NULL
    LPCTSTR lpszAlias           : Alias name or NULL

Return Value:

    N/A

--*/
    : m_hResult(S_OK),
      m_dwNumEntries(0),
      m_dwMDUserType(ALL_METADATA),
      m_dwMDDataType(ALL_METADATA),
      m_dwMDDataLen(0),
      m_pbMDData(NULL),
      m_fInherit(TRUE),
      CMetaKey(lpszServerName)
{
    //
    // Build the metabase path (prior to GetAllData)
    //
    BuildMetaPath(
        m_strMetaRoot,
        lpszService,
        dwInstance,
        lpszParentPath,
        lpszAlias
        );
}



CMetaProperties::CMetaProperties(
    IN const CMetaInterface * pInterface,
    IN LPCTSTR lpszService,         OPTIONAL
    IN DWORD   dwInstance,          OPTIONAL
    IN LPCTSTR lpszParentPath,      OPTIONAL
    IN LPCTSTR lpszAlias            OPTIONAL
    )
/*++

Routine Description:

    Constructor -- attach to an existing interface.

Arguments:

    CMetaInterface * pInterface  : Existing interface
    LPCTSTR lpszService          : Service name or NULL
    DWORD   dwInstance           : Instance number or 0
    LPCTSTR lpszParentPath       : Parent path or NULL
    LPCTSTR lpszAlias            : Alias name or NULL

Return Value:

    N/A

--*/
    : m_hResult(S_OK),
      m_dwNumEntries(0),
      m_dwMDUserType(ALL_METADATA),
      m_dwMDDataType(ALL_METADATA),
      m_dwMDDataLen(0),
      m_pbMDData(NULL),
      m_fInherit(TRUE),
      CMetaKey(pInterface)
{
    //
    // Build the metabase path
    //
    BuildMetaPath(
        m_strMetaRoot,
        lpszService,
        dwInstance,
        lpszParentPath,
        lpszAlias
        );
}



CMetaProperties::CMetaProperties(
    IN const CMetaKey * pKey,
    IN LPCTSTR lpszMDPath
    )
/*++

Routine Description:

    Construct from open key

Arguments:

    const CMetaKey * pKey   : Open key
    LPCTSTR lpszMDPath      : Path

Return Value:

    N/A

--*/
    : m_hResult(S_OK),
      m_dwNumEntries(0),
      m_dwMDUserType(ALL_METADATA),
      m_dwMDDataType(ALL_METADATA),
      m_dwMDDataLen(0),
      m_pbMDData(NULL),
      m_strMetaRoot(lpszMDPath),
      m_fInherit(TRUE),
      CMetaKey(FALSE, pKey)
{
}



CMetaProperties::CMetaProperties(
    IN const CMetaKey * pKey,
    IN DWORD dwPath
    )
/*++

Routine Description:

    Construct from open key

Arguments:

    const CMetaKey * pKey   : Open key
    DWORD dwPath            : Path (instance number probably)

Return Value:

    N/A

--*/
    : m_hResult(S_OK),
      m_dwNumEntries(0),
      m_dwMDUserType(ALL_METADATA),
      m_dwMDDataType(ALL_METADATA),
      m_dwMDDataLen(0),
      m_pbMDData(NULL),
      m_fInherit(TRUE),
      CMetaKey(FALSE, pKey)
{
    _ltot(dwPath, m_strMetaRoot.GetBuffer(32), 10);
    m_strMetaRoot.ReleaseBuffer();    
}



CMetaProperties::~CMetaProperties()
/*++

Routine Description:

    Destructor -- clean up

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    Cleanup();
}



/* virtual */
HRESULT 
CMetaProperties::LoadData()
/*++

Routine Description:

    Fetch all data with or without inheritance, and call the derived
    class to parse the data into fields.

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    //
    // Get all data off the master root
    //
    DWORD dwMDAttributes = METADATA_NO_ATTRIBUTES;

    if (m_fInherit)
    {
         dwMDAttributes = METADATA_INHERIT
            | METADATA_PARTIAL_PATH
            | METADATA_ISINHERITED;
    }

    m_hResult = GetAllData(
        dwMDAttributes,
        m_dwMDUserType,
        m_dwMDDataType,
        &m_dwNumEntries,
        &m_dwMDDataLen,
        &m_pbMDData,
        m_strMetaRoot
        );

    if (SUCCEEDED(m_hResult))
    {
        //
        // Call the derived class to break up data into fields
        //
        ParseFields();
    }

    Cleanup();

    return m_hResult;
}



void 
CMetaProperties::Cleanup()
/*++

Routine Description:

    Free data

Arguments:

    None

Return Value:

    None

--*/
{
    SAFE_FREEMEM(m_pbMDData);

    m_dwNumEntries = 0;
    m_dwMDDataLen = 0;
}



/* virtual */
HRESULT 
CMetaProperties::QueryResult() const
/*++

Routine Description:
    
    Determine the construction return code

Arguments:

    None

Return Value: 

    HRESULT

--*/
{   
    HRESULT hr = CMetaKey::QueryResult();

    return SUCCEEDED(hr) ? m_hResult : hr;
}



HRESULT 
CMetaProperties::OpenForWriting(
    IN BOOL fCreate     OPTIONAL
    )
/*++

Routine Description:

    Attempt to open the path for writing.  If fCreate is TRUE
    (default), then create the path if it doesn't yet exist

Arguments:

    BOOL fCreate        : If TRUE, create the path if it doesn't exist.

Return Value:

    HRESULT

Notes:

    If the key is already open, this will fire an ASSERT and close
    it.

--*/
{
    CError err;

    if (IsOpen())
    {
        TRACEEOLID("Key already open -- closing");
        ASSERT(FALSE);
        Close();
    }

    BOOL fNewPath;

    do
    {
        fNewPath = FALSE;

        err = Open(
            METADATA_PERMISSION_WRITE,
            METADATA_MASTER_ROOT_HANDLE,
            m_strMetaRoot
            );

        if (err.Win32Error() == ERROR_PATH_NOT_FOUND && fCreate)
        {
            TRACEEOLID("Metabase path doesn't exist -- creating it");

            err = CreatePathFromFailedOpen();
            fNewPath = err.Succeeded();
        }
    }
    while(fNewPath);

    return err;
}


//
// Machine properties
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


CMachineProps::CMachineProps(
    IN LPCTSTR lpszServerName
    )
/*++

Routine Description:

    Constructor for machine properties object

Arguments:

    LPCTSTR lpszServerName     : Server name

Return Value:

    N/A

--*/
    : CMetaProperties(
          lpszServerName,
          NULL,
          MASTER_INSTANCE
          ),
      //
      // Default properties
      //
      m_nMaxNetworkUse(DEF_BANDWIDTH)
{
}




CMachineProps::CMachineProps(
    IN const CMetaInterface * pInterface
    )
/*++

Routine Description:

    Constructor for machine properties object

Arguments:

    CMetaInterface * pInterface : Existing interface

Return Value:

    N/A

--*/
    : CMetaProperties(
          pInterface,
          NULL,
          MASTER_INSTANCE
          ),
      //
      // Default properties
      //
      m_nMaxNetworkUse(DEF_BANDWIDTH)
{
}



/* virtual */
void 
CMachineProps::ParseFields()
/*++

Routine Description:

    Parse the fetched data into fields

Arguments:

    None

Return Value:

    None

--*/
{
    BEGIN_PARSE_META_RECORDS(m_dwNumEntries, m_pbMDData)
      HANDLE_META_RECORD(MD_MAX_BANDWIDTH,   m_nMaxNetworkUse)
    END_PARSE_META_RECORDS
}



HRESULT
CMachineProps::WriteDirtyProps()
/*++

Routine Description:

    Write dirty properties

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CError err;

    BEGIN_META_WRITE()
      META_WRITE(MD_MAX_BANDWIDTH,  m_nMaxNetworkUse)
    END_META_WRITE(err);

    return err;
}



//
// Compression Properties
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

CIISCompressionProps::CIISCompressionProps(
    IN LPCTSTR lpszServerName,
    IN LPCTSTR lpszService,        OPTIONAL
    IN DWORD dwInstance,           OPTIONAL
    IN LPCTSTR lpszParent,         OPTIONAL
    IN LPCTSTR lpszAlias           OPTIONAL
    )
/*++

Routine Description:

    Constructor for compression properties object

Arguments:

    LPCTSTR lpszServerName     : Server name
    LPCTSTR lpszService        : Service name (must be w3svc)
    DWORD dwInstance           : Instance (must be master)
    LPCTSTR lpszParent         : Parent path (must be NULL)
    LPCTSTR lpszAlias          : Alias name (must be NULL)

Return Value:

    N/A

--*/
    : CMetaProperties(
        lpszServerName,
        lpszService,
        dwInstance,
        lpszParent,
        g_cszCompression
        ),
      //
      // Default properties
      //
      m_fEnableStaticCompression(FALSE),
      m_fEnableDynamicCompression(FALSE),
      m_fLimitDirectorySize(FALSE),
      m_fPathDoesNotExist(FALSE),
      m_dwDirectorySize(0xffffffff),
      m_strDirectory()
{
    //
    // Override base parameters
    //
    m_fInherit = FALSE;
}



/* virtual */ 
HRESULT 
CIISCompressionProps::LoadData()
/*++

Routine Description:

    Fetch all data with or without inheritance, and call the derived
    class to parse the data into fields.

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CError err(CMetaProperties::LoadData());
    m_fPathDoesNotExist = (err.Win32Error() == ERROR_PATH_NOT_FOUND);

    return err;
}



/* virtual */
void 
CIISCompressionProps::ParseFields()
/*++

Routine Description:

    Parse the fetched data into fields

Arguments:

    None

Return Value:

    None

--*/
{
    BEGIN_PARSE_META_RECORDS(m_dwNumEntries,           m_pbMDData)
      HANDLE_META_RECORD(MD_HC_DO_STATIC_COMPRESSION,  m_fEnableStaticCompression)
      HANDLE_META_RECORD(MD_HC_DO_DYNAMIC_COMPRESSION, m_fEnableDynamicCompression)
      HANDLE_META_RECORD(MD_HC_DO_DISK_SPACE_LIMITING, m_fLimitDirectorySize)
      HANDLE_META_RECORD(MD_HC_MAX_DISK_SPACE_USAGE,   m_dwDirectorySize)
      HANDLE_META_RECORD(MD_HC_COMPRESSION_DIRECTORY,  m_strDirectory)
    END_PARSE_META_RECORDS
}



/* virtual */
HRESULT 
CIISCompressionProps::WriteDirtyProps()
/*++

Routine Description:

    Write dirty properties

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CError err;

    BEGIN_META_WRITE()
      META_WRITE(MD_HC_DO_STATIC_COMPRESSION,  m_fEnableStaticCompression)
      META_WRITE(MD_HC_DO_DYNAMIC_COMPRESSION, m_fEnableDynamicCompression)
      META_WRITE(MD_HC_DO_DISK_SPACE_LIMITING, m_fLimitDirectorySize)
      META_WRITE(MD_HC_MAX_DISK_SPACE_USAGE,   m_dwDirectorySize)
      META_WRITE(MD_HC_COMPRESSION_DIRECTORY,  m_strDirectory)
    END_META_WRITE(err);

    return err;
}



//
// Mime Types Properties
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

CMimeTypes::CMimeTypes(
    IN LPCTSTR lpszServerName,
    IN LPCTSTR lpszService         OPTIONAL,
    IN DWORD   dwInstance          OPTIONAL,
    IN LPCTSTR lpszParent          OPTIONAL,
    IN LPCTSTR lpszAlias           OPTIONAL
    )
/*++

Routine Description:

    Mime types list constructor

Arguments:

    LPCTSTR lpszServerName     : Name of the server containing the metabase
    LPCTSTR lpszService        : Service name (e.g. "w3svc" or NULL)
    DWORD   dwInstance         : Instance number (could be MASTER_INSTANCE)
    LPCTSTR lpszParent         : Parent path
    LPCTSTR lpszAlias          : Alias name

Return Value:

    N/A

--*/
    : CMetaProperties(
        lpszServerName,
        lpszService,
        dwInstance,
        lpszParent,
        dwInstance == MASTER_INSTANCE  && lpszService == NULL
            ? g_cszMimeMap 
            : lpszAlias
        ),
      //
      // Default properties
      //
      m_strlMimeTypes()
{
}



CMimeTypes::CMimeTypes(
    IN const CMetaInterface * pInterface,
    IN LPCTSTR lpszService                   OPTIONAL,
    IN DWORD   dwInstance                    OPTIONAL,
    IN LPCTSTR lpszParent                    OPTIONAL,
    IN LPCTSTR lpszAlias                     OPTIONAL
    )
/*++

Routine Description:

    Mime types list constructor

Arguments:

    CMetaInterface * pInterface : Existing interface
    LPCTSTR lpszService         : Service name (e.g. "w3svc" or NULL)
    DWORD   dwInstance          : Instance number (could be MASTER_INSTANCE)
    LPCTSTR lpszParent          : Parent path
    LPCTSTR lpszAlias           : Alias name

Return Value:

    N/A

--*/
    : CMetaProperties(
        pInterface,
        lpszService,
        dwInstance,
        lpszParent,
        dwInstance == MASTER_INSTANCE && lpszService == NULL
            ? g_cszMimeMap 
            : lpszAlias
        ),
      //
      // Default properties
      //
      m_strlMimeTypes()
{
}



void
CMimeTypes::ParseFields()
/*++

Routine Description:

    Parse the fetched data into fields

Arguments:


    None

Return Value:

    None

--*/
{
    BEGIN_PARSE_META_RECORDS(m_dwNumEntries, m_pbMDData)
      HANDLE_META_RECORD(MD_MIME_MAP, m_strlMimeTypes)
    END_PARSE_META_RECORDS
}



/* virtual */
HRESULT
CMimeTypes::WriteDirtyProps()
/*++

Routine Description:

    Write the dirty properties to the metabase

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CError err;

    BEGIN_META_WRITE()
      META_WRITE(MD_MIME_MAP, m_strlMimeTypes);
    END_META_WRITE(err);

    return err;
}




//
// Server Capabilities
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



CServerCapabilities::CServerCapabilities(
    IN LPCTSTR lpszServerName,
    IN LPCTSTR lpszService,        OPTIONAL
    IN DWORD   dwInstance          OPTIONAL
    )
/*++

Routine Description:

    Constructor for server capabilities object

Arguments:

    LPCTSTR lpszServerName     : Server name
    LPCTSTR lpszService        : Service name (optional)
    DWORD   dwInstance         : Instance number -- ignored (will be removed)

Return Value:

    N/A

--*/
    : CMetaProperties(
        lpszServerName,
        lpszService,
        MASTER_INSTANCE, 
        g_cszInfo
        ),
      //
      // Default properties
      //
      m_dwPlatform(),
      m_dwVersionMajor(),
      m_dwVersionMinor(),
      m_dwCapabilities((DWORD)~IIS_CAP1_10_CONNECTION_LIMIT),
      m_dwConfiguration(0L)
{
    m_dwMDUserType = IIS_MD_UT_SERVER;
    m_dwMDDataType = DWORD_METADATA;
}



/* virtual */
void
CServerCapabilities::ParseFields()
/*++

Routine Description:

    Parse the fetched data into fields

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Only reading UT_SERVER, DWORD_METADATA.
    //
    BEGIN_PARSE_META_RECORDS(m_dwNumEntries,           m_pbMDData)
      HANDLE_META_RECORD(MD_SERVER_PLATFORM,           m_dwPlatform)
      HANDLE_META_RECORD(MD_SERVER_VERSION_MAJOR,      m_dwVersionMajor)
      HANDLE_META_RECORD(MD_SERVER_VERSION_MINOR,      m_dwVersionMinor)
      HANDLE_META_RECORD(MD_SERVER_CAPABILITIES,       m_dwCapabilities)
      HANDLE_META_RECORD(MD_SERVER_CONFIGURATION_INFO, m_dwConfiguration)
    END_PARSE_META_RECORDS
}



//
// Instance Properties
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



/* static */
LPCTSTR
CInstanceProps::GetDisplayText(
    OUT CString & strName,
    IN  LPCTSTR szComment,
    IN  LPCTSTR szHostHeaderName,
    IN  LPCTSTR szServiceName,
    IN  CIPAddress & ia,
    IN  UINT uPort,
    IN  DWORD dwID
    )
/*++

Routine Description:

    Build display text from instance information

Arguments:

    CString & strName
    LPCTSTR szComment
    LPCTSTR szHostHeaderName
    LPCTSTR szServiceName
    CIPAddress & ia
    UINT uPort
    DWORD dwID

Return Value:

    Pointer to the name buffer.

--*/
{
    //
    // Generate display name
    //
    // First use the comment,
    // if that's not available, use the host header name,
    // if that's not available, use the IP address:port.
    // If that's not available, use the instance number.
    // 
    //
    CString strFmt;

    if (szComment && *szComment)
    {
        strName = szComment;
    }
    else if (szHostHeaderName && *szHostHeaderName)
    {
        strName = szHostHeaderName;
    }
    else
    {

#ifndef _COMSTATIC

        HINSTANCE hOld = AfxGetResourceHandle();
        AfxSetResourceHandle(GetModuleHandle(COMPROP_DLL_NAME));

#endif // _COMSTATIC

        if(!ia.IsZeroValue() && uPort != 0)
        {
            VERIFY(strFmt.LoadString(IDS_INSTANCE_PORT_FMT));
            strName.Format(strFmt,(LPCTSTR)ia, uPort);
        }
        else
        {
//            VERIFY(strFmt.LoadString(IDS_INSTANCE_DEF_FMT));
//            strName.Format(strFmt, szServiceName, dwID);
			if (0 == _tcscmp(szServiceName, _T("FTP")))
			{
				VERIFY(strFmt.LoadString(IDS_INSTANCE_DEF_FMT_FTP));
			}
			else if (0 == _tcscmp(szServiceName, _T("Web")))
			{
				VERIFY(strFmt.LoadString(IDS_INSTANCE_DEF_FMT_WEB));
			}
            strName.Format(strFmt, dwID);
        }

#ifndef _COMSTATIC

        AfxSetResourceHandle(hOld);

#endif // _COMSTATIC

    }

    return strName;
}



/* static */
void
CInstanceProps::CrackBinding(
    IN  CString strBinding,
    OUT CIPAddress & iaIpAddress,
    OUT UINT & nTCPPort,
    OUT CString & strDomainName
    )
/*++

Routine Description:

    Helper function to crack a binding string

Arguments:

    CString strBinding          : Binding string to be parsed
    CIPAddress & iaIpAddress    : IP Address output
    UINT & nTCPPort             : TCP Port
    CString & strDomainName     : Domain (host) header name

Return Value:

    None

--*/
{
    //
    // Zero initialize
    //
    iaIpAddress.SetZeroValue();
    nTCPPort = 0;
    strDomainName.Empty();

    int iColonPos = strBinding.Find(_TCHAR(':'));

    if(iColonPos != -1)
    {
        //
        // Get the IP address
        //
        iaIpAddress = strBinding.Left(iColonPos);

        //
        // Look for the second colon
        //
        strBinding = strBinding.Mid(iColonPos + 1);
        iColonPos = strBinding.Find(_TCHAR(':'));
    }

    if(iColonPos != -1)
    {
        //
        // Get the port number
        //
        nTCPPort = ::_ttol(strBinding.Left(iColonPos));

        //
        // Look for the NULL termination
        //
        strBinding = strBinding.Mid(iColonPos + 1);
        iColonPos = strBinding.Find(_TCHAR('\0'));
    }

    if(iColonPos != -1)
    {
        strDomainName = strBinding.Left(iColonPos);
    }
}



/* static */
void
CInstanceProps::CrackSecureBinding(
    IN  CString strBinding,
    OUT CIPAddress & iaIpAddress,
    OUT UINT & nSSLPort
    )
/*++

Routine Description:

    Helper function to crack a secure binding string

Arguments:

    CString strBinding          : Binding string to be parsed
    CIPAddress & iaIpAddress    : IP Address output
    UINT & nSSLPort             : SSL Port

Return Value:

    None

--*/
{
    //
    // Same as regular binding without domain name
    //
    CString strDomainName;

    CrackBinding(strBinding, iaIpAddress, nSSLPort, strDomainName);

    ASSERT(strDomainName.IsEmpty());
}




/* static */
int
CInstanceProps::FindMatchingSecurePort(
    IN  CStringList & strlSecureBindings,
    IN  CIPAddress & iaIPAddress,
    OUT UINT & nSSLPort
    )
/*++

Routine Description:

    Find the SSL port applicable to the given IP Address.

Arguments:

    CStringList & strlSecureBindings : Input stringlist of secure bindings
    CIPAddress & iaIPAddress         : IP Address to target
    UINT & nSSLPort                  : Returns the SSL Port

Return Value:

    The index of the binding string, or -1 if not found.

Notes:

    The SSL port will be set to 0, if the IP address does not exist.

    A 0.0.0.0 ip address translates to "All Unassigned".

--*/
{
    nSSLPort = 0;

    int cItems = 0;
    POSITION pos = strlSecureBindings.GetHeadPosition();

    while(pos)
    {
        CString & strBinding = strlSecureBindings.GetNext(pos);

        CIPAddress ia;
        UINT nPort;
        CrackSecureBinding(strBinding, ia, nPort);

        if (ia == iaIPAddress)
        {
            //
            // Found it!
            //
            nSSLPort = nPort;
            return cItems;
        }

        ++cItems;
    }

    //
    // Not found
    //
    return -1;
}



/* static */
BOOL
CInstanceProps::IsPortInUse(
    IN CStringList & strlBindings,
    IN CIPAddress & iaIPAddress,
    IN UINT nPort
    )
/*++

Routine Description:

    Check to see if the give ip address/port combination is in use.

Arguments:

    CStringList & strlBindings    : Input stringlist of bindings
    CIPAddress & iaIpAddress      : IP Address target
    UINT nPort                    : Port

Return Value:

    TRUE if the given ip address/port combo is in use

Notes:

    Host header name is ignored


--*/
{
    POSITION pos = strlBindings.GetHeadPosition();

    while(pos)
    {
        CString & strBinding = strlBindings.GetNext(pos);

        CIPAddress ia;
        UINT n;
        CString str;
        CrackBinding(strBinding, ia, n, str);

        if (ia == iaIPAddress && n == nPort)
        {
            //
            // Found it!
            //
            return TRUE;
        }
    }

    //
    // Not found
    //
    return FALSE;

}



/* static */
void
CInstanceProps::BuildBinding(
    OUT CString & strBinding,
    IN  CIPAddress & iaIpAddress,
    IN  UINT & nTCPPort,
    IN  CString & strDomainName
    )
/*++

Routine Description:

    Build up a binding string from its component parts

Arguments:

    CString & strBinding        : Output binding string
    CIPAddress & iaIpAddress    : ip address (could be 0.0.0.0)
    UINT & nTCPPort             : TCP Port
    CString & strDomainName     : Domain name (host header)

Return Value:

    None.

--*/
{
    if (!iaIpAddress.IsZeroValue())
    {
        strBinding.Format(
            _T("%s:%d:%s"),
            (LPCTSTR)iaIpAddress,
            nTCPPort,
            (LPCTSTR)strDomainName
            );
    }
    else
    {
        //
        // Leave the ip address field blank
        //
        strBinding.Format(_T(":%d:%s"), nTCPPort, (LPCTSTR)strDomainName);
    }
}



/* static */
void
CInstanceProps::BuildSecureBinding(
    OUT CString & strBinding,
    IN  CIPAddress & iaIpAddress,
    IN  UINT & nSSLPort
    )
/*++

Routine Description:

    Build up a binding string from its component parts

Arguments:

    CString & strBinding        : Output binding string
    CIPAddress & iaIpAddress    : ip address (could be 0.0.0.0)
    UINT & nSSLPort             : SSL Port

Return Value:

    None.

--*/
{
    CString strDomainName;

    BuildBinding(strBinding, iaIpAddress, nSSLPort, strDomainName);
}



CInstanceProps::CInstanceProps(
    IN LPCTSTR lpszServerName,
    IN LPCTSTR lpszService,        //  e.g. "W3SVC"
    IN DWORD   dwInstance          OPTIONAL,
    IN UINT    nDefPort            OPTIONAL
    )
/*++

Routine Description:

    Constructor for instance properties

Arguments:

    LPCTSTR lpszServerName     : Name of server
    LPCTSTR lpszService        : Name of service (e.g. "W3SVC")
    DWORD   dwInstance         : Instance number (or MASTER_INSTANCE)

Return Value:

    N/A

--*/
    : CMetaProperties(lpszServerName, lpszService, dwInstance),
      m_dwInstance(dwInstance),
      m_dwWin32Error(ERROR_SUCCESS),
      //
      // Default Instance Values
      //
      m_strlBindings(),
      m_strComment(),
      m_fNotDeletable(FALSE),
      m_fCluster(FALSE),
      m_nTCPPort(nDefPort),
      m_iaIpAddress(NULL_IP_ADDRESS),
      m_strDomainName(),
      m_dwState(MD_SERVER_STATE_STOPPED),
      m_nISMState(INetServiceUnknown)
{
    //
    // Fetch just enough info for the enumeration
    //
    m_dwMDUserType = IIS_MD_UT_SERVER;
}



CInstanceProps::CInstanceProps(
    IN const CMetaInterface * pInterface,
    IN LPCTSTR lpszService,                 //  e.g. "W3SVC"
    IN DWORD   dwInstance                   OPTIONAL,
    IN UINT    nDefPort                     OPTIONAL
    )
/*++

Routine Description:

    Constructor that uses an existing interface

Arguments:

    CMetaInterface * pInterface : Existing interface
    LPCTSTR lpszService         : Name of service (e.g. "W3SVC")
    DWORD   dwInstance          : Instance number (or MASTER_INSTANCE)

Return Value:

    N/A

--*/
    : CMetaProperties(pInterface, lpszService, dwInstance),
      m_dwInstance(dwInstance),
      m_dwWin32Error(ERROR_SUCCESS),
      //
      // Default Instance Values
      //
      m_strlBindings(),
      m_strComment(),
      m_fNotDeletable(FALSE),
      m_fCluster(FALSE),
      m_nTCPPort(nDefPort),
      m_iaIpAddress((LONG)0),
      m_strDomainName(),
      m_dwState(MD_SERVER_STATE_STOPPED),
      m_nISMState(INetServiceUnknown)
{
    //
    // Fetch enough for enumeration only
    //
    m_dwMDUserType = IIS_MD_UT_SERVER;
}



CInstanceProps::CInstanceProps(
    IN CMetaKey * pKey,
    IN DWORD   dwInstance,
    IN UINT    nDefPort            OPTIONAL
    )
/*++

Routine Description:

    Read instance properties off an open key

Arguments:

    CMetaKey * pKey     : Open key
    DWORD   dwInstance  : Instance number
    UINT    nDefPort    : Default port number

Return Value:

    N/A

--*/
    : CMetaProperties(pKey, dwInstance),
      m_dwInstance(dwInstance),
      m_dwWin32Error(ERROR_SUCCESS),
      //
      // Default Instance Values
      //
      m_strlBindings(),
      m_strComment(),
      m_fNotDeletable(FALSE),
      m_fCluster(FALSE),
      m_nTCPPort(nDefPort),
      m_iaIpAddress((LONG)0),
      m_strDomainName(),
      m_dwState(MD_SERVER_STATE_STOPPED),
      m_nISMState(INetServiceUnknown)
{
    //
    // Fetch enough for enumeration only
    //
    m_dwMDUserType = IIS_MD_UT_SERVER;
}



void
CInstanceProps::SetISMStateFromServerState()
/*++

Routine Description:

    Translate server state to ISM state value

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    // Derive Values
    //
    switch(m_dwState)
    {
    case MD_SERVER_STATE_STARTED:
        m_nISMState = INetServiceRunning;
        break;

    case MD_SERVER_STATE_STOPPED:
        m_nISMState = INetServiceStopped;
        break;

    case MD_SERVER_STATE_PAUSED:
        m_nISMState  = INetServicePaused;
        break;

    case MD_SERVER_STATE_CONTINUING:
    default:
        m_nISMState = INetServiceUnknown;
        break;
    }
}



/* virtual */
void
CInstanceProps::ParseFields()
/*++

Routine Description:

    Break into fields.

Arguments:

    None.

Return Value:

    None.

--*/
{
    BEGIN_PARSE_META_RECORDS(m_dwNumEntries, m_pbMDData)
      HANDLE_META_RECORD(MD_SERVER_BINDINGS, m_strlBindings)
      HANDLE_META_RECORD(MD_SERVER_COMMENT,  m_strComment)
      HANDLE_META_RECORD(MD_SERVER_STATE,    m_dwState)
      HANDLE_META_RECORD(MD_WIN32_ERROR,     m_dwWin32Error);
      HANDLE_META_RECORD(MD_NOT_DELETABLE,   m_fNotDeletable);
      HANDLE_META_RECORD(MD_CLUSTER_ENABLED, m_fCluster);
    END_PARSE_META_RECORDS

    //
    // Crack the primary binding
    //
    if (MP_V(m_strlBindings).GetCount() > 0)
    {
        CString & strBinding = MP_V(m_strlBindings).GetHead();
        CrackBinding(strBinding, m_iaIpAddress, m_nTCPPort, m_strDomainName);
    }

    SetISMStateFromServerState();
}



/* virtual */
HRESULT
CInstanceProps::WriteDirtyProps()
/*++

Routine Description:

    Write the dirty properties to the metabase

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CError err;

    BEGIN_META_WRITE()
      META_WRITE(MD_SERVER_BINDINGS, m_strlBindings)
      META_WRITE(MD_SERVER_COMMENT,  m_strComment)
      META_WRITE(MD_SERVER_STATE,    m_dwState)
    END_META_WRITE(err);

    return err;
}



HRESULT
CInstanceProps::ChangeState(
    IN int nNewState
    )
/*++

Routine Description:

    Change the state of the instance

Arguments:

    int nNewState   : ISM service state value

Return Value:

    HRESULT

--*/
{
    DWORD  dwTargetState;
    DWORD  dwPendingState;
    DWORD  dwCommand;
    CError err;

    switch(nNewState)
    {
    case INetServiceStopped:
        dwTargetState = MD_SERVER_STATE_STOPPED;
        dwPendingState = MD_SERVER_STATE_STOPPING;
        dwCommand = MD_SERVER_COMMAND_STOP;
        break;

    case INetServiceRunning:
        dwTargetState = MD_SERVER_STATE_STARTED;
        if (m_nISMState == INetServicePaused)
        {
            dwPendingState = MD_SERVER_STATE_CONTINUING;
            dwCommand = MD_SERVER_COMMAND_CONTINUE;
        }
        else
        {
            dwPendingState = MD_SERVER_STATE_STARTING;
            dwCommand = MD_SERVER_COMMAND_START;
        }
        break;

    case INetServicePaused:
        dwTargetState = MD_SERVER_STATE_PAUSED;
        dwPendingState = MD_SERVER_STATE_PAUSING;
        dwCommand = MD_SERVER_COMMAND_PAUSE;
        break;

    default:
        ASSERT(FALSE && "Invalid service state requested");
        err = ERROR_INVALID_PARAMETER;
    }

    err = OpenForWriting(FALSE);

    if (err.Succeeded())
    {
        err = SetValue(MD_SERVER_COMMAND, dwCommand);
        Close();
    }

    if (err.Succeeded())
    {
        //
        // Wait for the service to attain desired state, timeout
        // after specified interval
        //
        DWORD dwSleepTotal = 0L;
        DWORD dwOldState = m_dwState;

        if (dwOldState == dwTargetState)
        {
            //
            // Current state matches desired
            // state already.  ISM must be behind
            // the times.  
            //
            return err;
        }

        //
        // CODEWORK: Write a 0 win32error to the instance properties
        //           prior to attempting to start the instance.
        //
        m_dwWin32Error = 0;

        while (dwSleepTotal < MAX_SLEEP_INST)
        {
            err = LoadData();

            if (err.Failed())
            {
                break;
            }

            if ((m_dwState != dwPendingState && m_dwState != dwOldState) 
              || m_dwWin32Error != ERROR_SUCCESS
               )
            {
                //
                // Done one way or another
                //
                if (m_dwState != dwTargetState)
                {
                    //
                    // Did not achieve desired result. Something went
                    // wrong.
                    //
                    if (m_dwWin32Error)
                    {
                        err = m_dwWin32Error;
                    }
                }

                break;
            }

            //
            // Still pending...
            //
            ::Sleep(SLEEP_INTERVAL);

            dwSleepTotal += SLEEP_INTERVAL;
        }

        if (dwSleepTotal >= MAX_SLEEP_INST)
        {
            //
            // Timed out.  If there is a real error in the metabase
            // use it, otherwise use a generic timeout error
            //
            err = m_dwWin32Error;
            if (err.Succeeded())
            {
                err = ERROR_SERVICE_REQUEST_TIMEOUT;
            }
        }

        //
        // Update state information
        //
        SetISMStateFromServerState();
    }

    return err;
}



/* static */
HRESULT
CInstanceProps::Add(
    IN  const CMetaInterface * pInterface,
    IN  LPCTSTR lpszService,
    IN  LPCTSTR lpszHomePath,
    IN  LPCTSTR lpszUserName,       OPTIONAL
    IN  LPCTSTR lpszPassword,       OPTIONAL
    IN  LPCTSTR lpszDescription,    OPTIONAL
    IN  LPCTSTR lpszBinding,        OPTIONAL
    IN  LPCTSTR lpszSecureBinding,  OPTIONAL
    IN  DWORD * pdwPermissions,     OPTIONAL
    IN  DWORD * pdwDirBrowsing,     OPTIONAL
    IN  DWORD * pwdAuthFlags,       OPTIONAL
    OUT DWORD * pdwInstance         OPTIONAL
    )
/*++

Routine Description:

    Create a new instance.  Find a free instance number, and attempt
    to create it. Optionally return the new instance number.

Arguments:

    const CMetaInterface * pInterface : Existing interface
    LPCTSTR lpszService        : Service name
    LPCTSTR lpszHomePath       : physical path for the new home directory
    LPCTSTR lpszUserName       : User name
    LPCTSTR lpszPassword       : Password
    LPCTSTR lpszDescription    : Optional instance description.
    LPCTSTR lpszBinding        : Binding string
    LPCTSTR lpszSecureBinding  : Secure binding string
    DWORD * pdwPermission      : Permission bits
    DWORD * pdwDirBrowsing     : Directory browsing
    DWORD * pwdAuthFlags       : Authorization flags
    DWORD * pdwInstance        : Buffer to the new instance number

Return Value:

    HRESULT

--*/
{
    CMetaKey mk(pInterface, METADATA_PERMISSION_WRITE, lpszService);
    CError err(mk.QueryResult());

    if (err.Failed())
    {
        //
        // The service key MUST exist!
        //
        ASSERT(err.Win32Error() != ERROR_PATH_NOT_FOUND);

        return err;
    }

    //
    // Loop through until we find a free instance number.  This
    // is not ideal, but the only way to do this for now.
    //
    CString strPath;
    LPTSTR lp = strPath.GetBuffer(MAX_INSTANCE_LEN);

    for (DWORD dw = FIRST_INSTANCE; dw <= LAST_INSTANCE; ++dw)
    {
        ::_ultot(dw, lp, 10);
        err = mk.DoesPathExist(lp);

        if (err.Failed())
        {
            if (err.Win32Error() != ERROR_PATH_NOT_FOUND)
            {
                //
                // Unexpected error
                //
                return err;
            }

            //
            // Ok, now create it
            //
            strPath.ReleaseBuffer();
            err = mk.AddKey(strPath);

            if (err.Succeeded())
            {
                if (pdwInstance)
                {
                    //
                    // Store instance number
                    //
                    *pdwInstance = dw;
                }

                //
                // Write the key name (hack for  beta 2)
                //
                CString strKeyName;
                CString strKeyDirName;

                if (!::lstrcmpi(lpszService, _T("w3svc")))
                {
                    strKeyName = _T("IIsWebServer");
                    strKeyDirName = _T("IIsWebVirtualDir");

                }
                else if (!::lstrcmpi(lpszService, _T("msftpsvc")))
                {
                    strKeyName = _T("IIsFtpServer");
                    strKeyDirName = _T("IIsFtpVirtualDir");
                }
                else
                {
                    ASSERT(FALSE && "unrecognize service name");
                }

                err = mk.SetValue(
                    MD_KEY_TYPE, 
                    strKeyName,
                    NULL,
                    strPath
                    );

                //
                // Optionally write the description field
                //
                if (lpszDescription)
                {
                    CString strDescription(lpszDescription);
                    err = mk.SetValue(
                        MD_SERVER_COMMENT, 
                        strDescription,
                        NULL,
                        strPath
                        );
                }

                //
                // The service binding
                //
                if (lpszBinding)
                {
                    CString strBinding(lpszBinding);
                    CStringListEx strlBindings;
                    strlBindings.AddTail(strBinding);
                    err = mk.SetValue(
                        MD_SERVER_BINDINGS, 
                        strlBindings,
                        NULL,
                        strPath
                        );
                }

                //
                // The secure binding
                //
                if (lpszSecureBinding)
                {
                    CString strBinding(lpszSecureBinding);
                    CStringListEx strlBindings;
                    strlBindings.AddTail(strBinding);
                    err = mk.SetValue(
                        MD_SECURE_BINDINGS, 
                        strlBindings,
                        NULL,
                        strPath
                        );
                }

                strPath += g_cszSep;
                strPath += g_cszRoot;

                //
                // Now add the home directory for it
                //
                err = mk.AddKey(strPath);
                if(err.Succeeded())
                {
                    CString strHomePath(lpszHomePath);
                    err = mk.SetValue(MD_VR_PATH,  strHomePath, NULL, strPath);
                    err = mk.SetValue(MD_KEY_TYPE, strKeyDirName, NULL, strPath);

                    if (pwdAuthFlags)
                    {
                        err = mk.SetValue(
                            MD_AUTHORIZATION, 
                            *pwdAuthFlags,
                            NULL, 
                            strPath
                            );
                    }

                    if (lpszUserName != NULL)
                    {
                        ASSERT(lpszPassword != NULL);

                        CString strUserName(lpszUserName);
                        err = mk.SetValue(
                            MD_VR_USERNAME, 
                            strUserName,
                            NULL, 
                            strPath
                            );
                    }

                    if (lpszPassword != NULL)
                    {
                        ASSERT(lpszUserName != NULL);

                        CString strPassword(lpszPassword);
                        err = mk.SetValue(
                            MD_VR_PASSWORD, 
                            strPassword,
                            NULL, 
                            strPath
                            );
                    }

                    if (pdwPermissions != NULL)
                    {
                        err = mk.SetValue(
                            MD_ACCESS_PERM,  
                            *pdwPermissions,
                            NULL, 
                            strPath
                            );
                    }       

                    if (pdwDirBrowsing != NULL)
                    {
                        //
                        // WWW only
                        //
                        err = mk.SetValue(
                            MD_DIRECTORY_BROWSING,  
                            *pdwDirBrowsing,
                            NULL, 
                            strPath
                            );
                    }
                }
            }
  
            return err;
        }
    }

    //
    // 4 billion instances???!!!!! This error message
    // may not be ideal, but it will have to do for now.
    //
    return CError::HResult(ERROR_SHARING_BUFFER_EXCEEDED);
}



/* static */
HRESULT
CInstanceProps::Delete(
    IN const CMetaInterface * pInterface,
    IN LPCTSTR lpszService,
    IN DWORD   dwInstance
    )
/*++

Routine Description:

    Delete the given instance number

Arguments:

    LPCTSTR lpszServer     : Server name
    LPCTSTR lpszService    : Service name (e.g. W3SVC)
    DWORD   dwInstance     : Instance number to be deleted

Return Value:

    HRESULT

--*/
{
    CMetaKey mk(pInterface, METADATA_PERMISSION_WRITE, lpszService);
    CError err(mk.QueryResult());

    if (err.Failed())
    {
        return err;
    }

    CString strPath;
    LPTSTR lp = strPath.GetBuffer(MAX_INSTANCE_LEN);
    ::_ltot(dwInstance, lp, 10);
    strPath.ReleaseBuffer();
    err = mk.DeleteKey(strPath);

    return err;
}



//
// Child node properties
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


//
// Redirect tags
//
const TCHAR   CChildNodeProps::s_chTagSep            = _T(',');
const LPCTSTR CChildNodeProps::s_cszExactDestination = _T("EXACT_DESTINATION");
const LPCTSTR CChildNodeProps::s_cszChildOnly        = _T("CHILD_ONLY");
const LPCTSTR CChildNodeProps::s_cszPermanent        = _T("PERMANENT");



CChildNodeProps::CChildNodeProps(
    IN LPCTSTR lpszServerName,
    IN LPCTSTR lpszService,    OPTIONAL
    IN DWORD   dwInstance,     OPTIONAL
    IN LPCTSTR lpszParent,     OPTIONAL
    IN LPCTSTR lpszAlias,      OPTIONAL
    IN BOOL    fInherit,       OPTIONAL
    IN BOOL    fPathOnly       OPTIONAL
    )
/*++

Routine Description:

    Child node properties (Can be file, dir, or vdir)

Arguments:

    LPCTSTR lpszServerName     : Server name
    LPCTSTR lpszService        : Service name
    DWORD   dwInstance         : Instance number (or MASTER INSTANCE)
    LPCTSTR lpszParent         : Parent path (can be NULL or blank)
    LPCTSTR lpszAlias          : Alias name (can be NULL or blank)
    BOOL    fInherit           : TRUE to inherit values, FALSE otherwise
    BOOL    fPathOnly          : TRUE to only fetch the path

Return Value:

    N/A

--*/
    : CMetaProperties(
        lpszServerName,
        lpszService,
        dwInstance,
        lpszParent,
        lpszAlias
        ),
      m_strAlias(lpszAlias),
      m_strRedirectStatement(),
      m_strRedirectPath(),
      m_fExact(FALSE),
      m_fChild(FALSE),
      m_fPermanent(FALSE),
      m_dwAccessPerms(0L),
      m_dwDirBrowsing(0L),
      m_dwWin32Error(ERROR_SUCCESS),
      m_fIsAppRoot(FALSE),
      m_fAppIsolated(FALSE),
      //
      // Default properties
      //
      m_fPathInherited(FALSE),
      m_strPath()
{
    if (fPathOnly)
    {
        //
        // Fetch only the homeroot physical path
        //
        m_dwMDUserType = IIS_MD_UT_FILE;
        m_dwMDDataType = STRING_METADATA;
    }

    m_strFullMetaPath = m_strMetaRoot;

    //
    // Override base parameters
    //
    m_fInherit = fInherit;
}



CChildNodeProps::CChildNodeProps(
    IN const CMetaInterface * pInterface,
    IN LPCTSTR lpszService,     OPTIONAL
    IN DWORD   dwInstance,      OPTIONAL
    IN LPCTSTR lpszParent,      OPTIONAL
    IN LPCTSTR lpszAlias,       OPTIONAL
    IN BOOL    fInherit,        OPTIONAL
    IN BOOL    fPathOnly        OPTIONAL
    )
/*++

Routine Description:

    Child node properties (Can be file, dir, or vdir)

Arguments:

    CMetaInterface * pInterface : Existing interface
    LPCTSTR lpszService         : Service name
    DWORD   dwInstance          : Instance number (or MASTER INSTANCE)
    LPCTSTR lpszParent          : Parent path (can be NULL or blank)
    LPCTSTR lpszAlias           : Alias name (can be NULL or blank)
    BOOL    fInherit            : TRUE to inherit values, FALSE otherwise
    BOOL    fPathOnly           : TRUE to only fetch the path

Return Value:

    N/A

--*/
    : CMetaProperties(
        pInterface,
        lpszService,
        dwInstance,
        lpszParent,
        lpszAlias
        ),
      m_strAlias(lpszAlias),
      m_strRedirectStatement(),
      m_strRedirectPath(),
      m_fExact(FALSE),
      m_fChild(FALSE),
      m_fPermanent(FALSE),
      m_dwAccessPerms(0L),
      m_dwDirBrowsing(0L),
      m_dwWin32Error(ERROR_SUCCESS),
      m_fIsAppRoot(FALSE),
      m_fAppIsolated(FALSE),
      //
      // Default properties
      //
      m_fPathInherited(FALSE),
      m_strPath()
{
    if (fPathOnly)
    {
        //
        // Fetch only the homeroot physical path
        //
        m_dwMDUserType = IIS_MD_UT_FILE;
        m_dwMDDataType = STRING_METADATA;
    }

    m_strFullMetaPath = m_strMetaRoot;

    //
    // Override base parameters
    //
    m_fInherit = fInherit;
}



CChildNodeProps::CChildNodeProps(
    IN const CMetaKey * pKey,
    IN LPCTSTR lpszPath,        OPTIONAL
    IN BOOL    fInherit,        OPTIONAL 
    IN BOOL    fPathOnly        OPTIONAL   
    )
/*++

Routine Description:

    Construct from open key

Arguments:

    const CMetaKey * pKey    Open key
    LPCTSTR lpszPath         Path               
    BOOL    fInherit         TRUE to inherit properties
    BOOL    fPathOnly        TRUE to only fetch the path

Return Value:

    N/A

--*/
    : CMetaProperties(pKey, lpszPath),
      m_strAlias(lpszPath), // ISSUE: Could be more than a node name
      m_strRedirectStatement(),
      m_strRedirectPath(),
      m_fExact(FALSE),
      m_fChild(FALSE),
      m_fPermanent(FALSE),
      m_dwAccessPerms(0L),
      m_dwDirBrowsing(0L),
      m_dwWin32Error(ERROR_SUCCESS),
      m_fIsAppRoot(FALSE),
      m_fAppIsolated(FALSE),
      //
      // Default properties
      //
      m_fPathInherited(FALSE),
      m_strPath()
{
    if (fPathOnly)
    {
        m_dwMDUserType = IIS_MD_UT_FILE;
        m_dwMDDataType = STRING_METADATA;
    }
    else
    {
        //
        // Build full metabase path, because we need to compare it
        // against the app root path
        //
        m_strFullMetaPath = pKey->QueryMetaPath(); 

        if (lpszPath && *lpszPath)
        {
            m_strFullMetaPath += SZ_MBN_SEP_STR;
            m_strFullMetaPath += lpszPath;
        }
    }

    //
    // Override base parameters
    //
    m_fInherit = fInherit;
}



void
CChildNodeProps::ParseRedirectStatement()
/*++

Routine Description:

    Break down the redirect statement into its component parts (path
    plus directives)

Arguments:

    None

Return Value:

    None

--*/
{
    m_fExact     = FALSE;
    m_fChild     = FALSE;
    m_fPermanent = FALSE;

    m_strRedirectPath = m_strRedirectStatement;

    int nComma = m_strRedirectPath.Find(s_chTagSep);

    if (nComma >= 0)
    {
        //
        // Check past the separator for these tags
        //
        LPCTSTR lpstr = m_strRedirectPath;
        lpstr += (nComma + 1);

        m_fExact     = _tcsstr(lpstr, s_cszExactDestination) != NULL;
        m_fChild     = _tcsstr(lpstr, s_cszChildOnly) != NULL;
        m_fPermanent = _tcsstr(lpstr, s_cszPermanent) != NULL;
        m_strRedirectPath.ReleaseBuffer(nComma);
    }
}



void
CChildNodeProps::BuildRedirectStatement()
/*++

Routine Description:

    Assemble the redirect statement from its component parts (path
    plus directives)

Arguments:

    None

Return Value:

    None

--*/
{
    CString strStatement = m_strRedirectPath;

    ASSERT(strStatement.Find(s_chTagSep) < 0);

    if (m_fExact)
    {
        strStatement += s_chTagSep;
        strStatement += _T(' ');
        strStatement += s_cszExactDestination;
    }

    if (m_fChild)
    {
        strStatement += s_chTagSep;
        strStatement += _T(' ');
        strStatement += s_cszChildOnly;
    }

    if (m_fPermanent)
    {
        strStatement += s_chTagSep;
        strStatement += _T(' ');
        strStatement += s_cszPermanent;
    }

    m_strRedirectStatement = strStatement;
}



/* virtual */
void
CChildNodeProps::ParseFields()
/*++

Routine Description:

    Break into fields.

Arguments:

    None.

Return Value:

    None.

--*/
{
    BEGIN_PARSE_META_RECORDS(m_dwNumEntries, m_pbMDData)
      HANDLE_INHERITED_META_RECORD(MD_VR_PATH,  m_strPath, m_fPathInherited)
      HANDLE_META_RECORD(MD_HTTP_REDIRECT,      m_strRedirectStatement)
      HANDLE_META_RECORD(MD_WIN32_ERROR,        m_dwWin32Error)
      HANDLE_META_RECORD(MD_ACCESS_PERM,        m_dwAccessPerms)
      HANDLE_META_RECORD(MD_DIRECTORY_BROWSING, m_dwDirBrowsing)
      HANDLE_META_RECORD(MD_APP_ROOT,           m_strAppRoot)
      HANDLE_META_RECORD(MD_APP_ISOLATED,       m_fAppIsolated)
    END_PARSE_META_RECORDS

    //
    // Check to see if this is an application root
    //
    if (!MP_V(m_strAppRoot).IsEmpty())
    {
        TRACEEOLID("App root: " << m_strAppRoot);

        //
        // CODEWORK: It's faster to set our app root to the path
        // that WAM expects than to strip off each instance.
        //

        //
        // Clean App root
        //
        if (MP_V(m_strAppRoot)[MP_V(m_strAppRoot).GetLength() - 1] == _T('/'))
        {
            MP_V(m_strAppRoot).ReleaseBuffer(
                MP_V(m_strAppRoot).GetLength() - 1
                );
        }

        if (MP_V(m_strAppRoot)[0] == _T('/'))
        {
            MP_V(m_strAppRoot) = MP_V(m_strAppRoot).Right(
                MP_V(m_strAppRoot).GetLength() - 1
                );
        }

        m_fIsAppRoot = m_strFullMetaPath.CompareNoCase(m_strAppRoot) == 0;
    }

    //
    // Break down redirect statement into component parts
    //
    ParseRedirectStatement();
}



/* virtual */
HRESULT
CChildNodeProps::WriteDirtyProps()
/*++

Routine Description:

    Write the dirty properties to the metabase

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CError err;

    BEGIN_META_WRITE()
      META_WRITE(MD_VR_PATH,            m_strPath)
      META_WRITE(MD_ACCESS_PERM,        m_dwAccessPerms)
      META_WRITE(MD_DIRECTORY_BROWSING, m_dwDirBrowsing)
      if (IsRedirected())
      {
        //
        // (Re-)Assemble the redirect statement from its component parts
        //
        BuildRedirectStatement();
        META_WRITE_INHERITANCE(MD_HTTP_REDIRECT, m_strRedirectStatement, m_fInheritRedirect)
      }
      else
      {
        META_DELETE(MD_HTTP_REDIRECT)
      }
    END_META_WRITE(err);

    return err;
}



/* static */
HRESULT
CChildNodeProps::Add(
    IN  const     CMetaInterface * pInterface,
    IN  LPCTSTR   lpszService,
    IN  DWORD     dwInstance,          OPTIONAL
    IN  LPCTSTR   lpszParentPath,      OPTIONAL
    IN  LPCTSTR   lpszAlias,
    OUT CString & strAliasCreated,
    IN  DWORD *   pdwPermissions,      OPTIONAL
    IN  DWORD *   pdwDirBrowsing,      OPTIONAL
    IN  LPCTSTR   lpszVrPath,          OPTIONAL
    IN  LPCTSTR   lpszUserName,        OPTIONAL
    IN  LPCTSTR   lpszPassword,        OPTIONAL
    IN  BOOL      fExactName
    )
/*++

Routine Description:

    Create new child node.  Optionally, this will append a number
    to the alias name to ensure uniqueness

Arguments:

    const CMetaInterface * pInterface : Existing interface
    LPCTSTR lpszService        : Service name
    DWORD   dwInstance         : Instance number (could be MASTER_INSTANCE)
    LPCTSTR lpszParentPath     : Parent path (could be NULL)
    LPCTSTR lpszAlias          : Desired alias name
    CString & strAliasCreated  : Alias created (may differ)
    DWORD * pdwPermissions     : Permissions
    DWORD * pdwDirBrowsing     : Directory browsing
    LPCTSTR lpszVrPath         : VrPath property
    LPCTSTR lpszUserName       : User name
    LPCTSTR lpszPassword       : Password
    BOOL    fExactName         : If TRUE, do not change the name
                                 to enforce uniqueness.

Return Value:

    HRESULT

--*/
{
    CMetaKey mk(pInterface);
    CError err(mk.QueryResult());

    if (err.Failed())
    {
        //
        // Hopeless...
        //
        return err;
    }

    BOOL fNewPath;

    do
    {
        fNewPath = FALSE;

        err = mk.Open(
            METADATA_PERMISSION_WRITE, 
            lpszService,
            dwInstance,
            lpszParentPath
            );

        if (err.Win32Error() == ERROR_PATH_NOT_FOUND)
        {
            //
            // This could happen -- creating a virtual
            // server underneath a physical directory
            // which does not exist in the metabase
            //
            err = mk.Open(
                METADATA_PERMISSION_WRITE,
                lpszService,
                dwInstance
                );

            if (err.Failed())
            {
                //
                // This really should never fail, because we're opening
                // the path at the instance.
                //
                TRACEEOLID("Instance path does not exist");
                ASSERT(FALSE);
                break;
            }

            err = mk.AddKey(lpszParentPath);

            fNewPath = err.Succeeded();

            mk.Close();
        }
    }
    while(fNewPath);

    if (err.Failed())
    {
        return err;
    }

    strAliasCreated = lpszAlias;
    DWORD dw = 2;

    FOREVER
    {
        //
        // Append a number if the name is not unique.
        //
        err = mk.DoesPathExist(strAliasCreated);

        if (err.Failed())
        {
            if (err.Win32Error() != ERROR_PATH_NOT_FOUND)
            {
                //
                // Unexpected error
                //
                return err;
            }

            //
            // Ok, now create it
            //
            err = mk.AddKey(strAliasCreated);
            if (err.Succeeded())
            {
                //
                // Write the ADSI key name (hack for  beta 2)
                //
                CString strKeyName;

                if (!::lstrcmpi(lpszService, _T("w3svc")))
                {
                    strKeyName = _T("IIsWebVirtualDir");
                }
                else if (!::lstrcmpi(lpszService, _T("msftpsvc")))
                {
                    strKeyName = _T("IIsFtpVirtualDir");
                }
                else
                {
                    ASSERT(FALSE && "unrecognize service name");
                }

                err = mk.SetValue(
                    MD_KEY_TYPE, 
                    strKeyName,
                    NULL,
                    strAliasCreated
                    );

                if (lpszVrPath != NULL)
                {
                    CString strVrPath(lpszVrPath);
                    err = mk.SetValue(
                        MD_VR_PATH, 
                        strVrPath, 
                        NULL, 
                        strAliasCreated
                        );
                }

                if (lpszUserName != NULL)
                {
                    ASSERT(lpszPassword != NULL);

                    CString strUserName(lpszUserName);
                    err = mk.SetValue(
                        MD_VR_USERNAME, 
                        strUserName,
                        NULL,
                        strAliasCreated
                        );
                }

                if (lpszPassword != NULL)
                {
                    ASSERT(lpszUserName != NULL);

                    CString strPassword(lpszPassword);
                    err = mk.SetValue(
                        MD_VR_PASSWORD, 
                        strPassword,
                        NULL,
                        strAliasCreated
                        );
                }

                if (pdwPermissions != NULL)
                {
                    err = mk.SetValue(
                        MD_ACCESS_PERM, 
                        *pdwPermissions,
                        NULL,
                        strAliasCreated
                        );
                }

                if (pdwDirBrowsing != NULL)
                {
                    //
                    // WWW only
                    //
                    err = mk.SetValue(
                        MD_DIRECTORY_BROWSING,  
                        *pdwDirBrowsing,
                        NULL,
                        strAliasCreated
                        );
                }
            }

            return err;
        }

        //
        // Name is not unique, increase the number and try
        // again if permitted to so.  Otherwise return the
        // 'path exists' error.
        //
        if (fExactName)
        {
            err = ERROR_ALREADY_EXISTS;
            return err;
        }

        TCHAR szNumber[32];
        ::_ultot(dw++, szNumber, 10);
        strAliasCreated = lpszAlias;
        strAliasCreated += szNumber;

        //
        // Continue on...
        //
    }
}



/* static */
HRESULT
CChildNodeProps::Delete(
    IN const CMetaInterface * pInterface,
    IN LPCTSTR lpszService,
    IN DWORD   dwInstance,      OPTIONAL
    IN LPCTSTR lpszParentPath,  OPTIONAL
    IN LPCTSTR lpszNode
    )
/*++

Routine Description:

    Delete child node off the given parent path

Arguments:

    const CMetaInterface * pInterface, Existing interface
    LPCTSTR lpszService        : Service name
    DWORD   dwInstance         : Instance number (could be MASTER_INSTANCE)
    LPCTSTR lpszParentPath     : Parent path (could be NULL)
    LPCTSTR lpszNode           : Name of node to be deleted

Return Value:

    HRESULT

--*/
{
    CMetaKey mk(
        pInterface, 
        METADATA_PERMISSION_WRITE, 
        lpszService,
        dwInstance,
        lpszParentPath
        );
    CError err(mk.QueryResult());

    if (err.Failed())
    {
        return err;
    }

    err = mk.DeleteKey(lpszNode);

    return err;
}



/* static */
HRESULT
CChildNodeProps::Rename(
    IN const CMetaInterface * pInterface,
    IN LPCTSTR lpszService,
    IN DWORD   dwInstance,          OPTIONAL
    IN LPCTSTR lpszParentPath,      OPTIONAL
    IN LPCTSTR lpszOldName,
    IN LPCTSTR lpszNewName
    )
/*++

Routine Description:

    Rename a child node off the given path

Arguments:

    IN const CMetaInterface * pInterface : Existing interface
    LPCTSTR lpszService        : Service name
    DWORD   dwInstance         : Instance number (could be MASTER_INSTANCE)
    LPCTSTR lpszParentPath     : Parent path (could be NULL)
    LPCTSTR lpszOldName        : Old node name
    LPCTSTR lpszNewName        : New node name

Return Value:

    HRESULT

--*/
{
    CMetaKey mk(
        pInterface, 
        METADATA_PERMISSION_WRITE, 
        lpszService,
        dwInstance,
        lpszParentPath
        );

    CError err(mk.QueryResult());

    if (err.Failed())
    {
        return err;
    }

    err = mk.RenameKey(lpszOldName, lpszNewName);

    return err;
}



//
// ISM Helpers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



HRESULT
COMDLL_RebindInterface(
    OUT IN CMetaInterface * pInterface,
    OUT BOOL * pfContinue,
    IN  DWORD dwCancelError
    )
/*++

Routine Description:

    Rebind the interface

Arguments:

    CMetaInterface * pInterface : Interface to rebind
    BOOL * pfContinue           : Returns TRUE to continue.
    DWORD  dwCancelError        : Return code on cancel

Return Value:

    HRESULT

--*/
{
    CError err;
    CString str, strFmt;

    ASSERT(pInterface != NULL);
    ASSERT(pfContinue != NULL);

    VERIFY(strFmt.LoadString(IDS_RECONNECT_WARNING));
    str.Format(strFmt, (LPCTSTR)pInterface->QueryServerName());

    if (*pfContinue = (YesNoMessageBox(str)))
    {
        //
        // Attempt to rebind the handle
        //
        err = pInterface->Regenerate();
    }
    else
    {
        //
        // Do not return an error in this case.
        //
        err = dwCancelError;
    }

    return err;
}




HRESULT 
COMDLL_ISMEnumerateInstances(
    IN  CMetaInterface * pInterface,
    OUT ISMINSTANCEINFO * pii,
    OUT IN HANDLE * phEnum,
    IN  LPCTSTR lpszService
    )
/*++

Routine Description:

    Enumerate Instances.  First call with *phEnum == NULL.

Arguments:

    CMetaInterface * pInterface : Existing interface
    ISMINSTANCEINFO * pii       : Buffer
    HANDLE * phEnum             : Enumeration handle.
    LPCTSTR lpszService         : Service name

Return Value:

    HRESULT

--*/
{
    ASSERT(pii != NULL);
    ASSERT(phEnum != NULL);
    ASSERT(pii->dwSize == ISMINSTANCEINFO_SIZE);
    ASSERT(pInterface != NULL);

    CMetaEnumerator * pme = (CMetaEnumerator *)*phEnum;

    if (pme == NULL)
    {
        //
        // Starting enumeration
        //
        pme = new CMetaEnumerator(pInterface, lpszService);
    }

    if (pme == NULL)
    {
        return CError::HResult(ERROR_NOT_ENOUGH_MEMORY);
    }

    CError err(pme->QueryResult());
    
    if (err.Win32Error() == ERROR_PATH_NOT_FOUND)
    {
        //
        // Base path didn't exist
        //
        err = ERROR_NO_MORE_ITEMS;
    }

    CString strHome;

    if (err.Succeeded())
    {
        DWORD dwInstance;

        err = pme->Next(dwInstance);

        if (err.Succeeded())
        {
            //
            // Read off the open key 
            //
            CInstanceProps inst(pme, dwInstance);

            err = inst.LoadData();

            DWORD dwWin32Error = err;

            if (err.Win32Error() == ERROR_ACCESS_DENIED)
            {
                err.Reset();
            }

            if (err.Succeeded())
            {
                inst.FillInstanceInfo(pii, dwWin32Error);

                inst.GetHomePath(strHome);
                TRACEEOLID(strHome);

                //
                // Get home directory path
                //
                CChildNodeProps home(
                    pme,
                    strHome,
                    WITHOUT_INHERITANCE,
                    TRUE                    // Path only
                    );
                
                err = home.LoadData();

                if (err.Win32Error() == ERROR_ACCESS_DENIED)
                {
                    err.Reset();
                }

                if (err.Succeeded())
                {
                    home.FillInstanceInfo(pii);                    
                }
            }
        }
    }

    if (err.Win32Error() == ERROR_NO_MORE_ITEMS
     || err.Win32Error() == RPC_S_SERVER_UNAVAILABLE)
    {
        //
        // Finished the enumerator
        //
        delete pme;
        pme = NULL;
    }

    *phEnum = (HANDLE)pme;

    return err;
}



HRESULT
COMDLL_ISMEnumerateChildren(
    IN  CMetaInterface * pInterface,
    OUT ISMCHILDINFO * pii,
    OUT IN HANDLE * phEnum,
    IN  LPCTSTR lpszService,
    IN  DWORD   dwInstance,
    IN  LPCTSTR lpszParent
    )
/*++

Routine Description:

    Enumerate children.  First call with *phEnum == NULL. 

Arguments:

    CMetaInterface * pInterface : Existing interface
    ISMCHILDINFO * pii          : Buffer
    HANDLE * phEnum             : Enumeration handle.
    LPCTSTR lpszService         : Service name
    DWORD   dwInstance          : Instance number
    LPCTSTR lpszParent          : Parent path

Return Value:

    HRESULT

--*/
{
    ASSERT(pii != NULL);
    ASSERT(phEnum != NULL);
    ASSERT(pii->dwSize == ISMCHILDINFO_SIZE);
    ASSERT(pInterface != NULL);

    BOOL fDone = FALSE;

    CMetaEnumerator * pme = (CMetaEnumerator *)*phEnum;

    if (pme == NULL)
    {
        //
        // Starting enumeration
        //
        pme = new CMetaEnumerator(
            pInterface,
            lpszService, 
            dwInstance, 
            lpszParent
            );
    }

    if (pme == NULL)
    {
        return CError::HResult(ERROR_NOT_ENOUGH_MEMORY);
    }

    CError err(pme->QueryResult());

    if (err.Win32Error() == ERROR_PATH_NOT_FOUND)
    {
        err = ERROR_NO_MORE_ITEMS;
    }

    if (err.Succeeded())
    {
        do
        {
            CString strAlias;

            err = pme->Next(strAlias);

            if (err.Succeeded())
            {
                CChildNodeProps child(pme, strAlias, WITH_INHERITANCE, FALSE);
                err = child.LoadData();
                DWORD dwWin32Error = err.Win32Error();

                if (err.Failed())
                {
                    //
                    // Filter out the non-fatal errors
                    //
                    switch(err.Win32Error())
                    {
                    case ERROR_ACCESS_DENIED:
                    case ERROR_FILE_NOT_FOUND:
                    case ERROR_PATH_NOT_FOUND:
                        err.Reset();
                        break;

                    default:
                        TRACEEOLID("Fatal error occurred " << err);
                    }
                }

                if (err.Succeeded())
                {
                    //
                    // Skip non-virtual directories (that is, those with
                    // inherited vrpaths)
                    //
                    if (!child.IsPathInherited())
                    {
                        //
                        // Fetch error overrides stored error value
                        //
                        child.FillChildInfo(pii);
                        fDone = TRUE;
                    }
                }
            }
        } 
        while (err.Succeeded() && !fDone);
    }

    if (err.Win32Error() == ERROR_NO_MORE_ITEMS
     || err.Win32Error() == RPC_S_SERVER_UNAVAILABLE)
    {
        //
        // Finished the enumerator
        //
        delete pme;
        pme = NULL;
    }

    *phEnum = (HANDLE)pme;

    return err;
}



DWORD
DetermineIfAdministrator(
    IN  CMetaInterface * pInterface,
    IN  LPCTSTR lpszService,
    IN  DWORD dwInstance,
    OUT BOOL* pfAdministrator
    )
/*++

Routine Description:

    Attempt to actually resolve whether or not the current user
    has administrator or merely "operator" access.  Until this method
    is called by the derived class, the user is assumed to have
    full administrator access, and may therefore get "access denied"
    errors in inconvenient places.

    The method to determine admin access is rather poor at the moment.
    There's a dummy metabase property that only allows admins to write
    to it, so we try to write to it to see if we're an admin.

Arguments:

    LPCTSTR lpszService         : Service name. e.g. "w3svc"
    DWORD dwInstance            : Instance number

Return Value:

    Error return code.  This will also set the m_fHasAdminAccess member

--*/
{
    *pfAdministrator = FALSE;

    //
    // Reuse existing interface we have lying around.
    //
    CMetaKey mk(pInterface);
    CError err(mk.QueryResult());

    if (err.Succeeded())
    {
        err = mk.Open(
            METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
            lpszService,
            dwInstance
            );

        if (err.Succeeded())
        {
            //
            // Write some nonsense
            //
            DWORD dwDummy = 0x1234;
            err = mk.SetValue(MD_ISM_ACCESS_CHECK, dwDummy);
            mk.Close();
        }
    }

    ASSERT(err.Succeeded() || err.Win32Error() == ERROR_ACCESS_DENIED);
    *pfAdministrator = (err.Succeeded());

#ifdef _DEBUG

    if (*pfAdministrator)
    {
        TRACEEOLID("You are a full admin.");
    }
    else
    {
        TRACEEOLID("You're just a lowly operator at best.  Error code is " << err);
    }

#endif // _DEBUG

    if (err.Win32Error() == ERROR_ACCESS_DENIED)
    {
        //
        // Expected result
        //
        err.Reset();
    }

    return err.Win32Error();
}




IMPLEMENT_DYNAMIC(CInetPropertySheet, CPropertySheet)



CInetPropertySheet::CInetPropertySheet(
    IN UINT     nIDCaption,
    IN LPCTSTR  lpszServer,
    IN LPCTSTR  lpszService, OPTIONAL
    IN DWORD    dwInstance,  OPTIONAL
    IN LPCTSTR  lpszParent,  OPTIONAL
    IN LPCTSTR  lpszAlias,   OPTIONAL
    IN CWnd *   pParentWnd,  OPTIONAL
    IN LPARAM   lParam,      OPTIONAL
    IN LONG_PTR handle,      OPTIONAL
    IN UINT     iSelectPage  OPTIONAL
    )
/*++

Routine Description:

    IIS Property Sheet constructor

Arguments:

    UINT nIDCaption           : Caption resource string
    LPCTSTR lpszServer        : Server name
    LPCTSTR lpszService       : Service name
    DWORD dwInstance          : Instance number
    LPCTSTR lpszParent        : Parent path
    LPCTSTR lpszAlias         : Alias name
    CWnd * pParentWnd         : Optional parent window
    LPARAM lParam             : MMC Console parameter
    LONG_PTR handle           : MMC Console handle
    UINT iSelectPage          : Initial page to be selected

Return Value:

    N/A

--*/
    : CPropertySheet(nIDCaption, pParentWnd, iSelectPage),
      m_cap(lpszServer, lpszService, dwInstance),
      m_strServer(lpszServer),
      m_strService(lpszService),
      m_dwInstance(dwInstance),
      m_strParent(lpszParent),
      m_strAlias(lpszAlias),
      m_bModeless(FALSE),
      m_hConsole(handle),
      m_lParam(lParam),
      m_fHasAdminAccess(TRUE), // assumed by default
      m_refcount(0)
{
    m_cap.LoadData();
    Initialize();
}



CInetPropertySheet::CInetPropertySheet(
    IN LPCTSTR  lpszCaption,
    IN LPCTSTR  lpszServer,
    IN LPCTSTR  lpszService, OPTIONAL
    IN DWORD    dwInstance,  OPTIONAL
    IN LPCTSTR  lpszParent,  OPTIONAL
    IN LPCTSTR  lpszAlias,   OPTIONAL
    IN CWnd *   pParentWnd,  OPTIONAL
    IN LPARAM   lParam,      OPTIONAL
    IN LONG_PTR handle,      OPTIONAL
    IN UINT     iSelectPage  OPTIONAL
    )
/*++

Routine Description:

    IIS Property Sheet constructor

Arguments:

    UINT nIDCaption           : Caption resource string
    LPCTSTR lpszServer        : Server name
    LPCTSTR lpszService       : Service name
    DWORD dwInstance          : Instance number
    LPCTSTR lpszParent        : Parent path
    LPCTSTR lpszAlias         : Alias name
    CWnd * pParentWnd         : Optional parent window
    LPARAM lParam             : MMC Console parameter
    LONG_PTR handle           : MMC Console handle
    UINT iSelectPage          : Initial page to be selected

Return Value:

    N/A

--*/
    : CPropertySheet(lpszCaption, pParentWnd, iSelectPage),
      m_cap(lpszServer, lpszService, dwInstance),
      m_strServer(lpszServer),
      m_strService(lpszService),
      m_dwInstance(dwInstance),
      m_strParent(lpszParent),
      m_strAlias(lpszAlias),
      m_bModeless(FALSE),
      m_hConsole(handle),
      m_lParam(lParam),
      m_fHasAdminAccess(TRUE), // assumed by default
      m_refcount(0)
{
    m_cap.LoadData();
    Initialize();
}



void
CInetPropertySheet::NotifyMMC()
/*++

Routine Description:

    Notify MMC that changes have been made, so that the changes are
    reflected.

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Notify MMC to update changes.
    //
    if (m_hConsole != NULL)
    {
        ASSERT(m_lParam != 0L);
        MMCPropertyChangeNotify(m_hConsole, m_lParam);
    }
}



CInetPropertySheet::~CInetPropertySheet()
/*++

Routine Description:

    IIS Property Sheet destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    NotifyMMC();

    if (m_hConsole != NULL)
    {
        MMCFreeNotifyHandle(m_hConsole);
    }
}



void
CInetPropertySheet::Initialize()
/*++

Routine Description:

    Initialize the sheet information by finding out information about
    the computer being administered.

Arguments:

    None

Return Value:

    None

--*/
{
    m_fLocal = ::IsServerLocal(m_strServer);

    DWORD dwError = DetermineAdminAccess(m_strService, m_dwInstance);
    ASSERT(dwError == ERROR_SUCCESS);
}



void
CInetPropertySheet::AddRef()
/*++

Routine Description:

    Increase the refcount

Arguments:

    None

Return Value:

    None

--*/
{
    ++m_refcount;
}



void
CInetPropertySheet::Release()
/*++

Routine Description:

    Decrease the ref count, and if 0, delete the object

Arguments:

    None

Return Value:

    None

--*/
{
    if (--m_refcount <= 0)
    {
        delete this;
    }
}



void
CInetPropertySheet::WinHelp(
    IN DWORD dwData,
    IN UINT nCmd
    )
/*++

Routine Description:

    WinHelp override.  We can't use the base class, because our
    'sheet' doesn't have a window handle

Arguments:

    DWORD dwData        : Help data
    UINT nCmd           : Help command

Return Value:

    None

--*/
{
    if (m_hWnd == NULL)
    {
        //
        // Special case
        //
        CWnd * pWnd = ::AfxGetMainWnd();

        if (pWnd != NULL)
        {
            pWnd->WinHelp(dwData, nCmd);
        }

        return;
    }

    CPropertySheet::WinHelp(dwData, nCmd);
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CInetPropertySheet, CPropertySheet)
    //{{AFX_MSG_MAP(CInetPropertySheet)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



//
// CInetPropertyPage property page
//
IMPLEMENT_DYNAMIC(CInetPropertyPage, CPropertyPage)



/* static */
UINT
CALLBACK
CInetPropertyPage::PropSheetPageProc(
    IN HWND hWnd,
    IN UINT uMsg,
    IN LPPROPSHEETPAGE ppsp
    )
/*++

Routine Description:

    Property page callback procedure.  The page is allocated on the heap,
    and deletes itself when it's destroyed.

Arguments:

    HWND hWnd,
    UINT uMsg,
    LPPROPSHEETPAGE ppsp

Return Value:

    Message dependent.

--*/
{
    CInetPropertyPage * pThis = (CInetPropertyPage *)ppsp->lParam;

    switch(uMsg)
    {
    case PSPCB_RELEASE:
        if (--(pThis->m_refcount) <= 0)
        {
            //
            // Save callback on the stack, since 'this' will be deleted.
            //
            LPFNPSPCALLBACK pfn = pThis->m_pfnOriginalPropSheetPageProc;
            delete pThis;

            return (pfn)(hWnd, uMsg, ppsp);
        }
        break;

    case PSPCB_CREATE:
        //
        // Don't increase refcount.
        //
    default:
        break;
    }

    return (pThis->m_pfnOriginalPropSheetPageProc)(hWnd, uMsg, ppsp);
}



#ifdef _DEBUG

/* virtual */
void
CInetPropertyPage::AssertValid() const
{
}



/* virtual */
void
CInetPropertyPage::Dump(CDumpContext& dc) const
{
}

#endif // _DEBUG



CInetPropertyPage::CInetPropertyPage(
    IN UINT nIDTemplate,
    IN CInetPropertySheet * pSheet,
    IN UINT nIDCaption,
    IN BOOL fEnableEnhancedFonts            OPTIONAL
    )
/*++

Routine Description:

    IIS Property Page Constructor

Arguments:

    UINT nIDTemplate            : Resource template
    CInetPropertySheet * pSheet : Associated property sheet
    UINT nIDCaption             : Caption ID
    BOOL fEnableEnhancedFonts   : Enable enhanced fonts

Return Value:

    N/A

--*/
    : CPropertyPage(nIDTemplate, nIDCaption),
      m_nHelpContext(nIDTemplate + 0x20000),
      m_fEnableEnhancedFonts(fEnableEnhancedFonts),
      m_refcount(1),
      m_bChanged(FALSE),
      m_pSheet(pSheet)
{
    //{{AFX_DATA_INIT(CInetPropertyPage)
    //}}AFX_DATA_INIT

    m_pfnOriginalPropSheetPageProc = m_psp.pfnCallback;
    m_psp.lParam = (LPARAM)this;
    m_psp.pfnCallback = CInetPropertyPage::PropSheetPageProc;
    m_psp.dwFlags |= (PSP_HASHELP | PSP_USECALLBACK);

    m_pSheet->AddRef();

    ASSERT(m_pSheet != NULL);
}



CInetPropertyPage::~CInetPropertyPage()
/*++

Routine Description:

    IIS Property Page Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    m_pSheet->Release();
}



void
CInetPropertyPage::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CPropertyPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CInetPropertyPage)
    //}}AFX_DATA_MAP
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CInetPropertyPage, CPropertyPage)
    //{{AFX_MSG_MAP(CInetPropertyPage)
    ON_COMMAND(ID_HELP, OnHelp)
    ON_WM_HELPINFO()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



/* virtual */
BOOL
CInetPropertyPage::OnInitDialog()
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.  Reset changed
    status (sometimes gets set by e.g. spinboxes when the dialog is
    constructed), so make sure the dialog is considered clean.

Arguments:

    None

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.
--*/
{
    m_bChanged = FALSE;

    //
    // Tell derived class to load its configuration parameters
    //
    CError err(LoadConfigurationParameters());

    if (err.Succeeded())
    {
        err = FetchLoadedValues();
    }

    BOOL bResult = CPropertyPage::OnInitDialog();

    err.MessageBoxOnFailure();

    if (m_fEnableEnhancedFonts)
    {
        CFont * pFont = &m_fontBold;

        if (CreateSpecialDialogFont(this, pFont))
        {
            ApplyFontToControls(this, pFont, IDC_ED_BOLD1, IDC_ED_BOLD5);
        }
    }

    return bResult;
}



void
CInetPropertyPage::OnHelp()
/*++

Routine Description:

    'Help' button handler

Arguments:

    None

Return Value:

    None

--*/
{
    m_pSheet->WinHelp(m_nHelpContext);
}



BOOL
CInetPropertyPage::OnHelpInfo(
    IN HELPINFO * pHelpInfo
    )
/*++

Routine Description:

    Eat "help info" command

Arguments:

    None

Return Value:

    None

--*/
{
    OnHelp();

    return TRUE;
}



BOOL
CInetPropertyPage::OnApply()
/*++

Routine Description:

    Handle "OK" or "APPLY".  Call the derived class to save its stuff,
    and set the dirty state depending on whether saving succeeded or 
    failed.

Arguments:

    None

Return Value:

    None

--*/
{
    BOOL bSuccess = TRUE;

    if (IsDirty())
    {
        CError err(SaveInfo());

        if (err.MessageBoxOnFailure())
        {
            //
            // Failed, sheet will not be dismissed.
            //
            // CODEWORK: This page should be activated.
            //
            bSuccess = FALSE;
        }

        SetModified(!bSuccess);
    }

    return bSuccess;
}





void
CInetPropertyPage::SetModified(
    IN BOOL bChanged
    )
/*++

Routine Description:

    Keep private check on dirty state of the property page.

Arguments:

    BOOL bChanged : Dirty flag

Return Value:

    None

--*/
{
    CPropertyPage::SetModified(bChanged);
    m_bChanged = bChanged;
}


#ifndef _COMSTATIC



static AFX_EXTENSION_MODULE extensionDLL = {NULL, NULL};



extern "C" int APIENTRY
DllMain(
    IN HINSTANCE hInstance,
    IN DWORD dwReason,
    IN LPVOID lpReserved
    )
/*++

Routine Description:

    DLL Main entry point

Arguments:

    HINSTANCE hInstance : Instance handle
    DWORD dwReason      : DLL_PROCESS_ATTACH, etc
    LPVOID lpReserved   : Reserved value

Return Value:

    1 for succesful initialisation, 0 for failed initialisation

--*/
{
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        ASSERT(hInstance != NULL);
        hDLLInstance = hInstance;
        if (!::AfxInitExtensionModule(extensionDLL, hInstance)
         || !InitIntlSettings()
         || !InitErrorFunctionality()
           )
        {
            return 0;
        }
        break ;

    case DLL_PROCESS_DETACH:
        //
        // termination
        //
        TerminateIntlSettings();
        TerminateErrorFunctionality();
        ::AfxTermExtensionModule(extensionDLL);
        break;
    }

    //
    // Succes loading the DLL
    //
    return 1;
}



extern "C" void WINAPI
InitIISUIDll()
/*++

Routine Description:

    Initialize the DLL

Arguments:

    None

Return Value:

    None

--*/
{
    new CDynLinkLibrary(extensionDLL);
    hDLLInstance = extensionDLL.hResource;
}

#endif // _COMSTATIC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\comprop\inetprop.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        inetprop.h

   Abstract:

        Internet Properties base classes definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

#ifndef _INETPROP_H_
#define _INETPROP_H_

//
// CDialog parameters
//
#define USE_DEFAULT_CAPTION (0)

//
// InitializeAndFetch parameters
//
#define WITHOUT_INHERITANCE (FALSE)
#define WITH_INHERITANCE    (TRUE)

//
// SSL Port number to use if SSL is not enabled
//
#define SSL_NOT_ENABLED     (0)

//
// Bandwidth and compression definitions
//
#define INFINITE_BANDWIDTH      (0xffffffff)
#define KILOBYTE                (1024L)
#define MEGABYTE                (1024L * KILOBYTE)
#define DEF_BANDWIDTH           (1 * MEGABYTE)
#define DEF_MAX_COMPDIR_SIZE    (1 * MEGABYTE)

//
// Arbitrary help IDs for user browser dialogs
//
#define IDHELP_USRBROWSER        (0x30000)
#define IDHELP_MULT_USRBROWSER   (0x30100)

//
// Attribute crackers
//
#define IS_VROOT(dwAttributes) ((dwAttributes & FILE_ATTRIBUTE_VIRTUAL_DIRECTORY) != 0)
#define IS_DIR(dwAttributes) ((dwAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0)
#define IS_FILE(dwAttributes) ((dwAttributes & (FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_VIRTUAL_DIRECTORY)) == 0)

//
// Metabase constants
//
COMDLL extern const LPCTSTR g_cszTemplates;
COMDLL extern const LPCTSTR g_cszCompression;
COMDLL extern const LPCTSTR g_cszMachine;
COMDLL extern const LPCTSTR g_cszMimeMap;
COMDLL extern const LPCTSTR g_cszRoot;
COMDLL extern const LPCTSTR g_cszSep;
COMDLL extern const TCHAR g_chSep;

//
// Utility Functions
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

//
// Forward Definitions
//
class CIPAddress;

BOOL COMDLL
GetIUsrAccount(
    IN  LPCTSTR lpszServer,
    IN  CWnd * pParent,      
    OUT CString & str
    );

//
// Build registry key name
//
COMDLL LPCTSTR
GenerateRegistryKey(
    OUT CString & strBuffer,    
    IN  LPCTSTR lpszSubKey = NULL
    );

//
// Get server comment
//
COMDLL NET_API_STATUS
GetInetComment(
    IN  LPCTSTR lpwstrServer,   
    IN  DWORD dwServiceMask,    
    IN  DWORD dwInstance,       
    IN  int cchComment,         
    OUT LPTSTR lpszComment
    );

//
// Get current service status
//
COMDLL NET_API_STATUS
QueryInetServiceStatus(
    LPCTSTR lpszServer,
    LPCTSTR lpszService,
    int * pnState
    );

//
// Change service state
//
COMDLL NET_API_STATUS
ChangeInetServiceState(
    IN LPCTSTR lpszServer,      
    IN LPCTSTR lpszService,     
    IN int nNewState,           
    IN int * pnCurrentState     
    );

//
// Determine if the given server name refers to the local machine
//
COMDLL BOOL 
IsServerLocal(
    IN LPCTSTR lpszServer       
    );

//
// Determine the given server name exists on the network
//
COMDLL BOOL
DoesServerExist(
    IN LPCTSTR lpszServer
    );

//
// Compare server name against the local machine
// if local, return NULL.  Otherwise return machine name
//
COMDLL LPCTSTR NormalizeServerName(
    IN LPCTSTR lpszServerName
    );

//
// Get volume information system flags for the given path
//
COMDLL BOOL GetVolumeInformationSystemFlags(
    IN  LPCTSTR lpszPath,
    OUT DWORD * pdwSystemFlags
    );

//
// Alloc string using ISM allocator
//
COMDLL LPTSTR
ISMAllocString(
    IN CString & str
    );

//
// Determine if the currently logged-in user us an administrator
// or operator in the virtual server provided
//
COMDLL DWORD
DetermineIfAdministrator(
    IN  CMetaInterface * pInterface,
    IN  LPCTSTR lpszService,
    IN  DWORD dwInstance,
    OUT BOOL* pfAdministrator
    );



//
// Utility classes
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

class COMDLL CBlob
/*++

Class Description:

    Binary large object class, which owns its pointer

Public Interface:

    CBlob           : Constructors
    ~CBlob          : Destructor

    SetValue        : Assign the value
    GetSize         : Get the byte size
    GetData         : Get pointer to the byte stream

--*/
{
//
// Constructors/Destructor
//
public:
    //
    // Initialize empty blob
    //
    CBlob();

    //
    // Initialize with binary data
    //
    CBlob(
        IN DWORD dwSize,
        IN PBYTE pbItem,
        IN BOOL fMakeCopy = TRUE
        );

    //
    // Copy constructor
    //
    CBlob(IN const CBlob & blob);

    //
    // Destructor destroys the pointer
    //    
    ~CBlob();

//
// Operators
//
public:
    CBlob & operator =(const CBlob & blob);
    BOOL operator ==(const CBlob & blob) const;
    BOOL operator !=(const CBlob & blob) const { return !operator ==(blob); }

//
// Access
//
public: 
    //
    // Clean up internal data
    //
    void CleanUp();

    //
    // Set the current value of the blob
    //
    void SetValue(
        IN DWORD dwSize,
        IN PBYTE pbItem,
        IN BOOL fMakeCopy = TRUE
        );

    //
    // TRUE if the blob is currently empty
    //
    BOOL IsEmpty() const { return m_dwSize == 0L; }

    //
    // Return the size of the blob in bytes
    //
    DWORD GetSize() const { return m_dwSize; }

    //
    // Get a pointer to the byte stream
    //
    PBYTE GetData();

private:
    DWORD m_dwSize;
    PBYTE m_pbItem;
};



class CMaskedDWORD
/*++

Class Description:

    A masked DWORD class.  This class performs assignments and comparison 
    on a masked range of the DWORD value.  For example, if a mask of 
    0x000000FF is set, any comparisons or assignments will only involve 
    the least significant byte.  A comparison against another DWORD will
    only compare that least significant byte, and an assignment will only
    set the least significant byte, leaving the rest untouched.

Public Interface:

    CMaskedDWORD        : Constructor
    operator ==         : Comparison operator
    operator !=         : Comparison operator
    operator =          : Assignment operator
    operator DWORD      : Cast to the value
    void SetMask        : Set the mask

--*/
{
//
// Constructor/Destructor
//
public:
    CMaskedDWORD(
        IN DWORD dwValue = 0L,
        IN DWORD dwMask  = 0xFFFFFFFF
        )
        : m_dwValue(dwValue),
          m_dwMask(dwMask)
    {
    }

public:
    BOOL operator ==(DWORD dwValue) const;
    BOOL operator !=(DWORD dwValue) const { return !(operator ==(dwValue)); }

    CMaskedDWORD & operator =(DWORD dwValue);
    operator DWORD() const { return m_dwValue; }
    operator DWORD &() { return m_dwValue; }
    void SetMask(DWORD dwMask) { m_dwMask = dwMask; }

private:
    DWORD m_dwValue;
    DWORD m_dwMask;
};


//
// Forward Definitions
//
class CIPAddress;



template <class TYPE, class ARG_TYPE> 
class CMPProp
{
public:
    CMPProp(ARG_TYPE value);
    CMPProp();
    operator ARG_TYPE() const;
    CMPProp<TYPE, ARG_TYPE> & operator =(ARG_TYPE value);
    BOOL m_fDirty;
    TYPE m_value;
};

template <class TYPE, class ARG_TYPE> 
inline CMPProp<TYPE, ARG_TYPE>::CMPProp(ARG_TYPE value)
    : m_value(value),
      m_fDirty(FALSE)
{
}

template <class TYPE, class ARG_TYPE> 
inline CMPProp<TYPE, ARG_TYPE>::CMPProp()
    : m_value(),
      m_fDirty(FALSE)
{
}

template <class TYPE, class ARG_TYPE>
inline CMPProp<TYPE, ARG_TYPE>::operator ARG_TYPE() const
{
    return (ARG_TYPE)m_value;
}

template <class TYPE, class ARG_TYPE>
inline CMPProp<TYPE, ARG_TYPE> & CMPProp<TYPE, ARG_TYPE>::operator =(ARG_TYPE value)
{
    if (m_value != value)
    {
        m_value = value;
        m_fDirty = TRUE;
    }
    
    return *this;
}


//
// MP Access (use operators where possible!)
//
#define MP_V(x) (x.m_value)
#define MP_D(x) (x.m_fDirty)


//
// Common property types
//
typedef CMPProp<CBlob, CBlob&>                   MP_CBlob;
typedef CMPProp<CString, LPCTSTR>                MP_CString;
typedef CMPProp<CStringListEx, CStringListEx &>  MP_CStringListEx;
typedef CMPProp<CILong, LONG>                    MP_CILong;
typedef CMPProp<int, int>                        MP_int;
typedef CMPProp<DWORD, DWORD>                    MP_DWORD;
typedef CMPProp<BOOL, BOOL>                      MP_BOOL;
typedef CMPProp<CMaskedDWORD, DWORD>             MP_CMaskedDWORD;



//
// CODEWORK: Turns these into proper methods
//
#define BEGIN_META_WRITE()\
{                                               \
    HRESULT hr = S_OK;                          \
    do                                          \
    {                                           \
        m_dwaDirtyProps.RemoveAll();            \

#define META_WRITE(id, value)\
        if(MP_D(value))                         \
        {                                       \
            if (!IsOpen())                      \
            {                                   \
                hr = OpenForWriting();          \
                if (FAILED(hr)) break;          \
            }                                   \
            hr = SetValue(id, MP_V(value));     \
            if (FAILED(hr)) break;              \
            MP_D(value) = FALSE;                \
            m_dwaDirtyProps.AddTail(id);        \
        }                                       \

#define META_WRITE_INHERITANCE(id, value, foverride)\
        if(MP_D(value))                         \
        {                                       \
            if (!IsOpen())                      \
            {                                   \
                hr = OpenForWriting();          \
                if (FAILED(hr)) break;          \
            }                                   \
            hr = SetValue(id, MP_V(value), &foverride);\
            if (FAILED(hr)) break;              \
            MP_D(value) = FALSE;                \
            m_dwaDirtyProps.AddTail(id);        \
        }                                       \

#define META_DELETE(id)\
        FlagPropertyForDeletion(id);            \

#define END_META_WRITE(err)\
        POSITION pos;                           \
        pos = m_dwaDeletedProps.GetHeadPosition();\
        while(pos != NULL)                      \
        {                                       \
            DWORD dwID = m_dwaDeletedProps.GetNext(pos);\
            if (!IsOpen())                      \
            {                                   \
                hr = OpenForWriting(FALSE);     \
                if (SUCCEEDED(hr))              \
                {                               \
                    TRACEEOLID("Deleting #" << dwID);\
                    hr = DeleteValue(dwID);          \
                    m_dwaDirtyProps.AddTail(dwID);   \
                }                                    \
            }                                   \
        }                                       \
        m_dwaDeletedProps.RemoveAll();          \
        if (IsOpen()) Close();                  \
        pos = m_dwaDirtyProps.GetHeadPosition();\
        hr = S_OK;                              \
        while(pos != NULL)                      \
        {                                       \
            hr = CheckDescendants(m_dwaDirtyProps.GetNext(pos), m_strServerName, m_strMetaRoot); \
            if (FAILED(hr)) break;              \
        }                                       \
    }                                           \
    while(FALSE);                               \
    err = hr;                                   \
}



//
// Binding helper macros.  Place calls that allow rebinding
// between these blocks
//
#define BEGIN_ASSURE_BINDING_SECTION\
    {                                                               \
        BOOL fRepeat;                                               \
        do                                                          \
        {                                                           \
            fRepeat = FALSE;                                        \

#define END_ASSURE_BINDING_SECTION(err, pInterface, CANCEL_ERROR)\
            if (err.Win32Error() == RPC_S_SERVER_UNAVAILABLE)       \
            {                                                       \
                err = COMDLL_RebindInterface(                       \
                    pInterface,                                     \
                    &fRepeat,                                       \
                    CANCEL_ERROR                                    \
                    );                                              \
            }                                                       \
        }                                                           \
        while(fRepeat);                                             \
    }



/* ABSTRACT */ class COMDLL CMetaProperties : public CMetaKey
/*++

Class Description:

    Abstract base class that reads all metadata at a specific
    metabase path.  

Public Interface:

    QueryResult             : Get result code from construction
    QueryMetaPath           : Get the metabase path

Virtual Interface:

    ParseFields             : Break up data into member variables    

--*/
{
//
// Constructor/Destructor
//
protected:
    //
    // Constructor which creates new interface
    //
    CMetaProperties(
        IN LPCTSTR lpszServerName,
        IN LPCTSTR lpszService      = NULL,
        IN DWORD   dwInstance       = MASTER_INSTANCE,
        IN LPCTSTR lpszParentPath   = NULL,
        IN LPCTSTR lpszAlias        = NULL
        );

    //
    // Construct with existing interface
    //
    CMetaProperties(
        IN const CMetaInterface * pInterface,
        IN LPCTSTR lpszService      = NULL,
        IN DWORD   dwInstance       = MASTER_INSTANCE,  
        IN LPCTSTR lpszParentPath   = NULL,
        IN LPCTSTR lpszAlias        = NULL
        );

    //
    // Construct with open key
    //
    CMetaProperties(
        IN const CMetaKey * pKey,
        IN LPCTSTR lpszMDPath
        );

    //
    // Construct with open key (specifically for instances)
    //
    CMetaProperties(
        IN const CMetaKey * pKey,
        IN DWORD   dwPath
        );

    //
    // Destructor
    //
    ~CMetaProperties();

public:
    //
    // GetAllData()
    //
    virtual HRESULT LoadData();
    virtual HRESULT WriteDirtyProps();
    void FlagPropertyForDeletion(DWORD dwID);

    virtual HRESULT CMetaProperties::QueryResult() const;
    LPCTSTR QueryMetaRoot() const { return m_strMetaRoot; }

protected:
    //
    // Call derived class
    //
    /* PURE */ virtual void ParseFields() = 0;

    //
    // Clean up
    //
    void Cleanup();

    //
    // Open for writing.  Optionally creates the path
    //
    HRESULT OpenForWriting(BOOL fCreate = TRUE);

protected:
    BOOL     m_fInherit;
    HRESULT  m_hResult;
    CString  m_strMetaRoot;
    DWORD    m_dwMDUserType;
    DWORD    m_dwMDDataType;
    CList<DWORD, DWORD> m_dwaDirtyProps;
    CList<DWORD, DWORD> m_dwaDeletedProps;

    //
    // Read all values
    //
    DWORD    m_dwNumEntries;
    DWORD    m_dwMDDataLen;
    PBYTE    m_pbMDData;
};



//
// Machine Properties object
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


class CMachineProps : public CMetaProperties
/*++

Class Description:

    Global machine properties

Public Interface:

    CMachineProps       : Constructor

    WriteDirtyProps     : Write dirty properties

--*/
{
public:
    CMachineProps(
        IN LPCTSTR lpszServerName
        );

    CMachineProps(
        IN const CMetaInterface * pInterface
        );

public:
    //
    // Write Data if dirty
    //
    HRESULT WriteDirtyProps();

protected:
    virtual void ParseFields();

public:
    MP_CILong  m_nMaxNetworkUse;
};



//
// Compression Properties Object
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

class COMDLL CIISCompressionProps : public CMetaProperties
/*++

Class Description:

    Compression settings

Public Interface:

    CIISCompressionProps : Constructor

    WriteIfDirty         : Write data if dirty

--*/
{
public:
    CIISCompressionProps(
        IN LPCTSTR lpszServerName,
        IN LPCTSTR lpszService        = SZ_MBN_WEB,
        IN DWORD dwInstance           = MASTER_INSTANCE,
        IN LPCTSTR lpszParent         = NULL,
        IN LPCTSTR lpszAlias          = NULL
        );

public:
    //
    // Write Data if dirty
    //
    virtual HRESULT WriteDirtyProps();

    //
    // Load data
    //
    virtual HRESULT LoadData();

public:
    MP_BOOL    m_fEnableStaticCompression;
    MP_BOOL    m_fEnableDynamicCompression;
    MP_BOOL    m_fLimitDirectorySize;
    MP_DWORD   m_dwDirectorySize;
    MP_CString m_strDirectory;

protected:
    virtual void ParseFields();

private:
    BOOL m_fPathDoesNotExist;
};




class COMDLL CMimeTypes : public CMetaProperties
/*++

Class Description:

    A list of mime types.

Public Interface:

    CMimeTypes          : Constructor

    WriteIfDirty        : Write properties if dirty

--*/
{
public:
    //
    // Constructor that creates new interface
    //
    CMimeTypes(
        LPCTSTR lpszServerName,
        LPCTSTR lpszService    = NULL,
        DWORD   dwInstance     = MASTER_INSTANCE,
        LPCTSTR lpszParent     = NULL,
        LPCTSTR lpszAlias      = NULL
        );

    //
    // Constructor that uses an existing interface
    //
    CMimeTypes(
        IN const CMetaInterface * pInterface,
        LPCTSTR lpszService     = NULL,
        DWORD   dwInstance      = MASTER_INSTANCE,
        LPCTSTR lpszParent      = NULL,
        LPCTSTR lpszAlias       = NULL
        );

public:
    //
    // Write the data;
    //
    virtual HRESULT WriteDirtyProps();

protected:
    virtual void ParseFields();

public:
    MP_CStringListEx   m_strlMimeTypes;
};



class COMDLL CServerCapabilities : public CMetaProperties
/*++

Class Description:

    Server capabilities object

Public Interface:

    CServerCapabilities     : Constructor

--*/
{
public:
    //
    // Constructor
    //
    CServerCapabilities(
        IN LPCTSTR lpszServerName,
        IN LPCTSTR lpszService         = NULL,
        IN DWORD   dwInstance          = MASTER_INSTANCE
        );

public:
    BOOL IsSSLSupported()       const { return (m_dwCapabilities & IIS_CAP1_SSL_SUPPORT) != 0L; }
    BOOL IsSSL128Supported()    const { return (m_dwConfiguration & MD_SERVER_CONFIG_SSL_128) != 0L; }
    BOOL HasMultipleSites()     const { return (m_dwCapabilities & IIS_CAP1_MULTIPLE_INSTANCE) != 0L; }
    BOOL HasBwThrottling()      const { return (m_dwCapabilities & IIS_CAP1_BW_THROTTLING) != 0L; }
    BOOL Has10ConnectionLimit() const { return (m_dwCapabilities & IIS_CAP1_10_CONNECTION_LIMIT) != 0L; }
    BOOL HasIPAccessCheck()     const { return (m_dwCapabilities & IIS_CAP1_IP_ACCESS_CHECK) != 0L; }
    BOOL HasOperatorList()      const { return (m_dwCapabilities & IIS_CAP1_OPERATORS_LIST) != 0L; }
    BOOL HasFrontPage()         const { return (m_dwCapabilities & IIS_CAP1_FP_INSTALLED) != 0L; }
    BOOL HasCompression()       const { return (m_dwCapabilities & IIS_CAP1_SERVER_COMPRESSION) != 0L; }
    BOOL HasCPUThrottling()     const { return (m_dwCapabilities & IIS_CAP1_CPU_AUDITING) != 0L; }
    BOOL HasDAV()               const { return (m_dwCapabilities & IIS_CAP1_DAV) != 0L; }
    BOOL HasDigest()            const { return (m_dwCapabilities & IIS_CAP1_DIGEST_SUPPORT) != 0L; }
    BOOL HasNTCertMapper()      const { return (m_dwCapabilities & IIS_CAP1_NT_CERTMAP_SUPPORT) != 0L; }
    DWORD QueryMajorVersion()   const { return m_dwVersionMajor; }
    DWORD QueryMinorVersion()   const { return m_dwVersionMinor; }

protected:
    virtual void ParseFields();

private:
    //
    // Capabilities fields
    //
    MP_DWORD m_dwPlatform;
    MP_DWORD m_dwVersionMajor;
    MP_DWORD m_dwVersionMinor;
    MP_DWORD m_dwCapabilities;
    MP_DWORD m_dwConfiguration;
};



class COMDLL CInstanceProps : public CMetaProperties
/*++

Class Description:

    Generic instance properties.  Construct with lightweight = TRUE
    to fetch enough information for enumeration only.

Public Interface:

    CInstanceProps:         : Constructor

    Add                     : static method to create new instance
    Remove                  : static method to remove instance
    ChangeState             : Change the state of a property
    QueryError              : Get the win32 error
    GetDisplayText          : Generate display name of instance
    FillInstanceInfo        : Fill ISMINSTANCE_INFO struct

--*/
{
public:
    //
    // Public method to convert instance info to display text
    //
    static LPCTSTR GetDisplayText(
        OUT CString & strName,
        IN  LPCTSTR szComment,
        IN  LPCTSTR szHostHeaderName,
        IN  LPCTSTR szServiceName,
        IN  CIPAddress & ia, 
        IN  UINT uPort,
        IN  DWORD dwID
        );

public:
    //
    // Constructor that creates an interface
    //
    CInstanceProps(
        IN LPCTSTR lpszServerName,
        IN LPCTSTR lpszService,                 //  e.g. "W3SVC"
        IN DWORD   dwInstance   = MASTER_INSTANCE,
        IN UINT    nDefPort     = 0U
        );

    //
    // Constructor that reuses existing interface
    //
    CInstanceProps(
        IN const CMetaInterface * pInterface,
        IN LPCTSTR lpszService,                 //  e.g. "W3SVC"
        IN DWORD   dwInstance   = MASTER_INSTANCE,
        IN UINT    nDefPort     = 0U
        );

    //
    // Constructor that uses an open parent key,
    // open at the service level
    //
    CInstanceProps(
        IN CMetaKey * pKey,
        IN DWORD   dwInstance   = MASTER_INSTANCE,
        IN UINT    nDefPort     = 0U
        );

public:
    //
    // Parse the binding string into component parts
    //
    static void CrackBinding(
        IN  CString lpszBinding,
        OUT CIPAddress & iaIpAddress, 
        OUT UINT & nTCPPort, 
        OUT CString & strDomainName
        );

    //
    // Parse the secure binding string into component parts
    //
    static void CrackSecureBinding(
        IN  CString lpszBinding,
        OUT CIPAddress & iaIpAddress, 
        OUT UINT & nSSLPort
        );

    //
    // Find the SSL port applicable to the given
    // IP Address.  Return the index where this SSL port
    // was found, or -1 if it was not found.
    //
    static int FindMatchingSecurePort(
        IN  CStringList & strlBindings, 
        IN  CIPAddress & iaIpAddress,
        OUT UINT & m_nSSLPort
        );

    //
    // Find ip address/port combo
    //
    static BOOL IsPortInUse(
        IN CStringList & strlBindings,
        IN CIPAddress & iaIPAddress,
        IN UINT nPort
        );

    //
    // Build binding string
    //
    static void BuildBinding(
        OUT CString & strBinding, 
        IN  CIPAddress & iaIpAddress, 
        IN  UINT & nTCPPort, 
        IN  CString & lpszDomainName
        );

    //
    // Build secure binding string
    //
    static void BuildSecureBinding(
        OUT CString & strBinding, 
        IN  CIPAddress & iaIpAddress, 
        IN  UINT & nSSLPort 
        );

    //
    // Create new instance
    //
    static HRESULT Add(
        IN  const CMetaInterface * pInterface,
        IN  LPCTSTR lpszService,
        IN  LPCTSTR lpszHomePath,
        IN  LPCTSTR lpszUserName        = NULL,
        IN  LPCTSTR lpszPassword        = NULL,
        IN  LPCTSTR lpszDescription     = NULL,
        IN  LPCTSTR lpszBinding         = NULL,
        IN  LPCTSTR lpszSecureBinding   = NULL,
        IN  DWORD * pdwPermissions      = NULL,
        IN  DWORD * pdwDirBrowsing      = NULL,
        IN  DWORD * pwdAuthFlags        = NULL,
        OUT DWORD * pdwInstance         = NULL    
        );

    //
    // Remove existing instance
    //
    static HRESULT Delete(
        IN const CMetaInterface * pInterface,
        IN LPCTSTR lpszService,
        IN DWORD   dwInstance
        );

//
// Access
//
public:
    //
    // Change the running state of the instance
    //
    HRESULT ChangeState(
        IN int nNewState  // INet definition
        );

    //
    // Get the WIN32 error
    //
    DWORD QueryError() const { return m_dwWin32Error; }

    //
    // Get the instance number
    //
    DWORD QueryInstance() const { return m_dwInstance; }

    //
    // Check to see if this is a deletable instance
    //
    BOOL IsDeletable() const { return !m_fNotDeletable; }

    //
    // Check to see if this is a cluster enabled instance
    //
    BOOL IsClusterEnabled() const { return m_fCluster; }

    //
    // Get ISM state value
    //
    int QueryISMState() const { return m_nISMState; }

    //
    // Get the friendly name for this instance
    //
    LPCTSTR GetDisplayText(
        OUT CString & strName, 
        IN  LPCTSTR szServiceName
        );

    //
    // Fill instance info structure
    //
    void FillInstanceInfo(
        OUT ISMINSTANCEINFO * pii, 
        IN  DWORD dwError = ERROR_SUCCESS
        );

    //
    // Get the complete metabase path to the home directory
    //
    LPCTSTR GetHomePath(OUT CString & str);

    //
    // Write Data if dirty
    //
    virtual HRESULT WriteDirtyProps();

protected:
    virtual void ParseFields();

    //
    // Helper to convert state constants
    //
    void SetISMStateFromServerState();

public:
    DWORD m_dwInstance;

public:
    //
    // Meta values
    //
    MP_BOOL          m_fNotDeletable;
    MP_BOOL          m_fCluster;
    MP_CStringListEx m_strlBindings;
    MP_CString       m_strComment;
    MP_DWORD         m_dwState;
    MP_DWORD         m_dwWin32Error;

    //
    // Derived Values
    //
    UINT             m_nTCPPort;
    CIPAddress       m_iaIpAddress;
    CString          m_strDomainName;
    int              m_nISMState;
};



class COMDLL CChildNodeProps : public CMetaProperties
{
/*++

Class Description:

    Generic child node properties.  Could be a vdir, a dir
    or a file.

Public Interface:

    CChildNodeProps         : Constructor

    Add                     : Create new virtual directory
    Delete                  : Delete virtual directory
    Rename                  : Rename virtual directory

    QueryError              : Get the win32 error
    IsPathInherited         : Return TRUE if the path was inherited
    FillInstanceInfo        : Fill instance info structure
    FillChildInfo           : Fill child info structure

--*/
public:
    //
    // Constructors
    //
    CChildNodeProps(
        IN LPCTSTR lpszServerName,
        IN LPCTSTR lpszService,
        IN DWORD   dwInstance   = MASTER_INSTANCE,
        IN LPCTSTR lpszParent   = NULL,
        IN LPCTSTR lpszAlias    = NULL,
        IN BOOL    fInherit     = WITHOUT_INHERITANCE,
        IN BOOL    fPathOnly    = FALSE
        );

    CChildNodeProps(
        IN const CMetaInterface * pInterface,
        IN LPCTSTR lpszService,
        IN DWORD   dwInstance   = MASTER_INSTANCE,
        IN LPCTSTR lpszParent   = NULL,
        IN LPCTSTR lpszAlias    = NULL,
        IN BOOL    fInherit     = WITHOUT_INHERITANCE,
        IN BOOL    fPathOnly    = FALSE
        );

    CChildNodeProps(
        IN const CMetaKey * pKey,
        IN LPCTSTR lpszPath     = NULL,
        IN BOOL    fInherit     = WITHOUT_INHERITANCE,
        IN BOOL    fPathOnly    = FALSE
        );

public:
    //
    // Create new virtual directory
    //
    static HRESULT Add(
        IN  const CMetaInterface * pInterface,
        IN  LPCTSTR lpszService,
        IN  DWORD   dwInstance,         
        IN  LPCTSTR lpszParentPath,     
        IN  LPCTSTR lpszAlias,
        OUT CString & strAliasCreated,
        IN  DWORD * pdwPermissions      = NULL,
        IN  DWORD * pdwDirBrowsing      = NULL,
        IN  LPCTSTR lpszVrPath          = NULL,
        IN  LPCTSTR lpszUserName        = NULL,
        IN  LPCTSTR lpszPassword        = NULL,
        IN  BOOL    fExactName          = TRUE
        );

    //
    // Delete virtual directory
    //
    static HRESULT Delete(
        IN const CMetaInterface * pInterface,
        IN LPCTSTR lpszService,
        IN DWORD   dwInstance,          OPTIONAL
        IN LPCTSTR lpszParentPath,      OPTIONAL
        IN LPCTSTR lpszNode
        );

    //
    // Rename virtual directory
    //
    static HRESULT Rename(
        IN const CMetaInterface * pInterface,
        IN LPCTSTR lpszService,
        IN DWORD   dwInstance,          OPTIONAL
        IN LPCTSTR lpszParentPath,      OPTIONAL
        IN LPCTSTR lpszOldName,
        IN LPCTSTR lpszNewName
        );

public:
    //
    // TRUE, if this is an enabled application
    //
    BOOL IsEnabledApplication() { return m_fIsAppRoot; }

    //
    // Get the alias name
    //
    LPCTSTR QueryAlias() const { return m_strAlias; }
    CString & GetAlias() { return m_strAlias; }

    //
    // Get the error
    //
    DWORD QueryWin32Error() const { return m_dwWin32Error; }

    //
    // This is how to separate file/dir props from vdirs
    //
    BOOL IsPathInherited() const { return m_fPathInherited; }

    //
    // Empty the path if it was inherited
    //
    void RemovePathIfInherited();

    //
    // CODEWORK: Ugly solution.
    //
    // Call this method to override the inheritance status of the
    // http redirect path
    //
    void MarkRedirAsInherit(BOOL fInherit) { m_fInheritRedirect = fInherit; }

    //
    // Get the path
    //
    CString & GetPath() { return MP_V(m_strPath); }

    //
    // Get the redirected path
    //
    CString & GetRedirectedPath() { return m_strRedirectPath; }

    //
    // Get the access perms
    //
    DWORD QueryAccessPerms() const { return m_dwAccessPerms; }

    //
    // Get dir browsing bits
    //
    DWORD QueryDirBrowsing() const { return m_dwDirBrowsing; }

    //
    // True if the child is redirected
    //
    BOOL IsRedirected() const { return !m_strRedirectPath.IsEmpty(); }

    //
    // Fill ISMINSTANCE_INFO fields
    //
    void FillInstanceInfo(OUT ISMINSTANCEINFO * pii);

    //
    // Fill ISMCHILDINFO fields
    //
    void FillChildInfo(OUT ISMCHILDINFO * pii);

    //
    // Write Data if dirty
    //
    virtual HRESULT WriteDirtyProps();

protected:    
    //
    // Break out GetAllData() data to data fields
    //
    virtual void ParseFields();

    //
    // Break down redirect statement into component paths
    //
    void ParseRedirectStatement();

    //
    // Reverse the above -- reassemble the redirect statement
    //
    void BuildRedirectStatement();

protected:
    //
    // Redirect tags
    //
    static const TCHAR   s_chTagSep;
    static const LPCTSTR s_cszExactDestination;
    static const LPCTSTR s_cszChildOnly;
    static const LPCTSTR s_cszPermanent;

public:
    BOOL            m_fIsAppRoot;
    BOOL            m_fPathInherited;
    BOOL            m_fInheritRedirect;
    BOOL            m_fExact;               // Redirect tag
    BOOL            m_fChild;               // Redirect tag
    BOOL            m_fPermanent;           // Redirect tag
    CString         m_strAlias;
    CString         m_strFullMetaPath;
    CString         m_strRedirectPath;      // Redirect _path_

public:
    MP_BOOL         m_fAppIsolated;
    MP_DWORD        m_dwWin32Error;
    MP_DWORD        m_dwDirBrowsing;
    MP_CString      m_strPath;
    MP_CString      m_strRedirectStatement; // Path + tags
    MP_CString      m_strAppRoot;
    MP_CMaskedDWORD m_dwAccessPerms;
};


//
// ISM Helper Functions
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline HRESULT COMDLL_ISMBind(
    IN  LPCTSTR lpszServer,
    OUT HANDLE * phServer
    )
{
    ASSERT(lpszServer != NULL);
    ASSERT(phServer != NULL);

    //
    // Use a metainterface pointer for the handle
    //
    CMetaKey * pKey = new CMetaKey(lpszServer);
    *phServer = pKey;

    return *phServer ? S_OK : CError::HResult(ERROR_NOT_ENOUGH_MEMORY);
}

inline HRESULT COMDLL_ISMUnbind(
    IN HANDLE hServer
    )
{
    CMetaKey * pKey = (CMetaKey *)hServer;

    if (pKey)
    {
        delete pKey;
        return S_OK;
    }

    return CError::HResult(ERROR_INVALID_HANDLE);
}

inline CMetaKey * GetMetaKeyFromHandle(IN HANDLE hServer)
{
    ASSERT(hServer != NULL);
    return (CMetaKey *)hServer;
}

inline LPCTSTR GetServerNameFromHandle(IN HANDLE hServer)
{
    ASSERT(hServer != NULL);
    return ((CMetaKey *)hServer)->QueryServerName();
}



//
// Rebind the interface
//
HRESULT COMDLL
COMDLL_RebindInterface(
    OUT IN CMetaInterface * pInterface,
    OUT BOOL * pfContinue,
    IN  DWORD dwCancelError
    );



//
// Enumerate Instances
//
HRESULT COMDLL
COMDLL_ISMEnumerateInstances(
    IN  CMetaInterface * pInterface,
    OUT ISMINSTANCEINFO * pii,
    OUT IN HANDLE * phEnum,
    IN  LPCTSTR lpszService
    );


//
// Enumerate Child Nodes
//
HRESULT COMDLL
COMDLL_ISMEnumerateChildren(
    IN  CMetaInterface * pInterface,
    OUT ISMCHILDINFO * pii,
    OUT IN HANDLE * phEnum,
    IN  LPCTSTR lpszService,
    IN  DWORD   dwInstance,
    IN  LPCTSTR lpszParent
    );


class COMDLL CInetPropertySheet : public CPropertySheet
/*++

Class Description:

    IIS Configuration property sheet class

Public Interface:

    CInetPropertySheet          : Constructor
    ~CInetPropertySheet         : Destructor

    cap                         : Get capabilities

--*/
{
    DECLARE_DYNAMIC(CInetPropertySheet)

//
// Construction/destruction
//
public:
    CInetPropertySheet(
        IN UINT nIDCaption,
        IN LPCTSTR lpszServer,
        IN LPCTSTR lpszService = NULL,
        IN DWORD   dwInstance  = MASTER_INSTANCE,
        IN LPCTSTR lpszParent  = NULL,
        IN LPCTSTR lpszAlias   = NULL,
        IN CWnd * pParentWnd   = NULL,
        IN LPARAM lParam       = 0L,
        IN LONG_PTR handle     = 0L,
        IN UINT iSelectPage    = 0
        );

    CInetPropertySheet(
        IN LPCTSTR lpszCaption,
        IN LPCTSTR lpszServer,
        IN LPCTSTR lpszService = NULL,
        IN DWORD   dwInstance  = MASTER_INSTANCE,
        IN LPCTSTR lpszParent  = NULL,
        IN LPCTSTR lpszAlias   = NULL,
        IN CWnd * pParentWnd   = NULL,
        IN LPARAM lParam       = 0L,
        IN LONG_PTR handle     = 0L,
        IN UINT iSelectPage    = 0
        );

    virtual ~CInetPropertySheet();

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CInetPropertySheet)
    //}}AFX_VIRTUAL

//
// Access
//
public:
    CServerCapabilities & cap()     { return m_cap; }
    CString & GetServerName()       { return m_strServer; }
    LPCTSTR QueryServerName() const { return m_strServer; }
    LPCTSTR QueryService()    const { return m_strService; }
    DWORD QueryInstance()     const { return m_dwInstance; }
    BOOL IsMasterInstance()   const { return IS_MASTER_INSTANCE(m_dwInstance); }
    LPCTSTR QueryAlias()      const { return m_strAlias; }
    LPCTSTR QueryParent()     const { return m_strParent; }
    BOOL IsLocal()            const { return m_fLocal; }
    BOOL HasAdminAccess()     const { return m_fHasAdminAccess; }

public:
    void AddRef();
    void Release();
    void NotifyMMC();
    void SetModeless();
    BOOL IsModeless() const { return m_bModeless; }

public:
    virtual void WinHelp(DWORD dwData, UINT nCmd = HELP_CONTEXT);

    //
    // Override in derived class to load delayed values
    //
    /* PURE */ virtual HRESULT LoadConfigurationParameters() = 0;
    /* PURE */ virtual void FreeConfigurationParameters() = 0;

//
// Generated message map functions
//
protected:
    //{{AFX_MSG(CInetPropertySheet)
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()

    void Initialize();

    //
    // Attempt to resolve admin/operator access for the given
    // instance number
    //
    DWORD DetermineAdminAccess(
        IN LPCTSTR lpszService,
        IN DWORD dwInstance
        );

protected:
    BOOL    m_fLocal;
    BOOL    m_fHasAdminAccess;
    DWORD   m_dwInstance;
    CString m_strServer;
    CString m_strService;
    CString m_strAlias;
    CString m_strParent;
    INT     m_refcount;
    CServerCapabilities m_cap;

private:
    BOOL    m_bModeless;
    LONG_PTR m_hConsole;
    LPARAM  m_lParam;
};



//
// Metabase Helpers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



//
// Get record data size
//
inline DWORD RecordDataSize(
    IN METADATA_GETALL_RECORD * pAllRecord, 
    IN int iIndex
    )
{
    return pAllRecord[iIndex].dwMDDataLen;
}

//
// Fetch data at index as DWORD
//
inline void FetchMetaValue(
    IN  METADATA_GETALL_RECORD * pAllRecord, 
    IN  int iIndex,
    OUT DWORD & dwValue
    )
{
    ASSERT(RecordDataSize(pAllRecord, iIndex) == sizeof(DWORD));
    dwValue = *((DWORD UNALIGNED *)((PBYTE)pAllRecord + pAllRecord[iIndex].dwMDDataOffset));
}

//
// Fetch data at index as UINT
//
inline void FetchMetaValue(
    IN  METADATA_GETALL_RECORD * pAllRecord, 
    IN  int iIndex,
    OUT UINT & uValue
    )
{
    ASSERT(RecordDataSize(pAllRecord, iIndex) == sizeof(DWORD));
    uValue = (UINT)*((DWORD UNALIGNED *)((PBYTE)pAllRecord + pAllRecord[iIndex].dwMDDataOffset));
}

//
// Fetch data at index as int
//
inline void FetchMetaValue(
    IN  METADATA_GETALL_RECORD * pAllRecord, 
    IN  int iIndex,
    OUT int & iValue
    )
{
    ASSERT(RecordDataSize(pAllRecord, iIndex) == sizeof(DWORD));
    iValue = (int)*((DWORD UNALIGNED *)((PBYTE)pAllRecord + pAllRecord[iIndex].dwMDDataOffset));
}

//
// Fetch data at index as a CString
//
inline void FetchMetaValue(
    IN  METADATA_GETALL_RECORD * pAllRecord, 
    IN  int iIndex,
    OUT CString & strValue
    )
{
    strValue = (LPTSTR)((PBYTE)pAllRecord + pAllRecord[iIndex].dwMDDataOffset);
}

//
// Fetch data at index as a CStringList
//
inline void FetchMetaValue(
    IN  METADATA_GETALL_RECORD * pAllRecord, 
    IN  int iIndex,
    OUT CStringList & strlValue
    )
{
    ConvertDoubleNullListToStringList(
        ((LPCTSTR)((PBYTE)pAllRecord + pAllRecord[iIndex].dwMDDataOffset)),
        strlValue,
        (RecordDataSize(pAllRecord, iIndex)) / sizeof(TCHAR)
        );
}

//
// Fetch binary data as a blob
//
inline void FetchMetaValue(
    IN  METADATA_GETALL_RECORD * pAllRecord, 
    IN  int iIndex,
    OUT CBlob & blob
    )
{
    blob.SetValue(
        RecordDataSize(pAllRecord, iIndex), 
        ((PBYTE)pAllRecord + pAllRecord[iIndex].dwMDDataOffset));
}    

inline void FetchMetaValue(
    IN  METADATA_GETALL_RECORD * pAllRecord, 
    IN  int iIndex,
    OUT CILong & ilValue
    )
{
    ilValue = (LONG)*((DWORD UNALIGNED *)((PBYTE)pAllRecord + pAllRecord[iIndex].dwMDDataOffset));
}

//
// Fetch data at index as CString, and check inheritance status
//
inline void FetchInheritedMetaValue(
    IN  METADATA_GETALL_RECORD * pAllRecord, 
    IN  int iIndex,
    OUT CString & strValue,
    OUT BOOL & fIsInherited
    )
{
    strValue = (LPTSTR)((PBYTE)pAllRecord + pAllRecord[iIndex].dwMDDataOffset);
    fIsInherited = (pAllRecord[iIndex].dwMDAttributes & METADATA_ISINHERITED) != 0;
}

//
// Flag Operations
//
#define IS_FLAG_SET(dw, flag) ((((dw) & (flag)) != 0) ? TRUE : FALSE)
#define SET_FLAG(dw, flag)    dw |= (flag)
#define RESET_FLAG(dw, flag)  dw &= ~(flag)
#define SET_FLAG_IF(cond, dw, flag)\
    if (cond)                      \
    {                              \
        SET_FLAG(dw, flag);        \
    }                              \
    else                           \
    {                              \
        RESET_FLAG(dw, flag);      \
    }

//
// Meta record crackers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

#define BEGIN_PARSE_META_RECORDS(dwNumEntries, pbMDData)\
{                                                       \
    METADATA_GETALL_RECORD * pAllRecords =              \
        (METADATA_GETALL_RECORD *)pbMDData;             \
    ASSERT(pAllRecords != NULL);                        \
                                                        \
    for (DWORD i = 0; i < dwNumEntries; ++i)            \
    {                                                   \
        METADATA_GETALL_RECORD * pRec = &pAllRecords[i];\
        switch(pRec->dwMDIdentifier)                    \
        {

#define HANDLE_META_RECORD(id, value)\
        case id:                                        \
            FetchMetaValue(pAllRecords, i, MP_V(value));\
            break;

#define HANDLE_INHERITED_META_RECORD(id, value, fIsInherited)\
        case id:                                                               \
            FetchInheritedMetaValue(pAllRecords, i, MP_V(value), fIsInherited);\
            break;


#define END_PARSE_META_RECORDS\
        }                                                \
    }                                                    \
}



//
// Sheet -> page crackers
//
#define BEGIN_META_INST_READ(sheet)\
{                                                                        \
    sheet * pSheet = (sheet *)GetSheet();                                \
    do                                                                   \
    {                                                                    \
        if (FAILED(pSheet->QueryInstanceResult()))                       \
        {                                                                \
            break;                                                       \
        }

#define FETCH_INST_DATA_FROM_SHEET(value)\
    value = pSheet->GetInstanceProperties().value;                       \
    TRACEEOLID(value);

#define END_META_INST_READ(err)\
                                                                         \
    }                                                                    \
    while(FALSE);                                                        \
}

#define BEGIN_META_DIR_READ(sheet)\
{                                                                        \
    sheet * pSheet = (sheet *)GetSheet();                                \
    do                                                                   \
    {                                                                    \
        if (FAILED(pSheet->QueryDirectoryResult()))                      \
        {                                                                \
            break;                                                       \
        }

#define FETCH_DIR_DATA_FROM_SHEET(value)\
    value = pSheet->GetDirectoryProperties().value;                      \
    TRACEEOLID(value);

#define END_META_DIR_READ(err)\
                                                                         \
    }                                                                    \
    while(FALSE);                                                        \
}


#define BEGIN_META_INST_WRITE(sheet)\
{                                                                        \
    sheet * pSheet = (sheet *)GetSheet();                                \
                                                                         \
    do                                                                   \
    {                                                                    \

#define STORE_INST_DATA_ON_SHEET(value)\
        pSheet->GetInstanceProperties().value = value;

#define STORE_INST_DATA_ON_SHEET_REMEMBER(value, dirty)\
        pSheet->GetInstanceProperties().value = value;    \
        dirty = MP_D(((sheet *)GetSheet())->GetInstanceProperties().value);

#define FLAG_INST_DATA_FOR_DELETION(id)\
        pSheet->GetInstanceProperties().FlagPropertyForDeletion(id);

#define END_META_INST_WRITE(err)\
                                                                        \
    }                                                                   \
    while(FALSE);                                                       \
                                                                        \
    err = pSheet->GetInstanceProperties().WriteDirtyProps();            \
}


#define BEGIN_META_DIR_WRITE(sheet)\
{                                                                        \
    sheet * pSheet = (sheet *)GetSheet();                                \
                                                                         \
    do                                                                   \
    {                                                                    \

#define STORE_DIR_DATA_ON_SHEET(value)\
        pSheet->GetDirectoryProperties().value = value;

#define STORE_DIR_DATA_ON_SHEET_REMEMBER(value, dirty)\
        pSheet->GetDirectoryProperties().value = value;      \
        dirty = MP_D(pSheet->GetDirectoryProperties().value);

#define INIT_DIR_DATA_MASK(value, mask)\
        MP_V(pSheet->GetDirectoryProperties().value).SetMask(mask);

#define FLAG_DIR_DATA_FOR_DELETION(id)\
        pSheet->GetDirectoryProperties().FlagPropertyForDeletion(id);

#define END_META_DIR_WRITE(err)\
                                                                        \
    }                                                                   \
    while(FALSE);                                                       \
                                                                        \
    err = pSheet->GetDirectoryProperties().WriteDirtyProps();           \
}




class COMDLL CInetPropertyPage : public CPropertyPage
{
/*++

Class Description:

    IIS Configuration property page class

Public Interface:

    CInetPropertyPage           : Constructor
    ~CInetPropertyPage          : Destructor

    SaveInfo                    : Save info on this page if dirty

--*/
    DECLARE_DYNAMIC(CInetPropertyPage)

//
// Construction/Destruction
//
public:
    CInetPropertyPage(
        IN UINT nIDTemplate,
        IN CInetPropertySheet * pSheet,
        IN UINT nIDCaption              = USE_DEFAULT_CAPTION,
        IN BOOL fEnableEnhancedFonts    = FALSE
        );

    ~CInetPropertyPage();

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CInetPropertyPage)
    //enum { IDD = _UNKNOWN_RESOURCE_ID_ };
    //}}AFX_DATA

//
// Overrides
//
public:
    //
    // Derived classes must provide their own equivalents
    //
    HRESULT LoadConfigurationParameters();
    /* PURE */ virtual HRESULT FetchLoadedValues() = 0;
    /* PURE */ virtual HRESULT SaveInfo() = 0;

    //
    // Is the data on this page dirty?
    //
    BOOL IsDirty() const { return m_bChanged; }

    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CInetPropertyPage)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

protected:
    //
    // Generated message map functions
    //
    //{{AFX_MSG(CInetPropertyPage)
    afx_msg void OnHelp();
    afx_msg BOOL OnHelpInfo(HELPINFO * pHelpInfo);
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()

    virtual BOOL OnInitDialog();
    virtual BOOL OnApply();

//
// Helper function
//
protected:
    BOOL GetIUsrAccount(CString & str);

//
// Access Functions
//
protected:
    //
    // Get associated property sheet object
    //
    CInetPropertySheet * GetSheet() { return m_pSheet; }
    CString & GetServerName()       { return m_pSheet->GetServerName(); }
    LPCTSTR QueryServerName() const { return m_pSheet->QueryServerName(); }
    DWORD QueryInstance()     const { return m_pSheet->QueryInstance(); }
    LPCTSTR QueryAlias()      const { return m_pSheet->QueryAlias(); }
    LPCTSTR QueryParent()     const { return m_pSheet->QueryParent(); }
    BOOL IsLocal()            const { return m_pSheet->IsLocal(); }
    BOOL HasAdminAccess()     const { return m_pSheet->HasAdminAccess(); }
    BOOL IsMasterInstance()   const { return m_pSheet->IsMasterInstance(); }

    //
    // Update MMC with new changes
    //
    void NotifyMMC();

public:
    //
    // Keep private information on page dirty state, necessary for
    // SaveInfo() later.
    //
    void SetModified(
        IN BOOL bChanged = TRUE
        );

protected:
    BOOL m_bChanged;

//
// Capability bits
//
protected:
    BOOL IsSSLSupported()       const { return m_pSheet->cap().IsSSLSupported(); }
    BOOL IsSSL128Supported()    const { return m_pSheet->cap().IsSSL128Supported(); }
    BOOL HasMultipleSites()     const { return m_pSheet->cap().HasMultipleSites(); }
    BOOL HasBwThrottling()      const { return m_pSheet->cap().HasBwThrottling(); }
    BOOL Has10ConnectionLimit() const { return m_pSheet->cap().Has10ConnectionLimit(); }
    BOOL HasIPAccessCheck()     const { return m_pSheet->cap().HasIPAccessCheck(); }
    BOOL HasOperatorList()      const { return m_pSheet->cap().HasOperatorList(); } 
    BOOL HasFrontPage()         const { return m_pSheet->cap().HasFrontPage(); }
    BOOL HasCompression()       const { return m_pSheet->cap().HasCompression(); }
    BOOL HasCPUThrottling()     const { return m_pSheet->cap().HasCPUThrottling(); }
    BOOL HasDAV()               const { return m_pSheet->cap().HasDAV(); }
    BOOL HasDigest()            const { return m_pSheet->cap().HasDigest(); }
    BOOL HasNTCertMapper()      const { return m_pSheet->cap().HasNTCertMapper(); }

protected:
    CInetPropertySheet * m_pSheet;
    INT m_refcount;
    LPFNPSPCALLBACK m_pfnOriginalPropSheetPageProc;
    static UINT CALLBACK PropSheetPageProc(
        IN HWND hWnd,
        IN UINT uMsg,
        IN LPPROPSHEETPAGE ppsp
        );

protected:
    BOOL      m_fEnableEnhancedFonts;
    CFont     m_fontBold;
    UINT      m_nHelpContext;
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline BOOL CMaskedDWORD::operator ==(DWORD dwValue) const
{
    return (m_dwValue & m_dwMask) == (dwValue & m_dwMask); 
} 

inline CMaskedDWORD & CMaskedDWORD::operator =(DWORD dwValue) 
{ 
    m_dwValue = ((m_dwValue &= ~m_dwMask) |= (dwValue & m_dwMask));
    return *this;
}

inline CBlob::~CBlob()
{
    CleanUp();
}

inline PBYTE CBlob::GetData()
{
    return m_pbItem;
}

inline LPCTSTR NormalizeServerName(
    IN LPCTSTR lpszServerName
    )
{
    return !lpszServerName || !::IsServerLocal(lpszServerName)
        ? lpszServerName
        : NULL;
}

inline /*virtual */ HRESULT CMetaProperties::WriteDirtyProps()
{
    ASSERT(FALSE);
    return E_NOTIMPL;
}

inline void CMetaProperties::FlagPropertyForDeletion(DWORD dwID)
{
    m_dwaDeletedProps.AddTail(dwID);
}

inline LPCTSTR CInstanceProps::GetDisplayText(
    OUT CString & strName, 
    IN  LPCTSTR szServiceName
    )
{
    return CInstanceProps::GetDisplayText(
        strName, 
        m_strComment, 
        m_strDomainName,
        szServiceName,
        m_iaIpAddress,
        m_nTCPPort,
        QueryInstance()
        );
}

inline LPCTSTR CInstanceProps::GetHomePath(CString & str)
{
    str = m_strMetaRoot + SZ_MBN_SEP_STR + g_cszRoot;
    return str;
}

inline void CInstanceProps::FillInstanceInfo(
    OUT ISMINSTANCEINFO * pii, 
    IN  DWORD dwError               OPTIONAL
    )
{
    pii->dwID = m_dwInstance;
    pii->dwIPAddress = (DWORD)m_iaIpAddress;
    pii->sPort = (SHORT)m_nTCPPort;
    pii->nState = m_nISMState;
    pii->fDeletable = IsDeletable();
    pii->fClusterEnabled = IsClusterEnabled();
    pii->dwError = dwError;

    _tcsncpy(
        pii->szComment, 
        m_strComment, 
        STRSIZE(pii->szComment)
        );

    _tcsncpy(
        pii->szServerName, 
        m_strDomainName, 
        STRSIZE(pii->szServerName)
        );
}

inline void CChildNodeProps::RemovePathIfInherited()
{
    if (IsPathInherited())
    {
        MP_V(m_strPath).Empty();
    }
}

inline void CChildNodeProps::FillInstanceInfo(ISMINSTANCEINFO * pii)
{
    _tcsncpy(pii->szPath, GetPath(), STRSIZE(pii->szPath));
    _tcsncpy(pii->szRedirPath, GetRedirectedPath(), STRSIZE(pii->szRedirPath));
    pii->fChildOnlyRedir = m_fChild;
}

inline void CChildNodeProps::FillChildInfo(ISMCHILDINFO * pii)
{
    //
    // Set the output structure
    //
    pii->fInheritedPath = IsPathInherited();
    pii->fEnabledApplication = IsEnabledApplication();
    pii->dwError = QueryWin32Error();

    _tcsncpy(
        pii->szAlias, 
        GetAlias(), 
        STRSIZE(pii->szAlias)
        );

    _tcsncpy(
        pii->szPath, 
        GetPath(),
        STRSIZE(pii->szPath)
        );

    _tcsncpy(
        pii->szRedirPath, 
        IsRedirected() ? GetRedirectedPath() : _T(""),
        STRSIZE(pii->szRedirPath)
        );

    pii->fChildOnlyRedir = m_fChild;
}

inline void CInetPropertySheet::SetModeless()
{
    m_bModeless = TRUE;
}

inline DWORD CInetPropertySheet::DetermineAdminAccess(
    IN LPCTSTR lpszService,
    IN DWORD dwInstance
    )
{
    return DetermineIfAdministrator(
        &m_cap,                      // Reuse existing interface
        lpszService,
        dwInstance,
        &m_fHasAdminAccess
        );
}

inline HRESULT CInetPropertyPage::LoadConfigurationParameters()
{
    return GetSheet()->LoadConfigurationParameters();
}

inline BOOL CInetPropertyPage::GetIUsrAccount(CString & str)
{
    return ::GetIUsrAccount(QueryServerName(), this, str);
}

inline void CInetPropertyPage::NotifyMMC()
{
   m_pSheet->NotifyMMC();
}


#endif // _INETPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\comprop\ipa.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        ipa.cpp

   Abstract:

        IP Address value and helper functions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include "comprop.h"
#include <winsock2.h>



/* static */
DWORD
CIPAddress::StringToLong(
    IN LPCTSTR lpstr,
    IN int nLength
    )
/*++

Routine Description:

    Static function to convert an ip address string of the form "1.2.3.4"
    to a a single 32 bit number.

Arguments:

    LPCTSTR lpstr : String ip address
    int nLength   : Length of string

Return Value:

    32 bit ip address.

--*/
{
    DWORD dwIPValue = 0L;

    if (nLength > 0)
    {
        u_long ul;

#ifdef UNICODE

        try
        {
            //
            // Convert to ANSI
            //
            LPSTR pszDest = AllocAnsiString(lpstr);
            ul = ::inet_addr(pszDest);
            FreeMem(pszDest);
        }
        catch(CException * e)
        {
            TRACEEOLID("!!!Exception converting string to ip address");
            e->ReportError();
            e->Delete();
        }

#else

        ul = ::inet_addr(lpstr);

#endif // UNICODE

        //
        // Convert to host byte order.
        //
        dwIPValue = (DWORD)::ntohl(ul);
    }

    return dwIPValue;
}



/* static */
LPTSTR
CIPAddress::LongToString(
    IN  const DWORD dwIPAddress,
    OUT LPTSTR lpStr,
    IN  int cbSize
    )
/*++

Routine Description:

    Static function to convert a 32 bit number to a CString of the format
    "1.2.3.4"

Arguments:

    const DWORD dwIPAddress : 32 bit ip address to be converted to string
    LPTSTR lpStr            : Destination string
    int cbSize              : Size of destination string

Return Value:

    Pointer to string buffer

--*/
{
    struct in_addr ipaddr;

    //
    // Convert the unsigned long to network byte order
    //
    ipaddr.s_addr = ::htonl((u_long)dwIPAddress);

    //
    // Convert the IP address value to a string
    //
    LPCSTR pchAddr = ::inet_ntoa(ipaddr);

#ifdef UNICODE

    VERIFY(::MultiByteToWideChar(CP_ACP, 0L, pchAddr, -1, lpStr, cbSize));

#else

    ::lstrcpy(lpStr, pchAddr);

#endif // UNICODE

    return lpStr;
}



/* static */
LPCTSTR
CIPAddress::LongToString(
    IN  const DWORD dwIPAddress,
    OUT CString & str
    )
/*++

Routine Description:

    Static function to convert a 32 bit number to a CString of the format
    "1.2.3.4"

Arguments:

    const DWORD dwIPAddress : 32 bit ip address to be converted to string
    CString & str           : Destination string

Return Value:

    Pointer to string buffer

--*/
{
    struct in_addr ipaddr;

    //
    // Convert the unsigned long to network byte order
    //
    ipaddr.s_addr = ::htonl((u_long)dwIPAddress);

    //
    // Convert the IP address value to a string
    //
    LPCSTR pchAddr = ::inet_ntoa(ipaddr);

    try
    {
        str = pchAddr;
    }
    catch(CMemoryException * e)
    {
        TRACEEOLID("!!!Exception converting ip address to string");
        e->ReportError();
        e->Delete();
    }

    return (LPCTSTR)str;
}



/* static */
LPBYTE
CIPAddress::DWORDtoLPBYTE(
    IN  DWORD  dw,
    OUT LPBYTE lpBytes
    )
/*++

Routine Description:

    Convert a DWORD to a byte array of 4 bytes.  No size
    checking is performed.

Arguments:

    DWORD  dw      : 32 bit ip address
    LPBYTE lpBytes : Byte stream

Return Value:

    Pointer to the input buffer.

--*/
{
    lpBytes[0] = (BYTE)GETIP_FIRST(dw);
    lpBytes[1] = (BYTE)GETIP_SECOND(dw);
    lpBytes[2] = (BYTE)GETIP_THIRD(dw);
    lpBytes[3] = (BYTE)GETIP_FOURTH(dw);

    return lpBytes;
}



CIPAddress::CIPAddress()
/*++

Routine Description:

    Constructor

Arguments:

    None

Return Value:

    N/A

--*/
    : m_dwIPAddress(0L)
{
}



CIPAddress::CIPAddress(
    IN DWORD dwIPAddress,
    IN BOOL fNetworkByteOrder
    )
/*++

Routine Description:

    Constructor.

Arguments:

    DWORD dwIPAddress      : IP address value
    BOOL fNetworkByteOrder : if TRUE, value must be converted to host byte
                             order, otherwise is assumed to already be in
                             host byte order.

Return Value:

    N/A

--*/
{
    if (fNetworkByteOrder)
    {
        //
        // Convert to host byte order
        //
        dwIPAddress = (DWORD)::ntohl((u_long)dwIPAddress);
    }

    m_dwIPAddress = dwIPAddress;
}



CIPAddress::CIPAddress(
    IN BYTE b1,
    IN BYTE b2,
    IN BYTE b3,
    IN BYTE b4
    )
/*++

Routine Description:

    Constructor.

Arguments:

    BYTE b1 : First octet
    BYTE b2 : Second octet
    BYTE b3 : Third octet
    BYTE b4 : Fourth octet

Return Value:

    N/A

Notes:

    This is already assumed to be in host order

--*/
    : m_dwIPAddress(MAKEIPADDRESS(b1, b2, b3, b4))
{
}



CIPAddress::CIPAddress(
    IN LPBYTE lpBytes,
    IN BOOL  fNetworkByteOrder OPTIONAL
    )
/*++

Routine Description:

    Construct from byte stream

Arguments:

    LPBYTE lpBytes           : Byte stream
    BOOL  fNetworkByteOrder  : TRUE if the byte stream is in network byte order

Return Value:

    N/A

--*/
{
}



CIPAddress::CIPAddress(
    IN const CIPAddress & ia
    )
/*++

Routine Description:

    Copy Constructor.

Arguments:

    const CIPAddress & ia

Return Value:

    N/A

--*/
    : m_dwIPAddress(ia.m_dwIPAddress)
{
}



CIPAddress::CIPAddress(
    IN LPCTSTR lpstr,
    IN int nLength
    )
/*++

Routine Description:

    Constructor.

Arguments:

    LPCTSTR lpstr : string ip value
    int nLength   : length of string

Return Value:

    N/A

--*/
{
    m_dwIPAddress = CIPAddress::StringToLong(lpstr, nLength);
}



CIPAddress::CIPAddress(
    const CString & str
    )
/*++

Routine Description:

    Constructor.

Arguments:

    const CString & str : IP Address string

Return Value:

    N/A

--*/
{
    m_dwIPAddress = CIPAddress::StringToLong(str);
}



const CIPAddress &
CIPAddress::operator =(
    IN const CIPAddress & ia
    )
/*++

Routine Description:

    Assignment operator

Arguments:

    const CIPAddress & ia : Source ip address

Return Value:

    Current object

--*/
{
    m_dwIPAddress = ia.m_dwIPAddress;

    return *this;
}



const CIPAddress &
CIPAddress::operator =(
    IN const DWORD dwIPAddress
    )
/*++

Routine Description:

    Assignment operator

Arguments:

    const DWORD dwIPAddress : Source ip address

Return Value:

    Current object

--*/
{
    m_dwIPAddress = dwIPAddress;

    return *this;
}



const CIPAddress &
CIPAddress::operator =(
    IN LPCTSTR lpstr
    )
/*++

Routine Description:

    Assignment operator

Arguments:

    LPCTSTR lpstr : Source string

Return Value:

    Current object

--*/
{
    m_dwIPAddress = CIPAddress::StringToLong(lpstr, ::lstrlen(lpstr));

    return *this;
}



const CIPAddress &
CIPAddress::operator =(
    IN const CString & str
    )
/*++

Routine Description:

    Assignment operator

Arguments:

    const CString & str : Source string

Return Value:

    Current object

--*/
{
    m_dwIPAddress = CIPAddress::StringToLong(str);

    return *this;
}



int
CIPAddress::CompareItem(
    IN const CIPAddress & ia
    ) const
/*++

Routine Description:

    Compare two ip addresses

Arguments:

    const CIPAddress & ia : IP Address to compare this to

Return Value:

    +1 if the current ip address is greater,
     0 if the two ip addresses are the same
    -1 if the current ip address is less,

--*/
{
    return (DWORD)ia < m_dwIPAddress
           ? +1
           : (DWORD)ia == m_dwIPAddress
                ? 0
                : -1;
}



CIPAddress::operator LPCTSTR() const
/*++

Routine Description:

    Conversion operator

Arguments:

    N/A

Return Value:

    Pointer to converted string

--*/
{
    static TCHAR szIPAddress[] = _T("xxx.xxx.xxx.xxx");

    return CIPAddress::LongToString(
        m_dwIPAddress,
        szIPAddress,
        ARRAY_SIZE(szIPAddress)
        );
}



CIPAddress::operator CString() const
/*++

Routine Description:

    Conversion operator

Arguments:

    N/A

Return Value:

    Converted string

--*/
{
    CString str;

    CIPAddress::LongToString(m_dwIPAddress, str);

    return str;
}



DWORD
CIPAddress::QueryIPAddress(
    IN BOOL fNetworkByteOrder
    ) const
/*++

Routine Description:

    Get the ip address as a 32 bit number

Arguments:

    BOOL fNetworkByteOrder : If TRUE, convert to network byte order

Return Value:

    32 bit ip address

--*/
{
    return fNetworkByteOrder
        ? ::htonl((u_long)m_dwIPAddress)
        : m_dwIPAddress;
}



//
// IP Address helper functions
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



DWORD
PopulateComboWithKnownIpAddresses(
    IN  LPCTSTR lpszServer,
    IN  CComboBox & combo,
    IN  CIPAddress & iaIpAddress,
    OUT CObListPlus & oblIpAddresses,
    OUT int & nIpAddressSel
    )
/*++

Routine Description:

    Fill a combo box with known ip addresses

Arguments:

    LPCTSTR lpszServer           : Server whose ip addresses to obtain
                                  (can be computer name or ip address)

    CComboBox & combo            : Combo box to populate
    CIPAddress & iaIpAddress     : IP Address to select
    CObListPlus & oblIpAddresses : Returns an oblist of CIPAddress objects
    int & nIpAddressSel          : Returns selected IP address

Return Value:

    Error return code

--*/
{
    //
    // Start clean
    //
    oblIpAddresses.RemoveAll();
    combo.ResetContent();

    //
    // Don't like \\names
    //
    lpszServer = PURE_COMPUTER_NAME(lpszServer);
    struct hostent * pHostEntry = NULL;
    if (_istdigit(*lpszServer))
    {
        //
        // Get by ip address
        //
        u_long ul = (DWORD)CIPAddress(lpszServer);
        ul = ::htonl(ul);   // convert to network order.
        pHostEntry = ::gethostbyaddr((CHAR *)&ul, sizeof(ul), PF_INET);
    }
    else
    {
        //
        // Get by domain name
        //
        const char FAR * lpszAnsiServer = NULL;

#ifdef UNICODE

        CHAR szAnsi[255];

        if (::WideCharToMultiByte(CP_ACP, 0L, lpszServer, -1,  szAnsi,
            sizeof(szAnsi), NULL, NULL) > 0)
        {
            lpszAnsiServer = szAnsi;
        }
#else
        lpszAnsiServer = lpszServer;
#endif // UNICODE

        if (lpszAnsiServer)
        {
            pHostEntry = ::gethostbyname(lpszAnsiServer);
        }
    }

    //
    // We'll always have the 'default' server id
    // selected
    //
    CString strDefault, str;
    VERIFY(strDefault.LoadString(IDS_DEFAULT));

    nIpAddressSel = -1;
    CIPAddress * pia = new CIPAddress;

    if (pia == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    oblIpAddresses.AddTail(pia);
    int nNewSel = combo.AddString(strDefault);

    if (iaIpAddress == *pia)
    {
        //
        // Remember selection
        //
        nIpAddressSel = nNewSel;
    }

    if (pHostEntry != NULL)
    {
        int n = 0;
        while (((DWORD *)pHostEntry->h_addr_list[n]) != NULL)
        {
            //
            // Convert from network byte order
            //
            pia = new CIPAddress(
                *((DWORD *)(pHostEntry->h_addr_list[n++])), TRUE);
            nNewSel = combo.AddString(pia->QueryIPAddress(str));
            oblIpAddresses.AddTail(pia);

            if (iaIpAddress == *pia)
            {
                //
                // This is our current ip address, save index
                // for selection
                //
                nIpAddressSel = nNewSel;
            }
        }
    }

    if (nIpAddressSel < 0)
    {
        //
        // Ok, the IP address selected is not part of the
        // list.  Add it to the list, and select it.
        //
        pia = new CIPAddress(iaIpAddress);
        nIpAddressSel = combo.AddString(pia->QueryIPAddress(str));
        oblIpAddresses.AddTail(pia);
    }

    combo.SetCurSel(nIpAddressSel);

    return ERROR_SUCCESS;
}



BOOL
FetchIpAddressFromCombo(
    IN  CComboBox & combo,
    IN  CObListPlus & oblIpAddresses,
    OUT CIPAddress & ia
    )
/*++

Routine Description:

    Helper function to fetch an ip address from the combo box.
    The combo box may not have a selection, in which case whatever
    is in the edit box is used

Arguments:

    CComboBox & combo               : Combo box
    CObListPlus & oblIpAddresses    : Oblist of ip addresses
    CIPAddress & ia                 : Returns the ip address

Return Value:

    TRUE if a valid IP address is found, FALSE otherwise.

--*/
{
    int nSel = combo.GetCurSel();

    if (nSel >= 0)
    {
        //
        // Fetch selected item
        //
        CIPAddress * pia = (CIPAddress *)oblIpAddresses.Index(nSel);
        ASSERT(pia != NULL);
        if (pia != NULL)
           ia = *pia;   

        return TRUE;
    }

    //
    // Try to make an ip address out of what's in the editbox
    //
    CString str;
    combo.GetWindowText(str);
    if (!str.IsEmpty())
    {
        ia = str;
        if (!ia.IsZeroValue() && !ia.IsBadValue())
        {
            return TRUE;
        }
    }

    //
    // No good
    //
    ::AfxMessageBox(IDS_IP_INVALID);

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\comprop\ipctl.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        ipctl.cpp

   Abstract:

        IP Address common control MFC wrapper

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include "comprop.h"

//#if (_WIN32_IE >= 0x0400)

//
// Static Initialization
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

BOOL CIPAddressCtl::m_fClassRegistered = FALSE;



/* static */
BOOL
CIPAddressCtl::RegisterClass()
/*++

Routine Description:

    Ensure that the class is registered.

Arguments:

    None

Return Value:

    TRUE for success, FALSE otherwise.

--*/
{
    if (!m_fClassRegistered)
    {
        //
        // Class not registed, register now
        //
        INITCOMMONCONTROLSEX icex;    
        icex.dwSize = sizeof(icex);
        icex.dwICC = ICC_INTERNET_CLASSES;

        m_fClassRegistered = ::InitCommonControlsEx(&icex);
    }        

    return m_fClassRegistered;
}



IMPLEMENT_DYNAMIC(CIPAddressCtl, CWnd)



CIPAddressCtl::CIPAddressCtl()
/*++

Routine Description:

    Constructor

Arguments:

    None

Return Value:

    N/A

--*/
{
    VERIFY(RegisterClass());
}



CIPAddressCtl::~CIPAddressCtl()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    DestroyWindow();
}

// #endif // _WIN32_IE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\comprop\ipa.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        ipa.h

   Abstract:

        IP Address value

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

#ifndef _IPA_H
#define _IPA_H

//
// IP Address Conversion Macros
//
#ifdef MAKEIPADDRESS
#undef MAKEIPADDRESS
#endif // MAKEIPADDRESS

#define MAKEIPADDRESS(b1,b2,b3,b4) (((DWORD)(b1)<<24) +\
                                    ((DWORD)(b2)<<16) +\
                                    ((DWORD)(b3)<< 8) +\
                                    ((DWORD)(b4)))

#ifndef GETIP_FIRST

  #define GETIP_FIRST(x)             ((x>>24) & 0xff)
  #define GETIP_SECOND(x)            ((x>>16) & 0xff)
  #define GETIP_THIRD(x)             ((x>> 8) & 0xff)
  #define GETIP_FOURTH(x)            ((x)     & 0xff)

#endif // GETIP_FIRST

//
// Some predefined IP values
//
#define NULL_IP_ADDRESS     (DWORD)(0x00000000)
#define NULL_IP_MASK        (DWORD)(0xFFFFFFFF)
#define BAD_IP_ADDRESS      (DWORD)(0xFFFFFFFF)



class COMDLL CIPAddress : public CObjectPlus
/*++

Class Description:

    IP Address classes.  Winsock is required to be initialized for this
    to work.

Public Interface:

    CIPAddress                 : Various constructors

    operator =                 : Assignment operator
    operator ==                : Comparison operators
    operator const DWORD       : Cast operator
    operator LPCTSTR           : Cast operator
    operator CString           : Cast operator
    CompareItem                : Comparison function
    QueryIPAddress             : Get the ip address value
    QueryNetworkOrderIPAddress : Get the ip address value (network order)
    QueryHostOrderIPAddress    : Get the ip address value (host order)

    StringToLong               : Convert ip address string to 32 bit number
    LongToString               : Convert 32 bit value to ip address string

--*/
{
//
// Helper Functions
//
public:
    static DWORD StringToLong(
        IN LPCTSTR lpstr,
        IN int nLength
        );

    static DWORD StringToLong(
        IN const CString & str
        );

    static LPCTSTR LongToString(
        IN  const DWORD dwIPAddress,
        OUT CString & str
        );

    static LPTSTR LongToString(
        IN  const DWORD dwIPAddress,
        OUT LPTSTR lpStr,
        IN  int cbSize
        );

    static LPBYTE DWORDtoLPBYTE(
        IN  DWORD  dw,
        OUT LPBYTE lpBytes
        );

public:
    //
    // Constructors
    //
    CIPAddress();

    //
    // Construct from DWORD
    //
    CIPAddress(
        IN DWORD dwIPValue,
        IN BOOL  fNetworkByteOrder = FALSE
        );

    //
    // Construct from byte stream
    //
    CIPAddress(
        IN LPBYTE lpBytes,
        IN BOOL  fNetworkByteOrder = FALSE
        );

    //
    // Construct from octets
    //
    CIPAddress(
        IN BYTE b1,
        IN BYTE b2,
        IN BYTE b3,
        IN BYTE b4
        );

    //
    // Copy constructor
    //
    CIPAddress(
        IN const CIPAddress & ia
        );

    //
    // Construct from string
    //
    CIPAddress(
        IN LPCTSTR lpstr,
        IN int nLength
        );

    //
    // Construct from CString
    //
    CIPAddress(
        IN const CString & str
        );

//
// Access Functions
//
public:
    int CompareItem(
        IN const CIPAddress & ia
        ) const;

    //
    // Query IP address value as a dword
    //
    DWORD QueryIPAddress(
        IN BOOL fNetworkByteOrder = FALSE
        ) const;

    //
    // Get the ip address value as a byte stream
    //
    LPBYTE QueryIPAddress(
        OUT LPBYTE lpBytes,
        IN  BOOL fNetworkByteOrder = FALSE
        ) const;

    //
    // Get the ip address as a CString
    //
    LPCTSTR QueryIPAddress(
        OUT CString & strAddress
        ) const;

    //
    // Get ip address in network byte order DWORD
    //
    DWORD QueryNetworkOrderIPAddress() const;

    //
    // Get the ip address in host byte order DWORD
    //
    DWORD QueryHostOrderIPAddress() const;

    //
    // Assignment operators
    //
    const CIPAddress & operator =(
        IN const DWORD dwIPAddress
        );

    const CIPAddress & operator =(
        IN LPCTSTR lpstr
        );

    const CIPAddress & operator =(
        IN const CString & str
        );

    const CIPAddress & operator =(
        IN const CIPAddress & ia
        );

    //
    // Comparison operators
    //
    BOOL operator ==(
        IN const CIPAddress & ia
        ) const;

    BOOL operator ==(
        IN DWORD dwIPAddress
        ) const;

    BOOL operator !=(
        IN const CIPAddress & ia
        ) const;

    BOOL operator !=(
        IN DWORD dwIPAddress
        ) const;

    //
    // Conversion operators
    //
    operator const DWORD() const { return m_dwIPAddress; }
    operator LPCTSTR() const;
    operator CString() const;

    //
    // Value Verification Helpers
    //
    void SetZeroValue();
    BOOL IsZeroValue() const;
    BOOL IsBadValue() const;

private:
    DWORD m_dwIPAddress;
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline /* static */ DWORD CIPAddress::StringToLong(
    IN const CString & str
    )
{
    return CIPAddress::StringToLong(str, str.GetLength());
}

inline LPCTSTR CIPAddress::QueryIPAddress(
    OUT CString & strAddress
    ) const
{
    return LongToString(m_dwIPAddress, strAddress);
}
        
inline DWORD CIPAddress::QueryNetworkOrderIPAddress() const
{
    return QueryIPAddress(TRUE);
}

inline DWORD CIPAddress::QueryHostOrderIPAddress() const
{
    return QueryIPAddress(FALSE);
}

inline BOOL CIPAddress::operator ==(
    IN const CIPAddress & ia
    ) const
{
    return CompareItem(ia) == 0;
}

inline BOOL CIPAddress::operator ==(
    IN DWORD dwIPAddress
    ) const
{
    return m_dwIPAddress == dwIPAddress;
}

inline BOOL CIPAddress::operator !=(
    IN const CIPAddress & ia
    ) const
{
    return CompareItem(ia) != 0;
}

inline BOOL CIPAddress::operator !=(
    IN DWORD dwIPAddress
    ) const
{
    return m_dwIPAddress != dwIPAddress;
}

inline void CIPAddress::SetZeroValue() 
{
    m_dwIPAddress = NULL_IP_ADDRESS;
}

inline BOOL CIPAddress::IsZeroValue() const
{
    return m_dwIPAddress == NULL_IP_ADDRESS;
}

inline BOOL CIPAddress::IsBadValue() const
{
    return m_dwIPAddress == BAD_IP_ADDRESS;
}



//
// Helper function to build a list of known IP addresses,
// and add them to a combo box
//
DWORD COMDLL PopulateComboWithKnownIpAddresses(
    IN  LPCTSTR lpszServer,
    IN  CComboBox & combo,
    IN  CIPAddress & iaIpAddress,
    OUT CObListPlus & oblIpAddresses,
    OUT int & nIpAddressSel
    );

//
// Helper function to get an ip address from a combo/edit/list
// control
//
BOOL COMDLL FetchIpAddressFromCombo(
    IN  CComboBox & combo,
    IN  CObListPlus & oblIpAddresses,
    OUT CIPAddress & ia
    );

#endif // _IPA_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\comprop\ipaddres.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1995                **/
/**********************************************************************/

/*
    FILE HISTORY:
        
*/

#define OEMRESOURCE
#include "stdafx.h"

#include <stdlib.h>
#include <memory.h>
#include <ctype.h>
#include <winsock.h>

#include "comprop.h"
#include "objplus.h"
#include "ipaddres.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#define new DEBUG_NEW

// CAVEAT: The functions herein require the winsock lib.

// Constructor
CIpAddress::CIpAddress (const CString & str)
{
    CHAR szString [ MAX_PATH ] = {0};

	if (IsValidIp(str))
	{
#ifdef UNICODE
		::WideCharToMultiByte(CP_ACP, 0, str, -1, szString, sizeof(szString), NULL, NULL);
#else
		strcpy (szString, str, str.GetLength());
#endif

		ULONG ul = ::inet_addr( szString );
		m_fInitOk = (ul != INADDR_NONE);
    
		//  Convert the string to network byte order, then to host byte order.
		if (m_fInitOk)
		{
			m_lIpAddress = (LONG)::ntohl(ul) ;
		}
	}
	else
	{
		m_fInitOk = FALSE;
		m_lIpAddress = 0;
	}
}

// Assignment operator
const CIpAddress & CIpAddress::operator =(const LONG l)
{
    m_lIpAddress = l;
    m_fInitOk = TRUE;
    return (*this);
}

// Assignment operator
const CIpAddress & CIpAddress::operator =(const CString & str)
{
    CHAR szString [ MAX_PATH ] = {0};

	if (IsValidIp(str))
	{
#ifdef UNICODE
	    ::WideCharToMultiByte(CP_ACP, 0, str, -1, szString, sizeof(szString), NULL, NULL);
#else
		strcpy (szString, str, str.GetLength());
#endif

		ULONG ul = ::inet_addr( szString );
		m_fInitOk = (ul != INADDR_NONE);
    
		//  Convert the string to network byte order, then to host byte order.
		if (m_fInitOk)
		{
			m_lIpAddress = (LONG)::ntohl(ul) ;
		}
	}
	else
	{
		m_fInitOk = FALSE;
		m_lIpAddress = 0;
	}

    return(*this);
}

BOOL
CIpAddress::IsValidIp(const CString & str)
{
	BOOL fValid = TRUE;

	for (int i = 0; i < str.GetLength(); i++)
	{
		if (str[i] != '.' &&
			!iswdigit(str[i]))
		{
			fValid = FALSE;
			break;
		}
	}

	return fValid;
}

// Conversion operator
CIpAddress::operator const CString&() const
{
    struct in_addr ipaddr ;
    static CString strAddr;

    //  Convert the unsigned long to network byte order
    ipaddr.s_addr = ::htonl( (u_long) m_lIpAddress ) ;

    //  Convert the IP address value to a string
    strAddr = inet_ntoa( ipaddr ) ;

    return(strAddr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\comprop\ipaddres.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1995                **/
/**********************************************************************/

/*
    FILE HISTORY:

*/

#ifndef _IPADDRES_H_
#define _IPADDRES_H_

//
// IP Address Conversion Macros
//
#ifndef MAKEIPADDRESS
  #define MAKEIPADDRESS(b1,b2,b3,b4) ((LONG)(((DWORD)(b1)<<24)+((DWORD)(b2)<<16)+((DWORD)(b3)<<8)+((DWORD)(b4))))

  #define GETIP_FIRST(x)             ((x>>24) & 0xff)
  #define GETIP_SECOND(x)            ((x>>16) & 0xff)
  #define GETIP_THIRD(x)             ((x>> 8) & 0xff)
  #define GETIP_FOURTH(x)            ((x)     & 0xff)
#endif // MAKEIPADDRESS

/////////////////////////////////////////////////////////////////////////////
// CIpAddress class

class CIpAddress : public CObjectPlus
{
public:
    // Constructors
    CIpAddress()
    {
        m_lIpAddress = 0L;
        m_fInitOk = FALSE;
    }
    CIpAddress (LONG l)
    {
        m_lIpAddress = l;
        m_fInitOk = TRUE;
    }
    CIpAddress (BYTE b1, BYTE b2, BYTE b3, BYTE b4)
    {
        m_lIpAddress = (LONG)MAKEIPADDRESS(b1,b2,b3,b4);
        m_fInitOk = TRUE;
    }
    CIpAddress(const CIpAddress& ia)
    {
        m_lIpAddress = ia.m_lIpAddress;
        m_fInitOk = ia.m_fInitOk;
    }

    CIpAddress (const CString & str);

    //
    // Assignment operators
    //
    const CIpAddress & operator =(const LONG l);
    const CIpAddress & operator =(const CString & str);
    const CIpAddress & operator =(const CIpAddress& ia)
    {
        m_lIpAddress = ia.m_lIpAddress;
        m_fInitOk = ia.m_fInitOk;
        return *this;
    }

    //
    // Conversion operators
    //
    operator const LONG() const
    {
        return m_lIpAddress;
    }
    operator const CString&() const;

public:
    BOOL IsValid() const
    {
        return m_fInitOk;
    }

protected:
	BOOL IsValidIp(const CString & str);

private:
    LONG m_lIpAddress;
    BOOL m_fInitOk;
};

#endif _IPADDRES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\comprop\ipctl.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        ipctl.h

   Abstract:

        IP Address common control MFC wrapper definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

#ifndef _IPCTL_H
#define _IPCTL_H


#if (_WIN32_IE < 0x0400)
//
// Defined in comctrl.h.  Defined here because NT 5 MFC42.dll are
// defined with _WIN32_IE 0x300
//
#pragma message("Warning: privately defining _WIN32_IE definitions")
#define IPM_CLEARADDRESS (WM_USER+100)
#define IPM_SETADDRESS   (WM_USER+101)
#define IPM_GETADDRESS   (WM_USER+102)
#define IPM_SETRANGE     (WM_USER+103)
#define IPM_SETFOCUS     (WM_USER+104) 
#define IPM_ISBLANK      (WM_USER+105)
#define WC_IPADDRESSW    L"SysIPAddress32"
#define WC_IPADDRESSA    "SysIPAddress32"
#ifdef UNICODE
#define WC_IPADDRESS     WC_IPADDRESSW
#else
#define WC_IPADDRESS     WC_IPADDRESSA
#endif // UNICODE
#endif // _WIN32_IE



class COMDLL CIPAddressCtl : public CWnd
{
/*--

Class Description:

    MFC IP Address control wrapper.

Public Interface:

    CIPAddressCtl       : Constructor
    ~CIPAddressCtl      : Destructor

    Create              : Create the control
    ClearAddress        : Clear the address
    SetAddress          : Set address to value
    GetAddress          : Get address from the control
    SetRange            : Set field to octet range
    SetFocus            : Set focus on a specifc field
    IsBlank             : Return true if the control is blank

Notes:

    Either create control dynamically with Create method, or put in resource
    template as a user control of name "SysIPAddress32".  In this case,
    common style DWORDs as follows:

    WS_BORDER | WS_CHILD | WS_VISIBLE     0x50800000

--*/

    DECLARE_DYNAMIC(CIPAddressCtl)

//
// Constructor/Destructor
//
public:
    CIPAddressCtl();
    ~CIPAddressCtl();

//
// Interface
//
public:
    //
    // Create the control
    //
    BOOL Create(
        IN LPCTSTR lpszName,
        IN DWORD dwStyle, 
        IN const RECT & rect, 
        IN CWnd * pParentWnd, 
        IN UINT nID
        );

    //
    // Clear the address in the control
    //
    void ClearAddress();

    //
    // Set the ip address value
    //
    void SetAddress(
        IN DWORD dwIPAddress
        );

    //
    // Get the ip address value. 
    // Returns the number of non-blank values
    //
    int GetAddress(
        OUT LPDWORD lpdwIPAddress
        );

    //
    // Set the octet range of a field
    // 
    void SetRange(
        IN int iField, 
        IN BYTE bRange
        );

    //
    // Set focus on an octet field within the control
    //
    void SetFocus(
        IN int iField
        );

    //
    // Return TRUE if the control is blank
    //
    BOOL IsBlank();

protected:
    static BOOL m_fClassRegistered;

protected:
    static BOOL RegisterClass();
};


//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline BOOL CIPAddressCtl::Create(
    IN LPCTSTR lpszName,
    IN DWORD dwStyle, 
    IN const RECT & rect, 
    IN CWnd * pParentWnd, 
    IN UINT nID
    )
{
    //
    // Create the control
    //
    return CWnd::Create(
        WC_IPADDRESS, 
        lpszName, 
        dwStyle, 
        rect, 
        pParentWnd, 
        nID
        );
}

inline void CIPAddressCtl::ClearAddress()
{
    SNDMSG(m_hWnd, IPM_CLEARADDRESS, 0, 0L);
}

inline void CIPAddressCtl::SetAddress(
    IN DWORD dwIPAddress
    )
{
    SNDMSG(m_hWnd, IPM_SETADDRESS, 0, (LPARAM)dwIPAddress);
}

inline int CIPAddressCtl::GetAddress(
    OUT LPDWORD lpdwIPAddress
    )
{
    return (int)SNDMSG(m_hWnd, IPM_GETADDRESS, 0, (LPARAM)lpdwIPAddress);
}   

inline void CIPAddressCtl::SetRange(
    IN int iField, 
    IN BYTE bRange
    )
{
    SNDMSG(m_hWnd, IPM_SETRANGE, (WPARAM)iField, (LPARAM)bRange);
}

inline void CIPAddressCtl::SetFocus(
    IN int iField
    )
{
    SNDMSG(m_hWnd, IPM_SETFOCUS, (WPARAM)iField, 0L);
}

inline BOOL CIPAddressCtl::IsBlank()
{
    return (BOOL)SNDMSG(m_hWnd, IPM_ISBLANK, 0, 0L);
}

#endif // _IPCTL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\comprop\machine.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        machine.cpp

   Abstract:

        IIS Machine properties page

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include "comprop.h"
#include "mime.h"

#define DLL_BASED __declspec(dllimport)

#include "mmc.h"
#include "machine.h"

#include "inetprop.h"

#include "..\mmc\constr.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CIISMachinePage, CPropertyPage)



typedef struct tagMASTER_DLL
{
    LPCTSTR lpszDllName;
    UINT    nID;
} MASTER_DLL;



MASTER_DLL rgMasters[] =
{
    //
    // Note: path should not be neccesary for these
    // config DLLs, because they should really already
    // be loaded by inetmgr at this point.
    //
    { _T("W3SCFG.DLL"), IDS_WWW_MASTER },
    { _T("FSCFG.DLL"),  IDS_FTP_MASTER },
};


#define NUM_MASTER_DLL ARRAY_SIZE(rgMasters)


CMasterDll::CMasterDll(
    IN UINT nID, 
    IN LPCTSTR lpszDllName,
    IN LPCTSTR lpszMachineName
    )
/*++

Routine Description:

    Construct master dll object

Arguments:

    UINT nID                : Resource ID
    LPCTSTR lpszDllName     : Dll filename and path
    LPCTSTR lpszMachineName : Current machine name

Return Value:

    N/A

--*/
    : m_hDll(NULL),
      m_pfnConfig(NULL),
      m_strText()
{
    m_hDll = ::AfxLoadLibrary(lpszDllName);
    if (m_hDll != NULL)
    {
        //
        // Check to see if this service is installed
        //
        pfnQueryServerInfo pfnInfo = (pfnQueryServerInfo)
            ::GetProcAddress(m_hDll, SZ_SERVERINFO_PROC);

        if (pfnInfo != NULL)
        {
            ISMSERVERINFO ism;
            ism.dwSize = ISMSERVERINFO_SIZE;
            CError err((*pfnInfo)(lpszMachineName, &ism));
            if (err.Succeeded())
            {
                m_pfnConfig = (pfnConfigure)::GetProcAddress(
                    m_hDll, 
                    SZ_CONFIGURE_PROC
                    );

                if (m_pfnConfig != NULL)
                {
                    HINSTANCE hOld = AfxGetResourceHandle();
                    AfxSetResourceHandle(GetModuleHandle(COMPROP_DLL_NAME));
                    VERIFY(m_strText.LoadString(nID));
                    AfxSetResourceHandle(hOld);

                    //
                    // Success!
                    //
                    return;
                }
            }
        }
    }

    //
    // Library didn't exist, was bogus, or unable to provide information
    // about itself.
    //
    SAFE_AFXFREELIBRARY(m_hDll);
}


CMasterDll::~CMasterDll()
/*++

Routine Description:

    Destructor -- decrement library reference count

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    TRACEEOLID("Deleting: " << m_strText);
    SAFE_AFXFREELIBRARY(m_hDll);
}



/* static */
void
CIISMachinePage::ParseMaxNetworkUse(
    IN  OUT CILong & nMaxNetworkUse,
    OUT BOOL & fLimitNetworkUse
    )
/*++

Routine Description:

    Break out max network use function

Arguments:

    CILong & nMaxNetworkUse    : Maximum network value (will be changed)
    BOOL & fLimitMaxNetworkUse : TRUE if max network is not infinite

Return Value

    None/

--*/
{
    fLimitNetworkUse = (nMaxNetworkUse != INFINITE_BANDWIDTH); 
    nMaxNetworkUse = fLimitNetworkUse 
                ? (nMaxNetworkUse / KILOBYTE)
                : (DEF_BANDWIDTH / KILOBYTE);
}



CIISMachinePage::CIISMachinePage(
    IN LPCTSTR lpstrMachineName,
    IN HINSTANCE hInstance
    ) 
/*++

Routine Description:

    Constructor for IIS Machine property page

Arguments:

    LPCTSTR lpstrMachineName   : Machine name
    HINSTANCE hInstance        : Instance handle

Return Value:

    N/A

--*/
    : CPropertyPage(CIISMachinePage::IDD),
      m_strMachineName(lpstrMachineName),
      m_fLocal(IsServerLocal(lpstrMachineName)),
      m_ppropMimeTypes(NULL),
      m_ppropMachine(NULL),
      m_lstMasterDlls(),
      m_hr(S_OK)
{

#if 0 // Keep class wizard happy

    //{{AFX_DATA_INIT(CIISMachinePage)
    m_fLimitNetworkUse = FALSE;
    m_nMasterType = -1;
    //}}AFX_DATA_INIT

    m_nMaxNetworkUse = 0;

#endif

    m_nMasterType = 0;

    //
    // Data will be fetched later to prevent marshalling across
    // threads errors.  The dialog is constructed in one thread,
    // and operates in another.
    // 
}



CIISMachinePage::~CIISMachinePage()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
}

//
// COMPILER ISSUE::: Inlining this function doesn't
//                   work on x86 using NT 5!
//
HRESULT CIISMachinePage::QueryResult() const
{
    return m_hr;
}



void 
CIISMachinePage::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    //
    // Make sure data was fetched
    //
    ASSERT(m_ppropMachine != NULL);
    ASSERT(m_ppropMimeTypes != NULL);

    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CIISMachinePage)
    DDX_CBIndex(pDX, IDC_COMBO_MASTER_TYPE, m_nMasterType);
    DDX_Control(pDX, IDC_EDIT_MAX_NETWORK_USE, m_edit_MaxNetworkUse);
    DDX_Control(pDX, IDC_STATIC_THROTTLE_PROMPT, m_static_ThrottlePrompt);
    DDX_Control(pDX, IDC_STATIC_MAX_NETWORK_USE, m_static_MaxNetworkUse);
    DDX_Control(pDX, IDC_STATIC_KBS, m_static_KBS);
    DDX_Control(pDX, IDC_BUTTON_EDIT_DEFAULT, m_button_EditDefault);
    DDX_Control(pDX, IDC_CHECK_LIMIT_NETWORK_USE, m_check_LimitNetworkUse);
    DDX_Control(pDX, IDC_COMBO_MASTER_TYPE, m_combo_MasterType);
    DDX_Check(pDX, IDC_CHECK_LIMIT_NETWORK_USE, m_fLimitNetworkUse);
    //}}AFX_DATA_MAP
	if (m_edit_MaxNetworkUse.IsWindowEnabled())
	{
		DDX_Text(pDX, IDC_EDIT_MAX_NETWORK_USE, m_nMaxNetworkUse);
		DDV_MinMaxLong(pDX, m_nMaxNetworkUse, 1, UD_MAXVAL);
	}
}


//
// Message Map
//
BEGIN_MESSAGE_MAP(CIISMachinePage, CPropertyPage)
    //{{AFX_MSG_MAP(CIISMachinePage)
    ON_BN_CLICKED(IDC_CHECK_LIMIT_NETWORK_USE, OnCheckLimitNetworkUse)
    ON_BN_CLICKED(IDC_BUTTON_EDIT_DEFAULT, OnButtonEditDefault)
    ON_BN_CLICKED(IDC_BUTTON_FILE_TYPES, OnButtonFileTypes)
    ON_COMMAND(ID_HELP, OnHelp)
    ON_COMMAND(ID_CONTEXT_HELP, OnHelp)
    ON_WM_DESTROY()
    ON_WM_HELPINFO()
    //}}AFX_MSG_MAP

    ON_EN_CHANGE(IDC_EDIT_MAX_NETWORK_USE, OnItemChanged)

END_MESSAGE_MAP()



BOOL
CIISMachinePage::SetControlStates()
/*++

Routine Description:

    Set button states depending on contents of the controls.
    Return whether or not "Limit network use" is on.

Arguments:

    None

Return Value:

    TRUE if "Limit network use" is checked

--*/
{
    BOOL fLimitOn = m_check_LimitNetworkUse.GetCheck() > 0;

    m_static_MaxNetworkUse.EnableWindow(fLimitOn);
    m_static_ThrottlePrompt.EnableWindow(fLimitOn);
    m_edit_MaxNetworkUse.EnableWindow(fLimitOn);
    m_static_KBS.EnableWindow(fLimitOn);

    return fLimitOn;
}



HRESULT
CIISMachinePage::LoadDelayedValues()
/*++

Routine Description:

    Load the metabase parameters

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    //
    // Fetch the properties from the metabase
    //
    ASSERT(m_ppropMachine == NULL);
    ASSERT(m_ppropMimeTypes == NULL);

    //
    // Share interface between the objects here
    //
    m_ppropMachine   = new CMachineProps(m_strMachineName);
	if (NULL == m_ppropMachine)
		return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
	else if (FAILED(m_ppropMachine->QueryResult()))
		return m_ppropMachine->QueryResult();

    m_ppropMimeTypes = new CMimeTypes(m_ppropMachine);
	if (NULL == m_ppropMimeTypes)
		return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
	else if (FAILED(m_ppropMimeTypes->QueryResult()))
		return m_ppropMimeTypes->QueryResult();
    
    m_hr = m_ppropMachine->LoadData();
    if (SUCCEEDED(m_hr))
    {
        m_nMaxNetworkUse = m_ppropMachine->m_nMaxNetworkUse;
        ParseMaxNetworkUse(m_nMaxNetworkUse, m_fLimitNetworkUse);

        m_hr = m_ppropMimeTypes->LoadData();
        if (SUCCEEDED(m_hr))
        {
            m_strlMimeTypes = m_ppropMimeTypes->m_strlMimeTypes;
        }
    }

    return S_OK;
}



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



void 
CIISMachinePage::OnHelp()
/*++

Routine Description:

    'Help' button handler

Arguments:

    None

Return Value:

    None

--*/
{
    if (m_strHelpFile.IsEmpty())
    {
        CRMCRegKey rk(REG_KEY, SZ_PARAMETERS, KEY_READ);
        rk.QueryValue(SZ_HELPPATH, m_strHelpFile, EXPANSION_ON);
        m_strHelpFile += _T("\\inetmgr.hlp");
        TRACEEOLID("Initialized help file " << m_strHelpFile);
    }

    CWnd * pWnd = ::AfxGetMainWnd();
    HWND hWndParent = pWnd != NULL
        ? pWnd->m_hWnd
        : NULL;

    ::WinHelp(m_hWnd, m_strHelpFile, HELP_CONTEXT, HIDD_IIS_MACHINE);
}

BOOL
CIISMachinePage::OnHelpInfo(HELPINFO * pHelpInfo)
{
   OnHelp();
   return FALSE;
}

void
CIISMachinePage::OnCheckLimitNetworkUse()
/*++

Routine Description:

    The "limit network use" checkbox has been clicked
    Enable/disable the "max network use" controls.

Arguments:

    None

Return Value:

    None

--*/
{
    if (SetControlStates())
    {
        m_edit_MaxNetworkUse.SetSel(0,-1);
        m_edit_MaxNetworkUse.SetFocus();
    }

    OnItemChanged();
}



void
CIISMachinePage::OnItemChanged()
/*++

Routine Description:

    All EN_CHANGE messages map to this function

Arguments:

    None

Return Value:

    None

--*/
{
    SetModified(TRUE);
}



void 
CIISMachinePage::OnButtonEditDefault() 
/*++

Routine Description:

    'edit default' button handler

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Get selection, and convert to index into server table
    // via associative array.
    //
    CError err;

    int nSel = m_combo_MasterType.GetCurSel();
    ASSERT(nSel >= 0 && nSel < NUM_MASTER_DLL);

    POSITION pos = m_lstMasterDlls.FindIndex(nSel);
    ASSERT(pos != NULL);

    CMasterDll * pDll = m_lstMasterDlls.GetAt(pos);

    ASSERT(pDll != NULL);

    //
    // Allocate string with 2 terminating NULLS
    //
    int nLen = m_strMachineName.GetLength();
    LPTSTR lpServers = AllocTString(nLen + 2);
    if (lpServers == NULL)
    {
        err = ERROR_NOT_ENOUGH_MEMORY;
    }
    else
    {
        ::lstrcpy(lpServers, m_strMachineName);
        lpServers[nLen + 1] = _T('\0');

        err = pDll->Config(m_hWnd, lpServers);
    }

    SAFE_FREEMEM(lpServers);
    err.MessageBoxOnFailure();
}



void 
CIISMachinePage::OnButtonFileTypes() 
/*++

Routine Description:

    'file types' button handler - bring up mime types dialog.

Arguments:

    None

Return Value:

    None

--*/
{
    HINSTANCE hOld = AfxGetResourceHandle();
    AfxSetResourceHandle(GetModuleHandle(COMPROP_DLL_NAME));

    CMimeDlg dlg(m_strlMimeTypes, this);
    if (dlg.DoModal() == IDOK)
    {
        OnItemChanged();
    }

    AfxSetResourceHandle(hOld);
}



BOOL 
CIISMachinePage::OnInitDialog() 
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CServerCapabilities  caps(m_strMachineName, SZ_MBN_WEB);
    BOOL fHasThrottling = caps.HasBwThrottling();

    CError err(LoadDelayedValues());

    if (err.Failed())
    {
        fHasThrottling = FALSE;
    }

    CPropertyPage::OnInitDialog();

    //
    // Fill the master combo box
    //
    int cServices = 0;
    CMasterDll * pDll;
    for (int n = 0; n < NUM_MASTER_DLL; ++n)
    {
        pDll = new CMasterDll(
            rgMasters[n].nID, 
            rgMasters[n].lpszDllName,
            m_strMachineName
            );

        if (pDll == NULL)
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        if (pDll->IsLoaded())
        {
            m_combo_MasterType.AddString(*pDll);
            m_lstMasterDlls.AddTail(pDll);
            ++cServices;
        }
        else
        {
            //
            // Dll didn't load, toss it.
            //
            delete pDll;
        }
    }

    if (cServices == 0)
    {
        //
        // No master-programmable services installed, so disallow
        // master editing.
        //
        GetDlgItem(IDC_BUTTON_EDIT_DEFAULT)->EnableWindow(FALSE);
        GetDlgItem(IDC_GROUP_MASTER)->EnableWindow(FALSE);
        GetDlgItem(IDC_STATIC_MASTER_PROMPT1)->EnableWindow(FALSE);
        GetDlgItem(IDC_STATIC_MASTER_PROMPT2)->EnableWindow(FALSE);
        m_combo_MasterType.EnableWindow(FALSE);
    }

    m_check_LimitNetworkUse.EnableWindow(fHasThrottling);

    m_combo_MasterType.SetCurSel(0);
        
    SetControlStates();

    err.MessageBoxOnFailure();
    
    return TRUE;  
}



BOOL 
CIISMachinePage::OnApply() 
/*++

Routine Description:

    'Apply' button handler. Called when OK or APPLY is pressed.

Arguments:

    None.

Return Value:

    TRUE to continue, FALSE otherwise

--*/
{
    //
    // Don't use m_nMaxNetworkUse, because it would
    // alter the values on the screen when DDX happens next.
    //
    CILong nMaxNetworkUse = m_nMaxNetworkUse;
    BuildMaxNetworkUse(nMaxNetworkUse, m_fLimitNetworkUse);

    m_ppropMachine->m_nMaxNetworkUse = nMaxNetworkUse;
    CError err(m_ppropMachine->WriteDirtyProps());

    if (err.Succeeded())
    {
        m_ppropMimeTypes->m_strlMimeTypes = m_strlMimeTypes;
        err = m_ppropMimeTypes->WriteDirtyProps();
    }

    if (err.Succeeded())
    {
        return CPropertyPage::OnApply();
    }

    //
    // Failed
    //
    err.MessageBox();

    return FALSE;
}



void 
CIISMachinePage::OnDestroy() 
/*++

Routine Description:

    Window is being destroyed.  Time to clean up

Arguments:

    None.

Return Value:

    None.

--*/
{
    ASSERT(m_ppropMachine != NULL);
    ASSERT(m_ppropMimeTypes != NULL);

    SAFE_DELETE(m_ppropMachine);
    SAFE_DELETE(m_ppropMimeTypes);

    while (!m_lstMasterDlls.IsEmpty())
    {
        CMasterDll * pDll = m_lstMasterDlls.RemoveHead();
        delete pDll;
    }

    //
    // Remove the help window if it's currently open
    //
    ::WinHelp(m_hWnd, NULL, HELP_QUIT, 0L);

    CPropertyPage::OnDestroy();
}



void 
CIISMachinePage::PostNcDestroy() 
/*++

Routine Description:

    handle destruction of the window by freeing the this
    pointer (as this modeless dialog must have been created
    on the heap)

Arguments:

    None.

Return Value:

    None

--*/
{
    delete this;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\comprop\mdkeys.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module Name :

        mdkeys.h

   Abstract:

        Metabase key wrapper classes

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

#ifndef _MDKEYS_H_
#define _MDKEYS_H_



//
// Include Files
//
#include <iadmw.h>
#include <iwamreg.h>
#include <iiscnfgp.h>
#include <winsvc.h>
#include <iisrsta.h>


//
// Forward definitions
//
class CBlob;



//
// Use this instance number to denote the master
//
#define MASTER_INSTANCE     (0)
#define IS_MASTER_INSTANCE(i) (i == MASTER_INSTANCE ? TRUE : FALSE)



//
// Metabase node constants, used for static initialization of const
// strings further down.  Defined here with #defines for easier 
// concatenation later.
//
#define SZ_MBN_MACHINE      _T("LM")
#define SZ_MBN_FILTERS      _T("Filters")
#define SZ_MBN_MIMEMAP      _T("MimeMap")
#define SZ_MBN_TEMPLATES    _T("Templates")
#define SZ_MBN_INFO         _T("Info")
#define SZ_MBN_ROOT         _T("Root")
#define SZ_MBN_COMPRESSION  _T("Compression")
#define SZ_MBN_PARAMETERS   _T("Parameters")
#define SZ_MBN_SEP_CHAR     _T('/')
#define SZ_MBN_SEP_STR      _T("/")
#define SZ_MBN_WEB          _T("W3SVC")
#define SZ_MBN_FTP          _T("MSFTPSVC")



class COMDLL CMetaInterface
/*++

Class description:

    Metabase interface class

Virtual Interface:

    Succeeded           : Return TRUE if item constructed successfully
    QueryResult         : Return construction error code

Public Interface:

    operator BOOL       : Cast to TRUE/FALSE depending on success
    operator HRESULT    : Cast to the HRESULT status

    QueryServerName     : Get the server name
    Regenerate          : Recreate the interface

--*/
{
//
// Constructor/Destructor
//
protected:
    //
    // Fully defined constructor that creates the interface.
    // Use NULL to indicate the local computer name
    //
    CMetaInterface(
        IN LPCTSTR lpszServerName = NULL
        );

    //
    // Construct from existing interface
    //
    CMetaInterface(
        IN const CMetaInterface * pInterface
        );

    //
    // Destructor destroys the interface
    //
    ~CMetaInterface();

//
// Virtual Interface:
//
public:
    virtual BOOL Succeeded() const;
    virtual HRESULT QueryResult() const;

//
// ISSUE: Does this break encapsulation?
//
public:
    LPCTSTR QueryServerName() const { return m_strServerName; }
    HRESULT Regenerate();

//
// Conversion Operators
//
public:
    operator BOOL() const { return Succeeded(); }
    operator HRESULT() const { return m_hrInterface; }

protected:
    //
    // Create a metadata object in this server. This function initializes the
    // metadata object with DCOM.
    //
    HRESULT Create(
        IN LPCTSTR lpszServerName = NULL
        );

    //
    // Make sure the interface has been created
    //
    BOOL HasInterface() const { return m_pInterface != NULL; }

//
// IADMW Interface
//
protected:
    HRESULT OpenKey(
        IN  METADATA_HANDLE hkBase,
        IN  LPCTSTR lpszMDPath,
        IN  DWORD dwFlags,
        OUT METADATA_HANDLE * phMDNewHandle
        );

    HRESULT CloseKey(
        IN METADATA_HANDLE hKey
        );

    HRESULT SetLastChangeTime( 
        IN METADATA_HANDLE hMDHandle,
        IN LPCTSTR pszMDPath,
        IN FILETIME * pftMDLastChangeTime,
        IN BOOL bLocalTime
        );
        
    HRESULT GetLastChangeTime( 
        IN  METADATA_HANDLE hMDHandle,
        IN  LPCTSTR lpszMDPath,
        OUT FILETIME * pftMDLastChangeTime,
        IN  BOOL bLocalTime
        );

    HRESULT AddKey( 
        IN METADATA_HANDLE hKey,
        IN LPCTSTR lpszMDPath
        );

    HRESULT DeleteKey(
        IN METADATA_HANDLE hKey,
        IN LPCTSTR lpszMDPath
        );

    HRESULT DeleteChildKeys(
        IN METADATA_HANDLE hKey,
        IN LPCTSTR lpszMDPath
        );

    HRESULT EnumKeys(
        IN  METADATA_HANDLE hKey,
        IN  LPCTSTR lpszMDPath,
        OUT LPTSTR lpszMDName,
        IN  DWORD dwIndex
        );

    HRESULT CopyKey(
        IN METADATA_HANDLE hSourceKey,
        IN LPCTSTR lpszMDSourcePath,
        IN METADATA_HANDLE hDestKey,
        IN LPCTSTR lpszMDDestPath,
        IN BOOL fOverwrite,
        IN BOOL fCopy
        );

    HRESULT RenameKey(
        IN METADATA_HANDLE hKey,
        IN LPCTSTR lpszMDPath,
        IN LPCTSTR lpszNewName
        );

    HRESULT GetData(
        IN  METADATA_HANDLE hKey,
        IN  LPCTSTR lpszMDPath,
        OUT METADATA_RECORD * pmdRecord,
        OUT DWORD * pdwRequiredDataLen
        );

    HRESULT SetData(
        IN METADATA_HANDLE hKey,
        IN LPCTSTR lpszMDPath,
        IN METADATA_RECORD * pmdRecord
        );

    HRESULT DeleteData(
        IN METADATA_HANDLE hKey,
        IN LPCTSTR lpszMDPath,
        IN DWORD dwMDIdentifier,
        IN DWORD dwMDDataType
        );

    HRESULT EnumData(
        IN  METADATA_HANDLE hKey,
        IN  LPCTSTR lpszMDPath,
        OUT METADATA_RECORD * pmdRecord,
        IN  DWORD dwIndex,
        OUT DWORD * pdwRequiredDataLen
        );

    HRESULT GetAllData(
        IN  METADATA_HANDLE hKey,
        IN  LPCTSTR lpszMDPath,
        IN  DWORD dwMDAttributes,
        IN  DWORD dwMDUserType,
        IN  DWORD dwMDDataType,
        OUT DWORD * pdwMDNumDataEntries,
        OUT DWORD * pdwMDDataSetNumber,
        IN  DWORD dwMDBufferSize,
        OUT LPBYTE pbMDBuffer,
        OUT DWORD * pdwRequiredBufferSize
        );

    HRESULT DeleteAllData( 
        IN METADATA_HANDLE hKey,
        IN LPCTSTR lpszMDPath,
        IN DWORD dwMDUserType,
        IN DWORD dwMDDataType
        );

    HRESULT CopyData( 
        IN METADATA_HANDLE hMDSourceKey,
        IN LPCTSTR lpszMDSourcePath,
        IN METADATA_HANDLE hMDDestKey,
        IN LPCTSTR lpszMDDestPath,
        IN DWORD dwMDAttributes,
        IN DWORD dwMDUserType,
        IN DWORD dwMDDataType,
        IN BOOL fCopy
        );

    HRESULT GetDataPaths( 
        IN  METADATA_HANDLE hKey,
        IN  LPCTSTR lpszMDPath,
        IN  DWORD dwMDIdentifier,
        IN  DWORD dwMDDataType,
        IN  DWORD dwMDBufferSize,
        OUT LPTSTR lpszBuffer,
        OUT DWORD * pdwMDRequiredBufferSize
        );

    HRESULT Backup( 
        IN LPCTSTR lpszBackupLocation,
        IN DWORD dwMDVersion,
        IN DWORD dwMDFlags
        );

    HRESULT BackupWithPassword(
        IN LPCTSTR lpszBackupLocation,
        IN DWORD dwMDVersion,
        IN DWORD dwMDFlags,
		IN LPCTSTR lpszPassword
		);

    HRESULT Restore(    
        IN LPCTSTR lpszBackupLocation,
        IN DWORD dwMDVersion,
        IN DWORD dwMDFlags
        );

    HRESULT RestoreWithPassword(
        IN LPCTSTR lpszBackupLocation,
        IN DWORD dwMDVersion,
        IN DWORD dwMDFlags,
		IN LPCTSTR lpszPassword
		);

    HRESULT EnumBackups(
        OUT LPTSTR lpszBackupLocation,
        OUT DWORD * pdwMDVersion,
        OUT FILETIME * pftMDBackupTime,
        IN  DWORD dwIndex
        );

    HRESULT DeleteBackup(
        IN LPCTSTR lpszBackupLocation,
        IN DWORD dwMDVersion
        );

protected:
    CString      m_strServerName;
    IMSAdminBase * m_pInterface; 

private:
    int     m_iTimeOutValue;         
    HRESULT m_hrInterface;
};



class COMDLL CWamInterface
/*++

Class description:

    WAM interface class

Virtual Interface:

    Succeeded           : Return TRUE if item constructed successfully
    QueryResult         : Return construction error code

Public Interface:

    operator BOOL       : Cast to TRUE/FALSE depending on success
    operator HRESULT    : Cast to the HRESULT status

    SupportsPooledProc  : Check to see if pooled out of proc is supported.

--*/
{
//
// App Protection States:
//
public:
    enum
    {
        //
        // Note: order must match MD_APP_ISOLATED values
        //
        APP_INPROC,
        APP_OUTOFPROC,
        APP_POOLEDPROC,
    };

//
// Constructor/Destructor
//
protected:
    //
    // Fully defined constructor that creates the interface.
    // Use NULL to create the interface on the local computer
    //
    CWamInterface(
        IN LPCTSTR lpszServerName = NULL
        );

    //
    // Construct from existing interface.  
    //
    CWamInterface(
        IN const CWamInterface * pInterface
        );

    //
    // Destructor destroys the interface
    //
    ~CWamInterface();

//
// Virtual Interface:
//
public:
    virtual BOOL Succeeded() const;
    virtual HRESULT QueryResult() const;

//
// Conversion Operators
//
public:
    operator BOOL() const    { return Succeeded(); }
    operator HRESULT() const { return m_hrInterface; }

//
// Access
//
public:
    BOOL SupportsPooledProc() const { return m_fSupportsPooledProc; }

protected:
    //
    // Create a wam object in this server. This function initializes the
    // object with DCOM.
    //
    HRESULT Create(
        IN LPCTSTR lpszServerName = NULL
        );

    //
    // Make sure the interface has been created
    //
    BOOL HasInterface() const { return m_pInterface != NULL; }

//
// IWAM Interface
//
protected:
    HRESULT AppCreate( 
        IN LPCTSTR szMDPath,
        IN DWORD dwAppProtection
        );
    
    HRESULT AppDelete( 
        IN LPCTSTR szMDPath,
        IN BOOL fRecursive
        );
    
    HRESULT AppUnLoad( 
        IN LPCTSTR szMDPath,
        IN BOOL fRecursive
        );
    
    HRESULT AppGetStatus( 
        IN  LPCTSTR szMDPath,
        OUT DWORD * pdwAppStatus
        );
    
    HRESULT AppDeleteRecoverable( 
        IN LPCTSTR szMDPath,
        IN BOOL fRecursive
        );
    
    HRESULT AppRecover( 
        IN LPCTSTR szMDPath,
        IN BOOL fRecursive
        );

protected:
    CString m_strServerName;
    IWamAdmin * m_pInterface; 

private:
    HRESULT m_hrInterface;
    BOOL    m_fSupportsPooledProc;
};



class COMDLL CMetaBack : public CMetaInterface, public CWamInterface
/*++

Class Description:

    Metabase backup/restore class

Virtual Interface:

    Succeeded           : Return TRUE if item constructed successfully
    QueryResult         : Return construction error code

Public Interface:

    Reset               : Enum first existing backup
    Next                : Enum next existing backup
    Backup              : Create new backup
    Delete              : Delete existing backup
    Restore             : Restore from existing backup

--*/
{
public:
    //
    // Construct and create the interfaces.  Use NULL to create
    // on the local computer.
    //
    CMetaBack(
        IN LPCTSTR lpszServerName = NULL
        );

//
// Virtual Interface
//
public:
    virtual BOOL Succeeded() const;
    virtual HRESULT QueryResult() const;

//
// Interface
//
public:
    //
    // Reset counter
    //
    void Reset() { m_dwIndex = 0L; }

    HRESULT Next(
        OUT DWORD * pdwVersion,
        OUT LPTSTR lpszLocation,
        OUT FILETIME * pftBackupTime
        );

    HRESULT Backup(
        IN LPCTSTR lpszLocation
        );

    HRESULT BackupWithPassword(
        IN LPCTSTR lpszLocation,
		IN LPCTSTR lpszPassword
		);

    HRESULT Delete(
        IN LPCTSTR lpszLocation,
        IN DWORD dwVersion
        );

    HRESULT Restore(
        IN LPCTSTR lpszLocation,
        IN DWORD dwVersion
        );

    HRESULT RestoreWithPassword(
        IN LPCTSTR lpszLocation,
        IN DWORD dwVersion,
		IN LPCTSTR lpszPassword
        );

protected:
    static const LPCTSTR s_szMasterAppRoot;

private:
    DWORD   m_dwIndex;
};



class COMDLL CMetaKey : public CMetaInterface
/*++

Class Description:

    Metabase key wrapper class

Public Interface:

    CMetaKey                    : Constructor
    ~CMetaKey                   : Destructor

    Succeeded                   : TRUE if key opened successfully.
    QueryResult                 : Get the HRESULT status

    QueryValue                  : Various overloaded methods to get values
    SetValue                    : Various overloaded methods to set values
    DeleteValue                 : Delete a value
    Open                        : Open key
    ReOpen                      : Re key that was opened before
    Close                       : Close key
    ConvertToParentPath         : Change path to parent path

    operator METADATA_HANDLE    : Cast to a metadata handle
    operator LPCTSTR            : Cast to the metabase path
    operator BOOL               : Cast to TRUE if the key is open, FALSE if not

    GetHandle                   : Obtain metadata handle
    IsOpen                      : TRUE if a key is open
    QueryMetaPath               : Get the relative metabase path
    QueryFlags                  : Get the open permissions

--*/
{
//
// Constructor/Destructor
//
public:
    //
    // Null constructor that only creates the interface.
    // A key constructed this way may read from META_ROOT_HANDLE.
    // This is not true of other constructors.
    //
    CMetaKey(
        IN LPCTSTR lpszServerName = NULL
        );

    //
    // As above, using an existing interface
    //
    CMetaKey(
        IN const CMetaInterface * pInterface
        );

    //
    // Fully defined constructor that opens a key
    //
    CMetaKey(
        IN LPCTSTR lpszServerName,
        IN DWORD   dwFlags,
        IN METADATA_HANDLE hkBase = METADATA_MASTER_ROOT_HANDLE,
        IN LPCTSTR lpszMDPath     = NULL
        );

    //
    // As above, using an existing interface
    //
    CMetaKey(
        IN const CMetaInterface * pInterface,
        IN DWORD   dwFlags,
        IN METADATA_HANDLE hkBase = METADATA_MASTER_ROOT_HANDLE,
        IN LPCTSTR lpszMDPath     = NULL
        );

    //
    // Constructor that takes portions of a metabase path.
    // and opens a key
    //
    CMetaKey(
        IN LPCTSTR lpszServerName,
        IN DWORD   dwFlags,
        IN LPCTSTR lpSvc,       // Or NULL or _T("")
        IN DWORD   dwInstance   = MASTER_INSTANCE,        
        IN LPCTSTR lpParentPath = NULL,        
        IN LPCTSTR lpAlias      = NULL
        );

    //
    // As above, using an existing interface
    //
    CMetaKey(
        IN const CMetaInterface * pInterface,
        IN DWORD   dwFlags,
        IN LPCTSTR lpSvc,       // Or NULL or _T("")
        IN DWORD   dwInstance   = MASTER_INSTANCE,        
        IN LPCTSTR lpParentPath = NULL,        
        IN LPCTSTR lpAlias      = NULL
        );

    //
    // Copy constructor, might or might not own the key
    //
    CMetaKey(
        IN BOOL  fOwnKey,
        IN const CMetaKey * pKey
        );

    //
    // Destructor -- closes key.
    //
    ~CMetaKey();

//
// Interface
//
public:
    //
    // Fetch a DWORD
    //
    HRESULT QueryValue(
        IN  DWORD dwID, 
        OUT DWORD & dwValue,
        IN  BOOL * pfInheritanceOverride = NULL,
        IN  LPCTSTR lpszMDPath           = NULL,
        OUT DWORD * pdwAttributes        = NULL
        );

    //
    // Fetch a boolean
    //
    HRESULT QueryValue(
        IN  DWORD dwID, 
        OUT BOOL & fValue,
        IN  BOOL * pfInheritanceOverride = NULL,
        IN  LPCTSTR lpszMDPath           = NULL,
        OUT DWORD * pdwAttributes        = NULL
        );

    //
    // Fetch a string
    //
    HRESULT QueryValue(
        IN  DWORD dwID, 
        OUT CString & strValue, 
        IN  BOOL * pfInheritanceOverride = NULL,
        IN  LPCTSTR lpszMDPath           = NULL,
        OUT DWORD * pdwAttributes        = NULL
        );

    //
    // Fetch a string list
    //
    HRESULT QueryValue(
        IN  DWORD dwID, 
        OUT CStringListEx & strlValue, 
        IN  BOOL * pfInheritanceOverride = NULL,
        IN  LPCTSTR lpszMDPath           = NULL,
        OUT DWORD * pdwAttributes        = NULL
        );

    //
    // Fetch binary blob
    //
    HRESULT QueryValue(
        IN  DWORD dwID, 
        OUT CBlob & blValue, 
        IN  BOOL * pfInheritanceOverride = NULL,
        IN  LPCTSTR lpszMDPath           = NULL,
        OUT DWORD * pdwAttributes        = NULL
        );

    //
    // Store a DWORD
    //
    HRESULT SetValue(
        IN DWORD dwID,
        IN DWORD dwValue,
        IN BOOL * pfInheritanceOverride = NULL,
        IN LPCTSTR lpszMDPath           = NULL
        );

    //
    // Store a BOOL
    //
    HRESULT SetValue(
        IN DWORD dwID,
        IN BOOL fValue,
        IN BOOL * pfInheritanceOverride = NULL,
        IN LPCTSTR lpszMDPath           = NULL
        );

    //
    // Store a string
    //
    HRESULT SetValue(
        IN DWORD dwID,
        IN CString & strValue,
        IN BOOL * pfInheritanceOverride = NULL,
        IN LPCTSTR lpszMDPath           = NULL
        );

    //
    // Store a stringlist
    //
    HRESULT SetValue(
        IN DWORD dwID,
        IN CStringListEx & strlValue,
        IN BOOL * pfInheritanceOverride  = NULL,
        IN LPCTSTR lpszMDPath            = NULL
        );

    //
    // Store a binary blob
    //
    HRESULT SetValue(
        IN DWORD dwID,
        IN CBlob & blValue,
        IN BOOL * pfInheritanceOverride  = NULL,
        IN LPCTSTR lpszMDPath            = NULL
        );

    //
    // Delete Value:
    //
    HRESULT DeleteValue(
        IN DWORD   dwID,
        IN LPCTSTR lpszMDPath = NULL
        );

    //
    // Check for path existance
    //
    HRESULT DoesPathExist(
        IN LPCTSTR lpszMDPath
        );

    //
    // Create current path (which we attempted to open, and got
    // a path not found error on).
    //
    HRESULT CreatePathFromFailedOpen();

    //
    // Check for descendant overrides
    //
    HRESULT CheckDescendants(
        IN DWORD   dwID,
        IN LPCTSTR lpszServer,
        IN LPCTSTR lpszMDPath = NULL
        );

    //
    // Open key
    //
    HRESULT Open(
        IN DWORD   dwFlags,
        IN METADATA_HANDLE hkBase, 
        IN LPCTSTR lpszMDPath   = NULL
        );

    //
    // Assemble metabase path and open key
    //
    HRESULT Open(
        IN DWORD   dwFlags,
        IN LPCTSTR lpSvc        = NULL,    
        IN DWORD   dwInstance   = MASTER_INSTANCE,        
        IN LPCTSTR lpParentPath = NULL,        
        IN LPCTSTR lpAlias      = NULL
        );

    //
    // Re-open previously opened key
    //
    HRESULT ReOpen(
        IN DWORD   dwFlags
        );

    //
    // As above using the same permissions as before
    //
    HRESULT ReOpen();

    //
    // Open the parent object
    // 
    HRESULT ConvertToParentPath(
        IN  BOOL fImmediate
        );

    //
    // Close key, set it to NULL, but doesn't destroy the interface
    //
    HRESULT Close();

    //
    // Add key
    //
    HRESULT AddKey(
        IN LPCTSTR lpszMDPath
        );

    //
    // Delete key off currently open key
    //
    HRESULT DeleteKey(
        IN LPCTSTR lpszMDPath
        );

    //
    // Rename key off currently open key
    //
    HRESULT RenameKey(
        IN LPCTSTR lpszMDPath,
        IN LPCTSTR lpszNewName
        );

    //
    // Get list of descendant nodes that override
    // a specific value
    //
    HRESULT GetDataPaths( 
        OUT CStringListEx & strlNodes,
        IN  DWORD dwMDIdentifier,
        IN  DWORD dwMDDataType,
        IN  LPCTSTR lpszMDPath = NULL
        );

    //
    // Clean metabase path
    //
    static LPCTSTR CleanMetaPath(
        IN OUT CString & strMetaRoot
        );

    static void ConvertToParentPath(
        IN OUT CString & strService,
        IN OUT DWORD & dwInstance,
        IN OUT CString & strParent,
        IN OUT CString & strAlias
        );

    static LPCTSTR ConvertToParentPath(
        OUT IN CString & strMetaPath
        );

    static BOOL IsHomeDirectoryPath(
        IN LPCTSTR lpszMetaPath
        );

//
// Access
//
public:
    METADATA_HANDLE GetHandle() const { return m_hKey; }
    METADATA_HANDLE GetBase() const   { return m_hBase; }
    LPCTSTR QueryMetaPath() const     { return m_strMetaPath; }
    DWORD QueryFlags() const          { return m_dwFlags; }
    BOOL IsOpen() const               { return m_hKey != NULL; }
    BOOL IsHomeDirectoryPath();

//
// Conversion operators
//
public:
    operator METADATA_HANDLE() const  { return GetHandle(); }
    operator LPCTSTR() const          { return QueryMetaPath(); }
    operator BOOL() const             { return IsOpen(); }

//
// Virtual Interface:
//
public:
    virtual BOOL Succeeded() const;
    virtual HRESULT QueryResult() const;

protected:
    //
    // Split metapath into parent and single node
    //
    static void SplitMetaPath(
        IN  LPCTSTR lpPath,
        OUT CString & strParent,
        OUT CString & strAlias
        );

    //
    // Split the metapath at the instance border
    //
    static void SplitMetaPathAtInstance(
        IN  LPCTSTR lpPath,
        OUT CString & strParent,
        OUT CString & strAlias
        );

    static LPCTSTR BuildMetaPath(
        OUT CString & strPath,
        IN  LPCTSTR lpSvc        = NULL,    
        IN  DWORD   dwInstance   = NULL,        
        IN  LPCTSTR lpParentPath = NULL,        
        IN  LPCTSTR lpAlias      = NULL    
        );

//
// Protected members
//
protected:
    //
    // Get data
    //
    HRESULT GetPropertyValue(
        IN  DWORD dwID,
        OUT IN DWORD & dwSize,
        OUT IN void *& pvData,
        OUT IN DWORD * pdwDataType           = NULL,
        IN  BOOL * pfInheritanceOverride     = NULL,
        IN  LPCTSTR lpszMDPath               = NULL,
        OUT DWORD * pdwAttributes            = NULL
        );

    //
    // Store data
    //
    HRESULT SetPropertyValue(
        IN DWORD dwID,
        IN DWORD dwSize,
        IN void * pvData,
        IN BOOL * pfInheritanceOverride = NULL,
        IN LPCTSTR lpszMDPath           = NULL
        );

    //
    // Get All Data off the open key
    //
    HRESULT GetAllData(
        IN  DWORD dwMDAttributes,
        IN  DWORD dwMDUserType,
        IN  DWORD dwMDDataType,
        OUT DWORD * pdwMDNumEntries,
        OUT DWORD * pdwMDDataLen,
        OUT PBYTE * ppbMDData,
        IN  LPCTSTR lpszMDPath  = NULL
        );

//
// Property Table Methods
//
protected:
    //
    // Metabase table entry definition
    //
    typedef struct tagMDFIELDDEF
    {
        DWORD dwMDIdentifier;
        DWORD dwMDAttributes;
        DWORD dwMDUserType;
        DWORD dwMDDataType;
        UINT  uStringID;
    } MDFIELDDEF;

    static const MDFIELDDEF s_rgMetaTable[];

//
// CODEWORK: Ideally, these should be protected, but are used
//           by idlg.
//
public:
    static BOOL GetMDFieldDef(
        IN  DWORD dwID,
        OUT DWORD & dwMDIdentifier,
        OUT DWORD & dwMDAttributes,
        OUT DWORD & dwMDUserType,
        OUT DWORD & dwMDDataType
        );

    //
    // Map metabase ID value to table index
    //
    static int MapMDIDToTableIndex(
        IN DWORD dwID
        );

//
// Allow limited access to the table
//
public:
    static BOOL IsPropertyInheritable(
        IN DWORD dwID
        );

    static BOOL GetPropertyDescription(
        IN  DWORD dwID, 
        OUT CString & strName
        );

protected:
    static const LPCTSTR s_cszCompression;
    static const LPCTSTR s_cszMachine;     
    static const LPCTSTR s_cszMimeMap;     
    static const LPCTSTR s_cszRoot;        
    static const LPCTSTR s_cszSep;         
    static const LPCTSTR s_cszInfo;        
    static const TCHAR   s_chSep;          

protected:
    BOOL    m_fAllowRootOperations;
    BOOL    m_fOwnKey;
    DWORD   m_cbInitialBufferSize;    
    DWORD   m_dwFlags;
    CString m_strMetaPath;
    HRESULT m_hrKey;
    METADATA_HANDLE m_hKey;
    METADATA_HANDLE m_hBase;
};



class COMDLL CMetaEnumerator : public CMetaKey
/*++

Class Description:

    Metabase key enumerator

Public Interface:

    CMetaEnumerator     : Constructor
    
    Reset               : Reset the enumerator
    Next                : Get next key

--*/
{
public:
    CMetaEnumerator(
        IN LPCTSTR lpszServerName,
        IN LPCTSTR lpSvc        = NULL,    
        IN DWORD   dwInstance   = MASTER_INSTANCE,        
        IN LPCTSTR lpParentPath = NULL,        
        IN LPCTSTR lpAlias      = NULL
        );

    //
    // Constructor with existing interface
    //
    CMetaEnumerator(
        IN CMetaInterface * pInterface,
        IN LPCTSTR lpSvc        = NULL,    
        IN DWORD   dwInstance   = MASTER_INSTANCE,        
        IN LPCTSTR lpParentPath = NULL,        
        IN LPCTSTR lpAlias      = NULL
        );

//
// Interface:
//
public:
    //
    // Reset counter
    //
    void Reset() { m_dwIndex = 0L; }

    //
    // Get next key as string.
    //
    HRESULT Next(
        OUT CString & strKey,
        IN  LPCTSTR lpszMDPath = NULL
        );

    //
    // Get next key as a DWORD (numeric keys only)
    //
    HRESULT Next(
        OUT DWORD & dwKey,
        IN  LPCTSTR lpszMDPath = NULL
        );

private:
    DWORD m_dwIndex;
};



class COMDLL CIISApplication : public CWamInterface, public CMetaKey
/*++

Class Description:

    IIS Application class

Virtual Interface:

    Succeeded           : Return TRUE if item constructed successfully
    QueryResult         : Return construction error code

Public Interface:

    RefreshState        : Refresh application state
    QueryAppState       : Return current application state
    IsEnabledApplication: Return TRUE if appplication is enabled. 
    Create              : Create app
    Delete              : Delete app
    Unload              : Unload app
    DeleteRecoverable   : Delete w. recovery allowed
    Recover             : Recover
    WriteFriendlyName   : Write friendly name to metabase

--*/
{
//
// Constructor/Destructor
//
public:
    CIISApplication(
        IN LPCTSTR lpszServer,
        IN LPCTSTR lpszMetapath
        );

    CIISApplication(
        IN LPCTSTR lpszServer,
        IN LPCTSTR lpSvc,    
        IN DWORD   dwInstance,        
        IN LPCTSTR lpParentPath = NULL,        
        IN LPCTSTR lpAlias      = NULL
        );

//
// Virtual Interface:
//
public:
    virtual BOOL Succeeded() const;
    virtual HRESULT QueryResult() const;

//
// Interface
//
public:
    DWORD   QueryAppState() const { return m_dwAppState; }
    LPCTSTR QueryWamPath() const { return m_strWamPath; }
    BOOL    IsEnabledApplication() const;
    HRESULT RefreshAppState();
    HRESULT Create(LPCTSTR lpszName, DWORD dwAppProtection);
    HRESULT Delete(BOOL fRecursive = FALSE);
    HRESULT Unload(BOOL fRecursive = FALSE);
    HRESULT DeleteRecoverable(BOOL fRecursive = FALSE);
    HRESULT Recover(BOOL fRecursive = FALSE);
    HRESULT WriteFriendlyName(LPCTSTR lpszName);

public:
    BOOL IsInproc() const { return m_dwProcessProtection == APP_INPROC; }
    BOOL IsOutOfProc() const { return m_dwProcessProtection == APP_OUTOFPROC; }
    BOOL IsPooledProc() const { return m_dwProcessProtection == APP_POOLEDPROC; }

public:
    DWORD   m_dwProcessProtection;
    CString m_strFriendlyName;
    CString m_strAppRoot;

protected:
    void CommonConstruct();

private:
    DWORD   m_dwAppState;
    CString m_strWamPath;
    HRESULT m_hrApp;
};



class COMDLL CIISSvcControl
/*++

Class description:

    IIS Service control

Virtual Interface:

    Succeeded           : Return TRUE if item constructed successfully
    QueryResult         : Return construction error code

Public Interface:

    operator BOOL       : Cast to TRUE/FALSE depending on success
    operator HRESULT    : Cast to the HRESULT status

--*/
{
//
// Constructor/Destructor
//
public:
    //
    // Fully defined constructor that creates the interface.
    // Use NULL to create the interface on the local computer
    //
    CIISSvcControl(
        IN LPCTSTR lpszServerName = NULL
        );

    //
    // Construct from existing interface.  
    //
    CIISSvcControl(
        IN const CIISSvcControl * pInterface
        );

    //
    // Destructor destroys the interface
    //
    ~CIISSvcControl();

//
// Virtual Interface:
//
public:
    virtual BOOL Succeeded() const;
    virtual HRESULT QueryResult() const;

//
// Conversion Operators
//
public:
    operator BOOL() const    { return Succeeded(); }
    operator HRESULT() const { return m_hrInterface; }

protected:
    //
    // Create an object in this server. This function initializes the
    // object with DCOM.
    //
    HRESULT Create(
        IN LPCTSTR lpszServerName = NULL
        );

    //
    // Make sure the interface has been created
    //
    BOOL HasInterface() const { return m_pInterface != NULL; }

//
// Interface
//
public:
    //
    // Stop services
    //
    HRESULT Stop(
        IN DWORD dwTimeoutMsecs,
        IN BOOL fForce
        );

    //
    // Start services
    //
    HRESULT Start(
        IN DWORD dwTimeoutMsecs
        );

    //
    // Reboot
    //
    HRESULT Reboot(
        IN DWORD dwTimeouMsecs,
        IN BOOL fForceAppsClosed
        );

    //
    // Status
    //
    HRESULT Status(
        IN  DWORD dwBufferSize,
        OUT LPBYTE pbBuffer,
        OUT DWORD * MDRequiredBufferSize,
        OUT DWORD * pdwNumServices
        );

    //
    // Kill
    //
    HRESULT Kill();

protected:
    CString m_strServerName;
    IIisServiceControl * m_pInterface; 

private:
    HRESULT m_hrInterface;
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline HRESULT CMetaInterface::OpenKey(
    IN  METADATA_HANDLE hkBase,
    IN  LPCTSTR lpszMDPath,
    IN  DWORD dwFlags,
    OUT METADATA_HANDLE * phMDNewHandle
    )
{
    ASSERT(m_pInterface != NULL);
    return m_pInterface->OpenKey(
        hkBase,
        lpszMDPath,
        dwFlags,
        m_iTimeOutValue,
        phMDNewHandle
        );
}

inline HRESULT CMetaInterface::CloseKey(
    IN METADATA_HANDLE hKey
    )
{
    ASSERT(m_pInterface != NULL);
    return m_pInterface->CloseKey(hKey);
}

inline HRESULT CMetaInterface::SetLastChangeTime( 
    IN METADATA_HANDLE hMDHandle,
    IN LPCTSTR pszMDPath,
    IN FILETIME * pftMDLastChangeTime,
    IN BOOL bLocalTime
    )
{
    ASSERT(m_pInterface != NULL);
    return m_pInterface->SetLastChangeTime(
        hMDHandle,
        pszMDPath,
        pftMDLastChangeTime,
        bLocalTime
        );
}
        
inline HRESULT CMetaInterface::GetLastChangeTime( 
    IN  METADATA_HANDLE hMDHandle,
    IN  LPCTSTR lpszMDPath,
    OUT FILETIME * pftMDLastChangeTime,
    IN  BOOL bLocalTime
    )
{
    ASSERT(m_pInterface != NULL);
    return m_pInterface->GetLastChangeTime(
        hMDHandle,
        lpszMDPath,
        pftMDLastChangeTime,
        bLocalTime
        );
}

inline HRESULT CMetaInterface::AddKey( 
    IN METADATA_HANDLE hKey,
    IN LPCTSTR lpszMDPath
    )
{
    ASSERT(m_pInterface != NULL);
    return m_pInterface->AddKey(hKey, lpszMDPath);
}

inline HRESULT CMetaInterface::DeleteKey(
    IN METADATA_HANDLE hKey,
    IN LPCTSTR lpszMDPath
    )
{
    ASSERT(m_pInterface != NULL);
    return m_pInterface->DeleteKey(hKey, lpszMDPath);
}

inline HRESULT CMetaInterface::DeleteChildKeys(
    IN METADATA_HANDLE hKey,
    IN LPCTSTR lpszMDPath
    )
{
    ASSERT(m_pInterface != NULL);
    return m_pInterface->DeleteChildKeys(hKey, lpszMDPath);
}

inline HRESULT CMetaInterface::EnumKeys(
    IN  METADATA_HANDLE hKey,
    IN  LPCTSTR lpszMDPath,
    OUT LPTSTR lpszMDName,
    IN  DWORD dwIndex
    )
{
    ASSERT(m_pInterface != NULL);
    return m_pInterface->EnumKeys(hKey, lpszMDPath, lpszMDName, dwIndex);
}        

inline HRESULT CMetaInterface::CopyKey(
    IN METADATA_HANDLE hSourceKey,
    IN LPCTSTR lpszMDSourcePath,
    IN METADATA_HANDLE hDestKey,
    IN LPCTSTR lpszMDDestPath,
    IN BOOL fOverwrite,
    IN BOOL fCopy
    )
{
    ASSERT(m_pInterface != NULL);
    return m_pInterface->CopyKey(
        hSourceKey,
        lpszMDSourcePath,
        hDestKey,
        lpszMDDestPath,
        fOverwrite,
        fCopy
        );        
}

inline HRESULT CMetaInterface::RenameKey(
    IN METADATA_HANDLE hKey,
    IN LPCTSTR lpszMDPath,
    IN LPCTSTR lpszNewName
    )
{   
    ASSERT(m_pInterface != NULL);     
    return m_pInterface->RenameKey(hKey, lpszMDPath, lpszNewName);
}

inline HRESULT CMetaInterface::GetData(
    IN  METADATA_HANDLE hKey,
    IN  LPCTSTR lpszMDPath,
    OUT METADATA_RECORD * pmdRecord,
    OUT DWORD * pdwRequiredDataLen
    )
{
    ASSERT(m_pInterface != NULL);
    return m_pInterface->GetData(
        hKey,
        lpszMDPath,
        pmdRecord,
        pdwRequiredDataLen
        );
}

inline HRESULT CMetaInterface::SetData(
    IN METADATA_HANDLE hKey,
    IN LPCTSTR lpszMDPath,
    IN METADATA_RECORD * pmdRecord
    )
{
    ASSERT(m_pInterface != NULL);
    return m_pInterface->SetData(
        hKey,
        lpszMDPath,
        pmdRecord
        );
}

inline HRESULT CMetaInterface::DeleteData(
    IN METADATA_HANDLE hKey,
    IN LPCTSTR lpszMDPath,
    IN DWORD dwMDIdentifier,
    IN DWORD dwMDDataType
    )
{
    ASSERT(m_pInterface != NULL);
    return m_pInterface->DeleteData(
        hKey,
        lpszMDPath,
        dwMDIdentifier,
        dwMDDataType
        );
}

inline HRESULT CMetaInterface::EnumData(
    IN  METADATA_HANDLE hKey,
    IN  LPCTSTR lpszMDPath,
    OUT METADATA_RECORD * pmdRecord,
    IN  DWORD dwIndex,
    OUT DWORD * pdwRequiredDataLen
    )
{
    ASSERT(m_pInterface != NULL);
    return m_pInterface->EnumData(
        hKey,
        lpszMDPath,
        pmdRecord,
        dwIndex,
        pdwRequiredDataLen
        );
}

inline HRESULT CMetaInterface::GetAllData(
    IN  METADATA_HANDLE hKey,
    IN  LPCTSTR lpszMDPath,
    IN  DWORD dwMDAttributes,
    IN  DWORD dwMDUserType,
    IN  DWORD dwMDDataType,
    OUT DWORD * pdwMDNumDataEntries,
    OUT DWORD * pdwMDDataSetNumber,
    IN  DWORD dwMDBufferSize,
    OUT LPBYTE pbMDBuffer,
    OUT DWORD * pdwRequiredBufferSize
    )
{
    ASSERT(m_pInterface != NULL);
    return m_pInterface->GetAllData(
        hKey,
        lpszMDPath,
        dwMDAttributes,
        dwMDUserType,
        dwMDDataType,
        pdwMDNumDataEntries,
        pdwMDDataSetNumber,
        dwMDBufferSize,
        pbMDBuffer,
        pdwRequiredBufferSize
        );
}    

inline HRESULT CMetaInterface::DeleteAllData( 
    IN METADATA_HANDLE hKey,
    IN LPCTSTR lpszMDPath,
    IN DWORD dwMDUserType,
    IN DWORD dwMDDataType
    )
{
    ASSERT(m_pInterface != NULL);
    return m_pInterface->DeleteAllData(
        hKey, 
        lpszMDPath, 
        dwMDUserType, 
        dwMDDataType
        );
}

inline HRESULT CMetaInterface::CopyData( 
    IN METADATA_HANDLE hMDSourceKey,
    IN LPCTSTR lpszMDSourcePath,
    IN METADATA_HANDLE hMDDestKey,
    IN LPCTSTR lpszMDDestPath,
    IN DWORD dwMDAttributes,
    IN DWORD dwMDUserType,
    IN DWORD dwMDDataType,
    IN BOOL fCopy
    )
{
    ASSERT(m_pInterface != NULL);
    return m_pInterface->CopyData(
        hMDSourceKey,
        lpszMDSourcePath,
        hMDDestKey,
        lpszMDDestPath,
        dwMDAttributes,
        dwMDUserType,
        dwMDDataType,
        fCopy
        );
}

inline HRESULT CMetaInterface::GetDataPaths( 
    IN  METADATA_HANDLE hKey,
    IN  LPCTSTR lpszMDPath,
    IN  DWORD dwMDIdentifier,
    IN  DWORD dwMDDataType,
    IN  DWORD dwMDBufferSize,
    OUT LPTSTR lpszBuffer,
    OUT DWORD * pdwMDRequiredBufferSize
    )
{
    ASSERT(m_pInterface != NULL);
    return m_pInterface->GetDataPaths(
        hKey,
        lpszMDPath,
        dwMDIdentifier,
        dwMDDataType,
        dwMDBufferSize,
        lpszBuffer,
        pdwMDRequiredBufferSize
        );
}

inline HRESULT CMetaInterface::Backup( 
    IN LPCTSTR lpszBackupLocation,
    IN DWORD dwMDVersion,
    IN DWORD dwMDFlags
    )
{
    ASSERT(m_pInterface != NULL);
    return m_pInterface->Backup(lpszBackupLocation, dwMDVersion, dwMDFlags);
}

inline HRESULT CMetaInterface::BackupWithPassword( 
    IN LPCTSTR lpszBackupLocation,
    IN DWORD dwMDVersion,
    IN DWORD dwMDFlags,
	IN LPCTSTR lpszPassword
    )
{
    ASSERT(m_pInterface != NULL);
	HRESULT hr = S_OK;
	IMSAdminBase2 * pInterface2 = NULL;
	if (SUCCEEDED(hr = m_pInterface->QueryInterface(IID_IMSAdminBase2, (void **)&pInterface2)))
	{
		hr = pInterface2->BackupWithPasswd(lpszBackupLocation, dwMDVersion, dwMDFlags, lpszPassword);
		pInterface2->Release();
	}
    return hr;
}

inline HRESULT CMetaInterface::Restore(    
    IN LPCTSTR lpszBackupLocation,
    IN DWORD dwMDVersion,
    IN DWORD dwMDFlags
    )
{
    ASSERT(m_pInterface != NULL);
    return m_pInterface->Restore(lpszBackupLocation, dwMDVersion, dwMDFlags);
}

inline HRESULT CMetaInterface::RestoreWithPassword(    
    IN LPCTSTR lpszBackupLocation,
    IN DWORD dwMDVersion,
    IN DWORD dwMDFlags,
	IN LPCTSTR lpszPassword
    )
{
    ASSERT(m_pInterface != NULL);
	HRESULT hr = S_OK;
	IMSAdminBase2 * pInterface2 = NULL;
	if (SUCCEEDED(hr = m_pInterface->QueryInterface(IID_IMSAdminBase2, (void **)&pInterface2)))
	{
		hr = pInterface2->RestoreWithPasswd(lpszBackupLocation, dwMDVersion, dwMDFlags, lpszPassword);
		pInterface2->Release();
	}
    return hr;
}

inline HRESULT CMetaInterface::EnumBackups(
    OUT LPTSTR lpszBackupLocation,
    OUT DWORD * pdwMDVersion,
    OUT FILETIME * pftMDBackupTime,
    IN  DWORD dwIndex
    )
{
    ASSERT(m_pInterface != NULL);
    return m_pInterface->EnumBackups(
        lpszBackupLocation,
        pdwMDVersion,
        pftMDBackupTime,
        dwIndex
        );    
}

inline HRESULT CMetaInterface::DeleteBackup(
    IN LPCTSTR lpszBackupLocation,
    IN DWORD dwMDVersion
    )
{
    ASSERT(m_pInterface != NULL);
    return m_pInterface->DeleteBackup(lpszBackupLocation, dwMDVersion);
}        

inline HRESULT CWamInterface::AppDelete( 
    IN LPCTSTR szMDPath,
    IN BOOL fRecursive
    )
{
    ASSERT(m_pInterface != NULL);
    return m_pInterface->AppDelete(szMDPath, fRecursive);
}

inline HRESULT CWamInterface::AppUnLoad( 
    IN LPCTSTR szMDPath,
    IN BOOL fRecursive
    )
{
    ASSERT(m_pInterface != NULL);
    return m_pInterface->AppUnLoad(szMDPath, fRecursive);
}

inline HRESULT CWamInterface::AppGetStatus( 
    IN  LPCTSTR szMDPath,
    OUT DWORD * pdwAppStatus
    )
{
    ASSERT(m_pInterface != NULL);
    return m_pInterface->AppGetStatus(szMDPath, pdwAppStatus);
}

inline HRESULT CWamInterface::AppDeleteRecoverable( 
    IN LPCTSTR szMDPath,
    IN BOOL fRecursive
    )
{
    ASSERT(m_pInterface != NULL);
    return m_pInterface->AppDeleteRecoverable(szMDPath, fRecursive);
}

inline HRESULT CWamInterface::AppRecover( 
    IN LPCTSTR szMDPath,
    IN BOOL fRecursive
    )
{
    ASSERT(m_pInterface != NULL);
    return m_pInterface->AppRecover(szMDPath, fRecursive);
}

inline HRESULT CMetaBack::Next(
    OUT DWORD * pdwVersion,
    OUT LPTSTR lpszLocation,
    OUT FILETIME * pftBackupTime
    )
{
    return EnumBackups(
        lpszLocation,
        pdwVersion,
        pftBackupTime,
        m_dwIndex++
        );
}

inline HRESULT CMetaBack::Backup(
    IN LPCTSTR lpszLocation
    )
{
    return CMetaInterface::Backup(
        lpszLocation, 
        MD_BACKUP_NEXT_VERSION, 
        MD_BACKUP_SAVE_FIRST
        );
}

inline HRESULT CMetaBack::Delete(
    IN LPCTSTR lpszLocation,
    IN DWORD dwVersion
    )
{
    return DeleteBackup(lpszLocation, dwVersion);
}

inline HRESULT CMetaKey::AddKey(
    IN LPCTSTR lpszMDPath
    )
{
    return CMetaInterface::AddKey(m_hKey, lpszMDPath);    
}

inline HRESULT CMetaKey::DeleteKey(
    IN LPCTSTR lpszMDPath
    )
{
    return CMetaInterface::DeleteKey(m_hKey, lpszMDPath);    
}

inline HRESULT CMetaKey::RenameKey(
    IN LPCTSTR lpszMDPath,
    IN LPCTSTR lpszNewName
    )
{
    return CMetaInterface::RenameKey(m_hKey, lpszMDPath, lpszNewName);    
}

inline HRESULT CMetaKey::ReOpen()
{
    return Open(m_dwFlags, m_hBase, m_strMetaPath);
}

inline HRESULT CMetaKey::ReOpen(DWORD dwFlags)
{
    return Open(dwFlags, m_hBase, m_strMetaPath);
}

inline BOOL CMetaKey::IsHomeDirectoryPath()
{
    return IsHomeDirectoryPath(m_strMetaPath);
}

inline HRESULT CMetaKey::QueryValue(
    IN  DWORD dwID, 
    OUT BOOL & fValue,
    IN  BOOL * pfInheritanceOverride,
    IN  LPCTSTR lpszMDPath,
    OUT DWORD * pdwAttributes        
    )
{
    ASSERT(sizeof(DWORD) == sizeof(BOOL));
    return CMetaKey::QueryValue(
        dwID, 
        (DWORD &)fValue, 
        pfInheritanceOverride, 
        lpszMDPath,
        pdwAttributes
        );
}

inline HRESULT CMetaKey::SetValue(
    IN DWORD dwID,
    IN DWORD dwValue,
    IN BOOL * pfInheritanceOverride,    OPTIONAL
    IN LPCTSTR lpszMDPath               OPTIONAL
    )
{
    return SetPropertyValue(
        dwID, 
        sizeof(dwValue), 
        &dwValue, 
        pfInheritanceOverride,
        lpszMDPath
        );
}

inline HRESULT CMetaKey::SetValue(
    IN DWORD dwID,
    IN BOOL fValue,
    IN BOOL * pfInheritanceOverride,
    IN LPCTSTR lpszMDPath
    )
{
    ASSERT(sizeof(DWORD) == sizeof(BOOL));
    return CMetaKey::SetValue(
        dwID,
        (DWORD)fValue,
        pfInheritanceOverride,
        lpszMDPath
        );
}

inline HRESULT CMetaKey::SetValue(
    IN DWORD dwID,
    IN CString & strValue,
    IN BOOL * pfInheritanceOverride,    OPTIONAL
    IN LPCTSTR lpszMDPath               OPTIONAL
    )
{
    return SetPropertyValue(
        dwID,
        (strValue.GetLength() + 1) * sizeof(TCHAR),
        (void *)(LPCTSTR)strValue,
        pfInheritanceOverride,
        lpszMDPath
        );
}

inline BOOL CIISApplication::IsEnabledApplication() const
{
    return m_dwAppState == APPSTATUS_STOPPED 
        || m_dwAppState == APPSTATUS_RUNNING;
}

inline HRESULT CIISApplication::Delete(
    IN BOOL fRecursive
    )
{
    ASSERT(!m_strWamPath.IsEmpty());
    return AppDelete(m_strWamPath, fRecursive);
}

inline HRESULT CIISApplication::Unload(
    IN BOOL fRecursive
    )
{
    ASSERT(!m_strWamPath.IsEmpty());
    return AppUnLoad(m_strWamPath, fRecursive);
}

inline HRESULT CIISApplication::DeleteRecoverable(
    IN BOOL fRecursive
    )
{
    ASSERT(!m_strWamPath.IsEmpty());
    return AppDeleteRecoverable(m_strWamPath, fRecursive);
}

inline HRESULT CIISApplication::Recover(
    IN BOOL fRecursive
    )
{
    ASSERT(!m_strWamPath.IsEmpty());
    return AppRecover(m_strWamPath, fRecursive);
}

inline HRESULT CIISSvcControl::Stop(
    IN DWORD dwTimeoutMsecs,
    IN BOOL fForce
    )
{
    ASSERT(m_pInterface != NULL);
    return m_pInterface->Stop(dwTimeoutMsecs, (DWORD)fForce);
}

inline HRESULT CIISSvcControl::Start(
    IN DWORD dwTimeoutMsecs
    )
{
    ASSERT(m_pInterface != NULL);
    return m_pInterface->Start(dwTimeoutMsecs);
}

inline HRESULT CIISSvcControl::Reboot(
    IN DWORD dwTimeouMsecs,
    IN BOOL fForceAppsClosed
    )
{
    ASSERT(m_pInterface != NULL);
    return m_pInterface->Reboot(dwTimeouMsecs, (DWORD)fForceAppsClosed);
}

inline HRESULT CIISSvcControl::Status(
    IN  DWORD dwBufferSize,
    OUT LPBYTE pbBuffer,
    OUT DWORD * MDRequiredBufferSize,
    OUT DWORD * pdwNumServices
    )
{
    ASSERT(m_pInterface != NULL);
    return m_pInterface->Status(
        dwBufferSize, 
        pbBuffer,
        MDRequiredBufferSize,
        pdwNumServices
        );
}

inline HRESULT CIISSvcControl::Kill()
{
    ASSERT(m_pInterface != NULL);
    return m_pInterface->Kill();
}

#endif // _MDKEYS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\comprop\mime.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        mime.cpp

   Abstract:

        Mime mapping dialog

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include "comprop.h"
#include "mime.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif



CMimeEditDlg::CMimeEditDlg(
    IN CWnd * pParent OPTIONAL
    )
/*++

Routine Description:

    Constructor to create new mime mapping

Arguments:

    CWnd * pParent  : Optional parent window or NULL

Return Value:

    N/A

--*/
    : m_strExt(),
      m_strMime(),
      CDialog(CMimeEditDlg::IDD, pParent)
{
}



CMimeEditDlg::CMimeEditDlg(
    IN LPCTSTR lpstrExt,
    IN LPCTSTR lpstrMime,
    IN CWnd * pParent OPTIONAL
    )
/*++

Routine Description:

    Constructor to edit existing mime mapping

Arguments:

    LPCTSTR lpstrExt  : Extension
    LPCTSTR lpstrMime : Mime mapping
    CWnd * pParent    : Optional parent window or NULL

Return Value:

    N/A

--*/
    : m_strExt(lpstrExt),
      m_strMime(lpstrMime),
      CDialog(CMimeEditDlg::IDD, pParent)
{
    //{{AFX_DATA_INIT(CMimeEditDlg)
    //}}AFX_DATA_INIT
}



void 
CMimeEditDlg::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CDialog::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CMimeEditDlg)
    DDX_Control(pDX, IDOK, m_button_Ok);
    DDX_Control(pDX, IDC_EDIT_MIME, m_edit_Mime);
    DDX_Control(pDX, IDC_EDIT_EXTENT, m_edit_Extent);
    //}}AFX_DATA_MAP
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CMimeEditDlg, CDialog)
    //{{AFX_MSG_MAP(CMimeEditDlg)
    //}}AFX_MSG_MAP

    ON_EN_CHANGE(IDC_EDIT_MIME,  OnItemChanged)
    ON_EN_CHANGE(IDC_EDIT_EXTENT, OnItemChanged)

END_MESSAGE_MAP()



void 
CMimeEditDlg::SetControlStates()
/*++

Routine Description:

    Enable/disable controls depending on current dialog data

Arguments:

    None

Return Value:

    None

--*/
{
    m_button_Ok.EnableWindow(
        m_edit_Extent.GetWindowTextLength() > 0
     && m_edit_Mime.GetWindowTextLength() > 0
        );
}



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



void 
CMimeEditDlg::OnItemChanged()
/*++

Routine Description:

    Respond to changes

Arguments:

    None.

Return Value:

    None.

--*/
{
    SetControlStates();
}



BOOL 
CMimeEditDlg::OnInitDialog()
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CDialog::OnInitDialog();

    m_edit_Extent.SetWindowText(m_strExt);
    m_edit_Mime.SetWindowText(m_strMime);

    SetControlStates();
    
    return TRUE;
}



void 
CMimeEditDlg::OnOK()
/*++

Routine Description:

    'OK' button was pressed -- store data.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    m_edit_Extent.GetWindowText(m_strExt);
    m_edit_Mime.GetWindowText(m_strMime);

    CleanExtension(m_strExt);

    CDialog::OnOK();
}




CMimeDlg::CMimeDlg(
    IN CStringListEx & strlMimeTypes,
    IN CWnd * pParent               OPTIONAL
    )
/*++

Routine Description:

    Constructor for the MIME listing dialog

Arguments:

    CStringListEx & strlMimeTypes : Listing of mime types to edit
    CWnd * pParent                : Optional parent window or NULL

Return Value:

    N/A

--*/
    : m_fDirty(FALSE),
      m_strlMimeTypes(strlMimeTypes),
      CDialog(CMimeDlg::IDD, pParent)
{
    //{{AFX_DATA_INIT(CMimeDlg)
    //}}AFX_DATA_INIT
}



void
CMimeDlg::DoDataExchange(
    IN OUT CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/

{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CMimeDlg)
    DDX_Control(pDX, IDOK, m_button_Ok);
    DDX_Control(pDX, IDC_EDIT_EXTENSION, m_edit_Extention);
    DDX_Control(pDX, IDC_EDIT_CONTENT_TYPE, m_edit_ContentType);
    DDX_Control(pDX, IDC_BUTTON_REMOVE, m_button_Remove);
    DDX_Control(pDX, IDC_BUTTON_EDIT, m_button_Edit);
    //}}AFX_DATA_MAP

    DDX_Control(pDX, IDC_LIST_MIME_TYPES, m_list_MimeTypes);
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CMimeDlg, CDialog)
    //{{AFX_MSG_MAP(CMimeDlg)
    ON_BN_CLICKED(IDC_BUTTON_EDIT, OnButtonEdit)
    ON_BN_CLICKED(IDC_BUTTON_NEW_TYPE, OnButtonNewType)
    ON_BN_CLICKED(IDC_BUTTON_REMOVE, OnButtonRemove)
    ON_LBN_DBLCLK(IDC_LIST_MIME_TYPES, OnDblclkListMimeTypes)
    ON_LBN_SELCHANGE(IDC_LIST_MIME_TYPES, OnSelchangeListMimeTypes)
    //}}AFX_MSG_MAP

    ON_EN_CHANGE(IDC_EDIT_CONTENT_TYPE, OnItemChanged)
    ON_EN_CHANGE(IDC_EDIT_EXTENSION, OnItemChanged)

END_MESSAGE_MAP()



void 
CMimeDlg::SetControlStates()
/*++

Routine Description:

    Enable/disable controls depending on current dialog data

Arguments:

    None

Return Value:

    None

--*/
{
    m_button_Remove.EnableWindow(m_list_MimeTypes.GetSelCount() > 0);
    m_button_Edit.EnableWindow(m_list_MimeTypes.GetSelCount() == 1);
    m_button_Ok.EnableWindow(m_fDirty);
}



BOOL
CMimeDlg::BuildDisplayString(
    IN  CString & strIn,
    OUT CString & strOut
    )
/*++

Routine Description:

    Build a listbox-suitable display string for the mime type

Arguments:

    CString & strIn     : Input string in metabase format
    CString & strOut    : Output string in display format

Return Value:

    TRUE if successfull, FALSE otherwise

--*/
{
    BOOL fSuccess = FALSE;

    int nComma = strIn.Find(_T(','));
    if (nComma >= 0)
    {
        CString strExt = strIn.Left(nComma);
        CString strMime = strIn.Mid(nComma + 1);

        try
        {
            BuildDisplayString(strExt, strMime, strOut);
            ++fSuccess;
        }
        catch(CMemoryException * e)
        {
            TRACEEOLID("Mem exception in BuildDisplayString");
            e->ReportError();
            e->Delete();
        }
    }

    return fSuccess;
}



BOOL
CMimeDlg::CrackDisplayString(
    IN  CString & strIn,
    OUT CString & strExt,
    OUT CString & strMime
    )
/*++

Routine Description:

    Parse a display-formatted mime mapping string, and break into
    component parts

Arguments:

    CString & strIn     : Input string in display format
    CString & strExt    : Output extension string
    CString & strMime   : Output MIME string.


Return Value:

    TRUE if successfull, FALSE otherwise

--*/
{
    BOOL fSuccess = FALSE;

    try
    {
        int nTab = strIn.Find(_T('\t'));
        if (nTab >= 0)
        {
            strExt = strIn.Left(nTab);
            strMime = strIn.Mid(nTab + 1);

            ++fSuccess;
        }
    }
    catch(CMemoryException * e)
    {
        TRACEEOLID("Mem exception in CrackDisplayString");
        e->ReportError();
        e->Delete();
    }

    return fSuccess;
}



int
CMimeDlg::FindMimeType(
    IN const CString & strTargetExt
    )
/*++

Routine Description:

    Find a mime type by its extention.  The return value
    is the listbox index where the item may be found, or
    -1 if the item doesn't exist

Arguments:

    const CString & strTargetExt : Target extension we're searching for

Return Value:

    The index of the MIME mapping for this extension if found, or -1
    otherwise.

--*/
{
    CString str;
    CString strExt;
    CString strMime;

    //
    // CODEWORK: Change to binsearch 
    //
    for (int n = 0; n < m_list_MimeTypes.GetCount(); ++n)
    {
        m_list_MimeTypes.GetText(n, str);    
        if (CrackDisplayString(str, strExt, strMime))
        {
            if (!strExt.CompareNoCase(strTargetExt))
            {
                //
                // Found it.
                //
                return n;
            }
        }        
    }

    //
    // Not found
    //
    return -1;
}


void 
CMimeDlg::FillListBox()
/*++

Routine Description:

    Move the mime mappings from the string list to
    the listbox

Arguments:

    None.

Return Value:

    None.

--*/
{
    BeginWaitCursor();

    POSITION pos = m_strlMimeTypes.GetHeadPosition();

    while(pos)
    {
        CString & str = m_strlMimeTypes.GetNext(pos);
        CString strOut;

        if (BuildDisplayString(str, strOut))
        {
            m_list_MimeTypes.AddString(strOut);
        }
    }

    EndWaitCursor();
}



void 
CMimeDlg::FillFromListBox()
/*++

Routine Description:

    Reverse the above; Move the contents of the listbox
    back to the stringlist

Arguments:

    None.

Return Value:

    None.

--*/

{
    CString str;
    CString strExt;
    CString strMime;

    BeginWaitCursor();

    m_strlMimeTypes.RemoveAll();
    for (int n = 0; n < m_list_MimeTypes.GetCount(); ++n)
    {
        m_list_MimeTypes.GetText(n, str);    
        if (CrackDisplayString(str, strExt, strMime))
        {
            BuildMetaString(strExt, strMime, str);
            m_strlMimeTypes.AddTail(str);
        }
    }

    EndWaitCursor();
}



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

BOOL 
CMimeDlg::OnInitDialog() 
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CDialog::OnInitDialog();

    m_list_MimeTypes.Initialize();

    FillListBox();
    SetControlStates(); 
    
    return TRUE;
}



void 
CMimeDlg::OnButtonEdit()
/*++

Routine Description:

    'Edit' button has been pressed -- edit current selection

Arguments:

    None.

Return Value:

    None.

--*/
{
    int nCurSel = m_list_MimeTypes.GetCurSel();

    if (nCurSel >= 0)
    {
        CString str;
        CString strExt;
        CString strMime;

        m_list_MimeTypes.GetText(nCurSel, str);
        if (CrackDisplayString(str, strExt, strMime))
        {
            CMimeEditDlg dlg(strExt, strMime, this);

            if (dlg.DoModal() == IDOK)
            {
                strExt = dlg.m_strExt;
                strMime = dlg.m_strMime;

                BuildDisplayString(strExt, strMime, str);
                m_list_MimeTypes.DeleteString(nCurSel);
                nCurSel = m_list_MimeTypes.AddString(str);
                m_list_MimeTypes.SetCurSel(nCurSel);
                m_fDirty = TRUE;

                OnSelchangeListMimeTypes();        
            }
        }
    }
}



void 
CMimeDlg::OnButtonNewType() 
/*++

Routine Description:

    'New' button has been pressed.  Create new MIME mapping, and
    bring up configuration on it.

Arguments:

    None.

Return Value:

    None.

--*/
{
    CMimeEditDlg dlg(this);

    if (dlg.DoModal() == IDOK)
    {
        CString str;
        CString strExt = dlg.m_strExt;
        CString strMime = dlg.m_strMime;

        //
        // Check to see if this extension already existed
        // in the list
        //
        int nOldSel = FindMimeType(strExt);
        if (nOldSel >= 0)
        {
            //
            // Yes, ask to have it replaced
            //
            if (::AfxMessageBox(
                IDS_REPLACE_MIME, 
                MB_ICONQUESTION | MB_YESNO | MB_DEFBUTTON2
                ) == IDYES)
            {
                //
                // Kill the old one
                //
                m_list_MimeTypes.DeleteString(nOldSel);
            }
            else
            {
                //
                // Nope..
                //
                return;    
            }
        }

        BuildDisplayString(strExt, strMime, str);
        int nCurSel = m_list_MimeTypes.AddString(str);
        m_list_MimeTypes.SetCurSel(nCurSel);
        m_fDirty = TRUE;

        OnSelchangeListMimeTypes();
    }
}



void 
CMimeDlg::OnButtonRemove()
/*++

Routine Description:

    'Remove' button has been pressed.  Remove the current MIME mapping.

Arguments:

    None.

Return Value:

    None.

--*/
{
    if (::AfxMessageBox(
        IDS_REMOVE_MIME, 
        MB_ICONQUESTION | MB_YESNO | MB_DEFBUTTON2
        ) != IDYES)
    {
        //
        // Changed his mind
        //
        return;
    }

    int nCurSel = m_list_MimeTypes.GetCurSel();

    int nSel = 0;
    while (nSel < m_list_MimeTypes.GetCount())
    {
        if (m_list_MimeTypes.GetSel(nSel))
        {
            m_list_MimeTypes.DeleteString(nSel);   
            m_fDirty = TRUE;
            continue;
        }

        ++nSel;
    }

    if (m_fDirty)
    {
        if (nCurSel > 0)
        {
            --nCurSel;
        }

        m_list_MimeTypes.SetCurSel(nCurSel);
        OnSelchangeListMimeTypes();
    }
}



void 
CMimeDlg::OnItemChanged()
/*++

Routine Description:

    Respond to changes

Arguments:

    None.

Return Value:

    None.

--*/
{
    SetControlStates();
}



void 
CMimeDlg::OnDblclkListMimeTypes()
/*++

Routine Description:

    Double clicking on an item is the same as pressing edit

Arguments:

    None.

Return Value:

    None.

--*/
{
    OnButtonEdit();
}



void
CMimeDlg::OnSelchangeListMimeTypes() 
/*++

Routine Description:

    Respond to change in selection in the listbox.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    // Update the text in the description box
    //
    int nCurSel = m_list_MimeTypes.GetCurSel();
    
    if (nCurSel >= 0)
    {
        CString str;
        CString strExt;
        CString strMime;

        m_list_MimeTypes.GetText(nCurSel, str);
        if (CrackDisplayString(str, strExt, strMime))
        {
            m_edit_Extention.SetWindowText(strExt);
            m_edit_ContentType.SetWindowText(strMime);
        }
    }
    else
    {
        m_edit_Extention.SetWindowText(_T(""));
        m_edit_ContentType.SetWindowText(_T(""));
    }

    SetControlStates();
}



void 
CMimeDlg::OnOK()
/*++

Routine Description:

    'OK' button was pressed -- store data.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    if (m_fDirty)
    {
        FillFromListBox();
    }

    CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\comprop\machine.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module Name :

        machine.h

   Abstract:

        IIS Machine Property Page Class Definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

#ifndef __MACHINE_H__
#define __MACHINE_H__

//
// Help ID
//
#define HIDD_IIS_MACHINE    (0x20081)



class CMasterDll : public CObject
/*++

Class Description:

    Master Dll object

Public Interface:

    CMasterDll          : Constructor
    ~CMasterDll         : Destructor

    Config              : Bring up config sheets

--*/
{
public:
    CMasterDll(
        IN UINT nID, 
        IN LPCTSTR lpszDllName,
        IN LPCTSTR lpszMachineName
        );

    ~CMasterDll();

public:
    //
    // Config Master Instance
    //
    DWORD Config(HWND hWnd, LPCTSTR lpServers);
    BOOL IsLoaded() const;
    operator LPCTSTR();
    operator HINSTANCE();

private:
    HINSTANCE    m_hDll;
    CString      m_strText;
    pfnConfigure m_pfnConfig;
};


typedef CList<CMasterDll *, CMasterDll *> CMasterDllList;



class COMDLL CIISMachinePage : public CPropertyPage
{
/*++

Class Description:

    IIS Machine Property Page

Public Interface:

    CIISMachinePage  : Constructor
    ~CIISMachinePage : Destructor

    QueryResult      : Get the result code

--*/
    DECLARE_DYNCREATE(CIISMachinePage)

//
// Construction/Destruction
//
public:
    CIISMachinePage(
        IN LPCTSTR lpstrMachineName = NULL,
        IN HINSTANCE hInstance      = NULL
        );

    ~CIISMachinePage();

//
// Access
//
public:
    HRESULT QueryResult() const;

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CIISMachinePage)
    enum { IDD = IDD_IIS_MACHINE };
    int       m_nMasterType;
    BOOL      m_fLimitNetworkUse;
    CEdit     m_edit_MaxNetworkUse;
    CStatic   m_static_ThrottlePrompt;
    CStatic   m_static_MaxNetworkUse;
    CStatic   m_static_KBS;
    CButton   m_button_EditDefault;
    CButton   m_check_LimitNetworkUse;
    CComboBox m_combo_MasterType;
    //}}AFX_DATA

//
// Overrides
//
protected:
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CIISMachinePage)
    public:
    virtual BOOL OnApply();
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    virtual void PostNcDestroy();
    //}}AFX_VIRTUAL

    CILong m_nMaxNetworkUse;

//
// Implementation
//
protected:
    HRESULT LoadDelayedValues();
    BOOL    SetControlStates();

    // Generated message map functions
    //{{AFX_MSG(CIISMachinePage)
    afx_msg void OnCheckLimitNetworkUse();
    afx_msg void OnButtonEditDefault();
    afx_msg void OnButtonFileTypes();
    afx_msg void OnHelp();
    afx_msg BOOL OnHelpInfo(HELPINFO * pHelpInfo);
    afx_msg void OnDestroy();
    virtual BOOL OnInitDialog();
    //}}AFX_MSG

    afx_msg void OnItemChanged();
    
    DECLARE_MESSAGE_MAP()

protected:
    CMasterDllList  m_lstMasterDlls;

protected:
    static void ParseMaxNetworkUse(
        IN  OUT CILong & nMaxNetworkUse,
        OUT BOOL & fLimitNetworkUse
        );

    static void BuildMaxNetworkUse(
        IN OUT CILong & nMaxNetworkUse,
        IN OUT BOOL & fLimitNetworkUse
        );

private:
    BOOL          m_fLocal;  
    HRESULT       m_hr;
    HINSTANCE     m_hInstance;
    CString       m_strMachineName;
    CString       m_strHelpFile;
    CStringListEx m_strlMimeTypes;
    CMimeTypes    * m_ppropMimeTypes;
    CMachineProps * m_ppropMachine;
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline DWORD CMasterDll::Config(
    IN HWND hWnd, 
    IN LPCTSTR lpServers
    )
{
    ASSERT(m_pfnConfig != NULL);
    return (*m_pfnConfig)(hWnd, MASTER_INSTANCE, lpServers);
}

inline BOOL CMasterDll::IsLoaded() const
{
    return m_hDll != NULL;
}

inline CMasterDll::operator LPCTSTR()
{
    return (LPCTSTR)m_strText;
}

inline CMasterDll::operator HINSTANCE()
{
    return m_hDll;
}

inline /* static */ void CIISMachinePage::BuildMaxNetworkUse(
    IN OUT CILong & nMaxNetworkUse,
    IN OUT BOOL & fLimitNetworkUse
    )
{
    nMaxNetworkUse = fLimitNetworkUse
        ? nMaxNetworkUse * KILOBYTE
        : INFINITE_BANDWIDTH;
}   

#if 0

//
// COMPILER ISSUE::: Inlining this function doesn't
//                   work on x86 using NT 5!
//
inline HRESULT CIISMachinePage::QueryResult() const
{
    return m_hr;
}

#endif // 0

#endif // __MACHINE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\comprop\mdkeys.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        mdkeys.cpp

   Abstract:

        Metabase key wrapper class

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/



//
// Include Files
//
#include "stdafx.h"
#include "comprop.h"
#include "idlg.h"
#include "mdkeys.h"



//
// Constants
//
#define MB_TIMEOUT          (15000)     // Timeout in milliseconds 
#define MB_INIT_BUFF_SIZE   (  256)     // Initial buffer size


//
// CMetaInterface class
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



CMetaInterface::CMetaInterface(
    IN LPCTSTR lpszServerName       OPTIONAL
    )
/*++

Routine Description:

    Construct and initialize the interface

Arguments:

    LPCTSTR lpszServerName  : Server name.  NULL indicates the local computer

Return Value:

    N/A

--*/
    : m_pInterface(NULL),
      m_iTimeOutValue(MB_TIMEOUT),
      m_strServerName(),
      m_hrInterface(S_OK)
{
    //
    // Initialize the interface
    //
    m_hrInterface = Create(lpszServerName);
}



CMetaInterface::CMetaInterface(
    IN const CMetaInterface * pInterface
    )
/*++

Routine Description:

    Construct from existing interface (Copy Constructor)

Arguments:

    CMetaInterface * pInterface : Existing interface

Return Value:

    N/A

Notes:
        
    Object will not take ownership of the interface,
    it will merely add to the reference count, and 
    release it upon destruction

--*/
    : m_pInterface(pInterface->m_pInterface),
      m_iTimeOutValue(pInterface->m_iTimeOutValue),
      m_strServerName(pInterface->m_strServerName),
      m_hrInterface(pInterface->m_hrInterface)
{
    ASSERT(m_pInterface != NULL);
    m_pInterface->AddRef();
}



CMetaInterface::~CMetaInterface()
/*++

Routine Description:

    Destructor -- releases the interface

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    SAFE_RELEASE(m_pInterface);
}



/* protected */
HRESULT
CMetaInterface::Create(
    IN LPCTSTR lpszServerName       OPTIONAL
    )
/*++

Routine Description:

    Create the interface with DCOM.

Arguments:

    lpszServerName  : machine name. Use the COSERVERINFO's pwszName syntax.
                      Could be NULL, in which case the local computer is used.

Return Value:

    HRESULT 

Notes:

    This function is smart enough to substitute NULL if the server
    name provided is in fact the local computer name.  Presumably,
    that's faster.

--*/
{
    COSERVERINFO * pcsiName = NULL;
    COSERVERINFO csiName;

    //
    // Be smart about the server name; optimize for local
    // computer name.
    //
    if (lpszServerName = ::NormalizeServerName(lpszServerName))
    {
        //
        // Create the COM server info for CoCreateInstanceEx
        //
        ::ZeroMemory(&csiName, sizeof(csiName));
        csiName.pwszName =  (LPWSTR)lpszServerName;
        pcsiName = &csiName;
    }

    //
    // Query the MD COM interface
    //
    MULTI_QI rgmqResults[1];
    rgmqResults[0].pIID = &IID_IMSAdminBase;
    rgmqResults[0].pItf = NULL;
    rgmqResults[0].hr = 0;

    //
    // Create a instance of the object and get the interface
    //
    HRESULT hr = ::CoCreateInstanceEx(
        GETAdminBaseCLSID(TRUE),
        NULL,
        CLSCTX_SERVER,
        pcsiName,
        1,
        rgmqResults
        );

    //
    // It failed, try with non-service MD
    //
    if (FAILED(hr))
    {
        //
        // inetinfo.exe run as user program
        //
        TRACEEOLID("Failed to create admin interface, second attempt");
        hr = ::CoCreateInstanceEx(
            GETAdminBaseCLSID(FALSE),
            NULL,
            CLSCTX_SERVER,
            pcsiName,
            1,
            rgmqResults
            );
    }

    if(SUCCEEDED(hr))
    {
        //
        // Save the interface pointer
        //
        m_pInterface = (IMSAdminBase *)rgmqResults[0].pItf;
        ASSERT(m_pInterface != NULL);
    }

    if (lpszServerName && *lpszServerName)
    {
        m_strServerName = lpszServerName;
    }
    else
    {
        //
        // Use local computer name
        //
        DWORD dwSize = MAX_PATH;
        LPTSTR lpName = m_strServerName.GetBuffer(dwSize);
        GetComputerName(lpName, &dwSize);
        m_strServerName.ReleaseBuffer();
    }

    return hr;
}



HRESULT
CMetaInterface::Regenerate()
/*++

Routine Description:

    Attempt to recreate the interface pointer.  This assumes that the interface
    had been successfully created before, but has become invalid at some
    point afterwards.

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    ASSERT(!m_strServerName.IsEmpty());     // Must've been initialized
    ASSERT(m_pInterface != NULL);           // As above

    SAFE_RELEASE(m_pInterface);

    m_hrInterface = Create(m_strServerName);

    return m_hrInterface;
}



/* virtual */
BOOL 
CMetaInterface::Succeeded() const
/*++

Routine Description:

    Determine if object was constructed successfully.

Arguments:

    None

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    return SUCCEEDED(m_hrInterface);
}



/* virtual */
HRESULT 
CMetaInterface::QueryResult() const
/*++

Routine Description:

    Return the construction error for this object.

Arguments:

    None

Return Value:

    HRESULT from construction errors

--*/
{
    return m_hrInterface;
}



//
// CWamInterface class
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



CWamInterface::CWamInterface(
    IN LPCTSTR lpszServerName       OPTIONAL
    )
/*++

Routine Description:

    Construct and initialize the interface.

Arguments:

    LPCTSTR lpszServerName  : Server name, use NULL to indicate the local
                              computer name.

Return Value:

    N/A

--*/
    : m_pInterface(NULL),
      m_strServerName(),
      m_fSupportsPooledProc(FALSE),
      m_hrInterface(S_OK)
{
    //
    // Initialize the interface
    //
    m_hrInterface = Create(lpszServerName);
}



CWamInterface::CWamInterface(
    IN const CWamInterface * pInterface
    )
/*++

Routine Description:

    Construct from existing interface (copy constructor)

Arguments:

    CWamInterface * pInterface  : Existing interface

Return Value:

    N/A

--*/
    : m_pInterface(pInterface->m_pInterface),
      m_strServerName(pInterface->m_strServerName),
      m_fSupportsPooledProc(FALSE),
      m_hrInterface(pInterface->m_hrInterface)
{
    ASSERT(m_pInterface != NULL);
    m_pInterface->AddRef();
}



CWamInterface::~CWamInterface()
/*++

Routine Description:

    Destructor -- releases the interface.

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    SAFE_RELEASE(m_pInterface);
}



/* protected */
HRESULT
CWamInterface::Create(
    IN LPCTSTR lpszServerName       OPTIONAL
    )
/*++

Routine Description:

    Create the interface with DCOM

Arguments:

    lpszServerName  : machine name. Use the COSERVERINFO's pwszName syntax.
                      Could be NULL, in which case the local computer is used.

Return Value:

    HRESULT 

Notes:

    This function is smart enough to substitute NULL if the server
    name provided is in fact the local computer name.  Presumably,
    that's faster.

    First, it will attempt to create the new interface, if it
    fails, it will attempt to create the downlevel interface

--*/
{
    COSERVERINFO * pcsiName = NULL;
    COSERVERINFO csiName;

    //
    // Be smart about the server name; optimize for local
    // computer name.
    //
    if (lpszServerName = ::NormalizeServerName(lpszServerName))
    {
        //
        // Create the COM server info for CoCreateInstanceEx
        //
        ::ZeroMemory(&csiName, sizeof(csiName));
        csiName.pwszName =  (LPWSTR)lpszServerName;
        pcsiName = &csiName;
    }

    //
    // First try to do the new interface
    //
    MULTI_QI rgmqResults[1];
    rgmqResults[0].pIID = &IID_IWamAdmin2;
    rgmqResults[0].pItf = NULL;
    rgmqResults[0].hr = 0;

    //
    // Create a instance of the object and get the interface
    //
    HRESULT hr = ::CoCreateInstanceEx(
        CLSID_WamAdmin,
        NULL,
        CLSCTX_SERVER,
        pcsiName,
        1,
        rgmqResults
        );

    m_fSupportsPooledProc = SUCCEEDED(hr);

    if (hr == E_NOINTERFACE)
    {
        //
        // Attempt to create the downlevel version
        //
        TRACEEOLID("Attempting downlevel WAM interface");
        rgmqResults[0].pIID = &IID_IWamAdmin;

        hr = ::CoCreateInstanceEx(
            CLSID_WamAdmin,
            NULL,
            CLSCTX_SERVER,
            pcsiName,
            1,
            rgmqResults
            );
    }

    if(SUCCEEDED(hr))
    {
        //
        // Save the interface pointer
        //
        m_pInterface = (IWamAdmin *)rgmqResults[0].pItf;
        ASSERT(m_pInterface != NULL);
    }

    if (lpszServerName && *lpszServerName)
    {
        m_strServerName = lpszServerName;
    }
    else
    {
        //
        // Use local computer name
        //
        DWORD dwSize = MAX_PATH;
        LPTSTR lpName = m_strServerName.GetBuffer(dwSize);
        GetComputerName(lpName, &dwSize);
        m_strServerName.ReleaseBuffer();
    }

    return hr;
}



/* virtual */
BOOL 
CWamInterface::Succeeded() const
/*++

Routine Description:

    Determine if object was constructed successfully

Arguments:

    None

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    return SUCCEEDED(m_hrInterface);
}



/* virtual */
HRESULT 
CWamInterface::QueryResult() const
/*++

Routine Description:

    Return the construction error for this object

Arguments:

    None

Return Value:

    HRESULT from construction errors

--*/
{
    return m_hrInterface;
}



HRESULT 
CWamInterface::AppCreate( 
    IN LPCTSTR szMDPath,
    IN DWORD dwAppProtection
    )
/*++

Routine Description:

    Create  application

Arguments:

    LPCTSTR szMDPath      : Metabase path
    DWORD dwAppProtection : APP_INPROC     to create in-proc app
                            APP_OUTOFPROC  to create out-of-proc app
                            APP_POOLEDPROC to create a pooled-proc app

Return Value:

    HRESULT (ERROR_INVALID_PARAMETER if unsupported protection state is requested)

--*/
{
    if (m_fSupportsPooledProc)
    {
        //
        // Interface pointer is really IWamAdmin2, so call the new method
        //
        return ((IWamAdmin2 *)m_pInterface)->AppCreate2(szMDPath, dwAppProtection);
    }

    //
    // Call the downlevel API
    //
    if (dwAppProtection == APP_INPROC || dwAppProtection == APP_OUTOFPROC)
    {
        BOOL fInProc = (dwAppProtection == APP_INPROC);
    
        ASSERT(m_pInterface != NULL);
        return m_pInterface->AppCreate(szMDPath, fInProc);
    }

    return CError(ERROR_INVALID_PARAMETER);
}



//
// CMetaback Class
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


const LPCTSTR CMetaBack::s_szMasterAppRoot =\
    SZ_MBN_SEP_STR SZ_MBN_MACHINE SZ_MBN_SEP_STR SZ_MBN_WEB;


CMetaBack::CMetaBack(
    IN LPCTSTR lpszServerName OPTIONAL
    )
/*++

Routine Description:

    Constructor for metabase backup/restore operations class.  This object
    is both a WAM interface and a METABASE interface.

Arguments:

    LPCTSTR lpszServerName  : Server name.  Use NULL to indicate the local
                              computer name.

Return Value:

    N/A

--*/
    : m_dwIndex(0),
      CMetaInterface(lpszServerName),
      CWamInterface(lpszServerName)
{
}



/* virtual */
BOOL 
CMetaBack::Succeeded() const
/*++

Routine Description:

    Determine if object was constructed successfully.

Arguments:

    None

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    return CMetaInterface::Succeeded() && CWamInterface::Succeeded();
}



/* virtual */
HRESULT 
CMetaBack::QueryResult() const
/*++

Routine Description:

    Return the construction error for this object

Arguments:

    None

Return Value:

    HRESULT from construction errors

--*/
{
    //
    // Both interfaces must have constructed successfully
    //
    HRESULT hr = CMetaInterface::QueryResult();

    if (SUCCEEDED(hr))
    {
        hr = CWamInterface::QueryResult();
    }    

    return hr;
}



HRESULT 
CMetaBack::Restore(
    IN LPCTSTR lpszLocation,
    IN DWORD dwVersion
    )
/*++

Routine Description:

    Restore metabase

Arguments:

    DWORD dwVersion         : Backup version
    LPCTSTR lpszLocation    : Backup location

Return Value:

    HRESULT

--*/
{
    //
    // Backup and restore the application information from a restore
    //
    CString strPath(s_szMasterAppRoot);
    HRESULT hr = AppDeleteRecoverable(strPath, TRUE);

    if (SUCCEEDED(hr))
    {
        hr = CMetaInterface::Restore(lpszLocation, dwVersion, 0);

        if (SUCCEEDED(hr))
        {
            hr = AppRecover(strPath, TRUE);
        }
    }

    return hr;
}



HRESULT
CMetaBack::BackupWithPassword(
    IN LPCTSTR lpszLocation,
	IN LPCTSTR lpszPassword
    )
{
    return CMetaInterface::BackupWithPassword(
        lpszLocation, 
        MD_BACKUP_NEXT_VERSION, 
        MD_BACKUP_SAVE_FIRST,
		lpszPassword
        );
}

HRESULT 
CMetaBack::RestoreWithPassword(
    IN LPCTSTR lpszLocation,
    IN DWORD dwVersion,
    IN LPCTSTR lpszPassword
    )
/*++

Routine Description:

    Restore metabase

Arguments:

    DWORD dwVersion         : Backup version
    LPCTSTR lpszLocation    : Backup location
    LPCTSTR lpszPassword    : Backup password

Return Value:

    HRESULT

--*/
{
    //
    // Backup and restore the application information from a restore
    //
    CString strPath(s_szMasterAppRoot);
    HRESULT hr = AppDeleteRecoverable(strPath, TRUE);

    if (SUCCEEDED(hr))
    {
        hr = CMetaInterface::RestoreWithPassword(lpszLocation, dwVersion, 0, lpszPassword);

        if (SUCCEEDED(hr))
        {
            hr = AppRecover(strPath, TRUE);
        }
    }

    return hr;
}

//
// CIISSvcControl class
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



CIISSvcControl::CIISSvcControl(
    IN LPCTSTR lpszServerName       OPTIONAL
    )
/*++

Routine Description:

    Construct and initialize the interface.

Arguments:

    LPCTSTR lpszServerName  : Server name, use NULL to indicate the local
                              computer name.

Return Value:

    N/A

--*/
    : m_pInterface(NULL),
      m_strServerName(),
      m_hrInterface(S_OK)
{
    //
    // Initialize the interface
    //
    m_hrInterface = Create(lpszServerName);
}



CIISSvcControl::CIISSvcControl(
    IN const CIISSvcControl * pInterface
    )
/*++

Routine Description:

    Construct from existing interface (copy constructor)

Arguments:

    CIISSvcControl * pInterface  : Existing interface

Return Value:

    N/A

--*/
    : m_pInterface(pInterface->m_pInterface),
      m_strServerName(pInterface->m_strServerName),
      m_hrInterface(pInterface->m_hrInterface)
{
    ASSERT(m_pInterface != NULL);
    m_pInterface->AddRef();
}



CIISSvcControl::~CIISSvcControl()
/*++

Routine Description:

    Destructor -- releases the interface.

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    SAFE_RELEASE(m_pInterface);
}



/* protected */
HRESULT
CIISSvcControl::Create(
    IN LPCTSTR lpszServerName       OPTIONAL
    )
/*++

Routine Description:

    Create the interface with DCOM

Arguments:

    lpszServerName  : machine name. Use the COSERVERINFO's pwszName syntax.
                      Could be NULL, in which case the local computer is used.

Return Value:

    HRESULT 

Notes:

    This function is smart enough to substitute NULL if the server
    name provided is in fact the local computer name.  Presumably,
    that's faster.

--*/
{
    COSERVERINFO * pcsiName = NULL;
    COSERVERINFO csiName;

    //
    // Be smart about the server name; optimize for local
    // computer name.
    //
    if (lpszServerName = ::NormalizeServerName(lpszServerName))
    {
        //
        // Create the COM server info for CoCreateInstanceEx
        //
        ::ZeroMemory(&csiName, sizeof(csiName));
        csiName.pwszName =  (LPWSTR)lpszServerName;
        pcsiName = &csiName;
    }

    //
    // Query the MD COM interface
    //
    MULTI_QI rgmqResults[1];
    rgmqResults[0].pIID = &IID_IIisServiceControl;
    rgmqResults[0].pItf = NULL;
    rgmqResults[0].hr = 0;

    //
    // Create a instance of the object and get the interface
    //
    HRESULT hr = ::CoCreateInstanceEx(
        CLSID_IisServiceControl,
        NULL,
        CLSCTX_SERVER,
        pcsiName,
        1,
        rgmqResults
        );

    if(SUCCEEDED(hr))
    {
        //
        // Save the interface pointer
        //
        m_pInterface = (IIisServiceControl *)rgmqResults[0].pItf;
        ASSERT(m_pInterface != NULL);
    }

    if (lpszServerName && *lpszServerName)
    {
        m_strServerName = lpszServerName;
    }
    else
    {
        //
        // Use local computer name
        //
        DWORD dwSize = MAX_PATH;
        LPTSTR lpName = m_strServerName.GetBuffer(dwSize);
        GetComputerName(lpName, &dwSize);
        m_strServerName.ReleaseBuffer();
    }

    return hr;
}



/* virtual */
BOOL 
CIISSvcControl::Succeeded() const
/*++

Routine Description:

    Determine if object was constructed successfully

Arguments:

    None

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    return SUCCEEDED(m_hrInterface);
}



/* virtual */
HRESULT 
CIISSvcControl::QueryResult() const
/*++

Routine Description:

    Return the construction error for this object

Arguments:

    None

Return Value:

    HRESULT from construction errors

--*/
{
    return m_hrInterface;
}



//
// CMetaKey class
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

//
// Helper macros
//
#define ASSURE_PROPER_INTERFACE()\
    if (!HasInterface()) { ASSERT(FALSE); return MD_ERROR_NOT_INITIALIZED; }

#define ASSURE_OPEN_KEY()\
    if (!m_hKey && !m_fAllowRootOperations) { ASSERT(FALSE); return HRESULT_FROM_WIN32(ERROR_INVALID_HANDLE); }

#define FETCH_PROPERTY_DATA_OR_FAIL(dwID, md)\
    ZeroMemory(&md, sizeof(md)); \
    if (!GetMDFieldDef(dwID, md.dwMDIdentifier, md.dwMDAttributes, md.dwMDUserType, md.dwMDDataType))\
    { ASSERT(FALSE); return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER); }

//
// Static Initialization
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

const LPCTSTR CMetaKey::s_cszCompression = 
    SZ_MBN_FILTERS SZ_MBN_SEP_STR SZ_MBN_COMPRESSION;
const LPCTSTR CMetaKey::s_cszMachine     = SZ_MBN_MACHINE;
const LPCTSTR CMetaKey::s_cszMimeMap     = SZ_MBN_MIMEMAP;
const LPCTSTR CMetaKey::s_cszRoot        = SZ_MBN_ROOT;
const LPCTSTR CMetaKey::s_cszSep         = SZ_MBN_SEP_STR;
const LPCTSTR CMetaKey::s_cszInfo        = SZ_MBN_INFO;
const TCHAR   CMetaKey::s_chSep          = SZ_MBN_SEP_CHAR;
//
// Metabase table
//
const CMetaKey::MDFIELDDEF CMetaKey::s_rgMetaTable[] =
{
    //
    // !!!IMPORTANT!!! This table must be sorted on dwMDIdentifier.  (will
    // be verified in the debug version)
    //
    { MD_MAX_BANDWIDTH,                   METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_KEY_TYPE,                        METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_SERVER_COMMAND,                  METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_CONNECTION_TIMEOUT,              METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_CONNECTION_TIMEOUT          },
    { MD_MAX_CONNECTIONS,                 METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_MAX_CONNECTIONS             },
    { MD_SERVER_COMMENT,                  METADATA_INHERIT,                          IIS_MD_UT_SERVER, STRING_METADATA,  IDS_MD_SERVER_COMMENT              },
    { MD_SERVER_STATE,                    METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_SERVER_AUTOSTART,                METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_SERVER_SIZE,                     METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_SERVER_SIZE                 },
    { MD_SERVER_LISTEN_BACKLOG,           METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_SERVER_LISTEN_BACKLOG       },
    { MD_SERVER_LISTEN_TIMEOUT,           METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_SERVER_LISTEN_TIMEOUT       },
    { MD_SERVER_BINDINGS,                 METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, MULTISZ_METADATA, 0                                  },
    { MD_WIN32_ERROR,                     METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_FILE,   DWORD_METADATA,   0                                  },
    { MD_SECURE_BINDINGS,                 METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, MULTISZ_METADATA, 0                                  },
    { MD_FILTER_LOAD_ORDER,               METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_FILTER_IMAGE_PATH,               METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_FILTER_STATE,                    METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_FILTER_ENABLED,                  METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_FILTER_FLAGS,                    METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_AUTH_CHANGE_URL,                 METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_AUTH_EXPIRED_URL,                METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_AUTH_NOTIFY_PWD_EXP_URL,         METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_ADV_NOTIFY_PWD_EXP_IN_DAYS,      METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_ADV_CACHE_TTL,                   METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_NET_LOGON_WKS,                   METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_USE_HOST_NAME,                   METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_AUTH_EXPIRED_UNSECUREURL,        METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_AUTH_CHANGE_FLAGS,               METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_AUTH_NOTIFY_PWD_EXP_UNSECUREURL, METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_FRONTPAGE_WEB,                   METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_MAPCERT,                         METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_MAPNTACCT,                       METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_MAPNAME,                         METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_MAPENABLED,                      METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_MAPREALM,                        METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_MAPPWD,                          METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_ITACCT,                          METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_CPP_CERT11,                      METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, BINARY_METADATA,  0                                  },
    { MD_SERIAL_CERT11,                   METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, BINARY_METADATA,  0                                  },
    { MD_CPP_CERTW,                       METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, BINARY_METADATA,  0                                  },
    { MD_SERIAL_CERTW,                    METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, BINARY_METADATA,  0                                  },
    { MD_CPP_DIGEST,                      METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, BINARY_METADATA,  0                                  },
    { MD_SERIAL_DIGEST,                   METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, BINARY_METADATA,  0                                  },
    { MD_CPP_ITA,                         METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, BINARY_METADATA,  0                                  },
    { MD_SERIAL_ITA,                      METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, BINARY_METADATA,  0                                  },
    { MD_APP_FRIENDLY_NAME,               METADATA_INHERIT,                          IIS_MD_UT_WAM,    STRING_METADATA,  IDS_MD_APP_FRIENDLY_NAME           },
    { MD_APP_ROOT,                        METADATA_INHERIT,                          IIS_MD_UT_WAM,    STRING_METADATA,  IDS_MD_APP_ROOT                    },
    { MD_APP_ISOLATED,                    METADATA_INHERIT,                          IIS_MD_UT_WAM,    DWORD_METADATA,   IDS_MD_APP_ISOLATED                },
    { MD_CPU_LIMITS_ENABLED,              METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_CPU_LIMITS_ENABLED          },
    { MD_CPU_LIMIT_LOGEVENT,              METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_CPU_LIMIT_LOGEVENT          },
    { MD_CPU_LIMIT_PRIORITY,              METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_CPU_LIMIT_PRIORITY          },
    { MD_CPU_LIMIT_PROCSTOP,              METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_CPU_LIMIT_PROCSTOP          },
    { MD_CPU_LIMIT_PAUSE,                 METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_CPU_LIMIT_PAUSE             },
    { MD_HC_COMPRESSION_DIRECTORY,        METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_HC_DO_DYNAMIC_COMPRESSION,       METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_HC_DO_STATIC_COMPRESSION,        METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_HC_DO_DISK_SPACE_LIMITING,       METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_HC_MAX_DISK_SPACE_USAGE,         METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_VR_PATH,                         METADATA_INHERIT,                          IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_VR_PATH                     },
    { MD_VR_USERNAME,                     METADATA_INHERIT,                          IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_VR_USERNAME                 },
    { MD_VR_PASSWORD,                     METADATA_INHERIT | METADATA_SECURE,        IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_VR_PASSWORD                 },
    { MD_VR_ACL,                          METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_FILE,   BINARY_METADATA,  0                                  },
    { MD_VR_UPDATE,                       METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_FILE,   DWORD_METADATA,   0                                  },
    { MD_LOG_TYPE,                        METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_LOG_TYPE                    },
    { MD_LOGFILE_DIRECTORY,               METADATA_INHERIT,                          IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_LOGFILE_DIRECTORY           },
    { MD_LOGFILE_PERIOD,                  METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_LOGFILE_PERIOD              },
    { MD_LOGFILE_TRUNCATE_SIZE,           METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_LOGFILE_TRUNCATE_SIZE       },
    { MD_LOGSQL_DATA_SOURCES,             METADATA_INHERIT,                          IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_LOGSQL_DATA_SOURCES         },
    { MD_LOGSQL_TABLE_NAME,               METADATA_INHERIT,                          IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_LOGSQL_TABLE_NAME           },
    { MD_LOGSQL_USER_NAME,                METADATA_INHERIT,                          IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_LOGSQL_USER_NAME            },
    { MD_LOGSQL_PASSWORD,                 METADATA_INHERIT | METADATA_SECURE,        IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_LOGSQL_PASSWORD             },
    { MD_LOG_PLUGIN_ORDER,                METADATA_INHERIT,                          IIS_MD_UT_SERVER, STRING_METADATA,  IDS_MD_LOG_PLUGIN_ORDER            },
    { MD_LOGEXT_FIELD_MASK,               METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_LOGEXT_FIELD_MASK           },
    { MD_LOGFILE_LOCALTIME_ROLLOVER,      METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_LOGFILE_LOCALTIME_ROLLOVER  },
    { MD_CPU_LOGGING_MASK,                METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_CPU_LOGGING_MASK            },
    { MD_EXIT_MESSAGE,                    METADATA_INHERIT,                          IIS_MD_UT_SERVER, STRING_METADATA,  IDS_MD_EXIT_MESSAGE                },
    { MD_GREETING_MESSAGE,                METADATA_INHERIT,                          IIS_MD_UT_SERVER, MULTISZ_METADATA, IDS_MD_GREETING_MESSAGE            },
    { MD_MAX_CLIENTS_MESSAGE,             METADATA_INHERIT,                          IIS_MD_UT_SERVER, STRING_METADATA,  IDS_MD_MAX_CLIENTS_MESSAGE         },
    { MD_MSDOS_DIR_OUTPUT,                METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_MSDOS_DIR_OUTPUT            },
    { MD_ALLOW_ANONYMOUS,                 METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_ALLOW_ANONYMOUS             },
    { MD_ANONYMOUS_ONLY,                  METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_ANONYMOUS_ONLY              },
    { MD_LOG_ANONYMOUS,                   METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_LOG_ANONYMOUS               },
    { MD_LOG_NONANONYMOUS,                METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_LOG_NONANONYMOUS            },
    { MD_SSL_PUBLIC_KEY,                  METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, BINARY_METADATA,  0                                  },
    { MD_SSL_PRIVATE_KEY,                 METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, BINARY_METADATA,  0                                  },
    { MD_SSL_KEY_PASSWORD,                METADATA_SECURE,                           IIS_MD_UT_SERVER, BINARY_METADATA,  0                                  },
    { MD_SSL_CERT_HASH,                   METADATA_INHERIT,                          IIS_MD_UT_SERVER, BINARY_METADATA,  0                                  },
    { MD_SSL_CERT_STORE_NAME,             METADATA_INHERIT,                          IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_SSL_CTL_IDENTIFIER,              METADATA_INHERIT,                          IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_SSL_CTL_STORE_NAME,              METADATA_INHERIT,                          IIS_MD_UT_SERVER, STRING_METADATA,  0                                  },
    { MD_SSL_USE_DS_MAPPER,               METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_SERVER, DWORD_METADATA,   0                                  },
    { MD_AUTHORIZATION,                   METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_AUTHORIZATION               },
    { MD_REALM,                           METADATA_INHERIT,                          IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_REALM                       },
    { MD_HTTP_EXPIRES,                    METADATA_INHERIT,                          IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_HTTP_EXPIRES                },
    { MD_HTTP_PICS,                       METADATA_INHERIT,                          IIS_MD_UT_FILE,   MULTISZ_METADATA, IDS_MD_HTTP_PICS                   },
    { MD_HTTP_CUSTOM,                     METADATA_INHERIT,                          IIS_MD_UT_FILE,   MULTISZ_METADATA, IDS_MD_HTTP_CUSTOM                 },
    { MD_DIRECTORY_BROWSING,              METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_DIRECTORY_BROWSING          },
    { MD_DEFAULT_LOAD_FILE,               METADATA_INHERIT,                          IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_DEFAULT_LOAD_FILE           },
    { MD_CONTENT_NEGOTIATION,             METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_CONTENT_NEGOTIATION         },
    { MD_CUSTOM_ERROR,                    METADATA_INHERIT,                          IIS_MD_UT_FILE,   MULTISZ_METADATA, IDS_MD_CUSTOM_ERROR                },
    { MD_FOOTER_DOCUMENT,                 METADATA_INHERIT,                          IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_FOOTER_DOCUMENT             },
    { MD_FOOTER_ENABLED,                  METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_FOOTER_ENABLED              },
    { MD_HTTP_REDIRECT,                   METADATA_INHERIT,                          IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_HTTP_REDIRECT               },
    { MD_DEFAULT_LOGON_DOMAIN,            METADATA_INHERIT,                          IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_DEFAULT_LOGON_DOMAIN        },
    { MD_LOGON_METHOD,                    METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_LOGON_METHOD                },
    { MD_SCRIPT_MAPS,                     METADATA_INHERIT,                          IIS_MD_UT_FILE,   MULTISZ_METADATA, IDS_MD_SCRIPT_MAPS                 },
    { MD_MIME_MAP,                        METADATA_INHERIT,                          IIS_MD_UT_FILE,   MULTISZ_METADATA, IDS_MD_MIME_MAP                    },
    { MD_ACCESS_PERM,                     METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_ACCESS_PERM                 },
    { MD_IP_SEC,                          METADATA_INHERIT | METADATA_REFERENCE,     IIS_MD_UT_FILE,   BINARY_METADATA,  IDS_MD_IP_SEC                      },
    { MD_ANONYMOUS_USER_NAME,             METADATA_INHERIT,                          IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_ANONYMOUS_USER_NAME         },
    { MD_ANONYMOUS_PWD,                   METADATA_INHERIT | METADATA_SECURE,        IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_ANONYMOUS_PWD               },
    { MD_ANONYMOUS_USE_SUBAUTH,           METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_ANONYMOUS_USE_SUBAUTH       },
    { MD_DONT_LOG,                        METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_DONT_LOG                    },
    { MD_ADMIN_ACL,                       METADATA_INHERIT | METADATA_SECURE | METADATA_REFERENCE,IIS_MD_UT_SERVER, BINARY_METADATA,  IDS_MD_ADMIN_ACL      },
    { MD_SSI_EXEC_DISABLED,               METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_SSI_EXEC_DISABLED           },
    { MD_SSL_ACCESS_PERM,                 METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_SSL_ACCESS_PERM             },
    { MD_NTAUTHENTICATION_PROVIDERS,      METADATA_INHERIT,                          IIS_MD_UT_FILE,   STRING_METADATA,  IDS_MD_NTAUTHENTICATION_PROVIDERS  },
    { MD_SCRIPT_TIMEOUT,                  METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_SCRIPT_TIMEOUT              },
    { MD_CACHE_EXTENSIONS,                METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_CACHE_EXTENSIONS            },
    { MD_CREATE_PROCESS_AS_USER,          METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_CREATE_PROCESS_AS_USER      },
    { MD_CREATE_PROC_NEW_CONSOLE,         METADATA_INHERIT,                          IIS_MD_UT_SERVER, DWORD_METADATA,   IDS_MD_CREATE_PROC_NEW_CONSOLE     },
    { MD_POOL_IDC_TIMEOUT,                METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_POOL_IDC_TIMEOUT            },
    { MD_ALLOW_KEEPALIVES,                METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_ALLOW_KEEPALIVES            },
    { MD_IS_CONTENT_INDEXED,              METADATA_INHERIT,                          IIS_MD_UT_FILE,   DWORD_METADATA,   IDS_MD_IS_CONTENT_INDEXED          },
    { MD_ISM_ACCESS_CHECK,                METADATA_NO_ATTRIBUTES,                    IIS_MD_UT_FILE,   DWORD_METADATA,   0                                  },
    { MD_ASP_BUFFERINGON,                 METADATA_INHERIT,                          ASP_MD_UT_APP,    DWORD_METADATA,   IDS_ASP_BUFFERINGON                },
    { MD_ASP_LOGERRORREQUESTS,            METADATA_INHERIT,                          IIS_MD_UT_WAM,    DWORD_METADATA,   IDS_ASP_LOGERRORREQUESTS           },
    { MD_ASP_SCRIPTERRORSSENTTOBROWSER,   METADATA_INHERIT,                          ASP_MD_UT_APP,    DWORD_METADATA,   IDS_ASP_SCRIPTERRORSSENTTOBROWSER  },
    { MD_ASP_SCRIPTERRORMESSAGE,          METADATA_INHERIT,                          ASP_MD_UT_APP,    STRING_METADATA,  IDS_ASP_SCRIPTERRORMESSAGE         },
    { MD_ASP_SCRIPTFILECACHESIZE,         METADATA_INHERIT,                          IIS_MD_UT_WAM,    DWORD_METADATA,   IDS_ASP_SCRIPTFILECACHESIZE        },
    { MD_ASP_SCRIPTENGINECACHEMAX,        METADATA_INHERIT,                          IIS_MD_UT_WAM,    DWORD_METADATA,   IDS_ASP_SCRIPTENGINECACHEMAX       },
    { MD_ASP_SCRIPTTIMEOUT,               METADATA_INHERIT,                          ASP_MD_UT_APP,    DWORD_METADATA,   IDS_ASP_SCRIPTTIMEOUT              },
    { MD_ASP_SESSIONTIMEOUT,              METADATA_INHERIT,                          ASP_MD_UT_APP,    DWORD_METADATA,   IDS_ASP_SESSIONTIMEOUT             },
    { MD_ASP_ENABLEPARENTPATHS,           METADATA_INHERIT,                          ASP_MD_UT_APP,    DWORD_METADATA,   IDS_ASP_ENABLEPARENTPATHS          },
    { MD_ASP_ALLOWSESSIONSTATE,           METADATA_INHERIT,                          ASP_MD_UT_APP,    DWORD_METADATA,   IDS_ASP_ALLOWSESSIONSTATE          },
    { MD_ASP_SCRIPTLANGUAGE,              METADATA_INHERIT,                          ASP_MD_UT_APP,    STRING_METADATA,  IDS_ASP_SCRIPTLANGUAGE             },
    { MD_ASP_EXCEPTIONCATCHENABLE,        METADATA_INHERIT,                          IIS_MD_UT_WAM,    DWORD_METADATA,   IDS_ASP_EXCEPTIONCATCHENABLE       },
    { MD_ASP_ENABLESERVERDEBUG,           METADATA_INHERIT,                          ASP_MD_UT_APP,    DWORD_METADATA,   IDS_ASP_ENABLESERVERDEBUG          },
    { MD_ASP_ENABLECLIENTDEBUG,           METADATA_INHERIT,                          ASP_MD_UT_APP,    DWORD_METADATA,   IDS_ASP_ENABLECLIENTDEBUG          },
};



#define NUM_ENTRIES (sizeof(CMetaKey::s_rgMetaTable) / sizeof(CMetaKey::s_rgMetaTable[0]))



/* static */
int
CMetaKey::MapMDIDToTableIndex(
    IN DWORD dwID
    )
/*++

Routine Description:

    Map MD id value to table index.  Return -1 if not found

Arguments:

    DWORD dwID : MD id value

Return Value:

    Index into the table that coresponds to the MD id value

--*/
{
#ifdef _DEBUG

    {
        //
        // Do a quick verification that our metadata
        // table is sorted correctly.
        //
        static BOOL fTableChecked = FALSE;

        if (!fTableChecked)
        {
            for (int n = 1; n < NUM_ENTRIES; ++n)
            {
                if (s_rgMetaTable[n].dwMDIdentifier
                    <= s_rgMetaTable[n - 1].dwMDIdentifier)
                {
                    TRACEEOLID("MD ID Table is out of order: Item is "
                        << n
                        << " "
                        << s_rgMetaTable[n].dwMDIdentifier
                        );
                    ASSERT(FALSE);
                }
            }

            //
            // But only once.
            //
            ++fTableChecked;
        }
    }

#endif // _DEBUG

    //
    // Look up the ID in the table using a binary search
    //
    int nRange = NUM_ENTRIES;
    int nLow = 0;
    int nHigh = nRange - 1;
    int nMid;
    int nHalf;

    while (nLow <= nHigh)
    {
        if (nHalf = nRange / 2)
        {
            nMid = nLow + (nRange & 1 ? nHalf : (nHalf - 1));

            if (s_rgMetaTable[nMid].dwMDIdentifier == dwID)
            {
                return nMid;
            }
            else if (s_rgMetaTable[nMid].dwMDIdentifier > dwID)
            {
                nHigh = --nMid;
                nRange = nRange & 1 ? nHalf : nHalf - 1;
            }
            else
            {
                nLow = ++nMid;
                nRange = nHalf;
            }
        }
        else if (nRange)
        {
            return s_rgMetaTable[nLow].dwMDIdentifier == dwID ? nLow : -1;
        }
        else
        {
            break;
        }
    }

    return -1;
}



/* static */
BOOL
CMetaKey::GetMDFieldDef(
    IN  DWORD dwID,
    OUT DWORD & dwMDIdentifier,
    OUT DWORD & dwMDAttributes,
    OUT DWORD & dwMDUserType,
    OUT DWORD & dwMDDataType
    )
/*++

Routine Description:

    Get information about metabase property

Arguments:

    DWORD dwID                  : Meta ID
    DWORD & dwMDIdentifier      : Meta parms
    DWORD & dwMDAttributes      : Meta parms
    DWORD & dwMDUserType        : Meta parms
    DWORD & dwMDDataType        : Meta parms

Return Value:

    TRUE for success, FALSE for failure.

--*/
{
    int nID = MapMDIDToTableIndex(dwID);

    if (nID == -1)
    {
        //
        // Unrecognized meta data ID
        //
        ASSERT(FALSE);
        return FALSE;
    }

    dwMDIdentifier = s_rgMetaTable[nID].dwMDIdentifier;
    dwMDAttributes = s_rgMetaTable[nID].dwMDAttributes;
    dwMDUserType   = s_rgMetaTable[nID].dwMDUserType;
    dwMDDataType   = s_rgMetaTable[nID].dwMDDataType;

    return TRUE;
}



/* static */
BOOL
CMetaKey::IsPropertyInheritable(
    IN DWORD dwID
    )
/*++

Routine Description:

    Check to see if the given property is inheritable

Arguments:

    DWORD dwID      : Metabase ID

Return Value:

    TRUE if the metabase ID is inheritable, FALSE otherwise.

--*/
{
    int nID = MapMDIDToTableIndex(dwID);

    if (nID == -1)
    {
        //
        // Unrecognized meta data ID
        //
        ASSERT(FALSE);
        return FALSE;
    }

    return (s_rgMetaTable[nID].dwMDAttributes & METADATA_INHERIT) != 0;
}



/* static */
BOOL
CMetaKey::GetPropertyDescription(
    IN  DWORD dwID,
    OUT CString & strName
    )
/*++

Routine Description:

    Get a description for the given property

Arguments:

    DWORD dwID          : Property ID
    CString & strName     : Returns friendly property name

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    int nID = MapMDIDToTableIndex(dwID);

    if (nID == -1)
    {
        //
        // Unrecognized meta data ID
        //
        ASSERT(FALSE);

        return FALSE;
    }

    UINT uID = s_rgMetaTable[nID].uStringID;

#ifndef _COMSTATIC

    HINSTANCE hOld = ::AfxGetResourceHandle();
    ::AfxSetResourceHandle(GetModuleHandle(COMPROP_DLL_NAME));

#endif // _COMSTATIC

    BOOL fResult = TRUE;

    if (uID > 0)
    {
        fResult = (strName.LoadString(uID) != 0);
    }
    else
    {
        //
        // Don't have a friendly name -- fake it
        //
        CString strFmt;
        VERIFY(strFmt.LoadString(IDS_INHERITANCE_NO_NAME));

        strName.Format(strFmt, dwID);
    }

#ifndef _COMSTATIC

    ::AfxSetResourceHandle(hOld);

#endif // _COMSTATIC

    return fResult;
}



/* static */
void
CMetaKey::SplitMetaPath(
    IN  LPCTSTR lpPath,
    OUT CString & strParent,
    OUT CString & strAlias
    )
/*++

Routine Description:

    Split the given path into parent metabase root and alias

Arguments:

    LPCTSTR lpPath      : Input path
    CString & strParent : Outputs the parent path
    CString & strAlias  : Outputs the alias name

Return Value:

    None.

--*/
{
    TRACEEOLID("Source Path " << lpPath);

    strParent = lpPath;
    strAlias.Empty();

    int cSlash = strParent.ReverseFind(g_chSep);
    ASSERT(cSlash >= 0);

    if (cSlash >= 0)
    {
        strAlias = strParent.Mid(++cSlash);
        strParent.ReleaseBuffer(--cSlash);
    }

    TRACEEOLID("Broken up into " << strParent);
    TRACEEOLID("           and " << strAlias);
}



/* static */
void
CMetaKey::SplitMetaPathAtInstance(
    IN  LPCTSTR lpPath,
    OUT CString & strParent,
    OUT CString & strAlias
    )
/*++

Routine Description:

    Split the given path into parent metabase root and alias, with the root
    being the instance path, and the alias everything following the
    instance.

Arguments:

    LPCTSTR lpPath      : Input path
    CString & strParent : Outputs the parent path
    CString & strAlias  : Outputs the alias name

Return Value:

    None.

--*/
{
    TRACEEOLID("Source Path " << lpPath);

    strParent = lpPath;
    strAlias.Empty();

    LPTSTR lp = strParent.GetBuffer(0);
    ASSERT(lp);
    int cSeparators = 0;
    int iChar = 0;

    //
    // Looking for "LM/sss/ddd/" <-- 3d slash:
    //
    while (*lp && cSeparators < 2)
    {
        if (*lp++ == g_chSep)
        {
            ++cSeparators;
        }

        ++iChar;
    }

    if (!*lp)
    {
        //
        // Bogus format
        //
        ASSERT(FALSE);
        return;
    }

    if (_istdigit(*lp))
    {
        //
        // Not at the master instance, skip one more.
        //
        while (*lp)
        {
            ++iChar;

            if (*lp++ == g_chSep)
            {
                break;
            }
        }

        if (!*lp)
        {
            //
            // Bogus format
            //
            ASSERT(FALSE);
            return;
        }
    }

    strAlias = strParent.Mid(iChar);
    strParent.ReleaseBuffer(--iChar);

    TRACEEOLID("Broken up into " << strParent);
    TRACEEOLID("           and " << strAlias);
}



/* static */
LPCTSTR
CMetaKey::BuildMetaPath(
    OUT CString & strPath,
    IN  LPCTSTR lpSvc            OPTIONAL,
    IN  DWORD   dwInstance       OPTIONAL,
    IN  LPCTSTR lpParentPath     OPTIONAL,
    IN  LPCTSTR lpAlias          OPTIONAL
    )
/*++

Routine Description:

    Build a complete metapath with the given service name, instance
    number and optional path components.

Arguments:

    CString & strPath       : Destination path
    LPCTSTR lpSvc           : Service (may be NULL or "")
    DWORD   dwInstance      : Instance number (may be 0 for master)
    LPCTSTR lpParentPath    : Parent path (may be NULL or "")
    LPCTSTR lpAlias         : Alias (may be NULL or "")

Return Value:

    Pointer to internal buffer containing the path.

--*/
{
    try
    {
        strPath = s_cszMachine;

        if (lpSvc && *lpSvc)
        {
            strPath += s_cszSep;
            strPath += lpSvc;
        }

        ASSERT(dwInstance >= 0);
        if (dwInstance != MASTER_INSTANCE)
        {
            TCHAR szInstance[] = _T("4000000000");

            strPath += s_cszSep;
            _ltot(dwInstance, szInstance, 10);
            strPath += szInstance;
        }

        if (lpParentPath && *lpParentPath)
        {
            strPath += s_cszSep;
            strPath += lpParentPath;
        }

        if (lpAlias && *lpAlias)
        {
            //
            // Special case: If the alias is root, but we're
            // at the master instance, ignore this.
            //
            if (dwInstance != MASTER_INSTANCE ||
                lstrcmpi(s_cszRoot, lpAlias) != 0)
            {
                strPath += s_cszSep;
                strPath += lpAlias;
            }
        }

        TRACEEOLID("Generated metapath: " << strPath);
    }
    catch(CMemoryException * e)
    {
        strPath.Empty();
        e->ReportError();
        e->Delete();
    }

    return strPath;
}



/* static */
LPCTSTR
CMetaKey::ConvertToParentPath(
    OUT IN CString & strMetaPath
    )
/*++

Routine Description:

    Given the path, convert it to the parent path
    e.g. "foo/bar/etc" returns "foo/bar"

Arguments:

    CString & strMetaPath    : Path to be converted

Return value:

    Pointer to the converted path, or NULL in case of error

--*/
{
    TRACEEOLID("Getting parent path of " << strMetaPath);

    LPTSTR lpszPath = strMetaPath.GetBuffer(1);
    LPTSTR lpszTail = lpszPath + lstrlen(lpszPath) - 1;
    LPTSTR lpszReturn = NULL;

    do
    {
        if (lpszTail <= lpszPath)
        {
            break;
        }

        //
        // Strip trailing backslash
        //
        if (*lpszTail == s_chSep)
        {
            *lpszTail-- = _T('\0');
        }

        //
        // Search for parent
        //
        while (lpszTail > lpszPath && *lpszTail != s_chSep)
        {
            --lpszTail;
        }

        if (lpszTail <= lpszPath)
        {
            break;
        }

        *lpszTail = _T('\0');

        lpszReturn = lpszPath;
    }
    while(FALSE);

    strMetaPath.ReleaseBuffer();

    TRACEEOLID("Parent path should be " << strMetaPath);

    return lpszReturn;
}



/* static */
void
CMetaKey::ConvertToParentPath(
    IN OUT CString & strService,
    IN OUT DWORD & dwInstance,
    IN OUT CString & strParent,
    IN OUT CString & strAlias
    )
/*++

Routine Description:

    Change the input parameters so that they are valid
    for the immediate parent of the path described

Arguments:

    CString & strService        : Service name
    DWORD & dwInstance          : Instance number
    CString & strParent         : Parent path
    CString & strAlias          : Node name

Return Value:

    None

--*/
{
    if (!strAlias.IsEmpty())
    {
        strAlias.Empty();
    }
    else
    {
        if (!strParent.IsEmpty())
        {
            int nSep = strParent.ReverseFind(g_chSep);

            if (nSep >= 0)
            {
                strParent.ReleaseBuffer(nSep);
            }
            else
            {
                strParent.Empty();
            }
        }
        else
        {
            if (dwInstance != MASTER_INSTANCE)
            {
                dwInstance = MASTER_INSTANCE;
            }
            else
            {
                strService.Empty();    
            }
        }
    }
}



/* static */
BOOL 
CMetaKey::IsHomeDirectoryPath(
    IN LPCTSTR lpszMetaPath
    )
/*++

Routine Description:

    Determine if the path given describes a root directory

Arguments:

    LPCTSTR lpszMetaPath        : Metabase path

Return Value:

    TRUE if the path describes a root directory, 
    FALSE if it does not

--*/
{
    ASSERT(lpszMetaPath != NULL);

    LPTSTR lpNode = _tcsrchr(lpszMetaPath, s_chSep);

    if (lpNode)
    {
        return _tcsicmp(++lpNode, g_cszRoot) == 0;
    }

    return FALSE;
}



/* static */
LPCTSTR
CMetaKey::CleanMetaPath(
    IN OUT CString & strMetaRoot
    )
/*++

Routine Description:

    Clean up the metabase path to one valid for internal consumption.
    This removes the beginning and trailing slashes off the path

Arguments:

    CString & strMetaRoot       : Metabase path to be cleaned up.

Return Value:

    Pointer to the metabase path

--*/
{
    TRACEEOLID("Dirty metapath: " << strMetaRoot);

    if (!strMetaRoot.IsEmpty())
    {
        if (strMetaRoot[strMetaRoot.GetLength() - 1] == SZ_MBN_SEP_CHAR)
        {
            strMetaRoot.ReleaseBuffer(strMetaRoot.GetLength() - 1);
        }

        if (strMetaRoot[0] == SZ_MBN_SEP_CHAR)
        {
            strMetaRoot = strMetaRoot.Right(strMetaRoot.GetLength() - 1);
        }
    }
    TRACEEOLID("Clean metapath: " << strMetaRoot);

    return strMetaRoot;
}



CMetaKey::CMetaKey(
    IN LPCTSTR lpszServerName OPTIONAL
    )
/*++

Routine Description:

    Constructor that creates the interface, but does not open the key.
    This is the ONLY constructor that allows operations from
    METDATA_MASTER_ROOT_HANDLE (read operations obviously)

Arguments:

    LPCTSTR lpszServerName  : If NULL, opens interface on local machine

Return Value:

    N/A

--*/
    : CMetaInterface(lpszServerName),
      m_hKey(METADATA_MASTER_ROOT_HANDLE),
      m_hBase(NULL),
      m_hrKey(S_OK),
      m_dwFlags(0L),
      m_cbInitialBufferSize(MB_INIT_BUFF_SIZE),
      m_strMetaPath(),
      m_fAllowRootOperations(TRUE),
      m_fOwnKey(TRUE)
{
    m_hrKey = CMetaInterface::QueryResult(); 
    //
    // Do not open key
    //
}



CMetaKey::CMetaKey(
    IN const CMetaInterface * pInterface
    )
/*++

Routine Description:

    Construct with pre-existing interface.  Does not
    open any keys

Arguments:

    CMetaInterface * pInterface       : Preexisting interface

Return Value:

    N/A

--*/
    : CMetaInterface(pInterface),
      m_hKey(NULL),
      m_hBase(NULL),
      m_strMetaPath(),
      m_dwFlags(0L),
      m_cbInitialBufferSize(MB_INIT_BUFF_SIZE),
      m_fAllowRootOperations(TRUE),
      m_fOwnKey(TRUE)
{
    m_hrKey = CMetaInterface::QueryResult(); 
}        



CMetaKey::CMetaKey(
    IN LPCTSTR lpszServerName,      
    IN DWORD dwFlags,               
    IN METADATA_HANDLE hkBase,
    IN LPCTSTR lpszMDPath
    )
/*++

Routine Description:

    Fully defined constructor that opens a key

Arguments:

    LPCTSTR lpszServerName  : Server name
    DWORD   dwFlags         : Open permissions
    METADATA_HANDLE hkBase  : Base key
    LPCTSTR lpszMDPath      : Path or NULL

Return Value:

    N/A

--*/
    : CMetaInterface(lpszServerName),
      m_hKey(NULL),
      m_hBase(NULL),
      m_dwFlags(0L),
      m_cbInitialBufferSize(MB_INIT_BUFF_SIZE),
      m_fAllowRootOperations(FALSE),
      m_strMetaPath(),
      m_fOwnKey(TRUE)
{
    m_hrKey = CMetaInterface::QueryResult(); 

    if (SUCCEEDED(m_hrKey))
    {
        m_hrKey = Open(dwFlags, hkBase, lpszMDPath);
    }
}



CMetaKey::CMetaKey(
    IN const CMetaInterface * pInterface,
    IN DWORD dwFlags,               
    IN METADATA_HANDLE hkBase,
    IN LPCTSTR lpszMDPath
    )
/*++

Routine Description:

    Fully defined constructor that opens a key

Arguments:

    CMetaInterface * pInterface : Existing interface
    DWORD   dwFlags             : Open permissions
    METADATA_HANDLE hkBase      : Base key
    LPCTSTR lpszMDPath          : Path or NULL

Return Value:

    N/A

--*/
    : CMetaInterface(pInterface),
      m_hKey(NULL),
      m_hBase(NULL),
      m_strMetaPath(),
      m_dwFlags(0L),
      m_cbInitialBufferSize(MB_INIT_BUFF_SIZE),
      m_fAllowRootOperations(FALSE),
      m_fOwnKey(TRUE)
{
    m_hrKey = CMetaInterface::QueryResult(); 

    if (SUCCEEDED(m_hrKey))
    {
        m_hrKey = Open(dwFlags, hkBase, lpszMDPath);
    }
}



CMetaKey::CMetaKey(
    IN LPCTSTR lpszServerName,
    IN DWORD   dwFlags,         
    IN LPCTSTR lpSvc,               OPTIONAL
    IN DWORD   dwInstance,          OPTIONAL
    IN LPCTSTR lpParentPath,        OPTIONAL
    IN LPCTSTR lpAlias              OPTIONAL
    )
/*++

Routine Description:

    Constructor with path components

Arguments:

    LPCTSTR lpszServerName  : Server name
    DWORD   dwFlags         : Open permissions
    LPCTSTR lpSvc           : Service name or NULL
    DWORD   dwInstance,     : Instance number of 0
    LPCTSTR lpParentPath    : Parent path or NULL
    LPCTSTR lpAlias         : Alias name or NULL

Return Value:

    N/A

--*/
    : CMetaInterface(lpszServerName),
      m_hKey(NULL),
      m_hBase(NULL),
      m_strMetaPath(),
      m_dwFlags(0L),
      m_cbInitialBufferSize(MB_INIT_BUFF_SIZE),
      m_fAllowRootOperations(FALSE),
      m_fOwnKey(TRUE)
{
    m_hrKey = CMetaInterface::QueryResult(); 

    if (SUCCEEDED(m_hrKey))
    {
        m_hrKey = Open(dwFlags, lpSvc, dwInstance, lpParentPath, lpAlias);
    }
}        



CMetaKey::CMetaKey(
    IN const CMetaInterface * pInterface,
    IN DWORD   dwFlags,         
    IN LPCTSTR lpSvc,               OPTIONAL
    IN DWORD   dwInstance,          OPTIONAL
    IN LPCTSTR lpParentPath,        OPTIONAL
    IN LPCTSTR lpAlias              OPTIONAL
    )
/*++

Routine Description:

    Constructor with path components

Arguments:

    CMetaInterface * pInterface : Existing interface
    DWORD   dwFlags             : Open permissions
    LPCTSTR lpSvc               : Service name or NULL
    DWORD   dwInstance,         : Instance number of 0
    LPCTSTR lpParentPath        : Parent path or NULL
    LPCTSTR lpAlias             : Alias name or NULL

Return Value:

    N/A

--*/
    : CMetaInterface(pInterface),
      m_hKey(NULL),
      m_hBase(NULL),
      m_dwFlags(0L),
      m_cbInitialBufferSize(MB_INIT_BUFF_SIZE),
      m_fAllowRootOperations(FALSE),
      m_strMetaPath(),
      m_fOwnKey(TRUE)
{
    m_hrKey = CMetaInterface::QueryResult(); 

    if (SUCCEEDED(m_hrKey))
    {
        m_hrKey = Open(dwFlags, lpSvc, dwInstance, lpParentPath, lpAlias);
    }
}        



CMetaKey::CMetaKey(
    IN BOOL  fOwnKey,
    IN const CMetaKey * pKey
    )
/*++

Routine Description:

    Copy constructor. 

Arguments:

    BOOL  fOwnKey               : TRUE to take ownership of the key
    const CMetaKey * pKey       : Existing key

Return Value:

    N/A

--*/
    : CMetaInterface(pKey),
      m_hKey(pKey->m_hKey),
      m_hBase(pKey->m_hBase),
      m_dwFlags(pKey->m_dwFlags),
      m_cbInitialBufferSize(pKey->m_cbInitialBufferSize),
      m_fAllowRootOperations(pKey->m_fAllowRootOperations),
      m_hrKey(pKey->m_hrKey),
      m_strMetaPath(pKey->m_strMetaPath),
      m_fOwnKey(fOwnKey)
{
    //
    // No provisions for anything else at the moment
    //
    ASSERT(!m_fOwnKey);
}



CMetaKey::~CMetaKey()
/*++

Routine Description:

    Destructor -- Close the key.

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    if (IsOpen() && m_fOwnKey)
    {
        Close();
    }
}



/* virtual */
BOOL 
CMetaKey::Succeeded() const
/*++

Routine Description:

    Determine if object was constructed successfully

Arguments:

    None

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    return SUCCEEDED(m_hrKey);
}



/* virtual */
HRESULT 
CMetaKey::QueryResult() const
/*++

Routine Description:

    Return the construction error for this object

Arguments:

    None

Return Value:

    HRESULT from construction errors

--*/
{
    return m_hrKey;
}



HRESULT 
CMetaKey::Open(
    IN DWORD dwFlags,                
    IN METADATA_HANDLE hkBase,      
    IN LPCTSTR lpszMDPath          OPTIONAL
    )
/*++

Routine Description:

    Attempt to open a metabase key

Arguments:

    METADATA_HANDLE hkBase  : Base metabase key
    LPCTSTR lpszMDPath      : Optional path
    DWORD dwFlags           : Permission flags

Return Value:

    HRESULT

--*/
{
    ASSURE_PROPER_INTERFACE();

    if (m_hKey != NULL)
    {
        TRACEEOLID("Attempting to open key that already has an open handle");
        ASSERT(FALSE);

        TRACEEOLID("Closing that key");
        Close();
    }

    //
    // Base key is stored for reopen purposes only
    //
    m_hBase = hkBase;
    m_strMetaPath = lpszMDPath;
    m_dwFlags = dwFlags;

    return OpenKey(m_hBase, m_strMetaPath, m_dwFlags, &m_hKey);
}



HRESULT 
CMetaKey::Open(
    IN DWORD   dwFlags,      
    IN LPCTSTR lpSvc,        OPTIONAL
    IN DWORD   dwInstance,   OPTIONAL    
    IN LPCTSTR lpParentPath, OPTIONAL
    IN LPCTSTR lpAlias       OPTIONAL
    )
/*++

Routine Description:

    Build metapath from components, and open key

Arguments:


Return Value:

    HRESULT

--*/
{
    m_hBase = METADATA_MASTER_ROOT_HANDLE;
    BuildMetaPath(m_strMetaPath, lpSvc, dwInstance, lpParentPath, lpAlias);

    return Open(dwFlags, m_hBase, m_strMetaPath);
}



HRESULT
CMetaKey::ConvertToParentPath(
    IN  BOOL fImmediate
    )
/*++

Routine Description:

    Change the path to the parent path.

Arguments:

    BOOL fImmediate     : If TRUE, the immediate parent's path will be used
                          if FALSE, the first parent that really exists

Return Value:

    HRESULT

        ERROR_INVALID_PARAMETER if there is no valid path

--*/
{
    BOOL fIsOpen = IsOpen();

    if (fIsOpen)
    {
        Close();
    }

    CError err;

    FOREVER
    {
        if (!ConvertToParentPath(m_strMetaPath))
        {
            //
            // There is no parent path
            //
            err = ERROR_INVALID_PARAMETER;
            break;
        }

        err = ReOpen();

        //
        // Path not found is the only valid error
        // other than success.
        //
        if (fImmediate 
            || err.Succeeded() 
            || err.Win32Error() != ERROR_PATH_NOT_FOUND)
        {
            break;
        }
    }

    //
    // Remember to reset the construction error
    // which referred to the parent path.
    //
    m_hrKey = err;

    return err;
}



HRESULT 
CMetaKey::CreatePathFromFailedOpen()
/*++

Routine Description:

    If the path doesn't exist, create it.  This method should be
    called after an Open call failed (because it will have initialized
    m_strMetaPath.

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CString strParentPath;
    CString strObjectName;
    CString strSavePath(m_strMetaPath);

    SplitMetaPathAtInstance(
        m_strMetaPath, 
        strParentPath, 
        strObjectName
        );

    CError err(Open(
        METADATA_PERMISSION_WRITE,
        METADATA_MASTER_ROOT_HANDLE,
        strParentPath
        ));

    if (err.Succeeded())
    {
        //
        // This really should never fail, because we're opening
        // the path at the instance.
        //
        err = AddKey(strObjectName);
    }

    if (IsOpen())
    {
        Close();
    }

    //
    // The previous open wiped out the path...
    //
    m_strMetaPath = strSavePath;

    return err;
}



HRESULT
CMetaKey::Close()
/*++

Routine Description:

    Close the currently open key.

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    ASSURE_PROPER_INTERFACE();

    HRESULT hr = S_OK;

    ASSERT(m_hKey != NULL);
    ASSERT(m_fOwnKey);

    if (m_hKey)
    {
        hr = CloseKey(m_hKey);

        if (SUCCEEDED(hr))
        {
            m_hKey = NULL;
        }
    }

    return hr;
}



/* protected */
HRESULT
CMetaKey::GetPropertyValue(
    IN  DWORD dwID,
    OUT IN DWORD & dwSize,               OPTIONAL
    OUT IN void *& pvData,               OPTIONAL
    OUT IN DWORD * pdwDataType,          OPTIONAL
    IN  BOOL * pfInheritanceOverride,    OPTIONAL
    IN  LPCTSTR lpszMDPath,              OPTIONAL
    OUT DWORD * pdwAttributes            OPTIONAL
    )
/*++

Routine Description:

    Get metadata on the currently open key.

Arguments:

    DWORD dwID                      : Property ID number
    DWORD & dwSize                  : Buffer size (could be 0)
    void *& pvData                  : Buffer -- will allocate if NULL
    DWORD * pdwDataType             : NULL or on in  contains valid data types,
                                    :         on out contains actual data type
    BOOL * pfInheritanceOverride    : NULL or on forces inheritance on/off
    LPCTSTR lpszMDPath              : Optional path off the open key
    DWORD * pdwAttributes           : Optionally returns attributes    

Return Value:

    HRESULT 

    ERROR_INVALID_HANDLE        : If the handle is not open
    ERROR_INVALID_PARAMETER     : If the property id is not found,
                                  or the data type doesn't match requested type
    ERROR_OUTOFMEMORY           : Out of memory

--*/
{
    ASSURE_PROPER_INTERFACE();
    ASSURE_OPEN_KEY();

    METADATA_RECORD mdRecord;
    FETCH_PROPERTY_DATA_OR_FAIL(dwID, mdRecord);

    //
    // If unable to find this property ID in our table, or
    // if we specified a desired type, and this type doesn't 
    // match it, give up.
    //
    if (pdwDataType && *pdwDataType != ALL_METADATA 
        && *pdwDataType != mdRecord.dwMDDataType)
    {
        ASSERT(FALSE);
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    //
    // Check to see if inheritance behaviour is overridden
    //
    if (pfInheritanceOverride)
    {
        if (*pfInheritanceOverride)
        {
            mdRecord.dwMDAttributes |= METADATA_INHERIT;
        }
        else
        {
            mdRecord.dwMDAttributes &= ~METADATA_INHERIT;
        }
    }

    //
    // This causes a bad parameter error on input otherwise
    //
    mdRecord.dwMDAttributes &= ~METADATA_REFERENCE;

    //
    // If we're looking for inheritable properties, the path
    // doesn't have to be completely specified.
    //
    if (mdRecord.dwMDAttributes & METADATA_INHERIT)
    {
        mdRecord.dwMDAttributes |= (METADATA_PARTIAL_PATH | METADATA_ISINHERITED);
    }

    ASSERT(dwSize > 0 || pvData == NULL);
    
    mdRecord.dwMDDataLen = dwSize;
    mdRecord.pbMDData = (LPBYTE)pvData;

    //
    // If no buffer provided, allocate one.
    //
    HRESULT hr = S_OK;
    BOOL fBufferTooSmall;
    BOOL fAllocatedMemory = FALSE;
    DWORD dwInitSize = m_cbInitialBufferSize;

    do
    {
        if(mdRecord.pbMDData == NULL)
        {
            mdRecord.dwMDDataLen = dwInitSize;
            mdRecord.pbMDData = (LPBYTE)AllocMem(dwInitSize);

            if(mdRecord.pbMDData == NULL && dwInitSize > 0)
            {
                hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
                break;
            }

            ++fAllocatedMemory;
        }

        //
        // Get the data
        //
        DWORD dwRequiredDataLen = 0;
        hr = GetData(m_hKey, lpszMDPath, &mdRecord, &dwRequiredDataLen);

        //
        // Re-fetch the buffer if it's too small.
        //
        fBufferTooSmall = 
            (HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER) && fAllocatedMemory;

        if(fBufferTooSmall)
        {
            //
            // Delete the old buffer, and set up for a re-fetch.
            //
            FreeMem(mdRecord.pbMDData);
            mdRecord.pbMDData = NULL;
            dwInitSize = dwRequiredDataLen;
        }
    }
    while(fBufferTooSmall);

    //
    // Failed
    //
    if(FAILED(hr) && fAllocatedMemory)
    {
        FreeMem(mdRecord.pbMDData);
        mdRecord.pbMDData = NULL;
    }

    dwSize = mdRecord.dwMDDataLen;
    pvData = mdRecord.pbMDData;

    if (pdwDataType != NULL)
    {
        //
        // Return actual data type
        //
        *pdwDataType = mdRecord.dwMDDataType;
    }

    if (pdwAttributes != NULL)
    {
        //
        // Return data attributes
        //
        *pdwAttributes =  mdRecord.dwMDAttributes;
    }

    return hr;
}



/* protected */
HRESULT 
CMetaKey::GetDataPaths( 
    OUT CStringListEx & strlDataPaths,
    IN  DWORD dwMDIdentifier,
    IN  DWORD dwMDDataType,
    IN  LPCTSTR lpszMDPath              OPTIONAL
    )
/*++

Routine Description:

    Get data paths

Arguments:


Return Value:

    HRESULT

--*/
{
    ASSURE_PROPER_INTERFACE();
    ASSURE_OPEN_KEY();

    //
    // Start with a small buffer
    //
    DWORD  dwMDBufferSize = 1024;
    LPTSTR lpszBuffer = NULL;
    CError err;

    do
    {
        if (lpszBuffer != NULL)
        {
            FreeMem(lpszBuffer);
        }

        lpszBuffer = AllocTString(dwMDBufferSize);

        if (lpszBuffer == NULL)
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        err = CMetaInterface::GetDataPaths(
            m_hKey,
            lpszMDPath,
            dwMDIdentifier,
            dwMDDataType,
            dwMDBufferSize,
            lpszBuffer,
            &dwMDBufferSize
            );
    }
    while(err.Win32Error() == ERROR_INSUFFICIENT_BUFFER);

    if (err.Succeeded() && (err.Win32Error() == ERROR_PATH_NOT_FOUND))
    {
        //
        // That's ok... this is some sort of physical directory
        // that doesn't currently exist in the metabase, and
        // which therefore doesn't have any descendants anyway.
        //
        ZeroMemory(lpszBuffer, dwMDBufferSize);
        err.Reset();
    }

    if (err.Succeeded())
    {
        ConvertDoubleNullListToStringList(lpszBuffer, strlDataPaths);
        FreeMem(lpszBuffer);
    }

    return err;
}



HRESULT
CMetaKey::CheckDescendants(
    IN DWORD   dwID,
    IN LPCTSTR lpszServer,
    IN LPCTSTR lpszMDPath       OPTIONAL
    )
/*++

Routine Description:

    Check for descendant overrides;  If there are any, bring up a dialog
    that displays them, and give the user the opportunity the remove
    the overrides.

Arguments:

    DWORD dwID          : Property ID

Return Value:

    HRESULT

--*/
{
    ASSURE_PROPER_INTERFACE();

    HRESULT hr = S_OK;

    METADATA_RECORD mdRecord;
    FETCH_PROPERTY_DATA_OR_FAIL(dwID, mdRecord);

    if (mdRecord.dwMDAttributes & METADATA_INHERIT)
    {
        CStringListEx strlDataPaths;

        hr = GetDataPaths( 
            strlDataPaths,
            mdRecord.dwMDIdentifier,
            mdRecord.dwMDDataType,
            lpszMDPath
            );

        if (SUCCEEDED(hr) && !strlDataPaths.IsEmpty())
        {
            CInheritanceDlg dlg(
                dwID,
                FROM_WRITE_PROPERTY,
                lpszServer,
                lpszMDPath,
                strlDataPaths
                );

            if (!dlg.IsEmpty())
            {
                dlg.DoModal();
            }
        }
    }

    return hr;
}



/* protected */
HRESULT
CMetaKey::SetPropertyValue(
    IN DWORD dwID,
    IN DWORD dwSize,
    IN void * pvData,
    IN BOOL * pfInheritanceOverride,    OPTIONAL
    IN LPCTSTR lpszMDPath               OPTIONAL
    )
/*++

Routine Description:

    Set metadata on the open key.  The key must have been opened with
    write permission.

Arguments:

    DWORD dwID                      : Property ID
    DWORD dwSize                    : Size of data
    void * pvData                   : Data buffer
    BOOL * pfInheritanceOverride    : NULL or forces inheritance on/off
    LPCTSTR lpszMDPath              : Optional path off the open key

Return Value:

    HRESULT 

    ERROR_INVALID_HANDLE            : If the handle is not open
    ERROR_INVALID_PARAMETER         : If the property id is not found,
                                      or the buffer is NULL or of size 0

--*/
{
    ASSURE_PROPER_INTERFACE();
    ASSURE_OPEN_KEY();

    if (pvData == NULL && dwSize != 0)
    {
        ASSERT(FALSE);
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    METADATA_RECORD mdRecord;
    FETCH_PROPERTY_DATA_OR_FAIL(dwID, mdRecord);

    if (pfInheritanceOverride)
    {
        if (*pfInheritanceOverride)
        {
            mdRecord.dwMDAttributes |= METADATA_INHERIT;
        }
        else
        {
            mdRecord.dwMDAttributes &= ~METADATA_INHERIT;
        }
    }

    mdRecord.dwMDDataLen = dwSize;
    mdRecord.pbMDData = (LPBYTE)pvData;

    return SetData(m_hKey, lpszMDPath, &mdRecord);
}



/* protected */
HRESULT 
CMetaKey::GetAllData(
    IN  DWORD dwMDAttributes,
    IN  DWORD dwMDUserType,
    IN  DWORD dwMDDataType,
    OUT DWORD * pdwMDNumEntries,
    OUT DWORD * pdwMDDataLen,
    OUT PBYTE * ppbMDData,
    IN  LPCTSTR lpszMDPath              OPTIONAL
    )
/*++

Routine Description:

    Get all data off the open key.  Buffer is created automatically.

Arguments:

    DWORD dwMDAttributes            : Attributes
    DWORD dwMDUserType              : User type to fetch
    DWORD dwMDDataType              : Data type to fetch
    DWORD * pdwMDNumEntries         : Returns number of entries read
    DWORD * pdwMDDataLen            : Returns size of data buffer
    PBYTE * ppbMDData               : Returns data buffer
    LPCTSTR lpszMDPath              : Optional data path        

Return Value:

    HRESULT

--*/
{
    ASSURE_PROPER_INTERFACE();
    ASSURE_OPEN_KEY();

    //
    // Check for valid parameters
    //
    if(!pdwMDDataLen || !ppbMDData || !pdwMDNumEntries)
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    HRESULT hr = S_OK;
    BOOL fBufferTooSmall;
    DWORD dwMDDataSetNumber;
    DWORD dwRequiredBufferSize;
    DWORD dwInitSize = m_cbInitialBufferSize;
    *ppbMDData = NULL;

    do
    {
        *pdwMDDataLen = dwInitSize;
        *ppbMDData = (LPBYTE)AllocMem(dwInitSize);

        if (ppbMDData == NULL && dwInitSize > 0)
        {
            hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
            break;
        }

        hr = CMetaInterface::GetAllData(
            m_hKey,
            lpszMDPath,
            dwMDAttributes,
            dwMDUserType,
            dwMDDataType,
            pdwMDNumEntries,
            &dwMDDataSetNumber,
            *pdwMDDataLen,
            *ppbMDData,
            &dwRequiredBufferSize
            );

        //
        // Re-fetch the buffer if it's too small.
        //
        fBufferTooSmall = (HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER);

        if(fBufferTooSmall)
        {
            //
            // Delete the old buffer, and set up for a re-fetch.
            //
            SAFE_FREEMEM(*ppbMDData);
            dwInitSize = dwRequiredBufferSize;
        }
    }
    while (fBufferTooSmall);

    if (FAILED(hr))
    {
        //
        // No good, be sure we don't leak anything
        //
        SAFE_FREEMEM(*ppbMDData);
        dwInitSize = 0L;
    }

    return hr;
}



HRESULT
CMetaKey::QueryValue(
    IN  DWORD dwID,
    IN  OUT DWORD & dwValue,
    IN  BOOL * pfInheritanceOverride, OPTIONAL
    IN  LPCTSTR lpszMDPath,           OPTIONAL
    OUT DWORD * pdwAttributes         OPTIONAL
    )
/*++

Routine Description:

    Fetch data as a DWORD

Arguments:

    DWORD dwID                      : Property ID
    DWORD & dwValue                 : Returns the value read in
    BOOL * pfInheritanceOverride    : NULL or forces inheritance on/off
    LPCTSTR lpszMDPath              : Optional path off the open key
    DWORD * pdwAttributes           : Optionally returns attributes    

Return Value:

    HRESULT

--*/
{
    DWORD dwSize = sizeof(dwValue);
    DWORD dwDataType = DWORD_METADATA;
    void * pvData = &dwValue;

    return GetPropertyValue(
        dwID, 
        dwSize, 
        pvData, 
        &dwDataType, 
        pfInheritanceOverride,
        lpszMDPath,
        pdwAttributes
        );
}



HRESULT
CMetaKey::QueryValue(
    IN  DWORD dwID,
    IN  OUT CString & strValue,
    IN  BOOL * pfInheritanceOverride, OPTIONAL
    IN  LPCTSTR lpszMDPath,           OPTIONAL
    OUT DWORD * pdwAttributes         OPTIONAL
    )
/*++

Routine Description:

    Fetch data as a string

Arguments:

    DWORD dwID                      : Property ID
    DWORD & strValue                : Returns the value read in
    BOOL * pfInheritanceOverride    : NULL or forces inheritance on/off
    LPCTSTR lpszMDPath              : Optional path off the open key
    DWORD * pdwAttributes           : Optionally returns attributes    

Return Value:

    HRESULT

--*/
{
    //
    // Get GetData allocate the buffer for us
    //
    DWORD dwSize = 0;
    DWORD dwDataType = ALL_METADATA;
    LPTSTR lpData = NULL;

    HRESULT hr = GetPropertyValue(
        dwID, 
        dwSize, 
        (void *&)lpData, 
        &dwDataType,
        pfInheritanceOverride,
        lpszMDPath,
        pdwAttributes
        );

    if (SUCCEEDED(hr))
    {
        //
        // Notes: consider optional auto-expansion on EXPANDSZ_METADATA
        // (see registry functions), and data type conversions for DWORD
        // or MULTISZ_METADATA or BINARY_METADATA
        //
        if (dwDataType == EXPANDSZ_METADATA || dwDataType == STRING_METADATA)
        {
            try
            {
                strValue = lpData;
            }
            catch(CMemoryException * e)
            {
                hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
                strValue.Empty();
                e->Delete();
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        }
    }

    if (lpData)
    {
        FreeMem(lpData);
    }

    return hr;
}



HRESULT
CMetaKey::QueryValue(
    IN  DWORD dwID,
    IN  OUT CStringListEx & strlValue,
    IN  BOOL * pfInheritanceOverride, OPTIONAL
    IN  LPCTSTR lpszMDPath,           OPTIONAL
    OUT DWORD * pdwAttributes         OPTIONAL
    )
/*++

Routine Description:

    Fetch data as a stringlist

Arguments:

    DWORD dwID                      : Property ID
    DWORD & strlValue               : Returns the value read in
    BOOL * pfInheritanceOverride    : NULL or forces inheritance on/off
    LPCTSTR lpszMDPath              : Optional path off the open key
    DWORD * pdwAttributes           : Optionally returns attributes    

Return Value:

    HRESULT

--*/
{
    //
    // Get GetData allocate the buffer for us
    //
    DWORD dwSize = 0;
    DWORD dwDataType = MULTISZ_METADATA;
    LPTSTR lpData = NULL;

    HRESULT hr = GetPropertyValue(
        dwID, 
        dwSize, 
        (void *&)lpData, 
        &dwDataType,
        pfInheritanceOverride,
        lpszMDPath,
        pdwAttributes
        );

    if (SUCCEEDED(hr))
    {
        //
        // Notes: Consider accepting a single STRING
        //
        ASSERT(dwDataType == MULTISZ_METADATA);

        DWORD err = ConvertDoubleNullListToStringList(
            lpData,
            strlValue,
            dwSize / sizeof(TCHAR)
            );
        hr = HRESULT_FROM_WIN32(err);
    }

    if (lpData)
    {
        FreeMem(lpData);
    }

    return hr;
}



HRESULT
CMetaKey::QueryValue(
    IN  DWORD dwID,
    IN  OUT CBlob & blValue,
    IN  BOOL * pfInheritanceOverride, OPTIONAL
    IN  LPCTSTR lpszMDPath,           OPTIONAL
    OUT DWORD * pdwAttributes         OPTIONAL
    )
/*++

Routine Description:

    Fetch data as a binary blob

Arguments:

    DWORD dwID                      : Property ID
    DWORD CBlob & blValue           : Returns the binary blob
    BOOL * pfInheritanceOverride    : NULL or forces inheritance on/off
    LPCTSTR lpszMDPath              : Optional path off the open key
    DWORD * pdwAttributes           : Optionally returns attributes    

Return Value:

    HRESULT

--*/
{
    //
    // Get GetData allocate the buffer for us
    //
    DWORD dwSize = 0;
    DWORD dwDataType = BINARY_METADATA;
    LPBYTE pbData = NULL;

    HRESULT hr = GetPropertyValue(
        dwID, 
        dwSize, 
        (void *&)pbData, 
        &dwDataType,
        pfInheritanceOverride,
        lpszMDPath,
        pdwAttributes
        );

    if (SUCCEEDED(hr))
    {
        //
        // Blob takes ownership of the data, so don't free it...
        //
        ASSERT(pbData != NULL);
        blValue.SetValue(dwSize, pbData, FALSE);
    }

    return hr;
}



HRESULT 
CMetaKey::SetValue(
    IN DWORD dwID,
    IN CStringListEx & strlValue,
    IN BOOL * pfInheritanceOverride,        OPTIONAL
    IN LPCTSTR lpszMDPath                   OPTIONAL
    )
/*++

Routine Description:

    Store data as string

Arguments:

    DWORD dwID                   : Property ID
    CStringListEx & strlValue    : Value to be written
    BOOL * pfInheritanceOverride : NULL or forces inheritance on/off
    LPCTSTR lpszMDPath           : Optional path (or NULL or "")

Return Value:

    HRESULT

--*/
{
    DWORD cCharacters;
    LPTSTR lpstr = NULL;

    //
    // Flatten value
    //
    ConvertStringListToDoubleNullList(
       strlValue,
       cCharacters,
       lpstr
       );

    HRESULT hr = SetPropertyValue(
        dwID,
        cCharacters * sizeof(TCHAR),
        (void *)lpstr,
        pfInheritanceOverride,
        lpszMDPath
        );

    SAFE_FREEMEM(lpstr);

    return hr;
}


HRESULT 
CMetaKey::SetValue(
    IN DWORD dwID,
    IN CBlob & blValue,
    IN BOOL * pfInheritanceOverride,    OPTIONAL     
    IN LPCTSTR lpszMDPath               OPTIONAL        
    )
/*++

Routine Description:

    Store data as binary

Arguments:

    DWORD dwID                   : Property ID
    CBlob & blValue              : Value to be written
    BOOL * pfInheritanceOverride : NULL or forces inheritance on/off
    LPCTSTR lpszMDPath           : Optional path (or NULL or "")

Return Value:

    HRESULT

--*/
{
    return SetPropertyValue(
        dwID,
        blValue.GetSize(),
        (void *)blValue.GetData(),
        pfInheritanceOverride,
        lpszMDPath
        );
}

HRESULT
CMetaKey::DeleteValue(
    DWORD   dwID,
    LPCTSTR lpszMDPath      OPTIONAL
    )
/*++

Routine Description:

    Delete data

Arguments:

    DWORD   dwID            : Property ID of property to be deleted
    LPCTSTR lpszMDPath      : Optional path (or NULL or "")

Return Value:

    HRESULT

--*/
{
    ASSURE_PROPER_INTERFACE();
    ASSURE_OPEN_KEY();

    METADATA_RECORD mdRecord;
    FETCH_PROPERTY_DATA_OR_FAIL(dwID, mdRecord);

    return DeleteData(
        m_hKey,
        lpszMDPath,
        mdRecord.dwMDIdentifier,
        mdRecord.dwMDDataType
        );
}



HRESULT 
CMetaKey::DoesPathExist(
    IN LPCTSTR lpszMDPath
    )
/*++

Routine Description:

    Determine if the path exists

Arguments:

    LPCTSTR lpszMDPath      : Relative path off the open key

Return Value:

    HRESULT, or S_OK if the path exists.

--*/
{
    ASSURE_PROPER_INTERFACE();
    ASSURE_OPEN_KEY();

    FILETIME ft;

    return GetLastChangeTime(m_hKey, lpszMDPath, &ft, FALSE);
}



//
// CMetaEnumerator Clas
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

CMetaEnumerator::CMetaEnumerator(
    IN LPCTSTR lpszServerName,
    IN LPCTSTR lpSvc,            OPTIONAL
    IN DWORD   dwInstance,       OPTIONAL
    IN LPCTSTR lpParentPath,     OPTIONAL
    IN LPCTSTR lpAlias           OPTIONAL
    )
/*++

Routine Description:

    Construct a new interface

Arguments:

    LPCTSTR lpszServerName  : Server name
    LPCTSTR lpSvc           : Service name or NULL
    DWORD   dwInstance,     : Instance number of 0
    LPCTSTR lpParentPath    : Parent path or NULL
    LPCTSTR lpAlias         : Alias name or NULL

Return Value:

    N/A

--*/
    : CMetaKey(
        lpszServerName, 
        METADATA_PERMISSION_READ,
        lpSvc, 
        dwInstance, 
        lpParentPath, 
        lpAlias
        ),
      m_dwIndex(0L)
{
}



CMetaEnumerator::CMetaEnumerator(
    IN CMetaInterface * pInterface,
    IN LPCTSTR lpSvc,            OPTIONAL
    IN DWORD   dwInstance,       OPTIONAL
    IN LPCTSTR lpParentPath,     OPTIONAL
    IN LPCTSTR lpAlias           OPTIONAL
    )
/*++

Routine Description:

    Construct with existing interface

Arguments:

    CMetaInterface * pInterface : Interface
    LPCTSTR lpSvc               : Service name or NULL
    DWORD   dwInstance,         : Instance number of 0
    LPCTSTR lpParentPath        : Parent path or NULL
    LPCTSTR lpAlias             : Alias name or NULL

Return Value:

    N/A

--*/
    : CMetaKey(
        pInterface, 
        METADATA_PERMISSION_READ,
        lpSvc, 
        dwInstance, 
        lpParentPath, 
        lpAlias
        ),
      m_dwIndex(0L)
{
}



HRESULT
CMetaEnumerator::Next(
    OUT CString & strKey,
    IN  LPCTSTR lpszMDPath      OPTIONAL
    )
/*++

Routine Description:

    Get the next subkey

Arguments:

    CString & str           Returns keyname
    LPCTSTR lpszMDPath      Optional subpath

Return Value:

    HRESULT

--*/
{
    ASSURE_PROPER_INTERFACE();
    ASSURE_OPEN_KEY();

    LPTSTR lpKey = strKey.GetBuffer(MAX_PATH);
    HRESULT hr = EnumKeys(m_hKey, lpszMDPath, lpKey, m_dwIndex++);
    strKey.ReleaseBuffer();

    return hr;        
}



HRESULT
CMetaEnumerator::Next(
    OUT DWORD & dwKey,
    IN  LPCTSTR lpszMDPath      OPTIONAL
    )
/*++

Routine Description:

    Get the next subkey as a DWORD.  This skips non-numeric
    keynames (including 0) until the first numeric key name 

Arguments:

    DWORD & dwKey           Numeric key
    LPCTSTR lpszMDPath      Optional subpath

Return Value:

    HRESULT

--*/
{
    ASSURE_PROPER_INTERFACE();
    ASSURE_OPEN_KEY();

    HRESULT hr;
    BOOL fContinue = TRUE;

    CString strKey;

    while (fContinue)
    {
        fContinue = FALSE;

        LPTSTR lpKey = strKey.GetBuffer(MAX_PATH);
        hr = EnumKeys(m_hKey, lpszMDPath, lpKey, m_dwIndex++);
        strKey.ReleaseBuffer();

        if (SUCCEEDED(hr))
        {
            if (!(dwKey = _ttoi((LPCTSTR)strKey)))
            {
                //
                // Ignore this one
                //
                fContinue = TRUE;
            }
        }
    }
    
    return hr;        
}



//
// CIISApplication class
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<</



CIISApplication::CIISApplication(
    IN LPCTSTR lpszServer,
    IN LPCTSTR lpszMetapath
    )
/*++

Routine Description:

    Constructor.  Create the interfaces, and fetch the state

Arguments:

    LPCTSTR lpszServer      : Server name
    LPCTSTR lpszMetapath    : Metabase path

Return Value:

    N/A

--*/
    : CWamInterface(lpszServer),
      CMetaKey(lpszServer),
      m_dwProcessProtection(APP_INPROC),
      m_dwAppState(APPSTATUS_NOTDEFINED),
      m_strFriendlyName(),
      m_strAppRoot(),
      m_strWamPath(lpszMetapath)
{
    CommonConstruct();
}



CIISApplication::CIISApplication(
    IN LPCTSTR lpszServer,
    IN LPCTSTR lpSvc,
    IN DWORD   dwInstance,
    IN LPCTSTR lpParentPath,        OPTIONAL
    IN LPCTSTR lpAlias              OPTIONAL
    )
/*++

Routine Description:

    Constructor.  Create the interfaces, and fetch the state

Arguments:

    LPCTSTR lpszServer      : Server name
    LPCTSTR lpSvc           : Service (may be NULL or "")
    DWORD   dwInstance      : Instance number (may be 0 for master)
    LPCTSTR lpParentPath    : Parent path (may be NULL or "")
    LPCTSTR lpAlias         : Alias (may be NULL or "")

Return Value:

    N/A

--*/
    : CWamInterface(lpszServer),
      CMetaKey(lpszServer),
      m_dwProcessProtection(APP_INPROC),
      m_dwAppState(APPSTATUS_NOTDEFINED),
      m_strFriendlyName(),
      m_strAppRoot()
{
    BuildMetaPath(m_strWamPath, lpSvc, dwInstance, lpParentPath, lpAlias);
    CommonConstruct();
}



void
CIISApplication::CommonConstruct()
/*++

Routine Description:

    Perform common construction

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Munge the metapath so that WAM doesn't cough up a hairball.
    //
    if (m_strWamPath[0] != SZ_MBN_SEP_CHAR)
    {
        m_strWamPath = SZ_MBN_SEP_CHAR + m_strWamPath;
    }

    do
    {
        m_hrApp = CWamInterface::QueryResult();

        if (FAILED(m_hrApp))
        {
            break;
        }

        m_hrApp = RefreshAppState();

        if (HRESULT_CODE(m_hrApp) == ERROR_PATH_NOT_FOUND)
        {
            //
            // "Path Not Found" errors are acceptable, since
            // the application may not yet exist.
            //
            m_hrApp = S_OK;
        }
    }
    while(FALSE);
}



/* virtual */
BOOL 
CIISApplication::Succeeded() const
/*++

Routine Description:

    Determine if object was constructed successfully

Arguments:

    None

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    return CMetaInterface::Succeeded() 
        && CWamInterface::Succeeded()
        && SUCCEEDED(m_hrApp);
}



/* virtual */
HRESULT 
CIISApplication::QueryResult() const
/*++

Routine Description:

    Return the construction error for this object

Arguments:

    None

Return Value:

    HRESULT from construction errors

--*/
{
    //
    // Both interfaces must have constructed successfully
    //
    HRESULT hr = CMetaInterface::QueryResult();

    if (SUCCEEDED(hr))
    {
        hr = CWamInterface::QueryResult();

        if (SUCCEEDED(hr))
        {
            hr = m_hrApp;
        }
    }    

    return hr;
}



HRESULT 
CIISApplication::RefreshAppState()
/*++

Routine Description:

    Refresh the application state

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    ASSERT(!m_strWamPath.IsEmpty());

    HRESULT hr, hrKeys;

    hr = AppGetStatus(m_strWamPath, &m_dwAppState);

    if (FAILED(hr))
    {
        m_dwAppState = APPSTATUS_NOTDEFINED;
    }

    m_strAppRoot.Empty();
    hrKeys = QueryValue(MD_APP_ROOT, m_strAppRoot, NULL, m_strWamPath);

    m_dwProcessProtection = APP_INPROC;
    hrKeys = QueryValue(
        MD_APP_ISOLATED, 
        m_dwProcessProtection, 
        NULL, 
        m_strWamPath
        );

    m_strFriendlyName.Empty();
    hrKeys = QueryValue(
        MD_APP_FRIENDLY_NAME, 
        m_strFriendlyName, 
        NULL, 
        m_strWamPath
        );

    return hr;
}



HRESULT 
CIISApplication::Create(
    IN LPCTSTR lpszName,        OPTIONAL
    IN DWORD dwAppProtection
    )
/*++

Routine Description:

    Create the application

Arguments:

    LPCTSTR lpszName      : Application name
    DWORD dwAppProtection : APP_INPROC     to create in-proc app
                            APP_OUTOFPROC  to create out-of-proc app
                            APP_POOLEDPROC to create a pooled-proc app

Return Value:

    HRESULT

--*/
{
    ASSERT(!m_strWamPath.IsEmpty());
    HRESULT hr = AppCreate(m_strWamPath, dwAppProtection);

    if (SUCCEEDED(hr))
    {
        //
        // Write the friendly app name, which we maintain
        // ourselves.  Empty it first, because we might
        // have picked up a name from inheritance.
        //
        m_strFriendlyName.Empty(); 
        hr = WriteFriendlyName(lpszName);

        RefreshAppState();
    }

    return hr;
}



HRESULT 
CIISApplication::WriteFriendlyName(
    IN LPCTSTR lpszName
    )
/*++

Routine Description:

    Write the friendly name.  This will not write anything
    if the name is the same as it was

Arguments:

    LPCTSTR lpszName        : New friendly name

Return Value:

    HRESULT

--*/
{
    HRESULT hr = S_OK;    

    if (m_strFriendlyName.CompareNoCase(lpszName) != 0)
    {
        hr = Open(
            METADATA_PERMISSION_WRITE, 
            METADATA_MASTER_ROOT_HANDLE,
            m_strWamPath
            );

        if (SUCCEEDED(hr))
        {
            ASSERT(lpszName != NULL);

            CString str(lpszName);    
            hr = SetValue(MD_APP_FRIENDLY_NAME, str);
            Close();

            if (SUCCEEDED(hr))
            {
                m_strFriendlyName = lpszName;
            }
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\comprop\mime.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        mime.h

   Abstract:

        Mime mapping dialog

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

#ifndef _MIME_H_
#define _MIME_H_




class COMDLL CMimeEditDlg : public CDialog
/*++

Class Description:

    MIME editor dialog.

Public Interface:

    CMimeEditDlg  : MIME editor dialog constructor

--*/
{
//
// Construction
//
public:
    //
    // Create new  mime mapping constructor
    //
    CMimeEditDlg(
        IN CWnd * pParent = NULL
        );   

    //
    // Constructor to edit existing MIME mapping
    //
    CMimeEditDlg(
        IN LPCTSTR lpstrExt,
        IN LPCTSTR lpstrMime,
        IN CWnd * pParent = NULL
        );

//
// Dialog Data
//
public:
    //{{AFX_DATA(CMimeEditDlg)
    enum { IDD = IDD_MIME_PROPERTY };
    CButton m_button_Ok;
    CEdit   m_edit_Mime;
    CEdit   m_edit_Extent;
    //}}AFX_DATA

    CString m_strMime;
    CString m_strExt;

//
// Overrides
//
protected:
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CMimeEditDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //
    // Enable/disable controls depending on window status
    //
    void SetControlStates();

    //
    // Extentions must start with a dot, add it if it isn't there
    //
    void CleanExtension(
        IN OUT CString & strExtension
        );

    // Generated message map functions
    //{{AFX_MSG(CMimeEditDlg)
    virtual BOOL OnInitDialog();
    virtual void OnOK();
    //}}AFX_MSG

    afx_msg void OnItemChanged();

    DECLARE_MESSAGE_MAP()
};




class COMDLL CMimeDlg : public CDialog
/*++

Class Description:

    MIME listings dialog

Public Interface:

    CMimeDlg : Constructor for the dialog

--*/
{
//
// Construction
//
public:
    CMimeDlg(
        IN CStringListEx & strlMimeTypes,
        IN CWnd * pParent = NULL
        );  

//
// Dialog Data
//
protected:
    //
    // Build the MIME list from the listbox
    //
    void FillFromListBox();

    //
    // Fill the listbox from the list of MIME types
    //
    void FillListBox();

    //
    // Enable/disable control states depending on dialog data
    //
    void SetControlStates();

    //
    // Build a listbox-suitable display string for the mime type
    //
    void BuildDisplayString(
       IN  CString & strExt,
       IN  CString & strMime,
       OUT CString & strOut
       );

    //
    // As above, but use a metabase internal formatted string for input
    //
    BOOL BuildDisplayString(
        IN  CString & strIn,
        OUT CString & strOut
        );

    //
    // Build a string in the metabase internal format for this mime type
    //
    void BuildMetaString(
       IN  CString & strExt,
       IN  CString & strMime,
       OUT CString & strOut
       );

    //
    // Given the listbox suitable display string, break it in extension
    // and MIME type strings
    //
    BOOL CrackDisplayString(
        IN  CString & strIn,
        OUT CString & strExt,
        OUT CString & strMime
        );

    //
    // Find a MIME entry for the given extension, or return -1 if not found
    //
    int FindMimeType(
        IN const CString & strTargetExt
        );

    //{{AFX_DATA(CMimeDlg)
    enum { IDD = IDD_MIME_TYPES };
    CEdit    m_edit_Extention;
    CEdit    m_edit_ContentType;
    CButton  m_button_Remove;
    CButton  m_button_Edit;
    CButton  m_button_Ok;
    //}}AFX_DATA

    CStringListEx & m_strlMimeTypes;
    CRMCListBox   m_list_MimeTypes;

//
// Overrides
//
protected:
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CMimeDlg)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    // Generated message map functions
    //{{AFX_MSG(CMimeDlg)
    virtual BOOL OnInitDialog();
    afx_msg void OnButtonEdit();
    afx_msg void OnButtonNewType();
    afx_msg void OnButtonRemove();
    afx_msg void OnDblclkListMimeTypes();
    afx_msg void OnSelchangeListMimeTypes();
    virtual void OnOK();
    //}}AFX_MSG

    afx_msg void OnItemChanged();

    DECLARE_MESSAGE_MAP()


private:
    BOOL m_fDirty;
};


//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline void CMimeEditDlg::CleanExtension(
    IN OUT CString & strExtension
    )
{
    if (strExtension[0] != _T('.'))
    {
        strExtension = _T('.') + strExtension;
    }
}

inline void CMimeDlg::BuildDisplayString(
   IN  CString & strExt,
   IN  CString & strMime,
   OUT CString & strOut
   )
{
    strOut.Format(_T("%s\t%s"), (LPCTSTR)strExt, (LPCTSTR)strMime);
}

inline void CMimeDlg::BuildMetaString(
   IN  CString & strExt,
   IN  CString & strMime,
   OUT CString & strOut
   )
{
    strOut.Format(_T("%s,%s"), (LPCTSTR)strExt, (LPCTSTR)strMime);
}

#endif // _MIME_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\comprop\msg.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        msg.h

   Abstract:

        Message Functions Definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

#ifndef _MSG_H
#define _MSG_H


//
// Helper macro to override an error message until the
// end of the current scope.
//
#define TEMP_ERROR_OVERRIDE(hr, nID)\
    CErrorOverride err##hr##to##nID##__LINE__(hr, nID)

//
// Slightly easier syntax to register a facility
//
#define REGISTER_FACILITY(dwCode, lpSource)\
    CError::RegisterFacility(dwCode, lpSource)


//
// Helper Function
//
COMDLL HRESULT GetLastHRESULT();

typedef struct tagFACILITY
{
    LPCTSTR lpszDll;
    UINT    nTextID;
} FACILITY;






typedef CMap<DWORD, DWORD &, CString, CString &> CMapDWORDtoCString;
typedef CMap<HRESULT, HRESULT &, UINT, UINT &>   CMapHRESULTtoUINT;



class COMDLL CError
/*++

Class Description:

    Error handling class, works for both HRESULT and old-style DWORD
    error codes.  Construct with or assign a DWORD or HRESULT error
    return code, and the object can then be used to determine success
    or failure, and the object provides text for the error code either
    directly, in a message, or formatted with additional text.  Also,
    the CError object understands the range of winsock errors and
    lanman errors, and looks for them in the appropriate places.
    The object can be referenced as a BOOL, a DWORD, an HRESULT, or
    a LPCTSTR as a success/failure, a WIN32 error, and HRESULT or
    the text equivalent respectively.

    Example of typical programme flow:

    //
    // Use IDS_MY_ERROR for access denied errors for the
    // duration of this scope.
    //
    TEMP_ERROR_OVERRIDE(ERROR_ACCESS_DENIED, IDS_MY_ERROR);

    CError err(FunctionWhichReturnsHresult());
    if (!err.MessageBoxOnFailure())
    {
        //
        // If we failed, this already displayed the error
        // message in a messagebox.  Only when we succeed
        // we get here.
        //
        ... stuff ...
    }

    SomeWinApiWhichSetsLastError();
    err.GetLastWinError();
    if (err.Failed())
    {
        printf("WIN32 Error code %ld\nHRESULT %ld\nText: %s\n",
            (DWORD)err,
            (HRESULT)err,
            (LPCTSTR)err
            );
    }

Public Interface:

    TextFromHRESULT         : Convert HRESULT to text
    TextFromHRESULTExpand   : Expand %h string to error text, %H to error code
    MessageBox              : Display error in a messagebox
    MessageBoxFormat        : Use %h string as format in messagebox
    MessageBoxOnFailure     : Display message if error is a failure
    MessageBoxLastError     : Display last error in a messagebox
    AddOverride             : Add message override with string ID
    RemoveOverride          : Remove message override
    RegisterFacility        : Register facility
    UnregisterFacility      : Unregister facility
    Succeeded               : Determine if the error code indicates a success
    Failed                  : Determine if the error code indicates a failure

    CError                  : Constructors
    Reset                   : Reset error code
    GetLastWinError         : Assign internal code to GetLastError
    SetLastWinError         : Set last error from internal code

    operator =              : Assignment operators
    operator ==             : Comparison operators
    operator !=             : Comparison operators
    operator HRESULT        : Conversion operator
    operator DWORD          : Conversion operator
    operator BOOL           : Conversion operator
    operator LPCTSTR        : Conversion operator

--*/
{
#define IS_HRESULT(hr)  (hr & 0xffff0000)
#define REMOVE_OVERRIDE ((UINT)-1)
#define NO_HELP_CONTEXT ((UINT)-1)
#define USE_LAST_ERROR  (TRUE)

//
// Private Internal FACILITY codes
//
#define FACILITY_WINSOCK    (0xffe)
#define FACILITY_LANMAN     (0xfff)

//
// Static Helpers
//
public:
    //
    // Success/Failure determinants, works regardless
    // of whether hrCode is a DWORD or HRESULT
    //
    static BOOL Succeeded(HRESULT hrCode);
    static BOOL Failed(HRESULT hrCode);

    //
    // Convert to text
    //
    static HRESULT TextFromHRESULT(
        IN  HRESULT hrCode,
        OUT LPTSTR  szBuffer,
        OUT DWORD   cchBuffer
        );

    //
    // As above, with a CString
    //
    static HRESULT TextFromHRESULT(
        IN  HRESULT hrCode,
        OUT CString & strBuffer
        );

    //
    // Expand %h to error message from hrcode
    //
    static LPCTSTR TextFromHRESULTExpand(
        IN  HRESULT hrCode,
        OUT LPTSTR  szBuffer,
        OUT DWORD   cchBuffer,
        OUT HRESULT * phResult = NULL
        );

    //
    // As above with CString
    //
    static LPCTSTR TextFromHRESULTExpand(
        IN  HRESULT hrCode,
        OUT CString & strBuffer
        );

    //
    // Display text in error messagebox
    //
    static int MessageBox(
        IN HRESULT hrCode,
        IN UINT    nType = MB_OK,
        IN UINT    nHelpContext = NO_HELP_CONTEXT
        );

    //
    // Display last error in messagebox
    //
    static int MessageBoxLastError(
        IN UINT nType = MB_OK,
        IN UINT nHelpContext = NO_HELP_CONTEXT
        );

    //
    // Guarantee return is WIN32 error code
    //
    static DWORD Win32Error(HRESULT hrCode) { return HRESULT_CODE(hrCode); }

    //
    // Guarantee return is a true HRESULT
    //
    static HRESULT HResult(HRESULT hrCode) { return HRESULT_FROM_WIN32(hrCode); }

    //
    // Add override for specific error code.
    // Use -1 to remove the override.  This function
    // will return the previous override (or -1)
    //
    static UINT AddOverride(
        IN HRESULT hrCode,
        IN UINT    nMessage = REMOVE_OVERRIDE
        );         

    static void RemoveOverride(
        IN HRESULT hrCode
        );
        
    static void RemoveAllOverrides();   

    //
    // Register a DLL for a given facility code.
    // Use NULL to unregister the facility
    //
    static void RegisterFacility(
        IN DWORD dwFacility,
        IN LPCSTR lpDLL = NULL
        );

    static void UnregisterFacility(
        IN DWORD dwFacility
        );

//
// Constructor/Destructor
//
public:
    //
    // If constructed with TRUE, the object is initialized to
    // last error.  It's set to ERROR_SUCCESS otherwise (default case)
    //
    CError(BOOL fUseLastError = FALSE);
    CError(HRESULT hrCode);
    CError(DWORD dwCode);
    ~CError();

//
// Helpers
//
public:
    BOOL Succeeded() const { return SUCCEEDED(m_hrCode); }
    BOOL Failed() const { return FAILED(m_hrCode); }

    HRESULT TextFromHRESULT(
        OUT LPTSTR szBuffer,
        OUT DWORD  cchBuffer
        ) const;

    HRESULT TextFromHRESULT(
        OUT CString & strMsg
        );

    LPCTSTR TextFromHRESULTExpand(
        OUT LPTSTR  szBuffer,
        OUT DWORD   cchBuffer,
        OUT HRESULT * phResult = NULL
        );

    LPCTSTR TextFromHRESULTExpand(
        OUT CString & strBuffer
        );

    int MessageBox(
        IN UINT nType = MB_OK,
        IN UINT nHelpContext = NO_HELP_CONTEXT
        ) const;

    BOOL MessageBoxOnFailure(
        IN UINT nType = MB_OK,
        IN UINT nHelpContext = NO_HELP_CONTEXT
        ) const;

    int MessageBoxFormat(
        IN UINT nFmt,
        IN UINT nType,
        IN UINT nHelpContext,
        ...
        ) const;

    void Reset();
    void GetLastWinError();
    void SetLastWinError() const;
    DWORD Win32Error() const;
    HRESULT HResult() const { return m_hrCode; }

//
// Assignment Operators
//
public:
    const CError & operator =(HRESULT hr);
    const CError & operator =(const CError & err);

// 
// Comparison Operators
//
public:
    const BOOL operator ==(HRESULT hr);
    const BOOL operator ==(CError & err);
    const BOOL operator !=(HRESULT hr);
    const BOOL operator !=(CError & err);

//
// Conversion Operators
//
public:
    operator const HRESULT() const { return m_hrCode; }
    operator const DWORD() const;
    operator const BOOL() const;
    operator LPCTSTR();

#ifdef _DEBUG  

public:
    //
    // CDumpContext stream operator
    //
    inline friend CDumpContext & AFXAPI operator <<(
        IN OUT CDumpContext & dc,
        IN const CError & value
        )
    {
        return dc << (DWORD)value.m_hrCode;
    }

#endif // _DEBUG

protected:
    static HRESULT CvtToInternalFormat(HRESULT hrCode);

    //
    // Expand escape code
    //
    static BOOL ExpandEscapeCode(
        IN  LPTSTR szBuffer,
        IN  DWORD cchBuffer,
        OUT IN LPTSTR & lp,
        IN  CString & strReplacement,
        OUT HRESULT & hr
        );

    //
    // Check for override message
    //
    static BOOL HasOverride(
        IN  HRESULT hrCode, 
        OUT UINT * pnMessage = NULL
        );

    //
    // Check for FACILITY dll
    //
    static LPCTSTR FindFacility(
        IN DWORD dwFacility
        );

protected:
    friend BOOL InitErrorFunctionality();
    friend void TerminateErrorFunctionality();
    static BOOL AllocateStatics();
    static void DeAllocateStatics();
    static BOOL AreStaticsAllocated() { return s_fAllocated; }

protected:
    static const TCHAR s_chEscape;    // Escape character
    static const TCHAR s_chEscText;   // Escape code for text
    static const TCHAR s_chEscNumber; // Escape code for error code
    static LPCTSTR s_cszLMDLL;        // Lanman Message DLL
    static LPCTSTR s_cszWSDLL;        // Winsock Message DLL
    static LPCTSTR s_cszFacility[];   // Facility Table
    static HRESULT s_cdwMinLMErr;     // Lanman Error Range
    static HRESULT s_cdwMaxLMErr;     // Lanman Error Range
    static HRESULT s_cdwMinWSErr;     // Winsock Error Range
    static HRESULT s_cdwMaxWSErr;     // Winsock Error Range
    static DWORD   s_cdwFacilities;   // Number of facility items

    //
    // Allocated objects 
    //
    static CString * s_pstrDefError;  // Default Error String
    static CString * s_pstrDefSuccs;  // Default Success String
    static CMapDWORDtoCString * s_pmapFacilities;
    static CMapHRESULTtoUINT  * s_pmapOverrides;
    static BOOL s_fAllocated;

protected:
    const CError & Construct(HRESULT hr);
    const CError & Construct(const CError & err);

private:
    HRESULT m_hrCode;
    CString * m_pstrBuff;
};



class COMDLL CErrorOverride
/*++

Class Description:

    Error override class -- restores the override on destructor
    see TEMP_ERROR_OVERRIDE macro below

Public Interface:

    CErrorOverride  : Constructor

--*/
{
public:
    CErrorOverride(HRESULT hr, UINT nID);
    ~CErrorOverride();

private:
    HRESULT m_hrCode;
    UINT m_nPrev;
};



//
// Inline Expansions
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline HRESULT GetLastHRESULT()
{
    return CError::HResult(::GetLastError());
}

inline /* static */ BOOL CError::Succeeded(HRESULT hrCode)
{
    //
    // Works with either HRESULT or WIN32 error code
    //
    return IS_HRESULT(hrCode)
        ? SUCCEEDED(hrCode)
        : hrCode == ERROR_SUCCESS;
}

inline /* static */ BOOL CError::Failed(HRESULT hrCode)
{
    //
    // Works with either HRESULT or WIN32 error code
    //
    return IS_HRESULT(hrCode)
        ? FAILED(hrCode)
        : hrCode != ERROR_SUCCESS;
}

inline /* static */ int MessageBoxLastError(
    IN UINT nType,
    IN UINT nHelpContext
    )
{
    return CError::MessageBox(
        ::GetLastError(), 
        nType, 
        nHelpContext
        );
}

#if 0

inline /* static */ DWORD CError::Win32Error(
    IN HRESULT hrCode
    )
{
    return HRESULT_CODE(hrCode);
}

inline /* static */ HRESULT CError::HResult(
    IN HRESULT hrCode
    )
{
    //
    // This will leave true HRESULTs intact
    //
    return HRESULT_FROM_WIN32(hrCode);
}
#endif // 0

inline /* static */ void CError::RemoveOverride(
    IN HRESULT hrCode
    )
{
    (void)CError::AddOverride(hrCode, REMOVE_OVERRIDE);
}
        
inline /* static */ void CError::UnregisterFacility(
    IN DWORD dwFacility
    )
{
    RegisterFacility(dwFacility, NULL);
}

inline CError::CError(
    IN BOOL fUseLastError
    )
    : m_pstrBuff(NULL)
{
    Construct(fUseLastError ? ::GetLastError() : ERROR_SUCCESS);
}

inline CError::CError(HRESULT hrCode)
    : m_pstrBuff(NULL)
{
    Construct(hrCode);
}

inline CError::CError(DWORD dwCode)
    : m_pstrBuff(NULL)
{
    Construct((HRESULT)dwCode);
}

inline HRESULT CError::TextFromHRESULT(
    OUT LPTSTR szBuffer,
    OUT DWORD  cchBuffer
    ) const
{
    return CError::TextFromHRESULT(m_hrCode, szBuffer, cchBuffer);
}

inline HRESULT CError::TextFromHRESULT(
    OUT CString & strBuffer
    )
{
    return CError::TextFromHRESULT(m_hrCode, strBuffer);
}

inline LPCTSTR CError::TextFromHRESULTExpand(
    OUT LPTSTR  szBuffer,
    OUT DWORD   cchBuffer,
    OUT HRESULT * phResult
    )
{
    return CError::TextFromHRESULTExpand(
        m_hrCode, 
        szBuffer, 
        cchBuffer, 
        phResult
        );
}

inline LPCTSTR CError::TextFromHRESULTExpand(
    OUT CString & strBuffer
    )
{
    return CError::TextFromHRESULTExpand(m_hrCode, strBuffer);
}

inline int CError::MessageBox(
    IN UINT nType,
    IN UINT nHelpContext
    ) const
{
    return CError::MessageBox(m_hrCode, nType, nHelpContext);
}

inline DWORD CError::Win32Error() const
{
    return CError::Win32Error(m_hrCode);
}

inline void CError::Reset()
{
    m_hrCode = S_OK;
}

inline void CError::GetLastWinError()
{
    Construct(::GetLastError());
}

inline void CError::SetLastWinError() const
{
    ::SetLastError(Win32Error(m_hrCode));
}

inline const CError & CError::operator =(HRESULT hr)
{
    return Construct(hr);
}

inline const CError & CError::operator =(const CError & err)
{
    return Construct(err);
}

inline const BOOL CError::operator ==(HRESULT hr)
{
    return m_hrCode == hr;
}

inline const BOOL CError::operator ==(CError & err)
{
    return m_hrCode == err.m_hrCode;
}

inline const BOOL CError::operator !=(HRESULT hr)
{
    return m_hrCode != hr;
}

inline const BOOL CError::operator !=(CError & err)
{
    return m_hrCode != err.m_hrCode;
}

inline CError::operator const DWORD() const
{
    return Win32Error();
}

inline CError::operator const BOOL() const
{
    return Succeeded();
}

inline CErrorOverride::CErrorOverride(
    IN HRESULT hr,
    IN UINT    nID
    )
    : m_hrCode(hr),
      m_nPrev(CError::AddOverride(hr, nID))
{
}

inline CErrorOverride::~CErrorOverride()
{
    //
    // Restore the old message
    //
    CError::AddOverride(m_hrCode, m_nPrev);
}



//
// Clear text warning dialog
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



class COMDLL CClearTxtDlg : public CDialog
{
/*++

Class Description:

    Dialog which displays the clear text warning

Public Interface:

    CClearTxtDlg : Constructor
    
--*/
public:
    //
    // Constructor
    //
    CClearTxtDlg(CWnd * pParent = NULL);

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CClearTxtDlg)
    enum { IDD = IDD_CLEARTEXTWARNING };
    //}}AFX_DATA

//
// Overrides
//
protected:
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CClearTxtDlg)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    // Generated message map functions
    //{{AFX_MSG(CClearTxtDlg)
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};



//
// AfxMessageBox helpers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline BOOL NoYesMessageBox(UINT nID)
{
    return AfxMessageBox(nID, MB_YESNO|MB_ICONQUESTION|MB_DEFBUTTON2) == IDYES;
}

inline BOOL NoYesMessageBox(CString & str)
{
    return AfxMessageBox(str, MB_YESNO|MB_ICONQUESTION|MB_DEFBUTTON2) == IDYES;
}

inline BOOL YesNoMessageBox(UINT nID)
{
    return AfxMessageBox(nID, MB_YESNO|MB_ICONQUESTION|MB_DEFBUTTON1) == IDYES;
}

inline BOOL YesNoMessageBox(CString & str)
{
    return AfxMessageBox(str, MB_YESNO|MB_ICONQUESTION|MB_DEFBUTTON1) == IDYES;
}

#endif // _MSG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\comprop\objpick.cpp ===
// objpick.cpp: implementation of the CGetUser class and the 
//              CGetComputer class using the object picker
//
//////////////////////////////////////////////////////////////////////
#include "stdafx.h"

#include <iads.h>           
#include <iadsp.h>          // IADsPathname

#include <objsel.h>
#include <adshlp.h>
#include <winsock2.h>
#include <comdef.h>
#include "comprop.h"
#include "objplus.h"
#include "ipaddres.h"

#include "objpick.h"
#include "usrbrows.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif


#define BREAK_ON_FAIL_HRESULT(hr)       \
    if (FAILED(hr)) { TRACE(_T("line %u err 0x%x\n"), __LINE__, hr); break; }

UINT g_cfDsObjectPicker = RegisterClipboardFormat(CFSTR_DSOP_DS_SELECTION_LIST);

HRESULT InitObjectPickerForGroups(IDsObjectPicker *pDsObjectPicker, 
                                  BOOL fMultiselect,
                                  LPCTSTR pszMachineName,
                                  BOOL bUsersOnly);
HRESULT InitObjectPickerForComputers(IDsObjectPicker *pDsObjectPicker);

DWORD ObjPickGetHostName(DWORD dwIpAddr, CString & strHostName);
DWORD ObjPickNameOrIpToHostname(CString & strNameOrIp, CString & strHostName);


CAccessEntryArray::~CAccessEntryArray()
{
    for (int i = 0; i < GetSize(); i++)
        delete GetAt(i);
}

//////////////////////////////////////////////////////////////////////
// CGetUsers Class
//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////


void    
FormatName(LPCTSTR pszFullName, LPCTSTR pszDomainName, CString & strDisplay)
{
    strDisplay.Format(_T("%s\\%s"), pszDomainName, pszFullName);
}

CGetUsers::CGetUsers(LPCTSTR pszMachineName, BOOL fMultiselect)
    : m_MachineName(pszMachineName),
      m_fMultiselect(fMultiselect)
{
}

CGetUsers::~CGetUsers()
{

}

BOOL
CGetUsers::GetUsers(HWND hwndParent, BOOL bUsersOnly)
{
    HRESULT             hr = S_OK;
    IDsObjectPicker *   pDsObjectPicker = NULL;
    IDataObject *       pdo = NULL;
    BOOL                fSuccess = TRUE;

    hr = CoInitialize(NULL);
    if (FAILED(hr)) 
        return FALSE;

    do
    {
        //
        // Create an instance of the object picker.  The implementation in
        // objsel.dll is apartment model.
        //
        hr = CoCreateInstance(CLSID_DsObjectPicker,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IDsObjectPicker,
                              (void **) &pDsObjectPicker);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = InitObjectPickerForGroups(
           pDsObjectPicker, m_fMultiselect, m_MachineName, bUsersOnly);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // Invoke the modal dialog.
        //
        hr = pDsObjectPicker->InvokeDialog(hwndParent, &pdo);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // If the user hit Cancel, hr == S_FALSE
        //
        if (hr == S_FALSE)
        {
            TRACE(_T("User canceled object picker dialog\n"));
            fSuccess = FALSE;
            break;
        }

        //
        // Process the user's selections
        //
        ASSERT(pdo);
        ProcessSelectedObjects(pdo);

        pdo->Release();
        pdo = NULL;

    } while (0);

    if (pDsObjectPicker)
    {
        pDsObjectPicker->Release();
    }
    
    CoUninitialize();

    if (FAILED(hr) || S_FALSE == hr)
        fSuccess = FALSE;

    return fSuccess;
}

void
CGetUsers::ProcessSelectedObjects(IDataObject *pdo)
{
    HRESULT hr = S_OK;

    STGMEDIUM stgmedium =
    {
        TYMED_HGLOBAL,
        NULL,
        NULL
    };

    FORMATETC formatetc =
    {
        (CLIPFORMAT)g_cfDsObjectPicker,
        NULL,
        DVASPECT_CONTENT,
        -1,
        TYMED_HGLOBAL
    };

    BOOL fGotStgMedium = FALSE;

    do
    {
        hr = pdo->GetData(&formatetc, &stgmedium);
        BREAK_ON_FAIL_HRESULT(hr);

        fGotStgMedium = TRUE;

        PDS_SELECTION_LIST pDsSelList =
            (PDS_SELECTION_LIST) GlobalLock(stgmedium.hGlobal);

        if (!pDsSelList)
        {
            TRACE(_T("GlobalLock error %u\n"), GetLastError());
            break;
        }

       	// create the path name thing
       	IADsPathname * pIADsPathname;
       	hr = CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                             IID_IADsPathname, (PVOID *)&pIADsPathname);
       	BREAK_ON_FAIL_HRESULT(hr);
       	if (FAILED(hr = pIADsPathname->SetDisplayType(ADS_DISPLAY_VALUE_ONLY)))
		{
			pIADsPathname->Release();
			break;
		}
        for (UINT i = 0; i < pDsSelList->cItems; i++)
        {
            PSID psid = NULL;
            DS_SELECTION * pDsSel = &(pDsSelList->aDsSelection[i]);
            if (pDsSel->pvarFetchedAttributes != NULL)
            {
               HRESULT hr = SafeArrayAccessData(V_ARRAY(pDsSel->pvarFetchedAttributes), &psid);
            }
            if (psid != NULL)
            {
            	LPWSTR pwzADsPath = pDsSel->pwzADsPath;
				CString name;
				if (pwzADsPath != NULL && *pwzADsPath != 0)
				{
            		if (FAILED(hr = pIADsPathname->Set(pwzADsPath, ADS_SETTYPE_FULL)))
						continue;
            		long lnNumPathElements = 0;
            		if (FAILED(hr = pIADsPathname->GetNumElements(&lnNumPathElements)))
                		continue;
            		BSTR bstrUser = NULL, bstrDomain = NULL;
            		if (FAILED(hr = pIADsPathname->GetElement(0, &bstrUser)))
                		continue;
            		switch (lnNumPathElements)
            		{
                		case 1:
                    		hr = pIADsPathname->Retrieve(ADS_FORMAT_SERVER, &bstrDomain);
                    		break;

                		case 2:  // nt4, nt5 domain
                		case 3:  // local domain
                    		hr = pIADsPathname->GetElement(1, &bstrDomain);
                    		break;

                		default:
                    		ASSERT(FALSE);
                    		hr = E_FAIL;
            		}
	            	if (FAILED(hr))
		            	continue;
					FormatName(bstrUser, bstrDomain, name);
					if (bstrDomain != NULL)
						SysFreeString(bstrDomain);
					if (bstrUser != NULL)
						SysFreeString(bstrUser);
				}
				else
					FormatName(pDsSel->pwzName, pDsSel->pwzADsPath, name);
                CAccessEntry * entry = 
                    new CAccessEntry(psid, name, pDsSel->pwzClass);
                Add(entry);
            }
        }
		pIADsPathname->Release();
        GlobalUnlock(stgmedium.hGlobal);

    } while (0);

    if (fGotStgMedium)
    {
        ReleaseStgMedium(&stgmedium);
    }
}


//////////////////////////////////////////////////////////////////////
// CGetComputer Class
//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CGetComputer::CGetComputer()
{
}

CGetComputer::~CGetComputer()
{
}

BOOL
CGetComputer::GetComputer(HWND hwndParent)
{
    HRESULT             hr = S_OK;
    IDsObjectPicker *   pDsObjectPicker = NULL;
    IDataObject *       pdo = NULL;
    BOOL                fSuccess = TRUE;

    hr = CoInitialize(NULL);
    if (FAILED(hr)) 
        return FALSE;

    do
    {
        //
        // Create an instance of the object picker.  The implementation in
        // objsel.dll is apartment model.
        //
        hr = CoCreateInstance(CLSID_DsObjectPicker,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IDsObjectPicker,
                              (void **) &pDsObjectPicker);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // Reinitialize the object picker to choose computers
        //

        hr = InitObjectPickerForComputers(pDsObjectPicker);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // Now pick a computer
        //

        hr = pDsObjectPicker->InvokeDialog(hwndParent, &pdo);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // If the user hit Cancel, hr == S_FALSE
        //
        if (hr == S_FALSE)
        {
            TRACE(_T("User canceled object picker dialog\n"));
            fSuccess = FALSE;
            break;
        }

        ASSERT(pdo);
        ProcessSelectedObjects(pdo);

        pdo->Release();
        pdo = NULL;
    
    } while (0);

    if (pDsObjectPicker)
    {
        pDsObjectPicker->Release();
    }
    
    CoUninitialize();

    if (FAILED(hr))
        fSuccess = FALSE;

    return fSuccess;
}


void
CGetComputer::ProcessSelectedObjects(IDataObject *pdo)
{
    HRESULT hr = S_OK;

    STGMEDIUM stgmedium =
    {
        TYMED_HGLOBAL,
        NULL,
        NULL
    };

    FORMATETC formatetc =
    {
        (CLIPFORMAT)g_cfDsObjectPicker,
        NULL,
        DVASPECT_CONTENT,
        -1,
        TYMED_HGLOBAL
    };

    BOOL fGotStgMedium = FALSE;

    do
    {
        hr = pdo->GetData(&formatetc, &stgmedium);
        BREAK_ON_FAIL_HRESULT(hr);

        fGotStgMedium = TRUE;

        PDS_SELECTION_LIST pDsSelList =
            (PDS_SELECTION_LIST) GlobalLock(stgmedium.hGlobal);

        if (!pDsSelList)
        {
            TRACE(_T("GlobalLock error %u\n"), GetLastError());
            break;
        }

        CString strTemp = pDsSelList->aDsSelection[0].pwzName;
        if (strTemp.Left(2) == _T("\\\\"))
            strTemp = pDsSelList->aDsSelection[0].pwzName[2];

        if (ERROR_SUCCESS != ObjPickNameOrIpToHostname(strTemp, m_strComputerName))
        {
            //we use the name from the object picker if we failed to convert it into hostname
            m_strComputerName = strTemp;
        }

        GlobalUnlock(stgmedium.hGlobal);

    } while (0);

    if (fGotStgMedium)
    {
        ReleaseStgMedium(&stgmedium);
    }
}


//+--------------------------------------------------------------------------
//
//  Function:   InitObjectPickerForGroups
//
//  Synopsis:   Call IDsObjectPicker::Initialize with arguments that will
//              set it to allow the user to pick one or more groups.
//
//  Arguments:  [pDsObjectPicker] - object picker interface instance
//
//  Returns:    Result of calling IDsObjectPicker::Initialize.
//
//---------------------------------------------------------------------------

HRESULT
InitObjectPickerForGroups(IDsObjectPicker *pDsObjectPicker, 
                          BOOL fMultiselect,
                          LPCTSTR pszMachineName,
                          BOOL bUsersOnly)
{
    //
    // Prepare to initialize the object picker.
    // Set up the array of scope initializer structures.
    //

    static const int     SCOPE_INIT_COUNT = 5;
    DSOP_SCOPE_INIT_INFO aScopeInit[SCOPE_INIT_COUNT];

    ZeroMemory(aScopeInit, sizeof(DSOP_SCOPE_INIT_INFO) * SCOPE_INIT_COUNT);

    //
    // Target computer scope.  This adds a "Look In" entry for the
    // target computer.  Computer scopes are always treated as
    // downlevel (i.e., they use the WinNT provider).
    //

    aScopeInit[0].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    aScopeInit[0].flType = DSOP_SCOPE_TYPE_TARGET_COMPUTER;
    aScopeInit[0].flScope = DSOP_SCOPE_FLAG_STARTING_SCOPE;
    aScopeInit[0].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_USERS;
    aScopeInit[0].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_USERS;
    if (!bUsersOnly)
    {
       aScopeInit[0].FilterFlags.flDownlevel |= 
            DSOP_DOWNLEVEL_FILTER_ALL_WELLKNOWN_SIDS;
    }

    //
    // The domain to which the target computer is joined.  Note we're
    // combining two scope types into flType here for convenience.
    //

    aScopeInit[1].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    aScopeInit[1].flScope = DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT;
    aScopeInit[1].flType = 
          DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN
      |   DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN;
    aScopeInit[1].FilterFlags.Uplevel.flNativeModeOnly = DSOP_FILTER_USERS;
    if (!bUsersOnly)
    {
      aScopeInit[1].FilterFlags.Uplevel.flNativeModeOnly |= 
            DSOP_FILTER_GLOBAL_GROUPS_SE
         |  DSOP_FILTER_UNIVERSAL_GROUPS_SE
         |  DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE;
    }
    aScopeInit[1].FilterFlags.Uplevel.flMixedModeOnly = DSOP_FILTER_USERS;
    if (!bUsersOnly)
    {
       aScopeInit[1].FilterFlags.Uplevel.flMixedModeOnly |= DSOP_FILTER_GLOBAL_GROUPS_SE;
    }
    aScopeInit[1].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_USERS;
    if (!bUsersOnly)
    {
       aScopeInit[1].FilterFlags.flDownlevel |= DSOP_DOWNLEVEL_FILTER_GLOBAL_GROUPS;
    }

    //
    // The domains in the same forest (enterprise) as the domain to which
    // the target machine is joined.  Note these can only be DS-aware
    //

    aScopeInit[2].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    aScopeInit[2].flType = DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN;
    aScopeInit[2].flScope = DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT;
    
    aScopeInit[2].FilterFlags.Uplevel.flNativeModeOnly = DSOP_FILTER_USERS;
    if (!bUsersOnly)
    {
       aScopeInit[2].FilterFlags.Uplevel.flNativeModeOnly |=
            DSOP_FILTER_GLOBAL_GROUPS_SE
         |  DSOP_FILTER_UNIVERSAL_GROUPS_SE;
    }
    aScopeInit[2].FilterFlags.Uplevel.flMixedModeOnly = DSOP_FILTER_USERS;
    if (!bUsersOnly)
    {
       aScopeInit[2].FilterFlags.Uplevel.flMixedModeOnly |= 
            DSOP_FILTER_GLOBAL_GROUPS_SE;
    }
    //
    // Domains external to the enterprise but trusted directly by the
    // domain to which the target machine is joined.
    //
    // If the target machine is joined to an NT4 domain, only the
    // external downlevel domain scope applies, and it will cause
    // all domains trusted by the joined domain to appear.
    //

    aScopeInit[3].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    aScopeInit[3].flScope = DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT;
    aScopeInit[3].flType =
         DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN
      |  DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN;

    aScopeInit[3].FilterFlags.Uplevel.flNativeModeOnly = DSOP_FILTER_USERS;
    if (!bUsersOnly)
    {
       aScopeInit[3].FilterFlags.Uplevel.flNativeModeOnly |= 
            DSOP_FILTER_GLOBAL_GROUPS_SE
         |  DSOP_FILTER_UNIVERSAL_GROUPS_SE;
    }

    aScopeInit[3].FilterFlags.Uplevel.flMixedModeOnly = DSOP_FILTER_USERS;
    if (!bUsersOnly)
    {
       aScopeInit[3].FilterFlags.Uplevel.flMixedModeOnly |= 
            DSOP_FILTER_GLOBAL_GROUPS_SE;
    }

    aScopeInit[3].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_USERS;
    if (!bUsersOnly)
    {
       aScopeInit[3].FilterFlags.flDownlevel |= 
            DSOP_DOWNLEVEL_FILTER_GLOBAL_GROUPS;
    }

    //
    // The Global Catalog
    //

    aScopeInit[4].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    aScopeInit[4].flScope = DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT;
    aScopeInit[4].flType = DSOP_SCOPE_TYPE_GLOBAL_CATALOG;

    // Only native mode applies to gc scope.

    aScopeInit[4].FilterFlags.Uplevel.flNativeModeOnly = DSOP_FILTER_USERS;
    if (!bUsersOnly)
    {
       aScopeInit[4].FilterFlags.Uplevel.flNativeModeOnly |= 
            DSOP_FILTER_GLOBAL_GROUPS_SE
         |  DSOP_FILTER_UNIVERSAL_GROUPS_SE;
    }

    //
    // Put the scope init array into the object picker init array
    //

    DSOP_INIT_INFO  InitInfo;
    ZeroMemory(&InitInfo, sizeof(InitInfo));

    InitInfo.cbSize = sizeof(InitInfo);

    //
    // The pwzTargetComputer member allows the object picker to be
    // retargetted to a different computer.  It will behave as if it
    // were being run ON THAT COMPUTER.
    //

    InitInfo.pwzTargetComputer = pszMachineName;
    InitInfo.cDsScopeInfos = SCOPE_INIT_COUNT;
    InitInfo.aDsScopeInfos = aScopeInit;
    InitInfo.flOptions = (fMultiselect) ? DSOP_FLAG_MULTISELECT : 0;

    LPCTSTR attrs[] = {_T("ObjectSid")};
    InitInfo.cAttributesToFetch = sizeof(attrs) / sizeof(attrs[0]);
    InitInfo.apwzAttributeNames = attrs;

    //
    // Note object picker makes its own copy of InitInfo.  Also note
    // that Initialize may be called multiple times, last call wins.
    //

    HRESULT hr = pDsObjectPicker->Initialize(&InitInfo);
#ifdef _DEBUG
    if (FAILED(hr))
    {
        ULONG i;

        for (i = 0; i < SCOPE_INIT_COUNT; i++)
        {
            if (FAILED(InitInfo.aDsScopeInfos[i].hr))
            {
                TRACE(_T("Initialization failed because of scope %u\n"), i);
            }
        }
    }
#endif
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   InitObjectPickerForComputers
//
//  Synopsis:   Call IDsObjectPicker::Initialize with arguments that will
//              set it to allow the user to pick a single computer object.
//
//  Arguments:  [pDsObjectPicker] - object picker interface instance
//
//  Returns:    Result of calling IDsObjectPicker::Initialize.
//
//  History:    10-14-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
InitObjectPickerForComputers(IDsObjectPicker *pDsObjectPicker)
{
    //
    // Prepare to initialize the object picker.
    // Set up the array of scope initializer structures.
    //

    static const int     SCOPE_INIT_COUNT = 2;
    DSOP_SCOPE_INIT_INFO aScopeInit[SCOPE_INIT_COUNT];

    ZeroMemory(aScopeInit, sizeof(DSOP_SCOPE_INIT_INFO) * SCOPE_INIT_COUNT);

    //
    // Build a scope init struct for everything except the joined domain.
    //

    aScopeInit[0].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    aScopeInit[0].flType = DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN
                           | DSOP_SCOPE_TYPE_GLOBAL_CATALOG
                           | DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN
                           | DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN
                           | DSOP_SCOPE_TYPE_WORKGROUP
                           | DSOP_SCOPE_TYPE_USER_ENTERED_UPLEVEL_SCOPE
                           | DSOP_SCOPE_TYPE_USER_ENTERED_DOWNLEVEL_SCOPE;
    aScopeInit[0].FilterFlags.Uplevel.flBothModes =
        DSOP_FILTER_COMPUTERS;
    aScopeInit[0].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_COMPUTERS;


    //
    // scope for the joined domain, make it the default
    //
    aScopeInit[1].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    aScopeInit[1].flType = DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN
                           | DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN;
    aScopeInit[1].FilterFlags.Uplevel.flBothModes =
        DSOP_FILTER_COMPUTERS;
    aScopeInit[1].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_COMPUTERS;

    aScopeInit[1].flScope = DSOP_SCOPE_FLAG_STARTING_SCOPE;

    //
    // Put the scope init array into the object picker init array
    //

    DSOP_INIT_INFO  InitInfo;
    ZeroMemory(&InitInfo, sizeof(InitInfo));

    InitInfo.cbSize = sizeof(InitInfo);
    InitInfo.pwzTargetComputer = NULL;  // NULL == local machine
    InitInfo.cDsScopeInfos = SCOPE_INIT_COUNT;
    InitInfo.aDsScopeInfos = aScopeInit;

    //
    // Note object picker makes its own copy of InitInfo.  Also note
    // that Initialize may be called multiple times, last call wins.
    //

    return pDsObjectPicker->Initialize(&InitInfo);
}

//Use WinSock to the host name based on the ip address
DWORD
ObjPickGetHostName
(
    DWORD       dwIpAddr,
    CString &   strHostName
)
{
    CString strName;

    //
    //  Call the Winsock API to get host name information.
    //
    strHostName.Empty();

    ULONG ulAddrInNetOrder = ::htonl( (ULONG) dwIpAddr ) ;

    HOSTENT * pHostInfo = ::gethostbyaddr( (CHAR *) & ulAddrInNetOrder,
                                           sizeof ulAddrInNetOrder,
                                           PF_INET ) ;
    if ( pHostInfo == NULL )
    {
        return ::WSAGetLastError();
    }

    // copy the name
    LPTSTR pBuf = strName.GetBuffer(256);
    ZeroMemory(pBuf, 256);

    ::MultiByteToWideChar(CP_ACP, 
                          MB_PRECOMPOSED, 
                          pHostInfo->h_name, 
                          -1, 
                          pBuf, 
                          256);

    strName.ReleaseBuffer();
    strName.MakeUpper();

    int nDot = strName.Find(_T("."));

    if (nDot != -1)
        strHostName = strName.Left(nDot);
    else
        strHostName = strName;

    return NOERROR;
}

//Convert any valid name of a machine (IP address, NetBios name or fully qualified DNS name)
//to the host name
DWORD ObjPickNameOrIpToHostname(CString & strNameOrIp, CString & strHostName)
{
    DWORD dwErr = ERROR_SUCCESS;
    CString strTemp;

    CIpAddress ia(strNameOrIp);
    if (!ia.IsValid())
    {
        dwErr = ObjPickGetHostName((LONG)ia, strTemp);
    }
    else
    {
         // just want the host name
         int nDot = strNameOrIp.Find('.');
         if (nDot != -1)
         {
             strTemp = strNameOrIp.Left(nDot);
         }
         else
         {
             strTemp = strNameOrIp;
         }
    }

    if (ERROR_SUCCESS == dwErr)
    {
        strHostName = strTemp;
    }

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\comprop\objpick.h ===
// objpick.cpp: implementation of the CGetUser class and the 
//              CGetComputer class using the object picker
//
//////////////////////////////////////////////////////////////////////
#ifndef OBJPICK_H
#define OBJPICK_H

//
// A list of names (e.g., users, groups, machines, and etc)
//

void    FormatName(LPCTSTR pszFullName, LPCTSTR pszDomainName, CString & strDisplay);

class CAccessEntry;

class CAccessEntryArray : public CArray<CAccessEntry *, CAccessEntry *&>
{
public:
    CAccessEntryArray() {}
    ~CAccessEntryArray();
};

class CGetUsers : public CAccessEntryArray
{
public:
    CGetUsers(LPCTSTR pszMachineName, BOOL fMultiselect = FALSE);
    ~CGetUsers();

	BOOL    GetUsers(HWND hwndOwner, BOOL bUsersOnly = FALSE);

protected:
    void    ProcessSelectedObjects(IDataObject *pdo);

protected:
    BOOL    m_fMultiselect;
    CString m_MachineName;
};

class CGetComputer 
{
public:
    CGetComputer();
    ~CGetComputer();

    BOOL    GetComputer(HWND hwndOwner);

protected:
    void    ProcessSelectedObjects(IDataObject *pdo);

public:
    CString     m_strComputerName;
};

#endif // GETUSER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\comprop\msg.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        msg.cpp

   Abstract:

        Message Functions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

#include "stdafx.h"
#include <lmerr.h>
#include <lmcons.h>
#include <winsock2.h>
#include "comprop.h"
#include <pudebug.h>


#ifdef _MT

    //
    // Thread protected stuff
    //
    // (use code chunk below for tracing)
	//		CString buf;\
	//		buf.Format(_T("LowerThreadProtection at line %d in %S\n"), __LINE__, __FILE__);\
	//		OutputDebugString(buf);
    #define RaiseThreadProtection() \
		do {\
			EnterCriticalSection(&_csSect);\
		} while(0)
    #define LowerThreadProtection() \
		do {\
			LeaveCriticalSection(&_csSect);\
		} while (0)

    static CRITICAL_SECTION _csSect;

#else

    #pragma message("Module is not thread-safe.")

    #define RaiseThreadProtection()
    #define LowerThreadProtection()

#endif // _MT




BOOL
InitErrorFunctionality()
/*++

Routine Description:

    Initialize CError class, and allocate static objects

Arguments:

    None:

Return Value:

    TRUE for success, FALSE for failure

--*/
{
#ifdef _MT
    INITIALIZE_CRITICAL_SECTION(&_csSect);
#endif // _MT

    return CError::AllocateStatics();
}



void
TerminateErrorFunctionality()
/*++

Routine Description:

    De-initialize CError class, freeing up static objects

Arguments:

    None

Return Value:

    None

--*/
{
    CError::DeAllocateStatics();

#ifdef _MT
    DeleteCriticalSection(&_csSect);
#endif // _MT

}

//
// Static Initialization:
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

const TCHAR g_cszNull[] = _T("(Null)");

const TCHAR CError::s_chEscape = _T('%');        // Error text escape
const TCHAR CError::s_chEscText = _T('h');       // Escape code for text
const TCHAR CError::s_chEscNumber = _T('H');     // Escape code for error code
LPCTSTR CError::s_cszLMDLL = _T("netmsg.dll");   // LM Error File
LPCTSTR CError::s_cszWSDLL = _T("iisui.dll");    // Winsock error file
LPCTSTR CError::s_cszFacility[] = 
{
    /* FACILITY_NULL        */ NULL,
    /* FACILITY_RPC         */ NULL,
    /* FACILITY_DISPATCH    */ NULL,            
    /* FACILITY_STORAGE     */ NULL,
    /* FACILITY_ITF         */ NULL,
    /* FACILITY_DS          */ NULL,
    /* 6                    */ NULL,
    /* FACILITY_WIN32       */ NULL,
    /* FACILITY_WINDOWS     */ NULL,
    /* FACILITY_SSPI        */ NULL,
    /* FACILITY_CONTROL     */ NULL,
    /* FACILITY_CERT        */ NULL,
    /* FACILITY_INTERNET    */ _T("metadata.dll"),
    /* FACILITY_MEDIASERVER */ NULL,
    /* FACILITY_MSMQ        */ NULL,
    /* FACILITY_SETUPAPI    */ NULL,
    /* FACILITY_SCARD       */ NULL,
    /* 17 (MTX)             */ _T("iisui.dll"),
};

HRESULT CError::s_cdwMinLMErr = NERR_BASE; 
HRESULT CError::s_cdwMaxLMErr = MAX_NERR;
HRESULT CError::s_cdwMinWSErr = WSABASEERR;    
HRESULT CError::s_cdwMaxWSErr = WSABASEERR + 2000;    
DWORD   CError::s_cdwFacilities = (sizeof(CError::s_cszFacility)\
    / sizeof(CError::s_cszFacility[0]));

//
// Allocated objects (static MFC objects in a DLL are a no-no)
//
CString * CError::s_pstrDefError;
CString * CError::s_pstrDefSuccs;
CMapHRESULTtoUINT  * CError::s_pmapOverrides;
CMapDWORDtoCString * CError::s_pmapFacilities;
BOOL CError::s_fAllocated = FALSE;



/* protected */
/* static */
BOOL
CError::AllocateStatics()
/*++

Routine Description:

    Allocate static objects

Arguments:

    None

Return Value:

    TRUE for successfull allocation, FALSE otherwise

--*/
{
    RaiseThreadProtection();

    if (!AreStaticsAllocated())
    {
        try
        {
            CError::s_pstrDefError = new CString;
            CError::s_pstrDefSuccs = new CString(_T("0x%08lx"));
            CError::s_pmapOverrides = new CMapHRESULTtoUINT;
            CError::s_pmapFacilities = new CMapDWORDtoCString;
            s_fAllocated = TRUE;

            LPTSTR lp = CError::s_pstrDefError->GetBuffer(255);
            if (!::LoadString(
                hDLLInstance,
                IDS_NO_MESSAGE,
                lp,
                255
                ))
            {
                //
                // Just in case...
                //
                ASSERT(FALSE);
                lstrcpy(lp, _T("Error Code: 0x%08lx"));
            }

            CError::s_pstrDefError->ReleaseBuffer();
        }
        catch(CMemoryException * e)
        {
            TRACEEOLID("Initialization Failed");
            e->ReportError();
            e->Delete();
        }
    }

    LowerThreadProtection();

    return AreStaticsAllocated();
}



/* protected */
/* static */
void
CError::DeAllocateStatics()
/*++

Routine Description:

    Clean up allocations

Arguments:

    N/A

Return Value:

    N/A

--*/
{

    RaiseThreadProtection();

    if (AreStaticsAllocated())
    {
        SAFE_DELETE(CError::s_pstrDefError);
        SAFE_DELETE(CError::s_pstrDefSuccs);
        SAFE_DELETE(CError::s_pmapOverrides);
        SAFE_DELETE(CError::s_pmapFacilities);
        s_fAllocated = FALSE;
    }

    LowerThreadProtection();
}



/* static */
HRESULT 
CError::CvtToInternalFormat(
    IN HRESULT hrCode
    )
/*++

Routine Description:

    Convert WIN32 or HRESULT code to internal (HRESULT) format.

Arguments:

    DWORD dwCode        Error code

Return Value:

    HRESULT

Notes:

    HRESULTS are left as is.  Lanman and Winsock errors are converted
    to HRESULTS using private facility codes.

--*/
{
    if (IS_HRESULT(hrCode))
    {
        return hrCode;
    }

    if(hrCode >= s_cdwMinLMErr && hrCode <= s_cdwMaxLMErr)
    {
        return MAKE_HRESULT(SEVERITY_ERROR, FACILITY_LANMAN, (DWORD)hrCode);
    }

    if (hrCode >= s_cdwMinWSErr && hrCode <= s_cdwMaxWSErr)
    {
        return MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WINSOCK, (DWORD)hrCode);
    }

    return HResult(hrCode);    
}


//
// Not publically defined in MFC
//
int AFXAPI AfxLoadString(UINT nIDS, LPTSTR lpszBuf, UINT nMaxBuf = 256);


/* static */
HRESULT
CError::TextFromHRESULT(
    IN  HRESULT hrCode,
    OUT LPTSTR  szBuffer,
    OUT DWORD   cchBuffer
    )
/*++

Routine Description:

    Get text from the given HRESULT.  Based on the range that the HRESULT
    falls in and the facility code, find the location of the message,
    and fetch it.

Arguments:

    HRESULT hrCode      HRESULT or (DWORD WIN32 error) whose message to get
    LPTSTR  szBuffer    Buffer to load message text into
    DWORD   cchBuffer   Size of buffer in characters.

Return Value:

    HRESULT error code depending on whether the message was
    found.  If the message was not found, some generic message
    is synthesized in the buffer if a buffer is provided.

    ERROR_FILE_NOT_FOUND        No message found
    ERROR_INSUFFICIENT_BUFFER   Buffer is a NULL pointer or too small

--*/
{
    HRESULT hrReturn = ERROR_SUCCESS;

    //
    // First check to see if this message is overridden
    //
    UINT nID;
    if (HasOverride(hrCode, &nID))
    {
        //
        // Message overridden.  Load replacement message
        // instead.
        //
        HINSTANCE hInstance = ::AfxGetResourceHandle();
        BOOL fSuccess;

        if (hInstance == NULL)
        {
            //
            // Console app
            //
            fSuccess = ::LoadString(
                ::GetModuleHandle(NULL), 
                nID, 
                szBuffer, 
                cchBuffer
                );
        }
        else
        {
            //
            // MFC app
            //
            fSuccess = ::AfxLoadString(
                nID, 
                szBuffer, 
                cchBuffer
                );
        }

        if (fSuccess)
        {
            //
            // Everything ok
            //
            return hrReturn;
        }

        //
        // Message didn't exist, skip the override, and 
        // load as normal.
        //
        TRACEEOLID("Attempted override failed.  Couldn't load " << nID);
        ASSERT(FALSE);
    }

    LPCTSTR lpDll    = NULL;
    HINSTANCE hDll   = NULL;
    DWORD dwFacility = HRESULT_FACILITY(hrCode);
    DWORD dwSeverity = HRESULT_SEVERITY(hrCode);
    DWORD dwCode     = HRESULT_CODE(hrCode);
    BOOL  fSuccess   = Succeeded(hrCode);

    //
    // Strip off meaningless internal facility codes
    //
    if (dwFacility == FACILITY_LANMAN || dwFacility == FACILITY_WINSOCK)
    {
        dwFacility = FACILITY_NULL;
        hrCode     = (HRESULT)dwCode;
    }

    DWORD dwFlags = FORMAT_MESSAGE_IGNORE_INSERTS | 
                    FORMAT_MESSAGE_MAX_WIDTH_MASK;

    //
    // Since we allow both HRESULTS and WIN32 codes to be
    // used here, we can't rely on the private FACILITY code 
    // for lanman and winsock.
    //
    if(hrCode >= s_cdwMinLMErr && hrCode <= s_cdwMaxLMErr)
    {
        //
        // Lanman error
        //
        lpDll = s_cszLMDLL;
    }
    else if (hrCode >= s_cdwMinWSErr && hrCode <= s_cdwMaxWSErr)
    {
        //
        // Winsock error
        //
        lpDll = s_cszWSDLL;
    }
    else
    {
        //
        // Attempt to determine message location from facility code.
        // Check for registered facility first.
        //
        lpDll = FindFacility(dwFacility);

        if (lpDll == NULL)
        {
            if (dwFacility < s_cdwFacilities)
            {
                lpDll = s_cszFacility[dwFacility];
            }
            else
            {
                TRACEEOLID("Bogus FACILITY code encountered.");
                ASSERT(FALSE);
                lpDll = NULL;
            }
        }
    }

    do
    {
        if (szBuffer == NULL || cchBuffer <= 0)
        {
            hrReturn = HResult(ERROR_INSUFFICIENT_BUFFER);
            break;
        }

        if (lpDll)
        {
            //
            // Load message file
            //
            hDll = ::LoadLibraryEx(
                lpDll,
                NULL,
                LOAD_LIBRARY_AS_DATAFILE
                );

            if (hDll == NULL)
            {
                hrReturn = ::GetLastHRESULT();
                break;
            }

            dwFlags |= FORMAT_MESSAGE_FROM_HMODULE;
        }
        else
        {
            dwFlags |= FORMAT_MESSAGE_FROM_SYSTEM;
        }

        DWORD dwResult = 0L;
        DWORD dwID = hrCode;
        HINSTANCE hSource = hDll;

        while(!dwResult)
        {
            dwResult = ::FormatMessage(
                dwFlags,
                (LPVOID)hSource,
                dwID,
                0,
                szBuffer,
                cchBuffer,
                NULL
                );

            if (dwResult > 0)
            {
                //
                // Successfully got a message
                //
                hrReturn = ERROR_SUCCESS;
                break;
            } 

            hrReturn = ::GetLastHRESULT();
    
            if (dwID != dwCode && !fSuccess)
            {
                //
                // Try the SCODE portion of the error from win32
                // if this is an error message
                //
                dwID = dwCode;
                hSource = NULL;
                continue;
            }

            //
            // Failed to obtain a message
            //
            hrReturn = HResult(ERROR_FILE_NOT_FOUND);
            break;
        }
    }
    while(FALSE);

    if(hDll != NULL)
    {
        ::FreeLibrary(hDll);
    }

    if (Failed(hrReturn))
    {
        //
        // Unable to find the message, synthesize something with
        // the code in it if there's room (+8 for the number)
        //
        CString & strMsg = (fSuccess ? *s_pstrDefSuccs : *s_pstrDefError);
        if (cchBuffer > (DWORD)strMsg.GetLength() + 8)
        {
            TRACEEOLID("Substituting default message for " << (DWORD)hrCode);
            wsprintf(szBuffer, (LPCTSTR)strMsg, hrCode);
        }
        else
        {
            //
            // Not enough room for message code
            //
            TRACEEOLID("Buffer too small for default message -- left blank");
            ASSERT(FALSE);
            *szBuffer = _T('\0');
        }
    }

    return hrReturn;
}



/* static */
HRESULT 
CError::TextFromHRESULT(
    IN  HRESULT hrCode,
    OUT CString & strBuffer
    )
/*++

Routine Description:

    Similar to the function above, but use a CString

Arguments:

    HRESULT hrCode         HRESULT or (DWORD WIN32 error) whose message to get
    CString & strBuffer    Buffer to load message text into

Return Value:

    HRESULT error code depending on whether the message was
    found.  If the message was not found, some generic message
    is synthesized in the buffer if a buffer is provided.

    ERROR_FILE_NOT_FOUND   No message found

--*/
{
    DWORD cchBuffer = 255;
    HRESULT hr = S_OK;

    for (;;)
    {
        LPTSTR szBuffer = strBuffer.GetBuffer(cchBuffer + 1);
        if (szBuffer == NULL)
        {
            return HResult(ERROR_NOT_ENOUGH_MEMORY);
        }

        hr = TextFromHRESULT(hrCode, szBuffer, cchBuffer);

        if (Win32Error(hr) != ERROR_INSUFFICIENT_BUFFER)
        {
            //
            // Done!
            //
            break;
        }

        //
        // Insufficient buffer, enlarge and try again
        //
        cchBuffer *= 2;
    }

    strBuffer.ReleaseBuffer();

    return hr;
}



/* static */
BOOL
CError::ExpandEscapeCode(
    IN  LPTSTR szBuffer,
    IN  DWORD cchBuffer,
    OUT IN LPTSTR & lp,
    IN  CString & strReplacement,
    OUT HRESULT & hr
    )
/*++

Routine Description:

    Expand escape code

Arguments:

    LPTSTR szBuffer             Buffer
    DWORD cchBuffer             Size of buffer
    LPTSTR & lp                 Pointer to escape code
    CString & strReplacement    Message to replace the escape code
    HRESULT & hr                Returns HRESULT in case of failure

Return Value:

    TRUE if the replacement was successful, FALSE otherwise.
    In the case of failure, hr will return an HRESULT.
    In the case of success, lp will be advanced past the
    replacement string.

--*/
{
    //
    // Make sure there's room (account for terminating NULL)
    // Free up 2 spaces for the escape code.
    //
    int cchFmt = lstrlen(szBuffer) - 2;
    int cchReplacement = strReplacement.GetLength();
    int cchRemainder = lstrlen(lp + 2);

    if ((DWORD)(cchReplacement + cchFmt) < cchBuffer)
    {
        //
        // Put it in
        //
        MoveMemory(
            lp + cchReplacement,
            lp + 2,
            (cchRemainder + 1) * sizeof(TCHAR)
            );
        CopyMemory(lp, strReplacement, cchReplacement * sizeof(TCHAR));
        lp += cchReplacement;
        
        return TRUE;
    }

    hr = HResult(ERROR_INSUFFICIENT_BUFFER);

    return FALSE;
}



/* static */ 
LPCTSTR 
CError::TextFromHRESULTExpand(
    IN  HRESULT hrCode,
    OUT LPTSTR  szBuffer,
    OUT DWORD   cchBuffer,
    OUT HRESULT * phResult  OPTIONAL
    )
/*++

Routine Description:

    Expand %h/%H strings in szBuffer to text from HRESULT,
    or error code respectively within the limits of szBuffer.

Arguments:

    HRESULT hrCode      HRESULT or (DWORD WIN32 error) whose message to get
    LPTSTR  szBuffer    Buffer to load message text into
    DWORD   cchBuffer   Buffer size in characters
    HRESULT * phResult  Optional return code

Return Value:

    Pointer to string.

--*/
{
    HRESULT hr = S_OK;

    if (szBuffer == NULL || cchBuffer <= 0)
    {
        hr = HResult(ERROR_INSUFFICIENT_BUFFER);
    }
    else
    {
        //
        // Look for the escape sequence
        //
        int cReplacements = 0;
        CString strMessage;
        LPTSTR lp = szBuffer;
        while (*lp)
        {
            if (*lp == s_chEscape)
            {
                switch(*(lp + 1))
                {
                case s_chEscText:
                    //
                    // Replace escape code with text message
                    //
                    hr = TextFromHRESULT(hrCode, strMessage);

                    if (ExpandEscapeCode(
                        szBuffer,
                        cchBuffer,
                        lp,
                        strMessage,
                        hr
                        ))
                    {
                        ++cReplacements;
                    }
                    break;

                case s_chEscNumber:
                    //
                    // Replace escape code with numeric error code
                    //
                    strMessage.Format(_T("0x%08x"), hrCode);

                    if (ExpandEscapeCode(
                        szBuffer,
                        cchBuffer,
                        lp,
                        strMessage,
                        hr
                        ))
                    {
                        ++cReplacements;
                    }
                    break;

                default:
                    //
                    // Regular printf-style escape sequence.
                    //
                    break;
                }
            }

            ++lp;
        }

        if (!cReplacements)
        {
            //
            // Got to the end without finding any escape codes.
            //
            hr = HResult(ERROR_INVALID_PARAMETER);
        }
    }

    if (phResult)
    {
        *phResult = hr;
    }

    return szBuffer;
}



/* static */
LPCTSTR 
CError::TextFromHRESULTExpand(
    IN  HRESULT hrCode,
    OUT CString & strBuffer
    )
/*++

Routine Description:

    Expand %h string in strBuffer to text from HRESULT

Arguments:

    HRESULT hrCode      HRESULT or (DWORD WIN32 error) whose message to get
    CString & strBuffer Buffer to load message text into

Return Value:

    Pointer to string.

--*/
{
    DWORD cchBuffer = strBuffer.GetLength() + 1024;

    for (;;)
    {
        LPTSTR szBuffer = strBuffer.GetBuffer(cchBuffer + 1);
        if (szBuffer != NULL)
        {
            HRESULT hr;

            TextFromHRESULTExpand(hrCode, szBuffer, cchBuffer, &hr);

            if (Win32Error(hr) != ERROR_INSUFFICIENT_BUFFER)
            {
                //
                // Done!
                //
                break;
            }

            //
            // Insufficient buffer, enlarge and try again
            //
            cchBuffer *= 2;
        }
    }

    strBuffer.ReleaseBuffer();

    return strBuffer;
}



/* static */
int
CError::MessageBox(
    IN HRESULT hrCode,
    IN UINT    nType,
    IN UINT    nHelpContext OPTIONAL
    )
/*++

Routine Description:

    Display error message in a message box

Arguments:

    HRESULT hrCode       : HRESULT error code
    UINT    nType        : See AfxMessageBox for documentation
    UINT    nHelpContext : See AfxMessageBox for documentation

Return Value:

    AfxMessageBox return code

--*/
{
    CString strMsg;

    TextFromHRESULT(hrCode, strMsg);

    //
    // Ensure we have a CWinApp
    //
    if (AfxGetApp() != NULL)
    {
        return ::AfxMessageBox(strMsg, nType, nHelpContext);
    }

    //
    // Else hang the message box off the desktop.
    // this must be a console app
    //
#ifndef _CONSOLE

    TRACEEOLID("No winapp detected -- using desktop as parent handle");
    ASSERT(FALSE);

#endif // _CONSOLE

    return ::MessageBox(NULL, strMsg, NULL, nType);
}


//
// Extend CString just to get at FormatV publically
//
class CStringEx : public CString
{
public:
    void FormatV(LPCTSTR lpszFormat, va_list argList)
    {
        CString::FormatV(lpszFormat, argList);
    }
};


int 
CError::MessageBoxFormat(
    IN UINT nFmt,
    IN UINT nType,
    IN UINT nHelpContext,
    ...
    ) const
/*++

Routine Description:

    Display formatted error message in messagebox.  The format
    string (given as a resource ID) is a normal printf-style
    string, with the additional parameter of %h, which takes
    the text equivalent of the error message, or %H, which takes
    the error return code itself.

Arguments:

    UINT    nFmt         : Resource format
    UINT    nType        : See AfxMessageBox for documentation
    UINT    nHelpContext : See AfxMessageBox for documentation
    ...                    More as needed for sprintf

Return Value:

    AfxMessageBox return code
    
--*/
{
    CString strFmt;
    CStringEx strMsg;

    strFmt.LoadString(nFmt);

    //
    // First expand the error
    //
    TextFromHRESULTExpand(m_hrCode, strFmt);

    va_list marker;
    va_start(marker, nHelpContext);
    strMsg.FormatV(strFmt, marker);
    va_end(marker);

    //
    // Ensure we have a CWinApp
    //
    if (AfxGetApp() != NULL)
    {
        return ::AfxMessageBox(strMsg, nType, nHelpContext);
    }

    //
    // Else hang the message box off the desktop.
    // this must be a console app
    //

#ifndef _CONSOLE
    
    TRACEEOLID("No winapp detected -- using desktop as parent handle");
    ASSERT(FALSE);

#endif // _CONSOLE

    return ::MessageBox(NULL, strMsg, NULL, nType);
}


BOOL 
CError::MessageBoxOnFailure(
    IN UINT nType,
    IN UINT nHelpContext    OPTIONAL
    ) const
/*++

Routine Description:

    Display message box if the current error is a failure
    condition, else do nothing

Arguments:

    UINT    nType        : See AfxMessageBox for documentation
    UINT    nHelpContext : See AfxMessageBox for documentation

Return Value:

    TRUE if a messagebox was shown, FALSE otherwise

--*/
{
    if (Failed())
    {
        MessageBox(nType, nHelpContext);
        return TRUE;
    }

    return FALSE;
}





/* static */
BOOL 
CError::HasOverride(
    IN  HRESULT hrCode, 
    OUT UINT * pnMessage        OPTIONAL
    )
/*++

Routine Description:

    Check to see if a given HRESULT has an override

Arguments:

    HRESULT hrCode              : HRESULT to check for
    UINT * pnMessage            : Optionally returns the override

Return Value:

    TRUE if there is an override, FALSE if there is not.

--*/
{
    RaiseThreadProtection();

    ASSERT(AreStaticsAllocated());

    UINT nID;
    hrCode = CvtToInternalFormat(hrCode);
    BOOL fResult = s_pmapOverrides->Lookup(hrCode, nID);

    if (fResult && pnMessage != NULL)
    {
        *pnMessage = nID;
    }

    LowerThreadProtection();

    return fResult;
}



/* static */ 
UINT
CError::AddOverride(
    IN HRESULT    hrCode,
    IN UINT       nMessage
    )
/*++

Routine Description:

    Add an override for a specific HRESULT.

Arguments:

    HRESULT    hrCode       : HRESULT to override
    UINT       nMessage     : New message, or -1 to remove override

Return Value:

    The previous override, or -1

--*/
{
    RaiseThreadProtection();

    ASSERT(AreStaticsAllocated());

    UINT nPrev;
    hrCode = CvtToInternalFormat(hrCode);

    //
    // Fetch the current override
    //
    if (!s_pmapOverrides->Lookup(hrCode, nPrev))
    {
        //
        // Didn't exist
        //
        nPrev = REMOVE_OVERRIDE;
    }

    if (nMessage == REMOVE_OVERRIDE)
    {
        //
        // Remove the override
        //
        s_pmapOverrides->RemoveKey(hrCode);
    }
    else
    {
        //
        // Set new override
        //
        s_pmapOverrides->SetAt(hrCode, nMessage);
    }

    LowerThreadProtection();

    return nPrev;
}


/* static */
void
CError::RemoveAllOverrides()
/*++

Routine Description:

    Remove all overrides

Arguments:

    None

Return Value:

    None

--*/
{
    RaiseThreadProtection();

    ASSERT(AreStaticsAllocated());
    s_pmapOverrides->RemoveAll();

    LowerThreadProtection();
}



/* static */
LPCTSTR 
CError::FindFacility(
    IN DWORD dwFacility
    )
/*++

Routine Description:

    Determine if a DLL name has been registered for the given facility
    code.

Arguments:

    DWORD dwFacility        : Facility code

Return Value:

    Returns the DLL name, or NULL.

--*/
{
    RaiseThreadProtection();

    ASSERT(AreStaticsAllocated());

	LPCTSTR pRes = NULL;
    CString strDLL;
    if (s_pmapFacilities->Lookup(dwFacility, strDLL))
    {
        pRes = strDLL;
    }

    LowerThreadProtection();

    return pRes;
}



/* static */ 
void 
CError::RegisterFacility(
    IN DWORD dwFacility,
    IN LPCSTR lpDLL         OPTIONAL
    )
/*++

Routine Description:

    Register a DLL for a given facility code.  Use NULL to unregister
    the DLL name.

Arguments:

    DWORD dwFacility : Facility code
    LPCSTR lpDLL     : DLL Name.

Return Value:

    None

--*/
{
    RaiseThreadProtection();

    ASSERT(AreStaticsAllocated());

    if (lpDLL == NULL)
    {
        //
        // Remove the facility
        //
        s_pmapFacilities->RemoveKey(dwFacility);
    }
    else
    {
        CString str(lpDLL);

        //
        // Register facility
        //
        s_pmapFacilities->SetAt(dwFacility, str);
    }

    LowerThreadProtection();
}



CError::~CError()
/*++

Routine Description:

    Destructor

Arguments:

    None

Return Value:

    N/A

--*/
{
    SAFE_DELETE(m_pstrBuff);
}




const CError & 
CError::Construct(
    IN HRESULT hr
    )
/*++

Routine Description:

    construct with new value.

Arguments:
    
    HRESULT hr : New value, either an HRESULT or a WIN32
                 error code.

Return Value:

    Reference to current object

--*/
{
    ASSERT(AreStaticsAllocated());

    m_hrCode = CvtToInternalFormat(hr);

    SAFE_DELETE(m_pstrBuff);

    return *this;
}



const CError & 
CError::Construct(
    IN const CError & err
    )
/*++

Routine Description:

    Assign new value.

Arguments:
    
    CError & err    : Error code

Return Value:

    Reference to current object

--*/
{
    ASSERT(AreStaticsAllocated());

    m_hrCode = err.m_hrCode;

    SAFE_DELETE(m_pstrBuff);

    return *this;
}



CError::operator LPCTSTR()
/*++

Routine Description:

    Convert message to text in internal buffer, and return
    pointer to the internal buffer.

Arguments:

    None

Return Value:

    Pointer to internal buffer.

--*/
{
    ASSERT(AreStaticsAllocated());

    if (m_pstrBuff == NULL)
    {
        m_pstrBuff = new CString;
    }

    if (m_pstrBuff)
    {
        TextFromHRESULT(m_hrCode, *m_pstrBuff);
        return (LPCTSTR)*m_pstrBuff;
    }

    return g_cszNull;
}



//
// Text dialog that warns of clear text violation
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


CClearTxtDlg::CClearTxtDlg(
    IN CWnd * pParent OPTIONAL
    )
/*++

Routine Description:

    Clear text dialog constructor

Arguments:

    CWnd * pParent : Optional parent window

Return Value:

    N/A

--*/
    : CDialog(CClearTxtDlg::IDD, pParent)
{
    //{{AFX_DATA_INIT(CClearTxtDlg)
    //}}AFX_DATA_INIT
}



void
CClearTxtDlg::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CDialog::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CClearTxtDlg)
    //}}AFX_DATA_MAP
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CClearTxtDlg, CDialog)
    //{{AFX_MSG_MAP(CClearTxtDlg)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BOOL
CClearTxtDlg::OnInitDialog()
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CDialog::OnInitDialog();

    (GetDlgItem(IDCANCEL))->SetFocus();
    CenterWindow();
    MessageBeep(MB_ICONEXCLAMATION);

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\comprop\objplus.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        objplus.h

   Abstract:

        Base object class definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

#ifndef _COMMON_H_
#define _COMMON_H_



//
// Forward declarations
//
class CObjHelper;
class CObjectPlus;
class CObListPlus;
class CObListIter;



class COMDLL CObjHelper
/*++

Class Description:

    Helper class for control of construction and API errors

Public Interface:

    IsValid           : Determine if the object is in a valid state.
    operator BOOL     : Boolean cast to IsValid()
    SetDirty          : Set or reset the dirty flag
    IsDirty           : Query the dirty state of the object
    QueryCreationTime : Query the creation time of the object
    QueryAge          : Query the age of the object
    ReportError       : Query/set construction failure
    QueryError        : Query the error code of the object
    QueryApiErr       : Query/set API error code
    ResetErrors       : Reset all error codes
    SetApiErr         : Echoes the error to the caller
    AssertValid       : Assert the object is in a valid state (debug only)

--*/
{
protected:
    //
    // Protected constructor: Not to be declared independently.
    //
    CObjHelper();

public:
    virtual BOOL IsValid() const;
    operator BOOL();

    //
    // Update the Dirty flag
    //
    void SetDirty(
        IN BOOL fDirty = TRUE
        );

    //
    // Query the Dirty flag
    //
    BOOL IsDirty() const { return m_fDirty; }

    //
    // Return the creation time of this object
    //
    DWORD QueryCreationTime() const { return m_time_created; }

    //
    // Return the elapsed time this object has been alive.
    //
    DWORD QueryAge() const;

    //
    // Query/set construction failure
    //
    void ReportError(
        IN LONG errInConstruction
        );

    //
    // Fetch construction error
    //
    LONG QueryError() const { return m_ctor_err; }

    //
    // Query/set API errors.
    //
    LONG QueryApiErr() const { return m_api_err; }

    //
    // Reset all error conditions.
    //
    void ResetErrors();

    //
    // SetApiErr() echoes the error to the caller.
    // for use in expressions.
    //
    LONG SetApiErr(
        IN LONG errApi = ERROR_SUCCESS
        );

#ifdef _DEBUG

    void AssertValid() const;

#endif // _DEBUG

protected:
    LONG  m_ctor_err;
    LONG  m_api_err;
    DWORD m_time_created;
    BOOL  m_fDirty;
};



class COMDLL CObjectPlus : public CObject, public CObjHelper
/*++

Class Description:

    Super CObject class.

Public Interface:

    CObjectPlus       : Constructor
    Compare           : Compare one object with another

--*/
{
public:
    CObjectPlus();

    //
    // Compare one object with another
    //
    virtual int Compare(
        IN const CObjectPlus * pob
        ) const;

    //
    // Define a typedef for an ordering function.
    //
    typedef int (CObjectPlus::*PCOBJPLUS_ORDER_FUNC)(
        IN const CObjectPlus * pobOther
        ) const;
};



class COMDLL CObListPlus : public CObList, public CObjHelper
/*++

Class Description:

    Object pointer list which optionally "owns" the objects pointed to, and
    with facility to sort.  If the list "owns" its objects, the destructor
    will clean up its member objects.

Public Interface:

    CObListPlus      : Constructor
    ~CObListPlus     : Destructor

    SetOwnership     : Set/reset ownership bit
    Index            : Get object by index
    RemoveIndex      : Remove object by index
    Remove           : Remove object
    RemoveAt         : Remove object at position
    RemoveAll        : Remove all objects
    FindElement      : Find object
    SetAll           : Set/Reset the dirty flag of all objects
    AddTail          : Add new object to the tail of the list
    Sort             : Sort the list elements with sorting function provided

--*/
{
//
// Constructor/Destructor
//
public:
    CObListPlus(
        IN int nBlockSize = 10
        );

    virtual ~CObListPlus();

//
// Access
//
public:
    BOOL SetOwnership(
        IN BOOL fOwned = TRUE
        );

    //
    // Return object at the given index
    //
    CObject * Index(
        IN int index
        );

    //
    // Remove item the given index
    //
    BOOL RemoveIndex(
        IN int index
        );

    //
    // Remove the given object from the list
    //
    BOOL Remove(
        IN CObject * pob
        );

    //
    // Remove the item at the given position
    //
    void RemoveAt(
        IN POSITION & pos
        );

    //
    // Remove all items from the list
    //
    void RemoveAll();

    int FindElement(
        IN CObject * pobSought
        ) const;

    //
    // Set all elements to dirty or clean.  Return TRUE if
    // any element was dirty.
    //
    BOOL SetAll(
        IN BOOL fDirty = FALSE
        );

    //
    // Sort the list elements according to the
    // given ordering function.  Return error code
    //
    DWORD Sort(
        IN CObjectPlus::PCOBJPLUS_ORDER_FUNC pOrderFunc
        );

protected:
    static int _cdecl SortHelper(
        IN const void * pa,
        IN const void * pb
        );

protected:
    BOOL m_fOwned;
};



class COMDLL CObListIter : public CObjectPlus
/*++

Class Description:

    Object iteration class

Public Interface:

    CObListIter       : Constructor
    Next              : Get next object
    Reset             : Reset the iteration index
    QueryPosition     : Query the current iteration index
    SetPosition       : Set the current position in the list by POSITION

--*/
{
public:
    CObListIter(
        IN const CObListPlus & obList
        );

    CObject * Next();
    void Reset();
    POSITION QueryPosition() const { return m_pos; }

    void SetPosition(
        IN POSITION pos
        );

protected:
    POSITION m_pos;
    const CObListPlus & m_obList;
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline CObjHelper::operator BOOL()
{
    return IsValid();
}

inline void CObjHelper::SetDirty(
    IN BOOL fDirty 
    )
{
    m_fDirty = fDirty;
}

inline void CObjHelper::ResetErrors()
{
    m_ctor_err = m_api_err = ERROR_SUCCESS;
}

inline BOOL CObListPlus::SetOwnership(
    IN BOOL fOwned
    )
{
    BOOL fOld = m_fOwned;
    m_fOwned = fOwned;

    return fOld;
}

inline void CObListIter::SetPosition(
    IN POSITION pos
    )
{
    m_pos = pos;
}

#endif // _COMMON_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\comprop\odlbox.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        odlbox.cpp

   Abstract:

        Owner draw listbox/combobox base classes

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include "comprop.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#define new DEBUG_NEW

#define BMP_LEFT_OFFSET  (1)          // Space allotted to the left of bitmap
#define BMP_RIGHT_OFFSET (3)          // Space allotted to the right of bitmap

//
// Ellipses are shown when column text doesn't fit in the display
//
const TCHAR g_szEllipses[] = _T("...");
int g_nLenEllipses = (sizeof(g_szEllipses) / sizeof(g_szEllipses[0])) - 1;

//
// Registry value for columns
//
const TCHAR g_szRegColumns[] = _T("Columns");

//
// Column Value Seperator
//
const TCHAR g_szColValueSep[] = _T(" ");



void
GetDlgCtlRect(
    IN  HWND hWndParent,
    IN  HWND hWndControl,
    OUT LPRECT lprcControl
    )
/*++

Routine Description:

    Get the control rectangle coordinates relative to its parent.  This can
    then be used in e.g. SetWindowPos()

Arguments:

    HWND hWndParent    : Parent window handle
    HWND hWndControl   : Control window handle
    LPRECT lprcControl : Control rectangle to be filled in

Return Value:

    None

--*/
{
#define MapWindowRect(hwndFrom, hwndTo, lprc)\
     MapWindowPoints((hwndFrom), (hwndTo), (POINT *)(lprc), 2)

    ::GetWindowRect(hWndControl, lprcControl);
    ::MapWindowRect(NULL, hWndParent, lprcControl);
}



void
FitPathToControl(
    IN CWnd & wndControl,
    IN LPCTSTR lpstrPath
    )
/*++

Routine Description:

    Display the given path in the given control, using ellipses
    to ensure that the path fits within the control.

Arguments:

    CWnd & wndControl       : Control to display on
    LPCTSTR lpstrPath       : Path

Return Value:

    None

--*/
{
    CString strDisplay(lpstrPath);
    UINT uLength = strDisplay.GetLength() + 4;  // Account for ell.
    LPTSTR lp = strDisplay.GetBuffer(uLength);

    if (lp)
    {
        CDC * pDC = wndControl.GetDC();
        ASSERT(pDC != NULL);

        if (pDC != NULL)
        {
            CRect rc;
            wndControl.GetClientRect(&rc);
            pDC->DrawText(lp, uLength, &rc, DT_PATH_ELLIPSIS | DT_MODIFYSTRING);
            wndControl.ReleaseDC(pDC);
        }

        strDisplay.ReleaseBuffer();
        wndControl.SetWindowText(strDisplay);
    }
}



void
ActivateControl(
    IN CWnd & wndControl,
    IN BOOL fShow
    )
/*++

Routine Description:

    Show/hide _AND_ enable/disable control window

Arguments:

    CWnd & wndControl           : Window in question
    BOOL fShow                  : TRUE to show/enable,
                                  FALSE to hide/disable

Return Value:

    None

Notes:

    Merely hiding a window does not disable it.  Use this function
    instead of ShowWindow() to do that.

--*/
{
    wndControl.ShowWindow(fShow ? SW_SHOW : SW_HIDE);
    wndControl.EnableWindow(fShow);
}




BOOL
CMappedBitmapButton::LoadMappedBitmaps(
    IN UINT nIDBitmapResource,
    IN UINT nIDBitmapResourceSel,
    IN UINT nIDBitmapResourceFocus,
    IN UINT nIDBitmapResourceDisabled
    )
/*++

Routine Description:

    LoadBitmaps will load one, two, three or all four bitmaps
    returns TRUE if all specified images are loaded.  This
    will map the buttons to the default colours

Arguments:

    UINT nIDBitmapResource           : Standard button
    UINT nIDBitmapResourceSel        : Selected button
    UINT nIDBitmapResourceFocus      : Button with focus
    UINT nIDBitmapResourceDisabled   : Disabled button

--*/
{
    //
    // delete old bitmaps (if present)
    //
    m_bitmap.DeleteObject();
    m_bitmapSel.DeleteObject();
    m_bitmapFocus.DeleteObject();
    m_bitmapDisabled.DeleteObject();

    if (!m_bitmap.LoadMappedBitmap(nIDBitmapResource))
    {
        TRACEEOLID("Failed to load bitmap for normal image.");

        return FALSE;   // need this one image
    }

    BOOL bAllLoaded = TRUE;
    if (nIDBitmapResourceSel != 0)
    {
        if (!m_bitmapSel.LoadMappedBitmap(nIDBitmapResourceSel))
        {
            TRACEEOLID("Failed to load bitmap for selected image.");
            bAllLoaded = FALSE;
        }
    }
    if (nIDBitmapResourceFocus != 0)
    {
        if (!m_bitmapFocus.LoadMappedBitmap(nIDBitmapResourceFocus))
        {
            bAllLoaded = FALSE;
        }
    }

    if (nIDBitmapResourceDisabled != 0)
    {
        if (!m_bitmapDisabled.LoadMappedBitmap(nIDBitmapResourceDisabled))
        {
            bAllLoaded = FALSE;
        }
    }

    return bAllLoaded;
}



CRMCListBoxResources::CRMCListBoxResources(
    IN int bmId,
    IN int nBitmaps,
    IN COLORREF rgbBackground
    )
/*++

Routine Description:

    Constructor

Arguments:

    int bmId               : Bitmap resource ID
    int nBitmaps           : Number of bitmaps
    COLORREF rgbBackground : Background colour to mask out

Return Value:

    N/A

--*/
    : m_idBitmap(bmId),
      m_rgbColorTransparent(rgbBackground),
      m_nBitmaps(nBitmaps),
      m_nBitmapHeight(0),
      m_nBitmapWidth(-1),    // Set Later
      m_fInitialized(FALSE)
{
    ASSERT(m_nBitmaps > 0);
    GetSysColors();
    PrepareBitmaps();
}



CRMCListBoxResources::~CRMCListBoxResources()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    UnprepareBitmaps();
}



void
CRMCListBoxResources::UnprepareBitmaps()
/*++

Routine Description:

    Free up bitmap resources

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    ASSERT(m_fInitialized);

    if (m_fInitialized)
    {
        CBitmap * pBmp = (CBitmap *)CGdiObject::FromHandle(m_hOldBitmap);
        ASSERT(pBmp != NULL);

        VERIFY(m_dcFinal.SelectObject(pBmp));
        VERIFY(m_dcFinal.DeleteDC());
        VERIFY(m_bmpScreen.DeleteObject());

        m_fInitialized = FALSE;
    }
}



void
CRMCListBoxResources::PrepareBitmaps()
/*++

Routine Description:

    Prepare 2 rows of bitmaps.  One with the selection colour background,
    and one with the ordinary listbox background.

Arguments:

    None

Return Value:

    None

--*/
{
    ASSERT(m_idBitmap);

    //
    // Clean up if we were already initialised
    //
    if (m_fInitialized)
    {
        UnprepareBitmaps();
    }

    //
    // create device contexts compatible with screen
    //
    CDC dcImage;
    CDC dcMasks;

    VERIFY(dcImage.CreateCompatibleDC(0));
    VERIFY(dcMasks.CreateCompatibleDC(0));

    VERIFY(m_dcFinal.CreateCompatibleDC(0));

    CBitmap bitmap;
    VERIFY(bitmap.LoadBitmap(m_idBitmap));

    BITMAP bm;
    VERIFY(bitmap.GetObject(sizeof(BITMAP), &bm));

    //
    // Each bitmap is assumed to be the same size.
    //
    m_nBitmapWidth = bm.bmWidth / m_nBitmaps;
    ASSERT(m_nBitmapWidth > 0);

    const int bmWidth = bm.bmWidth;
    const int bmHeight = bm.bmHeight;
    m_nBitmapHeight = bmHeight;

    CBitmap * pOldImageBmp = dcImage.SelectObject(&bitmap);
    ASSERT(pOldImageBmp);

    CBitmap bmpMasks;
    VERIFY(bmpMasks.CreateBitmap(bmWidth, bmHeight * 2, 1, 1, NULL));

    CBitmap * pOldMaskBmp = (CBitmap *)dcMasks.SelectObject(&bmpMasks);
    ASSERT(pOldMaskBmp);

    //
    // create the foreground and object masks
    //
    COLORREF crOldBk = dcImage.SetBkColor(m_rgbColorTransparent);
    dcMasks.BitBlt(0, 0, bmWidth, bmHeight, &dcImage, 0, 0, SRCCOPY);
    dcMasks.BitBlt(0, 0, bmWidth, bmHeight, &dcImage, 0, bmHeight, SRCAND);
    dcImage.SetBkColor(crOldBk);
    dcMasks.BitBlt(0, bmHeight, bmWidth, bmHeight, &dcMasks, 0, 0, NOTSRCCOPY);

    //
    // create DC to hold final image
    //
    VERIFY(m_bmpScreen.CreateCompatibleBitmap(&dcImage, bmWidth, bmHeight * 2));
    CBitmap * pOldBmp = (CBitmap*)m_dcFinal.SelectObject(&m_bmpScreen);
    ASSERT(pOldBmp);
    m_hOldBitmap = pOldBmp->m_hObject;

    CBrush b1, b2;
    VERIFY(b1.CreateSolidBrush(m_rgbColorHighlight));
    VERIFY(b2.CreateSolidBrush(m_rgbColorWindow));

    m_dcFinal.FillRect(CRect(0, 0, bmWidth, bmHeight), &b1);
    m_dcFinal.FillRect(CRect(0, bmHeight, bmWidth, bmHeight * 2), &b2);

    //
    // mask out the object pixels in the destination
    //
    m_dcFinal.BitBlt(0, 0, bmWidth, bmHeight, &dcMasks, 0, 0, SRCAND);

    //
    // mask out the background pixels in the image
    //
    dcImage.BitBlt(0, 0, bmWidth, bmHeight, &dcMasks, 0, bmHeight, SRCAND);

    //
    // XOR the revised image into the destination
    //
    m_dcFinal.BitBlt(0, 0, bmWidth, bmHeight, &dcImage, 0, 0, SRCPAINT);

    //
    // mask out the object pixels in the destination
    //
    m_dcFinal.BitBlt(0, bmHeight, bmWidth, bmHeight, &dcMasks, 0, 0, SRCAND);

    //
    // XOR the revised image into the destination
    //
    m_dcFinal.BitBlt(0, bmHeight, bmWidth, bmHeight, &dcImage, 0, 0, SRCPAINT);

    VERIFY(dcMasks.SelectObject(pOldMaskBmp));
    VERIFY(dcImage.SelectObject(pOldImageBmp));

    //
    // The result of all of this mucking about is a bitmap identical with the
    // one loaded from the resources but with the lower row of bitmaps having
    // their background changed from transparent1 to the window background
    // and the upper row having their background changed from transparent2 to
    // the highlight colour.  A derived CRMCListBox can BitBlt the relevant part
    // of the image into an item's device context for a transparent bitmap
    // effect which does not take any extra time over a normal BitBlt.
    //
    m_fInitialized = TRUE;
}



void
CRMCListBoxResources::SysColorChanged()
/*++

Routine Description:

    Respond to change in system colours by rebuilding the resources

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Reinitialise bitmaps and syscolors. This should be called from
    // the parent of the CRMCListBoxResources object from
    // the OnSysColorChange() function.
    //
    GetSysColors();
    PrepareBitmaps();
}



void
CRMCListBoxResources::GetSysColors()
/*++

Routine Description:

    Get sytem colours

Arguments:

    None

Return Value:

    None

--*/
{
    m_rgbColorWindow = ::GetSysColor(COLOR_WINDOW);
    m_rgbColorHighlight = ::GetSysColor(COLOR_HIGHLIGHT);
    m_rgbColorWindowText = ::GetSysColor(COLOR_WINDOWTEXT);
    m_rgbColorHighlightText = ::GetSysColor(COLOR_HIGHLIGHTTEXT);
}


CRMCListBoxDrawStruct::CRMCListBoxDrawStruct(
    IN CDC * pDC,
    IN RECT * pRect,
    IN BOOL sel,
    IN DWORD_PTR item,
    IN int itemIndex,
    IN const CRMCListBoxResources * pres
    )
/*++

Routine Description:

    Constructor

Arguments:

    CDC * pdc                           : Device context
    RECT * pRect                        : Rectange to paint into
    BOOL sel                            : TRUE if selected
    DWORD_PTR item                          : item
    int itemIndex                       : item index
    const CRMCListBoxResources * pres    : Pointer to resources

Return Value:

    N/A

--*/
    : m_pDC(pDC),
      m_Sel(sel),
      m_ItemData(item),
      m_ItemIndex(itemIndex),
      m_pResources(pres)
{
    m_Rect.CopyRect(pRect);
}



CODLBox::CODLBox()
/*++

Routine Description:

    Constructor for CODLBox -- abstract base class for both CRMCComboBox,
    and CRMCListBox

Arguments:

    None

Return Value:

    N/A

--*/
    : m_lfHeight(0),
      m_pResources(NULL),
      m_auTabs(),
      m_pWnd(NULL)
{
}



CODLBox::~CODLBox()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
}



/* virtual */
BOOL
CODLBox::Initialize()
/*++

Routine Description:

    Listbox/combobox is being created

Arguments:

    None

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    //
    // Derived control must be attached at this point
    //
    ASSERT(m_pWnd != NULL);

    //
    // GetFont returns non NULL when the control is in a dialog box
    //
    CFont * pFont = m_pWnd->GetFont();

    if(pFont == NULL)
    {
        LOGFONT lf;
        CFont fontTmp;

/* INTRINSA suppress=null_pointers, uninitialized */
        ::GetObject(::GetStockObject(SYSTEM_FONT), sizeof(LOGFONT), &lf);
        fontTmp.CreateFontIndirect(&lf);

        CalculateTextHeight(&fontTmp);
    }
    else
    {
        CalculateTextHeight(pFont);
    }

    return TRUE;
}



BOOL
CODLBox::ChangeFont(
    IN CFont * pFont
    )
/*++

Routine Description:

    Change the control font the specified font

Arguments:

    CFont * pFont : Pointer to the new font to be used

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    ASSERT(m_pResources);
    ASSERT(m_pWnd != NULL);

    if( pFont == NULL || m_pResources == NULL
     || m_pWnd == NULL || m_pWnd->m_hWnd == NULL
      )
    {
        TRACEEOLID("Invalid state of the control.  Can't change font");
        return FALSE;
    }

    //
    // Don't reflect changes immediately
    //
    m_pWnd->SetRedraw(FALSE);

    m_pWnd->SetFont(pFont, TRUE);
    CalculateTextHeight(pFont);

    int nItems = __GetCount();
    int bmHeight = m_pResources->BitmapHeight();
    int nHeight = bmHeight > m_lfHeight ? bmHeight : m_lfHeight;

    for(int i = 0; i < nItems; ++i)
    {
        __SetItemHeight(i, nHeight);
    }

    //
    // Now reflect the change visually
    //
    m_pWnd->SetRedraw(TRUE);
    m_pWnd->Invalidate();

    return TRUE;
}



void
CODLBox::AttachResources(
    IN const CRMCListBoxResources * pRes
    )
/*++

Routine Description:

    Attach the bitmaps

Arguments:

    const CRMCListBoxResources * pRes : pointer to resources to be attached

Return Value:

    None

--*/
{
    if(pRes != m_pResources)
    {
        ASSERT(pRes != NULL);
        m_pResources = pRes;

        if(m_pWnd != NULL && m_pWnd->m_hWnd != NULL)
        {
            //
            // if window was created already, redraw everything.
            //
            m_pWnd->Invalidate();
        }
    }
}



/* static */
int
CODLBox::GetRequiredWidth(
    IN CDC * pDC,
    IN const CRect & rc,
    IN LPCTSTR lpstr,
    IN int nLength
    )
/*++

Routine Description:

    Determine required display width of the string

Arguments:

    CDC * pDC         : Pointer to device context to use
    const CRect & rc  : Starting rectangle
    LPCTSTR lpstr     : String whose width is to be displayed
    int nLength       : Length (in characters of the string

Return Value:

    The display width that the string would need to be displayed on the
    given device context

--*/
{
#ifdef _DEBUG

    pDC->AssertValid();

#endif // _DEBUG

    CRect rcTmp(rc);

    pDC->DrawText(
        lpstr,
        nLength,
        &rcTmp,
        DT_CALCRECT | DT_LEFT | DT_SINGLELINE | DT_NOPREFIX | DT_VCENTER
        );

    return rcTmp.Width();
}



/* static */
BOOL
CODLBox::ColumnText(
    IN CDC * pDC,
    IN int nLeft,
    IN int nTop,
    IN int nRight,
    IN int nBottom,
    IN LPCTSTR lpstr
    )
/*++

Routine Description:

    Display text limited by a rectangle.  Use ellipses if the text is too wide
    to fit inside the given dimensions.

Arguments:

    CDC * pDC     : Pointer to display context to use
    int nLeft     : Left coordinate
    int nTop      : Top coordinate
    int nRight    : Right coordinate
    int nBottom   : Bottom coordinate
    LPCTSTR lpstr : String to be displayed

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    BOOL fSuccess = TRUE;

#ifdef _DEBUG

    pDC->AssertValid();

#endif // _DEBUG

    CString str;
    CRect rc(nLeft, nTop, nRight, nBottom);

    int nAvailWidth = rc.Width();
    int nLength = ::lstrlen(lpstr);

    try
    {
        if (GetRequiredWidth(pDC, rc, lpstr, nLength) <= nAvailWidth)
        {
            //
            // Sufficient space, display as is.
            //
            str = lpstr;
        }
        else
        {
            //
            // Build a string with ellipses until it
            // fits
            //
            LPTSTR lpTmp = str.GetBuffer(nLength + g_nLenEllipses);
            while (nLength)
            {
                ::lstrcpyn(lpTmp, lpstr, nLength);
                ::lstrcpy(lpTmp + nLength - 1, g_szEllipses);

                if (GetRequiredWidth(pDC, rc, lpTmp,
                    nLength + g_nLenEllipses) <= nAvailWidth)
                {
                    break;
                }

                --nLength;
            }

            str = lpTmp;
        }

        pDC->DrawText(
           str,
           &rc,
           DT_LEFT | DT_SINGLELINE | DT_NOPREFIX | DT_VCENTER
           );

    }
    catch(CMemoryException * e)
    {
        //
        // Mem failure
        //
        fSuccess = FALSE;
        e->ReportError();
        e->Delete();
    }

    return fSuccess;
}



void
CODLBox::ComputeMargins(
    IN  CRMCListBoxDrawStruct & ds,
    IN  int nCol,
    OUT int & nLeft,
    OUT int & nRight
    )
/*++

Routine Description:

    Compute the left and right margins of the given column.

Arguments:

    CRMCListBoxDrawStruct & ds : Drawing structure
    int nCol                  : Column whose margins we're interested in
    int & nLeft               : Left column
    int & nRight              : Right column

Return Value:

    None

--*/
{
    nLeft = ds.m_Rect.left;
    nRight = ds.m_Rect.right;

    //
    // Find tab value associated with column index (0-based),
    // and adjust left and right
    //
    ASSERT(nCol <= NumTabs());
    if (nCol > 0)
    {
        if (nCol <= NumTabs())
        {
            nLeft += m_auTabs[nCol-1];
        }
    }
    if (nCol < NumTabs())
    {
        nRight = m_auTabs[nCol];
    }
}



BOOL
CODLBox::DrawBitmap(
    IN CRMCListBoxDrawStruct & ds,
    IN int nCol,
    IN int nID
    )
/*++

Routine Description:

    Draw a bitmap in the given column.  Bitmap are always placed on the
    leftmost side of the column if there is sufficient space.

Arguments:

    CRMCListBoxDrawStruct & ds : Drawing structure
    int nCol                  : Column to place bitmap in
    int nID                   : Bitmap ID (offset within the bitmap resources)

Return Value:

    None

--*/
{
    CDC * pBmpDC = (CDC *)&ds.m_pResources->dcBitMap();

#ifdef _DEBUG

    pBmpDC->AssertValid();

#endif // _DEBUG

    //
    // Select the bitmap with either a selection or
    // a regular background
    //
    int bm_h = ds.m_Sel ? 0 : ds.m_pResources->BitmapHeight();
    int bm_w = ds.m_pResources->BitmapWidth() * nID;

    int nLeft, nRight;
    ComputeMargins(ds, nCol, nLeft, nRight);
    nLeft += BMP_LEFT_OFFSET;

    //
    // Check to make sure there's enough room before
    // drawing the bitmap.
    //
    if (nRight - nLeft >= ds.m_pResources->BitmapWidth())
    {
        ds.m_pDC->BitBlt(
            nLeft,
            ds.m_Rect.top,
            ds.m_pResources->BitmapWidth(),
            ds.m_pResources->BitmapHeight(),
            pBmpDC,
            bm_w,
            bm_h,
            SRCCOPY
            );
    }

    return TRUE;
}



BOOL
CODLBox::ColumnText(
    IN CRMCListBoxDrawStruct & ds,
    IN int nCol,
    IN BOOL fSkipBitmap,
    IN LPCTSTR lpstr
    )
/*++

Routine Description:

    Draw column text.

Arguments:

    CRMCListBoxDrawStruct & ds : Drawing structure
    int nCol                  : Column to place bitmap in
    BOOL fSkipBitmap          : If TRUE, increment lefthand column by the width
                                of a bitmap
    LPCTSTR lpstr             : String to be displayed.  May be truncated as
                                necessary

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    int nLeft, nRight;

    ComputeMargins(ds, nCol, nLeft, nRight);

    //
    // Optionally adjust for bitmap
    //
    if (fSkipBitmap)
    {
        nLeft += (ds.m_pResources->BitmapWidth() + BMP_RIGHT_OFFSET);
    }

    return CODLBox::ColumnText(
        ds.m_pDC,
        nLeft,
        ds.m_Rect.top,
        nRight,
        ds.m_Rect.bottom,
        lpstr
        );
}



void
CODLBox::CalculateTextHeight(
    IN CFont * pFont
    )
/*++

Routine Description:

    Calculate and set the text height of font

Arguments:

    CFont * pFont : Pointer to the font to be used.

Return Value:

    None

--*/
{
    ASSERT(m_pWnd != NULL);

    CClientDC dc(m_pWnd);
    CFont * pOldFont = dc.SelectObject(pFont);

    TEXTMETRIC tm;
    dc.GetTextMetrics(&tm);
    m_lfHeight = tm.tmHeight;

    dc.SelectObject(pOldFont);
}



int
CODLBox::AddTab(
    IN UINT uTab
    )
/*++

Routine Description:

    Add a tab to the end of the list (e.g the right side of the header)

Arguments:

    UINT uTab : Tab value to set

Return Value:

    The index of the new tab

--*/
{
    return (int)m_auTabs.Add(uTab);
}



int
CODLBox::AddTabFromHeaders(
    IN CWnd & wndLeft,
    IN CWnd & wndRight
    )
/*++

Routine Description:

    Add a tab to the end of the list (e.g the right side of the header),
    but compute the tab by taking the difference in left-hand coordinat of two
    window controls (usually static header text)

Arguments:

    CWnd & wndLeft   : Left window
    CWnd & wndRight  : Right window

Return Value:

    The index of the new tab

--*/
{
    CRect rcLeft, rcRight;

    wndLeft.GetWindowRect(&rcLeft);
    wndRight.GetWindowRect(&rcRight);

    ASSERT(rcRight.left > rcLeft.left);

    return AddTab(rcRight.left - rcLeft.left - 1);
}



int
CODLBox::AddTabFromHeaders(
    IN UINT idLeft,
    IN UINT idRight
    )
/*++

Routine Description:

    Similar to the function above, but use the control IDs.  The parent
    window is assumed to be the same as the parent window of the listbox

Arguments:

    UINT idLeft  : ID of the left control
    UINT idRight : ID of the right control

Return Value:

    The index of the new tab or -1 in case of failure

--*/
{
    ASSERT(m_pWnd);
    if (m_pWnd == NULL)
    {
        //
        // Should have associated window handle by now
        //
        return -1;
    }

    CWnd * pLeft = m_pWnd->GetParent()->GetDlgItem(idLeft);
    CWnd * pRight = m_pWnd->GetParent()->GetDlgItem(idRight);
    ASSERT(pLeft && pRight);
    if (!pLeft || !pRight)
    {
        //
        // One or both control IDs were not valid
        //
        return -1;
    }

    return AddTabFromHeaders(*pLeft, *pRight);
}



void
CODLBox::InsertTab(
    IN int nIndex,
    IN UINT uTab
    )
/*++

Routine Description:

    Insert a tab at the given index

Arguments:

    int nIndex : Column index at which the tab is to be inserted
    UINT uTab  : Tab value to set

Return Value:

    None

--*/
{
    m_auTabs.InsertAt(nIndex, uTab);
}



void
CODLBox::RemoveTab(
    IN int nIndex,
    IN int nCount
    )
/*++

Routine Description:

    Remove one or more tabs

Arguments:

    int nIndex : Column index at which to start removing tabs
    int nCount : Number of tabs to be removed

Return Value:

    None

--*/
{
    m_auTabs.RemoveAt(nIndex, nCount);
}



void
CODLBox::RemoveAllTabs()
/*++

Routine Description:

    Remove all tabs

Arguments:

    None

Return Value:

    None

--*/
{
    m_auTabs.RemoveAll();
}



void
CODLBox::__DrawItem(
    IN LPDRAWITEMSTRUCT lpDIS
    )
/*++

Routine Description:

    Draw an item.  This will draw the focus and selection state, and then
    call out to the derived class to draw the item.

Arguments:

    LPDRAWITEMSTRUCT lpDIS : The drawitem structure

Return Value:

    None

--*/
{
    //
    // Need to attach resources before creation/adding items
    //
    ASSERT(m_pResources);

    CDC * pDC = CDC::FromHandle(lpDIS->hDC);

#ifdef _DEBUG

    pDC->AssertValid();

#endif // _DEBUG

    //
    // Draw focus rectangle when no items in listbox
    //
    if(lpDIS->itemID == (UINT)-1)
    {
        if(lpDIS->itemAction & ODA_FOCUS)
        {
            //
            // rcItem.bottom seems to be 0 for variable height list boxes
            //
            lpDIS->rcItem.bottom = m_lfHeight;
            pDC->DrawFocusRect(&lpDIS->rcItem);
        }

        return;
    }
    else
    {
        BOOL fSelChange   = (lpDIS->itemAction & ODA_SELECT) != 0;
        BOOL fFocusChange = (lpDIS->itemAction & ODA_FOCUS) != 0;
        BOOL fDrawEntire  = (lpDIS->itemAction & ODA_DRAWENTIRE) != 0;

        if(fSelChange || fDrawEntire)
        {
            BOOL fSel = (lpDIS->itemState & ODS_SELECTED) != 0;

            COLORREF hlite   = (fSel ? (m_pResources->ColorHighlight())
                                     : (m_pResources->ColorWindow()));
            COLORREF textcol = (fSel ? (m_pResources->ColorHighlightText())
                                     : (m_pResources->ColorWindowText()));
            pDC->SetBkColor(hlite);
            pDC->SetTextColor(textcol);

            //
            // fill the rectangle with the background colour.
            //
            pDC->ExtTextOut(0, 0, ETO_OPAQUE, &lpDIS->rcItem, NULL, 0, NULL);

            CRMCListBoxDrawStruct ds(pDC,
                (RECT *)&lpDIS->rcItem,
                fSel,
                (DWORD_PTR)lpDIS->itemData,
                lpDIS->itemID,
                m_pResources
                );

            //
            // Now call the draw function of the derived class
            //
            DrawItemEx(ds);
        }

        if (fFocusChange || (fDrawEntire && (lpDIS->itemState & ODS_FOCUS)))
        {
            pDC->DrawFocusRect(&lpDIS->rcItem);
        }
    }
}



void
CODLBox::__MeasureItem(
    IN OUT LPMEASUREITEMSTRUCT lpMIS
    )
/*++

Routine Description:

    Provide dimensions of given item

Arguments:

    LPMEASUREITEMSTRUCT lpMIS : Measure item structure

Return Value:

    None

--*/
{
    ASSERT(m_pResources);

    int h = lpMIS->itemHeight;
    int ch = TextHeight();
    int bmHeight = m_pResources->BitmapHeight();

    lpMIS->itemHeight = ch < bmHeight ? bmHeight : ch;
}



CRMCListBoxHeader::CRMCListBoxHeader(
    IN DWORD dwStyle
    )
/*++

Routine Description:

    Constructor.

Arguments:

    DWORD dwStyle : Style bits

Return Value:

    N/A

--*/
    : m_pHCtrl(NULL),
      m_pListBox(NULL),
      m_dwStyle(dwStyle),
      m_fRespondToColumnWidthChanges(TRUE)
{
    m_pHCtrl = new CHeaderCtrl;
}



CRMCListBoxHeader::~CRMCListBoxHeader()
/*++

Routine Description:

    Destructor.

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    //
    // Kill the header control and the
    // font
    //
    if (m_pHCtrl)
    {
        delete m_pHCtrl;
    }

    //
    // Leave the listbox pointer alone, as we don't
    // own it, but are merely associated with it.
    //
}

//
// Message Map
//
BEGIN_MESSAGE_MAP(CRMCListBoxHeader, CStatic)
    //{{AFX_MSG_MAP(CRMCListBoxHeader)
    ON_WM_DESTROY()
    //}}AFX_MSG_MAP

    ON_NOTIFY_RANGE(HDN_ENDTRACK,    0, 0xFFFF, OnHeaderEndTrack)
    ON_NOTIFY_RANGE(HDN_ITEMCHANGED, 0, 0xFFFF, OnHeaderItemChanged)
    ON_NOTIFY_RANGE(HDN_ITEMCLICK,   0, 0xFFFF, OnHeaderItemClick)

END_MESSAGE_MAP()



void
CRMCListBoxHeader::OnDestroy()
/*++

Routine Description:

    WM_DESTROY message handler.  When the control is being destroyed,
    also destroy the invisible static control.

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Destroy optional header control
    //
    if (m_pHCtrl)
    {
        m_pHCtrl->DestroyWindow();
    }

    CStatic::OnDestroy();
}



BOOL
CRMCListBoxHeader::Create(
    IN DWORD dwStyle,
    IN const RECT & rect,
    IN CWnd * pParentWnd,
    IN CHeaderListBox * pListBox,
    IN UINT nID
    )
/*++

Routine Description:

    Create the control.  This will first create an invisible static window,
    which is to take up the entire area of the listbox.  This static window
    then will be the parent to the listbox as well as this header control.

Arguments:

    DWORD dwStyle              : Creation style bits
    const RECT & rect          : Rectangle in which the header is to be created
    CWnd * pParentWnd          : Parent window
    CHeaderListBox * pListBox  : Associated listbox
    UINT nID                   : Control ID of the header

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    //
    // Make sure the real header control exists by now
    //
    if (m_pHCtrl == NULL)
    {
        return FALSE;
    }

    //
    // Make sure there's an associated listbox
    //
    m_pListBox = pListBox;
    if (m_pListBox == NULL)
    {
        return FALSE;
    }

    //
    // Create the controlling static window as do-nothing window
    //
    if (!CStatic::Create(NULL, WS_VISIBLE | SS_BITMAP | WS_CHILD,
        rect, pParentWnd, 0xFFFF))
    {
        return FALSE;
    }

    //
    // Now create the header control. Its parent
    // window is this static control we just created
    //
    CRect rc(0, 0, 0 ,0);
    dwStyle |= (UseButtons() ? HDS_BUTTONS : 0L);
    VERIFY(m_pHCtrl->Create(dwStyle, rc, this, nID));

    //
    // Place header control as per style bits,
    // compute the desired layout, and move it
    //
    HD_LAYOUT hdl;
    WINDOWPOS wp;

    GetClientRect(&rc);
    hdl.prc = &rc;
    hdl.pwpos = &wp;

    m_pHCtrl->Layout(&hdl);
    m_pHCtrl->SetWindowPos(m_pListBox, wp.x, wp.y,
        wp.cx, wp.cy, wp.flags | SWP_SHOWWINDOW);

    //
    // And move our associated listbox just below it
    //
    ::GetDlgCtlRect(GetParent()->m_hWnd, m_pListBox->m_hWnd, &rc);
    rc.top += wp.cy - 1;

    //
    // Adjust if header is bigger than the entire listbox
    //
    if (rc.top > rc.bottom)
    {
        rc.top = rc.bottom;
    }
    m_pListBox->MoveWindow(rc.left, rc.top, rc.Width(), rc.Height());

    //
    // Make sure the header uses the right font
    //
    m_pHCtrl->SetFont(
        CFont::FromHandle((HFONT)::GetStockObject(DEFAULT_GUI_FONT)),
        FALSE
        );

    return TRUE;
}



void
CRMCListBoxHeader::OnHeaderEndTrack(
    IN  UINT nId,
    IN  NMHDR * pnmh,
    OUT LRESULT * pResult
    )
/*++

Routine Description:

    User has finished dragging the column divider.  If we're supposed to ensure
    that the last column is a stretch column, turn off the redraw now -- it
    will get turned back on after the column width changes have all been
    completed.  This will reduce the flash effect.

Arguments:

    UINT nId          : Control ID
    NMHDR * pnmh      : Notification header structure
    LRESULT * pResult : Result.  Will be set to 0 if the message was handled

Return Value:

    None (handled in pResult)

--*/
{
    if (DoesRespondToColumnWidthChanges() && UseStretch())
    {
        //
        // This will get turned back on in OnHeaderItemChanged
        //
        SetRedraw(FALSE);
    }

    *pResult = 0;
}



void
CRMCListBoxHeader::SetColumnWidth(
    IN int nCol,
    IN int nWidth
    )
/*++

Routine Description:

    Set the given column to the given width

Arguments:

    int nCol        : Column number
    int nWidth      : New width

Return Value:

    None

--*/
{
    ASSERT(nCol < QueryNumColumns());
    if (nCol >= QueryNumColumns())
    {
        return;
    }

    TRACEEOLID("Setting width of column  " << nCol << " to " << nWidth);

    HD_ITEM hdItem;

    hdItem.mask = HDI_WIDTH;
    hdItem.cxy = nWidth;
    VERIFY(SetItem(nCol, &hdItem));
}



void
CRMCListBoxHeader::OnHeaderItemChanged(
    IN  UINT nId,
    IN  NMHDR *pnmh,
    OUT LRESULT *pResult
    )
/*++

Routine Description:

    Handle change in header column width.  Note: we're actually tracking
    the HDN_ITEMCHANGED notification, not the HDN_ENDDRAG one, because
    the latter is sent out before the column widths in the structure have
    changed.

Arguments:

    UINT nId          : Control ID
    NMHDR * pnmh      : Notification header structure
    LRESULT * pResult : Result.  Will be set to 0 if the message was handled

Return Value:

    None (handled in pResult)

--*/
{
    //
    // Adjust tabs in associate listbox if
    // column widths have changed
    //
    HD_NOTIFY * pNotify = (HD_NOTIFY *)pnmh;
    if (DoesRespondToColumnWidthChanges() && pNotify->pitem->mask & HDI_WIDTH)
    {
        ASSERT(m_pListBox);

        //
        // Stretch the last column
        //
        if (UseStretch())
        {
            //
            // Turn this off, as we don't want
            // to get in an infinite loop
            //
            RespondToColumnWidthChanges(FALSE);

            //
            // Compute available space
            //
            CRect rc;
            GetClientRect(&rc);

            //
            // See how much is taken up by preceding
            // columns
            //
            int nTotalWidth = 0;
            int cColumns = QueryNumColumns();
            int nLastCol = cColumns - 1;
            ASSERT(nLastCol >= 0);

            for (int nCol = 0; nCol < nLastCol; ++nCol)
            {
                int nWidth = GetColumnWidth(nCol);

                //
                // Each column must be at least one pixel wide
                //
                int nMaxWidth = rc.Width() - nTotalWidth - (nLastCol - nCol);
                if (nWidth > nMaxWidth)
                {
                    nWidth = nMaxWidth;
                    SetColumnWidth(nCol, nWidth);
                }

                nTotalWidth += nWidth;
            }

            //
            // Make sure the last column takes up the rest
            //
            if (rc.Width() > nTotalWidth)
            {
                SetColumnWidth(nLastCol, rc.Width() - nTotalWidth);
            }

            //
            // Turn this back on again
            //
            RespondToColumnWidthChanges(TRUE);

            //
            // Redraw will have been turned off in
            // OnHeaderEndTrack, now that all column
            // movement has completed, turn it back
            // on to draw the control in its current
            // state.
            //
            SetRedraw(TRUE);
            Invalidate();
        }

        //
        // Recompute tabs on associate listbox,
        // and force redraw on it.
        //
        m_pListBox->SetRedraw(FALSE);
        SetTabsFromHeader();
        m_pListBox->SetRedraw(TRUE);
        m_pListBox->Invalidate();
    }

    *pResult = 0;
}



void
CRMCListBoxHeader::OnHeaderItemClick(
    IN  UINT nId,
    IN  NMHDR *pnmh,
    OUT LRESULT *pResult
    )
/*++

Routine Description:

    A button has been clicked in the header control.  Pass it on
    to the real parent window.

Arguments:

    UINT nId          : Control ID
    NMHDR * pnmh      : Notification header structure
    LRESULT * pResult : Result.  Will be set to 0 if the message was handled

Return Value:

    None (handled in pResult)

--*/
{
    //
    // Pass notification on to parent
    //
    ASSERT(GetParent());
    GetParent()->SendMessage(WM_NOTIFY, (WPARAM)nId, (LPARAM)pnmh);
    *pResult = 0;
}



void
CRMCListBoxHeader::SetTabsFromHeader()
/*++

Routine Description:

    Set the tabs (which are cumulative) from the header control
    columns (which are not)

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Must have the same number of tabs
    // as header columns
    //
    ASSERT(m_pListBox);
    ASSERT(GetItemCount() == m_pListBox->NumTabs());

    int nTab = 0;
    for (int n = 0; n < m_pListBox->NumTabs(); ++n)
    {
        m_pListBox->SetTab(n, nTab += GetColumnWidth(n));
    }
}



int
CRMCListBoxHeader::GetItemCount() const
/*++

Routine Description:

    Get the number of items in the header

Arguments:

    None

Return Value:

    The number of items in the header (e.g. the number of columns)

--*/
{
    ASSERT(m_pHCtrl);
    return m_pHCtrl->GetItemCount();
}



BOOL
CRMCListBoxHeader::GetItem(
    IN  int nPos,
    OUT HD_ITEM * pHeaderItem
    ) const
/*++

Routine Description:

    Get information on specific position (column index)

Arguments:

    int nPos              : Column index
    HD_ITEM * pHeaderItem : Header item information

Return Value:

    TRUE for success, FALSE for failure (bad column index)

--*/
{
    ASSERT(m_pHCtrl);
    return m_pHCtrl->GetItem(nPos, pHeaderItem);
}



int
CRMCListBoxHeader::GetColumnWidth(
    IN int nPos
    ) const
/*++

Routine Description:

    Get column width of a specific column

Arguments:

    int nPos : Column index

Return Value:

    The column width of the given colum, or -1 in case of failure (bad
    column index)

--*/
{
    HD_ITEM hi;

    hi.mask = HDI_WIDTH;
    if (GetItem(nPos, &hi))
    {
        return hi.cxy;
    }

    return -1;
}



BOOL
CRMCListBoxHeader::SetItem(
    IN int nPos,
    IN HD_ITEM * pHeaderItem
    )
/*++

Routine Description:

    Set information on specific position (column index)

Arguments:

    int nPos              : Column index
    HD_ITEM * pHeaderItem : Header item information

Return Value:

    TRUE for success, FALSE for failure (bad column index)

--*/
{
    ASSERT(m_pHCtrl);
    ASSERT(m_pListBox);

    if (!m_pHCtrl->SetItem(nPos, pHeaderItem))
    {
        return FALSE;
    }

    if (pHeaderItem->mask & HDI_WIDTH)
    {
        SetTabsFromHeader();
    }

    return TRUE;
}



int
CRMCListBoxHeader::InsertItem(
    IN int nPos,
    IN HD_ITEM * pHeaderItem
    )
/*++

Routine Description:

    insert information in specific position (column index)

Arguments:

    int nPos              : Column index
    HD_ITEM * pHeaderItem : Header item information

Return Value:

    The new index, or -1 in case of failure.

--*/
{
    ASSERT(m_pHCtrl);
    ASSERT(m_pListBox);

    int nCol = m_pHCtrl->InsertItem(nPos, pHeaderItem);
    if (nCol != -1)
    {
        //
        // Set 0-width tab, as tabs get recomputed anyway
        //
        m_pListBox->InsertTab(nPos, 0);
        SetTabsFromHeader();
    }

    return nCol;
}



BOOL
CRMCListBoxHeader::DeleteItem(
    IN int nPos
    )
/*++

Routine Description:

    Delete the given item (i.e. column)

Arguments:

    int nPos              : Column index

Return Value:

    TRUE for success, FALSE for failure (bad column index)

--*/
{
    ASSERT(m_pHCtrl);
    ASSERT(m_pListBox);

    if (!m_pHCtrl->DeleteItem(nPos))
    {
        return FALSE;
    }

    m_pListBox->RemoveTab(nPos, 1);

    return TRUE;
}



IMPLEMENT_DYNAMIC(CRMCListBoxHeader, CStatic);



CRMCListBox::CRMCListBox()
/*++

Routine Description:

    Constructor

Arguments:

    None

Return Value:

    N/A

--*/
    : m_fInitialized(FALSE),
      m_fMultiSelect(FALSE)
{
}



CRMCListBox::~CRMCListBox()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CRMCListBox, CListBox)
    //{{AFX_MSG_MAP(CRMCListBox)
    ON_WM_CREATE()
    ON_WM_DESTROY()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



/* virtual */
BOOL
CRMCListBox::Initialize()
/*++

Routine Description:

    This function should be called directly when subclassing an existing
    listbox, otherwise OnCreate will take care of it.

Arguments:

    None

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    //
    // Make sure we're only initialized once
    //
    if (m_fInitialized)
    {
        return TRUE;
    }

    //
    // Ensure the base class knows our window
    // handle
    //
    AttachWindow(this);

    if (!CODLBox::Initialize())
    {
        return FALSE;
    }

    m_fInitialized = TRUE;

    DWORD dwStyle = GetStyle();
    m_fMultiSelect = (dwStyle & (LBS_EXTENDEDSEL | LBS_MULTIPLESEL)) != 0;

    return m_fInitialized;
}



void
CRMCListBox::MeasureItem(
    IN LPMEASUREITEMSTRUCT lpMIS
    )
/*++

Routine Description:

    CListBox override to ODL base class

Arguments:

    LPMEASUREITEMSTRUCT lpMIS : Measure item structure

Return Value:

    None

--*/
{
    CODLBox::__MeasureItem(lpMIS);
}



void
CRMCListBox::DrawItem(
    IN LPDRAWITEMSTRUCT lpDIS
    )
/*++

Routine Description:

    CListBox override to ODL base class

Arguments:

    LPDRAWITEMSTRUCT lpDIS : Drawing item structure

Return Value:

    None

--*/
{
    CODLBox::__DrawItem(lpDIS);
}



/* virtual */
void
CRMCListBox::DrawItemEx(
    IN CRMCListBoxDrawStruct & dw
    )
/*++

Routine Description:

    Do-nothing extended draw function, which should
    be provided by the derived class.  This one will
    ASSERT, and should never be called.

Arguments:

    CRMCListBoxDrawStruct & dw   : Draw Structure

Return Value:

    None

--*/
{
    TRACEEOLID("Derived class did not provide DrawItemEx");
    ASSERT(FALSE);
}



/* virtual */
int
CRMCListBox::__GetCount() const
/*++

Routine Description:

    Provide GetCount() to ODL base class

Arguments:

    None

Return Value:

    Count of items in the listbox

--*/
{
    return GetCount();
}



/* virtual */
int
CRMCListBox::__SetItemHeight(
    IN int nIndex,
    IN UINT cyItemHeight
    )
/*++

Routine Description:

    Provide SetItemHeight() to ODL base class

Arguments:

    None

Return Value:

    LB_ERR if the index or height is invalid.

--*/
{
    return SetItemHeight(nIndex, cyItemHeight);
}



int
CRMCListBox::OnCreate(
    IN LPCREATESTRUCT lpCreateStruct
    )
/*++

Routine Description:

    Listbox is being created

Arguments:

    LPCREATESTRUCT lpCreateStruct : Creation structure

Return Value:

    -1 for failure, 0 for success

--*/
{
    if (CListBox::OnCreate(lpCreateStruct) == -1)
    {
        return -1;
    }

    Initialize();

    return 0;
}



int
CRMCListBox::GetCurSel() const
/*++

Routine Description:

    Get the index of the current selected item

Arguments:

    None

Return Value:

    On multi-selection listbox, it will return
    the index of an item, iff that is the only
    item selected.

    On single-selection listbox, it behaves as
    normal.

--*/
{
    if (IsMultiSelect())
    {
        //
        // We only like it if one item is selected
        //
        int nCurSel = LB_ERR;

        if (CListBox::GetSelCount() == 1)
        {
            if (CListBox::GetSelItems(1, &nCurSel) != 1)
            {
                nCurSel = LB_ERR;
            }
        }

        return nCurSel;
    }

    //
    // Single select listbox
    //
    return CListBox::GetCurSel();
}



int
CRMCListBox::SetCurSel(
    IN int nSelect
    )
/*++

Routine Description:

    Select an item.  On a multi-select listbox,
    this will deselect everything except the given
    item.

Arguments:

    int nSelect     : Index of the item to be selected, or
                      -1 to reset all selections.

Return Value:

    LB_ERR in case of error.

--*/
{
    if (IsMultiSelect())
    {
        //
        // Reset all selections
        //
        int nReturn = SelItemRange(FALSE, 0, GetCount() - 1);

        if (nSelect >= 0)
        {
            //
            // Ensure item is visible
            //
            nReturn = CListBox::SetSel(nSelect, TRUE);
            CListBox::SetCaretIndex(nSelect, 0);
        }

        return nReturn;
    }

    return CListBox::SetCurSel(nSelect);
}



int
CRMCListBox::GetSel(
    IN int nSel
    ) const
/*++

Routine Description:

    Determine if the given item is selected or not
    Works for both single and multi-select listboxes

Arguments:

    int nSel        : Item whose state to check

Return Value:

    LB_ERR in case of error, 0 if the item in question
    is not selected, a positive number if it is.

--*/
{
    if (IsMultiSelect())
    {
        return CListBox::GetSel(nSel);
    }

    //
    // Some magic for single select
    //
    if (nSel < 0 || nSel >= CListBox::GetCount())
    {
        return LB_ERR;
    }

    return nSel == CListBox::GetCurSel()
        ? TRUE
        : FALSE;
}



int
CRMCListBox::GetSelCount() const
/*++

Routine Description:

    Return count of selected items.  Works for both
    single and multi select (in the former case,
    it will return zero or one only)

Arguments:

    None

Return Value:

    Count of selected items

--*/
{
    if (IsMultiSelect())
    {
        return CListBox::GetSelCount();
    }

    return GetCurSel() != LB_ERR ? 1 : 0;
}



void *
CRMCListBox::GetSelectedListItem(
    OUT int * pnSel     OPTIONAL
    )
/*++

Routine Description:

    Return the single selected item in the list or NULL

Arguments:

    int * pnSel     : Optionally returns the selected index

Returns:

    The currently selected (single) item, or NULL
    if 0 or more than one items is selected.  Works for
    both multi-select and single select.

--*/
{
    void * pItem = NULL;

    int nCurSel = GetCurSel();
    if (nCurSel >= 0)
    {
        //
        // Get item properties
        //
        pItem = GetItemDataPtr(nCurSel);
        if (pnSel)
        {
            *pnSel = nCurSel;
        }
    }

    return pItem;
}



void *
CRMCListBox::GetNextSelectedItem(
    IN OUT int * pnStartingIndex
    )
/*++

Routine Description:

    Return the next selected item starting at a specific
    index.

Arguments:

    int *pnStartingIndex          : Starting index (>= 0)

Return Value:

    Pointer to next selected item, or NULL if there are
    none left.

    The starting index will be updated to reflect the current
    index, LB_ERR if no more selected items remain.

--*/
{
    ASSERT(pnStartingIndex);
    if (!pnStartingIndex)
    {
        return NULL;
    }

    ASSERT(*pnStartingIndex >= 0);
    if (*pnStartingIndex < 0)
    {
        *pnStartingIndex = 0;
    }

    if (IsMultiSelect())
    {
        //
        // Multi-select -- loop through
        // until found
        //
        BOOL fFoundItem = FALSE;

        while (*pnStartingIndex < GetCount())
        {
            if (CListBox::GetSel(*pnStartingIndex) > 0)
            {
                ++fFoundItem;
                break;
            }

            ++(*pnStartingIndex);
        }

        if (!fFoundItem)
        {
            *pnStartingIndex = LB_ERR;
        }
    }
    else
    {
        //
        // Single select listbox, so there's no
        // looping through -- either the selected item
        // (if any) is in range or it isn't.
        //
        int nCurSel = CListBox::GetCurSel();
        *pnStartingIndex = (nCurSel >= *pnStartingIndex) ? nCurSel : LB_ERR;
    }

    return (*pnStartingIndex != LB_ERR)
        ? GetItemDataPtr(*pnStartingIndex)
        : NULL;
}



BOOL
CRMCListBox::SelectItem(
    IN void * pItemData
    )
/*++

Routine Description:

    Select the listbox item with the given data pointer

Arguments:

    void * pItemData : Item to search for

Return Value:

    TRUE if the item was found and selected, FALSE otherwise

Notes:

    On a multi-select listbox, this will unselect
    all other items in the listbox.

--*/
{
    if (pItemData != NULL)
    {
        for (int n = 0; n < GetCount(); ++n)
        {
            if (pItemData == GetItemDataPtr(n))
            {
                SetCurSel(n);

                return TRUE;
            }
        }
    }

    if (!IsMultiSelect())
    {
        //
        // Set no selection
        //
        SetCurSel(-1);
    }

    return FALSE;
}



void
CRMCListBox::InvalidateSelection(
    IN int nSel
    )
/*++

Routine Description:

    Force a repaint of the given selection

Arguments:

    int nSel : Index of the item to be repainted

Return Value:

    None

--*/
{
    CRect rc;

    if (GetItemRect(nSel, &rc) != LB_ERR)
    {
        InvalidateRect(&rc, TRUE);
    }
}



IMPLEMENT_DYNAMIC(CRMCListBox,CListBox);



CHeaderListBox::CHeaderListBox(
    IN DWORD dwStyle,
    IN LPCTSTR lpRegKey OPTIONAL
    )
/*++

Routine Description:

    Constructor

Arguments:

    DWORD   dwStyle  : Style bits (see HLS_*)
    LPCTSTR lpRegKey : If specified, the registry key where the column
                       sizes will be stored.

Return Value:

    None

--*/
    : m_strRegKey(),
      m_fInitialized(FALSE)
{
    m_pHeader = new CRMCListBoxHeader(dwStyle);
    if (lpRegKey)
    {
        GenerateRegistryKey(m_strRegKey, lpRegKey);
    }
}



CHeaderListBox::~CHeaderListBox()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    //
    // Clean up header control
    //
    ASSERT(m_pHeader);
    if (m_pHeader != NULL)
    {
        delete m_pHeader;
    }
}



//
// Message map
//
BEGIN_MESSAGE_MAP(CHeaderListBox, CRMCListBox)
    //{{AFX_MSG_MAP(CHeaderListBox)
    ON_WM_CREATE()
    ON_WM_DESTROY()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



/* virtual */
BOOL
CHeaderListBox::Initialize()
/*++

Routine Description:

    This function should be called directly when subclassing an existing
    listbox, otherwise OnCreate will take care of it, and this function
    should not be called

Arguments:

    None

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    //
    // Make sure we're only initialized once
    //
    if (m_fInitialized)
    {
        return TRUE;
    }

    if (!CRMCListBox::Initialize())
    {
        return FALSE;
    }

    //
    // Create header control
    //
    ASSERT(m_pHeader);
    if (m_pHeader)
    {
        TRACEEOLID("Creating Header");

        //
        // Create it in our location exactly
        //
        CRect rc;
        ::GetDlgCtlRect(GetParent()->m_hWnd, m_hWnd, &rc);

        //
        // Make sure the header control shares the same parent
        // as we do,
        //
        ASSERT(GetParent() != NULL);

        #ifndef CCS_NOHILITE
        #define CCS_NOHILITE 0x00000010L
        #endif

        DWORD dwStyle = WS_VISIBLE | CCS_TOP | CCS_NODIVIDER | WS_BORDER
            | HDS_HORZ;

        if (!m_pHeader->Create(dwStyle, rc, GetParent(), this, 0xFFFF))
        {
            return FALSE;
        }
    }

    m_fInitialized = TRUE;

    return TRUE;
}



int
CHeaderListBox::QueryColumnWidth(
    IN int nCol
    ) const
/*++

Routine Description:

    Get the width of the specified column

Arguments:

    int nCol : The column

Return Value:

    The width of the column, or -1 if the column index was out of range

--*/
{
    ASSERT(nCol < QueryNumColumns());
    if (nCol >= QueryNumColumns())
    {
        return -1;
    }

    HD_ITEM hdItem;

    hdItem.mask = HDI_WIDTH;
    VERIFY(GetHeaderItem(nCol, &hdItem));

    return hdItem.cxy;
}



BOOL
CHeaderListBox::SetColumnWidth(
    IN int nCol,
    IN int nWidth
    )
/*++

Routine Description:

    Set the width of the specified column

Arguments:

    int nCol   : The column
    int nWidth : New width

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    ASSERT(nCol < QueryNumColumns());
    if (nCol >= QueryNumColumns())
    {
        return FALSE;
    }

    TRACEEOLID("Setting width of column  " << nCol << " to " << nWidth);

    HD_ITEM hdItem;
    hdItem.mask = HDI_WIDTH;
    hdItem.cxy = nWidth;
    VERIFY(SetHeaderItem(nCol, &hdItem));

    return TRUE;
}



BOOL
CHeaderListBox::SetWidthsFromReg()
/*++

Routine Description:

    Attempt to set the column widths from the registry
    value we were initialized with.

Arguments:

    None

Return Value:

    TRUE if the column widths were succesfully set from the registry,
    FALSE otherwise

--*/
{
    if (m_strRegKey.IsEmpty())
    {
        //
        // No reg key specified
        //
        return FALSE;
    }

    //
    // Try to read the current column sizes from the registry
    //
    CRMCRegKey rkUser(HKEY_CURRENT_USER, m_strRegKey);

    if (!rkUser.Ok())
    {
        //
        // Path doesn't exist -- no problem.
        //
        return FALSE;
    }

    //
    // Don't auto adjust
    //
    m_pHeader->RespondToColumnWidthChanges(FALSE);

    CRect rc;
    m_pHeader->GetClientRect(&rc);

    CError err;

    try
    {
        CString strValue;
        err = rkUser.QueryValue(g_szRegColumns, strValue);
        int nTotalWidth = 0;

        if (err.Succeeded())
        {
            LPTSTR lpstrValue = strValue.GetBuffer(strValue.GetLength());
            LPTSTR lpWidth = StringTok(lpstrValue, g_szColValueSep);

            for (int n = 0; n < QueryNumColumns(); ++n)
            {
                ASSERT(lpWidth);
                if (lpWidth == NULL)
                {
                    err = ERROR_INVALID_PARAMETER;
                    break;
                }

                //
                // Sanity check
                //
                int nWidth = _ttoi(lpWidth);
                if (nWidth <= 0 || (nTotalWidth + nWidth > rc.Width()))
                {
                    ASSERT(FALSE && "column width invalid");

                    return FALSE;
                }

                nTotalWidth += nWidth;

                VERIFY(SetColumnWidth(n, nWidth));

                lpWidth = StringTok(NULL, g_szColValueSep);
            }
        }
    }
    catch(CMemoryException * e)
    {
        err = ERROR_NOT_ENOUGH_MEMORY;
        e->Delete();
    }

    TRACEEOLID("SetWidthsFromReg() error is " << err);

    //
    // Turn auto-adjust back on
    //
    m_pHeader->RespondToColumnWidthChanges(TRUE);

    return !err.MessageBoxOnFailure();
}



void
CHeaderListBox::DistributeColumns()
/*++

Routine Description:

    Proportion the column widths of over the entire width of the
    header control while maintaining relative proportions.

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Obtain available width
    //
    ASSERT(m_pHeader);

    CRect rc;
    m_pHeader->GetClientRect(&rc);

    //
    // Get current total width
    //
    int nTotalWeight = 0;
    int nCol;
    for (nCol = 0; nCol < QueryNumColumns(); ++nCol)
    {
        nTotalWeight += QueryColumnWidth(nCol);
    }

    //
    // And spread out the width, maintaining the same
    // proportions
    //

    //
    // Temporarily ignore changes
    //
    m_pHeader->RespondToColumnWidthChanges(FALSE);
    int cColumns = QueryNumColumns();
    for (nCol = 0; nCol < cColumns; ++nCol)
    {
        int nWidth = QueryColumnWidth(nCol);
        nWidth = rc.Width() * nWidth / nTotalWeight;
        VERIFY(SetColumnWidth(nCol, nWidth));
    }

    //
    // Turn changes back on
    //
    m_pHeader->RespondToColumnWidthChanges(TRUE);
}



int
CHeaderListBox::InsertColumn(
    IN int nCol,
    IN int nWeight,
    IN UINT nStringID
    )
/*++

Routine Description:

    Insert column.  The width of the column is actually a relative
    "weight" of the column which needs to be adjusted later.  The
    return value is the column number or -1 if the column is not inserted.

Arguments:

    int nCol        : Column number
    int nWeight     : Relative weight of column
    UINT nStringID  : Resource string ID

Return Value:

    Index of the column, or -1 in case of failure

--*/
{
    CString strColName;
    HD_ITEM hdItem;

    VERIFY(strColName.LoadString(nStringID));

    hdItem.mask = HDI_FORMAT | HDI_WIDTH | HDI_TEXT;
    hdItem.fmt = HDF_STRING | HDF_LEFT;
    hdItem.pszText = (LPTSTR)(LPCTSTR)strColName;
    hdItem.cchTextMax = strColName.GetLength();
    hdItem.cxy = nWeight;

    return InsertHeaderItem(nCol, &hdItem);
}



int
CHeaderListBox::OnCreate(
    IN LPCREATESTRUCT lpCreateStruct
    )
/*++

Routine Description:

    Listbox is being created

Arguments:

    LPCREATESTRUCT lpCreateStruct : Creation structure

Return Value:

    0 for success, -1 for failure

--*/
{
    if (CRMCListBox::OnCreate(lpCreateStruct) == -1)
    {
        return -1;
    }

    Initialize();

    return 0;
}



BOOL
CHeaderListBox::EnableWindow(
    IN BOOL bEnable
    )
/*++

Routine Description:

    Enable/disable the control.

Arguments:

    BOOL bEnable : TRUE to enable the control, FALSE to disable

Return Value:

    Indicates the state before the EnableWindow member function was called.
    The return value is nonzero if the window was previously disabled. The
    return value is 0 if the window was previously enabled or an error
    occurred.

--*/
{
    if (m_pHeader)
    {
        m_pHeader->EnableWindow(bEnable);
    }

    return CRMCListBox::EnableWindow(bEnable);
}



BOOL
CHeaderListBox::ShowWindow(
    IN int nCmdShow
    )
/*++

Routine Description:

    Show/hide the window

Arguments:

    int nCmdShow : SW_ flag such as SW_SHOW or SW_HIDE

Return Value:

    If the window was previously visible, the return value is TRUE. If the
    window was previously hidden, the return value is FALSE.

--*/
{
    if (m_pHeader)
    {
        m_pHeader->ShowWindow(nCmdShow);
    }

    return CRMCListBox::ShowWindow(nCmdShow);
}



void
CHeaderListBox::OnDestroy()
/*++

Routine Description:

    Handle destruction of the control

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Destroy optional header control
    //
    ASSERT(m_pHeader);
    if (m_pHeader)
    {
        if (!m_strRegKey.IsEmpty())
        {
            //
            // Try to write the current column sizes to the registry
            //
            CError err;

            CRMCRegKey rkUser(NULL, HKEY_CURRENT_USER, m_strRegKey);

            int nWidth;
            TCHAR szValue[32];
            CString strValue;

            try
            {
                for (int n = 0; n < GetHeaderItemCount(); ++n)
                {
                    if (n > 0)
                    {
                        //
                        // Put in field separator
                        //
                        strValue += g_szColValueSep;
                    }

                    nWidth = m_pHeader->GetColumnWidth(n);
                    strValue += ::_itot(nWidth, szValue, 10);
                }

                err = rkUser.SetValue(g_szRegColumns, strValue);
            }
            catch(CMemoryException * e)
            {
                err = ERROR_NOT_ENOUGH_MEMORY;
                e->Delete();
            }

            err.MessageBoxOnFailure();
        }

        m_pHeader->DestroyWindow();
    }

    CRMCListBox::OnDestroy();
}



IMPLEMENT_DYNAMIC(CHeaderListBox, CRMCListBox);



CRMCComboBox::CRMCComboBox()
/*++

Routine Description:

    Constructor

Arguments:

    None

Return Value:

    N/A

--*/
    : m_fInitialized(FALSE)
{
}



CRMCComboBox::~CRMCComboBox()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CRMCComboBox, CComboBox)
    //{{AFX_MSG_MAP(CRMCComboBox)
    ON_WM_CREATE()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()




/* virtual */
BOOL
CRMCComboBox::Initialize()
/*++

Routine Description:

    This function should be called directly when subclassing an existing
    combobox, otherwise OnCreate will take care of it.

Arguments:

    None

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    //
    // Make sure we're only initialized once
    //
    if (m_fInitialized)
    {
        return TRUE;
    }

    //
    // Ensure the base class knows our window
    // handle
    //
    AttachWindow(this);

    if (!CODLBox::Initialize())
    {
        return FALSE;
    }

    m_fInitialized = TRUE;

    return TRUE;
}



void
CRMCComboBox::MeasureItem(
    IN LPMEASUREITEMSTRUCT lpMIS
    )
/*++

Routine Description:

    CComboBox override to ODL base class

Arguments:

    LPMEASUREITEMSTRUCT lpMIS : Measure item structure

Return Value:

    None

--*/
{
    CODLBox::__MeasureItem(lpMIS);
}



void
CRMCComboBox::DrawItem(
    IN LPDRAWITEMSTRUCT lpDIS
    )
/*++

Routine Description:

    CListBox override to ODL base class

Arguments:

    LPDRAWITEMSTRUCT lpDIS : Drawing item structure

Return Value:

    None

--*/
{
    CODLBox::__DrawItem(lpDIS);
}



/* virtual */
void
CRMCComboBox::DrawItemEx(
    IN CRMCListBoxDrawStruct & dw
    )
/*++

Routine Description:

    Do-nothing extended draw function, which should
    be provided by the derived class.  This one will
    ASSERT, and should never be called.

Arguments:

    CRMCListBoxDrawStruct & dw   : Draw Structure

Return Value:

    None

--*/
{
    TRACEEOLID("Derived class did not provide DrawItemEx");
    ASSERT(FALSE);
}



int
CRMCComboBox::OnCreate(
    IN LPCREATESTRUCT lpCreateStruct
    )
/*++

Routine Description:

    Combo box is being created

Arguments:

    LPCREATESTRUCT lpCreateStruct : Creation structure

Return Value:

    -1 for failure, 0 for success

--*/
{
    if (CComboBox::OnCreate(lpCreateStruct) == -1)
    {
        return -1;
    }

    Initialize();

    return 0;
}



/* virtual */
int
CRMCComboBox::__GetCount() const
/*++

Routine Description:

    Provide CComboBox::GetCount() functionality to base class

Arguments:

    None

Return Value:

    Get the count of items in the combo box

--*/
{
    return GetCount();
}



/* virtual */
int
CRMCComboBox::__SetItemHeight(
    IN int nIndex,
    IN UINT cyItemHeight
    )
/*++

Routine Description:

    Provide CListBox::SetItemHeight() functionality to base class.

Arguments:

    int nIndex        : Index of the item
    UINT cyItemHeight : Height of the item

Return Value:

    SetItemHeight return value.

--*/
{
    return SetItemHeight(nIndex, cyItemHeight);
}



IMPLEMENT_DYNAMIC(CRMCComboBox,CComboBox);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\comprop\pwiz.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        pwiz.cpp

   Abstract:

        IIS Security Wizard

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//

#include "stdafx.h"
#include "comprop.h"
#include <aclapi.h>
#include <ntseapi.h>
#include <shlwapi.h>

//
// IIS Security Template Class
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


//
// Package of access rights granted for "READ" access
//
#define ACCMASK_READ_FLAGS  (0L\
    | FILE_READ_DATA\
    | READ_CONTROL\
    | SYNCHRONIZE\
    | FILE_READ_ATTRIBUTES\
    | FILE_READ_EA\
    )

//
// Package of access rights granted for "WRITE" access
//
// Note: This includes "delete" because the web service assumes
//       "delete" when granting write access.  This differs from
//       the norm.
//
#define ACCMASK_WRITE_FLAGS (0L\
    | FILE_WRITE_DATA\
    | FILE_APPEND_DATA\
    | DELETE\
    | FILE_WRITE_ATTRIBUTES\
    | FILE_WRITE_EA\
    )

//
// Package of access rights granted for "EXECUTE" access
//
#define ACCMASK_EXEC_FLAGS  (0L\
    | FILE_EXECUTE\
    )

//
// Package of access rights granted for "DIR BROWSE" access
//
//#define ACCMASK_DIRBROWSE_FLAGS (0L\
//    | DS_LIST_OBJECT\
//    )

//
// Package of access rights granted for "FULL CONTROL" access
//
#define ACCMASK_ADMIN_FLAGS (0L\
    | STANDARD_RIGHTS_ALL\
    | FILE_READ_DATA\
    | FILE_WRITE_DATA\
    | FILE_APPEND_DATA\
    | FILE_READ_EA\
    | FILE_WRITE_EA\
    | FILE_EXECUTE\
    | FILE_ADD_FILE\
    | FILE_ADD_SUBDIRECTORY\
    | FILE_READ_ATTRIBUTES\
    | FILE_WRITE_ATTRIBUTES\
    | FILE_LIST_DIRECTORY\
    | FILE_DELETE_CHILD\
    | FILE_TRAVERSE\
    | ACTRL_DS_LIST_OBJECT\
    )
//
// Package of access rights granted for "Everyone"
#define ACC_MASK_EVERYONE_FLAGS (0L\
      | ACCMASK_READ_FLAGS\
      | ACCMASK_EXEC_FLAGS\
      )
//
//
// Access permission bit strings
//
FLAGTOSTRING fsAccessPerms[] = 
{
    { MD_ACCESS_READ,    IDS_PERMS_READ,                TRUE },
    { MD_ACCESS_WRITE,   IDS_PERMS_WRITE,               TRUE },
    { MD_ACCESS_SCRIPT,  IDS_PERMS_SCRIPT,              TRUE },
    { MD_ACCESS_EXECUTE, IDS_PERMS_EXECUTE,             TRUE },
};

//
// Access mask bit strings
//
FLAGTOSTRING fsAclFlags[] = 
{
    { FILE_READ_DATA,         IDS_ACL_READ,           TRUE },
    { READ_CONTROL,           IDS_ACL_READ_CONTROL,   TRUE },
    { FILE_READ_ATTRIBUTES,   IDS_ACL_READ_ATTRIB,    TRUE },
    { FILE_READ_EA,           IDS_ACL_READ_PROP,      TRUE },
    { FILE_WRITE_DATA,        IDS_ACL_WRITE,          TRUE },
    { FILE_APPEND_DATA,       IDS_ACL_APPEND,         TRUE },
    { DELETE,                 IDS_ACL_DELETE,         TRUE },
    { FILE_WRITE_ATTRIBUTES,  IDS_ACL_WRITE_ATTRIB,   TRUE },
    { FILE_WRITE_EA,          IDS_ACL_WRITE_PROP,     TRUE },
    { FILE_EXECUTE,           IDS_ACL_EXECUTE,        TRUE },
//    { DS_LIST_CONTENTS,       IDS_ACL_LIST_OBJECT,    TRUE },
};



CIISSecurityTemplate::CIISSecurityTemplate(
    IN const CMetaKey * pKey,
    IN LPCTSTR lpszMDPath,
    IN BOOL    fInherit     
    )
/*++

Routine Description:

    Construct from open key

Arguments:

    const CMetaKey * pKey   : Open key
    LPCTSTR lpszMDPath      : Path
    BOOL    fInherit        : TRUE to inherit properties

Return Value:

    N/A

--*/
    : CMetaProperties(pKey, lpszMDPath),
      m_dwAccessPerms(0L),
      m_dlProperties(),
      m_strlSummary(),
      m_ipl()
{
    //
    // Set base class member
    //
    m_fInherit = fInherit;

    //
    // Managed Properties
    //
    m_dlProperties.AddTail(MD_ACCESS_PERM);
    m_dlProperties.AddTail(MD_IP_SEC);
}



/* virtual */
void
CIISSecurityTemplate::ParseFields()
/*++

Routine Description:

    Break into fields.

Arguments:

    None.

Return Value:

    None.

--*/
{
    BEGIN_PARSE_META_RECORDS(m_dwNumEntries,    m_pbMDData)
      HANDLE_META_RECORD(MD_ACCESS_PERM,        m_dwAccessPerms)
      HANDLE_META_RECORD(MD_IP_SEC,             m_ipl)
    END_PARSE_META_RECORDS

    //
    // If "execute" or "script" is on, read should be as well (makes
    // little sense otherwise)
    //
    if (IS_FLAG_SET(
        MP_V(m_dwAccessPerms), 
        (MD_ACCESS_EXECUTE | MD_ACCESS_SCRIPT)
        ))
    {
        SET_FLAG(MP_V(m_dwAccessPerms), MD_ACCESS_READ);
    }
}



/* virtual */
HRESULT 
CIISSecurityTemplate::ApplySettings(
    IN BOOL    fUseTemplate,
    IN LPCTSTR lpszServerName,
    IN LPCTSTR lpszService,
    IN DWORD   dwInstance,
    IN LPCTSTR lpszParent,
    IN LPCTSTR lpszAlias
    )
/*++

Routine Description:

    Apply the settings to the specified destination path

Arguments:
    
    BOOL    fUseTemplates      : TRUE if the source is from a template,
                                 FALSE if using inheritance.
    LPCTSTR lpszServerName     : Server name
    LPCTSTR lpszService        : Service name 
    DWORD   dwInstance         : Instance        
    LPCTSTR lpszParent         : Parent path (or NULL)
    LPCTSTR lpszAlias          : Alias name  (or NULL)

Return Value:

    HRESULT

--*/
{
    BOOL fWriteProperties = TRUE;

    CMetaKey mk(
        lpszServerName, 
        METADATA_PERMISSION_WRITE,
        lpszService,
        dwInstance,
        lpszParent,
        lpszAlias
        );

    CError err(mk.QueryResult());

    if (err.Win32Error() == ERROR_PATH_NOT_FOUND)
    {
        if (fUseTemplate)
        {
            //
            // Create the path
            //
            err = mk.CreatePathFromFailedOpen();

            if (err.Succeeded())
            {
                err = mk.ReOpen(METADATA_PERMISSION_WRITE);
            }
        }
        else
        {
            //
            // No need to delete properties; everything's already
            // inherited.
            //
            fWriteProperties = FALSE;
            err.Reset();
        }
    }

    if (fWriteProperties)
    {
        do
        {
            BREAK_ON_ERR_FAILURE(err);
            
            if (fUseTemplate)
            {
                //
                // Write values from template
                //
                err = mk.SetValue(
                    MD_ACCESS_PERM, 
                    m_dwAccessPerms
                    );
                BREAK_ON_ERR_FAILURE(err);

                err = mk.SetValue(MD_IP_SEC, m_ipl);
                BREAK_ON_ERR_FAILURE(err);
            }
            else
            {
                //
                // We're going to use inheritance, so delete
                // the values that might exist here
                //
                ASSERT(m_dlProperties.GetCount() > 0);

                POSITION pos = m_dlProperties.GetHeadPosition();

                while(pos)
                {
                    DWORD dwID = m_dlProperties.GetNext(pos);
                    err = mk.DeleteValue(dwID);

                    if (err.HResult() == MD_ERROR_DATA_NOT_FOUND)
                    {
                        //
                        // That's ok
                        //
                        err.Reset();
                    }

                    if (err.Failed())
                    {
                        break;
                    }
                }
            }
        }
        while(FALSE);
    }

    return err;
}



void
CIISSecurityTemplate::AddSummaryString(
    IN LPCTSTR szTextItem,
    IN int cIndentLevel         OPTIONAL
    )
/*++

Routine Description:

    Helper function to add strings to the summary

Arguments:

    LPCTSTR szTextItem      : String to be added
    int cIndentLevel        : Indentation level

Return Value:

    None

--*/
{
    CString str(szTextItem);
    
    //
    // Add a tab at the beginning of each string for each
    // level of indentation requested
    //
    for (int i = 0; i < cIndentLevel; ++i)
    {
        str = _T("\t") + str;
    }

    m_strlSummary.AddTail(str);
}



void
CIISSecurityTemplate::AddSummaryString(
    IN UINT nID,
    IN int cIndentLevel         OPTIONAL
    )
/*++

Routine Description:

    Helper function to add strings to the summary which are referred to
    by string table resource ID

Arguments:

    UINT nID                : Resource ID
    int cIndentLevel        : Indentation level

Return Value:

    None

--*/
{
    CString str;
    VERIFY(str.LoadString(nID));

    AddSummaryString(str, cIndentLevel);
}



/* virtual */
void 
CIISSecurityTemplate::GenerateSummary(
    IN BOOL    fUseTemplate,
    IN LPCTSTR lpszServerName,
    IN LPCTSTR lpszService,
    IN DWORD   dwInstance,
    IN LPCTSTR lpszParent,
    IN LPCTSTR lpszAlias
    )
/*++

Routine Description:

    Generate text summary of what's in the security template

Arguments:
    
    BOOL    fUseTemplates      : TRUE if the source is from a template,
                                 FALSE if using inheritance.
    LPCTSTR lpszServerName     : Server name
    LPCTSTR lpszService        : Service name 
    DWORD   dwInstance         : Instance        
    LPCTSTR lpszParent         : Parent path (or NULL)
    LPCTSTR lpszAlias          : Alias name  (or NULL)

Return Value:

    None

Notes:

    This doesn't clear the summary.  It's the responsibility of
    the calling process to clear beforehand, otherwise the summary
    items get added at the end.  

    The derived class is expected to add its own information

--*/
{
    //
    // Summarize Access Permissions:
    //
    int nIndentLevel = 0;

    AddSummaryString(IDS_PERMISSIONS, nIndentLevel++);

    if (m_dwAccessPerms == 0L)
    {
        AddSummaryString(IDS_SUMMARY_NONE, nIndentLevel);
    }
    else
    {
        for (int i = 0; i < ARRAY_SIZE(fsAccessPerms); ++i)
        {
            if (IS_FLAG_SET(
                m_dwAccessPerms, 
                fsAccessPerms[i].dwFlag
                ) == fsAccessPerms[i].fSet)
            {
                AddSummaryString(fsAccessPerms[i].nID, nIndentLevel);
            }
        }
    }

    //
    // Summarize IP Access Restrictions:
    //
    --nIndentLevel;
    AddSummaryString(IDS_ADDRESS_RESTRICTIONS, nIndentLevel++);

    if (MP_V(m_ipl).IsEmpty())
    {
        AddSummaryString(IDS_SUMMARY_NONE, nIndentLevel);
    }
    else
    {
        CObListPlus oblAccessList;
        BOOL        fGrantByDefault;

        //
        // Get text version of ip access list for the summary
        //
        CError err(BuildIplOblistFromBlob(
            m_ipl,
            oblAccessList,
            fGrantByDefault
            ));

        if (err.Succeeded())
        {
            //
            // List default denied/granted state
            //
            AddSummaryString(
                fGrantByDefault ? IDS_SUMMARY_GRANTED : IDS_SUMMARY_DENIED,
                nIndentLevel
                );

            //
            // Enumerate restrictions (exceptions to the default)
            //
            CObListIter obli(oblAccessList);
            CIPAccessDescriptor * pAccess;

            CString str,
                    strAddress,
                    strGrpFormat,
                    strGrantedFmt,
                    strDeniedFmt;

            VERIFY(strGrantedFmt.LoadString(IDS_SPECIFIC_GRANTED));
            VERIFY(strDeniedFmt.LoadString(IDS_SPECIFIC_DENIED));
            VERIFY(strGrpFormat.LoadString(IDS_FMT_SECURITY));

            while (pAccess = (CIPAccessDescriptor *)obli.Next())
            {
                if (pAccess->IsDomainName())
                {
                    strAddress = pAccess->QueryDomainName();
                }
                else if (pAccess->IsSingle())
                {
                    strAddress = (LPCTSTR)pAccess->QueryIPAddress();
                }
                else
                {
                    CString strIP, strMask;

                    strAddress.Format(
                        strGrpFormat, 
                        (LPCTSTR)pAccess->QueryIPAddress().QueryIPAddress(strIP), 
                        (LPCTSTR)pAccess->QuerySubnetMask().QueryIPAddress(strMask)
                        );
                }

                str.Format( 
                    pAccess->HasAccess() ? strGrantedFmt : strDeniedFmt,
                    strAddress
                    );

                AddSummaryString(str, nIndentLevel);
            }
        }
        else
        {
            //
            // better than nothing
            //
            AddSummaryString(IDS_ADDRESS_IP, nIndentLevel);
        }
    }
}



CIISSecWizSettings::CIISSecWizSettings(
    IN pfnNewSecurityTemplate pfnTemplateAllocator,
    IN LPCTSTR lpszServer,
    IN LPCTSTR lpszService,
    IN DWORD   dwInstance,
    IN LPCTSTR lpszParent,
    IN LPCTSTR lpszAlias
    )
/*++

Routine Description:

    Constructor

Arguments:

    pfnNewSecurityTemplate pfnTemplateAllocator : Function to allocate templ.
    LPCTSTR lpszServer      : Server name
    LPCTSTR lpszService     : Service name
    DWORD   dwInstance      : Instance number
    LPCTSTR lpszParent      : Parent path
    LPCTSTR lpszAlias       : Alias node name

Return Value:

    N/A

--*/
    : CObjectPlus(),
      m_pfnTemplateAllocator(pfnTemplateAllocator),
      m_strServer(lpszServer),
      m_strService(lpszService),
      m_strParent(),
      m_strAlias(),
      m_dwInstance(dwInstance),
      m_fUseTemplate(TRUE),
      m_fSetAcls(FALSE),
      m_fReplaceAcls(FALSE),
      m_pist(NULL),
      m_hResult(S_OK)
{
    if (lpszParent)
    {
        m_strParent = lpszParent;
    }

    if (lpszAlias)
    {
        m_strAlias = lpszAlias;
    }
}



CIISSecWizSettings::~CIISSecWizSettings()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    if (m_pist != NULL)
    {
        delete m_pist;
    }
}



HRESULT
CIISSecWizSettings::FetchProperties(
    IN CMetaKey & mk,
    IN LPCTSTR lpszPath,    OPTIONAL
    IN BOOL    fInherit     OPTIONAL    
    )
/*++

Routine Description:

    Fetch metabase properties that are applicable for the security wizard

Arguments:

    CMetaKey & mk    : open key
    LPCTSTR lpszPath : Optional path
    BOOL    fInherit : TRUE to inherit properties

Return Value:

    HRESULT

--*/
{
    CError err(mk.QueryResult());

    if (err.Succeeded())
    {
        if (m_pist != NULL)
        {
            //
            // Clean up existing template data (must 
            // have pressed "back")
            //
            delete m_pist;
        }

        //
        // Create security template by calling the provided
        // allocator (which allocates an object of the 
        // derived class which is service-specific)
        //  
        m_pist = (*m_pfnTemplateAllocator)(&mk, lpszPath, fInherit);

        if (m_pist == NULL)
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            err = m_pist->LoadData();
        }
    }
   
    return err;
}



//
// Permissions Wizard Source Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



IMPLEMENT_DYNCREATE(CPWSource, CIISWizardPage)



CPWSource::CPWSource(
    IN CIISSecWizSettings * pSettings
    )
/*++

Routine Description:

    Constructor

Arguments:

    CIISSecWizSettings * pSettings      : Settings

Return Value:

    None

--*/
    : CIISWizardPage(
        CPWSource::IDD,        // Template
        IDS_PERMWIZ,           // Caption
        HEADER_PAGE            // Header
        ),
      m_pSettings(pSettings)
{
    //{{AFX_DATA_INIT(CPWSource)
    m_nSource = RADIO_INHERITANCE;
    //}}AFX_DATA_INIT

    ASSERT(m_pSettings);
    ASSERT(!m_pSettings->m_strServer.IsEmpty());
}



CPWSource::~CPWSource()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
}



void 
CPWSource::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CIISWizardPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CPWSource)
    DDX_Radio(pDX, IDC_RADIO_INHERIT, m_nSource);
    //}}AFX_DATA_MAP
}



void
CPWSource::SetControlStates()
/*++

Routine Description:

    Set the state of the control data

Arguments:

    None

Return Value:

    None

--*/
{
    SetWizardButtons(PSWIZB_NEXT | PSWIZB_BACK);
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CPWSource, CIISWizardPage)
    //{{AFX_MSG_MAP(CPWSource)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BOOL 
CPWSource::OnSetActive() 
/*++

Routine Description:

    Activation handler

Arguments:

    None

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    SetControlStates();

    return CIISWizardPage::OnSetActive();
}



LRESULT 
CPWSource::OnWizardNext() 
/*++

Routine Description:

    'next' handler.  Store the source specified, so the next
    pages can skip or continue.

Arguments:

    None

Return Value:

    0 to proceed, -1 to fail

--*/
{
    UpdateData(TRUE);

    m_pSettings->m_fUseTemplate = (m_nSource == RADIO_TEMPLATE);

    if (!m_pSettings->m_fUseTemplate)
    {
        CError err;

        CMetaKey mk(
            m_pSettings->m_strServer, 
            METADATA_PERMISSION_READ,
            m_pSettings->m_strService,
            m_pSettings->m_dwInstance,
            m_pSettings->m_strParent,
            m_pSettings->m_strAlias
            );

        if (mk.IsHomeDirectoryPath())
        {
            //
            // Current path is a virtual server, and we're
            // at the home directory.  We need to back up 
            // twice.
            //
            err = mk.ConvertToParentPath(TRUE);
            ASSERT(err.Succeeded());
        }

        //
        // Convert to first parent path
        //
        err = mk.ConvertToParentPath(FALSE);

        if (err.Succeeded())
        {
            err = m_pSettings->FetchProperties(mk, NULL, TRUE);
        }

        if (err.MessageBoxOnFailure())
        {
            return -1;
        }
    }

    return CIISWizardPage::OnWizardNext();
}



//
// Permissions Wizard Template Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



IMPLEMENT_DYNCREATE(CPWTemplate, CIISWizardPage)



CPWTemplate::CPWTemplate(
    IN CIISSecWizSettings * pSettings
    )
/*++

Routine Description:

    Constructor

Arguments:

    CIISSecWizSettings * pSettings      : Settings

Return Value:

    None

--*/
    : CIISWizardPage(
        CPWTemplate::IDD,        // Template
        IDS_PERMWIZ,             // Caption
        HEADER_PAGE              // Header
        ),
      m_pSettings(pSettings)
{
    //{{AFX_DATA_INIT(CPWTemplate)
    //}}AFX_DATA_INIT

    ASSERT(m_pSettings);
    ASSERT(!m_pSettings->m_strServer.IsEmpty());
}



CPWTemplate::~CPWTemplate()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
}



void 
CPWTemplate::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CIISWizardPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CPWTemplate)
    DDX_Control(pDX, IDC_LIST_TEMPLATES,   m_list_Templates);
    DDX_Control(pDX, IDC_EDIT_DESCRIPTION, m_edit_Description);
    //}}AFX_DATA_MAP
}



void
CPWTemplate::SetControlStates()
/*++

Routine Description:

    Set the state of the control data

Arguments:

    None

Return Value:

    None

--*/
{
    DWORD dwFlags = PSWIZB_BACK;

    int nSel = m_list_Templates.GetCurSel();

    if (nSel >= 0)
    {
        dwFlags |= PSWIZB_NEXT;
    }

    SetWizardButtons(dwFlags);
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CPWTemplate, CIISWizardPage)
    //{{AFX_MSG_MAP(CPWTemplate)
    ON_LBN_SELCHANGE(IDC_LIST_TEMPLATES, OnSelchangeListTemplates)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BOOL 
CPWTemplate::OnSetActive() 
/*++

Routine Description:

    Activation handler

Arguments:

    None

Return Value:

    TRUE to show the page, FALSE to skip it.

--*/
{
    if (!m_pSettings->m_fUseTemplate)
    {
        return FALSE;
    }

    SetControlStates();

    return CIISWizardPage::OnSetActive();
}



LRESULT 
CPWTemplate::OnWizardNext() 
/*++

Routine Description:

    'next' handler.  Store the source specified, so the next
    pages can skip or continue.

Arguments:

    None

Return Value:

    0 to proceed, -1 to fail

--*/
{
    UpdateData(TRUE);

    int nSel = m_list_Templates.GetCurSel();

    if (nSel < 0)
    {
        return -1;
    }
    
    CString strItem;

    m_list_Templates.GetText(nSel, strItem);

    //
    // Fetch the template, which is the text up until the tab
    // character
    //
    int nTab = strItem.Find(_T('\t'));
    ASSERT(nTab >= 0);

    if (nTab >= 0)
    {
        strItem.ReleaseBuffer(nTab);
    }

    TRACEEOLID(strItem);

    //
    // Read the properties from the selected template
    //
    CMetaKey mk(
        m_pSettings->m_strServer, 
        METADATA_PERMISSION_READ,
        m_pSettings->m_strService,
        MASTER_INSTANCE,
        g_cszTemplates,
        strItem
        );

    CError err(m_pSettings->FetchProperties(mk, g_cszRoot, FALSE));

    if (err.MessageBoxOnFailure())
    {
        return -1;
    }

    return CIISWizardPage::OnWizardNext();
}



BOOL 
CPWTemplate::OnInitDialog() 
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CIISWizardPage::OnInitDialog();

    //
    // Assure the comments remain offscreen
    //
    m_list_Templates.SetTabStops(5000);

    //
    // Enumerate the existing templates
    //
    CMetaEnumerator mk(
        m_pSettings->m_strServer, 
        m_pSettings->m_strService,
        MASTER_INSTANCE,
        g_cszTemplates
        );

    CError err(mk.QueryResult());

    if (err.Failed())
    {
        if (err.Win32Error() == ERROR_PATH_NOT_FOUND)
        {
            AfxMessageBox(IDS_NO_TEMPLATES);
        }
        else
        {
            err.MessageBox();
        }
    }
    else
    {
        //
        // Enumerate and add to the listbox.
        //
        CString strTemplate, strComment, strListItem;

        while (err.Succeeded())
        {
            err = mk.Next(strTemplate);

            if (err.Succeeded())
            {
                //
                // Read off the open key
                //
                err = mk.QueryValue(
                    MD_SERVER_COMMENT, 
                    strComment, 
                    NULL, 
                    strTemplate
                    );

                if (err.Succeeded())
                {
                    TRACEEOLID(strComment);

                    //
                    // Append the comment in the off-screen
                    // area of the listbox
                    //
                    strListItem.Format(_T("%s\t%s"), 
                        (LPCTSTR)strTemplate, 
                        (LPCTSTR)strComment
                        );

                    m_list_Templates.AddString(strListItem);
                }
            }
        }
    }

    return TRUE;  
}



void 
CPWTemplate::OnSelchangeListTemplates() 
/*++

Routine Description:

    Handle selection change in the templates listbox

Arguments:

    None

Return Value:

    None

--*/
{
    int nSel = m_list_Templates.GetCurSel();
    ASSERT(nSel >= 0);

    if (nSel >= 0)
    {
        CString strItem;

        m_list_Templates.GetText(nSel, strItem);

        //
        // Fetch the comment, which is just beyond the tab
        // character
        //
        int nTab = strItem.Find(_T('\t'));
        ASSERT(nTab >= 0);

        if (nTab >= 0)
        {
            strItem = strItem.Mid(nTab + 1);
        }

        m_edit_Description.SetWindowText(_T(""));
        m_edit_Description.SetWindowText(strItem);
        Invalidate();
        UpdateWindow();
    }

    SetControlStates();
}



//
// Permissions Wizard ACL Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



IMPLEMENT_DYNCREATE(CPWACL, CIISWizardPage)



CPWACL::CPWACL(
    IN CIISSecWizSettings * pSettings
    )
/*++

Routine Description:

    Constructor

Arguments:

    CIISSecWizSettings * pSettings      : Settings

Return Value:

    None

--*/
    : CIISWizardPage(
        CPWACL::IDD,        // Template
        IDS_PERMWIZ,        // Caption,
        HEADER_PAGE         // Header
        ),
      m_pSettings(pSettings)
{
    //{{AFX_DATA_INIT(CPWACL)
    m_nRadioAclType = RADIO_MAXIMUM;
    //}}AFX_DATA_INIT

    ASSERT(m_pSettings);
    ASSERT(!m_pSettings->m_strServer.IsEmpty());
}



CPWACL::~CPWACL()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
}



void 
CPWACL::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CIISWizardPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CPWACL)
    DDX_Control(pDX, IDC_ED_BOLD4, m_static_Line4);
    DDX_Control(pDX, IDC_ED_BOLD3, m_static_Line3);
    DDX_Control(pDX, IDC_ED_BOLD2, m_static_Line2);
    DDX_Control(pDX, IDC_ED_BOLD1, m_static_Line1);
    DDX_Radio(pDX, IDC_RADIO_ACL_MAXIMUM, m_nRadioAclType);
    //}}AFX_DATA_MAP
}



void
CPWACL::SetControlStates()
/*++

Routine Description:

    Set the state of the control data

Arguments:

    None

Return Value:

    None

--*/
{
    SetWizardButtons(PSWIZB_NEXT | PSWIZB_BACK);
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CPWACL, CIISWizardPage)
    //{{AFX_MSG_MAP(CPWACL)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



BOOL
GetPhysicalPath(
    IN  CMetaKey & mk,
    IN  CString & strMetaPath,
    OUT CString & strPhysicalPath
    )
/*++

Routine Description:

    Get the physical path of the parent as described by the metabase path

Arguments:

    CMetaKey & mk               : Open metabase key
    CString & strMetaPath       : Metabase path
    CString & strPhysicalPath   : Returns physical path

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    //
    // Get physical path of parent
    //
    CString strAlias;
    int nSlash = strMetaPath.ReverseFind(SZ_MBN_SEP_CHAR);

    if (nSlash < 0)
    {
        //
        // Didn't encounter a physical path at all!
        //
        TRACEEOLID("No physical path established -- ACLS skipped");
        ASSERT(FALSE);

        return FALSE;
    }

    strAlias = strMetaPath.Mid(nSlash + 1);
    strMetaPath.ReleaseBuffer(nSlash);

    TRACEEOLID(strAlias);
    TRACEEOLID(strMetaPath);

    BOOL fInherit = FALSE;
    CError err(mk.QueryValue(
        MD_VR_PATH, 
        strPhysicalPath, 
        &fInherit, 
        strMetaPath
        ));

    if (err.Failed())
    {
        GetPhysicalPath(mk, strMetaPath, strPhysicalPath);
    }
    
    strPhysicalPath += _T("\\");
    strPhysicalPath += strAlias;

    return TRUE;
}



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


LRESULT 
CPWACL::OnWizardNext() 
/*++

Routine Description:

    'next' handler.  Store the acl replacement type specified, so the next
    pages can skip or continue.

Arguments:

    None

Return Value:

    0 to proceed, -1 to fail

--*/
{
    UpdateData(TRUE);

    switch(m_nRadioAclType)
    {
    case RADIO_MINIMUM:
        m_pSettings->m_fReplaceAcls = FALSE;
        break;

    case RADIO_MAXIMUM:
        m_pSettings->m_fReplaceAcls = TRUE;
        break;

    case RADIO_NONE:
    default:    
        m_pSettings->m_fSetAcls = FALSE;
    }

    return CIISWizardPage::OnWizardNext();
}


static PSID psidAdministrators = NULL;
static PSID psidEveryone = NULL;

BOOL 
CPWACL::OnSetActive() 
/*++

Routine Description:

    Activation handler

Arguments:

    None

Return Value:

    TRUE to show the page, FALSE to skip it.

--*/
{
    //
    // Assume no acls until all tests pass
    //
    m_pSettings->m_fSetAcls = FALSE;

    if (!IsServerLocal(m_pSettings->m_strServer))
    {
        TRACEEOLID("We're not local -- skipping ACL phase");
        return FALSE;
    }

    //
    // Get properties on the current directory object
    //
    CChildNodeProps props(
        m_pSettings->m_strServer, 
        m_pSettings->m_strService,
        m_pSettings->m_dwInstance,
        m_pSettings->m_strParent,
        m_pSettings->m_strAlias,
        WITH_INHERITANCE
        );

    CError err(props.LoadData());

    if (err.MessageBoxOnFailure())
    {
        TRACEEOLID("Unable to determine directory properties -- skipping ACLS");
        ASSERT(FALSE);

        return FALSE;
    }

    m_pSettings->m_fRedirected = props.IsRedirected();

    if (m_pSettings->m_fRedirected)
    {
        TRACEEOLID("Redirection in place, will not set ACLS");

        return FALSE;
    }

    //
    // If the path is on a remote store, Then no ACL page. - boydm
    //
    if (::IsUNCName(MP_V(props.m_strPath)))
    {
        TRACEEOLID("share is remote, will not set ACLS");

        return FALSE;
    }

    //
    // Don't get confused here, build the real physical path
    //
    if (props.IsPathInherited())
    {
        TRACEEOLID("Path inherited");

        //
        // Look for parent path.
        //
        CString strMetaPath(props.QueryMetaRoot());
        TRACEEOLID(strMetaPath);

        CMetaKey mk(m_pSettings->m_strServer);
        err = mk.QueryResult();

        if (err.Failed())
        {
            ASSERT(FALSE);

            return FALSE;
        }

        if (!GetPhysicalPath(mk, strMetaPath, m_pSettings->m_strPath))
        {
            ASSERT(FALSE);

            return FALSE;
        }

    }
    else
    {
        m_pSettings->m_strPath = props.m_strPath;
    }

    DWORD dwFileSystemFlags;

    if (::GetVolumeInformationSystemFlags(
        m_pSettings->m_strPath,
        &dwFileSystemFlags
        ))
    {
        if (!(dwFileSystemFlags & FS_PERSISTENT_ACLS))
        {
            //
            // No ACLS
            //
            TRACEEOLID("Volume type doesn't accept ACLS -- skipping");

            return FALSE;
        }
    }

    //
    // Build ACL information to be set
    //
    m_pSettings->m_AccessMaskAdmin = ACCMASK_ADMIN_FLAGS;
    m_pSettings->m_AccessMaskDefault
        = m_pSettings->m_AccessMaskEveryone = ACC_MASK_EVERYONE_FLAGS;

    //
    // Display proposed ACEs in bold-faced entries on the dialog
    //
    UINT nID = IDC_ED_BOLD1;

    CString str;

    VERIFY(str.LoadString(IDS_ACL_ADMINS));
    GetDlgItem(nID++)->SetWindowText(str);

    if (IS_FLAG_SET(m_pSettings->m_pist->m_dwAccessPerms, MD_ACCESS_READ))
    {
        VERIFY(str.LoadString(IDS_ACL_EV_READ));
        GetDlgItem(nID++)->SetWindowText(str);

        m_pSettings->m_AccessMaskEveryone |= ACCMASK_READ_FLAGS;
    }

    if (IS_FLAG_SET(m_pSettings->m_pist->m_dwAccessPerms, MD_ACCESS_WRITE))
    {
        VERIFY(str.LoadString(IDS_ACL_EV_WRITE));
        GetDlgItem(nID++)->SetWindowText(str);

        m_pSettings->m_AccessMaskEveryone |= ACCMASK_WRITE_FLAGS;
    }

    if (IS_FLAG_SET(m_pSettings->m_pist->m_dwAccessPerms, MD_ACCESS_EXECUTE))
    {
        VERIFY(str.LoadString(IDS_ACL_EV_EXEC));
        GetDlgItem(nID++)->SetWindowText(str);

        m_pSettings->m_AccessMaskEveryone |= ACCMASK_EXEC_FLAGS;
    }

   ZeroMemory(&m_pSettings->m_rgaae, sizeof(m_pSettings->m_rgaae));
   SID_IDENTIFIER_AUTHORITY siaNtAuthority = SECURITY_NT_AUTHORITY;
	SID_IDENTIFIER_AUTHORITY siaWorldSidAuthority = SECURITY_WORLD_SID_AUTHORITY;

	AllocateAndInitializeSid(
		&siaNtAuthority,
		2,
		SECURITY_BUILTIN_DOMAIN_RID,
		DOMAIN_ALIAS_RID_ADMINS, 
		0, 0, 0, 0, 0, 0,
		&psidAdministrators);
	AllocateAndInitializeSid(
		&siaWorldSidAuthority,
		1,
		SECURITY_WORLD_RID,
		0, 0, 0, 0, 0, 0, 0,
		&psidEveryone);

    //
    // Set up permissions for the "Everyone" group
    //
    m_pSettings->m_rgaae[0].Trustee.pMultipleTrustee = NULL;
    m_pSettings->m_rgaae[0].Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
    m_pSettings->m_rgaae[0].Trustee.TrusteeForm = TRUSTEE_IS_SID;
    m_pSettings->m_rgaae[0].Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
    m_pSettings->m_rgaae[0].Trustee.ptstrName = (LPTSTR)psidEveryone;

    m_pSettings->m_rgaae[0].grfAccessMode = SET_ACCESS;
    m_pSettings->m_rgaae[0].grfAccessPermissions  = m_pSettings->m_AccessMaskEveryone;
    m_pSettings->m_rgaae[0].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
    
    //
    // Set up permissions for the "Administrators" group
    //
    m_pSettings->m_rgaae[1].Trustee.pMultipleTrustee  = NULL;
    m_pSettings->m_rgaae[1].Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
    m_pSettings->m_rgaae[1].Trustee.TrusteeForm = TRUSTEE_IS_SID;
    m_pSettings->m_rgaae[1].Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
    m_pSettings->m_rgaae[1].Trustee.ptstrName = (LPTSTR)psidAdministrators;

    m_pSettings->m_rgaae[1].grfAccessMode = SET_ACCESS;
    m_pSettings->m_rgaae[1].grfAccessPermissions  = m_pSettings->m_AccessMaskAdmin;
    m_pSettings->m_rgaae[1].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;

    SetControlStates();

    //
    // Passed all tests, we'll give the option to set ACLS
    //
    m_pSettings->m_fSetAcls = TRUE;

    return CIISWizardPage::OnSetActive();
}



//
// Permissions Wizard Template Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



IMPLEMENT_DYNCREATE(CPWSummary, CIISWizardPage)



CPWSummary::CPWSummary(
    IN CIISSecWizSettings * pSettings
    )
/*++

Routine Description:

    Constructor

Arguments:

    CIISSecWizSettings * pSettings      : Settings

Return Value:

    None

--*/
    : CIISWizardPage(
        CPWSummary::IDD,        // Template
        IDS_PERMWIZ,            // Caption
        HEADER_PAGE             // Header
        ),
      m_pSettings(pSettings)
{
    //{{AFX_DATA_INIT(CPWSummary)
    //}}AFX_DATA_INIT

    ASSERT(m_pSettings);
    ASSERT(!m_pSettings->m_strServer.IsEmpty());
}



CPWSummary::~CPWSummary()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
}



void 
CPWSummary::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CIISWizardPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CPWSummary)
    DDX_Control(pDX, IDC_LIST_SUMMARY, m_list_Summary);
    //}}AFX_DATA_MAP
}



void
CPWSummary::SetControlStates()
/*++

Routine Description:

    Set the state of the control data

Arguments:

    None

Return Value:

    None

--*/
{
    SetWizardButtons(PSWIZB_NEXT | PSWIZB_BACK);
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CPWSummary, CIISWizardPage)
    //{{AFX_MSG_MAP(CPWSummary)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



void
CPWSummary::GenerateAclSummary()
/*++

Routine Description:

    Break down ACL list into the summary

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Summarize ACL Settings:
    //
    int nIndentLevel = 0;

    if (m_pSettings->m_fSetAcls)
    {
        m_pSettings->m_pist->AddSummaryString(
            m_pSettings->m_fReplaceAcls
                ? IDS_ACL_REPLACEMENT
                : IDS_ACL_ADDED,
            nIndentLevel++
            );

        m_pSettings->m_pist->AddSummaryString(IDS_ACL_ADMIN, nIndentLevel);
        m_pSettings->m_pist->AddSummaryString(IDS_ACL_EVR,   nIndentLevel++);

//        if (m_pSettings->m_AccessMaskEveryone 
//            == m_pSettings->m_AccessMaskDefault)
//        {
//            //
//            // "Everyone" has zero access
//            //
//            m_pSettings->m_pist->AddSummaryString(
//                IDS_SUMMARY_NONE, 
//                nIndentLevel
//                );
//        }
//        else
//        {
            //
            // Enumerate the specific rights granted
            // to "everyone"
            //
            for (int i = 0; i < ARRAY_SIZE(fsAclFlags); ++i)
            {
                if (IS_FLAG_SET(
                    m_pSettings->m_AccessMaskEveryone, 
                    fsAclFlags[i].dwFlag
                    ) == fsAclFlags[i].fSet)
                {
                    m_pSettings->m_pist->AddSummaryString(
                        fsAclFlags[i].nID, 
                        nIndentLevel
                        );
                }
            }
//        }
    }
    else
    {
        m_pSettings->m_pist->AddSummaryString(IDS_ACL_NONE, nIndentLevel);
    }
}




void
CPWSummary::DisplaySummary()
/*++

Routine Description:

    Break down the security settings and display them in text
    form in the summary listbox.

Arguments:

    None

Return Value:

    None.

--*/
{
    //
    // Generate Summary
    //
    m_pSettings->m_pist->ClearSummary();

    m_pSettings->m_pist->GenerateSummary(
        m_pSettings->m_fUseTemplate,
        m_pSettings->m_strServer,
        m_pSettings->m_strService,
        m_pSettings->m_dwInstance,
        m_pSettings->m_strParent,
        m_pSettings->m_strAlias
        );

    GenerateAclSummary();

    //
    // Display it in the listbox
    //
    m_list_Summary.ResetContent();
    POSITION pos = m_pSettings->m_pist->GetHeadPosition();

    while(pos)
    {
        CString & str = m_pSettings->m_pist->GetNext(pos);
        m_list_Summary.AddString(str);
    }
}



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BOOL 
CPWSummary::OnSetActive() 
/*++

Routine Description:

    Activation handler

Arguments:

    None

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    SetControlStates();

    DisplaySummary();

    return CIISWizardPage::OnSetActive();
}



/* virtual */
LRESULT
CPWSummary::OnWizardNext() 
/*++

Routine Description:

    'Next' button handler.  Force the control data to be stored

Arguments:

    None

Return Value:

    0 to proceed, -1 to fail

--*/ 
{
    //
    // Store everything here
    //
    CError err(m_pSettings->m_pist->ApplySettings(
        m_pSettings->m_fUseTemplate,
        m_pSettings->m_strServer,
        m_pSettings->m_strService,
        m_pSettings->m_dwInstance,
        m_pSettings->m_strParent,
        m_pSettings->m_strAlias
        ));

    //
    // Set the ACLS
    //
    if (err.Succeeded() && m_pSettings->m_fSetAcls)
    {
        err = ApplyACLSToFiles();
    }

    //
    // Store the error for the completion page
    //
    m_pSettings->m_hResult = err;

    return CIISWizardPage::OnWizardNext();
}



HRESULT
CPWSummary::ApplyACLSToFiles()
/*++

Routine Description:

    Apply ACLS to files

Arguments:

    None

Return Value:

    HRESULT

--*/
{
   CError err;
   SECURITY_INFORMATION si = 0;
   SECURITY_DESCRIPTOR * psd = NULL;
   PACL pOldDacl = NULL, pNewDacl = NULL;;

   //
   // Can take a while.
   //
   CWaitCursor waitcursor;
   
   do
   {
      err = GetNamedSecurityInfo(
               (LPTSTR)(LPCTSTR)m_pSettings->m_strPath,
               SE_FILE_OBJECT,
               DACL_SECURITY_INFORMATION,
               NULL,                         // owner SID
               NULL,                         // group SID
               &pOldDacl,                    // pointer to the DACL
               NULL,                         // pointer to the SACL
               (PVOID *)&psd
               );
      BREAK_ON_ERR_FAILURE(err);

      if (!m_pSettings->m_fReplaceAcls)
      {
         m_pSettings->m_rgaae[0].grfAccessMode = GRANT_ACCESS;
         m_pSettings->m_rgaae[1].grfAccessMode = GRANT_ACCESS;
      }
      // Prepare DACL according to template
      err = SetEntriesInAcl(
               ARRAY_SIZE(m_pSettings->m_rgaae),
               m_pSettings->m_rgaae,
               m_pSettings->m_fReplaceAcls ? NULL : pOldDacl,
               &pNewDacl
               );
      BREAK_ON_ERR_FAILURE(err);

      // Set permissions on the selected object
      si |= DACL_SECURITY_INFORMATION;
      si |= PROTECTED_DACL_SECURITY_INFORMATION;
      err = HRESULT_FROM_WIN32(SetNamedSecurityInfo(
                                 (LPTSTR)(LPCTSTR)m_pSettings->m_strPath,
                                 SE_FILE_OBJECT,
                                 si,
                                 NULL,
                                 NULL,
                                 pNewDacl,
                                 NULL));
	   BREAK_ON_ERR_FAILURE(err);
      // For children of this object we should set empty DACL
      // if we need only permissions inherited from parent
      if (PathIsDirectory(m_pSettings->m_strPath))
      {
         if (m_pSettings->m_fReplaceAcls)
         {
            // Build security descriptor with empty DACL
            ACL daclEmpty = {0};
            InitializeAcl(&daclEmpty, sizeof(ACL), ACL_REVISION);
            si = 0;
            si |= DACL_SECURITY_INFORMATION;
            si |= UNPROTECTED_DACL_SECURITY_INFORMATION;
            err = SetPermToChildren(
                m_pSettings->m_strPath,
                si,
                &daclEmpty,
                NULL);
            BREAK_ON_ERR_FAILURE(err);
         }
      }
      // In other cases children should inherit permissions from the parent

   }
   while(FALSE);

   if (pOldDacl != NULL) 
	{
		LocalFree(pOldDacl);
	}
   if (pNewDacl != NULL) 
	{
		LocalFree(pNewDacl);
	}
   if (psd != NULL) 
   {
      LocalFree(psd);
   }
   return err;
}



BOOL 
CPWSummary::OnInitDialog() 
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CIISWizardPage::OnInitDialog();

    //
    // Set the tabs based on the hidden column headers
    //
    CRect rc1, rc2;

    GetDlgItem(IDC_STATIC_TAB2)->GetWindowRect(&rc2);
    GetDlgItem(IDC_STATIC_TAB1)->GetWindowRect(&rc1);

    m_list_Summary.SetTabStops(((LPRECT)rc2)->left - ((LPRECT)rc1)->left);

    return TRUE;  
}



HRESULT 
COMDLL_ISMSecurityWizard(
    IN pfnNewSecurityTemplate pfnTemplateAllocator,
    IN CMetaInterface * pInterface,
    IN UINT    nLeftBmpId,
    IN UINT    nHeadBmpId,
    IN LPCTSTR lpszService,
    IN DWORD   dwInstance,        
    IN LPCTSTR lpszParent,        
    IN LPCTSTR lpszAlias          
    )
/*++

Routine Description:

    Launch the security wizard

Arguments:

    pfnNewSecurityTemplate pfnTemplateAllocator : Function to allocate template.
    CMetaInterface * pInterface : Existing interface
    LPCTSTR lpszService         : Service name
    DWORD   dwInstance          : Parent instance
    LPCTSTR lpszParent          : Parent path
    LPCTSTR lpszAlias           : Child to configure or NULL

Return Value:

    HRESULT

--*/
{
    CError err;

    ASSERT(pInterface != NULL);

    LPCTSTR lpszServer = pInterface->QueryServerName();
    ASSERT(lpszServer != NULL);

    //
    // Only run wizard if they are an administrator - boydm
    //
    BOOL fAdmin;
    err = DetermineIfAdministrator(
        pInterface,
        lpszService,
        dwInstance,
        &fAdmin
        );

    if (err.Failed() || !fAdmin)
    {
        AfxMessageBox(IDS_ACL_ADMINS);

        return err;
    }

    CIISWizardSheet sheet(nLeftBmpId, nHeadBmpId);

    //
    // Create security wizard settings object
    //
    CIISSecWizSettings sws(
        pfnTemplateAllocator,
        lpszServer, 
        lpszService, 
        dwInstance,
        lpszParent,
        lpszAlias
        );

    CIISWizardBookEnd pgWelcome(IDS_PWIZ_WELCOME, IDS_PERMWIZ, IDS_PWIZ_BODY);
    CPWSource         pgSource(&sws);
    CPWTemplate       pgTemplate(&sws);
    CPWACL            pgACL(&sws);
    CPWSummary        pgSummary(&sws);
    CIISWizardBookEnd pgCompletion(
        &sws.m_hResult, 
        IDS_PWIZ_SUCCESS,
        IDS_PWIZ_FAILURE,
        IDS_PERMWIZ
        );

    sheet.AddPage(&pgWelcome);
    sheet.AddPage(&pgSource);
    sheet.AddPage(&pgTemplate);
    sheet.AddPage(&pgACL);
    sheet.AddPage(&pgSummary);
    sheet.AddPage(&pgCompletion);

    sheet.DoModal();

    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\comprop\objplus.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        objplus.cpp

   Abstract:

        Base object classes

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/



//
// Include Files
//
#include "stdafx.h"
#include "comprop.h"

#include <stdlib.h>
#include <memory.h>
#include <ctype.h>

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif



CObjHelper::CObjHelper()
/*++

Routine Description:

    Constructor for super object help class

Arguments:

    None

Return Value:

    N/A

--*/
    : m_ctor_err(ERROR_SUCCESS),
      m_api_err(ERROR_SUCCESS),
      m_fDirty(FALSE),
      m_time_created(::GetCurrentTime())
{
}



void
CObjHelper::ReportError(
    IN LONG errInConstruction
    )
/*++

Routine Description:

    Set the constructor error code, and dump the error message to
    the debugging context.

Arguments:

    LONG errInConstruction : Error code

Return Value:

    None

--*/
{
    TRACEEOLID("CObjectPlus construction failure, error = "
        << errInConstruction);

    m_ctor_err = errInConstruction;
}



LONG
CObjHelper::SetApiErr(
    IN LONG errApi
    )
/*++

Routine Description:

    Set the API error code.

Arguments:

    LONG errApi  : API error code

Return Value:

    The API error code

--*/
{
    return m_api_err = errApi;
}



BOOL
CObjHelper::IsValid() const
/*++

Routine Description:

    Determine if the object is in a valid state

Arguments:

    LONG errApi  : API error code

Return Value:

    TRUE if the the object is in a valid state, FALSE otherwise

--*/
{
    return QueryError() == 0;
}



DWORD
CObjHelper::QueryAge() const
/*++

Routine Description:

    Determine the age of the object.

Arguments:

    None

Return Value:

    time_t value indicating the age of the object.

--*/
{
    DWORD dwTime = ::GetCurrentTime(),
          dwDiff;

    if (dwTime < m_time_created)
    {
        dwDiff = dwTime + (((DWORD)-1) - (m_time_created - 1));
    }
    else
    {
        dwDiff = dwTime - m_time_created;
    }

    return dwDiff;
}



#ifdef _DEBUG



void
CObjHelper::AssertValid() const
/*++

Routine Description:

    Assert the object if the object is in a valid state

Arguments:

    None

Return Value:

    None

--*/
{
    ASSERT(IsValid());
}



#endif // _DEBUG



CObjectPlus::CObjectPlus()
/*++

Routine Description:

    Constructor of extended object

Arguments:

    None

Return Value:

    N/A

--*/
{
}



int
CObjectPlus::Compare(
    IN const CObjectPlus * pob
    ) const
/*++

Routine Description:

    Compare one object with another:  default implementation orders objects
    by creation time.  Return -1, 0 or 1.

Arguments:

    const CObjectPlus * pob : Object to be compared against

Return Value:

    -1 if this object is < than the compared object
     0 if this object is == to the compared object
    +1 if this object is > than the compared object

--*/
{
    return QueryCreationTime() < pob->QueryCreationTime()
        ? -1
        : QueryCreationTime() != pob->QueryCreationTime();
}



CObListPlus::CObListPlus(
    IN int nBlockSize
    )
/*++

Routine Description:

    Subclass of CObList whose default behavior is to destroy its
    contents during its own destruction

Arguments:

    int nBlockSize : Initial block size

Return Value:

    None

--*/
    : CObList(nBlockSize),
      m_fOwned(TRUE)
{
}



CObListPlus::~CObListPlus()
/*++

Routine Description:

    Destructor.  If the objects are owned, clean them up.

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    RemoveAll();
}



void
CObListPlus::RemoveAll()
/*++

Routine Description:

    Remove all the objects in the list if the list owns its objects

Arguments:

    None

Return Value:

    None

--*/
{
    if (m_fOwned)
    {
        //
        // Remove and discard all the objects
        //
        while (!IsEmpty())
        {
            CObject * pob = RemoveHead();
            delete pob ;
        }
    }
    else
    {
        //
        // Just remove the object pointers
        //
        CObList::RemoveAll();
    }
}



CObject *
CObListPlus::Index(
    IN int index
    )
/*++

Routine Description:

    Get object by index

Arguments:

    int index  : The index of the object to be returned

Return Value:

    The object, or NULL if the index is invalid

--*/
{
   CObListIter obli(*this);

   CObject * pob = NULL;

   for (int i = 0; (pob = obli.Next()) && i++ < index; /**/ );

   return pob;
}



BOOL
CObListPlus::RemoveIndex(
    IN int index
    )
/*++

Routine Description:

    Remove object by index

Arguments:

    int index  : The index of the object to be removed

Return Value:

    The object, or NULL if the index is invalid

--*/
{
    int i;
    POSITION pos;
    CObListIter obli(*this);
    CObject * pob;

    for (i = 0, pos = obli.QueryPosition();
        (pob = obli.Next()) && i < index;
        i++, pos = obli.QueryPosition());

    if (pob && i == index)
    {
        RemoveAt(pos);

        return TRUE;
    }

    return FALSE;
}



BOOL
CObListPlus::Remove(
    IN CObject * pob
    )
/*++

Routine Description:

    Remove the first (and hopefully only) occurrence of an object
    pointer from this list.

Arguments:

    CObject * pob : The object to be removed

Return Value:

    TRUE if the object was found and succesfully removed, FALSE otherwise

--*/
{
    POSITION pos = Find(pob);

    if (pos == NULL)
    {
        return FALSE;
    }

    RemoveAt(pos);

    return TRUE;
}



void
CObListPlus::RemoveAt(
    IN POSITION & pos
    )
/*++

Routine Description:

    Override of RemoveAt to delete the pointer at the position
    given

Arguments:

    POSITION pos        : Position of item to delete

Return Value:

    None.

Notes:

    The item will only be deleted if this is an "owned" list.

--*/
{
    CObject * pItem = GetAt(pos);

    CObList::RemoveAt(pos);

    if (m_fOwned)
    {
        delete pItem;
    }
}



BOOL
CObListPlus::SetAll(
    IN BOOL fDirty
    )
/*++

Routine Description:

    Set all elements to dirty or clean.  Return TRUE if any element was dirty.

Arguments:

    BOOL fDirty : Dirty flag to set the objects with

Return Value:

    TRUE if any element was dirty.

--*/
{
    int cDirtyItems = 0;
    CObjectPlus * pob;
    CObListIter obli(*this);

    while (pob = (CObjectPlus *)obli.Next())
    {
        cDirtyItems += pob->IsDirty();
        pob->SetDirty(fDirty);
    }

    SetDirty(fDirty);

    return cDirtyItems > 0;
}



int
CObListPlus::FindElement(
    IN CObject * pobSought
    ) const
/*++

Routine Description:

    Find the object in the list.

Arguments:

    CObject * pobSought : Object to be looked for

Return Value:

    The index of the object, or -1 if it wasn't found.

--*/
{
    CObject * pob;
    CObListIter obli(*this);

    for (int i = 0;
        (pob = obli.Next()) && pob != pobSought;
        i++);

    return pob
        ? i
        : -1;
}


//
// Sorting structure
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

typedef struct
{
    CObjectPlus * pObj;                        // Pointer to object to be sorted
    CObjectPlus::PCOBJPLUS_ORDER_FUNC  pFunc;  // Pointer to ordering function
} CBOWNEDLIST_SORT_HELPER;



int _cdecl
CObListPlus::SortHelper(
    IN const void * pa,
    IN const void * pb
    )
/*++

Routine Description:

    This static member function is used to quick sort an array of structures
    as declared above.  Each element contains the object pointer and a
    pointer to the object's member function to be invoked for comparison.

Arguments:

    const void * pa      : Sorting help struct 1
    const void * pb      : Sorting help struct 2

Return Value:

    Sort return code

--*/
{
    CBOWNEDLIST_SORT_HELPER *pHelp1 = (CBOWNEDLIST_SORT_HELPER *)pa,
                            *pHelp2 = (CBOWNEDLIST_SORT_HELPER *)pb;

    return (pHelp1->pObj->*pHelp1->pFunc)(pHelp2->pObj);
}



/* INTRINSA suppress=null_pointers, uninitialized */
DWORD
CObListPlus::Sort(
    IN CObjectPlus::PCOBJPLUS_ORDER_FUNC pOrderFunc
    )
/*++

Routine Description:

    Sort the list by recreating it entirely.

Arguments:

    CObjectPlus::PCOBJPLUS_ORDER_FUNC pOrderFunc : Ordering function

Return Value:

    Error code

--*/
{
    DWORD err = ERROR_SUCCESS;
    int cItems = (int)GetCount();

    if (cItems < 2)
    {
        return err;
    }

    CObjectPlus * pObNext;
    CObListIter obli(*this);
    BOOL fOwned = SetOwnership(FALSE);
    int i;

    CBOWNEDLIST_SORT_HELPER * paSortHelpers = NULL;

    try
    {
        //
        // Allocate the helper array
        //
        paSortHelpers = AllocMemByType(cItems, CBOWNEDLIST_SORT_HELPER);

        //
        // Fill the helper array.
        //
        for (i = 0; pObNext = (CObjectPlus *)obli.Next(); i++)
        {
            paSortHelpers[i].pFunc = pOrderFunc;
            paSortHelpers[i].pObj = pObNext;
        }

        //
        // Release all object pointer references.  Note that we
        // forced "owned" to FALSE above.
        //
        RemoveAll();
        ASSERT(GetCount() == 0);

        //
        // Sort the helper array
        //
        ::qsort( (void *) paSortHelpers,
            cItems,
            sizeof(paSortHelpers[0]),
            SortHelper
            );

        //
        // Refill the list from the helper array.
        //
        for (i = 0; i < cItems; i++ )
        {
            AddTail(paSortHelpers[i].pObj);
        }

        ASSERT(GetCount() == cItems);
    }
    catch(CMemoryException * e)
    {
        err = ERROR_NOT_ENOUGH_MEMORY;
        e->Delete();
    }

    //
    // Delete the working array
    //
    FreeMem(paSortHelpers);

    //
    // Restore the object ownership state
    //
    SetOwnership(fOwned);

    return err;
}



CObListIter::CObListIter(
    IN const CObListPlus & obList
    )
/*++

Routine Description:

    Constructor of ObOwnedList iterator

Arguments:

    const CObListPlus & obList : List to be iterated

Return Value:

    N/A

--*/
    : m_obList(obList)
{
    Reset();
}



void
CObListIter::Reset()
/*++

Routine Description:

    Reset the iterator

Arguments:

    None

Return Value:

    None

--*/
{
    m_pos = m_obList.GetCount()
        ? m_obList.GetHeadPosition()
        : NULL;
}



CObject * CObListIter::Next()
/*++

Routine Description:

    Get the next object in the list, or NULL

Arguments:

    None

Return Value:

    The next object in the list, or NULL

--*/
{
    return m_pos == NULL
        ? NULL
        : m_obList.GetNext(m_pos);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\comprop\registry.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        registry.cpp

   Abstract:

        Registry classes

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/



//
// Include Files
//
#include "stdafx.h"
#include <stdlib.h>
#include <memory.h>
#include <ctype.h>
#include "comprop.h"



#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif



CRMCRegKey::CRMCRegKey (
    IN HKEY    hKeyBase,
    IN LPCTSTR lpszSubKey        OPTIONAL,
    IN REGSAM  regSam            OPTIONAL,
    IN LPCTSTR lpszServerName    OPTIONAL
    )
/*++

Routine Description:

    Constructor registry key object for an existing key.  Optionally provide
    a computer name to open a registry key on a remote computer.

Arguments:

    HKEY hKeyBase          : Base key handle
    LPCTSTR lpszSubKey     : Name of the subkey
    REGSAM regSam          : Security access mask for registry key
    LPCTSTR lpszServerName : Optional computer name whose registry to open

Return Value:

    N/A

--*/
    : m_hKey(NULL),
      m_dwDisposition(REG_OPENED_EXISTING_KEY)
{
    HKEY hkBase = NULL;
    CError err;

    //
    // Change to NULL if server name is really local
    //
    lpszServerName = ::NormalizeServerName(lpszServerName);
    if (m_fLocal = (lpszServerName != NULL))
    {
        //
        // Remote connection.
        //
        err = ::RegConnectRegistry((LPTSTR)lpszServerName, hKeyBase, &hkBase);
        if (err.Failed())
        {
            hkBase = NULL;
        }
    }
    else
    {
        hkBase = hKeyBase;
    }

    if (err.Succeeded())
    {
        if (lpszSubKey != NULL)
        {
            err = ::RegOpenKeyEx(hkBase, lpszSubKey, 0, regSam, &m_hKey);
        }
        else
        {
            m_hKey = hkBase;
            hkBase = NULL;
        }

        if (hkBase && hkBase != hKeyBase)
        {
            ::RegCloseKey(hkBase);
        }
    }

    if (err.Failed())
    {
        m_hKey = NULL;
    }
}




CRMCRegKey::CRMCRegKey(
    OUT BOOL *  pfNewKeyCreated         OPTIONAL,
    IN  HKEY    hKeyBase,
    IN  LPCTSTR lpszSubKey              OPTIONAL,
    IN  DWORD   dwOptions               OPTIONAL,
    IN  REGSAM  regSam                  OPTIONAL,
    IN  LPSECURITY_ATTRIBUTES pSecAttr  OPTIONAL,
    IN  LPCTSTR lpszServerName          OPTIONAL
    )
/*++

Routine Description:

    Constructor registry key object to create a new key.  Optionally provide
    a computer name to open a registry key on a remote computer.

Arguments:

    BOOL * pfNewKeyCreated         : If specified, returns TRUE if a new key
                                     was created, FALSE if an existing one was
                                     opened.
    HKEY hKeyBase                  : Base key handle
    LPCTSTR lpszSubKey             : Name of the subkey
    DWORD dwOptions                : Option flags
    REGSAM regSam                  : Security access mask for registry key
    LPSECURITY_ATTRIBUTES pSecAttr : Security attributes
    LPCTSTR lpszServerName         : Optional computer name whose registry to
                                     open

Return Value:

    N/A

--*/
    : m_hKey(NULL),
      m_dwDisposition(0L)
{
    HKEY hkBase = NULL;
    CError err;

    //
    // Change to NULL if server name is really local
    //
    lpszServerName = NormalizeServerName(lpszServerName);
    if (m_fLocal = (lpszServerName != NULL))
    {
        //
        // Remote connection.
        //
        err = ::RegConnectRegistry((LPTSTR)lpszServerName, hKeyBase, &hkBase);
        if (err.Failed())
        {
            hkBase = NULL;
        }
    }
    else
    {
        hkBase = hKeyBase;
    }

    if (err.Succeeded())
    {
        LPCTSTR szEmpty = _T("");

        err = ::RegCreateKeyEx(
            hkBase,
            lpszSubKey,
            0,                // Reserved
            (LPTSTR)szEmpty,
            dwOptions,
            regSam,
            pSecAttr,
            &m_hKey,
            &m_dwDisposition
            );
    }

    if (err.Failed())
    {
        m_hKey = NULL;
    }

    if (pfNewKeyCreated)
    {
        *pfNewKeyCreated = m_dwDisposition == REG_CREATED_NEW_KEY;
    }
}




#ifdef _DEBUG




/* virtual */
void
CRMCRegKey::AssertValid() const
/*++

Routine Description:

    Assert the object is in a valid state.

Arguments:

    None

Return Value:

    None

--*/
{
    ASSERT(m_hKey != NULL);
}




/* virtual */
void
CRMCRegKey::Dump(
    IN OUT CDumpContext & dc
    ) const
/*++

Routine Description:

    Dump the contents of the object to the debug string

Arguments:

    CDumpContext & dc : debug context

Return Value:

    None

--*/
{
    dc << _T("HKEY = ")
       << m_hKey
       << _T("Disposition = ")
       << m_dwDisposition
       << _T(" \r\n");
}

#endif // _DEBUG




CRMCRegKey::~CRMCRegKey()
/*++

Routine Description:

    Destructor.  Close the key if it's open.

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    if (m_hKey != NULL)
    {
        ::RegCloseKey(m_hKey);
    }
}




/* protected */
DWORD
CRMCRegKey::PrepareValue(
    IN  LPCTSTR lpszValueName,
    OUT DWORD * pdwType,
    OUT DWORD * pcbSize,
    OUT BYTE ** ppbData
    )
/*++

Routine Description:

    Prepare to read a value by finding the value's size.

Arguments:

    LPCTSTR lpszValueName : Name of the value
    DWORD * pdwType       : Returns the type registry value
    DWORD * pcbSize       : Returns the size of the value
    BYTE ** ppbData       : Will allocate and return the the value here

Return Value:

    Error return code.

--*/
{
    CError err;

    BYTE chDummy[2];
    DWORD cbData = 0L;

    do
    {
        //
        // Set the resulting buffer size to 0.
        //
        *pcbSize = 0;
        *ppbData = NULL;

        err = ::RegQueryValueEx(
            *this,
            (LPTSTR)lpszValueName,
            0,
            pdwType,
            chDummy,
            &cbData
            );

        //
        // The only error we should get here is ERROR_MORE_DATA, but
        // we may get no error if the value has no data.
        //
        if (err.Succeeded())
        {
            //
            // Just a fudgy number
            //
            cbData = sizeof(LONG);
        }
        else
        {
            if (err.Win32Error() != ERROR_MORE_DATA)
            {
                break;
            }
        }

        //
        // Allocate a buffer large enough for the data.
        //
        *ppbData = (LPBYTE)AllocMem((*pcbSize = cbData) + sizeof(LONG));

        if (*ppbData == NULL)
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        //
        // Now that have a buffer, re-fetch the value.
        //
        err = ::RegQueryValueEx(
            *this,
            (LPTSTR)lpszValueName,
            0,
            pdwType,
            *ppbData,
            pcbSize
            );

    }
    while(FALSE);

    if (err.Failed() && *ppbData != NULL)
    {
        FreeMem(*ppbData);
    }

    return err;
}



//
// Overloaded value query members; each returns ERROR_INVALID_PARAMETER
// if data exists but not in correct form to deliver into result object.
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



DWORD
CRMCRegKey::QueryValue(
    IN  LPCTSTR lpszValueName,
    OUT CString & strResult,
    IN  BOOL fAutoExpand,       OPTIONAL
    OUT BOOL * pfExpanded       OPTIONAL
    )
/*++

Routine Description:

    Get a CString registry value.

Arguments:

    LPCTSTR lpszValueName : Name of the value
    CString & strResult   : String return value
    BOOL fAutoExpand      : If TRUE auto expand REG_EXPAND_SZ on local
                            computer.
    BOOL * pfExpanded     : Optionally returns TRUE if expanded

Return Value:

    Error return code.

--*/
{
    CError err;

    DWORD dwType;
    DWORD cbData;
    BYTE * pabData = NULL;

    try
    {
        do
        {
            err = PrepareValue(lpszValueName, &dwType, &cbData, &pabData);
            if (err.Failed())
            {
                break;
            }

            //
            //  Guarantee that the data looks like a string
            //
            pabData[cbData] = 0;

            switch(dwType)
            {
            case REG_EXPAND_SZ:
                if (IsLocal() && fAutoExpand)
                {
                    int cchBuff = (cbData / sizeof(TCHAR)) + 2048;
                    int cchRequired;

                    while(TRUE)
                    {
                        cchRequired = ExpandEnvironmentStrings(
                            (LPCTSTR)pabData,
                            strResult.GetBuffer(cchBuff),
                            cchBuff
                            );

                        if (cchRequired == 0)
                        {
                            //
                            // Never a valid result (even an empty
                            // string has a terminating null).
                            //
                            err.GetLastWinError();
                            break;
                        }

                        if (cchRequired > cchBuff)
                        {
                            //
                            // Buffer too small -- try again
                            //
                            cchBuff = cchRequired;
                            continue;
                        }

                        //
                        // Successfully expanded environment string.
                        //
                        strResult.ReleaseBuffer();
                        break;
                    }

                    if (err.Succeeded() && pfExpanded)
                    {
                        *pfExpanded = TRUE;
                    }
                    break;
                }

                //
                // Fall through
                //

            case REG_SZ:
                strResult = (LPTSTR)pabData;
                if (pfExpanded)
                {
                    *pfExpanded = FALSE;
                }
                break;

            default:
                err = ERROR_INVALID_PARAMETER;
                break;
            }
        }
        while(FALSE);
    }
    catch(CMemoryException * e)
    {
        err = ERROR_NOT_ENOUGH_MEMORY;
        e->Delete();
    }

    if (pabData)
    {
        FreeMem(pabData);
    }

    return err;
}




DWORD
CRMCRegKey::QueryValue(
    IN  LPCTSTR lpszValueName,
    OUT CStringListEx & strList
    )
/*++

Routine Description:

    Read REG_MULTI_SZ as a CStringListEx

Arguments:

    LPCTSTR lpszValueName   : Name of the value
    CStringListEx & strList : String list return value

Return Value:

    Error return code.

--*/
{
    CError err;

    DWORD dwType;
    DWORD cbData;
    BYTE * pabData = NULL;
    LPTSTR pbTemp, pbTempLimit;

    do
    {
        err = PrepareValue(lpszValueName, &dwType, &cbData, &pabData);
        if (err.Failed())
        {
            break;
        }

        ASSERT(dwType == REG_MULTI_SZ);
        if (dwType != REG_MULTI_SZ)
        {
            err = ERROR_INVALID_PARAMETER;
            break;
        }

        //
        // Guarantee that the trailing data looks like a string
        //
        pabData[cbData] = 0;
        pbTemp = (LPTSTR)pabData;
        pbTempLimit = &(pbTemp[cbData]);

        try
        {
            while (pbTemp < pbTempLimit)
            {
                strList.AddTail(pbTemp);
                pbTemp += ::_tcslen(pbTemp) + 1;
            }
        }
        catch(CMemoryException * e)
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
            e->Delete();
        }
    }
    while (FALSE);

    if (pabData)
    {
        FreeMem(pabData);
    }

    return err;
}




DWORD
CRMCRegKey::QueryValue(
    IN  LPCTSTR lpszValueName,
    OUT DWORD & dwResult
    )
/*++

Routine Description:

    Read a DWORD from the registry value

Arguments:

    LPCTSTR lpszValueName : Name of the value
    DWORD & dwResult      : DWORD to be returned

Return Value:

    Error return code.

--*/
{
    CError err;

    DWORD dwType;
    DWORD cbData;
    BYTE * pabData = NULL;

    do
    {
        err = PrepareValue(lpszValueName, &dwType, &cbData, &pabData);
        if (err.Failed())
        {
            break;
        }

        ASSERT(dwType == REG_DWORD && cbData == sizeof(dwResult));
        if (dwType != REG_DWORD || cbData != sizeof(dwResult))
        {
            err = ERROR_INVALID_PARAMETER;
            break;
        }

        dwResult = *((DWORD *)pabData);
    }
    while (FALSE);

    if (pabData)
    {
        FreeMem(pabData);
    }

    return err;
}



DWORD
CRMCRegKey::QueryValue(
    IN  LPCTSTR lpszValueName,
    OUT CByteArray & abResult
    )
/*++

Routine Description:

    Read a byte stream from the registry as a CByteArray

Arguments:

    LPCTSTR lpszValueName  : Name of the value
    CByteArray & abResult  : Byte array result

Return Value:

    Error return code.

--*/
{
    CError err;

    DWORD dwType;
    DWORD cbData;
    BYTE * pabData = NULL;

    do
    {
        err = PrepareValue(lpszValueName, &dwType, &cbData, &pabData);
        if (err.Failed())
        {
            break;
        }

        ASSERT(dwType == REG_BINARY);
        if (dwType != REG_BINARY)
        {
            err = ERROR_INVALID_PARAMETER;
            break;
        }

        try
        {
            abResult.SetSize(cbData);
        }
        catch(CMemoryException * e)
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
            e->Delete();
        }

        if (err.Failed())
        {
            break;
        }

        //
        //  Move the data to the result array.
        //
        for (DWORD i = 0; i < cbData; ++i)
        {
            abResult[i] = pabData[i];
        }
    }
    while (FALSE);

    if (pabData)
    {
        FreeMem(pabData);
    }

    return err;
}




DWORD
CRMCRegKey::QueryValue(
    IN LPCTSTR lpszValueName,
    IN void * pvResult,
    IN DWORD cbSize
    )
/*++

Routine Description:

    Read a byte stream from the registry into a previously allocated
    buffer.

Arguments:

    LPCTSTR lpszValueName : Name of the value
    void * pvResult       : Generic buffer
    DWORD cbSize          : Size of the buffer

Return Value:

    Error return code.

--*/
{
    CError err;

    DWORD dwType;
    DWORD cbData;
    BYTE * pabData = NULL;

    do
    {
        err = PrepareValue(lpszValueName, &dwType, &cbData, &pabData);
        if (err.Failed())
        {
            break;
        }

        ASSERT(dwType == REG_BINARY && pvResult != NULL);
        if (dwType != REG_BINARY || pvResult == NULL)
        {
            err = ERROR_INVALID_PARAMETER;
            break;
        }

        if (cbSize < cbData)
        {
            err = ERROR_MORE_DATA;
            break;
        }

        ::CopyMemory(pvResult, pabData, cbData);
    }
    while (FALSE);

    if (pabData)
    {
        FreeMem(pabData);
    }

    return err;
}



//
// Overloaded value setting members.
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



DWORD
CRMCRegKey::SetValue(
    IN LPCTSTR lpszValueName,
    IN CString & strResult,
    IN BOOL fAutoDeflate,       OPTIONAL
    IN OUT BOOL * pfDeflated    OPTIONAL
    )
/*++

Routine Description:

    Write a CString as REG_SZ or REG_EXPAND_SZ registry value.

Arguments:

    LPCTSTR lpszValueName : Name of the value
    CString & strResult   : String to be written
    BOOL fAutoDeflate     : If TRUE write as REG_EXPAND_SZ and
                            try using %SystemRoot% path
    BOOL * pfDeflated     : Optionally return whether item was
                            deflated.

                            If *TRUE on input, use REG_EXPAND_SZ
                            regardless.

Return Value:

    Error return code.

--*/
{
    TRACEEOLID(strResult);
    CError err;
    DWORD dwType = REG_SZ;

    if (fAutoDeflate || (pfDeflated && *pfDeflated))
    {
        err = DeflateEnvironmentVariablePath(
            _T("SystemRoot"),
            strResult
            );

        if (err.Failed())
        {
            err = DeflateEnvironmentVariablePath(
                _T("SystemDrive"),
                strResult
                );
        }

        dwType = REG_EXPAND_SZ;
    }

    return ::RegSetValueEx(
        *this,
        lpszValueName,
        0,    // Reserved
        dwType,
        (const LPBYTE)(LPCTSTR)strResult,
        (strResult.GetLength() + 1) * sizeof(TCHAR)
        );
}




DWORD
CRMCRegKey::SetValue(
    IN LPCTSTR lpszValueName,
    IN CStringListEx & strList
    )
/*++

Routine Description:

    Write a CStringListEx as REG_MULTI_SZ registry value.

Arguments:

    LPCTSTR lpszValueName   : Name of the value
    CStringListEx & strList : Strings to be written

Return Value:

    Error return code.

--*/
{
    DWORD cbSize;
    BYTE * pbData = NULL;

    CError err(FlattenValue(strList, &cbSize, &pbData));

    if (err.Succeeded())
    {
        err = ::RegSetValueEx(
            *this,
            lpszValueName,
            0,               // Reserved
            REG_MULTI_SZ,
            pbData,
            cbSize
            );
    }

    if (pbData != NULL)
    {
        FreeMem(pbData);
    }

    return err;
}




DWORD
CRMCRegKey::SetValue(
    IN LPCTSTR lpszValueName,
    IN DWORD & dwResult
    )
/*++

Routine Description:

    Write a DWORD to the registry value

Arguments:

    LPCTSTR lpszValueName : Name of the value
    DWORD & dwResult      : DWORD to be written

Return Value:

    Error return code.

--*/
{
    return ::RegSetValueEx(
        *this,
        lpszValueName,
        0,                 // Reserved
        REG_DWORD,
        (const LPBYTE)&dwResult,
        sizeof(dwResult)
        );
}




DWORD
CRMCRegKey::SetValue(
    IN LPCTSTR lpszValueName,
    IN CByteArray & abResult
    )
/*++

Routine Description:

    Write a CByteArray of bytes to the registry value

Arguments:

    LPCTSTR lpszValueName  : Name of the value
    CByteArray & abResult  : Bytes to be written

Return Value:

    Error return code.

--*/
{
    DWORD cbSize;
    BYTE * pbData = NULL;

    CError err(FlattenValue(abResult, &cbSize, &pbData));

    if (err.Succeeded())
    {
        err = ::RegSetValueEx(
            *this,
            lpszValueName,
            0,             // Reserved
            REG_BINARY,
            pbData,
            cbSize
            );
    }

    if (pbData != NULL)
    {
        FreeMem(pbData);
    }

    return err;
}




DWORD
CRMCRegKey::SetValue(
    IN LPCTSTR lpszValueName,
    IN void * pvResult,
    IN DWORD cbSize
    )
/*++

Routine Description:

    Write a generic stream of bytes to the registry value

Arguments:

    LPCTSTR lpszValueName  : Name of the value
    CByteArray & abResult  : Bytes to be written

Return Value:

    Error return code.

--*/
{
    return ::RegSetValueEx(
        *this,
        lpszValueName,
        0,                  // Reserved
        REG_BINARY,
        (const LPBYTE)pvResult,
        cbSize
        );
}




/* static */
/* protected */
/* INTRINSA suppress=null_pointers, uninitialized */
DWORD
CRMCRegKey::FlattenValue(
    IN  CStringListEx & strList,
    OUT DWORD * pcbSize,
    OUT BYTE ** ppbData
    )
/*++

Routine Description:

    Spread out the stringlist over a generic buffer.  Buffer will
    be allocated by this function.

Arguments:

    CStringListEx & strList : List of strings to be used
    DWORD * pcbSize         : Returns the byte size of the buffer allocated
    BYTE ** ppbData         : Buffer which will be allocated

Return Value:

    Error return code.

--*/
{
    CError err;

    POSITION pos;
    CString * pstr;
    int cbTotal = 0;

    //
    // CODEWORK:  Try using ConvertStringListToDoubleNullList here
    //

    //
    // Walk the list accumulating sizes
    //
    for (pos = strList.GetHeadPosition();
         pos != NULL && (pstr = & strList.GetNext(pos));
         /**/
        )
    {
        cbTotal += (pstr->GetLength() + 1) * sizeof(TCHAR);
    }

    //
    // Allocate and fill a temporary buffer
    //
    if (*pcbSize = cbTotal)
    {
        try
        {
            *ppbData = (LPBYTE)AllocMem(*pcbSize);

            BYTE * pbData = *ppbData;

            if (pbData == NULL) {
                err = ERROR_NOT_ENOUGH_MEMORY;
            }

            //
            // Populate the buffer with the strings.
            //
            else for (pos = strList.GetHeadPosition();
                 pos != NULL && (pstr = & strList.GetNext(pos));
                 /**/
                )
            {
                int cb = (pstr->GetLength() + 1) * sizeof(TCHAR);
                ::CopyMemory(pbData, (LPCTSTR)*pstr, cb);
                pbData += cb;
            }
        }
        catch(CMemoryException * e)
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
            e->Delete();
        }
    }
    else
    {
        *ppbData = NULL;
    }

    return err;
}




/* static */
/* protected */
/* INTRINSA suppress=null_pointers, uninitialized */
DWORD
CRMCRegKey::FlattenValue(
    IN  CByteArray & abData,
    OUT DWORD * pcbSize,
    OUT BYTE ** ppbData
    )
/*++

Routine Description:

    Spread out the CByteArray over a generic buffer.  Buffer will
    be allocated by this function.

Arguments:

    CByteArray * abData : Byte stream
    DWORD * pcbSize     : Returns the byte size of the buffer allocated
    BYTE ** ppbData     : Buffer which will be allocated

Return Value:

    Error return code.

--*/
{
    CError err;

    //
    // Allocate and fill a temporary buffer
    //
    if (*pcbSize = (DWORD) abData.GetSize())
    {
        try
        {
            *ppbData = (LPBYTE)AllocMem(*pcbSize);

            if (*ppbData == NULL) {
                err = ERROR_NOT_ENOUGH_MEMORY;
            }
            else for (DWORD i = 0; i < *pcbSize; i++)
            {
                (*ppbData)[i] = abData[i];
            }

        }
        catch(CMemoryException * e)
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
            e->Delete();
        }
    }
    else
    {
        *ppbData = NULL;
    }

    return err;
}




DWORD
CRMCRegKey::QueryKeyInfo(
    OUT CREGKEY_KEY_INFO * pRegKeyInfo
    )
/*++

Routine Description:

    Find out information about this given key.

Arguments:

    CREGKEY_KEY_INFO * pRegKeyInfo : Registry key structure

Return Value:

    Error return code.

--*/
{
    ASSERT(pRegKeyInfo != NULL);
    if (pRegKeyInfo == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    pRegKeyInfo->dwClassNameSize = sizeof(pRegKeyInfo->chBuff) - 1;

    return ::RegQueryInfoKey(
        *this,
        pRegKeyInfo->chBuff,
        &pRegKeyInfo->dwClassNameSize,
        NULL,
        &pRegKeyInfo->dwNumSubKeys,
        &pRegKeyInfo->dwMaxSubKey,
        &pRegKeyInfo->dwMaxClass,
        &pRegKeyInfo->dwMaxValues,
        &pRegKeyInfo->dwMaxValueName,
        &pRegKeyInfo->dwMaxValueData,
        &pRegKeyInfo->dwSecDesc,
        &pRegKeyInfo->ftKey
        );
}




CRMCRegKeyIter::CRMCRegKeyIter(
    IN CRMCRegKey & regKey
    )
/*++

Routine Description:

    Constructor for the registry keys iteration class.

Arguments:

    CRMCRegKey & regKey : Parent registry key to be enumerated.

Return Value:

    N/A

--*/
    : m_rkIter(regKey),
      m_pBuffer(NULL),
      m_cbBuffer(0)
{
    CRMCRegKey::CREGKEY_KEY_INFO regKeyInfo;

    Reset();

    CError err(regKey.QueryKeyInfo(&regKeyInfo));

    if (err.Succeeded())
    {
        try
        {
            m_cbBuffer = regKeyInfo.dwMaxSubKey + sizeof(DWORD);
            m_pBuffer = AllocTString(m_cbBuffer);
        }
        catch(CMemoryException * e)
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
            e->Delete();
        }
    }

    err.MessageBoxOnFailure();
}




CRMCRegKeyIter::~CRMCRegKeyIter()
/*++

Routine Description:

    Destructor for key iteration class

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    if (m_pBuffer != NULL)
    {
        FreeMem(m_pBuffer);
    }
}




DWORD
CRMCRegKeyIter::Next(
    OUT CString * pstrName,
    OUT CTime * pTime OPTIONAL
    )
/*++

Routine Description:

    Get the name (and optional last write time) of the next key.

Arguments:

    CString * pstrName : Next key name
    CTime * pTime      : Time structure or NULL

Return Value:

    ERROR_SUCCESS if the next key was found, ERROR_NO_MORE_ITEMS
    if no further items are available.

--*/
{
    if (m_pBuffer == NULL)
    {
        return ERROR_NO_MORE_ITEMS;
    }

    FILETIME ftDummy;
    DWORD dwNameSize = m_cbBuffer;

    CError err(::RegEnumKeyEx(
        m_rkIter,
        m_dwIndex,
        m_pBuffer,
        &dwNameSize,
        NULL,
        NULL,
        NULL,
        &ftDummy
        ));

    if (err.Succeeded())
    {
        ++m_dwIndex;

        if (pTime != NULL)
        {
            *pTime = ftDummy;
        }

        try
        {
            *pstrName = m_pBuffer;
        }
        catch(CMemoryException * e)
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
            e->Delete();
        }
    }

    return err;
}




CRMCRegValueIter::CRMCRegValueIter(
    IN CRMCRegKey & regKey
    )
/*++

Routine Description:

    Constructor for the Iterate through registry values class.

Arguments:

    CRMCRegKey & regKey : Parent registry key to be enumerated.

Return Value:

    N/A

--*/
    : m_rkIter(regKey),
      m_pBuffer(NULL),
      m_cbBuffer(0)
{
    CRMCRegKey::CREGKEY_KEY_INFO regKeyInfo;

    Reset();

    CError err(regKey.QueryKeyInfo(&regKeyInfo));

    if (err.Succeeded())
    {
        try
        {
            m_cbBuffer = regKeyInfo.dwMaxValueName + sizeof(DWORD);
            m_pBuffer = AllocTString(m_cbBuffer);
        }
        catch(CMemoryException * e)
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
            e->Delete();
        }
    }

    err.MessageBoxOnFailure();
}



CRMCRegValueIter::~CRMCRegValueIter()
/*++

Routine Description:

    Destructor for values iteration class

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    if (m_pBuffer != NULL)
    {
        FreeMem(m_pBuffer);
    }
}




DWORD
CRMCRegValueIter::Next(
    OUT CString * pstrName,
    OUT DWORD * pdwType
    )
/*++

Routine Description:

    Get the name and type of the next registry value

Arguments:

    CString * pstrName : Next value name
    DWORD *   pdwType  : Registry value type

Return Value:

    ERROR_SUCCESS if the next key was found, ERROR_NO_MORE_ITEMS
    if no further items are available.

--*/
{
    if (m_pBuffer == NULL)
    {
        return ERROR_NO_MORE_ITEMS;
    }

    DWORD dwNameLength = m_cbBuffer;

    CError err(::RegEnumValue(
        m_rkIter,
        m_dwIndex,
        m_pBuffer,
        &dwNameLength,
        NULL,
        pdwType,
        NULL,
        NULL
        ));

    if (err.Succeeded())
    {
        ++m_dwIndex;

        try
        {
            *pstrName = m_pBuffer;
        }
        catch(CMemoryException * e)
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
            e->Delete();
        }
    }

    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\comprop\odlbox.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        odlbox.h

   Abstract:

        Owner draw listbox/combobox base class

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

#ifndef _ODLBOX_H
#define _ODLBOX_H



//
// Get control rect in terms of
// parent coordinates
//
COMDLL void
GetDlgCtlRect(
    IN  HWND hWndParent,
    IN  HWND hWndControl,
    OUT LPRECT lprcControl
    );


//
// Fith path to the given control
//
COMDLL void
FitPathToControl(
    IN CWnd & wndControl,
    IN LPCTSTR lpstrPath
    );


//
// Show/hide _AND_ enable/disable control
//
COMDLL void
ActivateControl(
    IN CWnd & wndControl,
    IN BOOL fShow          = TRUE
    );

//
// Helper
//
inline void DeActivateControl(CWnd & wndControl)
{
    ActivateControl(wndControl, FALSE);
}



class COMDLL CMappedBitmapButton : public CBitmapButton
/*++

Class Description:

    Similar to CBitmapbutton, but use ::LoadMappedBitmap to reflect
    propert colour mapping.

Public Interface:

    CMappedBitmapButton     : Constructor

--*/
{
//
// Constructor
//
public:
    CMappedBitmapButton();

protected:
    BOOL LoadMappedBitmaps(
        UINT nIDBitmapResource,
        UINT nIDBitmapResourceSel = 0,
        UINT nIDBitmapResourceFocus = 0,
        UINT nIDBitmapResourceDisabled = 0
        );
};



class COMDLL CUpButton : public CMappedBitmapButton
/*++

Class Description:

    Up button.

Public Interface:

    CUpButton       : Constructor; does everything

--*/
{
public:
    CUpButton();
};



class COMDLL CDownButton : public CMappedBitmapButton
/*++

Class Description:

    Down button

Public Interface:

    CDownButton     : Constructor; does everything

--*/
{
public:
    CDownButton();
};



class COMDLL CRMCListBoxResources
{
/*++

Class Description:

    Listbox resources, a series of bitmaps for use by the listbox.  Will
    generate bitmaps against the proper background colours for both
    selected and non-selected states.

Public Interface:

    CRMCListBoxResources  : Constructor
    ~CRMCListBoxResources : Destructor

    SysColorChanged       : Regenerate bitmaps in response to change in colours
    DcBitMap              : Get final DC
    BitmapHeight          : Get bitmap height
    BitmapWidth           : Get bitmap width
    ColorWindow           : Get currently set window colour
    ColorHighlight        : Get currently set highlight colour
    ColorWindowText       : Get currently set window text colour
    ColorHighlightText    : Get currently set text highlight colour

--*/
//
// Constructor
//
public:
    CRMCListBoxResources(
        IN int bmId,
        IN int nBitmapWidth,
        IN COLORREF crBackground = RGB(0,255,0) /* Green */
        );

    ~CRMCListBoxResources();

//
// Interface
//
public:
    void SysColorChanged();
    const CDC & dcBitMap() const;
    int BitmapHeight() const;
    int BitmapWidth() const;
    COLORREF ColorWindow() const;
    COLORREF ColorHighlight() const;
    COLORREF ColorWindowText() const;
    COLORREF ColorHighlightText() const;

//
// Internal Helpers
//
protected:
    void GetSysColors();
    void PrepareBitmaps();
    void UnprepareBitmaps();
    void UnloadResources();
    void LoadResources();

private:
    COLORREF m_rgbColorWindow;
    COLORREF m_rgbColorHighlight;
    COLORREF m_rgbColorWindowText;
    COLORREF m_rgbColorHighlightText;
    COLORREF m_rgbColorTransparent;
    HGDIOBJ  m_hOldBitmap;
    CBitmap  m_bmpScreen;
    CDC      m_dcFinal;
    BOOL     m_fInitialized;
    int      m_idBitmap;
    int      m_nBitmapHeight;
    int      m_nBitmapWidth;
    int      m_nBitmaps;
};



class COMDLL CRMCListBoxDrawStruct
{
/*++

Class Description:

    Drawing information passed on to ODLBox

Public Interface:

    CRMCListBoxDrawStruct  : Constructor

--*/
public:
    CRMCListBoxDrawStruct(
        IN CDC * pDC,
        IN RECT * pRect,
        IN BOOL sel,
        IN DWORD_PTR item,
        IN int itemIndex,
        IN const CRMCListBoxResources * pres
        );

public:
    const CRMCListBoxResources * m_pResources;
    int   m_ItemIndex;
    CDC * m_pDC;
    CRect m_Rect;
    BOOL  m_Sel;
    DWORD_PTR m_ItemData;
};



/* abstract */ class COMDLL CODLBox
/*++

Class Description:

    abstract base class for owner-draw listbox and combobox

Public Interface:

    AttachResources   : Attach the resource structure to the list/combo box
    ChangeFont        : Change the font
    NumTabs           : Get the number of tabs currently set
    AddTab            : Add tab
    AddTabFromHeaders : Add tab computed from the difference in left coordinate
                        of two controls.
    InsertTab         : Insert a tab
    RemoveTab         : Remove a tab
    RemoveAllTabs     : Remove all tabs
    SetTab            : Set tab value
    GetTab            : Get tab value
    TextHeight        : Get the text height of the current font
    __GetCount        : Pure virtual function to get the number of items in the
                        list/combo box
    __SetItemHeight   : Pure virtual function to set the text height of the font

--*/
{
//
// Operations
//
public:
    void AttachResources(
        IN const CRMCListBoxResources * pResources
        );

    BOOL ChangeFont(
        CFont * pNewFont
        );

    int NumTabs() const;

    int AddTab(
        IN UINT uTab
        );

    int AddTabFromHeaders(
        IN CWnd & wndLeft,
        IN CWnd & wndRight
        );

    int AddTabFromHeaders(
        IN UINT idLeft,
        IN UINT idRight
        );

    void InsertTab(
        IN int nIndex,
        IN UINT uTab
        );

    void RemoveTab(
        IN int nIndex,
        IN int nCount = 1
        );

    void RemoveAllTabs();

    void SetTab(
        IN int nIndex,
        IN UINT uTab
        );

    UINT GetTab(
        IN int nIndex
        ) const;

    int TextHeight() const;

    /* pure */ virtual int __GetCount() const = 0;

    /* pure */ virtual int __SetItemHeight(
        IN int nIndex,
        IN UINT cyItemHeight
        ) = 0;

protected:
    CODLBox();
    ~CODLBox();

protected:
    //
    // Determine required display width of the string
    //
    static int GetRequiredWidth(
        IN CDC * pDC,
        IN const CRect & rc,
        IN LPCTSTR lpstr,
        IN int nLength
        );

    //
    // Helper function to display text in a limited rectangle
    //
    static BOOL ColumnText(
        IN CDC * pDC,
        IN int left,
        IN int top,
        IN int right,
        IN int bottom,
        IN LPCTSTR str
        );

protected:
    //
    // Helper functions for displaying bitmaps and text
    //
    BOOL DrawBitmap(
        IN CRMCListBoxDrawStruct & ds,
        IN int nCol,
        IN int nID
        );

    BOOL ColumnText(
        IN CRMCListBoxDrawStruct & ds,
        IN int nCol,
        IN BOOL fSkipBitmap,
        IN LPCTSTR lpstr
        );

    void ComputeMargins(
        IN  CRMCListBoxDrawStruct & ds,
        IN  int nCol,
        OUT int & nLeft,
        OUT int & nRight
        );

protected:
    void CalculateTextHeight(
        IN CFont * pFont
        );

    void AttachWindow(
        IN CWnd * pWnd
        );

protected:
    //
    // must override this to provide drawing of item
    //
    /* pure */ virtual void DrawItemEx(
        IN CRMCListBoxDrawStruct & dw
        ) = 0;

    void __MeasureItem(
        IN OUT LPMEASUREITEMSTRUCT lpMIS
        );

    void __DrawItem(
        IN LPDRAWITEMSTRUCT lpDIS
        );

    virtual BOOL Initialize();

protected:
    int m_lfHeight;
    const CRMCListBoxResources* m_pResources;

private:
    //
    // Window handle -- to be attached by derived class
    //
    CWnd * m_pWnd;
    CUIntArray m_auTabs;
};


//
// Forward decleration
//
class CHeaderListBox;



//
// Styles for listbox headers
//
#define HLS_STRETCH         (0x00000001)
#define HLS_BUTTONS         (0x00000002)

#define HLS_DEFAULT         (HLS_STRETCH | HLS_BUTTONS)



class COMDLL CRMCListBoxHeader : public CStatic
/*++

Class Description:

    Header object to be used in conjunction with listbox

Public Interface:

    CRMCListBoxHeader            : Constructor
    ~CRMCListBoxHeader           : Destructor

    Create                      : Create control

    GetItemCount                : Get the number of items in the header control
    GetColumnWidth              : Get column width of a specific column
    QueryNumColumns             : Get the number of columns in the listbox
    SetColumnWidth              : Set the width of specified column
    GetItem                     : Get header item information about specific
                                  column
    SetItem                     : Set header item information about specific
                                  column
    InsertItem                  : Insert header item
    DeleteItem                  : Delete header item
    RespondToColumnWidthChanges : Set response flagg

--*/
{
    DECLARE_DYNAMIC(CRMCListBoxHeader)

public:
    //
    // Constructor
    //
    CRMCListBoxHeader(
        IN DWORD dwStyle = HLS_DEFAULT
        );

    ~CRMCListBoxHeader();

    //
    // Create control
    //
    BOOL Create(
        IN DWORD dwStyle,
        IN const RECT & rect,
        IN CWnd * pParentWnd,
        IN CHeaderListBox * pListBox,
        IN UINT nID
        );

//
// Header control stuff
//
public:
    int GetItemCount() const;

    int GetColumnWidth(
        IN int nPos
        ) const;

    BOOL GetItem(
        IN int nPos,
        IN HD_ITEM * pHeaderItem
        ) const;

    BOOL SetItem(
        IN int nPos,
        IN HD_ITEM * pHeaderItem
        );

    int InsertItem(
        IN int nPos,
        IN HD_ITEM * phdi
        );

    BOOL DeleteItem(
        IN int nPos
        );

    void SetColumnWidth(
        IN int nCol,
        IN int nWidth
        );

    BOOL DoesRespondToColumnWidthChanges() const;

    void RespondToColumnWidthChanges(
        IN BOOL fRespond = TRUE
        );

    int QueryNumColumns() const;

protected:
    //{{AFX_MSG(CRMCListBoxHeader)
    afx_msg void OnDestroy();
    //}}AFX_MSG

    afx_msg void OnHeaderItemChanged(UINT nId, NMHDR * n, LRESULT * l);
    afx_msg void OnHeaderEndTrack(UINT nId, NMHDR * n, LRESULT * l);
    afx_msg void OnHeaderItemClick(UINT nId, NMHDR * n, LRESULT * l);

    DECLARE_MESSAGE_MAP()

    void CRMCListBoxHeader::SetTabsFromHeader();

    BOOL UseStretch() const;
    BOOL UseButtons() const;

private:
    CHeaderCtrl * m_pHCtrl;
    CHeaderListBox * m_pListBox;
    DWORD m_dwStyle;
    BOOL m_fRespondToColumnWidthChanges;

};



class COMDLL CRMCListBox : public CListBox, public CODLBox
/*++

Class Description:

    Super listbox class.  Its methods work for both
    single selection, and multi selection listboxes.

Public Interface:

    CRMCListBox          : Constructor
    ~CRMCListBox         : Destructor

    Initialize          : Initialize the control

    __GetCount          : Get the count of items in the listbox
    __SetItemHeight     : Set the item height in the listbox
    InvalidateSelection : Invalidate selection

--*/
{
    DECLARE_DYNAMIC(CRMCListBox)

public:
    //
    // Plain Construction
    //
    CRMCListBox();
    virtual ~CRMCListBox();
    virtual BOOL Initialize();

//
// Implementation
//
public:
    virtual int __GetCount() const;

    virtual int __SetItemHeight(
        IN int nIndex,
        IN UINT cyItemHeight
        );

    //
    // Invalidate item
    //
    void InvalidateSelection(
        IN int nSel
        );

    //
    // Select single item
    //
    int SetCurSel(int nSelect);

    //
    // Get index of selected item.  For multi-selects
    // with more than 1 selected, it will return LB_ERR
    //
    int GetCurSel() const;

    //
    // Check to see if item is selected
    //
    int GetSel(int nSel) const;

    //
    // Get count of selected items
    //
    int GetSelCount() const;

    //
    // Get next select item (single or multi-select).
    // Returns NULL if no further selected items available
    //
    void * GetNextSelectedItem(
        IN OUT int * pnStartingIndex
        );

    //
    // Select a single item (works for multi and single
    // select listboxes)
    //
    BOOL SelectItem(
        IN void * pItemData = NULL
        );

    //
    // Get the item at the single selection (works for both
    // multi and single selection listboxes).  Return NULL
    // if fewer than or more than one is selected.
    //
    void * GetSelectedListItem(
        OUT int * pnSel = NULL
        );

protected:
    //
    // Do-nothing drawitemex for non-owner draw listboxes.
    //
    virtual void DrawItemEx(
        IN CRMCListBoxDrawStruct & dw
        );

    virtual void MeasureItem(
        IN OUT LPMEASUREITEMSTRUCT lpMIS
        );

    virtual void DrawItem(
        IN LPDRAWITEMSTRUCT lpDIS
        );

protected:
    //{{AFX_MSG(CRMCListBox)
    afx_msg int  OnCreate(LPCREATESTRUCT lpCreateStruct);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

//
// Helpers
//
protected:
    BOOL IsMultiSelect() const;

private:
    BOOL m_fInitialized;
    BOOL m_fMultiSelect;
};


//
// Column Definition Structure
//
typedef struct tagODL_COLUMN_DEF
{
    int nWeight;
    UINT nLabelID;
} ODL_COLUMN_DEF;



//
// Enhanced Column Definition Structure (Can't
// be used in global structures in an AFXEXT dll
// because of the CObjectPlus reference)
//
typedef struct tagODL_COLUMN_DEF_EX
{
    ODL_COLUMN_DEF cd;
    CObjectPlus::PCOBJPLUS_ORDER_FUNC pSortFn;
} ODL_COLUMN_DEF_EX;



class COMDLL CHeaderListBox : public CRMCListBox
/*++

Class Description:

    Header listbox class. When using this class, do not use the tabbing
    functions of the base class.  These will be set by the header control.

Public Interface:

    CHeaderListBox      : Constructor
    ~CHeaderListBox     : Destructor

    Initialize          : Initialize the control
    QueryNumColumns     : Get the number of columns in the listbox
    QueryColumnWidth    : Get the width of specified column
    SetColumnWidth      : Set the width of specified column

--*/
{
    DECLARE_DYNAMIC(CHeaderListBox)

public:
    //
    // Plain Construction
    //
    CHeaderListBox(
        IN DWORD dwStyle = HLS_DEFAULT,
        LPCTSTR lpRegKey = NULL
        );

    virtual ~CHeaderListBox();

    virtual BOOL Initialize();

public:
    BOOL EnableWindow(
        IN BOOL bEnable = TRUE
        );

    BOOL ShowWindow(
        IN int nCmdShow
        );

    int QueryNumColumns() const;

    int QueryColumnWidth(
        IN int nCol
        ) const;

    BOOL SetColumnWidth(
        IN int nCol,
        IN int nWidth
        );

//
// Header Control Attachment Access
//
protected:
    int GetHeaderItemCount() const;

    BOOL GetHeaderItem(
        IN int nPos,
        IN HD_ITEM * pHeaderItem
        ) const;

    BOOL SetHeaderItem(
        IN int nPos,
        IN HD_ITEM * pHeaderItem
        );

    int InsertHeaderItem(
        IN int nPos,
        IN HD_ITEM * phdi
        );

    BOOL DeleteHeaderItem(
        IN int nPos
        );

    CRMCListBoxHeader * GetHeader();

    int InsertColumn(
        IN int nCol,
        IN int nWeight,
        IN UINT nStringID
        );

    void ConvertColumnWidth(
        IN int nCol,
        IN int nTotalWeight,
        IN int nTotalWidth
        );

    BOOL SetWidthsFromReg();

    void DistributeColumns();

protected:
    //{{AFX_MSG(CHeaderListBox)
    afx_msg int  OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg void OnDestroy();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:
    BOOL m_fInitialized;
    CString m_strRegKey;
    CRMCListBoxHeader * m_pHeader;
};




class COMDLL CRMCComboBox : public CComboBox, public CODLBox
/*++

Class Description:

    Super combo box class

Public Interface:

    CRMCComboBox        : Constructor
    ~CRMCComboBox       : Destructor

    Initialize          : Initialize the control

    __GetCount          : Get the count of items in the combobox
    __SetItemHeight     : Set the item height in the combobox
    InvalidateSelection : Invalidate selection

--*/
{
    DECLARE_DYNAMIC(CRMCComboBox)

//
// Construction
//
public:
    CRMCComboBox();
    virtual BOOL Initialize();

//
// Implementation
//
public:
    virtual ~CRMCComboBox();

    virtual int __GetCount() const;

    virtual int __SetItemHeight(
        IN int nIndex,
        IN UINT cyItemHeight
        );

    void InvalidateSelection(
        IN int nSel
        );

protected:
    //
    // Do-nothing drawitemex for non-owner draw comboboxes.
    //
    virtual void DrawItemEx(
        IN CRMCListBoxDrawStruct & dw
        );

    virtual void MeasureItem(
        IN OUT LPMEASUREITEMSTRUCT lpMIS
        );

    virtual void DrawItem(
        IN LPDRAWITEMSTRUCT lpDIS
        );

protected:
    //{{AFX_MSG(CRMCComboBox)
    afx_msg int  OnCreate(LPCREATESTRUCT lpCreateStruct);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:
    BOOL m_fInitialized;
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline CMappedBitmapButton::CMappedBitmapButton()
{
};

inline CUpButton::CUpButton()
{
    LoadMappedBitmaps(IDB_UP, IDB_UPINV, IDB_UPFOC, IDB_UPDIS);
}

inline CDownButton::CDownButton()
{
    LoadMappedBitmaps(IDB_DOWN, IDB_DOWNINV, IDB_DOWNFOC, IDB_DOWNDIS);
}

inline const CDC & CRMCListBoxResources::dcBitMap() const
{
    return m_dcFinal;
}

inline int CRMCListBoxResources::BitmapHeight() const
{
    return m_nBitmapHeight;
}

inline int CRMCListBoxResources::BitmapWidth() const
{
    return m_nBitmapWidth;
}

inline COLORREF CRMCListBoxResources::ColorWindow() const
{
    return m_rgbColorWindow;
}

inline COLORREF CRMCListBoxResources::ColorHighlight() const
{
    return m_rgbColorHighlight;
}

inline COLORREF CRMCListBoxResources::ColorWindowText() const
{
    return m_rgbColorWindowText;
}

inline COLORREF CRMCListBoxResources::ColorHighlightText() const
{
    return m_rgbColorHighlightText;
}

inline int CODLBox::NumTabs() const
{
    return (int)m_auTabs.GetSize();
}

inline void CODLBox::SetTab(
    IN int nIndex,
    IN UINT uTab
    )
{
    ASSERT(nIndex >= 0 && nIndex < NumTabs());
    m_auTabs[nIndex] = uTab;
}

inline UINT CODLBox::GetTab(
    IN int nIndex
    ) const
{
    ASSERT(nIndex >= 0 && nIndex < NumTabs());
    return m_auTabs[nIndex];
}

inline int CODLBox::TextHeight() const
{
    return m_lfHeight;
}

inline void CODLBox::AttachWindow(
    IN CWnd * pWnd
    )
{
    m_pWnd = pWnd;
}

inline BOOL CRMCListBoxHeader::DoesRespondToColumnWidthChanges() const
{
    return m_fRespondToColumnWidthChanges;
}

inline void CRMCListBoxHeader::RespondToColumnWidthChanges(
    IN BOOL fRespond
    )
{
    m_fRespondToColumnWidthChanges = fRespond;
}

inline int CRMCListBoxHeader::QueryNumColumns() const
{
    return GetItemCount();
}

inline BOOL CRMCListBoxHeader::UseStretch() const
{
    return (m_dwStyle & HLS_STRETCH) != 0L;
}

inline BOOL CRMCListBoxHeader::UseButtons() const
{
    return (m_dwStyle & HLS_BUTTONS) != 0L;
}

inline int CHeaderListBox::QueryNumColumns() const
{
    return GetHeaderItemCount();
}

inline int CHeaderListBox::GetHeaderItemCount() const
{
    ASSERT(m_pHeader);
    return m_pHeader->GetItemCount();
}

inline BOOL CHeaderListBox::GetHeaderItem(
    IN int nPos,
    IN HD_ITEM * pHeaderItem
    ) const
{
    ASSERT(m_pHeader);
    return m_pHeader->GetItem(nPos, pHeaderItem);
}

inline BOOL CHeaderListBox::SetHeaderItem(
    IN int nPos,
    IN HD_ITEM * pHeaderItem
    )
{
    ASSERT(m_pHeader);
    return m_pHeader->SetItem(nPos, pHeaderItem);
}

inline int CHeaderListBox::InsertHeaderItem(
    IN int nPos,
    IN HD_ITEM * phdi
    )
{
    ASSERT(m_pHeader);
    return m_pHeader->InsertItem(nPos, phdi);
}

inline BOOL CHeaderListBox::DeleteHeaderItem(
    IN int nPos
    )
{
    ASSERT(m_pHeader);
    return m_pHeader->DeleteItem(nPos);
}

inline CRMCListBoxHeader * CHeaderListBox::GetHeader()
{
    return m_pHeader;
}

inline BOOL CRMCListBox::IsMultiSelect() const
{
    ASSERT(m_fInitialized);
    return m_fMultiSelect;
}


#endif  // _ODLBOX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\comprop\pwiz.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        pwiz.h

   Abstract:

        IIS Security Wizard

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/


#ifndef __IISPWIZ_H__
#define __IISPWIZ_H__



class CBlob;



#define NUM_ACCESS_RECORDS      (2)



typedef CList<DWORD, DWORD>  CDWORDList;                 




//
// Structure to map a flag to a string ID
//
typedef struct tagFLAGTOSTRING
{
    DWORD dwFlag;
    UINT  nID;
    BOOL  fSet;
} FLAGTOSTRING;





class COMDLL CIISSecurityTemplate : public CMetaProperties
/*++

Class Description:

    Security template info

Public Interface:

    CIISSecurityTemplate        : Constructor

    ApplySettings               : Apply template to destination path
    ClearSummary                : Clear the text summary
    GenerateSummary             : Generate the text summary

--*/
{
public:
    CIISSecurityTemplate(
        IN const CMetaKey * pKey,
        IN LPCTSTR lpszMDPath,
        IN BOOL    fInherit
        );

public:
    //
    // Apply settings to destination path
    //
    virtual HRESULT ApplySettings(
        IN BOOL    fUseTemplates,
        IN LPCTSTR lpszServerName,
        IN LPCTSTR lpszService,
        IN DWORD   dwInstance         = MASTER_INSTANCE,
        IN LPCTSTR lpszParent         = NULL,
        IN LPCTSTR lpszAlias          = NULL
        );

    //
    // Build summary strings from security settings.  Clear summary
    // before calling GenerateSummary().
    //
    virtual void GenerateSummary(
        IN BOOL    fUseTemplates,
        IN LPCTSTR lpszServerName,
        IN LPCTSTR lpszService,
        IN DWORD   dwInstance         = MASTER_INSTANCE,
        IN LPCTSTR lpszParent         = NULL,
        IN LPCTSTR lpszAlias          = NULL
        );

    void ClearSummary() { m_strlSummary.RemoveAll(); }
    POSITION GetHeadPosition() { return m_strlSummary.GetHeadPosition(); }
    CString & GetNext(POSITION & pos) { return m_strlSummary.GetNext(pos); }

    void AddSummaryString(
        IN LPCTSTR szTextItem,
        IN int cIndentLevel = 0
        );

    void AddSummaryString(
        IN UINT nID,
        IN int cIndentLevel = 0
        );

protected:
    //
    // Break out GetAllData() data to data fields
    //
    virtual void ParseFields();

public:
    MP_DWORD    m_dwAccessPerms;
    MP_CBlob    m_ipl;

protected:
    //
    // The derived class is expected to add its managed properties
    // to this list in its constructor
    //
    CDWORDList m_dlProperties;
    CStringList m_strlSummary;
};



//
// Method to allocate security template.  This is used by the service
// configuration dll to allocate a CIISSecurityTemplate-derived class
// specific to their service.
//
typedef CIISSecurityTemplate * (* pfnNewSecurityTemplate)(
    IN const CMetaKey * pKey,
    IN LPCTSTR lpszMDPath,
    IN BOOL    fInherit
    );



//
// Launch security wizard
//
HRESULT COMDLL
COMDLL_ISMSecurityWizard(
    IN pfnNewSecurityTemplate pfnTemplateAllocator,
    IN CMetaInterface * pInterface,
    IN UINT    nLeftBmpId,
    IN UINT    nHeadBmpId,
    IN LPCTSTR lpszService,
    IN DWORD   dwInstance,        
    IN LPCTSTR lpszParent,        
    IN LPCTSTR lpszAlias          
    );



class CIISSecWizSettings : public CObjectPlus
/*++

Class Description:

    Security wizard settings -- passed around from page
    to page.

Public Interface:

    CIISSecWizSettings     : Constructor    

--*/
{
//
// Constructor/Destructor
//
public:
    CIISSecWizSettings(
        IN pfnNewSecurityTemplate pfnTemplateAllocator,
        IN LPCTSTR lpszServer,
        IN LPCTSTR lpszService,
        IN DWORD   dwInstance,
        IN LPCTSTR lpszParent,
        IN LPCTSTR lpszAlias
        );

    ~CIISSecWizSettings();

public:
    //
    // Fetch the metabase properties from the open key
    // (could be template or another vroot)
    //
    HRESULT FetchProperties(
        IN  CMetaKey & mk,
        IN  LPCTSTR lpszPath = NULL,
        IN  BOOL    fInherit = FALSE
        );

//
// Data Members
//
public:
    BOOL    m_fSetAcls;
    BOOL    m_fReplaceAcls;
    BOOL    m_fRedirected;
    BOOL    m_fUseTemplate;
    DWORD   m_dwInstance;
    DWORD   m_AccessMaskAdmin;
    DWORD   m_AccessMaskEveryone;
    DWORD   m_AccessMaskDefault;
    HRESULT m_hResult;
    CString m_strServer;
    CString m_strService;
    CString m_strParent;
    CString m_strAlias;
    CString m_strPath;
    CIISSecurityTemplate * m_pist;
    pfnNewSecurityTemplate m_pfnTemplateAllocator;
    EXPLICIT_ACCESS m_rgaae[NUM_ACCESS_RECORDS];
};



//
// Permissions Wizard Source Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

class COMDLL CPWSource : public CIISWizardPage
{
    DECLARE_DYNCREATE(CPWSource)

//
// Construction
//
public:
    CPWSource(IN CIISSecWizSettings * pSettings = NULL);
    ~CPWSource();

//
// Dialog Data
//
protected:
    enum { RADIO_INHERITANCE, RADIO_TEMPLATE, };

    //{{AFX_DATA(CPWSource)
    enum { IDD = IDD_PERMWIZ_SOURCE };
    int     m_nSource;
    //}}AFX_DATA

//
// Overrides
//
protected:
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CPWSource)
    public:
    virtual BOOL OnSetActive();
    virtual LRESULT OnWizardNext();
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);    
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    // Generated message map functions
    //{{AFX_MSG(CPWSource)
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    void SetControlStates();    

private:
    CIISSecWizSettings * m_pSettings;
};



//
// Permissions Wizard Template Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

class COMDLL CPWTemplate : public CIISWizardPage
{
    DECLARE_DYNCREATE(CPWTemplate)

//
// Construction
//
public:
    CPWTemplate(IN CIISSecWizSettings * pSettings = NULL);
    ~CPWTemplate();

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CPWTemplate)
    enum { IDD = IDD_PERMWIZ_TEMPLATE };
    CListBox    m_list_Templates;
    CEdit       m_edit_Description;
    //}}AFX_DATA

//
// Overrides
//
protected:
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CPWTemplate)
    public:
    virtual BOOL OnSetActive();
    virtual LRESULT OnWizardNext();
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    // Generated message map functions
    //{{AFX_MSG(CPWTemplate)
    virtual BOOL OnInitDialog();
    afx_msg void OnSelchangeListTemplates();
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()

    void SetControlStates();    

private:
    CIISSecWizSettings * m_pSettings;
};



//
// Permissions Wizard ACL Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

class COMDLL CPWACL : public CIISWizardPage
{
    DECLARE_DYNCREATE(CPWACL)

//
// Construction
//
public:
    CPWACL(IN CIISSecWizSettings * pSettings = NULL);
    ~CPWACL();

//
// Dialog Data
//
protected:
    enum { RADIO_MAXIMUM, RADIO_MINIMUM, RADIO_NONE, };

    //{{AFX_DATA(CPWACL)
    enum { IDD = IDD_PERMWIZ_ACL };
    CStatic m_static_Line4;
    CStatic m_static_Line3;
    CStatic m_static_Line2;
    CStatic m_static_Line1;
    int     m_nRadioAclType;
    //}}AFX_DATA

//
// Overrides
//
protected:
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CPWACL)
    public:
    virtual BOOL OnSetActive();
    virtual LRESULT OnWizardNext();
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    // Generated message map functions
    //{{AFX_MSG(CPWACL)
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    void SetControlStates();    

private:
    CIISSecWizSettings * m_pSettings;
};



//
// Permissions Wizard Summary Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

class COMDLL CPWSummary : public CIISWizardPage
{
    DECLARE_DYNCREATE(CPWSummary)

//
// Construction
//
public:
    CPWSummary(IN CIISSecWizSettings * pSettings = NULL);
    ~CPWSummary();

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CPWSummary)
    enum { IDD = IDD_PERMWIZ_SUMMARY };
    CListBox    m_list_Summary;
    //}}AFX_DATA

//
// Overrides
//
protected:
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CPWSummary)
    public:
    virtual BOOL OnSetActive();
    virtual LRESULT OnWizardNext();
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    // Generated message map functions
    //{{AFX_MSG(CPWSummary)
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    void SetControlStates();    
    void GenerateAclSummary();
    void DisplaySummary();

    HRESULT ApplyACLSToFiles();

    HRESULT
    SetPermToChildren(
	      IN CString& FileName,
	      IN SECURITY_INFORMATION si,
         IN PACL pDacl,
         IN PACL pSacl
	      );

private:
    CIISSecWizSettings * m_pSettings;
};

#endif // __IISPWIZ_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\comprop\registry.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        registry.h

   Abstract:

        Registry classes definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

#ifndef _REGISTRY_H
#define _REGISTRY_H

//
// Forward declarations
//
class CRMCRegKey;
class CRMCRegValueIter;
class CRMCRegKeyIter;

//
// Maximum size of a Registry class name
//
#define CREGKEY_MAX_CLASS_NAME     MAX_PATH

//
// Parameter helper
//
#define EXPANSION_ON  (TRUE)
#define EXPANSION_OFF (FALSE)




class COMDLL CRMCRegKey : public CObject
/*++

Class Description:

    Registry key class.

Public Interface:

    CRMCRegKey         : Registry key object constructor
    ~CRMCRegKey        : Registry key object destructor

    operator HKEY      : cast to HKEY handle
    GetHandle          : Get HKEY handle
    Ok                 : TRUE if the key was initialized OK, FALSE otherwise.
    IsLocal            : TRUE if the key was opened on the local machine

    QueryKeyInfo       : Fill a key information structure
    QueryValue         : Overloaded value query members
    SetValue           : Overloaded set value members

    AssertValid        : Assert the object is in a valid state (debug only)
    Dump               : Dump to the debug context (debug only)

--*/
{
public:
    //
    // Key information return structure
    //
    typedef struct
    {
        TCHAR chBuff[CREGKEY_MAX_CLASS_NAME];
        DWORD dwClassNameSize,
              dwNumSubKeys,
              dwMaxSubKey,
              dwMaxClass,
              dwMaxValues,
              dwMaxValueName,
              dwMaxValueData,
              dwSecDesc;
        FILETIME ftKey;
    } CREGKEY_KEY_INFO;

//
// Constructor/Destructor
//
public:
    //
    // Standard constructor for an existing key
    //
    CRMCRegKey(
        IN HKEY    hKeyBase,
        IN LPCTSTR lpszSubKey     = NULL,
        IN REGSAM  regSam         = KEY_ALL_ACCESS,
        IN LPCTSTR lpszServerName = NULL
        );

    //
    // Constructor creating a new key.
    //
    CRMCRegKey(
        OUT BOOL * pfNewKeyCreated,
        IN  HKEY    hKeyBase,
        IN  LPCTSTR lpszSubKey             = NULL,
        IN  DWORD   dwOptions              = REG_OPTION_NON_VOLATILE,
        IN  REGSAM  regSam                 = KEY_ALL_ACCESS,
        IN  LPSECURITY_ATTRIBUTES pSecAttr = NULL,
        IN  LPCTSTR lpszServerName         = NULL
        );

    ~CRMCRegKey();

//
// Interface
//
public:
    //
    // Allow a CRMCRegKey to be used anywhere an HKEY is required.
    //
    operator HKEY() const;
    HKEY GetHandle() const;
    BOOL Ok() const;
    BOOL IsLocal() const;

    //
    // Fill a key information structure
    //
    DWORD QueryKeyInfo(
        OUT CREGKEY_KEY_INFO * pRegKeyInfo
        );

//
// Overloaded value query members; each returns ERROR_INVALID_PARAMETER
// if data exists but not in correct form to deliver into result object.
//
public:
    //
    // Autoexpand will automatically expand REG_EXPAND_SZ items on the
    // local computer.
    //
    DWORD QueryValue(
        IN  LPCTSTR lpszValueName, 
        OUT CString & strResult,
        IN  BOOL fAutoExpand  = EXPANSION_OFF,
        OUT BOOL * pfExpanded = NULL
        );

    DWORD QueryValue(
        IN  LPCTSTR lpszValueName, 
        OUT CStringListEx & strList
        );

    DWORD QueryValue(
        IN  LPCTSTR lpszValueName, 
        OUT DWORD & dwResult
        );

    DWORD QueryValue(
        IN  LPCTSTR lpszValueName, 
        OUT CByteArray & abResult
        );

    DWORD QueryValue(
        IN  LPCTSTR lpszValueName, 
        OUT void * pvResult, 
        OUT DWORD cbSize
        );

//
// Overloaded value setting members.
//
public:
    //
    // AutoDeflate will attempt to use %SystemRoot% in the path
    // and write it as REG_EXPAND_SZ.  if *pfDeflate = TRUE
    // upon entry, REG_EXPAND_SZ will be set as well, but
    // not automatic environment substitution will be performed.
    //
    // Otherwise, this will set as REG_SZ.
    //
    DWORD SetValue(
        IN  LPCTSTR lpszValueName, 
        IN  CString & strResult,
        IN  BOOL fAutoDeflate    = EXPANSION_OFF,
        OUT BOOL * pfDeflate     = NULL
        );

    DWORD SetValue(
        IN LPCTSTR lpszValueName, 
        IN CStringListEx & strList
        );

    DWORD SetValue(
        IN LPCTSTR lpszValueName, 
        IN DWORD & dwResult
        );

    DWORD SetValue(
        IN LPCTSTR lpszValueName, 
        IN CByteArray & abResult
        );

    DWORD SetValue(
        IN LPCTSTR lpszValueName, 
        IN void * pvResult, 
        IN DWORD cbSize
        );

//
// Delete Key/Value
//
public:
    DWORD DeleteValue(LPCTSTR lpszValueName);
    DWORD DeleteKey(LPCTSTR lpszSubKey);

#ifdef _DEBUG

    virtual void AssertValid() const;
    virtual void Dump(
        IN OUT CDumpContext& dc
        ) const;

#endif // _DEBUG

protected:
    //
    // Convert a CStringListEx to the REG_MULTI_SZ format
    //
    static DWORD FlattenValue(
        IN  CStringListEx & strList,
        OUT DWORD * pcbSize,
        OUT BYTE ** ppbData 
        );

    //
    // Convert a CByteArray to a REG_BINARY block
    //
    static DWORD FlattenValue(
        IN  CByteArray & abData,
        OUT DWORD * pcbSize,
        OUT BYTE ** ppbData 
        );

protected:
    //
    // Prepare to read a value by finding the value's size.
    //
    DWORD PrepareValue(
        LPCTSTR lpszValueName,  
        DWORD * pdwType,
        DWORD * pcbSize,
        BYTE ** ppbData 
        );

private:
    BOOL  m_fLocal;
    HKEY  m_hKey;
    DWORD m_dwDisposition;
};



class COMDLL CRMCRegValueIter : public CObject
/*++

Class Description:

    Registry value iteration class

Public Interface:

    CRMCRegValueIter   : Iteration class constructor
    ~CRMCRegValueIter  : Iteration class destructor

    Next               : Get the name of the next key
    Reset              : Reset the iterator

--*/
{
//
// Constructor/Destructor
//
public:
    CRMCRegValueIter(
        IN CRMCRegKey & regKey
        );

    ~CRMCRegValueIter();

//
// Interface
//
public:
    //
    // Get the name (and optional last write time) of the next key.
    //
    DWORD Next(
        OUT CString * pstrName, 
        OUT DWORD * pdwType
        );

    //
    // Reset the iterator
    //
    void Reset();

protected:
    CRMCRegKey & m_rkIter;
    DWORD m_dwIndex;
    TCHAR * m_pBuffer;
    DWORD m_cbBuffer;
};




class COMDLL CRMCRegKeyIter : public CObject
/*++

Class Description:

    Iterate the sub-key names of a key

Public Interface:

    CRMCRegKeyIter     : Iteration class constructor
    ~CRMCRegKeyIter    : Iteration class destructor

    Next               : Get the name of the next key
    Reset              : Reset the iterator

--*/
{
public:
    CRMCRegKeyIter(
        IN CRMCRegKey & regKey
        );

    ~CRMCRegKeyIter();

//
// Interface
//
public:
    //
    // Get the name (and optional last write time) of the next key.
    //
    DWORD Next(
        OUT CString * pstrName, 
        OUT CTime * pTime = NULL
        );

    //
    // Reset the iterator
    //
    void Reset();

private:
    CRMCRegKey & m_rkIter;
    DWORD m_dwIndex;
    TCHAR * m_pBuffer;
    DWORD m_cbBuffer;
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline CRMCRegKey::operator HKEY() const
{ 
    return m_hKey; 
}

inline HKEY CRMCRegKey::GetHandle() const
{
    return m_hKey;
}

inline BOOL CRMCRegKey::Ok() const
{
    return m_hKey != NULL;
}

inline BOOL CRMCRegKey::IsLocal() const
{
    return m_fLocal;
}

inline DWORD CRMCRegKey::DeleteValue(
    IN LPCTSTR lpszValueName
    )
{
    return ::RegDeleteValue(*this, lpszValueName);
}

inline DWORD CRMCRegKey::DeleteKey(
    IN LPCTSTR lpszSubKey
    )
{
    return ::RegDeleteKey(*this, lpszSubKey);
}

inline void CRMCRegValueIter::Reset()
{
    m_dwIndex = 0L; 
}

inline void CRMCRegKeyIter::Reset()
{ 
    m_dwIndex = 0L; 
}

#endif // _REGISTRY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\comprop\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by comprop.rc
//
#define IDS_DATABASE_NAME               1
#define IDS_DIRECTORY_NAME              2
#define IDS_FILENAME                    3
#define IDS_IPADDRESS                   4
#define IDS_DENIED                      5
#define IDS_DIRECTORY                   6
#define IDS_ALIAS                       7
#define IDS_ERR_MAKE_DIRECTORY          8
#define IDHELP                          9
#define IDS_HOME_DIRECTORY              9
#define IDS_WRN_HOME_EXISTS             10
#define IDS_WRN_MULTIPLE_HOMES          11
#define IDD_MIME_TYPES                  11
#define IDS_LOG_FILENAME                12
#define IDS_ERR_ROOT_NO_HOME            13
#define IDS_DENY                        14
#define IDS_GRANT                       15
#define IDS_ERR_ALIAS_NOT_UNIQUE        16
#define IDS_SPEC_HOME                   17
#define IDS_EXECUTE                     18
#define IDS_WEEKLY_LOG                  20
#define IDS_MONTHLY_LOG                 21
#define IDS_SEQUENTIAL_LOG              22
#define IDS_GRANTED                     23
#define IDS_ERROR                       24
#define IDS_COMMON_CHANGE               25
#define IDS_SSL_DISABLED                26
#define IDS_SSL_NOT_INSTALLED           27
#define IDS_WRN_CLEARTEXT               28
#define IDS_DDX_MINIMUM                 28
#define IDS_MS_FORMAT                   29
#define IDS_NCSA_FORMAT                 30
#define IDS_PASSWORD_NO_MATCH           31
#define IDS_PROMPT_NETWORK_ID           32
#define IDS_PROMPT_IP_ADDRESS           33
#define IDS_SELECT_IUSR_ACCOUNT         34
#define IDS_INVALID_NUMBER              35
#define IDS_FMT_SECURITY                36
#define IDS_BINARY_FORMAT               37
#define IDS_PROMPT_DOMAIN               38
#define IDS_DOMAIN_PERF                 39
#define IDS_CUSTOM_FORMAT               40
#define IDS_DUPLICATE_ENTRY             41
#define IDS_IP_INVALID                  42
#define IDS_ACCESS                      43
#define IDS_IP_ADDRESS_SUBNET_MASK      44
#define IDS_IP_ADDRESS_SUBNET_MASK_DOMAIN 45
#define IDS_DUP_ALIAS                   45
#define IDS_DEFAULT_VROOT               46
#define IDS_BROWSE_DIRECTORY            47
#define IDS_BROWSE_DOMAIN               48
#define IDS_SERVICE_NAME                49
#define IDS_SERVER_IP_ADDRESS           50
#define IDS_WIN_32_STATUS               51
#define IDS_CLIENT_HOST_NAME            52
#define IDS_CLIENT_AGENT_NAME           53
#define IDS_CLIENT_USER_NAME            54
#define IDS_CLIENT_PASSWORD             55
#define IDS_PROTOCOL_VERSION            56
#define IDS_LANGUAGE                    57
#define IDS_PROCESSING_TIME             58
#define IDS_BYTES_SENT                  59
#define IDS_BYTES_RECEVIED              60
#define IDS_SERVICE_STATUS_CODE         61
#define IDS_OPERATION                   62
#define IDS_TARGET                      63
#define IDS_PARAMETERS                  64
#define IDS_COOKIE                      65
#define IDS_LOG_TIME                    66
#define IDS_SERVER_NAME                 67
#define IDS_WWW_MASTER                  68
#define IDS_FTP_MASTER                  69
#define IDS_REMOVE_MIME                 70
#define IDS_REPLACE_MIME                71
#define IDS_CONNECTION_LIMIT            72
#define IDS_WRN_CONNECTION_LIMIT        73
#define IDS_PASSWORD_OK                 74
#define IDS_ERR_NO_USERNAME             75
#define IDS_DEFAULT                     76
#define IDS_UNKNOWN_USER                77
#define IDS_SELECT_ADMIN                78
#define IDS_INVALID_DOMAIN_NAME         79
#define IDS_ERR_BAD_PATH                80
#define IDS_BAD_BROWSE                  81
#define IDS_ERR_PATH_NOT_FOUND          82
#define IDS_ERR_INVALID_PATH            83
#define IDS_WRN_PWSYNC                  84
#define IDS_INSTANCE_STATE_FMT          85
#define IDS_INSTANCE_PORT_FMT           86
#define IDS_INSTANCE_DEF_FMT            87
#define IDS_INHERITANCE_PROMPT          88
#define IDS_INHERITANCE_NO_NAME         89
#define IDS_RECONNECT_WARNING           90
#define IDC_MACHINE_NAME                103
#define IDC_SERVIEC_NAME                104
#define IDD_SITE_SECURITY               106
#define IDD_COMMON                      109
#define IDC_SERVER_IP_ADDRESS           110
#define IDC_WIN_STATUS                  111
#define IDC_CLIENT_HOSTNAME             113
#define IDC_CLIENT_AGENTNAME            114
#define IDC_CLIENT_USERNAME             115
#define IDC_CLIENT_PASSWORD             116
#define IDD_DIRBROWSE                   118
#define IDC_PROTOCOL_VERSION            119
#define IDC_LANGUAGE                    120
#define IDD_IP_ACCESS                   121
#define IDC_PROCESSING_TIME             122
#define IDD_DNS                         126
#define IDD_CONFIRM_PASSWORD            127
#define IDD_CLEARTEXTWARNING            128
#define IDD_IIS_MACHINE                 129
#define IDI_FILE_TYPES                  129
#define IDI_DEFAULT_PROPERTIES          130
#define IDD_ADD_FILTER                  131
#define IDC_SERVICE_STATUS_CODE         132
#define IDD_MIME_PROPERTY               133
#define IDD_INHERITANCE                 135
#define IDD_ERROR                       136
#define IDD_SELECTION_DIALOG            200
#define IDS_MD_CONNECTION_TIMEOUT       200
#define IDS_MD_MAX_CONNECTIONS          201
#define IDS_MD_SERVER_COMMENT           202
#define IDS_MD_SERVER_SIZE              203
#define IDS_MD_SERVER_LISTEN_BACKLOG    204
#define IDS_MD_SERVER_LISTEN_TIMEOUT    205
#define IDS_MD_APP_FRIENDLY_NAME        207
#define IDS_MD_APP_ROOT                 208
#define IDS_MD_APP_ISOLATED             209
#define IDS_MD_VR_PATH                  210
#define IDS_MD_VR_USERNAME              211
#define IDS_MD_VR_PASSWORD              212
#define IDS_MD_EXIT_MESSAGE             213
#define IDS_MD_GREETING_MESSAGE         214
#define IDS_MD_MAX_CLIENTS_MESSAGE      215
#define IDS_MD_MSDOS_DIR_OUTPUT         216
#define IDS_MD_ALLOW_ANONYMOUS          217
#define IDS_MD_ANONYMOUS_ONLY           218
#define IDS_MD_LOG_ANONYMOUS            219
#define IDS_MD_LOG_NONANONYMOUS         220
#define IDS_MD_AUTHORIZATION            221
#define IDS_MD_REALM                    222
#define IDS_MD_HTTP_EXPIRES             223
#define IDS_MD_HTTP_PICS                224
#define IDS_MD_HTTP_CUSTOM              225
#define IDS_MD_DIRECTORY_BROWSING       226
#define IDS_MD_DEFAULT_LOAD_FILE        227
#define IDS_MD_CONTENT_NEGOTIATION      228
#define IDS_MD_CUSTOM_ERROR             229
#define IDS_MD_FOOTER_DOCUMENT          230
#define IDS_MD_FOOTER_ENABLED           231
#define IDS_MD_HTTP_REDIRECT            232
#define IDS_MD_DEFAULT_LOGON_DOMAIN     233
#define IDS_MD_LOGON_METHOD             234
#define IDS_MD_SCRIPT_MAPS              235
#define IDS_MD_MIME_MAP                 236
#define IDS_MD_ACCESS_PERM              237
#define IDS_MD_HEADER_DOCUMENT          238
#define IDS_MD_HEADER_ENABLED           239
#define IDS_MD_IP_SEC                   240
#define IDS_MD_ANONYMOUS_USER_NAME      241
#define IDS_MD_ANONYMOUS_PWD            242
#define IDS_MD_ANONYMOUS_USE_SUBAUTH    243
#define IDS_MD_DONT_LOG                 244
#define IDS_MD_ADMIN_ACL                245
#define IDS_MD_SSI_EXEC_DISABLED        246
#define IDS_MD_SSL_ACCESS_PERM          247
#define IDS_MD_NTAUTHENTICATION_PROVIDERS 248
#define IDS_MD_SCRIPT_TIMEOUT           249
#define IDS_MD_CACHE_EXTENSIONS         250
#define IDS_MD_CREATE_PROCESS_AS_USER   251
#define IDS_MD_CREATE_PROC_NEW_CONSOLE  252
#define IDS_MD_POOL_IDC_TIMEOUT         253
#define IDS_MD_ALLOW_KEEPALIVES         254
#define IDS_MD_IS_CONTENT_INDEXED       255
#define IDS_ASP_BUFFERINGON             256
#define IDS_ASP_LOGERRORREQUESTS        257
#define IDS_ASP_SCRIPTERRORSSENTTOBROWSER 258
#define IDS_ASP_SCRIPTERRORMESSAGE      259
#define IDS_ASP_SCRIPTFILECACHESIZE     260
#define IDS_ASP_SCRIPTENGINECACHEMAX    261
#define IDS_ASP_SCRIPTTIMEOUT           262
#define IDS_ASP_SESSIONTIMEOUT          263
#define IDS_ASP_ENABLEPARENTPATHS       264
#define IDS_ASP_ALLOWSESSIONSTATE       265
#define IDS_ASP_SCRIPTLANGUAGE          266
#define IDS_ASP_EXCEPTIONCATCHENABLE    267
#define IDS_ASP_ENABLESERVERDEBUG       268
#define IDS_ASP_ENABLECLIENTDEBUG       269
#define IDS_MD_LOG_PLUGIN_ORDER         270
#define IDS_MD_LOGEXT_FIELD_MASK        271
#define IDS_MD_LOG_TYPE                 272
#define IDS_MD_LOGFILE_DIRECTORY        273
#define IDS_MD_LOGFILE_PERIOD           274
#define IDS_MD_LOGFILE_TRUNCATE_SIZE    275
#define IDS_MD_LOGSQL_DATA_SOURCES      276
#define IDS_MD_LOGSQL_TABLE_NAME        277
#define IDS_MD_LOGSQL_USER_NAME         278
#define IDS_MD_LOGSQL_PASSWORD          279
#define IDS_MD_CPU_LIMITS_ENABLED       280
#define IDS_MD_CPU_LIMIT_LOGEVENT       281
#define IDS_MD_CPU_LIMIT_PRIORITY       282
#define IDS_MD_CPU_LIMIT_PAUSE          283
#define IDS_MD_CPU_LIMIT_PROCSTOP       284
#define IDS_MD_LOGFILE_LOCALTIME_ROLLOVER 285
#define IDS_MD_CPU_LOGGING_MASK         286
#define IDS_PERMWIZ                     287
#define IDS_NO_TEMPLATES                288
#define IDS_AUTHENTICATION_METHODS      289
#define IDS_AUTHENTICATION_ANONYMOUS    290
#define IDS_AUTHENTICATION_BASIC        291
#define IDS_AUTHENTICATION_NT           292
#define IDS_AUTHENTICATION_DIGEST       293
#define IDS_SUMMARY_NONE                294
#define IDS_PERMISSIONS                 295
#define IDS_PERMS_READ                  296
#define IDS_PERMS_WRITE                 297
#define IDS_PERMS_SCRIPT                298
#define IDS_PERMS_EXECUTE               299
#define IDS_ADDRESS_RESTRICTIONS        300
#define IDS_PERM_SUCCESS                301
#define IDS_ADDRESS_IP                  302
#define IDS_AUTHENTICATION_ANONYMOUS_ONLY 303
#define IDS_AUTHENTICATION_NO_ANONYMOUS 304
#define IDS_SUMMARY_GRANTED             305
#define IDS_SUMMARY_DENIED              306
#define IDS_SPECIFIC_GRANTED            307
#define IDS_SPECIFIC_DENIED             308
#define IDS_ACL_ADMINS                  309
#define IDS_ACL_EV_READ                 310
#define IDS_ACL_EV_WRITE                311
#define IDS_ACL_EV_EXEC                 312
#define IDS_ACL_SUMMARY                 313
#define IDS_ACL_NONE                    314
#define IDS_ACL_REPLACEMENT             315
#define IDS_ACL_ADDED                   316
#define IDS_ACL_ADMIN                   317
#define IDS_ACL_EVR                     318
#define IDS_ACL_READ                    319
#define IDS_ACL_READ_CONTROL            320
#define IDS_ACL_READ_ATTRIB             321
#define IDS_ACL_READ_PROP               322
#define IDS_ACL_WRITE                   323
#define IDS_ACL_APPEND                  324
#define IDS_ACL_DELETE                  325
#define IDS_ACL_WRITE_ATTRIB            326
#define IDS_ACL_WRITE_PROP              327
#define IDS_ACL_EXECUTE                 328
#define IDS_ACL_LIST_OBJECT             329
#define IDS_DIR_BROWSE_ON               350
#define IDS_DIR_BROWSE_OFF              351
#define IDS_LOAD_DEFAULT_ON             352
#define IDS_LOAD_DEFAULT_OFF            353
#define IDS_BUTTON_DONE                 354
#define IDS_WIZ_NEXT                    355
#define IDS_WIZ_FINISH                  356
#define IDS_PWIZ_WELCOME                357
#define IDS_PWIZ_BODY                   358
#define IDS_PWIZ_SUCCESS                359
#define IDS_PWIZ_FAILURE                360
#define IDS_INSTANCE_DEF_FMT_WEB        361
#define IDS_INSTANCE_DEF_FMT_FTP        362
#define IDB_ACCESS                      501
#define IDI_GRANTED                     503
#define IDI_DENIED                      504
#define IDB_UP                          505
#define IDB_UPFOC                       506
#define IDB_UPDIS                       507
#define IDB_UPINV                       508
#define IDB_DOWN                        509
#define IDB_DOWNFOC                     510
#define IDB_DOWNDIS                     511
#define IDB_DOWNINV                     512
#define IDC_LIST_MIME_TYPES             800
#define IDC_ICON_EXTENSION              801
#define IDC_EDIT_EXTENSION              802
#define IDC_EDIT_PROGRAM                804
#define IDC_BUTTON_NEW_TYPE             805
#define IDC_STATIC_EXTENSION            832
#define IDC_STATIC_PROGRAM              833
#define IDC_EDIT_CONTENT_TYPE           834
#define IDC_STATIC_CONTENT_TYPE         835
#define IDC_ADD                         1001
#define IDC_REMOVE                      1002
#define IDC_DIRECTORY                   1005
#define IDC_BROWSE                      1008
#define IDC_EDIT_DIRECTORY              1015
#define IDC_BUTTON_ADD                  1016
#define IDC_EDIT_MAX_NETWORK_USE        1017
#define IDC_EDIT_USER_NAME              1017
#define IDC_IPA_SUBNET_MASK             1023
#define IDC_HEADER                      1023
#define IDC_LIST_DIRECTORIES            1024
#define IDC_STATIC_DIRECTORY            1026
#define IDC_GROUP                       1030
#define IDC_STATIC_FILE                 1030
#define chx1                            0x0410
#define IDC_NEW_LOG                     1044
#define IDC_WEEKLY                      1046
#define IDC_TABLE                       1049
#define IDC_USER_NAME                   1050
#define IDC_PASSWORD                    1053
#define IDC_STATIC_DATASOURCE           1054
#define IDC_STATIC_USER_NAME            1056
#define IDC_STATIC_PASSWORD             1057
#define IDC_STATIC_MB                   1059
#define IDC_BUTTON_EDIT                 1067
#define IDC_BUTTON_REMOVE               1068
#define IDC_LIST_IP_ADDRESSES           1069
#define IDC_EDIT_DISK_CACHE             1071
#define IDC_CHECK_LIMIT_NETWORK_USE     1073
#define IDC_STATIC_MAX_NETWORK_USE      1074
#define IDC_STATIC_KBS                  1076
#define IDC_BUTTON_BROWSE               1077
#define IDC_EDIT_ALIAS                  1079
#define IDC_SPIN_FILESIZE               1082
#define stc1                            0x0440
#define stc2                            0x0441
#define stc3                            0x0442
#define stc4                            0x0443
#define IDC_RADIO_GRANTED               1094
#define IDC_RADIO_DENIED                1095
#define IDC_RADIO_SINGLE                1096
#define IDC_RADIO_MULTIPLE              1097
#define IDC_STATIC_SUBNET_MASK          1098
#define IDC_RADIO_GRANT                 1101
#define IDC_RADIO_DENY                  1102
#define IDC_STATIC_ACCESS               1104
#define IDC_STATIC_IP_ADDRESS           1105
#define IDC_STATIC_SUBNETMASK           1106
#define IDC_IPA_IPADDRESS               1107
#define lst1                            0x0460
#define IDC_STATIC_IP_GROUP             1120
#define lst2                            0x0461
#define IDC_CHECK_USE_IP                1121
#define IDC_STATIC_IP_PROMPT            1122
#define IDC_STATIC_ALIAS                1125
#define cmb1                            0x0470
#define IDC_RADIO_HOME                  1136
#define cmb2                            0x0471
#define IDC_RADIO_ALIAS                 1137
#define IDC_CHECK_EXECUTE               1138
#define IDC_GROUP_ACCOUNT               1139
#define IDC_GROUP_ACCESS                1140
#define IDC_CHECK_SSL                   1141
#define IDC_BUTTON_DNS                  1142
#define IDC_EDIT_DNS_NAME               1143
#define IDC_STATIC_BY_DEFAULT           1144
#define IDC_STATIC_EXCEPT               1145
#define IDC_ICON_GRANTED                1146
#define IDC_ICON_DENIED                 1147
#define IDC_EDIT_CONFIRM_PASSWORD       1149
#define IDC_BUTTON_FILE_TYPES           1151
#define IDC_DESCRIPTION                 1151
#define edt1                            0x0480
#define IDC_BUTTON_EDIT_DEFAULT         1152
#define IDC_DOWN                        1153
#define IDC_CONFIGURE                   1156
#define IDC_IMPORT                      1158
#define IDC_RADIO_DOMAIN                1160
#define IDC_EDIT_DOMAIN                 1161
#define IDC_COMBO_MASTER_TYPE           1162
#define IDC_OPERATION                   1163
#define IDC_TARGET                      1164
#define IDC_PARAMETERS                  1165
#define IDC_AVAILABLE_FIELD             1166
#define IDC_EDIT_EXTENT                 1170
#define IDC_EDIT_MIME                   1171
#define IDC_STATIC_THROTTLE_PROMPT      1172
#define IDC_GROUP_MASTER                1173
#define IDC_STATIC_MASTER_PROMPT1       1174
#define IDC_STATIC_MASTER_PROMPT2       1175
#define IDC_LIST_CHILD_NODES            1177
#define IDC_BUTTON_SELECT_ALL           1178
#define IDC_STATIC_PROMPT               1180
#define IDC_RADIO_UNLIMITED             1182
#define IDC_BUTTON_COMPRESSION_CONFIGURE 1182
#define IDC_RADIO_LIMITED               1183
#define IDC_EDIT_DIRECTORY_SIZE         1184
#define IDC_EDIT_FILE_TYPES             1185
#define IDC_STATIC_GROUP_DETAILS        1186
#define IDC_STATIC_TAB1                 1187
#define IDC_STATIC_TAB2                 1188
#define IDC_BUTTON_E3                   1190
#define IDC_STATIC_ERROR_ICON           1191
#define IDC_RICHEDIT1                   1198
#define IDC_STATIC_DIR_NAME             1251
#define IDC_EDIT_NEW_DIRECTORY_NAME     1267
#define IDB_ACLUSERS                    2004
#define IDI_AUTHENTICATION              2025
#define IDD_USER_ACCOUNT                2029
#define IDD_COMPRESSION                 2030
#define IDD_PERMWIZ_WELCOME             2059
#define IDD_PERMWIZ_SOURCE              2060
#define IDD_PERMWIZ_TEMPLATE            2061
#define IDD_PERMWIZ_ACL                 2062
#define IDD_PERMWIZ_SUMMARY             2063
#define IDD_WIZARD_BOOKEND              2066
#define IDC_EDIT_USERNAME               3050
#define IDC_EDIT_PASSWORD               3051
#define IDC_STATIC_USERNAME             3053
#define IDC_RADIO_UNIX                  3055
#define IDC_RADIO_MSDOS                 3056
#define IDC_BUTTON_CHECK_PASSWORD       3070
#define IDC_BUTTON_BROWSE_USERS         3082
#define IDC_EDIT_DESCRIPTION            3216
#define IDC_RADIO_INHERIT               3859
#define IDC_RADIO_TEMPLATE              3860
#define IDC_LIST_TEMPLATES              3861
#define IDC_RADIO_ACL_MAXIMUM           3863
#define IDC_RADIO_ACL_MINIMUM           3864
#define IDC_RADIO_NO_ACL                3865
#define IDC_LIST_SUMMARY                3867
#define IDC_STATIC_WZ_WELCOME           4000
#define IDC_STATIC_WZ_TITLE             4001
#define IDC_STATIC_WZ_SUBTITLE          4002
#define IDC_STATIC_WZ_BODY              4003
#define IDC_STATIC_WZ_CLICK             4004
#define IDC_STATIC_WZ_HEADER_DIVIDER    4005
#define IDC_ED_BOLD1                    4011
#define IDC_ED_BOLD2                    4012
#define IDC_ED_BOLD3                    4013
#define IDC_ED_BOLD4                    4014
#define IDC_ED_BOLD5                    4015
#define IDS_ERR_BASE                    50000
#define IDS_ERR_COMMON_BASE             50000
#define IDS_ERR_RPC_NA                  50000
#define IDS_ERR_INTERFACE               50001
#define IDS_ERR_ODBC                    50002
#define IDS_NO_MESSAGE                  50003
#define IDS_CANT_START_SERVICE          50004
#define IDS_METABASE_ERROR              50005
#define IDS_ERR_DUP_VROOT               50006
#define IDS_ERR_COMMON_LAST             50999
#define IDS_ERR_SVC_BASE                51000
#define IDS_ERR_SVC_LAST                54999
#define IDS_ERR_LAST                    55000

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        137
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1199
#define _APS_NEXT_SYMED_VALUE           111
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\comprop\setperm.cpp ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        setperm.cpp

   Abstract:

        IIS Security Wizard helper file

   Author:

        Sergei Antonov (sergeia)

   Project:

        Internet Services Manager

   Revision History:
		7/12/99		created
--*/

//
// Include Files
//
#include "stdafx.h"
#include "comprop.h"
#include <aclapi.h>
#include <ntseapi.h>
#include <shlwapi.h>

static HRESULT
SetSecurityDeep(
   LPTSTR *ppszBuffer,
   UINT * pcchBuffer,
   DWORD dwAttributes,
   SECURITY_INFORMATION si,
   PACL pDacl,
   PACL pSacl
   );

static BOOL 
PathIsDotOrDotDot(LPCTSTR pszPath)
{
   if (TEXT('.') == *pszPath++)
   {
      if (TEXT('\0') == *pszPath || (TEXT('.') == *pszPath && TEXT('\0') == *(pszPath + 1)))
         return TRUE;
   }
   return FALSE;
}

HRESULT
CPWSummary::SetPermToChildren(
	IN CString& FileName,
   IN SECURITY_INFORMATION si,
	IN PACL pDacl,
   IN PACL pSacl
	)
{
   HRESULT hr = S_OK;
   LPTSTR pszBuffer = NULL;
   UINT cchBuffer = 0, cchFolder;
   HANDLE hFind;
   WIN32_FIND_DATA fd;

   pszBuffer = (LPTSTR)LocalAlloc(LMEM_FIXED, 2 * MAX_PATH * sizeof(TCHAR));
   if (pszBuffer == NULL)
      return E_OUTOFMEMORY;
   cchBuffer = (UINT)LocalSize(pszBuffer) / sizeof(TCHAR);
   lstrcpy(pszBuffer, FileName);
   cchFolder = lstrlen(pszBuffer);
   // Append a backslash if it's not there already
   if (pszBuffer[cchFolder-1] != TEXT('\\'))
   {
      pszBuffer[cchFolder] = TEXT('\\');
      cchFolder++;
   }

   // Append the '*' wildcard
   pszBuffer[cchFolder] = TEXT('*');
   pszBuffer[cchFolder+1] = TEXT('\0');

   if (INVALID_HANDLE_VALUE != (hFind = FindFirstFile(pszBuffer, &fd)))
   {
      do
      {
         if (PathIsDotOrDotDot(fd.cFileName))
            continue;
         //
         // Build full path name and recurse
         //
         lstrcpyn(pszBuffer + cchFolder, fd.cFileName, cchBuffer - cchFolder);
         if (fd.dwFileAttributes == FILE_ATTRIBUTE_DIRECTORY)
         {
            hr = SetSecurityDeep(&pszBuffer,
                     &cchBuffer,
                     fd.dwFileAttributes,
                     si,
                     pDacl,
                     pSacl);
         }
         else
         {
            hr = HRESULT_FROM_WIN32(SetNamedSecurityInfo(
                                 pszBuffer,
                                 SE_FILE_OBJECT,
                                 si,
                                 NULL,
                                 NULL,
                                 pDacl,
                                 pSacl));
         }
      }
      while (S_OK == hr && FindNextFile(hFind, &fd));
      FindClose(hFind);
   }
   if (pszBuffer != NULL)
      LocalFree(pszBuffer);
   return hr;
}

static HRESULT
SetSecurityDeep(
   LPTSTR *ppszBuffer,
   UINT * pcchBuffer,
   DWORD dwAttributes,
   SECURITY_INFORMATION si,
   PACL pDacl,
   PACL pSacl
   )
{
   HRESULT hr = S_OK;
   DWORD dwErr = NOERROR;
   LPTSTR pszBuffer;
   BOOL bWriteDone = FALSE;

   pszBuffer = *ppszBuffer;
   //
   // Recursively apply the new SD to subfolders
   //
   if (dwAttributes & FILE_ATTRIBUTE_DIRECTORY)
   {
      HANDLE hFind;
      WIN32_FIND_DATA fd;
      UINT cchFolder;
      UINT cchSizeRequired;

      cchFolder = lstrlen(pszBuffer);

      //
      // If the buffer is getting tight, realloc
      //
      cchSizeRequired = cchFolder + 1 + sizeof(fd.cFileName) / sizeof(TCHAR); // 1 for backslash
      if (cchSizeRequired > *pcchBuffer)
      {
         cchSizeRequired += MAX_PATH;  // so we don't realloc as often
         pszBuffer = (LPTSTR)LocalReAlloc(*ppszBuffer, cchSizeRequired * sizeof(TCHAR), LMEM_MOVEABLE);
         if (pszBuffer)
         {
            *ppszBuffer = pszBuffer;
            *pcchBuffer = cchSizeRequired;
         }
         else
         {
            // fd.cFileName typically has some empty space, so we
            // may be able to continue
            pszBuffer = *ppszBuffer;
            if (*pcchBuffer < cchFolder + 3) // backslash, '*', and NULL
               return E_OUTOFMEMORY;
         }
      }

      // Append a backslash if it's not there already
      if (pszBuffer[cchFolder-1] != TEXT('\\'))
      {
         pszBuffer[cchFolder] = TEXT('\\');
         cchFolder++;
      }

      // Append the '*' wildcard
      pszBuffer[cchFolder] = TEXT('*');
      pszBuffer[cchFolder+1] = TEXT('\0');

      //
      // Enumerate the folder contents
      //
      hFind = FindFirstFile(pszBuffer, &fd);

      if (INVALID_HANDLE_VALUE == hFind)
      {
         dwErr = GetLastError();

         if (ERROR_ACCESS_DENIED == dwErr)
         {
            // Remove the '*' wildcard
            pszBuffer[cchFolder-1] = TEXT('\0');

            if (si & DACL_SECURITY_INFORMATION)
            {
               //
               // The user may be granting themselves access, so call
               // WriteObjectSecurity and retry FindFirstFile.
               //
               // Don't blindly call WriteObjectSecurity before FindFirstFile
               // since it's possible the user has access now but is removing
               // their own access.
               //
               bWriteDone = TRUE;
               hr = HRESULT_FROM_WIN32(SetNamedSecurityInfo(
                                 pszBuffer,
                                 SE_FILE_OBJECT,
                                 si,
                                 NULL,
                                 NULL,
                                 pDacl,
                                 pSacl));
               if (SUCCEEDED(hr))
               {
                  // Retry FindFirstFile
                  pszBuffer[cchFolder-1] = TEXT('\\');
                  hFind = FindFirstFile(pszBuffer, &fd);
               }
            }
         }
      }

      if (hFind != INVALID_HANDLE_VALUE)
      {
         do
         {
            if (PathIsDotOrDotDot(fd.cFileName))
               continue;

            //
            // Build full path name and recurse
            //
            lstrcpyn(pszBuffer + cchFolder, fd.cFileName, *pcchBuffer - cchFolder);
            hr = SetSecurityDeep(ppszBuffer,
                     pcchBuffer,
                     fd.dwFileAttributes,
                     si,
                     pDacl,
                     pSacl);

            // In case the buffer was reallocated
            pszBuffer = *ppszBuffer;
         }
         while (S_OK == hr && FindNextFile(hFind, &fd));

         FindClose(hFind);
      }
      else if (NOERROR != dwErr)
      {
         hr = S_FALSE;   // abort
      }

      // Truncate the path back to the original length (sans backslash)
      pszBuffer[cchFolder-1] = TEXT('\0');
   }

   //
   // Finally, write out the new security descriptor
   //
   if (!bWriteDone)
   {
      hr = HRESULT_FROM_WIN32(SetNamedSecurityInfo(
                                 pszBuffer,
                                 SE_FILE_OBJECT,
                                 si,
                                 NULL,
                                 NULL,
                                 pDacl,
                                 pSacl));
   }
   if (SUCCEEDED(hr))
   {
      //
      // Notify the shell if we change permissions on a folder (48220)
      //
      if (  (dwAttributes & FILE_ATTRIBUTE_DIRECTORY) 
         && (si & DACL_SECURITY_INFORMATION)
         )
      {
         SHChangeNotify(
            SHCNE_UPDATEDIR,
            SHCNF_PATH | SHCNF_FLUSH | SHCNF_FLUSHNOWAIT,
            pszBuffer,
            NULL);
      }
   }
   else
   {
      hr = S_FALSE;   // abort
   }
   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\comprop\stdafx.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        stdafx.cpp

   Abstract:

        Precompiled header file

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\comprop\sources.inc ===
!include ..\..\..\..\place.inc

MAJORCOMP=internet
MINORCOMP=comprop

TARGETNAME=iisui
TARGETPATH=obj

TARGETTYPE=DYNLINK

UMTYPE=windows
UMENTRY=winmain
USE_MFCUNICODE=1
USE_MSVCRT=1

DLLENTRY=_DllMainCRTStartup
DLLDEF=..\iisui.def

PRECOMPILED_INCLUDE=stdafx.h
PRECOMPILED_CXX=1
SUBSYSTEM_VERSION=4.00

C_DEFINES=$(C_DEFINES) -D_COMEXPORT -D_AFXEXT

PASS0_HEADERDIR=$(O)
PASS0_SOURCEDIR=$(O)

INCLUDES=..\..\..\..\svcs\infocomm\common;\
         ..\..\inc;\
         $(IISBASEDIR)\inc;\
         $(IISBASEDIR)\inc\$(O);\
         $(DS_INC_PATH);\
         ..;

MSC_WARNING_LEVEL=/W3 /WX

SOURCES=\
    ..\wsockmsg.mc  \
    ..\mtxmsg.mc    \
    ..\debugafx.cpp \
    ..\dirbrows.cpp \
    ..\ipa.cpp      \
    ..\dnsnamed.cpp \
    ..\inetprop.cpp \
    ..\msg.cpp      \
    ..\odlbox.cpp   \
    ..\objplus.cpp  \
    ..\ddxv.cpp     \
    ..\strfn.cpp    \
    ..\registry.cpp \
    ..\accessdl.cpp \
    ..\usrbrows.cpp \
    ..\machine.cpp  \
    ..\sitesecu.cpp \
    ..\mime.cpp     \
    ..\idlg.cpp     \
    ..\guid.cpp     \
    ..\mdkeys.cpp   \
    ..\wizard.cpp   \
    ..\pwiz.cpp     \
    ..\setperm.cpp  \
    ..\dtp.cpp      \
    ..\ipctl.cpp    \
    ..\objpick.cpp  \
    ..\ipaddres.cpp \
    ..\comprop.rc

NTTARGETFILE0= $(O)\iisui.h

TARGETLIBS=\
   $(IISBASEDIR)\svcs\iisrtl\$(O)\iisrtl.lib         \
   $(SDK_LIB_PATH)\netapi32.lib       \
   $(SDK_LIB_PATH)\ws2_32.lib         \
   $(SDK_LIB_PATH)\kernel32.lib       \
   $(SDK_LIB_PATH)\advapi32.lib       \
   $(SDK_LIB_PATH)\comdlg32.lib       \
   $(SDK_LIB_PATH)\comctl32.lib       \
   $(SDK_LIB_PATH)\winspool.lib       \
   $(SDK_LIB_PATH)\shell32.lib        \
   $(SDK_LIB_PATH)\user32.lib         \
   $(SDK_LIB_PATH)\netui2.lib         \
   $(SDK_LIB_PATH)\mpr.lib            \
   $(SDK_LIB_PATH)\ole32.lib          \
   $(SDK_LIB_PATH)\oleaut32.lib       \
   $(SDK_LIB_PATH)\gdi32.lib          \
   $(SDK_LIB_PATH)\mmc.lib            \
   $(SDK_LIB_PATH)\adsiid.lib		  \
   $(SDK_LIB_PATH)\shlwapi.lib        \
   ..\..\..\..\svcs\infocomm\rdns\$(O)\isrdns.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\comprop\sitesecu.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        sitesecu.cpp

   Abstract:

        Site Security property page

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include "comprop.h"
#include "accessdl.h"

#undef dllexp
#include "tcpdllp.hxx"
#define  _RDNS_STANDALONE
#include <rdns.hxx>

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif


//#ifdef _DEBUG
//
// Careful here... This may cause build failure
//
extern "C" DEBUG_PRINTS * g_pDebug = NULL;
//#endif // _DEBUG


//
// Registry key name for this dialog
//
const TCHAR g_szRegKey[] = _T("Advanced");



//
// Site Security Listbox Column Definitions
//
// Note: IDS_IP_ADDRESS_SUBNET_MASK is overridden
//       in w3scfg
//
static const ODL_COLUMN_DEF g_aColumns[] =
{
// ===============================================
// Weight   Label                 
// ===============================================
    {  4,   IDS_ACCESS,                 },
    { 15,   IDS_IP_ADDRESS_SUBNET_MASK, },
};



#define NUM_COLUMNS (sizeof(g_aColumns) / sizeof(g_aColumns[0]))




CIPAccessDescriptor::CIPAccessDescriptor(
    IN BOOL fGranted 
    )
/*++

Routine Description:

    Dummy Constructor for access description object.  Assumes a single IP
    address of 0.0.0.0

Arguments:
    
    BOOL fGranted : TRUE for 'grant' access, FALSE for 'deny' access      

Return Value:

    N/A

--*/
    : m_fGranted(fGranted),
      m_adtType(CIPAccessDescriptor::ADT_SINGLE),
      m_iaIPAddress(NULL_IP_ADDRESS),
      m_iaSubnetMask(NULL_IP_MASK),
      m_strDomain()
{
}




CIPAccessDescriptor::CIPAccessDescriptor(
    IN const CIPAccessDescriptor & ac
    )
/*++

Routine Description:

    Copy constructor for access description object

Arguments:

    const CIPAccessDescriptor & ac : Source access description object    

Return Value:

    N/A

--*/
    : m_fGranted(ac.m_fGranted),
      m_adtType(ac.m_adtType),
      m_iaIPAddress(ac.m_iaIPAddress),
      m_iaSubnetMask(ac.m_iaSubnetMask),
      m_strDomain(ac.m_strDomain)
{
}




CIPAccessDescriptor::CIPAccessDescriptor(
    IN BOOL fGranted,
    IN DWORD dwIPAddress,
    IN DWORD dwSubnetMask,    OPTIONAL
    IN BOOL fNetworkByteOrder OPTIONAL
    )
/*++

Routine Description:

    Constructor for ip range (ip address/subnet mask pair) 
    access description object.

Arguments:

    BOOL fGranted          : TRUE for 'grant' access, FALSE for 'deny' access      
    DWORD dwIPAddress      : IP Address
    DWORD dwSubnetMask     : The subnet mask or 0xffffffff
    BOOL fNetworkByteOrder : If TRUE, the ip address and subnet mask are in 
                             network byte order

Return Value:

    N/A

--*/
{
    SetValues(fGranted, dwIPAddress, dwSubnetMask, fNetworkByteOrder);
}




CIPAccessDescriptor::CIPAccessDescriptor(
    IN BOOL fGranted,
    IN LPCTSTR lpstrDomain
    )
/*++

Routine Description:

    Constructor for domain name access description object.

Arguments:

    BOOL fGranted       : TRUE for 'grant' access, FALSE for 'deny' access      
    LPCTSTR lpstrDomain : The domain name

Return Value:

    N/A

--*/
{
    SetValues(fGranted, lpstrDomain);
}




void
CIPAccessDescriptor::SetValues(
    IN BOOL fGranted,
    IN DWORD dwIPAddress,
    IN DWORD dwSubnetMask,
    IN BOOL fNetworkByteOrder OPTIONAL
    )
/*++

Routine Description:

    Set values for 'ip range (ip address and subnet mask)' access descriptor,
    or a single ip address if  the mask is 0xffffffff

Arguments:

    BOOL fGranted          : TRUE for 'grant' access, FALSE for 'deny' access
    DWORD dwIPAddress      : IP Address
    DWORD dwSubnetMask     : The subnet mask or ffffffff
    BOOL fNetworkByteOrder : If TRUE, the ip address and subnet mask are in 
                             network byte order

Return Value:

    None

Notes:

    If the subnetmask is 0xffffffff this describes a single ip address.

--*/
{
    m_fGranted = fGranted;
    m_adtType = (dwSubnetMask == NULL_IP_MASK) ? ADT_SINGLE : ADT_MULTIPLE;
    m_iaIPAddress = CIPAddress(dwIPAddress, fNetworkByteOrder);
    m_iaSubnetMask = CIPAddress(dwSubnetMask, fNetworkByteOrder);

    //
    // Not used:
    //
    m_strDomain.Empty();
}




void
CIPAccessDescriptor::SetValues(
    IN BOOL fGranted,
    IN LPCTSTR lpstrDomain
    )
/*++

Routine Description:

    Set values for 'domain name' access descriptor

Arguments:

    BOOL fGranted       : TRUE for 'grant' access, FALSE for 'deny' access
    LPCTSTR lpstrDomain : The domain name

Return Value:

    None

--*/
{
    m_fGranted = fGranted;
    m_adtType = ADT_DOMAIN;

    try
    {
        m_strDomain = lpstrDomain;
    }
    catch(CMemoryException * e)
    {
        TRACEEOLID("!!!exception assigning domain name");
        e->ReportError();
        e->Delete();
    }

    //
    // Not used:
    //
    m_iaIPAddress.SetZeroValue();
    m_iaSubnetMask.SetZeroValue();
}




BOOL 
CIPAccessDescriptor::DuplicateInList(
    IN CObListPlus & oblList
    )
/*++

Routine Description:

    Check to see if a duplicate exists in the provided oblist

Arguments:

    CObListPlus & oblList

Return Value:

    TRUE if a duplicate exists, FALSE otherwise.

Notes:

    As there's no information how this list might be sorted at this point,
    and the list is likely to be small, the search is sequential.

--*/
{
    CObListIter obli(oblList);
    CIPAccessDescriptor * pAccess;

    TRACEEOLID("Looking for duplicate access descriptors");
    while (pAccess = (CIPAccessDescriptor *)obli.Next())
    {
        ASSERT(pAccess != NULL);

        //
        // Eliminate the item itself from the list, and look
        // only for duplicates.
        //
        if (pAccess != this && *this == *pAccess)
        {
            TRACEEOLID("Duplicate access descriptor found");
            return TRUE;
        }
    }

    TRACEEOLID("No duplicate access descriptor found");

    return FALSE;
}




BOOL
CIPAccessDescriptor::operator ==(
    IN const CIPAccessDescriptor & ac
    ) const
/*++

Routine Description:

    Compare against another access descriptor.

Arguments:

    const CIPAccessDescriptor & ac : Object to be compared against

Return Value:

    TRUE if the two are identical

--*/
{
    if ( m_fGranted != ac.m_fGranted
      || m_adtType != ac.m_adtType)
    {
        return FALSE;
    }

    if (IsDomainName())
    {
        return m_strDomain.CompareNoCase(ac.m_strDomain) == 0;
    }

    return m_iaIPAddress == ac.m_iaIPAddress
        && m_iaSubnetMask == ac.m_iaSubnetMask;
}




int
CIPAccessDescriptor::OrderByAddress(
    IN const CObjectPlus * pobAccess
    ) const
/*++

Routine Description:

    Compare two access descriptors against each other. 
    Sorting criteria are in the following order:

    1) 'Granted' sorts before 'Denied'
    2) Domain names are sorted before ip addresses, and are
       sorted alphabetically.
    3) IP Address and IP Address/subnet mask pairs are sorted
       by ip address.

Arguments:

    const CObjectPlus * pobAccess : This really refers to another 
                                    CIPAccessDescriptor to be compared to.

Return Value:

    Sort (+1, 0, -1) return value

--*/
{
    const CIPAccessDescriptor * pob = (CIPAccessDescriptor *)pobAccess;

    //
    // First sort by access/denied
    //
    int n1 = HasAccess() ? 1 : 0;
    int n2 = pob->HasAccess() ? 1 : 0;

    if (n2 != n1)
    {
        //
        // Grant sorts before denied
        //
        return n2 - n1;
    }

    //
    // Secondly, try to sort by domain name (domain name sorts before
    // ip address and ip address/subnet mask objects)
    //
    n1 = IsDomainName() ? 1 : 0;
    n2 = pob->IsDomainName() ? 1 : 0;

    if (n1 != n2)
    {
        //
        // Domain names sort before ip addresses
        //
        return n2 - n1;
    }

    if (n1 && n2)
    {
        //
        // Both are domain names.  Sort alphabetically
        //
        return ::lstrcmpi(QueryDomainName(), pob->QueryDomainName());
    }

    //
    // IP address is the third key.
    //
    return QueryIPAddress().CompareItem(pob->QueryIPAddress());
}




DWORD
AddAccessEntries(
    IN  ADDRESS_CHECK & ac,
    IN  BOOL fName,
    IN  BOOL fGrant,
    OUT CObListPlus & oblAccessList,
    OUT DWORD & cEntries
    )
/*++

Routine Description:

    Add specific kind of addresses from the list to the oblist of
    access entries

Arguments:

    ADDRESS_CHECK & ac              : Address list input object
    BOOL fName                      : TRUE for names, FALSE for ip
    BOOL fGrant                     : TRUE for granted, FALSE for denied        
    CObListPlus & oblAccessList     : ObList to add access entries to
    int & cEntries                  : Returns the number of entries
    
Return Value:

    Error code

Notes:

    Sentinel entries (ip 0.0.0.0) are not added to the oblist, but
    are reflected in the cEntries return value

--*/
{
    DWORD i;
    DWORD dwFlags;

    if (fName)
    {
        //
        // Domain names
        //
        LPSTR lpName;

        cEntries = ac.GetNbName(fGrant);

        for (i = 0L; i < cEntries; ++i)
        {
            if (ac.GetName(fGrant, i,  &lpName, &dwFlags))
            {
                CString strDomain(lpName);
                if (!(dwFlags & DNSLIST_FLAG_NOSUBDOMAIN))
                {
                    strDomain = _T("*.") + strDomain;
                }

                oblAccessList.AddTail(new CIPAccessDescriptor(fGrant, strDomain));
            }
        }
    }
    else
    {
        //
        // IP Addresses
        //
        LPBYTE lpMask;
        LPBYTE lpAddr;
        cEntries = ac.GetNbAddr(fGrant);
        for (i = 0L; i < cEntries; ++i)
        {
            if (ac.GetAddr(fGrant, i,  &dwFlags, &lpMask, &lpAddr))
            {
                DWORD dwIP = MAKEIPADDRESS(lpAddr[0], lpAddr[1], lpAddr[2], lpAddr[3]);
                DWORD dwMask = MAKEIPADDRESS(lpMask[0], lpMask[1], lpMask[2], lpMask[3]);

                if (dwIP == NULL_IP_ADDRESS && dwMask == NULL_IP_MASK)
                {
                    //
                    // Sentinel in the grant list is not added, but
                    // also not subtracted from the count of entries,
                    // which is correct behaviour, since this is
                    // how default grant/deny by default is determined.
                    //
                    TRACEEOLID("Ignoring sentinel");
                }
                else
                {
                    oblAccessList.AddTail(
                        new CIPAccessDescriptor(
                           fGrant,
                           dwIP,
                           dwMask,
                           FALSE
                           )
                        );
                }
            }
        }
    }

    return ERROR_SUCCESS;
}





DWORD
BuildIplOblistFromBlob(
    IN  CBlob & blob,
    OUT CObListPlus & oblAccessList,
    OUT BOOL & fGrantByDefault
    )
/*++

Routine Description:

    Convert a blob to an oblist of access descriptors.

Arguments:

    CBlob & blob                : Input binary large object(blob)
    CObListPlus & oblAccessList : Output oblist of access descriptors
    BOOL & fGrantByDefault      : Returns TRUE if access is granted
                                  by default, FALSE otherwise

Return Value:

    Error Return Code

--*/
{
    oblAccessList.RemoveAll();

    if (blob.IsEmpty())
    {
        return ERROR_SUCCESS;
    }

    ADDRESS_CHECK ac;
    ac.BindCheckList(blob.GetData(), blob.GetSize());

    DWORD cGrantAddr, cGrantName, cDenyAddr, cDenyName;

    //                   Name/IP Granted/Deny
    // ============================================================
    AddAccessEntries(ac, TRUE,   TRUE,  oblAccessList, cGrantName);
    AddAccessEntries(ac, FALSE,  TRUE,  oblAccessList, cGrantAddr);
    AddAccessEntries(ac, TRUE,   FALSE, oblAccessList, cDenyName);
    AddAccessEntries(ac, FALSE,  FALSE, oblAccessList, cDenyAddr);

    ac.UnbindCheckList();

    fGrantByDefault = (cDenyAddr + cDenyName != 0L)
        || (cGrantAddr + cGrantName == 0L);

    return ERROR_SUCCESS;
}  




LPSTR 
PrepareDomainName(
    IN  LPSTR lpName,
    OUT DWORD * pdwFlags
    )
/*++

Routine Description:

    Check to see if the domain name contains a wild card,
    if so remove it.  Set the flags based on the domain name

Arguments:

    LPSTR  lpName       : Input domain name
    DWORD * pdwFlags    : Return the flags for AddName

Return:

    Pointer to the cleaned up domain name

--*/
{
    *pdwFlags = 0L;

    if (!strncmp(lpName, "*.", 2))
    {
        return lpName + 2;
    }

    *pdwFlags |= DNSLIST_FLAG_NOSUBDOMAIN;

    return lpName;
}




void
BuildIplBlob(
    IN  CObListPlus & oblAccessList,
    IN  BOOL fGrantByDefault,
    OUT CBlob & blob
    )
/*++

Routine Description:

    Build a blob from an oblist of access descriptors

Arguments:

    CObListPlus & oblAccessList  : Input oblist of access descriptors
    BOOL fGrantByDefault         : TRUE if access is granted by default
    CBlob & blob                 : Output blob

Return Value:

    None

Notes:

    If fGrantByDefault is FALSE, e.g. access is to be denied by
    default, but nobody is specifically granted access, then add
    a dummy entry 0.0.0.0 to the grant list.

    If grant by default is on, then granted entries will not be
    added to the blob.  Similart for denied entries if deny by
    default is on.

--*/
{
    ADDRESS_CHECK ac;

    ac.BindCheckList();

    int cItems = 0;

    CObListIter obli(oblAccessList);
    const CIPAccessDescriptor * pAccess;

    //
    // Should be empty to start with.
    //
    ASSERT(blob.IsEmpty());
    blob.CleanUp();

    BYTE bMask[4];
    BYTE bIp[4];

    while (pAccess = (CIPAccessDescriptor *)obli.Next())
    {
        ASSERT(pAccess != NULL);

        if (pAccess->HasAccess() == fGrantByDefault)
        {
            //
            // Skip this entry -- it's irrelevant
            //
            continue;
        }

        if (pAccess->IsDomainName())
        {
            LPSTR lpName = AllocAnsiString(pAccess->QueryDomainName());
            if (lpName)
            {
                DWORD dwFlags;
                LPSTR lpDomain = PrepareDomainName(lpName, &dwFlags);
                ac.AddName(
                    pAccess->HasAccess(),
                    lpDomain,
                    dwFlags
                    );
                FreeMem(lpName);
            }
        }
        else
        {
            //
            // Build with network byte order
            //
            ac.AddAddr(
                pAccess->HasAccess(),
                AF_INET, 
                CIPAddress::DWORDtoLPBYTE(pAccess->QuerySubnetMask(FALSE), bMask),
                CIPAddress::DWORDtoLPBYTE(pAccess->QueryIPAddress(FALSE), bIp)  
                );
        }

        ++cItems;
    }

    if (cItems == 0 && !fGrantByDefault)
    {
        //
        // List is empty.  If deny by default is on, create
        // a dummy sentinel entry to grant access to single
        // address 0.0.0.0, otherwise we're ok.
        //
        ac.AddAddr(
            TRUE,
            AF_INET, 
            CIPAddress::DWORDtoLPBYTE(NULL_IP_MASK, bMask),
            CIPAddress::DWORDtoLPBYTE(NULL_IP_ADDRESS, bIp)  
            );
        ++cItems;
    }

    if (cItems > 0)
    {
        blob.SetValue(ac.QueryCheckListSize(), ac.QueryCheckListPtr(), TRUE);
    }

    ac.UnbindCheckList();
}




IMPLEMENT_DYNAMIC(CIPAccessDescriptorListBox, CHeaderListBox);




//
// Bitmap indices
//
enum
{
    BMPID_GRANTED = 0,
    BMPID_DENIED,
    BMPID_SINGLE,
    BMPID_MULTIPLE,

    //
    // Don't move this one
    //
    BMPID_TOTAL
};




const int CIPAccessDescriptorListBox::nBitmaps = BMPID_TOTAL;




CIPAccessDescriptorListBox::CIPAccessDescriptorListBox(
    IN BOOL fDomainsAllowed
    )
/*++

Routine Description:

    Constructor

Arguments:

    fDomainsAllowed : TRUE if domain names are legal.

Return Value:

    N/A

--*/
    : m_fDomainsAllowed(fDomainsAllowed),
      CHeaderListBox(HLS_STRETCH, g_szRegKey)
{
    m_strGranted.LoadString(IDS_GRANTED);
    m_strDenied.LoadString(IDS_DENIED);
    m_strFormat.LoadString(IDS_FMT_SECURITY);
}




void
CIPAccessDescriptorListBox::DrawItemEx(
    IN CRMCListBoxDrawStruct & ds
    )
/*++

Routine Description:

    Draw item in the listbox

Arguments:

    CRMCListBoxDrawStruct & ds : Draw item structure

Return Value:

    None

--*/
{
    CIPAccessDescriptor * p = (CIPAccessDescriptor *)ds.m_ItemData;
    ASSERT(p != NULL);

    //
    // Display Granted/Denied with appropriate bitmap
    //
    DrawBitmap(ds, 0, p->HasAccess() ? BMPID_GRANTED : BMPID_DENIED);
    ColumnText(ds, 0, TRUE, p->HasAccess() ? m_strGranted : m_strDenied);

    //
    // Display IP Address with multiple/single bitmap
    //
    DrawBitmap(ds, 1, p->IsSingle() ? BMPID_SINGLE : BMPID_MULTIPLE);

    if (p->IsDomainName())
    {
        ColumnText(ds, 1, TRUE, p->QueryDomainName());
    }
    else if (p->IsSingle())
    {
        //
        // Display only ip address
        //
        ColumnText(ds, 1, TRUE, p->QueryIPAddress());
    }
    else
    {
        //
        // Display ip address/subnet mask
        //
        CString str, strIP, strMask;

        str.Format(
            m_strFormat, 
            (LPCTSTR)p->QueryIPAddress().QueryIPAddress(strIP), 
            (LPCTSTR)p->QuerySubnetMask().QueryIPAddress(strMask)
            );
        ColumnText(ds, 1, TRUE, str);
    }
}




/* virtual */
BOOL 
CIPAccessDescriptorListBox::Initialize()
/*++

Routine Description:

    Initialize the listbox.  Insert the columns as requested, and lay 
    them out appropriately

Arguments:

    None

Return Value:

    TRUE for succesful initialisation, FALSE otherwise

--*/
{
    if (!CHeaderListBox::Initialize())
    {
        return FALSE;
    }

    //
    // Build all columns
    //
    for (int nCol = 0; nCol < NUM_COLUMNS; ++nCol)
    {
        InsertColumn(nCol, g_aColumns[nCol].nWeight, g_aColumns[nCol].nLabelID);
    }

    //
    // Try to set the widths from the stored registry value,
    // otherwise distribute according to column weights specified
    //
    if (!SetWidthsFromReg())
    {
        DistributeColumns();
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\comprop\sitesecu.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        sitesecu.h

   Abstract:

        Site Security property page definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

#ifndef _SITESECU_H_
#define _SITESECU_H_

#define DEFAULT_GRANTED     0
#define DEFAULT_DENIED      1




class COMDLL CIPAccessDescriptor : public CObjectPlus
/*++

Class Description:

    Access description object

Public Interface:

    CIPAccessDescriptor : Various overload constructors for the different types

    SetValues         : Set values, overloaded on a per type basis
    DuplicateInList   : Check to see if a duplicate entry exists in the list
    GrantAccess       : Grant or deny access
    HasAccess         : Query whether the object describes a 'grant' or 'deny'
                        item
    IsSingle          : Query whether the object describes a single IP address
    IsMultiple        : Query whether the object describes a range of ip 
                        addresses
    IsDomainName      : Query whether the object describes a domain name
    QueryIPAddress    : Get the object's IP address
    QuerySubnetMask   : Get the object's subnet mask value
    QueryDomainName   : Get the object's domain name
    operator ==       : Comparison operator
    OrderByAddress    : Sorting helper

--*/
{
protected:
    //
    // Access descriptor types
    //
    enum AD_TYPE
    {
        ADT_SINGLE,
        ADT_MULTIPLE,
        ADT_DOMAIN,
    };

//
// Constructors
//
public:
    //
    // Construct NULL descriptor
    //
    CIPAccessDescriptor(
        IN BOOL fGranted = TRUE
        );

    //
    // Copy Constructor
    //
    CIPAccessDescriptor(
        IN const CIPAccessDescriptor & ac
        );

    //
    // Construct with ip address(ip address/subnet mask) descriptor
    // if subnet massk is ffffffff this describes a single ip address
    //
    CIPAccessDescriptor(
        IN BOOL fGranted,
        IN DWORD dwIpAddress,
        IN DWORD dwSubnetMask = NULL_IP_MASK,
        IN BOOL fNetworkByteOrder = FALSE
        );

    //
    // Construct domain name descriptor
    //
    CIPAccessDescriptor(
        IN BOOL fGranted,
        IN LPCTSTR lpstrDomain
        );

//
// Interface
//
public:
    //
    // Set ip address/ip range value
    //
    void SetValues(
        IN BOOL fGranted,
        IN DWORD dwIpAddress,
        IN DWORD dwSubnetMask = NULL_IP_MASK,
        BOOL fNetworkByteOrder = FALSE
        );

    //
    // Set domain name
    //
    void SetValues(
        IN BOOL fGranted,
        IN LPCTSTR lpstrDomain
        );

    //
    // Check to see if a duplicate exists in the 
    // list.  
    //
    BOOL DuplicateInList(
        IN CObListPlus & oblList
        );
        
//
// Access
//
public:
    //
    // Access Functions
    //
    BOOL HasAccess() const;

    //
    // Grant/deny access
    //
    void GrantAccess(
        IN BOOL fGranted = TRUE
        );

    //
    // TRUE if this item is single ip address
    //
    BOOL IsSingle() const;

    //
    // True if this item describes an ip range
    //
    BOOL IsMultiple() const;

    //
    // True if this item describes a domain name
    //
    BOOL IsDomainName() const;

    //
    // Get the ip address as a DWORD
    //
    DWORD QueryIPAddress(
        IN BOOL fNetworkByteOrder
        ) const;

    //
    // Get the ip address as ip address object
    //
    CIPAddress QueryIPAddress() const;

    //
    // Get the subnet mask as a DWORD
    //
    DWORD QuerySubnetMask(
        IN BOOL fNetworkByteOrder
        ) const;

    //
    // Get the subnet mask as an ip address object
    //
    CIPAddress QuerySubnetMask() const;

    //
    // Get the domain name
    //
    LPCTSTR QueryDomainName() const;

public:
    //
    // Comparison Operator
    //
    BOOL operator ==(
        IN const CIPAccessDescriptor & ac
        ) const;

    //
    // Sorting Helper
    //
    int OrderByAddress(
        IN const CObjectPlus * pobAccess
        ) const;

private:
    BOOL m_fGranted;
    AD_TYPE m_adtType;
    CString m_strDomain;
    CIPAddress m_iaIPAddress;
    CIPAddress m_iaSubnetMask;
};



//
// Helper Functions
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


//
// Convert an oblist of access descriptors to a blob
//
void COMDLL
BuildIplBlob(
    IN  CObListPlus & oblAccessList,
    IN  BOOL fGrantByDefault,
    OUT CBlob & blob
    );


//
// Reverse the above, build an oblist of access descriptors
// from a blob
//
DWORD COMDLL
BuildIplOblistFromBlob(
    IN  CBlob & blob,
    OUT CObListPlus & oblAccessList,
    OUT BOOL & fGrantByDefault
    );



class COMDLL CIPAccessDescriptorListBox : public CHeaderListBox
/*++

Class Description:

    Listbox of CIPAccessDescriptor objects

Public Interface:

    CIPAccessDescriptorListBox : Constructor

    GetItem                  : Get CIPAccessDescriptor item at specified position
                               in the listbox
    AddItem                  : Add new CIPAccessDescriptor item to the listbox
    Initialize               : Initialize the listbox

--*/
{
    DECLARE_DYNAMIC(CIPAccessDescriptorListBox);

public:
    //
    // Number of bitmaps
    //
    static const nBitmaps;

//
// Constructor/Destructor
//
public:
    CIPAccessDescriptorListBox(
        IN BOOL fDomainsAllowed = FALSE
        );

//
// Interface
//
public:
    CIPAccessDescriptor * GetItem(
        IN UINT nIndex
        );

    int AddItem(
        IN const CIPAccessDescriptor * pItem
        );

    //
    // Return the singly selected item, or NULL
    // if 0, or more than one item is selected
    //
    CIPAccessDescriptor * GetSelectedItem(
        OUT int * pnSel = NULL
        );

    //
    // Return next selected listbox item (doesn't matter
    // if the listbox is single select or multi-select)
    //
    CIPAccessDescriptor * GetNextSelectedItem(
        IN OUT int * pnStartingIndex
        );

    virtual BOOL Initialize();

protected:
    virtual void DrawItemEx(
        IN CRMCListBoxDrawStruct & ds
        );

protected:
    BOOL m_fDomainsAllowed;
    CString m_strGranted;
    CString m_strDenied;
    CString m_strFormat;
};




//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline BOOL CIPAccessDescriptor::HasAccess() const
{
    return m_fGranted;
}

inline void CIPAccessDescriptor::GrantAccess(
    IN BOOL fGranted
    )
{
    m_fGranted = fGranted;
}

inline BOOL CIPAccessDescriptor::IsSingle() const
{
    return m_adtType == ADT_SINGLE;
}

inline BOOL CIPAccessDescriptor::IsMultiple() const
{
    return m_adtType == ADT_MULTIPLE;
}

inline BOOL CIPAccessDescriptor::IsDomainName() const
{
    return m_adtType == ADT_DOMAIN;
}

inline DWORD CIPAccessDescriptor::QueryIPAddress(
    IN BOOL fNetworkByteOrder
    ) const
{
    ASSERT(!IsDomainName());
    return m_iaIPAddress.QueryIPAddress(fNetworkByteOrder);
}

inline CIPAddress CIPAccessDescriptor::QueryIPAddress() const
{
    ASSERT(!IsDomainName());
    return m_iaIPAddress;
}

inline DWORD CIPAccessDescriptor::QuerySubnetMask(
    IN BOOL fNetworkByteOrder
    ) const
{
    ASSERT(!IsDomainName());
    return m_iaSubnetMask.QueryIPAddress(fNetworkByteOrder);
}

inline CIPAddress CIPAccessDescriptor::QuerySubnetMask() const
{
    ASSERT(!IsDomainName());
    return m_iaSubnetMask;
}

inline LPCTSTR CIPAccessDescriptor::QueryDomainName() const
{
    ASSERT(IsDomainName());
    return (LPCTSTR)m_strDomain;
}

inline CIPAccessDescriptor * CIPAccessDescriptorListBox::GetItem(
    IN UINT nIndex
    )
{
    return (CIPAccessDescriptor *)GetItemDataPtr(nIndex);
}

inline int CIPAccessDescriptorListBox::AddItem(
    IN const CIPAccessDescriptor * pItem
    )
{
    return AddString((LPCTSTR)pItem);
}

inline CIPAccessDescriptor * CIPAccessDescriptorListBox::GetSelectedItem(
    OUT int * pnSel
    )
{
    return (CIPAccessDescriptor *)CRMCListBox::GetSelectedListItem(pnSel);
}

inline CIPAccessDescriptor * CIPAccessDescriptorListBox::GetNextSelectedItem(
    IN OUT int * pnStartingIndex
    )
{
    return (CIPAccessDescriptor *)CRMCListBox::GetNextSelectedItem(pnStartingIndex);
}



#endif  // _SITESECU_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\comprop\strfn.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        strfrn.cpp

   Abstract:

        String Functions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include "comprop.h"
#include <pudebug.h>


#ifdef _MT

    //
    // Thread protected stuff
    //
    #define RaiseThreadProtection() EnterCriticalSection(&_csSect)
    #define LowerThreadProtection() LeaveCriticalSection(&_csSect)

    static CRITICAL_SECTION _csSect;

#else

    #pragma message("Module is not thread-safe")

    #define RaiseThreadProtection()
    #define LowerThreadProtection()

#endif // _MT

#define MAKE_NULL(obj) { if (obj) delete obj, obj = NULL; }


//
// Text copy functions
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

BOOL
PCToUnixText(
    OUT LPWSTR & lpstrDestination,
    IN  const CString strSource
    )
/*++

Routine Description:

    Convert CR/LF string to LF string (T String to W String).  Destination
    string will be allocated.

Arguments:

    LPWSTR & lpstrDestination : Destination string
    const CString & strSource : Source string

Return Value:

    TRUE for success, FALSE for failure.

--*/
{
    int cch = strSource.GetLength() + 1;
    lpstrDestination = (LPWSTR)AllocMem(cch * sizeof(WCHAR));
    if (lpstrDestination != NULL)
    {
        LPCTSTR lpS = strSource;
        LPWSTR lpD = lpstrDestination;

        do
        {
            if (*lpS != _T('\r'))
            {

#ifdef UNICODE
                *lpD++ = *lpS;
#else
                ::MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, lpS, 1, lpD++, 1);
#endif // UNICODE

            }
        }
        while (*lpS++);

        return TRUE;
    }

    return FALSE;
}



BOOL
UnixToPCText(
    OUT CString & strDestination,
    IN  LPCWSTR lpstrSource
    )
/*++

Routine Description:

    Expand LF to CR/LF (no allocation necessary) W String to T String.

Arguments:

    CString & strDestination : Destination string
    LPCWSTR lpstrSource      : Source string

Return Value:

    TRUE for success, FALSE for failure.

--*/
{
    BOOL fSuccess = FALSE;

    try
    {
        LPCWSTR lpS = lpstrSource;
        //
        // Since we're doubling every linefeed length, assume
        // the worst possible expansion to start with.
        //
        int cch = (::lstrlenW(lpstrSource) + 1) * 2;
        LPTSTR lpD = strDestination.GetBuffer(cch);

        do
        {
            if (*lpS == L'\n')
            {
                *lpD++ = _T('\r');
            }

#ifdef UNICODE
                *lpD++ = *lpS;
#else
                ::WideCharToMultiByte(CP_ACP, 0, lpS, 1, lpD++, 1, NULL, NULL);
#endif // UNICODE

        }
        while (*lpS++);

        strDestination.ReleaseBuffer();

        ++fSuccess;
    }
    catch(CMemoryException * e)
    {
        TRACEEOLID("Exception in UnixToPCText");
        e->ReportError();
        e->Delete();
    }

    return fSuccess;
}



BOOL
TextToText(
    OUT LPWSTR & lpstrDestination,
    IN  const CString & strSource
    )
/*++

Routine Description:

    Straight copy with allocation. T String to W String.

Arguments:

    LPWSTR & lpstrDestination : Destination string
    const CString & strSource : Source string

Return Value:

    TRUE for success, FALSE for failure.

--*/
{
    int cch = strSource.GetLength() + 1;
    lpstrDestination = (LPWSTR)AllocMem(cch * sizeof(WCHAR));
    if (lpstrDestination != NULL)
    {
        TWSTRCPY(lpstrDestination, strSource, cch);
        return TRUE;
    }

    return FALSE;
}



#ifndef UNICODE



#define WBUFF_SIZE  255



LPWSTR
ReferenceAsWideString(
    IN LPCTSTR str
    )
/*++

Routine Description:

    Reference a T string as a W string (non-unicode only).

Arguments:

    LPCTSTR str : Source string

Return Value:

    Wide char pointer to wide string.

Notes:

    This uses an internal wide char buffer, which will be overwritten
    by subsequent calls to this function.

--*/
{
    static WCHAR wchBuff[WBUFF_SIZE + 1];

    ::MultiByteToWideChar(
        CP_ACP,
        MB_PRECOMPOSED,
        str,
        -1,
        wchBuff,
        WBUFF_SIZE + 1
        );

    return wchBuff;
}



#endif !UNICODE



LPSTR
AllocAnsiString(
    IN LPCTSTR lpString
    )
/*++

Routine Description:

    Convert the wide string to an ansi (multi-byte) string, which is allocated
    by this function

Arguments:

    LPCTSTR lpString        : Input wide string

Return Value:

    Pointer to the allocated string

--*/
{
    //
    // Character counts are DBCS friendly
    //
    int cChars = lstrlen(lpString);
    int nLength = (cChars * 2) + 1;
    LPSTR lp = (LPSTR)AllocMem(nLength);
    if (lp)
    {
        ::WideCharToMultiByte(
            CP_ACP,
            0,
            lpString,
            cChars + 1,
            lp,
            nLength,
            NULL,
            NULL
            );
    }

    return lp;
}




LPTSTR
AllocString(
    IN LPCTSTR lpString
    )
/*++

Routine Description:

    Allocate and copy string

Arguments:

    LPCTSTR lpString        : Input string

Return Value:

    Pointer to the allocated string

--*/
{
    int nLength = lstrlen(lpString) + 1;
    LPTSTR lp = (LPTSTR)AllocMem(nLength * sizeof(TCHAR));

    if (lp)
    {
        lstrcpy(lp, lpString);
    }

    return lp;
}



BOOL
IsUNCName(
    IN const CString & strDirPath
    )
/*++

Routine Description:

    Determine if the given string path is a UNC path.

Arguments:

    const CString & strDirPath : Directory path string

Return Value:

    TRUE if the path is a UNC path, FALSE otherwise.

Notes:

    Any string of the form \\foo\bar\whatever is considered a UNC path,
    with the exception of \\.\device paths.  No validation for the 
    existance occurs, only for the correct format.

--*/
{
    if (strDirPath.GetLength() >= 5)  // It must be at least as long as \\x\y,
    {                                 //
        LPCTSTR lp = strDirPath;      //
        if (*lp == _T('\\')           // It must begin with \\,
         && *(lp + 1) == _T('\\')     //
         && *(lp + 2) != _T('.')      // This is a device.
         && _tcschr(lp + 3, _T('\\')) // And have at least one more \ after that
           )
        {
            //
            // Yes, it's a UNC path
            //
            return TRUE;
        }
    }

    //
    // No, it's not
    //
    return FALSE;
}



BOOL 
IsDevicePath(
    IN const CString & strDirPath
    )
/*++

Routine Description:

    Determine if the given path is of the form "\\.\foobar"

Arguments:

    const CString & strDirPath : Directory path string

Return Value:

    TRUE if the path given is a device path, 
    FALSE if it is not.

--*/
{
    LPCTSTR lpszDevice = _T("\\\\.\\");

    return _tcsnccmp(strDirPath, lpszDevice, lstrlen(lpszDevice)) == 0;
}



BOOL
IsFullyQualifiedPath(
    IN const CString & strDirPath
    )
/*++

Routine Description:

    Determine if the given string is a fully qualified path name

Arguments:

    const CString & strDirPath : Directory path string

Return Value:

    TRUE if the path is a fully qualified path name


--*/
{
    return strDirPath.GetLength() >= 3
        && strDirPath[1] == _T(':')
        && strDirPath[2] == _T('\\');
}



BOOL
IsNetworkPath(
    IN  const CString & strDirPath,
    OUT CString * pstrDrive,        OPTIONAL
    OUT CString * pstrUNC           OPTIONAL
    )
/*++

Routine Description:

    Determine if the path exists on a network directory
    in the context of the local machine.

Arguments:

    const CString & strDirPath : Directory path string
    CString * pstrDrive        : Returns drive
    CString * pstrUNC          : Returns UNC path

Return Value:

    TRUE if the path is a network path, FALSE if it is local.

Notes:

    Only fully qualified paths with drive letters are checked.

--*/
{
    BOOL fUNC = FALSE;
    CString strDrive;

    try
    {
        if (pstrDrive == NULL)
        {
            pstrDrive = &strDrive;
        }

        ASSERT(strDirPath[1] == _T(':'));
        if (strDirPath[1] == _T(':'))
        {
            *pstrDrive = _T("?:");

            //
            // Fill in actual drive letter
            //
            pstrDrive->SetAt(0, strDirPath[0]);
            UINT nType = GetDriveType(*pstrDrive);

            //
            // DRIVE_NO_ROOT_DIR? this is a little dodgy, but
            // this is the result I get back after browsing
            // using a file open dialog.  Weird.
            //
            fUNC = (nType == DRIVE_NO_ROOT_DIR || nType == DRIVE_REMOTE);
        }

        //
        // Return UNC path if requested
        //
        if (fUNC && pstrUNC != NULL)
        {
            DWORD dwSize = _MAX_PATH;
            LPTSTR lp = pstrUNC->GetBuffer(dwSize);
            ::WNetGetConnection(*pstrDrive, lp, &dwSize);
            pstrUNC->ReleaseBuffer();
        }
    }
    catch(CException * e)
    {
        e->ReportError();
        e->Delete();
    }

    return fUNC;
}



LPCTSTR
MakeUNCPath(
    IN OUT CString & strDir,
    IN LPCTSTR lpszOwner,
    IN LPCTSTR lpszDirectory
    )
/*++

Routine Description:

    Convert the given directory to a UNC path.

Arguments:

    CString & strDir      : UNC String.
    LPCTSTR lpszOwner     : Computer name
    LPCTSTR lpszDirectory : Source string

Return Value:

    Pointer to strDir

Notes:

    The owner may or may not start with "\\".  If it doesn't, the
    backslashes are provided.

--*/
{
    //
    // Try to make make a unc path out of the directory
    //
    ASSERT(lpszDirectory[1] == _T(':'));

    strDir.Format(
        _T("\\\\%s\\%c$\\%s"),
        PURE_COMPUTER_NAME(lpszOwner),
        lpszDirectory[0],
        lpszDirectory + 3
        );

    return (LPCTSTR)strDir;
}



BOOL
IsURLName(
    IN const CString & strDirPath
    )
/*++

Routine Description:

    Determine if the given string path is an URL path.

Arguments:

    const CString & strDirPath : Directory path string

Return Value:

    TRUE if the path is an URL path, FALSE otherwise.

Notes:

    Any string of the form protocol://whatever is considered an URL path

--*/
{
    if (strDirPath.GetLength() >= 4)  // It must be at least as long as x://
    {                                 //
        if (strDirPath.Find(_T("://")) > 0) // Must contain ://
        {
            //
            // Yes, it's an URL path
            //
            return TRUE;
        }
    }

    //
    // No, it's not
    //
    return FALSE;
}



int
CStringFindNoCase(
    IN const CString & strSrc,
    IN LPCTSTR lpszSub
    )
/*++

Routine Description:

    This should be CString::FindNoCase().  Same as CString::Find(),
    but case-insensitive.

Arguments:

    const CString & strSrc  : Source string
    LPCTSTR lpszSub         : String to look for.

Return Value:

    The position of the substring, or -1 if not found.

--*/
{
    LPCTSTR lp1 = strSrc;
    LPCTSTR lp2, lp3;
    int nPos = -1;

    while (*lp1)
    {
        lp2 = lp1;
        lp3 = lpszSub;

        while(*lp2 && *lp3 && _totupper(*lp2) == _totupper(*lp3))
        {
            ++lp2;
            ++lp3;
        }

        if (!*lp3)
        {
            //
            // Found the substring
            //
            nPos = (int)(lp1 - (LPCTSTR)strSrc);
            break;
        }
    
        ++lp1;                    
    }

    return nPos;
}



DWORD
ReplaceStringInString(
    OUT IN CString & strBuffer,
    IN  CString & strTarget,
    IN  CString & strReplacement,
    IN  BOOL fCaseSensitive
    )
/*++

Routine Description:

    Replace the first occurrence of a string with a second string
    inside a third string.

Arguments:

    CString & strBuffer         : Buffer in which to replace
    CString & strTarget         : String to look for
    CString & strReplacement    : String to replace it with
    BOOL fCaseSensitive         : TRUE for case sensitive replacement.
    
Return Value:

    ERROR_SUCCESS for successful replacement.
    ERROR_INVALID_PARAMETER if any string is empty,
    ERROR_FILE_NOT_FOUND if the target string doesn't exist, or
    another win32 error code indicating failure.

--*/
{
    if (strBuffer.IsEmpty() || strTarget.IsEmpty() || strReplacement.IsEmpty())
    {
        return ERROR_INVALID_PARAMETER;
    }

    DWORD err = ERROR_FILE_NOT_FOUND;
    int nPos = fCaseSensitive 
        ? strBuffer.Find(strTarget)
        : CStringFindNoCase(strBuffer, strTarget);

    if (nPos >= 0)
    {
        try
        {
            CString str(strBuffer.Left(nPos));

            str += strReplacement;
            str += strBuffer.Mid(nPos + strTarget.GetLength());
            strBuffer = str;

            err = ERROR_SUCCESS;
        }
        catch(CMemoryException * e)
        {
            e->Delete();
            err = ERROR_NOT_ENOUGH_MEMORY;
        }
    }    

    return err;
}




DWORD
DeflateEnvironmentVariablePath(
    IN LPCTSTR lpszEnvVar,
    IN OUT CString & strTarget
    )
/*++

Routine Description:

    Take a path, and if the path represents a superset of the
    path in the environment variable given, replace the relevant
    portion of the path with the environment variable.

Arguments:

    LPCTSTR lpszEnvVar      : Environment variable
    CString & strTarget     : Path

Return Value:

    ERROR_SUCCESS if the replacement was done succesfully,
    ERROR_FILE_NOT_FOUND if the path represented by the environment
    variable is not contained within the string, or an other win32
    error for error conditions

--*/
{
    CError err;
    CString strEnv;

    if (!::GetEnvironmentVariable(
        lpszEnvVar,
        strEnv.GetBuffer(_MAX_PATH),
        _MAX_PATH
        ))
    {
        err.SetLastWinError();
    }

    strEnv.ReleaseBuffer();
    if (err.Succeeded())
    {
        try
        {
            CString strReplacement(_T("%"));
            strReplacement += lpszEnvVar;
            strReplacement += _T("%");

            err = ReplaceStringInString(
                strTarget,
                strEnv,
                strReplacement,
                FALSE 
                );
        }
        catch(CMemoryException * e)
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
            e->Delete();
        }
    }

    return err;
}



LPCTSTR
GUIDToCString(
    IN  REFGUID guid,
    OUT CString & str
    )
/*++

Routine Description:

    Convert a GUID to a CString, returning pointer to the string

Arguments:

    REFGUID       : GUID to be converted
    CString & str : Output string buffer

Return Value:

    Pointer to the string

--*/
{
    LPTSTR lpGUID = str.GetBuffer(MAX_PATH);

    if (lpGUID)
    {
        ::StringFromGUID2(guid, lpGUID, MAX_PATH);
        str.ReleaseBuffer();
    }

    return str;
}



int
CountCharsToDoubleNull(
    IN LPCTSTR lp
    )
/*++

Routine Description:

    Count TCHARS up to and including the double NULL.

Arguments:

    LPCTSTR lp       : TCHAR Stream

Return Value:

    Number of chars up to and including the double NULL

--*/
{
    int cChars = 0;

    for(;;)
    {
        ++cChars;
        if (lp[0] == _T('\0') && lp[1] == _T('\0'))
        {
            return ++cChars;
        }

        ++lp;
    }
}



DWORD
ConvertDoubleNullListToStringList(
    IN  LPCTSTR lpstrSrc,
    OUT CStringList & strlDest,
    IN  int cChars                  OPTIONAL
    )
/*++

Routine Description:

    Convert a double null terminate list of null terminated strings to a more
    manageable CStringListEx

Arguments:

    LPCTSTR lpstrSrc       : Source list of strings
    CStringList & strlDest : Destination string list.
    int cChars             : Number of characters in double NULL list. if
                             -1, autodetermine length

Return Value:

    ERROR_SUCCESS           if the list was converted properly
    ERROR_INVALID_PARAMETER if the list was empty
    ERROR_NOT_ENOUGH_MEMORY if there was a mem exception

--*/
{
    DWORD err = ERROR_SUCCESS;

    if (lpstrSrc == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (cChars < 0)
    {
        //
        // Calculate our own size.  This might be off if multiple
        // blank linkes (0) appear in the multi_sz, so the character
        // size is definitely preferable
        //
        cChars = CountCharsToDoubleNull(lpstrSrc);
    }

    try
    {
        strlDest.RemoveAll();

        if (cChars == 2 && *lpstrSrc == _T('\0'))
        {
            //
            // Special case: MULTI_SZ containing only
            // a double NULL are in fact blank entirely.
            //
            // N.B. IMHO this is a metabase bug -- RonaldM
            //
            --cChars;
        }

        //
        // Grab strings until only the final NULL remains
        //
        while (cChars > 1)
        {
            CString strTmp = lpstrSrc;
            strlDest.AddTail(strTmp);
            lpstrSrc += (strTmp.GetLength() + 1);
            cChars -= (strTmp.GetLength() + 1);
        }
    }
    catch(CMemoryException * e)
    {
        TRACEEOLID("!!! exception building stringlist");
        err = ERROR_NOT_ENOUGH_MEMORY;
        e->Delete();
    }

    return err;
}




DWORD
ConvertStringListToDoubleNullList(
    IN  CStringList & strlSrc,
    OUT DWORD & cchDest,
    OUT LPTSTR & lpstrDest
    )
/*++

Routine Description:

    Flatten the string list into a double null terminated list
    of null terminated strings.

Arguments:

    CStringList & strlSrc : Source string list
    DWORD & cchDest       : Size in characters of the resultant array
                            (including terminating NULLs)
    LPTSTR & lpstrDest    : Allocated flat array.

Return Value:

    ERROR_SUCCESS           if the list was converted properly
    ERROR_INVALID_PARAMETER if the list was empty
    ERROR_NOT_ENOUGH_MEMORY if there was a mem exception

--*/
{
    cchDest = 0;
    lpstrDest = NULL;
    BOOL fNullPad = FALSE;

    //
    // Compute total size in characters
    //
    POSITION pos;
    for(pos = strlSrc.GetHeadPosition(); pos != NULL; /**/ )
    {
        CString & str = strlSrc.GetNext(pos);

        TRACEEOLID(str);

        cchDest += str.GetLength() + 1;
    }

    if (!cchDest)
    {
        //
        // Special case: A totally empty MULTI_SZ
        // in fact consists of 2 (final) NULLS, instead
        // of 1 (final) NULL.  This is required by the
        // metabase, but should be a bug.  See note
        // at reversal function above.
        //
        ++cchDest;
        fNullPad = TRUE;
    }

    //
    // Remember final NULL
    //
    cchDest += 1;

    lpstrDest = AllocTString(cchDest);
    if (lpstrDest == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    LPTSTR pch = lpstrDest;

    for(pos = strlSrc.GetHeadPosition(); pos != NULL; /**/ )
    {
        CString & str = strlSrc.GetNext(pos);

        lstrcpy(pch, (LPCTSTR)str);
        pch += str.GetLength();
        *pch++ = _T('\0');
    }

    *pch++ = _T('\0');

    if (fNullPad)
    {
        *pch++ = _T('\0');
    }

    return ERROR_SUCCESS;
}



int
ConvertSepLineToStringList(
    IN  LPCTSTR lpstrIn,
    OUT CStringList & strlOut,
    IN  LPCTSTR lpstrSep
    )
/*++

Routine Description:

    Convert a line containing multiple strings separated by
    a given character to a CStringListEx

Arguments:

    LPCTSTR lpstrIn         : Input line
    CStringListEx & strlOut : Output stringlist
    LPCTSTR lpstrSep        : List of separators

Return Value:

    The number of items added

--*/
{
    int cItems = 0;
    strlOut.RemoveAll();

    try
    {
        CString strSrc(lpstrIn);
        LPTSTR lp = strSrc.GetBuffer(0);
        lp = StringTok(lp, lpstrSep);

        while (lp)
        {
            CString str(lp);

            strlOut.AddTail(str);
            lp = StringTok(NULL, lpstrSep);
            ++cItems;
        }
    }
    catch(CMemoryException * e)
    {
        TRACEEOLID("Exception converting CSV list to stringlist");
        e->ReportError();
        e->Delete();
    }

    return cItems;
}




LPCTSTR
ConvertStringListToSepLine(
    IN  CStringList & strlIn,
    OUT CString & strOut,
    IN  LPCTSTR lpstrSep
    )
/*++

Routine Description:

    Convert stringlist into a single CString, each entry seperated by the given
    seperator string.

Arguments:

    CStringListEx & strlIn  : Input stringlist
    CString & strOut        : Output string
    LPCTSTR lpstrSep        : Seperator string

Return Value:

    Pointer to the output string.

--*/
{
    strOut.Empty();
    POSITION pos = strlIn.GetHeadPosition();

    while(pos)
    {
        CString & str = strlIn.GetNext(pos);

        strOut += str;
		if (str.Right(1) == _T("\r"))
			strOut += lpstrSep;
    }
    return strOut;
}



LPTSTR
StringTok(
    IN LPTSTR string,
    IN LPCTSTR control
    )
/*++

Routine Description:

    strtok replacement function.

Arguments:

    LPTSTR string       : string, see strtok
    LPCTSTR control     : seperators, see strtok

Return Value:

    Pointer to string or NULL, see strtok.

Notes:

    This function is NOT thread-safe.

--*/
{
    LPTSTR str;
    LPCTSTR ctrl = control;

    TCHAR map[32];

    static LPTSTR nextoken;

    //
    // Clear control map
    //
    ZeroMemory(map, sizeof(map));

    //
    // Set bits in delimiter table
    //
    do
    {
        map[*ctrl >> 3] |= (1 << (*ctrl & 7));
    }
    while (*ctrl++);

    //
    // Initialize str. If string is NULL, set str to the saved
    // pointer (i.e., continue breaking tokens out of the string
    // from the last StringTok call)
    //
    if (string != NULL)
    {
        str = string;
    }
    else
    {
        str = nextoken;
    }

    //
    // Find beginning of token (skip over leading delimiters). Note that
    // there is no token iff this loop sets str to point to the terminal
    // null (*str == '\0').
    //

#ifdef UNICODE

    //
    // To avoid index overflow, check non-ASCII characters (UNICODE)
    //
    while (!(*str & 0xff00) &&
        (map[*str >> 3] & (1 << (*str & 7))) && *str)
#else

    while ((map[*str >> 3] & (1 << (*str & 7))) && *str)

#endif // UNICODE
    {
        ++str;
    }

    string = str;

    //
    // Find the end of the token. If it is not the end of the string,
    // put a null there.
    //
    for ( /**/ ; *str ; str++ )
    {

#ifdef UNICODE

        //
        // To avoid index overflow, check non-ASCII characters (UNICODE)
        //
        if ( !(*str & 0xff00) &&
            map[*str >> 3] & (1 << (*str & 7)) )
#else

        //
        // Skip DBCS character (ANSI)
        //
        if (IsDBCSLeadByte(*str) && *(str + 1))
        {
            ++str;
        }
        else if ( map[*str >> 3] & (1 << (*str & 7)) )

#endif // UNICODE

        {
            *str++ = '\0';
            break;
        }
    }

    //
    // Update nextoken structure
    //
    nextoken = str;

    //
    // Determine if a token has been found.
    //
    return string != str ? string : NULL;
}



BOOL
CStringListEx::operator ==(
    IN const CStringList & strl
    )
/*++

Routine Description:

    Compare against CStringList.  In order for two CStringLists to match,
    they must match in every element, which must be in the same order.

Arguments:

    CStringList strl       : String list to compare against.

Return Value:

    TRUE if the two string lists are identical

--*/
{
    if (strl.GetCount() != GetCount())
    {
        return FALSE;
    }

    POSITION posa = strl.GetHeadPosition();
    POSITION posb = GetHeadPosition();

    while (posa)
    {
        ASSERT(posa);
        ASSERT(posb);

        CString & strA = strl.GetNext(posa);
        CString & strB = GetNext(posb);

        if (strA != strB)
        {
            return FALSE;
        }
    }

    return TRUE;
}



CStringListEx & 
CStringListEx::operator =(
    IN const CStringList & strl
    )
/*++

Routine Description:

    Assignment operator

Arguments:

    const CStringList & strl        : Source stringlist

Return Value:

    Reference to this

--*/
{
    RemoveAll();
    POSITION pos = strl.GetHeadPosition();

    while(pos)
    {
        CString & str = strl.GetNext(pos);
        AddTail(str);
    }

    return *this;
}



BOOL
SplitUserNameAndDomain(
    IN OUT CString & strUserName,
    IN CString & strDomainName
    )
/*++

Routine Description:

    Split the user name and domain from the given
    username, which is in the format "domain\user".

    Return TRUE if the user name contained a domain
    FALSE if it did not

Arguments:

    CString & strUserName   : User name which may contain a domain name
    CString & strDomainName : Output domain name ("." if local)

Return Value:

    TRUE if a domain is split off

--*/
{
    //
    // Assume local
    //
    strDomainName = _T(".");
    int nSlash = strUserName.Find(_T("\\"));
    if (nSlash >= 0)
    {
        strDomainName = strUserName.Left(nSlash);
        strUserName = strUserName.Mid(nSlash + 1);

        return TRUE;
    }

    return FALSE;
}



BOOL
CvtStringToLong(
    IN  LPCTSTR lpNumber,
    OUT DWORD * pdwValue
    )
/*++

Routine Description:

    Helper function to convert string (hex or decimal) to a dword.

Arguments:

    LPCTSTR lpNumber        : Input number
    DWORD * pdwValue        : Returns the value

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    const TCHAR rgchHex[] = _T("00112233445566778899aAbBcCdDeEfF");

    DWORD dwResult = 0L;
    DWORD dwResultPrev = 0L;

    //
    // Assume a decimal base
    //
    DWORD dwBase = 10L;

    ASSERT(lpNumber != NULL);
    ASSERT(pdwValue != NULL);

    while (*lpNumber == _T(' ') || *lpNumber == _T('0'))
    {
        ++lpNumber;
    }

    if (*lpNumber == _T('x') || *lpNumber == _T('X'))
    {
        dwBase = 16L;
        ++lpNumber;
    }

    while (*lpNumber)
    {
        DWORD dwDigit;

        //
        // Search the character in the hexadecimal string
        //
        LPCTSTR pchDigit =  _tcschr(rgchHex, *lpNumber);

        if (!pchDigit)
        {
            //
            // Character is not found
            //
            return FALSE;
        }

        dwDigit = DIFF(pchDigit - rgchHex) >> 1;
        if (dwDigit >= dwBase)
        {
            //
            // Hexadecimal character in a decimal integer
            //
            return FALSE;
        }

        dwResultPrev = dwResult;
        dwResult *= dwBase;
        dwResult += dwDigit;
        if (dwResult < dwResultPrev)
        {
            //
            // Overflow
            //
            return FALSE;
        }

        //
        // Parse the next character
        //
        ++lpNumber;
    }

    *pdwValue = dwResult;

    return TRUE;
}



const LPCTSTR g_cszMonths[] =
{
    _T("Jan"),
    _T("Feb"),
    _T("Mar"),
    _T("Apr"),
    _T("May"),
    _T("Jun"),
    _T("Jul"),
    _T("Aug"),
    _T("Sep"),
    _T("Oct"),
    _T("Nov"),
    _T("Dec"),
};



const LPCTSTR g_cszWeekDays[] =
{
    _T("Sun"),
    _T("Mon"),
    _T("Tue"),
    _T("Wed"),
    _T("Thu"),
    _T("Fri"),
    _T("Sat"),
};



inline BOOL SkipTillDigit(LPCTSTR & lp)
{
    while (lp && *lp && !_istdigit(*lp)) ++lp;

    return lp != NULL;
}



inline BOOL SkipPastDigits(LPCTSTR & lp)
{
    while (lp && *lp && _istdigit(*lp)) ++lp;

    return lp != NULL;
}



BOOL
FetchIntField(
    LPCTSTR & lp,
    int & n
    )
{
    if (SkipTillDigit(lp))
    {
        n = _ttoi(lp);
        if (n < 0)
        {
            ASSERT(FALSE && "Bogus string->int");
            return FALSE;
        }

        return SkipPastDigits(lp);
    }

    return FALSE;
}



BOOL
MatchString(
    LPCTSTR lpTarget,
    const LPCTSTR * rglp,
    int cElements,
    int & idx
    )
{
    for (idx = 0; idx < cElements; ++idx)
    {
        if (!_tcsnicmp(lpTarget, rglp[idx], _tcslen(rglp[idx])))
        {
            return TRUE;
        }
    }

    return FALSE;
}



static g_dwCurrentTimeZone = TIME_ZONE_ID_INVALID;
static TIME_ZONE_INFORMATION g_tzInfo;




BOOL
CvtGMTStringToInternal(
    IN  LPCTSTR lpTime,
    OUT time_t * ptValue
    )
/*++

Routine Description:

    Convert GMT string to time in the local timezone format

Arguments:

    IN  LPCSTSTR lpTime             : Input time string
    OUT time_t * ptValue            : Output time_t

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    ASSERT(lpTime != NULL);
    ASSERT(ptValue != NULL);

    int year, month, day, hour, minutes, seconds;

    do
    {
        if (!lpTime || !ptValue)
        {
            break;
        }

        if (!FetchIntField(lpTime, day))
        {
            break;
        }

        ++lpTime;   // Skip seperator

        if (!MatchString(lpTime, g_cszMonths, 12, month))
        {
            break;
        }

        ++month; // 0-based.

        if (!FetchIntField(lpTime, year)    ||
            !FetchIntField(lpTime, hour)    ||
            !FetchIntField(lpTime, minutes) ||
            !FetchIntField(lpTime, seconds))
        {
            break;
        }

        if (year < 100)
        {
            year += ((year < 50) ? 2000 : 1900);
        }

        CTime time(year, month, day, hour, minutes, seconds);
        if (time.GetTime() == (time_t)-1L)
        {
            break;
        }

        *ptValue = time.GetTime();

        TRACEEOLID("GMT Time is " << ctime(ptValue));

        //
        // Adjust for local time zone
        //
        RaiseThreadProtection();
        if (g_dwCurrentTimeZone == TIME_ZONE_ID_INVALID) 
        {
            //
            // GetTimeZoneInfo() is expensive, so cache its output
            //
            g_dwCurrentTimeZone = GetTimeZoneInformation(&g_tzInfo);
        }
        LowerThreadProtection();

        if (g_dwCurrentTimeZone != TIME_ZONE_ID_INVALID)
        {
            _tzset();

            struct tm * tb = localtime(ptValue);

            BOOL fDST = tb->tm_isdst;

            RaiseThreadProtection();
            *ptValue -= (g_tzInfo.Bias * 60L);

            TRACEEOLID("local time (w/o dst adjustment) is " << ctime(ptValue));

            if (fDST)
            {
                *ptValue -= (g_tzInfo.DaylightBias * 60L);
            }
            else
            {
                //
                // Almost always this is zero
                //
                *ptValue -= (g_tzInfo.StandardBias * 60L);
            }
            LowerThreadProtection();

            TRACEEOLID("Local time adjusted for dst is " << ctime(ptValue));
        }

        //
        // Time OK
        //
        return TRUE;
    }
    while(FALSE);

    //
    // Set max abs timeout value.
    //
    CTime time(2037, 12, 31, 0, 0, 0);
    *ptValue = (time_t)time.GetTime();

    return FALSE;
}



void
CvtInternalToGMTString(
    IN  time_t tm,
    OUT CString & str
    )
/*++

Routine Description:

    Reverse of the above function.  Convert internal time_t to a GMT
    time string (converting to GM time in the process)

Arguments:

    time_t tm       : Input time_t
    CString & str   : Out CString

Return Value:

    None

--*/
{
    try
    {
        _tzset();

        struct tm * tb = gmtime(&tm);

        str.Format(
            _T("%-3.3s, %02d %-3.3s %4d %02d:%02d:%02d GMT"),
            g_cszWeekDays[tb->tm_wday],
            tb->tm_mday,
            g_cszMonths[tb->tm_mon],
            tb->tm_year + 1900,
            tb->tm_hour,
            tb->tm_min,
            tb->tm_sec
            );

        TRACEEOLID("Time string is " << str);
    }
    catch(CMemoryException * e)
    {
        e->ReportError();
        e->Delete();
    }
}


//
// International numeric strings
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



//
// Initialize library
//
BOOL
InitIntlSettings()
{
#ifdef _MT
    INITIALIZE_CRITICAL_SECTION(&_csSect);
#endif // _MT

    return CINumber::Allocate();
}



//
// De-initialize library
//
void
TerminateIntlSettings()
{
    CINumber::DeAllocate();

#ifdef _MT
    DeleteCriticalSection(&_csSect);
#endif // _MT
}



//
// Static Member Initialization
//
CString * CINumber::s_pstrThousandSeperator = NULL;
CString * CINumber::s_pstrDecimalPoint = NULL;
CString * CINumber::s_pstrBadNumber = NULL;
CString * CINumber::s_pstrCurrency = NULL;
CString * CINumber::s_pstr = NULL;
BOOL CINumber::s_fAllocated = FALSE;
BOOL CINumber::s_fCurrencyPrefix = TRUE;
BOOL CINumber::s_fInitialized = FALSE;



#ifdef _DOS



BOOL
_dos_getintlsettings(
    OUT INTLFORMAT * pStruct
    )
/*++

Routine Description:

    Get the international settings on a DOS box

Parameters:

    INTLFORMAT * pStruct : Structure to be filled in.

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    TRACEEOLID("[_dos_getintlsetting]");
    union _REGS inregs, outregs;
    struct _SREGS segregs;

    inregs.h.ah = 0x38;   // Intl call
    inregs.h.al = 0x00;   // Current country code
    inregs.x.bx = 0x00;   // Current country code

    segregs.ds  = _FP_SEG(pStruct);
    inregs.x.dx = _FP_OFF(pStruct);

    int nError = _intdosx(&inregs, &outregs, &segregs);

    return outregs.x.cflag == 0;
}

#endif // _DOS



/* protected */
CINumber::CINumber()
/*++

Routine Description:

    Constructor

Arguments:

    None

Return Value:

    None

--*/
{
    if (!CINumber::s_fInitialized)
    {
        CINumber::Initialize();
    }
}



CINumber::~CINumber()
/*++

Routine Description:

    Destructor

Arguments:

    None

Return Value:

    None

--*/
{
}



/* protected */
/* static */
BOOL
CINumber::Allocate()
/*++

Routine Description:

    Allocate with US settings

Arguments:

    None

Return Value:

    TRUE if allocation was successfull, FALSE otherwise

--*/
{
    RaiseThreadProtection();

    ASSERT(!IsAllocated());
    if (!IsAllocated())
    {
        try
        {
            CINumber::s_pstrThousandSeperator = new CString(_T(","));
            CINumber::s_pstrDecimalPoint = new CString(_T("."));
            CINumber::s_pstrBadNumber = new CString(_T("--"));
            CINumber::s_pstrCurrency = new CString(_T("$ "));
            CINumber::s_pstr = new CString;
            s_fAllocated = TRUE;
        }
        catch(CMemoryException * e)
        {
            TRACEEOLID("Initialization Failed");
            e->ReportError();
            e->Delete();
        }
    }

    LowerThreadProtection();

    return IsAllocated();
}



/* protected */
/* static */
void
CINumber::DeAllocate()
/*++

Routine Description:

    Clean up allocations

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    RaiseThreadProtection();
    
    ASSERT(IsAllocated());
    if (IsAllocated())
    {
        MAKE_NULL(CINumber::s_pstrThousandSeperator);
        MAKE_NULL(CINumber::s_pstrDecimalPoint);
        MAKE_NULL(CINumber::s_pstrBadNumber);
        MAKE_NULL(CINumber::s_pstrCurrency);
        MAKE_NULL(CINumber::s_pstr);
    }

    LowerThreadProtection();

    s_fAllocated = FALSE;
}



/* static */
/* protected */
BOOL
CINumber::Initialize(
    IN BOOL fUserSetting /* TRUE */
    )
/*++

Routine Description:

    Initialize all the international settings, such as thousand
    seperators and decimal points

Parameters:

    BOOL    fUserSetting        If TRUE, use current user settings,
                                if FALSE use system settings.
Return Value:

    TRUE for success, FALSE for failure

Notes:

    Note that this function only needs to be explicitly called
    when the country settings have changed, or when system
    settings are desired (user is default)

--*/
{
#define MAXLEN  6

    int cErrors = 0;

    TRACEEOLID("Getting locale-dependend information");

    ASSERT(IsAllocated());
    if (!IsAllocated())
    {
        Allocate();
    }

    RaiseThreadProtection();

    try
    {

#if defined(_MAC)

        TRACEEOLID("Couldn't get international settings from system");

#elif defined(_WIN32)

        LCID lcid = fUserSetting
            ? ::GetUserDefaultLCID()
            : GetSystemDefaultLCID();

        LCTYPE lctype = fUserSetting ? 0 : LOCALE_NOUSEROVERRIDE;

        //
        // Get Decimal Point
        //
        if (!::GetLocaleInfo(
            lcid,
            LOCALE_SDECIMAL | lctype,
            CINumber::s_pstrDecimalPoint->GetBuffer(MAXLEN),
            MAXLEN
            ))
        {
            TRACEEOLID("Unable to get intl decimal point");
            ++cErrors;
        }

        CINumber::s_pstrDecimalPoint->ReleaseBuffer();

        //
        // Get Thousand Seperator
        //
        if (!::GetLocaleInfo(
            lcid, LOCALE_STHOUSAND | lctype,
            CINumber::s_pstrThousandSeperator->GetBuffer(MAXLEN),
            MAXLEN
            ))
        {
            TRACEEOLID("Unable to get 1000 seperator");
            ++cErrors;
        }

        CINumber::s_pstrThousandSeperator->ReleaseBuffer();

#ifndef _UNICODE

        //
        // Some countries have a space as a 1000 seperator,
        // but for some reason, this is ansi 160, which
        // shows up as a space fine on windows apps,
        // looks like garbage on console apps.
        //
        if ((*CINumber::s_pstrThousandSeperator)[0] == CHAR(160))
        {
            CINumber::s_pstrThousandSeperator->SetAt(0, ' ');
            TRACEEOLID("Space 1000 seperator substituted");
        }

#endif // _UNICODE

        //
        // Get currency symbol
        //
        if (!::GetLocaleInfo(
            lcid,
            LOCALE_SCURRENCY | lctype,
            CINumber::s_pstrCurrency->GetBuffer(MAXLEN),
            MAXLEN
            ))
        {
            TRACEEOLID("Unable to get currency symbol");
            ++cErrors;
        }

        CINumber::s_pstrCurrency->ReleaseBuffer();

#elif defined(_WIN16)

        //
        // Get Decimal Point
        //
        ::GetProfileString(
            "Intl",
            "sDecimal",
            ".",
            CINumber::s_pstrDecimalPoint->GetBuffer(MAXLEN),
            MAXLEN
            );
        CINumber::s_pstrDecimalPoint->ReleaseBuffer();

        //
        // Get 1000 seperator
        //
        ::GetProfileString(
            "Intl",
            "sThousand",
            ",",
            CINumber::s_pstrThousandSeperator->GetBuffer(MAXLEN),
            MAXLEN
            );
        CINumber::s_pstrThousandSeperator->ReleaseBuffer();

        //
        // Get currency symbol
        //
        ::GetProfileString(
            "Intl",
            "sCurrency",
            ",",
            CINumber::s_pstrCurrency->GetBuffer(MAXLEN),
            MAXLEN
            );
        CINumber::s_pstrCurrency->ReleaseBuffer();

#elif defined(_DOS)

        INTLFORMAT fm;

        if (_dos_getintlsettings(&fm))
        {
            //
            // Get Decimal Point
            //
            *CINumber::s_pstrDecimalPoint = fm.szDecimalPoint;

            //
            // Get 1000 seperator
            //
            *CINumber::s_pstrThousandSeperator = fm.szThousandSep;

            //
            // Get Currency Symbol
            //
            *CINumber::s_pstrCurrency = fm.szCurrencySymbol;
        }
        else
        {
            TRACEEOLID("Unable to get intl settings");
            ++cErrors;
        }

#endif // _WIN32 etc

    }

    catch(CMemoryException * e)
    {
        TRACEEOLID("!!!exception in getting intl settings:");
        e->ReportError();
        e->Delete();
        ++cErrors;
    }

    TRACEEOLID("Thousand Seperator . . . . . : " << *CINumber::s_pstrThousandSeperator);
    TRACEEOLID("Decimal Point  . . . . . . . : " << *CINumber::s_pstrDecimalPoint);
    TRACEEOLID("Currency Symbol. . . . . . . : " << *CINumber::s_pstrCurrency);
    TRACEEOLID("Bad number . . . . . . . . . : " << *CINumber::s_pstrBadNumber);
    TRACEEOLID("Currency Prefix. . . . . . . : " << CINumber::s_fCurrencyPrefix);

    CINumber::s_fInitialized = TRUE;

    LowerThreadProtection();

    return cErrors == 0;
}



/* static */
double
CINumber::BuildFloat(
    IN const LONG lInteger,
    IN const LONG lFraction
    )
/*++

Return Value:

    Combine integer and fraction to form float

Parameters:

    const LONG lInteger       Integer portion
    const LONG lFraction      Fractional portion

Return Value:

    float value

--*/
{
    double flValue = 0.0;

    //
    // Negative fractions?
    //
    ASSERT(lFraction >= 0);

    if (lFraction >= 0)
    {
        flValue = (double)lFraction;
        while (flValue >= 1.0)
        {
            flValue /= 10.0;
        }

        //
        // Re-add (or subtract if the original number
        // was negative) the fractional part
        //
        if (lInteger > 0L)
        {
            flValue += (double)lInteger;
        }
        else
        {
            flValue -= (double)lInteger;
            flValue = -flValue;
        }
    }

    return flValue;
}



/* static */
LPCTSTR
CINumber::ConvertLongToString(
    IN  const LONG lSrc,
    OUT CString & str
    )
/*++

CINumber::ConvertLongToString

Purpose:

    Convert long number to string with 1000 seperators

Parameters:

    const LONG lSrc         Source number
    CString & str           String to write to

Return Value:

    Pointer to converted string

--*/
{
    LPTSTR lpOutString = str.GetBuffer(16);

    //
    // Forget about the negative sign for now.
    //
    LONG lNum = (lSrc >= 0L) ? lSrc : -lSrc;
    int outstrlen = 0;
    do
    {
        lpOutString[outstrlen++] = _T('0') + (TCHAR)(lNum % 10L);
        lNum /= 10L;

        //
        // if more digits left and we're on a 1000 boundary (printed 3 digits,
        // or 3 digits + n*(3 digits + 1 comma), then print a 1000 separator.
        // Note: will only work if the 1000 seperator is 1 character.
        //
        ASSERT(CINumber::s_pstrThousandSeperator->GetLength() == 1);
        if (lNum != 0L && (outstrlen == 3 || outstrlen == 7 || outstrlen == 11))
        {
            lstrcpy(lpOutString + outstrlen, *CINumber::s_pstrThousandSeperator);
            outstrlen += CINumber::s_pstrThousandSeperator->GetLength();
        }

    }
    while (lNum > 0L);

    //
    // Add a negative sign if necessary.
    //
    if (lSrc < 0L)
    {
        lpOutString[outstrlen++] = _T('-');
    }

    str.ReleaseBuffer(outstrlen);
    str.MakeReverse();

    return (LPCTSTR)str;
}



/* static */
LPCTSTR
CINumber::ConvertFloatToString(
    IN const double flSrc,
    IN int nPrecision,
    OUT CString & str
    )
/*++

Routine Description:

    Convert floating point number to string represenation

Parameters:

    const double flSrc          Source floating point number
    int nPrecision              Number of decimal points
    CString & str               String to convert to

Return Value:

    Pointer to converted string.

--*/
{
    //
    // Forget about the negative sign for now,
    // and the fractional portion.
    //
    TCHAR szFraction[256];
    LPCTSTR lpFraction = NULL;

    ::_stprintf(szFraction, _T("%.*f"), nPrecision, flSrc);
    lpFraction = ::_tcschr(szFraction, _T('.') );
    ASSERT(lpFraction != NULL);
    ++lpFraction;

    CINumber::ConvertLongToString((LONG)flSrc, str);

    str += *CINumber::s_pstrDecimalPoint + lpFraction;

    return (LPCTSTR)str;
}



/* static */
BOOL
CINumber::ConvertStringToLong(
    IN  LPCTSTR lpsrc,
    OUT LONG & lValue
    )
/*++

Routine Description:

    Convert string to long integer.  1000 Seperators will be treated
    correctly.

Parameters:

    LPCTSTR lpsrc       Source string
    LONG & lValue       Value to convert to.  Will be 0 in case of error

Return Value:

    TRUE for success, FALSE for failure.

--*/
{
    CString strNumber(lpsrc);
    LONG lBase = 1L;
    BOOL fNegative = FALSE;

    lValue = 0L;

    //
    // Empty strings are invalid
    //
    if (strNumber.IsEmpty())
    {
        return FALSE;
    }

    //
    // Check for negative sign (at the end only)
    //
    if (strNumber[0] == _T('-'))
    {
        fNegative = TRUE;
    }

    strNumber.MakeReverse();

    //
    // Strip negative sign
    //
    if (fNegative)
    {
        strNumber.ReleaseBuffer(strNumber.GetLength()-1);
    }

    //
    // Make sure the 1000 seperator is only 1 char.  See note below
    //
    ASSERT(CINumber::s_pstrThousandSeperator->GetLength() == 1);
    for (int i = 0; i < strNumber.GetLength(); ++i)
    {
        if ((strNumber[i] >= _T('0')) && (strNumber[i] <= _T('9')))
        {
            LONG lDigit = (LONG)(strNumber[i] - _T('0'));
            if (lDigit != 0L)
            {
                LONG lOldValue = lValue;
                LONG lDelta = (lDigit * lBase);
                if (lDelta / lDigit != lBase)
                {
                    TRACEEOLID("Overflow!");
                    lValue = 0x7fffffff;

                    return FALSE;
                }

                lValue += lDelta;
                if (lValue - lDelta != lOldValue)
                {
                    TRACEEOLID("Overflow!");
                    lValue = 0x7fffffff;

                    return FALSE;
                }
            }

            lBase *= 10L;
        }
        //
        // It's not a digit, maybe a thousand seperator?
        // CAVEAT: If a thousand seperator of more than
        //         one character is used, this won't work.
        //
        else if ((strNumber[i] != (*CINumber::s_pstrThousandSeperator)[0])
             || (i != 3) && (i != 7) && (i != 11))
        {
            //
            // This is just invalid, since it is not a thousand
            // seperator in the proper location, nor a negative
            // sign.
            //
            TRACEEOLID("Invalid character " << (BYTE)strNumber[i] << " encountered");
            return FALSE;
        }
    }

    if (fNegative)
    {
        lValue = -lValue;
    }

    return TRUE;
}



/* static */
BOOL
CINumber::ConvertStringToFloat(
    IN  LPCTSTR lpsrc,
    OUT double & flValue
    )
/*++

Routine Description:

    Convert fully decorated floating point string to double

Parameters:

    LPCTSTR lpsrc       Source string
    double & flValue    float value generated from string

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    CString strNumber(lpsrc);

    //
    // This only works if the decimal point is a
    // single character
    //
    ASSERT(CINumber::s_pstrDecimalPoint->GetLength() == 1);

    //
    // Strip off the > 0 part
    //
    LONG lFraction = 0;

    int nPoint = strNumber.ReverseFind((*CINumber::s_pstrDecimalPoint)[0]);

    if (nPoint >= 0)
    {
        //
        // Convert fractional part
        //
        LPCTSTR lpszFraction = (LPCTSTR)strNumber + ++nPoint;
        lFraction = ::_ttol(lpszFraction);
        strNumber.ReleaseBuffer(--nPoint);
    }

    //
    // Convert integer part
    //
    LONG lInteger;
    if (ConvertStringToLong(strNumber, lInteger))
    {
        flValue = CINumber::BuildFloat(lInteger, lFraction);
        return TRUE;
    }

    return FALSE;
}



CILong::CILong()
/*++

Routine Description:

    Constructor without arguments

Parameters:

    None.

Return Value:

    N/A

--*/
    : m_lValue(0L)
{
}



CILong::CILong(
    IN LONG lValue
    )
/*++

Routine Description:

    Constructor taking LONG argument

Parameters:

    LONG lValue     Value to be set

Return Value:

    N/A

--*/
    : m_lValue(lValue)
{
}



CILong::CILong(
    IN LPCTSTR lpszValue
    )
/*++

Routine Description:

    Constructor taking string argument

Parameters:

    LPCTSTR lpszValue       String number

Return Value:

    N/A

--*/
{
    ConvertStringToLong(lpszValue, m_lValue);
}



CILong &
CILong::operator =(
    IN LONG lValue
    )
/*++

Routine Description:

    Assignment operator taking long value

Parameters:

    LONG lValue     Value to be set

Return Value:

    this object

--*/
{
    m_lValue = lValue;

    return *this;
}



CILong &
CILong::operator =(
    IN LPCTSTR lpszValue
    )
/*++

Routine Description:

    Assignment operator taking string value

Parameters:

    LPCTSTR lpszValue       String number

Return Value:

    this object

--*/
{
    ConvertStringToLong(lpszValue, m_lValue);

    return *this;
}



//
// Arithmetic Shorthand operators
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



CILong &
CILong::operator +=(
    IN const LONG lValue
    )
{
    m_lValue += lValue;

    return *this;
}



//
// As above
//
CILong &
CILong::operator +=(
    IN const LPCTSTR lpszValue
    )
{
    LONG lValue;

    ConvertStringToLong(lpszValue, lValue);

    m_lValue += lValue;

    return *this;
}



//
// As above
//
CILong &
CILong::operator +=(
    IN const CILong& value
    )
{
    m_lValue += value.m_lValue;

    return *this;
}



//
// As above
//
CILong &
CILong::operator -=(
    IN const LONG lValue
    )
{
    m_lValue -= lValue;

    return *this;
}



//
// As above
//
CILong &
CILong::operator -=(
    IN const LPCTSTR lpszValue
    )
{
    LONG lValue;

    ConvertStringToLong(lpszValue, lValue);

    m_lValue -= lValue;

    return *this;
}



//
// As above
//
CILong &
CILong::operator -=(
    IN const CILong& value
    )
{
    m_lValue -= value.m_lValue;

    return *this;
}



//
// As above
//
CILong &
CILong::operator *=(
    IN const LONG lValue
    )
{
    m_lValue *= lValue;

    return *this;
}



//
// As above
//
CILong &
CILong::operator *=(
    IN const LPCTSTR lpszValue
    )
{
    LONG lValue;

    ConvertStringToLong(lpszValue, lValue);

    m_lValue *= lValue;

    return *this;
}



//
// As above
//
CILong &
CILong::operator *=(
    IN const CILong& value
    )
{
    m_lValue *= value.m_lValue;

    return *this;
}



//
// As above
//
CILong &
CILong::operator /=(
    IN const LONG lValue
    )
{
    m_lValue /= lValue;

    return *this;
}



//
// As above
//
CILong &
CILong::operator /=(
    IN const LPCTSTR lpszValue
    )
{
    LONG lValue;

    ConvertStringToLong(lpszValue, lValue);

    m_lValue /= lValue;

    return *this;
}



//
// As above
//
CILong &
CILong::operator /=(
    IN const CILong& value
    )
{
    m_lValue /= value.m_lValue;

    return *this;
}



CIFloat::CIFloat(
    IN int nPrecision
    )
/*++

Routine Description:

    Constructor without arguments

Parameters:

    int nPrecision              Number of decimal digits in string,

Return Value:

    N/A

--*/
    : m_flValue(0.0),
      m_nPrecision(nPrecision)
{
}



CIFloat::CIFloat(
    IN double flValue,
    IN int nPrecision
    )
/*++

Routine Description:

    Constructor taking double argument

Parameters:

    double flValue              Value to be set
    int nPrecision              Number of decimal digits in string,

Return Value:

    N/A

--*/
    : m_flValue(flValue),
      m_nPrecision(nPrecision)
{
}



CIFloat::CIFloat(
    IN LONG lInteger,
    IN LONG lFraction,
    IN int nPrecision
    )
/*++

Routine Description:

    Constructor taking integer and fraction argument

Parameters:

    LONG lInteger               Integer portion
    LONG lFraction              Fractional portion
    int nPrecision              Number of decimal digits in string,

Return Value:

    N/A

--*/
    : m_nPrecision(nPrecision)
{
    m_flValue = CINumber::BuildFloat(lInteger, lFraction);
}



CIFloat::CIFloat(
    IN LPCTSTR lpszValue,
    IN int nPrecision
    )
/*++

Routine Description:

    Constructor taking string argument

Parameters:

    LPCTSTR lpszValue           String number
    int nPrecision              Number of decimal digits in string,

Return Value:

    N/A

--*/
    : m_nPrecision(nPrecision)
{
    ConvertStringToFloat(lpszValue, m_flValue);
}



CIFloat &
CIFloat::operator =(
    IN double flValue
    )
/*++

Routine Description:

    Assignment operator taking double value

Parameters:

    double flValue     Value to be set

Return Value:

    this object

--*/
{
    m_flValue = flValue;

    return *this;
}



CIFloat &
CIFloat::operator =(
    IN LPCTSTR lpszValue
    )
/*++

Routine Description:

    Assignment operator taking string value

Parameters:

    LPCTSTR lpszValue       String number

Return Value:

    this object

--*/
{
    ConvertStringToFloat(lpszValue, m_flValue);

    return *this;
}



//
// Arithmetic Shorthand operators
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



CIFloat &
CIFloat::operator +=(
    IN const double flValue
    )
{
    m_flValue += flValue;

    return *this;
}



//
// As above
//
CIFloat &
CIFloat::operator +=(
    IN const LPCTSTR lpszValue
    )
{
    double flValue;

    ConvertStringToFloat(lpszValue, flValue);

    m_flValue += flValue;

    return *this;
}



//
// As above
//
CIFloat &
CIFloat::operator +=(
    IN const CIFloat& value
    )
{
    m_flValue += value.m_flValue;

    return *this;
}



//
// As above
//
CIFloat &
CIFloat::operator -=(
    IN const double flValue
    )
{
    m_flValue -= flValue;

    return *this;
}



//
// As above
//
CIFloat &
CIFloat::operator -=(
    IN const LPCTSTR lpszValue
    )
{
    double flValue;

    ConvertStringToFloat(lpszValue, flValue);

    m_flValue -= flValue;

    return *this;
}



//
// As above
//
CIFloat &
CIFloat::operator -=(
    IN const CIFloat& value
    )
{
    m_flValue -= value.m_flValue;

    return *this;
}



//
// As above
//
CIFloat &
CIFloat::operator *=(
    IN const double flValue
    )
{
    m_flValue *= flValue;

    return *this;
}



//
// As above
//
CIFloat &
CIFloat::operator *=(
    IN const LPCTSTR lpszValue
    )
{
    double flValue;

    ConvertStringToFloat(lpszValue, flValue);

    m_flValue *= flValue;

    return *this;
}



//
// As above
//
CIFloat &
CIFloat::operator *=(
    IN const CIFloat& value
    )
{
    m_flValue *= value.m_flValue;

    return *this;
}



//
// As above
//
CIFloat &
CIFloat::operator /=(
    IN const double flValue
    )
{
    m_flValue /= flValue;

    return *this;
}



//
// As above
//
CIFloat &
CIFloat::operator /=(
    IN const LPCTSTR lpszValue
    )
{
    double flValue;

    ConvertStringToFloat(lpszValue, flValue);

    m_flValue /= flValue;

    return *this;
}



//
// As above
//
CIFloat &
CIFloat::operator /=(
    IN const CIFloat& value
    )
{
    m_flValue /= value.m_flValue;

    return *this;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\comprop\strfn.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        strfrn.h

   Abstract:

        String Functions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

#ifndef _STRFN_H
#define _STRFN_H

//
// Helper Macros
//

//
// Get number of array elements
//
#define ARRAY_SIZE(a)    (sizeof(a)/sizeof(a[0]))

//
// Compute size of string array in characters.  That is, don't count
// the terminal null.
//
#define STRSIZE(str)     (ARRAY_SIZE(str)-1)

//
// Get byte count of array
//
#define ARRAY_BYTES(a)   (sizeof(a) * sizeof(a[0]))

//
// Get byte count of character elements of a string -- again
// by not including the terminating NULL.
//
#define STRBYTES(str)    (ARRAY_BYTES(str) - sizeof(str[0]))

#define AllocTString(cch)\
    (LPTSTR)AllocMem((cch) * sizeof(TCHAR))

#define IS_NETBIOS_NAME(lpstr) (*lpstr == _T('\\'))

//
// Return the portion of a computer name without the backslashes
//
#define PURE_COMPUTER_NAME(lpstr) (IS_NETBIOS_NAME(lpstr) ? lpstr + 2 : lpstr)

//
// Convert CR/LF to LF
//
COMDLL BOOL 
PCToUnixText(
    OUT LPWSTR & lpstrDestination,
    IN  const CString strSource
    );

//
// Expand LF to CR/LF (no allocation necessary)
//
COMDLL BOOL 
UnixToPCText(
    OUT CString & strDestination,
    IN  LPCWSTR lpstrSource
    );

//
// Straight copy
//
COMDLL BOOL
TextToText(
    OUT LPWSTR & lpstrDestination,
    IN  const CString & strSource
    );

LPSTR COMDLL AllocAnsiString(
    IN LPCTSTR lpString
    );

LPTSTR COMDLL AllocString(
    IN LPCTSTR lpString
    );

#ifdef UNICODE

    //
    // Copy W string to T string
    // 
    #define WTSTRCPY(dst, src, cch) \
        lstrcpy(dst, src)

    //
    // Copy T string to W string
    //
    #define TWSTRCPY(dst, src, cch) \
        lstrcpy(dst, src)

    //
    // Reference a T String as a W String (a nop in Unicode)
    //
    #define TWSTRREF(str)   ((LPWSTR)str)

#else

    //
    // Convert a T String to a temporary W Buffer, and
    // return a pointer to this internal buffer
    //
    LPWSTR ReferenceAsWideString(LPCTSTR str);

    //
    // Copy W string to T string
    // 
    #define WTSTRCPY(dst, src, cch) \
        WideCharToMultiByte(CP_ACP, 0, src, -1, dst, cch, NULL, NULL)

    //
    // Copy T string to W string
    //
    #define TWSTRCPY(dst, src, cch) \
        MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, src, -1, dst, cch)

    //
    // Reference a T String as a W String 
    //
    #define TWSTRREF(str)   ReferenceAsWideString(str)

#endif // UNICODE

//
// Determine if the given string is a UNC name
//
COMDLL BOOL IsUNCName(
    IN const CString & strDirPath
    );

//
// Determine if the path is e.g. an IFS path
//
COMDLL BOOL IsDevicePath(
    IN const CString & strDirPath
    );

//
// Determine if the path is a fully qualified path in the context
// of the local machine
//
COMDLL BOOL IsFullyQualifiedPath(
    IN const CString & strDirPath
    );

//
// Determine if the path exists on a network directory in the context
// of the local machine
//
COMDLL BOOL IsNetworkPath(
    IN  const CString & strDirPath,
    OUT CString * pstrDrive = NULL,
    OUT CString * pstrUNC = NULL
    );

//
// Determine if the given string is an URL path
//
COMDLL BOOL IsURLName(
    IN const CString & strDirPath
    );

//
// Determine if the given string describes a relative URL path
//
inline BOOL IsRelURLPath(
    IN LPCTSTR lpPath
    )
{
    ASSERT(lpPath != NULL);
    return *lpPath == _T('/');
}

//
// Determine if the given path describes a wild-carded redirection
// path (starts with *;)
//
inline BOOL IsWildcardedRedirectPath(
    IN LPCTSTR lpPath
    )
{
    ASSERT(lpPath != NULL);
    return lpPath[0] == '*' && lpPath[1] == ';';
}

//
// Determine if the account is local (doesn't have a computer name)
//
inline BOOL IsLocalAccount(
    IN CString & strAccount
    )
{
    return strAccount.Find(_T('\\')) == -1;
}

//
// Convert local path to UNC path
//
COMDLL LPCTSTR MakeUNCPath(
    IN OUT CString & strDir,
    IN LPCTSTR lpszOwner,
    IN LPCTSTR lpszDirectory
    );

//
// Given domain\username, split into user name and domain
//
COMDLL BOOL SplitUserNameAndDomain(
    IN OUT CString & strUserName,
    IN CString & strDomainName
    );

//
// Convert GUID to a CString
//
COMDLL LPCTSTR GUIDToCString(
    IN  REFGUID guid,
    OUT CString & str
    );

//
// Convert double-null terminated string to a CStringList
//
COMDLL DWORD
ConvertDoubleNullListToStringList(
    IN  LPCTSTR lpstrSrc,
    OUT CStringList & strlDest,
    IN  int cChars = -1
    );

//
// Go from a CStringList to a double null terminated list
//
COMDLL DWORD
ConvertStringListToDoubleNullList(
    IN  CStringList & strlSrc,
    OUT DWORD & cchDest,
    OUT LPTSTR & lpstrDest
    );

//
// Convert separated list of strings to CStringList
//
COMDLL int
ConvertSepLineToStringList(
    IN  LPCTSTR lpstrIn,
    OUT CStringList & strlOut,
    IN  LPCTSTR lpstrSep
    );

//
// Reverse function of the above
//
COMDLL LPCTSTR
ConvertStringListToSepLine(
    IN  CStringList & strlIn,
    OUT CString & strOut,
    IN  LPCTSTR lpstrSep
    );

//
// Advanced atol which recognises hex strings
//
COMDLL BOOL 
CvtStringToLong(
    IN  LPCTSTR lpNumber,
    OUT DWORD * pdwValue
    );

//
// GMT string to time_t
//
COMDLL BOOL
CvtGMTStringToInternal(
    IN  LPCTSTR lpTime,
    OUT time_t * ptValue
    );

//
// time_t to GMT string
//
COMDLL void
CvtInternalToGMTString(
    IN  time_t tm,
    OUT CString & str
    );

//
// Private strtok
//
COMDLL LPTSTR 
StringTok(
    IN LPTSTR string,
    IN LPCTSTR control
    );

//
// CString.Find() that's not case-sensitive
//
COMDLL int 
CStringFindNoCase(
    IN const CString & strSrc,
    IN LPCTSTR lpszSub
    );

//
// Replace the first occurrance of one string
// inside another one.  Return error code
//
COMDLL DWORD
ReplaceStringInString(
    OUT IN CString & strBuffer,
    IN  CString & strTarget,
    IN  CString & strReplacement,
    IN  BOOL fCaseSensitive
    );

//
// Replace a path in strTarget with the 
// environment variable lpszEnvVar if that
// strTarget path is a superset of the path
// pointed to by lpszEnvVar
//
COMDLL DWORD
DeflateEnvironmentVariablePath(
    IN LPCTSTR lpszEnvVar,
    IN OUT CString & strTarget
    );



class COMDLL CStringListEx : public CStringList
/*++

Class Description:

    Superclass of CStringList with comparison and assignment
    operators.

Public Interface:

    operator ==       Comparison operator
    operator !=       Comparison operator
    operator =        Assignment operator  

--*/
{
//
// ctor
//
public:
    CStringListEx(int nBlockSize = 10) : CStringList(nBlockSize) {};

//
// Operators
//
public:
    BOOL operator == (const CStringList & strl);           
    BOOL operator != (const CStringList & strl) { return !operator ==(strl); }
    CStringListEx & operator =(const CStringList & strl);
};


#ifdef _DOS

typedef struct tagINTLFORMAT
{
    WORD wDateFormat;
    CHAR szCurrencySymbol[5];
    CHAR szThousandSep[2];
    CHAR szDecimalPoint[2];
    CHAR szDateSep[2];
    CHAR szTimeSep[2];
    BYTE bCurrencyFormat;
    BYTE bCurrencyDecimals;
    BYTE bTimeFormat;
    DWORD dwMapCall;
    CHAR szDataSep[2];
    BYTE bReserved[5];
} INTLFORMAT;

BOOL _dos_getintlsettings(INTLFORMAT * pStruct);

#endif // _DOS



class COMDLL CINumber
/*++

Class Description:

    Base class for international-friendly number formatting

Public Interface:

NOTES: Consider making this class a template

--*/
{
public:
    static BOOL Initialize(BOOL fUserSetting = TRUE);
    static CString * s_pstrBadNumber;
    static BOOL UseSystemDefault();
    static BOOL UseUserDefault();
    static BOOL IsInitialized();
    static LPCTSTR QueryThousandSeperator();
    static LPCTSTR QueryDecimalPoint();
    static LPCTSTR QueryCurrency();
    static double BuildFloat(const LONG lInteger, const LONG lFraction);
    static LPCTSTR ConvertLongToString(const LONG lSrc, CString & str);
    static LPCTSTR ConvertFloatToString(
        IN const double flSrc, 
        IN int nPrecision, 
        OUT CString & str
        );

    static BOOL ConvertStringToLong(LPCTSTR lpsrc, LONG & lValue);
    static BOOL ConvertStringToFloat(LPCTSTR lpsrc, double & flValue);

protected:
    CINumber();
    ~CINumber();

protected:
    friend BOOL InitIntlSettings();
    friend void TerminateIntlSettings();
    static BOOL Allocate();
    static void DeAllocate();
    static BOOL IsAllocated();

protected:
    static CString * s_pstr;

private:
    static CString * s_pstrThousandSeperator;
    static CString * s_pstrDecimalPoint;
    static CString * s_pstrCurrency;
    static BOOL s_fCurrencyPrefix;
    static BOOL s_fInitialized;
    static BOOL s_fAllocated;
};



class COMDLL CILong : public CINumber
/*++

Class Description:

    International-friendly LONG number

Public Interface:


--*/
{
public:
    //
    // Constructors
    //
    CILong();
    CILong(LONG lValue);
    CILong(LPCTSTR lpszValue);

public:
    //
    // Assignment Operators
    //
    CILong & operator =(LONG lValue);
    CILong & operator =(LPCTSTR lpszValue);

    //
    // Shorthand Operators
    //
    CILong & operator +=(const LONG lValue);
    CILong & operator +=(const LPCTSTR lpszValue);
    CILong & operator +=(const CILong& value);
    CILong & operator -=(const LONG lValue);
    CILong & operator -=(const LPCTSTR lpszValue);
    CILong & operator -=(const CILong& value);
    CILong & operator *=(const LONG lValue);
    CILong & operator *=(const LPCTSTR lpszValue);
    CILong & operator *=(const CILong& value);
    CILong & operator /=(const LONG lValue);
    CILong & operator /=(const LPCTSTR lpszValue);
    CILong & operator /=(const CILong& value);

    //
    // Comparison operators
    //
    BOOL operator ==(LONG value);
    BOOL operator !=(CILong& value);

    //
    // Conversion operators
    //
    operator const LONG() const;
    operator LPCTSTR() const;

    inline friend CArchive & AFXAPI operator<<(CArchive & ar, CILong & value)
    {
        return (ar << value.m_lValue);
    }

    inline friend CArchive & AFXAPI operator>>(CArchive & ar, CILong & value)
    {
        return (ar >> value.m_lValue);
    }

#ifdef _DEBUG
    //
    // CDumpContext stream operator
    //
    inline friend CDumpContext & AFXAPI operator<<(
        CDumpContext& dc, 
        const CILong& value
        )
    {
        return (dc << value.m_lValue);
    }

#endif // _DEBUG

protected:
    LONG m_lValue;
};



class COMDLL CIFloat : public CINumber
/*++

Class Description:

    International-friendly floating point number    

Public Interface:

--*/
{
public:
    //
    // Constructors
    //
    CIFloat(int nPrecision = 2);
    CIFloat(double flValue, int nPrecision = 2);
    CIFloat(LONG lInteger, LONG lFraction, int nPrecision = 2);
    CIFloat(LPCTSTR lpszValue, int nPrecision = 2);

public:
    //
    // Precision functions
    //
    int QueryPrecision() const;
    void SetPrecision(int nPrecision);

    //
    // Assignment Operators
    //
    CIFloat & operator =(double flValue);
    CIFloat & operator =(LPCTSTR lpszValue);

    //
    // Shorthand Operators
    //
    CIFloat & operator +=(const double flValue);
    CIFloat & operator +=(const LPCTSTR lpszValue);
    CIFloat & operator +=(const CIFloat& value);
    CIFloat & operator -=(const double flValue);
    CIFloat & operator -=(const LPCTSTR lpszValue);
    CIFloat & operator -=(const CIFloat& value);
    CIFloat & operator *=(const double flValue);
    CIFloat & operator *=(const LPCTSTR lpszValue);
    CIFloat & operator *=(const CIFloat& value);
    CIFloat & operator /=(const double flValue);
    CIFloat & operator /=(const LPCTSTR lpszValue);
    CIFloat & operator /=(const CIFloat& value);

    //
    // Conversion operators
    //
    operator const double() const;
    operator LPCTSTR() const;

    //
    // Persistence Operators
    //
    inline friend CArchive& AFXAPI operator<<(CArchive& ar, CIFloat& value)
    {
        return (ar << value.m_flValue);
    }

    inline friend CArchive& AFXAPI operator>>(CArchive& ar, CIFloat& value)
    {
        return (ar >> value.m_flValue);
    }

#ifdef _DEBUG

    //
    // CDumpContext stream operator
    //
    inline friend CDumpContext& AFXAPI operator<<(
        CDumpContext& dc, 
        const CIFloat& value
        )
    {
        return (dc << value.m_flValue);
    }

#endif // _DEBUG

protected:
    double m_flValue;
    int m_nPrecision;
};


//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline /* static */ BOOL CINumber::UseSystemDefault()
{
    return Initialize(FALSE);
}

inline /* static */ BOOL CINumber::UseUserDefault()
{
    return Initialize(TRUE);
}

inline /* static */ BOOL CINumber::IsInitialized()
{
    return s_fInitialized;
}

inline /* static */ LPCTSTR CINumber::QueryThousandSeperator()
{
    return (LPCTSTR)*s_pstrThousandSeperator;
}

inline /* static */ LPCTSTR CINumber::QueryDecimalPoint()
{
    return (LPCTSTR)*s_pstrDecimalPoint;
}

inline /* static */ LPCTSTR CINumber::QueryCurrency()
{
    return (LPCTSTR)*s_pstrCurrency;
}

inline /* static */ BOOL CINumber::IsAllocated()
{
    return s_fAllocated;
}

inline BOOL CILong::operator ==(LONG value)
{
    return m_lValue == value;
}

inline BOOL CILong::operator !=(CILong& value)
{
    return m_lValue != value.m_lValue;
}

inline CILong::operator const LONG() const
{
    return m_lValue;
}

inline CILong::operator LPCTSTR() const
{
    return CINumber::ConvertLongToString(m_lValue, *CINumber::s_pstr);
}

inline int CIFloat::QueryPrecision() const
{
    return m_nPrecision;
}

inline void CIFloat::SetPrecision(int nPrecision)
{
    m_nPrecision = nPrecision;
}

inline CIFloat::operator const double() const
{
    return m_flValue;
}

inline CIFloat::operator LPCTSTR() const
{
    return CINumber::ConvertFloatToString(
        m_flValue, 
        m_nPrecision, 
        *CINumber::s_pstr
        );
}

#endif // _STRFN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\comprop\usrbrows.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        usrbrows.cpp

   Abstract:

        User Browser Dialog

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include <iiscnfgp.h>
#include "comprop.h"

#include "objpick.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

extern "C"
{
    #define _NTSEAPI_   // Don't want the security API hdrs
    #include <getuser.h>
}

#define SZ_USER_CLASS 		_T("user")
#define SZ_GROUP_CLASS		_T("group")

BOOL
CAccessEntry::LookupAccountSid(
    OUT CString & strFullUserName,
    OUT int & nPictureID,
    IN  PSID pSid,
    IN  LPCTSTR lpstrSystemName /* OPTIONAL */
    )
/*++

Routine Description:

    Get a full user name and picture ID from the SID
    
Arguments:

    CString &strFullUserName        : Returns the user name
    int & nPictureID                : Returns offset into the imagemap that
                                      represents the account type.
    PSID pSid                       : Input SID pointer
    LPCTSTR lpstrSystemName         : System name or NULL
     
Return Value:

    TRUE for success, FALSE for failure.

--*/
{
    DWORD cbUserName = PATHLEN * sizeof(TCHAR);
    DWORD cbRefDomainName = PATHLEN * sizeof(TCHAR);

    CString strUserName;
    CString strRefDomainName;
    SID_NAME_USE SidToNameUse;

    LPTSTR lpUserName = strUserName.GetBuffer(PATHLEN);
    LPTSTR lpRefDomainName = strRefDomainName.GetBuffer(PATHLEN);
    BOOL fLookUpOK = ::LookupAccountSid(
        lpstrSystemName, 
        pSid, 
        lpUserName,
        &cbUserName, 
        lpRefDomainName, 
        &cbRefDomainName, 
        &SidToNameUse
        );

    strUserName.ReleaseBuffer();
    strRefDomainName.ReleaseBuffer();

    strFullUserName.Empty();

    if (fLookUpOK)
    {
        if (!strRefDomainName.IsEmpty()
            && strRefDomainName.CompareNoCase(_T("BUILTIN")))
        {
            strFullUserName += strRefDomainName;
            strFullUserName += "\\";
        }
        strFullUserName += strUserName;

        nPictureID = SidToNameUse;
    }
    else
    {
        strFullUserName.LoadString(IDS_UNKNOWN_USER);
        nPictureID = SidTypeUnknown;
    }

    //
    // SID_NAME_USE is 1-based
    //
    --nPictureID ;

    return fLookUpOK;
}


CAccessEntry::CAccessEntry(
    IN LPVOID pAce,
    IN BOOL fResolveSID
    )
/*++

Routine Description:

    Construct from an ACE

Arguments:

    LPVOID pAce         : Pointer to ACE object
    BOOL fResolveSID    : TRUE to resolve the SID immediately

Return Value:

    N/A

--*/
    : m_pSid(NULL),
      m_fSIDResolved(FALSE),
      m_fDeletable(TRUE),
      m_fInvisible(FALSE),
      m_nPictureID(SidTypeUnknown-1),   // SID_NAME_USE is 1-based
      m_lpstrSystemName(NULL),
      m_accMask(0L),
      m_fDeleted(FALSE),
      m_strUserName()
{
    MarkEntryAsClean();

    PACE_HEADER ph = (PACE_HEADER)pAce;
    PSID pSID = NULL;

    switch(ph->AceType)
    {
    case ACCESS_ALLOWED_ACE_TYPE:
        pSID = (PSID)&((PACCESS_ALLOWED_ACE)pAce)->SidStart;
        m_accMask = ((PACCESS_ALLOWED_ACE)pAce)->Mask;
        break;
        
    case ACCESS_DENIED_ACE_TYPE:
    case SYSTEM_AUDIT_ACE_TYPE:
    case SYSTEM_ALARM_ACE_TYPE:           
    default:
        //
        // Not supported!
        //
        ASSERT(FALSE);
        break;
    }

    if (pSID == NULL)
    {
        return;
    }

    //
    // Allocate a new copy of the sid.
    //
    DWORD cbSize = ::RtlLengthSid(pSID);
    m_pSid = (PSID)AllocMem(cbSize); 
    DWORD err = ::RtlCopySid(cbSize, m_pSid, pSID);
    ASSERT(err == ERROR_SUCCESS);

    //
    // Only the non-deletable administrators have execute
    // privileges
    //
    m_fDeletable = (m_accMask & FILE_EXECUTE) == 0L;

    //
    // Enum_keys is a special access right that literally "everyone"
    // has, but it doesn't designate an operator, so it should not
    // show up in the operator list if this is the only right it has.
    //
    m_fInvisible = (m_accMask == MD_ACR_ENUM_KEYS);
    
    //SetAccessMask(lpAccessEntry);

    if (fResolveSID)
    {
        ResolveSID();
    }
}



CAccessEntry::CAccessEntry(
    IN ACCESS_MASK accPermissions,
    IN PSID pSid,
    IN LPCTSTR lpstrSystemName,     OPTIONAL
    IN BOOL fResolveSID
    )
/*++

Routine Description:

    Constructor from access permissions and SID.

Arguments:

    ACCESS_MASK accPermissions      : Access mask
    PSID pSid                       : Pointer to SID
    LPCTSTR lpstrSystemName         : Optional system name
    BOOL fResolveSID                : TRUE to resolve SID immediately

Return Value:

    N/A


--*/
    : m_pSid(NULL),
      m_fSIDResolved(FALSE),
      m_fDeletable(TRUE),
      m_fInvisible(FALSE),
      m_fDeleted(FALSE),
      m_nPictureID(SidTypeUnknown-1),   // SID_NAME_USE is 1-based
      m_strUserName(),
      m_lpstrSystemName(NULL),
      m_accMask(accPermissions)
{
    MarkEntryAsClean();

    //
    // Allocate a new copy of the sid.
    //
    DWORD cbSize = ::RtlLengthSid(pSid);
    m_pSid = (PSID)AllocMem(cbSize); 
    DWORD err = ::RtlCopySid(cbSize, m_pSid, pSid);
    ASSERT(err == ERROR_SUCCESS);

    if (lpstrSystemName != NULL)
    {
        m_lpstrSystemName = AllocTString(::lstrlen(lpstrSystemName) + 1);
        ::lstrcpy(m_lpstrSystemName, lpstrSystemName);
    }

    if (fResolveSID)
    {
        TRACEEOLID("Bogus SID");
        ResolveSID();
    }
}

CAccessEntry::CAccessEntry(
    IN PSID pSid,
    IN LPCTSTR pszUserName,
    IN LPCTSTR pszClassName
    )
    : m_pSid(NULL),
      m_fSIDResolved(pszUserName != NULL),
      m_fDeletable(TRUE),
      m_fInvisible(FALSE),
      m_fDeleted(FALSE),
      m_nPictureID(SidTypeUnknown-1),   // SID_NAME_USE is 1-based
      m_strUserName(pszUserName),
      m_lpstrSystemName(NULL),
      m_accMask(0)
{
    MarkEntryAsClean();
    //
    // Allocate a new copy of the sid.
    //
    DWORD cbSize = ::RtlLengthSid(pSid);
    m_pSid = (PSID)AllocMem(cbSize); 
    DWORD err = ::RtlCopySid(cbSize, m_pSid, pSid);
    ASSERT(err == ERROR_SUCCESS);
	if (lstrcmpi(SZ_USER_CLASS, pszClassName) == 0)
		m_nPictureID = SidTypeUser - 1;
	else if (lstrcmpi(SZ_GROUP_CLASS, pszClassName) == 0)
		m_nPictureID = SidTypeGroup - 1;
}

CAccessEntry::CAccessEntry(
	IN CAccessEntry& ae
	)
    : m_fSIDResolved(ae.m_fSIDResolved),
      m_fDeletable(ae.m_fDeletable),
      m_fInvisible(ae.m_fInvisible),
      m_fDeleted(ae.m_fDeleted),
	  m_fDirty(ae.m_fDirty),
      m_nPictureID(ae.m_nPictureID),
      m_strUserName(ae.m_strUserName),
      m_lpstrSystemName(ae.m_lpstrSystemName),
      m_accMask(ae.m_accMask)
{
    DWORD cbSize = ::RtlLengthSid(ae.m_pSid);
    m_pSid = (PSID)AllocMem(cbSize); 
    DWORD err = ::RtlCopySid(cbSize, m_pSid, ae.m_pSid);
    ASSERT(err == ERROR_SUCCESS);
}

CAccessEntry::~CAccessEntry()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    TRACEEOLID(_T("Destroying local copy of the SID"));
    ASSERT(m_pSid != NULL);
    FreeMem(m_pSid);
    if (m_lpstrSystemName != NULL)
    {
        FreeMem(m_lpstrSystemName);
    }
}




BOOL
CAccessEntry::ResolveSID()
/*++

Routine Description:

    Look up the user name and type.

Arguments:

    None

Return Value:

    TRUE for success, FALSE for failure.

Notes:

    This could take some time.

--*/
{
    //
    // Even if it fails, it will be considered
    // resolved
    //
    m_fSIDResolved = TRUE;   

    return CAccessEntry::LookupAccountSid(
        m_strUserName,
        m_nPictureID,
        m_pSid,
        m_lpstrSystemName
        );
}



void 
CAccessEntry::AddPermissions(
    IN ACCESS_MASK accNewPermissions
    )
/*++

Routine Description:

   Add permissions to this entry.

Arguments:

    ACCESS_MASK accNewPermissions       : New access permissions to be added

Return Value:

    None.

--*/
{
    m_accMask |= accNewPermissions;
    m_fInvisible = (m_accMask == MD_ACR_ENUM_KEYS);
    m_fDeletable = (m_accMask & FILE_EXECUTE) == 0L;
    MarkEntryAsChanged();
}



void 
CAccessEntry::RemovePermissions(
    IN ACCESS_MASK accPermissions
    )
/*++

Routine Description:

    Remove permissions from this entry.

Arguments:

    ACCESS_MASK accPermissions          : Access permissions to be taken away

--*/
{
    m_accMask &= ~accPermissions;
    MarkEntryAsChanged();
}

//
// Helper Functions
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



PSID
GetOwnerSID()
/*++

Routine Description:

    Return a pointer to the primary owner SID we're using.

Arguments:

    None

Return Value:

    Pointer to owner SID.

--*/
{
    PSID pSID = NULL;

    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;

    if (!::AllocateAndInitializeSid(
        &NtAuthority, 
        2,
        SECURITY_BUILTIN_DOMAIN_RID,
        DOMAIN_ALIAS_RID_ADMINS, 
        0, 0, 0, 0, 0, 0,
        &pSID
        ))
    {
        TRACEEOLID("Unable to get primary SID " << ::GetLastError());
    }

    return pSID;
}



BOOL
BuildAclBlob(
    IN  CObListPlus & oblSID,
    OUT CBlob & blob
    )
/*++

Routine Description:

    Build a security descriptor blob from the access entries in the oblist

Arguments:

    CObListPlus & oblSID    : Input list of access entries
    CBlob & blob            : Output blob
    
Return Value:

    TRUE if the list is dirty.  If the list had no entries marked
    as dirty, the blob generated will be empty, and this function will
    return FALSE.

Notes:

    Entries marked as deleted will not be added to the list.

--*/
{
    ASSERT(blob.IsEmpty());

    BOOL fAclDirty = FALSE;
    CAccessEntry * pEntry;

    DWORD dwAclSize = sizeof(ACL) - sizeof(DWORD);
    CObListIter obli(oblSID);
    int cItems = 0;
    while(pEntry = (CAccessEntry *)obli.Next())
    {
        if (!pEntry->IsDeleted())
        {
            dwAclSize += GetLengthSid(pEntry->GetSid());
            dwAclSize += sizeof(ACCESS_ALLOWED_ACE);
            ++cItems;
        }

        if (pEntry->IsDirty())
        {
            fAclDirty = TRUE;
        }
    }

    if (fAclDirty)
    {
        //
        // Build the acl
        //
        PACL pacl = NULL;

        try
        {
            if (cItems > 0 && dwAclSize > 0)
            {
                pacl = (PACL)AllocMem(dwAclSize);
                if (InitializeAcl(pacl, dwAclSize, ACL_REVISION))
                {
                    obli.Reset();    
                    while(pEntry = (CAccessEntry *)obli.Next())
                    {
                        if (!pEntry->IsDeleted())
                        {
                            BOOL f = AddAccessAllowedAce(
                                pacl, 
                                ACL_REVISION, 
                                pEntry->QueryAccessMask(),
                                pEntry->GetSid()
                                );
                            ASSERT(f);
                        }
                    }
                }
            }

            //
            // Build the security descriptor
            //
            PSECURITY_DESCRIPTOR pSD = 
                (PSECURITY_DESCRIPTOR)AllocMem(SECURITY_DESCRIPTOR_MIN_LENGTH);
            VERIFY(InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION));
            VERIFY(SetSecurityDescriptorDacl(pSD, TRUE, pacl, FALSE));

            //
            // Set owner and primary group
            //
            PSID pSID = GetOwnerSID();
            ASSERT(pSID);
            VERIFY(SetSecurityDescriptorOwner(pSD, pSID, TRUE));
            VERIFY(SetSecurityDescriptorGroup(pSD, pSID, TRUE));
        
            //
            // Convert to self-relative
            //
            PSECURITY_DESCRIPTOR pSDSelfRelative = NULL;
            DWORD dwSize = 0L;
            MakeSelfRelativeSD(pSD, pSDSelfRelative, &dwSize);
            pSDSelfRelative = AllocMem(dwSize);
            MakeSelfRelativeSD(pSD, pSDSelfRelative, &dwSize);

            //
            // Blob takes ownership 
            //
            blob.SetValue(dwSize, (PBYTE)pSDSelfRelative, FALSE);

            //
            // Clean up
            //
            FreeMem(pSD);
            FreeSid(pSID);
        }
        catch(CMemoryException * e)
        {
            e->ReportError();
            e->Delete();
        }
    }

    return fAclDirty;
}



DWORD
BuildAclOblistFromBlob(
    IN  CBlob & blob,
    OUT CObListPlus & oblSID
    )
/*++

Routine Description:

    Build an oblist of access entries from a security descriptor blob

Arguments:

    CBlob & blob            : Input blob
    CObListPlus & oblSID    : Output oblist of access entries
    
Return Value:

    Error return code

--*/
{
    PSECURITY_DESCRIPTOR pSD = NULL;

    if (!blob.IsEmpty())
    {
        pSD = (PSECURITY_DESCRIPTOR)blob.GetData();
    }

    if (pSD == NULL)
    {
        //
        // Empty...
        //
        return ERROR_SUCCESS;
    }

    if (!IsValidSecurityDescriptor(pSD))
    {
        return ::GetLastError();
    }

    ASSERT(GetSecurityDescriptorLength(pSD) == blob.GetSize());

    PACL pacl;
    BOOL fDaclPresent;
    BOOL fDaclDef;

    VERIFY(GetSecurityDescriptorDacl(pSD, &fDaclPresent, &pacl, &fDaclDef));

    if (!fDaclPresent || pacl == NULL)
    {
        return ERROR_SUCCESS;
    }

    if (!IsValidAcl(pacl))
    {
        return GetLastError();
    }

    CError err;
    for (WORD w = 0; w < pacl->AceCount; ++w)
    {
        PVOID pAce;
        if (GetAce(pacl, w, &pAce))
        {
            CAccessEntry * pEntry = new CAccessEntry(pAce, TRUE);
            oblSID.AddTail(pEntry);
        }
        else
        {
            //
            // Save last error, but continue
            //
            err.GetLastWinError();
        }
    }

    //
    // Return last error
    //
    return err;
}



//
// CAccessEntryListBox - a listbox of user SIDs
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



IMPLEMENT_DYNAMIC(CAccessEntryListBox, CRMCListBox);



const int CAccessEntryListBox::nBitmaps = 8;



void
CAccessEntryListBox::DrawItemEx(
    IN CRMCListBoxDrawStruct& ds
    )
/*++

Routine Description:

   Draw item in the listbox

Arguments:

    CRMCListBoxDrawStruct & ds   : Input data structure

Return Value:

    N/A

--*/
{
    CAccessEntry * pEntry = (CAccessEntry *)ds.m_ItemData;
    ASSERT(pEntry != NULL);
    ASSERT(pEntry->IsSIDResolved());

    DrawBitmap(ds, 0, pEntry->QueryPictureID());
    ColumnText(ds, 0, TRUE, pEntry->QueryUserName());
}



void
CAccessEntryListBox::FillAccessListBox(
    IN CObListPlus & obl
    )
/*++

Routine Description:

    Fill a listbox with entries from the oblist.

    Entries will not be shown if the deleted flag is set, or if
    their access mask does not fit with the requested access mask.

Arguments:

    CObListPlus & obl       : List of access entries

Return Value:

    None.

--*/
{
    CObListIter obli(obl);
    CAccessEntry * pAccessEntry;

    //
    // Remember the selection.
    //
    CAccessEntry * pSelEntry = GetSelectedItem();

    SetRedraw(FALSE);
    ResetContent();
    int cItems = 0;

    for ( /**/ ; pAccessEntry = (CAccessEntry *)obli.Next(); ++cItems)
    {
        if (pAccessEntry->IsVisible() && !pAccessEntry->IsDeleted())
        {
            AddItem(pAccessEntry);
        }
    }

    SetRedraw(TRUE);
    SelectItem(pSelEntry);
}



void 
CAccessEntryListBox::ResolveAccessList(
    IN CObListPlus &obl
    )
/*++

Routine Description:

    For each member of the list, resolve the SID into a username.

Arguments:

    CObListPlus & obl       : List of access entries

Return Value:

    None.

--*/
{
    CObListIter obli(obl);
    CAccessEntry * pAccessEntry;

    while (pAccessEntry = (CAccessEntry *)obli.Next())
    {
        if (!pAccessEntry->IsSIDResolved())
        {
            pAccessEntry->ResolveSID();
        }
    }
}



BOOL
CAccessEntryListBox::AddUserPermissions(
    IN LPCTSTR lpstrServer,
    IN CObListPlus &oblSID,
    IN CAccessEntry * newUser,
    IN ACCESS_MASK accPermissions
    )
/*++

Routine Description:

    Add a user to the service list.  The return value is
    the what would be its listbox index.

Arguments:

    LPCTSTR lpstrServer             : Server name
    CObListPlus &oblSID             : List of SIDs
    LPUSERDETAILS pusdtNewUser      : User details from user browser
    ACCESS_MASK accPermissions      : Access permissions

Return Value:

    TRUE for success, FALSE for failure.

--*/
{
    CAccessEntry * pAccessEntry;
    //
    // Look it up in the list to see if it exists already
    //
    CObListIter obli(oblSID);

    while(pAccessEntry = (CAccessEntry *)obli.Next())
    {
        if (*pAccessEntry == newUser->GetSid())
        {
            TRACEEOLID("Found existing account -- adding permissions");
            if (pAccessEntry->IsDeleted())
            {
                //
                // Back again..
                //
                pAccessEntry->FlagForDeletion(FALSE);
            }
            break;
        }
    }

    if (pAccessEntry == NULL)
    {
        // I am creating new entry here to be sure that I could delete it from 
        // the input array. SID is copied to new entry.
        pAccessEntry = new CAccessEntry(*newUser);
        if (pAccessEntry == NULL)
            return FALSE;
        pAccessEntry->MarkEntryAsNew();
        oblSID.AddTail(pAccessEntry);
    }
    pAccessEntry->AddPermissions(accPermissions);

    return TRUE;
}



BOOL
CAccessEntryListBox::AddToAccessList(
    IN  CWnd * pWnd,
    IN  LPCTSTR lpstrServer,
    OUT CObListPlus & obl
    )
/*++

Routine Description:

    Bring up the Add Users and Groups dialogs from netui.

Arguments:

    CWnd * pWnd             : Parent window
    LPCTSTR lpstrServer     : Server that owns the accounts
    CObListPlus & obl       : Returns the list of selected users.

Return Value:

    TRUE if anything was added, FALSE otherwise.

--*/
{
    CGetUsers usrBrowser(lpstrServer, TRUE);
    BOOL bRes = usrBrowser.GetUsers(pWnd->GetSafeHwnd());
    UINT cItems = 0;
    if (bRes)
    {
        //
        // Specify access mask for an operator
        //
        ACCESS_MASK accPermissions =
            (MD_ACR_READ | MD_ACR_WRITE | MD_ACR_ENUM_KEYS);
        for (int i = 0; i < usrBrowser.GetSize(); i++)
        {
            if (!AddUserPermissions(lpstrServer, obl, usrBrowser[i], accPermissions))
            {
                bRes = FALSE;
                break;
            }
            cItems++;
        }
    }
    if (cItems > 0)
    {
        FillAccessListBox(obl);
    }
    return bRes;
#if 0
    USERBROWSER ub;
    CError err;

    //
    // Specify access mask for an operator
    //
    ACCESS_MASK accPermissions =
        (MD_ACR_READ | MD_ACR_WRITE | MD_ACR_ENUM_KEYS);

    CString strDomain(lpstrServer);

    //
    // Ensure the computer name starts with
    // backslashes
    //
    if (strDomain[0] != _T('\\'))
    {
        strDomain = _T("\\\\") + strDomain;
    }

    CString strTitle;
    VERIFY(strTitle.LoadString(IDS_SELECT_ADMIN));

    ub.ulStructSize = sizeof(ub);
    ub.fUserCancelled = FALSE;
    ub.fExpandNames = FALSE;
    ub.hwndOwner = pWnd ? pWnd->m_hWnd : NULL;
    ub.pszTitle = NULL;
    ub.pszInitialDomain = (LPTSTR)(LPCTSTR)strDomain;
    ub.Flags = USRBROWS_INCL_EVERYONE
             | USRBROWS_SHOW_ALL
             | USRBROWS_EXPAND_USERS;
    ub.pszHelpFileName = NULL;
    ub.ulHelpContext = IDHELP_MULT_USRBROWSER;
    CWinApp * pApp = ::AfxGetApp();
    ASSERT(pApp);
    if (pApp)
    {
        ub.pszHelpFileName = (LPTSTR)(LPCTSTR)pApp->m_pszHelpFilePath;
    }

    HUSERBROW hUserBrowser = ::OpenUserBrowser(&ub);
    if (hUserBrowser == NULL)
    {
        err.GetLastWinError();
        err.MessageBoxOnFailure(MB_OK | MB_ICONHAND);

        return FALSE;
    }

    int cItems = 0;
    if (!ub.fUserCancelled)
    {
        //
        // Selected users are granted the new privilege
        //
        try
        {
            //
            // We break out of this loop ourselves
            //
            for ( ;; )
            {
                LPUSERDETAILS pusdtNewUser;
                DWORD cbSize;

                //
                // First call should always fail, but tell
                // us the size required.
                //
                cbSize = 0;
                EnumUserBrowserSelection(hUserBrowser, NULL, &cbSize);
                err.GetLastWinError();
                if (err.Win32Error() == ERROR_NO_MORE_ITEMS)
                {
                    //
                    // All done
                    //
                    err.Reset();
                    break;
                }

                if (err.Win32Error() == ERROR_INSUFFICIENT_BUFFER)
                {
                    err.Reset();
                } 

                if (err.Failed())
                {
                    break;
                }

                //
                // The EnumUserBrowserSelection API has a bug in which
                // the size returned might actually by insufficient.
                //
                cbSize += 100;
                TRACEEOLID("Enum structure size requested is " << cbSize);
                pusdtNewUser = (LPUSERDETAILS)AllocMem(cbSize);
                if (pusdtNewUser == NULL)
                {
                    err.GetLastWinError();
                    break;
                }

                if (!EnumUserBrowserSelection(
                    hUserBrowser,
                    pusdtNewUser,
                    &cbSize
                    ))
                {
                    err.GetLastWinError();
                    break;
                }

                TRACEEOLID("Adding user " << pusdtNewUser->pszAccountName);
                AddUserPermissions(
                    lpstrServer,
                    obl,
                    pusdtNewUser,
                    accPermissions
                    );
                ++cItems;

                FreeMem(pusdtNewUser);

                if (err.Failed())
                {
                    break;
                }
            }
        }
        catch(CException * e)
        {
            err.GetLastWinError();

            TRACEEOLID("Exception generated while enumerating users");
            e->Delete();
        }
    }

    err.MessageBoxOnFailure();
    ::CloseUserBrowser(hUserBrowser);

    if (cItems > 0)
    {
        FillAccessListBox(obl);
        return TRUE;
    }

    return FALSE;
#endif
}



static
int 
BrowseCallbackProc(
   IN HWND hwnd,    
   IN UINT uMsg,    
   IN LPARAM lParam,    
   IN LPARAM lpData 
   )
/*++

Routine Description:

    Callback function for the folder browser

Arguments:

    hwnd     : Handle to the browse dialog box. The callback function can 
               send the following messages to this window:

               BFFM_ENABLEOK      Enables the OK button if the wParam parameter 
                                  is nonzero or disables it if wParam is zero.
               BFFM_SETSELECTION  Selects the specified folder. The lParam 
                                  parameter is the PIDL of the folder to select 
                                  if wParam is FALSE, or it is the path of the 
                                  folder otherwise.
               BFFM_SETSTATUSTEXT Sets the status text to the null-terminated 
                                  string specified by the lParam parameter.
 
    uMsg     : Value identifying the event. This parameter can be one of the 
               following values:

               0                  Initialize dir path.  lParam is the path.

               BFFM_INITIALIZED   The browse dialog box has finished 
                                  initializing. lpData is NULL.
               BFFM_SELCHANGED    The selection has changed. lpData 
                                  is a pointer to the item identifier list for 
                                  the newly selected folder.
 
    lParam   : Message-specific value. For more information, see the 
               description of uMsg.

    lpData   : Application-defined value that was specified in the lParam 
               member of the BROWSEINFO structure.

Return Value:

    0

--*/
{
    static LPCTSTR lpstrDomain = NULL;

    switch(uMsg)
    {
    case 0:
        lpstrDomain = (LPCTSTR)lParam;
        break;

    case BFFM_INITIALIZED:
        //
        // Dialog initialized -- select desired folder
        //
        if (lpstrDomain != NULL)
        {
            ::SendMessage(hwnd, BFFM_SETSELECTION, TRUE, (LPARAM)lpstrDomain);
        }
        break;
    }

    return 0;
}



CBrowseDomainDlg::CBrowseDomainDlg(
    IN CWnd * pParent            OPTIONAL,
    IN LPCTSTR lpszInitialDomain OPTIONAL
    )
/*++

Routine Description:

    Constructor for domain browser dialog

Arguments:

    CWnd * pParent            : Parent window or NULL
    LPCTSTR lpszInitialDomain : Initial domain, or NULL

Return Value:

    N/A

--*/
    : m_strInitialDomain(lpszInitialDomain)
{
    VERIFY(m_strTitle.LoadString(IDS_BROWSE_DOMAIN));

    m_bi.pidlRoot = NULL;
    m_bi.hwndOwner = pParent ? pParent->m_hWnd : NULL;
    m_bi.pszDisplayName = m_szBuffer;
    m_bi.lpszTitle = m_strTitle;
    m_bi.ulFlags = BIF_DONTGOBELOWDOMAIN;
    m_bi.lpfn = BrowseCallbackProc;
    m_bi.lParam = 0;

    //
    // Let the callback function know the default dir is
    //
    lpszInitialDomain = !m_strInitialDomain.IsEmpty() 
        ? (LPCTSTR)m_strInitialDomain
        : NULL;
    BrowseCallbackProc(m_bi.hwndOwner, 0, (LPARAM)lpszInitialDomain, NULL);

    //
    // Only display network items
    //
    LPITEMIDLIST  pidl;
    if (SUCCEEDED(::SHGetSpecialFolderLocation(m_bi.hwndOwner,  
        CSIDL_NETWORK, &pidl)))
    {
        m_bi.pidlRoot = pidl;
    }
}



CBrowseDomainDlg::~CBrowseDomainDlg()
/*++

Routine Description:

    Destructor for directory browser dialog

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    if (m_bi.pidlRoot != NULL)
    {
        LPITEMIDLIST pidl = (LPITEMIDLIST)m_bi.pidlRoot;

        //
        // Free using shell allocator
        //
        LPMALLOC pMalloc;
        if (::SHGetMalloc(&pMalloc) == NOERROR)
        {
            pMalloc->Free(pidl);
            pMalloc->Release();
        }
    }
}



/* virtual */
int 
CBrowseDomainDlg::DoModal()
/*++

Routine Description:

    Display the browser dialog, and fill in the selected domain.

Arguments:

    None

Return Value:

    IDOK if the OK button was pressed, IDCANCEL otherwise.

--*/
{
    BOOL fSelectionMade = FALSE;

    //
    // Gets the Shell's default allocator 
    //
    LPMALLOC pMalloc;
    if (::SHGetMalloc(&pMalloc) == NOERROR)
    {
        LPITEMIDLIST pidl;

        if ((pidl = ::SHBrowseForFolder(&m_bi)) != NULL)
        {
            //
            // m_szBuffer contains the selected path already
            //
            fSelectionMade = TRUE;

            //
            // Free the PIDL allocated by SHBrowseForFolder.
            //
            pMalloc->Free(pidl);
        }

        //
        // Release the shell's allocator.
        //
        pMalloc->Release();
    }

    return fSelectionMade ? IDOK : IDCANCEL;
}



LPCTSTR
CBrowseDomainDlg::GetSelectedDomain(
    OUT CString & strName
    ) const
/*++

Routine Description:

    Get the selected domain

Arguments:

    CString & strName  : String in which to return the domain

Return Value:

    A pointer to the domain string or NULL in case of error.

Notes:

    This function should be called only after the dialog has been dismissed.

--*/
{
    LPCTSTR lp = NULL;

    try
    {
        strName = m_szBuffer;
        lp = strName;
    }
    catch(CMemoryException * e)
    {
        TRACEEOLID("!!!exception getting path");
        e->ReportError();
        e->Delete();
        strName.Empty();
    }

    return lp;
}



CBrowseUserDlg::CBrowseUserDlg(
    IN CWnd * pParentWnd OPTIONAL,
    IN LPCTSTR lpszTitle,
    IN LPCTSTR lpszInitialDomain,
    IN BOOL fExpandNames,
    IN BOOL fSkipInitialDomainInName,
    IN DWORD dwFlags,
    IN LPCTSTR lpszHelpFileName,
    IN ULONG ulHelpContext
    )
/*++

Routine Description:

    Constructor for user browser dialog

Arguments:

    CWnd * pParentWnd             : Parent window
    LPCTSTR lpszTitle             : Dialog title text
    LPCTSTR lpszInitialDomain     : Initial domain name
    BOOL fExpandNames             : Expand the names
    BOOL fSkipInitialDomainInName : Skip the initial domain when expanding
    DWORD dwFlags                 : Flags
    LPCTSTR lpszHelpFileName      : Help file path and name
    ULONG ulHelpContext           : Help context ID

Return Value:

    N/A

--*/
    : m_fSkipInitialDomainInName(fSkipInitialDomainInName),
      m_strTitle(lpszTitle),
      m_strInitialDomain(lpszInitialDomain),
      m_strHelpFileName(lpszHelpFileName)
{
    m_ub.ulStructSize = sizeof(m_ub);
    m_ub.fExpandNames = fExpandNames;
    m_ub.hwndOwner = pParentWnd->m_hWnd;
    m_ub.pszTitle = (LPTSTR)(LPCTSTR)m_strTitle;
    m_ub.pszInitialDomain = (LPTSTR)(LPCTSTR)m_strInitialDomain;
    m_ub.Flags = dwFlags;
    m_ub.pszHelpFileName = (LPTSTR)(LPCTSTR)m_strHelpFileName;
    m_ub.ulHelpContext = ulHelpContext;
}



/* virtual */
int
CBrowseUserDlg::DoModal()
/*++

Routine Description:

    Show the user browser dialog

Arguments:

    None

Return Value:

    IDOK if the OK button was pressed, IDCANCEL if the dialog
    was cancelled.

--*/
{
    CError err;

    m_ub.fUserCancelled = FALSE;
    m_strSelectedAccounts.RemoveAll();

    HUSERBROW hUserBrowser = ::OpenUserBrowser(&m_ub);
    if (hUserBrowser == NULL)
    {
        err.GetLastWinError();
        err.MessageBoxOnFailure(MB_OK | MB_ICONHAND);

        return IDCANCEL;
    }

    if (!m_ub.fUserCancelled)
    {
        try
        {
            CString strInitialDomain(PURE_COMPUTER_NAME(m_ub.pszInitialDomain));

            //
            // We break out of this loop ourselves
            //
            for ( ;; )
            {
                LPUSERDETAILS pusdtNewUser;
                DWORD cbSize;

                //
                // First call should always fail, but tell
                // us the size required.
                //
                cbSize = 0;
                EnumUserBrowserSelection(hUserBrowser, NULL, &cbSize);
                err.GetLastWinError();
                if (err.Win32Error() == ERROR_NO_MORE_ITEMS)
                {
                    //
                    // All done
                    //
                    err.Reset();
                    break;
                }

                if (err.Win32Error() == ERROR_INSUFFICIENT_BUFFER)
                {
                    err.Reset();
                } 

                if (err.Failed())
                {
                    break;
                }

                //
                // The EnumUserBrowserSelection API has a bug in which
                // the size returned might actually be insufficient.
                //
                cbSize += 100;
                TRACEEOLID("Enum structure size requested is " << cbSize);
                pusdtNewUser = (LPUSERDETAILS)AllocMem(cbSize);
                if (pusdtNewUser == NULL)
                {
                    err.GetLastWinError();
                    break;
                }

                if (!EnumUserBrowserSelection(
                    hUserBrowser,
                    pusdtNewUser,
                    &cbSize
                    ))
                {
                    err.GetLastWinError();
                    break;
                }

                TRACEEOLID("Adding user " << pusdtNewUser->pszAccountName);

                CString strAccount;

                //
                // If the domain name doesn't match that of the 
                // intial domain, add it as well.
                //
                if (!m_fSkipInitialDomainInName ||
                    strInitialDomain.CompareNoCase(pusdtNewUser->pszDomainName) != 0)
                {
                    strAccount += pusdtNewUser->pszDomainName;
                    strAccount += _T('\\');
                }

                strAccount += pusdtNewUser->pszAccountName;
                m_strSelectedAccounts.AddTail(strAccount);

                FreeMem(pusdtNewUser);

                if (err.Failed())
                {
                    break;
                }
            }
        }
        catch(CMemoryException * e)
        {
            TRACEEOLID("!!!exception generated while enumerating users");
            err = ERROR_NOT_ENOUGH_MEMORY;
            e->Delete();
        }
    }

    err.MessageBoxOnFailure();
    ::CloseUserBrowser(hUserBrowser);

    return m_ub.fUserCancelled ? IDCANCEL : IDOK;
}



//
// CUserAccountDlg dialog
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



CUserAccountDlg::CUserAccountDlg(
    IN LPCTSTR lpstrServer,
    IN LPCTSTR lpstrUserName,
    IN LPCTSTR lpstrPassword,
    IN CWnd * pParent OPTIONAL
    )
/*++

Routine Description:

    Constructor for bringing up the user account dialog

Arguments:

    LPCTSTR lpstrServer     : Server
    LPCTSTR lpstrUserName   : Starting Username
    LPCTSTR lpstrPassword   : Starting Password
    CWnd * pParent          : Parent window handle

Return Value:

    N/A

--*/
    : m_strUserName(lpstrUserName),
      m_strPassword(lpstrPassword),
      m_strServer(lpstrServer),
      CDialog(CUserAccountDlg::IDD, pParent)
{
    //{{AFX_DATA_INIT(CUserAccountDlg)
    //}}AFX_DATA_INIT
}



void 
CUserAccountDlg::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control Data

Arguments:

    CDataExchange * pDX : DDX/DDV struct

Return Value:

    None.

--*/
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CUserAccountDlg)
    DDX_Control(pDX, IDC_EDIT_USERNAME, m_edit_UserName);
    DDX_Control(pDX, IDC_EDIT_PASSWORD, m_edit_Password);
    //}}AFX_DATA_MAP

    //
    // Private DDX/DDV Routines
    //
    DDX_Text(pDX, IDC_EDIT_USERNAME, m_strUserName);
    DDV_MinMaxChars(pDX, m_strUserName, 1, UNLEN);
    DDX_Password(pDX, IDC_EDIT_PASSWORD, m_strPassword, g_lpszDummyPassword);
    DDV_MaxChars(pDX, m_strPassword, PWLEN);
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CUserAccountDlg, CDialog)
    //{{AFX_MSG_MAP(CUserAccountDlg)
    ON_BN_CLICKED(IDC_BUTTON_BROWSE_USERS, OnButtonBrowseUsers)
    ON_BN_CLICKED(IDC_BUTTON_CHECK_PASSWORD, OnButtonCheckPassword)
    ON_EN_CHANGE(IDC_EDIT_USERNAME, OnChangeEditUsername)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

BOOL
GetIUsrAccount(
    IN  LPCTSTR lpstrServer,
    IN  CWnd * pParent,      OPTIONAL
    OUT CString & str
    )
/*++

Routine Description:

    Helper function to browse for IUSR Account

Arguments:

    LPCTSTR lpstrServer : Server
    CWnd * pParent      : Parent window
    CString & str       : Will contain the selected account

Return Value:

    TRUE if an account was selected FALSE if not

--*/
{
    CGetUsers usrBrowser(lpstrServer);
    BOOL bRes = usrBrowser.GetUsers(pParent->GetSafeHwnd(), TRUE);
    if (bRes)
    {
       if (usrBrowser.GetSize() != 0)
       {
         str = usrBrowser.GetAt(0)->QueryUserName();
       }
       else
          bRes = FALSE;
    }
    return bRes;
#if 0
    CString strDomain(lpstrServer);

    //
    // Ensure the computer name starts with
    // backslashes
    //
    if (strDomain[0] != _T('\\'))
    {
        strDomain = _T("\\\\") + strDomain;
    }

    CString strTitle;
    LPCTSTR lpszHelpPath = NULL;
    ULONG ulHelpID = IDHELP_USRBROWSER;

    VERIFY(strTitle.LoadString(IDS_SELECT_IUSR_ACCOUNT));
    CWinApp * pApp = ::AfxGetApp();
    ASSERT(pApp);
    if (pApp)
    {
        lpszHelpPath = pApp->m_pszHelpFilePath;
    }

    CBrowseUserDlg dlg(
        pParent,
        strTitle,
        strDomain,
        FALSE,
        TRUE,
        USRBROWS_EXPAND_USERS
        | USRBROWS_SINGLE_SELECT
        | USRBROWS_SHOW_USERS,
        lpszHelpPath,
        ulHelpID
        );

    if (dlg.DoModal() == IDOK
     && dlg.GetSelectionCount() > 0)
    {
        str = dlg.GetSelectedAccounts().GetHead();
        return TRUE;
    }

    return FALSE;
#endif
}



DWORD
VerifyUserPassword(
    IN LPCTSTR lpstrUserName,
    IN LPCTSTR lpstrPassword
    )
/*++

Routine Description:

    Verify the usernamer password combo checks out

Arguments:

    LPCTSTR lpstrUserName   : Domain/username combo
    LPCTSTR lpstrPassword   : Password

Return Value:

    ERROR_SUCCESS if the password checks out, an error code
    otherwise.

--*/
{
    CString strDomain;
    CString strUser(lpstrUserName);
    CString strPassword(lpstrPassword);

    SplitUserNameAndDomain(strUser, strDomain);

    //
    // In order to look up an account name, this process
    // must first be granted the privilege of doing so.
    //
    CError err;
    {
        HANDLE hToken;
        LUID AccountLookupValue;
        TOKEN_PRIVILEGES tkp;

        do
        {
            if (!OpenProcessToken(GetCurrentProcess(),
                TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                &hToken)
                )
            {
                err.GetLastWinError();
                break;
            }
            if (!LookupPrivilegeValue(NULL, SE_TCB_NAME, &AccountLookupValue))
            {
                err.GetLastWinError();
                break;
            }

            tkp.PrivilegeCount = 1;
            tkp.Privileges[0].Luid = AccountLookupValue;
            tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

            AdjustTokenPrivileges(
                hToken,
                FALSE,
                &tkp,
                sizeof(TOKEN_PRIVILEGES),
                (PTOKEN_PRIVILEGES)NULL,
                (PDWORD)NULL
                );

            err.GetLastWinError();
            if (err.Failed())
            {
                break;
            }

            HANDLE hUser = NULL;
            if (LogonUser(
                strUser.GetBuffer(0),
                strDomain.GetBuffer(0),
                strPassword.GetBuffer(0),
                LOGON32_LOGON_NETWORK,
                LOGON32_PROVIDER_DEFAULT,
                &hUser
                ))
            {
                //
                // Success!
                //
                CloseHandle(hUser);
            }
            else
            {
                err.GetLastWinError();
            }

            //
            // Remove the privilege
            //
        }
        while(FALSE);
    }

    HANDLE hUser = NULL;
    if (LogonUser(
        strUser.GetBuffer(0),
        strDomain.GetBuffer(0),
        strPassword.GetBuffer(0),
        LOGON32_LOGON_NETWORK,
        LOGON32_PROVIDER_DEFAULT,
        &hUser))
    {
        //
        // Success!
        //
        CloseHandle(hUser);
    }
    else
    {
        err.GetLastWinError();
    }

    return err;
}



void
CUserAccountDlg::OnButtonBrowseUsers()
/*++

Routine Description:

    User browse dialog pressed, bring up
    the user browser

Arguments:

    None

Return Value:

    None

--*/
{
    CString str;

    if (GetIUsrAccount(m_strServer, this, str))
    {
        //
        // If a name was selected, blank
        // out the password
        //
        m_edit_UserName.SetWindowText(str);
        m_edit_Password.SetFocus();
    }
}



void 
CUserAccountDlg::OnChangeEditUsername() 
/*++

Routine Description:

    Handle change in user name edit box by blanking out the password

Arguments:

    None

Return Value:

    None

--*/
{
    m_edit_Password.SetWindowText(_T(""));
}



void
CUserAccountDlg::OnButtonCheckPassword()
/*++

Routine Description:

    'Check Password' has been pressed.  Try to validate
    the password that has been entered

Arguments:

    None

Return Value:

    None

--*/
{
    if (!UpdateData(TRUE))
    {
        return;
    }

    CError err(VerifyUserPassword(m_strUserName, m_strPassword));
    if (!err.MessageBoxOnFailure())
    {
        ::AfxMessageBox(IDS_PASSWORD_OK);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\comprop\w95\makefile.inc ===
#
# Supplemental rules for generating message file.
#

$(O)\iisui.mc: ..\mtxmsg.mc ..\wsockmsg.mc
    copy /A ..\wsockmsg.mc+..\mtxmsg.mc $(O)\iisui.mc

$(O)\iisui.h $(O)\iisui.rc $(O)\msg0001.bin: $(O)\iisui.mc
    mc -v $(O)\iisui.mc -r .\$(O) -h .\$(O)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\comprop\usrbrows.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        usrbrows.h

   Abstract:

        User Browser Dialog definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

#ifndef _USRBROWS_H
#define _USRBROWS_H

#ifndef _GETUSER_H_
    extern "C"
    {
        #define _NTSEAPI_   // We already have the security API hdrs
        #include <getuser.h>
    }
#endif // _GETUSER_H_

#ifndef _SHLOBJ_H_
#include <shlobj.h>
#endif // _SHLOBJ_H_



BOOL COMDLL
GetIUsrAccount(
    IN  LPCTSTR lpstrServer,
    IN  CWnd * pParent,
    OUT CString & str
    );

DWORD COMDLL
VerifyUserPassword(
    IN LPCTSTR lpstrUserName,
    IN LPCTSTR lpstrPassword
    );



class COMDLL CAccessEntry : public CObjectPlus
/*++

Class Description:

    An access description entry, containing a SID and ACCESS mask
    of rights specifically granted.

Public Interface:

    LookupAccountSid        : Resolve account name to SID

    CAccessEntry            : Constructors
    ~CAccessEntry           : Destructor

    ResolveSID              : Resolve account name to SID
    operator ==             : Comparison operator
    AddPermissions          : Add to access mask
    RemovePermissions       : Remove from access mask
    MarkEntryAsNew          : Flag object as new
    MarkEntryAsClean        : Remove dirty flag
    QueryUserName           : Get the account name
    QueryPictureID          : Get 0-based bitmap offset for account
    GetSid                  : Get the SID
    QueryAccessMask         : Get the raw Access granted bits
    IsDirty                 : Determine if item has changed
    IsDeleted               : Determine if item is flagged for deletion
    IsVisible               : Determine if item should be shown in listbox
    FlagForDeletion         : Flag object for deletion or reset that flag
    IsSIDResolved           : Return TRUE if the SID has already been resolved
    HasAppropriateAccess    : Compare access bits to see if the objects has
                              specific permissions
    HasSomeAccess           : Check to see if object has at least one
                              permission bit set.
    IsDeletable             : Determine if object can be deleted

--*/
{
public:
    //
    // Helper function to look up account sid
    //
    static BOOL LookupAccountSid(
        IN  CString & str,
        OUT int & nPictureID,
        OUT PSID pSid,
        IN  LPCTSTR lpstrSystemName = NULL
        );

//
// Construction/Destruction
//
public:
    CAccessEntry(
        IN LPVOID pAce,
        IN BOOL fResolveSID = FALSE
        );

    CAccessEntry(
        IN ACCESS_MASK accPermissions,
        IN PSID pSid,
        IN LPCTSTR lpstrSystemName = NULL,
        IN BOOL fResolveSID = FALSE
        );

    CAccessEntry(
        IN PSID pSid,
        IN LPCTSTR pszUserName,
		IN LPCTSTR pszClassName
        );

	CAccessEntry(
		IN CAccessEntry& ae
		);

    ~CAccessEntry();

//
// Operations
//
public:
    //void SetAccessMask(LPACCESS_ENTRY lpAccessEntry);
    BOOL ResolveSID();
    BOOL operator ==(const CAccessEntry & acc) const;
    BOOL operator ==(const PSID pSid) const;
    void AddPermissions(ACCESS_MASK accnewPermissions);
    void RemovePermissions(ACCESS_MASK accPermissions);
    void MarkEntryAsNew();
    void MarkEntryAsClean();
    void MarkEntryAsChanged();

//
// Access Functions
//
public:
    LPCTSTR QueryUserName() const;

    //
    // The "picture" id is the 0-based index of the
    // bitmap that goes with this entry, and which
    // is used for display in the listbox.
    //
    int QueryPictureID() const;

    PSID GetSid();

    ACCESS_MASK QueryAccessMask() const;

    //
    // Check to see if this entry has undergone
    // any changes since we called it up
    //
    BOOL IsDirty() const;

    BOOL IsDeleted() const;

    BOOL IsVisible() const;

    void FlagForDeletion(
        IN BOOL fDelete = TRUE
        );

    //
    // Check to see if we've already looked up the
    // name of this SID
    //
    BOOL IsSIDResolved() const;

    //
    // Check to see if the add flag has been set for this
    // entry.
    //
    /*
    BOOL IsNew() const;

    //
    // Check to see if the update flag has been set for this
    // entry.
    //
    BOOL IsDifferent() const;
    */

    //
    // See if the entry has the access mask required.
    //
    BOOL HasAppropriateAccess(ACCESS_MASK accTargetMask) const;

    //
    // Check to see if the entry has at least some
    // privileges (if it doesn't, it should be deleted)
    //
    BOOL HasSomeAccess() const;

    //
    // See if this is a deletable entry
    //
    BOOL IsDeletable() const;

private:
    ACCESS_MASK m_accMask;
    CString m_strUserName;
    LPTSTR m_lpstrSystemName;
    PSID m_pSid;
    BOOL m_fDirty;
    BOOL m_fSIDResolved;
    BOOL m_fDeletable;
    BOOL m_fInvisible;
    BOOL m_fDeleted;
    int m_nPictureID;
    int m_fUpdates;
};



//
// Helper functions
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



//
// Convert an oblist of CAccessEntry objects to a blob
//
BOOL COMDLL BuildAclBlob(
    IN  CObListPlus & oblSID,
    OUT CBlob & blob
    );

//
// Reverse the above.  Build an oblist of CAccessEntry lists from
// a blob.
//
DWORD COMDLL BuildAclOblistFromBlob(
    IN  CBlob & blob,
    OUT CObListPlus & oblSID
    );

//
// Build a blob representing an ACL with the local domain group
//
DWORD COMDLL BuildAdminAclBlob(
    OUT CBlob & blob
    );



class COMDLL CAccessEntryListBox : public CRMCListBox
/*++

Class Description:

    Listbox of access entry objects.  Listbox may be
    single or multiselect.

Public Interface:

    CAccessEntryListBox     : Constructor

    AddToAccessList         : Add to list
    FillAccessListBox       : Fill listbox
    ResolveAccessList       : Resolve all SIDS in the container
    AddUserPermissions      : Add user permissions
    GetSelectedItem         : Get item if it's the only one selected,
                              or NULL.

--*/
{
    DECLARE_DYNAMIC(CAccessEntryListBox);

public:
    static const nBitmaps;  // Number of bitmaps

//
// Constructor
//
public:
    CAccessEntryListBox(
        IN int nTab = 0
        );

//
// Interface
//
public:
    //
    // Return the singly selected item, or NULL
    // if 0, or more than one item is selected
    //
    CAccessEntry * GetSelectedItem(
        OUT int * pnSel = NULL
        );

    //
    // Return next selected listbox item (doesn't matter
    // if the listbox is single select or multi-select)
    //
    CAccessEntry * GetNextSelectedItem(
        IN OUT int * pnStartingIndex
        );

    //
    // Get item at selection or NULL
    //
    CAccessEntry * GetItem(UINT nIndex);

//
// Interface to container
//
public:
    BOOL AddToAccessList(
        IN CWnd * pWnd,
        IN LPCTSTR lpstrServer,
        IN CObListPlus & obl
        );

    void FillAccessListBox(
        IN CObListPlus & obl
        );

protected:
    void ResolveAccessList(
        IN CObListPlus &obl
        );

    BOOL AddUserPermissions(
        IN LPCTSTR lpstrServer,
        IN CObListPlus &oblSID,
        IN CAccessEntry * newUser,
        IN ACCESS_MASK accPermissions
        );

//
// Interface to listbox
//
protected:
    int AddItem(CAccessEntry * pItem);
    void SetTabs(int nTab);

protected:
    virtual void DrawItemEx(CRMCListBoxDrawStruct & s);

private:
    int m_nTab;
};




class COMDLL CBrowseDomainDlg
/*++

Class Description:

    Domain browser dialog

Public Interface:

    CBrowseDomainDlg   : Construct the dialog
    ~CBrowseDomainDlg  : Destruct the dialog
    GetSelectedDomain  : Get the full path selected

--*/
{
//
// Construction
//
public:
    //
    // standard constructor
    //
    CBrowseDomainDlg(
        IN CWnd * pParent = NULL,
        IN LPCTSTR lpszInitialDomain = NULL
        );

    ~CBrowseDomainDlg();

public:
    LPCTSTR GetSelectedDomain(
        OUT CString & str
        ) const;

    virtual int DoModal();

protected:
    TCHAR m_szBuffer[MAX_PATH+1];
    CString m_strTitle;
    CString m_strInitialDomain;
    BROWSEINFO m_bi;
};



class COMDLL CBrowseUserDlg
/*++

Class Description:

    User browser dialog class.  This is simply a thin wrapper around
    the getuser interface

Public Interface:

    CBrowseUserDlg      : Construct the dialog
    DoModal             : Show the dialog
    GetSelectionCount   : Query how many user names/groups were selected
    GetSelectedAccounts : Get the string list of account names

--*/
{
public:
    //
    // Constructor
    //
    CBrowseUserDlg(
        IN CWnd * pParentWnd = NULL,
        IN LPCTSTR lpszTitle = NULL,
        IN LPCTSTR lpszInitialDomain = NULL,
        IN BOOL fExpandNames = FALSE,
        IN BOOL fSkipInitialDomainInName = TRUE,
        IN DWORD dwFlags = USRBROWS_INCL_EVERYONE
                         | USRBROWS_SHOW_ALL,
        IN LPCTSTR lpszHelpFileName = NULL,
        IN ULONG ulHelpContext = 0L
        );

    //
    // Show the dialog
    //
    virtual int DoModal();

    //
    // Get the number of selected accounts
    //
    int GetSelectionCount() const;

    //
    // Get the selected accounts list
    //
    CStringList & GetSelectedAccounts();

private:
    USERBROWSER m_ub;
    BOOL m_fSkipInitialDomainInName;
    CStringList m_strSelectedAccounts;
    CString m_strTitle;
    CString m_strInitialDomain;
    CString m_strHelpFileName;
};



class COMDLL CUserAccountDlg : public CDialog
/*++

Class Description:

    User account dialog.  Present a user account/password and allow
    changing, browsing and checking the password

Public Interface:

    CUserAccountDlg : Constructor

--*/
{
//
// Construction
//
public:
    CUserAccountDlg(
        IN LPCTSTR lpstrServer,
        IN LPCTSTR lpstrUserName,
        IN LPCTSTR lpstrPassword,
        IN CWnd * pParent = NULL
        );

//
// Dialog Data
//
public:
    //{{AFX_DATA(CUserAccountDlg)
    enum { IDD = IDD_USER_ACCOUNT };
    CEdit   m_edit_UserName;
    CEdit   m_edit_Password;
    CString m_strUserName;
    //}}AFX_DATA

    CString m_strPassword;
//
// Overrides
//
protected:
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CUserAccountDlg)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:

    // Generated message map functions
    //{{AFX_MSG(CUserAccountDlg)
    afx_msg void OnButtonBrowseUsers();
    afx_msg void OnButtonCheckPassword();
    afx_msg void OnChangeEditUsername();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:
    CString m_strServer;
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline int CAccessEntry::QueryPictureID() const
{
    ASSERT(m_fSIDResolved);
    return m_nPictureID;
}

inline LPCTSTR CAccessEntry::QueryUserName() const
{
    return m_strUserName;
}

inline PSID CAccessEntry::GetSid()
{
    return m_pSid;
}

inline ACCESS_MASK CAccessEntry::QueryAccessMask() const
{
    return m_accMask;
}

inline BOOL CAccessEntry::IsDirty() const
{
    return m_fDirty;
}

inline BOOL CAccessEntry::IsDeleted() const
{
    return m_fDeleted;
}

inline BOOL CAccessEntry::IsVisible() const
{
    return !m_fInvisible;
}

inline void CAccessEntry::FlagForDeletion(
    IN BOOL fDelete
    )
{
    m_fDirty = TRUE;
    m_fDeleted = fDelete;
}

inline BOOL CAccessEntry::IsSIDResolved() const
{
    return m_fSIDResolved;
}

/*
inline BOOL CAccessEntry::IsNew() const
{
    return (m_fUpdates & UPD_ADDED) != 0;
}

inline BOOL CAccessEntry::IsDifferent() const
{
    return (m_fUpdates & UPD_CHANGED) != 0;
}

inline void CAccessEntry::SetAccessMask(
    IN LPACCESS_ENTRY lpAccessEntry
    )
{
    m_accMask = lpAccessEntry->AccessRights;
}

*/

inline BOOL CAccessEntry::HasAppropriateAccess(
    IN ACCESS_MASK accTargetMask
    ) const
{
    return (m_accMask & accTargetMask) == accTargetMask;
}

inline BOOL CAccessEntry::HasSomeAccess() const
{
    return m_accMask;
}

inline BOOL CAccessEntry::IsDeletable() const
{
    return m_fDeletable;
}

inline BOOL  CAccessEntry::operator ==(
    IN const CAccessEntry & acc
    ) const
{
    return ::EqualSid(acc.m_pSid, m_pSid);
}

inline BOOL CAccessEntry::operator ==(
    IN const PSID pSid
    ) const
{
    return ::EqualSid(pSid, m_pSid);
}

inline void  CAccessEntry::MarkEntryAsNew()
{
    m_fDirty = TRUE;
    //m_fUpdates |= UPD_ADDED;
}

inline void CAccessEntry::MarkEntryAsClean()
{
    m_fDirty = FALSE;
    //m_fUpdates = UPD_NONE;
}

inline void CAccessEntry::MarkEntryAsChanged()
{
    m_fDirty = TRUE;
    //m_fUpdates = UPD_CHANGED;
}

inline CAccessEntryListBox::CAccessEntryListBox (
    IN int nTab
    )
{
    SetTabs(nTab);
}

inline void CAccessEntryListBox::SetTabs(
    IN int nTab
    )
{
    m_nTab = nTab;
}

inline CAccessEntry * CAccessEntryListBox::GetItem(
    IN UINT nIndex
    )
{
    return (CAccessEntry *)GetItemDataPtr(nIndex);
}

inline int CAccessEntryListBox::AddItem(
    IN CAccessEntry * pItem
    )
{
    return AddString ((LPCTSTR)pItem);
}

inline CAccessEntry * CAccessEntryListBox::GetSelectedItem(
    OUT int * pnSel
    )
{
    return (CAccessEntry *)CRMCListBox::GetSelectedListItem(pnSel);
}

inline CAccessEntry * CAccessEntryListBox::GetNextSelectedItem(
    IN OUT int * pnStartingIndex
    )
{
    return (CAccessEntry *)CRMCListBox::GetNextSelectedItem(pnStartingIndex);
}

inline int CBrowseUserDlg::GetSelectionCount() const
{
    return (int) m_strSelectedAccounts.GetCount();
}

inline CStringList & CBrowseUserDlg::GetSelectedAccounts()
{
    return m_strSelectedAccounts;
}

#endif // _USRBROWS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\comprop\wizard.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        wizard.h

   Abstract:

        Enhanced dialog and IIS MMC Wizards definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

#ifndef __IISUI_WIZARD_H__
#define __IISUI_WIZARD_H__


//
// CIISWizardPage parameters
//
#define HEADER_PAGE         (TRUE)
#define WELCOME_PAGE        (FALSE)



#if (_WIN32_IE < 0x0400)
//
// Defined in comctrl.h.  Defined here because NT 5 MFC42.dll are
// defined with _WIN32_IE 0x300
//
#pragma message("Warning: privately defining _WIN32_IE definitions")
#define PSH_WIZARD97               0x00002000
#define ICC_INTERNET_CLASSES       0x00000800
#define PSP_HIDEHEADER             0x00000800
#define PSP_USEHEADERTITLE         0x00001000
#define PSP_USEHEADERSUBTITLE      0x00002000
#define PSH_WIZARD_LITE            0x00400000
#endif // _WIN32_IE



//
// Using dialog font as a basis, create a new special effects font
//
COMDLL BOOL
CreateSpecialDialogFont(
    IN CWnd * pdlg,                 // Source dialog
    IN OUT CFont * pfontSpecial,    // Font to be used must be allocated already
    IN LONG lfOffsetWeight = +300,  // Assuming boldification
    IN LONG lfOffsetHeight = +0,    // Assuming no change in height
    IN LONG lfOffsetWidth  = +0,    // Assuming no change in width (or true type)
    IN BOOL fItalic        = FALSE, // Do not invert italic state
    IN BOOL fUnderline     = FALSE  // Do not invert underline state
    );



//
// Apply fonts to child controls of a dialog
//
COMDLL void
ApplyFontToControls(
    IN CWnd * pdlg,                 // Parent dialog
    IN CFont * pfont,               // Font to be applied
    IN UINT nFirst,                 // First control ID in the series
    IN UINT nLast                   // Last control ID in the series
    );



class COMDLL CEmphasizedDialog : public CDialog
/*++

Class Description:

    A standard CDialog that allows use of emphasized fonts as follows:

    control ID      Meaning
    --------------------------------------------------------------------------
    IDC_ED_BOLD1    Dialog font, bold-faced.
    IDC_ED_BOLD2    Dialog font, bold-faced.
    IDC_ED_BOLD3    Dialog font, bold-faced.
    IDC_ED_BOLD4    Dialog font, bold-faced.
    IDC_ED_BOLD5    Dialog font, bold-faced.

    Note: others might be added as needed.

Public Interface:

    CEmphasizedDialog   : Constructor

--*/
{
    DECLARE_DYNCREATE(CEmphasizedDialog)

//
// Constructors
//
public:
    CEmphasizedDialog(LPCTSTR lpszTemplateName, CWnd * pParentWnd = NULL);
    CEmphasizedDialog(UINT nIDTemplate, CWnd * pParentWnd = NULL);
    CEmphasizedDialog();

protected:
    virtual BOOL OnInitDialog();
    afx_msg void OnDestroy();

    DECLARE_MESSAGE_MAP()

private:
    CFont   m_fontBold;
};



class COMDLL CIISWizardSheet : public CPropertySheet
/*++

Class Description:

    IIS Wizard sheet base class
    
Public Interface:    

    CIISWizardSheet     : Constructor

    IsWizard97          : TRUE if the wizard is in '97 mode
    GetSpecialFont      : Get pointer to special font
    GetBitmapMemDC      : Get memory DC where bitmap resides.
    GetBackgroundBrush  : Get background brush
    QueryBitmapWidth    : Get bitmap width
    QueryBitmapHeight   : Get bitmap height

Notes:

    The sheets will be shown in wizard '97 format
    if a welcome bitmap ID is specified.  In that
    case, a header bitmap ID must also be specified.

    Additionally, the same control IDs as used in CEmphasizedDialog
    above have special meaning.

--*/
{
    DECLARE_DYNCREATE(CIISWizardSheet)

//
// Construction
//
public:
    //
    // Specifying a welcome bitmap make the wizard
    // wizard '97, otherwise it's a plain-old wizard
    // page.
    //
    CIISWizardSheet(
        IN UINT nWelcomeBitmap     = 0,
        IN UINT nHeaderBitmap      = 0,
        IN COLORREF rgbForeColor   = RGB(0,0,0),      // Black
        IN COLORREF rgbBkColor     = RGB(255,255,255) // White
        );

//
// Access
//
public:
    BOOL IsWizard97() const;
    CFont * GetSpecialFont(BOOL fHeader);
    CFont * GetBoldFont() { return &m_fontTitle; }
    CFont * GetBigFont() { return &m_fontWelcome; }
    CDC * GetBitmapMemDC(BOOL fHeader);
    HBRUSH GetBackgroundBrush() const { return m_brBkgnd; }
    CBrush * GetWindowBrush() { return &m_brWindow; }
    LONG QueryBitmapWidth(BOOL fHeader) const;
    LONG QueryBitmapHeight(BOOL fHeader) const;
    COLORREF QueryWindowColor() const { return m_rgbWindow; }
    COLORREF QueryWindowTextColor() const { return m_rgbWindowText; }
    void EnableButton(int nID, BOOL fEnable = TRUE);

protected:
    virtual BOOL OnInitDialog();
    virtual void WinHelp(DWORD dwData, UINT nCmd = HELP_CONTEXT);
    afx_msg void OnDestroy();

    DECLARE_MESSAGE_MAP()

protected:
    static const int s_cnBoldDeltaFont;
    static const int s_cnBoldDeltaHeight;
    static const int s_cnBoldDeltaWidth;

protected:
    COLORREF m_rgbWindow;
    COLORREF m_rgbWindowText;

private:
    CFont   m_fontWelcome;
    CFont   m_fontTitle;
    HBRUSH  m_brBkgnd;       
    CBrush  m_brWindow;
    CBitmap m_bmpWelcome;
    CBitmap m_bmpHeader;
    BITMAP  m_bmWelcomeInfo;        
    BITMAP  m_bmHeaderInfo;
    CDC     m_dcMemWelcome;     
    CDC     m_dcMemHeader;     
    HBITMAP m_hbmpOldWelcome;   
    HBITMAP m_hbmpOldHeader;   
};



class COMDLL CIISWizardPage : public CPropertyPage
/*++

Class Description:

    IIS Wizard page base class

Public Interface:

    CIISWizardPage      : Constructor

    ValidateString      : DDX/DDV Helper

Notes:

    If the sheet is constructed with bitmap IDs, the
    pages will be displayed in wizard '97 format.  
    Wizard '97 pages will be displayed in either welcome
    page or header page format.  The welcome page will
    be displayed on a welcome bitmap background, with
    the welcome text (IDC_STATIC_WZ_WELCOME) displayed
    in large bold.  Header pages (ordinary pages), display
    IDC_STATIC_WZ_TITLE in bold, and use the header bitmap
    at the top of the page.

    Special control IDs:
    --------------------

        IDC_STATIC_WZ_WELCOME    - Welcome text displayed in bold
        IDC_STATIC_WZ_TITLE      - Title text displayed in bold
        IDC_STATIC_WZ_SUBTITLE   - Subtitle text

--*/
{
    DECLARE_DYNCREATE(CIISWizardPage)

//
// Construction
//
public:
    CIISWizardPage(
        IN UINT nIDTemplate        = 0,
        IN UINT nIDCaption         = USE_DEFAULT_CAPTION,
        IN BOOL fHeaderPage        = FALSE,
        IN UINT nIDHeaderTitle     = USE_DEFAULT_CAPTION,
        IN UINT nIDSubHeaderTitle  = USE_DEFAULT_CAPTION
        );

public:
    //
    // DDX/DDV Helper
    //
    BOOL ValidateString(
        IN  CEdit & edit,
        OUT CString & str,
        IN  int nMin,
        IN  int nMax
        );

//
// Interface
//
protected:
    virtual BOOL OnInitDialog();
    afx_msg HBRUSH OnCtlColor(CDC * pDC, CWnd * pWnd, UINT nCtlColor);
    afx_msg BOOL OnEraseBkgnd(CDC * pDC);
    DECLARE_MESSAGE_MAP()

//
// Sheet Access
//
protected:
    CIISWizardSheet * GetSheet() const;
    void SetWizardButtons(DWORD dwFlags);
    void EnableSheetButton(int nID, BOOL fEnable = TRUE);
    BOOL IsWizard97() const;
    BOOL IsHeaderPage() const { return m_fUseHeader; }
    CFont * GetSpecialFont();
    CFont * GetBoldFont();
    CFont * GetBigFont();
    CDC   * GetBitmapMemDC();
    HBRUSH GetBackgroundBrush() const;
    CBrush * GetWindowBrush();
    LONG QueryBitmapWidth() const;
    LONG QueryBitmapHeight() const;
    COLORREF QueryWindowColor() const;
    COLORREF QueryWindowTextColor() const;

protected:
    static const int s_cnHeaderOffset;

private:
    BOOL    m_fUseHeader;    // TRUE to use header
    CRect   m_rcFillArea;    // Fill area
    CPoint  m_ptOrigin;      // Bitmap origin
    CString m_strTitle;      // Title text
    CString m_strSubTitle;   // Subtitle text
};



class COMDLL CIISWizardBookEnd : public CIISWizardPage
/*++

Class Description:

    Welcome / Completion Page

Public Interface:

    CIISWizardBookEnd    : Constructor

Notes:

    The resource template is not required.  If not provided,
    a default template will be used.

    Special control IDs (on the dialog template):
    ---------------------------------------------

        IDC_STATIC_WZ_WELCOME    - Welcome text displayed in bold
        IDC_STATIC_WZ_BODY       - Body text will be placed here
        IDC_STATIC_WZ_CLICK      - Click instructions.

    The click instructions default to something sensible, and body text
    will default to the error text on a failure page and to nothing on 
    success and welcome page.  The body text may include the %h/%H 
    escape sequences for CError on a success/failure page.

--*/
{
    DECLARE_DYNCREATE(CIISWizardBookEnd)

public:
    //
    // Constructor for success/failure completion page
    //
    CIISWizardBookEnd(
        IN HRESULT * phResult,
        IN UINT nIDWelcomeTxtSuccess ,
        IN UINT nIDWelcomeTxtFailure,
        IN UINT nIDCaption           = USE_DEFAULT_CAPTION,
        IN UINT nIDBodyTxtSuccess    = USE_DEFAULT_CAPTION,
        IN UINT nIDBodyTxtFailure    = USE_DEFAULT_CAPTION,
        IN UINT nIDClickTxt          = USE_DEFAULT_CAPTION,
        IN UINT nIDTemplate          = 0
        );

    //
    // Constructor for a welcome page
    //
    CIISWizardBookEnd(
        IN UINT nIDWelcomeTxt        = 0,
        IN UINT nIDCaption           = USE_DEFAULT_CAPTION,
        IN UINT nIDBodyTxt           = USE_DEFAULT_CAPTION,
        IN UINT nIDClickTxt          = USE_DEFAULT_CAPTION,
        IN UINT nIDTemplate          = 0
        );

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CPWWelcome)
    enum { IDD = IDD_WIZARD_BOOKEND };
    //}}AFX_DATA

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CIISWizardBookEnd)
    public:
    virtual BOOL OnSetActive();
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    // Generated message map functions
    //{{AFX_MSG(CPWTemplate)
    virtual BOOL OnInitDialog();
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()

    BOOL IsWelcomePage() const { return m_phResult == NULL; }

private:
    HRESULT * m_phResult;
    CString m_strWelcomeSuccess;
    CString m_strWelcomeFailure;
    CString m_strBodySuccess;
    CString m_strBodyFailure;
    CString m_strClick;
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline CEmphasizedDialog::CEmphasizedDialog(
    IN LPCTSTR lpszTemplateName,
    IN CWnd * pParentWnd
    )
    : CDialog(lpszTemplateName, pParentWnd)
{
}

inline CEmphasizedDialog::CEmphasizedDialog(
    IN UINT nIDTemplate,
    IN CWnd * pParentWnd
    )
    : CDialog(nIDTemplate, pParentWnd)
{
}

inline CEmphasizedDialog::CEmphasizedDialog()
    : CDialog()
{
}

inline BOOL CIISWizardSheet::IsWizard97() const
{
    return ((HBITMAP)m_bmpWelcome != NULL);
}

inline CFont * CIISWizardSheet::GetSpecialFont(BOOL fHeader)
{
    return fHeader ? &m_fontTitle : &m_fontWelcome;
}

inline CDC * CIISWizardSheet::GetBitmapMemDC(BOOL fHeader)
{
    return fHeader ? &m_dcMemHeader : &m_dcMemWelcome;
}

inline LONG CIISWizardSheet::QueryBitmapWidth(BOOL fHeader) const
{
    return fHeader ? m_bmHeaderInfo.bmWidth : m_bmWelcomeInfo.bmWidth;
}

inline LONG CIISWizardSheet::QueryBitmapHeight(BOOL fHeader) const
{
    return fHeader ? m_bmHeaderInfo.bmHeight : m_bmWelcomeInfo.bmHeight;
}

inline CIISWizardSheet * CIISWizardPage::GetSheet() const
{
    return (CIISWizardSheet *)GetParent();
}

inline void CIISWizardPage::SetWizardButtons(DWORD dwFlags)
{
    GetSheet()->SetWizardButtons(dwFlags);
}

inline void CIISWizardPage::EnableSheetButton(int nID, BOOL fEnable)
{
    GetSheet()->EnableButton(nID, fEnable);
}

inline BOOL CIISWizardPage::IsWizard97() const
{
    return GetSheet()->IsWizard97();
}

inline CFont * CIISWizardPage::GetSpecialFont()
{
    ASSERT(IsWizard97());
    return GetSheet()->GetSpecialFont(m_fUseHeader);
}

inline CFont * CIISWizardPage::GetBoldFont()
{
    ASSERT(IsWizard97());
    return GetSheet()->GetBoldFont();
}

inline CFont * CIISWizardPage::GetBigFont()
{
    ASSERT(IsWizard97());
    return GetSheet()->GetBigFont();
}

inline CDC * CIISWizardPage::GetBitmapMemDC()
{
    ASSERT(IsWizard97());
    return GetSheet()->GetBitmapMemDC(m_fUseHeader);
}

inline LONG CIISWizardPage::QueryBitmapWidth() const
{
    ASSERT(IsWizard97());
    return GetSheet()->QueryBitmapWidth(m_fUseHeader);
}

inline LONG CIISWizardPage::QueryBitmapHeight() const
{
    ASSERT(IsWizard97());
    return GetSheet()->QueryBitmapHeight(m_fUseHeader);
}

inline HBRUSH CIISWizardPage::GetBackgroundBrush() const
{
    ASSERT(IsWizard97());
    return GetSheet()->GetBackgroundBrush();
}

inline CBrush * CIISWizardPage::GetWindowBrush()
{
    ASSERT(IsWizard97());
    return GetSheet()->GetWindowBrush();
}

inline COLORREF CIISWizardPage::QueryWindowColor() const 
{ 
    ASSERT(IsWizard97());
    return GetSheet()->QueryWindowColor();
}

inline COLORREF CIISWizardPage::QueryWindowTextColor() const
{ 
    ASSERT(IsWizard97());
    return GetSheet()->QueryWindowTextColor();
}

#endif // __IISUI_WIZARD_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\comprop\wizard.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        wizard.cpp

   Abstract:

        Enhanced dialog and IIS Wizard pages, including
        support for Wizard '97

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include "comprop.h"



BOOL
CreateSpecialDialogFont(
    IN CWnd * pDlg,
    IN OUT CFont * pfontSpecial,
    IN LONG lfOffsetWeight,     OPTIONAL
    IN LONG lfOffsetHeight,     OPTIONAL
    IN LONG lfOffsetWidth,      OPTIONAL
    IN BOOL fItalic,            OPTIONAL
    IN BOOL fUnderline          OPTIONAL
    )
/*++

Routine Description:

    From the dialog font, create special effects font.

Arguments:

    CWnd * pDlg         : Pointer to dialog
    CFont * pfontSpecial: Font object to be created.
    LONG lfOffsetWeight : Change in font weight
    LONG lfOffsetHeight : Value to add to height (will autonegate for truetype)
    LONG lfOffsetWidth  : Value to add to width (ignored for truetype)
    BOOL fItalic        : If true, reverses italic
    BOOL fUnderline     : If true, reverses underline

Return Value:

    TRUE for success, FALSE for failure.

--*/
{
    ASSERT(pDlg != NULL);
    ASSERT(pfontSpecial != NULL);           // Font must be allocated
    ASSERT((HFONT)(*pfontSpecial) == NULL); // But not yet created

    if (pDlg && pfontSpecial)
    {
        //
        // Use dialog font as basis.
        //
        CFont * pfontDlg = pDlg->GetFont();
        ASSERT(pfontDlg != NULL);

        if (pfontDlg)
        {
            LOGFONT lf;

            if (pfontDlg->GetLogFont(&lf))
            {
                lf.lfWeight += lfOffsetWeight;

                if (lf.lfHeight < 0)
                {
                    //
                    // truetype font, ignore widths
                    //
                    lf.lfHeight -= lfOffsetHeight;
                    ASSERT(lf.lfWidth == 0);
                }
                else
                {
                    //
                    // Non-true type font
                    //
                    lf.lfHeight += lfOffsetHeight;
                    lf.lfWidth += lfOffsetWidth;
                }

                if (fItalic)
                {
                    lf.lfItalic = !lf.lfItalic;
                }

                if (fUnderline)
                {
                    lf.lfUnderline = !lf.lfUnderline;
                }

                return pfontSpecial->CreateFontIndirect(&lf);
            }
        }
    }

    return FALSE;
}



void
ApplyFontToControls(
    IN CWnd * pdlg,
    IN CFont * pfont,
    IN UINT nFirst,
    IN UINT nLast
    )
/*++

Routine Description:

    Helper function to apply a font to a range of controls in a dialog.

Arguments:

    CWnd * pdlg      : Pointer to dialog
    CFont * pfont    : Font to apply
    UINT nFirst      : First control ID
    UINT nLast       : Last control ID (Not all need exist)

Return Value:

    None

Notes:

    The control IDs are expected to exist sequentially.  That is,
    the first id in the range nFirst to nLast that doesn't exist
    will break the loop.

---*/
{
    ASSERT((HFONT)(*pfont) != NULL);
    ASSERT(nFirst <= nLast);

    CWnd * pCtl;
    for (UINT n = nFirst; n <= nLast; ++n)
    {
        pCtl = pdlg->GetDlgItem(n);

        if (!pCtl)
        {
            break;
        }

        pCtl->SetFont(pfont);
    }
}



IMPLEMENT_DYNCREATE(CEmphasizedDialog, CDialog)



//
// Message Map
//
BEGIN_MESSAGE_MAP(CEmphasizedDialog, CDialog)
    ON_WM_DESTROY()
END_MESSAGE_MAP()



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BOOL 
CEmphasizedDialog::OnInitDialog()
/*++

Routine Description:

    WM_INITDIALOG handler.

Arguments:

    None

Return:

    TRUE unless a control has received focus.

--*/
{
    BOOL bReturn = CDialog::OnInitDialog();

    if (CreateSpecialDialogFont(this, &m_fontBold))
    {
        //
        // Apply bold font
        //
        ApplyFontToControls(this, &m_fontBold, IDC_ED_BOLD1, IDC_ED_BOLD5);
    }

    return bReturn;
}



void 
CEmphasizedDialog::OnDestroy()
/*++

Routine Description:

    Cleanup internal structures
    
Arguments:

    None

Return Value:

    None

--*/
{
    m_fontBold.DeleteObject();

    CDialog::OnDestroy();
}



IMPLEMENT_DYNCREATE(CIISWizardSheet, CPropertySheet)



//
// Static Initialization
//
const int CIISWizardSheet::s_cnBoldDeltaFont   = +500;
const int CIISWizardSheet::s_cnBoldDeltaHeight = +8;
const int CIISWizardSheet::s_cnBoldDeltaWidth  = +3;



CIISWizardSheet::CIISWizardSheet(
    IN UINT nWelcomeBitmap,
    IN UINT nHeaderBitmap,
    IN COLORREF rgbForeColor,
    IN COLORREF rgbBkColor
    )
/*++

Routine Description:

    Wizard sheet constructor.  Specifying a welcome bitmap
    make the sheet wizard '97 compliant.

Arguments:

    UINT nWelcomeBitmap     : Resource ID of welcome bitmap
    UINT nHeaderBitmap      : Resource ID of header bitmap

Return Value:

    N/A

--*/
    : CPropertySheet()
{
    m_psh.dwFlags &= ~(PSH_HASHELP);
    SetWizardMode();

    m_rgbWindow     = GetSysColor(COLOR_WINDOW);
    m_rgbWindowText = GetSysColor(COLOR_WINDOWTEXT);

    if (nWelcomeBitmap)
    {
        //
        // Load bitmaps, replacing colours.
        //
        COLORMAP crMap[2];
        
        crMap[0].from = rgbBkColor;
        crMap[0].to = m_rgbWindow;
        crMap[1].from = rgbForeColor;
        crMap[1].to = m_rgbWindowText;

        //
        // Half tone the foreground colour
        //
        if (m_rgbWindowText == RGB(0,0,0))
        {
            BYTE bRed, bGreen, bBlue;
            bRed   = GetRValue(m_rgbWindowText);
            bGreen = GetGValue(m_rgbWindowText);
            bBlue  = GetBValue(m_rgbWindowText);
        
            crMap[1].to = RGB( ((255 - bRed) * 2 / 3), ((255 - bGreen) * 2 / 3), ((255 - bBlue) * 2 / 3) );
        }
        else
        {
            crMap[1].to = m_rgbWindowText;
        }

        VERIFY(m_bmpWelcome.LoadBitmap(nWelcomeBitmap));
        m_bmpWelcome.GetBitmap(&m_bmWelcomeInfo);

        /*
        VERIFY(m_bmpHeader.LoadMappedBitmap(
            nHeaderBitmap, 
            0, 
            crMap, 
            ARRAY_SIZE(crMap)
            ));
        */
        VERIFY(m_bmpHeader.LoadMappedBitmap(nHeaderBitmap));
        m_bmpHeader.GetBitmap(&m_bmHeaderInfo);

        m_psh.dwFlags |= PSH_WIZARD_LITE;
    }
}



void 
CIISWizardSheet::EnableButton(
    IN int nID, 
    IN BOOL fEnable         OPTIONAL
    )
/*++

Routine Description:

    Enable/disable sheet button

Arguments:

    int nID         : Button ID (IDCANCEL, etc)
    BOOL fEnable    : TRUE to enable, FALSE to disable

Return Value:

    None

--*/
{
    CWnd * pButton = GetDlgItem(nID);

    if (pButton)
    {
        pButton->EnableWindow(fEnable);
    }
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CIISWizardSheet, CPropertySheet)
    ON_WM_DESTROY()
END_MESSAGE_MAP()



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BOOL 
CIISWizardSheet::OnInitDialog()
/*++

Routine Description:

    WM_INITDIALOG handler.  Resize the sheet to the proper
    size, and set up some basic information

Arguments:

    None

Return:

    TRUE unless a control has received focus.

--*/
{
    if (IsWizard97())
    {
        //
        // Create special fonts.
        //
        // Title font is same size as dialog, but bold
        // Welcome font is much bolder (+500), and 3 sizes larger.
        // Specifying a +1 in width increase is on the unlikely chance
        // that the dialog font is not true-type.
        //                                                            
        VERIFY(CreateSpecialDialogFont(this, &m_fontTitle));
        VERIFY(CreateSpecialDialogFont(
            this, 
            &m_fontWelcome, 
            s_cnBoldDeltaFont, 
            s_cnBoldDeltaHeight, 
            s_cnBoldDeltaWidth
            ));
    }

    //
    // Load default brush (transparent brush);
    //
    VERIFY(m_brBkgnd = (HBRUSH)GetStockObject(HOLLOW_BRUSH));

    //
    // Create the window brush
    //
    VERIFY(m_brWindow.CreateSolidBrush(m_rgbWindow));

    BOOL bResult = CPropertySheet::OnInitDialog();

    if (IsWizard97())
    {
        // 
        // Get temporary DC for dialog - Will be released in dc destructor
        //
        CClientDC dc(this);

        //
        // Create compatible memory DCs using the dialogs DC
        //
        VERIFY(m_dcMemWelcome.CreateCompatibleDC(&dc));
        VERIFY(m_dcMemHeader.CreateCompatibleDC(&dc));

        //
        // Save state to be restored later.
        //
        CBitmap * pbmpOldWelcome, 
                * pbmpOldHeader;

        VERIFY(pbmpOldWelcome   = m_dcMemWelcome.SelectObject(&m_bmpWelcome));
        VERIFY(m_hbmpOldWelcome = (HBITMAP)pbmpOldWelcome->GetSafeHandle());
        VERIFY(pbmpOldHeader    = m_dcMemHeader.SelectObject(&m_bmpHeader));
        VERIFY(m_hbmpOldHeader  = (HBITMAP)pbmpOldHeader->GetSafeHandle());
    }

    return bResult;
}



void 
CIISWizardSheet::OnDestroy()
/*++

Routine Description:

    Cleanup internal structures

Arguments:

    None

Return Value:

    None

--*/
{
    CPropertySheet::OnDestroy();

    if (IsWizard97())
    {
        //
        // Restore memory DCs
        //
        ASSERT(m_hbmpOldWelcome != NULL);
        ASSERT(m_hbmpOldHeader != NULL);
        VERIFY(m_dcMemWelcome.SelectObject(
            CBitmap::FromHandle(m_hbmpOldWelcome)
            ));
        VERIFY(m_dcMemHeader.SelectObject(
            CBitmap::FromHandle(m_hbmpOldHeader)
            ));

        //
        // Clean up the bitmaps
        //
        m_bmpWelcome.DeleteObject();
        m_bmpHeader.DeleteObject();
        m_brWindow.DeleteObject();
       
        //
        // Destructors will take care of the rest.
        //
    }
}




void
CIISWizardSheet::WinHelp(
    IN DWORD dwData,
    IN UINT nCmd
    )
/*++

Routine Description:

    'Help' handler.  Implemented to ensure no response for F1,
    instead of the bogus "Topic not found" error.

Arguments:

    DWORD dwData        : Help data
    UINT nCmd           : Help command

Return Value:

    None

--*/
{
    //
    // Eat the help command
    //
}



IMPLEMENT_DYNCREATE(CIISWizardPage, CPropertyPage)



//
// Margin for header bitmap
//
const int CIISWizardPage::s_cnHeaderOffset = 2;



CIISWizardPage::CIISWizardPage(
    IN UINT nIDTemplate,            OPTIONAL
    IN UINT nIDCaption,             OPTIONAL
    IN BOOL fHeaderPage,            OPTIONAL
    IN UINT nIDHeaderTitle,         OPTIONAL
    IN UINT nIDSubHeaderTitle       OPTIONAL
    )
/*++

Routine Description:

    Header wizard page 

Arguments:

    UINT nIDTemplate        : Resource template
    UINT nIDCaption         : caption ID
    BOOL fHeaderPage        : TRUE for header page, FALSE for welcome page
    UINT nIDHeaderTitle     : Header title
    UINT nIDSubHeaderTitle  : Subheader title.

Return Value:

    N/A

--*/
    : CPropertyPage(nIDTemplate, nIDCaption),
      m_strTitle(),
      m_strSubTitle(),
      m_rcFillArea(0, 0, 0, 0),
      m_ptOrigin(0, 0),
      m_fUseHeader(fHeaderPage)
{
    m_psp.dwFlags &= ~(PSP_HASHELP); // No Help

    if (nIDHeaderTitle)
    {
        ASSERT(IsHeaderPage());
        VERIFY(m_strTitle.LoadString(nIDHeaderTitle));
    }

    if (nIDSubHeaderTitle)
    {
        ASSERT(IsHeaderPage());
        VERIFY(m_strSubTitle.LoadString(nIDSubHeaderTitle));
    }

    m_psp.dwFlags |= PSP_HIDEHEADER; // Wizard97
}



BOOL
CIISWizardPage::ValidateString(
    IN  CEdit & edit,
    OUT CString & str,
    IN  int nMin,
    IN  int nMax
    )
/*++

Routine Description:

    Since normal 'DoDataExchange' validation happens on every entrance
    and exit of a property page, it's not well suited to wizards.  This
    function is to be called on 'next' only to do validation.

Arguments:

    CEdit & edit        : Edit box where the string is to be gotten from
    CString & str       : String to be validated
    int nMin            : Minimum length
    int nMax            : Maximum length

Return Value:

    TRUE if the string is within the limits, FALSE otherwise.

--*/
{
    ASSERT(nMin <= nMax);

    UINT nID;
    TCHAR szT[33];

    edit.GetWindowText(str);

    if (str.GetLength() < nMin)
    {
        nID = IDS_DDX_MINIMUM;
        ::wsprintf(szT, _T("%d"), nMin);
    }
    else if (str.GetLength() > nMax)
    {
        nID = AFX_IDP_PARSE_STRING_SIZE;
        ::wsprintf(szT, _T("%d"), nMax);
    }
    else
    {
        //
        // Passes both our tests, it's ok.
        //
        return TRUE;
    }

    //
    // Highlight and puke
    //
    edit.SetSel(0,-1);
    edit.SetFocus();

    CString prompt;
    ::AfxFormatString1(prompt, nID, szT);
    ::AfxMessageBox(prompt, MB_ICONEXCLAMATION, nID);

    return FALSE;
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CIISWizardPage, CPropertyPage)
    ON_WM_CTLCOLOR()
    ON_WM_ERASEBKGND()
END_MESSAGE_MAP()



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



HBRUSH 
CIISWizardPage::OnCtlColor(
    IN CDC * pDC, 
    IN CWnd * pWnd, 
    IN UINT nCtlColor
    )
/*++

Routine Description:

    Handle control colour.  Ensure a true transparent
    background colouring.

Arguments:

    CDC * pDC       : Device context
    CWnd * pWnd     : Pointer to window
    UINT nCtlColor  : Ctrl type ID

Return Value:

    Handle to brush to be used for background painting

--*/
{
    if (IsWizard97())
    {
        switch (nCtlColor)    
        {        
            case CTLCOLOR_BTN:
            case CTLCOLOR_STATIC:        
            //case CTLCOLOR_EDIT:
            //case CTLCOLOR_LISTBOX:
            //case CTLCOLOR_SCROLLBAR:
            case CTLCOLOR_DLG: 

            //
            // Have text and controls be painted smoothly over bitmap
            // without using default background colour
            //
            pDC->SetBkMode(TRANSPARENT);
            pDC->SetTextColor(QueryWindowTextColor());

            return GetBackgroundBrush();
        }
    }

    //
    // Default processing...
    //
    return CPropertyPage::OnCtlColor(pDC, pWnd, nCtlColor);
}



BOOL 
CIISWizardPage::OnEraseBkgnd(
    IN CDC * pDC
    )
/*++

Routine Description:

    Handle erasing the background colour of the dialog

Arguments:

    CDC * pDC       : Device context

Return Value:

    TRUE if no further works needs to be done.
    FALSE otherwise.

--*/
{
    if (IsWizard97())
    {
        //
        // Cache height/width of the fill area, and compute
        // the origin of the destination bitmap.
        //
        if (m_rcFillArea.Width() == 0)
        {
            //
            // Not yet cached, compute values
            //
            CRect rcClient;

            GetClientRect(&rcClient);

            if (IsHeaderPage())
            {
                //
                // Fill the upper rectangle above
                // the divider
                //
                CWnd * pDiv = GetDlgItem(IDC_STATIC_WZ_HEADER_DIVIDER);
                ASSERT(pDiv != NULL);

                if (pDiv != NULL)
                {
                    m_rcFillArea = rcClient;                    
                    GetDlgCtlRect(m_hWnd, pDiv->m_hWnd, &rcClient);
                    m_rcFillArea.bottom = rcClient.top;
        
                    //
                    // Figure out a place for the bitmap
                    // to go.  If any coordinate is negative,
                    // the bitmap will not be displayed
                    //                    
                    TRACEEOLID(
                        "Fill area  : " << m_rcFillArea.Height() 
                        << "x"          << m_rcFillArea.Width()
                        );
                    TRACEEOLID(
                        "Bitmap size: " << QueryBitmapHeight()
                        << "x"          << QueryBitmapWidth()
                        );

                    ASSERT(m_rcFillArea.Width()  >= QueryBitmapWidth());
                    ASSERT(m_rcFillArea.Height() >= QueryBitmapHeight()); 

                    //
                    // Find a place for the header box properly offset from the
                    // margins
                    //
                    m_ptOrigin.y = 
                        (m_rcFillArea.Height() - QueryBitmapHeight() + 1) / 2;
                    m_ptOrigin.x = m_rcFillArea.Width() 
                        - QueryBitmapWidth() 
                        + 1
                        - (__max(s_cnHeaderOffset, m_ptOrigin.y));
                }   
            }      
            else
            {
                //
                // Fill the entire client are
                //
                m_rcFillArea = rcClient;
            }
        }
        
        //
        // Fill background colour with window colour
        //
        pDC->FillRect(&m_rcFillArea, GetWindowBrush());

        //
        // Draw the background picture if there's room.
        //
        if (m_ptOrigin.x >= 0 && m_ptOrigin.y >= 0)
        {
            pDC->BitBlt( 
                m_ptOrigin.x,
                m_ptOrigin.y,
                QueryBitmapWidth() - 1, 
                QueryBitmapHeight() - 1,
                GetBitmapMemDC(), 
                0, 
                0, 
                SRCCOPY 
                );
        }

        /*

        //
        // Scale bitmap appropriately -- looks grainy
        //
        int nHeight = rc.Height();

        double dDelta = (double)nHeight / (double)(QueryBitmapHeight() - 1);

        int nWidth = (int)((double)(QueryBitmapWidth() - 1) * dDelta);

        pDC->StretchBlt( 
            0,
            0,
            nWidth,
            nHeight,    
            GetBitmapMemDC(), 
            0, 
            0, 
            QueryBitmapWidth() - 1, 
            QueryBitmapHeight() - 1,
            SRCCOPY 
            );

         */

        //
        // No more background painting needed
        //
        return TRUE;    
    }

    //
    // No background images of any kind
    //
    return CPropertyPage::OnEraseBkgnd(pDC);
}



BOOL
CIISWizardPage::OnInitDialog()
/*++

Routine Description:

    Handle WM_INITIDIALOG.  Load the appropriate 
    bitmaps, and create the brushes and fonts as needed.

Arguments:

    None

Return Value:

    TRUE unless a control has received initial focus

--*/
{
    CPropertyPage::OnInitDialog();

    //
    // Fake the WIZARD97 look
    //
    if (IsWizard97())
    {
        if (IsHeaderPage())
        {
            CWnd * pCtlTitle = GetDlgItem(IDC_STATIC_WZ_TITLE);
            CWnd * pCtlSubTitle = GetDlgItem(IDC_STATIC_WZ_SUBTITLE);
            ASSERT(pCtlTitle);
            ASSERT(pCtlSubTitle);

            if (pCtlTitle)
            {
                pCtlTitle->SetFont(GetSpecialFont());

                if (!m_strTitle.IsEmpty())
                {
                    pCtlTitle->SetWindowText(m_strTitle);
                }
            }

            if (pCtlSubTitle && !m_strSubTitle.IsEmpty())
            {
                pCtlSubTitle->SetWindowText(m_strSubTitle);
            }
        }
        else
        {
            CWnd * pCtl = GetDlgItem(IDC_STATIC_WZ_WELCOME);
            ASSERT(pCtl != NULL);

            if (pCtl)
            {
                pCtl->SetFont(GetSpecialFont());
            }
        }

        //
        // Apply fonts
        //
        ApplyFontToControls(this, GetBoldFont(), IDC_ED_BOLD1, IDC_ED_BOLD5);
    }

    return TRUE;  
}


                            
//
// CIISWizardBookEnd page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



IMPLEMENT_DYNCREATE(CIISWizardBookEnd, CIISWizardPage)



CIISWizardBookEnd::CIISWizardBookEnd(
    IN HRESULT * phResult,
    IN UINT nIDWelcomeTxtSuccess,
    IN UINT nIDWelcomeTxtFailure,
    IN UINT nIDCaption,             OPTIONAL
    IN UINT nIDBodyTxtSuccess,      OPTIONAL
    IN UINT nIDBodyTxtFailure,      OPTIONAL
    IN UINT nIDClickTxt,            OPTIONAL
    IN UINT nIDTemplate             OPTIONAL
    )
/*++

Routine Description:

    Constructor for success/failure page

Arguments:

    HRESULT * phResult          : Address of result code
    UINT nIDWelcomeTxtSuccess   : Success message
    UINT nIDWelcomeTxtFailure   : Failure message
    UINT nIDCaption             : Template caption
    UINT nIDBodyTxtSuccess      : Body text for success
    UINT nIDBodyTxtFailure      : Body text for success
    UINT nIDClickTxt            : Click message
    UINT nIDTemplate            : Dialog template
    

Return Value:

    N/A

--*/
    : CIISWizardPage(
        nIDTemplate ? nIDTemplate : CIISWizardBookEnd::IDD,
        nIDCaption
        ),
      m_phResult(phResult),
      m_strWelcomeSuccess(),
      m_strWelcomeFailure(),
      m_strBodySuccess(),
      m_strBodyFailure(),
      m_strClick()
{
    ASSERT(m_phResult != NULL); // Must know success/failure

    VERIFY(m_strWelcomeSuccess.LoadString(nIDWelcomeTxtSuccess));
    VERIFY(m_strWelcomeFailure.LoadString(nIDWelcomeTxtFailure));
    VERIFY(m_strClick.LoadString(nIDClickTxt ? nIDClickTxt : IDS_WIZ_FINISH));

    if (nIDBodyTxtSuccess)
    {
        VERIFY(m_strBodySuccess.LoadString(nIDBodyTxtSuccess));
    }

    if (nIDBodyTxtFailure)
    {
        VERIFY(m_strBodyFailure.LoadString(nIDBodyTxtFailure));
    }
    else
    {
        //
        // Error text only by default
        //
        m_strBodyFailure = _T("%h");
    }
}



CIISWizardBookEnd::CIISWizardBookEnd(
    IN UINT nIDWelcomeTxt,        
    IN UINT nIDCaption,         OPTIONAL
    IN UINT nIDBodyTxt,
    IN UINT nIDClickTxt,        OPTIONAL
    IN UINT nIDTemplate
    )
/*++

Routine Description:

    Constructor for welcome page

Arguments:

    UINT nIDWelcomeTxt          : Welcome message
    UINT nIDCaption             : Template
    UINT nIDBodyTxt             : Body text
    UINT nIDClickTxt            : Click message
    UINT nIDTemplate            : Dialog template

Return Value:

    N/A

--*/
    : CIISWizardPage(
        nIDTemplate ? nIDTemplate : CIISWizardBookEnd::IDD,
        nIDCaption
        ),
      m_phResult(NULL),
      m_strWelcomeSuccess(),
      m_strWelcomeFailure(),
      m_strBodySuccess(),
      m_strBodyFailure(),
      m_strClick()
{
    VERIFY(m_strWelcomeSuccess.LoadString(nIDWelcomeTxt));

    if (nIDBodyTxt)
    {
        VERIFY(m_strBodySuccess.LoadString(nIDBodyTxt));
    }

    VERIFY(m_strClick.LoadString(nIDClickTxt ? nIDClickTxt : IDS_WIZ_NEXT));
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CIISWizardBookEnd, CIISWizardPage)
    //{{AFX_MSG_MAP(CIISWizardBookEnd)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



BOOL 
CIISWizardBookEnd::OnSetActive() 
/*++

Routine Description:

    Activation handler

Arguments:

    None

Return Value:

    TRUE to display the page, FALSE otherwise.

--*/
{
    if (IsWelcomePage())
    {
        GetDlgItem(IDC_STATIC_WZ_WELCOME)->SetWindowText(m_strWelcomeSuccess);
        GetDlgItem(IDC_STATIC_WZ_BODY)->SetWindowText(m_strBodySuccess);
    }
    else
    {
        CError err(*m_phResult);

        GetDlgItem(IDC_STATIC_WZ_WELCOME)->SetWindowText(
            err.Succeeded() ? m_strWelcomeSuccess : m_strWelcomeFailure
            );

        //
        // Build body text string and expand error messages
        //
        CString strBody = err.Succeeded() ? m_strBodySuccess : m_strBodyFailure;
        err.TextFromHRESULTExpand(strBody);

        GetDlgItem(IDC_STATIC_WZ_BODY)->SetWindowText(strBody);
    }

    DWORD dwFlags = IsWelcomePage() ? PSWIZB_NEXT : PSWIZB_FINISH;

    SetWizardButtons(dwFlags);

    return CIISWizardPage::OnSetActive();
}



BOOL 
CIISWizardBookEnd::OnInitDialog() 
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CIISWizardPage::OnInitDialog();

    //
    // Make the "Click 'foo' to continue" message bold as well.
    //
    ApplyFontToControls(this, GetBoldFont(), IDC_STATIC_WZ_CLICK, IDC_STATIC_WZ_CLICK);

    GetDlgItem(IDC_STATIC_WZ_CLICK)->SetWindowText(m_strClick);

    //
    // Remove Cancel Button on the completion page only.
    //
    EnableSheetButton(IDCANCEL, IsWelcomePage());

    return TRUE;  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\comprop\nt\stdafx.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1995                **/
/**********************************************************************/

#ifndef _STDAFX_H_
#define _STDAFX_H_

#define VC_EXTRALEAN

#include <ctype.h>

extern "C"
{
    #include <nt.h>
    #include <ntrtl.h>
    #include <nturtl.h>
}

#undef VERIFY
#undef ASSERT

#include <stdio.h>

//
// MFC include files
//
#include <afxwin.h>
#include <afxdlgs.h>
#include <afxext.h>         // MFC extensions
#include <afxcoll.h>        // collection class
#include <afxcmn.h>
#include <afxole.h>
#include <afxtempl.h>
#include <objbase.h>

//
// Required by VC5
//
#ifndef MIDL_INTERFACE
#define MIDL_INTERFACE(x) struct
#endif // MIDL_INTERFACE
#ifndef __RPCNDR_H_VERSION__
#define __RPCNDR_H_VERSION__ 440
#endif // __RPCNDR_H_VERSION__

#include <iiscnfg.h>
#include <inetreg.h>
#include <lmcons.h>
#include <tchar.h>

#include <aclapi.h>

#endif // _STDAFX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\comprop\nt\makefile.inc ===
#
# Supplemental rules for generating message file.
#

$(O)\iisui.mc: ..\mtxmsg.mc ..\wsockmsg.mc
    copy /A ..\wsockmsg.mc+..\mtxmsg.mc $(O)\iisui.mc

$(O)\iisui.h $(O)\iisui.rc $(O)\msg0001.bin: $(O)\iisui.mc
    mc -v $(O)\iisui.mc -r .\$(O) -h .\$(O)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\fscfg\font.cpp ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "stdafx.h"
#include "font.h"


/////////////////////////////////////////////////////////////////////////////
// COleFont properties

CString COleFont::GetName()
{
    CString result;
    GetProperty(0x0, VT_BSTR, (void*)&result);
    return result;
}

void COleFont::SetName(LPCTSTR propVal)
{
    SetProperty(0x0, VT_BSTR, propVal);
}

CY COleFont::GetSize()
{
    CY result;
    GetProperty(0x2, VT_CY, (void*)&result);
    return result;
}

void COleFont::SetSize(const CY& propVal)
{
    SetProperty(0x2, VT_CY, &propVal);
}

BOOL COleFont::GetBold()
{
    BOOL result;
    GetProperty(0x3, VT_BOOL, (void*)&result);
    return result;
}

void COleFont::SetBold(BOOL propVal)
{
    SetProperty(0x3, VT_BOOL, propVal);
}

BOOL COleFont::GetItalic()
{
    BOOL result;
    GetProperty(0x4, VT_BOOL, (void*)&result);
    return result;
}

void COleFont::SetItalic(BOOL propVal)
{
    SetProperty(0x4, VT_BOOL, propVal);
}

BOOL COleFont::GetUnderline()
{
    BOOL result;
    GetProperty(0x5, VT_BOOL, (void*)&result);
    return result;
}

void COleFont::SetUnderline(BOOL propVal)
{
    SetProperty(0x5, VT_BOOL, propVal);
}

BOOL COleFont::GetStrikethrough()
{
    BOOL result;
    GetProperty(0x6, VT_BOOL, (void*)&result);
    return result;
}

void COleFont::SetStrikethrough(BOOL propVal)
{
    SetProperty(0x6, VT_BOOL, propVal);
}

short COleFont::GetWeight()
{
    short result;
    GetProperty(0x7, VT_I2, (void*)&result);
    return result;
}

void COleFont::SetWeight(short propVal)
{
    SetProperty(0x7, VT_I2, propVal);
}

short COleFont::GetCharset()
{
    short result;
    GetProperty(0x8, VT_I2, (void*)&result);
    return result;
}

void COleFont::SetCharset(short propVal)
{
    SetProperty(0x8, VT_I2, propVal);
}

/////////////////////////////////////////////////////////////////////////////
// COleFont operations
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\comprop\w95\stdafx.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1995                **/
/**********************************************************************/

#ifndef _STDAFX_H_
#define _STDAFX_H_

#define VC_EXTRALEAN

#include <ctype.h>

extern "C"
{
    #include <nt.h>
    #include <ntrtl.h>
    #include <nturtl.h>
}

#undef VERIFY
#undef ASSERT

#include <stdio.h>

//
// MFC include files
//
#include <afxwin.h>
#include <afxdlgs.h>
#include <afxext.h>         // MFC extensions
#include <afxcoll.h>        // collection class
#include <afxcmn.h>
#include <afxole.h>
#include <afxtempl.h>
#include <objbase.h>

//
// Required by VC5
//
#ifndef MIDL_INTERFACE
#define MIDL_INTERFACE(x) struct
#endif // MIDL_INTERFACE
#ifndef __RPCNDR_H_VERSION__
#define __RPCNDR_H_VERSION__ 440
#endif // __RPCNDR_H_VERSION__

#include <iiscnfg.h>
#include <inetreg.h>
#include <lmcons.h>
#include <tchar.h>

#endif // _STDAFX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\fscfg\facc.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        facc.h

   Abstract:

        FTP Accounts Property Page

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/


#ifndef __FACC_H__
#define __FACC_H__



class CFtpAccountsPage : public CInetPropertyPage
{
/*++

Class Description:

    FTP Service property page

Public Interface:

    CFtpAccountsPage  : Constructor
    ~CFtpAccountsPage : Destructor

--*/
    DECLARE_DYNCREATE(CFtpAccountsPage)

//
// Constructor/Destructor
//
public:
    CFtpAccountsPage(
        IN CInetPropertySheet * pSheet = NULL
        );

    ~CFtpAccountsPage();

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CFtpAccountsPage)
    enum { IDD = IDD_ACCOUNTS };
    BOOL    m_fAllowAnonymous;
    BOOL    m_fOnlyAnonymous;
    BOOL    m_fPasswordSync;
    CString m_strUserName;
    CEdit   m_edit_Password;
    CEdit   m_edit_UserName;
    CStatic m_static_Password;
    CStatic m_static_UserName;
    CStatic m_static_AccountPrompt;
    CButton m_button_Add;
    CButton m_button_CheckPassword;
    CButton m_button_Browse;
    CButton m_button_CurrentSessions;
    CButton m_button_RemoveAdministrator;
    CButton m_chk_PasswordSync;
    CButton m_chk_AllowAnymous;
    CButton m_chk_OnlyAnonymous;
    //}}AFX_DATA

    CString m_strPassword;
    CAccessEntryListBox m_list_Administrators;

//
// Overrides
//
protected:
    virtual HRESULT FetchLoadedValues();
    virtual HRESULT SaveInfo();

    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CFtpAccountsPage)
    public:
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    void SetControlStates(BOOL fAllowAnonymous);
    BOOL SetAdminRemoveState();

    // Generated message map functions
    //{{AFX_MSG(CFtpAccountsPage)
    virtual BOOL OnInitDialog();
    afx_msg void OnButtonCheckPassword();
    afx_msg void OnButtonBrowseUser();
    afx_msg void OnButtonAdd();
    afx_msg void OnButtonDelete();
    afx_msg void OnCheckAllowAnonymous();
    afx_msg void OnCheckAllowOnlyAnonymous();
    afx_msg void OnCheckEnablePwSynchronization();
    afx_msg void OnSelchangeListAdministrators();
    afx_msg void OnChangeEditUsername();
    //}}AFX_MSG

    afx_msg void OnItemChanged();

    DECLARE_MESSAGE_MAP()

private:
    BOOL m_fPasswordSyncChanged;
    BOOL m_fPasswordSyncMsgShown;
    BOOL m_fUserNameChanged;
    CString m_strServerName;
    CRMCListBoxResources m_ListBoxRes;
    CObListPlus m_oblSID;
};



#endif // __FACC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\fscfg\facc.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        facc.cpp

   Abstract:

        FTP Accounts Property Page

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include "fscfg.h"
#include "facc.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNCREATE(CFtpAccountsPage, CInetPropertyPage)



CFtpAccountsPage::CFtpAccountsPage(
    IN CInetPropertySheet * pSheet
    )
/*++

Routine Description:

    Constructor for FTP service property page

Arguments:

    CInetPropertySheet * pSheet : Associated property sheet

Return Value:

    N/A

--*/
    : CInetPropertyPage(CFtpAccountsPage::IDD, pSheet),
      m_ListBoxRes(
        IDB_ACLUSERS,
        CAccessEntryListBox::nBitmaps
        ),
      m_oblSID(),
      m_fPasswordSyncChanged(FALSE),
      m_fUserNameChanged(FALSE),
      m_fPasswordSyncMsgShown(FALSE)
{
#ifdef _DEBUG

    afxMemDF |= checkAlwaysMemDF;

#endif // _DEBUG

#if 0 // Keep Class Wizard happy

    //{{AFX_DATA_INIT(CFtpAccountsPage)
    m_strUserName = _T("");
    m_fAllowAnonymous = TRUE;
    m_fOnlyAnonymous = FALSE;
    m_fPasswordSync = FALSE;
    //}}AFX_DATA_INIT

#endif // 0

    m_list_Administrators.AttachResources(&m_ListBoxRes);
}



CFtpAccountsPage::~CFtpAccountsPage()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
}



void
CFtpAccountsPage::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CInetPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CFtpAccountsPage)
    DDX_Check(pDX, IDC_CHECK_ALLOW_ANONYMOUS, m_fAllowAnonymous);
    DDX_Check(pDX, IDC_CHECK_ONLY_ANYMOUS, m_fOnlyAnonymous);
    DDX_Check(pDX, IDC_CHECK_ENABLE_PW_SYNCHRONIZATION, m_fPasswordSync);
    DDX_Control(pDX, IDC_BUTTON_ADD, m_button_Add);
    DDX_Control(pDX, IDC_EDIT_PASSWORD, m_edit_Password);
    DDX_Control(pDX, IDC_EDIT_USERNAME, m_edit_UserName);
    DDX_Control(pDX, IDC_STATIC_PW, m_static_Password);
    DDX_Control(pDX, IDC_STATIC_USERNAME, m_static_UserName);
    DDX_Control(pDX, IDC_STATIC_ACCOUNT_PROMPT, m_static_AccountPrompt);
    DDX_Control(pDX, IDC_BUTTON_CHECK_PASSWORD, m_button_CheckPassword);
    DDX_Control(pDX, IDC_BUTTON_BROWSE_USER, m_button_Browse);
    DDX_Control(pDX, IDC_BUTTON_DELETE, m_button_RemoveAdministrator);
    DDX_Control(pDX, IDC_CHECK_ENABLE_PW_SYNCHRONIZATION, m_chk_PasswordSync);
    DDX_Control(pDX, IDC_CHECK_ALLOW_ANONYMOUS, m_chk_AllowAnymous);
    DDX_Control(pDX, IDC_CHECK_ONLY_ANYMOUS, m_chk_OnlyAnonymous);
    //}}AFX_DATA_MAP

    //
    // Private DDX/DDV Routines
    //
    DDX_Control(pDX, IDC_LIST_ADMINISTRATORS, m_list_Administrators);

    //
    // Set password/username only during load stage,
    // or if saving when allowing anonymous logons
    //
    if (!pDX->m_bSaveAndValidate || m_fAllowAnonymous)
    {
        DDX_Text(pDX, IDC_EDIT_USERNAME, m_strUserName);
        DDV_MinMaxChars(pDX, m_strUserName, 1, UNLEN);

        //
        // Some people have a tendency to add "\\" before
        // the computer name in user accounts.  Fix this here.
        //
        m_strUserName.TrimLeft();
        while (*m_strUserName == '\\')
        {
            m_strUserName = m_strUserName.Mid(2);
        }


        //
        // Display the remote password sync message if
        // password sync is on, the account is not local,
        // password sync has changed or username has changed
        // and the message hasn't already be shown.
        //
        if (pDX->m_bSaveAndValidate && m_fPasswordSync 
            && !IsLocalAccount(m_strUserName)
            && (m_fPasswordSyncChanged || m_fUserNameChanged)
            && !m_fPasswordSyncMsgShown
            )
        {
            if (!NoYesMessageBox(IDS_WRN_PWSYNC))
            {
                pDX->Fail();
            }

            //
            // Don't show it again
            //
            m_fPasswordSyncMsgShown = TRUE;
        }

        if (!m_fPasswordSync || !pDX->m_bSaveAndValidate)
        {
            DDX_Password(
                pDX, 
                IDC_EDIT_PASSWORD, 
                m_strPassword, 
                g_lpszDummyPassword
                );
        }

        if (!m_fPasswordSync)
        {
            DDV_MaxChars(pDX, m_strPassword, PWLEN);
        }
    }

}

//
// Message Map
//
BEGIN_MESSAGE_MAP(CFtpAccountsPage, CInetPropertyPage)
    //{{AFX_MSG_MAP(CFtpAccountsPage)
    ON_BN_CLICKED(IDC_BUTTON_CHECK_PASSWORD, OnButtonCheckPassword)
    ON_BN_CLICKED(IDC_BUTTON_ADD, OnButtonAdd)
    ON_CBN_SELCHANGE(IDC_LIST_ADMINISTRATORS, OnSelchangeListAdministrators)
    ON_BN_CLICKED(IDC_BUTTON_DELETE, OnButtonDelete)
    ON_BN_CLICKED(IDC_CHECK_ENABLE_PW_SYNCHRONIZATION, OnCheckEnablePwSynchronization)
    ON_EN_CHANGE(IDC_EDIT_USERNAME, OnChangeEditUsername)
    //}}AFX_MSG_MAP

    ON_EN_CHANGE(IDC_EDIT_PASSWORD, OnItemChanged)
    ON_BN_CLICKED(IDC_CHECK_ALLOW_ANONYMOUS, OnCheckAllowAnonymous)
    ON_BN_CLICKED(IDC_CHECK_ONLY_ANYMOUS, OnCheckAllowOnlyAnonymous)
    ON_BN_CLICKED(IDC_BUTTON_BROWSE_USER, OnButtonBrowseUser)

END_MESSAGE_MAP()



void
CFtpAccountsPage::SetControlStates(
    IN BOOL fAllowAnonymous
    )
/*++

Routine Description:

    Set the states of the dialog control depending on its current
    values.

Arguments:

    BOOL fAllowAnonymous : If TRUE, 'allow anonymous' is on.

Return Value:

    None

--*/
{
    m_static_Password.EnableWindow(
        fAllowAnonymous 
     && !m_fPasswordSync 
     && HasAdminAccess()
        );
    m_edit_Password.EnableWindow(
        fAllowAnonymous 
     && !m_fPasswordSync
     && HasAdminAccess()
        );
    m_button_CheckPassword.EnableWindow(
        fAllowAnonymous 
     && !m_fPasswordSync
     && HasAdminAccess()
        );
    m_static_AccountPrompt.EnableWindow(fAllowAnonymous);
    m_static_UserName.EnableWindow(fAllowAnonymous && HasAdminAccess());
    m_edit_UserName.EnableWindow(fAllowAnonymous && HasAdminAccess());
    m_button_Browse.EnableWindow(fAllowAnonymous && HasAdminAccess());
    m_chk_PasswordSync.EnableWindow(fAllowAnonymous && HasAdminAccess());
    m_chk_OnlyAnonymous.EnableWindow(fAllowAnonymous);
}



BOOL
CFtpAccountsPage::SetAdminRemoveState()
/*++

Routine Description:

    Set the state of the remove button depending on the selection in the
    administrators listbox.  Remove is only enabled if ALL selected
    items are removable.

Arguments:

    None

Return Value:

    TRUE if the remove button is enabled.

--*/
{
    int nSel = 0;
    int cSelectedItems = 0;
    BOOL fAllDeletable = TRUE;
    CAccessEntry * pAccess;
    while ((pAccess = m_list_Administrators.GetNextSelectedItem(&nSel)) != NULL)
    {
        ++cSelectedItems;

        if (!pAccess->IsDeletable())
        {
            fAllDeletable = FALSE;
            break;
        }

        ++nSel;
    }

    fAllDeletable = fAllDeletable && (cSelectedItems > 0);

    m_button_RemoveAdministrator.EnableWindow(
        fAllDeletable 
     && HasOperatorList()
     && HasAdminAccess()
        );

    return fAllDeletable;
}



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


BOOL
CFtpAccountsPage::OnInitDialog()
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CInetPropertyPage::OnInitDialog();

    m_list_Administrators.Initialize();

    CWaitCursor wait;

    //
    // Build the ACL list
    //        
    CError err(BuildAclOblistFromBlob(
        ((CFtpSheet *)GetSheet())->GetInstanceProperties().m_acl,
        m_oblSID
        ));

    err.MessageBoxOnFailure();

    m_list_Administrators.FillAccessListBox(m_oblSID);

    //
    // check if the operators controls are accessible
    //
    m_button_Add.EnableWindow(HasOperatorList() && HasAdminAccess());
    m_list_Administrators.EnableWindow(HasOperatorList() && HasAdminAccess());

    GetDlgItem(IDC_STATIC_OPERATOR_PROMPT1)->EnableWindow(
        HasOperatorList() 
     && HasAdminAccess()
        );

    GetDlgItem(IDC_STATIC_OPERATOR_PROMPT2)->EnableWindow(
        HasOperatorList() 
     && HasAdminAccess()
        );

    SetControlStates(m_fAllowAnonymous);
    SetAdminRemoveState();

    return TRUE;
}



/* virtual */
HRESULT
CFtpAccountsPage::FetchLoadedValues()
/*++

Routine Description:
    
    Move configuration data from sheet to dialog controls

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CError err;

    BEGIN_META_INST_READ(CFtpSheet)
        FETCH_INST_DATA_FROM_SHEET(m_strUserName);
        FETCH_INST_DATA_FROM_SHEET(m_strPassword);
        FETCH_INST_DATA_FROM_SHEET(m_fAllowAnonymous);
        FETCH_INST_DATA_FROM_SHEET(m_fOnlyAnonymous);
        FETCH_INST_DATA_FROM_SHEET(m_fPasswordSync);
    END_META_INST_READ(err)

    return err;
}



/* virtual */
HRESULT
CFtpAccountsPage::SaveInfo()
/*++

Routine Description:

    Save the information on this property page

Arguments:

    None

Return Value:

    Error return code

--*/
{
    ASSERT(IsDirty());

    TRACEEOLID("Saving FTP service page now...");

    //
    // Use m_ notation because the message crackers require it
    //
    CBlob m_acl;
    BOOL fAclDirty = BuildAclBlob(m_oblSID, m_acl);

    CError err;

    BeginWaitCursor();
    BEGIN_META_INST_WRITE(CFtpSheet)
        STORE_INST_DATA_ON_SHEET(m_strUserName)
        STORE_INST_DATA_ON_SHEET(m_fOnlyAnonymous)
        STORE_INST_DATA_ON_SHEET(m_fAllowAnonymous)
        STORE_INST_DATA_ON_SHEET(m_fPasswordSync)
        if (fAclDirty)
        {
            STORE_INST_DATA_ON_SHEET(m_acl)
        }
        if (m_fPasswordSync)
        {
            //
            // Delete password
            //
            // CODEWORK: Shouldn't need to know ID number.
            // Implement m_fDelete flag in CMP template maybe?
            //
            FLAG_INST_DATA_FOR_DELETION(MD_ANONYMOUS_PWD);
        }
        else
        {
            STORE_INST_DATA_ON_SHEET(m_strPassword);
        }
    END_META_INST_WRITE(err)
    EndWaitCursor();

    return err;
}



void
CFtpAccountsPage::OnItemChanged()
/*++

Routine Description:

    Register a change in control value on this page.  Mark the page as dirty.
    All change messages map to this function

Arguments:

    None

Return Value:

    None

--*/
{
    SetModified(TRUE);
    SetControlStates(m_chk_AllowAnymous.GetCheck() > 0);
}



void
CFtpAccountsPage::OnCheckAllowAnonymous()
/*++

Routine Description:

    Respond to 'allow anonymous' checkbox being pressed

Arguments:

    None

Return Value:

    None

--*/
{
    if (m_chk_AllowAnymous.GetCheck() == 0)
    {
        //
        // Show security warning
        //
        CClearTxtDlg dlg;
        if (dlg.DoModal() != IDOK)
        {
            m_chk_AllowAnymous.SetCheck(1);
            return;
        }
    }

    SetControlStates(m_chk_AllowAnymous.GetCheck() > 0);
    OnItemChanged();
}



void
CFtpAccountsPage::OnCheckAllowOnlyAnonymous()
/*++

Routine Description:

    Respond to 'allow only anonymous' checkbox being pressed

Arguments:

    None

Return Value:

    None

--*/
{
    if (m_chk_OnlyAnonymous.GetCheck() == 0)
    {
        //
        // Show security warning
        //
        CClearTxtDlg dlg;
        if (dlg.DoModal() != IDOK)
        {
            m_chk_OnlyAnonymous.SetCheck(1);
            return;
        }
    }

    OnItemChanged();
}



void 
CFtpAccountsPage::OnButtonBrowseUser()
/*++

Routine Description:

    User browser button has been pressed.  Browse for IUSR account name

Arguments:

    None

Return Value:

    None

--*/
{
    CString str;

    if (GetIUsrAccount(str))
    {
        //
        // If the name is non-local (determined by having
        // a slash in the name, password sync is disabled,
        // and a password should be entered.
        //
        m_edit_UserName.SetWindowText(str);
        if (!(m_fPasswordSync = IsLocalAccount(str)))
        {
            m_edit_Password.SetWindowText(_T(""));
            m_edit_Password.SetFocus();
        }

        m_chk_PasswordSync.SetCheck(m_fPasswordSync);
        OnItemChanged();
    }
}



void 
CFtpAccountsPage::OnButtonCheckPassword() 
/*++

Routine Description:

    Check password button has been pressed.

Arguments:

    None

Return Value:

    None

--*/
{
    if (!UpdateData(TRUE))
    {
        return;
    }

    CError err(VerifyUserPassword(m_strUserName, m_strPassword));
    if (!err.MessageBoxOnFailure())
    {
        ::AfxMessageBox(IDS_PASSWORD_OK);
    }
}



void
CFtpAccountsPage::OnButtonAdd()
/*++

Routine Description:

    'Add' button has been pressed

Arguments:

    None

Return Value:

    None

--*/
{
    if (m_list_Administrators.AddToAccessList(
        this,
        QueryServerName(),
        m_oblSID
        ))
    {
        OnItemChanged();
    }

    SetAdminRemoveState();
}



void
CFtpAccountsPage::OnSelchangeListAdministrators()
/*++

Routine Description:

    Selection Change in admin list box handler

Arguments:

    None.

Return Value:

    None

--*/
{
    SetAdminRemoveState();
}



void 
CFtpAccountsPage::OnButtonDelete()
/*++

Routine Description:

    Delete all selected items in the list box

Arguments:

    None.

Return Value:

    None

--*/
{
    int nSel = 0;
    int cChanges = 0;
    CAccessEntry * pAccess;
    while ((pAccess = m_list_Administrators.GetNextSelectedItem(&nSel)) != NULL)
    {
        //
        // Remove button should be disabled unless all selected
        // items are deletable
        //
        ASSERT(pAccess->IsDeletable());
        if (pAccess->IsDeletable())
        {
            ++cChanges;
            pAccess->FlagForDeletion();
            m_list_Administrators.DeleteString(nSel);

            //
            // Don't advance counter to account for shift
            //
            continue;
        }

        ++nSel;
    }

    if (cChanges)
    {
        OnItemChanged();
    }

    if (!SetAdminRemoveState())
    {
        m_button_Add.SetFocus();
    }
}



void 
CFtpAccountsPage::OnCheckEnablePwSynchronization() 
/*++

Routine Description:

    Handler for 'enable password synchronization' checkbox press

Arguments:

    None

Return Value:

    None

--*/
{
    m_fPasswordSyncChanged = TRUE;
    m_fPasswordSync = !m_fPasswordSync;
    OnItemChanged();
    SetControlStates(m_chk_AllowAnymous.GetCheck() > 0);
    if (!m_fPasswordSync )
    {
        m_edit_Password.SetSel(0,-1);
        m_edit_Password.SetFocus();
    }
}



void 
CFtpAccountsPage::OnChangeEditUsername() 
/*++

Routine description:

    Handler for 'username' edit box change messages

Arguments:

    None

Return Value:

    None

--*/
{
    m_fUserNameChanged = TRUE;
    OnItemChanged();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\fscfg\fmessage.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        fmessage.cpp

   Abstract:

        FTP Messages property page

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include "fscfg.h"
#include "fmessage.h"



#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif



IMPLEMENT_DYNCREATE(CFtpMessagePage, CInetPropertyPage)

CFtpMessagePage::CFtpMessagePage(
    IN CInetPropertySheet * pSheet
    )
/*++

Routine Description:

    Constructor for FTP message property page

Arguments:

    CInetPropertySheet * pSheet : Associated property sheet

Return Value:

    N/A

--*/
    : CInetPropertyPage(CFtpMessagePage::IDD, pSheet)
{
#ifdef _DEBUG

    afxMemDF |= checkAlwaysMemDF;

#endif // _DEBUG

#if 0 // Keep class wizard happy

    //{{AFX_DATA_INIT(CFtpMessagePage)
    m_strExitMessage = _T("");
    m_strMaxConMsg = _T("");
    m_strWelcome = _T("");
    //}}AFX_DATA_INIT

#endif // 0

    m_hInstRichEdit = LoadLibrary(_T("RichEd20.dll"));
}



CFtpMessagePage::~CFtpMessagePage()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
   if (m_hInstRichEdit != NULL)
      FreeLibrary(m_hInstRichEdit);
}



void
CFtpMessagePage::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CInetPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CFtpMessagePage)
    DDX_Control(pDX, IDC_EDIT_EXIT, m_edit_Exit);
    DDX_Control(pDX, IDC_EDIT_MAX_CONNECTIONS, m_edit_MaxCon);
    DDX_Text(pDX, IDC_EDIT_EXIT, m_strExitMessage);
    DDX_Text(pDX, IDC_EDIT_MAX_CONNECTIONS, m_strMaxConMsg);
    DDX_Text(pDX, IDC_EDIT_WELCOME, m_strWelcome);
    //}}AFX_DATA_MAP
}

//
// Message Map
//
BEGIN_MESSAGE_MAP(CFtpMessagePage, CInetPropertyPage)
    //{{AFX_MSG_MAP(CFtpMessagePage)
    //}}AFX_MSG_MAP

    ON_EN_CHANGE(IDC_EDIT_EXIT, OnItemChanged)
    ON_EN_CHANGE(IDC_EDIT_MAX_CONNECTIONS, OnItemChanged)
    ON_EN_CHANGE(IDC_EDIT_WELCOME, OnItemChanged)

END_MESSAGE_MAP()



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

BOOL
CFtpMessagePage::OnInitDialog()
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CInetPropertyPage::OnInitDialog();

    CHARFORMAT cf;
    ZeroMemory(&cf, sizeof(cf));
    cf.cbSize = sizeof(cf);
    cf.dwMask = CFM_FACE;
    cf.bPitchAndFamily = FIXED_PITCH | FF_DONTCARE;
    lstrcpyn((LPTSTR)cf.szFaceName, _T("Courier"), LF_FACESIZE);

    SendDlgItemMessage(IDC_EDIT_WELCOME, EM_SETCHARFORMAT, SCF_ALL, (LPARAM)&cf);

    DWORD event = (DWORD)SendDlgItemMessage(IDC_EDIT_WELCOME, EM_GETEVENTMASK, 0, 0);
    event |= ENM_CHANGE;
    SendDlgItemMessage(IDC_EDIT_WELCOME, EM_SETEVENTMASK, 0, (LPARAM)event);

    return TRUE;
}



/* virtual */
HRESULT
CFtpMessagePage::FetchLoadedValues()
/*++

Routine Description:
    
    Move configuration data from sheet to dialog controls

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CError err;

    BEGIN_META_INST_READ(CFtpSheet)

        //
        // Use m_ notation because the message cracker functions require it.
        //
        CStringListEx m_strlWelcome;
        FETCH_INST_DATA_FROM_SHEET(m_strExitMessage);
        FETCH_INST_DATA_FROM_SHEET(m_strMaxConMsg);
        FETCH_INST_DATA_FROM_SHEET(m_strlWelcome);

        //
        // Incoming strings contain '\r' at the end of each string.
        // Append a '\n' for internal consumption
        //
        ConvertStringListToSepLine(m_strlWelcome, m_strWelcome, _T("\n"));

    END_META_INST_READ(err)

    return err;
}



/* virtual */
HRESULT
CFtpMessagePage::SaveInfo()
/*++

Routine Description:

    Save the information on this property page

Arguments:

    None

Return Value:

    Error return code

--*/
{
    ASSERT(IsDirty());

    TRACEEOLID("Saving FTP message page now...");

    CError err;

    BeginWaitCursor();

    //
    // Use m_ notation because the message cracker macros require
    // it.
    //
    CStringListEx m_strlWelcome;
    ConvertSepLineToStringList(m_strWelcome, m_strlWelcome, _T("\n"));

    BEGIN_META_INST_WRITE(CFtpSheet)
        STORE_INST_DATA_ON_SHEET(m_strExitMessage)
        STORE_INST_DATA_ON_SHEET(m_strMaxConMsg)
        STORE_INST_DATA_ON_SHEET(m_strlWelcome)
    END_META_INST_WRITE(err)

    EndWaitCursor();

    return err;
}



void
CFtpMessagePage::OnItemChanged()
/*++

Routine Description:

    Register a change in control value on this page.  Mark the page as dirty.
    All change messages map to this function

Arguments:

    None

Return Value:

    None

--*/
{
    SetModified(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\fscfg\font.h ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.

/////////////////////////////////////////////////////////////////////////////
// COleFont wrapper class

class COleFont : public COleDispatchDriver
{
public:
    COleFont() {}       // Calls COleDispatchDriver default constructor
    COleFont(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
    COleFont(const COleFont& dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

// Attributes
public:
    CString GetName();
    void SetName(LPCTSTR);
    CY GetSize();
    void SetSize(const CY&);
    BOOL GetBold();
    void SetBold(BOOL);
    BOOL GetItalic();
    void SetItalic(BOOL);
    BOOL GetUnderline();
    void SetUnderline(BOOL);
    BOOL GetStrikethrough();
    void SetStrikethrough(BOOL);
    short GetWeight();
    void SetWeight(short);
    short GetCharset();
    void SetCharset(short);

// Operations
public:
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\fscfg\defws.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        defws.cpp

   Abstract:

        Default Web Site Dialog

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include "fscfg.h"
#include "defws.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif



//
// Master Property Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



IMPLEMENT_DYNCREATE(CDefWebSitePage, CInetPropertyPage)



CDefWebSitePage::CDefWebSitePage(
    IN CInetPropertySheet * pSheet
    )
/*++

Routine Description:

    Constructor for WWW Default Web Site page

Arguments:

    CInetPropertySheet * pSheet : Sheet object

Return Value:

    N/A


--*/
    : CInetPropertyPage(CDefWebSitePage::IDD, pSheet),
      m_rgdwInstances()
{
    //{{AFX_DATA_INIT(CDefWebSitePage)
    //}}AFX_DATA_INIT
}



CDefWebSitePage::~CDefWebSitePage()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
}



void
CDefWebSitePage::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CInetPropertyPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CDefWebSitePage)
    DDX_Control(pDX, IDC_COMBO_WEBSITES, m_combo_WebSites);
    //}}AFX_DATA_MAP
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CDefWebSitePage, CInetPropertyPage)
    //{{AFX_MSG_MAP(CDefWebSitePage)
    ON_CBN_SELCHANGE(IDC_COMBO_WEBSITES, OnSelchangeComboWebsites)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



HRESULT
CDefWebSitePage::BuildInstanceList()
/*++

Routine Description:

    Build the instance list of friendly instances

Arguments:

    None

Return Value:

    Error return code

--*/
{
    CWaitCursor wait;

    //
    // Create interface
    //
    CMetaKey mk(QueryServerName());
    CError err(mk.QueryResult());
    if (err.Failed())
    {
        return err;
    }

    //
    // Populate combo box with known web sites.
    //
    ISMINSTANCEINFO ii;
    ii.dwSize = sizeof(ISMINSTANCEINFO);
    HANDLE hEnum = NULL;
    int i = 0;
    int iSel = LB_ERR;

    FOREVER
    {
        err = COMDLL_ISMEnumerateInstances(&mk, &ii, &hEnum, g_cszSvc);
        if (err.Failed())
        {
            break;
        }

        CString strComment(ii.szComment);
        if (strComment.IsEmpty())
        {
            //
            // This should be rare -- an instance without a name
            // just use the number.
            //
            {
                CString str;

                VERIFY(str.LoadString(IDS_INSTANCE_DEF_FMT));
                strComment.Format(
                    str, 
                    g_cszSvc, 
                    ii.dwID
                    );
            }
        }

        m_combo_WebSites.AddString(strComment);
        m_rgdwInstances.Add(ii.dwID);
        if (m_dwDownlevelInstance == ii.dwID)
        {   
            //
            // This is the current one, remember the selection
            //
            iSel = i;
        }

        ++i;
    }

    m_rgdwInstances.FreeExtra();
    m_combo_WebSites.SetCurSel(iSel);

    if (err.Win32Error() == ERROR_NO_MORE_ITEMS)
    {
        //
        // Normal way to end the loop
        //
        err.Reset();
    }

    return err;
}



DWORD
CDefWebSitePage::FetchInstanceSelected()
/*++

Routine Description:

    Based on the selection in the combo box, fetch the instance number
    selected.

Arguments:

    None

Return Value:

    The instance number coresponding to the selected instance, or -1.

--*/
{
    DWORD dwInstance = -1;

    int iSel = m_combo_WebSites.GetCurSel();

    if (iSel >= 0)
    {
        dwInstance = m_rgdwInstances[iSel];
    }

    return dwInstance;
}



/* virtual */
HRESULT
CDefWebSitePage::FetchLoadedValues()
/*++

Routine Description:
    
    Move configuration data from sheet to dialog controls

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CError err;

    BEGIN_META_INST_READ(CFtpSheet)
        FETCH_INST_DATA_FROM_SHEET(m_dwDownlevelInstance);
    END_META_INST_READ(err)

    m_rgdwInstances.SetSize(0, 10);

    return err;
}



/* virtual */
HRESULT
CDefWebSitePage::SaveInfo()
/*++

Routine Description:

    Save the information on this property page

Arguments:

    None

Return Value:

    Error return code

--*/
{
    ASSERT(IsDirty());

    TRACEEOLID("Saving W3 default web site page now...");

    CError err;

    m_dwDownlevelInstance = FetchInstanceSelected();

    BeginWaitCursor();
    BEGIN_META_INST_WRITE(CFtpSheet)
        STORE_INST_DATA_ON_SHEET(m_dwDownlevelInstance);
    END_META_INST_WRITE(err)
    EndWaitCursor();

    return err;
}


//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BOOL
CDefWebSitePage::OnInitDialog()
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CInetPropertyPage::OnInitDialog();

    CError err(BuildInstanceList());
    err.MessageBoxOnFailure();

    return TRUE;
}


void
CDefWebSitePage::OnSelchangeComboWebsites() 
/*++

Routine Description:

    web site combo box 'selection change' handler

Arguments:

    None

Return Value:

    None

--*/
{
    SetModified(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\fscfg\defws.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        defws.h

   Abstract:

        Default Web Site Dialog

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/


#ifndef __DEFWS_H__
#define __DEFWS_H__


class CDefWebSitePage : public CInetPropertyPage
/*++

Class Description:

    WWW Errors property page

Public Interface:

    CDefWebSitePage       : Constructor
    CDefWebSitePage       : Destructor

--*/
{
    DECLARE_DYNCREATE(CDefWebSitePage)

//
// Construction
//
public:
    CDefWebSitePage(CInetPropertySheet * pSheet = NULL);
    ~CDefWebSitePage();

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CDefWebSitePage)
    enum { IDD = IDD_DEFAULT_SITE };
    CComboBox   m_combo_WebSites;
    //}}AFX_DATA

    DWORD m_dwDownlevelInstance;

//
// Overrides
//
protected:
    virtual HRESULT FetchLoadedValues();
    virtual HRESULT SaveInfo();

    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CDefWebSitePage)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    // Generated message map functions
    //{{AFX_MSG(CDefWebSitePage)
    virtual BOOL OnInitDialog();
    afx_msg void OnSelchangeComboWebsites();
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()

    HRESULT BuildInstanceList();
    DWORD FetchInstanceSelected();

private:
    CDWordArray m_rgdwInstances;
};


#endif // __DEFWS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\fscfg\fscfg.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        fscfg.cpp

   Abstract:

        FTP Configuration Module

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"

#include "fscfg.h"
#include "fservic.h"
#include "facc.h"
#include "fmessage.h"
#include "vdir.h"
#include "security.h"
#include "wizard.h"
#include "..\mmc\constr.h"

//
// Standard Configuration Information
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

#define SVC_ID                      INET_FTP_SVC_ID

#define INETSLOC_MASK               (INET_FTP_SVCLOC_ID)

//
// Service capabilities flags
//
#define SERVICE_INFO_FLAGS (\
    ISMI_UNDERSTANDINSTANCE | \
    ISMI_INSTANCES          | \
    ISMI_CHILDREN           | \
    ISMI_INETSLOCDISCOVER   | \
    ISMI_CANCONTROLSERVICE  | \
    ISMI_CANPAUSESERVICE    | \
    ISMI_TASKPADS           | \
    ISMI_SECURITYWIZARD     | \
    ISMI_HASWEBPROTOCOL     | \
    ISMI_SUPPORTSMETABASE   | \
    ISMI_SUPPORTSMASTER     | \
    ISMI_NORMALTBMAPPING)

//
// Name used for this service by the service controller manager.
//
#define SERVICE_SC_NAME             _T("MSFTPSVC")

//
// Short descriptive name of the service.  This
// is what will show up as the name of the service
// in the internet manager tool.
//
// Issue: I'm assuming here that this name does NOT
//        require localisation.
//
#define SERVICE_SHORT_NAME          _T("FTP")

//
// Longer name.  This is the text that shows up in
// the tooltips text on the internet manager
// tool.  This probably should be localised.
//
#define SERVICE_LONG_NAME           _T("FTP Service")

//
// Web browser protocol name.  e.g. xxxxx://address
// A blank string if this is not supported.
//
#define SERVICE_PROTOCOL            _T("ftp")

//
// Toolbar button background mask. This is
// the colour that gets masked out in
// the bitmap file and replaced with the
// actual button background.  This setting
// is automatically assumed to be lt. gray
// if NORMAL_TB_MAPPING (above) is TRUE
//
#define BUTTON_BMP_BACKGROUND       RGB(192, 192, 192)      // Lt. Gray

//
// Resource ID of the toolbar button bitmap.
//
// The bitmap must be 16x16
//
#define BUTTON_BMP_ID               IDB_FTP

//
// Similar to BUTTON_BMP_BACKGROUND, this is the
// background mask for the service ID
//
#define SERVICE_BMP_BACKGROUND      RGB(255,0,255)          // Purple

//
// Bitmap id which is used in the service view
// of the service manager.  This may be the same
// bitmap as BUTTON_BMP_BACKGROUND.
//
// The bitmap must be 16x16.
//
#define SERVICE_BMP_ID              IDB_FTPVIEW

//
// /* K2 */
//
// Similar to BUTTON_BMP_BACKGROUND, this is the
// background mask for the child bitmap
//
#define CHILD_BMP_BACKGROUND         RGB(255, 0, 255)      // Purple

//
// /* K2 */
//
// Bitmap id which is used for the child bitmap
//
// The bitmap must be 16x16.
//
#define CHILD_BMP_ID                 IDB_FTPDIR
#define CHILD_BMP32_ID               IDB_FTPDIR32

//
// /* K2 */
//
// Large bitmap (32x32) id
//
#define SERVICE_BMP32_ID             IDB_FTPVIEW32

//
// Service Name
//
const LPCTSTR g_cszSvc =            _T("MSFTPSVC");

//
// Help IDs
//
#define HIDD_DIRECTORY_PROPERTIES       (0x207DB)
#define HIDD_HOME_DIRECTORY_PROPERTIES  (HIDD_DIRECTORY_PROPERTIES + 0x20000)

//
// End Of Standard configuration Information
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<




CFTPInstanceProps::CFTPInstanceProps(
    IN LPCTSTR lpszServerName,
    IN DWORD   dwInstance       OPTIONAL
    )
/*++

Routine Description:

    Constructor for FTP instance properties

Arguments:

    LPCTSTR lpszServerName     : Server name
    DWORD   dwInstance         : Instance number (could be MASTER_INSTANCE)

Return Value:

    N/A

--*/
    : CInstanceProps(lpszServerName, g_cszSvc, dwInstance, 21U),
      m_nMaxConnections((LONG)0L),
      m_nConnectionTimeOut((LONG)0L),
      m_dwLogType(MD_LOG_TYPE_DISABLED),
      /**/
      m_strUserName(),
      m_strPassword(),
      m_fAllowAnonymous(FALSE),
      m_fOnlyAnonymous(FALSE),
      m_fPasswordSync(TRUE),
      m_acl(),
      /**/
      m_strExitMessage(),
      m_strMaxConMsg(),
      m_strlWelcome(),
      /**/
      m_fDosDirOutput(TRUE),
      /**/
      m_dwDownlevelInstance(1)
{
    //
    // Fetch everything
    //
    m_dwMDUserType = ALL_METADATA