       0x18a6
#define IDS_COUNTRY_a7                  0x18a7
#define IDS_COUNTRY_a8                  0x18a8
#define IDS_COUNTRY_a9                  0x18a9
#define IDS_COUNTRY_aa                  0x18aa
#define IDS_COUNTRY_ab                  0x18ab
#define IDS_COUNTRY_ac                  0x18ac
#define IDS_COUNTRY_ad                  0x18ad
#define IDS_COUNTRY_ae                  0x18ae
#define IDS_COUNTRY_af                  0x18af
#define IDS_COUNTRY_b0                  0x18b0
#define IDS_COUNTRR_b1                  0x18b1
#define IDS_COUNTRY_b2                  0x18b2
#define IDS_COUNTRY_b3                  0x18b3
#define IDS_COUNTRY_b4                  0x18b4
#define IDS_COUNTRY_b5                  0x18b5
#define IDS_COUNTRY_b6                  0x18b6
#define IDS_COUNTRY_b7                  0x18b7
#define IDS_COUNTRY_b8                  0x18b8
#define IDS_COUNTRY_b9                  0x18b9
#define IDS_COUNTRY_ba                  0x18ba
#define IDS_COUNTRY_bb                  0x18bb
#define IDS_COUNTRY_bc                  0x18bc
#define IDS_COUNTRY_bd                  0x18bd
#define IDS_COUNTRY_be                  0x18be
#define IDS_COUNTRY_bf                  0x18bf
#define IDS_COUNTRY_c0                  0x18c0
#define IDS_COUNTRR_c1                  0x18c1
#define IDS_COUNTRY_c2                  0x18c2
#define IDS_COUNTRY_c3                  0x18c3
#define IDS_COUNTRY_c4                  0x18c4
#define IDS_COUNTRY_RU1                 6500
#define IDS_COUNTRY_RU2                 6501
#define IDS_COUNTRY_RU3                 6502
#define IDS_COUNTRY_RU4                 6503
#define IDS_COUNTRY_RU5                 6504
#define IDS_COUNTRY_RU6                 6505
#define IDS_COUNTRY_RU7                 6506
#define IDS_COUNTRY_RU8                 6507
#define IDS_COUNTRY_RU9                 6508
#define IDS_COUNTRY_RUA                 6509
#define IDS_COUNTRY_RUB                 6510
#define IDS_COUNTRY_RUC                 6511
#define IDS_COUNTRY_RUD                 6512
#define IDS_COUNTRY_RUE                 6513
#define IDS_COUNTRY_YU2                 6600
#define IDS_COUNTRY_YU3                 6601
#define IDS_COUNTRY_YU4                 6602
#define IDS_COUNTRY_YU5                 6603
#define IDS_COUNTRY_YU6                 6604
#define IDC_ST_DIAG_RHS                 10310
#define IDC_DIAG_RHS                    10360
#define IDD_MODEM                       20011
#define IDD_DIAG_WAITMODEM              20012
#define IDS_HARDWARE_ID                 20013
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        133
#define _APS_NEXT_COMMAND_VALUE         101
#define _APS_NEXT_CONTROL_VALUE         1112
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\modemui\cstrings.h ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1993-1994
//
// File: cstrings.h
//
//---------------------------------------------------------------------------

#ifndef _CSTRINGS_H_
#define _CSTRINGS_H_

extern LPGUID c_pguidModem;

extern TCHAR const FAR c_szNULL[];
extern TCHAR const FAR c_szDelim[];
extern TCHAR const FAR c_szBackslash[];

extern TCHAR const FAR c_szWinHelpFile[];

// Registry key names

extern TCHAR const FAR c_szClass[];
extern TCHAR const FAR c_szPortClass[];
extern TCHAR const FAR c_szModemClass[];
extern TCHAR const FAR c_szEnumPropPages[];
extern TCHAR const FAR c_szPortName[];
extern TCHAR const FAR c_szPortSubclass[];
extern TCHAR const FAR c_szConfigDialog[];
extern TCHAR const FAR c_szDeviceDesc[];
extern TCHAR const FAR c_szAttachedTo[];
extern TCHAR const FAR c_szDeviceType[];
extern TCHAR const FAR c_szDeviceCaps[];
extern TCHAR const FAR c_szFriendlyName[];
extern TCHAR const FAR c_szDefault[];
extern TCHAR const FAR c_szDCB[];
extern TCHAR const FAR c_szUserInit[];
extern TCHAR const FAR c_szLogging[];
extern TCHAR const FAR c_szLoggingPath[];
extern TCHAR const FAR c_szPathEnum[];
extern TCHAR const FAR c_szPathRoot[];
extern TCHAR const FAR c_szInactivityScale[];
extern TCHAR const FAR c_szExtension[];

extern TCHAR const FAR c_szVoice[];
extern TCHAR const FAR c_szVoiceProfile[];

extern TCHAR const FAR c_szSerialUI[];

extern TCHAR const FAR c_szMaximumPortSpeed[];

extern TCHAR const c_szCurrentCountry[];

typedef struct
{
    DWORD   dwDTERate;
    int     ids;

} BAUDS;

extern const BAUDS c_rgbauds[]; // Last item has dwDTERate==0.

#endif  // _CSTRINGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\modemui\dll.c ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1993-1995
//
// File: dll.c
//
//  This file contains the library entry points 
//
// History:
//  12-23-93 ScottH     Created
//   9-22-95 ScottH     Ported to NT
//
//---------------------------------------------------------------------------


#include "proj.h"         
#include <rovdbg.h>         // debug assertion code

// Global data
//
BOOL g_bAdminUser;


#ifdef WIN32

CRITICAL_SECTION g_csDll = { 0 };

#endif  // WIN32


DWORD g_dwIsCalledByCpl;

/*----------------------------------------------------------
Purpose: Initialize the DLL
Returns: 
Cond:    --
*/
BOOL PRIVATE Dll_Initialize(void)
    {
    BOOL bRet = TRUE;

    InitCommonControls();

    return bRet;
    }

/*----------------------------------------------------------
Purpose: Unregister window classes per process
Returns: 
Cond:    --
*/
void PRIVATE TermWindowClasses(
    HINSTANCE hinst)
    {
    }


/*----------------------------------------------------------
Purpose: Attach a process to this DLL
Returns: --
Cond:    --
*/
BOOL PRIVATE Dll_ProcessAttach(HINSTANCE hDll)
    {
    BOOL bSuccess = TRUE;

    if (NULL != GetModuleHandle (TEXT("telephon.cpl")))
    {
        g_dwIsCalledByCpl = TRUE;
    }
    else
    {
        g_dwIsCalledByCpl = FALSE;
    }

    InitializeCriticalSection(&g_csDll);

    g_bAdminUser = IsAdminUser();

    g_hinst = hDll;

#ifdef DEBUG

    // We do this simply to load the debug .ini flags
    //
    RovComm_ProcessIniFile();

    TRACE_MSG(TF_GENERAL, "Process Attach (hDll = %lx)", hDll);
    DEBUG_BREAK(BF_ONPROCESSATT);

#endif

    bSuccess = Dll_Initialize();

    return bSuccess;
    }


/*----------------------------------------------------------
Purpose: Detach a process from the DLL
Returns: --
Cond:    --
*/
BOOL PRIVATE Dll_ProcessDetach(HINSTANCE hDll)
    {
    BOOL bSuccess = TRUE;

    ASSERT(hDll == g_hinst);

    DEBUG_CODE( TRACE_MSG(TF_GENERAL, "Process Detach  (hDll = %lx)", hDll); )


    DEBUG_CODE( DEBUG_BREAK(BF_ONPROCESSDET); )

    DeleteCriticalSection(&g_csDll);

    TermWindowClasses(hDll);

    return bSuccess;
    }



HINSTANCE g_hinst = 0;



// **************************************************************************
// WIN32 specific code
// **************************************************************************

#ifdef WIN32

#ifdef DEBUG
BOOL g_bExclusive=FALSE;
#endif


/*----------------------------------------------------------
Purpose: Enter an exclusive section
Returns: --
Cond:    --
*/
void PUBLIC Dll_EnterExclusive(void)
    {
    EnterCriticalSection(&g_csDll);

#ifdef DEBUG
    g_bExclusive = TRUE;
#endif
    }


/*----------------------------------------------------------
Purpose: Leave an exclusive section
Returns: --
Cond:    --
*/
void PUBLIC Dll_LeaveExclusive(void)
    {
#ifdef DEBUG
    g_bExclusive = FALSE;
#endif

    LeaveCriticalSection(&g_csDll);
    }


/*----------------------------------------------------------
Purpose: Win32 Libmain
Returns: --
Cond:    --
*/
BOOL APIENTRY LibMain(
    HANDLE hDll, 
    DWORD dwReason,  
    LPVOID lpReserved)
    {
    switch(dwReason)
        {
    case DLL_PROCESS_ATTACH:

        DEBUG_MEMORY_PROCESS_ATTACH("MODEMUI");

        DisableThreadLibraryCalls(hDll);

        Dll_ProcessAttach(hDll);
        break;

    case DLL_PROCESS_DETACH:

        Dll_ProcessDetach(hDll);

        DEBUG_MEMORY_PROCESS_DETACH();
        break;

    default:
        break;
        } 
    
    return TRUE;
    } 


#else   // WIN32


// **************************************************************************
// WIN16 specific code
// **************************************************************************


BOOL CALLBACK LibMain(HINSTANCE hinst, UINT wDS, DWORD unused)
    {
    return Dll_ProcessAttach(hinst);
    }

BOOL CALLBACK WEP(BOOL fSystemExit)
    {
    return Dll_ProcessDetach(g_hinst);
    }

#endif  // WIN32
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\modemui\cstrings.c ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1993-1994
//
// File: cstrings.c
//
//  This file contains read-only string constants
//
// History:
//  12-23-93 ScottH     Created 
//
//---------------------------------------------------------------------------

#include "proj.h"
#define INITGUID
#include <objbase.h>
#include <initguid.h>
#include <devguid.h>

#pragma data_seg(DATASEG_READONLY)

LPGUID c_pguidModem     = (LPGUID)&GUID_DEVCLASS_MODEM;

TCHAR const FAR c_szNULL[] = TEXT("");
TCHAR const FAR c_szDelim[] = TEXT(" \t,");
TCHAR const FAR c_szBackslash[] = TEXT("\\");

TCHAR const FAR c_szWinHelpFile[] = TEXT("modem.hlp");

// Registry key names

TCHAR const FAR c_szClass[] = REGSTR_KEY_CLASS;
TCHAR const FAR c_szPortClass[] = TEXT("ports");
TCHAR const FAR c_szModemClass[] = TEXT("Modem");
TCHAR const FAR c_szEnumPropPages[] = REGSTR_VAL_ENUMPROPPAGES;
TCHAR const FAR c_szPortName[] = TEXT("PortName");
TCHAR const FAR c_szPortSubclass[] = TEXT("PortSubClass");
TCHAR const FAR c_szConfigDialog[] = TEXT("ConfigDialog");
TCHAR const FAR c_szAttachedTo[] = TEXT("AttachedTo");
TCHAR const FAR c_szDeviceType[] = REGSTR_VAL_DEVTYPE;
TCHAR const FAR c_szDeviceDesc[] = TEXT("DeviceDesc");
TCHAR const FAR c_szDeviceCaps[] = REGSTR_VAL_PROPERTIES;
TCHAR const FAR c_szDefault[] = REGSTR_KEY_DEFAULT;
TCHAR const FAR c_szFriendlyName[] = REGSTR_VAL_FRIENDLYNAME;
TCHAR const FAR c_szDCB[] = TEXT("DCB");
TCHAR const FAR c_szUserInit[] = TEXT("UserInit");
TCHAR const FAR c_szLogging[] = TEXT("Logging");
TCHAR const FAR c_szLoggingPath[] = TEXT("LoggingPath");
TCHAR const FAR c_szPathEnum[] = REGSTR_PATH_ENUM;
TCHAR const FAR c_szPathRoot[] = REGSTR_PATH_ROOT;
TCHAR const FAR c_szInactivityScale[] = TEXT("InactivityScale");
TCHAR const FAR c_szExtension[] = TEXT("EnableExtension");

TCHAR const FAR c_szVoice[] = TEXT("VoiceSwitchFeatures");
TCHAR const FAR c_szVoiceProfile[] = TEXT("VoiceProfile");

TCHAR const FAR c_szSerialUI[] = TEXT("SERIALUI.DLL");

TCHAR const FAR c_szMaximumPortSpeed[] = TEXT("MaximumPortSpeed");

TCHAR const c_szCurrentCountry[]   = TEXT("MSCurrentCountry");

// This is the structure that is used to fill the 
// max speed listbox
BAUDS const c_rgbauds[] = {
        // These numbers must increase monotonically
        { 300L,         IDS_BAUD_300     },
        { 1200L,        IDS_BAUD_1200    },
        { 2400L,        IDS_BAUD_2400    },
        { 4800L,        IDS_BAUD_4800    },
        { 9600L,        IDS_BAUD_9600    },
        { 19200,        IDS_BAUD_19200   },
        { 38400,        IDS_BAUD_38400   },
        { 57600,        IDS_BAUD_57600   },
        { 115200,       IDS_BAUD_115200  },
        { 230400,       IDS_BAUD_230400  },
        { 460800,       IDS_BAUD_460800  },
        { 921600,       IDS_BAUD_921600  },
        { 0,            0  },               // Must be last!
        };


#pragma data_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\modemui\dll.h ===
//
// dll.h
//

#ifndef __DLL_H__
#define __DLL_H__

extern HINSTANCE g_hinst;

#ifdef WIN32

// Notes:
//  1. Never "return" from the critical section.
//  2. Never "SendMessage" or "Yield" from the critical section.
//  3. Never call USER API which may yield.
//  4. Always make the critical section as small as possible.
//  5. Critical sections in Win95 block across processes.  In NT
//     they are per-process only, so use mutexes instead.
// 

#define WIN32_CODE(x)       x

void PUBLIC Dll_EnterExclusive(void);
void PUBLIC Dll_LeaveExclusive(void);

#ifdef WIN95
#define	USER_IS_ADMIN()	TRUE
#else // !WIN95
extern BOOL g_bAdminUser;
#define	USER_IS_ADMIN()	(g_bAdminUser)
#endif // !WIN95

#define ENTER_X()    Dll_EnterExclusive();
#define LEAVE_X()    Dll_LeaveExclusive();
#define ASSERT_X()   ASSERT(g_bExclusive)

#else   // WIN32

#define WIN32_CODE(x)

#define ENTER_X()    
#define LEAVE_X()    
#define ASSERT_X()   

#endif  // WIN32

#endif  //!__DLL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\modemui\helpids.h ===
#define IDH_PROPS_DIAG_ST_MODEM_GRP	2000
#define IDH_PROPS_DIAG_MOREINFOV2	2001
#define IDH_PROPS_DIAG_MOREINFOLV	2002
#define IDH_PROPS_DIAG_REFRESH	2003
#define IDH_PROPS_DIAG_LOGGING	2004
#define IDH_PROPS_DIAG_VIEWLOG	2005
#define IDH_NEW	2006
#define IDH_PROPS_GENERAL_SPEAKER	2007
#define IDH_PROPS_GENERAL_SPEED	2008
#define IDH_PROPS_GENERAL_WAITFORDIALTONE	2009
#define IDH_PROPS_EXTRA_SETTINGS_GRP	2010
#define IDH_PROPS_ADV_EXTRA_INIT_COMMANDS	2011
#define IDH_PROPS_ADV_WAIT_CREDIT_CARD_TONE	2012
#define IDH_PROPS_ADV_BN_PORTSETTINGS	2013
#define IDH_PROPS_ADV_BN_DEFAULTS	2014
#define IDH_CFG_ADV_TERMINALGRP	2015
#define IDH_CFG_ADV_TERMINAL_PRE	2016
#define IDH_CFG_ADV_TERMINAL_POST	2017
#define IDH_CFG_ADV_TERMINALGRP2	2018
#define IDH_CFG_ADV_DATABITS	2019
#define IDH_CFG_ADV_PARITY	2020
#define IDH_CFG_ADV_STOPBITS	2021
#define IDH_CFG_ADV_MODULATION	2022
#define IDH_CFG_GEN_CALL_PREF	2023
#define IDH_CFG_GEN_MANUAL_DIAL	2024
#define IDH_CFG_GEN_IDLETIMER	2025
#define IDH_CFG_GEN_DIALTIMER	2026
#define IDH_CFG_GEN_DATA_GR	2027
#define IDH_CFG_GEN_PORT_SPEED	2028
#define IDH_CFG_GEN_DATA_PROTOCOL	2029
#define IDH_CFG_GEN_COMPRESSION	2030
#define IDH_CFG_GEN_FLOW_CONTROL	2031
#define IDH_CHEAPRING_RING_CHECK	2032
#define IDH_CHEAPRING_RING	2033
#define IDH_RING_RING_CHECK	2034
#define IDH_RING_PRIMARY_ADDRESS	2035
#define IDH_RING_ADDRESS	2036
#define IDH_RING_ADDRESS_RING_PATTERN	2037
#define IDH_RING_ADDRESS_TYPE_OF_CALL	2038
#define IDH_RING_PRIORITY_CALLERS	2039
#define IDH_RING_PRIORITY_RING_PATTERN	2040
#define IDH_RING_PRIORITY_TYPE_OF_CALL	2041
#define IDH_RING_CALLBACK	2042
#define IDH_RING_CALLBACK_RING_PATTERN	2043
#define IDH_RING_CALLBACK_TYPE_OF_CALL	2044
#define IDH_ISDN_SWITCH_TYPE	2045
#define IDH_ISDN_N1	2046
#define IDH_ISDN_ID1	2047
#define IDH_ISDN_N2	2048
#define IDH_ISDN_ID2	2049
#define IDH_PROPS_GENERAL_PORT  2050
#define IDH_RING_CALLBACK_TYPE_OF_CALL_CALLBACK 2051
#define IDH_PROPS_ADV_COUNTRY_SELECT			2070

extern const DWORD g_aHelpIDs_IDD_ADV_MODEM[];
extern const DWORD g_aHelpIDs_IDD_CFG_ADVANCED[];
extern const DWORD g_aHelpIDs_IDD_CFG_GENERAL[];
extern const DWORD g_aHelpIDs_IDD_CHEAPRING[];
extern const DWORD g_aHelpIDs_IDD_CPL_ISDN[];
extern const DWORD g_aHelpIDs_IDD_DIAGNOSTICS[];
extern const DWORD g_aHelpIDs_IDD_GENERAL[];
extern const DWORD g_aHelpIDs_IDD_RING[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\modemui\modem.h ===
//
// modem.h
//

#ifndef __MODEM_H__
#define __MODEM_H__

//****************************************************************************
//
//****************************************************************************

// Global flags for the CPL, and their values:
extern int g_iCPLFlags;

#define FLAG_INSTALL_NOUI       0x0002
#define FLAG_PROCESS_DEVCHANGE  0x0004


#define INSTALL_NOUI()          (g_iCPLFlags & FLAG_INSTALL_NOUI)

#define LVIF_ALL                LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM | LVIF_STATE

extern DWORD gDeviceFlags;

#define fDF_DEVICE_NEEDS_REBOOT 0x2


//-----------------------------------------------------------------------------------
//  cpl.c
//-----------------------------------------------------------------------------------

// Constant strings
extern TCHAR const c_szAttachedTo[];
extern TCHAR const c_szDeviceType[];
extern TCHAR const c_szFriendlyName[];

//-----------------------------------------------------------------------------------
//  util.c
//-----------------------------------------------------------------------------------

// Private modem properties structure
typedef struct tagMODEM_PRIV_PROP
    {
    DWORD   cbSize;
    DWORD   dwMask;     
    TCHAR   szFriendlyName[MAX_BUF_REG];
    DWORD   nDeviceType;
    TCHAR   szPort[MAX_BUF_REG];
    } MODEM_PRIV_PROP, FAR * PMODEM_PRIV_PROP;

// Mask bitfield for MODEM_PRIV_PROP
#define MPPM_FRIENDLY_NAME  0x00000001
#define MPPM_DEVICE_TYPE    0x00000002
#define MPPM_PORT           0x00000004

BOOL
PUBLIC
CplDiGetPrivateProperties(
    IN  HDEVINFO        hdi,
    IN  PSP_DEVINFO_DATA pdevData,
    OUT PMODEM_PRIV_PROP pmpp);


BOOL
PUBLIC
CplDiGetModemDevs(
    OUT HDEVINFO FAR *  phdi,
    IN  HWND            hwnd,
    IN  DWORD           dwFlags,        // DIGCF_ bit field
    OUT BOOL FAR *      pbInstalled);

//-----------------------------------------------------------------------------------
//  shell32p.lib
//-----------------------------------------------------------------------------------

int
RestartDialog(
    IN HWND hwnd,
    IN PTSTR Prompt,
    IN DWORD Return);

SHSTDAPI_(int) RestartDialogEx(HWND hwnd, LPCTSTR lpPrompt, DWORD dwReturn, DWORD dwReasonCode);

#endif  // __MODEM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\modemui\helpids.c ===
#include "proj.h"
		
#pragma data_seg(DATASEG_READONLY)
const DWORD g_aHelpIDs_IDD_ADV_MODEM[]= {		
	IDC_AM_EXTRA3,	((DWORD) -1),
	IDC_WAIT_TEXT2,	IDH_PROPS_ADV_EXTRA_INIT_COMMANDS,
	IDC_AM_EXTRA_ED,	IDH_PROPS_ADV_EXTRA_INIT_COMMANDS,
	IDC_WAIT_TEXT,	IDH_PROPS_ADV_WAIT_CREDIT_CARD_TONE,
	IDC_WAIT_SEC,	IDH_PROPS_ADV_WAIT_CREDIT_CARD_TONE,
	IDC_WAIT_UNIT,	IDH_PROPS_ADV_WAIT_CREDIT_CARD_TONE,
	IDC_BN_PORTSETTINGS,	IDH_PROPS_ADV_BN_PORTSETTINGS,
	IDC_BN_DEFAULTS,	IDH_PROPS_ADV_BN_DEFAULTS,
    IDC_AM_COUNTRY,     IDH_PROPS_ADV_COUNTRY_SELECT,
    IDC_CB_COUNTRY,     IDH_PROPS_ADV_COUNTRY_SELECT,
0, 0 };		

const DWORD g_aHelpIDs_IDD_CFG_ADVANCED[]= {		
	IDC_TERMINALGRP,	IDH_CFG_ADV_TERMINALGRP,
	IDC_TERMINAL_PRE,	IDH_CFG_ADV_TERMINAL_PRE,
	IDC_TERMINAL_POST,	IDH_CFG_ADV_TERMINAL_POST,
	IDC_TERMINALGRP2,	IDH_CFG_ADV_TERMINALGRP2,
	IDC_LBL_DATABITS,	IDH_CFG_ADV_DATABITS,
	IDC_CB_DATABITS,	IDH_CFG_ADV_DATABITS,
	IDC_LBL_PARITY,	IDH_CFG_ADV_PARITY,
	IDC_CB_PARITY,	IDH_CFG_ADV_PARITY,
	IDC_LBL_STOPBITS,	IDH_CFG_ADV_STOPBITS,
	IDC_CB_STOPBITS,	IDH_CFG_ADV_STOPBITS,
	IDC_LBL_MOD2,	IDH_CFG_ADV_MODULATION,
	IDC_CB_MOD,	IDH_CFG_ADV_MODULATION,
0, 0 };		

const DWORD g_aHelpIDs_IDD_CFG_GENERAL[]= {		
	IDC_CALL_PREF,	IDH_CFG_GEN_CALL_PREF,
	IDC_MANUAL_DIAL,	IDH_CFG_GEN_MANUAL_DIAL,
	IDC_CH_IDLETIMER,	IDH_CFG_GEN_IDLETIMER,
	IDC_ED_IDLETIMER,	IDH_CFG_GEN_IDLETIMER,
	IDC_MINUTES,	IDH_CFG_GEN_IDLETIMER,
	IDC_ED_DIALTIMER,	IDH_CFG_GEN_DIALTIMER,
	IDC_SECONDS,	IDH_CFG_GEN_DIALTIMER,
	IDC_LBL_PS,	IDH_CFG_GEN_PORT_SPEED,
	IDC_CB_SPEED,	IDH_CFG_GEN_PORT_SPEED,
	IDC_LBL_EC,	IDH_CFG_GEN_DATA_PROTOCOL,
	IDC_CB_EC,	IDH_CFG_GEN_DATA_PROTOCOL,
	IDC_LBL_COMP,	IDH_CFG_GEN_COMPRESSION,
	IDC_CB_COMP,	IDH_CFG_GEN_COMPRESSION,
	IDC_LBL_FC,	IDH_CFG_GEN_FLOW_CONTROL,
	IDC_CB_FC,	IDH_CFG_GEN_FLOW_CONTROL,
//	IDC_PB_CPLPROPS,	IDH_CFG_GEN_CPLPROPS,
0, 0 };		

const DWORD g_aHelpIDs_IDD_CHEAPRING[]= {		
	IDC_RING_GROUP,	IDH_CHEAPRING_RING_CHECK,
	IDC_RING_CHECK,	IDH_CHEAPRING_RING_CHECK,
	IDC_LBL_RING1,	IDH_CHEAPRING_RING,
	IDC_TYPE_RING1,	IDH_CHEAPRING_RING,
	IDC_LBL_RING2,	IDH_CHEAPRING_RING,
	IDC_TYPE_RING2,	IDH_CHEAPRING_RING,
	IDC_LBL_RING3,	IDH_CHEAPRING_RING,
	IDC_TYPE_RING3,	IDH_CHEAPRING_RING,
0, 0 };		

const DWORD g_aHelpIDs_IDD_CPL_ISDN[]= {		
	IDC_CB_ISDN_ST,	IDH_ISDN_SWITCH_TYPE,
	IDC_EB_ISDN_N1,	IDH_ISDN_N1,
	IDC_LBL_FC,	IDH_ISDN_ID1,
	IDC_EB_ISDN_ID1,	IDH_ISDN_ID1,
	IDC_EB_ISDN_N2,	IDH_ISDN_N2,
	IDC_LBL_FC2,	IDH_ISDN_ID2,
	IDC_EB_ISDN_ID2,	IDH_ISDN_ID2,
0, 0 };		

const DWORD g_aHelpIDs_IDD_DIAGNOSTICS[]= {		
	IDC_ST_MODEM_GRP,	IDH_PROPS_DIAG_ST_MODEM_GRP,
	IDC_MOREINFOV2,	IDH_PROPS_DIAG_MOREINFOV2,
	IDC_MOREINFOLV,	IDH_PROPS_DIAG_MOREINFOLV,
	IDC_REFRESH,	IDH_PROPS_DIAG_REFRESH,
	IDC_LOGGING,	IDH_PROPS_DIAG_LOGGING,
	IDC_VIEWLOG,	IDH_PROPS_DIAG_VIEWLOG,
0, 0 };		
		
const DWORD g_aHelpIDs_IDD_GENERAL[]= {		
	IDC_LBL_PORT,	IDH_PROPS_GENERAL_PORT,
	IDC_PORT_TEXT,	IDH_PROPS_GENERAL_PORT,
	IDC_SPEAKER,	IDH_PROPS_GENERAL_SPEAKER,
	IDC_VOLUME,	    IDH_PROPS_GENERAL_SPEAKER,
    IDC_LBL_OFF,    IDH_PROPS_GENERAL_SPEAKER,
    IDC_LOUD,       IDH_PROPS_GENERAL_SPEAKER,
	IDC_SPEED,	    IDH_PROPS_GENERAL_SPEED,
	IDC_CB_SPEED,	IDH_PROPS_GENERAL_SPEED,
	IDC_CALL_PREF,	IDH_PROPS_GENERAL_WAITFORDIALTONE,
	IDC_WAITFORDIALTONE,	IDH_PROPS_GENERAL_WAITFORDIALTONE,
0, 0 };		


//		
const DWORD g_aHelpIDs_IDD_RING[]= {		
	IDC_RING_CHECK,	IDH_RING_RING_CHECK,
	IDC_RING_GROUP,	IDH_RING_RING_CHECK,
	IDC_LBL_ADDR_PRI,	IDH_RING_PRIMARY_ADDRESS,
	IDC_ADDR_PRI,	IDH_RING_ADDRESS_RING_PATTERN,
	IDC_TYPE_ADDR_PRI,	IDH_RING_ADDRESS_TYPE_OF_CALL,
	IDC_LBL_ADDR1,	IDH_RING_ADDRESS,
	IDC_ADDR1,	IDH_RING_ADDRESS_RING_PATTERN,
	IDC_TYPE_ADDR1,	IDH_RING_ADDRESS_TYPE_OF_CALL,
	IDC_LBL_ADDR2,	IDH_RING_ADDRESS,
	IDC_ADDR2,	IDH_RING_ADDRESS_RING_PATTERN,
	IDC_TYPE_ADDR2,	IDH_RING_ADDRESS_TYPE_OF_CALL,
	IDC_LBL_ADDR3,	IDH_RING_ADDRESS,
	IDC_ADDR3,	IDH_RING_ADDRESS_RING_PATTERN,
	IDC_TYPE_ADDR3,	IDH_RING_ADDRESS_TYPE_OF_CALL,
	IDC_LBL_PRI_CALLERS,	IDH_RING_PRIORITY_CALLERS,
	IDC_PRI_CALLERS,	IDH_RING_PRIORITY_RING_PATTERN,
	IDC_TYPE_PRI_CALLERS,	IDH_RING_PRIORITY_TYPE_OF_CALL,
	IDC_LBL_CALLBACK,	IDH_RING_CALLBACK,
	IDC_CALLBACK,	IDH_RING_CALLBACK_RING_PATTERN,
	IDC_TYPE_CALLBACK,	IDH_RING_CALLBACK_TYPE_OF_CALL_CALLBACK,
0, 0 };		
#pragma data_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\modemui\rcids.h ===
//{{NO_DEPENDENCIES}}
// App Studio generated include file.
// Used by SYNCUI.RC
//

// Icon values
//
#define IDI_NULL_MODEM                  700
#define IDI_EXTERNAL_MODEM              701
#define IDI_INTERNAL_MODEM              702
#define IDI_PCMCIA_MODEM                703

// Bitmap values
//
#define IDB_ACTIONS                     108
#define IDB_SMALLACTIONS_MASK           111
#define IDB_CONTAIN                     801
#define IDB_CONTAIN_MASK                802
#define IDB_ACTIONS_MASK                803
#define IDB_SMALLACTIONS                804
#define IDB_MENU_MASK                   806
#define IDB_MENU                        806

// Random stuff
//
#define IDS_NULL_MODEM                  180
#define IDS_EXTERNAL_MODEM              181
#define IDS_INTERNAL_MODEM              182
#define IDS_PCMCIA_MODEM                183
#define IDS_PARALLEL_MODEM              184
#define IDS_PARALLEL_PORT               185

#define IDS_BAUD_110                    200
#define IDS_BAUD_1200                   201
#define IDS_BAUD_2400                   202
#define IDS_BAUD_4800                   203
#define IDS_BAUD_9600                   204
#define IDS_BAUD_14400                  205
#define IDS_BAUD_19200                  206
#define IDS_BAUD_38400                  207
#define IDS_BAUD_56K                    208
#define IDS_BAUD_128K                   209
#define IDS_BAUD_115200                 210
#define IDS_BAUD_57600                  211
//#define IDS_BAUD_FASTEST                212
#define IDS_BAUD_075                    213
#define IDS_BAUD_134_5                  214     
#define IDS_BAUD_150                    215     
#define IDS_BAUD_300                    216     
#define IDS_BAUD_600                    217     
#define IDS_BAUD_1800                   218     
#define IDS_BAUD_7200                   219     
#define IDS_BAUD_230400                 220
#define IDS_BAUD_460800                 221
#define IDS_BAUD_921600                 222

#define IDS_BYTESIZE_4                  240
#define IDS_BYTESIZE_5                  241
#define IDS_BYTESIZE_6                  242
#define IDS_BYTESIZE_7                  243
#define IDS_BYTESIZE_8                  244

#define IDS_PARITY_EVEN                 250
#define IDS_PARITY_ODD                  251
#define IDS_PARITY_NONE                 252
#define IDS_PARITY_MARK                 253
#define IDS_PARITY_SPACE                254
#define IDS_STOPBITS_1                  255
#define IDS_STOPBITS_1_5                256
#define IDS_STOPBITS_2                  257

#define IDS_FLOWCTL_XONXOFF             260
#define IDS_FLOWCTL_HARDWARE            261
#define IDS_FLOWCTL_NONE                262

#define IDS_ON                          263
#define IDS_SOFT                        264

#define IDS_CCITT_V23                   265
#define IDS_CCITT_V21V22                266
#define IDS_BELL                        267

#define IDS_LOGFILE                     270

#define IDS_UNSPECIFIED                 300
#define IDS_DATA                        301                                          
#define IDS_FAX                         302
#define IDS_VOICE                       303
#define IDS_AUTOMATIC                   304

// Messages
//

#define IDS_OK_COUNTRY                  320

// Captions                             
//
#define IDS_CAP_GENERAL                 340
#define IDS_CAP_SETTINGS                341
#define IDS_CAP_RING                    342
#define IDS_CAP_CALLFWD                 343

// Formatted strings
//

// Error strings
//
#define IDS_ERR_COUNTRY                 400
#define IDS_ERR_LONGSTRING              401
#define IDS_ERR_WARNING                 402

// Out-of-memory strings
//
#define IDS_OOM_GENERAL                 460
#define IDS_OOM_SETTINGS                461
#define IDS_OOM_PORT                    462
#define IDS_ERR_DUP_PATTERN             463
#define IDS_ERR_NEED_VALUE              464


// Context sensitive help ids (as assigned in windows.hlp)
//
#define IDH_UNI_GEN_MODEM               5050
#define IDH_UNI_GEN_PORT                5051
#define IDH_UNI_GEN_VOLUME              5052
#define IDH_UNI_GEN_MAX_SPEED           5053
#define IDH_UNI_GEN_THIS_SPEED          5054
#define IDH_UNI_CON_PREFS               5055
#define IDH_UNI_CON_CALL_PREFS          5056

#define IDH_UNI_CON_DIALTONE            5058
#define IDH_UNI_CON_CANCEL              5059
#define IDH_UNI_CON_DISCONNECT          5060

#define IDH_UNI_CON_ADVANCED            5062
#define IDH_UNI_CON_ADV_ERROR           5063
#define IDH_UNI_CON_ADV_REQUIRED        5064
#define IDH_UNI_CON_ADV_COMPRESS        5065
#define IDH_UNI_CON_ADV_CELLULAR        5066
#define IDH_UNI_CON_ADV_FLOW            5067
#define IDH_UNI_CON_ADV_MODULATION      5068
#define IDH_UNI_CON_ADV_CSITT           5069
#define IDH_UNI_CON_ADV_BELL            5070
#define IDH_UNI_CON_ADV_EXTRA           5071
#define IDH_UNI_CON_ADV_AUDIT           5072

#define IDH_UNI_GEN_PORT_INT            5081

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        113
#define _APS_NEXT_COMMAND_VALUE         105
#define _APS_NEXT_CONTROL_VALUE         1006
#define _APS_NEXT_SYMED_VALUE           105
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\modemui\proj.h ===
//
// proj.h:  Includes all files that are to be part of the precompiled
//             header.
//

#ifndef __PROJ_H__
#define __PROJ_H__

#define STRICT

#if DBG > 0 && !defined(DEBUG)
#define DEBUG
#endif
#if DBG > 0 && !defined(FULL_DEBUG)
#define FULL_DEBUG
#endif

#define UNICODE

// Defines for rovcomm.h

#define NODA
#define NOSHAREDHEAP
#define NOFILEINFO
#define NOCOLORHELP
#define NODRAWTEXT
#define NOPATH
#define NOSYNC
#ifndef DEBUG
#define NOPROFILE
#endif

#define SZ_MODULEA      "MODEMUI"
#define SZ_MODULEW      TEXT("MODEMUI")

#ifdef DEBUG
#define SZ_DEBUGSECTION TEXT("MODEMUI")
#define SZ_DEBUGINI     TEXT("unimdm.ini")
#endif // DEBUG

// Includes

#define USECOMM

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#undef ASSERT

#define ISOLATION_AWARE_ENABLED 1
#include <windows.h>        
#include <windowsx.h>

#include <winerror.h>
#include <commctrl.h>       // needed by shlobj.h and our progress bar
#include <prsht.h>          // Property sheet stuff
#define SIDEBYSIDE_COMMONCONTROLS 1


#include <rovcomm.h>

#include <setupapi.h>       // PnP setup/installer services
#include <cfgmgr32.h>
#include <tapi.h>
#include <unimdmp.h>        // Microsoft-internal unimodem exports
#include <modemp.h>
#include <regstr.h>

#include <debugmem.h>

#include <shellapi.h>       // for registration functions
#include <unimodem.h>
#include <tspnotif.h>
#include <slot.h>

#include <winuserp.h>


// local includes
//
#include "modemui.h"
#include "util.h"           // Utility functions
#include "dll.h"
#include "cstrings.h"       // Read-only string constants
#include "dlgids.h"
#include "helpids.h"

#include "modem.h"
#include "dlgids.h"

extern const LBMAP s_rgErrorControl[];

///****************************************************************************
//  debug stuff
//****************************************************************************

#ifdef DEBUG

#define DBG_EXIT_BOOL_ERR(fn, b)                      \
        g_dwIndent-=2;                                \
        TRACE_MSG(TF_FUNC, "< " #fn "() with %s (%#08lx)", (b) ? (LPTSTR)TEXT("TRUE") : (LPTSTR)TEXT("FALSE"), GetLastError())

#define ELSE_TRACE(_a)  \
    else                \
    {                   \
        TRACE_MSG _a;   \
    }

#else // DEBUG

#define DBG_EXIT_BOOL_ERR(fn, b)
#define ELSE_TRACE(_a)

#endif // DEBUG

//****************************************************************************
// 
//****************************************************************************

// Dump flags
#define DF_DCB              0x00000001
#define DF_MODEMSETTINGS    0x00000002
#define DF_DEVCAPS          0x00000004

// Trace flags
#define TF_DETECT           0x00010000
#define TF_REG              0x00020000


// This structure is private data for the main modem dialog
typedef struct tagMODEMDLG
{
    HDEVINFO    hdi;
    HDEVNOTIFY  NotificationHandle;
    int         cSel;
    DWORD       dwFlags;
} MODEMDLG, FAR * LPMODEMDLG;


void PUBLIC GetModemImageIndex(
    BYTE nDeviceType,
    int FAR * pindex
    );

HANDLE WINAPI
GetModemCommHandle(
    LPCTSTR         FriendlyName,
    PVOID       *TapiHandle
    );

VOID WINAPI
FreeModemCommHandle(
    PVOID      *TapiHandle
    );


ULONG
_cdecl
DbgPrint(
    PCH Format,
    ...
    );

#ifndef MAXDWORD
#define MAXDWORD 0xffffffff
#endif

#endif  //!__PROJ_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\modemui\tapi.c ===
#include "proj.h"

#include <tapi.h>

#define  DYN_LOAD  1

#if DBG

ULONG
_cdecl
DbgPrint(
    PCH Format,
    ...
    );



#define IF_LOUD(_x) {_x}
#define IF_ERROR(_x) {_x}

#else

#define IF_LOUD(_x) {}
#define IF_ERROR(_x) {}


#endif

#ifdef DYN_LOAD
typedef
LONG
(*PFN_lineInitializeExW)(                                               // TAPI v2.0
    LPHLINEAPP                  lphLineApp,
    HINSTANCE                   hInstance,
    LINECALLBACK                lpfnCallback,
    LPCWSTR                     lpszFriendlyAppName,
    LPDWORD                     lpdwNumDevs,
    LPDWORD                     lpdwAPIVersion,
    LPLINEINITIALIZEEXPARAMS    lpLineInitializeExParams
    );

typedef
LONG
(*PFN_lineMakeCallW)(
    HLINE               hLine,
    LPHCALL             lphCall,
    LPCWSTR             lpszDestAddress,
    DWORD               dwCountryCode,
    LPLINECALLPARAMS    const lpCallParams
    );

typedef
LONG
(*PFN_lineOpenW)(
    HLINEAPP hLineApp,
    DWORD dwDeviceID,
    LPHLINE lphLine,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    DWORD_PTR           dwCallbackInstance,
    DWORD               dwPrivileges,
    DWORD               dwMediaModes,
    LPLINECALLPARAMS    const lpCallParams
    );

typedef
LONG
(*PFN_lineGetDevCapsW)(
    HLINEAPP            hLineApp,
    DWORD               dwDeviceID,
    DWORD               dwAPIVersion,
    DWORD               dwExtVersion,
    LPLINEDEVCAPS       lpLineDevCaps
    );

typedef
LONG
(*PFN_lineGetIDW)(
    HLINE               hLine,
    DWORD               dwAddressID,
    HCALL               hCall,
    DWORD               dwSelect,
    LPVARSTRING         lpDeviceID,
    LPCWSTR             lpszDeviceClass
    );

typedef
LONG
(*PFN_lineDrop)(
    HCALL               hCall,
    LPCSTR              lpsUserUserInfo,
    DWORD               dwSize
    );

typedef
LONG
(*PFN_lineDeallocateCall)(
    HCALL               hCall
    );


typedef
LONG
(*PFN_lineClose)(
    HLINE               hLine
    );

typedef
LONG
(*PFN_lineShutdown)(
    HLINEAPP            hLineApp
    );

#endif // DYN_LOAD

typedef struct _CONTROL_OBJECT {

    LONG       LineReplyToWaitFor;
    HLINE      hLine;
    HCALL      hCall;
    HLINEAPP   hLineApp;
    DWORD      NumberOfLineDevs;

    DWORD      CallStateToWaitFor;

    HANDLE     CommHandle;

    BOOL volatile StopWaiting;
    BOOL volatile StopWaitingForCallState;

    LPTSTR      ModemRegKey;

#ifdef DYN_LOAD
    HINSTANCE               hLib;
    PFN_lineInitializeExW   pfn_lineInitializeExW;
    PFN_lineMakeCallW       pfn_lineMakeCallW;
    PFN_lineOpenW           pfn_lineOpenW;
    PFN_lineGetDevCapsW     pfn_lineGetDevCapsW;
    PFN_lineGetIDW          pfn_lineGetIDW;
    PFN_lineDrop            pfn_lineDrop;
    PFN_lineDeallocateCall  pfn_lineDeallocateCall;
    PFN_lineClose           pfn_lineClose;
    PFN_lineShutdown        pfn_lineShutdown;
#endif
} CONTROL_OBJECT, *PCONTROL_OBJECT;




DWORD
MakeTheCall(
    PCONTROL_OBJECT  pControl
    );


BOOL WINAPI
WaitForLineReply(
    PCONTROL_OBJECT    pControl,
    LONG               ReplyToWaitFor,
    DWORD              msToWait
    );

BOOL WINAPI
WaitForCallState(
    PCONTROL_OBJECT    pControl,
    DWORD              msToWait
    );

VOID WINAPI
TapiCallback(
    DWORD hDevice, 
    DWORD dwMsg, 
    DWORD_PTR dwCallbackInstance,
    DWORD_PTR dwParam1,
    DWORD_PTR dwParam2,
    DWORD_PTR dwParam3
    )
{
    PCONTROL_OBJECT  pControl=(PCONTROL_OBJECT)dwCallbackInstance;

    switch (dwMsg) {

        case LINE_REPLY:

            IF_LOUD(DbgPrint("LineReply: %d\n\r",dwParam1);)

            if (pControl->LineReplyToWaitFor == (LONG)dwParam1) {

                pControl->StopWaiting = TRUE;
            }

            break;

        case LINE_CALLSTATE:

            IF_LOUD(DbgPrint("LINECALL_STATE\n\r");)

            if (pControl->CallStateToWaitFor == dwParam1) {

                pControl->StopWaitingForCallState=TRUE;
            }

            break;

        default:

            break;
    }

    return;

}

#ifdef DYN_LOAD
BOOL
LoadTapi32(
    PCONTROL_OBJECT    pControl
    )

{
    TCHAR szLib[MAX_PATH];

    GetSystemDirectory(szLib,sizeof(szLib) / sizeof(TCHAR));
    lstrcat(szLib,TEXT("\\tapi32.dll"));
    pControl->hLib=LoadLibrary(szLib);

    if (pControl->hLib == NULL) {
        IF_ERROR(DbgPrint("Could Not Load tapi32.dll\n\r");)
        return FALSE;
    }

    pControl->pfn_lineInitializeExW  =(PFN_lineInitializeExW)GetProcAddress(pControl->hLib,"lineInitializeExW");
    pControl->pfn_lineMakeCallW      =(PFN_lineMakeCallW)GetProcAddress(pControl->hLib,"lineMakeCallW");
    pControl->pfn_lineOpenW          =(PFN_lineOpenW)GetProcAddress(pControl->hLib,"lineOpenW");
    pControl->pfn_lineGetDevCapsW    =(PFN_lineGetDevCapsW)GetProcAddress(pControl->hLib,"lineGetDevCapsW");
    pControl->pfn_lineGetIDW         =(PFN_lineGetIDW)GetProcAddress(pControl->hLib,"lineGetIDW");
    pControl->pfn_lineDrop           =(PFN_lineDrop)GetProcAddress(pControl->hLib,"lineDrop");
    pControl->pfn_lineDeallocateCall =(PFN_lineDeallocateCall)GetProcAddress(pControl->hLib,"lineDeallocateCall");
    pControl->pfn_lineClose          =(PFN_lineClose)GetProcAddress(pControl->hLib,"lineClose");
    pControl->pfn_lineShutdown       =(PFN_lineShutdown)GetProcAddress(pControl->hLib,"lineShutdown");

    if (pControl->pfn_lineInitializeExW &&
        pControl->pfn_lineMakeCallW     &&
        pControl->pfn_lineOpenW         &&
        pControl->pfn_lineGetDevCapsW   &&
        pControl->pfn_lineGetIDW        &&
        pControl->pfn_lineDrop          &&
        pControl->pfn_lineDeallocateCall&&
        pControl->pfn_lineClose         &&
        pControl->pfn_lineShutdown      ) {

        return TRUE;
    }

    IF_ERROR(DbgPrint("Could Not get procedure\n\r");)
    return FALSE;
}
#endif



HANDLE WINAPI
GetModemCommHandle(
    LPCTSTR         FriendlyName,
    PVOID       *TapiHandle
    )

{
  
    PCONTROL_OBJECT    pControl;
    VARSTRING         *VarString;
    LONG               Result;
    LPLINEDEVCAPS      lpDevCaps;
    UINT               i;
    LPSTR              lpDevSpec;
    DWORD              ApiVersion=0x00020000;

    LINEINITIALIZEEXPARAMS Params;

    IF_LOUD(DbgPrint("GetModemCommHandle: Entered\n\r");)

    *TapiHandle=NULL;

    pControl=ALLOCATE_MEMORY(sizeof(CONTROL_OBJECT));

    if (NULL == pControl) {

        return NULL;
    }

#ifdef DYN_LOAD
    if (!LoadTapi32(pControl)) {
        IF_ERROR(DbgPrint("Could Not Loadtapi\n\r");)
        goto Cleanup011;
    }
#endif



    ZeroMemory(&Params,sizeof(LINEINITIALIZEEXPARAMS));

    Params.dwTotalSize=sizeof(LINEINITIALIZEEXPARAMS);
    Params.dwOptions=LINEINITIALIZEEXOPTION_USEHIDDENWINDOW;

#ifdef DYN_LOAD
    Result=(*pControl->pfn_lineInitializeExW)(
#else
    Result=lineInitializeEx(
#endif
        &pControl->hLineApp,
        g_hinst,
        TapiCallback,
        TEXT("Modem Diagnostics"),
        &pControl->NumberOfLineDevs,
        &ApiVersion,
        &Params
        );

    if (Result < 0) {
        IF_ERROR(DbgPrint("lineInitialize Failed %08x\n\r",Result);)
        goto Cleanup012;
    }

    lpDevCaps=ALLOCATE_MEMORY( sizeof(LINEDEVCAPS)+4096);

//    lpDevCaps->dwTotalSize=sizeof(LINEDEVCAPS)+4096;

    IF_LOUD(DbgPrint("LineDevices =%d\n\r",pControl->NumberOfLineDevs);)

    //
    //  find the line that matches the name passed in
    //
    for (i=0; i < pControl->NumberOfLineDevs; i++) {

        ZeroMemory(lpDevCaps,sizeof(LINEDEVCAPS)+4096);
        lpDevCaps->dwTotalSize=sizeof(LINEDEVCAPS)+4096;
#ifdef DYN_LOAD
        Result=(*pControl->pfn_lineGetDevCapsW)(
#else
        Result=lineGetDevCaps(
#endif
            pControl->hLineApp,
            i,
            0x00010004,
            0,
            lpDevCaps
            );

        if (0 == Result && lpDevCaps->dwLineNameOffset != 0 && lpDevCaps->dwLineNameSize != 0) {

            LPTSTR      lpLineName;

            lpLineName=(LPTSTR)(((LPBYTE)lpDevCaps)+lpDevCaps->dwLineNameOffset);

            IF_LOUD(DbgPrint("Line %d Name is %ws\n\r",i,lpLineName);)

            if (lstrcmp(lpLineName,FriendlyName) == 0) {
                //
                // found a match, stop looking
                //
                IF_LOUD(DbgPrint("Found match\n\r");)

                break;
            }
        } else {


            IF_ERROR(DbgPrint("lineGetDevCaps(%d) returned %08lx\n\r",i,Result);)
        }
    }

    FREE_MEMORY(lpDevCaps);

    if (i >= pControl->NumberOfLineDevs) {
        //
        //  did not find the line
        //
        goto Cleanup015;
    }

#ifdef DYN_LOAD
    Result=(*pControl->pfn_lineOpenW)(
#else
    Result=lineOpen(
#endif
        pControl->hLineApp,
        i,
        &pControl->hLine,
        0x00020000,
        0,
        (DWORD_PTR)pControl,
        LINECALLPRIVILEGE_NONE,
        LINEMEDIAMODE_DATAMODEM,
        NULL
        );

    if (0 != Result) {
        IF_ERROR(DbgPrint("lineOpen Failed %08x\n\r",Result);)
        goto Cleanup015;
    }

    Result=MakeTheCall(
        pControl
        );

    if (Result == 0) {
        IF_ERROR(DbgPrint("MakeTheCall: failed\n\r");)
        goto Cleanup020;
    }

    VarString=ALLOCATE_MEMORY(sizeof(VARSTRING)+(MAX_PATH*sizeof(TCHAR)));

    if (NULL == VarString) {

        goto Cleanup040;
    }    

    VarString->dwTotalSize=sizeof(VARSTRING)+MAX_PATH*sizeof(TCHAR);
    VarString->dwStringFormat=STRINGFORMAT_BINARY;

#ifdef DYN_LOAD
    Result=(*pControl->pfn_lineGetIDW)(
#else
    Result=lineGetID(
#endif
        pControl->hLine,
        0,
        0,
        LINECALLSELECT_LINE,
        VarString,
        TEXT("COMM/DATAMODEM")
        );

    if (Result < 0) {
        IF_ERROR(DbgPrint("lineGetId Failed %08x\n\r",Result);)
        goto Cleanup040;
    }

    pControl->CommHandle=*((HANDLE *)((PUCHAR)VarString+VarString->dwStringOffset));

    *TapiHandle=pControl;

    FREE_MEMORY(VarString);

    return pControl->CommHandle;


Cleanup040:
#ifdef DYN_LOAD
    (*pControl->pfn_lineDrop)(
#else
    lineDrop(
#endif
        pControl->hCall,
        NULL,
        0
        );

//Cleanup030:
#ifdef DYN_LOAD
    (*pControl->pfn_lineDeallocateCall)(
#else
    lineDeallocateCall(
#endif
        pControl->hCall
        );

Cleanup020:
#ifdef DYN_LOAD
    (*pControl->pfn_lineClose)(
#else
    lineClose(
#endif
        pControl->hLine
        );

Cleanup015:
#ifdef DYN_LOAD
    (*pControl->pfn_lineShutdown)(
#else
    lineShutdown(
#endif
        pControl->hLineApp
        );

Cleanup012:
#ifdef DYN_LOAD
    FreeLibrary(pControl->hLib);
Cleanup011:
#endif
    FREE_MEMORY(pControl);

    return NULL;

}


DWORD
MakeTheCall(
    PCONTROL_OBJECT  pControl
    )

{
    LINECALLPARAMS     LineCallParams;
    LONG               Result;
    BOOL               bResult;
  
    memset(&LineCallParams,0,sizeof(LINECALLPARAMS));

    LineCallParams.dwTotalSize=sizeof(LINECALLPARAMS);
    LineCallParams.dwBearerMode=LINEBEARERMODE_PASSTHROUGH;
    LineCallParams.dwMediaMode=LINEMEDIAMODE_DATAMODEM;

    pControl->CallStateToWaitFor=LINECALLSTATE_CONNECTED;
    pControl->StopWaitingForCallState=FALSE;

#ifdef DYN_LOAD
    Result=(*pControl->pfn_lineMakeCallW)(
#else
    Result=lineMakeCall(
#endif
        pControl->hLine,
        &pControl->hCall,
        NULL,
        0,
        &LineCallParams
        );

    if (Result < 0) {
        IF_ERROR(DbgPrint("LineMakeCall: Failed %08lx\n\r",Result);)
        return 0;
    }

    bResult=WaitForLineReply(
        pControl,
        Result,
        5*1000
        );

    if (!bResult) {
        IF_ERROR(DbgPrint("LineMakeCall: Failed\n\r");)
        return 0;
    }


    bResult=WaitForCallState(
        pControl,
        5*1000
        );

    if (bResult == FALSE) {

#ifdef DYN_LOAD
        (*pControl->pfn_lineDrop)(
#else
        lineDrop(
#endif
            pControl->hCall,
            NULL,
            0
            );

#ifdef DYN_LOAD
        (*pControl->pfn_lineDeallocateCall)(
#else
        lineDeallocateCall(
#endif
            pControl->hCall
            );

        return 0;

    }

    return 1;

}




VOID WINAPI
FreeModemCommHandle(
    PVOID      *TapiHandle
    )

{
    PCONTROL_OBJECT    pControl=(PCONTROL_OBJECT)TapiHandle;

//    CloseHandle(pControl->CommHandle);

#ifdef DYN_LOAD
    (*pControl->pfn_lineDrop)(
#else
    lineDrop(
#endif
        pControl->hCall,
        NULL,
        0
        );

#ifdef DYN_LOAD
    (*pControl->pfn_lineDeallocateCall)(
#else
    lineDeallocateCall(
#endif
        pControl->hCall
        );

#ifdef DYN_LOAD
    (*pControl->pfn_lineClose)(
#else
    lineClose(
#endif
        pControl->hLine
        );

#ifdef DYN_LOAD
    (*pControl->pfn_lineShutdown)(
#else
    lineShutdown(
#endif
        pControl->hLineApp
        );

#ifdef DYN_LOAD
    FreeLibrary(pControl->hLib);
#endif

    FREE_MEMORY(pControl);

    return;
    
}


BOOL WINAPI
WaitForLineReply(
    PCONTROL_OBJECT    pControl,
    LONG               ReplyToWaitFor,
    DWORD              msToWait
    )
{

    DWORD     StartTime=GetCurrentTime();
    MSG       Msg;

    pControl->StopWaiting=FALSE;
    pControl->LineReplyToWaitFor=ReplyToWaitFor;

    while (1) {
        
        while (PeekMessage(&Msg, NULL, 0, 0, PM_REMOVE)) {

            if (WM_QUIT == Msg.message) {

                return FALSE;
            }

            TranslateMessage(
                &Msg
                );

            DispatchMessage(
                &Msg
                );

        }

        if (pControl->StopWaiting) {
            
            return TRUE;
        }

        if (GetCurrentTime() > StartTime+msToWait) {

            IF_ERROR(DbgPrint("WaitForLineReply: timed out\n\r");)
            return FALSE;
        }
    }
}

BOOL WINAPI
WaitForCallState(
    PCONTROL_OBJECT    pControl,
    DWORD              msToWait
    )
{

    DWORD     StartTime=GetCurrentTime();
    MSG       Msg;



    while (1) {
        
        while (PeekMessage(&Msg, NULL, 0, 0, PM_REMOVE)) {

            if (WM_QUIT == Msg.message) {

                return FALSE;
            }

            TranslateMessage(
                &Msg
                );

            DispatchMessage(
                &Msg
                );

        }

        if (pControl->StopWaitingForCallState) {
            
            return TRUE;
        }

        if (GetCurrentTime() > StartTime+msToWait) {
            IF_ERROR(DbgPrint("WaitForCallState: timed out\n\r");)
            return FALSE;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\modemui\modemui.c ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1993-1994
//
// File: modemui.c
//
// This files contains the DLL entry-points.
//
// History:
//  1-12-94 ScottH        Created
//  9-20-95 ScottH        Ported to NT
//  10-25-97 JosephJ      Extensively reorganized -- stuff moved over to other
//                        files.
//
//---------------------------------------------------------------------------
#include "proj.h"     // common headers

//------------------------------------------------------------------------------
//  Entry-points provided for KERNEL32 APIs
//------------------------------------------------------------------------------


DWORD 
APIENTRY 
#ifdef UNICODE
drvCommConfigDialogA(
    IN     LPCSTR       pszFriendlyName,
    IN     HWND         hwndOwner,
    IN OUT LPCOMMCONFIG pcc)
#else
drvCommConfigDialogW(
    IN     LPCWSTR      pszFriendlyName,
    IN     HWND         hwndOwner,
    IN OUT LPCOMMCONFIG pcc)
#endif
{
    return ERROR_CALL_NOT_IMPLEMENTED;
}


/*----------------------------------------------------------
Purpose: Entry point for CommConfigDialog

Returns: standard error value in winerror.h
Cond:    --
*/
DWORD 
APIENTRY 
drvCommConfigDialog(
    IN     LPCTSTR      pszFriendlyName,
    IN     HWND         hwndOwner,
    IN OUT LPCOMMCONFIG pcc)
{
    DWORD dwRet;

    DBG_ENTER_SZ(drvCommConfigDialog, pszFriendlyName);

    DEBUG_CODE( DEBUG_BREAK(BF_ONAPIENTER); )

    dwRet =  CplDoProperties(
                pszFriendlyName,
                hwndOwner,
                pcc,
                NULL
                );

    DBG_EXIT_DWORD(drvCommConfigDialog, dwRet);

    return dwRet;

}


DWORD 
APIENTRY 
#ifdef UNICODE
drvGetDefaultCommConfigA(
    IN     LPCSTR       pszFriendlyName,
    IN     LPCOMMCONFIG pcc,
    IN OUT LPDWORD      pdwSize)
#else
drvGetDefaultCommConfigW(
    IN     LPCWSTR      pszFriendlyName,
    IN     LPCOMMCONFIG pcc,
    IN OUT LPDWORD      pdwSize)
#endif
{
    return ERROR_CALL_NOT_IMPLEMENTED;
}


/*----------------------------------------------------------
Purpose: Entry point for GetDefaultCommConfig

Returns: standard error value in winerror.h
Cond:    --
*/
DWORD 
APIENTRY 
drvGetDefaultCommConfig(
    IN     LPCTSTR      pszFriendlyName,
    IN     LPCOMMCONFIG pcc,
    IN OUT LPDWORD      pdwSize)
{
    DWORD dwRet;
    LPFINDDEV pfd;

    DBG_ENTER_SZ(drvGetDefaultCommConfig, pszFriendlyName);

    DEBUG_CODE( DEBUG_BREAK(BF_ONAPIENTER); )

    // We support friendly names (eg, "Hayes Accura 144")

    if (NULL == pszFriendlyName || 
        NULL == pcc || 
        NULL == pdwSize)
    {
        dwRet = ERROR_INVALID_PARAMETER;
        goto end;
    }

    if (FindDev_Create(&pfd, c_pguidModem, c_szFriendlyName, pszFriendlyName))
    {
            dwRet=UnimodemGetDefaultCommConfig(
                pfd->hkeyDrv,
                pcc,
                pdwSize
                );

            FindDev_Destroy(pfd);
    }
    else
    {
        dwRet = ERROR_BADKEY;
    }

end:

    DBG_EXIT_DWORD(drvGetDefaultCommConfig, dwRet);

    return dwRet;
}


DWORD 
APIENTRY 
#ifdef UNICODE
drvSetDefaultCommConfigA(
    IN LPSTR        pszFriendlyName,
    IN LPCOMMCONFIG pcc,
    IN DWORD        dwSize)           
#else
drvSetDefaultCommConfigW(
    IN LPWSTR       pszFriendlyName,
    IN LPCOMMCONFIG pcc,
    IN DWORD        dwSize)           
#endif
{
    return ERROR_CALL_NOT_IMPLEMENTED;
}


/*----------------------------------------------------------
Purpose: Entry point for SetDefaultCommConfig

Returns: standard error value in winerror.h
Cond:    --
*/
DWORD 
APIENTRY 
drvSetDefaultCommConfig(
    IN LPTSTR       pszFriendlyName,
    IN LPCOMMCONFIG pcc,
    IN DWORD        dwSize)           // This is ignored
{
    DWORD dwRet = ERROR_INVALID_PARAMETER;
    LPFINDDEV pfd = NULL;

    DBG_ENTER_SZ(drvSetDefaultCommConfig, pszFriendlyName);

    DEBUG_CODE( DEBUG_BREAK(BF_ONAPIENTER); )


    //
    // 10/26/1997 JosephJ: the last two checks below are new for NT5.0
    //            Also, for the middle two checks, ">" has been replaced
    //            by "!=".
    //
    if (   NULL == pszFriendlyName
        || NULL == pcc
        || CB_PROVIDERSIZE != pcc->dwProviderSize
        || FIELD_OFFSET(COMMCONFIG, wcProviderData) != pcc->dwProviderOffset
        || pcc->dwSize != dwSize           // <- NT5.0
        || CB_COMMCONFIGSIZE != dwSize)    // <- NT5.0
    {
        goto end;
    }

    if (!FindDev_Create(&pfd, c_pguidModem, c_szFriendlyName, pszFriendlyName))
    {
        pfd = NULL;
    }
    else
    {
        DWORD cbData;
        LPMODEMSETTINGS pms = PmsFromPcc(pcc);

        // Write the DCB to the driver key
        cbData = sizeof(WIN32DCB);

        pcc->dcb.DCBlength=cbData;

        TRACE_MSG(
            TF_GENERAL,
            "drvSetDefaulCommConfig: seting baudrate to %lu",
            pcc->dcb.BaudRate
            );
        ASSERT (0 < pcc->dcb.BaudRate);

        dwRet = RegSetValueEx(
                    pfd->hkeyDrv,
                    c_szDCB,
                    0,
                    REG_BINARY, 
                    (LPBYTE)&pcc->dcb,
                    cbData
                    );

        TRACE_MSG(TF_GENERAL, "Writing DCB to registry");

        DEBUG_CODE( DumpDCB(&pcc->dcb); )

        if (ERROR_SUCCESS == dwRet)
        {
            TRACE_MSG(TF_GENERAL, "Writing MODEMSETTINGS to registry");

            dwRet = RegSetModemSettings(pfd->hkeyDrv, pms);

            DEBUG_CODE( DumpModemSettings(pms); )
        }
    }

        
end:

    if (pfd)
    {
        FindDev_Destroy(pfd);
        pfd=NULL;
    }

    DBG_EXIT_DWORD(drvSetDefaultCommConfig, dwRet);

    return dwRet;
}



/*----------------------------------------------------------
Purpose: Gets the default COMMCONFIG for the specified device.
         This API doesn't require a handle.

         We get the info from the registry.

Returns: One of the ERROR_ values

Cond:    --
*/
DWORD APIENTRY
UnimodemGetDefaultCommConfig(
    HKEY  hKey,
    LPCOMMCONFIG pcc,
    LPDWORD pdwSize)
{
    DWORD dwRet = ERROR_INVALID_PARAMETER;
    
    if (    !pcc
         || !pdwSize)
    {
        goto end;
    }

    if (*pdwSize < CB_COMMCONFIGSIZE)
    {
        *pdwSize = CB_COMMCONFIGSIZE;
        dwRet = ERROR_INSUFFICIENT_BUFFER;
        goto end;
    }

    *pdwSize = CB_COMMCONFIGSIZE;

    dwRet = RegQueryModemSettings(hKey, PmsFromPcc(pcc));
    
    if (ERROR_SUCCESS != dwRet)
    {
        goto end;
    }

#ifdef DEBUG
    DumpModemSettings(PmsFromPcc(pcc));
#endif


    // Initialize the commconfig structure
    pcc->dwSize = *pdwSize;
    pcc->wVersion = COMMCONFIG_VERSION_1;
    pcc->dwProviderSubType = PST_MODEM;
    pcc->dwProviderOffset = CB_COMMCONFIG_HEADER;
    pcc->dwProviderSize = sizeof(MODEMSETTINGS);

    dwRet = RegQueryDCB(hKey, &pcc->dcb);

    DEBUG_CODE( DumpDCB(&pcc->dcb); )

end:

    return dwRet;
}

DWORD
APIENTRY
UnimodemDevConfigDialog(
    IN     LPCTSTR pszFriendlyName,
    IN     HWND hwndOwner,
    IN     DWORD dwType,                          // One of UMDEVCFGTYPE_*
    IN     DWORD dwFlags,                         // Reserved, must be 0
    IN     void *pvConfigBlobIn,
    OUT    void *pvConfigBlobOut,
    IN     LPPROPSHEETPAGE pExtPages,     OPTIONAL   // PPages to add
    IN     DWORD cExtPages
    )
{
    DWORD dwRet = ERROR_INVALID_PARAMETER;
    

    if (dwFlags)
    {
        goto end;
    }

    if (!dwFlags && UMDEVCFGTYPE_COMM == dwType)
    {
        dwRet =  CfgDoProperties(
                    pszFriendlyName,
                    hwndOwner,
                    pExtPages,
                    cExtPages,
                    (PUMDEVCFG) pvConfigBlobIn,
                    (PUMDEVCFG) pvConfigBlobOut
                    );
    }

end:

    return dwRet;
}


#include "cplui.h"
DWORD PRIVATE InitializeModemInfo(
    LPMODEMINFO pmi,
    LPFINDDEV pfd,
    LPCTSTR pszFriendlyName,
    LPCOMMCONFIG pcc,
    LPGLOBALINFO pglobal
    );

UINT CALLBACK
    CplGeneralPageCallback(
    HWND hwnd,
    UINT uMsg,
    LPPROPSHEETPAGE ppsp
    );

DWORD PRIVATE
AddCplGeneralPage(
    LPMODEMINFO pmi,
    LPFNADDPROPSHEETPAGE pfnAdd, 
    LPARAM lParam
    );

/*++

Routine Description: ModemPropPageProvider

    Entry-point for adding additional device manager property
    sheet pages.  Registry specifies this routine under
    Control\Class\PortNode::EnumPropPage32="modemui.dll,thisproc"
    entry.  This entry-point gets called only when the Device
    Manager asks for additional property pages.

Arguments:

    pinfo  - points to PROPSHEETPAGE_REQUEST, see setupapi.h
    pfnAdd - function ptr to call to add sheet.
    lParam - add sheet functions private data handle.

Return Value:

    BOOL: FALSE if pages could not be added, TRUE on success

--*/
BOOL APIENTRY ModemPropPagesProvider (
    PSP_PROPSHEETPAGE_REQUEST pPropPageRequest,
    LPFNADDPROPSHEETPAGE      pfnAdd,
    LPARAM                    lParam)
{
 HKEY         hKeyDrv;
 LPFINDDEV    pFindDev;
 DWORD        dwRW = KEY_READ;
 BOOL         bRet = FALSE;
 LPCOMMCONFIG pcc = NULL;
 LPGLOBALINFO pglobal = NULL;
 LPMODEMINFO  pmi = NULL;
 TCHAR        sz[256];
 DWORD        cbSize = CB_COMMCONFIGSIZE;
 CONFIGRET    cr;
 DWORD        ulStatus, ulProblem;

    if (!USER_IS_ADMIN())
    {
        return FALSE;
    }

    cr = CM_Get_DevInst_Status (&ulStatus, &ulProblem, pPropPageRequest->DeviceInfoData->DevInst, 0);
    if (CR_SUCCESS != cr               ||
        0 != ulProblem                 ||
        !(ulStatus & DN_DRIVER_LOADED) ||
        !(ulStatus & DN_STARTED))
    {
        // If there are any problems with this device
        // (like the device is not present, or not
        // started etc) then we don't add our pages.
        return FALSE;
    }

    g_dwIsCalledByCpl = TRUE;

    pFindDev = (LPFINDDEV)ALLOCATE_MEMORY(sizeof(FINDDEV));
    if (NULL == pFindDev)
    {
        goto end;
    }
    TRACE_MSG(TF_GENERAL, "EMANP - Allocated pFindDev @ %#p", pFindDev);

    if (USER_IS_ADMIN()) dwRW |= KEY_WRITE;
    pFindDev->hkeyDrv = SetupDiOpenDevRegKey (pPropPageRequest->DeviceInfoSet,
                                              pPropPageRequest->DeviceInfoData,
                                              DICS_FLAG_GLOBAL, 0, DIREG_DRV, dwRW);
    if (INVALID_HANDLE_VALUE == pFindDev->hkeyDrv)
    {
        goto end;
    }

    if (!SetupDiGetDeviceRegistryProperty (pPropPageRequest->DeviceInfoSet,
                                           pPropPageRequest->DeviceInfoData,
                                           SPDRP_FRIENDLYNAME,
                                           NULL,
                                           (PBYTE)sz,
                                           sizeof (sz),
                                           NULL))
    {
        goto end;
    }

    if (NULL ==
        (pcc = (LPCOMMCONFIG)ALLOCATE_MEMORY (cbSize)))
    {
        goto end;
    }
    TRACE_MSG(TF_GENERAL, "EMANP - Allocated pcc @ %#p", pcc);

    if (NULL ==
        (pmi = (LPMODEMINFO)ALLOCATE_MEMORY( sizeof(*pmi))))
    {
        goto end;
    }
    TRACE_MSG(TF_GENERAL, "EMANP - Allocated pmi @ %#p", pmi);

    // Create a structure for the global modem info
    if (NULL == 
        (pglobal = (LPGLOBALINFO)ALLOCATE_MEMORY (sizeof(GLOBALINFO))))
    {
        goto end;
    }
    TRACE_MSG(TF_GENERAL, "EMANP - Allocated pglobal @ %#p", pglobal);

    if (ERROR_SUCCESS !=
        UnimodemGetDefaultCommConfig (pFindDev->hkeyDrv, pcc, &cbSize))
    {
        goto end;
    }

    pFindDev->hdi     = pPropPageRequest->DeviceInfoSet;
    pFindDev->devData = *pPropPageRequest->DeviceInfoData;

    if (ERROR_SUCCESS !=
        RegQueryGlobalModemInfo (pFindDev, pglobal))
    {
        goto end;
    }

    if (ERROR_SUCCESS !=
        InitializeModemInfo (pmi, pFindDev, sz, pcc, pglobal))
    {
        goto end;
    }

    SetFlag (pmi->uFlags, MIF_FROM_DEVMGR);

    //
    // ADD THE CPL GENERAL PAGE
    //
    if (NO_ERROR !=
        AddCplGeneralPage(pmi, pfnAdd, lParam))
    {
        goto end;
    }

    AddPage (pmi, 
             MAKEINTRESOURCE(IDD_DIAGNOSTICS), 
             Diag_WrapperProc,
             pfnAdd, lParam);

    //
    // ADD THE CPL ISDN PAGE
    //
    if (pglobal->pIsdnStaticCaps && pglobal->pIsdnStaticConfig)
    {
        AddPage (pmi, 
                 MAKEINTRESOURCE(IDD_CPL_ISDN),
                 CplISDN_WrapperProc, 
                 pfnAdd, lParam);
    }

    //
    // ADD THE CPL ADVANCED PAGE
    //
    AddPage (pmi, 
             MAKEINTRESOURCE(IDD_ADV_MODEM),
             CplAdv_WrapperProc, 
             pfnAdd, lParam);


    // Now add device pages
    pmi->hInstExtraPagesProvider = AddDeviceExtraPages (pmi->pfd, pfnAdd, lParam);

    bRet = TRUE;

end:
    if (!bRet)
    {
        if (NULL != pFindDev)
        {
            if (INVALID_HANDLE_VALUE != pFindDev->hkeyDrv)
            {
                RegCloseKey (pFindDev->hkeyDrv);
            }
            TRACE_MSG(TF_GENERAL, "EMANP - Freeing pFindDev @ %#p", pFindDev);
            FREE_MEMORY(pFindDev);
        }
        if (NULL != pcc)
        {
            TRACE_MSG(TF_GENERAL, "EMANP - Freeing pcc @ %#p", pcc);
            FREE_MEMORY(pcc);
        }
        if (NULL != pglobal)
        {
            TRACE_MSG(TF_GENERAL, "EMANP - Freeing pglobal @ %#p", pglobal);
            FREE_MEMORY(pglobal);
        }
        if (NULL != pmi)
        {
            TRACE_MSG(TF_GENERAL, "EMANP - Freeing pmi @ %#p", pmi);
            FREE_MEMORY(pmi);
        }
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\modemui\modemui.h ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1993-1994
//
// File: modemui.h
//
// This files contains the shared prototypes and macros.
//
// History:
//  02-03-94 ScottH     Created
//
//---------------------------------------------------------------------------


#ifndef __MODEMUI_H__
#define __MODEMUI_H__

// The Unimodem provider fills in the COMMCONFIG structure as
// follows:
//
//  +-----------------------+
//  |                       |
//  | COMMCONFIG data       |
//  |                       |
//  | Provider offset       |--+
//  | Provider size         |  |
//  |    = ms.size          |  |
//  |                       |  |
//  +-----------------------+  |
//  |                       |<-+
//  | MODEMSETTINGS         |
//  |                       |
//  | Size                  |
//  |    = MODEMSETTINGS +  |
//  |      dev.size         |
//  |                       |
//  | DevSpecific offset    |--+
//  | DevSpecific size      |  |
//  |    = DEVSPECIFIC      |  |
//  +-----------------------+  |
//  |                       |<-+
//  | DEVSPECIFIC           |
//  | (optional)            |
//  |                       |
//  +-----------------------+
//

#define MAXBUFLEN       MAX_BUF
#define MAXMSGLEN       MAX_BUF_MSG
#define MAXMEDLEN       MAX_BUF_MED
#define MAXSHORTLEN     MAX_BUF_SHORT

#define USERINITLEN     255

#ifndef LINE_LEN
#define LINE_LEN        MAXBUFLEN
#endif

#define MIN_CALL_SETUP_FAIL_TIMER   1
#define MIN_INACTIVITY_TIMEOUT      0
#define DEFAULT_INACTIVITY_SCALE   10    // == decasecond units


#define MAX_CODE_BUF    8
#define MAXPORTNAME     13
#define MAXFRIENDLYNAME LINE_LEN        // LINE_LEN is defined in setupx.h

#define CB_COMMCONFIG_HEADER        FIELD_OFFSET(COMMCONFIG, wcProviderData)
#define CB_PRIVATESIZE              (CB_COMMCONFIG_HEADER)
#define CB_PROVIDERSIZE             (sizeof(MODEMSETTINGS))
#define CB_COMMCONFIGSIZE           (CB_PRIVATESIZE+CB_PROVIDERSIZE)

#define CB_MODEMSETTINGS_HEADER     FIELD_OFFSET(MODEMSETTINGS, dwCallSetupFailTimer)
#define CB_MODEMSETTINGS_TAIL       (sizeof(MODEMSETTINGS) - FIELD_OFFSET(MODEMSETTINGS, dwNegotiatedModemOptions))
#define CB_MODEMSETTINGS_OVERHEAD   (CB_MODEMSETTINGS_HEADER + CB_MODEMSETTINGS_TAIL)

#define PmsFromPcc(pcc)             ((LPMODEMSETTINGS)(pcc)->wcProviderData)


#define MAX_PROP_PAGES  16          // Define a reasonable limit

#if (DBG)
    #define MYASSERT(cond) ((cond) ? 0: DebugBreak())
#else
    #define MYASSERT(cond) (0)
#endif // MYASSERT
// Voice settings
#define MAX_DIST_RINGS     6

typedef struct
{
    DWORD dwPattern;            // DRP_*
    DWORD dwMediaType;          // DRT_*
} DIST_RING, * PDIST_RING;


typedef struct tagFINDDEV
{
    HDEVINFO        hdi;
    SP_DEVINFO_DATA devData;
    HKEY            hkeyDrv;
} FINDDEV, FAR * LPFINDDEV;


DWORD CplDoProperties(
        LPCWSTR      pszFriendlyName,
        HWND hwndParent,
        IN OUT LPCOMMCONFIG pcc,
        OUT DWORD *pdwMaxSpeed      OPTIONAL
        );

DWORD CfgDoProperties(
        LPCWSTR         pszFriendlyName,
        HWND            hwndParent,
        LPPROPSHEETPAGE pExtPages,     // Optional; may be NULL
        DWORD           cExtPages,     // Number of external pages
        UMDEVCFG *pDevCfgIn,
        UMDEVCFG *pDevCfgOut
        );

HINSTANCE
AddDeviceExtraPages (
    LPFINDDEV            pfd,
    LPFNADDPROPSHEETPAGE pfnAdd,
    LPARAM               lParam);

extern DWORD g_dwIsCalledByCpl;

#endif // __MODEMUI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\modemui\util.c ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1993-1994
//
// File: util.c
//
//  This files contains all common utility routines
//
// History:
//  12-23-93 ScottH     Created
//  09-22-95 ScottH     Ported to NT
//
//---------------------------------------------------------------------------

#include "proj.h"     // common headers
#include <objbase.h>



//----------------------------------------------------------------------------
// Dialog utilities ...
//----------------------------------------------------------------------------

/*----------------------------------------------------------
Purpose: Sets an edit control to contain a string representing the
         given numeric value.  
Returns: --
Cond:    --
*/
void Edit_SetValue(
    HWND hwnd,
    int nValue)
{
    TCHAR sz[MAXSHORTLEN];

    wsprintf(sz, TEXT("%d"), nValue);
    Edit_SetText(hwnd, sz);
}


/*----------------------------------------------------------
Purpose: Gets a numeric value from an edit control.  Supports hexadecimal.
Returns: int
Cond:    --
*/
int Edit_GetValue(
    HWND hwnd)
{
    TCHAR sz[MAXSHORTLEN];
    int cch;
    int nVal = 0;

    cch = Edit_GetTextLength(hwnd);
    ASSERT(ARRAYSIZE(sz) >= cch);

    Edit_GetText(hwnd, sz, ARRAYSIZE(sz));
    AnsiToInt(sz, &nVal);

    return nVal;
}


//-----------------------------------------------------------------------------------
//  
//-----------------------------------------------------------------------------------


/*----------------------------------------------------------
Purpose: Enumerates the HKEY_LOCAL_MACHINE branch and finds the
         device matching the given class and value.  If there
         are duplicate devices that match both criteria, only the
         first device is returned. 

         Returns TRUE if the device was found.

Returns: see above
Cond:    --
*/
BOOL 
FindDev_Find(
    IN  LPFINDDEV   pfinddev,
    IN  LPGUID      pguidClass,
    IN  LPCTSTR     pszValueName,
    IN  LPCTSTR     pszValue)
{
    BOOL bRet = FALSE;
    TCHAR szKey[MAX_BUF];
    TCHAR szName[MAX_BUF];
    HDEVINFO hdi;
	DWORD dwRW = KEY_READ;

    ASSERT(pfinddev);
    ASSERT(pguidClass);
    ASSERT(pszValueName);
    ASSERT(pszValue);

	if (USER_IS_ADMIN()) dwRW |= KEY_WRITE;

    hdi = CplDiGetClassDevs(pguidClass, NULL, NULL, 0);
    if (INVALID_HANDLE_VALUE != hdi)
        {
        SP_DEVINFO_DATA devData;
        DWORD iIndex = 0;
        HKEY hkey;

        // Look for the modem that has the matching value
        devData.cbSize = sizeof(devData);
        while (CplDiEnumDeviceInfo(hdi, iIndex, &devData))
            {
            hkey = CplDiOpenDevRegKey(hdi, &devData, DICS_FLAG_GLOBAL, 0, DIREG_DRV, dwRW);
            if (INVALID_HANDLE_VALUE != hkey)
                {
                // Does the value match?
                DWORD cbData = sizeof(szName);
                if (NO_ERROR == RegQueryValueEx(hkey, pszValueName, NULL, NULL, 
                                                (LPBYTE)szName, &cbData) &&
                    IsSzEqual(pszValue, szName))
                    {
                    // Yes
                    pfinddev->hkeyDrv = hkey;
                    pfinddev->hdi = hdi;
                    BltByte(&pfinddev->devData, &devData, sizeof(devData));

                    // Don't close the driver key or free the DeviceInfoSet, 
                    // but exit
                    bRet = TRUE;
                    break;
                    }
                RegCloseKey(hkey);
                }

            iIndex++;
            }

        // Free the DeviceInfoSet if nothing was found.  Otherwise, we will
        // retain these handles so the caller can make use of this.
        if ( !bRet )
            {
            CplDiDestroyDeviceInfoList(hdi);
            }
        }

    return bRet;
}


/*----------------------------------------------------------
Purpose: Creates a FINDDEV structure given the device class,
         and a valuename and its value.

Returns: TRUE if the device is found in the system

Cond:    --
*/
BOOL 
PUBLIC 
FindDev_Create(
    OUT LPFINDDEV FAR * ppfinddev,
    IN  LPGUID      pguidClass,
    IN  LPCTSTR     pszValueName,
    IN  LPCTSTR     pszValue)
{
    BOOL bRet;
    LPFINDDEV pfinddev;

    DEBUG_CODE( TRACE_MSG(TF_FUNC, " > FindDev_Create(....%s, %s, ...)",
                Dbg_SafeStr(pszValueName), Dbg_SafeStr(pszValue));g_dwIndent+=2; )

    ASSERT(ppfinddev);
    ASSERT(pguidClass);
    ASSERT(pszValueName);
    ASSERT(pszValue);

    pfinddev = (LPFINDDEV)ALLOCATE_MEMORY( sizeof(*pfinddev));
    if (NULL == pfinddev)
        {
        bRet = FALSE;
        }
    else
        {
        bRet = FindDev_Find(pfinddev, pguidClass, pszValueName, pszValue);

        if (FALSE == bRet)
            {
            // Didn't find anything 
            FindDev_Destroy(pfinddev);
            pfinddev = NULL;
            }
        }

    *ppfinddev = pfinddev;

    DBG_EXIT_BOOL(FindDev_Create, bRet);

    return bRet;
}


/*----------------------------------------------------------
Purpose: Destroys a FINDDEV structure

Returns: TRUE on success
Cond:    --
*/
BOOL 
PUBLIC 
FindDev_Destroy(
    IN LPFINDDEV this)
{
    BOOL bRet;

    if (NULL == this)
        {
        bRet = FALSE;
        }
    else
        {
        if (this->hkeyDrv)
            RegCloseKey(this->hkeyDrv);

        if (this->hdi && INVALID_HANDLE_VALUE != this->hdi)
            CplDiDestroyDeviceInfoList(this->hdi);

        FREE_MEMORY(this);

        bRet = TRUE;
        }

    return bRet;
}


/*----------------------------------------------------------
Purpose: Return the appropriate text and background COLORREFs
         given the DRAWITEMSTRUCT.

Returns: --
Cond:    --
*/
void PUBLIC TextAndBkCr(
    const DRAWITEMSTRUCT FAR * lpcdis,
    COLORREF FAR * pcrText,
    COLORREF FAR * pcrBk)
{
    #define CR_DARK_GRAY    RGB(128, 128, 128)

    UINT nState;

    ASSERT(lpcdis);
    ASSERT(pcrText);
    ASSERT(pcrBk);

    nState = lpcdis->itemState;

    switch (lpcdis->CtlType)
        {
    case ODT_STATIC:
        if (IsFlagSet(nState, ODS_DISABLED))
            {
            *pcrText = GetSysColor(COLOR_GRAYTEXT);
            *pcrBk = GetSysColor(COLOR_3DFACE);
            }
        else
            {
            *pcrText = GetSysColor(COLOR_WINDOWTEXT);
            *pcrBk = GetSysColor(COLOR_3DFACE);
            }
        break;

    case ODT_LISTBOX:
    case ODT_COMBOBOX:
        if (IsFlagSet(nState, ODS_SELECTED))
            {
            *pcrText = GetSysColor(COLOR_HIGHLIGHTTEXT);
            *pcrBk = GetSysColor(COLOR_HIGHLIGHT);
            }
        else if (IsFlagSet(nState, ODS_DISABLED))
            {
            *pcrText = GetSysColor(COLOR_GRAYTEXT);
            *pcrBk = GetSysColor(COLOR_3DFACE);
            }
        else
            {
            *pcrText = GetSysColor(COLOR_WINDOWTEXT);
            *pcrBk = GetSysColor(COLOR_WINDOW);
            }
        break;

    case ODT_MENU:
        if (IsFlagSet(nState, ODS_SELECTED))
            {
            *pcrText = GetSysColor(COLOR_HIGHLIGHTTEXT);
            *pcrBk = GetSysColor(COLOR_HIGHLIGHT);
            }
        else
            {
            *pcrText = GetSysColor(COLOR_MENUTEXT);
            *pcrBk = GetSysColor(COLOR_MENU);
            }
        break;

    default:
        ASSERT(0);
        *pcrText = GetSysColor(COLOR_WINDOWTEXT);
        *pcrBk = GetSysColor(COLOR_3DFACE);
        break;
        }
}

//------------------------------------------------------------------------------
//  Read/Write stuff from registry...
//------------------------------------------------------------------------------

/*----------------------------------------------------------
Purpose: Returns value of the InactivityScale value in the registry.

Returns: see above
Cond:    --
*/
DWORD GetInactivityTimeoutScale(
    HKEY hkey)
    {
    DWORD dwInactivityScale;
    DWORD dwType;
    DWORD cbData;

    cbData = sizeof(DWORD);
    if (ERROR_SUCCESS != RegQueryValueEx(hkey, c_szInactivityScale, NULL, &dwType,
                                         (LPBYTE)&dwInactivityScale, &cbData) ||
        REG_BINARY    != dwType ||
        sizeof(DWORD) != cbData ||
        0             == dwInactivityScale)
        {
        dwInactivityScale = DEFAULT_INACTIVITY_SCALE;
        }
    return dwInactivityScale;
    }


/*----------------------------------------------------------
Purpose: Gets a MODEMSETTINGS struct from the registry.  Also
         sets *pdwSize bigger if the data in the registry includes
         extra data.

Returns: One of the ERROR_ values
Cond:    --
*/
DWORD
RegQueryModemSettings(
    HKEY hkey,
    LPMODEMSETTINGS pms
    )
{

    // 10/26/1997 JosephJ:
    //      Only the following 4 contiguous fields of MODEMSETTINGS are saved
    //      in the registry:
    //        DWORD   dwCallSetupFailTimer;       // seconds
    //        DWORD   dwInactivityTimeout;        // seconds
    //        DWORD   dwSpeakerVolume;            // level
    //        DWORD   dwSpeakerMode;              // mode
    //        DWORD   dwPreferredModemOptions;    // bitmap
    //
    //      The following code reads in just those fields, and then
    //      munges the dwInactivityTimeout by multiplying by the
    //      separate InactivityScale registry entry.
    //
    //      On NT4.0 we just blindly read the above 4 fields
    //      Here we validate the size before reading.

    struct
    {
        DWORD   dwCallSetupFailTimer;       // seconds
        DWORD   dwInactivityTimeout;        // seconds
        DWORD   dwSpeakerVolume;            // level
        DWORD   dwSpeakerMode;              // mode
        DWORD   dwPreferredModemOptions;    // bitmap

    } Defaults;
    
    DWORD dwRet;
    DWORD cbData = sizeof(Defaults);

    dwRet = RegQueryValueEx(
                hkey,
                c_szDefault,
                NULL,
                NULL, 
                (BYTE*) &Defaults,
                &cbData
                );

    if (ERROR_SUCCESS != dwRet)
    {
        goto end;
    }

    if (cbData != sizeof(Defaults))
    {
        dwRet = ERROR_BADKEY;
        goto end;
    }

    ZeroMemory(pms, sizeof(*pms));

    pms->dwActualSize = sizeof(*pms);
    pms->dwRequiredSize = sizeof(*pms);
    pms->dwCallSetupFailTimer    = Defaults.dwCallSetupFailTimer;
    pms->dwInactivityTimeout     = Defaults.dwInactivityTimeout
                                   * GetInactivityTimeoutScale(hkey);
    pms->dwSpeakerVolume         = Defaults.dwSpeakerVolume;
    pms->dwSpeakerMode           = Defaults.dwSpeakerMode;
    pms->dwPreferredModemOptions = Defaults.dwPreferredModemOptions;

    // fall through ..

end:

    return dwRet;
}


/*----------------------------------------------------------
Purpose: Gets a WIN32DCB from the registry.

Returns: One of the ERROR_ values
Cond:    --
*/
DWORD
RegQueryDCB(
    HKEY hkey,
    WIN32DCB FAR * pdcb)
{
    DWORD dwRet = ERROR_BADKEY;
    DWORD cbData;

    ASSERT(pdcb);

    // Does the DCB key exist in the driver key?
    if (ERROR_SUCCESS == RegQueryValueEx(hkey, c_szDCB, NULL, NULL, NULL, &cbData))
        {
        // Yes; is the size in the registry okay?  
        if (sizeof(*pdcb) < cbData)
            {
            // No; the registry has bogus data
            dwRet = ERROR_BADDB;
            }
        else
            {
            // Yes; get the DCB from the registry
            if (ERROR_SUCCESS == RegQueryValueEx(hkey, c_szDCB, NULL, NULL, (LPBYTE)pdcb, &cbData))
                {
                if (sizeof(*pdcb) == pdcb->DCBlength)
                    {
                    dwRet = NO_ERROR;
                    }
                else
                    {
                    dwRet = ERROR_BADDB;
                    }
                }
            else
                {
                dwRet = ERROR_BADKEY;
                }
            }
        }

    return dwRet;
}


/*----------------------------------------------------------
Purpose: Set dev settings info in the registry, after checking
         for legal values.

Returns: One of ERROR_
Cond:    --
*/
DWORD
RegSetModemSettings(
    HKEY hkeyDrv,
    LPMODEMSETTINGS pms)
{
    DWORD dwRet;
    DWORD cbData;
    DWORD dwInactivityScale;
    DWORD dwInactivityTimeoutTemp;
    REGDEVCAPS regdevcaps;
    REGDEVSETTINGS regdevsettings;

    // Read in the Properties line from the registry.
    cbData = sizeof(REGDEVCAPS);
    dwRet = RegQueryValueEx(hkeyDrv, c_szDeviceCaps, NULL, NULL, 
                            (LPBYTE)&regdevcaps, &cbData);

    if (ERROR_SUCCESS == dwRet)
        {
        // Read in existing regdevsettings, so that we can handle error cases below.
        cbData = sizeof(REGDEVSETTINGS);
        dwRet = RegQueryValueEx(hkeyDrv, c_szDefault, NULL, NULL, 
                                (LPBYTE)&regdevsettings, &cbData);
        }

    if (ERROR_SUCCESS == dwRet)
        {
        // copy new REGDEVSETTINGS while checking validity of each option (ie, is the option available?)
        // dwCallSetupFailTimer - MIN_CALL_SETUP_FAIL_TIMER <= xxx <= ModemDevCaps->dwCallSetupFailTimer
        if (pms->dwCallSetupFailTimer > regdevcaps.dwCallSetupFailTimer)           // max
            {
            regdevsettings.dwCallSetupFailTimer = regdevcaps.dwCallSetupFailTimer;
            }
        else
            {
            if (pms->dwCallSetupFailTimer < MIN_CALL_SETUP_FAIL_TIMER)             // min
                {
                regdevsettings.dwCallSetupFailTimer = MIN_CALL_SETUP_FAIL_TIMER;
                }
            else
                {
                regdevsettings.dwCallSetupFailTimer = pms->dwCallSetupFailTimer;   // dest = src
                }
            }
        
        // convert dwInactivityTimeout to registry scale
        dwInactivityScale = GetInactivityTimeoutScale(hkeyDrv);
        dwInactivityTimeoutTemp = pms->dwInactivityTimeout / dwInactivityScale +
                                  (pms->dwInactivityTimeout % dwInactivityScale ? 1 : 0);

        // dwInactivityTimeout - MIN_INACTIVITY_TIMEOUT <= xxx <= ModemDevCaps->dwInactivityTimeout
        if (dwInactivityTimeoutTemp > regdevcaps.dwInactivityTimeout)              // max
            {
            regdevsettings.dwInactivityTimeout = regdevcaps.dwInactivityTimeout;
            }
        else
            {
            if ((dwInactivityTimeoutTemp + 1) < (MIN_INACTIVITY_TIMEOUT + 1))
                    // min
                {
                regdevsettings.dwInactivityTimeout = MIN_INACTIVITY_TIMEOUT;
                }
            else
                {
                regdevsettings.dwInactivityTimeout = dwInactivityTimeoutTemp;      // dest = src
                }
            }
        
        // dwSpeakerVolume - check to see if selection is possible
        if ((1 << pms->dwSpeakerVolume) & regdevcaps.dwSpeakerVolume)
            {
            regdevsettings.dwSpeakerVolume = pms->dwSpeakerVolume;
            }
            
        // dwSpeakerMode - check to see if selection is possible
        if ((1 << pms->dwSpeakerMode) & regdevcaps.dwSpeakerMode)
            {
            regdevsettings.dwSpeakerMode = pms->dwSpeakerMode;
            }

        // dwPreferredModemOptions - mask out anything we can't set
        regdevsettings.dwPreferredModemOptions = pms->dwPreferredModemOptions &
                                                 (regdevcaps.dwModemOptions | MDM_MASK_EXTENDEDINFO);

        cbData = sizeof(REGDEVSETTINGS);
        dwRet = RegSetValueEx(hkeyDrv, c_szDefault, 0, REG_BINARY, 
                              (LPBYTE)&regdevsettings, cbData);
        }
    return dwRet;
}

//------------------------------------------------------------------------------
//  Debug functions
//------------------------------------------------------------------------------


#ifdef DEBUG

//------------------------------------------------------------------------------
//  Debug routines
//------------------------------------------------------------------------------

/*----------------------------------------------------------
Purpose: 
Returns: 
Cond:    --
*/
void DumpModemSettings(
    LPMODEMSETTINGS pms)
{
    ASSERT(pms);

    if (IsFlagSet(g_dwDumpFlags, DF_MODEMSETTINGS))
        {
        int i;
        LPDWORD pdw = (LPDWORD)pms;

        TRACE_MSG(TF_ALWAYS, "MODEMSETTINGS %08lx %08lx %08lx %08lx",  pdw[0], pdw[1], 
            pdw[2], pdw[3]);
        pdw += 4;
        for (i = 0; i < sizeof(MODEMSETTINGS)/sizeof(DWORD); i += 4, pdw += 4)
            {
            TRACE_MSG(TF_ALWAYS, "              %08lx %08lx %08lx %08lx", pdw[0], pdw[1], 
                pdw[2], pdw[3]);
            }
        }
}


/*----------------------------------------------------------
Purpose: 
Returns: 
Cond:    --
*/
void DumpDCB(
    LPWIN32DCB pdcb)
{
    ASSERT(pdcb);

    if (IsFlagSet(g_dwDumpFlags, DF_DCB))
        {
        int i;
        LPDWORD pdw = (LPDWORD)pdcb;

        TRACE_MSG(TF_ALWAYS, "DCB  %08lx %08lx %08lx %08lx", pdw[0], pdw[1], pdw[2], pdw[3]);
        pdw += 4;
        for (i = 0; i < sizeof(WIN32DCB)/sizeof(DWORD); i += 4, pdw += 4)
            {
            TRACE_MSG(TF_ALWAYS, "     %08lx %08lx %08lx %08lx", pdw[0], pdw[1], pdw[2], pdw[3]);
            }
        }
}


/*----------------------------------------------------------
Purpose: 
Returns: 
Cond:    --
*/
void DumpDevCaps(
    LPREGDEVCAPS pdevcaps)
{
    ASSERT(pdevcaps);

    if (IsFlagSet(g_dwDumpFlags, DF_DEVCAPS))
        {
        int i;
        LPDWORD pdw = (LPDWORD)pdevcaps;

        TRACE_MSG(TF_ALWAYS, "PROPERTIES    %08lx %08lx %08lx %08lx", pdw[0], pdw[1], pdw[2], pdw[3]);
        pdw += 4;
        for (i = 0; i < sizeof(REGDEVCAPS)/sizeof(DWORD); i += 4, pdw += 4)
            {
            TRACE_MSG(TF_ALWAYS, "              %08lx %08lx %08lx %08lx", pdw[0], pdw[1], pdw[2], pdw[3]);
            }
        }
}


#endif  // DEBUG

/*----------------------------------------------------------
Purpose: Add a page.  The pmi is the pointer to the modeminfo 
         buffer which we can edit.

Returns: ERROR_ values

Cond:    --
*/
DWORD AddPage(
    void *pvBlob,
    LPCTSTR pszTemplate,
    DLGPROC pfnDlgProc, 
    LPFNADDPROPSHEETPAGE pfnAdd, 
    LPARAM lParam)
{
    DWORD dwRet = ERROR_NOT_ENOUGH_MEMORY;
    PROPSHEETPAGE   psp;
    HPROPSHEETPAGE  hpage;

    ASSERT(pvBlob);
    ASSERT(pfnAdd);

    // Add the Port Settings property page
    //
    psp.dwSize = sizeof(PROPSHEETPAGE);
    psp.dwFlags = PSP_DEFAULT;
    psp.hInstance = g_hinst;
    psp.pszTemplate = pszTemplate;
    psp.pfnDlgProc = pfnDlgProc;
    psp.lParam = (LPARAM)pvBlob;
    
    hpage = CreatePropertySheetPage(&psp);
    if (hpage)
        {
        if (!pfnAdd(hpage, lParam))
            DestroyPropertySheetPage(hpage);
        else
            dwRet = NO_ERROR;
        }
    
    return dwRet;
}


/*----------------------------------------------------------
Purpose: Add extra pages.

Returns: ERROR_ values

Cond:    --
*/
DWORD AddExtraPages(
    LPPROPSHEETPAGE pPages,
    DWORD cPages,
    LPFNADDPROPSHEETPAGE pfnAdd, 
    LPARAM lParam)
{
    HPROPSHEETPAGE  hpage;
    UINT            i;

    ASSERT(pPages);
    ASSERT(cPages);
    ASSERT(pfnAdd);

    for (i = 0; i < cPages; i++, pPages++)
        {
        // Add the extra property page
        //
        if (pPages->dwSize == sizeof(PROPSHEETPAGE))
        {
          hpage = CreatePropertySheetPage(pPages);
          if (hpage)
              {
              if (!pfnAdd(hpage, lParam))
                  DestroyPropertySheetPage(hpage);
              }
          };
        };

    return ERROR_SUCCESS;
}


/*----------------------------------------------------------
Purpose: Function that is called by EnumPropPages entry-point to
         add property pages.

Returns: TRUE on success
         FALSE on failure

Cond:    --
*/
BOOL WINAPI AddInstallerPropPage(
    HPROPSHEETPAGE hPage, 
    LPARAM lParam)
{
    PROPSHEETHEADER FAR * ppsh = (PROPSHEETHEADER FAR *)lParam;
 
    if (ppsh->nPages < MAX_PROP_PAGES)
        {
        ppsh->phpage[ppsh->nPages] = hPage;
        ++ppsh->nPages;
        return(TRUE);
        }
    return(FALSE);
}


void    LBMapFill(
            HWND hwndCB,
            LBMAP const *pLbMap,
            PFNLBLSELECTOR pfnSelector,
            void *pvContext
            )
{
    int iSel = -1;
    TCHAR sz[MAXMEDLEN];

    SetWindowRedraw(hwndCB, FALSE);

    // Fill the listbox
    for  (;pLbMap->dwIDS;pLbMap++)
    {
        DWORD dwFlags = pfnSelector(pLbMap->dwValue, pvContext);
        if (fLBMAP_ADD_TO_LB & dwFlags)
        {
            int n = ComboBox_AddString(
                        hwndCB,
                        SzFromIDS(
                            g_hinst,
                            pLbMap->dwIDS,
                            sz,
                            ARRAYSIZE(sz)
                            )
                        );
            ComboBox_SetItemData(hwndCB, n, pLbMap->dwValue);

            if ( (-1==iSel) && (fLBMAP_SELECT & dwFlags))
            {
                iSel = n;
            }
        }

    }

    if (iSel >= 0)
    {
        ComboBox_SetCurSel(hwndCB, iSel);
    }

    SetWindowRedraw(hwndCB, TRUE);
}


UINT ReadCommandsA(
        IN  HKEY hKey,
        IN  CHAR *pSubKeyName,
        OUT CHAR **ppValues // OPTIONAL
        )
{
    UINT uRet = 0;
    LONG	lRet;
    UINT	cValues=0;
    UINT   cbTot=0;
	HKEY hkSubKey = NULL;
    char *pMultiSz = NULL;

    lRet = RegOpenKeyExA(
                hKey,
                pSubKeyName,
                0,
                KEY_READ,
                &hkSubKey
                );
    if (lRet!=ERROR_SUCCESS)
    {
        hkSubKey = NULL;
        goto end;
    }

    //
    // 1st determine the count of names in the sequence "1","2",3",....
    // and also compute the size required for the MULTI_SZ array
    // will store all the value data.
    //
    {
        UINT u = 1;

        for (;;u++)
        {
            DWORD cbData=0;
            DWORD dwType=0;
            char rgchName[10];

            wsprintfA(rgchName, "%lu", u);
            lRet = RegQueryValueExA(
                        hkSubKey,
                        rgchName,
                        NULL,
                        &dwType,
                        NULL,
                        &cbData
                        );
            if (ERROR_SUCCESS != lRet || dwType!=REG_SZ || cbData<=1)
            {
                // stop looking further (empty strings not permitted)
                break;
            }
            cbTot += cbData;
            cValues++;
        }
    }

    if (!ppValues || !cValues)
    {
        // we're done...

        uRet = cValues;
        goto end;
    }

    // We need to actually get the values -- allocate space for them, including
    // the ending extra NULL for the multi-sz.
    pMultiSz = (char *) ALLOCATE_MEMORY( cbTot+1);

    if (!pMultiSz)
    {
        uRet = 0;
        goto end;
    }


    //
    // Now actually read the values.
    //
    {
        UINT cbUsed = 0;
        UINT u = 1;

        for (;u<=cValues; u++)
        {
            DWORD cbData = cbTot - cbUsed;
            DWORD dwType=0;
            char rgchName[10];

            if (cbUsed>=cbTot)
            {
                //
                // We should never get here, because we already calculated
                // the size we want (unless the values are changing on us,
                // which is assumed not to happen).
                //
                ASSERT(FALSE);
                goto end;
            }

            wsprintfA(rgchName, "%lu", u);
            lRet = RegQueryValueExA(
                        hkSubKey,
                        rgchName,
                        NULL,
                        &dwType,
                        pMultiSz+cbUsed,
                        &cbData
                        );
            if (ERROR_SUCCESS != lRet || dwType!=REG_SZ || cbData<=1)
            {
                // We really shouldn't get here!
                ASSERT(FALSE);
                goto end;
            }

            cbUsed += cbData;
        }

        ASSERT(cbUsed==cbTot); // We should have used up everything.
        ASSERT(!pMultiSz[cbTot]); // The memory was zeroed on allocation,
                                // so the last char must be still zero.
                                // (Note: we allocated cbTot+1 bytes.
    }

    // If we're here means we're succeeding....
    uRet = cValues;
    *ppValues = pMultiSz;
    pMultiSz = NULL; // so it won't get freed below...

end:

	if (hkSubKey) {RegCloseKey(hkSubKey); hkSubKey=NULL;}
	if (pMultiSz)
	{
	    FREE_MEMORY(pMultiSz);
	    pMultiSz = NULL;
	}

	return uRet;
    
}

UINT ReadIDSTR(
        IN  HKEY hKey,
        IN  CHAR *pSubKeyName,
        IN  IDSTR *pidstrNames,
        IN  UINT cNames,
        BOOL fMandatory,
        OUT IDSTR **ppidstrValues, // OPTIONAL
        OUT char **ppstrValues    // OPTIONAL
        )
{
    UINT uRet = 0;
    LONG lRet;
    UINT cValues=0;
    UINT cbTot=0;
	HKEY hkSubKey = NULL;
    char *pstrValues = NULL;
    IDSTR *pidstrValues = NULL;

    if (!ppidstrValues && ppstrValues)
    {
        // we don't allow this combination...
        goto end;
    }

    lRet = RegOpenKeyExA(
                hKey,
                pSubKeyName,
                0,
                KEY_READ,
                &hkSubKey
                );
    if (lRet!=ERROR_SUCCESS)
    {
        hkSubKey = NULL;
        goto end;
    }

    //
    // 1st run therough the supplied list
    // and also compute the size required for the MULTI_SZ array
    // will store all the value data.
    //
    {
        UINT u = 0;

        for (;u<cNames;u++)
        {
            DWORD cbData=0;
            DWORD dwType=0;

            lRet = RegQueryValueExA(
                        hkSubKey,
                        pidstrNames[u].pStr,
                        NULL,
                        &dwType,
                        NULL,
                        &cbData
                        );
            if (ERROR_SUCCESS != lRet || dwType!=REG_SZ)
            {
                if (fMandatory)
                {
                    // failure...
                    goto end;
                }

                // ignore this one and move on...
                continue;
            }
            cbTot += cbData;
            cValues++;
        }
    }

    if (!cValues || !ppidstrValues)
    {
        // we're done...

        uRet = cValues;
        goto end;
    }

    pidstrValues = (IDSTR*) ALLOCATE_MEMORY( cValues*sizeof(IDSTR));
    if (!pidstrValues) goto end;

    if (ppstrValues)
    {
        pstrValues = (char *) ALLOCATE_MEMORY( cbTot);

        if (!pstrValues) goto end;


    }

    //
    // Now go through once again, and optinally read the values.
    //
    {
        UINT cbUsed = 0;
        UINT u = 0;
        UINT v = 0;

        for (;u<cNames; u++)
        {
            DWORD dwType=0;
            char *pStr = NULL;
            DWORD cbData = 0;


            if (pstrValues)
            {
                cbData = cbTot - cbUsed;

                if (cbUsed>=cbTot)
                {
                    //
                    // We should never get here, because we already calculated
                    // the size we want (unless the values are changing on us,
                    // which is assumed not to happen).
                    //
                    ASSERT(FALSE);
                    goto end;
                }

                pStr = pstrValues+cbUsed;
            }

            lRet = RegQueryValueExA(
                        hkSubKey,
                        pidstrNames[u].pStr,
                        NULL,
                        &dwType,
                        pStr,
                        &cbData
                        );

            if (ERROR_SUCCESS != lRet || dwType!=REG_SZ)
            {
                if (fMandatory)
                {
                    // We really shouldn't get here!
                    ASSERT(FALSE);
                    goto end;
                }
                continue;
            }

            // this is a good one...

            pidstrValues[v].dwID = pidstrNames[u].dwID;
            pidstrValues[v].dwData = pidstrNames[u].dwData;

            if (pstrValues)
            {
                pidstrValues[v].pStr = pStr;
                cbUsed += cbData;
            }

            v++;

            if (v>=cValues)
            {
                if (fMandatory)
                {
                    //
                    // This should never happen because we already counted
                    // the valid values.
                    //
                    ASSERT(FALSE);
                    goto end;
                }

                // we're done now...
                break;
            }
        }

        // We should have used up everything.
        ASSERT(!pstrValues || cbUsed==cbTot);
        ASSERT(v==cValues);
    }

    // If we're here means we're succeeding....
    uRet = cValues;
    *ppidstrValues = pidstrValues;
    pidstrValues = NULL; // so that it won't get freed below...

    if (ppstrValues)
    {
        *ppstrValues = pstrValues;
        pstrValues = NULL; // so it won't get freed below...
    }

end:

	if (hkSubKey) {RegCloseKey(hkSubKey); hkSubKey=NULL;}
	if (pstrValues)
	{
	    FREE_MEMORY(pstrValues);
	    pstrValues = NULL;
	}

	if (pidstrValues)
	{
	    FREE_MEMORY(pidstrValues);
	    pidstrValues = NULL;
	}

	return uRet;
}


UINT FindKeys(
        IN  HKEY hkRoot,
        IN  CHAR *pKeyName,
        IN  IDSTR *pidstrNames,
        IN  UINT cNames,
        OUT IDSTR ***pppidstrAvailableNames // OPTIONAL
        )
{
    LONG lRet;
    UINT cFound=0;
	HKEY hk = NULL;
    UINT uEnum=0;
    char rgchName[LINE_LEN+1];
    UINT cchBuffer = sizeof(rgchName)/sizeof(rgchName[0]);
    IDSTR **ppidstrAvailableNames=NULL;
    FILETIME ft;

    //DebugBreak();

    if (!cNames) goto end;

    // We allocate enough space for cFound names, although in practice
    // we may return a proper subset.
    if (pppidstrAvailableNames)
    {
        ppidstrAvailableNames = (IDSTR**)ALLOCATE_MEMORY(cNames*sizeof(IDSTR*));
        if (!ppidstrAvailableNames)
        {
            goto end;
        }
    }

    lRet = RegOpenKeyExA(
                hkRoot,
                pKeyName,
                0,
                KEY_READ,
                &hk
                );
    if (lRet!=ERROR_SUCCESS)
    {
        hk = NULL;
        goto end;
    }

    // Enumerate each installed modem
    //
    for (
        uEnum=0;
        !RegEnumKeyExA(
                    hk,  // handle of key to enumerate 
                    uEnum,  // index of subkey to enumerate 
                    rgchName,  // buffer for subkey name 
                    &cchBuffer,   // ptr to size (in chars) of subkey buffer 
                    NULL, // reserved 
                    NULL, // address of buffer for class string 
                    NULL,  // address for size of class buffer 
                    &ft // address for time key last written to 
                    );
        uEnum++, (cchBuffer = sizeof(rgchName)/sizeof(rgchName[0]))
        )
    {
        // Let's see if we can find this in our list...
        IDSTR *pidstr = pidstrNames;
        IDSTR *pidstrEnd = pidstrNames+cNames;

        for(;pidstr<pidstrEnd;pidstr++)
        {
            if (!lstrcmpiA(rgchName, pidstr->pStr))
            {
                // found it!
                if (ppidstrAvailableNames)
                {
                    ppidstrAvailableNames[cFound]=pidstr;
                }
                cFound++;
                break;
            }
        }
    }

    if (cFound)
    {
        // found at least one

        if (pppidstrAvailableNames)
        {
            *pppidstrAvailableNames = ppidstrAvailableNames;
            ppidstrAvailableNames = NULL; // so we don't free this later...
        }

    }

end:

	if (hk) {RegCloseKey(hk); hk=NULL;}

    if (ppidstrAvailableNames)
    {
        FREE_MEMORY(ppidstrAvailableNames);
        ppidstrAvailableNames=NULL;

    }

	return cFound;
}


/*----------------------------------------------------------
Purpose: This function gets the device info set for the modem
         class.  The set may be empty, which means there are
         no modems currently installed.

         The parameter pbInstalled is set to TRUE if there
         is a modem installed on the system.

Returns: TRUE a set is created
         FALSE

Cond:    --
*/
BOOL
PUBLIC
CplDiGetModemDevs(
    OUT HDEVINFO FAR *  phdi,           OPTIONAL
    IN  HWND            hwnd,           OPTIONAL
    IN  DWORD           dwFlags,        // DIGCF_ bit field
    OUT BOOL FAR *      pbInstalled)    OPTIONAL
{
 BOOL bRet;
 HDEVINFO hdi;

    DBG_ENTER(CplDiGetModemDevs);

    *pbInstalled = FALSE;

    hdi = CplDiGetClassDevs(c_pguidModem, NULL, hwnd, dwFlags);
    if (NULL != pbInstalled &&
        INVALID_HANDLE_VALUE != hdi)
    {
     SP_DEVINFO_DATA devData;

        // Is there a modem present on the system?
        devData.cbSize = sizeof(devData);
        *pbInstalled = CplDiEnumDeviceInfo(hdi, 0, &devData);
        SetLastError (NO_ERROR);
    }

    if (NULL != phdi)
    {
        *phdi = hdi;
    }
    else if (INVALID_HANDLE_VALUE != hdi)
    {
        SetupDiDestroyDeviceInfoList (hdi);
    }

    bRet = (INVALID_HANDLE_VALUE != hdi);

    DBG_EXIT_BOOL_ERR(CplDiGetModemDevs, bRet);

    return bRet;
}


/*----------------------------------------------------------
Purpose: Retrieves the friendly name of the device.  If there
         is no such device or friendly name, this function
         returns FALSE.

Returns: see above
Cond:    --
*/
BOOL
PUBLIC
CplDiGetPrivateProperties(
    IN  HDEVINFO        hdi,
    IN  PSP_DEVINFO_DATA pdevData,
    OUT PMODEM_PRIV_PROP pmpp)
{
 BOOL bRet = FALSE;
 HKEY hkey;

    DBG_ENTER(CplDiGetPrivateProperties);

    ASSERT(hdi && INVALID_HANDLE_VALUE != hdi);
    ASSERT(pdevData);
    ASSERT(pmpp);

    if (sizeof(*pmpp) != pmpp->cbSize)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
    }
    else
    {
        hkey = CplDiOpenDevRegKey(hdi, pdevData, DICS_FLAG_GLOBAL, 0, DIREG_DRV, KEY_READ);
        if (INVALID_HANDLE_VALUE != hkey)
        {
         DWORD cbData;
         DWORD dwMask = pmpp->dwMask;
         BYTE nValue;

            pmpp->dwMask = 0;

            if (IsFlagSet(dwMask, MPPM_FRIENDLY_NAME))
            {
                // Attempt to get the friendly name
                cbData = sizeof(pmpp->szFriendlyName);
                if (NO_ERROR ==
                     RegQueryValueEx(hkey, c_szFriendlyName, NULL, NULL, (LPBYTE)pmpp->szFriendlyName, &cbData) ||
                    0 != LoadString(g_hinst, IDS_UNINSTALLED, pmpp->szFriendlyName, sizeof(pmpp->szFriendlyName)/sizeof(WCHAR)))
                {
                    SetFlag(pmpp->dwMask, MPPM_FRIENDLY_NAME);
                }
            }

            if (IsFlagSet(dwMask, MPPM_DEVICE_TYPE))
            {
                // Attempt to get the device type
                cbData = sizeof(nValue);
                if (NO_ERROR ==
                    RegQueryValueEx(hkey, c_szDeviceType, NULL, NULL, &nValue, &cbData))
                {
                    pmpp->nDeviceType = nValue;     // dword <-- byte
                    SetFlag(pmpp->dwMask, MPPM_DEVICE_TYPE);
                }
            }

            if (IsFlagSet(dwMask, MPPM_PORT))
            {
                // Attempt to get the attached port
                cbData = sizeof(pmpp->szPort);
                if (NO_ERROR ==
                     RegQueryValueEx(hkey, c_szAttachedTo, NULL, NULL, (LPBYTE)pmpp->szPort, &cbData) ||
                    0 != LoadString(g_hinst, IDS_UNKNOWNPORT, pmpp->szPort, sizeof(pmpp->szPort)/sizeof(WCHAR)))
                {
                    SetFlag(pmpp->dwMask, MPPM_PORT);
                }
            }

            bRet = TRUE;

            RegCloseKey(hkey);
        }
        ELSE_TRACE ((TF_ERROR, "SetupDiOpenDevRegKey(DIREG_DRV) failed: %#lx.", GetLastError ()));
    }

    DBG_EXIT_BOOL_ERR(CplDiGetPrivateProperties, bRet);
    return bRet;
}


HINSTANCE
AddDeviceExtraPages (
    LPFINDDEV            pfd,
    LPFNADDPROPSHEETPAGE pfnAdd,
    LPARAM               lParam)
{
 TCHAR szExtraPages[LINE_LEN];
 TCHAR *pFunctionName = NULL;
 HINSTANCE hInstRet = NULL;
 DWORD dwType;
 DWORD cbData = sizeof(szExtraPages);
 PFNADDEXTRAPAGES pFn;

    // 1. Read the extra pages provider from the registry.
    if (ERROR_SUCCESS ==
        RegQueryValueEx (pfd->hkeyDrv, REGSTR_VAL_DEVICEEXTRAPAGES, NULL, &dwType, (PBYTE)szExtraPages, &cbData) &&
        REG_SZ == dwType)
    {
        // 2. The extra pages provider looks like this:
        //    "DLL,function".
        for (pFunctionName = szExtraPages;
             0 != *pFunctionName;
             pFunctionName++)
        {
            if (',' == *pFunctionName)
            {
                *pFunctionName = 0;
                pFunctionName++;
                break;
            }
        }

        // 3. Now load the DLL.
        hInstRet = LoadLibrary (szExtraPages);
        if (NULL != hInstRet)
        {
#ifdef UNICODE
            // If need be, convert the unicode string
            // to ascii.
            if (0 ==
                WideCharToMultiByte (CP_ACP, 0, pFunctionName, -1, (char*)szExtraPages, sizeof (szExtraPages), NULL, NULL))
            {
                FreeLibrary (hInstRet);
                hInstRet = 0;
            }
            else
#else // not UNICODE
            lstrcpy (szExtraPages, pFunctionName);
#endif // UNICODE
            {
                // 4. Get the address of the function.
                pFn = (PFNADDEXTRAPAGES)GetProcAddress (hInstRet, (char*)szExtraPages);
                if (NULL != pFn)
                {
                    pFn (pfd->hdi, &pfd->devData, pfnAdd, lParam);
                }
                else
                {
                    FreeLibrary (hInstRet);
                    hInstRet = NULL;
                }
            }
        }
    }

    return hInstRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\modemui\translate.h ===
//
// Country translation table
//


DWORD CountryTranslationTable[] =
{
93	,	0x5c, // Afghanistan
355	,	0x01, // Albania
213	,	0x02, // Algeria
684	,	0x03, // American Samoa
244	,	0x43, // Angola
101	,	0x05, // Anguilla
102	,	0x06, // Antigua and Barbuda
54	,	0x07, // Argentina
374	,	0xb8, // Armenia
247	,	0x08, // Ascension Island
61	,	0x09, // Australia
43	,	0x0a, // Austria
994	,	0xb8, // Azerbaijan
103	,	0x0b, // Bahamas
973	,	0x0c, // Bahrain
880	,	0x0d, // Bangladesh
104	,	0x0e, // Barbados
120	,	0x06, // Antigua and Barbuda
375	,	0x1e, // Belarus 
32	,	0x0f, // Belgium
501	,	0x10, // Belize 
229	,	0x11, // Benin 
105	,	0x12, // Bermuda 
975	,	0x13, // Bhutan 
591	,	0x14, // Bolivia 
387	,	0xc5, // Bosnia and Herzegovina
267	,	0x15, // Botswana 
55	,	0x16, // Brazil 
106	,	0x19, // British Virgin Islands 
673	,	0x1a, // Brunei 
359	,	0x1b, // Bulgaria 
226	,	0xb6, // Burkina Faso
257	,	0x1d, // Burundi 
855	,	0x2f, // Cambodia
237	,	0x1f, // Cameroon 
107	,	0x20, // Canada
238	,	0x21, // Cape Verde
108	,	0x22, // Cayman Islands
236	,	0x23, // Central African Republic
235	,	0x24, // Chad
56	,	0x25, // Chile
86	,	0x26, // China
57	,	0x27, // Colombia
2691,	0x28, // Comoros
242	,	0x29, // Congo
243	,	0xc2, // Congo (DRC)
682	,	0x2a, // Cook Islands
506	,	0x2b, // Costa Rica
225	,	0x5a, // Cte d'Ivoire
385	,	0xc5, // Croatia
53	,	0x2c, // Cuba
357	,	0x2d, // Cyprus
420	,	0x2e, // Czech Republic
45	,	0x31, // Denmark
253	,	0x32, // Djibouti
109	,	0x34, // Dominica
110	,	0x33, // Dominican Republic
593	,	0x35, // Ecuador
20	,	0x36, // Egypt
503	,	0x37, // El Salvador
240	,	0x38, // Equatorial Guinea
372	,	0xb8, // Estonia
251	,	0x39, // Ethiopia
500	,	0x3a, // Falkland Islands (Islas Malvinas)
679	,	0x3b, // Fiji Islands
358	,	0x3c, // Finland
33	,	0x3d, // France
689	,	0x3e, // French Polynesia
241	,	0x40, // Gabon
220	,	0x41, // Gambia
995	,	0xb8, // Georgia
49	,	0x04, // Germany (country code 04)
233	,	0x44, // Ghana
350	,	0x45, // Gibraltar
30	,	0x46, // Greece
111	,	0x47, // Grenada
124	,	0x48, // Guam
502	,	0x49, // Guatemala
224	,	0x4b, // Guinea
245	,	0x4c, // Guinea-Bissau
592	,	0x4d, // Guyana
509	,	0x4e, // Haiti
504	,	0x4f, // Honduras
852	,	0x50, // Hong Kong SAR
36	,	0x51, // Hungary
354	,	0x52, // Iceland
91	,	0x53, // India
62	,	0x54, // Indonesia
98	,	0x55, // Iran
964	,	0x56, // Iraq
353	,	0x57, // Ireland
972	,	0x58, // Israel
39	,	0x59, // Italy
112	,	0x5b, // Jamaica
81	,	0x00, // Japan
962	,	0x5e, // Jordan
705	,	0xb8, // Kazakhstan
254	,	0x5f, // Kenya
686	,	0x60, // Kiribati
850	,	0x61, // Korea
82	,	0x61, // Korea
965	,	0x62, // Kuwait
996	,	0xb8, // Kyrgyzstan
856	,	0x63, // Laos
371	,	0xb8, // Latvia
961	,	0x64, // Lebanon
266	,	0x65, // Lesotho
231	,	0x66, // Liberia
218	,	0x67, // Libya
423	,	0x68, // Liechtenstein
370	,	0xb8, // Lithuania
352	,	0x69, // Luxembourg
853	,	0x6a, // Macau SAR
261	,	0x6b, // Madagascar
265	,	0x6d, // Malawi
60	,	0x6c, // Malaysia
960	,	0x6e, // Maldives
223	,	0x6f, // Mali
356	,	0x70, // Malta
222	,	0x71, // Mauritania
230	,	0x72, // Mauritius
52	,	0x73, // Mexico
373	,	0xb8, // Moldova
377	,	0x74, // Monaco
976	,	0x75, // Mongolia
113	,	0x76, // Montserrat
212	,	0x77, // Morocco
258	,	0x78, // Mozambique
95	,	0x1c, // Myanmar 
674	,	0x79, // Nauru
977	,	0x7a, // Nepal
31	,	0x7b, // Netherlands
599	,	0x7c, // Netherlands Antilles
687	,	0x7d, // New Caledonia
64	,	0x7e, // New Zealand
505	,	0x7f, // Nicaragua
227	,	0x80, // Niger
234	,	0x81, // Nigeria
47	,	0x82, // Norway
968	,	0x83, // Oman
92	,	0x84, // Pakistan
507	,	0x85, // Panama
675	,	0x86, // Papua New Guinea
595	,	0x87, // Paraguay
51	,	0x88, // Peru
63	,	0x89, // Philippines
48	,	0x8a, // Poland
351	,	0x8b, // Portugal
121	,	0x8c, // Puerto Rico
974	,	0x8d, // Qatar
40	,	0x8e, // Romania
7	,	0xb8, // Russia
250	,	0x8f, // Rwanda
685	,	0xbe, // Samoa
378	,	0x94, // San Marino
239	,	0x96, // So Tom and Prncipe
966	,	0x98, // Saudi Arabia
221	,	0x99, // Senegal
248	,	0x9a, // Seychelles
232	,	0x9b, // Sierra Leone
65	,	0x9c, // Singapore
386	,	0xc5, // Slovenia
677	,	0x9d, // Solomon Islands
252	,	0x9e, // Somalia
27	,	0x9f, // South Africa
34	,	0xa0, // Spain
94	,	0xa1, // Sri Lanka
290	,	0x92, // St. Helena
115	,	0x90, // St. Kitts and Nevis
116	,	0x97, // St. Vincent and the Grenadines
249	,	0xa2, // Sudan
597	,	0xa3, // Suriname
268	,	0xa4, // Swaziland
46	,	0xa5, // Sweden
41	,	0xa6, // Switzerland
963	,	0xa7, // Syria
992	,	0xb8, // Tajikistan
255	,	0xa8, // Tanzania
66	,	0xa9, // Thailand
228	,	0xaa, // Togo
676	,	0xab, // Tonga
117	,	0xac, // Trinidad and Tobago
216	,	0xad, // Tunisia
90	,	0xae, // Turkey
993	,	0xb8, // Turkmenistan
118	,	0xaf, // Turks and Caicos Islands
688	,	0xb0, // Tuvalu
256	,	0xb1, // Uganda
380	,	0xb2, // Ukraine
971	,	0xb3, // United Arab Emirates
44	,	0xb4, // United Kingdom
1	,	0xb5, // United States
598	,	0xb7, // Uruguay
998	,	0xb8, // Uzbekistan
678	,	0xb9, // Vanuatu
379	,	0xba, // Vatican City
58	,	0xbb, // Venezuela
84	,	0xbc, // Vietnam
681	,	0xbd, // Wallis and Futuna
967	,	0xbf, // Yemen
381	,	0xc5, // Yugoslavia
260	,	0xc3, // Zambia
263	,	0xc4  // Zimbabwe
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\serwvdrv\debug.c ===
/*****************************************************************************
 *
 *  Microsoft Confidential
 *  Copyright (c) Microsoft Corporation 1996
 *  All rights reserved
 *
 *  File:       AIPC.H
 *
 *  Desc:       Interface to the asynchronous IPC mechanism for accessing the
 *              voice modem device functions.
 *
 *  History:    
 *      11/16/96    HeatherA created   
 * 
 *****************************************************************************/

#include <windows.h>
#include <stdarg.h>
#include <stdio.h>

#include "debug.h"



#if ( DBG )



ULONG DbgPrint( PCH pchFormat, ... )
{
    int         i;
    char        buf[256];
    va_list     va;

    va_start( va, pchFormat );
    i = vsprintf( buf, pchFormat, va );
    va_end( va );

    OutputDebugString( buf );
    return (ULONG) i;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\serwvdrv\debug.h ===
/*****************************************************************************
 *
 *  Microsoft Confidential
 *  Copyright (c) Microsoft Corporation 1996
 *  All rights reserved
 *
 *  File:       AIPC.H
 *
 *  Desc:       Interface to the asynchronous IPC mechanism for accessing the
 *              voice modem device functions.
 *
 *  History:    
 *      11/16/96    HeatherA created   
 * 
 *****************************************************************************/

#ifndef UMDEBUG_H
#define UMDEBUG_H

#define STR_MODULENAME "SERWVDRV:"

#define LVL_BLAB    4
#define LVL_VERBOSE 3
#define LVL_REPORT  2
#define LVL_ERROR   1

#ifdef ASSERT
#undef ASSERT
#endif // ASSERT


#if (DBG)

extern ULONG DebugLevel;

ULONG DbgPrint(PCH pchFormat, ...);


#define TRACE(lvl, strings)\
   if (lvl <= DebugLevel)\
   {\
      DbgPrint(STR_MODULENAME);\
      DbgPrint##strings;\
      DbgPrint("\n");\
      if (lvl == LVL_ERROR)\
      {\
      }\
   }



#define ASSERT(_x)\
    { if(!(_x))\
      { TRACE(LVL_ERROR,("ASSERT: (%s) File: %s, Line: %d \n\r",\
                                    #_x, __FILE__, __LINE__));\
      }\
    }
 
#else   // DBG

#define TRACE(lvl, strings)

#define ASSERT(_x)  {}

#endif  // DBG


#endif  // UMDEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\serwvdrv\aipc.h ===
/*****************************************************************************
 *
 *  Microsoft Confidential
 *  Copyright (c) Microsoft Corporation 1996
 *  All rights reserved
 *
 *  File:       AIPC.H
 *
 *  Desc:       Interface to the asynchronous IPC mechanism for accessing the
 *              voice modem device functions.
 *
 *  History:    
 *      2/26/97    HeatherA created   
 * 
 *****************************************************************************/

#define _AT_V2
#include <tapi.h>
#include "..\..\inc\umdmmini.h"
#include "..\tsp\asyncipc.h"


HANDLE
aipcInit(
    PDEVICE_CONTROL   Device,
    LPAIPCINFO        pAipc
    );




VOID
aipcDeinit(
    LPAIPCINFO pAipc
    );


BOOL WINAPI
SetVoiceMode(
    LPAIPCINFO pAipc,
    DWORD dwMode
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\modemui\util.h ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1997-1998
//
// File: util.h
//
//  This files contains all common utility routines
//
// History:
//  10-25-97 JosephJ     Adapted from NT4.0 util.h
//
//

#ifndef __UTIL_H__
#define __UTIL_H__


// Color macros
//
void PUBLIC TextAndBkCr(const DRAWITEMSTRUCT FAR * lpcdis, COLORREF FAR * pcrText, COLORREF FAR * pcrBk);


//----------------------------------------------------------------------------
// Dialog utilities ...
//----------------------------------------------------------------------------
int Edit_GetValue(
        HWND hwnd
        );

void Edit_SetValue(
    HWND hwnd,
    int nValue
    );

//----------------------------------------------------------------------------
// FINDDEV structure
//----------------------------------------------------------------------------

BOOL 
FindDev_Create(
    OUT LPFINDDEV FAR * ppfinddev,
    IN  LPGUID      pguidClass,
    IN  LPCTSTR     pszValueName,
    IN  LPCTSTR     pszValue);

BOOL 
FindDev_Destroy(
    IN LPFINDDEV this);


//----------------------------------------------------------------------------
// Property page utilities....
//----------------------------------------------------------------------------

BOOL
AddInstallerPropPage(
    HPROPSHEETPAGE hPage, 
    LPARAM lParam);

DWORD
AddExtraPages(
    LPPROPSHEETPAGE pPages,
    DWORD cPages,
    LPFNADDPROPSHEETPAGE pfnAdd, 
    LPARAM lParam);

DWORD
AddPage(
    //LPMODEMINFO pmi,
    void *pvBlob,
    LPCTSTR pszTemplate,
    DLGPROC pfnDlgProc, 
    LPFNADDPROPSHEETPAGE pfnAdd, 
    LPARAM lParam);



//----------------------------------------------------------------------------
//  Registry Access Functions....
//----------------------------------------------------------------------------

DWORD GetInactivityTimeoutScale(
    HKEY hkey);

DWORD
RegQueryModemSettings(
    HKEY hkey,
    LPMODEMSETTINGS pms
    );


DWORD
RegQueryDCB(
    HKEY hkey,
    WIN32DCB FAR * pdcb
    );


DWORD
RegSetModemSettings(
    HKEY hkeyDrv,
    LPMODEMSETTINGS pms
    );


// that is used to fill the various listboxes
typedef struct
{
        DWORD dwValue;
        // DWORD dwFlags;
        DWORD dwIDS;

} LBMAP;


typedef DWORD (*PFNLBLSELECTOR)(
                DWORD dwValue,
                void *pvContext
                );

#define fLBMAP_ADD_TO_LB (0x1 << 0)
#define fLBMAP_SELECT    (0x1 << 1)

void    LBMapFill(
            HWND hwndCB,
            LBMAP const *pLbMap,
            PFNLBLSELECTOR pfnSelector,
            void *pvContext
            );

typedef struct
{
    DWORD dwID;
    DWORD dwData;
    char *pStr;

} IDSTR; // for lack of a better name!

UINT ReadCommandsA(
        IN  HKEY hKey,
        IN  CHAR *pSubKeyName,
        OUT CHAR **ppValues // OPTIONAL
        );
//
// Reads all values (assumed to be REG_SZ) with names
// in the sequence "1", "2", "3".
//
// If ppValues is non-NULL it will be set to a  MULTI_SZ array
// of values.
//
// The return value is the number of values, or 0 if there is an error
// (or none).
//

UINT ReadIDSTR(
        IN  HKEY hKey,
        IN  CHAR *pSubKeyName,
        IN  IDSTR *pidstrNames,
        IN  UINT cNames,
        BOOL fMandatory,
        OUT IDSTR **ppidstrValues, // OPTIONAL
        OUT char **ppstrValues    // OPTIONAL
        );
//
//
// Reads the specified names from the specified subkey.
//
// If fMandatory is TRUE, all the specified names must exist, else the
// function will return 0 (failure).
//
// Returns the number of names that match.
//
// If ppidstrValues is non null, it will be set to
// a LocalAlloced array of IDSTRs, each IDSTR giving the ID and value
// associated with the corresponding name.
//
// The pstr pointo into a multi-sz LocalAlloced string, whose start is
// pointed to by ppstrValues on exit.
//
// If ppstrValues is NULL but ppidstrValues is non-null, the pStr field
// if the IDSTR entries is NULL.
//

UINT FindKeys(
        IN  HKEY hkRoot,
        IN  CHAR *pKeyName,
        IN  IDSTR *pidstrNames,
        IN  UINT cNames,
        OUT IDSTR ***pppidstrAvailableNames // OPTIONAL
        );
//      
//      Returns the count of subkeys it finds under the specified key
//      that are in the passed-in array (pidstrNames).
//      If pppidstrAvailableNames is non-null, it will set
//      *pppidstrAvailableNames to an ALLOCATE_MEMORY array of pointers
//      to the elements of pidstrNames that are found to be sub-keys
//      (there will be <ret-val> of them).
//


#ifdef DEBUG

//----------------------------------------------------------------------------
// Debug helper functions ...
//----------------------------------------------------------------------------

void
DumpDevCaps(
        LPREGDEVCAPS pdevcaps
        );

void
DumpModemSettings(
    LPMODEMSETTINGS pms
    );

void
DumpDCB(
    LPWIN32DCB pdcb
    );

#endif // DEBUG

#endif // __UTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\serwvdrv\aipc.c ===
/*****************************************************************************
 *
 *  Microsoft Confidential
 *  Copyright (c) Microsoft Corporation 1996
 *  All rights reserved
 *
 *  File:       AIPC.C
 *
 *  Desc:       Interface to the asynchronous IPC mechanism for accessing the
 *              voice modem device functions.
 *
 *  History:    
 *      2/26/97    HeatherA created   
 * 
 *****************************************************************************/


#include "internal.h"

#include <devioctl.h>
#include <ntddmodm.h>

#include "debug.h"



HANDLE WINAPI
OpenDeviceHandle(
    LPCTSTR  FriendlyName,
    LPOVERLAPPED Overlapped
    );



/*****************************************************************************
 *
 *  Function:   aipcInit()
 *
 *  Descr:      Allocates and initializes the device's AIPCINFO structure.
 *              This gets the COMM handle to the device.
 *
 *  Returns:    Pointer to newly allocated & initialized AIPCINFO, or 
 *              NULL if failure.
 *
 *****************************************************************************/
HANDLE
aipcInit(
    PDEVICE_CONTROL   Device,
    LPAIPCINFO        pAipc
    )
{
    LONG        lErr;
    DWORD       i;

    //
    // Create an event so SetVoiceMode() can wait for completion.  Event
    // will be signalled by CompleteSetVoiceMode().
    //

    pAipc->Overlapped.hEvent = (LPVOID)CreateEvent(NULL, TRUE, FALSE, NULL);


    if (pAipc->Overlapped.hEvent == NULL) {

        TRACE(LVL_ERROR,("aipcInit:: CreateEvent() failed (%#08lX)",
                    GetLastError()));
        goto err_exit;
    }


    pAipc->hComm = OpenDeviceHandle(Device->FriendlyName,&pAipc->Overlapped);

    // get the modem's COMM handle
    if (pAipc->hComm == INVALID_HANDLE_VALUE) {

    	TRACE(LVL_REPORT,("aipcInit:: OpenDeviceHandle() failed"));
        CloseHandle(pAipc->Overlapped.hEvent);
        goto err_exit;
    }

    
    return(pAipc->hComm);

err_exit:



    return(INVALID_HANDLE_VALUE);
    
}



/*****************************************************************************
 *
 *  Function:   OpenDeviceHandle()
 *
 *  Descr:      Gets a COMM handle for the device represented by the given
 *              registry key.
 *
 *  NOTES:      Borrowed from atmini\openclos.c
 *
 *  Returns:    Open COMM handle.
 *
 *****************************************************************************/
HANDLE WINAPI
OpenDeviceHandle
(
    LPCTSTR      FriendlyName,
    LPOVERLAPPED Overlapped
)
{
    LONG     lResult;
    DWORD    Type;
    DWORD    Size;

    HANDLE   FileHandle;

    DWORD    BytesTransfered;
    DWORD    OpenType;
    BOOL         bResult;

    //
    //  open the modem device using the friendly name
    //
    FileHandle=CreateFile(
        FriendlyName,
        GENERIC_WRITE | GENERIC_READ,
        FILE_SHARE_WRITE | FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        FILE_FLAG_OVERLAPPED,
        NULL
        );

    if (FileHandle == INVALID_HANDLE_VALUE)
    {
        TRACE(LVL_ERROR,("OpenDeviceHandle:: Failed to open (%ws). %08lx\n",
                FriendlyName, GetLastError()));
    }
#if 0
    OpenType=MODEM_OPEN_TYPE_WAVE;

    bResult=DeviceIoControl(
        FileHandle,
        IOCTL_MODEM_SET_OPEN_TYPE,
        &OpenType,
        sizeof(OpenType),
        NULL,
        0,
        NULL,
        Overlapped
        );

    if (!bResult && GetLastError() != ERROR_IO_PENDING) {

        CloseHandle(FileHandle);

        return INVALID_HANDLE_VALUE;
    }



    bResult=GetOverlappedResult(
        FileHandle,
        Overlapped,
        &BytesTransfered,
        TRUE
        );

    if (!bResult) {

        CloseHandle(FileHandle);

        return INVALID_HANDLE_VALUE;
    }
#endif

    return FileHandle;

}


/*****************************************************************************
 *
 *  Function:   aipcDeinit()
 *
 *  Descr:      Closes all open objects referenced by the given AIPCINFO
 *              structure, and frees it.
 *
 *  Returns:    none
 *
 *****************************************************************************/
VOID
aipcDeinit(
    LPAIPCINFO pAipc
    )
{

    CloseHandle(pAipc->hComm);

    CloseHandle(pAipc->Overlapped.hEvent);

    return;
}





/*****************************************************************************
 *
 *  Function:   SetVoiceMode()
 *
 *  Descr:      Send a call to the minidriver via the AIPC mechanism to put
 *              the device into a voice modes: start/stop play/record.
 *
 *  Notes:      In order to use this call, the AIPC services must have been
 *              successfully initialized by calling aipcInit().
 *
 *  Returns:    TRUE on success, FALSE on failure.
 *
 *****************************************************************************/
BOOL WINAPI SetVoiceMode
(
    LPAIPCINFO pAipc,
    DWORD dwMode
)
{
    BOOL    bResult = FALSE;       // assume failure
    DWORD   WaitResult;
    DWORD   BytesTransfered;

    LPCOMP_WAVE_PARAMS pCWP;
    
    LPAIPC_PARAMS pAipcParams = (LPAIPC_PARAMS)(pAipc->sndBuffer);
    LPREQ_WAVE_PARAMS pRWP = (LPREQ_WAVE_PARAMS)&pAipcParams->Params;
    
    pAipcParams->dwFunctionID = AIPC_REQUEST_WAVEACTION;
    pRWP->dwWaveAction = dwMode;


    bResult = DeviceIoControl(
        pAipc->hComm,
        IOCTL_MODEM_SEND_GET_MESSAGE,
        pAipc->sndBuffer,
        sizeof(pAipc->sndBuffer),
        pAipc->rcvBuffer,
        sizeof(pAipc->rcvBuffer),
        NULL,                  // lpBytesReturned
        &pAipc->Overlapped
        );

    if (!bResult && (GetLastError() != ERROR_IO_PENDING)) {

        TRACE(LVL_ERROR,("SetVoiceMode: Send message failed: %d",GetLastError()));

        return bResult;

    }

    WaitResult=WaitForSingleObject(
        pAipc->Overlapped.hEvent,
        30*1000
        );

    if (WaitResult == WAIT_TIMEOUT) {
        //
        //  Wait did not complete, cancel it
        //
        TRACE(LVL_ERROR,("SetVoiceMode: Send Wait timed out"));

        CancelIo(pAipc->hComm);
    }

    bResult=GetOverlappedResult(
        pAipc->hComm,
        &pAipc->Overlapped,
        &BytesTransfered,
        TRUE
        );

    if (!bResult) {
        //
        //  send message failed.
        //
        TRACE(LVL_ERROR,("SetVoiceMode: Send message failed async: %d",GetLastError()));

        return bResult;
    }

#if 0
    bResult = DeviceIoControl(
        pAipc->hComm,
        IOCTL_MODEM_GET_MESSAGE,
        NULL,
        0L,
        pAipc->rcvBuffer,
        sizeof(pAipc->rcvBuffer),
        NULL,                      // lpBytesReturned
        &pAipc->Overlapped
        );

    if (!bResult && (GetLastError() != ERROR_IO_PENDING)) {

        TRACE(LVL_ERROR,("SetVoiceMode: Get message failed: %d",GetLastError()));

        return bResult;

    }

    WaitResult=WaitForSingleObject(
        pAipc->Overlapped.hEvent,
        10*1000
        );

    if (WaitResult == WAIT_TIMEOUT) {
        //
        //  Wait did not complete, cancel it
        //
        TRACE(LVL_ERROR,("SetVoiceMode: Get Wait timed out"));

        CancelIo(pAipc->hComm);
    }

    bResult=GetOverlappedResult(
        pAipc->hComm,
        &pAipc->Overlapped,
        &BytesTransfered,
        TRUE
        );

    if (!bResult) {
        //
        //  send message failed.
        //
        TRACE(LVL_ERROR,("SetVoiceMode: Get message failed async: %d",GetLastError()));

        return bResult;
    }
#endif

    pAipcParams = (LPAIPC_PARAMS)(pAipc->rcvBuffer);
    pCWP = (LPCOMP_WAVE_PARAMS )&pAipcParams->Params;

    // We should be getting completion of the call we submitted.
    ASSERT(pCWP->dwWaveAction == dwMode);
    
    bResult = pCWP->bResult;

    TRACE(LVL_VERBOSE,("SetVoiceMode:: completed function: %#08lx  returns: %d",
            dwMode, bResult));

    return(bResult);
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\serwvdrv\internal.h ===
/*****************************************************************************
 *
 *  Microsoft Confidential
 *  Copyright (c) Microsoft Corporation 1996
 *  All rights reserved
 *
 *  File:       internal.h
 *
 *  Desc:
 *
 *  History:    
 *      ???         BryanW      Original author of MSWAV32.DLL: user-mode 
 *                              proxy to WDM-CSA driver MSWAVIO.DRV.
 *      10/28/96    HeatherA    Adapted from Bryan's MSWAV32.DLL for Unimodem
 *                              serial wave data streaming.
 * 
 *****************************************************************************/

#define UNICODE 1

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>


#include <windows.h>
#include <mmsystem.h>
#include <mmddk.h>
#include <mmreg.h>
#include <objbase.h>
#include <devioctl.h>

#include "debug.h"

#include <debugmem.h>

#include <umdmxfrm.h>

#include <vmodem.h>

#include "..\inc\waveids.h"

typedef struct _DEVICE_CONTROL {

    struct _DEVICE_CONTROL   *Next;

    LPTSTR     FriendlyName;

    HINSTANCE  TransformDll;

    WORD       TransformId;

    XFORM_INFO WaveOutXFormInfo;

    XFORM_INFO WaveInXFormInfo;

    WORD       InputGain;
    WORD       OutputGain;

    DWORD      DeviceId;

    WORD       WaveDevices;

    WAVEFORMATEX  WaveFormat;

} DEVICE_CONTROL, *PDEVICE_CONTROL;




typedef struct _DRIVER_CONTROL {

    DWORD             NumberOfDevices;

    BOOL              Enumerated;

    PDEVICE_CONTROL   DeviceList[512];

    TCHAR             WaveOutLine[MAXPNAMELEN];
    TCHAR             WaveInLine[MAXPNAMELEN];
    TCHAR             WaveOutHandset[MAXPNAMELEN];
    TCHAR             WaveInHandset[MAXPNAMELEN];

} DRIVER_CONTROL, *PDRIVER_CONTROL;


typedef struct _BUFFER_HEADER {

    OVERLAPPED             Overlapped;

    PWAVEHDR               WaveHeader;

    LIST_ENTRY             ListElement;

    union {

        struct {

            LPBYTE         Buffer;
            DWORD          BufferSize;

        } Input;

        struct {

            LPBYTE         Buffer;
            DWORD          BufferSize;

            DWORD          TotalDuration;
        } Output;
    };


    LPSTR     lpDataA;
    DWORD     dwBufferLengthA;
    LPSTR     lpDataB;
    DWORD     dwBufferLengthB;


} BUFFER_HEADER, *PBUFFER_HEADER;


// the following PIDs have been registered
// but are not yet in mmreg.h
#ifndef MM_MSFT_VMDMS_LINE_WAVEIN
  #define MM_MSFT_VMDMS_LINE_WAVEIN         70
  #define MM_MSFT_VMDMS_LINE_WAVEOUT        71
  #define MM_MSFT_VMDMS_HANDSET_WAVEIN      72
  #define MM_MSFT_VMDMS_HANDSET_WAVEOUT     73
  #define MM_MSFT_VMDMW_LINE_WAVEIN         74
  #define MM_MSFT_VMDMW_LINE_WAVEOUT        75
  #define MM_MSFT_VMDMW_HANDSET_WAVEIN      76
  #define MM_MSFT_VMDMW_HANDSET_WAVEOUT     77
  #define MM_MSFT_VMDMW_MIXER               78
  #define MM_MSFT_VMDM_GAME_WAVEOUT         79
  #define MM_MSFT_VMDM_GAME_WAVEIN          80

#endif



extern DRIVER_CONTROL  DriverControl;

LONG WINAPI
EnumerateModems(
    PDRIVER_CONTROL  DriverControl
    );




PDEVICE_CONTROL WINAPI
GetDeviceFromId(
    PDRIVER_CONTROL   DriverControl,
    DWORD             Id,
    PBOOL             Handset
    );

VOID
AlertedWait(
    HANDLE   EventToWaitFor
    );


#include "aipc.h"

typedef enum {

    DEVSTATE_STOP,
    DEVSTATE_PAUSE,
    DEVSTATE_RUN
    
} DEVSTATE, *PDEVSTATE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\serwvdrv\wavein.c ===
/*****************************************************************************
 *
 *  Microsoft Confidential
 *  Copyright (c) Microsoft Corporation 1996
 *  All rights reserved
 *
 *  File:       WIDDRV.C
 *
 *  Desc:
 *
 *  History:    
 *      ???         BryanW      Original author of MSWAV32.DLL: user-mode 
 *                              proxy to WDM-CSA driver MSWAVIO.DRV.
 *      10/28/96    HeatherA    Adapted from Bryan's MSWAV32.DLL for Unimodem
 *                              serial wave data streaming.
 * 
 *****************************************************************************/


#include "internal.h"



VOID
AsyncProcessingHandler(
    ULONG_PTR              dwParam
    );


typedef struct tagWIDINSTANCE
{
    HANDLE           hDevice;        // handle to wave output device
    HANDLE           hThread;
    HWAVE            hWave;          // APP's wave device handle (from WINMM)
    CRITICAL_SECTION csQueue;
    DWORD            cbSample;
    DWORD            dwFlags;        // flags passed by APP to waveOutOpen()
    DWORD_PTR        dwCallback;     // address of APP's callback function
    DWORD_PTR        dwInstance;     // APP's callback instance data
    DWORD            dwThreadId;
    volatile BOOL    fActive;
    AIPCINFO         Aipc;         // for async IPC mechanism

    LIST_ENTRY       ListHead;

    PBUFFER_HEADER   Current;

    HANDLE           ThreadStopEvent;

    DWORD            BytesTransfered;

    BOOL             Closing;

    DWORD            BuffersOutstanding;

    LONG             ReferenceCount;

    DWORD            BuffersInDriver;

    HANDLE           DriverEmpty;

    PDEVICE_CONTROL  DeviceControl;

    PVOID            pvXformObject;

    BOOL             Handset;

    WAVEHDR          FlushHeader;
    SHORT            FlushBuffer[40];


} WIDINSTANCE, *PWIDINSTANCE;

//--------------------------------------------------------------------------


DWORD PASCAL
widPrepare
(
    PWIDINSTANCE   pwi,
    LPWAVEHDR lpWaveHdr
);

DWORD PASCAL
widUnprepare
(
    LPWAVEHDR lpWaveHdr
);


//
// HACK! code duplication, need to set up a common header for the device
// instances.
//





/*****************************************************************************
 *
 *  Function:   
 *
 *  Descr:      
 *
 *  Returns:    
 *
 *****************************************************************************/
VOID widCallback
(
   PWIDINSTANCE   pwi,
   DWORD          dwMsg,
   DWORD_PTR      dwParam1
)
{
   if (pwi->dwCallback)
      DriverCallback( pwi->dwCallback,          // user's callback DWORD
                      HIWORD(pwi->dwFlags),     // callback flags
                      (HDRVR)pwi->hWave,        // handle to the wave device
                      dwMsg,                    // the message
                      pwi->dwInstance,          // user's instance data
                      dwParam1,                 // first DWORD
                      0L );                     // second DWORD
}


VOID static WINAPI
RemoveReference(
    PWIDINSTANCE   pwi
    )

{

    if (InterlockedDecrement(&pwi->ReferenceCount) == 0) {

        TRACE(LVL_VERBOSE,("RemoveReference: Cleaning up"));

        CloseHandle(pwi->DriverEmpty);

        CloseHandle(pwi->ThreadStopEvent);

        CloseHandle(pwi->hThread);

        DeleteCriticalSection(&pwi->csQueue);

        widUnprepare(&pwi->FlushHeader);

        FREE_MEMORY( pwi );
    }

    return;

}




VOID
UmWorkerThread(
    PWIDINSTANCE  pwi
    )

{

    BOOL           bResult;
    DWORD          BytesTransfered;
    DWORD          CompletionKey;
    LPOVERLAPPED   OverLapped;
    DWORD          WaitResult=WAIT_IO_COMPLETION;

//    D_INIT(DbgPrint("UmWorkThread:  starting\n");)


    while (WaitResult != WAIT_OBJECT_0) {

        WaitResult=WaitForSingleObjectEx(
            pwi->ThreadStopEvent,
            INFINITE,
            TRUE
            );


    }

    RemoveReference(pwi);

//    D_INIT(DbgPrint("UmWorkThread:  Exitting\n");)

    ExitThread(0);

}




/*****************************************************************************
 *
 *  Function:   
 *
 *  Descr:      
 *
 *  Returns:    
 *
 *****************************************************************************/
MMRESULT widGetPos
(
   PWIDINSTANCE   pwi,
   LPMMTIME       pmmt,
   ULONG          cbSize
)
{
    ULONG ulCurrentPos=pwi->BytesTransfered;
    DWORD Error;
    COMSTAT    ComStat;


    ClearCommError(
        pwi->hDevice,
        &Error,
        &ComStat
        );

    ulCurrentPos+=ComStat.cbInQue;

    ulCurrentPos = pwi->DeviceControl->WaveInXFormInfo.lpfnGetPosition(
        pwi->pvXformObject,
        ulCurrentPos
        );



    // Write this to the buffer as appropriate.

    if (pmmt-> wType == TIME_BYTES)
       pmmt->u.cb = ulCurrentPos;
    else
    {
       pmmt->wType = TIME_SAMPLES;
       pmmt->u.sample = ulCurrentPos / pwi->cbSample;
    }

    return MMSYSERR_NOERROR;
}


/*****************************************************************************
 *
 *  Function:   
 *
 *  Descr:      
 *
 *  Returns:    
 *
 *****************************************************************************/
MMRESULT widGetDevCaps
(
   UINT  uDevId,
   PBYTE pwc,
   ULONG cbSize
)
{
    WAVEINCAPSW wc;
    PDEVICE_CONTROL DeviceControl;
    BOOL            Handset;


    DeviceControl=GetDeviceFromId(
        &DriverControl,
        uDevId,
        &Handset
        );

    wc.wMid = MM_MICROSOFT;
    wc.wPid = MM_MSFT_VMDMS_LINE_WAVEIN;
    wc.vDriverVersion = 0x500;
    wc.dwFormats = 0;//WAVE_FORMAT_1M08 ;
    wc.wChannels = 1;

    if (Handset) {

        wsprintf(wc.szPname, DriverControl.WaveInHandset,DeviceControl->DeviceId);

    } else {

        wsprintf(wc.szPname, DriverControl.WaveInLine,DeviceControl->DeviceId);
    }


    CopyMemory( pwc, &wc, min( sizeof( wc ), cbSize ) );

    return MMSYSERR_NOERROR;
}


/*****************************************************************************
 *
 *  Function:   
 *
 *  Descr:      
 *
 *  Returns:    
 *
 *****************************************************************************/
MMRESULT widOpen
(
   UINT           uDevId,
   LPVOID         *ppvUser,
   LPWAVEOPENDESC pwodesc,
   ULONG          ulFlags
)
{
    HANDLE          hDevice;
    LPWAVEFORMATEX  pwf;
    PWIDINSTANCE    pwi;
    PDEVICE_CONTROL DeviceControl;
    BOOL            Handset;
    DWORD           dwThreadId;



    DeviceControl=GetDeviceFromId(
        &DriverControl,
        uDevId,
        &Handset
        );

        // Make sure we can handle the format

    pwf = (LPWAVEFORMATEX)(pwodesc -> lpFormat) ;

    if ((pwf->wFormatTag != DeviceControl->WaveFormat.wFormatTag)
        ||
        (pwf->nChannels != DeviceControl->WaveFormat.nChannels)
        ||
        (pwf->wBitsPerSample != DeviceControl->WaveFormat.wBitsPerSample)
        ||
        (pwf->nSamplesPerSec != DeviceControl->WaveFormat.nSamplesPerSec) ) {

         return WAVERR_BADFORMAT;
    }

    if (ulFlags & WAVE_FORMAT_QUERY) {

        return MMSYSERR_NOERROR;
    }



    //
    // Create and fill in a device instance structure.
    //
    pwi = (PWIDINSTANCE) ALLOCATE_MEMORY( sizeof(WIDINSTANCE));


    if (pwi  == NULL) {

        TRACE(LVL_ERROR,("widOpen:: LocalAlloc() failed"));

        return MMSYSERR_NOMEM;

    }


    pwi->Handset=Handset;

    pwi->DeviceControl=DeviceControl;

    pwi->BytesTransfered=0;

    InitializeCriticalSection(&pwi->csQueue);

    pwi->ReferenceCount=1;

    // hca: if this only supports callback, then error return on other requests?
    pwi->hWave = pwodesc->hWave;
    pwi->dwCallback = pwodesc->dwCallback;
    pwi->dwInstance = pwodesc->dwInstance;
    pwi->dwFlags = ulFlags;

    pwi->cbSample = pwf->wBitsPerSample / 8;

    pwi->fActive = FALSE;

    // allocate transform object

    pwi->pvXformObject = NULL;

    if (0 != pwi->DeviceControl->WaveInXFormInfo.wObjectSize) {
                    
        pwi->pvXformObject = ALLOCATE_MEMORY(pwi->DeviceControl->WaveInXFormInfo.wObjectSize);
                    
        if (NULL == pwi->pvXformObject) {

            FREE_MEMORY(pwi);

            return MMSYSERR_NOMEM ;
        }
    }

    pwi->FlushHeader.dwBufferLength=sizeof(pwi->FlushBuffer);
    pwi->FlushHeader.lpData=(PUCHAR)&pwi->FlushBuffer[0];


    if (MMSYSERR_NOERROR != widPrepare(
        pwi,
        &pwi->FlushHeader
        )) {

        FREE_MEMORY(pwi->pvXformObject);

        FREE_MEMORY(pwi);

        return MMSYSERR_NOMEM ;
    }



    pwi->hDevice = aipcInit(DeviceControl,&pwi->Aipc);

    if (pwi->hDevice == INVALID_HANDLE_VALUE) {

        widUnprepare(&pwi->FlushHeader);

        FREE_MEMORY(pwi->pvXformObject);

        FREE_MEMORY(pwi);

        return MMSYSERR_ALLOCATED;
    }



    InitializeListHead(
        &pwi->ListHead
        );


    pwi->ReferenceCount=1;

    pwi->DriverEmpty=CreateEvent(
        NULL,      // no security
        TRUE,      // manual reset
        TRUE,      // initially signalled
        NULL       // unnamed
        );

    if (pwi->DriverEmpty == NULL) {

        TRACE(LVL_REPORT,("widStart:: CreateEvent() failed"));

        DeleteCriticalSection(&pwi->csQueue);

        aipcDeinit(&pwi->Aipc);

        widUnprepare(&pwi->FlushHeader);

        FREE_MEMORY(pwi->pvXformObject);

        FREE_MEMORY(pwi);

        return MMSYSERR_NOMEM;

    }



    pwi->ThreadStopEvent = CreateEvent(
        NULL,      // no security
        TRUE,      // manual reset
        FALSE,     // initially not signalled
        NULL       // unnamed
        );

    if (pwi->ThreadStopEvent == NULL) {

        TRACE(LVL_REPORT,("widStart:: CreateEvent() failed"));

        CloseHandle(pwi->DriverEmpty);

        DeleteCriticalSection(&pwi->csQueue);

        aipcDeinit(&pwi->Aipc);

        widUnprepare(&pwi->FlushHeader);

        FREE_MEMORY(pwi->pvXformObject);

        FREE_MEMORY(pwi);

        return MMSYSERR_NOMEM;

    }

    pwi->hThread = CreateThread(
         NULL,                              // no security
         0,                                 // default stack
         (PTHREAD_START_ROUTINE) UmWorkerThread,
         (PVOID) pwi,                       // parameter
         0,                                 // default create flags
         &dwThreadId
         );



    if (pwi->hThread == NULL) {

        CloseHandle(pwi->ThreadStopEvent);

        CloseHandle(pwi->DriverEmpty);

        DeleteCriticalSection(&pwi->csQueue);

        aipcDeinit(&pwi->Aipc);

        widUnprepare(&pwi->FlushHeader);

        FREE_MEMORY(pwi->pvXformObject);

        FREE_MEMORY(pwi);

        return MMSYSERR_NOMEM;
    }


    //
    //  add one for thread
    //
    pwi->ReferenceCount++;

    if (!SetVoiceMode(&pwi->Aipc, Handset ? (WAVE_ACTION_USE_HANDSET | WAVE_ACTION_START_RECORD)
                                          : WAVE_ACTION_START_RECORD)) {

        aipcDeinit(&pwi->Aipc);

        FREE_MEMORY(pwi->pvXformObject);

        RemoveReference(pwi);

        SetEvent(pwi->ThreadStopEvent);

        return MMSYSERR_NOMEM;
    }




    DeviceControl->WaveInXFormInfo.lpfnInit(pwi->pvXformObject,DeviceControl->InputGain);

    //
    // Prepare the device...
    //

    pwi->Current=NULL;

    *ppvUser = pwi;

    widCallback(pwi, WIM_OPEN, 0L);

    QueueUserAPC(
        AsyncProcessingHandler,
        pwi->hThread,
        (ULONG_PTR)pwi
        );


    return MMSYSERR_NOERROR;
}




/*****************************************************************************
 *
 *  Function:   
 *
 *  Descr:      
 *
 *  Returns:    
 *
 *****************************************************************************/
MMRESULT widStart
(
   PWIDINSTANCE  pwi
)
{
    // If device instance is already in active state, don't allow restart.
    if (pwi->fActive)
    {
        TRACE(LVL_REPORT,("widStart:: no-op: device already active"));
        return MMSYSERR_INVALPARAM;
    }

    pwi->fActive = TRUE;

    EnterCriticalSection(&pwi->csQueue);

    if (pwi->fActive) {
        //
        //  started, see if there is a buffer being processed
        //
        if (pwi->Current == NULL) {

            BOOL    bResult;

            bResult=QueueUserAPC(
                AsyncProcessingHandler,
                pwi->hThread,
                (ULONG_PTR)pwi
                );
        }
    }

    LeaveCriticalSection(&pwi->csQueue);


    return MMSYSERR_NOERROR;
}






VOID WINAPI
ReadCompletionHandler(
    DWORD              ErrorCode,
    DWORD              BytesRead,
    LPOVERLAPPED       Overlapped
    )

{
    PBUFFER_HEADER      Header=(PBUFFER_HEADER)Overlapped;

    PWIDINSTANCE        pwi=(PWIDINSTANCE)Header->WaveHeader->lpNext;

    LPWAVEHDR           WaveHeader=Header->WaveHeader;

    BOOL                bResult;


    VALIDATE_MEMORY(Header);

    if ((ErrorCode == ERROR_SUCCESS)) {

        pwi->BytesTransfered+=BytesRead;

        WaveHeader->dwBytesRecorded+=BytesRead;

    } else {

        WaveHeader->dwBytesRecorded=0;
    }


    if (NULL == Header->lpDataA) {
        //
        // no transforms
        // Header->SerWaveIO.lpData == WaveHeader->lpData
        //
//        WaveHeader->dwBytesRecorded = Header->SerWaveIO.BytesRead;

    } else {

        if (NULL == Header->lpDataB) {
            //
            // perform only one transform
            // do the transform directly from the serial wave buffer
            //
            WaveHeader->dwBytesRecorded = pwi->DeviceControl->WaveInXFormInfo.lpfnTransformA(
                pwi->pvXformObject,
                Header->Input.Buffer,
                WaveHeader->dwBytesRecorded,
                WaveHeader->lpData,
                WaveHeader->dwBufferLength
                );

        } else {

            DWORD   dwBytes;
            //
            // perform both transforms
            //
            VALIDATE_MEMORY(Header->Input.Buffer);

            dwBytes = pwi->DeviceControl->WaveInXFormInfo.lpfnTransformB(
                pwi->pvXformObject,
                Header->Input.Buffer,
                WaveHeader->dwBytesRecorded,
                Header->lpDataA,
                Header->dwBufferLengthA
                );

            VALIDATE_MEMORY(Header->lpDataA);

            WaveHeader->dwBytesRecorded = pwi->DeviceControl->WaveInXFormInfo.lpfnTransformA(
                pwi->pvXformObject,
                Header->lpDataA,
                dwBytes,
                WaveHeader->lpData,
                WaveHeader->dwBufferLength
                );
        }
    }

    EnterCriticalSection(&pwi->csQueue);

    pwi->BuffersOutstanding--;

    if ((pwi->BuffersOutstanding == 0) && (pwi->Closing)) {
        //
        //  last buffer has been completed and the device is being closed, tell the thread
        //  to exit.
        //
        SetEvent(pwi->ThreadStopEvent);

    }

    //
    //  done with this buffer, it on its way out
    //
    pwi->Current=NULL;

    LeaveCriticalSection(&pwi->csQueue);


    ASSERT(WaveHeader->dwBytesRecorded <= WaveHeader->dwBufferLength);

    if (WaveHeader != &pwi->FlushHeader) {
        //
        //  not the flush buffer
        //
        WaveHeader->dwFlags &= ~WHDR_INQUEUE;
        WaveHeader->dwFlags |= WHDR_DONE;

        widCallback( pwi, WIM_DATA, (DWORD_PTR) WaveHeader );

        EnterCriticalSection(&pwi->csQueue);

        if (InterlockedDecrement(&pwi->BuffersInDriver) == 0) {

            TRACE(LVL_VERBOSE,("ReadCompletionHandler:: driver empty, Oustanding %d",pwi->BuffersOutstanding));

            SetEvent(pwi->DriverEmpty);
        }

        LeaveCriticalSection(&pwi->csQueue);
    }


    AsyncProcessingHandler(
        (ULONG_PTR)pwi
        );


    return;

}





VOID
AsyncProcessingHandler(
    ULONG_PTR              dwParam
    )

{
    PWIDINSTANCE   pwi=(PWIDINSTANCE)dwParam;

    PLIST_ENTRY        Element;

    PBUFFER_HEADER      Header;

    LPWAVEHDR           WaveHeader;

    BOOL               bEmpty=TRUE;
    BOOL               bResult;

    EnterCriticalSection(&pwi->csQueue);

    if (pwi->fActive) {

        if (pwi->Current == NULL) {

            bEmpty=IsListEmpty(
                &pwi->ListHead
                );

            if (!bEmpty) {

                Element=RemoveHeadList(
                    &pwi->ListHead
                    );

                pwi->Current=CONTAINING_RECORD(Element,BUFFER_HEADER,ListElement);

            }

            Header=pwi->Current;
        }

    } else {
        //
        //  not started
        //
        if ((pwi->Current == NULL) && !pwi->Closing) {
            //
            //  not currently processing a buffer
            //
            Header=(PBUFFER_HEADER)pwi->FlushHeader.reserved;

            pwi->Current=Header;

            pwi->FlushHeader.dwBytesRecorded=0;

            pwi->FlushHeader.lpNext=(LPWAVEHDR)pwi;

            pwi->BuffersOutstanding++;

            bEmpty=FALSE;
        }
    }



    if (bEmpty) {

        LeaveCriticalSection(&pwi->csQueue);

        return;
    }

    WaveHeader=Header->WaveHeader;
    //
    //  a buffer is going to be sent to the driver, if it an app one reset our event
    //
    if (WaveHeader != &pwi->FlushHeader) {
        //
        //  app supplied buffer
        //
        ResetEvent(pwi->DriverEmpty);

        InterlockedIncrement(&pwi->BuffersInDriver);
    }

    LeaveCriticalSection(&pwi->csQueue);



    bResult=ReadFileEx(
        pwi->hDevice,
        Header->Input.Buffer        + WaveHeader->dwBytesRecorded,
        Header->Input.BufferSize    - WaveHeader->dwBytesRecorded,
        &Header->Overlapped,
        ReadCompletionHandler
        );

    if (bResult) {
        //
        //  success, the buffer is on its way, just wait for it to complete
        //
    } else {
        //
        //  ReadFileEx() failed, send the buffer back now
        //
        pwi->Current=NULL;

        if (WaveHeader != &pwi->FlushHeader) {
            //
            //  not the flush buffer
            //
            WaveHeader->dwFlags &= ~WHDR_INQUEUE;
            WaveHeader->dwFlags |= WHDR_DONE;

            widCallback( pwi, WIM_DATA, (DWORD_PTR) WaveHeader );

            EnterCriticalSection(&pwi->csQueue);
            //
            //  buffer never made it to the wave driver, mark the driver as empty
            //
            if (InterlockedDecrement(&pwi->BuffersInDriver) == 0) {

                TRACE(LVL_VERBOSE,("ReadCompletionHandler:: driver empty, Oustanding %d",pwi->BuffersOutstanding));

                SetEvent(pwi->DriverEmpty);
            }
            LeaveCriticalSection(&pwi->csQueue);

        }

        EnterCriticalSection(&pwi->csQueue);

        pwi->BuffersOutstanding--;

        if ((pwi->BuffersOutstanding == 0) && (pwi->Closing)) {
            //
            //  last buffer has been completed and the device is being closed, tell the thread
            //  to exit.
            //
            SetEvent(pwi->ThreadStopEvent);

        }
        LeaveCriticalSection(&pwi->csQueue);

    }

    return;


}


DWORD PASCAL
widPrepare
(
    PWIDINSTANCE   pwi,
    LPWAVEHDR lpWaveHdr
)
{
    DWORD dwSamples;
    PBUFFER_HEADER    Header;



    Header=ALLOCATE_MEMORY(sizeof(BUFFER_HEADER));

    if (NULL == Header) {

        return MMSYSERR_NOMEM;
    }


    Header->lpDataA = NULL;
    Header->lpDataB = NULL;


    // link the pointers so we can find them when WODM_WRITE is called and
    // in the callback
    lpWaveHdr->reserved = (DWORD_PTR)Header;
    Header->WaveHeader =  lpWaveHdr;



    pwi->DeviceControl->WaveInXFormInfo.lpfnGetBufferSizes(
        pwi->pvXformObject,
        lpWaveHdr->dwBufferLength,
        &Header->dwBufferLengthA,
        &Header->dwBufferLengthB);

    if (0 == Header->dwBufferLengthA) {

        Header->Input.Buffer=lpWaveHdr->lpData;
        Header->Input.BufferSize=lpWaveHdr->dwBufferLength;

    } else {

        if (0 == Header->dwBufferLengthB) {

            // create the data buffer for the actual shadow buffer
            // which will get passed down to the serial port
            Header->lpDataA = ALLOCATE_MEMORY( Header->dwBufferLengthA);

            if ((LPSTR)NULL == Header->lpDataA) {

                goto CleanUp010;
            }

            Header->Input.Buffer=Header->lpDataA;
            Header->Input.BufferSize=Header->dwBufferLengthA;
        }
        else {

            // create the data buffer for the imtermediate conversion
            //
            Header->lpDataA = ALLOCATE_MEMORY( Header->dwBufferLengthA);

            if ((LPSTR)NULL == Header->lpDataA) {

                goto CleanUp010;
            }

            // now, create the data buffer for the actual shadow buffer
            // which will get passed down to the serial port
            Header->lpDataB = ALLOCATE_MEMORY( Header->dwBufferLengthB);

            if ((LPSTR)NULL == Header->lpDataB) {

                goto CleanUp020;

            }

            Header->Input.Buffer=Header->lpDataB;
            Header->Input.BufferSize=Header->dwBufferLengthB;


        }
    }

    lpWaveHdr->dwFlags |= WHDR_PREPARED;

    return MMSYSERR_NOERROR;

CleanUp020:

    FREE_MEMORY(Header->lpDataA);

CleanUp010:

    FREE_MEMORY(Header);

    ASSERT(0);
    return MMSYSERR_NOTENABLED;


}

DWORD PASCAL
widUnprepare
(
    LPWAVEHDR lpWaveHdr
)
{

    PBUFFER_HEADER Header;


    Header = (PBUFFER_HEADER)lpWaveHdr->reserved;

    VALIDATE_MEMORY(Header);

#if DBG
    lpWaveHdr->reserved=0;
    lpWaveHdr->lpNext=NULL;
#endif


    if (NULL != Header->lpDataB)
    {
        FREE_MEMORY(Header->lpDataB);
    }

    if (NULL != Header->lpDataA)
    {
        FREE_MEMORY(Header->lpDataA);
    }

    FREE_MEMORY(Header);

    lpWaveHdr->dwFlags &= ~WHDR_PREPARED;

    return MMSYSERR_NOERROR;

}





/*****************************************************************************
 *
 *  Function:   widAddBuffer()
 *
 *  Descr:      This wave API constitutes a request for input.  Due to the 
 *              latency of the device relative to the speed of the COMM port,
 *              the request is queued and serviced when waveInStart() is
 *              called.
 *
 *  Returns:    
 *
 *****************************************************************************/
MMRESULT widAddBuffer
(
   PWIDINSTANCE   pwi,
   LPWAVEHDR      phdr
)
{
    MMRESULT    mmr;

    PBUFFER_HEADER     Header;



    mmr = MMSYSERR_NOERROR;

    // Make sure the app has prepared the buffer.
    if (0 == (phdr->dwFlags & WHDR_PREPARED))
    {
        TRACE(LVL_REPORT,("widAddBuffer:: buffer hasn't been prepared"));
        return WAVERR_UNPREPARED;
    }

    // Make sure the app isn't handing us a buffer we've already been given.
    if (phdr->dwFlags & WHDR_INQUEUE)
    {
        TRACE(LVL_REPORT,("widAddBuffer:: buffer is already queued"));
        return WAVERR_STILLPLAYING;
    }

    if (pwi->Closing) {
        //
        //  closing send it back out now
        //
        TRACE(LVL_VERBOSE,("widaddbuffer: called while closing"));

        phdr->dwFlags &= ~WHDR_INQUEUE;
        phdr->dwFlags |= WHDR_DONE;

        widCallback( pwi, WIM_DATA, (DWORD_PTR) phdr );

        return MMSYSERR_NOERROR;
    }


    Header=(PBUFFER_HEADER)phdr->reserved;

    phdr->lpNext=(LPWAVEHDR)pwi;

    phdr->dwBytesRecorded=0;

    phdr->dwFlags |= WHDR_INQUEUE;
    phdr->dwFlags &= ~WHDR_DONE;

    // Add the new buffer (write request) to the END of the queue.
    EnterCriticalSection(&pwi->csQueue);

    pwi->BuffersOutstanding++;

    VALIDATE_MEMORY(Header);

    InsertTailList(
        &pwi->ListHead,
        &Header->ListElement
        );


    if (pwi->fActive) {
        //
        //  started, see if there is a buffer being processed
        //
        if (pwi->Current == NULL) {

            BOOL    bResult;

            bResult=QueueUserAPC(
                AsyncProcessingHandler,
                pwi->hThread,
                (ULONG_PTR)pwi
                );
        }
    }



    LeaveCriticalSection(&pwi->csQueue);


    return MMSYSERR_NOERROR;
}


/*****************************************************************************
 *
 *  Function:   
 *
 *  Descr:      
 *
 *  Returns:    
 *
 *****************************************************************************/
MMRESULT widReset
(
   PWIDINSTANCE   pwi
)
{

    BOOL         bEmpty;

    PBUFFER_HEADER     BufferHeader;

    PLIST_ENTRY        Element;

    LIST_ENTRY         TempList;


    pwi->fActive = FALSE;

    InitializeListHead(&TempList);

    EnterCriticalSection(&pwi->csQueue);

    bEmpty=IsListEmpty(
        &pwi->ListHead
        );

    while  (!bEmpty) {

        Element=RemoveHeadList(
            &pwi->ListHead
            );

        BufferHeader=CONTAINING_RECORD(Element,BUFFER_HEADER,ListElement);

        pwi->BuffersOutstanding--;

        TRACE(LVL_VERBOSE,("widreset: Putting buffer on temp list before waiting"));

        InsertTailList(
            &TempList,
            &BufferHeader->ListElement
            );


        bEmpty=IsListEmpty(
            &pwi->ListHead
            );

    }

    LeaveCriticalSection(&pwi->csQueue);

    PurgeComm(
       pwi->hDevice,
       PURGE_RXABORT
       );

    TRACE(LVL_VERBOSE,("widreset: %d buffers in driver, waiting",pwi->BuffersInDriver));

    AlertedWait(pwi->DriverEmpty);

    EnterCriticalSection(&pwi->csQueue);

    //
    //  remove any more buffers that may have been queued, while we were waiting
    //
    while  (!bEmpty) {

        Element=RemoveHeadList(
            &pwi->ListHead
            );

        BufferHeader=CONTAINING_RECORD(Element,BUFFER_HEADER,ListElement);

        pwi->BuffersOutstanding--;

        TRACE(LVL_VERBOSE,("widreset: Putting buffer on temp list after waiting"));

        InsertTailList(
            &TempList,
            &BufferHeader->ListElement
            );


        bEmpty=IsListEmpty(
            &pwi->ListHead
            );

    }



    bEmpty=IsListEmpty(
        &TempList
        );

    while  (!bEmpty) {

        Element=RemoveHeadList(
            &TempList
            );

        BufferHeader=CONTAINING_RECORD(Element,BUFFER_HEADER,ListElement);

        BufferHeader->WaveHeader->dwFlags &= ~WHDR_INQUEUE;
        BufferHeader->WaveHeader->dwFlags |= WHDR_DONE;

        if ((pwi->BuffersOutstanding == 0) && (pwi->Closing)) {
            //
            //  last buffer has been completed and the device is being closed, tell the thread
            //  to exit.
            //
            SetEvent(pwi->ThreadStopEvent);

        }

        LeaveCriticalSection(&pwi->csQueue);

        widCallback( pwi, WIM_DATA, (DWORD_PTR) BufferHeader->WaveHeader );

        EnterCriticalSection(&pwi->csQueue);

        bEmpty=IsListEmpty(
            &TempList
            );

    }

    LeaveCriticalSection(&pwi->csQueue);

    return MMSYSERR_NOERROR;
}


/*****************************************************************************
 *
 *  Function:   
 *
 *  Descr:      
 *
 *  Returns:    
 *
 *****************************************************************************/
MMRESULT widStop
(
   PWIDINSTANCE   pwi
)
{
    if (pwi->fActive) {

        pwi->fActive = FALSE;

        PurgeComm(
           pwi->hDevice,
           PURGE_RXABORT
           );

        TRACE(LVL_VERBOSE,("widstop: %d buffers in driver, waiting",pwi->BuffersInDriver));

        AlertedWait(pwi->DriverEmpty);

    }

   return MMSYSERR_NOERROR;
}


/*****************************************************************************
 *
 *  Function:   
 *
 *  Descr:      
 *
 *  Returns:    
 *
 *****************************************************************************/
MMRESULT widClose
(
   PWIDINSTANCE   pwi
)
{
    HANDLE      hDevice;

    pwi->fActive = FALSE;

    pwi->Closing=TRUE;

    widReset(pwi);

    EnterCriticalSection(&pwi->csQueue);

    if ((pwi->BuffersOutstanding == 0) && (pwi->Closing)) {
        //
        //  last buffer has been completed and the device is being closed, tell the thread
        //  to exit.
        //
        SetEvent(pwi->ThreadStopEvent);

    }

    LeaveCriticalSection(&pwi->csQueue);

    //
    //  thread will exit when the last buffer is processed
    //
    AlertedWait(pwi->ThreadStopEvent);

    SetVoiceMode(
        &pwi->Aipc,
        pwi->Handset ? (WAVE_ACTION_USE_HANDSET | WAVE_ACTION_STOP_STREAMING) : WAVE_ACTION_STOP_STREAMING
        );

    aipcDeinit(&pwi->Aipc);

    // free the allocated memory
    if (NULL != pwi->pvXformObject) {

        FREE_MEMORY(pwi->pvXformObject );
    }


    widCallback( pwi, WIM_CLOSE, 0L );

    RemoveReference(pwi);

    return MMSYSERR_NOERROR;
}


/*****************************************************************************
 *
 *  Function:   widMessage()
 *
 *  Descr:      Exported driver function (required).  Processes messages sent
 *              from WINMM.DLL to wave input device.
 *
 *  Returns:    
 *
 *****************************************************************************/
DWORD APIENTRY widMessage
(
   DWORD     id,
   DWORD     msg,
   DWORD_PTR dwUser,
   DWORD_PTR dwParam1,
   DWORD     dwParam2
)
{
   switch (msg) {
      case DRVM_INIT:
         TRACE(LVL_VERBOSE, ("WIDM_INIT") );
         return MMSYSERR_NOERROR;

      case WIDM_GETNUMDEVS:
         TRACE(LVL_VERBOSE, ("WIDM_GETNUMDEVS, device id==%d", id) );

         EnumerateModems(
                &DriverControl
                );


         return DriverControl.NumberOfDevices;
//         return 1;

      case WIDM_OPEN:
//         TRACE(LVL_VERBOSE, ("WIDM_OPEN, device id==%d", id) );
         return widOpen( id, (LPVOID *) dwUser, 
                         (LPWAVEOPENDESC) dwParam1, dwParam2 );

      case WIDM_GETDEVCAPS:
         TRACE(LVL_VERBOSE, ("WIDM_GETDEVCAPS, device id==%d", id) );
         return widGetDevCaps( id, (LPBYTE) dwParam1, dwParam2 );

      case WIDM_CLOSE:
         TRACE(LVL_VERBOSE, ("WIDM_CLOSE, device id==%d", id) );
         return widClose( (PWIDINSTANCE) dwUser );

      case WIDM_ADDBUFFER:
//         TRACE(LVL_VERBOSE, ("WIDM_ADDBUFFER, device id==%d", id) );
         return widAddBuffer( (PWIDINSTANCE) dwUser, (LPWAVEHDR) dwParam1 );

      case WIDM_START:
         TRACE(LVL_VERBOSE, ("WIDM_START, device id==%d", id) );
         return widStart( (PWIDINSTANCE) dwUser );

      case WIDM_STOP:
         TRACE(LVL_VERBOSE, ("WIDM_STOP, device id==%d", id) );
         return widStop( (PWIDINSTANCE) dwUser );

      case WIDM_RESET:
         TRACE(LVL_VERBOSE, ("WIDM_RESET, device id==%d", id) );
         return widReset( (PWIDINSTANCE) dwUser );

      case WIDM_GETPOS:
         TRACE(LVL_VERBOSE, ("WIDM_GETPOS, device id==%d", id) );
         return widGetPos( (PWIDINSTANCE) dwUser,
                           (LPMMTIME) dwParam1, dwParam2 );

#if 1
        case WIDM_PREPARE:
            return widPrepare((PWIDINSTANCE) dwUser, (LPWAVEHDR) dwParam1);

        case WIDM_UNPREPARE:
            return widUnprepare((LPWAVEHDR) dwParam1);
#endif


      default:
         return MMSYSERR_NOTSUPPORTED;
   }

   //
   // Should not get here
   //

   return MMSYSERR_NOTSUPPORTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\serwvdrv\waveout.c ===
/*****************************************************************************
 *
 *  Microsoft Confidential
 *  Copyright (c) Microsoft Corporation 1996
 *  All rights reserved
 *
 *  File:       WODDRV.C
 *
 *  Desc:
 *
 *  History:    
 *      ???         BryanW      Original author of MSWAV32.DLL: user-mode 
 *                              proxy to WDM-CSA driver MSWAVIO.DRV.
 *      10/28/96    HeatherA    Adapted from Bryan's MSWAV32.DLL for Unimodem
 *                              serial wave data streaming.
 * 
 *****************************************************************************/


#include "internal.h"

#define SAMPLES_TO_MS(_samples) ((_samples)/16)

VOID
WriteAsyncProcessingHandler(
    ULONG_PTR              dwParam
    );



typedef struct tagWODINSTANCE;


// data associated with an output device instance
typedef struct tagWODINSTANCE
{
    HANDLE           hDevice;        // handle to wave output device
    HANDLE           hThread;
    HWAVE            hWave;          // APP's wave device handle (from WINMM)
    CRITICAL_SECTION csQueue;
    DWORD            cbSample;
    DWORD            dwFlags;        // flags passed by APP to waveOutOpen()
    DWORD_PTR        dwCallback;     // address of APP's callback function
    DWORD_PTR        dwInstance;     // APP's callback instance data
    volatile BOOL    fActive;

    AIPCINFO         Aipc;         // for async IPC mechanism

    LIST_ENTRY       ListHead;

    LIST_ENTRY       ResetListHead;

    HANDLE           ThreadStopEvent;

    DWORD            BytesWritten;

    BOOL             Closing;

    DWORD            BuffersOutstanding;

    LONG             ReferenceCount;

    DWORD            BuffersInDriver;

    HANDLE           DriverEmpty;

    PDEVICE_CONTROL  DeviceControl;

    PVOID            pvXformObject;

    BOOL             Handset;

    DWORD            StartTime;
    DWORD            TotalTime;

    HANDLE           TimerHandle;

    LIST_ENTRY       BuffersToReturn;

    BOOL             Aborted;

} WODINSTANCE, *PWODINSTANCE;



VOID
AlertedWait(
    HANDLE   EventToWaitFor
    )
{
    DWORD          WaitResult=WAIT_IO_COMPLETION;

    while (WaitResult != WAIT_OBJECT_0) {

        WaitResult=WaitForSingleObjectEx(
            EventToWaitFor,
            INFINITE,
            TRUE
            );

    }
    return;
}



/*****************************************************************************
 *
 *  Function:   
 *
 *  Descr:      
 *
 *  Returns:    
 *
 *****************************************************************************/
VOID wodCallback
(
   PWODINSTANCE   pwi,
   DWORD          dwMsg,
   DWORD_PTR      dwParam1
)
{
   if (pwi->dwCallback)
      DriverCallback( pwi->dwCallback,         // user's callback DWORD
                      HIWORD( pwi->dwFlags ),  // callback flags
                      (HDRVR) pwi->hWave,      // handle to the wave device
                      dwMsg,                   // the message
                      pwi->dwInstance,         // user's instance data
                      dwParam1,                // first DWORD
                      0L );                    // second DWORD
}




VOID WINAPI
RemoveReference(
    PWODINSTANCE   pwi
    )

{

    if (InterlockedDecrement(&pwi->ReferenceCount) == 0) {

        TRACE(LVL_VERBOSE,("RemoveReference: Cleaning up"));

        CloseHandle(pwi->DriverEmpty);

        CloseHandle(pwi->ThreadStopEvent);

        CloseHandle(pwi->hThread);

        DeleteCriticalSection(&pwi->csQueue);

        CloseHandle(pwi->TimerHandle);

        FREE_MEMORY( pwi );
    }

    return;

}




VOID
WriteUmWorkerThread(
    PWODINSTANCE  pwi
    )

{

    DWORD          WaitResult=WAIT_IO_COMPLETION;

    TRACE(LVL_VERBOSE,("WorkerThread: Starting"));

//    D_INIT(DbgPrint("UmWorkThread:  starting\n");)

    while (WaitResult != WAIT_OBJECT_0) {

        WaitResult=WaitForSingleObjectEx(
            pwi->ThreadStopEvent,
            INFINITE,
            TRUE
            );


    }

    RemoveReference(pwi);

    TRACE(LVL_VERBOSE,("WorkerThread: Exitting"));

//    D_INIT(DbgPrint("UmWorkThread:  Exitting\n");)

    ExitThread(0);

}






/*****************************************************************************
 *
 *  Function:   
 *
 *  Descr:      
 *
 *  Returns:    
 *
 *****************************************************************************/
MMRESULT wodGetPos
(
   PWODINSTANCE   pwi,
   LPMMTIME       pmmt,
   ULONG          cbSize
)
{
    ULONG ulCurrentPos=pwi->BytesWritten;
    DWORD Error;
    COMSTAT    ComStat;

/*
    ClearCommError(
        pwi->hDevice,
        &Error,
        &ComStat
        );

    ulCurrentPos-=ComStat.cbOutQue;
    */


    ulCurrentPos = pwi->DeviceControl->WaveOutXFormInfo.lpfnGetPosition(
        pwi->pvXformObject,
        ulCurrentPos
        );


    // Write this to the buffer as appropriate.

    if (pmmt-> wType == TIME_BYTES)
       pmmt->u.cb = ulCurrentPos;
    else
    {
       pmmt->wType = TIME_SAMPLES;
       pmmt->u.sample = ulCurrentPos / pwi->cbSample;
    }

    return MMSYSERR_NOERROR;
}


/*****************************************************************************
 *
 *  Function:   
 *
 *  Descr:      
 *
 *  Returns:    
 *
 *****************************************************************************/
MMRESULT wodGetDevCaps
(
   UINT  uDevId,
   PBYTE pwc,
   ULONG cbSize
)
{
    WAVEOUTCAPSW wc;
    PDEVICE_CONTROL DeviceControl;
    BOOL            Handset;



    DeviceControl=GetDeviceFromId(
        &DriverControl,
        uDevId,
        &Handset
        );

    wc.wMid = MM_MICROSOFT;
    wc.wPid = MM_MSFT_VMDMS_LINE_WAVEOUT;
    wc.vDriverVersion = 0x0500;
    wc.dwFormats = 0; //WAVE_FORMAT_1M08 ;
    wc.wChannels = 1;
    wc.dwSupport = 0;

    if (Handset) {

        wsprintf(wc.szPname, DriverControl.WaveOutHandset,DeviceControl->DeviceId);

    } else {

        wsprintf(wc.szPname, DriverControl.WaveOutLine,DeviceControl->DeviceId);
    }

    CopyMemory( pwc, &wc, min( sizeof( wc ), cbSize ) );

    return MMSYSERR_NOERROR;
}


/*****************************************************************************
 *
 *  Function:   
 *
 *  Descr:      
 *
 *  Returns:    
 *
 *****************************************************************************/
MMRESULT wodOpen
(
   UINT           uDevId,
   LPVOID         *ppvUser,
   LPWAVEOPENDESC pwodesc,
   ULONG          ulFlags
)
{
    HANDLE          hDevice;
    LPWAVEFORMATEX  pwf;
    PWODINSTANCE    pwi=NULL;
    PDEVICE_CONTROL DeviceControl;
    BOOL            Handset;
    MMRESULT        Result;
    DWORD           dwThreadId;



    DeviceControl=GetDeviceFromId(
        &DriverControl,
        uDevId,
        &Handset
        );


        // Make sure we can handle the format

    pwf = (LPWAVEFORMATEX)(pwodesc -> lpFormat) ;

    if ((pwf->wFormatTag != DeviceControl->WaveFormat.wFormatTag)
        ||
        (pwf->nChannels != DeviceControl->WaveFormat.nChannels)
        ||
        (pwf->wBitsPerSample != DeviceControl->WaveFormat.wBitsPerSample)
        ||
        (pwf->nSamplesPerSec != DeviceControl->WaveFormat.nSamplesPerSec) ) {

//         TRACE(LVL_REPORT,("wodOpen: Bad Format format %d, channels %d, Bits %d, rate %d",
//             pwf->wFormatTag,
//             pwf->nChannels,
//             pwf->wBitsPerSample,
//             pwf->nSamplesPerSec
//             ));

         return WAVERR_BADFORMAT;
    }

    if (ulFlags & WAVE_FORMAT_QUERY) {

//        TRACE(LVL_REPORT,("wodOpen: Format Query"));

        return MMSYSERR_NOERROR;
    }

    TRACE(LVL_REPORT,("wodOpen"));

    pwi = (PWODINSTANCE) ALLOCATE_MEMORY( sizeof(WODINSTANCE));

    // Create and fill in a device instance structure.
    //
    if (pwi == NULL) {

        TRACE(LVL_ERROR,("wodOpen:: LocalAlloc() failed"));
        // TBD: return an appropriate MMSYSERR_ here

        return MMSYSERR_NOMEM;
    }

    InitializeCriticalSection(&pwi->csQueue);

    pwi->Handset=Handset;

    pwi->DeviceControl=DeviceControl;

    // allocate transform object

    pwi->pvXformObject = NULL;

    if (0 != pwi->DeviceControl->WaveOutXFormInfo.wObjectSize) {
                    
        pwi->pvXformObject = ALLOCATE_MEMORY(pwi->DeviceControl->WaveOutXFormInfo.wObjectSize);
                    
        if (NULL == pwi->pvXformObject) {

            Result=MMSYSERR_NOMEM ;

            goto Cleanup;
        }
    }


    pwi->hDevice = aipcInit(DeviceControl,&pwi->Aipc);

    if (pwi->hDevice == INVALID_HANDLE_VALUE) {

        Result=MMSYSERR_ALLOCATED;

        goto Cleanup;
    }


    pwi->TotalTime=0;
    pwi->StartTime=0;

    pwi->Aborted=FALSE;

    pwi->BytesWritten=0;

    // hca: if this only supports callback, then error return on other requests?
    pwi->hWave = pwodesc->hWave;
    pwi->dwCallback = pwodesc->dwCallback;
    pwi->dwInstance = pwodesc->dwInstance;
    pwi->dwFlags = ulFlags;

    // hca: do we do *any* format that the app asks for?  Don't think so....
    pwf = (LPWAVEFORMATEX) pwodesc->lpFormat;
    pwi->cbSample = pwf->nChannels;
    pwi->cbSample *= pwf->wBitsPerSample / 8;

    pwi->fActive = TRUE;

    //
    // Prepare the device...
    //


    InitializeListHead(
        &pwi->ListHead
        );

    InitializeListHead(
        &pwi->ResetListHead
        );

    InitializeListHead(
        &pwi->BuffersToReturn
        );

    pwi->TimerHandle=CreateWaitableTimer(
        NULL,
        TRUE,
        NULL
        );

    if (pwi->TimerHandle == NULL) {

        TRACE(LVL_REPORT,("widStart: CreateWaitableTimer() failed"));

        Result=MMSYSERR_NOMEM;

        goto Cleanup;
    }



    pwi->ReferenceCount=1;

    pwi->DriverEmpty=CreateEvent(
        NULL,      // no security
        TRUE,      // manual reset
        TRUE,      // initially signalled
        NULL       // unnamed
        );

    if (pwi->DriverEmpty == NULL) {

        TRACE(LVL_REPORT,("widStart:: CreateEvent() failed"));

        Result=MMSYSERR_NOMEM;

        goto Cleanup;

    }



    pwi->ThreadStopEvent = CreateEvent(
        NULL,      // no security
        TRUE,      // manual reset
        FALSE,     // initially not signalled
        NULL       // unnamed
        );

    if (pwi->ThreadStopEvent == NULL) {

        TRACE(LVL_REPORT,("widStart:: CreateEvent() failed"));

        Result=MMSYSERR_NOMEM;

        goto Cleanup;
    }

    pwi->hThread = CreateThread(
         NULL,                              // no security
         0,                                 // default stack
         (PTHREAD_START_ROUTINE) WriteUmWorkerThread,
         (PVOID) pwi,                       // parameter
         0,                                 // default create flags
         &dwThreadId
         );



    if (pwi->hThread == NULL) {

        Result=MMSYSERR_NOMEM;

        goto Cleanup;
    }

    //
    //  one for thread
    //
    InterlockedIncrement(&pwi->ReferenceCount);



    if (!SetVoiceMode(&pwi->Aipc, Handset ? (WAVE_ACTION_START_PLAYBACK | WAVE_ACTION_USE_HANDSET)
                                          : WAVE_ACTION_START_PLAYBACK)) {

        aipcDeinit(&pwi->Aipc);

        FREE_MEMORY(pwi->pvXformObject);

        RemoveReference(pwi);

        SetEvent(pwi->ThreadStopEvent);

        return MMSYSERR_NOMEM;
    }


    DeviceControl->WaveOutXFormInfo.lpfnInit(pwi->pvXformObject,DeviceControl->OutputGain);

    *ppvUser = pwi;

    pwi->StartTime=GetTickCount();

    wodCallback(pwi, WOM_OPEN, 0L);

    return MMSYSERR_NOERROR;

Cleanup:

    if (pwi->ThreadStopEvent != NULL) {

        CloseHandle(pwi->ThreadStopEvent);
    }

    if (pwi->DriverEmpty != NULL) {

        CloseHandle(pwi->DriverEmpty);
    }

    if (pwi->TimerHandle != NULL) {

        CloseHandle(pwi->TimerHandle);
    }

    if (pwi->hDevice != INVALID_HANDLE_VALUE) {

        aipcDeinit(&pwi->Aipc);
    }

    if (pwi->pvXformObject != NULL) {

        FREE_MEMORY(pwi->pvXformObject);
    }

    DeleteCriticalSection(&pwi->csQueue);

    FREE_MEMORY(pwi);

    return Result;

}


/*****************************************************************************
 *
 *  Function:   
 *
 *  Descr:      Creates the event queue and worker thread if they don't exist
 *              already, and sets the state to active.
 *
 *  Returns:    
 *
 *****************************************************************************/
MMRESULT wodStart
(
   PWODINSTANCE   pwi
)
{
    // If device instance is already in active state, don't allow restart.
    if (pwi->fActive)
    {
        TRACE(LVL_REPORT,("wodStart:: no-op: device already active"));
        return MMSYSERR_INVALPARAM;
    }


    // (hca: why the atomic set?  Only one thread per dev instance...)
    InterlockedExchange( (LPLONG)&pwi->fActive, TRUE );
    TRACE(LVL_VERBOSE,("wodStart:: state = active\n"));

    EnterCriticalSection(&pwi->csQueue);

    pwi->StartTime=GetTickCount();

    if (pwi->fActive) {
        //
        //  started, see if there is a buffer being processed
        //

        BOOL    bResult;

        bResult=QueueUserAPC(
            WriteAsyncProcessingHandler,
            pwi->hThread,
            (ULONG_PTR)pwi
            );
    }

    LeaveCriticalSection(&pwi->csQueue);



    return MMSYSERR_NOERROR;
}

#if 0
VOID WINAPI
TryToCompleteClose(
    PWODINSTANCE   pwi
    )

{

    if ((pwi->BuffersOutstanding == 0) && (pwi->Closing)) {
        //
        //  last buffer has been completed and the device is being closed, tell the thread
        //  to exit.
        //
        SetEvent(pwi->ThreadStopEvent);

    }

}
#endif


VOID WINAPI
TimerApcRoutine(
    PWODINSTANCE       pwi,
    DWORD              LowTime,
    DWORD              HighTime
    )

{
    PLIST_ENTRY        Element;
    PBUFFER_HEADER     Header;
    LPWAVEHDR          WaveHeader;

    EnterCriticalSection(&pwi->csQueue);

    TRACE(LVL_VERBOSE,("TimerApcRoutine: Running"));

    Element=RemoveHeadList(
        &pwi->BuffersToReturn
        );

    Header=CONTAINING_RECORD(Element,BUFFER_HEADER,ListElement);

    WaveHeader=Header->WaveHeader;

    pwi->BuffersOutstanding--;

    if ((pwi->BuffersOutstanding == 0) && (pwi->Closing)) {
        //
        //  last buffer has been completed and the device is being closed, tell the thread
        //  to exit.
        //
        SetEvent(pwi->ThreadStopEvent);

    }

    if (!IsListEmpty( &pwi->BuffersToReturn)) {
        //
        //  not empty, need to set timer again
        //
        DWORD  ExpireTime;
        LONGLONG       DueTime;

        Element=pwi->BuffersToReturn.Flink;

        Header=CONTAINING_RECORD(Element,BUFFER_HEADER,ListElement);


        if (Header->Output.TotalDuration <= (GetTickCount()-pwi->StartTime)) {
            //
            //  time has past set time to 1 ms
            //
            ExpireTime=1;

        } else {

            ExpireTime=Header->Output.TotalDuration-(GetTickCount()-pwi->StartTime);
        }

        DueTime=Int32x32To64(ExpireTime,-10000);

        TRACE(LVL_VERBOSE,("TimerApcRoutine: setting timer for %d ms",ExpireTime));

        SetWaitableTimer(
            pwi->TimerHandle,
            (LARGE_INTEGER*)&DueTime,
            0,
            TimerApcRoutine,
            pwi,
            FALSE
            );

    }



    LeaveCriticalSection(&pwi->csQueue);

    WaveHeader->dwFlags &= ~WHDR_INQUEUE;
    WaveHeader->dwFlags |= WHDR_DONE;

    wodCallback( pwi, WOM_DONE, (DWORD_PTR) WaveHeader );

    if (InterlockedDecrement(&pwi->BuffersInDriver) == 0) {

        TRACE(LVL_VERBOSE,("WriteCompletionHandler:: driver empty, Oustanding %d",pwi->BuffersOutstanding));

        SetEvent(pwi->DriverEmpty);
    }


    return;

}

VOID
QueueBufferForReturn(
    PWODINSTANCE   pwi,
    PBUFFER_HEADER      Header
    )

{
    EnterCriticalSection(&pwi->csQueue);

    if (IsListEmpty( &pwi->BuffersToReturn)) {
        //
        //  no buffer there yet, need to set timer
        //
        DWORD       ExpireTime;

        LONGLONG    DueTime;

        if (Header->Output.TotalDuration <= (GetTickCount()-pwi->StartTime)) {
            //
            //  time has past set time to 1 ms
            //
            ExpireTime=1;

        } else {

            ExpireTime=Header->Output.TotalDuration-(GetTickCount()-pwi->StartTime);
        }

        DueTime=Int32x32To64(ExpireTime,-10000);

        TRACE(LVL_VERBOSE,("QueueBufferForReturn: setting timer for %d ms, duration=%d, diff=%d",ExpireTime,Header->Output.TotalDuration,GetTickCount()-pwi->StartTime));

        SetWaitableTimer(
            pwi->TimerHandle,
            (LARGE_INTEGER*)&DueTime,
            0,
            TimerApcRoutine,
            pwi,
            FALSE
            );

    }

    InsertTailList(
        &pwi->BuffersToReturn,
        &Header->ListElement
        );

    LeaveCriticalSection(&pwi->csQueue);

    return;
}


VOID WINAPI
WriteCompletionHandler(
    DWORD              ErrorCode,
    DWORD              BytesRead,
    LPOVERLAPPED       Overlapped
    )

{
    PBUFFER_HEADER      Header=(PBUFFER_HEADER)Overlapped;

    PWODINSTANCE        pwi=(PWODINSTANCE)Header->WaveHeader->lpNext;

    LPWAVEHDR           WaveHeader=Header->WaveHeader;

    BOOL                bResult;


    if ((ErrorCode != ERROR_SUCCESS)) {

        TRACE(LVL_VERBOSE,("WriteCompletionHandler:: failed  %d",ErrorCode));

        //
        //  set duration to zero so it will complete quickly
        //
        Header->Output.TotalDuration=0;

//        CancelIo(
//           pwi->hDevice
//           );

    }

    pwi->BytesWritten+=BytesRead;

    QueueBufferForReturn(
        pwi,
        Header
        );

    WriteAsyncProcessingHandler(
        (ULONG_PTR)pwi
        );

    return;

}




VOID
WriteAsyncProcessingHandler(
    ULONG_PTR              dwParam
    )

{
    PWODINSTANCE   pwi=(PWODINSTANCE)dwParam;

    PLIST_ENTRY        Element;

    PBUFFER_HEADER      Header;

    LPWAVEHDR           WaveHeader;

    BOOL               bResult;




    if (!pwi->fActive) {

        return;
    }

    EnterCriticalSection(&pwi->csQueue);

    while (!IsListEmpty( &pwi->ListHead )) {

        Element=RemoveHeadList(
            &pwi->ListHead
            );


        Header=CONTAINING_RECORD(Element,BUFFER_HEADER,ListElement);

        WaveHeader=Header->WaveHeader;

        pwi->TotalTime+=SAMPLES_TO_MS(WaveHeader->dwBufferLength);

        Header->Output.TotalDuration=pwi->TotalTime;

        ResetEvent(pwi->DriverEmpty);

        InterlockedIncrement(&pwi->BuffersInDriver);

        bResult=WriteFileEx(
            pwi->hDevice,
            Header->Output.Buffer,
            Header->Output.BufferSize,
            &Header->Overlapped,
            WriteCompletionHandler
            );

        if (!bResult) {
            //
            //  failed, return it now
            //
            TRACE(LVL_ERROR,("WriteAsyncProcessingHandler: writeFileEx() failed"));

            Header->Output.TotalDuration=0;

            QueueBufferForReturn(
                pwi,
                Header
                );

        }
    }

    LeaveCriticalSection(&pwi->csQueue);


    return;


}


DWORD PASCAL
wodPrepare
(
    PWODINSTANCE   pwi,
    LPWAVEHDR lpWaveHdr
)
{
    DWORD dwSamples;
    PBUFFER_HEADER    Header;



    Header=ALLOCATE_MEMORY(sizeof(BUFFER_HEADER));

    if (NULL == Header) {

        return MMSYSERR_NOMEM;
    }


    Header->lpDataA = NULL;
    Header->lpDataB = NULL;


    // link the pointers so we can find them when WODM_WRITE is called and
    // in the callback
    lpWaveHdr->reserved = (DWORD_PTR)Header;
    Header->WaveHeader =  lpWaveHdr;



    pwi->DeviceControl->WaveOutXFormInfo.lpfnGetBufferSizes(
        pwi->pvXformObject,
        lpWaveHdr->dwBufferLength,
        &Header->dwBufferLengthA,
        &Header->dwBufferLengthB);

    if (0 == Header->dwBufferLengthA) {

        return MMSYSERR_NOTSUPPORTED;
    }

    if (0 == Header->dwBufferLengthB) {

        // create the data buffer for the actual shadow buffer 
        // which will get passed down to the serial port
        Header->lpDataA = ALLOCATE_MEMORY( Header->dwBufferLengthA);

        if ((LPSTR)NULL == Header->lpDataA) {

            goto CleanUp010;
        }

    }
    else {

        // create the data buffer for the imtermediate conversion
        //
        Header->lpDataA = ALLOCATE_MEMORY( Header->dwBufferLengthA);

        if ((LPSTR)NULL == Header->lpDataA) {

            goto CleanUp010;
        }

        // now, create the data buffer for the actual shadow buffer 
        // which will get passed down to the serial port
        Header->lpDataB = ALLOCATE_MEMORY( Header->dwBufferLengthB);

        if ((LPSTR)NULL == Header->lpDataB) {

            goto CleanUp020;

        }

    }

    lpWaveHdr->dwFlags |= WHDR_PREPARED;

    return MMSYSERR_NOERROR;

CleanUp020:

    FREE_MEMORY(Header->lpDataA);

CleanUp010:

    FREE_MEMORY(Header);

    ASSERT(0);
    return MMSYSERR_NOTENABLED;


}

DWORD PASCAL
wodUnprepare
(
    LPWAVEHDR lpWaveHdr
)
{

    PBUFFER_HEADER Header;


    Header = (PBUFFER_HEADER)lpWaveHdr->reserved;

    if (NULL != Header->lpDataB)
    {
        FREE_MEMORY(Header->lpDataB);
    }

    if (NULL != Header->lpDataA)
    {
        FREE_MEMORY(Header->lpDataA);
    }


    FREE_MEMORY(Header);

    lpWaveHdr->dwFlags &= ~WHDR_PREPARED;

    return MMSYSERR_NOERROR;

}




/*****************************************************************************
 *
 *  Function:   
 *
 *  Descr:      
 *
 *  Returns:    
 *
 *****************************************************************************/
MMRESULT wodWrite
(
   PWODINSTANCE   pwi,
   LPWAVEHDR      phdr
)
{
    MMRESULT    mmr;

    PBUFFER_HEADER     Header;

    mmr = MMSYSERR_NOERROR;

    // check if it's been prepared

    if (0 == (phdr->dwFlags & WHDR_PREPARED))
            return WAVERR_UNPREPARED;

    if (phdr->dwFlags & WHDR_INQUEUE)
            return WAVERR_STILLPLAYING;



    Header=(PBUFFER_HEADER)phdr->reserved;

    if (NULL == Header->lpDataA) {
        //
        // no transforms
        //

        Header->Output.Buffer     = phdr->lpData;
        Header->Output.BufferSize = phdr->dwBufferLength;

    } else {

        if (NULL == Header->lpDataB) {
            //
            // perform only one transform
            // do the transform directly to the serial wave buffer
            //
            Header->Output.Buffer=Header->lpDataA;

            Header->Output.BufferSize = pwi->DeviceControl->WaveOutXFormInfo.lpfnTransformA(
                pwi->pvXformObject,
                phdr->lpData,
                phdr->dwBufferLength,
                Header->Output.Buffer,
                0 //Header->dwBufferLengthB
                );

        } else {

            DWORD   dwBytes;

            //
            // perform both transforms
            //
            dwBytes = pwi->DeviceControl->WaveOutXFormInfo.lpfnTransformA(
                pwi->pvXformObject,
                phdr->lpData,
                phdr->dwBufferLength,
                Header->lpDataA,
                0 //Header->dwBufferLengthA
                );

            Header->Output.Buffer=Header->lpDataB;

            Header->Output.BufferSize = pwi->DeviceControl->WaveOutXFormInfo.lpfnTransformB(
                pwi->pvXformObject,
                Header->lpDataA,
                dwBytes,
                Header->Output.Buffer,
                0 //Header->dwBufferLengthB
                );
        }
    }


    EnterCriticalSection(&pwi->csQueue);

    if (pwi->Closing) {

        LeaveCriticalSection(&pwi->csQueue);

        return MMSYSERR_NOMEM;
    }



    pwi->BuffersOutstanding++;

    phdr->lpNext=(LPWAVEHDR)pwi;

    phdr->dwFlags |= WHDR_INQUEUE;
    phdr->dwFlags &= ~WHDR_DONE;

    // Add the new buffer (write request) to the END of the queue.

    InsertTailList(
        &pwi->ListHead,
        &Header->ListElement
        );


    if (pwi->fActive) {
        //
        //  started, see if there is a buffer being processed
        //
        BOOL    bResult;

        bResult=QueueUserAPC(
            WriteAsyncProcessingHandler,
            pwi->hThread,
            (ULONG_PTR)pwi
            );
    }



    LeaveCriticalSection(&pwi->csQueue);


    return MMSYSERR_NOERROR;
}


/*****************************************************************************
 *
 *  Function:   
 *
 *  Descr:      
 *
 *  Returns:    
 *
 *****************************************************************************/
MMRESULT wodPause
(
   PWODINSTANCE   pwi
)
{
    // nothing to do if device is already in paused state
    if (pwi->fActive) {

        TRACE(LVL_VERBOSE,("wodPause:: setting active device state to PAUSED"));
    }

    pwi->fActive=FALSE;

    TRACE(LVL_VERBOSE,("wodpause: %d buffers in driver, outstanding %d ",pwi->BuffersInDriver, pwi->BuffersOutstanding));

    return MMSYSERR_NOERROR;
}


VOID
ResetAsyncProcessingHandler(
    ULONG_PTR              dwParam
    )

{
    PWODINSTANCE   pwi=(PWODINSTANCE)dwParam;

    PLIST_ENTRY        Element;

    PBUFFER_HEADER      Header;

    LPWAVEHDR           WaveHeader;

    EnterCriticalSection(&pwi->csQueue);

    TRACE(LVL_VERBOSE,("ResetAsyncProccessingHandler"));
    //
    //  remove the count for the apc that was queued
    //
    InterlockedDecrement(&pwi->BuffersInDriver);

    while  (!IsListEmpty(&pwi->ResetListHead)) {

        Element=RemoveHeadList(
            &pwi->ResetListHead
            );

        Header=CONTAINING_RECORD(Element,BUFFER_HEADER,ListElement);


        Header->Output.TotalDuration=0;

        ResetEvent(pwi->DriverEmpty);
        //
        //  add ref for this apc which will continue the processing
        //
        InterlockedIncrement(&pwi->BuffersInDriver);


        QueueBufferForReturn(
            pwi,
            Header
            );

    }



    LeaveCriticalSection(&pwi->csQueue);
}



/*****************************************************************************
 *
 *  Function:   
 *
 *  Descr:      
 *
 *  Returns:    
 *
 *****************************************************************************/
MMRESULT wodReset
(
   PWODINSTANCE   pwi
)
{

    BOOL    bEmpty;
    PLIST_ENTRY    Element;
    PBUFFER_HEADER Header;

    DWORD          BuffersOnResetQueue=0;

    InterlockedExchange( (LPLONG)&pwi->fActive, FALSE );

    EnterCriticalSection(&pwi->csQueue);

    if (!pwi->Aborted) {
        //
        //  has not been aborted so far
        //
        pwi->Aborted=(pwi->BuffersOutstanding != 0);

        if (pwi->Aborted) TRACE(LVL_VERBOSE,("wodreset: reset with buffers outstanding"));
    }

    while  (!IsListEmpty(&pwi->ListHead)) {

        Element=RemoveHeadList(
            &pwi->ListHead
            );

        InsertTailList(
            &pwi->ResetListHead,
            Element
            );

    }

    PurgeComm(
       pwi->hDevice,
       PURGE_TXABORT | PURGE_TXCLEAR
       );


    LeaveCriticalSection(&pwi->csQueue);

    TRACE(LVL_VERBOSE,("wodreset: %d buffers in driver, waiting",pwi->BuffersInDriver));

    AlertedWait(pwi->DriverEmpty);

    EnterCriticalSection(&pwi->csQueue);


    while  (!IsListEmpty(&pwi->ListHead)) {

        Element=RemoveHeadList(
            &pwi->ListHead
            );

        InsertTailList(
            &pwi->ResetListHead,
            Element
            );

    }

    if (!IsListEmpty(&pwi->ResetListHead)) {

        TRACE(LVL_VERBOSE,("wodreset: reset list not empty"));

        ResetEvent(pwi->DriverEmpty);
        //
        //  add ref for this apc which will continue the processing
        //
        InterlockedIncrement(&pwi->BuffersInDriver);

        QueueUserAPC(
            ResetAsyncProcessingHandler,
            pwi->hThread,
            (ULONG_PTR)pwi
            );
    }

    LeaveCriticalSection(&pwi->csQueue);

    AlertedWait(pwi->DriverEmpty);


    wodStart(pwi);

    TRACE(LVL_VERBOSE,("wodreset: %d buffers in driver, outstanding %d ",pwi->BuffersInDriver, pwi->BuffersOutstanding));

    return MMSYSERR_NOERROR;
}


/*****************************************************************************
 *
 *  Function:   
 *
 *  Descr:      
 *
 *  Returns:    
 *
 *****************************************************************************/
MMRESULT wodClose
(
   PWODINSTANCE   pwi
)
{
    HANDLE      hDevice;
    ULONG       cbReturned;
    DWORD       WaveAction;

    pwi->Closing=TRUE;

    wodReset(pwi);

    EnterCriticalSection(&pwi->csQueue);

    if ((pwi->BuffersOutstanding == 0) && (pwi->Closing)) {
        //
        //  last buffer has been completed and the device is being closed, tell the thread
        //  to exit.
        //
        SetEvent(pwi->ThreadStopEvent);

    }

    LeaveCriticalSection(&pwi->csQueue);

    if (!IsListEmpty(
            &pwi->ListHead
            )) {

        return WAVERR_STILLPLAYING;
    }

    InterlockedExchange( (LPLONG)&pwi->fActive, FALSE );


    //
    //  thread will exit when the last buffer is processed
    //
    AlertedWait(pwi->ThreadStopEvent);

    WaveAction=pwi->Aborted ? WAVE_ACTION_ABORT_STREAMING : WAVE_ACTION_STOP_STREAMING;

    WaveAction |= (pwi->Handset ? WAVE_ACTION_USE_HANDSET : 0);

    SetVoiceMode(
        &pwi->Aipc,
        WaveAction
        );

    aipcDeinit(&pwi->Aipc);

    // free the allocated memory
    if (NULL != pwi->pvXformObject) {

        FREE_MEMORY(pwi->pvXformObject );
    }


    wodCallback( pwi, WOM_CLOSE, 0L );


    RemoveReference(pwi);

    return MMSYSERR_NOERROR;
}




/*****************************************************************************
 *
 *  Function:   wodMessage()
 *
 *  Descr:      Exported driver function (required).  Processes messages sent
 *              from WINMM.DLL to wave output device.
 *
 *  Returns:    
 *
 *****************************************************************************/
DWORD APIENTRY wodMessage
(
   DWORD     id,
   DWORD     msg,
   DWORD_PTR dwUser,
   DWORD_PTR dwParam1,
   DWORD     dwParam2
)
{
    switch (msg) 
    {
        case DRVM_INIT:
            TRACE(LVL_VERBOSE,("WODM_INIT"));
            return MMSYSERR_NOERROR;

        case WODM_GETNUMDEVS:
//            TRACE(LVL_VERBOSE,("WODM_GETNUMDEVS"));

            EnumerateModems(
                &DriverControl
                );

            return DriverControl.NumberOfDevices;
//            return 1;

        case WODM_GETDEVCAPS:
//            TRACE(LVL_VERBOSE,("WODM_GETDEVCAPS, device id==%d", id));
            return wodGetDevCaps( id, (LPBYTE) dwParam1, dwParam2 );

        case WODM_OPEN:
//            TRACE(LVL_VERBOSE,("WODM_OPEN, device id==%d", id));
            return wodOpen( id, (LPVOID *) dwUser,
                            (LPWAVEOPENDESC) dwParam1, dwParam2  );

        case WODM_CLOSE:
            TRACE(LVL_VERBOSE,("WODM_CLOSE, device id==%d", id));
            return wodClose( (PWODINSTANCE) dwUser );

        case WODM_WRITE:
            TRACE(LVL_BLAB,("WODM_WRITE, device id==%d", id));
            return wodWrite( (PWODINSTANCE) dwUser, (LPWAVEHDR) dwParam1 );

        case WODM_PAUSE:
            TRACE(LVL_VERBOSE,("WODM_PAUSE, device id==%d", id));
            return wodPause( (PWODINSTANCE) dwUser );

        case WODM_RESTART:
            TRACE(LVL_VERBOSE,("WODM_RESTART, device id==%d", id));
            return wodStart((PWODINSTANCE) dwUser);
//            return wodResume( (PWODINSTANCE) dwUser );

        case WODM_RESET:
            TRACE(LVL_VERBOSE,("WODM_RESET, device id==%d", id));
            return wodReset( (PWODINSTANCE) dwUser );

        case WODM_BREAKLOOP:
            TRACE(LVL_VERBOSE,("WODM_BREAKLOOP, device id==%d", id));
            return MMSYSERR_NOTSUPPORTED;

        case WODM_GETPOS:
//            TRACE(LVL_VERBOSE,("WODM_GETPOS, device id==%d", id));
            return wodGetPos( (PWODINSTANCE) dwUser,
                            (LPMMTIME) dwParam1, dwParam2 );

        case WODM_SETPITCH:
            TRACE(LVL_VERBOSE,("WODM_SETPITCH, device id==%d", id));
            return MMSYSERR_NOTSUPPORTED;

        case WODM_SETVOLUME:
            TRACE(LVL_VERBOSE,("WODM_SETVOLUME, device id==%d", id));
            return MMSYSERR_NOTSUPPORTED;

        case WODM_SETPLAYBACKRATE:
            TRACE(LVL_VERBOSE,("WODM_SETPLAYBACKRATE, device id==%d", id));
            return MMSYSERR_NOTSUPPORTED;

        case WODM_GETPITCH:
            TRACE(LVL_VERBOSE,("WODM_GETPITCH, device id==%d", id));
            return MMSYSERR_NOTSUPPORTED;

        case WODM_GETVOLUME:
            TRACE(LVL_VERBOSE,("WODM_GETVOLUME, device id==%d", id));
            return MMSYSERR_NOTSUPPORTED;

        case WODM_GETPLAYBACKRATE:
            TRACE(LVL_VERBOSE,("WODM_GETPLAYBACKRATE, device id==%d", id));
            return MMSYSERR_NOTSUPPORTED;
#if 1
        case WODM_PREPARE:
            return wodPrepare((PWODINSTANCE) dwUser, (LPWAVEHDR) dwParam1);

        case WODM_UNPREPARE:
            return wodUnprepare((LPWAVEHDR) dwParam1);
#endif

        default:
            return MMSYSERR_NOTSUPPORTED;
    }

    //
    // Should not get here
    //

    return MMSYSERR_NOTSUPPORTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\serwvdrv\drvproc.c ===
/*****************************************************************************
 *
 *  Microsoft Confidential
 *  Copyright (c) Microsoft Corporation 1996
 *  All rights reserved
 *
 *  File:       DRVPROC.C
 *
 *  Desc:
 *
 *  History:    BryanW
 *              HeatherA
 * 
 *****************************************************************************/

#include "internal.h"

#include <regstr.h>

#define INITGUID
#include <initguid.h>
#include <devguid.h>

#ifdef USE_SETUPAPI
#include <setupapi.h>
#endif

BOOL
IsThisDeviceEnabled(
    HKEY    DeviceKey
    );


HANDLE ghModule;
#if DBG
ULONG DebugLevel=0;
#endif

CONST TCHAR cszHWNode[]       = TEXT("SYSTEM\\CurrentControlSet\\Control\\Class\\{4D36E96D-E325-11CE-BFC1-08002BE10318}");

WAVEFORMATEX DefaultWaveFormat =
{
    WAVE_FORMAT_PCM,    // WORD  wFormatTag;
    1,                  // WORD  nChannels;
    8000L,              // DWORD nSamplesPerSec;
    16000L,             // DWORD nAvgBytesPerSec;
    2,                  // WORD  nBlockAlign;
    16,                 // WORD  wBitsPerSample;
    0                   // WORD  cbSize;
};


#define DOSDEVICEROOT TEXT("\\\\.\\")

LPGUID g_pguidModem     = (LPGUID)&GUID_DEVCLASS_MODEM;

DRIVER_CONTROL  DriverControl={0};




/*****************************************************************************
 *
 *  Function:   DriverProc()
 *
 *  Descr:      Exported driver function (required).  Processes messages sent
 *              from WINMM.DLL to wave driver.
 *
 *  Returns:    
 *
 *****************************************************************************/
LRESULT DriverProc
(
    DWORD   dwDriverID,
    HDRVR   hDriver,
    UINT    uiMessage,
    LPARAM  lParam1,
    LPARAM  lParam2
)
{
    LRESULT lr;

    PDEVICE_CONTROL    Current;
    PDEVICE_CONTROL    Next;
    DWORD              i;

    switch (uiMessage) 
    {
        case DRV_LOAD:
            ghModule = GetDriverModuleHandle(hDriver);

            ZeroMemory(&DriverControl,sizeof(DRIVER_CONTROL));

            DriverControl.NumberOfDevices=0;
#if 1
            EnumerateModems(
                &DriverControl
                );
#endif

            LoadString(
                ghModule,
                IDS_WAVEOUT_LINE,
                &DriverControl.WaveOutLine[0],
                sizeof(DriverControl.WaveOutLine)/sizeof(TCHAR)
                );

            LoadString(
                ghModule,
                IDS_WAVEIN_LINE,
                &DriverControl.WaveInLine[0],
                sizeof(DriverControl.WaveInLine)/sizeof(TCHAR)
                );

            LoadString(
                ghModule,
                IDS_WAVEOUT_HANDSET,
                &DriverControl.WaveOutHandset[0],
                sizeof(DriverControl.WaveOutHandset)/sizeof(TCHAR)
                );

            LoadString(
                ghModule,
                IDS_WAVEIN_HANDSET,
                &DriverControl.WaveInHandset[0],
                sizeof(DriverControl.WaveInHandset)/sizeof(TCHAR)
                );


            return (LRESULT)1L;

        case DRV_FREE:

            for (i=0; i< DriverControl.NumberOfDevices; i++) {

                Current=DriverControl.DeviceList[i];

                if (Current != NULL) {
                    //
                    //  if the low bit is set that means that this is a handset device. It uses
                    //  the same structure as the line device for the same modem. We will only free
                    //  the line device.
                    //
                    if ((((ULONG_PTR)Current) & 0x1) == 0) {
                        //
                        //  The is a line device, free it
                        //
#ifdef TRACK_MEM
                        FREE_MEMORY(Current->FriendlyName);
#else
                        LocalFree(Current->FriendlyName);
#endif

#ifdef TRACK_MEM
                        FREE_MEMORY(Current);
#else
                        LocalFree(Current);
#endif


                    }
                }
                DriverControl.DeviceList[i]=NULL;
            }

            DriverControl.NumberOfDevices=0;

            return (LRESULT)1L;

        case DRV_OPEN:
            return (LRESULT)1L;

        case DRV_CLOSE:
            return (LRESULT)1L;

        case DRV_ENABLE:
            return 1L;

        case DRV_DISABLE:
            return (LRESULT)1L;

        case DRV_QUERYCONFIGURE:
            return 0L;

        case DRV_CONFIGURE:
            return 0L;

        case DRV_INSTALL:
            return 1L;

        case DRV_REMOVE:
            return 1L;

        default:
            return DefDriverProc( dwDriverID, 
                                  hDriver,
                                  uiMessage,
                                  lParam1,
                                  lParam2 );
    }
}





LONG WINAPI
EnumerateModems(
    PDRIVER_CONTROL  DriverControl
    )
{
#ifdef USE_SETUPAPI
    HDEVINFO          hdevinfo;
    SP_DEVINFO_DATA   diData;
    DWORD dwDIGCF =  DIGCF_PRESENT;
#endif
    DWORD             iEnum;
    BOOL              fContinue;
    HKEY              hkey;
    DWORD dwRW = KEY_READ;


#ifndef USE_SETUPAPI

    HKEY              ModemKey;
    TCHAR              szEnumNode[80];
#endif

    if (DriverControl->Enumerated) {

        return 0;
    }

    DriverControl->Enumerated=TRUE;




#ifdef USE_SETUPAPI

    hdevinfo = SetupDiGetClassDevsW(
                              g_pguidModem,
                              NULL,
                              NULL,
                              dwDIGCF);


    if (hdevinfo != NULL) {
        //
        // Enumerate each modem
        //
        fContinue = TRUE;
        iEnum     = 0;
        diData.cbSize = sizeof(diData);

        while(fContinue && SetupDiEnumDeviceInfo(hdevinfo, iEnum, &diData)) {

            // Get the driver key
            //
            hkey = SetupDiOpenDevRegKey(hdevinfo, &diData, DICS_FLAG_GLOBAL, 0,
                                        DIREG_DRV, dwRW);

            if (hkey == INVALID_HANDLE_VALUE) {
#else

    if (RegOpenKey(HKEY_LOCAL_MACHINE, cszHWNode, &ModemKey) == ERROR_SUCCESS) {

        DWORD iEnum;

        // Enumerate the enumerator
        iEnum  = 0;
        while ((RegEnumKey(ModemKey, iEnum, szEnumNode,
                         sizeof(szEnumNode) / sizeof(TCHAR)) == ERROR_SUCCESS )) {

            // Open the modem node for this enumerator
            if (RegOpenKey(ModemKey, szEnumNode, &hkey) != ERROR_SUCCESS) {

#endif

                iEnum++;

                continue;

            } else {

                PDEVICE_CONTROL    Device;

                TCHAR    TempBuffer[256];
                DWORD    Type;
                DWORD    Length;
                LONG     lResult;
                DWORD    VoiceProfile=0;
                BOOL     Handset=TRUE;

                LPFNXFORM_GETINFO   lpfnGetInfo;

                LPTSTR      FriendlyName;
                //
                //  get the voice profile to see if it is a voice modem
                //
                Length=sizeof(VoiceProfile);

                lResult=RegQueryValueEx(
                    hkey,
                    TEXT("VoiceProfile"),
                    NULL,
                    &Type,
                    (LPBYTE)&VoiceProfile,
                    &Length
                    );

                Handset=(VoiceProfile & VOICEPROF_HANDSET);

                //
                //  mask the bit we care about, all these need to be set
                //
                VoiceProfile &= (VOICEPROF_CLASS8ENABLED |
                                 VOICEPROF_SERIAL_WAVE   |
                                 VOICEPROF_NT5_WAVE_COMPAT);

                if ((lResult != ERROR_SUCCESS)
                    ||
                    (VoiceProfile != (VOICEPROF_CLASS8ENABLED | VOICEPROF_SERIAL_WAVE | VOICEPROF_NT5_WAVE_COMPAT))
                    ||
                    (!IsThisDeviceEnabled(hkey))) {

                    //
                    //  no, next device
                    //
                    RegCloseKey(hkey);

                    iEnum++;

                    continue;
                }



                {
                    CONST TCHAR cszFriendlyName[] = TEXT("FriendlyName");


                    lstrcpy(TempBuffer,DOSDEVICEROOT);

                    Length=sizeof(TempBuffer)-((lstrlen(TempBuffer)+1)*sizeof(TCHAR));
                    //
                    //  read the friendly name from the registry
                    //
                    lResult=RegQueryValueEx(
                        hkey,
                        cszFriendlyName,
                        NULL,
                        &Type,
                        (LPBYTE)(TempBuffer+lstrlen(TempBuffer)),
                        &Length
                        );

                    if ((lResult != ERROR_SUCCESS)) {

                        RegCloseKey(hkey);

                        iEnum++;

                        continue;
                    }

                    lstrcat(TempBuffer,TEXT("\\Wave"));

#ifdef TRACK_MEM
                    FriendlyName=ALLOCATE_MEMORY((lstrlen(TempBuffer)+1)*sizeof(TCHAR));
#else
                    FriendlyName=LocalAlloc(LPTR,(lstrlen(TempBuffer)+1)*sizeof(TCHAR));
#endif
                    if (FriendlyName == NULL) {

                        RegCloseKey(hkey);

                        iEnum++;

                        continue;
                    }

                    lstrcpy(FriendlyName,TempBuffer);
                }



#ifdef TRACK_MEM
                Device=ALLOCATE_MEMORY(sizeof(DEVICE_CONTROL));
#else
                Device=LocalAlloc(LPTR,sizeof(DEVICE_CONTROL));
#endif
                if (Device != NULL) {

                    HKEY    WaveKey;

                    //
                    //  try to open the wavedriver key under the modem instance key
                    //
                    lResult=RegOpenKeyEx(
                        hkey,
                        TEXT("WaveDriver"),
                        0,
                        KEY_READ,
                        &WaveKey
                        );


                    if (lResult == ERROR_SUCCESS) {

                        Length=sizeof(Device->DeviceId);

                        lResult=RegQueryValueEx(
                            WaveKey,
                            TEXT("WaveInstance"),
                            NULL,
                            &Type,
                            (LPBYTE)&Device->DeviceId,
                            &Length
                            );



                        //
                        //  number of wavedevice
                        //
                        Length=sizeof(Device->WaveDevices);

                        lResult=RegQueryValueEx(
                            WaveKey,
                            TEXT("WaveDevices"),
                            NULL,
                            &Type,
                            (LPBYTE)&Device->WaveDevices,
                            &Length
                            );


                        if ((lResult != ERROR_SUCCESS)) {
                            //
                            //  default to this one
                            //
                            Device->WaveDevices=2;

                        }


                        if (Device->WaveDevices < 1 || Device->WaveDevices > 2) {

                            Device->WaveDevices=1;
                        }


                        //
                        //  check which xform should be used
                        //
                        Length=sizeof(Device->TransformId);

                        lResult=RegQueryValueEx(
                            WaveKey,
                            TEXT("XformId"),
                            NULL,
                            &Type,
                            (LPBYTE)&Device->TransformId,
                            &Length
                            );


                        if ((lResult != ERROR_SUCCESS)) {
                            //
                            //  default to this one
                            //
                            Device->TransformId=7;

                        }





                        //
                        //  get input gain value
                        //
                        Length=sizeof(Device->InputGain);

                        lResult=RegQueryValueEx(
                            WaveKey,
                            TEXT("XformInput"),
                            NULL,
                            &Type,
                            (LPBYTE)&Device->InputGain,
                            &Length
                            );


                        if ((lResult != ERROR_SUCCESS)) {
                            //
                            //  default to this one
                            //
                            Device->InputGain=0x0000;

                        }

                        //
                        //  get output gain value
                        //
                        Length=sizeof(Device->OutputGain);

                        lResult=RegQueryValueEx(
                            WaveKey,
                            TEXT("XformOutput"),
                            NULL,
                            &Type,
                            (LPBYTE)&Device->OutputGain,
                            &Length
                            );


                        if ((lResult != ERROR_SUCCESS)) {
                            //
                            //  default to this one
                            //
                            Device->OutputGain=0x0000;

                        }



                        //
                        //  check which if the modem support a different format
                        //

                        CopyMemory(
                            &Device->WaveFormat,
                            &DefaultWaveFormat,
                            sizeof(Device->WaveFormat)
                            );

                        Length=sizeof(Device->WaveFormat);

                        lResult=RegQueryValueEx(
                            WaveKey,
                            TEXT("WaveFormatEx"),
                            NULL,
                            &Type,
                            (LPBYTE)&Device->WaveFormat,
                            &Length
                            );


                        if ((lResult != ERROR_SUCCESS)) {
                            //
                            //  default to this one
                            //
                            CopyMemory(
                                &Device->WaveFormat,
                                &DefaultWaveFormat,
                                sizeof(Device->WaveFormat)
                                );

                        }


                        //
                        //  find out the name of the xform dll
                        //
                        Length=sizeof(TempBuffer);

                        lResult=RegQueryValueEx(
                            WaveKey,
                            TEXT("XformModule"),
                            NULL,
                            &Type,
                            (LPBYTE)TempBuffer,
                            &Length
                            );

                        if ((lResult != ERROR_SUCCESS)) {
                            //
                            //  default to the only one around
                            //
                            lstrcpy(TempBuffer,TEXT("umdmxfrm.dll"));
                        }

                        RegCloseKey(WaveKey);

                    } else {
                        //
                        //  no wave driver key, use these defaults
                        //
                        Device->TransformId=7;

                        lstrcpy(TempBuffer,TEXT("umdmxfrm.dll"));
                    }

                    //
                    //  load the dll
                    //
                    Device->TransformDll=LoadLibrary(TempBuffer);

                    if (Device->TransformDll == NULL) {
                        //
                        //  have to have a dll
                        //
                        RegCloseKey(hkey);

                        LocalFree(FriendlyName);
#ifdef TRACK_MEM
                        FREE_MEMORY(Device);
                        FREE_MEMORY(FriendlyName);
#else
                        LocalFree(Device);
                        LocalFree(FriendlyName);
#endif
                        iEnum++;

                        continue;
                    }


                    //
                    //  get the entry point for the dll
                    //
                    lpfnGetInfo=(LPFNXFORM_GETINFO)GetProcAddress(
                        Device->TransformDll,
                        "GetXformInfo"
                        );

                    if (lpfnGetInfo == NULL) {

                        FreeLibrary(Device->TransformDll);

                        RegCloseKey(hkey);
#ifdef TRACK_MEM
                        FREE_MEMORY(Device);
                        FREE_MEMORY(FriendlyName);
#else
                        LocalFree(Device);
                        LocalFree(FriendlyName);
#endif

                        iEnum++;

                        continue;
                    }

                    //
                    //  get the transform info
                    //
                    lResult=(*lpfnGetInfo)(
                        Device->TransformId,
                        &Device->WaveInXFormInfo,
                        &Device->WaveOutXFormInfo
                        );

                    if (lResult != 0) {

                        FreeLibrary(Device->TransformDll);

                        RegCloseKey(hkey);
#ifdef TRACK_MEM
                        FREE_MEMORY(Device);
                        FREE_MEMORY(FriendlyName);
#else
                        LocalFree(Device);
                        LocalFree(FriendlyName);
#endif
                        iEnum++;

                        continue;
                    }

                    Device->FriendlyName=FriendlyName;

                    RegCloseKey(hkey);


                    DriverControl->DeviceList[DriverControl->NumberOfDevices]=Device;

                    DriverControl->NumberOfDevices++;

#define HANDSET_SUPPORT 1
#ifdef HANDSET_SUPPORT
                    if ((Device->WaveDevices == 2) && Handset) {

                        DriverControl->DeviceList[DriverControl->NumberOfDevices]=(PDEVICE_CONTROL)((ULONG_PTR)Device | 1);

                        DriverControl->NumberOfDevices++;
                    }
#endif

                } else {
                    //
                    //  failed to allocate device block
                    //

                    RegCloseKey(hkey);
#ifdef TRACK_MEM
                    FREE_MEMORY(FriendlyName);
#else
                    LocalFree(FriendlyName);
#endif
                    iEnum++;

                    continue;


                }

            }

            // Find next modem
            //
            iEnum++;
        }
#ifdef USE_SETUPAPI

        SetupDiDestroyDeviceInfoList(hdevinfo);
#else

        RegCloseKey(ModemKey);

#endif
    }


    return ERROR_SUCCESS;

}



BOOL
IsThisDeviceEnabled(
    HKEY    DeviceKey
    )

{

    HKEY    WaveKey;
    BOOL    bResult=TRUE;
    LONG    lResult;

    //
    //  try to open the wavedriver key under the modem instance key
    //
    lResult=RegOpenKeyEx(
        DeviceKey,
        TEXT("WaveDriver"),
        0,
        KEY_READ,
        &WaveKey
        );

    if (lResult == ERROR_SUCCESS) {

        HKEY    EnumeratedKey;

        lResult=RegOpenKeyEx(
            WaveKey,
            TEXT("Enumerated"),
            0,
            KEY_READ,
            &EnumeratedKey
            );

        if (lResult == ERROR_SUCCESS) {

            DWORD    Started;
            DWORD    Length;
            DWORD    Type;

            Length=sizeof(Started);

            lResult=RegQueryValueEx(
                EnumeratedKey,
                TEXT("Started"),
                NULL,
                &Type,
                (LPBYTE)&Started,
                &Length
                );

            if (lResult == ERROR_SUCCESS) {

                bResult=(Started != 0);
            }

            RegCloseKey(EnumeratedKey);
        }

        RegCloseKey(WaveKey);
    }

    return bResult;
}


PDEVICE_CONTROL WINAPI
GetDeviceFromId(
    PDRIVER_CONTROL   DriverControl,
    DWORD             Id,
    PBOOL             Handset
    )

{

    PDEVICE_CONTROL   Device=DriverControl->DeviceList[Id];

    *Handset=(BOOL)((ULONG_PTR)Device) & 1;

    Device = (PDEVICE_CONTROL)((ULONG_PTR)Device & (~1));


    return Device;

}



BOOL APIENTRY
DllMain(
    HANDLE hDll,
    DWORD dwReason,
    LPVOID lpReserved
    )
{

    switch(dwReason) {

        case DLL_PROCESS_ATTACH:

#if DBG

            {
                CONST static TCHAR  UnimodemRegPath[]=REGSTR_PATH_SETUP TEXT("\\Unimodem");
                LONG    lResult;
                HKEY    hKey;
                DWORD   Type;
                DWORD   Size;

                lResult=RegOpenKeyEx(
		    HKEY_LOCAL_MACHINE,
		    UnimodemRegPath,
		    0,
		    KEY_READ,
		    &hKey
		    );


                if (lResult == ERROR_SUCCESS) {

                    Size = sizeof(DebugLevel);

                    RegQueryValueEx(
                        hKey,
                        TEXT("WaveDebugLevel"),
                        NULL,
                        &Type,
                        (LPBYTE)&DebugLevel,
                        &Size
                        );

                    RegCloseKey(hKey);
                }
            }

#endif
            DEBUG_MEMORY_PROCESS_ATTACH("SERWVDRV");

            DisableThreadLibraryCalls(hDll);

            break;

        case DLL_PROCESS_DETACH:

            DEBUG_MEMORY_PROCESS_DETACH();

            break;

        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:

        default:
              break;

    }

    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\sys\inc\modemp.h ===
/*++

Copyright (c) 1996 Microsoft Corporation.

Module Name:

    modemp.h

Abstract:

    Internal header file for modem driver components

--*/



#ifndef _MODEMP
#define _MODEMP 1

#define READ_CONFIG_PERMANENT_GUID  0
#define READ_CONFIG_NAME_SIZE       1
#define READ_CONFIG_DEVICE_NAME     2
#define READ_CONFIG_DUPLEX_SUPPORT  3

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\sys\modem\getput.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    ioctl.c

Abstract:

    This module contains the code that is very specific to the io control
    operations in the modem driver

Author:

    Brian Lieuallen  7/19/98

Environment:

    Kernel mode

Revision History :

--*/

#include "precomp.h"


PIRP
GetUsableIrp(
    PLIST_ENTRY   List
    );


VOID
HandleIpc(
    PDEVICE_EXTENSION DeviceExtension
    );

#pragma alloc_text(PAGEUMDM,HandleIpc)
#pragma alloc_text(PAGEUMDM,QueueMessageIrp)
#pragma alloc_text(PAGEUMDM,QueueLoopbackMessageIrp)
#pragma alloc_text(PAGEUMDM,GetUsableIrp)
#pragma alloc_text(PAGEUMDM,GetPutCancelRoutine)
#pragma alloc_text(PAGEUMDM,EmptyIpcQueue)


VOID
QueueLoopbackMessageIrp(
    PDEVICE_EXTENSION   Extension,
    PIRP                Irp
    )

{

    KIRQL              CancelIrql;
    KIRQL              origIrql;
    PLIST_ENTRY        ListToUse;
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);
    UINT               OwnerClient=(UINT)((ULONG_PTR)irpSp->FileObject->FsContext);

    IoMarkIrpPending(Irp);

    Irp->IoStatus.Status = STATUS_PENDING;

    //
    //  pick the right list to use
    //
    ListToUse= &Extension->IpcControl[OwnerClient ? 0 : 1].PutList;

    KeAcquireSpinLock(
        &Extension->DeviceLock,
        &origIrql
        );

    InsertTailList(
        ListToUse,
        &Irp->Tail.Overlay.ListEntry
        );

    IoAcquireCancelSpinLock(&CancelIrql);

    IoSetCancelRoutine(
        Irp,
        GetPutCancelRoutine
        );

    IoReleaseCancelSpinLock(CancelIrql);

    KeReleaseSpinLock(
        &Extension->DeviceLock,
        origIrql
        );

    HandleIpc(
        Extension
        );

    return;
}



VOID
QueueMessageIrp(
    PDEVICE_EXTENSION   Extension,
    PIRP                Irp
    )

{

    KIRQL              CancelIrql;
    KIRQL              origIrql;
    PLIST_ENTRY        ListToUse;
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);
    UINT               OwnerClient=(UINT)((ULONG_PTR)irpSp->FileObject->FsContext);

    IoMarkIrpPending(Irp);

    Irp->IoStatus.Status = STATUS_PENDING;

    //
    //  pick the right list to use
    //
    ListToUse=irpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_MODEM_GET_MESSAGE ?
                  &Extension->IpcControl[OwnerClient].GetList : &Extension->IpcControl[OwnerClient].PutList;

    KeAcquireSpinLock(
        &Extension->DeviceLock,
        &origIrql
        );

    InsertTailList(
        ListToUse,
        &Irp->Tail.Overlay.ListEntry
        );

    IoAcquireCancelSpinLock(&CancelIrql);

    IoSetCancelRoutine(
        Irp,
        GetPutCancelRoutine
        );

    IoReleaseCancelSpinLock(CancelIrql);

    KeReleaseSpinLock(
        &Extension->DeviceLock,
        origIrql
        );

    HandleIpc(
        Extension
        );

    return;
}



PIRP
GetUsableIrp(
    PLIST_ENTRY   List
    )

{

    PLIST_ENTRY   ListElement;
    PIRP          Irp;

    while (!IsListEmpty(List)) {
        //
        //  irp in list
        //
        ListElement=RemoveTailList(
            List
            );

        Irp=CONTAINING_RECORD(ListElement,IRP,Tail.Overlay.ListEntry);

        if (Irp->Cancel) {
            //
            //  canceled, cancel reoutine will complete
            //
            Irp->IoStatus.Status = STATUS_CANCELLED;

            Irp=NULL;

        } else {
            //
            //  good irp
            //
            return Irp;
        }
    }

    return NULL;

}



VOID
HandleIpc(
    PDEVICE_EXTENSION DeviceExtension
    )

{

    KIRQL      origIrql;
    KIRQL      CancelIrql;
    UINT       Source;
    UINT       Sink;


    KeAcquireSpinLock(
        &DeviceExtension->DeviceLock,
        &origIrql
        );

    Source=0;
    Sink=1;

    while (Source < 2) {

        PIRP          GetIrp;
        PIRP          PutIrp;

        UINT          BytesToCopy;

        IoAcquireCancelSpinLock(&CancelIrql);

        //
        //  see if we can get a usable irp
        //
        GetIrp=GetUsableIrp(
            &DeviceExtension->IpcControl[Sink].GetList
            );

        if (GetIrp != NULL) {

            PutIrp=GetUsableIrp(
                &DeviceExtension->IpcControl[Source].PutList
                );

            if (PutIrp != NULL) {
                //
                //  got two irp's, let do it
                //
                IoSetCancelRoutine(GetIrp,NULL);
                IoSetCancelRoutine(PutIrp,NULL);

                IoReleaseCancelSpinLock(CancelIrql);

                KeReleaseSpinLock(
                    &DeviceExtension->DeviceLock,
                    origIrql
                    );


                BytesToCopy=IoGetCurrentIrpStackLocation(PutIrp)->Parameters.DeviceIoControl.InputBufferLength
                                 < IoGetCurrentIrpStackLocation(GetIrp)->Parameters.DeviceIoControl.OutputBufferLength
                                 ? IoGetCurrentIrpStackLocation(PutIrp)->Parameters.DeviceIoControl.InputBufferLength
                                 : IoGetCurrentIrpStackLocation(GetIrp)->Parameters.DeviceIoControl.OutputBufferLength;

                RtlCopyMemory(
                    GetIrp->AssociatedIrp.SystemBuffer,
                    PutIrp->AssociatedIrp.SystemBuffer,
                    BytesToCopy
                    );



                GetIrp->IoStatus.Information=BytesToCopy;

                RemoveReferenceAndCompleteRequest(
                    DeviceExtension->DeviceObject,
                    GetIrp,
                    STATUS_SUCCESS
                    );
#if DBG
                GetIrp=NULL;
#endif


                if (IoGetCurrentIrpStackLocation(PutIrp)->Parameters.DeviceIoControl.IoControlCode == IOCTL_MODEM_SEND_GET_MESSAGE) {
                    //
                    //  Send, get combo irp, put it on the get queue to get the response from
                    //  the other side
                    //

                    KeAcquireSpinLock(
                        &DeviceExtension->DeviceLock,
                        &origIrql
                        );

                    PutIrp->IoStatus.Status=STATUS_PENDING;

                    InsertTailList(
                        &DeviceExtension->IpcControl[Source].GetList,
                        &PutIrp->Tail.Overlay.ListEntry
                        );

                    IoAcquireCancelSpinLock(&CancelIrql);

                    IoSetCancelRoutine(
                        PutIrp,
                        GetPutCancelRoutine
                        );

                    IoReleaseCancelSpinLock(CancelIrql);

                    KeReleaseSpinLock(
                        &DeviceExtension->DeviceLock,
                        origIrql
                        );

                    HandleIpc(DeviceExtension);


                } else {
                    //
                    //  normal put irp, just complete
                    //

                    PutIrp->IoStatus.Information=0;

                    RemoveReferenceAndCompleteRequest(
                        DeviceExtension->DeviceObject,
                        PutIrp,
                        STATUS_SUCCESS
                        );
                }

#if DBG
                PutIrp=NULL;
#endif


                KeAcquireSpinLock(
                    &DeviceExtension->DeviceLock,
                    &origIrql
                    );


            } else {
                //
                //  put the get irp back
                //
                InsertHeadList(
                    &DeviceExtension->IpcControl[Sink].GetList,
                    &GetIrp->Tail.Overlay.ListEntry
                    );

                IoReleaseCancelSpinLock(CancelIrql);

            }

        } else {
            //
            //  no get irp
            //
            IoReleaseCancelSpinLock(CancelIrql);
        }

        Source++;
        Sink--;
    }

    KeReleaseSpinLock(
        &DeviceExtension->DeviceLock,
        origIrql
        );


    return;
}






VOID
GetPutCancelRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject - The device object of the modem.

    Irp - This is the irp to cancel.

Return Value:

    None.

--*/

{

    PDEVICE_EXTENSION DeviceExtension = DeviceObject->DeviceExtension;
    KIRQL origIrql;

    IoReleaseCancelSpinLock(
        Irp->CancelIrql
        );


    KeAcquireSpinLock(
        &DeviceExtension->DeviceLock,
        &origIrql
        );

    if (Irp->IoStatus.Status == STATUS_PENDING) {
        //
        //  irp is still in queue
        //
        RemoveEntryList(&Irp->Tail.Overlay.ListEntry);

    }

    KeReleaseSpinLock(
        &DeviceExtension->DeviceLock,
        origIrql
        );

    Irp->IoStatus.Information=0;

    RemoveReferenceAndCompleteRequest(
        DeviceObject,
        Irp,
        STATUS_CANCELLED
        );


    return;



}





VOID
EmptyIpcQueue(
    PDEVICE_EXTENSION    DeviceExtension,
    PLIST_ENTRY          List
    )

{
    KIRQL         origIrql;
    KIRQL         CancelIrql;
    PIRP          Irp;

    KeAcquireSpinLock(
        &DeviceExtension->DeviceLock,
        &origIrql
        );

    IoAcquireCancelSpinLock(&CancelIrql);

    Irp=GetUsableIrp(
        List
        );

    while (Irp != NULL) {

        IoSetCancelRoutine(Irp,NULL);

        IoReleaseCancelSpinLock(CancelIrql);

        KeReleaseSpinLock(
            &DeviceExtension->DeviceLock,
            origIrql
            );

        Irp->IoStatus.Information = 0ul;

        RemoveReferenceAndCompleteRequest(
            DeviceExtension->DeviceObject,
            Irp,
            STATUS_CANCELLED
            );

        KeAcquireSpinLock(
            &DeviceExtension->DeviceLock,
            &origIrql
            );

        IoAcquireCancelSpinLock(&CancelIrql);


        Irp=GetUsableIrp(
            List
            );
    }

    IoReleaseCancelSpinLock(CancelIrql);

    KeReleaseSpinLock(
        &DeviceExtension->DeviceLock,
        origIrql
        );


    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\sys\modem\mask.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    mask.c

Abstract:

    This module contains the code that is very specific to open
    and close operations in the modem driver

Author:

    Anthony V. Ercolano 13-Aug-1995

Environment:

    Kernel mode

Revision History :

--*/

#include "precomp.h"


#pragma alloc_text(PAGEUMDM,UniMaskStarter)
#pragma alloc_text(PAGEUMDM,UniGeneralWaitComplete)
#pragma alloc_text(PAGEUMDM,UniGeneralMaskComplete)
#pragma alloc_text(PAGEUMDM,UniRundownShuttledWait)
#pragma alloc_text(PAGEUMDM,UniCancelShuttledWait)
#pragma alloc_text(PAGEUMDM,UniChangeShuttledToPassDown)
#pragma alloc_text(PAGEUMDM,UniMakeIrpShuttledWait)



VOID _inline
UNI_SAVE_OLD_SETMASK(
    PIRP    Irp
    )
{
   PIO_STACK_LOCATION  irpSp=IoGetCurrentIrpStackLocation(Irp);

   irpSp->Parameters.DeviceIoControl.OutputBufferLength=*((PULONG)Irp->AssociatedIrp.SystemBuffer);
#if DBG
   irpSp->Parameters.Others.Argument4=(PVOID)0x3;
#endif
   return;

}

VOID _inline
UNI_RESTORE_OLD_SETMASK(
   PIRP    Irp
   )
{

   PIO_STACK_LOCATION  irpSp=IoGetCurrentIrpStackLocation(Irp);

   *((PULONG)Irp->AssociatedIrp.SystemBuffer)=irpSp->Parameters.DeviceIoControl.OutputBufferLength;
   irpSp->Parameters.DeviceIoControl.OutputBufferLength=0;

#if DBG
   irpSp->Parameters.Others.Argument4=0;
#endif

   return;
}


NTSTATUS
UniMaskStarter(
    IN PDEVICE_EXTENSION Extension
    )

/*++

Routine Description:

    Deal with managing initiating mask operations.

Arguments:

    Extension - The modem device extension.

Return Value:

    The function value is the final status of the call

--*/

{

    PIRP newIrp=NULL;

    do {

        PIO_STACK_LOCATION irpSp  = IoGetCurrentIrpStackLocation(Extension->CurrentMaskOp);

        PULONG origMask = (PULONG)Extension->CurrentMaskOp->AssociatedIrp.SystemBuffer;

        KIRQL origIrql;

        int ownerHandle = irpSp->FileObject->FsContext?CONTROL_HANDLE:CLIENT_HANDLE;
        PMASKSTATE thisMaskState = &Extension->MaskStates[ownerHandle];
        PMASKSTATE otherMaskState = thisMaskState->OtherState;

        if (irpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_SERIAL_SET_WAIT_MASK) {
            //
            // First make sure that the mask operation we have is well
            // formed.  (The params are ok.)
            //

            if (irpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(ULONG)) {

                Extension->CurrentMaskOp->IoStatus.Status = STATUS_BUFFER_TOO_SMALL;

                Extension->CurrentMaskOp->IoStatus.Information = 0L;

                UniGetNextIrp(
                    Extension->DeviceObject,
                    &Extension->DeviceLock,
                    &Extension->CurrentMaskOp,
                    &Extension->MaskOps,
                    &newIrp,
                    TRUE
                    );
                continue;

            }

            //
            // Copy our location information so that the lower
            // level serial driver performs the mask op.
            //

            IoCopyCurrentIrpStackLocationToNext(Extension->CurrentMaskOp);

            //
            // Setup so that upon the lower level serial drivers completion
            // we decrement the reference counts and such.
            //

            IoSetCompletionRoutine(
                Extension->CurrentMaskOp,
                UniGeneralMaskComplete,
                thisMaskState,
                TRUE,
                TRUE,
                TRUE
                );

            //
            // Save off the actual value of our mask data into
            // argument three of our own stack location.  We know
            // that we don't use that memory for anything.  We
            // recover it later so that we always know what events
            // this handle is interested in.
            //

            UNI_SAVE_OLD_SETMASK(Extension->CurrentMaskOp);

            //
            // Set it up so that lower level serial driver has the
            // client, owner, and DCD (if necessary bits) events.
            //

            KeAcquireSpinLock(
                &Extension->DeviceLock,
                &origIrql
                );

            *origMask |= (otherMaskState->Mask |
                         ((Extension->PassThrough == MODEM_DCDSNIFF)?
                          (SERIAL_EV_RLSD | SERIAL_EV_DSR):
                          (0)
                         ));

            //
            // Increment another reference count that counts
            // the number of setmasks have been sent down to the
            // lower serial drivr.  These will be decremented when
            // the setmask operation completes.
            //

            thisMaskState->SentDownSetMasks++;

            //
            // Check to see if we have a shuttled aside wait mask
            // for ourselves (client or owner).  If so, complete it
            // before we go on with processing the actual setmask.
            //

            if (thisMaskState->ShuttledWait) {

                PIRP savedIrp = thisMaskState->ShuttledWait;

                thisMaskState->ShuttledWait = NULL;

                UniRundownShuttledWait(
                    Extension,
                    &thisMaskState->ShuttledWait,
                    UNI_REFERENCE_NORMAL_PATH,
                    savedIrp,
                    origIrql,
                    STATUS_SUCCESS,
                    0ul
                    );

            } else {

                //
                // If we don't have a shuttled wait, we might
                // have a passed down wait.  If we do then
                // mark it to complete.
                //

                if (thisMaskState->PassedDownWait) {
                    //
                    //  set the passdown irp, so that it will be complete by the completion
                    //  handler
                    //
                    SetPassdownToComplete(thisMaskState);

                }

                KeReleaseSpinLock(
                    &Extension->DeviceLock,
                    origIrql
                    );

            }

            //
            // Off to the lower serial driver.
            //

            IoCallDriver(
                Extension->AttachedDeviceObject,
                Extension->CurrentMaskOp
                );

            UniGetNextIrp(
                Extension->DeviceObject,
                &Extension->DeviceLock,
                &Extension->CurrentMaskOp,
                &Extension->MaskOps,
                &newIrp,
                FALSE
                );
            continue;

        } else {

            //
            // It wasn't a setmask.  So it must be a wait.
            //
            // Verify that it is well formed.  We really should
            // do this here because it may never make it down
            // to the lower level serial driver.
            //

            if (irpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(ULONG)) {

                Extension->CurrentMaskOp->IoStatus.Status = STATUS_BUFFER_TOO_SMALL;

                Extension->CurrentMaskOp->IoStatus.Information = 0L;

                UniGetNextIrp(
                    Extension->DeviceObject,
                    &Extension->DeviceLock,
                    &Extension->CurrentMaskOp,
                    &Extension->MaskOps,
                    &newIrp,
                    TRUE
                    );

                continue;

            }

            //
            // Make sure that we aren't trying to start a wait
            // when the setmask for this handle is zero.  Note
            // that if this is the owner handle, we need to
            // or in the dcd value if dcd sniffing is on.
            //


            if ( (ownerHandle
                  &&
                 ((thisMaskState->Mask == 0)
                  &&
                 (Extension->PassThrough != MODEM_DCDSNIFF)))
                ||
                (!ownerHandle && (thisMaskState->Mask == 0))) {

                Extension->CurrentMaskOp->IoStatus.Status = STATUS_INVALID_PARAMETER;

                Extension->CurrentMaskOp->IoStatus.Information = 0L;

                UniGetNextIrp(
                    Extension->DeviceObject,
                    &Extension->DeviceLock,
                    &Extension->CurrentMaskOp,
                    &Extension->MaskOps,
                    &newIrp,
                    TRUE
                    );
                continue;

            }

            //
            // If there is already a wait around for this handle
            // (either shuttled or actually down waiting) then
            // this wait fails.
            //
            // At this point we need to take out the lock to
            // prevent anything from moving on.
            //

            KeAcquireSpinLock(
                &Extension->DeviceLock,
                &origIrql
                );

            if ((thisMaskState->ShuttledWait) || (thisMaskState->PassedDownWait != NULL)) {

                D_ERROR(DbgPrint("Shuttled = %08lx, passeddown=%08lx\n",thisMaskState->ShuttledWait,thisMaskState->PassedDownWait);)

                KeReleaseSpinLock(
                    &Extension->DeviceLock,
                    origIrql
                    );

                Extension->CurrentMaskOp->IoStatus.Status = STATUS_INVALID_PARAMETER;

                Extension->CurrentMaskOp->IoStatus.Information = 0L;

                UniGetNextIrp(
                    Extension->DeviceObject,
                    &Extension->DeviceLock,
                    &Extension->CurrentMaskOp,
                    &Extension->MaskOps,
                    &newIrp,
                    TRUE
                    );
                continue;

            }



            //
            // See if this wait can be satisfied with the last set of
            // events that we saw.
            //

            if (thisMaskState->HistoryMask) {


                PULONG maskValue = Extension->CurrentMaskOp->AssociatedIrp.SystemBuffer;

                //
                // A non-zero history mask implies we have something
                // that will statisfy this wait.
                //

//                D_TRACE(DbgPrint("Modem: Complete wait because of history %08lx\n",thisMaskState->HistoryMask);)

                Extension->CurrentMaskOp->IoStatus.Status = STATUS_SUCCESS;
                Extension->CurrentMaskOp->IoStatus.Information =sizeof(ULONG);

                *maskValue = thisMaskState->HistoryMask;

                thisMaskState->HistoryMask = 0UL;



                KeReleaseSpinLock(
                    &Extension->DeviceLock,
                    origIrql
                    );

                UniGetNextIrp(
                    Extension->DeviceObject,
                    &Extension->DeviceLock,
                    &Extension->CurrentMaskOp,
                    &Extension->MaskOps,
                    &newIrp,
                    TRUE
                    );
                continue;

            }

            //
            // If the reference counts for our handle (client or
            // owner) indicate more setmasks, then complete it
            // right away since it won't get very far any way.
            //

            if (thisMaskState->SentDownSetMasks < thisMaskState->SetMaskCount) {

                PULONG maskValue = Extension->CurrentMaskOp->AssociatedIrp.SystemBuffer;

                Extension->CurrentMaskOp->IoStatus.Status = STATUS_SUCCESS;
                Extension->CurrentMaskOp->IoStatus.Information = sizeof(ULONG);

                *maskValue = 0UL;

                KeReleaseSpinLock(
                    &Extension->DeviceLock,
                    origIrql
                    );

                UniGetNextIrp(
                    Extension->DeviceObject,
                    &Extension->DeviceLock,
                    &Extension->CurrentMaskOp,
                    &Extension->MaskOps,
                    &newIrp,
                    TRUE
                    );
                continue;

            }

            //
            // If the complementry handle already has a wait pending
            // (or because of DCD sniffing)
            // then shuttle this wait off to the side.
            //

            if ((otherMaskState->PassedDownWait != NULL) || (Extension->PassThrough == MODEM_DCDSNIFF)) {

                UniMakeIrpShuttledWait(
                    thisMaskState,
                    Extension->CurrentMaskOp,
                    origIrql,
                    TRUE,
                    &newIrp
                    );

                continue;

            }


            MakeIrpCurrentPassedDown(
                thisMaskState,
                Extension->CurrentMaskOp
                );


            KeReleaseSpinLock(
                &Extension->DeviceLock,
                origIrql
                );


            //
            // There was no other wait pendings so send this one down.
            //
            // We want to set the completion routine so that we
            // can shuttle it aside if is pushed out by DCD sniff
            // or a setmask from the other handle.
            //

            IoCopyCurrentIrpStackLocationToNext(Extension->CurrentMaskOp);


            //
            // Setup so that upon the lower level serial drivers completion
            // we decrement the reference count and such.
            //

            IoSetCompletionRoutine(
                Extension->CurrentMaskOp,
                UniGeneralWaitComplete,
                thisMaskState,
                TRUE,
                TRUE,
                TRUE
                );


            IoCallDriver(
                Extension->AttachedDeviceObject,
                Extension->CurrentMaskOp
                );

            UniGetNextIrp(
                Extension->DeviceObject,
                &Extension->DeviceLock,
                &Extension->CurrentMaskOp,
                &Extension->MaskOps,
                &newIrp,
                FALSE
                );
            continue;

        }

    } while (newIrp != NULL);

    return STATUS_PENDING;

}

NTSTATUS
UniGeneralWaitComplete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    Deal with finishing off the wait function

Arguments:

    DeviceObject - Pointer to the device object for the modem

    Irp - The irp being completed.

    Context - Points to the mask state for the client or control handle

Return Value:

    The function value is the final status of the call

--*/

{

    //
    // This completion routine is invoked when a wait function was
    // actually down in a lower level serial driver and for one
    // reason or another has been completed.
    //
    // A wait will be completed by the lower level serial driver
    // for 3 reasons:
    //
    // 1) The wait reason was actually satisfied.
    //
    // 2) The irp was cancelled.
    //
    // 3) A setmask came in.
    //
    // How do we deal with "1"?
    //
    // We can tell we have reason 1 if the status is successful
    // and the mask value is non-zero.
    //
    //    We have subcases here:
    //
    //    a) The irp did complete however the reason is because
    //       of the complementry mask operation.  In this case
    //       we want to deal with the complementary mask state
    //       and resubmit ourselves down to the lower serial driver.
    //
    //    b) The operations is actually satisfied.  We need to complete
    //       the operation, however we also need to determine if
    //       the complementary state needs to be dealt with.  This
    //       could mean completing a shuttled wait or recording
    //       the current events in its history mask.
    //
    //    Somewhat of a subcase (we'll call it 1c) is if a dcd sniff
    //    sneaked in on us.  This could cause a completion with a bad
    //    status.  However, in this case we simply shuttle aside the wait.
    //
    // How do we deal with "2"?
    //
    // We can tell we have reason 2 because the status in the
    // irp will be cancelled.  We will let the irp continue
    // on to completion.  HOWEVER, we also need to see if the
    // other handle had an irp that was shuttled aside.  If the
    // other irp was shuttled aside, we should cause that irp to
    // be sent down to the lower serial driver.
    //
    // How do we deal with "3"?
    //
    // We know we have reason 3 when we have a successful status
    // but the mask is zero.  There are 3 different ways that
    // a setmask can come in.
    //
    //     a) A setmask from our own handle.
    //
    //     b) A setmask from the modem driver in response to
    //        dcd sniff request.
    //
    //     c) A setmask from the other handle.
    //
    //     What is key to what we are going to do here is that
    //     while the IRP may have completed for ANY of "a", "b"
    //     or "c" here, ALL we care about is whether our own handle
    //     did the setmask.  If our handle DIDN'T do a setmask while
    //     this irp was passed down, then all we want to do is shuttle
    //     the irp aside.
    //
    //     What we've done is to mark any passed down irp from our
    //     handle when we do a setmask.  When we get to here, if it's
    //     marked, complete it.  If it's not marked, shuttle it aside.
    //
    //     Note that the actions for 3 are the same as for "1a"
    //

    ULONG maskValue = *((PULONG)Irp->AssociatedIrp.SystemBuffer);
    PMASKSTATE thisState = Context;
    PMASKSTATE otherState = thisState->OtherState;
    KIRQL origIrql;


    KeAcquireSpinLock(
        &otherState->Extension->DeviceLock,
        &origIrql
        );


    if (UNI_SHOULD_PASSDOWN_COMPLETE(Irp)) {
        //
        //  this passed down irp should complete
        //
        KeReleaseSpinLock(
            &otherState->Extension->DeviceLock,
            origIrql
            );

        //
        // While we may have bumped into a dcd setting
        // it's probably nicer if we just say we got
        // killed by the setmask.  We already adjusted
        // the status above so just make sure that
        // the system buffer is zero.  We return
        // STATUS_SUCCESS now so that the iosubsystem
        // will complete this request.
        //

        Irp->IoStatus.Status = STATUS_SUCCESS;
        Irp->IoStatus.Information = sizeof(ULONG);

        *((PULONG)Irp->AssociatedIrp.SystemBuffer) = 0UL;

        RemoveReferenceForIrp(DeviceObject);

        return STATUS_SUCCESS;
    }

    //
    // Clear ourself out of passed down.
    //

    thisState->PassedDownWait = NULL;

    //
    // Take care of "1c & 3".  This is when the wait completes with an
    // invalid parameters sta tus.  This can only occur if another
    // wait sneaked in ahead of us.  This only occurs if we switched
    // into the DCD sniff state.  We handle this case by making the
    // irp a shuttled wait.
    //

    if ((Irp->IoStatus.Status == STATUS_INVALID_PARAMETER)
        ||
        (NT_SUCCESS(Irp->IoStatus.Status) && (maskValue == 0))) {


        PIRP junk;

        Irp->IoStatus.Status = STATUS_SUCCESS;
        Irp->IoStatus.Information = 0UL;

        //
        // First make sure that even that it didn't get
        // hit with a setmask trying to kill it also.  If
        // it did, then we should run it down.
        //
        UniMakeIrpShuttledWait(
            thisState,
            Irp,
            origIrql,
            FALSE,
            &junk
            );

        //
        // We say more processing required so that the io subsystem
        // will leave this irp alone.  The irp has actually been
        // shuttled (or been completed because of cancelling)
        // at this point.
        //

        return STATUS_MORE_PROCESSING_REQUIRED;

    } else if (NT_SUCCESS(Irp->IoStatus.Status) && (maskValue != 0)) {

        //
        // This is where we deal with scenario 1.  The most
        // important feature in this case is that our mask
        // processing code NEVER allows a new regular wait operation
        // down into the lower level serial driver when we have a
        // current wait operation.  However it does let down
        // new setmasks.  We need to resubmit the wait if the maskValue
        // was for the complementry mask.  However, we shouldn't resubmit
        // it if our mask state structure implies that we would actually
        // be completing this irp if an event hadn't occured.
        //

        if (otherState->Mask & maskValue) {

            if (otherState->ShuttledWait) {

                //
                // Rundown the shuttled wait.
                //
                PIRP savedIrp = otherState->ShuttledWait;

                otherState->ShuttledWait = NULL;

                //
                // Set this back cause the lock is going to get
                // released and we DON'T want a new irp to
                // slip in.
                //
                thisState->PassedDownWait = Irp;

                UniRundownShuttledWait(
                    otherState->Extension,
                    &otherState->ShuttledWait,
                    UNI_REFERENCE_NORMAL_PATH,
                    savedIrp,
                    origIrql,
                    STATUS_SUCCESS,
                    (ULONG)otherState->Mask & maskValue
                    );

                KeAcquireSpinLock(
                    &thisState->Extension->DeviceLock,
                    &origIrql
                    );
                thisState->PassedDownWait = NULL;

            } else {

                //
                // No shuttled wait, update the others
                // history mask.
                //
                D_TRACE(DbgPrint("Modem: Adding event to history mask=%08lx event=%08lx\n",otherState->Mask,maskValue);)

                otherState->HistoryMask |= otherState->Mask & maskValue;

            }

        }

        if (thisState->Mask & maskValue) {
            //
            //  this wait is satisified, let it complete
            //
            // If there is a shuttled wait, send it on down if possible.
            //
            // Note that the call will release the spinlock.
            //
            UniChangeShuttledToPassDown(
                otherState,
                origIrql
                );

        } else {
            //
            //  this mask state did not care this event
            //
            if ((thisState->SentDownSetMasks < thisState->SetMaskCount)) {

                *((PULONG)Irp->AssociatedIrp.SystemBuffer) = 0UL;

                //
                //  lock will be released
                //
                UniChangeShuttledToPassDown(
                    otherState,
                    origIrql
                    );


            } else {
                //
                //  send it back down again
                //
                MakeIrpCurrentPassedDown(
                    thisState,
                    Irp
                    );

                KeReleaseSpinLock(
                    &thisState->Extension->DeviceLock,
                    origIrql
                    );


                IoCopyCurrentIrpStackLocationToNext(Irp);

                //
                // Setup so that upon the lower level serial drivers completion
                // we decrement the reference count and such.
                //

                IoSetCompletionRoutine(
                    Irp,
                    UniGeneralWaitComplete,
                    thisState,
                    TRUE,
                    TRUE,
                    TRUE
                    );


                IoCallDriver(
                    thisState->Extension->AttachedDeviceObject,
                    Irp
                    );

                return STATUS_MORE_PROCESSING_REQUIRED;
            }

        }

        //
        // The other was all taken care of.  We are done with this irp
        // and we return a succesful status so the irp will actually complete.
        //
        RemoveReferenceForIrp(DeviceObject);

        return STATUS_SUCCESS;

    } else if (Irp->IoStatus.Status == STATUS_CANCELLED) {

        //
        // Take care of "2".
        //
        //
        // Ours was cancelled.  Just let the cancel go ahead.
        //
        // Try to start off the other wait if there is one.
        // The other wait had a cancel routine and it might
        // be gone or going also.
        //
        UniChangeShuttledToPassDown(
            otherState,
            origIrql
            );

        //
        // We return success so that the irp finishes off.  This does
        // not change the fact that it is cancelled.
        //
        RemoveReferenceForIrp(DeviceObject);

        return STATUS_SUCCESS;

    } else {

        //
        // We really should have taken care of everything above.
        //

        ASSERT(FALSE);

        KeReleaseSpinLock(
            &otherState->Extension->DeviceLock,
            origIrql
            );

        RemoveReferenceForIrp(DeviceObject);

        return STATUS_SUCCESS;
    }

}

NTSTATUS
UniGeneralMaskComplete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    Deal with finishing mask function

Arguments:

    DeviceObject - Pointer to the device object for the modem

    Irp - The irp being completed.

    Context - Points to the mask state for the client or control handle

Return Value:

    The function value is the final status of the call

--*/

{

    //
    // Decrement the reference count on the setmasks for this handle
    // under the protection of the lock.
    //

    PMASKSTATE maskState = Context;

    KIRQL oldIrql;

    KeAcquireSpinLock(
        &maskState->Extension->DeviceLock,
        &oldIrql
        );

    maskState->SetMaskCount--;
    maskState->SentDownSetMasks--;

    //
    // Additionally we want to clean out any bits in the history
    // mask that we no longer care about from this handle
    // (as long as the setmask was successful).
    //

    UNI_RESTORE_OLD_SETMASK(Irp);

    if (NT_SUCCESS(Irp->IoStatus.Status)) {

        maskState->Mask = *((PULONG)Irp->AssociatedIrp.SystemBuffer);
        maskState->HistoryMask &= maskState->Mask;

    }

    KeReleaseSpinLock(
        &maskState->Extension->DeviceLock,
        oldIrql
        );

    RemoveReferenceForIrp(DeviceObject);

    return STATUS_SUCCESS;

}

VOID
UniRundownShuttledWait(
    IN PDEVICE_EXTENSION Extension,
    IN PIRP *ShuttlePointer,
    IN ULONG ReferenceMask,
    IN PIRP IrpToRunDown,
    IN KIRQL DeviceLockIrql,
    IN NTSTATUS StatusToComplete,
    IN ULONG MaskCompleteValue
    )

/*++

Routine Description:

    This routine rundowns (and completes) shuttled aside wait irps.

    Note that we come in assuming that the device lock is held.

    Note that this routine assumes NO responsibility for starting
    new irps.

Arguments:

    Extension - The device extension for the particular modem.

    ShuttlePointer - Pointer to the pointer to the irp that we
                     will try to rundown.

    ReferenceMask - Bit to clear in the reference mask for the irp
                    we are trying to rundown.

    IrpToRunDown - The irp that we will actually complete if all the
                   references are gone at the end of this routine.

    DeviceLockIrql - The old irql when the caller acquired the
                     device lock.

    StatusToComplete - The status to use to complete the irp if
                       this call can actually complete it.

    MaskCompleteValue - The value to put in for the completed event
                        mask if this routine actually completes the
                        irp.

Return Value:

    None.

--*/

{

    BOOLEAN actuallyCompleteIt = FALSE;
    KIRQL cancelIrql;


    VALIDATE_IRP(IrpToRunDown);

#if 1 // EXTRA_DBG


    {
        PIO_STACK_LOCATION  irpSp;
#if EXTRA_DBG
        if (IrpToRunDown->IoStatus.Status !=STATUS_PENDING) {
            DbgPrint("MODEM: shuttled irp looks bad\n");
            DbgBreakPoint();
        }
#endif
        irpSp=IoGetCurrentIrpStackLocation(IrpToRunDown);

        if (irpSp->MajorFunction != IRP_MJ_DEVICE_CONTROL) {

            DbgPrint("MODEM: shuttled irp has bad major function\n");
            DbgBreakPoint();
        }
    }


#endif
    //
    // Clear the requested reference bit in the irp.
    //

    UNI_CLEAR_REFERENCE(
        IrpToRunDown,
        (BYTE)ReferenceMask
        );

    //
    // We first acquire the cancel spinlock and try to clear out the
    // cancel routine.
    //

    IoAcquireCancelSpinLock(&cancelIrql);

    if (IrpToRunDown->CancelRoutine) {

        IrpToRunDown->CancelRoutine = NULL;
        UNI_CLEAR_REFERENCE(
            IrpToRunDown,
            UNI_REFERENCE_CANCEL_PATH
            );

    }

    IoReleaseCancelSpinLock(cancelIrql);

    if (*ShuttlePointer) {

        *ShuttlePointer = NULL;
        UNI_CLEAR_REFERENCE(
            IrpToRunDown,
            UNI_REFERENCE_NORMAL_PATH
            );

    }

    actuallyCompleteIt = !UNI_REFERENCE_COUNT(IrpToRunDown);

    KeReleaseSpinLock(
        &Extension->DeviceLock,
        DeviceLockIrql
        );

    if (actuallyCompleteIt) {

        PULONG maskValue = IrpToRunDown->AssociatedIrp.SystemBuffer;
        IrpToRunDown->IoStatus.Information = sizeof(ULONG);
        *maskValue = MaskCompleteValue;

        RemoveReferenceAndCompleteRequest(
            Extension->DeviceObject,
            IrpToRunDown,
            StatusToComplete
            );

    }

}

VOID
UniCancelShuttledWait(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine will start the rundown of a wait operation that had
    been shuttled aside and has now been cancelled (for one reason
    or another).

Arguments:

    DeviceObject - The device object of the modem.

    Irp - This is the irp to cancel.  Note that this irp will
          have stashed away in it a pointer to the maskstate
          that should be used to cancel this irp.

Return Value:

    None.

--*/

{

    KIRQL origIrql;
    PMASKSTATE thisState = UNI_GET_STATE_IN_IRP(Irp);
    //
    // This lets the rest of the world move on.
    //

    IoReleaseCancelSpinLock(Irp->CancelIrql);

    //
    // Now attempt to rundown this irp.  We need to first acquire
    // the device lock.  We can get ahold of everything because
    // the state for this irp is hiding in the stack location.
    //

    KeAcquireSpinLock(
        &thisState->Extension->DeviceLock,
        &origIrql
        );

    UNI_CLEAR_STATE_IN_IRP(Irp);

    UniRundownShuttledWait(
        thisState->Extension,
        &thisState->ShuttledWait,
        UNI_REFERENCE_CANCEL_PATH,
        Irp,
        origIrql,
        STATUS_CANCELLED,
        0ul
        );

}

VOID
UniChangeShuttledToPassDown(
    IN PMASKSTATE ChangingState,
    IN KIRQL OrigIrql
    )

/*++

Routine Description:

    This routine is responsible for changing a shuttled aside wait
    into a passed down wait.

    NOTE: It is called with the device lock held.

    NOTE: Two things could "abort" the move.  One, we catch the irp
          in a cancelled state.  Two, we moved into a dcd sniff state.

Arguments:

    ChangingState - The state that the irp who we wish to pass down
                    is part of.

    OrigIrql - The previous irql to when we acquired the device lock.

Return Value:

    None.

--*/

{

    KIRQL cancelIrql;
    //
    // We are in here with the lock.  If it was cancelled run it down.
    //

    if (ChangingState->ShuttledWait == NULL) {
        //
        //  No wait for this state, just return
        //
        KeReleaseSpinLock(
            &ChangingState->Extension->DeviceLock,
            OrigIrql
            );

        return;
    }


    ASSERT(!ChangingState->PassedDownWait);
    IoAcquireCancelSpinLock(&cancelIrql);

    if (ChangingState->ShuttledWait->CancelRoutine) {

        //
        // It hasn't been cancelled yet.  Pull it out of the
        // cancellable state.
        //

        ChangingState->ShuttledWait->CancelRoutine = NULL;
        UNI_CLEAR_REFERENCE(
            ChangingState->ShuttledWait,
            UNI_REFERENCE_CANCEL_PATH
            );

        IoReleaseCancelSpinLock(cancelIrql);

        //
        // It hasn't been cancelled, We should now check if we are in the
        // dcd sniff state.  If we aren't then we can change to passed
        // down.
        //

        if (ChangingState->Extension->PassThrough != MODEM_DCDSNIFF) {


            PIO_STACK_LOCATION irpSp =  IoGetCurrentIrpStackLocation(ChangingState->ShuttledWait);

            PIO_STACK_LOCATION nextSp = IoGetNextIrpStackLocation(ChangingState->ShuttledWait);

            //
            // Not in the passthrough state.  We can pass it down.
            //

            UNI_CLEAR_REFERENCE(
                ChangingState->ShuttledWait,
                UNI_REFERENCE_NORMAL_PATH
                );
            UNI_CLEAR_STATE_IN_IRP(ChangingState->ShuttledWait);

            MakeIrpCurrentPassedDown(
                ChangingState,
                ChangingState->ShuttledWait
                );

            ChangingState->ShuttledWait = NULL;

            nextSp->MajorFunction = irpSp->MajorFunction;
            nextSp->MinorFunction = irpSp->MinorFunction;
            nextSp->Flags = irpSp->Flags;
            nextSp->Parameters.DeviceIoControl.IoControlCode =
                IOCTL_SERIAL_WAIT_ON_MASK;
            nextSp->Parameters.DeviceIoControl.OutputBufferLength =
                irpSp->Parameters.DeviceIoControl.OutputBufferLength;
            nextSp->Parameters.DeviceIoControl.Type3InputBuffer =
                irpSp->Parameters.DeviceIoControl.Type3InputBuffer;

            IoSetCompletionRoutine(
                ChangingState->PassedDownWait,
                UniGeneralWaitComplete,
                ChangingState,
                TRUE,
                TRUE,
                TRUE
                );

            //
            // We now can release the device lock and send the irp on
            // down.  Note one small glitch here is that between the
            // time that we release the lock and when we send down the
            // irp, we can enter into a DCD sniff state, and the modem
            // drivers wait might make it through ahead of ours.  We will
            // be ok through because the completion routine will simply
            // turn this back into a shuttled wait.
            //

            //
            //  make sure irp does not have status pending so isapnp does not choke
            //
            ChangingState->PassedDownWait->IoStatus.Status=STATUS_SUCCESS;

            KeReleaseSpinLock(
                &ChangingState->Extension->DeviceLock,
                OrigIrql
                );



            IoCallDriver(
                ChangingState->Extension->AttachedDeviceObject,
                ChangingState->PassedDownWait
                );

        } else {

            //
            // Well, we (potentially) moved into a dcd sniff while we were figuring
            // stuff out.  We should change it back into a shuttled wait.
            //

            UniMakeIrpShuttledWait(
                ChangingState,
                ChangingState->ShuttledWait,
                OrigIrql,
                FALSE,
                NULL
                );

        }

    } else {

        //
        // Gack! It's been cancelled.  Release the cancel lock and
        // run it down.
        //

        PIRP savedIrp = ChangingState->ShuttledWait;

        IoReleaseCancelSpinLock(cancelIrql);
        ChangingState->ShuttledWait = NULL;

        //
        // Before we actually run this state down, under the presumption
        // that we really want a wait operation down in the lower serial
        // driver, see if the "other" state has a shuttled wait.  If it
        // does, try to send it down (we can do this by calling ourself.
        //

        if (ChangingState->OtherState->ShuttledWait) {

            KIRQL recallIrql;

            UniChangeShuttledToPassDown(
                ChangingState->OtherState,
                OrigIrql
                );

            KeAcquireSpinLock(
                &ChangingState->Extension->DeviceLock,
                &recallIrql
                );
            OrigIrql = recallIrql;

        }

        UniRundownShuttledWait(
            ChangingState->Extension,
            &ChangingState->ShuttledWait,
            UNI_REFERENCE_NORMAL_PATH,
            savedIrp,
            OrigIrql,
            STATUS_CANCELLED,
            0UL
            );

    }

}

NTSTATUS
UniMakeIrpShuttledWait(
    IN PMASKSTATE MaskState,
    IN PIRP Irp,
    IN KIRQL OrigIrql,
    IN BOOLEAN GetNextIrpInQueue,
    OUT PIRP *NewIrp
    )

/*++

Routine Description:

    This routine is responsible for taking an irp and making it
    a shuttled aside wait. It works on the irp regardless of whether
    it had already been shuttled aside or if it's a new irp.

    NOTE: It is called with the device lock held.

    NOTE: Note that it can result in the irp being completed because
          it was cancelled.

Arguments:

    MaskState - The mask state that the irp is to become part of.

    Irp - The irp to make shuttled.

    OrigIrql - The old irql when the device lock was acquired.

    GetNextIrpInQueue - When done making the irp shuttled, this
                        will be used to determine if we should
                        try to get the next irp in the mask list.

    NewIrp - If we do get the next irp, this points to it.

Return Value:

    If we actually have to complete an irp this will be the status
    of the completion.  If we don't complete it, we give make
    STATUS_PENDING because the IRP is left shuttled aside.

--*/

{

    KIRQL cancelIrql;

    VALIDATE_IRP(Irp);

    IoAcquireCancelSpinLock(&cancelIrql);

    //
    // Since we are about to put the irp into a cancelable
    // state we need to make sure that it hasn't already
    // been canceled.  If it has, then we should NOT let
    // it proceed.
    //

    if (Irp->Cancel) {

        IoReleaseCancelSpinLock(cancelIrql);
        KeReleaseSpinLock(
            &MaskState->Extension->DeviceLock,
            OrigIrql
            );
        Irp->IoStatus.Status = STATUS_CANCELLED;
        Irp->IoStatus.Information = 0L;

        if (GetNextIrpInQueue) {

            UniGetNextIrp(
                MaskState->Extension->DeviceObject,
                &MaskState->Extension->DeviceLock,
                &MaskState->Extension->CurrentMaskOp,
                &MaskState->Extension->MaskOps,
                NewIrp,
                TRUE
                );

        }

        return STATUS_CANCELLED;

    }

    //
    // Make this irp a shuttled aside wait.
    //

    IoMarkIrpPending(Irp);
    MaskState->ShuttledWait = Irp;
    ASSERT(!MaskState->PassedDownWait);

#if EXTRA_DBG

    {
        PIO_STACK_LOCATION  NextSp;
        Irp->IoStatus.Status=STATUS_PENDING;

        NextSp=IoGetNextIrpStackLocation(Irp);

        NextSp->Parameters.Others.Argument1=(PVOID)1;
        NextSp->Parameters.Others.Argument2=(PVOID)2;
        NextSp->Parameters.Others.Argument3=(PVOID)3;
        NextSp->Parameters.Others.Argument4=(PVOID)4;


        NextSp=IoGetCurrentIrpStackLocation(Irp);

        MaskState->CurrentStackCompletionRoutine=NextSp->CompletionRoutine;

        if (NextSp->MajorFunction != IRP_MJ_DEVICE_CONTROL) {

            DbgPrint("MODEM: irp being shuttled has bad major function\n");
            DbgBreakPoint();
        }
    }


#endif

    UNI_INIT_REFERENCE(
        Irp
        );

    UNI_SET_REFERENCE(
        Irp,
        UNI_REFERENCE_CANCEL_PATH
        );
    UNI_SET_REFERENCE(
        Irp,
        UNI_REFERENCE_NORMAL_PATH
        );
    UNI_SAVE_STATE_IN_IRP(
        Irp,
        MaskState
        );
    IoSetCancelRoutine(
        Irp,
        UniCancelShuttledWait
        );

    IoReleaseCancelSpinLock(cancelIrql);
    KeReleaseSpinLock(
        &MaskState->Extension->DeviceLock,
        OrigIrql
        );

    if (GetNextIrpInQueue) {

        UniGetNextIrp(
            MaskState->Extension->DeviceObject,
            &MaskState->Extension->DeviceLock,
            &MaskState->Extension->CurrentMaskOp,
            &MaskState->Extension->MaskOps,
            NewIrp,
            FALSE
            );

    }

    return STATUS_PENDING;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\sys\modem\init.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    initunlo.c

Abstract:

    This module contains the code that is very specific to initialization
    and unload operations in the modem driver

Author:

    Anthony V. Ercolano 13-Aug-1995

Environment:

    Kernel mode

Revision History :

--*/

#include "precomp.h"

PVOID            PagedCodeSectionHandle;

UNICODE_STRING   DriverEntryRegPath;


#if DBG
ULONG UniDebugLevel = 0;
ULONG DebugFlags=0;
#endif


NTSTATUS
ModemPnP(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );


NTSTATUS
ModemHandleSymbolicLink(
    PDEVICE_OBJECT      Pdo,
    PUNICODE_STRING     InterfaceName,
    BOOL                Create
    );




NTSTATUS
ModemAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT Pdo
    );



NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
UniUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
UniDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );


NTSTATUS
UniInitializeItem(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT  Pdo
    );

VOID
CleanUpOnRemove(
    PDEVICE_OBJECT    DeviceObject,
    PIRP              Irp
    );


NTSTATUS
IsDeviceMultifunctionEnumerated(
    PDEVICE_OBJECT   Pdo,
    PBOOLEAN          Match
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,DriverEntry)
#pragma alloc_text(PAGE,UniUnload)
#pragma alloc_text(PAGE,ModemAddDevice)
#pragma alloc_text(PAGE,ModemPnP)
#pragma alloc_text(PAGE,QueryDeviceCaps)

#pragma alloc_text(PAGE,WaitForLowerDriverToCompleteIrp)
#pragma alloc_text(PAGE,IsDeviceMultifunctionEnumerated)

#pragma alloc_text(PAGE,ModemHandleSymbolicLink)
#pragma alloc_text(PAGE,ModemGetRegistryKeyValue)
#pragma alloc_text(PAGE,ModemSetRegistryKeyValue)

#pragma alloc_text(PAGEUMDM,CleanUpOnRemove)
#pragma alloc_text(PAGEUMDM,UniDispatch)
#endif


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    The entry point that the system point calls to initialize
    any driver.

Arguments:

    DriverObject - Just what it says,  really of little use
    to the driver itself, it is something that the IO system
    cares more about.

    PathToRegistry - points to the entry for this driver
    in the current control set of the registry.

Return Value:

    STATUS_SUCCESS if we could initialize a single device,
    otherwise STATUS_NO_SUCH_DEVICE.

--*/

{
    //
    // We use this to query into the registry as to whether we
    // should break at driver entry.
    //
    RTL_QUERY_REGISTRY_TABLE paramTable[4];
    ULONG zero = 0;
    ULONG debugLevel = 0;
    ULONG debugFlags = 0;
    ULONG shouldBreak = 0;


    DriverEntryRegPath.Length=RegistryPath->Length;
    DriverEntryRegPath.MaximumLength=DriverEntryRegPath.Length+sizeof(WCHAR);


    DriverEntryRegPath.Buffer=ALLOCATE_PAGED_POOL(DriverEntryRegPath.MaximumLength);

    if (DriverEntryRegPath.Buffer == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory(
        DriverEntryRegPath.Buffer,
        RegistryPath->Buffer,
        RegistryPath->Length
        );

    //
    //  NULL terminate the string
    //
    DriverEntryRegPath.Buffer[RegistryPath->Length/sizeof(WCHAR)]=L'\0';

    //
    // Since the registry path parameter is a "counted" UNICODE string, it
    // might not be zero terminated.  For a very short time allocate memory
    // to hold the registry path zero terminated so that we can use it to
    // delve into the registry.
    //
    // NOTE NOTE!!!! This is not an architected way of breaking into
    // a driver.  It happens to work for this driver because the author
    // likes to do things this way.
    //

    RtlZeroMemory(
        &paramTable[0],
        sizeof(paramTable)
        );

    paramTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[0].Name = L"BreakOnEntry";
    paramTable[0].EntryContext = &shouldBreak;
    paramTable[0].DefaultType = REG_DWORD;
    paramTable[0].DefaultData = &zero;
    paramTable[0].DefaultLength = sizeof(ULONG);

    paramTable[1].Flags = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[1].Name = L"DebugLevel";
    paramTable[1].EntryContext = &debugLevel;
    paramTable[1].DefaultType = REG_DWORD;
    paramTable[1].DefaultData = &zero;
    paramTable[1].DefaultLength = sizeof(ULONG);

    paramTable[2].Flags = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[2].Name = L"DebugFlags";
    paramTable[2].EntryContext = &debugFlags;
    paramTable[2].DefaultType = REG_DWORD;
    paramTable[2].DefaultData = &zero;
    paramTable[2].DefaultLength = sizeof(ULONG);

    if (!NT_SUCCESS(RtlQueryRegistryValues(
                        RTL_REGISTRY_ABSOLUTE | RTL_REGISTRY_OPTIONAL,
                        DriverEntryRegPath.Buffer,
                        &paramTable[0],
                        NULL,
                        NULL
                        ))) {

        shouldBreak = 0;
        debugLevel = 0;

    }


#if DBG
    UniDebugLevel = debugLevel;
    DebugFlags=debugFlags;
#endif

    if (shouldBreak) {

        DbgBreakPoint();

    }
    //
    //  pnp driver entry point
    //
    DriverObject->DriverExtension->AddDevice = ModemAddDevice;

    //
    // Initialize the Driver Object with driver's entry points
    //

    DriverObject->DriverUnload = UniUnload;

    DriverObject->MajorFunction[IRP_MJ_CREATE] = UniOpen;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]  = UniClose;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]  = UniIoControl;


    DriverObject->MajorFunction[IRP_MJ_FLUSH_BUFFERS] = UniDispatch;
    DriverObject->MajorFunction[IRP_MJ_WRITE]  = UniWrite;
    DriverObject->MajorFunction[IRP_MJ_READ]   = UniRead;
    DriverObject->MajorFunction[IRP_MJ_CLEANUP] = UniCleanup;

    DriverObject->MajorFunction[IRP_MJ_QUERY_INFORMATION] = UniDispatch;
    DriverObject->MajorFunction[IRP_MJ_SET_INFORMATION] =   UniDispatch;

    DriverObject->MajorFunction[IRP_MJ_PNP]   = ModemPnP;

    DriverObject->MajorFunction[IRP_MJ_POWER] = ModemPower;

    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = ModemWmi;


    D_PNP(DbgPrint("Modem: DriverEntry\n");)


    //
    //  lock and unlock here so we can get a handle to the section
    //  so future calls will be faster
    //
    PagedCodeSectionHandle=MmLockPagableCodeSection(UniDispatch);
    MmUnlockPagableImageSection(PagedCodeSectionHandle);


    return STATUS_SUCCESS;

}


VOID
UniUnload(
    IN PDRIVER_OBJECT DriverObject
    )
{

    D_PNP(DbgPrint("Modem: UnLoad\n");)

    FREE_POOL(DriverEntryRegPath.Buffer);

    return;

}



NTSTATUS
ModemAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT Pdo
    )
{

    // Temp value

    DWORD dwTemp = 0;

    //
    // Holds the NT Status that is returned from each call to the
    // kernel and executive.
    //
    NTSTATUS status = STATUS_SUCCESS;

    //
    // Points to the device object (not the extension) created
    // for this device.
    //
    PDEVICE_OBJECT Fdo = NULL;

    PDEVICE_OBJECT LowerDevice;

    //
    // Pointer to the device extension created for this
    // device
    //
    PDEVICE_EXTENSION deviceExtension = NULL;

    //
    // Create the device object for the modem.
    // Allocates the device extension.  Note that
    // the device is marked non-exclusive.
    //

    D_PNP(DbgPrint("MODEM: AddDevice\n");)


    //
    // Create the device object for this device.
    //

    status = IoCreateDevice(
                 DriverObject,
                 sizeof(DEVICE_EXTENSION),
                 NULL,
                 FILE_DEVICE_MODEM,
                 FILE_AUTOGENERATED_DEVICE_NAME,
                 FALSE,
                 &Fdo
                 );

    //
    // If we couldn't create the device object, then there
    // is no point in going on.
    //

    if (!NT_SUCCESS(status)) {

        D_ERROR(DbgPrint("MODEM: IoCreateDevice() failed %08lx\n",status);)

        UniLogError(
            DriverObject,
            NULL,
            0,
            0,
            0,
            5,
            status,
            MODEM_INSUFFICIENT_RESOURCES,
            0,
            NULL,
            0,
            NULL
            );

        return status;

    }

    Pdo->DeviceType=FILE_DEVICE_MODEM;

    LowerDevice=IoAttachDeviceToDeviceStack(
        Fdo,
        Pdo
        );

    if (LowerDevice == NULL) {

        D_ERROR(DbgPrint("MODEM: Could not attach to PDO\n");)

        UniLogError(
            DriverObject,
            NULL,
            0,
            0,
            0,
            5,
            status,
            MODEM_INSUFFICIENT_RESOURCES,
            0,
            NULL,
            0,
            NULL
            );

        IoDeleteDevice(Fdo);
        return STATUS_INSUFFICIENT_RESOURCES;

    }

    Fdo->Flags |= DO_BUFFERED_IO | DO_POWER_PAGABLE;
    deviceExtension = Fdo->DeviceExtension;

    deviceExtension->DoType=DO_TYPE_FDO;

    deviceExtension->DeviceObject = Fdo;
    deviceExtension->Pdo=Pdo;
    deviceExtension->LowerDevice=LowerDevice;


    status=ExInitializeResourceLite(
        &deviceExtension->OpenCloseResource
        );

    if (status != STATUS_SUCCESS) {

        D_ERROR(DbgPrint("MODEM: Could not initialize resource\n");)

        IoDetachDevice(LowerDevice);

        IoDeleteDevice(Fdo);
        return status;

    }

    deviceExtension->ReferenceCount=1;
    deviceExtension->Started=FALSE;
    deviceExtension->Removing=FALSE;

    deviceExtension->WakeOnRingEnabled=FALSE;

    status = ModemGetRegistryKeyValue(
            Pdo,
            PLUGPLAY_REGKEY_DEVICE,
            L"WakeOnRing",
            &dwTemp,
            sizeof(DWORD));

    if (!NT_SUCCESS(status))
    {

        DWORD dwRegval = 0;

        // There may not be any wake on ring settings in the registry
       
        if (deviceExtension->WakeOnRingEnabled)
        {
            dwRegval = 1;
        }

        status = ModemSetRegistryKeyValue(
                Pdo,
                PLUGPLAY_REGKEY_DEVICE,
                L"WakeOnRing",
                REG_DWORD,
                &dwRegval,
                sizeof(DWORD));

        if (!NT_SUCCESS(status))
        {
            D_ERROR(DbgPrint("MODEM: Could not set wake on ring status\n");)
        } else
        {
            D_ERROR(DbgPrint("MODEM: Set reg entry for wake on ring\n");)
        }

   } else
   {
       D_ERROR(DbgPrint("MODEM: Wake On Ring retrieved\n");)

       if (dwTemp)
       {
           deviceExtension->WakeOnRingEnabled=TRUE;
           D_ERROR(DbgPrint("MODEM: Wake On Ring Enabled\n");)
       } else
       {
           D_ERROR(DbgPrint("MODEM: Wake On Ring Disabled\n");)
       }
   }

    KeInitializeEvent(&deviceExtension->RemoveEvent,   NotificationEvent, FALSE);

    KeInitializeSpinLock(&deviceExtension->DeviceLock);
    InitializeListHead(&deviceExtension->PassThroughQueue);
    InitializeListHead(&deviceExtension->MaskOps);

    InitializeListHead(&deviceExtension->IpcControl[0].GetList);
    InitializeListHead(&deviceExtension->IpcControl[0].PutList);

    InitializeListHead(&deviceExtension->IpcControl[1].GetList);
    InitializeListHead(&deviceExtension->IpcControl[1].PutList);


    InitIrpQueue(
        &deviceExtension->WriteIrpControl,
        Fdo,
        WriteIrpStarter
        );

    InitIrpQueue(
        &deviceExtension->ReadIrpControl,
        Fdo,
        ReadIrpStarter
        );



    KeInitializeDpc(
        &deviceExtension->WaveStopDpc,
        WaveStopDpcHandler,
        deviceExtension
        );



    deviceExtension->MaskStates[0].Extension = deviceExtension;
    deviceExtension->MaskStates[1].Extension = deviceExtension;
    deviceExtension->MaskStates[0].OtherState = &deviceExtension->MaskStates[1];
    deviceExtension->MaskStates[1].OtherState = &deviceExtension->MaskStates[0];

#if 0
    deviceExtension->ModemOwnsPolicy=0l;

    ModemGetRegistryKeyValue(
        Pdo,
        PLUGPLAY_REGKEY_DEVICE,
        L"SerialRelinquishPowerPolicy",
        &deviceExtension->ModemOwnsPolicy,
        sizeof(deviceExtension->ModemOwnsPolicy)
        );
#endif

    status=ModemHandleSymbolicLink(
        Pdo,
        &deviceExtension->InterfaceNameString,
        TRUE
        );

    if (!NT_SUCCESS(status)) {

        //
        // Oh well, couldn't create the symbolic link.  No point
        // in trying to create the device map entry.
        //

        D_ERROR(DbgPrint("MODEM: Could not create symbolic link %08lx\n",status);)

        UniLogError(
            DriverObject,
            Fdo,
            0,
            0,
            0,
            52,
            status,
            MODEM_NO_SYMLINK_CREATED,
            0,
            0,
            0,
            NULL
            );

        IoDetachDevice(LowerDevice);

        ExDeleteResourceLite(&deviceExtension->OpenCloseResource);

        goto ErrorCleanup;

    }

    Fdo->Flags &= ~DO_DEVICE_INITIALIZING;

    IoWMIRegistrationControl(
        Fdo,
        WMIREG_ACTION_REGISTER
        );

    goto OkCleanup;

ErrorCleanup:

    IoDeleteDevice(Fdo);

OkCleanup: ;

    D_PNP(DbgPrint("MODEM: AddDevice returning %08lx\n",status);)


    return status;

}

VOID
UniLogError(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT DeviceObject OPTIONAL,
    IN ULONG SequenceNumber,
    IN UCHAR MajorFunctionCode,
    IN UCHAR RetryCount,
    IN ULONG UniqueErrorValue,
    IN NTSTATUS FinalStatus,
    IN NTSTATUS SpecificIOStatus,
    IN ULONG LengthOfInsert1,
    IN PWCHAR Insert1,
    IN ULONG LengthOfInsert2,
    IN PWCHAR Insert2
    )

/*++

Routine Description:

    This routine allocates an error log entry, copies the supplied data
    to it, and requests that it be written to the error log file.

Arguments:

    DriverObject - A pointer to the driver object for the device.

    DeviceObject - A pointer to the device object associated with the
    device that had the error, early in initialization, one may not
    yet exist.

    SequenceNumber - A ulong value that is unique to an IRP over the
    life of the irp in this driver - 0 generally means an error not
    associated with an irp.

    MajorFunctionCode - If there is an error associated with the irp,
    this is the major function code of that irp.

    RetryCount - The number of times a particular operation has been
    retried.

    UniqueErrorValue - A unique long word that identifies the particular
    call to this function.

    FinalStatus - The final status given to the irp that was associated
    with this error.  If this log entry is being made during one of
    the retries this value will be STATUS_SUCCESS.

    SpecificIOStatus - The IO status for a particular error.

    LengthOfInsert1 - The length in bytes (including the terminating NULL)
                      of the first insertion string.

    Insert1 - The first insertion string.

    LengthOfInsert2 - The length in bytes (including the terminating NULL)
                      of the second insertion string.  NOTE, there must
                      be a first insertion string for their to be
                      a second insertion string.

    Insert2 - The second insertion string.

Return Value:

    None.

--*/

{
    PIO_ERROR_LOG_PACKET errorLogEntry;

    PVOID objectToUse;
    PUCHAR ptrToFirstInsert;
    PUCHAR ptrToSecondInsert;


    if (ARGUMENT_PRESENT(DeviceObject)) {

        objectToUse = DeviceObject;

    } else {

        objectToUse = DriverObject;

    }

    errorLogEntry = IoAllocateErrorLogEntry(
                        objectToUse,
                        (UCHAR)(sizeof(IO_ERROR_LOG_PACKET) +
                                LengthOfInsert1 +
                                LengthOfInsert2)
                        );

    if ( errorLogEntry != NULL ) {

        errorLogEntry->ErrorCode = SpecificIOStatus;
        errorLogEntry->SequenceNumber = SequenceNumber;
        errorLogEntry->MajorFunctionCode = MajorFunctionCode;
        errorLogEntry->RetryCount = RetryCount;
        errorLogEntry->UniqueErrorValue = UniqueErrorValue;
        errorLogEntry->FinalStatus = FinalStatus;

        ptrToFirstInsert = (PUCHAR)&errorLogEntry->DumpData[0];

        ptrToSecondInsert = ptrToFirstInsert + LengthOfInsert1;

        if (LengthOfInsert1) {

            errorLogEntry->NumberOfStrings = 1;
            errorLogEntry->StringOffset = (USHORT)(ptrToFirstInsert -
                                                   (PUCHAR)errorLogEntry);
            RtlCopyMemory(
                ptrToFirstInsert,
                Insert1,
                LengthOfInsert1
                );

            if (LengthOfInsert2) {

                errorLogEntry->NumberOfStrings = 2;
                RtlCopyMemory(
                    ptrToSecondInsert,
                    Insert2,
                    LengthOfInsert2
                    );

            }

        }

        IoWriteErrorLogEntry(errorLogEntry);

    }

}

NTSTATUS
UniDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

{

    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);

    NTSTATUS status;

    //
    //  make sure the device is ready for irp's
    //
    status=CheckStateAndAddReference(
        DeviceObject,
        Irp
        );

    if (STATUS_SUCCESS != status) {
        //
        //  not accepting irp's. The irp has already been completed
        //
        return status;

    }

    if ((deviceExtension->PassThrough != MODEM_NOPASSTHROUGH) ||
        (irpSp->FileObject->FsContext)) {

        IoSkipCurrentIrpStackLocation(Irp);

        status=IoCallDriver(
                   deviceExtension->AttachedDeviceObject,
                   Irp
                   );

        RemoveReferenceForIrp(DeviceObject);
        RemoveReferenceForDispatch(DeviceObject);

        return status;

    } else {

        Irp->IoStatus.Information=0L;

        RemoveReferenceAndCompleteRequest(
            DeviceObject,
            Irp,
            STATUS_PORT_DISCONNECTED
            );

        RemoveReferenceForDispatch(DeviceObject);

        return STATUS_PORT_DISCONNECTED;

    }

}



#if DBG

NTSTATUS
UnhandledPnpIrpCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);

    D_PNP(DbgPrint("MODEM: Forwarded IRP, MN func=%d, completed with %08lx\n",irpSp->MinorFunction,Irp->IoStatus.Status);)

    return STATUS_SUCCESS;

}

#endif

NTSTATUS ForwardIrp(
    PDEVICE_OBJECT   NextDevice,
    PIRP   Irp
    )

{

#if DBG
            IoMarkIrpPending(Irp);
            IoCopyCurrentIrpStackLocationToNext(Irp);
            IoSetCompletionRoutine(
                         Irp,
                         UnhandledPnpIrpCompletion,
                         NULL,
                         TRUE,
                         TRUE,
                         TRUE
                         );

            IoCallDriver(NextDevice, Irp);

            return STATUS_PENDING;
#else
            IoSkipCurrentIrpStackLocation(Irp);
            return IoCallDriver(NextDevice, Irp);
#endif

}


#if DBG


NTSTATUS
ModemDealWithResources(
    IN PDEVICE_OBJECT   Fdo,
    IN PIRP             Irp
    )

/*++

Routine Description:

    This routine will get the configuration information and put
    it into a CONFIG_DATA structure.  It first sets up with 
    defaults and then queries the registry to see if the user has 
    overridden these defaults.

Arguments:

    Fdo - Pointer to the functional device object.

Return Value:

    STATUS_SUCCESS if consistant configuration was found - otherwise.
    returns STATUS_SERIAL_NO_DEVICE_INITED.

--*/

{
    NTSTATUS                        status          = STATUS_SUCCESS;
    PIO_STACK_LOCATION              irpSp        = IoGetCurrentIrpStackLocation(Irp);
    
    ULONG                           count;
    ULONG                           i;


    PCM_RESOURCE_LIST               pResourceList;
    PCM_PARTIAL_RESOURCE_LIST       pPartialResourceList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR pPartialResourceDesc;
    
    PCM_FULL_RESOURCE_DESCRIPTOR    pFullResourceDesc       = NULL;
    

    //
    //  Get resource list
    //
    pResourceList = irpSp->Parameters.StartDevice.AllocatedResources;

    if (pResourceList != NULL) {

        pFullResourceDesc   = &pResourceList->List[0];

    } else {

        pFullResourceDesc=NULL;

    }

    
    //
    // Ok, if we have a full resource descriptor.  Let's take it apart.
    //
    
    if (pFullResourceDesc) {

        pPartialResourceList    = &pFullResourceDesc->PartialResourceList;
        pPartialResourceDesc    = pPartialResourceList->PartialDescriptors;
        count                   = pPartialResourceList->Count;


        //
        // Pull out the stuff that is in the full descriptor.
        //

        D_PNP(DbgPrint("MODEM: Interface type is %d, Bus number %d\n",pFullResourceDesc->InterfaceType,pFullResourceDesc->BusNumber);)
        //
        // Now run through the partial resource descriptors looking for the port,
        // interrupt, and clock rate.
        //


        for (i = 0;     i < count;     i++, pPartialResourceDesc++) {

            switch (pPartialResourceDesc->Type) {


                case CmResourceTypeMemory: {

                    D_PNP(DbgPrint("MODEM: Memory resource at %x, length %d, addressSpace=%d\n",
                                    pPartialResourceDesc->u.Memory.Start.LowPart,
                                    pPartialResourceDesc->u.Memory.Length,
                                    pPartialResourceDesc->Flags
                                    );)
                    break;
                }


                case CmResourceTypePort: {

                    D_PNP(DbgPrint("MODEM: Port resource at %x, length %d, Flags=%x, %s, %s%s\n",
                                    pPartialResourceDesc->u.Port.Start.LowPart,
                                    pPartialResourceDesc->u.Port.Length,
                                    pPartialResourceDesc->Flags,
                                    pPartialResourceDesc->Flags & CM_RESOURCE_PORT_IO ? "Port" : "Memory",
                                    pPartialResourceDesc->Flags & CM_RESOURCE_PORT_10_BIT_DECODE ? "10-bit, " : "",
                                    pPartialResourceDesc->Flags & CM_RESOURCE_PORT_16_BIT_DECODE ? "16-bit" : ""
                                    );)
                    break;
                }

                case CmResourceTypeDma: {

                    D_PNP(DbgPrint("MODEM: DMA channel %d, port %d, addressSpace=%d\n",
                                    pPartialResourceDesc->u.Dma.Channel,
                                    pPartialResourceDesc->u.Dma.Port
                                    );)


                    break;
                }


                case CmResourceTypeInterrupt: {

                    D_PNP(DbgPrint("MODEM: Interrupt resource, level=%d, vector=%d, %s, %s\n",
                                   pPartialResourceDesc->u.Interrupt.Level,
                                   pPartialResourceDesc->u.Interrupt.Vector,
                                   (pPartialResourceDesc->Flags & CM_RESOURCE_INTERRUPT_LATCHED) ? "Latched" : "Level",
                                   (pPartialResourceDesc->ShareDisposition == CmResourceShareShared) ? "Shared" : "Exclusive/undetermined"
                                   );)

                    break;
                }

        
                default: {

                    D_PNP(DbgPrint("MODEM: Other resources\n");)
                    break;
                }
            }
        }
    }

    return status;
}

#endif





NTSTATUS
ModemPnP(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

{

    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS    status;

    ULONG newRelationsSize, oldRelationsSize = 0;

    if ((deviceExtension->DoType==DO_TYPE_PDO) || (deviceExtension->DoType==DO_TYPE_DEL_PDO)) {
        //
        //  this one is for the child
        //
        return ModemPdoPnp(
                   DeviceObject,
                   Irp
                   );
    }

    if (deviceExtension->DoType != DO_TYPE_FDO) {

        DbgPrint("MODEM: ModemPnp: Bad DevObj\n");

        Irp->IoStatus.Status = STATUS_SUCCESS;

        IoCompleteRequest(
            Irp,
            IO_NO_INCREMENT
            );


        return STATUS_SUCCESS;

    }

    switch (irpSp->MinorFunction) {

        case IRP_MN_START_DEVICE:

            D_PNP(
                DbgPrint("MODEM: IRP_MN_START_DEVICE\n");
                ModemDealWithResources(DeviceObject,Irp);
                )
            //
            // Send this down to the PDO first
            //
            status=WaitForLowerDriverToCompleteIrp(
                deviceExtension->LowerDevice,
                Irp,
                COPY_CURRENT_TO_NEXT
                );


            if (NT_SUCCESS(status)) {

                deviceExtension->Started=TRUE;

                KeEnterCriticalRegion();

                ExAcquireResourceExclusiveLite(
                    &deviceExtension->OpenCloseResource,
                    TRUE
                    );

                //
                //  create child PDO if there is a duplex modem
                //
                CreateChildPdo(deviceExtension);

                ExReleaseResourceLite(
                    &deviceExtension->OpenCloseResource
                    );

                KeLeaveCriticalRegion();

            } else {

                D_ERROR(DbgPrint("MODEM: PDO failed start irp, %08lx\n",status);)


            }

            Irp->IoStatus.Status = status;
            Irp->IoStatus.Information=0L;
            IoCompleteRequest(
                Irp,
                IO_NO_INCREMENT
                );
            return status;


        case IRP_MN_QUERY_STOP_DEVICE:

            D_PNP(DbgPrint("MODEM: IRP_MN_QUERY_STOP_DEVICE\n");)

            KeEnterCriticalRegion();

            ExAcquireResourceExclusiveLite(
                &deviceExtension->OpenCloseResource,
                TRUE
                );

            if (deviceExtension->OpenCount != 0) {
                //
                //  no can do
                //
                D_PNP(DbgPrint("MODEM: IRP_MN_QUERY_STOP_DEVICE -- failing\n");)

                ExReleaseResourceLite(
                    &deviceExtension->OpenCloseResource
                    );

                KeLeaveCriticalRegion();

                Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
                IoCompleteRequest(
                    Irp,
                    IO_NO_INCREMENT
                    );

                return STATUS_UNSUCCESSFUL;
            }


            deviceExtension->PreQueryStartedStatus=deviceExtension->Started;
            deviceExtension->Started=FALSE;

            ExReleaseResourceLite(
                &deviceExtension->OpenCloseResource
                );

            KeLeaveCriticalRegion();

            Irp->IoStatus.Status = STATUS_SUCCESS;

            return ForwardIrp(deviceExtension->LowerDevice, Irp);


        case IRP_MN_CANCEL_STOP_DEVICE:

            D_PNP(DbgPrint("MODEM: IRP_MN_CANCEL_STOP_DEVICE\n");)

            status=WaitForLowerDriverToCompleteIrp(
                deviceExtension->LowerDevice,
                Irp,
                COPY_CURRENT_TO_NEXT
                );

            deviceExtension->Started=deviceExtension->PreQueryStartedStatus;

            Irp->IoStatus.Status = status;
            Irp->IoStatus.Information=0L;
            IoCompleteRequest(
                Irp,
                IO_NO_INCREMENT
                );

            return status;



        case IRP_MN_STOP_DEVICE:

            D_PNP(DbgPrint("MODEM: IRP_MN_STOP_DEVICE\n");)

            deviceExtension->Started=FALSE;

            Irp->IoStatus.Status = STATUS_SUCCESS;

            return ForwardIrp(deviceExtension->LowerDevice, Irp);


        case IRP_MN_QUERY_DEVICE_RELATIONS: {

            PDEVICE_RELATIONS    CurrentRelations=(PDEVICE_RELATIONS)Irp->IoStatus.Information;
            PDEVICE_RELATIONS    NewRelations=NULL;

            D_PNP(DbgPrint("MODEM: IRP_MN_QUERY_DEVICE_RELATIONS type=%d\n",irpSp->Parameters.QueryDeviceRelations.Type);)
            D_PNP(DbgPrint("                                     Information=%08lx\n",Irp->IoStatus.Information);)


            switch (irpSp->Parameters.QueryDeviceRelations.Type ) {

                case BusRelations: {

                    //
                    // Send this down to the PDO first
                    //
                    status=WaitForLowerDriverToCompleteIrp(
                        deviceExtension->LowerDevice,
                        Irp,
                        COPY_CURRENT_TO_NEXT
                        );


                    CurrentRelations=(PDEVICE_RELATIONS)Irp->IoStatus.Information;

                    if (NT_SUCCESS(status) && (CurrentRelations != NULL)) {

                        NewRelations=ALLOCATE_PAGED_POOL(sizeof(DEVICE_RELATIONS)+CurrentRelations->Count*sizeof(PDEVICE_OBJECT));

                        if (NewRelations != NULL) {

                            RtlCopyMemory(
                                NewRelations,
                                CurrentRelations,
                                FIELD_OFFSET(DEVICE_RELATIONS,Objects)+(CurrentRelations->Count*sizeof(PDEVICE_OBJECT))
                                );

                            FREE_POOL(CurrentRelations);

                            CurrentRelations=NewRelations;
                            NewRelations=NULL;

                            Irp->IoStatus.Information=(ULONG_PTR)CurrentRelations;

                        } else {
                            //
                            //  just complete with the old status, no child

                            IoCompleteRequest(
                                Irp,
                                IO_NO_INCREMENT
                                );

                            return status;
                        }

                    } else {
                        //
                        //  allocate memory for a relations structure
                        //
                        CurrentRelations=ALLOCATE_PAGED_POOL(sizeof(DEVICE_RELATIONS));

                        if (CurrentRelations == NULL) {

                            Irp->IoStatus.Status= STATUS_INSUFFICIENT_RESOURCES;

                            IoCompleteRequest(
                                Irp,
                                IO_NO_INCREMENT
                                );

                            return STATUS_INSUFFICIENT_RESOURCES;
                        }

                        RtlZeroMemory(CurrentRelations, sizeof(DEVICE_RELATIONS));
                        Irp->IoStatus.Information=(ULONG_PTR)CurrentRelations;
                    }


                    KeEnterCriticalRegion();

                    ExAcquireResourceExclusiveLite(
                        &deviceExtension->OpenCloseResource,
                        TRUE
                        );

                    //
                    //  create child PDO if there is a duplex modem
                    //
                    if (deviceExtension->ChildPdo != NULL && ((PPDO_DEVICE_EXTENSION)deviceExtension->ChildPdo->DeviceExtension)->DoType == DO_TYPE_PDO ) {

                       D_PNP(DbgPrint("                                     ChildPdo=%08lx\n",deviceExtension->ChildPdo);)

                       ObReferenceObject(deviceExtension->ChildPdo);
                       CurrentRelations->Objects[CurrentRelations->Count]=deviceExtension->ChildPdo;
                       CurrentRelations->Count++;

                    }

                    ExReleaseResourceLite(
                        &deviceExtension->OpenCloseResource
                        );

                    KeLeaveCriticalRegion();

                    status=STATUS_SUCCESS;


                    Irp->IoStatus.Status = status;
                    IoCompleteRequest(
                        Irp,
                        IO_NO_INCREMENT
                        );

                    return status;
                }

                case TargetDeviceRelation:
                default: {

                    return ForwardIrp(deviceExtension->LowerDevice, Irp);
                }
            }

            break;

        }


        case IRP_MN_QUERY_REMOVE_DEVICE:

            D_PNP(DbgPrint("MODEM: IRP_MN_QUERY_REMOVE_DEVICE\n");)

            Irp->IoStatus.Status = STATUS_SUCCESS;

            return ForwardIrp(deviceExtension->LowerDevice, Irp);


        case IRP_MN_CANCEL_REMOVE_DEVICE:

            D_PNP(DbgPrint("MODEM: IRP_MN_CANCEL_REMOVE_DEVICE\n");)

            Irp->IoStatus.Status = STATUS_SUCCESS;

            return ForwardIrp(deviceExtension->LowerDevice, Irp);

        case IRP_MN_SURPRISE_REMOVAL: {

            D_PNP(DbgPrint("MODEM: IRP_MN_SURPRISE_REMOVAL\n");)

            Irp->IoStatus.Status = STATUS_SUCCESS;

            deviceExtension->Removing=TRUE;

            if (deviceExtension->InterfaceNameString.Buffer != NULL) {
                //
                //  disable the interface so the tsp will know it went away.
                //
                IoSetDeviceInterfaceState(
                    &deviceExtension->InterfaceNameString,
                    FALSE
                    );
            }

            MmLockPagableSectionByHandle(PagedCodeSectionHandle);

            KeEnterCriticalRegion();

            ExAcquireResourceExclusiveLite(
                &deviceExtension->OpenCloseResource,
                TRUE
                );

            CleanUpOnRemove(
                DeviceObject,
                Irp
                );

            ExReleaseResourceLite(
                &deviceExtension->OpenCloseResource
                );

            KeLeaveCriticalRegion();

            MmUnlockPagableImageSection(PagedCodeSectionHandle);

            return ForwardIrp(deviceExtension->LowerDevice, Irp);

        }
        break;


        case IRP_MN_REMOVE_DEVICE: {

            ULONG    NewReferenceCount;

            D_PNP(DbgPrint("MODEM: IRP_MN_REMOVE_DEVICE, %d\n",deviceExtension->ReferenceCount);)
            //
            //  removing now for sure
            //
            deviceExtension->Removing=TRUE;
            deviceExtension->Removed=TRUE;

            //
            //  get rid of the symbolic link
            //
            ModemHandleSymbolicLink(
                deviceExtension->Pdo,
                &deviceExtension->InterfaceNameString,
                FALSE
                );

#ifdef WAVE_KEY
            //
            //  remove the wavedriver key
            //
            RemoveWaveDriverRegKeyValue(
                deviceExtension->Pdo
                );
#endif

            MmLockPagableSectionByHandle(PagedCodeSectionHandle);

            KeEnterCriticalRegion();

            ExAcquireResourceExclusiveLite(
                &deviceExtension->OpenCloseResource,
                TRUE
                );

            CleanUpOnRemove(
                DeviceObject,
                Irp
                );

            if (deviceExtension->ChildPdo != NULL) {

                PPDO_DEVICE_EXTENSION   PdoDeviceExtension=deviceExtension->ChildPdo->DeviceExtension;

                D_PNP(DbgPrint("MODEM: IRP_MN_REMOVE_DEVICE, Not enumerating ChildPdo %08lx\n",deviceExtension->ChildPdo);)

                PdoDeviceExtension->UnEnumerated=TRUE;

                if (!PdoDeviceExtension->Deleted) {
                    //
                    //  child PDO has not been deleted by the PDO handler, kill it now
                    //  beacause the child is gone
                    //
                    D_PNP(DbgPrint("MODEM: IRP_MN_REMOVE_DEVICE, Deleting ChildPdo %08lx\n",deviceExtension->ChildPdo);)

                    PdoDeviceExtension->Deleted=TRUE;

                    IoDeleteDevice(deviceExtension->ChildPdo);

                    deviceExtension->ChildPdo=NULL;
                }
            }

            ExReleaseResourceLite(
                &deviceExtension->OpenCloseResource
                );

            KeLeaveCriticalRegion();

            MmUnlockPagableImageSection(PagedCodeSectionHandle);

            IoWMIRegistrationControl(
                DeviceObject,
                WMIREG_ACTION_DEREGISTER
                );


            //
            //  remove the ref for the AddDevice
            //
            NewReferenceCount=InterlockedDecrement(&deviceExtension->ReferenceCount);

            if (NewReferenceCount > 0) {
                //
                //  Still have outstanding request, wait
                //
                D_PNP(DbgPrint("MODEM: IRP_MN_REMOVE_DEVICE- waiting for refcount to drop\n");)

                KeWaitForSingleObject(&deviceExtension->RemoveEvent, Executive, KernelMode, FALSE, NULL);

                D_PNP(DbgPrint("MODEM: IRP_MN_REMOVE_DEVICE- Done waiting\n");)
            }

            IoCopyCurrentIrpStackLocationToNext(Irp);

            status=IoCallDriver(deviceExtension->LowerDevice, Irp);

            //
            //  detach from the driver below
            //
            IoDetachDevice(deviceExtension->LowerDevice);

            deviceExtension->DoType=DO_TYPE_DEL_FDO;

            ExDeleteResourceLite(&deviceExtension->OpenCloseResource);
            //
            //  delete our device object
            //
            IoDeleteDevice(DeviceObject);

            D_PNP(DbgPrint("MODEM: IRP_MN_REMOVE_DEVICE exit, %08lx\n",status);)

            return status;

        }

        case IRP_MN_FILTER_RESOURCE_REQUIREMENTS: {

            BOOLEAN    MultifunctionEnumerated=FALSE;

            D_PNP(DbgPrint("MODEM: IRP_MN_FILTER_RESOURCE_REQUIREMENTS\n");)

            status=IsDeviceMultifunctionEnumerated(
                deviceExtension->Pdo,
                &MultifunctionEnumerated
                );


            status=WaitForLowerDriverToCompleteIrp(
                deviceExtension->LowerDevice,
                Irp,
                COPY_CURRENT_TO_NEXT
                );

            if (NT_SUCCESS(status) && !MultifunctionEnumerated) {

                PIO_RESOURCE_REQUIREMENTS_LIST ResourceRequirementsList;
                PIO_RESOURCE_LIST              ResourceList;
                UINT                           i,j;

                ResourceRequirementsList=(PIO_RESOURCE_REQUIREMENTS_LIST)Irp->IoStatus.Information;

                if (ResourceRequirementsList != NULL) {

                    ResourceList=&ResourceRequirementsList->List[0];

                    for (i=0; i<ResourceRequirementsList->AlternativeLists; i++) {

                        for (j=0; j<ResourceList->Count; j++) {

                            PIO_RESOURCE_DESCRIPTOR  Descriptor;

                            Descriptor=&ResourceList->Descriptors[j];

                            if (Descriptor->Type == CmResourceTypeInterrupt) {

                                if ((Descriptor->ShareDisposition == CmResourceShareShared) && (Descriptor->Flags & CM_RESOURCE_INTERRUPT_LATCHED)) {

                                    D_PNP(DbgPrint("MODEM: FilterResource: Forcing shared latched interrupt to EXCLUSIVE, min=%d, max=%d\n",
                                                   Descriptor->u.Interrupt.MaximumVector,
                                                   Descriptor->u.Interrupt.MinimumVector);)

                                    Descriptor->ShareDisposition=CmResourceShareDeviceExclusive;

                                }

                            }
                        }

                        ResourceList=(PIO_RESOURCE_LIST)(((PUCHAR)ResourceList)
                                     +sizeof(IO_RESOURCE_DESCRIPTOR)*(ResourceList->Count-1)
                                     +sizeof(IO_RESOURCE_LIST));

                    }
                }
            } else {

                if (MultifunctionEnumerated) {

                    D_PNP(DbgPrint("MODEM: FilterResource: Not filtering resources for MF device\n");)
                }
            }

            IoCompleteRequest(
                Irp,
                IO_NO_INCREMENT
                );

            return status;

        }


        case IRP_MN_QUERY_CAPABILITIES: {

            ULONG   i;

            //
            // Send this down to the PDO first
            //
            status=WaitForLowerDriverToCompleteIrp(
                deviceExtension->LowerDevice,
                Irp,
                COPY_CURRENT_TO_NEXT
                );

            deviceExtension->CapsQueried=TRUE;

            irpSp = IoGetCurrentIrpStackLocation(Irp);

            for (i = PowerSystemUnspecified; i < PowerSystemMaximum;   i++) {

                deviceExtension->SystemPowerStateMap[i]=PowerDeviceD3;
            }

            for (i = PowerSystemWorking; i < PowerSystemShutdown;  i++) {

                D_POWER(DbgPrint("MODEM: DevicePower for System %d is %d\n",i,irpSp->Parameters.DeviceCapabilities.Capabilities->DeviceState[i]);)
                deviceExtension->SystemPowerStateMap[i]=irpSp->Parameters.DeviceCapabilities.Capabilities->DeviceState[i];
            }

            deviceExtension->SystemPowerStateMap[PowerSystemWorking]=PowerDeviceD0;

            deviceExtension->SystemWake=irpSp->Parameters.DeviceCapabilities.Capabilities->SystemWake;
            deviceExtension->DeviceWake=irpSp->Parameters.DeviceCapabilities.Capabilities->DeviceWake;

            D_POWER(DbgPrint("MODEM: DeviceWake=%d, SystemWake=%d\n",deviceExtension->DeviceWake,deviceExtension->SystemWake);)

            IoCompleteRequest(
                Irp,
                IO_NO_INCREMENT
                );
            return status;


            break;
        }



        default:
            D_PNP(DbgPrint("MODEM: Sending to PDO PnP IRP, MN func=%d\n",irpSp->MinorFunction);)

            return ForwardIrp(deviceExtension->LowerDevice, Irp);
    }

    return STATUS_SUCCESS;
}




NTSTATUS
ModemHandleSymbolicLink(
    PDEVICE_OBJECT      Pdo,
    PUNICODE_STRING     InterfaceName,
    BOOL                Create
    )

{

    UNICODE_STRING     SymbolicLink;
    DWORD              StringLength;
    NTSTATUS           Status;

    SymbolicLink.Length=0;
    SymbolicLink.MaximumLength=sizeof(WCHAR)*256;

    SymbolicLink.Buffer=ALLOCATE_PAGED_POOL(SymbolicLink.MaximumLength+sizeof(WCHAR));

    if (SymbolicLink.Buffer == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(
        SymbolicLink.Buffer,
        SymbolicLink.MaximumLength
        );

    RtlAppendUnicodeToString(
        &SymbolicLink,
        OBJECT_DIRECTORY
        );

    Status=IoGetDeviceProperty(
        Pdo,
        DevicePropertyFriendlyName,
        (ULONG)SymbolicLink.MaximumLength-SymbolicLink.Length,
        SymbolicLink.Buffer+(SymbolicLink.Length/sizeof(WCHAR)),
        &StringLength
        );

    if (!NT_SUCCESS(Status)) {

        FREE_POOL(SymbolicLink.Buffer);

        return Status;
    }

    SymbolicLink.Length+=(USHORT)StringLength-sizeof(UNICODE_NULL);

    if (Create) {

        UNICODE_STRING     PdoName;

        PdoName.Length=0;
        PdoName.MaximumLength=sizeof(WCHAR)*256;

        PdoName.Buffer=ALLOCATE_PAGED_POOL(PdoName.MaximumLength+sizeof(WCHAR));

        if (PdoName.Buffer == NULL) {

            FREE_POOL(SymbolicLink.Buffer);

            return STATUS_INSUFFICIENT_RESOURCES;
        }


        Status=IoGetDeviceProperty(
            Pdo,
            DevicePropertyPhysicalDeviceObjectName,
            (ULONG)PdoName.MaximumLength,
            PdoName.Buffer,
            &StringLength
            );

        if (!NT_SUCCESS(Status)) {

            FREE_POOL(SymbolicLink.Buffer);

            return Status;
        }

        PdoName.Length+=(USHORT)StringLength-sizeof(UNICODE_NULL);


        Status=IoCreateSymbolicLink(
            &SymbolicLink,
            &PdoName
            );

        FREE_POOL(PdoName.Buffer);


        Status=IoRegisterDeviceInterface(
            Pdo,
            &GUID_CLASS_MODEM,
            NULL,
            InterfaceName
            );


        if (NT_SUCCESS(Status)) {

            IoSetDeviceInterfaceState(
                InterfaceName,
                TRUE
                );

        }  else {

            D_ERROR(DbgPrint("MODEM: IoRegisterDeviceInterface() failed %08lx\n",Status);)
        }

    } else {

        if (InterfaceName->Buffer != NULL) {

            IoSetDeviceInterfaceState(
                InterfaceName,
                FALSE
                );

            RtlFreeUnicodeString(
                InterfaceName
                );
        }

        Status=IoDeleteSymbolicLink(
            &SymbolicLink
            );

    }

    FREE_POOL(SymbolicLink.Buffer);

    return Status;

}

NTSTATUS
IsDeviceMultifunctionEnumerated(
    PDEVICE_OBJECT   Pdo,
    PBOOLEAN          Match
    )

{
    NTSTATUS   Status;
    WCHAR      TempBuffer[20];
    ULONG      BytesUsed;

    Status=IoGetDeviceProperty(
        Pdo,
        DevicePropertyEnumeratorName,
        sizeof(TempBuffer),
        &TempBuffer,
        &BytesUsed
        );

    if (NT_SUCCESS(Status)) {

        *Match = (0 == wcscmp( TempBuffer,L"MF"));

    }

    return Status;


}




VOID
CleanUpOnRemove(
    PDEVICE_OBJECT    DeviceObject,
    PIRP              Irp
    )

{

    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);
    PIO_STACK_LOCATION nextSp = IoGetNextIrpStackLocation(Irp);
    NTSTATUS    status;

    KIRQL origIrql;
    PMASKSTATE thisMaskState;

    UINT               i;

    if (deviceExtension->OpenCount != 0) {
        //
        //  The modem is open, clean things up
        //

        PVOID    OldSystemBuffer;
        ULONG    MaskValue=0;

        for (i=0; i<2; i++) {

            thisMaskState = &deviceExtension->MaskStates[i];

            KeAcquireSpinLock(
                &deviceExtension->DeviceLock,
                &origIrql
                );


            if (thisMaskState->PassedDownWait != NULL) SetPassdownToComplete(thisMaskState);

            if (thisMaskState->ShuttledWait) {

                PIRP savedIrp = thisMaskState->ShuttledWait;

                thisMaskState->ShuttledWait = NULL;

                UniRundownShuttledWait(
                    deviceExtension,
                    &thisMaskState->ShuttledWait,
                    UNI_REFERENCE_NORMAL_PATH,
                    savedIrp,
                    origIrql,
                    STATUS_SUCCESS,
                    0ul
                    );

            } else {

                KeReleaseSpinLock(
                    &deviceExtension->DeviceLock,
                    origIrql
                    );

            }

        }


        //
        //  send down set mask to clear out ant wait masks
        //
        nextSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;
        nextSp->MinorFunction = 0UL;
        nextSp->Flags = irpSp->Flags;
        nextSp->Parameters.DeviceIoControl.OutputBufferLength = 0UL;
        nextSp->Parameters.DeviceIoControl.InputBufferLength = sizeof(ULONG);
        nextSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_SERIAL_SET_WAIT_MASK;
        nextSp->Parameters.DeviceIoControl.Type3InputBuffer = NULL;

        OldSystemBuffer=Irp->AssociatedIrp.SystemBuffer;

        Irp->AssociatedIrp.SystemBuffer = &MaskValue;


        status=WaitForLowerDriverToCompleteIrp(
            deviceExtension->AttachedDeviceObject,
            Irp,
            LEAVE_NEXT_AS_IS
            );



        //
        //  clear out any pending read or writes
        //
        nextSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;
        nextSp->MinorFunction = 0UL;
        nextSp->Flags = 0;
        nextSp->Parameters.DeviceIoControl.OutputBufferLength = 0UL;
        nextSp->Parameters.DeviceIoControl.InputBufferLength = sizeof(ULONG);
        nextSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_SERIAL_PURGE;
        nextSp->Parameters.DeviceIoControl.Type3InputBuffer = NULL;
        *((PULONG)Irp->AssociatedIrp.SystemBuffer) = SERIAL_PURGE_TXABORT | SERIAL_PURGE_RXABORT;

        status=WaitForLowerDriverToCompleteIrp(
            deviceExtension->AttachedDeviceObject,
            Irp,
            LEAVE_NEXT_AS_IS
            );



        Irp->AssociatedIrp.SystemBuffer= OldSystemBuffer;


        //
        //  clean out any ipc irps
        //
        for (i=0; i<2; i++ ) {

            UINT    OwnerClient;

            OwnerClient=i;

            EmptyIpcQueue(
                deviceExtension,
                &deviceExtension->IpcControl[OwnerClient].GetList
                );

            EmptyIpcQueue(
                deviceExtension,
                &deviceExtension->IpcControl[OwnerClient].PutList
                );


        }


        CompletePowerWait(
            DeviceObject,
            STATUS_CANCELLED
            );

        {

            PIRP    DleIrp=NULL;

            KeAcquireSpinLock(
                &deviceExtension->DeviceLock,
                &origIrql
                );

            if (deviceExtension->DleWaitIrp != NULL) {

                if (!HasIrpBeenCanceled(deviceExtension->DleWaitIrp)) {
                    //
                    //  Hasn't been canceled
                    //
                    DleIrp=deviceExtension->DleWaitIrp;

                    deviceExtension->DleWaitIrp=NULL;

                }
            }

            KeReleaseSpinLock(
                &deviceExtension->DeviceLock,
                origIrql
                );

            if (DleIrp != NULL) {

                DleIrp->IoStatus.Information=0;

                RemoveReferenceAndCompleteRequest(
                    DeviceObject,
                    DleIrp,
                    STATUS_SUCCESS
                    );
            }
        }

    }

    return;

}


BOOL
HasIrpBeenCanceled(
    PIRP    Irp
    )

{
    KIRQL    CancelIrql;
    BOOL     Canceled;

    IoAcquireCancelSpinLock(&CancelIrql);

    Canceled=Irp->Cancel;

    if (Irp->Cancel) {
        //
        //  canceled
        //
        Irp->IoStatus.Status=STATUS_CANCELLED;

    }

    IoSetCancelRoutine(
        Irp,
        NULL
        );


    IoReleaseCancelSpinLock(CancelIrql);

    return Canceled;

}



/*
 * Creates or update a new registry key value
 */

NTSTATUS
ModemSetRegistryKeyValue(
        IN PDEVICE_OBJECT   Pdo,
        IN ULONG            DevInstKeyType,
        IN PWCHAR           KeyNameString,
        IN ULONG            DataType,
        IN PVOID            Data,
        IN ULONG            DataLength)
{

    NTSTATUS ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    HANDLE Handle;
    UNICODE_STRING keyName;

    PAGED_CODE();

    D_ERROR(DbgPrint("MODEM: Current IRQL %d\n",KeGetCurrentIrql());)

    ntStatus = IoOpenDeviceRegistryKey(
            Pdo,
            DevInstKeyType,
            KEY_ALL_ACCESS,
            &Handle);

    if (NT_SUCCESS(ntStatus))
    {
        RtlInitUnicodeString(&keyName,KeyNameString);

        ntStatus = ZwSetValueKey(Handle,
                &keyName,
                0,
                DataType,
                Data,
                DataLength);

        if (!NT_SUCCESS(ntStatus))
        {
            D_ERROR(DbgPrint("MODEM: Could not set value, %08lx\n",ntStatus);)
        }

    } else
    {
            ZwClose(Handle);

            D_ERROR(DbgPrint("MODEM: Could not open dev registry key, %08lx\n",ntStatus);)
    }


    return ntStatus;
}


NTSTATUS 
ModemGetRegistryKeyValue (
    IN PDEVICE_OBJECT   Pdo,
    IN ULONG            DevInstKeyType,
    IN PWCHAR KeyNameString,
    IN PVOID Data,
    IN ULONG DataLength
    )
/*++

Routine Description:

    Reads a registry key value from an already opened registry key.
    
Arguments:

    Handle              Handle to the opened registry key
    
    KeyNameString       ANSI string to the desired key

    KeyNameStringLength Length of the KeyNameString

    Data                Buffer to place the key value in

    DataLength          Length of the data buffer

Return Value:

    STATUS_SUCCESS if all works, otherwise status of system call that
    went wrong.

--*/
{
    UNICODE_STRING              keyName;
    ULONG                       length;
    PKEY_VALUE_PARTIAL_INFORMATION     PartialInfo;

    NTSTATUS                    ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    HANDLE                      Handle;

    PAGED_CODE();


    ntStatus = IoOpenDeviceRegistryKey(
        Pdo,
        DevInstKeyType,
        STANDARD_RIGHTS_READ,
        &Handle
        );


    if (NT_SUCCESS(ntStatus)) {

        RtlInitUnicodeString (&keyName, KeyNameString);

        length = sizeof(KEY_VALUE_FULL_INFORMATION) + DataLength;

        PartialInfo = ALLOCATE_PAGED_POOL(length);

        if (PartialInfo) {
            ntStatus = ZwQueryValueKey (Handle,
                                        &keyName,
                                        KeyValuePartialInformation,
                                        PartialInfo,
                                        length,
                                        &length);

            if (NT_SUCCESS(ntStatus)) {
                //
                // If there is enough room in the data buffer, copy the output
                //

                if (DataLength >= PartialInfo->DataLength) {
                    RtlCopyMemory (Data,
                                   PartialInfo->Data,
                                   PartialInfo->DataLength);
                }
            } else {

                D_ERROR(DbgPrint("MODEM: could not query value, %08lx\n",ntStatus);)
            }

            FREE_POOL(PartialInfo);
        }

        ZwClose(Handle);

    } else {

        D_ERROR(DbgPrint("MODEM: could open device reg key, %08lx\n",ntStatus);)
    }

    return ntStatus;
}



NTSTATUS
IoCompletionSetEvent(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT pdoIoCompletedEvent
    )
{


#if DBG
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);

    UCHAR    *Pnp="PnP";
    UCHAR    *Power="Power";
    UCHAR    *Create="Create";
    UCHAR    *Close="Close";
    UCHAR    *Other="Other";


    PUCHAR   IrpType;

    switch(irpSp->MajorFunction) {

        case IRP_MJ_PNP:

            IrpType=Pnp;
            break;

        case IRP_MJ_CREATE:

            IrpType=Create;
            break;

        case IRP_MJ_CLOSE:

            IrpType=Close;
            break;

        default:

            IrpType=Other;
            break;

    }

    D_PNP(DbgPrint("MODEM: Setting event for %s wait, completed with %08lx\n",IrpType,Irp->IoStatus.Status);)
#endif

    KeSetEvent(pdoIoCompletedEvent, IO_NO_INCREMENT, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}



NTSTATUS
WaitForLowerDriverToCompleteIrp(
    PDEVICE_OBJECT    TargetDeviceObject,
    PIRP              Irp,
    BOOLEAN           CopyCurrentToNext
    )

{
    NTSTATUS         Status;
    KEVENT           Event;

#if DBG
    PIO_STACK_LOCATION  IrpSp=IoGetCurrentIrpStackLocation(Irp);
#endif

    KeInitializeEvent(
        &Event,
        NotificationEvent,
        FALSE
        );


    if (CopyCurrentToNext) {

        IoCopyCurrentIrpStackLocationToNext(Irp);
    }

    IoSetCompletionRoutine(
                 Irp,
                 IoCompletionSetEvent,
                 &Event,
                 TRUE,
                 TRUE,
                 TRUE
                 );

    Status = IoCallDriver(TargetDeviceObject, Irp);

    if (Status == STATUS_PENDING) {

         D_ERROR(DbgPrint("MODEM: Waiting for PDO\n");)

         KeWaitForSingleObject(
             &Event,
             Executive,
             KernelMode,
             FALSE,
             NULL
             );
    }

#if DBG
    ASSERT(IrpSp == IoGetCurrentIrpStackLocation(Irp));

    RtlZeroMemory(&Event,sizeof(Event));
#endif

    return Irp->IoStatus.Status;

}


NTSTATUS
QueryDeviceCaps(
    PDEVICE_OBJECT    Pdo,
    PDEVICE_CAPABILITIES   Capabilities
    )

{

    PDEVICE_OBJECT       deviceObject=Pdo;
    PIRP                 irp;
    PIO_STACK_LOCATION   NextSp;
    KEVENT               Event;
    NTSTATUS             Status;

    //
    // Get a pointer to the topmost device object in the stack of devices,
    // beginning with the deviceObject.
    //

    while (deviceObject->AttachedDevice) {
        deviceObject = deviceObject->AttachedDevice;
    }

    //
    // Begin by allocating the IRP for this request.  Do not charge quota to
    // the current process for this IRP.
    //

    irp = IoAllocateIrp(
#if DBG
              (UCHAR)(deviceObject->StackSize+1),
#else
              deviceObject->StackSize,
#endif
              FALSE
              );

    if (irp == NULL){

        return STATUS_INSUFFICIENT_RESOURCES;
    }

#if DBG
    {
        //
        //  setup a current stack location, so the debug code and see the MJ value
        //
        PIO_STACK_LOCATION   irpSp=IoGetNextIrpStackLocation(irp);;

        irpSp->MajorFunction=IRP_MJ_PNP;

        IoSetNextIrpStackLocation(irp);
    }
#endif

    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
    irp->IoStatus.Information = 0;

    RtlZeroMemory(Capabilities,sizeof(DEVICE_CAPABILITIES));

    Capabilities->Size=sizeof(DEVICE_CAPABILITIES);
    Capabilities->Version=1;
    Capabilities->Address=-1;
    Capabilities->UINumber=-1;

    //
    // Get a pointer to the stack location of the first driver which will be
    // invoked.  This is where the function codes and parameters are set.
    //

    NextSp = IoGetNextIrpStackLocation(irp);

    NextSp->MajorFunction=IRP_MJ_PNP;
    NextSp->MinorFunction=IRP_MN_QUERY_CAPABILITIES;
    NextSp->Parameters.DeviceCapabilities.Capabilities=Capabilities;


    Status=WaitForLowerDriverToCompleteIrp(
        deviceObject,
        irp,
        LEAVE_NEXT_AS_IS
        );


    IoFreeIrp(irp);

    return Status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\sys\modem\ioctl.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    ioctl.c

Abstract:

    This module contains the code that is very specific to the io control
    operations in the modem driver

Author:

    Anthony V. Ercolano 13-Aug-1995

Environment:

    Kernel mode

Revision History :

--*/

#include "precomp.h"


VOID
GetDleCancelRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
UniStopReceiveComplete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );




VOID
PowerWaitCancelRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
GetPropertiesHandler(
    PDEVICE_OBJECT    DeviceObject,
    PIRP              Irp
    );

#pragma alloc_text(PAGEUMDM,UniIoControl)
#pragma alloc_text(PAGEUMDM,WaveStopDpcHandler)
#pragma alloc_text(PAGEUMDM,PowerWaitCancelRoutine)

#pragma alloc_text(PAGE,GetPropertiesHandler)

#define WAVE_STOP_WRITE_COMPLETE  0
#define WAVE_STOP_READ_COMPLETE   1


NTSTATUS
UniIoControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

{

    PDEVICE_EXTENSION extension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS status;
    KIRQL origIrql;
    UINT    OwnerClient;

    //
    //  make sure the device is ready for irp's
    //
    status=CheckStateAndAddReference(
        DeviceObject,
        Irp
        );

    if (STATUS_SUCCESS != status) {
        //
        //  not accepting irp's. The irp has already been completed
        //
        return status;

    }

    OwnerClient=(UINT)((ULONG_PTR)irpSp->FileObject->FsContext);

    Irp->IoStatus.Information = 0L;

    status = STATUS_INVALID_PARAMETER;

    switch (irpSp->Parameters.DeviceIoControl.IoControlCode) {


        case IOCTL_MODEM_CHECK_FOR_MODEM:
            //
            //  used to determine if modem is already in this driver stack
            //
            status=STATUS_SUCCESS;

            break;


        case IOCTL_SERIAL_GET_WAIT_MASK:

            //
            // Just give back the saved mask from the maskstate.
            //

            if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
                sizeof(ULONG)) {

                status=STATUS_BUFFER_TOO_SMALL;

                break;


            }

            *((PULONG)Irp->AssociatedIrp.SystemBuffer) =
                extension->MaskStates[
                    irpSp->FileObject->FsContext?CONTROL_HANDLE:CLIENT_HANDLE
                    ].Mask;

            status=STATUS_SUCCESS;
            Irp->IoStatus.Information=sizeof(ULONG);

            break;


        //
        // We happen to know tht no lower level serial driver
        // implements config data.  We will process that
        // irp right here so that we return simply the
        // size needed for our modem settings.
        //
        case IOCTL_SERIAL_CONFIG_SIZE:

            if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
                sizeof(ULONG)) {

                status=STATUS_BUFFER_TOO_SMALL;

                break;
            }

            *((PULONG)Irp->AssociatedIrp.SystemBuffer) =
                extension->ModemSettings.dwRequiredSize +
                FIELD_OFFSET(
                    COMMCONFIG,
                    wcProviderData
                    );

            Irp->IoStatus.Information=sizeof(ULONG);
            status=STATUS_SUCCESS;

            break;


        case IOCTL_SERIAL_GET_COMMCONFIG: {

            KIRQL origIrql;
            LPCOMMCONFIG localConf = Irp->AssociatedIrp.SystemBuffer;

            if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <
                (extension->ModemSettings.dwRequiredSize +
                 FIELD_OFFSET(
                     COMMCONFIG,
                     wcProviderData
                     ))
               ) {

                status=STATUS_BUFFER_TOO_SMALL;

                break;
            }

            //
            // Take out the lock.  We don't want things to
            // change halfway through.
            //
            localConf->dwSize =
                extension->ModemSettings.dwRequiredSize +
                FIELD_OFFSET(
                    COMMCONFIG,
                    wcProviderData);
            localConf->wVersion = 1;
            localConf->wReserved = 0;
            localConf->dwProviderSubType = SERIAL_SP_MODEM;
            localConf->dwProviderOffset =
                FIELD_OFFSET(
                    COMMCONFIG,
                    wcProviderData
                    );
            localConf->dwProviderSize =
                extension->ModemSettings.dwRequiredSize;

            KeAcquireSpinLock(
                &extension->DeviceLock,
                &origIrql
                );
            RtlCopyMemory(
                &localConf->wcProviderData[0],
                &extension->ModemSettings,
                extension->ModemSettings.dwRequiredSize
                );
            KeReleaseSpinLock(
                &extension->DeviceLock,
                origIrql
                );

            status=STATUS_SUCCESS;
            Irp->IoStatus.Information = localConf->dwSize;

            break;

        }


        case IOCTL_SERIAL_GET_PROPERTIES: {

            if (irpSp->Parameters.DeviceIoControl.OutputBufferLength <

                 ((ULONG_PTR) &((PSERIAL_COMMPROP)0)->ProvChar ) + sizeof(MODEMDEVCAPS)) {


                if (irpSp->Parameters.DeviceIoControl.OutputBufferLength == sizeof(SERIAL_COMMPROP)) {
                    //
                    //  make the comm server people happy
                    //
                    //  the buffer was too small for a modem, but is the right size for a comm port,
                    //  just call the serial driver
                    //
                    status=UniNoCheckPassThrough(
                               DeviceObject,
                               Irp
                               );

                    RemoveReferenceForDispatch(DeviceObject);

                    return status;
                }

                status=STATUS_BUFFER_TOO_SMALL;

                break;

            }

            if (KeGetCurrentIrql() <= APC_LEVEL) {

                status=GetPropertiesHandler(
                           DeviceObject,
                           Irp
                           );

                RemoveReferenceForDispatch(DeviceObject);

                return status;

            } else {

                status=STATUS_INVALID_DEVICE_REQUEST;

                break;


            }


        }


        case IOCTL_MODEM_SET_DLE_MONITORING: {

            KIRQL origIrql;
            DWORD    Function;

            if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(ULONG)) {

                status=STATUS_BUFFER_TOO_SMALL;

                break;

            }

            Function=*((PULONG)Irp->AssociatedIrp.SystemBuffer);

            if (Function == MODEM_DLE_MONITORING_ON) {

                KeAcquireSpinLock(
                    &extension->DeviceLock,
                    &origIrql
                    );

                extension->DleMonitoringEnabled=TRUE;
                extension->DleCount=0;
                extension->DleMatchingState=DLE_STATE_IDLE;


                KeReleaseSpinLock(
                    &extension->DeviceLock,
                    origIrql
                    );


                status=STATUS_SUCCESS;

                break;


            }

            if (Function == MODEM_DLE_MONITORING_OFF) {

                PIRP   WaitIrp=NULL;

                KeAcquireSpinLock(
                    &extension->DeviceLock,
                    &origIrql
                    );


                if (extension->DleWaitIrp != NULL) {

                    if (!HasIrpBeenCanceled(extension->DleWaitIrp)) {

                        WaitIrp=extension->DleWaitIrp;

                        extension->DleWaitIrp=NULL;

                    }
                }

                extension->DleMonitoringEnabled=FALSE;
                extension->DleCount=0;
                extension->DleMatchingState=DLE_STATE_IDLE;


                KeReleaseSpinLock(
                    &extension->DeviceLock,
                    origIrql
                    );

                if (WaitIrp != NULL) {

                    WaitIrp->IoStatus.Information=0;

                    RemoveReferenceAndCompleteRequest(
                        DeviceObject,
                        WaitIrp,
                        STATUS_SUCCESS
                        );

                }

                status=STATUS_SUCCESS;

                break;

            }


            status=STATUS_INVALID_PARAMETER;

            break;
        }

        case IOCTL_MODEM_GET_DLE: {

            KIRQL origIrql;

            KeAcquireSpinLock(
                &extension->DeviceLock,
                &origIrql
                );


            if (!extension->DleMonitoringEnabled) {
                //
                //  make sure monitoring is on
                //
                KeReleaseSpinLock(
                    &extension->DeviceLock,
                    origIrql
                    );

                status=STATUS_INVALID_PARAMETER;

                break;

            } else {

                PIRP    OldIrp=NULL;

                OldIrp=(PIRP)InterlockedExchangePointer(&extension->DleWaitIrp,NULL);

                if (OldIrp != NULL) {

                    if (HasIrpBeenCanceled(OldIrp)) {
                        //
                        //  been canceled, cancel routine will complete
                        //
                        OldIrp=NULL;
                    }
                }


                if (extension->DleCount > 0) {
                    //
                    //  Data availible,  complete now
                    //
                    DWORD   BytesToTransfer;

                    BytesToTransfer = (extension->DleCount < irpSp->Parameters.DeviceIoControl.OutputBufferLength) ?
                                          extension->DleCount : irpSp->Parameters.DeviceIoControl.OutputBufferLength;


                    RtlCopyMemory(
                        Irp->AssociatedIrp.SystemBuffer,
                        extension->DleBuffer,
                        BytesToTransfer
                        );


                    extension->DleCount-=BytesToTransfer;

                    KeReleaseSpinLock(
                        &extension->DeviceLock,
                        origIrql
                        );

                    status=STATUS_SUCCESS;

                    Irp->IoStatus.Information=BytesToTransfer;

                    if (OldIrp != NULL) {

                        OldIrp->IoStatus.Information=0;

                        RemoveReferenceAndCompleteRequest(
                            DeviceObject,
                            OldIrp,
                            STATUS_CANCELLED
                            );
                    }


                    break;


                } else {
                    //
                    //  no data pend
                    //
                    KIRQL   CancelIrql;

                    IoMarkIrpPending(Irp);

                    Irp->IoStatus.Status = STATUS_PENDING;
                    status=STATUS_PENDING;


                    IoAcquireCancelSpinLock(&CancelIrql);

                    IoSetCancelRoutine(
                        Irp,
                        GetDleCancelRoutine
                        );

                    extension->DleWaitIrp=Irp;

                    IoReleaseCancelSpinLock(CancelIrql);



#if DBG
                    Irp=NULL;
#endif

                    KeReleaseSpinLock(
                        &extension->DeviceLock,
                        origIrql
                        );

                    if (OldIrp != NULL) {

                        OldIrp->IoStatus.Information=0;

                        RemoveReferenceAndCompleteRequest(
                            DeviceObject,
                            OldIrp,
                            STATUS_CANCELLED
                            );
                    }



                    break;

                }
            }

            KeReleaseSpinLock(
                &extension->DeviceLock,
                origIrql
                );


            status=STATUS_INVALID_PARAMETER;

            break;
        }

        case IOCTL_MODEM_SET_DLE_SHIELDING: {

            KIRQL origIrql;
            DWORD    Function;

            if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(ULONG)) {

                status=STATUS_BUFFER_TOO_SMALL;

                break;
            }

            Function=*((PULONG)Irp->AssociatedIrp.SystemBuffer);

            if (Function == MODEM_DLE_SHIELDING_ON) {

                KeAcquireSpinLock(
                    &extension->DeviceLock,
                    &origIrql
                    );

                extension->DleWriteShielding=TRUE;

                KeReleaseSpinLock(
                    &extension->DeviceLock,
                    origIrql
                    );

                status=STATUS_SUCCESS;

                break;


            }

            if (Function == MODEM_DLE_SHIELDING_OFF) {

                PKDEVICE_QUEUE_ENTRY        QueueEntry;

                KeAcquireSpinLock(
                    &extension->DeviceLock,
                    &origIrql
                    );

                extension->DleWriteShielding=FALSE;

                KeReleaseSpinLock(
                    &extension->DeviceLock,
                    origIrql
                    );

                CleanUpQueuedIrps(
                    &extension->WriteIrpControl,
                    STATUS_SUCCESS
                    );


                status=STATUS_SUCCESS;

                break;


            }

            status=STATUS_INVALID_PARAMETER;


            break;
        }


        case IOCTL_MODEM_STOP_WAVE_RECEIVE: {

            KIRQL origIrql;
            DWORD    Function;

            PIO_STACK_LOCATION nextSp = IoGetNextIrpStackLocation(Irp);

            if (irpSp->Parameters.DeviceIoControl.InputBufferLength < 1) {

                status=STATUS_BUFFER_TOO_SMALL;

                break;

            }

            extension->WaveStopState=WAVE_STOP_WRITE_COMPLETE;

            nextSp->MajorFunction = IRP_MJ_WRITE;
            nextSp->MinorFunction = 0;
            nextSp->Parameters.Write.Length = irpSp->Parameters.DeviceIoControl.InputBufferLength;

            IoSetCompletionRoutine(
                Irp,
                UniStopReceiveComplete,
                extension,
                TRUE,
                TRUE,
                TRUE
                );

            IoMarkIrpPending(Irp);

            status=STATUS_PENDING;
            Irp->IoStatus.Status = STATUS_PENDING;

            IoCallDriver(
                extension->AttachedDeviceObject,
                Irp
                );

            break;
        }

        case IOCTL_MODEM_SEND_GET_MESSAGE: {

            PMODEM_MESSAGE ModemMessage=Irp->AssociatedIrp.SystemBuffer;


            if (extension->OpenCount < 2) {
                //
                //  only send if another open instance that could be listening
                //
                status=STATUS_INVALID_PARAMETER;
                D_ERROR(DbgPrint("MODEM: SendGetMessage less than 2 handles\n");)
                break;
            }

            if (OwnerClient != CLIENT_HANDLE) {
                //
                //  only WAVE client should send this
                //
                status=STATUS_INVALID_PARAMETER;
                D_ERROR(DbgPrint("MODEM: SendGetMessage not from client\n");)
                break;
            }

            if (extension->IpcServerRunning == 0) {

                status=STATUS_INVALID_PARAMETER;
                D_ERROR(DbgPrint("MODEM: SendGetMessage server not running\n");)
                break;
            }

            if (irpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(MODEM_MESSAGE )) {

                status=STATUS_BUFFER_TOO_SMALL;
                D_ERROR(DbgPrint("MODEM: SendGetMessage buffer too small\n");)
                break;
            }


            //
            //  next request id
            //
            extension->IpcControl[OwnerClient].CurrentRequestId++;

            ModemMessage->SessionId=extension->IpcControl[OwnerClient].CurrentSession;
            ModemMessage->RequestId=extension->IpcControl[OwnerClient].CurrentRequestId;

            status=STATUS_PENDING;

            QueueMessageIrp(
                extension,
                Irp
                );

            break;

        }

        case IOCTL_MODEM_SEND_LOOPBACK_MESSAGE: {

            PMODEM_MESSAGE ModemMessage=Irp->AssociatedIrp.SystemBuffer;

            if (OwnerClient != CONTROL_HANDLE) {
                //
                //  only TSP should send this
                //
                status=STATUS_INVALID_PARAMETER;
                D_ERROR(DbgPrint("MODEM: Send Loopback message not from tsp\n");)
                break;
            }


            if (irpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(MODEM_MESSAGE )) {

                status=STATUS_BUFFER_TOO_SMALL;
                D_ERROR(DbgPrint("MODEM: Send Loopback message buffer too small\n");)
                break;
            }

            extension->IpcServerRunning=FALSE;
            //
            //  set these to be bogus since no one will be listening
            //
            ModemMessage->SessionId=-1;
            ModemMessage->RequestId=-1;

            status=STATUS_PENDING;

            QueueLoopbackMessageIrp(
                extension,
                Irp
                );

            EmptyIpcQueue(
                    extension,
                    &extension->IpcControl[CLIENT_HANDLE].GetList
                    );


            EmptyIpcQueue(
                extension,
                &extension->IpcControl[CLIENT_HANDLE].PutList
                );

            break;

        }


        case IOCTL_MODEM_SEND_MESSAGE: {

            PMODEM_MESSAGE ModemMessage=Irp->AssociatedIrp.SystemBuffer;

            if (OwnerClient != CONTROL_HANDLE) {
                //
                //  only TSP should send this
                //
                status=STATUS_INVALID_PARAMETER;
                D_ERROR(DbgPrint("MODEM: Sendmessage not from tsp\n");)
                break;
            }


            if (extension->OpenCount < 2) {
                //
                //  only send if another open instance that could be listening
                //
                status=STATUS_INVALID_PARAMETER;
                D_ERROR(DbgPrint("MODEM: Sendmessage not two owners\n");)
                break;
            }

            if (irpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(MODEM_MESSAGE )) {

                status=STATUS_BUFFER_TOO_SMALL;
                D_ERROR(DbgPrint("MODEM: Sendmessage buffer too small\n");)
                break;
            }

            if ((ModemMessage->SessionId != extension->IpcControl[CLIENT_HANDLE].CurrentSession)
                ||
                (ModemMessage->RequestId != extension->IpcControl[CLIENT_HANDLE].CurrentRequestId)) {

                status=STATUS_UNSUCCESSFUL;
                D_ERROR(DbgPrint("MODEM: Sendmessage Not current\n");)
                break;
            }

            status=STATUS_PENDING;

            QueueMessageIrp(
                extension,
                Irp
                );

            break;

        }

        case IOCTL_MODEM_GET_MESSAGE: {

            status=STATUS_PENDING;

            QueueMessageIrp(
                extension,
                Irp
                );

            break;

        }

        case IOCTL_CANCEL_GET_SEND_MESSAGE: {

            EmptyIpcQueue(
                extension,
                &extension->IpcControl[OwnerClient].GetList
                );


            EmptyIpcQueue(
                extension,
                &extension->IpcControl[OwnerClient].PutList
                );

            if (OwnerClient == CONTROL_HANDLE) {
                //
                //  clear out the client as well
                //
                EmptyIpcQueue(
                    extension,
                    &extension->IpcControl[CLIENT_HANDLE].GetList
                    );


                EmptyIpcQueue(
                    extension,
                    &extension->IpcControl[CLIENT_HANDLE].PutList
                    );

            }

            status=STATUS_SUCCESS;

            break;

        }

        case IOCTL_SET_SERVER_STATE: {

            ULONG ServerState;

            if (OwnerClient != CONTROL_HANDLE) {
                //
                //  only TSP should send this
                //
                status=STATUS_INVALID_PARAMETER;
                D_ERROR(DbgPrint("MODEM: Set Server state not from tsp\n");)
                break;
            }


            if (irpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(ULONG)) {

                status=STATUS_BUFFER_TOO_SMALL;
                D_ERROR(DbgPrint("MODEM: Set sever State buffer too small\n");)
                break;
            }

            ServerState = *(PULONG)Irp->AssociatedIrp.SystemBuffer;

            extension->IpcServerRunning=ServerState;

            status=STATUS_SUCCESS;

            break;
        }

        case IOCTL_MODEM_SET_MIN_POWER: {

            KIRQL origIrql;
            DWORD    Function;

            if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(ULONG)) {

                status=STATUS_BUFFER_TOO_SMALL;

                break;
            }

            Function=*((PULONG)Irp->AssociatedIrp.SystemBuffer);

            extension->MinSystemPowerState=Function ? PowerSystemHibernate : PowerSystemWorking;

            if (Function == 0) {
                //
                //  active connection
                //
                extension->PowerSystemState=PoRegisterSystemState(
                    extension->PowerSystemState,
                    ES_SYSTEM_REQUIRED | ES_CONTINUOUS
                    );

            } else {
                //
                //  no connection
                //

                if (extension->PowerSystemState != NULL) {

                    PoUnregisterSystemState(
                        extension->PowerSystemState
                        );

                    extension->PowerSystemState=NULL;
                }

            }

            status= STATUS_SUCCESS;

            break;

        }

        case IOCTL_MODEM_WATCH_FOR_RESUME: {

            KIRQL    CancelIrql;
            KIRQL    origIrql;
            DWORD    Function;
            PIRP     WakeIrp;

            if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
                sizeof(ULONG)) {

                status=STATUS_BUFFER_TOO_SMALL;

                break;
            }

            Function=*((PULONG)Irp->AssociatedIrp.SystemBuffer);


            KeAcquireSpinLock(
                &extension->DeviceLock,
                &origIrql
                );

            if (Function == 0) {
                //
                //  clear pending irp
                //
                WakeIrp=(PIRP)InterlockedExchangePointer(&extension->WakeUpIrp,NULL);

                status=STATUS_SUCCESS;

            } else {
                //
                //  replace old one with this one
                //

                IoMarkIrpPending(Irp);

                Irp->IoStatus.Status = STATUS_PENDING;

                status=STATUS_PENDING;

                IoAcquireCancelSpinLock(&CancelIrql);

                IoSetCancelRoutine(
                    Irp,
                    PowerWaitCancelRoutine
                    );

                IoReleaseCancelSpinLock(CancelIrql);

                WakeIrp=(PIRP)InterlockedExchangePointer(&extension->WakeUpIrp,Irp);


            }

            if (WakeIrp != NULL) {
                //
                // an irp was already waiting
                //
                if (HasIrpBeenCanceled(WakeIrp)) {
                    //
                    //  been canceled, cancel routine will complete
                    //
                    WakeIrp=NULL;
                }
            }

            KeReleaseSpinLock(
                &extension->DeviceLock,
                origIrql
                );


            if (WakeIrp != NULL) {

                WakeIrp->IoStatus.Information=0;

                RemoveReferenceAndCompleteRequest(
                    DeviceObject,
                    WakeIrp,
                    STATUS_CANCELLED
                    );


            }

            break;

        }


        case IOCTL_SERIAL_GET_STATS:
        case IOCTL_SERIAL_CLEAR_STATS:

        case IOCTL_SERIAL_GET_BAUD_RATE:
        case IOCTL_SERIAL_GET_LINE_CONTROL:
        case IOCTL_SERIAL_GET_TIMEOUTS:
        case IOCTL_SERIAL_GET_CHARS:
        case IOCTL_SERIAL_SET_QUEUE_SIZE:
        case IOCTL_SERIAL_GET_HANDFLOW:
        case IOCTL_SERIAL_GET_MODEMSTATUS:
        case IOCTL_SERIAL_GET_DTRRTS:
        case IOCTL_SERIAL_GET_COMMSTATUS:

            //
            // Will filter out any settings that the owning handle has
            // silently set.
            //
            status=UniNoCheckPassThrough(
                       DeviceObject,
                       Irp
                       );

            RemoveReferenceForDispatch(DeviceObject);

            return status;


        case IOCTL_SERIAL_PURGE: {

            ULONG   PurgeFlags;

            if (irpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(ULONG)) {

                D_ERROR(DbgPrint("MODEM: Purge Buffer to small\n");)
                status=STATUS_BUFFER_TOO_SMALL;

                break;
            }

            PurgeFlags=*((PULONG)Irp->AssociatedIrp.SystemBuffer);

            if (PurgeFlags & (SERIAL_PURGE_TXABORT | SERIAL_PURGE_TXCLEAR)) {

                MarkQueueToEmpty(
                    &extension->WriteIrpControl
                    );
            }

            if (PurgeFlags & (SERIAL_PURGE_RXABORT | SERIAL_PURGE_RXCLEAR)) {

                MarkQueueToEmpty(
                    &extension->ReadIrpControl
                    );
            }
        }


        case IOCTL_SERIAL_SET_COMMCONFIG :
        case IOCTL_SERIAL_SET_BAUD_RATE :
        case IOCTL_SERIAL_SET_LINE_CONTROL:
        case IOCTL_SERIAL_SET_TIMEOUTS:
        case IOCTL_SERIAL_SET_CHARS:
        case IOCTL_SERIAL_SET_DTR:
        case IOCTL_SERIAL_CLR_DTR:
        case IOCTL_SERIAL_RESET_DEVICE:
        case IOCTL_SERIAL_SET_RTS:
        case IOCTL_SERIAL_CLR_RTS:
        case IOCTL_SERIAL_SET_XOFF:
        case IOCTL_SERIAL_SET_XON:
        case IOCTL_SERIAL_SET_BREAK_ON:
        case IOCTL_SERIAL_SET_BREAK_OFF:
        case IOCTL_SERIAL_SET_WAIT_MASK:
        case IOCTL_SERIAL_WAIT_ON_MASK:
        case IOCTL_SERIAL_IMMEDIATE_CHAR:

        case IOCTL_SERIAL_SET_HANDFLOW:
        case IOCTL_SERIAL_XOFF_COUNTER:
        case IOCTL_SERIAL_LSRMST_INSERT:

        default: {

            if (irpSp->FileObject->FsContext) {

                status=UniSniffOwnerSettings(
                           DeviceObject,
                           Irp
                           );

            } else {

                status=UniCheckPassThrough(
                           DeviceObject,
                           Irp
                           );

            }

            RemoveReferenceForDispatch(DeviceObject);

            return status;

        }
    }

    if (status != STATUS_PENDING) {
        //
        //  not pending, complete it now
        //
        RemoveReferenceAndCompleteRequest(
            DeviceObject,
            Irp,
            status
            );



    }

    RemoveReferenceForDispatch(DeviceObject);

    return status;


}

NTSTATUS
GetPropertiesHandler(
    PDEVICE_OBJECT    DeviceObject,
    PIRP              Irp
    )

{

    PDEVICE_EXTENSION extension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS status;

    PSERIAL_COMMPROP localProp = Irp->AssociatedIrp.SystemBuffer;
    PMODEMDEVCAPS    localCaps = (PVOID)&localProp->ProvChar[0];
    //
    // We want to get the properties for modem.
    //

    //
    // It has to be at least the size of the commprop as
    // well as the non-variable lenght modem devcaps.
    //


    ULONG maxName;
    PKEY_VALUE_PARTIAL_INFORMATION partialInf;


    //
    //  send the irp down to the lower serial driver now
    //
    status=WaitForLowerDriverToCompleteIrp(
        extension->LowerDevice,
        Irp,
        COPY_CURRENT_TO_NEXT
        );

    if (NT_SUCCESS(status)) {
        //
        //  got a good result from the lower driver, fill in the specific info
        //

        *localCaps = extension->ModemDevCaps;

        localCaps->dwModemManufacturerSize = 0;
        localCaps->dwModemModelSize = 0;
        localCaps->dwModemVersionSize = 0;

        //
        // Attempt to get each one of the strings from the
        // registry if we need to AND we have any room for it.
        //

        //
        // Allocate some pool to hold the largest
        // amount of names.  Note that it has to fit
        // at the end of a partial information structure.
        //

        maxName = extension->ModemDevCaps.dwModemManufacturerSize;

        if (extension->ModemDevCaps.dwModemModelSize > maxName) {

            maxName = extension->ModemDevCaps.dwModemModelSize;
        }

        if (extension->ModemDevCaps.dwModemVersionSize >  maxName) {

            maxName = extension->ModemDevCaps.dwModemVersionSize;
        }

        maxName+=sizeof(UNICODE_NULL);

        partialInf = ALLOCATE_PAGED_POOL(
                         sizeof(KEY_VALUE_PARTIAL_INFORMATION) +
                             maxName
                         );

        if (partialInf) {

            //
            // Open up the instance and
            //

            HANDLE instanceHandle;
            ULONG currentOffset;
            ULONG endingOffset;
            ACCESS_MASK accessMask = FILE_ALL_ACCESS;
            PUCHAR currentLocation = Irp->AssociatedIrp.SystemBuffer;

            endingOffset = irpSp->Parameters.DeviceIoControl.OutputBufferLength;

            currentOffset = FIELD_OFFSET(
                                SERIAL_COMMPROP,
                                ProvChar
                                );

            currentOffset += FIELD_OFFSET(
                                 MODEMDEVCAPS,
                                 abVariablePortion
                                 );

            currentLocation += currentOffset;


            if (NT_SUCCESS(IoOpenDeviceRegistryKey(
                extension->Pdo,
                PLUGPLAY_REGKEY_DRIVER,
                accessMask,
                &instanceHandle
                ))) {


                UNICODE_STRING valueEntryName;
                ULONG junkLength;

                //
                // If we can fit in the manufactureing string
                // put it in.
                //

                if ((extension->ModemDevCaps.dwModemManufacturerSize != 0) &&
                    ((currentOffset +
                      extension->ModemDevCaps.dwModemManufacturerSize) <= endingOffset )) {


                    RtlInitUnicodeString(
                        &valueEntryName,
                        L"Manufacturer"
                        );

                    status=ZwQueryValueKey(
                        instanceHandle,
                        &valueEntryName,
                        KeyValuePartialInformation,
                        partialInf,
                        (sizeof(KEY_VALUE_PARTIAL_INFORMATION)-sizeof(UCHAR))
                          + extension->ModemDevCaps.dwModemManufacturerSize+sizeof(UNICODE_NULL),
                        &junkLength
                        );


                    if ((status == STATUS_SUCCESS) && (partialInf->DataLength >= sizeof(UNICODE_NULL))) {

                        ULONG    LengthOfString=partialInf->DataLength-sizeof(UNICODE_NULL);

                        RtlCopyMemory(
                            currentLocation,
                            &partialInf->Data[0],
                            LengthOfString
                            );

                        localCaps->dwModemManufacturerSize = LengthOfString;

                        localCaps->dwModemManufacturerOffset =
                            (DWORD)((BYTE *)currentLocation -
                            (BYTE *)localCaps);

                        localCaps->dwActualSize += localCaps->dwModemManufacturerSize;

                        currentOffset +=  localCaps->dwModemManufacturerSize;

                        currentLocation += localCaps->dwModemManufacturerSize;

                    }

                }

                if ((extension->ModemDevCaps.dwModemModelSize != 0)
                    &&
                    ((currentOffset + extension->ModemDevCaps.dwModemModelSize) <= endingOffset )) {

                    RtlInitUnicodeString(
                        &valueEntryName,
                        L"Model"
                        );

                    status=ZwQueryValueKey(
                            instanceHandle,
                            &valueEntryName,
                            KeyValuePartialInformation,
                            partialInf,
                            (sizeof(KEY_VALUE_PARTIAL_INFORMATION)- sizeof(UCHAR))
                              + extension->ModemDevCaps.dwModemModelSize + sizeof(UNICODE_NULL),
                            &junkLength
                            );

                    if ((status == STATUS_SUCCESS) && (partialInf->DataLength >= sizeof(UNICODE_NULL))) {

                        ULONG    LengthOfString=partialInf->DataLength-sizeof(UNICODE_NULL);

                        RtlCopyMemory(
                            currentLocation,
                            &partialInf->Data[0],
                            LengthOfString
                            );

                        localCaps->dwModemModelSize = LengthOfString;

                        localCaps->dwModemModelOffset =
                            (DWORD)((BYTE *)currentLocation -
                            (BYTE *)localCaps);

                        localCaps->dwActualSize += localCaps->dwModemModelSize;

                        currentOffset += localCaps->dwModemModelSize;

                        currentLocation +=  localCaps->dwModemModelSize;

                    }

                }
                if ((extension->ModemDevCaps.dwModemVersionSize  != 0)
                     &&
                    ((currentOffset + extension->ModemDevCaps.dwModemVersionSize) <= endingOffset)) {

                    RtlInitUnicodeString(
                        &valueEntryName,
                        L"Version"
                        );

                    status=ZwQueryValueKey(
                            instanceHandle,
                            &valueEntryName,
                            KeyValuePartialInformation,
                            partialInf,
                            (sizeof(KEY_VALUE_PARTIAL_INFORMATION)- sizeof(UCHAR))
                              + extension->ModemDevCaps.dwModemVersionSize+sizeof(UNICODE_NULL),
                            &junkLength
                            );

                    if ((status == STATUS_SUCCESS) && (partialInf->DataLength >= sizeof(UNICODE_NULL))) {

                        ULONG    LengthOfString=partialInf->DataLength-sizeof(UNICODE_NULL);

                        RtlCopyMemory(
                            currentLocation,
                            &partialInf->Data[0],
                            LengthOfString
                            );

                        localCaps->dwModemVersionSize = LengthOfString;

                        localCaps->dwModemVersionOffset =
                            (DWORD)((BYTE *)currentLocation -
                            (BYTE *)localCaps);

                        localCaps->dwActualSize += localCaps->dwModemVersionSize;

                        currentOffset +=  localCaps->dwModemVersionSize;

                        currentLocation += localCaps->dwModemVersionSize;

                    }

                }
                ZwClose(instanceHandle);

            }

            FREE_POOL(partialInf);

        } else {

            D_ERROR(DbgPrint("MODEM: lower driver falied get com prop, %08lx\n",status);)
        }

        localProp->ProvSubType = SERIAL_SP_MODEM;
        localProp->PacketLength = (USHORT)(FIELD_OFFSET(SERIAL_COMMPROP,ProvChar)+localCaps->dwActualSize);

        Irp->IoStatus.Information = localProp->PacketLength;

#if DBG
        {
            PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);

            ASSERT(Irp->IoStatus.Information <= irpSp->Parameters.DeviceIoControl.OutputBufferLength);

        }
#endif
    }

    status=Irp->IoStatus.Status;

    RemoveReferenceAndCompleteRequest(
        DeviceObject,
        Irp,
        Irp->IoStatus.Status
        );

    return status;

}





VOID
GetDleCancelRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject - The device object of the modem.

    Irp - This is the irp to cancel.

Return Value:

    None.

--*/

{

    PDEVICE_EXTENSION DeviceExtension = DeviceObject->DeviceExtension;
    KIRQL origIrql;

    IoReleaseCancelSpinLock(
        Irp->CancelIrql
        );


    KeAcquireSpinLock(
        &DeviceExtension->DeviceLock,
        &origIrql
        );


    if (DeviceExtension->DleWaitIrp==Irp) {
        //
        //  still pending, clear it out
        //
        DeviceExtension->DleWaitIrp=NULL;

    }

    KeReleaseSpinLock(
        &DeviceExtension->DeviceLock,
        origIrql
        );

    Irp->IoStatus.Information=0;

    RemoveReferenceAndCompleteRequest(
        DeviceObject,
        Irp,
        STATUS_CANCELLED
        );


    return;

}







NTSTATUS
UniStopReceiveComplete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:


Arguments:

    DeviceObject - Pointer to the device object for the modem.

    Irp - Pointer to the IRP for the current request.

    Context - Really a pointer to the Extension.

Return Value:

    Always return status_success.

--*/

{
    PDEVICE_EXTENSION DeviceExtension = DeviceObject->DeviceExtension;

    KeInsertQueueDpc(
        &DeviceExtension->WaveStopDpc,
        Irp,
        DeviceExtension
        );

    return STATUS_MORE_PROCESSING_REQUIRED;

}




VOID
WaveStopDpcHandler(
    PKDPC  Dpc,
    PVOID  Context,
    PVOID  SysArg1,
    PVOID  SysArg2
    )

{

    PDEVICE_EXTENSION DeviceExtension = SysArg2;
    PIRP              Irp=SysArg1;

    PIO_STACK_LOCATION nextSp = IoGetNextIrpStackLocation(Irp);



    if (NT_SUCCESS(Irp->IoStatus.Status)) {

        switch (DeviceExtension->WaveStopState) {

            case WAVE_STOP_WRITE_COMPLETE: {

                DeviceExtension->WaveStopState=WAVE_STOP_READ_COMPLETE;

                nextSp->MajorFunction = IRP_MJ_READ;
                nextSp->MinorFunction = 0;
                nextSp->Parameters.Read.Length = 1;

                IoSetCompletionRoutine(
                    Irp,
                    UniStopReceiveComplete,
                    DeviceExtension,
                    TRUE,
                    TRUE,
                    TRUE
                    );

                IoCallDriver(
                    DeviceExtension->AttachedDeviceObject,
                    Irp
                    );

                break;

            }

            case WAVE_STOP_READ_COMPLETE: {

                PUCHAR    Buffer=Irp->AssociatedIrp.SystemBuffer;

                if (Irp->IoStatus.Information == 1) {

                    KeAcquireSpinLockAtDpcLevel(
                        &DeviceExtension->DeviceLock
                        );

                    if (DeviceExtension->DleMatchingState == DLE_STATE_IDLE) {

                        if (*Buffer == DLE_CHAR) {
                            //
                            //  found a DLE
                            //
                            DeviceExtension->DleMatchingState = DLE_STATE_WAIT_FOR_NEXT_CHAR;

                        }

                    } else {

                        DeviceExtension->DleMatchingState = DLE_STATE_IDLE;

                        //
                        //  store the dle any way
                        //
                        if ((DeviceExtension->DleCount < MAX_DLE_BUFFER_SIZE)) {

                            DeviceExtension->DleBuffer[DeviceExtension->DleCount]=*Buffer;
                            DeviceExtension->DleCount++;
                        }


                        if (*Buffer == 0x03) {
                            //
                            //  got dle etx, were out'a here
                            //
                            D_TRACE(DbgPrint("Modem: stop wave Got Dle Etx\n");)

                            KeReleaseSpinLockFromDpcLevel(
                                &DeviceExtension->DeviceLock
                                );

                            Irp->IoStatus.Information=0;

                            RemoveReferenceAndCompleteRequest(
                                DeviceExtension->DeviceObject,
                                Irp,
                                STATUS_SUCCESS
                                );

                            break;

                        }
                    }

                    KeReleaseSpinLockFromDpcLevel(
                        &DeviceExtension->DeviceLock
                        );


                    nextSp->MajorFunction = IRP_MJ_READ;
                    nextSp->MinorFunction = 0;
                    nextSp->Parameters.Read.Length = 1;

                    IoSetCompletionRoutine(
                        Irp,
                        UniStopReceiveComplete,
                        DeviceExtension,
                        TRUE,
                        TRUE,
                        TRUE
                        );

                    IoCallDriver(
                        DeviceExtension->AttachedDeviceObject,
                        Irp
                        );

                    break;
                }

                //
                //  did not get any bytes, must be a time out, did not dle ext
                //


                Irp->IoStatus.Information=0;

                RemoveReferenceAndCompleteRequest(
                    DeviceExtension->DeviceObject,
                    Irp,
                    STATUS_UNSUCCESSFUL
                    );

                break;
            }

            default:

            break;

        }

    } else {
        //
        //  irp failed, just complete it now
        //

        RemoveReferenceAndCompleteRequest(
            DeviceExtension->DeviceObject,
            Irp,
            Irp->IoStatus.Status
            );
    }


    HandleDleIrp(
        DeviceExtension
        );



    return;

}



VOID
PowerWaitCancelRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject - The device object of the modem.

    Irp - This is the irp to cancel.

Return Value:

    None.

--*/
{

    PDEVICE_EXTENSION DeviceExtension = DeviceObject->DeviceExtension;
    KIRQL origIrql;

    IoReleaseCancelSpinLock(
        Irp->CancelIrql
        );


    KeAcquireSpinLock(
        &DeviceExtension->DeviceLock,
        &origIrql
        );

    if (Irp->IoStatus.Status == STATUS_PENDING) {
        //
        //  irp is still in queue
        //
        DeviceExtension->WakeUpIrp=NULL;
    }

    KeReleaseSpinLock(
        &DeviceExtension->DeviceLock,
        origIrql
        );

    Irp->IoStatus.Information=0;

    RemoveReferenceAndCompleteRequest(
        DeviceObject,
        Irp,
        STATUS_CANCELLED
        );


    return;



}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\sys\modem\precomp.h ===
#include <stddef.h>
#include <stdarg.h>
#include <stdio.h>
#define INITGUID
#include <ntddk.h>
#include <ntddser.h>
#include <ntddmodm.h>
#include <wmilib.h>
#include "mdm.h"
#include "mdmlog.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\sys\modem\power.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    initunlo.c

Abstract:

    This module contains the code that is very specific to initialization
    and unload operations in the modem driver

Author:

    Anthony V. Ercolano 13-Aug-1995

Environment:

    Kernel mode

Revision History :

--*/

#include "precomp.h"

#pragma alloc_text(PAGE,ModemPower)


VOID
CompletePowerWait(
    PDEVICE_OBJECT   DeviceObject,
    NTSTATUS         Status
    )

{

    PDEVICE_EXTENSION extension = DeviceObject->DeviceExtension;
    KIRQL    origIrql;
    KIRQL    CancelIrql;
    PIRP     WakeIrp;



    KeAcquireSpinLock(
        &extension->DeviceLock,
        &origIrql
        );

    WakeIrp=(PIRP)InterlockedExchangePointer(&extension->WakeUpIrp,NULL);

    if (WakeIrp != NULL) {

        D_POWER(DbgPrint("MODEM: CompletePowerWait\n");)

        if (HasIrpBeenCanceled(WakeIrp)) {
            //
            //  Canceled, let canceled routine deal with it
            //
            WakeIrp=NULL;
        }
    }


    KeReleaseSpinLock(
        &extension->DeviceLock,
        origIrql
        );


    if (WakeIrp != NULL) {

        WakeIrp->IoStatus.Information=0;

        RemoveReferenceAndCompleteRequest(
            DeviceObject,
            WakeIrp,
            Status
            );


    }

    return;

}


NTSTATUS
PowerIrpCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID          Context
    )
{
    PDEVICE_EXTENSION  deviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);
    //
    //  the device set power irp has completed
    //

    D_POWER(DbgPrint("MODEM: PowerIrpComplete DevicePowerState, completed with %08lx\n",Irp->IoStatus.Status);)

    if (NT_SUCCESS(Irp->IoStatus.Status)) {

        if ((irpSp->Parameters.Power.State.DeviceState == PowerDeviceD0) && (deviceExtension->LastDevicePowerState != PowerDeviceD0)) {

            CompletePowerWait(
                DeviceObject,
                STATUS_SUCCESS
                );

        }

        deviceExtension->LastDevicePowerState=irpSp->Parameters.Power.State.DeviceState;
    }


    RemoveReferenceForIrp(DeviceObject);

    if (Irp->PendingReturned && Irp->CurrentLocation <= Irp->StackCount) {
        IoMarkIrpPending( Irp );
    }

    return STATUS_SUCCESS;

}




NTSTATUS
ModemPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

{

    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS    status;

    PAGED_CODE();

    if (deviceExtension->DoType==DO_TYPE_PDO) {
        //
        //  this one is for the child
        //
        return ModemPdoPower(
                   DeviceObject,
                   Irp
                   );
    }


    //
    //  make sure the device is ready for irp's
    //
    status=CheckStateAndAddReferencePower(
        DeviceObject,
        Irp
        );

    if (STATUS_SUCCESS != status) {
        //
        //  not accepting irp's. The irp has already been completed
        //
        return status;

    }

    switch (irpSp->MinorFunction) {

        case IRP_MN_SET_POWER:

            D_POWER(DbgPrint("MODEM: IRP_MN_SET_POWER, Type=%s, state=%d\n",irpSp->Parameters.Power.Type == SystemPowerState ? "SystemPowerState" : "DevicePowerState",irpSp->Parameters.Power.State.SystemState);)

            if (irpSp->Parameters.Power.Type == SystemPowerState) {
                //
                //  system power state change
                //
            }  else {
                //
                //  changing device state
                //
#if DBG

                if ((irpSp->Parameters.Power.State.DeviceState < PowerDeviceD0)
                    ||
                    (irpSp->Parameters.Power.State.DeviceState > PowerDeviceD3)) {

                    D_ERROR(DbgPrint("MODEM: Bad Device power state\n");)
//                    DbgBreakPoint();
                }
#endif
                IoCopyCurrentIrpStackLocationToNext(Irp);

                IoSetCompletionRoutine(
                             Irp,
                             PowerIrpCompletion,
                             &deviceExtension,
                             TRUE,
                             TRUE,
                             TRUE
                             );

                PoStartNextPowerIrp(Irp);

                status=PoCallDriver(deviceExtension->LowerDevice, Irp);

                RemoveReferenceForDispatch(DeviceObject);

                PAGED_CODE();

                return status;

            }

            break;

        case IRP_MN_QUERY_POWER:

            D_POWER(DbgPrint("MODEM: IRP_MN_QUERY_POWER, Type=%s, state=%d\n",irpSp->Parameters.Power.Type == SystemPowerState ? "SystemPowerState" : "DevicePowerState",irpSp->Parameters.Power.State.DeviceState);)

            Irp->IoStatus.Status=STATUS_SUCCESS;

            break;
#if DBG
        case IRP_MN_WAIT_WAKE:

            D_POWER(DbgPrint("MODEM: IRP_MN_WAIT_WAKE\n");)

            break;
#endif

        default:

            D_POWER(DbgPrint("MODEM: Power IRP, MN func=%d\n",irpSp->MinorFunction);)

            break;

    }

    PoStartNextPowerIrp(Irp);

    IoSkipCurrentIrpStackLocation(Irp);

    status=PoCallDriver(deviceExtension->LowerDevice, Irp);

    RemoveReferenceForIrp(DeviceObject);

    RemoveReferenceForDispatch(DeviceObject);

    PAGED_CODE();

    return status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\sys\modem\pdo.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    initunlo.c

Abstract:

    Code to handle child PDO

Author:

    Brian Lieuallen   02/12/98

Environment:

    Kernel mode

Revision History :

--*/

#include "precomp.h"


//#define MODEM_INSTANCE_ID  L"0000"

#define DEVICE_ID  L"MODEMWAVE\\0"

#define HARDWARE_ID_PREFIX  L"MODEMWAVE\\"

#define WAVE_EXTENSION      L"\\Wave"

#define CHILD_DEVICE_TEXT L"Modem Audio Device"


NTSTATUS
ModemGetVolatileWaveKey(
    IN PDEVICE_OBJECT   Pdo,
    OUT HANDLE          *Handle
    );


NTSTATUS
ModemCreateWaveDriverRegValue(
    IN PDEVICE_OBJECT   Pdo,
    IN ULONG            Started
    );

NTSTATUS
RemoveWaveDriverRegKeyValue(
    PDEVICE_OBJECT    Pdo
    );


#pragma alloc_text(PAGE,CreateChildPdo)
#pragma alloc_text(PAGE,ModemPdoPnp)
#pragma alloc_text(PAGE,ModemPdoPower)
#pragma alloc_text(PAGE,ModemPdoWmi)
#pragma alloc_text(PAGE,ModemGetVolatileWaveKey)
#pragma alloc_text(PAGE,ModemCreateWaveDriverRegValue)
#pragma alloc_text(PAGE,RemoveWaveDriverRegKeyValue)

//#define DUPLEX_ONLY 1

NTSTATUS
CreateChildPdo(
    PDEVICE_EXTENSION   DeviceExtension
    )

{
    NTSTATUS   Status;

    ACCESS_MASK AccessMask = FILE_ALL_ACCESS;
    HANDLE      hKey;

    PAGED_CODE();

    if (DeviceExtension->ChildPdo != NULL) {

        D_PNP(DbgPrint("MODEM: CreateChildPdo: already have child\n");)

        return STATUS_SUCCESS;
    }


    if (DeviceExtension->Removing) {

        D_PNP(DbgPrint("MODEM: CreateChildPdo: Removing\n");)

        return STATUS_SUCCESS;
    }


    Status=IoOpenDeviceRegistryKey(
        DeviceExtension->Pdo,
        PLUGPLAY_REGKEY_DRIVER,
        AccessMask,
        &hKey
        );

    if (NT_SUCCESS(Status)) {
        //
        //  opened the key
        //
        RTL_QUERY_REGISTRY_TABLE ParamTable[5];

        UNICODE_STRING           HardwareId;
        ULONG                    DuplexSupport=0;
        GUID                     PermanentGuid;

        PWSTR      Parameters = L"WaveDriver";
        PWSTR      Id         = L"WaveHardwareID";
        PWSTR      Duplex     = L"DuplexSupport";

        RtlInitUnicodeString(&HardwareId,NULL);

        HardwareId.MaximumLength=256*sizeof(WCHAR);

        RtlZeroMemory(
            ParamTable,
            sizeof(ParamTable)
            );

        //
        // Entry for the modem reg properties
        //

        ParamTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
        ParamTable[0].Name = L"PermanentGuid";
        ParamTable[0].EntryContext = &PermanentGuid;
        ParamTable[0].DefaultType = REG_NONE;
        ParamTable[0].DefaultLength = 0;//sizeof(localProp);

        //
        // Note that rtlqueryregistryvalues has a real hack
        // way of getting binary data.  We also have to add
        // the *negative* length that we want to the beginning
        // of the buffer.
        //
        *(PLONG)&PermanentGuid = -((LONG)sizeof(PermanentGuid));



        //
        //  change to the parmeters key
        //

        ParamTable[1].QueryRoutine = NULL;
        ParamTable[1].Flags = RTL_QUERY_REGISTRY_SUBKEY;
        ParamTable[1].Name = Parameters;

        //
        //  Get the hardware id
        //

        ParamTable[2].QueryRoutine = NULL;
        ParamTable[2].Flags = RTL_QUERY_REGISTRY_REQUIRED |
                              RTL_QUERY_REGISTRY_NOEXPAND |
                              RTL_QUERY_REGISTRY_DIRECT;

        ParamTable[2].Name = Id;
        ParamTable[2].EntryContext = (PVOID)&HardwareId;
        ParamTable[2].DefaultType = 0;

        //
        //  see if it supports duplex mode
        //

        ParamTable[3].QueryRoutine = NULL;
        ParamTable[3].Flags = RTL_QUERY_REGISTRY_NOEXPAND |
                              RTL_QUERY_REGISTRY_DIRECT;

        ParamTable[3].Name = Duplex;
        ParamTable[3].EntryContext = (PVOID)&DuplexSupport;
        ParamTable[3].DefaultType = REG_DWORD;


        Status=RtlQueryRegistryValues(
                   RTL_REGISTRY_HANDLE,
                   hKey,
                   ParamTable,
                   NULL,
                   NULL
                   );



        if (NT_SUCCESS(Status)) {
            //
            //  got the values
            //
#ifdef DUPLEX_ONLY
            if (DuplexSupport != 0) {
#endif
                //
                //  it supports full duplex
                //
                PDEVICE_OBJECT    NewPdo;

                Status = IoCreateDevice(
                             DeviceExtension->DeviceObject->DriverObject,
                             sizeof(PDO_DEVICE_EXTENSION),
                             NULL,
                             FILE_DEVICE_BUS_EXTENDER,
                             FILE_AUTOGENERATED_DEVICE_NAME,
                             FALSE,
                             &NewPdo
                             );

                if (NT_SUCCESS(Status)) {
                    //
                    //  got the device
                    //
                    PPDO_DEVICE_EXTENSION   PdoExtension=NewPdo->DeviceExtension;

                    PdoExtension->DoType=DO_TYPE_PDO;

                    PdoExtension->ParentFdo=DeviceExtension->DeviceObject;
                    PdoExtension->ParentPdo=DeviceExtension->Pdo;

                    //
                    //  save hardware id string
                    //
                    PdoExtension->HardwareId=HardwareId;

                    PdoExtension->UnEnumerated=FALSE;

                    PdoExtension->DuplexSupport=DuplexSupport;

                    RtlCopyMemory(&PdoExtension->PermanentGuid,&PermanentGuid,sizeof(GUID));

                    DeviceExtension->ChildPdo=NewPdo;

//                    ObReferenceObject(DeviceExtension->ChildPdo);

                    NewPdo->Flags |= DO_POWER_PAGABLE;

                    NewPdo->Flags &= ~DO_DEVICE_INITIALIZING;
#ifdef WAVE_KEY
                    ModemCreateWaveDriverRegValue(
                        DeviceExtension->Pdo,
                        0
                        );
#endif

                } else {

                    D_PNP(DbgPrint("MODEM: CreateChildPdo: IoCreateDevice() failed %08lx\n",Status);)

                }
#ifdef DUPLEX_ONLY
            } else {
                D_PNP(DbgPrint("MODEM: CreateChildPdo: Not a duplex modem\n");)
            }
#endif
        } else {

            D_PNP(DbgPrint("MODEM: CreateChildPdo: could not query reg, %08lx\n",Status);)
        }

        ZwClose(hKey);

    } else {

        D_PNP(DbgPrint("MODEM: CreateChildPdo: could not open driver key, %08lx\n",Status);)
    }

    return Status;

}



NTSTATUS
ModemPdoPnp (
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp
    )
/*++
Routine Description:
    Handle requests from the PlugPlay system for the devices on the BUS

--*/
{
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);

    PPDO_DEVICE_EXTENSION   PdoDeviceExtension=DeviceObject->DeviceExtension;

    PDEVICE_CAPABILITIES    deviceCapabilities;
    ULONG                   information;
    PWCHAR                  buffer=NULL, buffer2=NULL;
    ULONG                   length, i, j;
    NTSTATUS                status;

    PAGED_CODE ();

    status = Irp->IoStatus.Status;


    switch (IrpSp->MinorFunction) {
    case IRP_MN_QUERY_CAPABILITIES:

        D_PNP(DbgPrint("MODEM: PDO: IRP_MN_QUERY_CAPABILITIES\n");)


        //
        // Get the packet.
        //
        deviceCapabilities=IrpSp->Parameters.DeviceCapabilities.Capabilities;

        //
        // Set the capabilities.
        //

        deviceCapabilities->Version = 1;
        deviceCapabilities->Size = sizeof (DEVICE_CAPABILITIES);

        // We cannot wake the system.
        deviceCapabilities->SystemWake = PowerSystemUnspecified;
        deviceCapabilities->DeviceWake = PowerDeviceUnspecified;

        // We have no latencies
        deviceCapabilities->D1Latency = 0;
        deviceCapabilities->D2Latency = 0;
        deviceCapabilities->D3Latency = 0;

        // No locking or ejection
        deviceCapabilities->LockSupported = FALSE;
        deviceCapabilities->EjectSupported = FALSE;

        // Device can be physically removed.
        // Technically there is no physical device to remove, but this bus
        // driver can yank the PDO from the PlugPlay system, when ever it
        // receives an IOCTL_SERENUM_REMOVE_PORT device control command.
//        deviceCapabilities->Removable = TRUE;

        deviceCapabilities->SurpriseRemovalOK=TRUE;


        // not Docking device
        deviceCapabilities->DockDevice = FALSE;

        deviceCapabilities->UniqueID = TRUE;
        status = STATUS_SUCCESS;
        break;

    case IRP_MN_QUERY_DEVICE_TEXT:

        if (IrpSp->Parameters.QueryDeviceText.DeviceTextType == DeviceTextDescription) {

            buffer=ALLOCATE_PAGED_POOL(sizeof(CHILD_DEVICE_TEXT));

            if (buffer != NULL) {

                RtlCopyMemory(buffer,CHILD_DEVICE_TEXT,sizeof(CHILD_DEVICE_TEXT));

                status=STATUS_SUCCESS;
                Irp->IoStatus.Information = (ULONG_PTR) buffer;
                break;

            } else {

                status=STATUS_INSUFFICIENT_RESOURCES;
            }
        }
        break;

    case IRP_MN_QUERY_ID:

        D_PNP(DbgPrint("MODEM: PDO: IRP_MN_QUERY_ID\n");)

        // Query the IDs of the device

        switch (IrpSp->Parameters.QueryId.IdType) {

            case BusQueryInstanceID: {
                //
                // Build an instance ID.  This is what PnP uses to tell if it has
                // seen this thing before or not.

                UNICODE_STRING    InstanceString;

                buffer=NULL;

                status=RtlStringFromGUID(
                         &PdoDeviceExtension->PermanentGuid,
                         &InstanceString
                         );

                if (NT_SUCCESS(status)) {

                    buffer = ALLOCATE_PAGED_POOL(InstanceString.Length+sizeof(WCHAR));

                    if (buffer) {

                        RtlZeroMemory(buffer,InstanceString.Length+sizeof(WCHAR));

                        RtlCopyMemory (buffer, InstanceString.Buffer, InstanceString.Length);

                    } else {

                        status=STATUS_NO_MEMORY;
                    }
                    RtlFreeUnicodeString(&InstanceString);
                }
                Irp->IoStatus.Status=status;
                Irp->IoStatus.Information = (ULONG_PTR) buffer;
                break;
            }

            case BusQueryDeviceID:
                //
                // return a WCHAR (null terminated) string describing the device
                // For PNP devices, it is exactly the same as the Hardware ID,
                //


                length=sizeof(DEVICE_ID);

                buffer = ALLOCATE_PAGED_POOL(length);

                if (buffer != NULL) {

                    status = STATUS_SUCCESS;
                    RtlZeroMemory(buffer, length);

                    RtlCopyMemory(
                        buffer,
                        DEVICE_ID,
                        length
                        );

                } else {

                    status=STATUS_INSUFFICIENT_RESOURCES;
                }
                Irp->IoStatus.Information = (ULONG_PTR) buffer;
                break;


            case BusQueryHardwareIDs:
                //
                // return a multi WCHAR (null terminated) string (null terminated)
                // array for use in matching hardare ids in inf files;
                //

                length = sizeof(HARDWARE_ID_PREFIX) +
                         PdoDeviceExtension->HardwareId.Length+
                         (sizeof(WCHAR)*2);

                buffer = ALLOCATE_PAGED_POOL(length);

                if (buffer != NULL) {

                    status = STATUS_SUCCESS;
                    RtlZeroMemory(buffer, length);

                    //
                    //  copy the prefix string in
                    //
                    RtlCopyMemory(
                        buffer,
                        HARDWARE_ID_PREFIX,
                        sizeof(HARDWARE_ID_PREFIX)-sizeof(UNICODE_NULL)
                        );

                    RtlCopyMemory (
                        buffer+((sizeof(HARDWARE_ID_PREFIX)-sizeof(UNICODE_NULL))/sizeof(WCHAR)),
                        PdoDeviceExtension->HardwareId.Buffer,
                        PdoDeviceExtension->HardwareId.Length
                        );

                } else {

                    status=STATUS_INSUFFICIENT_RESOURCES;
                }

                Irp->IoStatus.Information = (ULONG_PTR) buffer;
                break;


            case BusQueryCompatibleIDs:
                // The generic ids for installation of this pdo.


                length=sizeof(WCHAR)*2;

                buffer = ALLOCATE_PAGED_POOL(length);

                if (buffer != NULL) {

                    RtlZeroMemory (buffer,  length);
                    status = STATUS_SUCCESS;

                } else {

                    status=STATUS_INSUFFICIENT_RESOURCES;
                }

                Irp->IoStatus.Information = (ULONG_PTR) buffer;
                break;

            default:
                //
                //  not supported
                //
                break;

        }

        break;

    case IRP_MN_START_DEVICE: {

        PDEVICE_EXTENSION   FdoExtension=PdoDeviceExtension->ParentFdo->DeviceExtension;

        D_PNP(DbgPrint("MODEM: PDO: IRP_MN_START_DEVICE\n");)
#ifdef WAVE_KEY
        ModemCreateWaveDriverRegValue(
            FdoExtension->Pdo,
            1
            );
#endif

        status = STATUS_SUCCESS;

        break;
    }

    case IRP_MN_STOP_DEVICE:

        D_PNP(DbgPrint("MODEM: PDO: IRP_MN_STOP_DEVICE\n");)

        // Here we shut down the device.  The opposite of start.
        status = STATUS_SUCCESS;
        break;

    case IRP_MN_SURPRISE_REMOVAL:

        D_PNP(DbgPrint("MODEM: PDO: IRP_MN_SURPRISE_REMOVAL\n");)

        status = STATUS_SUCCESS;
        break;


    case IRP_MN_REMOVE_DEVICE: {

            PDEVICE_EXTENSION   FdoExtension=PdoDeviceExtension->ParentFdo->DeviceExtension;

            D_PNP(DbgPrint("MODEM: PDO: IRP_MN_REMOVE_DEVICE: %08lx\n",DeviceObject);)
            //
            // The remove IRP code for a PDO uses the following steps:
            //
            KeEnterCriticalRegion();

            ExAcquireResourceExclusiveLite(
                &FdoExtension->OpenCloseResource,
                TRUE
                );

            if (PdoDeviceExtension->Deleted ) {
                //
                //  the PDO has already been deleted, Just return success
                //
                D_PNP(DbgPrint("MODEM: PDO: IRP_MN_REMOVE_DEVICE: already deleted %08lx\n",DeviceObject);)

                status=STATUS_SUCCESS;

            } else {
#ifdef WAVE_KEY
                ModemCreateWaveDriverRegValue(
                    FdoExtension->Pdo,
                    0
                    );
#endif

                if (PdoDeviceExtension->UnEnumerated) {
                    //
                    //  the parent is not emunerating, the child anymore
                    //
                    D_PNP(DbgPrint("MODEM: PDO: IRP_MN_REMOVE_DEVICE: NOT-Enumerated %08lx\n",DeviceObject);)

                    PdoDeviceExtension->DoType=DO_TYPE_DEL_PDO;

                    RtlFreeUnicodeString(&PdoDeviceExtension->HardwareId);

                    PdoDeviceExtension->Deleted=TRUE;

                    IoDeleteDevice(DeviceObject);

                    status=STATUS_SUCCESS;

                } else {
                    //
                    //  The parent is still enumerating, the child, leave it alone
                    //
                    D_PNP(DbgPrint("MODEM: PDO: IRP_MN_REMOVE_DEVICE: Still enumerated %08lx\n",DeviceObject);)

                    status=STATUS_SUCCESS;
                }
            }

            ExReleaseResourceLite(
                &FdoExtension->OpenCloseResource
                );

            KeLeaveCriticalRegion();
        }
        break;

    case IRP_MN_QUERY_STOP_DEVICE:

        D_PNP(DbgPrint("MODEM: PDO: IRP_MN_QUERY_STOP_DEVICE\n");)

        // No reason here why we can't stop the device.
        // If there were a reason we should speak now for answering success
        // here may result in a stop device irp.
        status = STATUS_SUCCESS;
        break;

    case IRP_MN_CANCEL_STOP_DEVICE:

        D_PNP(DbgPrint("MODEM: PDO: IRP_MN_CANCEL_STOP_DEVICE\n");)
        //
        // The stop was canceled.  Whatever state we set, or resources we put
        // on hold in anticipation of the forcoming STOP device IRP should be
        // put back to normal.  Someone, in the long list of concerned parties,
        // has failed the stop device query.
        //
        status = STATUS_SUCCESS;
        break;

    case IRP_MN_QUERY_REMOVE_DEVICE:

        D_PNP(DbgPrint("MODEM: PDO: IRP_MN_QUERY_REMOVE_DEVICE\n");)

        //
        // Just like Query Stop only now the impending doom is the remove irp
        //
        status = STATUS_SUCCESS;
        break;

    case IRP_MN_CANCEL_REMOVE_DEVICE:

        D_PNP(DbgPrint("MODEM: PDO: IRP_MN_CANCEL_REMOVE_DEVICE\n");)
        //
        // Clean up a remove that did not go through, just like cancel STOP.
        //
        status = STATUS_SUCCESS;
        break;



    case IRP_MN_READ_CONFIG:

        D_PNP(DbgPrint("MODEM: PDO: IRP_MN_READ_CONFIG: Space=%d\n",IrpSp->Parameters.ReadWriteConfig.WhichSpace);)

        switch ( IrpSp->Parameters.ReadWriteConfig.WhichSpace ) {

            case READ_CONFIG_PERMANENT_GUID:

                if ((IrpSp->Parameters.ReadWriteConfig.Length >= sizeof(GUID))) {

                    RtlCopyMemory(
                        IrpSp->Parameters.ReadWriteConfig.Buffer,
                        &PdoDeviceExtension->PermanentGuid,
                        sizeof(GUID)
                        );

                    status = STATUS_SUCCESS;
                    Irp->IoStatus.Information=sizeof(GUID);
                    break;

                }
                status=STATUS_BUFFER_TOO_SMALL;
                break;

            case READ_CONFIG_DEVICE_NAME:  {

                ULONG    NameLength;
                ULONG    BufferLength;
                //
                //  Get the name of the modem device object
                //

                if (IrpSp->Parameters.ReadWriteConfig.Length > sizeof(WAVE_EXTENSION)) {

                    BufferLength=IrpSp->Parameters.ReadWriteConfig.Length - sizeof(WAVE_EXTENSION);

                    status=IoGetDeviceProperty(
                        PdoDeviceExtension->ParentPdo,
                        DevicePropertyPhysicalDeviceObjectName,
                        BufferLength,
                        IrpSp->Parameters.ReadWriteConfig.Buffer,
                        &NameLength
                        );


                    if (status == STATUS_SUCCESS) {

                        RtlCopyMemory(
                            ((PUCHAR)IrpSp->Parameters.ReadWriteConfig.Buffer)+NameLength-sizeof(UNICODE_NULL),
                            WAVE_EXTENSION,
                            sizeof(WAVE_EXTENSION)
                            );

                        Irp->IoStatus.Information=(NameLength-sizeof(UNICODE_NULL))+sizeof(WAVE_EXTENSION);

                    } else {

                        D_ERROR(DbgPrint("MODEM: PDO: ReadConfig: name failed\n");)
                    }
                }

                break;
            }

            case READ_CONFIG_NAME_SIZE:  {

                ULONG    NameLength;
                //
                //  Get the length of the modem device name
                //

                if (IrpSp->Parameters.ReadWriteConfig.Length >= sizeof(ULONG)) {

                    status=IoGetDeviceProperty(
                        PdoDeviceExtension->ParentPdo,
                        DevicePropertyPhysicalDeviceObjectName,
                        0,
                        NULL,
                        &NameLength
                        );

                    if (status == STATUS_BUFFER_TOO_SMALL) {

                        NameLength+=sizeof(WAVE_EXTENSION);

                        *(PULONG)(IrpSp->Parameters.ReadWriteConfig.Buffer)=NameLength;
                        Irp->IoStatus.Information=sizeof(ULONG);
                        status=STATUS_SUCCESS;
                    }

                } else {
                    D_ERROR(DbgPrint("MODEM: PDO: ReadConfig: name size failed\n");)
                    status=STATUS_BUFFER_TOO_SMALL;
                }

                break;
            }

            case READ_CONFIG_DUPLEX_SUPPORT:  {

                ULONG    NameLength;
                //
                //  Get the DuplexSupport value
                //

                if (IrpSp->Parameters.ReadWriteConfig.Length >= sizeof(ULONG)) {

                    *(PULONG)(IrpSp->Parameters.ReadWriteConfig.Buffer)=PdoDeviceExtension->DuplexSupport;
                    Irp->IoStatus.Information=sizeof(ULONG);
                    status=STATUS_SUCCESS;

                } else {

                    D_ERROR(DbgPrint("MODEM: PDO: ReadConfig: DuplexSupport size failed\n");)
                    status=STATUS_BUFFER_TOO_SMALL;
                }

                break;
            }

            default:

                break;
        }
        break;



    case IRP_MN_QUERY_DEVICE_RELATIONS: {

        PDEVICE_RELATIONS    CurrentRelations;

        switch (IrpSp->Parameters.QueryDeviceRelations.Type) {

            case TargetDeviceRelation:

                CurrentRelations=ALLOCATE_PAGED_POOL(sizeof(DEVICE_RELATIONS));

                if (CurrentRelations != NULL) {

                    ObReferenceObject(DeviceObject);
                    CurrentRelations->Objects[0]=DeviceObject;
                    CurrentRelations->Count=1;

                    Irp->IoStatus.Information=(ULONG_PTR)CurrentRelations;

                    status=STATUS_SUCCESS;

                }  else {

                    status=STATUS_INSUFFICIENT_RESOURCES;
                }

                break;

            default:

                break;

        }

        break;
    }

    default:
        //
        //  we aren't handling this irp
        //  just complete it
        //
        break;

    }

    //
    //  the irp has been handled in some way or the other
    //  complete it now
    //
    Irp->IoStatus.Status = status;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    return status;
}


NTSTATUS
ModemPdoPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

{

    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS Status;

    PAGED_CODE();

    D_POWER(DbgPrint("MODEM: PDO: Power IRP, MN func=%d\n",irpSp->MinorFunction);)

    PoStartNextPowerIrp(Irp);
    
    if ((irpSp->MinorFunction == IRP_MN_SET_POWER)
            || (irpSp->MinorFunction == IRP_MN_QUERY_POWER))
    {
        Irp->IoStatus.Status = STATUS_SUCCESS;
    }
            
    Status = Irp->IoStatus.Status;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);
    return Status;
}



NTSTATUS
ModemPdoWmi(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

{
    NTSTATUS   Status=Irp->IoStatus.Status;

    D_WMI(DbgPrint("MODEM: PDO: Wmi\n");)

    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    return Status;
}


#ifdef WAVE_KEY

NTSTATUS
ModemGetVolatileWaveKey(
    IN PDEVICE_OBJECT   Pdo,
    OUT HANDLE          *Handle
    )
{

    NTSTATUS    Status;

    const ACCESS_MASK AccessMask = FILE_ALL_ACCESS;
    HANDLE      hKey;

    *Handle=NULL;


    Status=IoOpenDeviceRegistryKey(
        Pdo,
        PLUGPLAY_REGKEY_DRIVER,
        AccessMask,
        &hKey
        );

    if (NT_SUCCESS(Status)) {
        //
        //  opened the key
        //
        OBJECT_ATTRIBUTES    ObjectAttributes;
        UNICODE_STRING       SubKeyName;

        HANDLE               WaveSubKey;

        RtlInitUnicodeString(
            &SubKeyName,
            L"WaveDriver"
            );

        InitializeObjectAttributes(
            &ObjectAttributes,
            &SubKeyName,
            OBJ_CASE_INSENSITIVE,
            hKey,
            NULL
            );

        Status=ZwOpenKey(
            &WaveSubKey,
            AccessMask,
            &ObjectAttributes
            );

        if (NT_SUCCESS(Status)) {

            ULONG                Disposition;
            HANDLE               SubKey=NULL;

            RtlInitUnicodeString(
                &SubKeyName,
                L"Enumerated"
                );

            InitializeObjectAttributes(
                &ObjectAttributes,
                &SubKeyName,
                OBJ_CASE_INSENSITIVE,
                WaveSubKey,
                NULL
                );

            Status=ZwCreateKey(
                &SubKey,
                KEY_SET_VALUE,
                &ObjectAttributes,
                0,
                NULL,
                REG_OPTION_VOLATILE,
                &Disposition
                );

            if (NT_SUCCESS(Status)) {

                *Handle=SubKey;

            } else {

                D_ERROR(DbgPrint("MODEM: Failed to create Enumerated key %08lx\n",Status);)
            }

            ZwClose(WaveSubKey);

        } else {

            D_ERROR(DbgPrint("MODEM: Failed to Open Wavedriver key %08lx\n",Status);)
        }

        ZwClose(hKey);

    } else {

        D_ERROR(DbgPrint("MODEM: Failed to open device reg key %08lx\n",Status);)
    }

    return Status;
}


NTSTATUS
ModemCreateWaveDriverRegValue(
    IN PDEVICE_OBJECT   Pdo,
    IN ULONG            Started
    )

{
    NTSTATUS    Status;
    HANDLE      hKey;

    Status=ModemGetVolatileWaveKey(Pdo,&hKey);

    if (NT_SUCCESS(Status)) {
        //
        //  created or open the key
        //
        UNICODE_STRING    ValueName;

        RtlInitUnicodeString(
            &ValueName,
            L"Started"
            );

        Status=ZwSetValueKey(
            hKey,
            &ValueName,
            0,
            REG_DWORD,
            &Started,
            sizeof(Started)
            );

        if (!NT_SUCCESS(Status)) {

             D_ERROR(DbgPrint("MODEM: Failed to set value %08lx\n",Status);)
        }

        ZwClose(hKey);
    }

    return Status;
}



NTSTATUS
RemoveWaveDriverRegKeyValue(
    PDEVICE_OBJECT    Pdo
    )

{

    NTSTATUS    Status;

    HANDLE      hKey;

    Status=ModemGetVolatileWaveKey(Pdo,&hKey);

    if (NT_SUCCESS(Status)) {
        //
        //  created or open the key
        //
        ZwDeleteKey(hKey);
    }

    return Status;

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\sys\modem\mdm.h ===
#include "windef.h"
#include "mcx.h"
#include "..\inc\modemp.h"

#if DBG
#define EXTRA_DBG 1
#else
#define EXTRA_DBG 0
#endif

#define WAVE_KEY

#define _AT_V

#ifdef _AT_V

#define MAX_DLE_BUFFER_SIZE    40

#define DLE_STATE_IDLE                0
#define DLE_STATE_WAIT_FOR_NEXT_CHAR  1

#define DLE_CHAR               0x10
#endif


extern PVOID   PagedCodeSectionHandle;
extern UNICODE_STRING   DriverEntryRegPath;

//
// DTR Control Flow Values.
//
#define DTR_CONTROL_DISABLE    0x00
#define DTR_CONTROL_ENABLE     0x01
#define DTR_CONTROL_HANDSHAKE  0x02

//
// RTS Control Flow Values
//
#define RTS_CONTROL_DISABLE    0x00
#define RTS_CONTROL_ENABLE     0x01
#define RTS_CONTROL_HANDSHAKE  0x02
#define RTS_CONTROL_TOGGLE     0x03

typedef struct _DCB {
    DWORD DCBlength;      /* sizeof(DCB)                     */
    DWORD BaudRate;       /* Baudrate at which running       */
    DWORD fBinary: 1;     /* Binary Mode (skip EOF check)    */
    DWORD fParity: 1;     /* Enable parity checking          */
    DWORD fOutxCtsFlow:1; /* CTS handshaking on output       */
    DWORD fOutxDsrFlow:1; /* DSR handshaking on output       */
    DWORD fDtrControl:2;  /* DTR Flow control                */
    DWORD fDsrSensitivity:1; /* DSR Sensitivity              */
    DWORD fTXContinueOnXoff: 1; /* Continue TX when Xoff sent */
    DWORD fOutX: 1;       /* Enable output X-ON/X-OFF        */
    DWORD fInX: 1;        /* Enable input X-ON/X-OFF         */
    DWORD fErrorChar: 1;  /* Enable Err Replacement          */
    DWORD fNull: 1;       /* Enable Null stripping           */
    DWORD fRtsControl:2;  /* Rts Flow control                */
    DWORD fAbortOnError:1; /* Abort all reads and writes on Error */
    DWORD fDummy2:17;     /* Reserved                        */
    WORD wReserved;       /* Not currently used              */
    WORD XonLim;          /* Transmit X-ON threshold         */
    WORD XoffLim;         /* Transmit X-OFF threshold        */
    BYTE ByteSize;        /* Number of bits/byte, 4-8        */
    BYTE Parity;          /* 0-4=None,Odd,Even,Mark,Space    */
    BYTE StopBits;        /* 0,1,2 = 1, 1.5, 2               */
    char XonChar;         /* Tx and Rx X-ON character        */
    char XoffChar;        /* Tx and Rx X-OFF character       */
    char ErrorChar;       /* Error replacement char          */
    char EofChar;         /* End of Input character          */
    char EvtChar;         /* Received Event character        */
    WORD wReserved1;      /* Fill for now.                   */
} DCB, *LPDCB;

typedef struct _COMMCONFIG {
    DWORD dwSize;               /* Size of the entire struct */
    WORD wVersion;              /* version of the structure */
    WORD wReserved;             /* alignment */
    DCB dcb;                    /* device control block */
    DWORD dwProviderSubType;    /* ordinal value for identifying
                                   provider-defined data structure format*/
    DWORD dwProviderOffset;     /* Specifies the offset of provider specific
                                   data field in bytes from the start */
    DWORD dwProviderSize;       /* size of the provider-specific data field */
    WCHAR wcProviderData[1];    /* provider-specific data */
} COMMCONFIG,*LPCOMMCONFIG;

typedef struct _MODEM_REG_PROP {
    DWORD   dwDialOptions;          // bitmap of supported options
    DWORD   dwCallSetupFailTimer;   // Maximum value in seconds
    DWORD   dwInactivityTimeout;    // Maximum value in units specific by InactivityScale
    DWORD   dwSpeakerVolume;        // bitmap of supported values
    DWORD   dwSpeakerMode;          // bitmap of supported values
    DWORD   dwModemOptions;         // bitmap of supported values
    DWORD   dwMaxDTERate;           // Maximum value in bit/s
    DWORD   dwMaxDCERate;           // Maximum value in bit/s
} MODEM_REG_PROP;

typedef struct _MODEM_REG_DEFAULT {
    DWORD   dwCallSetupFailTimer;       // seconds
    DWORD   dwInactivityTimeout;        // units specific by InactivityScale
    DWORD   dwSpeakerVolume;            // level
    DWORD   dwSpeakerMode;              // mode
    DWORD   dwPreferredModemOptions;    // bitmap
} MODEM_REG_DEFAULT;

#ifdef POOL_TAGGING
#undef ExAllocatePool
#undef ExAllocatePoolWithQuota
#endif



#define ALLOCATE_PAGED_POOL(_y)  ExAllocatePoolWithTag(PagedPool,_y,'MDMU')

#define ALLOCATE_NONPAGED_POOL(_y) ExAllocatePoolWithTag(NonPagedPool,_y,'MDMU')

#define FREE_POOL(_x) {ExFreePool(_x);_x=NULL;};



extern ULONG  DebugFlags;

#if DBG

#define VALIDATE_IRP(_x) if ((((DWORD_PTR)_x & 3) != 0) || (_x->Type != IO_TYPE_IRP)) {DbgPrint("MODEM: bad irp\n");DbgBreakPoint();}

#define DEBUG_FLAG_ERROR  0x0001
#define DEBUG_FLAG_INIT   0x0002
#define DEBUG_FLAG_PNP    0x0004
#define DEBUG_FLAG_POWER  0x0008
#define DEBUG_FLAG_WMI    0x0010
#define DEBUG_FLAG_TRACE  0x0020


#define D_INIT(_x)  if (DebugFlags & DEBUG_FLAG_INIT) {_x}

#define D_PNP(_x)   if (DebugFlags & DEBUG_FLAG_PNP) {_x}

#define D_POWER(_x) if (DebugFlags & DEBUG_FLAG_POWER) {_x}

#define D_TRACE(_x) if (DebugFlags & DEBUG_FLAG_TRACE) {_x}

#define D_ERROR(_x) if (DebugFlags & DEBUG_FLAG_ERROR) {_x}

#define D_WMI(_x) if (DebugFlags & DEBUG_FLAG_WMI) {_x}

#else

#define VALIDATE_IRP(_x) {}

#define D_INIT(_x)  {}

#define D_PNP(_x)   {}

#define D_POWER(_x) {}

#define D_TRACE(_x) {}

#define D_ERROR(_x) {}

#define D_WMI(_x)   {}

#endif

#define RETREIVE_OUR_WAIT_IRP(_exten) InterlockedExchangePointer(&(_exten->xOurWaitIrp),NULL)
#define RETURN_OUR_WAIT_IRP(_exten,_irp)   _exten->xOurWaitIrp=_irp


#if DBG
#define UNIDIAG1              ((ULONG)0x00000001)
#define UNIDIAG2              ((ULONG)0x00000002)
#define UNIDIAG3              ((ULONG)0x00000004)
#define UNIDIAG4              ((ULONG)0x00000008)
#define UNIDIAG5              ((ULONG)0x00000010)
#define UNIERRORS             ((ULONG)0x00000020)
#define UNIBUGCHECK           ((ULONG)0x80000000)
extern ULONG UniDebugLevel;
#define UniDump(LEVEL,STRING) \
        do { \
            ULONG _level = (LEVEL); \
            if (UniDebugLevel & _level) { \
                DbgPrint STRING; \
            } \
            if (_level == UNIBUGCHECK) { \
                ASSERT(FALSE); \
            } \
        } while (0)
#else
#define UniDump(LEVEL,STRING) do {NOTHING;} while (0)
#endif

#define OBJECT_DIRECTORY L"\\DosDevices\\"



//
// Values define the reference bits kept in the irps.
//

#define UNI_REFERENCE_NORMAL_PATH 0x00000001
#define UNI_REFERENCE_CANCEL_PATH 0x00000002

#define CLIENT_HANDLE 0
#define CONTROL_HANDLE 1

struct _DEVICE_EXTENSION;

typedef struct _MASKSTATE {

    //
    // Helpful when this is passed as context to a completion routine.
    //
    struct _DEVICE_EXTENSION *Extension;

    //
    // Pointer to the complementry mask state.
    //
    struct _MASKSTATE *OtherState;

    //
    // Counts the number of setmasks for the current client or
    // control wait.
    //
    ULONG SetMaskCount;

    //
    // This counts the number of setmask that have actually been
    // passed down to a lower level serial driver.  This helps
    // us on not starting waits that will die soon enough.
    //
    ULONG SentDownSetMasks;

    //
    // Holds the value of the last successful setmask for the client
    // or the control.
    //
    ULONG Mask;

    //
    // Holds the value of the above mask with whatever was last seen
    // by a successful wait from any handle.
    //
    ULONG HistoryMask;

    //
    // Points to the wait operation shuttled aside for the client
    // or control.
    //
    PIRP ShuttledWait;

    //
    // Points to the wait operation sent down to a lower level serial
    // driver
    //
    PIRP PassedDownWait;

    //
    // The current stack location of the passed down irp, We use one of the unused paramters
    // to indicate if the passdown irp should be completed back to the client when its
    // completion routine is call
    //
    PIO_STACK_LOCATION  PassedDownStackLocation;

#if EXTRA_DBG
    PVOID               CurrentStackCompletionRoutine;
#endif


} MASKSTATE,*PMASKSTATE;

//
// Scads of little macros to manipulate our stack location.
//

#define UNI_INIT_REFERENCE(Irp) { \
    ASSERT(sizeof(LONG) <= sizeof(PVOID)); \
    IoGetCurrentIrpStackLocation((Irp))->Parameters.Others.Argument4 = NULL; \
    }

#define UNI_SET_REFERENCE(Irp,RefType) \
   do { \
       BYTE _refType = (RefType); \
       PBYTE _arg4 = (PVOID)&IoGetCurrentIrpStackLocation((Irp))->Parameters.Others.Argument4; \
       ASSERT(!(*_arg4 & _refType)); \
       *_arg4 |= _refType; \
   } while (0)

#define UNI_CLEAR_REFERENCE(Irp,RefType) \
   do { \
       BYTE _refType = (RefType); \
       PBYTE _arg4 = (PVOID)&IoGetCurrentIrpStackLocation((Irp))->Parameters.Others.Argument4; \
       ASSERT(*_arg4 & _refType); \
       *_arg4 &= ~_refType; \
   } while (0)

#define UNI_REFERENCE_COUNT(Irp) \
   ((BYTE)((ULONG_PTR)((IoGetCurrentIrpStackLocation((Irp))->Parameters.Others.Argument4))))

#define UNI_SAVE_STATE_IN_IRP(Irp,MaskState) \
   do { \
       PMASKSTATE _maskState = (MaskState); \
       PMASKSTATE *_arg3 = (PVOID)&IoGetCurrentIrpStackLocation((Irp))->Parameters.Others.Argument3; \
       *_arg3 = _maskState; \
   } while (0)

#define UNI_CLEAR_STATE_IN_IRP(Irp) \
   do { \
       PMASKSTATE *_arg3 = (PVOID)&IoGetCurrentIrpStackLocation((Irp))->Parameters.Others.Argument3; \
       ASSERT(*_arg3); \
       *((PULONG)_arg3) = IOCTL_SERIAL_WAIT_ON_MASK; \
   } while (0)



#define UNI_GET_STATE_IN_IRP(Irp) \
    ((PMASKSTATE)((IoGetCurrentIrpStackLocation((Irp))->Parameters.Others.Argument3)))

#define UNI_ORIG_SYSTEM_BUFFER(Irp) \
    ((PVOID)((IoGetCurrentIrpStackLocation((Irp)))->Parameters.Others.Argument3))

#define UNI_RESTORE_IRP(Irp,Code) \
    do { \
        PIRP _irp = (Irp); \
        ULONG _ccode = (Code); \
        PIO_STACK_LOCATION _irpSp = IoGetCurrentIrpStackLocation(_irp); \
        ASSERT(&(_irpSp->Parameters.Others.Argument3) == (PVOID)&(_irpSp->Parameters.DeviceIoControl.IoControlCode)); \
        _irp->AssociatedIrp.SystemBuffer = _irpSp->Parameters.Others.Argument3; \
        _irpSp->Parameters.DeviceIoControl.IoControlCode = _ccode; \
    } while (0)

#define UNI_SETUP_NEW_BUFFER(Irp) \
    do { \
        PIRP _irp = (Irp); \
        PIO_STACK_LOCATION _irpSp = IoGetCurrentIrpStackLocation(_irp); \
        _irpSp->Parameters.Others.Argument3 = _irp->AssociatedIrp.SystemBuffer; \
        _irp->AssociatedIrp.SystemBuffer = &_irpSp->Parameters.DeviceIoControl.Type3InputBuffer; \
    } while (0)


VOID _inline
SetPassdownToComplete(
    PMASKSTATE   MaskState
    )

{
    PIO_STACK_LOCATION _irpSp=MaskState->PassedDownStackLocation;
    PBYTE              _arg4 = (PVOID)&_irpSp->Parameters.Others.Argument4;

    _arg4[1]=TRUE;

    MaskState->PassedDownWait=NULL;
    MaskState->PassedDownStackLocation=NULL;

    return;
}

VOID _inline
MakeIrpCurrentPassedDown(
    PMASKSTATE   MaskState,
    PIRP         Irp
    )

{
    PIO_STACK_LOCATION _irpSp = IoGetCurrentIrpStackLocation(Irp);

    PBYTE _arg4 = (PVOID)&_irpSp->Parameters.Others.Argument4;

    _arg4[1]=FALSE;

    MaskState->PassedDownWait=Irp;
    MaskState->PassedDownStackLocation=_irpSp;

    return;
}

BOOLEAN _inline
UNI_SHOULD_PASSDOWN_COMPLETE(
    PIRP     Irp
    )
{
    PIO_STACK_LOCATION _irpSp = IoGetCurrentIrpStackLocation(Irp);

    PBYTE _arg4 = (PVOID)&_irpSp->Parameters.Others.Argument4;

    return _arg4[1];

}


typedef struct _IPC_CONTROL {
    ULONG         CurrentSession;
    ULONG         CurrentRequestId;
    LIST_ENTRY    GetList;
    LIST_ENTRY    PutList;

} IPC_CONTROL, *PIPC_CONTROL;

typedef NTSTATUS (*IRPSTARTER)(
    struct _READ_WRITE_CONTROL *Control,
    PDEVICE_OBJECT              DeviceObject,
    PIRP                        Irp
    );


typedef struct _READ_WRITE_CONTROL {

    KSPIN_LOCK    Lock;

    LIST_ENTRY    ListHead;

    PIRP          CurrentIrp;

    PDEVICE_OBJECT DeviceObject;

    BOOL           InStartNext;

    IRPSTARTER     Starter;

    BOOL           CompleteAllQueued;

    union {

        struct {

            PDEVICE_OBJECT LowerDevice;

            ULONG   State;

            PVOID          SystemBuffer;
            ULONG          CurrentTransferLength;
            ULONG          TotalTransfered;


        } Read;

        struct {

            ULONG   State;

            PDEVICE_OBJECT LowerDevice;

            PUCHAR         RealSystemBuffer;

        } Write;
    };

} READ_WRITE_CONTROL, *PREAD_WRITE_CONTROL;

#define DO_TYPE_PDO   ' ODP'
#define DO_TYPE_FDO   ' ODF'

#define DO_TYPE_DEL_PDO   'ODPx'
#define DO_TYPE_DEL_FDO   'ODFx'


typedef struct _PDO_DEVICE_EXTENSION {

    ULONG              DoType;

    PDEVICE_OBJECT     ParentPdo;
    PDEVICE_OBJECT     ParentFdo;

    UNICODE_STRING     HardwareId;

    ULONG              DuplexSupport;

    GUID               PermanentGuid;

    BOOLEAN            UnEnumerated;
    BOOLEAN            Deleted;

} PDO_DEVICE_EXTENSION, *PPDO_DEVICE_EXTENSION;




typedef struct _DEVICE_EXTENSION {

    ULONG              DoType;

    PDEVICE_OBJECT   ChildPdo;
    //
    // The general synchronization primative used by the modem driver.
    //
    KSPIN_LOCK DeviceLock;

    //
    // Points back to the device object that was created in
    // conjunction with this device extension
    //
    PDEVICE_OBJECT DeviceObject;

    PDEVICE_OBJECT Pdo;
    PDEVICE_OBJECT LowerDevice;

    //
    // These to items were returned from the acquiring of the device
    // object pointer to the lower level serial device.
    //
    PDEVICE_OBJECT AttachedDeviceObject;
    BOOLEAN      Started;

    BOOLEAN      PreQueryStartedStatus;

    BOOLEAN      Removing;

    BOOLEAN      Removed;

    ULONG        ReferenceCount;

    //
    // Keeps a count (synchronized by the DeviceLock) of the number
    // of times the modem has been opened (and closed).
    //
    ULONG OpenCount;


    UNICODE_STRING InterfaceNameString;

    //
    // The queue of passthrough state requests.  It is synchronized
    // using the DeviceLock spinlock.
    //
    LIST_ENTRY PassThroughQueue;
    PIRP CurrentPassThrough;


    //
    // The address of the process that first opened us.  The sharing
    // semantics of the modem device are such that ONLY the first
    // process that opened us can open us again.  Dispense with all
    // other access checks.
    //
    PEPROCESS ProcAddress;

    ULONG     IpcServerRunning;

    //
    // The state that the particular modem device is in.  For definitions
    // of the value, see the public header ntddmodm.h
    //
    ULONG PassThrough;

    ULONG CurrentPassThroughSession;

    //
    // The queue of mask operations.  It is synchronized using the
    // DeviceLock spinlock.
    //
    LIST_ENTRY MaskOps;
    PIRP CurrentMaskOp;

    //
    // This points to an irp that we allocate at port open time.
    // The irp will be used to look for dcd changes when a sniff
    // request is given.
    //
    PIRP xOurWaitIrp;

    //
    //
    // Holds the states for both the client and the controlling handle.
    //
    MASKSTATE MaskStates[2];

    MODEMDEVCAPS ModemDevCaps;
    MODEMSETTINGS ModemSettings;
    ULONG InactivityScale;

    ERESOURCE    OpenCloseResource;

    KEVENT       RemoveEvent;

    DWORD        MinSystemPowerState;

    PIRP         WakeUpIrp;
    PIRP         WaitWakeIrp;

    BOOLEAN      CapsQueried;

    DEVICE_POWER_STATE  SystemPowerStateMap[PowerSystemMaximum];

    SYSTEM_POWER_STATE SystemWake;
    DEVICE_POWER_STATE DeviceWake;


    DEVICE_POWER_STATE  LastDevicePowerState;

    PVOID     PowerSystemState;

    DWORD     ModemOwnsPolicy;

    LONG      PowerDelay;
    LONG      ConfigDelay;

#ifdef _AT_V

    CHAR      DleBuffer[MAX_DLE_BUFFER_SIZE];
    DWORD     DleCount;

    DWORD     DleMatchingState;

    BOOLEAN   DleMonitoringEnabled;

    BOOLEAN   DleWriteShielding;

    BOOLEAN   WakeOnRingEnabled;

    PIRP      DleWaitIrp;

    KDPC      WaveStopDpc;

    DWORD     WaveStopState;

    IPC_CONTROL   IpcControl[2];

    READ_WRITE_CONTROL  WriteIrpControl;

    READ_WRITE_CONTROL  ReadIrpControl;

#endif


} DEVICE_EXTENSION,*PDEVICE_EXTENSION;

BOOLEAN _inline
CanIrpGoThrough(
    PDEVICE_EXTENSION     DeviceExtension,
    PIO_STACK_LOCATION   IrpSp
    )

{

    //
    //  can passthrough if
    //
    //  1. is tsp owner handle
    //  2. Is in passthrough mode and handle's session number is current
    //
    return ((IrpSp->FileObject->FsContext != NULL)
            ||
            ((DeviceExtension->PassThrough != MODEM_NOPASSTHROUGH)
             &&
             (IrpSp->FileObject->FsContext2 == IntToPtr(DeviceExtension->CurrentPassThroughSession))));

}



VOID
WaveStopDpcHandler(
    PKDPC  Dpc,
    PVOID  Context,
    PVOID  SysArg1,
    PVOID  SysArg2
    );



NTSTATUS
UniOpen(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
UniClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
UniLogError(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT DeviceObject OPTIONAL,
    IN ULONG SequenceNumber,
    IN UCHAR MajorFunctionCode,
    IN UCHAR RetryCount,
    IN ULONG UniqueErrorValue,
    IN NTSTATUS FinalStatus,
    IN NTSTATUS SpecificIOStatus,
    IN ULONG LengthOfInsert1,
    IN PWCHAR Insert1,
    IN ULONG LengthOfInsert2,
    IN PWCHAR Insert2
    );

NTSTATUS
UniIoControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
UniReadWrite(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
UniRead(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
UniWrite(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );


NTSTATUS
ModemWmi(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );


NTSTATUS
UniSniffOwnerSettings(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
UniCheckPassThrough(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
UniNoCheckPassThrough(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );


NTSTATUS
ModemPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );


typedef
NTSTATUS
(*PUNI_START_ROUTINE) (
    IN PDEVICE_EXTENSION Extension
    );

typedef
VOID
(*PUNI_GET_NEXT_ROUTINE) (
    IN PIRP *CurrentOpIrp,
    IN PLIST_ENTRY QueueToProcess,
    OUT PIRP *NewIrp,
    IN BOOLEAN CompleteCurrent
    );

NTSTATUS
UniStartOrQueue(
    IN PDEVICE_EXTENSION Extension,
    IN PKSPIN_LOCK QueueLock,
    IN PIRP Irp,
    IN PLIST_ENTRY QueueToExamine,
    IN PIRP *CurrentOpIrp,
    IN PUNI_START_ROUTINE Starter
    );

VOID
UniGetNextIrp(
    IN PDEVICE_OBJECT  DeviceObject,
    IN PKSPIN_LOCK QueueLock,
    IN PIRP *CurrentOpIrp,
    IN PLIST_ENTRY QueueToProcess,
    OUT PIRP *NextIrp,
    IN BOOLEAN CompleteCurrent
    );



NTSTATUS
UniMaskStarter(
    IN PDEVICE_EXTENSION Extension
    );

NTSTATUS
UniGeneralMaskComplete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

VOID
UniRundownShuttledWait(
    IN PDEVICE_EXTENSION Extension,
    IN PIRP *ShuttlePointer,
    IN ULONG ReferenceMask,
    IN PIRP IrpToRunDown,
    IN KIRQL DeviceLockIrql,
    IN NTSTATUS StatusToComplete,
    IN ULONG MaskCompleteValue
    );

VOID
UniCancelShuttledWait(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
UniGeneralWaitComplete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

VOID
UniChangeShuttledToPassDown(
    IN PMASKSTATE ChangingState,
    IN KIRQL OrigIrql
    );

NTSTATUS
UniMakeIrpShuttledWait(
    IN PMASKSTATE MaskState,
    IN PIRP Irp,
    IN KIRQL OrigIrql,
    IN BOOLEAN GetNextIrpInQueue,
    OUT PIRP *NewIrp
    );

NTSTATUS
UniValidateNewCommConfig(
    IN PDEVICE_EXTENSION Extension,
    IN PIRP Irp,
    IN BOOLEAN Owner
    );

NTSTATUS
UniCleanup(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );



VOID
GetPutCancelRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );


VOID
EmptyIpcQueue(
    PDEVICE_EXTENSION    DeviceExtension,
    PLIST_ENTRY          List
    );

VOID
QueueMessageIrp(
    PDEVICE_EXTENSION   Extension,
    PIRP                Irp
    );

VOID
QueueLoopbackMessageIrp(
    PDEVICE_EXTENSION   Extension,
    PIRP                Irp
    );



NTSTATUS
CheckStateAndAddReference(
    PDEVICE_OBJECT   DeviceObject,
    PIRP             Irp
    );

NTSTATUS
CheckStateAndAddReferencePower(
    PDEVICE_OBJECT   DeviceObject,
    PIRP             Irp
    );

NTSTATUS
CheckStateAndAddReferenceWMI(
    PDEVICE_OBJECT   DeviceObject,
    PIRP             Irp
    );


VOID
RemoveReferenceAndCompleteRequest(
    PDEVICE_OBJECT    DeviceObject,
    PIRP              Irp,
    NTSTATUS          StatusToReturn
    );

VOID
RemoveReference(
    PDEVICE_OBJECT    DeviceObject
    );

VOID
CompletePowerWait(
    PDEVICE_OBJECT   DeviceObject,
    NTSTATUS         Status
    );

BOOL
HasIrpBeenCanceled(
    PIRP    Irp
    );



#define RemoveReferenceForDispatch  RemoveReference
#define RemoveReferenceForIrp       RemoveReference

VOID
InitIrpQueue(
    PREAD_WRITE_CONTROL Control,
    PDEVICE_OBJECT      DeviceObject,
    IRPSTARTER          Starter
    );

NTSTATUS
WriteIrpStarter(
    PREAD_WRITE_CONTROL Control,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
MarkQueueToEmpty(
    PREAD_WRITE_CONTROL Control
    );


VOID
CleanUpQueuedIrps(
    PREAD_WRITE_CONTROL Control,
    NTSTATUS            Status
    );


NTSTATUS
ReadIrpStarter(
    PREAD_WRITE_CONTROL Control,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
HandleDleIrp(
    PDEVICE_EXTENSION deviceExtension
    );

VOID
CancelWaitWake(
    PDEVICE_EXTENSION    DeviceExtension
    );

NTSTATUS
ModemGetRegistryKeyValue (
    IN PDEVICE_OBJECT   Pdo,
    IN ULONG            DevInstKeyType,
    IN PWCHAR KeyNameString,
    IN PVOID Data,
    IN ULONG DataLength
    );

NTSTATUS
ModemSetRegistryKeyValue(
        IN PDEVICE_OBJECT   Pdo,
        IN ULONG            DevInstKeyType,
        IN PWCHAR           KeyNameString,
        IN ULONG            DataType,
        IN PVOID            Data,
        IN ULONG            DataLength);

NTSTATUS
CreateChildPdo(
    PDEVICE_EXTENSION   DeviceExtension
    );

NTSTATUS
ModemPdoPnp (
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp
    );

NTSTATUS
ModemPdoPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ModemPdoWmi(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

#define LEAVE_NEXT_AS_IS      FALSE
#define COPY_CURRENT_TO_NEXT  TRUE

NTSTATUS
WaitForLowerDriverToCompleteIrp(
    PDEVICE_OBJECT    TargetDeviceObject,
    PIRP              Irp,
    BOOLEAN           CopyCurrentToNext
    );


NTSTATUS
EnableDisableSerialWaitWake(
    PDEVICE_EXTENSION    deviceExtension,
    BOOLEAN              Enable
    );


NTSTATUS ForwardIrp(
    PDEVICE_OBJECT   NextDevice,
    PIRP   Irp
    );

NTSTATUS
QueryDeviceCaps(
    PDEVICE_OBJECT    Pdo,
    PDEVICE_CAPABILITIES   Capabilities
    );


NTSTATUS
RemoveWaveDriverRegKeyValue(
    PDEVICE_OBJECT    Pdo
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\sys\modem\open.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    open.c

Abstract:

    This module contains the code that is very specific to open
    and close operations in the modem driver

Author:

    Anthony V. Ercolano 13-Aug-1995

Environment:

    Kernel mode

Revision History :

--*/

#include "precomp.h"

NTSTATUS
UniOpenStarter(
    IN PDEVICE_EXTENSION Extension,
    IN PIRP              Irp
    );

NTSTATUS
UniCloseStarter(
    IN PDEVICE_EXTENSION Extension,
    IN PIRP              Irp
    );


NTSTATUS
UniCloseComplete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );


NTSTATUS
SetDtr(
    PDEVICE_EXTENSION    deviceExtension,
    BOOLEAN              Enable
    );

VOID
ModemSleep(
    LONG   MilliSeconds
    );


NTSTATUS
StartDevicePower(
    PDEVICE_EXTENSION   DeviceExtension
    );

NTSTATUS
BinaryQueryRegRoutine(
    PWSTR    ValueName,
    ULONG    ValueType,
    PVOID    ValueData,
    ULONG    ValueLength,
    PVOID    Context,
    PVOID    EntryContext
    );


#pragma alloc_text(PAGE,UniOpen)
#pragma alloc_text(PAGE,UniClose)
#pragma alloc_text(PAGE,UniOpenStarter)
#pragma alloc_text(PAGE,UniCloseStarter)
#pragma alloc_text(PAGE,EnableDisableSerialWaitWake)
#pragma alloc_text(PAGE,StartDevicePower)
#pragma alloc_text(PAGE,SetDtr)
#pragma alloc_text(PAGE,ModemSleep)
#pragma alloc_text(PAGE,BinaryQueryRegRoutine)
#pragma alloc_text(PAGEUMDM,UniCleanup)


NTSTATUS
EnableDisableSerialWaitWake(
    PDEVICE_EXTENSION    deviceExtension,
    BOOLEAN              Enable
    )

{
    PIRP   TempIrp;
    KEVENT Event;
    IO_STATUS_BLOCK   IoStatus;
    NTSTATUS          status=STATUS_SUCCESS;

    KeInitializeEvent(
        &Event,
        NotificationEvent,
        FALSE
        );

    //
    //  build an IRP to send to the attched to driver to see if modem
    //  is in the stack.
    //
    TempIrp=IoBuildDeviceIoControlRequest(
        Enable ? IOCTL_SERIAL_INTERNAL_DO_WAIT_WAKE : IOCTL_SERIAL_INTERNAL_CANCEL_WAIT_WAKE,
        deviceExtension->AttachedDeviceObject,
        NULL,
        0,
        NULL,
        0,
        TRUE,  //internal
        &Event,
        &IoStatus
        );

    if (TempIrp == NULL) {

        status = STATUS_INSUFFICIENT_RESOURCES;

    } else {

        status = IoCallDriver(deviceExtension->AttachedDeviceObject, TempIrp);

        if (status == STATUS_PENDING) {

             D_ERROR(DbgPrint("MODEM: Waiting for PDO\n");)

             KeWaitForSingleObject(
                 &Event,
                 Executive,
                 KernelMode,
                 FALSE,
                 NULL
                 );

             status=IoStatus.Status;
        }


        TempIrp=NULL;


    }

    D_ERROR(if (!NT_SUCCESS(status)) {DbgPrint("MODEM: EnableWaitWake Status=%08lx\n",status);})

    return status;

}

NTSTATUS
SetDtr(
    PDEVICE_EXTENSION    deviceExtension,
    BOOLEAN              Enable
    )

{
    PIRP   TempIrp;
    KEVENT Event;
    IO_STATUS_BLOCK   IoStatus;
    NTSTATUS          status=STATUS_SUCCESS;

    KeInitializeEvent(
        &Event,
        NotificationEvent,
        FALSE
        );

    //
    //  build an IRP to send to the attched to driver to see if modem
    //  is in the stack.
    //
    TempIrp=IoBuildDeviceIoControlRequest(
        IOCTL_SERIAL_SET_DTR,
        deviceExtension->AttachedDeviceObject,
        NULL,
        0,
        NULL,
        0,
        FALSE,  //internal
        &Event,
        &IoStatus
        );

    if (TempIrp == NULL) {

        status = STATUS_INSUFFICIENT_RESOURCES;

    } else {

        status = IoCallDriver(deviceExtension->AttachedDeviceObject, TempIrp);

        if (status == STATUS_PENDING) {

             D_ERROR(DbgPrint("MODEM: Waiting for PDO\n");)

             KeWaitForSingleObject(
                 &Event,
                 Executive,
                 KernelMode,
                 FALSE,
                 NULL
                 );

             status=IoStatus.Status;
        }


        TempIrp=NULL;


    }

    D_ERROR(if (!NT_SUCCESS(status)) {DbgPrint("MODEM: SetDtr Status=%08lx\n",status);})

    return status;

}

VOID
ModemSleep(
    LONG   MilliSeconds
    )

{
    LONGLONG    WaitTime=Int32x32To64(MilliSeconds,-10000);

    ASSERT(MilliSeconds < 60*1000);

    if (MilliSeconds > 0) {

        KeDelayExecutionThread(
            KernelMode,
            FALSE,
            (LARGE_INTEGER*)&WaitTime
            );
    }

    return;
}




NTSTATUS
UniOpen(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

{

    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    NTSTATUS          status;

    //
    //  increment the open count here so the check will pass
    //
    InterlockedIncrement(&deviceExtension->OpenCount);

    //
    //  make sure the device is ready for irp's
    //
    status=CheckStateAndAddReference(
        DeviceObject,
        Irp
        );

    InterlockedDecrement(&deviceExtension->OpenCount);

    if (STATUS_SUCCESS != status) {
        //
        //  not accepting irp's. The irp has already been complted
        //
        return status;

    }

    KeEnterCriticalRegion();

    ExAcquireResourceExclusiveLite(
        &deviceExtension->OpenCloseResource,
        TRUE
        );


    if (deviceExtension->Started) {

        status = UniOpenStarter(deviceExtension,Irp);

    } else {
        //
        //  not started
        //
        status = STATUS_PORT_DISCONNECTED;
    }

    ExReleaseResourceLite(
        &deviceExtension->OpenCloseResource
        );

    KeLeaveCriticalRegion();

    RemoveReferenceAndCompleteRequest(
        DeviceObject,
        Irp,
        status
        );

    RemoveReferenceForDispatch(DeviceObject);

    return status;


}

NTSTATUS
UniClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

{

    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    NTSTATUS          status;

    D_TRACE(DbgPrint("Modem: Close\n");)

    InterlockedIncrement(&deviceExtension->ReferenceCount);

    if (deviceExtension->Removed) {
        //
        //  driver not accepting requests
        //
        D_ERROR(DbgPrint("MODEM: Close: removed!\n");)

        RemoveReferenceAndCompleteRequest(
            DeviceObject,
            Irp,
            STATUS_UNSUCCESSFUL
            );

        return STATUS_UNSUCCESSFUL;

    }

    KeEnterCriticalRegion();

    ExAcquireResourceExclusiveLite(
        &deviceExtension->OpenCloseResource,
        TRUE
        );

    status = UniCloseStarter(deviceExtension,Irp);

    ExReleaseResourceLite(
        &deviceExtension->OpenCloseResource
        );

    KeLeaveCriticalRegion();

    D_TRACE(DbgPrint("Modem: Close: RefCount=%d\n",deviceExtension->ReferenceCount);)

    RemoveReferenceAndCompleteRequest(
        DeviceObject,
        Irp,
        status
        );

    return status;
}

NTSTATUS
BinaryQueryRegRoutine(
    PWSTR    ValueName,
    ULONG    ValueType,
    PVOID    ValueData,
    ULONG    ValueLength,
    PVOID    Context,
    PVOID    EntryContext
    )

{
    PDEVICE_EXTENSION Extension=(PDEVICE_EXTENSION)Context;
    LONG              SizeOfDestination=-*((LONG*)EntryContext);

    if ((ValueType != REG_BINARY) && (ValueType != REG_DWORD)) {

        D_ERROR(DbgPrint("MODEM: BinaryQueryRegRoutine: bad reg type %d\n",ValueType);)

        return STATUS_INVALID_PARAMETER;
    }

    if ((ULONG)SizeOfDestination < ValueLength) {

        D_ERROR(DbgPrint("MODEM: BinaryQueryRegRoutine: Buffer too small %d < %d\n",SizeOfDestination,ValueLength);)

        return STATUS_BUFFER_TOO_SMALL;
    }

    RtlCopyMemory(EntryContext,ValueData,SizeOfDestination);

    return STATUS_SUCCESS;
}



NTSTATUS
UniOpenStarter(
    IN PDEVICE_EXTENSION Extension,
    IN PIRP              irp
    )

{

    NTSTATUS status = STATUS_SUCCESS;

    //
    // We use this to query into the registry for the attached
    // device.
    //
    RTL_QUERY_REGISTRY_TABLE paramTable[6];
    ACCESS_MASK accessMask = FILE_READ_ACCESS;
    PIO_STACK_LOCATION irpSp;

    HANDLE instanceHandle;
    MODEM_REG_PROP localProp;
    MODEM_REG_DEFAULT localDefault;
    UNICODE_STRING valueEntryName;
    KEY_VALUE_PARTIAL_INFORMATION localKeyValue;
    NTSTATUS junkStatus;
    ULONG neededLength;
    ULONG defaultInactivity = 10;
    ULONG DefaultPowerDelay=0;

    irpSp = IoGetCurrentIrpStackLocation(irp);

    irp->IoStatus.Status = STATUS_SUCCESS;
    irp->IoStatus.Information = 0;

    //
    // Make sure a directory open isn't going on here.
    //

    if (irpSp->Parameters.Create.Options & FILE_DIRECTORY_FILE) {

        irp->IoStatus.Status = STATUS_NOT_A_DIRECTORY;

        return STATUS_NOT_A_DIRECTORY;

    }



    if (irpSp->FileObject->FileName.Length == 0) {
        //
        //  no filename, must be a comx open
        //
        if (Extension->OpenCount != 0) {
            //
            //  can only be first
            //
            D_ERROR(DbgPrint("MODEM: Open: ComX open but not exclusive\n");)

            status = STATUS_SHARING_VIOLATION;
            irp->IoStatus.Status = status;
            goto leaveOpen;

        }

    } else {
        //
        //  has a file name, must be a unimodem component
        //
        BOOLEAN         Match;
        UNICODE_STRING  TspString;

        RtlInitUnicodeString(
            &TspString,
            L"\\Tsp"
            );

        Match=RtlEqualUnicodeString(&irpSp->FileObject->FileName,&TspString,TRUE);

        if (Match) {
            //
            //  open from tsp
            //
            if (Extension->OpenCount != 0) {
                //
                //  can only be first
                //
                D_ERROR(DbgPrint("MODEM: Open: TSP open but not exclusive\n");)

                status = STATUS_SHARING_VIOLATION;
                irp->IoStatus.Status = status;
                goto leaveOpen;

            }

        } else {

            RtlInitUnicodeString(
                &TspString,
                L"\\Client"
                );


            Match=RtlEqualUnicodeString(&irpSp->FileObject->FileName,&TspString,TRUE);

            if (Match) {
                //
                //  second open for client
                //
                if (Extension->OpenCount < 1) {
                    //
                    //  can't be the only one
                    //
                    D_ERROR(DbgPrint("MODEM: Open: Client open but no owner\n");)

                    status = STATUS_INVALID_PARAMETER;
                    irp->IoStatus.Status = status;
                    goto leaveOpen;

                }

            } else {

                RtlInitUnicodeString(
                    &TspString,
                    L"\\Wave"
                    );


                Match=RtlEqualUnicodeString(&irpSp->FileObject->FileName,&TspString,TRUE);

                if (Match) {
                    //
                    //  wave driver open
                    //
                    if ((Extension->OpenCount != 1)
                        ||
                        (Extension->ProcAddress == NULL)
                        ||
                        (IsListEmpty(&Extension->IpcControl[CONTROL_HANDLE].GetList) && !Extension->DleMonitoringEnabled)
                        ) {

                        D_ERROR(DbgPrint("MODEM: Open: Wave Driver, open=%d\n",Extension->OpenCount);)

                        status=STATUS_INVALID_PARAMETER;
                        irp->IoStatus.Status = status;
                        goto leaveOpen;


                    }

                } else {

                    D_ERROR(DbgPrint("MODEM: Open: Bad file name\n");)

                    status = STATUS_INVALID_PARAMETER;
                    irp->IoStatus.Status = status;
                    goto leaveOpen;

                }
            }
        }
    }

    //
    // We are the only ones here.  If we are not the first
    // then not much work to do.
    //

    if (Extension->OpenCount > 0) {

        //
        // Already been opened once.  We will succeed if there
        // currently a controlling open.  If not, then we should
        // fail.
        //

        if (Extension->ProcAddress) {

            //
            //
            // A ok.  Increment the reference and
            // leave.
            //
            irpSp->FileObject->FsContext=CLIENT_HANDLE;
            irpSp->FileObject->FsContext2=IntToPtr(Extension->CurrentPassThroughSession);
            Extension->OpenCount++;
            Extension->IpcControl[CLIENT_HANDLE].CurrentSession++;
            goto leaveOpen;

        } else {

            status = STATUS_INVALID_PARAMETER;
            irp->IoStatus.Status = status;
            goto leaveOpen;

        }

    }

    //
    // Given our device instance go get a handle to the Device.
    //
    junkStatus=IoOpenDeviceRegistryKey(
        Extension->Pdo,
        PLUGPLAY_REGKEY_DRIVER,
        accessMask,
        &instanceHandle
        );

    if (!NT_SUCCESS(junkStatus)) {

        status = STATUS_INVALID_PARAMETER;
        irp->IoStatus.Status = status;
        goto leaveOpen;
    }

    RtlZeroMemory(
        &paramTable[0],
        sizeof(paramTable)
        );
    //
    // Entry for the modem reg properties
    //

    paramTable[0].Flags = RTL_QUERY_REGISTRY_REQUIRED;
    paramTable[0].QueryRoutine=BinaryQueryRegRoutine;
    paramTable[0].Name = L"Properties";
    paramTable[0].EntryContext = &localProp;


    //
    // Note that rtlqueryregistryvalues has a real hack
    // way of getting binary data.  We also have to add
    // the *negative* length that we want to the beginning
    // of the buffer.
    //
    *(PLONG)&localProp.dwDialOptions = -((LONG)sizeof(localProp));

    //
    // Read in the default config from the registry.
    //

    paramTable[1].Flags =  RTL_QUERY_REGISTRY_REQUIRED;
    paramTable[1].QueryRoutine=BinaryQueryRegRoutine;
    paramTable[1].Name = L"Default";
    paramTable[1].EntryContext = &localDefault;
    *(PLONG)&localDefault.dwCallSetupFailTimer = -((LONG)sizeof(localDefault));


    paramTable[2].Flags = 0;
    paramTable[2].QueryRoutine=BinaryQueryRegRoutine;
    paramTable[2].Name = L"InactivityScale";
    paramTable[2].EntryContext = &Extension->InactivityScale;
    paramTable[2].DefaultType = REG_BINARY;
    paramTable[2].DefaultLength = sizeof(Extension->InactivityScale);
    paramTable[2].DefaultData = &defaultInactivity;
    *(PLONG)&Extension->InactivityScale = -((LONG)sizeof(Extension->InactivityScale));


    paramTable[3].Flags = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[3].Name = L"PowerDelay";
    paramTable[3].EntryContext = &Extension->PowerDelay;
    paramTable[3].DefaultType = REG_DWORD;
    paramTable[3].DefaultLength = sizeof(Extension->PowerDelay);
    paramTable[3].DefaultData = &DefaultPowerDelay;

    paramTable[4].Flags = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[4].Name = L"ConfigDelay";
    paramTable[4].EntryContext = &Extension->ConfigDelay;
    paramTable[4].DefaultType = REG_DWORD;
    paramTable[4].DefaultLength = sizeof(Extension->ConfigDelay);
    paramTable[4].DefaultData = &DefaultPowerDelay;


    if (!NT_SUCCESS(RtlQueryRegistryValues(
                        RTL_REGISTRY_HANDLE,
                        instanceHandle,
                        &paramTable[0],
                        Extension,
                        NULL
                        ))) {

        status = STATUS_INVALID_PARAMETER;
        irp->IoStatus.Status = status;

        //
        // Before we leave, Close the handle to the device instance.
        //
        ZwClose(instanceHandle);
        goto leaveOpen;

    }

    //
    // Clean out the old devcaps and settings.
    //

    RtlZeroMemory(
        &Extension->ModemDevCaps,
        sizeof(MODEMDEVCAPS)
        );
    RtlZeroMemory(
        &Extension->ModemSettings,
        sizeof(MODEMSETTINGS)
        );

    //
    // Get the lengths each of the manufacture, model and version.
    //
    // We can get this by doing a query for the partial with a
    // short buffer.  The return value from the call will tell us
    // how much we actually need (plus null termination).
    //

    RtlInitUnicodeString(
        &valueEntryName,
        L"Manufacturer"
        );
    localKeyValue.DataLength = sizeof(UCHAR);
    junkStatus = ZwQueryValueKey(
                     instanceHandle,
                     &valueEntryName,
                     KeyValuePartialInformation,
                     &localKeyValue,
                     sizeof(localKeyValue),
                     &neededLength
                     );

    if ((junkStatus == STATUS_SUCCESS) ||
        (junkStatus == STATUS_BUFFER_OVERFLOW)) {

        Extension->ModemDevCaps.dwModemManufacturerSize = localKeyValue.DataLength-sizeof(UNICODE_NULL);


    } else {

        Extension->ModemDevCaps.dwModemManufacturerSize = 0;

    }

    RtlInitUnicodeString(
        &valueEntryName,
        L"Model"
        );
    localKeyValue.DataLength = sizeof(UCHAR);
    junkStatus = ZwQueryValueKey(
                     instanceHandle,
                     &valueEntryName,
                     KeyValuePartialInformation,
                     &localKeyValue,
                     sizeof(localKeyValue),
                     &neededLength
                     );

    if ((junkStatus == STATUS_SUCCESS) ||
        (junkStatus == STATUS_BUFFER_OVERFLOW)) {

        Extension->ModemDevCaps.dwModemModelSize = localKeyValue.DataLength-sizeof(UNICODE_NULL);

    } else {

        Extension->ModemDevCaps.dwModemModelSize = 0;

    }

    RtlInitUnicodeString(
        &valueEntryName,
        L"Version"
        );
    localKeyValue.DataLength = sizeof(UCHAR);
    junkStatus = ZwQueryValueKey(
                     instanceHandle,
                     &valueEntryName,
                     KeyValuePartialInformation,
                     &localKeyValue,
                     sizeof(localKeyValue),
                     &neededLength
                     );

    if ((junkStatus == STATUS_SUCCESS) ||
        (junkStatus == STATUS_BUFFER_OVERFLOW)) {

        Extension->ModemDevCaps.dwModemVersionSize = localKeyValue.DataLength-sizeof(UNICODE_NULL);

    } else {

        Extension->ModemDevCaps.dwModemVersionSize = 0;

    }

    ZwClose(instanceHandle);

    //
    // Move the properties and the defaults into the extension.
    //

    Extension->ModemDevCaps.dwDialOptions = localProp.dwDialOptions;
    Extension->ModemDevCaps.dwCallSetupFailTimer =
        localProp.dwCallSetupFailTimer;
    Extension->ModemDevCaps.dwInactivityTimeout =
        localProp.dwInactivityTimeout;
    Extension->ModemDevCaps.dwSpeakerVolume = localProp.dwSpeakerVolume;
    Extension->ModemDevCaps.dwSpeakerMode = localProp.dwSpeakerMode;
    Extension->ModemDevCaps.dwModemOptions = localProp.dwModemOptions;
    Extension->ModemDevCaps.dwMaxDTERate = localProp.dwMaxDTERate;
    Extension->ModemDevCaps.dwMaxDCERate = localProp.dwMaxDCERate;

    Extension->ModemDevCaps.dwActualSize = FIELD_OFFSET(
                                                MODEMDEVCAPS,
                                                abVariablePortion
                                                );

    Extension->ModemDevCaps.dwRequiredSize = Extension->ModemDevCaps.dwActualSize +
        Extension->ModemDevCaps.dwModemManufacturerSize +
        Extension->ModemDevCaps.dwModemModelSize +
        Extension->ModemDevCaps.dwModemVersionSize;



    Extension->ModemSettings.dwCallSetupFailTimer =
        localDefault.dwCallSetupFailTimer;
    Extension->ModemSettings.dwInactivityTimeout =
        localDefault.dwInactivityTimeout * Extension->InactivityScale;
    Extension->ModemSettings.dwSpeakerVolume = localDefault.dwSpeakerVolume;
    Extension->ModemSettings.dwSpeakerMode = localDefault.dwSpeakerMode;
    Extension->ModemSettings.dwPreferredModemOptions =
        localDefault.dwPreferredModemOptions;

    Extension->ModemSettings.dwActualSize = sizeof(MODEMSETTINGS);

    Extension->ModemSettings.dwRequiredSize = sizeof(MODEMSETTINGS);
    Extension->ModemSettings.dwDevSpecificOffset = 0;
    Extension->ModemSettings.dwDevSpecificSize = 0;

    //
    //  attempt to power laim modems up here before we have the serial driver does it.
    //
    StartDevicePower(
        Extension
        );

    //
    //  send irp to serial FDO
    //
    status=WaitForLowerDriverToCompleteIrp(
            Extension->LowerDevice,
            irp,
            COPY_CURRENT_TO_NEXT
            );

    if (NT_SUCCESS(status)) {

        Extension->AttachedDeviceObject=Extension->LowerDevice;

    } else {

        D_ERROR(DbgPrint("MODEM: serial failed create Irp, %08lx\n",status);)

        irp->IoStatus.Status = status;
        goto leaveOpen;

    }

    //
    // We have the device open.  Increment our irp stack size
    // by the stack size of the attached device.
    //
    {
        UCHAR    StackDepth;

        StackDepth= Extension->AttachedDeviceObject->StackSize > Extension->LowerDevice->StackSize ?
                        Extension->AttachedDeviceObject->StackSize : Extension->LowerDevice->StackSize;

        Extension->DeviceObject->StackSize = 1 + StackDepth;
    }



    SetDtr(
        Extension,
        TRUE
        );

    EnableDisableSerialWaitWake(
        Extension,
        Extension->WakeOnRingEnabled
        );


    //
    //  give pc-card modems a little more time if they need it
    //
    ModemSleep(Extension->ConfigDelay);


    Extension->WriteIrpControl.Write.LowerDevice=Extension->AttachedDeviceObject;
    Extension->ReadIrpControl.Read.LowerDevice=Extension->AttachedDeviceObject;


    irpSp->FileObject->FsContext = (PVOID)1;
    Extension->PassThrough = MODEM_PASSTHROUGH;
    Extension->OpenCount = 1;
    Extension->ProcAddress = IoGetCurrentProcess();

    //
    // Allocate an IRP for use in processing wait operations.
    //
    {
        PIRP    WaitIrp;
        PIO_STACK_LOCATION waitSp;

        WaitIrp = IoAllocateIrp(
                                    Extension->DeviceObject->StackSize,
                                    FALSE
                                    );

        if (!WaitIrp) {

            status = STATUS_INSUFFICIENT_RESOURCES;

            //
            // Call the close routine, it knows what to do with
            // the various system objects.
            //

            UniCloseStarter(Extension,irp);

            irp->IoStatus.Status = status;

            goto leaveOpen;

        }

        WaitIrp->Flags = IRP_BUFFERED_IO | IRP_DEALLOCATE_BUFFER;
        WaitIrp->UserBuffer = NULL;
        WaitIrp->AssociatedIrp.SystemBuffer = NULL;
        WaitIrp->UserEvent = NULL;
        WaitIrp->UserIosb = NULL;

        WaitIrp->CurrentLocation--;
        waitSp = IoGetNextIrpStackLocation(WaitIrp);
        WaitIrp->Tail.Overlay.CurrentStackLocation = waitSp;
        waitSp->DeviceObject = Extension->DeviceObject;

        RETURN_OUR_WAIT_IRP(Extension,WaitIrp);
    }

    Extension->DleMonitoringEnabled=FALSE;
    Extension->DleWriteShielding=FALSE;

    Extension->MinSystemPowerState=PowerSystemHibernate;

    Extension->IpcServerRunning=FALSE;
    //
    // Clean up any trash left in our maskstates.
    //
    Extension->MaskStates[0].SetMaskCount = 0;
    Extension->MaskStates[1].SetMaskCount = 0;
    Extension->MaskStates[0].SentDownSetMasks = 0;
    Extension->MaskStates[1].SentDownSetMasks = 0;
    Extension->MaskStates[0].Mask = 0;
    Extension->MaskStates[1].Mask = 0;
    Extension->MaskStates[0].HistoryMask = 0;
    Extension->MaskStates[1].HistoryMask = 0;
    Extension->MaskStates[0].ShuttledWait = 0;
    Extension->MaskStates[1].ShuttledWait = 0;
    Extension->MaskStates[0].PassedDownWait = 0;
    Extension->MaskStates[1].PassedDownWait = 0;

    MmLockPagableSectionByHandle(PagedCodeSectionHandle);

    status = STATUS_SUCCESS;

leaveOpen:
    return status;

}



NTSTATUS
UniCloseStarter(
    IN PDEVICE_EXTENSION Extension,
    PIRP                 irp
    )

{

    NTSTATUS status = STATUS_SUCCESS;

    Extension->OpenCount--;

    //
    // Here is where we should do the check whether
    // we are the open handle for the controlling
    // open.  If we are then we should null the controlling
    // open.
    //

    if (IoGetCurrentIrpStackLocation(irp)->FileObject->FsContext) {

        Extension->ProcAddress = NULL;
        IoGetCurrentIrpStackLocation(irp)->FileObject->FsContext = NULL;

        Extension->PassThrough = MODEM_NOPASSTHROUGH;

    }

    if (Extension->OpenCount == 0) {

        //
        // No references to anything.  It's safe to get
        // rid of the irp that we allocated.  (We check
        // for non-null pointer incase this call is done
        // in response to NOT being able to allocate
        // this irp.)
        //
        PIRP   WaitIrp;

        WaitIrp=RETREIVE_OUR_WAIT_IRP(Extension);

        if (WaitIrp) {

            IoFreeIrp(WaitIrp);
        }

        status=WaitForLowerDriverToCompleteIrp(
            Extension->LowerDevice,
            irp,
            COPY_CURRENT_TO_NEXT
            );

        Extension->MinSystemPowerState=PowerSystemHibernate;

        Extension->IpcServerRunning=FALSE;

        if (Extension->PowerSystemState != NULL) {

            PoUnregisterSystemState(
                Extension->PowerSystemState
                );

            Extension->PowerSystemState=NULL;
        }



        MmUnlockPagableImageSection(PagedCodeSectionHandle);

    }
    irp->IoStatus.Status = status;
    irp->IoStatus.Information=0L;

    return status;

}




NTSTATUS
UniCleanup(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

{

    PDEVICE_EXTENSION extension = DeviceObject->DeviceExtension;
    KIRQL origIrql;
    PMASKSTATE thisMaskState = &extension->MaskStates[
        IoGetCurrentIrpStackLocation(Irp)->FileObject->FsContext?
            CONTROL_HANDLE:
            CLIENT_HANDLE
            ];


    if (extension->OpenCount < 1) {
        //
        //  Device is not open, see bug 253109
        //
        Irp->IoStatus.Status = STATUS_SUCCESS;
        Irp->IoStatus.Information = 0ul;
        IoCompleteRequest(
            Irp,
            IO_NO_INCREMENT
            );
        return STATUS_SUCCESS;

    }



    //
    // If this open has a shuttled read or write kill it.  We know that
    // another won't come through because the IO subsystem won't let
    // it.
    //

    KeAcquireSpinLock(
        &extension->DeviceLock,
        &origIrql
        );


    if (thisMaskState->ShuttledWait) {

        PIRP savedIrp = thisMaskState->ShuttledWait;

        thisMaskState->ShuttledWait = NULL;

        UniRundownShuttledWait(
            extension,
            &thisMaskState->ShuttledWait,
            UNI_REFERENCE_NORMAL_PATH,
            savedIrp,
            origIrql,
            STATUS_SUCCESS,
            0ul
            );

    } else {

        KeReleaseSpinLock(
            &extension->DeviceLock,
            origIrql
            );

    }



    {
        ULONG_PTR    OwnerClient=(ULONG_PTR)IoGetCurrentIrpStackLocation(Irp)->FileObject->FsContext;

        EmptyIpcQueue(
            extension,
            &extension->IpcControl[OwnerClient].GetList
            );


        EmptyIpcQueue(
            extension,
            &extension->IpcControl[OwnerClient].PutList
            );


        if (OwnerClient == CONTROL_HANDLE) {
            //
            //  if tht tsp is closing clearout any wave driver requests
            //
            EmptyIpcQueue(
                extension,
                &extension->IpcControl[CLIENT_HANDLE].GetList
                );
        }


        //
        //  Clear out any send irps from the other handle, leave gets irps though
        //
        EmptyIpcQueue(
            extension,
            &extension->IpcControl[(OwnerClient == CONTROL_HANDLE) ? CLIENT_HANDLE : CONTROL_HANDLE].PutList
            );


    }



    //
    // If this is the controlling open then we let the cleanup go
    // on down.  If we let every cleanup go down then clients closing
    // could mess up the owners reads or writes.
    //

    if (IoGetCurrentIrpStackLocation(Irp)->FileObject->FsContext) {

        CompletePowerWait(
            DeviceObject,
            STATUS_CANCELLED
            );

        return ForwardIrp(
                   extension->AttachedDeviceObject,
                   Irp
                   );

    } else {

        Irp->IoStatus.Status = STATUS_SUCCESS;
        Irp->IoStatus.Information = 0ul;
        IoCompleteRequest(
            Irp,
            IO_NO_INCREMENT
            );
        return STATUS_SUCCESS;

    }

}

typedef struct _MODEM_POWER_BLOCK {

    NTSTATUS   Status;
    KEVENT     Event;

} MODEM_POWER_BLOCK, *PMODEM_POWER_BLOCK;


VOID
SetPowerCompletion(
    PDEVICE_OBJECT     DeviceObject,
    UCHAR              MinorFunction,
    POWER_STATE        PowerState,
    PVOID              Context,
    PIO_STATUS_BLOCK   IoStatus
    )

{
    PMODEM_POWER_BLOCK    PowerBlock=Context;

    PowerBlock->Status=IoStatus->Status;
    KeSetEvent(&PowerBlock->Event, IO_NO_INCREMENT, FALSE);

    return;
}

NTSTATUS
StartDevicePower(
    PDEVICE_EXTENSION   DeviceExtension
    )

{
    NTSTATUS    Status;
    MODEM_POWER_BLOCK    PowerBlock;
    KEVENT      Event;

    POWER_STATE  PowerState;

    if ((DeviceExtension->PowerDelay == 0) || (DeviceExtension->LastDevicePowerState == PowerDeviceD0)) {
        //
        //  no delay, or it is already powered
        //
        return STATUS_SUCCESS;
    }

    KeInitializeEvent(&PowerBlock.Event, NotificationEvent, FALSE);

    PowerState.DeviceState=PowerDeviceD0;

    Status=PoRequestPowerIrp(
        DeviceExtension->Pdo,
        IRP_MN_SET_POWER,
        PowerState,
        SetPowerCompletion,
        &PowerBlock,
        NULL
        );

    if (Status == STATUS_PENDING) {

         KeWaitForSingleObject(
             &PowerBlock.Event,
             Executive,
             KernelMode,
             FALSE,
             NULL
             );

        Status=PowerBlock.Status;
    }

    if (NT_SUCCESS(Status)) {
        //
        //  Delay for a while waiting for the device to become ready.
        //
        ModemSleep(DeviceExtension->PowerDelay);

    }

    return Status;


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\sys\modem\readwrit.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    readwrit.c

Abstract:

    This module contains the code that is very specific to the read/write
    operations in the modem driver

Author:

    Anthony V. Ercolano 20-Aug-1995

Environment:

    Kernel mode

Revision History :

--*/

#include "precomp.h"


#ifdef _AT_V

#define  DTMF_START                0x10
#define  DTMF_END                  0x11

#define  DTMF_0                    0x00
#define  DTMF_1                    0x01

#define  DTMF_2                    0x02
#define  DTMF_3                    0x03

#define  DTMF_4                    0x04
#define  DTMF_5                    0x05

#define  DTMF_6                    0x06
#define  DTMF_7                    0x07

#define  DTMF_8                    0x08
#define  DTMF_9                    0x09

#define  DTMF_A                    0x0a
#define  DTMF_B                    0x0b

#define  DTMF_C                    0x0c
#define  DTMF_D                    0x0d

#define  DTMF_STAR                 0x0e
#define  DTMF_POUND                0x0f

#define  DLE_______                0xff

#define  DLE_ETX                   0x20

#define  DLE_OFHOOK                0x21  //rockwell value

#define  DLE_ONHOOK                0x22

#define  DLE_RING                  0x23
#define  DLE_RINGBK                0x24

#define  DLE_ANSWER                0x25
#define  DLE_BUSY                  0x26

#define  DLE_FAX                   0x27
#define  DLE_DIALTN                0x28


#define  DLE_SILENC                0x29
#define  DLE_QUIET                 0x2a


#define  DLE_DATACT                0x2b
#define  DLE_BELLAT                0x2c

#define  DLE_LOOPIN               0x2d
#define  DLE_LOOPRV               0x2e

#endif


VOID
IrpCancelRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
QueueIrp(
    PREAD_WRITE_CONTROL Control,
    PIRP                Irp
    );

VOID
StartNextReadWriteIrp(
    PREAD_WRITE_CONTROL Control
    );



NTSTATUS
UniReadComplete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );


NTSTATUS
UniWriteComplete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );



VOID
HandleDleIrp(
    PDEVICE_EXTENSION deviceExtension
    );


#pragma alloc_text(PAGEUMDM,UniWrite)
#pragma alloc_text(PAGEUMDM,UniRead)
#pragma alloc_text(PAGEUMDM,ReadIrpStarter)
#pragma alloc_text(PAGEUMDM,UniReadComplete)
#pragma alloc_text(PAGEUMDM,HandleDleIrp)
#pragma alloc_text(PAGEUMDM,UniWriteComplete)
#pragma alloc_text(PAGEUMDM,WriteIrpStarter)
#pragma alloc_text(PAGEUMDM,QueueIrp)
#pragma alloc_text(PAGEUMDM,StartNextReadWriteIrp)
#pragma alloc_text(PAGEUMDM,IrpCancelRoutine)
#pragma alloc_text(PAGEUMDM,CleanUpQueuedIrps)

#if EXTRA_DBG

VOID
IsThisIrpAShuttledWait(
    PDEVICE_EXTENSION    DeviceExtension,
    PIRP                 Irp
    )

{
    if ((DeviceExtension->MaskStates[0].ShuttledWait == Irp)
        ||
        (DeviceExtension->MaskStates[1].ShuttledWait == Irp)) {

        DbgPrint("MODEM: A read/or write irp seems to also be a shuttled wait!\n");
        DbgBreakPoint();
    }
    return;
}

#endif


NTSTATUS
UniWrite(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

{

    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS status;

#if EXTRA_DBG
    IsThisIrpAShuttledWait(deviceExtension,Irp);
#endif


    //
    //  make sure the device is ready for irp's
    //
    status=CheckStateAndAddReference(
        DeviceObject,
        Irp
        );

    if (STATUS_SUCCESS != status) {
        //
        //  not accepting irp's. The irp has already been completed
        //
        return status;

    }



//    if (irpSp->FileObject->FsContext ||
//        (deviceExtension->PassThrough != MODEM_NOPASSTHROUGH)) {

    if (CanIrpGoThrough(deviceExtension,irpSp)) {

        if (!deviceExtension->DleWriteShielding) {
            //
            //  not shielding just do it
            //
            IoSkipCurrentIrpStackLocation(Irp);

            status=IoCallDriver(
                       deviceExtension->AttachedDeviceObject,
                       Irp
                       );

            RemoveReferenceForIrp(DeviceObject);

        } else {

            status=QueueIrp(
                &deviceExtension->WriteIrpControl,
                Irp
                );


        }

    } else {

        RemoveReferenceAndCompleteRequest(
            DeviceObject,
            Irp,
            STATUS_PORT_DISCONNECTED
            );

        status=STATUS_PORT_DISCONNECTED;

    }

    RemoveReferenceForDispatch(DeviceObject);

    return status;


}



NTSTATUS
UniRead(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

{

    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS status;

#if EXTRA_DBG
    IsThisIrpAShuttledWait(deviceExtension,Irp);
#endif

    //
    //  make sure the device is ready for irp's
    //
    status=CheckStateAndAddReference(
        DeviceObject,
        Irp
        );

    if (STATUS_SUCCESS != status) {
        //
        //  not accepting irp's. The irp has already been complted
        //
        return status;

    }


//    if (irpSp->FileObject->FsContext ||
//        (deviceExtension->PassThrough != MODEM_NOPASSTHROUGH)) {

      if (CanIrpGoThrough(deviceExtension,irpSp)) {

        if (!deviceExtension->DleMonitoringEnabled) {
            //
            //  not monitoring, just do it
            //
            IoSkipCurrentIrpStackLocation(Irp);

            status=IoCallDriver(
                       deviceExtension->AttachedDeviceObject,
                       Irp
                       );

            RemoveReferenceForIrp(DeviceObject);


        } else {

            status=QueueIrp(
                &deviceExtension->ReadIrpControl,
                Irp
                );


        }

    } else {

        RemoveReferenceAndCompleteRequest(
            DeviceObject,
            Irp,
            STATUS_PORT_DISCONNECTED
            );

        status=STATUS_PORT_DISCONNECTED;

    }

    RemoveReferenceForDispatch(DeviceObject);

    return status;


}


NTSTATUS
ReadIrpStarter(
    PREAD_WRITE_CONTROL Control,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

{

    PIO_STACK_LOCATION irpSp;

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    Control->Read.SystemBuffer=Irp->AssociatedIrp.SystemBuffer;
    Control->Read.CurrentTransferLength=irpSp->Parameters.Read.Length;
    Control->Read.TotalTransfered=0;

    IoCopyCurrentIrpStackLocationToNext(Irp);

    IoSetCompletionRoutine(
        Irp,
        UniReadComplete,
        Control,
        TRUE,
        TRUE,
        TRUE
        );

    IoMarkIrpPending(Irp);

    IoCallDriver(
        Control->Read.LowerDevice,
        Irp
        );

    return STATUS_PENDING;

}

NTSTATUS
UniReadComplete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:


Arguments:

    DeviceObject - Pointer to the device object for the modem.

    Irp - Pointer to the IRP for the current request.

    Context - Really a pointer to the Extension.

Return Value:

    Always return status_success.

--*/

{
    PREAD_WRITE_CONTROL Control=(PREAD_WRITE_CONTROL)Context;
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PUCHAR   Buffer;
    DWORD    Length;
    KIRQL    origIrql;
    DWORD    OriginalLength;
    BOOL     CompleteTransfer;

    PIO_STACK_LOCATION irpSp;
    PIO_STACK_LOCATION nextSp;


    irpSp = IoGetCurrentIrpStackLocation(Irp);
    nextSp = IoGetNextIrpStackLocation(Irp);

    if (NT_SUCCESS(Irp->IoStatus.Status) && !deviceExtension->Removing) {
        //
        //  we have data
        //
        CompleteTransfer = (Irp->IoStatus.Information == Control->Read.CurrentTransferLength) && (irpSp->Parameters.Read.Length > 40);

        Buffer=Irp->AssociatedIrp.SystemBuffer;
        Length=(DWORD)Irp->IoStatus.Information;
        OriginalLength=(DWORD)Irp->IoStatus.Information;

        while (Length != 0) {

            if (deviceExtension->DleMatchingState == DLE_STATE_IDLE) {

                if (*Buffer == DLE_CHAR) {
                    //
                    //  found a DLE
                    //
                    deviceExtension->DleMatchingState = DLE_STATE_WAIT_FOR_NEXT_CHAR;

                    RtlCopyMemory(
                        Buffer,
                        Buffer+1,
                        Length-1
                        );

                    Length--;
                    Irp->IoStatus.Information--;

                } else {
                    //
                    // normal char
                    //
                    Length--;
                    Buffer++;
                }

            } else {
                //
                //  wait for the next char
                //
                if (*Buffer != DLE_CHAR) {
                    //
                    //  not a second dle, store the char and remove
                    //

                    KeAcquireSpinLock(
                        &deviceExtension->DeviceLock,
                        &origIrql
                        );

                    if ((deviceExtension->DleCount < MAX_DLE_BUFFER_SIZE)) {

                        deviceExtension->DleBuffer[deviceExtension->DleCount]=*Buffer;
                        deviceExtension->DleCount++;
                    }

                    KeReleaseSpinLock(
                        &deviceExtension->DeviceLock,
                        origIrql
                        );


                    RtlCopyMemory(
                        Buffer,
                        Buffer+1,
                        Length-1
                        );

                    Length--;
                    Irp->IoStatus.Information--;

                } else {
                    //
                    //  this is a dle as well, just leave it where it is and continue
                    //
                    Length--;
                    Buffer++;
                }

                deviceExtension->DleMatchingState = DLE_STATE_IDLE;
            }
        }

        HandleDleIrp(
            deviceExtension
            );


        Control->Read.TotalTransfered+=(DWORD)Irp->IoStatus.Information;

        if ((CompleteTransfer && (Irp->IoStatus.Information != OriginalLength))
            ||
            ((Irp->IoStatus.Information==0) && (OriginalLength != 0)))     {
            //
            //  we got all the bytes we wanted, but a dle pair was removed
            //  Send the irp back down to fill it up
            //
            IoCopyCurrentIrpStackLocationToNext(Irp);

            (PUCHAR)Irp->AssociatedIrp.SystemBuffer+=Irp->IoStatus.Information;

            nextSp->Parameters.Read.Length=irpSp->Parameters.Read.Length-Control->Read.TotalTransfered;

            IoSetCompletionRoutine(
                Irp,
                UniReadComplete,
                Control,
                TRUE,
                TRUE,
                TRUE
                );

            IoCallDriver(
                Control->Read.LowerDevice,
                Irp
                );

            return STATUS_MORE_PROCESSING_REQUIRED;
        }

    } else {

        D_ERROR(DbgPrint("MODEM: UniReadComplete: status=%08lx\n",Irp->IoStatus.Status);)
    }

    Irp->AssociatedIrp.SystemBuffer=Control->Read.SystemBuffer;

    Irp->IoStatus.Information=Control->Read.TotalTransfered;

    //
    //  let this one complete and start the next one
    //
    StartNextReadWriteIrp(
        Control
        );

    //
    //  done with irp let it complete
    //
    RemoveReference(DeviceObject);

    return STATUS_SUCCESS;
}

VOID
HandleDleIrp(
    PDEVICE_EXTENSION deviceExtension
    )


{
    KIRQL    origIrql;
    PIRP    DleIrp=NULL;

    KeAcquireSpinLock(
        &deviceExtension->DeviceLock,
        &origIrql
        );


    if ((deviceExtension->DleCount > 0 ) && (deviceExtension->DleWaitIrp != NULL)) {

        DWORD   BytesToTransfer;

        PIO_STACK_LOCATION irpSp;

        if (!HasIrpBeenCanceled(deviceExtension->DleWaitIrp)) {
            //
            //  irp to be handled
            //
            DleIrp=deviceExtension->DleWaitIrp;

            deviceExtension->DleWaitIrp=NULL;

            irpSp = IoGetCurrentIrpStackLocation(DleIrp);

            BytesToTransfer = (deviceExtension->DleCount < irpSp->Parameters.DeviceIoControl.OutputBufferLength) ?
                                  deviceExtension->DleCount : irpSp->Parameters.DeviceIoControl.OutputBufferLength;


            RtlCopyMemory(
                DleIrp->AssociatedIrp.SystemBuffer,
                deviceExtension->DleBuffer,
                BytesToTransfer
                );


            deviceExtension->DleCount-=BytesToTransfer;

            //
            //  move any extra bytes down
            //
            RtlMoveMemory(
                deviceExtension->DleBuffer,
                deviceExtension->DleBuffer+BytesToTransfer,
                deviceExtension->DleCount
                );


            DleIrp->IoStatus.Information=BytesToTransfer;

        }

    }

    KeReleaseSpinLock(
        &deviceExtension->DeviceLock,
        origIrql
        );


    if (DleIrp != NULL) {

        RemoveReferenceAndCompleteRequest(
            deviceExtension->DeviceObject,
            DleIrp,
            STATUS_SUCCESS
            );
    }
}




NTSTATUS
UniWriteComplete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:


Arguments:

    DeviceObject - Pointer to the device object for the modem.

    Irp - Pointer to the IRP for the current request.

    Context - Really a pointer to the Extension.

Return Value:

    Always return status_success.

--*/

{
    PREAD_WRITE_CONTROL Control=(PREAD_WRITE_CONTROL)Context;
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PUCHAR   Buffer;
    PUCHAR   BufferEnd;
    DWORD    Length;
    KIRQL    origIrql;
    PIO_STACK_LOCATION irpSp;
    PIO_STACK_LOCATION nextSp;
    PKDEVICE_QUEUE_ENTRY  QueueEntry;


    irpSp = IoGetCurrentIrpStackLocation(Irp);
    nextSp = IoGetNextIrpStackLocation(Irp);



    if (irpSp->Parameters.Write.ByteOffset.HighPart != 0) {
        //
        //  we munged this one, else just complete it
        //
        if (NT_SUCCESS(Irp->IoStatus.Status) && (Irp->IoStatus.Information == (ULONG)irpSp->Parameters.Write.ByteOffset.HighPart) && !deviceExtension->Removing) {
            //
            //  It worked
            //

            //
            //  start at the DLE character, so it is resent
            //
            (PUCHAR)Irp->AssociatedIrp.SystemBuffer+=(Irp->IoStatus.Information-1);


            //
            //  skip the dle
            //
            Buffer=(PUCHAR)Irp->AssociatedIrp.SystemBuffer+1;

            //
            //  the end of the buffer is still in the same place
            //
            BufferEnd=Control->Write.RealSystemBuffer + irpSp->Parameters.Write.Length;

            //
            //  assume there ain't any dle's
            //
            nextSp->Parameters.Write.Length=(ULONG)((BufferEnd-(PUCHAR)Irp->AssociatedIrp.SystemBuffer));

            irpSp->Parameters.Write.ByteOffset.HighPart=0;

            while (Buffer < BufferEnd) {

                if (*Buffer == DLE_CHAR) {
                    //
                    //  adjust the write so, that the data up to and including the DLE is written
                    //
                    nextSp->Parameters.Write.Length=(DWORD)(Buffer-(PUCHAR)Irp->AssociatedIrp.SystemBuffer)+1;

                    irpSp->Parameters.Write.ByteOffset.HighPart=(LONG)nextSp->Parameters.Write.Length;

                    break;
                }

                Buffer++;
            }

            if (nextSp->Parameters.Write.Length != 0) {
                //
                //  more data to be written, send it down again
                //
                IoSetCompletionRoutine(
                    Irp,
                    UniWriteComplete,
                    Control,
                    TRUE,
                    TRUE,
                    TRUE
                    );

                IoCallDriver(
                    Control->Write.LowerDevice,
                    Irp
                    );

                return STATUS_MORE_PROCESSING_REQUIRED;

            }

        }


    }

    if (NT_SUCCESS(Irp->IoStatus.Status)) {
        //
        //  the app does not know about our munging, tell it, it wrote what it wanted
        //
        Irp->IoStatus.Information=irpSp->Parameters.Write.Length;
    }

    //
    //  put the real system buffer back
    //
    Irp->AssociatedIrp.SystemBuffer=Control->Write.RealSystemBuffer;
#if DBG
    Control->Write.RealSystemBuffer=NULL;
#endif

    StartNextReadWriteIrp(
        Control
        );

    RemoveReference(DeviceObject);

    return STATUS_SUCCESS;


}




NTSTATUS
WriteIrpStarter(
    PREAD_WRITE_CONTROL Control,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

{

    PIO_STACK_LOCATION irpSp;
    PIO_STACK_LOCATION nextSp;
    PUCHAR             Buffer;
    PUCHAR             BufferEnd;
    KIRQL              CancelIrql;



    irpSp = IoGetCurrentIrpStackLocation(Irp);
    nextSp = IoGetNextIrpStackLocation(Irp);

    nextSp->MajorFunction = irpSp->MajorFunction;
    nextSp->MinorFunction = irpSp->MinorFunction;
    nextSp->Flags = irpSp->Flags;
    nextSp->Parameters = irpSp->Parameters;


    irpSp->Parameters.Write.ByteOffset.HighPart=0;

    Control->Write.RealSystemBuffer=Irp->AssociatedIrp.SystemBuffer;

    Buffer=Irp->AssociatedIrp.SystemBuffer;

    BufferEnd=Buffer+irpSp->Parameters.Write.Length;

    while (Buffer < BufferEnd) {

        if (*Buffer == DLE_CHAR) {
            //
            //  found a DLE
            //
            //  adjust the write so, that the data up to and includeing the DLE is written
            //
            nextSp->Parameters.Write.Length=(ULONG)(Buffer-(PUCHAR)Irp->AssociatedIrp.SystemBuffer)+1;

            irpSp->Parameters.Write.ByteOffset.HighPart=(LONG)nextSp->Parameters.Write.Length;

            break;

        }

        Buffer++;
    }

    IoMarkIrpPending(Irp);

    Irp->IoStatus.Status = STATUS_PENDING;


    IoSetCompletionRoutine(
        Irp,
        UniWriteComplete,
        Control,
        TRUE,
        TRUE,
        TRUE
        );

    IoCallDriver(
        Control->Write.LowerDevice,
        Irp
        );

    return STATUS_PENDING;


}



#if 1

VOID
InitIrpQueue(
    PREAD_WRITE_CONTROL Control,
    PDEVICE_OBJECT      DeviceObject,
    IRPSTARTER          Starter
    )

{

    InitializeListHead(&Control->ListHead);

    Control->CurrentIrp=NULL;

    KeInitializeSpinLock(
        &Control->Lock
        );

    Control->InStartNext=FALSE;

    Control->Starter=Starter;

    Control->DeviceObject=DeviceObject;

    return;

}

NTSTATUS
QueueIrp(
    PREAD_WRITE_CONTROL Control,
    PIRP                Irp
    )

{

    KIRQL   CancelIrql;
    KIRQL   origIrql;





    KeAcquireSpinLock(
        &Control->Lock,
        &origIrql
        );

    if (Control->CurrentIrp == NULL && IsListEmpty(&Control->ListHead)) {
        //
        //  not busy, do it now
        //
        Control->CurrentIrp=Irp;

        KeReleaseSpinLock(
            &Control->Lock,
            origIrql
            );

        return (*Control->Starter)(
            Control,
            Control->DeviceObject,
            Irp
            );

    }


    IoMarkIrpPending(Irp);
    Irp->IoStatus.Status = STATUS_PENDING;

    InsertTailList(
        &Control->ListHead,
        &Irp->Tail.Overlay.ListEntry
        );

    IoAcquireCancelSpinLock(&CancelIrql);

    Irp->IoStatus.Information=(LONG_PTR)Control;

    IoSetCancelRoutine(
        Irp,
        IrpCancelRoutine
        );

    IoReleaseCancelSpinLock(CancelIrql);

    KeReleaseSpinLock(
        &Control->Lock,
        origIrql
        );


    return STATUS_PENDING;

}


VOID
StartNextReadWriteIrp(
    PREAD_WRITE_CONTROL Control
    )

{

    KIRQL   CancelIrql;
    KIRQL   origIrql;
    PIRP    Irp;
    NTSTATUS Status;


    KeAcquireSpinLock(
        &Control->Lock,
        &origIrql
        );

    Control->CurrentIrp=NULL;

    if (!Control->InStartNext) {

        Control->InStartNext=TRUE;

        do {

            Irp=NULL;

            while (!IsListEmpty(&Control->ListHead)) {
                //
                //  irp in list
                //
                PLIST_ENTRY   ListElement;

                ListElement=RemoveHeadList(
                    &Control->ListHead
                    );

                Irp=CONTAINING_RECORD(ListElement,IRP,Tail.Overlay.ListEntry);

                IoAcquireCancelSpinLock(&CancelIrql);

                //
                //  got one see if it has been canceled
                //
                if (Irp->Cancel) {
                    //
                    //  canceled, cancel routine will complete
                    //
                    Irp->IoStatus.Status = STATUS_CANCELLED;

                    Irp=NULL;

                    IoReleaseCancelSpinLock(CancelIrql);

                } else {
                    //
                    //  good irp
                    //
                    IoSetCancelRoutine(
                        Irp,
                        NULL
                        );

                    IoReleaseCancelSpinLock(CancelIrql);

                    break;
                }

            }

            //
            //  at this point, we either have the next servicable irp, or there none remaining
            //
            Control->CurrentIrp=Irp;

            if (Irp != NULL) {

                if (!Control->CompleteAllQueued) {

                    KeReleaseSpinLock(
                        &Control->Lock,
                        origIrql
                        );

                    (*Control->Starter)(
                        Control,
                        Control->DeviceObject,
                        Irp
                        );

                    KeAcquireSpinLock(
                        &Control->Lock,
                        &origIrql
                        );

                } else {
                    //
                    //  we want to clean out the queue
                    //
                    D_TRACE(DbgPrint("MODEM: StartNextReadWriteIrp: emptying irp from queue\n");)

                    KeReleaseSpinLock(
                        &Control->Lock,
                        origIrql
                        );

                    RemoveReferenceAndCompleteRequest(
                        Control->DeviceObject,
                        Irp,
                        STATUS_CANCELLED
                        );


                    KeAcquireSpinLock(
                        &Control->Lock,
                        &origIrql
                        );

                    //
                    //  not current anymore
                    //
                    Control->CurrentIrp=NULL;
                }

            }


        } while ((Control->CurrentIrp == NULL) && !IsListEmpty(&Control->ListHead));


        Control->CompleteAllQueued=FALSE;

        Control->InStartNext=FALSE;
    }

    KeReleaseSpinLock(
        &Control->Lock,
        origIrql
        );

    return;

}




VOID
IrpCancelRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:


Arguments:

    DeviceObject - The device object of the modem.

    Irp - This is the irp to cancel.

Return Value:

    None.

--*/

{

    PREAD_WRITE_CONTROL Control=(PREAD_WRITE_CONTROL)Irp->IoStatus.Information;
    KIRQL origIrql;

    IoReleaseCancelSpinLock(
        Irp->CancelIrql
        );

    KeAcquireSpinLock(
        &Control->Lock,
        &origIrql
        );


    if (Irp->IoStatus.Status == STATUS_PENDING) {
        //
        //  irp is still in queue
        //
        RemoveEntryList(&Irp->Tail.Overlay.ListEntry);

    }

    KeReleaseSpinLock(
        &Control->Lock,
        origIrql
        );


    Irp->IoStatus.Information=0;

    RemoveReferenceAndCompleteRequest(
        DeviceObject,
        Irp,
        STATUS_CANCELLED
        );


    return;



}


VOID
CleanUpQueuedIrps(
    PREAD_WRITE_CONTROL Control,
    NTSTATUS            Status
    )

{

    KIRQL   CancelIrql;
    KIRQL   origIrql;
    PIRP    Irp;


    KeAcquireSpinLock(
        &Control->Lock,
        &origIrql
        );


    while (!IsListEmpty(&Control->ListHead)) {
        //
        //  irp in list
        //
        PLIST_ENTRY   ListElement;

        ListElement=RemoveTailList(
            &Control->ListHead
            );

        Irp=CONTAINING_RECORD(ListElement,IRP,Tail.Overlay.ListEntry);

        IoAcquireCancelSpinLock(&CancelIrql);

        //
        //  got one see if it has been canceled
        //
        if (Irp->Cancel) {
            //
            //  canceled, cancel routine will complete
            //
            Irp->IoStatus.Status = STATUS_CANCELLED;

            Irp=NULL;

            IoReleaseCancelSpinLock(CancelIrql);

        } else {
            //
            //  good irp
            //
            IoSetCancelRoutine(
                Irp,
                NULL
                );

            IoReleaseCancelSpinLock(CancelIrql);

        }

        if (Irp != NULL) {

            KeReleaseSpinLock(
                &Control->Lock,
                origIrql
                );

            Irp->IoStatus.Information=0;

            RemoveReferenceAndCompleteRequest(
                Control->DeviceObject,
                Irp,
                Status
                );

            KeAcquireSpinLock(
                &Control->Lock,
                &origIrql
                );

        }
    }


    KeReleaseSpinLock(
        &Control->Lock,
        origIrql
        );

    return;

}


VOID
MarkQueueToEmpty(
    PREAD_WRITE_CONTROL Control
    )

{
    KIRQL   origIrql;

    KeAcquireSpinLock(
        &Control->Lock,
        &origIrql
        );

    if ((Control->CurrentIrp != NULL) || !IsListEmpty(&Control->ListHead)) {

        D_TRACE(DbgPrint("MODEM: MarkQueueToEmpty, setting flags\n");)

        Control->CompleteAllQueued=TRUE;
    }

    KeReleaseSpinLock(
        &Control->Lock,
        origIrql
        );

    return;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\sys\modem\refcount.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    refcount.c

Abstract:

    maintains ref count for removal checks

Author:

    Brian Lieuallen 6-21-1997

Environment:

    Kernel mode

Revision History :

--*/

#include "precomp.h"



NTSTATUS
CheckStateAndAddReference(
    PDEVICE_OBJECT   DeviceObject,
    PIRP             Irp
    )

{

    PDEVICE_EXTENSION    DeviceExtension=(PDEVICE_EXTENSION)DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION   irpSp = IoGetCurrentIrpStackLocation(Irp);

    VALIDATE_IRP(Irp);

    if (DeviceExtension->DoType==DO_TYPE_FDO) {

        if (DeviceExtension->OpenCount > 0) {

            if (irpSp->FileObject != NULL) {

                InterlockedIncrement(&DeviceExtension->ReferenceCount);

                if (DeviceExtension->Removing) {
                    //
                    //  driver not accepting requests
                    //
                    D_ERROR(DbgPrint("MODEM: removing! MJ=%d MN=%d\n",irpSp->MajorFunction,irpSp->MinorFunction);)

                    RemoveReferenceAndCompleteRequest(
                        DeviceObject,
                        Irp,
                        STATUS_UNSUCCESSFUL
                        );

                    return STATUS_UNSUCCESSFUL;

                }

                InterlockedIncrement(&DeviceExtension->ReferenceCount);

                return STATUS_SUCCESS;

            } else {

                D_ERROR(DbgPrint("MODEM: CheckStateAndAddReference: no file object!\n");)

            }
        } else {

            DbgPrint("MODEM: CheckStateAndAddReference: Got IRP when not open!\n");
        }

    } else {

        D_ERROR(DbgPrint("MODEM: Not FDO!\n");)

        if (DeviceExtension->DoType != DO_TYPE_PDO)  {

            DbgPrint("MODEM: CheckStateAndAddReference: Bad DevObj\n");
#if DBG
            DbgBreakPoint();
#endif
        }
    }


    Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;

    IoCompleteRequest(
        Irp,
        IO_NO_INCREMENT
        );


    return STATUS_UNSUCCESSFUL;

}

NTSTATUS
CheckStateAndAddReferencePower(
    PDEVICE_OBJECT   DeviceObject,
    PIRP             Irp
    )

{

    PDEVICE_EXTENSION    DeviceExtension=(PDEVICE_EXTENSION)DeviceObject->DeviceExtension;

    InterlockedIncrement(&DeviceExtension->ReferenceCount);

    if (DeviceExtension->Removing) {
        //
        //  driver not accepting requests
        //
        D_ERROR(DbgPrint("MODEM: removing!\n");)

        PoStartNextPowerIrp(Irp);

        RemoveReferenceAndCompleteRequest(
            DeviceObject,
            Irp,
            STATUS_UNSUCCESSFUL
            );

        return STATUS_UNSUCCESSFUL;

    }

    InterlockedIncrement(&DeviceExtension->ReferenceCount);

    return STATUS_SUCCESS;

}

NTSTATUS
CheckStateAndAddReferenceWMI(
    PDEVICE_OBJECT   DeviceObject,
    PIRP             Irp
    )

{

    PDEVICE_EXTENSION    DeviceExtension=(PDEVICE_EXTENSION)DeviceObject->DeviceExtension;

    InterlockedIncrement(&DeviceExtension->ReferenceCount);

    if (DeviceExtension->Removing) {
        //
        //  driver not accepting requests
        //
        D_ERROR(DbgPrint("MODEM: removing!\n");)

        RemoveReferenceAndCompleteRequest(
            DeviceObject,
            Irp,
            STATUS_UNSUCCESSFUL
            );

        return STATUS_UNSUCCESSFUL;

    }

    InterlockedIncrement(&DeviceExtension->ReferenceCount);

    return STATUS_SUCCESS;

}



VOID
RemoveReferenceAndCompleteRequest(
    PDEVICE_OBJECT    DeviceObject,
    PIRP              Irp,
    NTSTATUS          StatusToReturn
    )

{

    PDEVICE_EXTENSION    DeviceExtension=(PDEVICE_EXTENSION)DeviceObject->DeviceExtension;
    KIRQL                OldIrql;
    LONG                 NewReferenceCount;

    VALIDATE_IRP(Irp);

    NewReferenceCount=InterlockedDecrement(&DeviceExtension->ReferenceCount);

    D_TRACE(
        if (DeviceExtension->Removing) {DbgPrint("MODEM: RemoveReferenceAndCompleteRequest: %d\n",NewReferenceCount);}
        )


    if (NewReferenceCount == 0) {
        //
        //  device is being removed, set event
        //
        ASSERT(DeviceExtension->Removing);

        KeSetEvent(
            &DeviceExtension->RemoveEvent,
            0,
            FALSE
            );

    }

    Irp->IoStatus.Status = StatusToReturn;

    IoCompleteRequest(
        Irp,
        IO_SERIAL_INCREMENT
        );

    return;


}




VOID
RemoveReference(
    PDEVICE_OBJECT    DeviceObject
    )

{
    PDEVICE_EXTENSION    DeviceExtension=(PDEVICE_EXTENSION)DeviceObject->DeviceExtension;
    LONG                 NewReferenceCount;

    NewReferenceCount=InterlockedDecrement(&DeviceExtension->ReferenceCount);

    D_TRACE(
        if (DeviceExtension->Removing) {DbgPrint("MODEM: RemoveReference: %d\n",NewReferenceCount);}
        )

    if (NewReferenceCount == 0) {
        //
        //  device is being removed, set event
        //
        ASSERT(DeviceExtension->Removing);

        KeSetEvent(
            &DeviceExtension->RemoveEvent,
            0,
            FALSE
            );

    }

    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\sys\modem\utils.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    utils.c

Abstract:

    This module contains the code that is of a general
    support nature to the modem driver.
    operations in the modem driver.

Author:

    Anthony V. Ercolano 29-Aug-1995

Environment:

    Kernel mode

Revision History :

--*/

#include "precomp.h"

NTSTATUS
UniSetupNoPassPart1(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
UniSetupNoPassPart2(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
UniSetupNoPassPart3(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
UniSetupSniffPart0(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
UniSetupSniffPart1(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
UniSetupSniffPart2(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
UniSniffWaitComplete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
UniPassThroughStarter(
    IN PDEVICE_EXTENSION Extension
    );

VOID
UniSendOurWaitDown(
    IN PDEVICE_EXTENSION Extension
    );

VOID
UniPostProcessShuttledWaits(
    IN PDEVICE_EXTENSION Extension,
    IN PMASKSTATE MaskStates,
    IN ULONG MaskValue
    );

VOID
UniPreProcessShuttledWaits(
    IN PMASKSTATE ExtensionMaskStates,
    IN PMASKSTATE MaskStates,
    IN ULONG MaskValue
    );


NTSTATUS
UniSetupPass(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );


#pragma alloc_text(PAGEUMDM,UniCheckPassThrough)
#pragma alloc_text(PAGEUMDM,UniNoCheckPassThrough)
#pragma alloc_text(PAGEUMDM,UniStartOrQueue)
#pragma alloc_text(PAGEUMDM,UniGetNextIrp)
#pragma alloc_text(PAGEUMDM,UniSniffOwnerSettings)
#pragma alloc_text(PAGEUMDM,UniSetupNoPassPart1)
#pragma alloc_text(PAGEUMDM,UniSetupNoPassPart2)
#pragma alloc_text(PAGEUMDM,UniSetupNoPassPart3)
#pragma alloc_text(PAGEUMDM,UniPassThroughStarter)
#pragma alloc_text(PAGEUMDM,UniSetupPass)
#pragma alloc_text(PAGEUMDM,UniSetupSniffPart0)
#pragma alloc_text(PAGEUMDM,UniSetupSniffPart1)
#pragma alloc_text(PAGEUMDM,UniSetupSniffPart2)
#pragma alloc_text(PAGEUMDM,UniSniffWaitComplete)
#pragma alloc_text(PAGEUMDM,UniSendOurWaitDown)
#pragma alloc_text(PAGEUMDM,UniPreProcessShuttledWaits)
#pragma alloc_text(PAGEUMDM,UniPostProcessShuttledWaits)
#pragma alloc_text(PAGEUMDM,UniValidateNewCommConfig)


NTSTATUS
UniCheckPassThrough(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

The function value is the final status of the call

--*/

{

    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS status;

    //
    // We need to check each of the ioctls that can come through.  If they
    // set something that intersects with what the owner is doing we need
    // to note this so that when the owner doesn't want that info anymore
    // it still goes back to the app.
    //

    if (deviceExtension->PassThrough != MODEM_NOPASSTHROUGH) {

        //
        // If it is a mask operation, serialize it.
        //

        if ((irpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_SERIAL_SET_WAIT_MASK)
              ||
            (irpSp->Parameters.DeviceIoControl.IoControlCode ==  IOCTL_SERIAL_WAIT_ON_MASK)) {


             return UniStartOrQueue(
                        deviceExtension,
                        &deviceExtension->DeviceLock,
                        Irp,
                        &deviceExtension->MaskOps,
                        &deviceExtension->CurrentMaskOp,
                        UniMaskStarter
                        );

        } else {

            //
            // If it is a setcommconfig then we can process it
            // right here.
            //

            if (irpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_SERIAL_SET_COMMCONFIG) {

                return UniValidateNewCommConfig(
                           deviceExtension,
                           Irp,
                           FALSE
                           );


            } else {

                IoSkipCurrentIrpStackLocation(Irp);

                status=IoCallDriver(
                           deviceExtension->AttachedDeviceObject,
                           Irp
                           );

                RemoveReferenceForIrp(DeviceObject);

                return status;

            }

        }

    } else {

        Irp->IoStatus.Information=0L;

        RemoveReferenceAndCompleteRequest(
            DeviceObject,
            Irp,
            STATUS_PORT_DISCONNECTED
            );

        return STATUS_PORT_DISCONNECTED;

    }

}

NTSTATUS
UniNoCheckPassThrough(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    Just let the request go on down.  On it's way back up, strip out anything that
    the owner added that the application doesn't already want.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

The function value is the final status of the call

--*/

{

    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    NTSTATUS          status;

    IoSkipCurrentIrpStackLocation(Irp);

    status=IoCallDriver(
               deviceExtension->AttachedDeviceObject,
               Irp
               );

    RemoveReferenceForIrp(DeviceObject);

    return status;



}

NTSTATUS
UniStartOrQueue(
    IN PDEVICE_EXTENSION Extension,
    IN PKSPIN_LOCK QueueLock,
    IN PIRP Irp,
    IN PLIST_ENTRY QueueToExamine,
    IN PIRP *CurrentOpIrp,
    IN PUNI_START_ROUTINE Starter
    )

/*++

Routine Description:

    This routine is used to either start or queue any requst
    that can be queued in the driver.

Arguments:

    Extension - Points to the device extension.

    QueueLock - The lock protecting the particular queue.

    Irp - The irp to either queue or start.  In either
          case the irp will be marked pending.

    QueueToExamine - The queue the irp will be place on if there
                     is already an operation in progress.

    CurrentOpIrp - Pointer to a pointer to the irp the is current
                   for the queue.  The pointer pointed to will be
                   set with to Irp if what CurrentOpIrp points to
                   is NULL.

    Starter - The routine to call if the queue is empty.

Return Value:

    This routine will return STATUS_PENDING if the queue is
    not empty.  Otherwise, it will return the status returned
    from the starter routine (or cancel, if the cancel bit is
    on in the irp).


--*/

{

    KIRQL oldIrql;
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);

    KeAcquireSpinLock(
        QueueLock,
        &oldIrql
        );

    //
    // Help out the mask operations.  If this irp is a mask irp,
    // increment the reference count for the appropriate handle.
    //

    if (irpSp->Parameters.DeviceIoControl.IoControlCode ==
        IOCTL_SERIAL_SET_WAIT_MASK) {

        Extension->MaskStates[
            irpSp->FileObject->FsContext?CONTROL_HANDLE:CLIENT_HANDLE
            ].SetMaskCount++;

    }

    if ((IsListEmpty(QueueToExamine)) &&
        !(*CurrentOpIrp)) {

        //
        // There were no current operation.  Mark this one as
        // current and start it up.
        //

        *CurrentOpIrp = Irp;

        KeReleaseSpinLock(
            QueueLock,
            oldIrql
            );

        IoMarkIrpPending(Irp);

        Starter(Extension);

        return STATUS_PENDING;

    } else {

        IoMarkIrpPending(Irp);

        InsertTailList(
            QueueToExamine,
            &Irp->Tail.Overlay.ListEntry
            );

        KeReleaseSpinLock(
            QueueLock,
            oldIrql
            );

        return STATUS_PENDING;

    }

}

VOID
UniGetNextIrp(
    IN PDEVICE_OBJECT  DeviceObject,
    IN PKSPIN_LOCK QueueLock,
    IN PIRP *CurrentOpIrp,
    IN PLIST_ENTRY QueueToProcess,
    OUT PIRP *NextIrp,
    IN BOOLEAN CompleteCurrent
    )

/*++

Routine Description:

    This function is used to make the head of the particular
    queue the current irp.  It also completes the what
    was the old current irp if desired.

Arguments:

    QueueLock - The lock protecting this queue.

    CurrentOpIrp - Pointer to a pointer to the currently active
                   irp for the particular work list.  Note that
                   this item is not actually part of the list.

    QueueToProcess - The list to pull the new item off of.

    NextIrp - The next Irp to process.  Note that CurrentOpIrp
              will be set to this value under protection of the
              cancel spin lock.  However, if *NextIrp is NULL when
              this routine returns, it is not necessaryly true the
              what is pointed to by CurrentOpIrp will also be NULL.
              The reason for this is that if the queue is empty
              when we hold the cancel spin lock, a new irp may come
              in immediately after we release the lock.

    CompleteCurrent - If TRUE then this routine will complete the
                      irp pointed to by the pointer argument
                      CurrentOpIrp.

Return Value:

    None.

--*/

{

    KIRQL oldIrql;
    PIRP oldIrp;


    KeAcquireSpinLock(
        QueueLock,
        &oldIrql
        );

    oldIrp = *CurrentOpIrp;

    //
    // Check to see if there is a new irp to start up.
    //

    if (!IsListEmpty(QueueToProcess)) {

        PLIST_ENTRY headOfList;

        headOfList = RemoveHeadList(QueueToProcess);

        *CurrentOpIrp = CONTAINING_RECORD(
                            headOfList,
                            IRP,
                            Tail.Overlay.ListEntry
                            );

    } else {

        *CurrentOpIrp = NULL;

    }

    *NextIrp = *CurrentOpIrp;
    KeReleaseSpinLock(
        QueueLock,
        oldIrql
        );

    if (CompleteCurrent) {

        if (oldIrp) {

            RemoveReferenceAndCompleteRequest(
                DeviceObject,
                oldIrp,
                oldIrp->IoStatus.Status
                );
        }

    }

}

NTSTATUS
UniSniffOwnerSettings(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    We manage three things from this level.

    1) If asked we change the state so that we are / are not
       in passthrough mode.

    2) If the owner asks for things that the app won't know about
       we note that here.

    3) Huh, I was sure there was a third thing.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

    The function value is the final status of the call

--*/

{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);
    ULONG controlCode = irpSp->Parameters.DeviceIoControl.IoControlCode;



    NTSTATUS status;


    Irp->IoStatus.Information=0L;

    //
    // For now this test is good enough to figure out if we
    // are dealing with the modem state changes.
    //
    if ((controlCode >> 16) == FILE_DEVICE_MODEM) {

        if (controlCode == IOCTL_MODEM_SET_PASSTHROUGH) {

            ULONG passThroughType;

            //
            // Parameter lenght ok?
            //

            if (irpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(ULONG)) {

                RemoveReferenceAndCompleteRequest(
                    DeviceObject,
                    Irp,
                    STATUS_BUFFER_TOO_SMALL
                    );

                return STATUS_BUFFER_TOO_SMALL;

            }

            return UniStartOrQueue(
                       deviceExtension,
                       &deviceExtension->DeviceLock,
                       Irp,
                       &deviceExtension->PassThroughQueue,
                       &deviceExtension->CurrentPassThrough,
                       &UniPassThroughStarter
                       );

        } else if (controlCode == IOCTL_MODEM_GET_PASSTHROUGH) {

            if (irpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(ULONG)) {

                RemoveReferenceAndCompleteRequest(
                    DeviceObject,
                    Irp,
                    STATUS_BUFFER_TOO_SMALL
                    );

                return STATUS_BUFFER_TOO_SMALL;

            }

            *(PULONG)Irp->AssociatedIrp.SystemBuffer = deviceExtension->PassThrough;

            Irp->IoStatus.Information = sizeof(ULONG);

            RemoveReferenceAndCompleteRequest(
                DeviceObject,
                Irp,
                STATUS_SUCCESS
                );

            return STATUS_SUCCESS;

        } else {

            //
            // Fail the request.  Unknown modem command.
            //
            RemoveReferenceAndCompleteRequest(
                DeviceObject,
                Irp,
                STATUS_INVALID_PARAMETER
                );

            return STATUS_INVALID_PARAMETER;

        }

    } else {

        //
        // Not a modem type command.  If it is one of the requests that
        // set's something that the owner cares about but not apps, then
        // record this here.
        //
        // Is there really such requests?  It would seem as though you can't
        // tell the difference between another app request and the owner.
        //

        //
        // If it is a mask operation, serialize it.
        //

        if ((irpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_SERIAL_SET_WAIT_MASK)
            ||
            (irpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_SERIAL_WAIT_ON_MASK)) {

            return UniStartOrQueue(
                        deviceExtension,
                        &deviceExtension->DeviceLock,
                        Irp,
                        &deviceExtension->MaskOps,
                        &deviceExtension->CurrentMaskOp,
                        UniMaskStarter
                        );

        } else if (irpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_SERIAL_SET_COMMCONFIG) {

            return UniValidateNewCommConfig(
                       deviceExtension,
                       Irp,
                       TRUE
                       );

        } else {

            IoSkipCurrentIrpStackLocation(Irp);

            status=IoCallDriver(
                       deviceExtension->AttachedDeviceObject,
                       Irp
                       );

            RemoveReferenceForIrp(DeviceObject);

            return status;

        }

    }

}

NTSTATUS
UniSetupNoPassPart1(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    This does the first part of going into no passthrough mode.
    It sends down the current irp to the lower level serial driver
    with a setmask to clear out the dcd sniff stuff.  (Note that
    if the client or owner handle still wants to see those changes
    these bits will still be set, BUT, the setmask will still be
    done which should cause any pending waits to complete.)

Arguments:

    DeviceObject - Pointer to the device object for the modem.

    Irp - Pointer to the IRP for the current request.

    Context - Really a pointer to the Extension.

Return Value:

    We ALWAYS return more processing required, when this is actually
    called as a completion routine we NEVER want the irp to actually
    finish up at this point.

--*/

{

    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);
    PIO_STACK_LOCATION nextSp = IoGetNextIrpStackLocation(Irp);
    PDEVICE_EXTENSION extension = Context;
    KIRQL origIrql;

    //
    // We don't want anything to change while we test and adjust
    // states.
    //

    KeAcquireSpinLock(
        &extension->DeviceLock,
        &origIrql
        );

    if (extension->PassThrough == MODEM_DCDSNIFF) {

        //
        // We fall out of the dcd sniff state no matter what.
        //

        extension->PassThrough = MODEM_NOPASSTHROUGH;

        UNI_SETUP_NEW_BUFFER(Irp);
        nextSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;
        nextSp->MinorFunction = 0UL;
        nextSp->Flags = irpSp->Flags;
        nextSp->Parameters.DeviceIoControl.OutputBufferLength = 0UL;
        nextSp->Parameters.DeviceIoControl.InputBufferLength = sizeof(ULONG);
        nextSp->Parameters.DeviceIoControl.IoControlCode =
            IOCTL_SERIAL_SET_WAIT_MASK;
        nextSp->Parameters.DeviceIoControl.Type3InputBuffer = NULL;
        *((PULONG)Irp->AssociatedIrp.SystemBuffer) =
            extension->MaskStates[0].Mask |
            extension->MaskStates[1].Mask;

        IoSetCompletionRoutine(
            Irp,
            UniSetupNoPassPart2,
            extension,
            TRUE,
            TRUE,
            TRUE
            );

        KeReleaseSpinLock(
            &extension->DeviceLock,
            origIrql
            );
        IoCallDriver(
            extension->AttachedDeviceObject,
            Irp
            );

    } else {

        //
        // Ok, so we weren't in a state where we have to change
        // the mask down in the lower serial driver.  We still
        // have to cause all reads and writes to complete.  Call
        // the standard routine for doing this.  Note that this
        // routine is called by the completion routine for the
        // mask clearing up above.  We simply need to make
        // sure that the irp looks like it would after the clearing
        // This means that the original systembuffer is saved off.
        //

        extension->PassThrough = MODEM_NOPASSTHROUGH;
        KeReleaseSpinLock(
            &extension->DeviceLock,
            origIrql
            );
        UNI_SETUP_NEW_BUFFER(Irp);
        UniSetupNoPassPart2(
            extension->AttachedDeviceObject,
            Irp,
            extension
            );

    }

    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
UniSetupNoPassPart2(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    This does the first part of going into no passthrough mode.
    It sends down the current irp to the lower level serial driver
    with a setmask to clear out the dcd sniff stuff.  (Note that
    if the client or owner handle still wants to see those changes
    these bits will still be set, BUT, the setmask will still be
    done which should cause any pending waits to complete.)

Arguments:

    DeviceObject - Pointer to the device object for the modem.

    Irp - Pointer to the IRP for the current request.

    Context - Really a pointer to the Extension.


Return Value:

    Always more processing required since we don't want
    the iosubsystem to mess with this irp.

--*/

{

    PIO_STACK_LOCATION nextSp = IoGetNextIrpStackLocation(Irp);

    nextSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;
    nextSp->MinorFunction = 0UL;
    nextSp->Flags = 0;
    nextSp->Parameters.DeviceIoControl.OutputBufferLength = 0UL;
    nextSp->Parameters.DeviceIoControl.InputBufferLength = sizeof(ULONG);
    nextSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_SERIAL_PURGE;
    nextSp->Parameters.DeviceIoControl.Type3InputBuffer = NULL;
    *((PULONG)Irp->AssociatedIrp.SystemBuffer) = SERIAL_PURGE_TXABORT |
//        (((PDEVICE_EXTENSION)Context)->DleMonitoringEnabled) ? 0 :
         SERIAL_PURGE_RXABORT;



    IoSetCompletionRoutine(
        Irp,
        UniSetupNoPassPart3,
        Context,
        TRUE,
        TRUE,
        TRUE
        );

    IoCallDriver(
        ((PDEVICE_EXTENSION)Context)->AttachedDeviceObject,
        Irp
        );

    return STATUS_MORE_PROCESSING_REQUIRED;

}

NTSTATUS
UniSetupNoPassPart3(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    This is called when all the no passthrough code has reached
    completion.

    We have to irps that we could have been called with.

    1) An irp from above that actually put us into a nopassthrough
    state.

    2) The modem driver initiated wait completing.

Arguments:

    DeviceObject - Pointer to the device object for the modem.

    Irp - Pointer to the IRP for the current request.

    Context - Really a pointer to the Extension.

Return Value:

    Always more processing required since we don't want
    the iosubsystem to mess with this irp.

--*/

{


    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);
    PDEVICE_EXTENSION extension = Context;

    //
    // How do we tell caller initiated nopassthrough from modem driver
    // wait completion (since we STOMPED on the ioctl value)?  The
    // modem drivers saved off systembuffer will be null.  We know that
    // the caller initiated saved systembuffer HAD to be non-null cause
    // it would have NEVER made it past our irp validation code.
    //

    if (UNI_ORIG_SYSTEM_BUFFER(Irp)) {

        PIRP newIrp;
        //
        // app initiated irp.  Put back the old system buffer and
        // restore the ioctl.
        //

        UNI_RESTORE_IRP(
            Irp,
            IOCTL_MODEM_SET_PASSTHROUGH
            );

        //
        // Now, we are going to return more processing because we are
        // going to call our regular queue processing code
        // to process the passthrough queue.  The queue processing
        // code will actually reinvoke complete on this irp.
        //

        UniGetNextIrp(
            extension->DeviceObject,
            &extension->DeviceLock,
            &extension->CurrentPassThrough,
            &extension->PassThroughQueue,
            &newIrp,
            TRUE
            );

        if (newIrp) {

            UniPassThroughStarter(extension);

        }

        return STATUS_MORE_PROCESSING_REQUIRED;

    } else {

        //
        // The modem drivers wait is all done.
        //
        // We need to see if there are shuttled wait operations to
        // be sent down.
        //
        // The basic theory here is that we take out the device
        // lock, look to see if we are no longer in sniff mode.
        // If this is the case then try to send to a shuttled wait
        // that is suitable for sending down.  If the shuttled
        // wait makes it on down, it might already find a wait
        // already there because a dcd sniff came in.  That's ok.
        // Shuttled waits that are sent down can handle being completed
        // with an error (they just reshuttle).
        //

        KIRQL origIrql;

        RETURN_OUR_WAIT_IRP(extension,Irp);

        KeAcquireSpinLock(
            &extension->DeviceLock,
            &origIrql
            );

        if (extension->PassThrough != MODEM_DCDSNIFF) {

            if (!(extension->MaskStates[0].PassedDownWait ||
                  extension->MaskStates[1].PassedDownWait)) {

                if (extension->MaskStates[0].ShuttledWait) {

                    UniChangeShuttledToPassDown(
                        &extension->MaskStates[0],
                        origIrql
                        );

                } else if (extension->MaskStates[1].ShuttledWait) {

                    UniChangeShuttledToPassDown(
                        &extension->MaskStates[1],
                        origIrql
                        );

                } else {

                    KeReleaseSpinLock(
                        &extension->DeviceLock,
                        origIrql
                        );

                }

            } else {

                KeReleaseSpinLock(
                    &extension->DeviceLock,
                    origIrql
                    );

            }

        } else {

            KeReleaseSpinLock(
                &extension->DeviceLock,
                origIrql
                );

        }

        return STATUS_MORE_PROCESSING_REQUIRED;

    }

}

NTSTATUS
UniPassThroughStarter(
    IN PDEVICE_EXTENSION Extension
    )

{

    PIRP newIrp;
    PIRP irp;
    ULONG passThroughType;

    do {

        irp = Extension->CurrentPassThrough;
        passThroughType = *(PULONG)irp->AssociatedIrp.SystemBuffer;

        if (passThroughType == MODEM_NOPASSTHROUGH_INC_SESSION_COUNT) {
            //
            //  inc the passthrough session count so, this handle will never be
            //  able to send irps through
            //
            Extension->CurrentPassThroughSession++;

            //
            //  Change back to regular no passthrough
            //
            passThroughType = MODEM_NOPASSTHROUGH;
            *(PULONG)irp->AssociatedIrp.SystemBuffer=MODEM_NOPASSTHROUGH;
        }

        if (passThroughType == MODEM_NOPASSTHROUGH) {
            //
            // Requested to go into the not connected (no passthrough)
            // state.
            //
            // Change the state to nopassthrough.  When we are done with
            // that, purge the read/write data (not the hardware buffers
            // though).
            //

            //
            // If we are already in the nopassthrough, then nothing
            // to do.
            //

            if (Extension->PassThrough == MODEM_NOPASSTHROUGH) {

                irp->IoStatus.Status = STATUS_SUCCESS;
                irp->IoStatus.Information = 0L;

            } else {

                //
                // The following will actually start off the
                // work of putting us into passthrough mode.
                //
                // Since this ALWAYS entails calling down to a
                // lower level driver we know we won't be completing
                // and that we won't be starting a new irp right
                // away, so we can just return.
                //
                UniSetupNoPassPart1(
                    Extension->DeviceObject,
                    irp,
                    Extension
                    );

                return STATUS_PENDING;

            }

        } else if (passThroughType == MODEM_PASSTHROUGH) {

            //
            // Set into the passthrough state.  Make sure that any
            // owner settings and app settings are still set up and
            // set passthrough.
            //

            //
            // If already in this state then do nothing.
            //

            if (Extension->PassThrough != MODEM_PASSTHROUGH) {

                //
                // If going to this state from DCD sniffing state, kill the
                // wait (resubmit if there is any reason from the apps).
                //
                UniSetupPass(
                    Extension->DeviceObject,
                    irp,
                    Extension
                    );

                return STATUS_PENDING;

            } else {

                irp->IoStatus.Status = STATUS_SUCCESS;
                irp->IoStatus.Information = 0L;

            }

        } else if (passThroughType == MODEM_DCDSNIFF) {

            //
            // Go into the connect (passthrough) state with dcd sniffing.
            //
            // Any wait requests sent down by the apps were filtered so
            // and were replaced by our own wait.  Set a new mask with
            // our dcd bit.  This will cause the current wait to finish.
            // resubmit it with dcd sniffing turned on.
            //

            if (Extension->PassThrough != MODEM_DCDSNIFF) {

                //
                // We call the routine that starts off the sniffing.
                // Since this work inherintly calls lower level serial
                // drivers we know that this will pend.  If this is
                // the first time through the loop make sure we return
                // pending.
                //

                UniSetupSniffPart0(
                    Extension->DeviceObject,
                    irp,
                    Extension
                    );

                return STATUS_PENDING;

            } else {

                irp->IoStatus.Status = STATUS_SUCCESS;
                irp->IoStatus.Information = 0L;

            }

        } else {

            //
            // Fail the request.  Unknown modem command.
            //

            irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
            irp->IoStatus.Information=0L;

        }

        UniGetNextIrp(
            Extension->DeviceObject,
            &Extension->DeviceLock,
            &Extension->CurrentPassThrough,
            &Extension->PassThroughQueue,
            &newIrp,
            TRUE
            );

    } while (newIrp);

    return STATUS_PENDING;

}

NTSTATUS
UniSetupPass(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    This sets us up for passthrough IF we are called while DCD
    sniffing enabled.  The basic theory here is that by
    sending down the setmask that will wipe out the pending
    wait (and completing the pending wait will take care of
    all it's gory details itself).  We just send down the setmask
    and set the completion routine to the nopassthrough final
    completion cause that has code to restore the irps and
    start off a new one.

Arguments:

    DeviceObject - Pointer to the device object for the modem.

    Irp - Pointer to the IRP for the current request.

    Context - Really a pointer to the Extension.

Return Value:

    We ALWAYS return more processing required.

--*/

{

    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);
    PIO_STACK_LOCATION nextSp = IoGetNextIrpStackLocation(Irp);
    PDEVICE_EXTENSION extension = Context;
    KIRQL origIrql;

    //
    // We don't want anything to change while we test and adjust
    // states.
    //

    KeAcquireSpinLock(
        &extension->DeviceLock,
        &origIrql
        );

    if (extension->PassThrough == MODEM_DCDSNIFF) {

        //
        // We fall out of the dcd sniff state no matter what.
        //

        extension->PassThrough = MODEM_PASSTHROUGH;

        UNI_SETUP_NEW_BUFFER(Irp);
        nextSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;
        nextSp->MinorFunction = 0UL;
        nextSp->Flags = irpSp->Flags;
        nextSp->Parameters.DeviceIoControl.OutputBufferLength = 0UL;
        nextSp->Parameters.DeviceIoControl.InputBufferLength = sizeof(ULONG);
        nextSp->Parameters.DeviceIoControl.IoControlCode =
            IOCTL_SERIAL_SET_WAIT_MASK;
        nextSp->Parameters.DeviceIoControl.Type3InputBuffer = NULL;
        *((PULONG)Irp->AssociatedIrp.SystemBuffer) =
            extension->MaskStates[0].Mask |
            extension->MaskStates[1].Mask;

        IoSetCompletionRoutine(
            Irp,
            UniSetupNoPassPart3,
            extension,
            TRUE,
            TRUE,
            TRUE
            );

        KeReleaseSpinLock(
            &extension->DeviceLock,
            origIrql
            );
        IoCallDriver(
            extension->AttachedDeviceObject,
            Irp
            );

    } else {

        //
        // Ok, so we weren't in a state where we have to change
        // the mask down in the lower serial driver.  (Something
        // came in around us?)  Simply finish up the irp.
        //

        extension->PassThrough = MODEM_PASSTHROUGH;
        KeReleaseSpinLock(
            &extension->DeviceLock,
            origIrql
            );
        Irp->IoStatus.Status = STATUS_SUCCESS;
        Irp->IoStatus.Information = 0UL;
        UNI_SETUP_NEW_BUFFER(Irp);
        UniSetupNoPassPart3(
            extension->AttachedDeviceObject,
            Irp,
            extension
            );

    }

    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
UniSetupSniffPart0(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    This begins setting up for dcd sniffing.  We KNOW
    getting here we weren't already in dcd sniff.

    1) Set the passthrough state to dcdsniff.

    2) Call down to the lower serial driver to set the mask to
       0.  This will totally clear out the state.

    3) Further processing (in the completion) will send down a new
       setmask as well as a wait irp that has been preallocated by
       the modem driver.

Arguments:

    DeviceObject - Pointer to the device object for the modem.

    Irp - Pointer to the IRP for the current request.

    Context - Really a pointer to the Extension.

Return Value:

    None.

--*/

{

    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);
    PIO_STACK_LOCATION nextSp = IoGetNextIrpStackLocation(Irp);
    PDEVICE_EXTENSION extension = Context;

    extension->PassThrough = MODEM_DCDSNIFF;

    UNI_SETUP_NEW_BUFFER(Irp);
    nextSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;
    nextSp->MinorFunction = 0UL;
    nextSp->Flags = irpSp->Flags;
    nextSp->Parameters.DeviceIoControl.OutputBufferLength = 0UL;
    nextSp->Parameters.DeviceIoControl.InputBufferLength = sizeof(ULONG);
    nextSp->Parameters.DeviceIoControl.IoControlCode =
        IOCTL_SERIAL_SET_WAIT_MASK;
    nextSp->Parameters.DeviceIoControl.Type3InputBuffer = NULL;

    *((PULONG)Irp->AssociatedIrp.SystemBuffer) = 0;

    IoSetCompletionRoutine(
        Irp,
        UniSetupSniffPart1,
        extension,
        TRUE,
        TRUE,
        TRUE
        );

    IoCallDriver(
        extension->AttachedDeviceObject,
        Irp
        );

    return STATUS_SUCCESS;

}

NTSTATUS
UniSetupSniffPart1(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    Call down to the lower serial driver to set the mask to
    sniff for DCD.

    Further processing (in the completion) will send down a wait irp
    that has been preallocated by the modem driver.

Arguments:

    DeviceObject - Pointer to the device object for the modem.

    Irp - Pointer to the IRP for the current request.

    Context - Really a pointer to the Extension.

Return Value:

    None.

--*/

{

    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);
    PIO_STACK_LOCATION nextSp = IoGetNextIrpStackLocation(Irp);
    PDEVICE_EXTENSION extension = Context;


    if (NT_ERROR(Irp->IoStatus.Status)) {

        PIRP newIrp = NULL;

        D_ERROR(DbgPrint("MODEM: UniSetupSniffPart1() %08lx\n",Irp->IoStatus.Status);)

        extension->PassThrough = MODEM_PASSTHROUGH;

        UNI_RESTORE_IRP(
            Irp,
            IOCTL_MODEM_SET_PASSTHROUGH
            );

        UniGetNextIrp(
            extension->DeviceObject,
            &extension->DeviceLock,
            &extension->CurrentPassThrough,
            &extension->PassThroughQueue,
            &newIrp,
            TRUE
            );

        if (newIrp) {

            UniPassThroughStarter(extension);

        }

    } else {

        nextSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;
        nextSp->MinorFunction = 0UL;
        nextSp->Flags = irpSp->Flags;
        nextSp->Parameters.DeviceIoControl.OutputBufferLength = 0UL;
        nextSp->Parameters.DeviceIoControl.InputBufferLength = sizeof(ULONG);
        nextSp->Parameters.DeviceIoControl.IoControlCode =
            IOCTL_SERIAL_SET_WAIT_MASK;
        nextSp->Parameters.DeviceIoControl.Type3InputBuffer = NULL;

        *((PULONG)Irp->AssociatedIrp.SystemBuffer) =
            extension->MaskStates[0].Mask |
            extension->MaskStates[1].Mask |
            (SERIAL_EV_RLSD | SERIAL_EV_DSR);

        IoSetCompletionRoutine(
            Irp,
            UniSetupSniffPart2,
            extension,
            TRUE,
            TRUE,
            TRUE
            );

        IoCallDriver(
            extension->AttachedDeviceObject,
            Irp
            );

    }

    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
UniSetupSniffPart2(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    This ends setting up for dcd sniffing.  If the status is actually
    ok, then send down the wait.  Otherwise go into passthrough mode.

Arguments:

    DeviceObject - Pointer to the device object for the modem.

    Irp - Pointer to the IRP for the current request.

    Context - Really a pointer to the Extension.

Return Value:

    Always more processing required.  We want to call our
    regular queue processing code at this point.  It will
    actually complete the irp.

--*/

{

    PDEVICE_EXTENSION extension = Context;
    PIRP newIrp;

    if (NT_ERROR(Irp->IoStatus.Status)) {

        D_ERROR(DbgPrint("MODEM: UniSetupSniffPart2() %08lx\n",Irp->IoStatus.Status);)

        extension->PassThrough = MODEM_PASSTHROUGH;

    } else {

        UniSendOurWaitDown(extension);

    }

    UNI_RESTORE_IRP(
        Irp,
        IOCTL_MODEM_SET_PASSTHROUGH
        );

    UniGetNextIrp(
        extension->DeviceObject,
        &extension->DeviceLock,
        &extension->CurrentPassThrough,
        &extension->PassThroughQueue,
        &newIrp,
        TRUE
        );

    if (newIrp) {

        UniPassThroughStarter(extension);

    }

    return STATUS_MORE_PROCESSING_REQUIRED;


}

NTSTATUS
UniSniffWaitComplete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    This is the completion routine associated with the wait irp
    owned by the serial driver.

Arguments:

    DeviceObject - Pointer to the device object for the modem.

    Irp - Pointer to the IRP for the current request.

    Context - Really a pointer to the Extension.

Return Value:

    Always more processing required.  This is a driver owned irp.
    We NEVER want the io subsystem to automatically deallocate it.

--*/

{

    PDEVICE_EXTENSION extension = Context;
    PIRP newIrp;
    ULONG maskValue;
    KIRQL origIrql;

    VALIDATE_IRP(Irp);

    //
    // We can complete because
    //
    // 1) The irp was cancelled.
    //
    // 2) The irp was in error.
    //
    // 3) The wait is satisfied.
    //
    // Let's examine each case separately.
    //
    // Case 1:
    //
    //    The irp can only be cancelled by the modem driver itself
    //    because the modem device is being closed.  (This is
    //    because nobody but the modem driver knows this irp
    //    exists (it's not in any threadlist.)
    //
    //    In this case, we should just act like we saw a DCD
    //    change.  This will cause everything to get shut down.
    //    This is just the shape that we want to be in for
    //    closing.
    //
    // Case 2:
    //
    //    Somehow, some other wait go in ahead of us.  It seems
    //    as though the only reasonable course of action here is
    //    to go into nopassthrough again.  This shuts everything
    //    down, and can put us into a state that the upper applications
    //    can detect an move forward with.  Note that I can not
    //    envision a situation where we would get an error.  This
    //    is why we will have an assert for this case.
    //
    // Case 3:
    //
    //    There are 3 subcases here.
    //
    //    Case A:
    //
    //        The irp completes with a mask value of zero.  This implies
    //        that somebody sent down a new setmask.  (A client changes
    //        what they are looking for perhaps.)  In this case
    //        if we are still in DCD sniff mode, then we should simply
    //        resubmit ourselves to the lower serial driver.  If we are
    //        no longer in sniff mode then we look for a shuttled wait.
    //        if there is one, send it on down.
    //
    //    Case B:
    //
    //        The irp completes with a mask value that doesn't include
    //        the DCD sniff values.  This means that we need to look
    //        at each  mask state and complete an irp if waiting
    //        for that kind of event (or update it's history if no wait
    //        shuttled).
    //
    //    Case C:
    //
    //        The irp completes with a mask value the does include
    //        the DCD sniff values.  Essentially at this point we need
    //        to go into nopassthrough mode.  Do all the stuff associated
    //        with that.  Then we need to essentially do what is in
    //        case 3B, and complete any irps there that are waiting
    //        on returned events.
    //

//    ASSERT(NT_SUCCESS(Irp->IoStatus.Status) ||
//           Irp->IoStatus.Status == STATUS_CANCELLED);

    RETURN_OUR_WAIT_IRP(extension,Irp);

    //
    // Freeze everything up.  We don't want anybody to move
    // now that we are thinking about who to complete and
    // send down.
    //

    KeAcquireSpinLock(
        &extension->DeviceLock,
        &origIrql
        );


    if (!NT_SUCCESS(Irp->IoStatus.Status) ||
         Irp->IoStatus.Status == STATUS_CANCELLED) {

        //
        // Set up so that we fall out of dcd sniff mode as well
        // as complete any pending waits.
        //

        maskValue = ~0UL;

    } else {

        maskValue = *((PULONG)Irp->AssociatedIrp.SystemBuffer);

    }

    if (maskValue == 0) {

        //
        // Case A.
        //

        if (extension->PassThrough == MODEM_DCDSNIFF) {

            //
            // Send ourself back down.
            //

            KeReleaseSpinLock(
                &extension->DeviceLock,
                origIrql
                );
            UniSendOurWaitDown(extension);

        } else {

            //
            // The following sees if there is a shuttled wait.  If there
            // is it will send it down.  There isn't any real possiblity
            // of starving a shuttled wait, as app wait completion code
            // will always complete both waits if possible.
            //
            // As a note, the set mask that caused us to complete with
            // a maskvalue of zero, CAN NOT cause the client or owner
            // shuttled waits to complete **HERE** because if the setmask
            // originated from the client or owner, it would have completed
            // the shuttled wait in it's ordinary processing before it
            // was sent down to the lower level serial driver.
            //

            if (!(extension->MaskStates[0].PassedDownWait ||
                  extension->MaskStates[1].PassedDownWait)) {

                if (extension->MaskStates[0].ShuttledWait) {

                    UniChangeShuttledToPassDown(
                        &extension->MaskStates[0],
                        origIrql
                        );

                } else if (extension->MaskStates[1].ShuttledWait) {

                    UniChangeShuttledToPassDown(
                        &extension->MaskStates[1],
                        origIrql
                        );

                } else {

                    KeReleaseSpinLock(
                        &extension->DeviceLock,
                        origIrql
                        );
                }

            } else {

                KeReleaseSpinLock(
                    &extension->DeviceLock,
                    origIrql
                    );
            }


        }

    } else {
        //
        //  mask value is non-zero, so a real event happened
        //
        MASKSTATE maskStates[2];

        UniPreProcessShuttledWaits(
            &extension->MaskStates[0],
            &maskStates[0],
            maskValue
            );

        KeReleaseSpinLock(
            &extension->DeviceLock,
            origIrql
            );


        if (maskValue & (SERIAL_EV_RLSD | SERIAL_EV_DSR)) {
            //
            // Got something for the DCD sniff.
            //
            // We first call up the code to go into the no passthrough mode.
            // That code does NOT take care of finding a shuttled wait to
            // pass down.  We will do that in the completion routine.
            //
            //


            //
            // Re-init the wait apps system buffer to null since we
            // will completely reuse the irp in the following pass.
            //

            Irp=RETREIVE_OUR_WAIT_IRP(extension);

            Irp->AssociatedIrp.SystemBuffer = NULL;

            UniSetupNoPassPart1(
                DeviceObject,
                Irp,
                Context
                );

        } else {
            //
            // This is a case where the dcd sniff isn't satisfied BUT, there
            // is a bit that a client/owner has asked to be able to wait on.
            // Resubmit ourself back down, but also update the client/owner
            // wait operations.
            //

            UniSendOurWaitDown(extension);

        }

        UniPostProcessShuttledWaits(
            extension,
            &maskStates[0],
            maskValue
            );

    }

    RemoveReference(extension->DeviceObject);

    return STATUS_MORE_PROCESSING_REQUIRED;

}

VOID
UniSendOurWaitDown(
    IN PDEVICE_EXTENSION Extension
    )

/*++

Routine Description:

    Sends the wait operation down to the lower level serial driver

Arguments:

    Extension - The device extension of the modem device

Return Value:

    None.

--*/

{

    PIRP irp =RETREIVE_OUR_WAIT_IRP(Extension);
//    PIRP irp = Extension->OurWaitIrp;

    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(irp);
    PIO_STACK_LOCATION nextSp = IoGetNextIrpStackLocation(irp);

    VALIDATE_IRP(irp);

    irp->AssociatedIrp.SystemBuffer = NULL;
    UNI_SETUP_NEW_BUFFER(irp);
    nextSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;
    nextSp->MinorFunction = 0;
    nextSp->Parameters.DeviceIoControl.OutputBufferLength = sizeof(ULONG);
    nextSp->Parameters.DeviceIoControl.InputBufferLength = 0UL;;
    nextSp->Parameters.DeviceIoControl.IoControlCode =
        IOCTL_SERIAL_WAIT_ON_MASK;
    nextSp->Parameters.DeviceIoControl.Type3InputBuffer = NULL;
    irp->CancelIrql = 0;
    irp->CancelRoutine = NULL;
    irp->Cancel = FALSE;

    IoSetCompletionRoutine(
        irp,
        UniSniffWaitComplete,
        Extension,
        TRUE,
        TRUE,
        TRUE
        );

    InterlockedIncrement(&Extension->ReferenceCount);

    VALIDATE_IRP(irp);

    IoCallDriver(
        Extension->AttachedDeviceObject,
        irp
        );

}

VOID
UniPreProcessShuttledWaits(
    IN PMASKSTATE ExtensionMaskStates,
    IN PMASKSTATE MaskStates,
    IN ULONG MaskValue
    )

/*++

Routine Description:

    This routine will go through shuttled waits and see which
    ones can be satisifed with the passed in mask value.  Any that
    would be completable are pulled out of the device extension.
    Any history masks are updated also.

    NOTE: This routine is called with the lock held.

Arguments:

    Extension - The device extension of the modem device

    MaskStates - Points to the first element of a maskstate array.

    MaskValue - The mask that the items would be completed with.

Return Value:

    None.

--*/

{

    UINT  i=2;

    RtlZeroMemory(MaskStates,sizeof(*MaskStates)*2);

    do {

        if (ExtensionMaskStates->Mask & MaskValue) {
            //
            //  the open is looking for this event
            //
            if (ExtensionMaskStates->ShuttledWait) {
                //
                // and it has a wait irp pending
                //
                *MaskStates = *ExtensionMaskStates;

                //
                //  the wait irp has been moved to the local copy, clear it from the extension copy
                //
                ExtensionMaskStates->ShuttledWait = NULL;

                //
                //  we have used this mask state, move to next
                //
                MaskStates++;

            } else {
                //
                //  no irp pending, but it wants to know about this event, put it in the history
                //
                ExtensionMaskStates->HistoryMask |= (ExtensionMaskStates->Mask & MaskValue);
            }
        }

        ExtensionMaskStates++;
        i--;

    } while (i > 0);

    return;
}

VOID
UniPostProcessShuttledWaits(
    IN PDEVICE_EXTENSION Extension,
    IN PMASKSTATE MaskStates,
    IN ULONG MaskValue
    )

/*++

Routine Description:

    This routine will take any preprocessed shuttled waits and run them
    down

Arguments:

    Extension - The device extension of the modem device

    MaskStates - Points to the first element of a maskstate array.

    MaskValue - The mask used in completing the operation.

Return Value:

    None.

--*/

{

    KIRQL origIrql;
    PIRP irpToComplete;// = MaskStates[0].ShuttledWait;
    UINT i=2;

    do {

        irpToComplete = MaskStates->ShuttledWait;

        if (irpToComplete) {
            //
            // Initiated sending the wait down.  Rundown any waits that
            // we should have satisfied.
            //
            VALIDATE_IRP(irpToComplete);

            MaskStates->ShuttledWait=NULL;

            KeAcquireSpinLock(
                &Extension->DeviceLock,
                &origIrql
                );

            UniRundownShuttledWait(
                Extension,
                &MaskStates->ShuttledWait,
                UNI_REFERENCE_NORMAL_PATH,
                irpToComplete,
                origIrql,
                STATUS_SUCCESS,
                (ULONG)MaskStates->Mask & MaskValue
                );

        }
        MaskStates++;
        i--;

    } while (i > 0);

    return;
}

NTSTATUS
UniValidateNewCommConfig(
    IN PDEVICE_EXTENSION Extension,
    IN PIRP Irp,
    IN BOOLEAN Owner
    )

/*++

Routine Description:

    Validates that new comm config settings do NOT conflict
    with the devcaps.

Arguments:

    Extension - The device extension of the modem device

    Irp - The irp with the new settings.

Return Value:

    STATUS_BUFFER_TOO_SMALL if not enough passed for the settings,
    STATUS_SUCCESS otherwise.

--*/

{

#define MIN_CALL_SETUP_FAIL_TIMER 1
#define MIN_INACTIVITY_TIMEOUT    0

    KIRQL origIrql;
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);
    LPCOMMCONFIG localConf = (LPCOMMCONFIG)(Irp->AssociatedIrp.SystemBuffer);
    PMODEMSETTINGS localSet = (PVOID)&localConf->wcProviderData[0];

    if (irpSp->Parameters.DeviceIoControl.InputBufferLength <
        (FIELD_OFFSET(COMMCONFIG,wcProviderData[0]) +  sizeof(MODEMSETTINGS))) {

        Irp->IoStatus.Information = 0L;

        RemoveReferenceAndCompleteRequest(
            Extension->DeviceObject,
            Irp,
            STATUS_BUFFER_TOO_SMALL
            );

        return STATUS_BUFFER_TOO_SMALL;

    }

    //
    // Acquire the spinlock now while we change settings.
    //

    KeAcquireSpinLock(
        &Extension->DeviceLock,
        &origIrql
        );

    if (localSet->dwCallSetupFailTimer >
        Extension->ModemDevCaps.dwCallSetupFailTimer) {

        Extension->ModemSettings.dwCallSetupFailTimer =
            Extension->ModemDevCaps.dwCallSetupFailTimer;

    } else if (localSet->dwCallSetupFailTimer < MIN_CALL_SETUP_FAIL_TIMER) {

        Extension->ModemSettings.dwCallSetupFailTimer =
            MIN_CALL_SETUP_FAIL_TIMER;

    } else {

        Extension->ModemSettings.dwCallSetupFailTimer =
            localSet->dwCallSetupFailTimer;

    }

    if (localSet->dwInactivityTimeout >
        Extension->ModemDevCaps.dwInactivityTimeout) {

        Extension->ModemSettings.dwInactivityTimeout =
            Extension->ModemDevCaps.dwInactivityTimeout;

    } else if ((localSet->dwInactivityTimeout + 1) < (MIN_INACTIVITY_TIMEOUT + 1)) {

        Extension->ModemSettings.dwInactivityTimeout =
            MIN_INACTIVITY_TIMEOUT;

    } else {

        Extension->ModemSettings.dwInactivityTimeout =
            localSet->dwInactivityTimeout;

    }

    if ((1 << localSet->dwSpeakerVolume) &
        Extension->ModemDevCaps.dwSpeakerVolume) {

        Extension->ModemSettings.dwSpeakerVolume = localSet->dwSpeakerVolume;

    }

    if ((1 << localSet->dwSpeakerMode) &
        Extension->ModemDevCaps.dwSpeakerMode) {

        Extension->ModemSettings.dwSpeakerMode = localSet->dwSpeakerMode;

    }

    Extension->ModemSettings.dwPreferredModemOptions =
        localSet->dwPreferredModemOptions &
        Extension->ModemDevCaps.dwModemOptions;

    //
    // The owner is allowed to set these fields and we do not need
    // to question their validity.  It is the owner's responsibility.
    //

    if (Owner) {

        Extension->ModemSettings.dwNegotiatedModemOptions =
            localSet->dwNegotiatedModemOptions;

        Extension->ModemSettings.dwNegotiatedDCERate =
            localSet->dwNegotiatedDCERate;

    }

    KeReleaseSpinLock(
        &Extension->DeviceLock,
        origIrql
        );


    Irp->IoStatus.Information = 0L;

    RemoveReferenceAndCompleteRequest(
        Extension->DeviceObject,
        Irp,
        STATUS_SUCCESS
        );


    return STATUS_SUCCESS;


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\sys\modem\wmi.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    wmi.c

Abstract:

    This module contains the code that handles WMI irps.

Author:

    Brian Lieuallen  10/7/98

Environment:

    Kernel mode

Revision History :

--*/

#include "precomp.h"

#include <wmistr.h>

#include <wdmguid.h>

NTSTATUS
ModemQueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PULONG RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT *Pdo
    );

NTSTATUS
ModemWmiQueryDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG BufferAvail,
    OUT PUCHAR Buffer
    );

NTSTATUS
ModemWmiSetDataItem(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG DataItemId,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    );

NTSTATUS
ModemWmiSetDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    );

NTSTATUS
SetWakeEnabledState(
    PDEVICE_OBJECT       DeviceObject,
    BOOLEAN              NewState
    );


#pragma alloc_text(PAGE,ModemQueryWmiRegInfo)
#pragma alloc_text(PAGE,ModemWmiQueryDataBlock)
#pragma alloc_text(PAGE,ModemWmiSetDataItem)
#pragma alloc_text(PAGE,ModemWmiSetDataBlock)
#pragma alloc_text(PAGE,ModemWmi)
#pragma alloc_text(PAGE,SetWakeEnabledState)

#if 0
// {BE742A70-B6EF-11d2-A287-00C04F8EC951}
DEFINE_GUID(MODEM_WAKE_ON_RING_STATE,
    0xbe742a70, 0xb6ef, 0x11d2, 0xa2, 0x87, 0x0, 0xc0, 0x4f, 0x8e, 0xc9, 0x51);
#endif
#define MODEM_WMI_WAKE_INDEX 0

WMIGUIDREGINFO   WmiGuidInfo = {
    &GUID_POWER_DEVICE_WAKE_ENABLE, 1, WMIREG_FLAG_INSTANCE_PDO };

WMILIB_CONTEXT   WmiContext= {
    1,
    &WmiGuidInfo,
    ModemQueryWmiRegInfo,
    ModemWmiQueryDataBlock,
    ModemWmiSetDataBlock,
    ModemWmiSetDataItem,
    NULL, //executeMethod
    NULL, //dunctionControl
    };
#if 0
WMILIB_CONTEXT   NoWakeWmiContext= {
    0,
    NULL,
    ModemQueryWmiRegInfo,
    ModemWmiQueryDataBlock,
    ModemWmiSetDataBlock,
    ModemWmiSetDataItem,
    NULL, //executeMethod
    NULL, //dunctionControl
    };
#endif

NTSTATUS
ModemWmi(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

{

    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);

    SYSCTL_IRP_DISPOSITION           IrpDisposition;
    NTSTATUS status;

    BOOLEAN   WakeSupported;

    if ((deviceExtension->DoType==DO_TYPE_PDO) || (deviceExtension->DoType==DO_TYPE_DEL_PDO)) {
        //
        //  this one is for the child
        //
        return ModemPdoWmi(
                   DeviceObject,
                   Irp
                   );
    }


    D_WMI(DbgPrint("MODEM: Wmi\n");)


    //
    //  make sure the device is ready for irp's
    //
    status=CheckStateAndAddReferenceWMI(
        DeviceObject,
        Irp
        );

    if (STATUS_SUCCESS != status) {
        //
        //  not accepting irp's. The irp has already been completed
        //
        return status;

    }

    if (!deviceExtension->CapsQueried) {
        //
        //  caps have not been queried, yet so we don't know the wake caps, do it here
        //
        DEVICE_CAPABILITIES   DeviceCaps;

        QueryDeviceCaps(
            deviceExtension->Pdo,
            &DeviceCaps
            );
    }


    // WakeSupported=((deviceExtension->SystemWake != PowerSystemUnspecified)
    //                &&
    //                (deviceExtension->DeviceWake != PowerDeviceUnspecified));
    //
    WakeSupported=((deviceExtension->SystemWake > PowerSystemWorking)
		    &&
		    (deviceExtension->DeviceWake > PowerDeviceD0));


    if (!WakeSupported) {
        //
        //  we don't support wmi for this modem
        //

        if (irpSp->Parameters.WMI.ProviderId == (ULONG_PTR)DeviceObject)
        {
            // we can't forward this any further.  Remove IRP and
            // return status success

            RemoveReferenceForDispatch(DeviceObject);

            status = Irp->IoStatus.Status;

            RemoveReferenceAndCompleteRequest(DeviceObject,
                    Irp,
                    Irp->IoStatus.Status);

            return status;
        } else

        {

            D_WMI(DbgPrint("MODEM: Wmi: No support, forwarding\n");)

                status=ForwardIrp(deviceExtension->LowerDevice, Irp);

            RemoveReferenceForIrp(DeviceObject);

            RemoveReferenceForDispatch(DeviceObject);

            return status;
        }

    }

    status=WmiSystemControl(
        &WmiContext,
        DeviceObject,
        Irp,
        &IrpDisposition
        );



    switch (IrpDisposition) {

        case IrpForward:

            D_WMI(DbgPrint("MODEM: Wmi: disp Forward\n");)

            status=ForwardIrp(deviceExtension->LowerDevice, Irp);

            RemoveReferenceForIrp(DeviceObject);

            break;


        case IrpNotWmi:

            D_WMI(DbgPrint("MODEM: Wmi: disp NotWmi\n");)

            status=ForwardIrp(deviceExtension->LowerDevice, Irp);

            RemoveReferenceForIrp(DeviceObject);

            break;

        case IrpProcessed:
            //
            //  wmi should have completed it now
            //
            D_WMI(DbgPrint("MODEM: Wmi: disp Processed\n");)

            RemoveReferenceForIrp(DeviceObject);
            break;

        case IrpNotCompleted:

            D_WMI(DbgPrint("MODEM: Wmi: disp NotCompleted\n");)

            RemoveReferenceAndCompleteRequest(
                DeviceObject,
                Irp,
                Irp->IoStatus.Status
                );

            break;

        default:

            ASSERT(0);
            break;
    }

    RemoveReferenceForDispatch(DeviceObject);

    return status;


}



NTSTATUS
ModemQueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PULONG RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT *Pdo
    )

{

    PDEVICE_EXTENSION DeviceExtension = DeviceObject->DeviceExtension;

    D_WMI(DbgPrint("MODEM: Wmi: queryRegInfo\n");)

    *RegFlags=WMIREG_FLAG_INSTANCE_PDO;
    *RegistryPath=&DriverEntryRegPath;
    RtlInitUnicodeString(MofResourceName,L"MODEMWMI");
    *Pdo=DeviceExtension->Pdo;

    return STATUS_SUCCESS;

}





NTSTATUS
ModemWmiQueryDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG BufferAvail,
    OUT PUCHAR Buffer
    )

{
    PDEVICE_EXTENSION DeviceExtension = DeviceObject->DeviceExtension;
    NTSTATUS          Status;
    ULONG             BytesUsed=0;

    D_WMI(DbgPrint("MODEM: Wmi: QueryDataBlock GuidIndex=%d, InstanceIndex=%d, size=%d\n",GuidIndex,InstanceIndex,BufferAvail);)

    switch (GuidIndex) {

        case MODEM_WMI_WAKE_INDEX:

            if (BufferAvail >= sizeof(BYTE)) {

                *Buffer=DeviceExtension->WakeOnRingEnabled;
                BytesUsed=sizeof(BYTE);
                *InstanceLengthArray=BytesUsed;
                Status=STATUS_SUCCESS;

            } else {

                BytesUsed=sizeof(BYTE);
                Status=STATUS_BUFFER_TOO_SMALL;

            }

            break;

        default:

            Status=STATUS_WMI_GUID_NOT_FOUND;

            break;
    }

    return WmiCompleteRequest(
        DeviceObject,
        Irp,
        Status,
        BytesUsed,
        IO_NO_INCREMENT
        );


}



NTSTATUS
ModemWmiSetDataItem(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG DataItemId,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    )

{
    PDEVICE_EXTENSION DeviceExtension = DeviceObject->DeviceExtension;

    NTSTATUS          Status;
    ULONG             BytesUsed=0;

    D_WMI(DbgPrint("MODEM: Wmi: SetDataItem GuidIndex=%d, InstanceIndex=%d, size=%d\n",GuidIndex,InstanceIndex,BufferSize);)

    switch (GuidIndex) {

        case MODEM_WMI_WAKE_INDEX:

            if (BufferSize >= sizeof(BYTE)) {

                SetWakeEnabledState(DeviceObject,*Buffer);

                BytesUsed=sizeof(BYTE);
                Status=STATUS_SUCCESS;

            } else {

                BytesUsed=sizeof(BYTE);
                Status=STATUS_BUFFER_TOO_SMALL;

            }

            break;

        default:

            Status=STATUS_WMI_GUID_NOT_FOUND;

            break;
    }


    return WmiCompleteRequest(
        DeviceObject,
        Irp,
        Status,
        BytesUsed,
        IO_NO_INCREMENT
        );


}






NTSTATUS
ModemWmiSetDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    )

{
    PDEVICE_EXTENSION DeviceExtension = DeviceObject->DeviceExtension;

    NTSTATUS          Status;
    ULONG             BytesUsed=0;

    D_WMI(DbgPrint("MODEM: Wmi: SetDataBlock GuidIndex=%d, InstanceIndex=%d, size=%d\n",GuidIndex,InstanceIndex,BufferSize);)

    switch (GuidIndex) {

        case MODEM_WMI_WAKE_INDEX:

            if (BufferSize >= sizeof(BYTE)) {

                SetWakeEnabledState(DeviceObject,*Buffer);

                BytesUsed=sizeof(BYTE);
                Status=STATUS_SUCCESS;

            } else {

                BytesUsed=sizeof(BYTE);
                Status=STATUS_BUFFER_TOO_SMALL;

            }

            break;

        default:

            Status=STATUS_WMI_GUID_NOT_FOUND;

            break;
    }


    return WmiCompleteRequest(
        DeviceObject,
        Irp,
        Status,
        BytesUsed,
        IO_NO_INCREMENT
        );


}



NTSTATUS
SetWakeEnabledState(
    PDEVICE_OBJECT       DeviceObject,
    BOOLEAN              NewState
    )

{
    DWORD dwTemp;
    NTSTATUS status;
    PDEVICE_EXTENSION DeviceExtension;

    DeviceExtension = DeviceObject->DeviceExtension;

    D_WMI(DbgPrint("MODEM: SetWakeState: %s\n", NewState ? "Enable" : "Disable");)

        KeEnterCriticalRegion();

    ExAcquireResourceExclusiveLite(
            &DeviceExtension->OpenCloseResource,
            TRUE
                              );

    if (DeviceExtension->OpenCount == 0) {
        //
        //  device is closed, just set the state
        //
        DeviceExtension->WakeOnRingEnabled=NewState;


    } else {
        //
        //  it is already open
        //
        if ((DeviceExtension->WakeOnRingEnabled && NewState)
                ||
                (!DeviceExtension->WakeOnRingEnabled && !NewState)) {
            //
            //  same state. easy
            //
        } else {
            //
            //  tell the lower driver the new state
            //
            DeviceExtension->WakeOnRingEnabled=NewState;

            EnableDisableSerialWaitWake(
                    DeviceExtension,
                    NewState);
        }
    }

    ExReleaseResourceLite( &DeviceExtension->OpenCloseResource);

    KeLeaveCriticalRegion();

    dwTemp = 0;
    if (DeviceExtension->WakeOnRingEnabled)
    {
        dwTemp = 1;
    }

    status = ModemSetRegistryKeyValue(
            DeviceExtension->Pdo,
            PLUGPLAY_REGKEY_DEVICE,
            L"WakeOnRing",
            REG_DWORD,
            &dwTemp,
            sizeof(DWORD));

    if (!NT_SUCCESS(status))
    {
        D_ERROR(DbgPrint("MODEM: Could not set wake on ring status %08lx\n",status);)
    } else
    {
        D_ERROR(DbgPrint("MODEM: Set reg entry for wake on ring %08lx\n",status);)
    }

    return STATUS_SUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\sys\modemcsa\filter.c ===
/*++

Copyright (c) 1996 Microsoft Corporation.

Module Name:

    filter.c

Abstract:

    Filter property sets.

--*/

#include "modemcsa.h"



#ifdef ALLOC_PRAGMA
NTSTATUS
FilterDispatchCreate(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );
NTSTATUS
FilterDispatchClose(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );
NTSTATUS
FilterDispatchIoControl(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );
NTSTATUS
FilterTopologyPropertyHandler(
    IN PIRP         Irp,
    IN PKSPROPERTY  Property,
    IN OUT PVOID    Data
    );
NTSTATUS
FilterPinPropertyHandler(
    IN PIRP         Irp,
    IN PKSPROPERTY  Property,
    IN OUT PVOID    Data
    );
NTSTATUS
FilterPinInstances(
    IN PIRP                 Irp,
    IN PKSP_PIN             Pin,
    OUT PKSPIN_CINSTANCES   Instances
    );
NTSTATUS
IntersectHandler(
    IN PIRP             Irp,
    IN PKSP_PIN         Pin,
    IN PKSDATARANGE     DataRange,
    OUT PVOID           Data
    );
NTSTATUS
FilterPinIntersection(
    IN PIRP     Irp,
    IN PKSP_PIN Pin,
    OUT PVOID   Data
    );

NTSTATUS
GetModemDeviceName(
    PDEVICE_OBJECT    Pdo,
    UNICODE_STRING   *ModemDeviceName
    );


NTSTATUS
SetPersistanInterfaceInfo(
    PUNICODE_STRING   Interface,
    PWCHAR            ValueName,
    ULONG             Type,
    PVOID             Buffer,
    ULONG             BufferLength
    );

NTSTATUS
IdGetHandler(
    IN PIRP         Irp,
    IN PKSIDENTIFIER Request,
    IN OUT PVOID    Data
    );


#pragma alloc_text(PAGE, PnpAddDevice)
#pragma alloc_text(PAGE, FilterDispatchCreate)
#pragma alloc_text(PAGE, FilterDispatchClose)
#pragma alloc_text(PAGE, FilterDispatchIoControl)
#pragma alloc_text(PAGE, FilterTopologyPropertyHandler)
#pragma alloc_text(PAGE, FilterPinPropertyHandler)
#pragma alloc_text(PAGE, FilterPinInstances)
#pragma alloc_text(PAGE, IntersectHandler)
#pragma alloc_text(PAGE, FilterPinIntersection)
#endif // ALLOC_PRAGMA

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif // ALLOC_DATA_PRAGMA

static const WCHAR PinTypeName[] = KSSTRING_Pin;

static const DEFINE_KSCREATE_DISPATCH_TABLE(FilterCreateItems) {
    DEFINE_KSCREATE_ITEM(PinDispatchCreate, PinTypeName, 0)
};

static DEFINE_KSDISPATCH_TABLE(
    FilterDispatchTable,
    FilterDispatchIoControl,
    NULL,
    NULL,
    NULL,
    FilterDispatchClose,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL);


static DEFINE_KSPROPERTY_PINSET(
    FilterPinProperties,
    FilterPinPropertyHandler,
    FilterPinInstances,
    FilterPinIntersection);

static const GUID RenderCategory[] = {
    STATICGUIDOF(KSCATEGORY_RENDER)
};


static const KSTOPOLOGY FilterRenderTopology = {
    SIZEOF_ARRAY(RenderCategory),
    (GUID*)RenderCategory,
    0,
    NULL,
    0,
    NULL,
    NULL,
    0
};

// {F420CB9C-B19D-11d2-A286-00C04F8EC951}
static const GUID KSPROPSETID_MODEMCSA={
0xf420cb9c, 0xb19d, 0x11d2, 0xa2, 0x86, 0x0, 0xc0, 0x4f, 0x8e, 0xc9, 0x51};




static DEFINE_KSPROPERTY_TOPOLOGYSET(
    FilterTopologyProperties,
    FilterTopologyPropertyHandler);


const KSPROPERTY_ITEM IdPropertyItem= {
    0,
    IdGetHandler,
    sizeof(KSPROPERTY),
    sizeof(GUID),
    NULL,
    NULL,
    0,
    NULL,
    NULL,
    0
    };

static DEFINE_KSPROPERTY_SET_TABLE(FilterPropertySets) {
    DEFINE_KSPROPERTY_SET(
        &KSPROPSETID_Pin,
        SIZEOF_ARRAY(FilterPinProperties),
        FilterPinProperties,
        0,
        NULL),
    DEFINE_KSPROPERTY_SET(
        &KSPROPSETID_Topology,
        SIZEOF_ARRAY(FilterTopologyProperties),
        FilterTopologyProperties,
        0,
        NULL),
    DEFINE_KSPROPERTY_SET(
        &KSPROPSETID_MODEMCSA,
        1,
        &IdPropertyItem,
        0,
        NULL)

};

static DEFINE_KSPIN_INTERFACE_TABLE(PinInterfaces) {
    DEFINE_KSPIN_INTERFACE_ITEM(
        KSINTERFACESETID_Standard,
        KSINTERFACE_STANDARD_STREAMING)
};

static DEFINE_KSPIN_MEDIUM_TABLE(PinDevIoMediums) {
    DEFINE_KSPIN_MEDIUM_ITEM(
        KSMEDIUMSETID_Standard,
        KSMEDIUM_TYPE_ANYINSTANCE)
};



//
// Data ranges = collective formats supported on our Pins.
// In our case, streams of unknown data
//typedef struct {
//   KSDATARANGE              DataRange;
//   ULONG                    MaximumChannels;
//   ULONG                    MinimumBitsPerSample;
//   ULONG                    MaximumBitsPerSample;
//   ULONG                    MinimumSampleFrequency;
//   ULONG                    MaximumSampleFrequency;
//} KSDATARANGE_AUDIO, *PKSDATARANGE_AUDIO;

const KSDATARANGE_AUDIO PinDevIoRange = {
	{

		sizeof(KSDATARANGE_AUDIO),//(KSDATARANGE_AUDIO),
		0,
		0,
		0,
		STATIC_KSDATAFORMAT_TYPE_AUDIO,			 // major format
                STATICGUIDOF(KSDATAFORMAT_SUBTYPE_PCM),
		STATIC_KSDATAFORMAT_SPECIFIER_WAVEFORMATEX
	},
	1, // 1 channels
	STREAM_BYTES_PER_SAMPLE*8,
        STREAM_BYTES_PER_SAMPLE*8,
	SAMPLES_PER_SECOND,
	SAMPLES_PER_SECOND
};
#if 0
const KSDATARANGE_AUDIO PinDevIoRange8bit = {
	{

		sizeof(KSDATARANGE_AUDIO),//(KSDATARANGE_AUDIO),
		0,
		0,
		0,
		STATIC_KSDATAFORMAT_TYPE_AUDIO,			 // major format
                STATICGUIDOF(KSDATAFORMAT_SUBTYPE_PCM),
		STATIC_KSDATAFORMAT_SPECIFIER_WAVEFORMATEX
	},
	1, // 1 channels
	8,
        8,
	SAMPLES_PER_SECOND,
	SAMPLES_PER_SECOND
};
#endif

//
// Array of above (only one for us).
// TBS: we should split this out into an array of specific types when we get more
// sophisticated in identifying the type of stream handled by teh VC via CallParams
// -- e.g. audio, video	with subformats of compression types. Eventually, we should
// create a bridge PIN of format corresponding to callparams info, then expose the
// full range of these types via the PIN factory. The PinDispatchCreate handler
// would look for a bridge PIN of teh corresponding type.
//
static const PKSDATARANGE PinDevIoRanges[] = {
	(PKSDATARANGE)&PinDevIoRange
};


//CONST GUID RenderName={STATIC_KSNODETYPE_PHONE_LINE};

// {AD536070-AFDE-11d2-A286-00C04F8EC951}
    static const GUID CaptureName =
    { 0xad536070, 0xafde, 0x11d2, { 0xa2, 0x86, 0x0, 0xc0, 0x4f, 0x8e, 0xc9, 0x51 } };

// {10C328BC-AFE1-11d2-A286-00C04F8EC951}
    static const GUID RenderName =
    { 0x10c328bc, 0xafe1, 0x11d2, { 0xa2, 0x86, 0x0, 0xc0, 0x4f, 0x8e, 0xc9, 0x51 } };



DEFINE_KSPIN_DESCRIPTOR_TABLE(PinDescriptors) {

    DEFINE_KSPIN_DESCRIPTOR_ITEMEX(
        SIZEOF_ARRAY(PinInterfaces),
        PinInterfaces,
        SIZEOF_ARRAY(PinDevIoMediums),
        PinDevIoMediums,
        SIZEOF_ARRAY(PinDevIoRanges),
        (PKSDATARANGE*)PinDevIoRanges,
        KSPIN_DATAFLOW_IN,
        KSPIN_COMMUNICATION_BOTH,
        NULL,
        &RenderName
        ),

    DEFINE_KSPIN_DESCRIPTOR_ITEMEX(
        SIZEOF_ARRAY(PinInterfaces),
        PinInterfaces,
        SIZEOF_ARRAY(PinDevIoMediums),
        PinDevIoMediums,
        SIZEOF_ARRAY(PinDevIoRanges),
        (PKSDATARANGE*)PinDevIoRanges,
        KSPIN_DATAFLOW_OUT,
        KSPIN_COMMUNICATION_BOTH,
        NULL,
        &CaptureName
        )

};


#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif // ALLOC_DATA_PRAGMA



NTSTATUS
FilterDispatchCreate(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

    Dispatches the creation of a Filter instance. Allocates the object header and initializes
    the data for this Filter instance.

Arguments:

    DeviceObject -
        Device object on which the creation is occuring.

    Irp -
        Creation Irp.

Return Values:

    Returns STATUS_SUCCESS on success, STATUS_INSUFFICIENT_RESOURCES or some related error
    on failure.

--*/
{
    NTSTATUS            Status;
//    UNICODE_STRING      ModemDeviceName;

    PFILTER_INSTANCE    FilterInstance;

    D_INIT(DbgPrint("MODEMCSA: FilterDispatchCreate\n");)
    //
    // Create the instance information. This contains the list of current Pins, and
    // the mutex used when modifying pins.
    //
    if (FilterInstance = (PFILTER_INSTANCE)ExAllocatePoolWithTag(NonPagedPool, sizeof(FILTER_INSTANCE), 'IFsK')) {

        RtlZeroMemory(FilterInstance,sizeof(FILTER_INSTANCE));

        //
        // This object uses KS to perform access through the FilterCreateItems and
        // FilterDispatchTable.
        //
        Status = KsAllocateObjectHeader(&FilterInstance->Header,
            SIZEOF_ARRAY(FilterCreateItems),
            (PKSOBJECT_CREATE_ITEM)FilterCreateItems,
            Irp,
            &FilterDispatchTable);

        if (NT_SUCCESS(Status)) {
            ULONG       PinCount;

            ExInitializeFastMutex(&FilterInstance->ControlMutex);
            //
            // Initialize the list of Pins on this Filter to an unconnected state.
            //
            for (PinCount = SIZEOF_ARRAY(FilterInstance->PinFileObjects); PinCount;) {
                FilterInstance->PinFileObjects[--PinCount] = NULL;
            }

            InitializeDuplexControl(
                &((PDEVICE_INSTANCE)DeviceObject->DeviceExtension)->DuplexControl,
                &((PDEVICE_INSTANCE)DeviceObject->DeviceExtension)->ModemDeviceName
                );

            FilterInstance->DeviceObject=DeviceObject;
            //
            // KS expects that the object data is in FsContext.
            //
            IoGetCurrentIrpStackLocation(Irp)->FileObject->FsContext = FilterInstance;
        } else {
            ExFreePool(FilterInstance);
        }
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }


    Irp->IoStatus.Status = Status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return Status;
}


NTSTATUS
FilterDispatchClose(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

    Closes a previously opened Filter instance. This can only occur after the Pins have been
    closed, as they reference the Filter object when created. This also implies that all the
    resources the Pins use have been released or cleaned up.

Arguments:

    DeviceObject -
        Device object on which the close is occuring.

    Irp -
        Close Irp.

Return Values:

    Returns STATUS_SUCCESS.

--*/
{
    PFILTER_INSTANCE    FilterInstance;

    FilterInstance = (PFILTER_INSTANCE)IoGetCurrentIrpStackLocation(Irp)->FileObject->FsContext;

    D_INIT(DbgPrint("MODEMCSA: FilterDispatchClose\n");)


    //
    // These were allocated during the creation of the Filter instance.
    //
    KsFreeObjectHeader(FilterInstance->Header);
    ExFreePool(FilterInstance);

    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}


NTSTATUS
FilterDispatchIoControl(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

    Dispatches property requests on a Filter instance. These are enumerated in the
    FilterPropertySets list.

Arguments:

    DeviceObject -
        Device object on which the device control is occuring.

    Irp -
        Device control Irp.

Return Values:

    Returns STATUS_SUCCESS if the property was successfully manipulated, else an error.

--*/
{
    PIO_STACK_LOCATION  IrpStack;
    NTSTATUS            Status;

//    D_INIT(DbgPrint("MODEMCSA: FilterDispatchIoControl\n");)

    IrpStack = IoGetCurrentIrpStackLocation(Irp);

    switch (IrpStack->Parameters.DeviceIoControl.IoControlCode) {

    case IOCTL_KS_PROPERTY: {
#if DBG
            KSPROPERTY          LocalProperty;

            RtlCopyMemory(
                &LocalProperty,
                IrpStack->Parameters.DeviceIoControl.Type3InputBuffer,
                sizeof(LocalProperty) < IrpStack->Parameters.DeviceIoControl.InputBufferLength ?
                    sizeof(LocalProperty) : IrpStack->Parameters.DeviceIoControl.InputBufferLength
                );

            D_PROP(DbgPrint(
                "MODEMCSA: Property, guid=%08lx-%04x, id=%d, flags=%08lx\n",
                LocalProperty.Set.Data1,
                LocalProperty.Set.Data2,
                LocalProperty.Id,
                LocalProperty.Flags
                );)
#endif


            Status = KsPropertyHandler(Irp, SIZEOF_ARRAY(FilterPropertySets), FilterPropertySets);
            break;
        }

    default:
        return KsDefaultDeviceIoCompletion(DeviceObject, Irp);
    }
    Irp->IoStatus.Status = Status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return Status;
}




NTSTATUS
IdGetHandler(
    IN PIRP         Irp,
    IN PKSIDENTIFIER Request,
    IN OUT PVOID    Data
    )
/*++

Routine Description:

    This is the general handler for most Pin property requests, and is used to route
    the request to the KsPinPropertyHandler using the Pin[Reader/Writer]Descriptors
    information. This request would have been routed through FilterDispatchIoControl,
    then KsPropertyHandler, which would have then called the handler for the property
    item, which is this function.

Arguments:

    Irp -
        Device control Irp.

    Property -
        Specific property request. This actually contains a PKSP_PIN pointer in
        most cases.

    Data -
        Property data.

Return Values:

    Returns STATUS_SUCCESS if the property was successfully manipulated, else an error.

--*/
{
    PFILTER_INSTANCE    FilterInstance;
    PDEVICE_INSTANCE     DeviceInstance;

    D_INIT(DbgPrint("MODEMCSA: guid queried\n");)

    FilterInstance = (PFILTER_INSTANCE)IoGetCurrentIrpStackLocation(Irp)->FileObject->FsContext;

    DeviceInstance=(PDEVICE_INSTANCE)FilterInstance->DeviceObject->DeviceExtension;

    RtlCopyMemory(
        Data,
        &DeviceInstance->PermanentGuid,
        sizeof(GUID)
        );

    Irp->IoStatus.Information = sizeof(GUID);
    return STATUS_SUCCESS;

}





NTSTATUS
FilterPinPropertyHandler(
    IN PIRP         Irp,
    IN PKSPROPERTY  Property,
    IN OUT PVOID    Data
    )
/*++

Routine Description:

    This is the general handler for most Pin property requests, and is used to route
    the request to the KsPinPropertyHandler using the Pin[Reader/Writer]Descriptors
    information. This request would have been routed through FilterDispatchIoControl,
    then KsPropertyHandler, which would have then called the handler for the property
    item, which is this function.

Arguments:

    Irp -
        Device control Irp.

    Property -
        Specific property request. This actually contains a PKSP_PIN pointer in
        most cases.

    Data -
        Property data.

Return Values:

    Returns STATUS_SUCCESS if the property was successfully manipulated, else an error.

--*/
{


    return KsPinPropertyHandler(Irp, Property, Data, SIZEOF_ARRAY(PinDescriptors), PinDescriptors);

}


NTSTATUS
FilterPinInstances(
    IN PIRP                 Irp,
    IN PKSP_PIN             Pin,
    OUT PKSPIN_CINSTANCES   Instances
    )
/*++

Routine Description:

    Handles the KSPROPERTY_PIN_CINSTANCES property in the Pin property set. Returns the
    total possible and current number of Pin instances available for a Pin factory.

Arguments:

    Irp -
        Device control Irp.

    Pin -
        Specific property request followed by Pin factory identifier.

    Instances -
        The place in which to return the instance information of the specified Pin factory.

Return Values:

    returns STATUS_SUCCESS, else STATUS_INVALID_PARAMETER.

--*/
{
    PFILTER_INSTANCE    FilterInstance;

    //
    // Ensure that the Pin factory being queried is valid. Assumes that the Reader/Writer
    // have the same number of Pin Factories.
    //
    if (Pin->PinId >= SIZEOF_ARRAY(PinDescriptors)) {
        return STATUS_INVALID_PARAMETER;
    }


    //
    // There is always only one instance total, but the current number depends on whether
    // there is a file object in this slot in the Filter instance. This does not take the
    // filter mutex, since it is just retrieving whether or not the value is NULL at that
    // particular instant, and it does not matter if the value subsequently changes.
    //
    Instances->PossibleCount = 1;
    FilterInstance = (PFILTER_INSTANCE)IoGetCurrentIrpStackLocation(Irp)->FileObject->FsContext;
    Instances->CurrentCount = FilterInstance->PinFileObjects[Pin->PinId] ? 1 : 0;
    Irp->IoStatus.Information = sizeof(*Instances);
    return STATUS_SUCCESS;
}


NTSTATUS
IntersectHandler(
    IN PIRP             Irp,
    IN PKSP_PIN         Pin,
    IN PKSDATARANGE     DataRange,
    OUT PVOID           Data
    )
/*++

Routine Description:

    This is the data range callback for KsPinDataIntersection, which is called by
    FilterPinIntersection to enumerate the given list of data ranges, looking for
    an acceptable match. If a data range is acceptable, a data format is copied
    into the return buffer. A STATUS_NO_MATCH continues the enumeration.

Arguments:

    Irp -
        Device control Irp.

    Pin -
        Specific property request followed by Pin factory identifier, followed by a
        KSMULTIPLE_ITEM structure. This is followed by zero or more data range structures.
        This enumeration callback does not need to look at any of this though. It need
        only look at the specific pin identifier.

    DataRange -
        Contains a specific data range to validate.

    Data -
        The place in which to return the data format selected as the first intersection
        between the list of data ranges passed, and the acceptable formats.

Return Values:

    returns STATUS_SUCCESS or STATUS_NO_MATCH, else STATUS_INVALID_PARAMETER,
    STATUS_BUFFER_TOO_SMALL, or STATUS_INVALID_BUFFER_SIZE.

--*/
{
    ULONG       OutputBufferLength;
    GUID        SubFormat;
    BOOL        SubFormatSet;
    NTSTATUS    Status=STATUS_SUCCESS;

    //
    // Determine whether the data format itself is to be returned, or just the size
    // of the data format so that the client can allocate memory for the full range.
    // Assumes that the data range structures are the same size as data formats.
    //
    OutputBufferLength = IoGetCurrentIrpStackLocation(Irp)->Parameters.DeviceIoControl.OutputBufferLength;

    if ((DataRange->FormatSize == sizeof(KSDATARANGE_AUDIO)) &&
        IsEqualGUIDAligned(&DataRange->MajorFormat, &PinDevIoRange.DataRange.MajorFormat) &&
        IsEqualGUIDAligned(&DataRange->Specifier, &PinDevIoRange.DataRange.Specifier)) {


        if (OutputBufferLength == sizeof(ULONG)) {

            *(PULONG)Data = sizeof(KSDATAFORMAT_WAVEFORMATEX);
            Irp->IoStatus.Information = sizeof(ULONG);

        } else {

            if (OutputBufferLength < sizeof(KSDATAFORMAT_WAVEFORMATEX)) {

                Status = STATUS_BUFFER_TOO_SMALL;

            } else {

                PKSDATARANGE_AUDIO          AudioRange;
                PKSDATAFORMAT_WAVEFORMATEX  WaveFormat;


                //
                // No preexisting format -- default to a generic audio format.
                //
                AudioRange = (PKSDATARANGE_AUDIO)DataRange;

                WaveFormat = (PKSDATAFORMAT_WAVEFORMATEX)Data;


                WaveFormat->DataFormat = AudioRange->DataRange;

                WaveFormat->DataFormat.FormatSize = sizeof(KSDATAFORMAT_WAVEFORMATEX);

                //
                // The range just contained a wildcard, so default to PCM.
                //
                WaveFormat->WaveFormatEx.wFormatTag = WAVE_FORMAT_PCM;
                WaveFormat->DataFormat.SubFormat = KSDATAFORMAT_SUBTYPE_PCM;

//                WaveFormat->WaveFormatEx.wFormatTag = EXTRACT_WAVEFORMATEX_ID(&DataRange->SubFormat);

                WaveFormat->WaveFormatEx.nChannels = (USHORT)1;
                WaveFormat->WaveFormatEx.nSamplesPerSec = SAMPLES_PER_SECOND;
                WaveFormat->WaveFormatEx.wBitsPerSample = (USHORT)AudioRange->MaximumBitsPerSample;
                WaveFormat->WaveFormatEx.nAvgBytesPerSec =
                   (WaveFormat->WaveFormatEx.nSamplesPerSec *
                    WaveFormat->WaveFormatEx.wBitsPerSample *
                    WaveFormat->WaveFormatEx.nChannels) / 8;

                WaveFormat->WaveFormatEx.nBlockAlign = (USHORT)AudioRange->MaximumBitsPerSample/8;
                WaveFormat->WaveFormatEx.cbSize = 0;

                Irp->IoStatus.Information = sizeof(KSDATAFORMAT_WAVEFORMATEX);

            }
        }
    }

    return Status;
}


NTSTATUS
FilterPinIntersection(
    IN PIRP     Irp,
    IN PKSP_PIN Pin,
    OUT PVOID   Data
    )
/*++

Routine Description:

    Handles the KSPROPERTY_PIN_DATAINTERSECTION property in the Pin property set.
    Returns the first acceptable data format given a list of data ranges for a specified
    Pin factory. Actually just calls the Intersection Enumeration helper, which then
    calls the IntersectHandler callback with each data range.

Arguments:

    Irp -
        Device control Irp.

    Pin -
        Specific property request followed by Pin factory identifier, followed by a
        KSMULTIPLE_ITEM structure. This is followed by zero or more data range structures.

    Data -
        The place in which to return the data format selected as the first intersection
        between the list of data ranges passed, and the acceptable formats.

Return Values:

    returns STATUS_SUCCESS or STATUS_NO_MATCH, else STATUS_INVALID_PARAMETER,
    STATUS_BUFFER_TOO_SMALL, or STATUS_INVALID_BUFFER_SIZE.

--*/
{
    //
    // Assumes that the Reader/Writer have the same number of Pin Factories,
    // and that they support the same data ranges.
    //
    return KsPinDataIntersection(
        Irp,
        Pin,
        Data,
        SIZEOF_ARRAY(PinDescriptors),
        PinDescriptors,
        IntersectHandler);
}




NTSTATUS
FilterTopologyPropertyHandler(
    IN PIRP         Irp,
    IN PKSPROPERTY  Property,
    IN OUT PVOID    Data
    )
/*++

Routine Description:

    This is the general handler for all Topology property requests, and is used to route
    the request to the KsTopologyPropertyHandler using the Filter[Reader/Writer]Topology
    information. This request would have been routed through FilterDispatchIoControl,
    then KsPropertyHandler, which would have then called the handler for the property
    item, which is this function.

Arguments:

    Irp -
        Device control Irp.

    Property -
        Specific property request.

    Data -
        Property data.

Return Values:

    Returns STATUS_SUCCESS if the property was successfully manipulated, else an error.

--*/
{
    //
    // This switch can go away when the topologies are merged.
    //

//    D_INIT(DbgPrint("MODEMCSA: FilterTopologyPropertyHandler\n");)

        return KsTopologyPropertyHandler(Irp, Property, Data, &FilterRenderTopology);
}







#if 0

NTSTATUS
GetModemDeviceName(
    PDEVICE_OBJECT    Pdo,
    PUNICODE_STRING   ModemDeviceName
    )

{
    NTSTATUS    Status;
    ACCESS_MASK AccessMask = FILE_ALL_ACCESS;
    HANDLE      hKey;


    RtlInitUnicodeString(
        ModemDeviceName,
        NULL
        );


    //
    //  write out the device name, to the PDO's DeviceParameters key
    //  so the csa driver can open it
    //
    Status=IoOpenDeviceRegistryKey(
        Pdo,
        PLUGPLAY_REGKEY_DEVICE,
        AccessMask,
        &hKey
        );

    if (NT_SUCCESS(Status)) {

        RTL_QUERY_REGISTRY_TABLE ParamTable[2];

        RtlZeroMemory(
            ParamTable,
            sizeof(ParamTable)
            );

        //
        //  Get the hardware id
        //

        ParamTable[0].QueryRoutine = NULL;
        ParamTable[0].Flags = RTL_QUERY_REGISTRY_REQUIRED |
                              RTL_QUERY_REGISTRY_NOEXPAND |
                              RTL_QUERY_REGISTRY_DIRECT;

        ParamTable[0].Name = L"ModemDeviceName";
        ParamTable[0].EntryContext = (PVOID)ModemDeviceName;
        ParamTable[0].DefaultType = 0;

        Status=RtlQueryRegistryValues(
                   RTL_REGISTRY_HANDLE,
                   hKey,
                   ParamTable,
                   NULL,
                   NULL
                   );

        if (!NT_SUCCESS(Status)) {

            D_ERROR(DbgPrint("MODEMCSA: Could not query reg, %08lx\n",Status);)
        }


        ZwClose(hKey);

    } else {

        D_ERROR(DbgPrint("MODEMCSA: Could not open DeviceParameters key, %08lx\n",Status);)

    }

    return Status;

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\sys\modemcsa\duplex.c ===
/*++

Copyright (c) 1996 Microsoft Corporation.

Module Name:

    msfsio.c

Abstract:

    Pin property support.

--*/

#include "modemcsa.h"


#define HANDLE_TO_OBJECT(_x) ((PDUPLEX_CONTROL)((ULONG_PTR)_x & ~1))
#define HANDLE_TO_DIRECTION(_x) ((BOOLEAN)((ULONG_PTR)_x & 1))


NTSTATUS
PrimeOutput(
    PDUPLEX_CONTROL    DuplexControl
    );

#if 1


#endif


PVOID
InitializeDuplexControl(
    PDUPLEX_CONTROL    DuplexControl,
    PUNICODE_STRING    ModemDeviceName
    )
{

    if (!DuplexControl->Initialized) {

        DuplexControl->Initialized=TRUE;

        DuplexControl->OpenCount=0;
        DuplexControl->OpenFlags=0;
        DuplexControl->ModemFileObject=NULL;

        DuplexControl->AcquireCount=0;
        DuplexControl->StartCount=0;

        DuplexControl->Input.BytesPerSample=STREAM_BYTES_PER_SAMPLE;
        DuplexControl->Output.BytesPerSample=STREAM_BYTES_PER_SAMPLE;

        KeInitializeSpinLock(&DuplexControl->SpinLock);

        KeInitializeEvent(&DuplexControl->Input.ModemDriverEmpty,NotificationEvent,FALSE);

        KeInitializeSpinLock(&DuplexControl->Input.FilledModemIrpSpinLock);

        InitializeListHead(&DuplexControl->Input.FilledModemIrpQueue);

        DuplexControl->Input.CurrentFilledModemIrp=NULL;

        InitializeListHead(&DuplexControl->Input.ReadStreamIrpQueue);

        KeInitializeSpinLock(&DuplexControl->Input.ReadStreamSpinLock);

        DuplexControl->Input.CurrentReadStreamIrp=NULL;

        InitializeListHead(&DuplexControl->Output.WriteStreamIrpQueue);

        InitializeListHead(&DuplexControl->Output.FreeReadStreamIrps);

        InitializeBufferControl(&DuplexControl->Output.BufferControl);

        InitializeBufferControl(&DuplexControl->Input.BufferControl);


        ExInitializeFastMutex(&DuplexControl->ControlMutex);

        InitializeListHead(&DuplexControl->EventQueue);
        ExInitializeFastMutex(&DuplexControl->EventQueueLock);

        DuplexControl->ModemName=ModemDeviceName;

    }

    return NULL;
}

VOID
CleanUpDuplexControl(
    PDUPLEX_CONTROL    DuplexControl
    )

{


    return;
}


PVOID
OpenDuplexControl(
    PDEVICE_INSTANCE    DeviceInstance,
    DWORD               Flags,
    HANDLE              DownStreamFilterHandle,
    DWORD               BitsPerSample
    )

{
    NTSTATUS            Status;

    if (Flags & INPUT_PIN) {
        //
        //  input pin, get the file object for the down stream filter
        //
        if (DownStreamFilterHandle != NULL) {
            //
            //  this input pin is an irp sources, reference the downstrean handle
            //
            Status=ObReferenceObjectByHandle(
                DownStreamFilterHandle,
                FILE_WRITE_DATA,
                NULL,
                ExGetPreviousMode(),
                &DeviceInstance->DuplexControl.Input.DownStreamFileObject,
                NULL
                );

            if (!NT_SUCCESS(Status)) {

                return NULL;
            }
        } else {
            //
            //  this input pin is an irp sink, no downstream handle
            //
            DeviceInstance->DuplexControl.Input.DownStreamFileObject=NULL;
        }

        DeviceInstance->DuplexControl.Input.StreamPosition=0;
        DeviceInstance->DuplexControl.Input.BytesPerSample=BitsPerSample/8;

    } else {

        if (DownStreamFilterHandle != NULL) {
            //
            //  this input pin is an irp sources, reference the downstrean handle
            //
            Status=ObReferenceObjectByHandle(
                DownStreamFilterHandle,
                FILE_READ_DATA,
                NULL,
                ExGetPreviousMode(),
                &DeviceInstance->DuplexControl.Output.DownStreamFileObject,
                NULL
                );

            if (!NT_SUCCESS(Status)) {

                return NULL;
            }
        } else {
            //
            //  this input pin is an irp sink, no downstream handle
            //
            DeviceInstance->DuplexControl.Output.DownStreamFileObject=NULL;
        }

        DeviceInstance->DuplexControl.Output.BytesPerSample=BitsPerSample/8;
    }

    return (PVOID)((ULONG_PTR)(&DeviceInstance->DuplexControl) | ((Flags & INPUT_PIN) ? 1 : 0));



}


VOID
CloseDuplexControl(
    PVOID               DuplexHandle
    )

{

    PDUPLEX_CONTROL    DuplexControl=HANDLE_TO_OBJECT(DuplexHandle);
    BOOLEAN            Input=HANDLE_TO_DIRECTION(DuplexHandle);
    PFILE_OBJECT       FileObjectToDereference=NULL;

    ExAcquireFastMutexUnsafe(&DuplexControl->ControlMutex);

    if (DuplexControl->AcquireFlags & (Input ? INPUT_PIN : OUTPUT_PIN)) {

        D_ERROR(DbgPrint("MODEMCSA: CloseDuplexDevice: still acquired\n");)

        ExReleaseFastMutexUnsafe(&DuplexControl->ControlMutex);

        ReleaseDevice(DuplexHandle);

        ExAcquireFastMutexUnsafe(&DuplexControl->ControlMutex);
    }

    if (Input) {

        FileObjectToDereference=DuplexControl->Input.DownStreamFileObject;

        DuplexControl->Input.DownStreamFileObject=NULL;

    } else {

        FileObjectToDereference=DuplexControl->Output.DownStreamFileObject;

        DuplexControl->Output.DownStreamFileObject=NULL;
    }


    ExReleaseFastMutexUnsafe(&DuplexControl->ControlMutex);

    if (FileObjectToDereference != NULL) {

        ObDereferenceObject(FileObjectToDereference);
    }

    return;

}

NTSTATUS
AcquireDevice(
    PVOID        DuplexHandle
    )

{

    PDUPLEX_CONTROL    DuplexControl=HANDLE_TO_OBJECT(DuplexHandle);
    BOOLEAN            Input=HANDLE_TO_DIRECTION(DuplexHandle);

    NTSTATUS            Status=STATUS_SUCCESS;
    PFILE_OBJECT        ModemFileObject=NULL;
    PDEVICE_OBJECT      DeviceObject;

    ExAcquireFastMutexUnsafe(&DuplexControl->ControlMutex);

    if (DuplexControl->AcquireFlags & (Input ? INPUT_PIN : OUTPUT_PIN)) {

        ExReleaseFastMutexUnsafe(&DuplexControl->ControlMutex);

        D_ERROR(DbgPrint("MODEMCSA: AcquireDevice: alreay acquired, %s\n",Input ? "Input" : "OutPut");)

        return Status;
    }



    if (DuplexControl->AcquireCount == 0) {
        //
        //  first open,
        //
        PIRP    ModemIrp;

        ULONG   i;

        Status=IoGetDeviceObjectPointer(
            DuplexControl->ModemName,
            FILE_READ_DATA | FILE_WRITE_DATA,
            &ModemFileObject,
            &DeviceObject
            );

        if (Status == STATUS_SUCCESS) {

            DuplexControl->ModemFileObject=ModemFileObject;

            for (i=0; i< 5; i++) {

                ModemIrp=AllocateIrpForModem(
                    DuplexControl->ModemFileObject,
                    STREAM_BUFFER_SIZE
                    );

                if (ModemIrp != NULL) {
#if DBG
                    InterlockedIncrement(&DuplexControl->Input.EmptyIrps);
#endif
                    AddBuffer(
                        &DuplexControl->Input.BufferControl,
                        ModemIrp
                        );

                }
            }

            DuplexControl->AcquireCount=1;

        } else {

            D_ERROR(DbgPrint("MODEMCSA: failed to open device %08lx\n",Status);)
        }

    } else {

        if (DuplexControl->AcquireCount == 1) {
            //
            //  second open
            //
            DuplexControl->AcquireCount++;

        } else {
            //
            //  too many opens
            //
            Status=STATUS_SHARING_VIOLATION;

            D_ERROR(DbgPrint("MODEMCSA: AcquireDevice failed, too many %d/n",DuplexControl->AcquireCount);)
        }
    }


    if (NT_SUCCESS(Status)) {

        if (!Input && (DuplexControl->Output.DownStreamFileObject != NULL)) {

            ULONG    i;

            for (i=0; i<5 ;i++) {

                PIRP    StreamIrp;

                StreamIrp=AllocateOutputIrpPair(
                    DuplexControl->ModemFileObject,
                    DuplexControl->Output.DownStreamFileObject,
                    STREAM_BUFFER_SIZE
                    );

                if (StreamIrp != NULL) {

                    AddBuffer(&DuplexControl->Output.BufferControl,
                        StreamIrp
                        );

                }
            }

        }

        DuplexControl->AcquireFlags |= (Input ? INPUT_PIN : OUTPUT_PIN);
    }

    ExReleaseFastMutexUnsafe(&DuplexControl->ControlMutex);

    return Status;



}


VOID
CleanupInput(
    PDUPLEX_CONTROL   DuplexControl
    )
{
    //
    //  input, stream clean this up
    //
    PIRP    ModemIrp;
    PIRP    ReadStreamIrp;
    KIRQL   OldIrql;

    D_INIT(DbgPrint("MODEMCSA: cleanupinput: filled %d, current %d, pCurrent %p\n",DuplexControl->Input.FilledModemIrps,DuplexControl->Input.CurrentFilledIrps,DuplexControl->Input.CurrentFilledModemIrp);)

    KsCancelIo(
        &DuplexControl->Input.ReadStreamIrpQueue,
        &DuplexControl->Input.ReadStreamSpinLock
        );


    while ((ModemIrp=RemoveIrpFromListHead(
            &DuplexControl->Input.FilledModemIrpQueue,
            &DuplexControl->Input.FilledModemIrpSpinLock
            )) != NULL) {

#ifdef DBG
        InterlockedDecrement(&DuplexControl->Input.FilledModemIrps);
#endif

        FinishUpIrp(
            DuplexControl,
            ModemIrp
            );
    }

    KeAcquireSpinLock(
        &DuplexControl->SpinLock,
        &OldIrql
        );

    ModemIrp = InterlockedExchangePointer(&DuplexControl->Input.CurrentFilledModemIrp,NULL);

    ReadStreamIrp = InterlockedExchangePointer(&DuplexControl->Input.CurrentReadStreamIrp,NULL);


    KeReleaseSpinLock(
        &DuplexControl->SpinLock,
        OldIrql
        );

    if (ModemIrp != NULL) {
#if DBG
        InterlockedDecrement(&DuplexControl->Input.CurrentFilledIrps);
#endif

        FinishUpIrp(
            DuplexControl,
            ModemIrp
            );
    }

    if (ReadStreamIrp != NULL) {

        ReadStreamIrp->IoStatus.Status=STATUS_CANCELLED;

        ReadStreamIrp->IoStatus.Status=0;

        IoCompleteRequest(
            ReadStreamIrp,
            IO_SERIAL_INCREMENT
            );
    }

    D_INIT(DbgPrint("MODEMCSA: cleanupinput exit: filled %d, current %d, pCurrent %p\n",DuplexControl->Input.FilledModemIrps,DuplexControl->Input.CurrentFilledIrps,DuplexControl->Input.CurrentFilledModemIrp);)
    return;
}


VOID
ReleaseDevice(
    PVOID      DuplexHandle
    )

{

    PDUPLEX_CONTROL    DuplexControl=HANDLE_TO_OBJECT(DuplexHandle);
    BOOLEAN            Input=HANDLE_TO_DIRECTION(DuplexHandle);

    NTSTATUS            Status;

    ExAcquireFastMutexUnsafe(&DuplexControl->ControlMutex);

    if (!Input) {
        //
        //  Output stream, cancel all queued write stream irps
        //
        KsCancelIo(
            &DuplexControl->Output.WriteStreamIrpQueue,
            &DuplexControl->SpinLock
            );

    } else {
        //
        //  input, stream clean this up
        //

        CleanupInput(DuplexControl);
    }


    if ((DuplexControl->StartCount > 0) && (DuplexControl->StartFlags & (Input ? INPUT_PIN : OUTPUT_PIN))) {

        D_ERROR(DbgPrint("MODEMCSA: ReleaseDevice on non-stopped stream\n");)

        ExReleaseFastMutexUnsafe(&DuplexControl->ControlMutex);

        StopStream(DuplexHandle);

        ExAcquireFastMutexUnsafe(&DuplexControl->ControlMutex);
    }

    //
    //  clear the flags
    //
    if (DuplexControl->AcquireFlags & (Input ? INPUT_PIN : OUTPUT_PIN)) {
        //
        //  this pin is acquired
        //
        DuplexControl->AcquireFlags &= ~(Input ? INPUT_PIN : OUTPUT_PIN);

        if (!Input) {
            //
            //  free output buffers
            //
            PIRP    StreamIrp;

            StreamIrp=EmptyBuffers(
                &DuplexControl->Output.BufferControl
                );

            while (StreamIrp != NULL) {

                FreeOutputPair(StreamIrp);

                StreamIrp=EmptyBuffers(
                    &DuplexControl->Output.BufferControl
                    );

            }
        }


        DuplexControl->AcquireCount--;

        if (DuplexControl->AcquireCount == 0) {

            PIRP    ModemIrp;

            PauseBufferQueue(
                &DuplexControl->Input.BufferControl,
                TRUE
                );


            ObDereferenceObject(DuplexControl->ModemFileObject);

            DuplexControl->ModemFileObject=NULL;

            ModemIrp=EmptyBuffers(
                &DuplexControl->Input.BufferControl
                );

            while (ModemIrp != NULL) {

#if DBG
                InterlockedDecrement(&DuplexControl->Input.EmptyIrps);
#endif

                FreeInputIrps(ModemIrp);

                ModemIrp=EmptyBuffers(
                    &DuplexControl->Input.BufferControl
                    );


            }

        }
    } else {

        D_ERROR(DbgPrint("MODEMCSA: Release called when not acquired %s\n",Input ? "Input" : "OutPut");)
    }

    ExReleaseFastMutexUnsafe(&DuplexControl->ControlMutex);

    return ;

}

NTSTATUS
StartStream(
    PVOID        DuplexHandle
    )

{
    PDUPLEX_CONTROL    DuplexControl=HANDLE_TO_OBJECT(DuplexHandle);
    BOOLEAN            Input=HANDLE_TO_DIRECTION(DuplexHandle);

    NTSTATUS            Status=STATUS_SUCCESS;

    ExAcquireFastMutexUnsafe(&DuplexControl->ControlMutex);

    if (DuplexControl->StartCount == 0) {
        //
        //  not running yet, start stream
        //
        Status=WaveAction(
            DuplexControl->ModemFileObject,
            WAVE_ACTION_START_DUPLEX
            );

        if (NT_SUCCESS(Status)) {
            //
            //  it worked,
            //
            DuplexControl->StartCount=1;
            DuplexControl->StartFlags= Input ? INPUT_PIN : OUTPUT_PIN;

            DuplexControl->Input.ModemStreamDead=FALSE;

            DuplexControl->Input.BytesToThrowAway=1024;

            ActivateBufferQueue(
                &DuplexControl->Input.BufferControl
                );

            KeResetEvent(
                &DuplexControl->Input.ModemDriverEmpty
                );


            PrimeOutput(DuplexControl);



        } else {

            D_ERROR(DbgPrint("MODEMCSA: StartStream: WaveAction Failed\n");)
        }

    } else {
        //
        //  second, open
        //
        DuplexControl->StartCount++;
        DuplexControl->StartFlags |= Input ? INPUT_PIN : OUTPUT_PIN;
    }

    if (!Input) {

        ActivateBufferQueue(&DuplexControl->Output.BufferControl);
    }


    ExReleaseFastMutexUnsafe(&DuplexControl->ControlMutex);

    if (NT_SUCCESS(Status)) {

        StartRead(DuplexControl);

        ProcessWriteIrps(DuplexControl);
    }

    return Status;

}

UCHAR PrimeData[1024]={0x80};

NTSTATUS
PrimeCompletion(
    PDEVICE_OBJECT    DeviceObject,
    PIRP              Irp,
    PVOID             Context
    )

{
    PDUPLEX_CONTROL     DuplexControl=(PDUPLEX_CONTROL)Context;

    if (Irp->Flags & IRP_DEALLOCATE_BUFFER) {

        ExFreePool( Irp->AssociatedIrp.SystemBuffer );
    }

    IoFreeIrp(Irp);

//    D_INIT(DbgPrint("MODEMCSA: WriteCompletion\n");)

    return STATUS_MORE_PROCESSING_REQUIRED;

}



NTSTATUS
PrimeOutput(
    PDUPLEX_CONTROL    DuplexControl
    )

{

    PIRP                ModemIrp;
    LARGE_INTEGER  Offset={0,0};


    ModemIrp=IoBuildAsynchronousFsdRequest(
        IRP_MJ_WRITE,
        IoGetRelatedDeviceObject(DuplexControl->ModemFileObject),
        PrimeData,
        sizeof(PrimeData),
        &Offset,
        NULL
        );

    if (ModemIrp != NULL) {

        PIO_STACK_LOCATION      NextSp;

        RtlFillMemory(
            ModemIrp->AssociatedIrp.SystemBuffer,
            sizeof(PrimeData),
            0x80
            );

        IoSetCompletionRoutine(
            ModemIrp,
            PrimeCompletion,
            DuplexControl,
            TRUE,
            TRUE,
            TRUE
            );

        NextSp = IoGetNextIrpStackLocation(ModemIrp);
        NextSp->FileObject = DuplexControl->ModemFileObject;

        IoCallDriver(
            IoGetRelatedDeviceObject(DuplexControl->ModemFileObject),
            ModemIrp
            );

    } else {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    return STATUS_SUCCESS;
}


VOID
StopStream(
    PVOID        DuplexHandle
    )

{
    PDUPLEX_CONTROL    DuplexControl=HANDLE_TO_OBJECT(DuplexHandle);
    BOOLEAN            Input=HANDLE_TO_DIRECTION(DuplexHandle);

    NTSTATUS            Status;


    ExAcquireFastMutexUnsafe(&DuplexControl->ControlMutex);

    D_INIT(DbgPrint("MODEMCSA: StopStream: Count %d, %s\n",DuplexControl->StartCount,Input ? "Input" : "OutPut");)



    //
    //  the selected stream has been started
    //
    if (!Input) {
        //
        //  Output stream, cancel all queued write stream irps
        //
        KsCancelIo(
            &DuplexControl->Output.WriteStreamIrpQueue,
            &DuplexControl->SpinLock
            );

        //
        //  deactivate stream and wait for all buffers to return;
        //
        PauseBufferQueue(&DuplexControl->Output.BufferControl,TRUE);


    } else {

        CleanupInput(DuplexControl);

    }

    if (DuplexControl->StartFlags & (Input ? INPUT_PIN : OUTPUT_PIN)) {

        //
        //  Not running any more
        //
        DuplexControl->StartFlags &= ~(Input ? INPUT_PIN : OUTPUT_PIN);

        if (DuplexControl->StartCount > 0) {
            //
            //  currently running
            //
            DuplexControl->StartCount--;

            if (DuplexControl->StartCount == 0) {

                PauseBufferQueue(
                    &DuplexControl->Input.BufferControl,
                    FALSE
                    );

                CleanupInput(DuplexControl);

                if (DuplexControl->Input.IrpsInModemDriver != 0) {

                    D_INIT(DbgPrint("MODEMCSA: StopStream: wait for event %d downstream %d\n",DuplexControl->Input.BufferControl.IrpsInUse,DuplexControl->Input.IrpsDownStream);)

                    KeWaitForSingleObject(
                        &DuplexControl->Input.ModemDriverEmpty,
                        Executive,
                        KernelMode,
                        FALSE,
                        NULL
                        );

                }

                Status=WaveAction(
                    DuplexControl->ModemFileObject,
                    WAVE_ACTION_STOP_STREAMING
                    );

            }


        }
    } else {

        D_INIT(DbgPrint("MODEMCSA: StopStream: Stream not started, %s\n",Input ? "Input" : "OutPut");)
    }

    ExReleaseFastMutexUnsafe(&DuplexControl->ControlMutex);

    return ;

}



VOID
QueueOutputIrp(
    PVOID        DuplexHandle,
    PIRP         Irp
    )

{
    PDUPLEX_CONTROL    DuplexControl=HANDLE_TO_OBJECT(DuplexHandle);
    BOOLEAN            Input=HANDLE_TO_DIRECTION(DuplexHandle);

    if (Input) {
        //
        //  read stream irp
        //
        KsAddIrpToCancelableQueue(
            &DuplexControl->Input.ReadStreamIrpQueue,
            &DuplexControl->Input.ReadStreamSpinLock,
            Irp,
            KsListEntryTail,
            NULL
            );


    } else {
        //
        //  write stream irp
        //
        KsAddIrpToCancelableQueue(
            &DuplexControl->Output.WriteStreamIrpQueue,
            &DuplexControl->SpinLock,
            Irp,
            KsListEntryTail,
            NULL
            );
    }

    return;

}

VOID
KickWriteProcessing(
    PVOID        DuplexHandle
    )

{
    PDUPLEX_CONTROL    DuplexControl=HANDLE_TO_OBJECT(DuplexHandle);
    BOOLEAN            Input=HANDLE_TO_DIRECTION(DuplexHandle);

    if (Input) {

        if (DuplexControl->Input.DownStreamFileObject == NULL) {
            //
            //  we are sinking read stream irps, try to get things going
            //
            ProcessReadStreamIrp(DuplexControl);
        }

    } else {

        ProcessWriteIrps(DuplexControl);
    }

    return;
}




NTSTATUS
EnableEvent(
    PVOID        DuplexHandle,
    PIRP         Irp,
    const KSEVENT_SET* EventSets,
    ULONG        EventCount
    )

{
    PDUPLEX_CONTROL    DuplexControl=HANDLE_TO_OBJECT(DuplexHandle);
    BOOLEAN            Input=HANDLE_TO_DIRECTION(DuplexHandle);
    NTSTATUS           Status=STATUS_PROPSET_NOT_FOUND;

    if (!Input) {

        Status = KsEnableEvent(
            Irp,
            EventCount,
            EventSets,
            &DuplexControl->EventQueue,
            KSEVENTS_FMUTEXUNSAFE,
            &DuplexControl->EventQueueLock
            );
    }

    return Status;

}


NTSTATUS
DisableEvent(
    PVOID        DuplexHandle,
    PIRP         Irp
    )

{
    PDUPLEX_CONTROL    DuplexControl=HANDLE_TO_OBJECT(DuplexHandle);
    BOOLEAN            Input=HANDLE_TO_DIRECTION(DuplexHandle);
    NTSTATUS           Status=STATUS_PROPSET_NOT_FOUND;

    if (!Input) {

        Status = KsDisableEvent(
            Irp,
            &DuplexControl->EventQueue,
            KSEVENTS_FMUTEXUNSAFE,
            &DuplexControl->EventQueueLock
            );
    }

    return Status;

}

VOID
GenerateEvent(
    PVOID        DuplexHandle
    )

{
    PDUPLEX_CONTROL    DuplexControl=HANDLE_TO_OBJECT(DuplexHandle);
    BOOLEAN            Input=HANDLE_TO_DIRECTION(DuplexHandle);

    KsGenerateEventList(
        NULL,
        KSEVENT_CONNECTION_ENDOFSTREAM,
        &DuplexControl->EventQueue,
        KSEVENTS_FMUTEXUNSAFE,
        &DuplexControl->EventQueueLock
        );

    return;

}



VOID
FreeEventList(
    PVOID        DuplexHandle,
    PIRP         Irp
    )

{
    PDUPLEX_CONTROL    DuplexControl=HANDLE_TO_OBJECT(DuplexHandle);
    BOOLEAN            Input=HANDLE_TO_DIRECTION(DuplexHandle);

    if (!Input) {

        KsFreeEventList(
            IoGetCurrentIrpStackLocation(Irp)->FileObject,
            &DuplexControl->EventQueue,
            KSEVENTS_FMUTEXUNSAFE,
            &DuplexControl->EventQueueLock
            );
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\sys\modemcsa\input.c ===
/*++

Copyright (c) 1996 Microsoft Corporation.

Module Name:

    msfsio.c

Abstract:

    Pin property support.

--*/

#include "modemcsa.h"

//#define CREATE_ALLOCATOR


VOID
StartRead(
    PDUPLEX_CONTROL     DuplexControl
    );




VOID
AdjustIrpStack(
    PIRP    Irp
    )

{
    PIO_STACK_LOCATION   irpSp;

    //
    //  move the current stack location to the first stack location,
    //  so we can use it driver specific stuff.
    //
    Irp->CurrentLocation--;

    irpSp = IoGetNextIrpStackLocation( Irp );
    Irp->Tail.Overlay.CurrentStackLocation = irpSp;

    return;
}


PIRP
AllocateIrpForModem(
    PFILE_OBJECT   FileObject,
    ULONG          Length
    )

{

    PIRP           Irp;
    PIO_STACK_LOCATION   irpSp;

    Irp=IoAllocateIrp((CCHAR)(IoGetRelatedDeviceObject(FileObject)->StackSize+1), FALSE );

    if (Irp == NULL) {

        return NULL;
    }

    AdjustIrpStack(Irp);

    irpSp = IoGetNextIrpStackLocation( Irp );

    Irp->AssociatedIrp.SystemBuffer = ExAllocatePoolWithTag( NonPagedPoolCacheAligned,
                                                             Length,
                                                             'SCDM' );
    if (Irp->AssociatedIrp.SystemBuffer == NULL) {
        IoFreeIrp( Irp );
        return (PIRP) NULL;
    }

    IoGetCurrentIrpStackLocation(Irp)->Parameters.Others.Argument3=IntToPtr(Length);

    IoGetCurrentIrpStackLocation(Irp)->FileObject = FileObject;

    return Irp;

}

VOID
FreeInputIrps(
    PIRP    ModemIrp
    )

{
    PIO_STACK_LOCATION      IrpSp;
    PIRP                    FilterIrp;

    IrpSp = IoGetCurrentIrpStackLocation(ModemIrp);

    FilterIrp=IrpSp->Parameters.Others.Argument2;


//    ExFreePool(FilterIrp->AssociatedIrp.SystemBuffer);

    ExFreePool(ModemIrp->AssociatedIrp.SystemBuffer);

//    IoFreeMdl(FilterIrp->MdlAddress);

//    IoFreeIrp(FilterIrp);

    IoFreeIrp(ModemIrp);

    return;

}


PIRP
AllocateStreamIrp(
    PFILE_OBJECT    FileObject,
    PIRP            ModemIrp
    )

{
    PIRP           FilterIrp;
    PKSSTREAM_HEADER     StreamHeader;
    PMDL                 Mdl;


    FilterIrp=IoAllocateIrp( (CCHAR)(IoGetRelatedDeviceObject(FileObject)->StackSize+1), FALSE );

    if (FilterIrp == NULL) {

        return NULL;
    }

    AdjustIrpStack(FilterIrp);

    Mdl=IoAllocateMdl(
        ModemIrp->AssociatedIrp.SystemBuffer,
        (ULONG)((ULONG_PTR)IoGetCurrentIrpStackLocation(ModemIrp)->Parameters.Others.Argument3),
        FALSE,
        FALSE,
        FilterIrp
        );

    if (Mdl == NULL) {

        IoFreeIrp( FilterIrp );
        return NULL;
    }

    MmBuildMdlForNonPagedPool(
        Mdl
        );

    StreamHeader=ExAllocatePoolWithTag(
        NonPagedPoolCacheAligned,
        sizeof(KSSTREAM_HEADER),
        'SCDM'
        );

    if (StreamHeader == NULL) {

        IoFreeMdl(Mdl);
        IoFreeIrp( FilterIrp );
        return NULL;
    }

    FilterIrp->AssociatedIrp.SystemBuffer=StreamHeader;

    //
    //  link the two irps together, using the current stack locations
    //
    IoGetCurrentIrpStackLocation(ModemIrp)->Parameters.Others.Argument2=FilterIrp;

    IoGetCurrentIrpStackLocation(FilterIrp)->Parameters.Others.Argument2=ModemIrp;


    return FilterIrp;

}


VOID
FinishUpIrp(
    PDUPLEX_CONTROL    DuplexControl,
    PIRP               ModemIrp
    )

{

#if DBG
    InterlockedIncrement(&DuplexControl->Input.EmptyIrps);
#endif

    ReturnAnIrp(
        &DuplexControl->Input.BufferControl,
        ModemIrp
        );

    StartRead(DuplexControl);

    return;
}


NTSTATUS
FilterWriteCompletion(
    PDEVICE_OBJECT    DeviceObject,
    PIRP              FilterIrp,
    PVOID             Context
    )

{
    PDUPLEX_CONTROL     DuplexControl=(PDUPLEX_CONTROL)Context;
    PIO_STACK_LOCATION      IrpSp;
    PIRP                    ModemIrp;
    ULONG                   NewCount;

    D_INPUT(DbgPrint("MODEMCSA: FilterWriteCompletion\n");)

#ifdef DBG
    InterlockedDecrement(&DuplexControl->Input.IrpsDownStream);
#endif
    IrpSp = IoGetCurrentIrpStackLocation(FilterIrp);

    ModemIrp=IrpSp->Parameters.Others.Argument2;

    //
    //  free up the filter irp
    //
    ExFreePool(FilterIrp->AssociatedIrp.SystemBuffer);

    IoFreeMdl(FilterIrp->MdlAddress);

    IoFreeIrp(FilterIrp);


    FinishUpIrp(
        DuplexControl,
        ModemIrp
        );

    return STATUS_MORE_PROCESSING_REQUIRED;
}



VOID
ProcessReadStreamIrp(
    PDUPLEX_CONTROL    DuplexControl
    )

{
    KIRQL   OldIrql;

    KeAcquireSpinLock(
        &DuplexControl->SpinLock,
        &OldIrql
        );

    while (1) {

        if (DuplexControl->Input.CurrentReadStreamIrp == NULL)  {
            //
            //  we don't have a current readstream irp, try to get one
            //
            DuplexControl->Input.CurrentReadStreamIrp=KsRemoveIrpFromCancelableQueue(
                &DuplexControl->Input.ReadStreamIrpQueue,
                &DuplexControl->Input.ReadStreamSpinLock,
                KsListEntryHead,
                KsAcquireAndRemove
                );
        }

        if (DuplexControl->Input.CurrentFilledModemIrp == NULL)  {
            //
            //  we don't have a current readstream irp, try to get one
            //
            DuplexControl->Input.BytesUsedInModemIrp=0;

            DuplexControl->Input.CurrentFilledModemIrp=RemoveIrpFromListHead(
                &DuplexControl->Input.FilledModemIrpQueue,
                &DuplexControl->Input.FilledModemIrpSpinLock
                );
#ifdef DBG
            if (DuplexControl->Input.CurrentFilledModemIrp != NULL)  {
                InterlockedDecrement(&DuplexControl->Input.FilledModemIrps);
                InterlockedIncrement(&DuplexControl->Input.CurrentFilledIrps);
            }
#endif

        }

        if ((DuplexControl->Input.CurrentReadStreamIrp != NULL)
            &&
            (DuplexControl->Input.CurrentFilledModemIrp != NULL)) {
            //
            //  we have two irps to work on
            //
            PIO_STACK_LOCATION      IrpStack;
            ULONG                   BufferLength;
            PKSSTREAM_HEADER        StreamHdr;
            PMDL                    Mdl;
            PIRP                    ReturnThisModemIrp=NULL;
            PIRP                    CompleteThisReadStreamIrp=NULL;
            PIRP                    Irp;
            PIRP                    ModemIrp;
            PBYTE                   Buffer;

            Irp=DuplexControl->Input.CurrentReadStreamIrp;

            ModemIrp=DuplexControl->Input.CurrentFilledModemIrp;

            if (!NT_SUCCESS(ModemIrp->IoStatus.Status)) {

                ModemIrp->IoStatus.Information=0;
            }


            IrpStack = IoGetCurrentIrpStackLocation(Irp);

            BufferLength = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;
            StreamHdr = (PKSSTREAM_HEADER)Irp->AssociatedIrp.SystemBuffer;
            //
            // This is only used if an Mdl list was already present.
            //
            Mdl = Irp->MdlAddress;
            Buffer = MmGetSystemAddressForMdl(Mdl);

            //
            // Enumerate the stream headers, filling in each one.
            //
            while (1) {

                ULONG    SamplesLeftInReadStream=(StreamHdr->FrameExtent - StreamHdr->DataUsed)/DuplexControl->Input.BytesPerSample;

                if (SamplesLeftInReadStream > 0) {
                    //
                    //  there is some room in the header to put the data
                    //
                    ULONG    SamplesToMove;
                    ULONG    SamplesFromModem=(ULONG)(ModemIrp->IoStatus.Information-DuplexControl->Input.BytesUsedInModemIrp);

                    SamplesToMove=SamplesFromModem < SamplesLeftInReadStream ?
                                      SamplesFromModem : SamplesLeftInReadStream;

                    if (DuplexControl->Input.BytesPerSample == 1) {
                        //
                        //  both are 8 bit samples
                        //
                        RtlCopyMemory(
                            Buffer+StreamHdr->DataUsed,
                            (PBYTE)ModemIrp->AssociatedIrp.SystemBuffer+DuplexControl->Input.BytesUsedInModemIrp,
                            SamplesToMove
                            );

                    } else {
                        //
                        //
                        //
                        PUCHAR   ModemSample=(PBYTE)ModemIrp->AssociatedIrp.SystemBuffer+DuplexControl->Input.BytesUsedInModemIrp;
                        PUCHAR   EndPoint=ModemSample+SamplesToMove;

                        PSHORT   ReadStreamSample=(PSHORT)(Buffer+StreamHdr->DataUsed);

                        while (ModemSample < EndPoint) {

                            *ReadStreamSample++=(((SHORT)*ModemSample++)-0x80)<<8;
                        }

                    }

                    StreamHdr->DataUsed+=SamplesToMove*DuplexControl->Input.BytesPerSample;
                    DuplexControl->Input.BytesUsedInModemIrp+=SamplesToMove;
                }

                if (ModemIrp->IoStatus.Information == DuplexControl->Input.BytesUsedInModemIrp) {
                    //
                    //  used all of the data in the current filled modem irp
                    //
                    ReturnThisModemIrp=DuplexControl->Input.CurrentFilledModemIrp;
                    DuplexControl->Input.CurrentFilledModemIrp=NULL;
#if DBG
                    InterlockedDecrement(&DuplexControl->Input.CurrentFilledIrps);
                    ModemIrp=NULL;
#endif
                    break;
                }

                SamplesLeftInReadStream=(StreamHdr->FrameExtent - StreamHdr->DataUsed)/DuplexControl->Input.BytesPerSample;

                if (SamplesLeftInReadStream == 0) {
                    //
                    //  this stream header is filled up
                    //


                    StreamHdr->PresentationTime.Numerator = BITS_PER_BYTE * NANOSECONDS;
                    StreamHdr->PresentationTime.Denominator = 8 * 1 * 8000;
                    StreamHdr->PresentationTime.Time=DuplexControl->Input.StreamPosition;

                    DuplexControl->Input.StreamPosition+=(LONGLONG)StreamHdr->DataUsed;

                    BufferLength -= sizeof(KSSTREAM_HEADER);

                    if (BufferLength != 0) {
                        //
                        //  next stream header
                        //
                        StreamHdr++;

                    } else {
                        //
                        //  all done with this read stream irp
                        //
                        CompleteThisReadStreamIrp=DuplexControl->Input.CurrentReadStreamIrp;
                        DuplexControl->Input.CurrentReadStreamIrp=NULL;
#if DBG
                        Irp=NULL;
#endif

                        CompleteThisReadStreamIrp->IoStatus.Information=IrpStack->Parameters.DeviceIoControl.OutputBufferLength;

                        break;
                    }
                }
            }

            KeReleaseSpinLock(
                &DuplexControl->SpinLock,
                OldIrql
                );

            if (ReturnThisModemIrp != NULL) {
                //
                //  done, with this modem irp
                //
                FinishUpIrp(
                    DuplexControl,
                    ReturnThisModemIrp
                    );

                ReturnThisModemIrp=NULL;
            }

            if (CompleteThisReadStreamIrp != NULL) {

                CompleteThisReadStreamIrp->IoStatus.Status=STATUS_SUCCESS;

                IoCompleteRequest(
                    CompleteThisReadStreamIrp,
                    IO_SERIAL_INCREMENT
                    );

                CompleteThisReadStreamIrp=NULL;
            }

            KeAcquireSpinLock(
                &DuplexControl->SpinLock,
                &OldIrql
                );


        } else {
            //
            //  don't have both a filled modem irp and a readstream irp,
            //  exit
            //
            break;
        }
    }


    KeReleaseSpinLock(
        &DuplexControl->SpinLock,
        OldIrql
        );

    StartRead(DuplexControl);

    return;
}



VOID
ReadCompleteWorker(
    PVOID    Context
    )

{
    PIRP                    ModemIrp=(PIRP)Context;
    PIRP                    FilterIrp;
    PKSSTREAM_HEADER        StreamHeader;
    PIO_STACK_LOCATION      IrpSp;
    PIO_STACK_LOCATION      FilterNextSp;
    ULONG                   BufferLength;
    PDUPLEX_CONTROL         DuplexControl;
    ULONG                   NewCount;

    IrpSp = IoGetCurrentIrpStackLocation(ModemIrp);

    DuplexControl=(PDUPLEX_CONTROL)IrpSp->Parameters.Others.Argument1;

#if DBG
    InterlockedDecrement(&DuplexControl->Input.WorkItemsOutstanding);
#endif

    NewCount=InterlockedDecrement(&DuplexControl->Input.IrpsInModemDriver);

    D_INIT(if (DuplexControl->StartCount == 0) DbgPrint("MODEMCSA: ReadCompleWorker: Stopped %d\n",NewCount);)

    if ((NewCount == 0) && (DuplexControl->StartCount == 0)) {

        D_INIT(DbgPrint("MODEMCSA: ReadCompleteWorker: SetEvent\n");)

        KeSetEvent(
           &DuplexControl->Input.ModemDriverEmpty,
           IO_NO_INCREMENT,
           FALSE
           );
    }

    if (DuplexControl->Input.BytesToThrowAway > 0) {

        DuplexControl->Input.BytesToThrowAway-=(ULONG)ModemIrp->IoStatus.Information;
    }


    if (!NT_SUCCESS(ModemIrp->IoStatus.Status)) {

        D_INIT(DbgPrint("MODEMCSA: ReadIrp Failed  %08lx\n",ModemIrp->IoStatus.Status);)
        DuplexControl->Input.ModemStreamDead = TRUE;
    }

    if ((DuplexControl->StartFlags & INPUT_PIN)  && (DuplexControl->Input.BytesToThrowAway <= 0)) {
        //
        //  input stream started
        //

        if (DuplexControl->Input.DownStreamFileObject != NULL) {
            //
            //  we are a source of write stream irps
            //

            FilterIrp=AllocateStreamIrp(
                DuplexControl->Input.DownStreamFileObject,
                ModemIrp
                );

            if (FilterIrp != NULL) {

                FilterNextSp=IoGetNextIrpStackLocation( FilterIrp );

                //
                //  the streamheader is already allocated and in the system buffer
                //
                StreamHeader=FilterIrp->AssociatedIrp.SystemBuffer;

                StreamHeader->Size=sizeof(KSSTREAM_HEADER);
                StreamHeader->OptionsFlags=0;
                StreamHeader->TypeSpecificFlags=0;
                StreamHeader->DataUsed=(ULONG)ModemIrp->IoStatus.Information;

                //
                //  the data is in the system buffer of the modem irp
                //
                StreamHeader->Data=ModemIrp->AssociatedIrp.SystemBuffer;

                //
                //  set the total buffer size
                //
                StreamHeader->FrameExtent=(ULONG)((ULONG_PTR)IoGetCurrentIrpStackLocation(ModemIrp)->Parameters.Others.Argument3);




                StreamHeader->PresentationTime.Numerator = BITS_PER_BYTE * NANOSECONDS;
                StreamHeader->PresentationTime.Denominator = 8 * 1 * 8000;
                StreamHeader->PresentationTime.Time=DuplexControl->Input.StreamPosition;

                DuplexControl->Input.StreamPosition+=(LONGLONG)StreamHeader->DataUsed;

                FilterNextSp->FileObject=DuplexControl->Input.DownStreamFileObject;

                FilterNextSp->Parameters.DeviceIoControl.OutputBufferLength=StreamHeader->Size;

                FilterNextSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;
                FilterNextSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_KS_WRITE_STREAM;


                IoSetCompletionRoutine(
                    FilterIrp,
                    FilterWriteCompletion,
                    DuplexControl,
                    TRUE,
                    TRUE,
                    TRUE
                    );
#ifdef DBG
                InterlockedIncrement(&DuplexControl->Input.IrpsDownStream);
#endif

                IoCallDriver(
                    IoGetRelatedDeviceObject(DuplexControl->Input.DownStreamFileObject),
                    FilterIrp
                    );
#if DBG
                ModemIrp=NULL;
                FilterIrp=NULL;
#endif
            } else {
                //
                //  could not get irp
                //
                FinishUpIrp(
                    DuplexControl,
                    ModemIrp
                    );

                ModemIrp=NULL;

            }

        } else {
            //
            //  we are a sink for read stream irps
            //
#ifdef DBG
            InterlockedIncrement(&DuplexControl->Input.FilledModemIrps);
#endif

            QueueIrpToListTail(
                &DuplexControl->Input.FilledModemIrpQueue,
                &DuplexControl->Input.FilledModemIrpSpinLock,
                ModemIrp
                );

            ModemIrp=NULL;

            ProcessReadStreamIrp(
                DuplexControl
                );

        }


    } else {
        //
        //  input not started, throw data away
        //
        FinishUpIrp(
            DuplexControl,
            ModemIrp
            );

        ModemIrp=NULL;

    }

    return;
}

NTSTATUS
ModemReadCompletion(
    PDEVICE_OBJECT    DeviceObject,
    PIRP              Irp,
    PVOID             Context
    )

{
    PDUPLEX_CONTROL     DuplexControl=(PDUPLEX_CONTROL)Context;

    D_INPUT(DbgPrint("MODEMCSA: ModemReadCompletion\n");)

    IoGetCurrentIrpStackLocation(Irp)->Parameters.Others.Argument1=Context;

    ExInitializeWorkItem(
        (PWORK_QUEUE_ITEM)&Irp->Tail.Overlay.DriverContext,
        ReadCompleteWorker,
        Irp
        );


#if DBG
    InterlockedIncrement(&DuplexControl->Input.WorkItemsOutstanding);
#endif


    ExQueueWorkItem(
        (PWORK_QUEUE_ITEM)&Irp->Tail.Overlay.DriverContext,
        CriticalWorkQueue
        );


    return STATUS_MORE_PROCESSING_REQUIRED;

}



VOID
StartRead(
    PDUPLEX_CONTROL     DuplexControl
    )

{
    PIRP    ModemIrp;
    PIO_STACK_LOCATION   irpSp;

    while (!DuplexControl->Input.ModemStreamDead) {

        ModemIrp=TryToRemoveAnIrp(
            &DuplexControl->Input.BufferControl
            );

        if (ModemIrp != NULL) {

#if DBG
            InterlockedDecrement(&DuplexControl->Input.EmptyIrps);
#endif


            irpSp = IoGetNextIrpStackLocation( ModemIrp );

            //
            // Set the major function code.
            //

            irpSp->MajorFunction = (UCHAR) IRP_MJ_READ;

            irpSp->FileObject = DuplexControl->ModemFileObject;

            irpSp->Parameters.Read.Length = STREAM_BUFFER_SIZE;
            irpSp->Parameters.Read.ByteOffset.HighPart=0;
            irpSp->Parameters.Read.ByteOffset.LowPart=0;

            InterlockedIncrement(&DuplexControl->Input.IrpsInModemDriver);

            IoSetCompletionRoutine(
                ModemIrp,
                ModemReadCompletion,
                DuplexControl,
                TRUE,
                TRUE,
                TRUE
                );

            IoCallDriver(
                IoGetRelatedDeviceObject(DuplexControl->ModemFileObject),
                ModemIrp
                );
#if DBG
            ModemIrp=NULL;
#endif

        } else {
            //
            // could not get a irp
            //
            break;
        }
    }

    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\sys\modemcsa\device.c ===
/*++

Copyright (c) 1996 Microsoft Corporation.

Module Name:

    device.c

Abstract:

    Device entry point and hardware validation.

--*/

#include "modemcsa.h"

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  RegistryPathName
    );

NTSTATUS
QueryPdoInformation(
    PDEVICE_OBJECT    Pdo,
    ULONG             InformationType,
    PVOID             Buffer,
    ULONG             BufferLength
    );

NTSTATUS
WaitForLowerDriverToCompleteIrp(
   PDEVICE_OBJECT    TargetDeviceObject,
   PIRP              Irp,
   PKEVENT           Event
   );

NTSTATUS
FilterPnpDispatch(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
FilterPowerDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
GetModemDeviceName(
    PDEVICE_OBJECT    Pdo,
    PUNICODE_STRING   ModemDeviceName
    );


#ifdef ALLOC_PRAGMA

#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, PnpAddDevice)
#pragma alloc_text(PAGE, QueryPdoInformation)
#pragma alloc_text(PAGE, FilterPnpDispatch)
#pragma alloc_text(PAGE, FilterPowerDispatch)
#pragma alloc_text(PAGE, WaitForLowerDriverToCompleteIrp)
#pragma alloc_text(PAGE, GetModemDeviceName)
#endif // ALLOC_PRAGMA


#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif // ALLOC_DATA_PRAGMA

static const WCHAR DeviceTypeName[] = L"Wave";

static const DEFINE_KSCREATE_DISPATCH_TABLE(DeviceCreateItems) {
    DEFINE_KSCREATE_ITEM(FilterDispatchCreate, DeviceTypeName, -1)
};

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif // ALLOC_DATA_PRAGMA


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  RegistryPath
    )
/*++

Routine Description:

    Sets up the driver object to handle the KS interface and PnP Add Device
    request. Does not set up a handler for PnP Irp's, as they are all dealt
    with directly by the PDO.

Arguments:

    DriverObject -
        Driver object for this instance.

    RegistryPathName -
        Contains the registry path which was used to load this instance.

Return Values:

    Returns STATUS_SUCCESS.

--*/
{

    RTL_QUERY_REGISTRY_TABLE paramTable[3];
    ULONG zero = 0;
    ULONG debugLevel = 0;
    ULONG shouldBreak = 0;
    PWCHAR path;


    D_INIT(DbgPrint("MODEMCSA: DriverEntry\n");)

    //
    // Since the registry path parameter is a "counted" UNICODE string, it
    // might not be zero terminated.  For a very short time allocate memory
    // to hold the registry path zero terminated so that we can use it to
    // delve into the registry.
    //
    // NOTE NOTE!!!! This is not an architected way of breaking into
    // a driver.  It happens to work for this driver because the author
    // likes to do things this way.
    //

    path = ALLOCATE_PAGED_POOL(RegistryPath->Length+sizeof(WCHAR));

    if (path != NULL) {

        RtlZeroMemory(
            &paramTable[0],
            sizeof(paramTable)
            );
        RtlZeroMemory(
            path,
            RegistryPath->Length+sizeof(WCHAR)
            );
        RtlMoveMemory(
            path,
            RegistryPath->Buffer,
            RegistryPath->Length
            );
        paramTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
        paramTable[0].Name = L"BreakOnEntry";
        paramTable[0].EntryContext = &shouldBreak;
        paramTable[0].DefaultType = REG_DWORD;
        paramTable[0].DefaultData = &zero;
        paramTable[0].DefaultLength = sizeof(ULONG);
        paramTable[1].Flags = RTL_QUERY_REGISTRY_DIRECT;
        paramTable[1].Name = L"DebugFlags";
        paramTable[1].EntryContext = &debugLevel;
        paramTable[1].DefaultType = REG_DWORD;
        paramTable[1].DefaultData = &zero;
        paramTable[1].DefaultLength = sizeof(ULONG);

        if (!NT_SUCCESS(RtlQueryRegistryValues(
                            RTL_REGISTRY_ABSOLUTE | RTL_REGISTRY_OPTIONAL,
                            path,
                            &paramTable[0],
                            NULL,
                            NULL
                            ))) {

            shouldBreak = 0;
            debugLevel = DebugFlags;

        }

        FREE_POOL(path);
    }

#if DBG
    DebugFlags= debugLevel;
#endif

    if (shouldBreak) {

        DbgBreakPoint();

    }


    DriverObject->MajorFunction[IRP_MJ_PNP] = FilterPnpDispatch;
    DriverObject->DriverExtension->AddDevice = PnpAddDevice;
    DriverObject->MajorFunction[IRP_MJ_POWER] = FilterPowerDispatch;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = KsDefaultForwardIrp;
    DriverObject->DriverUnload = KsNullDriverUnload;
    KsSetMajorFunctionHandler(DriverObject, IRP_MJ_CREATE);
    KsSetMajorFunctionHandler(DriverObject, IRP_MJ_CLOSE);
    KsSetMajorFunctionHandler(DriverObject, IRP_MJ_DEVICE_CONTROL);
    return STATUS_SUCCESS;
}







#if DBG
ULONG  DebugFlags= DEBUG_FLAG_POWER; //DEBUG_FLAG_ERROR | DEBUG_FLAG_INIT; // | DEBUG_FLAG_INPUT;
#else
ULONG  DebugFlags=0;
#endif


NTSTATUS
PnpAddDevice(
    IN PDRIVER_OBJECT   DriverObject,
    IN PDEVICE_OBJECT   PhysicalDeviceObject
    )
/*++

Routine Description:

    When a new device is detected, PnP calls this entry point with the
    new PhysicalDeviceObject (PDO). The driver creates an associated 
    FunctionalDeviceObject (FDO).

Arguments:

    DriverObject -
        Pointer to the driver object.

    PhysicalDeviceObject -
        Pointer to the new physical device object.

Return Values:

    STATUS_SUCCESS or an appropriate error condition.

--*/
{
    PDEVICE_OBJECT      FunctionalDeviceObject;
    PDEVICE_INSTANCE    DeviceInstance;
    NTSTATUS            Status;
    ULONG               BufferSizeNeeded;

    UNICODE_STRING      ReferenceString;


    D_INIT(DbgPrint("MODEMCSA: AddDevice\n");)

    Status = IoCreateDevice(
        DriverObject,
        sizeof(DEVICE_INSTANCE),
        NULL,
        FILE_DEVICE_KS,
        0,
        FALSE,
        &FunctionalDeviceObject);

    if (!NT_SUCCESS(Status)) {

        D_ERROR(DbgPrint("MODEMCSA: AddDevice: could not create FDO, %08lx\n",Status);)

        return Status;
    }

    FunctionalDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    FunctionalDeviceObject->Flags |= DO_POWER_PAGABLE;

    DeviceInstance = (PDEVICE_INSTANCE)FunctionalDeviceObject->DeviceExtension;

    DeviceInstance->Pdo=PhysicalDeviceObject;

    QueryPdoInformation(
        PhysicalDeviceObject,
        READ_CONFIG_PERMANENT_GUID,
        &DeviceInstance->PermanentGuid,
        sizeof(DeviceInstance->PermanentGuid)
        );

    QueryPdoInformation(
        PhysicalDeviceObject,
        READ_CONFIG_DUPLEX_SUPPORT,
        &DeviceInstance->DuplexSupport,
        sizeof(DeviceInstance->DuplexSupport)
        );


    Status=GetModemDeviceName(
        PhysicalDeviceObject,
        &DeviceInstance->ModemDeviceName
        );

    if (NT_SUCCESS(Status)) {

        RtlInitUnicodeString(&ReferenceString,L"Wave");

        Status=IoRegisterDeviceInterface(
            PhysicalDeviceObject,
            &KSCATEGORY_RENDER,
            &ReferenceString,
            &DeviceInstance->InterfaceName
            );

        if (NT_SUCCESS(Status)) {

            if (DeviceInstance->DuplexSupport & 0x1) {

                Status=IoSetDeviceInterfaceState(
                    &DeviceInstance->InterfaceName,
                    TRUE
                    );
            } else {
                D_TRACE(DbgPrint("MODEMCSA: AddDevice: Not enabling interface for half duplex modem\n");)
            }

            if (NT_SUCCESS(Status)) {
                //
                // This object uses KS to perform access through the DeviceCreateItems.
                //
                Status = KsAllocateDeviceHeader(
                    &DeviceInstance->Header,
                    SIZEOF_ARRAY(DeviceCreateItems),
                    (PKSOBJECT_CREATE_ITEM)DeviceCreateItems
                    );

                if (NT_SUCCESS(Status)) {

                    DeviceInstance->LowerDevice=IoAttachDeviceToDeviceStack(
                        FunctionalDeviceObject,
                        PhysicalDeviceObject
                        );

                    D_ERROR({if (DeviceInstance->LowerDevice==NULL) {DbgPrint("MODEMCSA: IoAttachDeviceToStack return NULL\n");}})

                    KsSetDevicePnpAndBaseObject(
                        DeviceInstance->Header,
                        DeviceInstance->LowerDevice,
                        FunctionalDeviceObject
                        );

                    return STATUS_SUCCESS;

                } else {

                    D_ERROR(DbgPrint("MODEMCSA: AddDevice: could allocate DeviceHeader, %08lx\n",Status);)

                    IoSetDeviceInterfaceState(
                        &DeviceInstance->InterfaceName,
                        FALSE
                        );
                }

            } else {

                D_ERROR(DbgPrint("MODEMCSA: AddDevice: IoSetDeviceInterfaceState failed, %08lx\n",Status);)
            }
        } else {

            D_ERROR(DbgPrint("MODEMCSA: AddDevice: IoRegisterDeviceInterface failed, %08lx\n",Status);)
        }
    } else {

        D_ERROR(DbgPrint("MODEMCSA: AddDevice: GetModemDeviceNameFailed, %08lx\n",Status);)
    }

    if (DeviceInstance->ModemDeviceName.Buffer != NULL) {

        FREE_POOL(DeviceInstance->ModemDeviceName.Buffer);
    }


    IoDeleteDevice(FunctionalDeviceObject);
    return Status;
}



NTSTATUS
FilterPnpDispatch(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

    Dispatches the creation of a Filter instance. Allocates the object header and initializes
    the data for this Filter instance.

Arguments:

    DeviceObject -
        Device object on which the creation is occuring.

    Irp -
        Creation Irp.

Return Values:

    Returns STATUS_SUCCESS on success, STATUS_INSUFFICIENT_RESOURCES or some related error
    on failure.

--*/
{
    PDEVICE_INSTANCE    DeviceInstance;
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);

    DeviceInstance = (PDEVICE_INSTANCE)DeviceObject->DeviceExtension;

    switch (irpSp->MinorFunction) {

        case IRP_MN_REMOVE_DEVICE: {

            D_PNP(DbgPrint("MODEMCSA: IRP_MN_REMOVE_DEVICE\n");)

            if (DeviceInstance->InterfaceName.Buffer != NULL) {

                IoSetDeviceInterfaceState(
                    &DeviceInstance->InterfaceName,
                    FALSE
                    );


                RtlFreeUnicodeString(&DeviceInstance->InterfaceName);

                CleanUpDuplexControl(
                    &((PDEVICE_INSTANCE)DeviceObject->DeviceExtension)->DuplexControl
                    );

            }

            if (DeviceInstance->ModemDeviceName.Buffer != NULL) {

                FREE_POOL(DeviceInstance->ModemDeviceName.Buffer);

            }
        }
    }

    return KsDefaultDispatchPnp(DeviceObject,Irp);
}


NTSTATUS
FilterPowerDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

{
    PDEVICE_INSTANCE    DeviceInstance=DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS    status;

    D_POWER(DbgPrint("MODEMCSA: Power IRP, MN func=%d\n",irpSp->MinorFunction);)

    PoStartNextPowerIrp(Irp);

    IoSkipCurrentIrpStackLocation(Irp);

    status=PoCallDriver(DeviceInstance->LowerDevice, Irp);

    return status;
}




NTSTATUS
ModemAdapterIoCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT pdoIoCompletedEvent
    )
{
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);

    KeSetEvent(pdoIoCompletedEvent, IO_NO_INCREMENT, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
WaitForLowerDriverToCompleteIrp(
   PDEVICE_OBJECT    TargetDeviceObject,
   PIRP              Irp,
   PKEVENT           Event
   )

{
    NTSTATUS         Status;

    KeResetEvent(Event);


    IoSetCompletionRoutine(
                 Irp,
                 ModemAdapterIoCompletion,
                 Event,
                 TRUE,
                 TRUE,
                 TRUE
                 );

    Status = IoCallDriver(TargetDeviceObject, Irp);

    if (Status == STATUS_PENDING) {

         D_ERROR(DbgPrint("MODEM: Waiting for PDO\n");)

         KeWaitForSingleObject(
             Event,
             Executive,
             KernelMode,
             FALSE,
             NULL
             );
    }

    return Irp->IoStatus.Status;

}



NTSTATUS
QueryPdoInformation(
    PDEVICE_OBJECT    Pdo,
    ULONG             InformationType,
    PVOID             Buffer,
    ULONG             BufferLength
    )

{

    PDEVICE_OBJECT       deviceObject=Pdo;
    PIRP                 irp;
    PIO_STACK_LOCATION   irpSp;
    KEVENT               Event;
    NTSTATUS             Status;

    //
    // Get a pointer to the topmost device object in the stack of devices,
    // beginning with the deviceObject.
    //

    while (deviceObject->AttachedDevice) {
        deviceObject = deviceObject->AttachedDevice;
    }

    //
    // Begin by allocating the IRP for this request.  Do not charge quota to
    // the current process for this IRP.
    //

    irp = IoAllocateIrp(deviceObject->StackSize, FALSE);
    if (irp == NULL){

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
    irp->IoStatus.Information = 0;


    //
    // Get a pointer to the stack location of the first driver which will be
    // invoked.  This is where the function codes and parameters are set.
    //

    irpSp = IoGetNextIrpStackLocation(irp);

    irpSp->MajorFunction=IRP_MJ_PNP;
    irpSp->MinorFunction=IRP_MN_READ_CONFIG;
    irpSp->Parameters.ReadWriteConfig.WhichSpace=InformationType;
    irpSp->Parameters.ReadWriteConfig.Offset=0;
    irpSp->Parameters.ReadWriteConfig.Buffer=Buffer;
    irpSp->Parameters.ReadWriteConfig.Length=BufferLength;

    KeInitializeEvent(
        &Event,
        SynchronizationEvent,
        FALSE
        );


    Status=WaitForLowerDriverToCompleteIrp(
        deviceObject,
        irp,
        &Event
        );


    IoFreeIrp(irp);

    return Status;

}


NTSTATUS
GetModemDeviceName(
    PDEVICE_OBJECT    Pdo,
    PUNICODE_STRING   ModemDeviceName
    )
{

    NTSTATUS   Status;
    PVOID      NameBuffer=NULL;
    ULONG      BufferLength=0;

    RtlInitUnicodeString(
        ModemDeviceName,
        NULL
        );

    Status=QueryPdoInformation(
        Pdo,
        READ_CONFIG_NAME_SIZE,
        &BufferLength,
        sizeof(BufferLength)
        );

    if (Status == STATUS_SUCCESS) {

        NameBuffer=ALLOCATE_PAGED_POOL(BufferLength);

        if (NameBuffer != NULL) {

            Status=QueryPdoInformation(
                Pdo,
                READ_CONFIG_DEVICE_NAME,
                NameBuffer,
                BufferLength
                );

            if (Status == STATUS_SUCCESS) {
                //
                //  got it
                //
                RtlInitUnicodeString(
                    ModemDeviceName,
                    NameBuffer
                    );

            } else {

                D_ERROR(DbgPrint("MODEMCSA: GetModemDeviceName: QueryPdoInformation failed %08lx\n",Status);)

                FREE_POOL(NameBuffer);
            }

        } else {

            Status=STATUS_NO_MEMORY;
        }
    } else {

        D_ERROR(DbgPrint("MODEMCSA: GetModemDeviceName: QueryPdoInformation for size failed %08lx\n",Status);)
    }

    return Status;
}

#if 0

NTSTATUS
SetPersistanInterfaceInfo(
    PUNICODE_STRING   Interface,
    PWCHAR            ValueName,
    ULONG             Type,
    PVOID             Buffer,
    ULONG             BufferLength
    )

{

    HANDLE     hKey;
    NTSTATUS   Status;
    UNICODE_STRING   UnicodeValueName;

    RtlInitUnicodeString (&UnicodeValueName, ValueName);

    Status=IoOpenDeviceInterfaceRegistryKey(
        Interface,
        STANDARD_RIGHTS_WRITE,
        &hKey
        );

    if (!NT_SUCCESS(Status)) {

        return Status;
    }

    Status=ZwSetValueKey(
        hKey,
        &UnicodeValueName,
        0,
        Type,
        Buffer,
        BufferLength
        );

    ZwClose(hKey);

    return Status;

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\sys\modemcsa\output.c ===
/*++

Copyright (c) 1996 Microsoft Corporation.

Module Name:

    msfsio.c

Abstract:

    Pin property support.

--*/

#include "modemcsa.h"


NTSTATUS
WriteStream(
    IN PDUPLEX_CONTROL     DuplexControl,
    IN PIRP     Irp
    );

NTSTATUS
FilterReadCompletion(
    PDEVICE_OBJECT    DeviceObject,
    PIRP              Irp,
    PVOID             Context
    );


VOID
ProcessWriteIrps(
    PDUPLEX_CONTROL     DuplexControl
    )

{
    KIRQL    OldIrql;
    PIRP     NewIrp=NULL;

//    D_INIT(DbgPrint("MODEMCSA: ProcessWriteIrps\n");)

    if (DuplexControl->Output.DownStreamFileObject == NULL) {
        //
        //  we are a sink for write stream irps
        //

        KeAcquireSpinLock(
            &DuplexControl->SpinLock,
            &OldIrql
            );

        if (DuplexControl->Output.CurrentIrp == NULL && (DuplexControl->StartFlags & OUTPUT_PIN)) {

            DuplexControl->Output.CurrentIrp = (PIRP)-1;

            KeReleaseSpinLock(
                &DuplexControl->SpinLock,
                OldIrql
                );


            NewIrp=KsRemoveIrpFromCancelableQueue(
                &DuplexControl->Output.WriteStreamIrpQueue,
                &DuplexControl->SpinLock,
                KsListEntryHead,
                KsAcquireAndRemove
                );

            KeAcquireSpinLock(
                &DuplexControl->SpinLock,
                &OldIrql
                );



            DuplexControl->Output.CurrentIrp=NewIrp;

        }

        KeReleaseSpinLock(
            &DuplexControl->SpinLock,
            OldIrql
            );

        if (NewIrp != NULL) {

            NewIrp->IoStatus.Status=STATUS_SUCCESS;
//            D_INIT(DbgPrint("MODEMCSA: ProcessWriteIrps: new irp\n");)

            WriteStream(
                DuplexControl,
                NewIrp
                );
        }

    } else {
        //
        //  we are a source of read stream irps
        //

        PIRP    StreamIrp;

        while (1) {

            StreamIrp=TryToRemoveAnIrp(
                &DuplexControl->Output.BufferControl
                );

            if (StreamIrp != NULL) {

                PIRP                    ModemIrp;
                PIO_STACK_LOCATION      NextSp;
                PIO_STACK_LOCATION      IrpSp;
                PKSSTREAM_HEADER        StreamHeader;

                IrpSp = IoGetCurrentIrpStackLocation(StreamIrp);

                ModemIrp=IrpSp->Parameters.Others.Argument2;


                NextSp=IoGetNextIrpStackLocation(StreamIrp);

                IrpSp->Parameters.DeviceIoControl.OutputBufferLength=sizeof(KSSTREAM_HEADER);

                StreamHeader = (PKSSTREAM_HEADER)StreamIrp->AssociatedIrp.SystemBuffer;

                RtlZeroMemory(StreamHeader,sizeof(KSSTREAM_HEADER));

                StreamHeader->Size=sizeof(KSSTREAM_HEADER);
                StreamHeader->Data=ModemIrp->AssociatedIrp.SystemBuffer;
                StreamHeader->FrameExtent=PtrToUlong(IoGetCurrentIrpStackLocation(ModemIrp)->Parameters.Others.Argument3);

                NextSp->FileObject=DuplexControl->Output.DownStreamFileObject;

                NextSp->Parameters.DeviceIoControl.OutputBufferLength=StreamHeader->Size;

                NextSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;
                NextSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_KS_READ_STREAM;

                StreamIrp->IoStatus.Status=STATUS_SUCCESS;
                StreamIrp->IoStatus.Information=0;

                IoSetCompletionRoutine(
                    StreamIrp,
                    FilterReadCompletion,
                    DuplexControl,
                    TRUE,
                    TRUE,
                    TRUE
                    );

                IoCallDriver(
                    IoGetRelatedDeviceObject(DuplexControl->Output.DownStreamFileObject),
                    StreamIrp
                    );


            } else {

                break;
            }
        }
    }

    return;
}


VOID
WriteCompleteWorker(
    PVOID    Context
    )

{
    PIRP                    Irp=(PIRP)Context;
    PKSSTREAM_HEADER        StreamHdr;
    PIO_STACK_LOCATION      IrpStack;
    ULONG                   BufferLength;

//    D_INIT(DbgPrint("MODEMCSA: WriteCompleteWorker\n");)

    IrpStack = IoGetCurrentIrpStackLocation(Irp);

    BufferLength = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;
    StreamHdr = (PKSSTREAM_HEADER)Irp->AssociatedIrp.SystemBuffer;

    for (; BufferLength; BufferLength -= sizeof(KSSTREAM_HEADER), StreamHdr++) {

        if (StreamHdr->OptionsFlags & KSSTREAM_HEADER_OPTIONSF_ENDOFSTREAM) {

            D_INIT(DbgPrint("MODEMCSA: WriteCompleteWorker: EOS\n");)

            GenerateEvent(((PPIN_INSTANCE)IrpStack->FileObject->FsContext)->DuplexHandle);
        }
    }

    IoCompleteRequest(Irp, IO_SERIAL_INCREMENT);

    return;
}

VOID
RemoveReferenceFromCurrentIrp(
    PDUPLEX_CONTROL     DuplexControl
    )

{

    if (InterlockedDecrement(&DuplexControl->Output.OutstandingChildIrps) == 0) {

        KIRQL    OldIrql;
        PIRP     IrpToComplete;

//        D_INIT(DbgPrint("MODEMCSA: WriteCompletion: complete master\n");)

        KeAcquireSpinLock(
            &DuplexControl->SpinLock,
            &OldIrql
            );

        IrpToComplete=DuplexControl->Output.CurrentIrp;

        DuplexControl->Output.CurrentIrp = NULL;

        KeReleaseSpinLock(
            &DuplexControl->SpinLock,
            OldIrql
            );

        ExInitializeWorkItem(
            (PWORK_QUEUE_ITEM)&IrpToComplete->Tail.Overlay.DriverContext,
            WriteCompleteWorker,
            IrpToComplete
            );

        ExQueueWorkItem((PWORK_QUEUE_ITEM)&IrpToComplete->Tail.Overlay.DriverContext,CriticalWorkQueue);

        ProcessWriteIrps(DuplexControl);

    }


    return;

}

NTSTATUS
WriteCompletion(
    PDEVICE_OBJECT    DeviceObject,
    PIRP              Irp,
    PVOID             Context
    )

{
    PDUPLEX_CONTROL     DuplexControl=(PDUPLEX_CONTROL)Context;


//    ExFreePool(Irp->UserIosb);

    if (Irp->Flags & IRP_DEALLOCATE_BUFFER) {

        ExFreePool( Irp->AssociatedIrp.SystemBuffer );
    }

    DuplexControl->Output.CurrentIrp->IoStatus.Information+=Irp->IoStatus.Information*DuplexControl->Output.BytesPerSample;

    DuplexControl->Output.CurrentIrp->IoStatus.Status=Irp->IoStatus.Status;

    IoFreeIrp(Irp);

#if DBG
    Irp=NULL;
#endif

//    D_INIT(DbgPrint("MODEMCSA: WriteCompletion\n");)

    RemoveReferenceFromCurrentIrp(
        DuplexControl
        );

    return STATUS_MORE_PROCESSING_REQUIRED;

}




NTSTATUS
WriteStream(
    IN PDUPLEX_CONTROL     DuplexControl,
    IN PIRP     Irp
    )
/*++

Routine Description:

    Handles IOCTL_KS_WRITE_STREAM by writing data to the current file position, or a
    specified file position.

Arguments:

    Irp -
        Streaming Irp.

Return Values:

    Returns STATUS_SUCCESS if the request was fulfilled. Else returns
    STATUS_DEVICE_NOT_CONNECTED if the File I/O Pin has been closed, some write error,
    or some parameter validation error.

--*/
{
    NTSTATUS    Status;

    PIO_STACK_LOCATION      IrpStack;
    ULONG                   BufferLength;
    PKSSTREAM_HEADER        StreamHdr;
    PMDL                    Mdl;

    IrpStack = IoGetCurrentIrpStackLocation(Irp);

    BufferLength = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;
    StreamHdr = (PKSSTREAM_HEADER)Irp->AssociatedIrp.SystemBuffer;
    //
    // This is only used if an Mdl list was already present.
    //
    Mdl = Irp->MdlAddress;

    DuplexControl->Output.OutstandingChildIrps=1;
    //
    // Enumerate the stream headers, filling in each one.
    //
    for (; BufferLength; BufferLength -= sizeof(KSSTREAM_HEADER), StreamHdr++) {

        if (!StreamHdr->DataUsed) {
            //
            // If there is no buffer, then nothing gets written, but complete
            // filling in this header anyway. Notice that the Mdl list is
            // not incremented in this case (if it is being used) because
            // no Mdl would have been allocated for this item.
            //
//            IoStatusBlock.Information = 0;
        } else {
            PVOID   Buffer;

            //
            // If an Mdl list was present, then get the system address, else
            // get the address from the current header.
            //
            if (Mdl) {
                Buffer = MmGetSystemAddressForMdl(Mdl);
                Mdl = Mdl->Next;
            } else {
                Buffer = StreamHdr->Data;
            }
            //



            {
                PIO_STATUS_BLOCK    IoStatus;
                PIRP                ModemIrp;
                LARGE_INTEGER  Offset={0,0};

                ModemIrp=IoBuildAsynchronousFsdRequest(
                    IRP_MJ_WRITE,
                    IoGetRelatedDeviceObject(DuplexControl->ModemFileObject),
                    Buffer,
                    StreamHdr->DataUsed/DuplexControl->Output.BytesPerSample,
                    &Offset,
                    NULL
                    );

                if (ModemIrp != NULL) {

                    PIO_STACK_LOCATION      NextSp;

                    NextSp = IoGetNextIrpStackLocation(ModemIrp);

                    if (DuplexControl->Output.BytesPerSample > 1) {

                        PSHORT WriteStreamSample=Buffer;
                        PUCHAR ModemSample=ModemIrp->AssociatedIrp.SystemBuffer;
                        PUCHAR EndPoint=ModemSample+NextSp->Parameters.Write.Length;

                        while (ModemSample < EndPoint) {

                            *ModemSample++=(UCHAR)(((*WriteStreamSample++)+0x8000)>>8);
                        }
                    }

                    IoSetCompletionRoutine(
                        ModemIrp,
                        WriteCompletion,
                        DuplexControl,
                        TRUE,
                        TRUE,
                        TRUE
                        );


                    NextSp->FileObject = DuplexControl->ModemFileObject;

                    InterlockedIncrement(&DuplexControl->Output.OutstandingChildIrps);

                    IoCallDriver(
                        IoGetRelatedDeviceObject(DuplexControl->ModemFileObject),
                        ModemIrp
                        );

                }
            }

            Status=STATUS_SUCCESS;


        }
        if (NT_SUCCESS(Status)) {

        } else {
            break;
        }
    }

    RemoveReferenceFromCurrentIrp(
        DuplexControl
        );

    return Status;
}



VOID
FreeOutputPair(
    PIRP    StreamIrp
    )

{
    PIO_STACK_LOCATION      IrpSp;
    PIRP                    ModemIrp;

    IrpSp = IoGetCurrentIrpStackLocation(StreamIrp);

    ModemIrp=IrpSp->Parameters.Others.Argument2;


    ExFreePool(StreamIrp->AssociatedIrp.SystemBuffer);

    ExFreePool(ModemIrp->AssociatedIrp.SystemBuffer);

    IoFreeMdl(StreamIrp->MdlAddress);

    IoFreeIrp(StreamIrp);

    IoFreeIrp(ModemIrp);

    return;

}





PIRP
AllocateOutputIrpPair(
    PFILE_OBJECT    ModemFileObject,
    PFILE_OBJECT    StreamFileObject,
    ULONG           Length
    )

{
    PIRP    NewModemIrp;
    PIRP    NewStreamIrp;

    NewModemIrp=AllocateIrpForModem(
        ModemFileObject,
        Length
        );

    if (NewModemIrp == NULL) {

        return NULL;
    }

    NewStreamIrp=AllocateStreamIrp(
        StreamFileObject,
        NewModemIrp
        );

    if (NewStreamIrp == NULL) {

        ExFreePool(NewModemIrp->AssociatedIrp.SystemBuffer);

        IoFreeIrp(NewModemIrp);

        return NULL;
    }
    //
    //  link the two irps together, using the current stack locations
    //
    IoGetCurrentIrpStackLocation(NewModemIrp)->Parameters.Others.Argument2=NewStreamIrp;

    IoGetCurrentIrpStackLocation(NewStreamIrp)->Parameters.Others.Argument2=NewModemIrp;

    return NewStreamIrp;
}


VOID
ReadStreamWriteCompleteWorker(
    PVOID    Context
    )

{
    PDUPLEX_CONTROL         DuplexControl;
    PIRP                    ModemIrp=(PIRP)Context;
    PIRP                    StreamIrp;
    UINT                    NewCount;

    DuplexControl=IoGetCurrentIrpStackLocation(ModemIrp)->Parameters.Others.Argument1;

    StreamIrp=(PIRP)IoGetCurrentIrpStackLocation(ModemIrp)->Parameters.Others.Argument2;

    ReturnAnIrp(
        &DuplexControl->Output.BufferControl,
        StreamIrp
        );

    ProcessWriteIrps(DuplexControl);

}

NTSTATUS
ReadStreamWriteCompletion(
    PDEVICE_OBJECT    DeviceObject,
    PIRP              ModemIrp,
    PVOID             Context
    )

{
    PDUPLEX_CONTROL         DuplexControl=(PDUPLEX_CONTROL)Context;

    IoGetCurrentIrpStackLocation(ModemIrp)->Parameters.Others.Argument1=DuplexControl;

    ExInitializeWorkItem(
        (PWORK_QUEUE_ITEM)&ModemIrp->Tail.Overlay.DriverContext,
        ReadStreamWriteCompleteWorker,
        ModemIrp
        );

    ExQueueWorkItem((PWORK_QUEUE_ITEM)&ModemIrp->Tail.Overlay.DriverContext,CriticalWorkQueue);

    return STATUS_MORE_PROCESSING_REQUIRED;
}


#define MID_POINT  0x80

BOOL
CheckForSilence(
    PBYTE    Buffer,
    ULONG    Length,
    BYTE     ThreshHold
    )

{

    PBYTE   EndPoint=Buffer+Length;
    BOOLEAN Silence=TRUE;

    BYTE    MaxValue=MID_POINT+ThreshHold;
    BYTE    MinValue=MID_POINT-ThreshHold;

    while (Buffer < EndPoint) {

        if (*Buffer > ( MaxValue)) {

            Silence=FALSE;
            break;
        }

        if (*Buffer < ( MinValue)) {

            Silence=FALSE;
            break;
        }

        Buffer++;
    }

    return Silence;

}


NTSTATUS
FilterReadCompletion(
    PDEVICE_OBJECT    DeviceObject,
    PIRP              StreamIrp,
    PVOID             Context
    )

{

    PIRP    ModemIrp;
    PIO_STACK_LOCATION      NextSp;
    PIO_STACK_LOCATION      IrpSp;
    PKSSTREAM_HEADER        StreamHeader;
    PDUPLEX_CONTROL         DuplexControl=(PDUPLEX_CONTROL)Context;

    IrpSp = IoGetCurrentIrpStackLocation(StreamIrp);

    ModemIrp=IrpSp->Parameters.Others.Argument2;



    if (NT_SUCCESS(StreamIrp->IoStatus.Status)) {
        //
        //  read stream worked, send to modem
        //
        StreamHeader = (PKSSTREAM_HEADER)StreamIrp->AssociatedIrp.SystemBuffer;

        if (CheckForSilence(StreamHeader->Data,StreamHeader->DataUsed,3)) {
//
//            StreamHeader->DataUsed-=StreamHeader->DataUsed/16;
//        }

            NextSp=IoGetNextIrpStackLocation(ModemIrp);

            NextSp->Parameters.Write.Length=StreamHeader->DataUsed;

            IoSetCompletionRoutine(
                ModemIrp,
                ReadStreamWriteCompletion,
                DuplexControl,
                TRUE,
                TRUE,
                TRUE
                );


            NextSp->FileObject = DuplexControl->ModemFileObject;

            NextSp->MajorFunction = IRP_MJ_WRITE;

            StreamIrp->IoStatus.Status=STATUS_SUCCESS;
            StreamIrp->IoStatus.Information=0;

            IoCallDriver(
                IoGetRelatedDeviceObject(DuplexControl->ModemFileObject),
                ModemIrp
                );
#if 1
        } else {
            //
            //  Buffer is full of silence, toss it
            //
            ReadStreamWriteCompletion(
                DeviceObject,
                ModemIrp,
                DuplexControl
                );
        }
#endif
    } else {
        //
        //  read stream failed, just return it now
        //
        ReadStreamWriteCompletion(
            DeviceObject,
            ModemIrp,
            DuplexControl
            );

    }

    return STATUS_MORE_PROCESSING_REQUIRED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\sys\modemcsa\util.c ===
/*++

Copyright (c) 1996 Microsoft Corporation.

Module Name:

    util.c

Abstract:

    Pin property support.

--*/

#include "modemcsa.h"



VOID
QueueIrpToListTail(
    PLIST_ENTRY        ListToUse,
    PKSPIN_LOCK        SpinLock,
    PIRP               Irp
    )

{

    KIRQL              origIrql;

    KeAcquireSpinLock(
        SpinLock,
        &origIrql
        );

    InsertTailList(
        ListToUse,
        &Irp->Tail.Overlay.ListEntry
        );

    KeReleaseSpinLock(
        SpinLock,
        origIrql
        );

    return;

}


PIRP
RemoveIrpFromListHead(
    PLIST_ENTRY        ListToUse,
    PKSPIN_LOCK        SpinLock
    )

{
    KIRQL              origIrql;
    PLIST_ENTRY        ListElement;
    PIRP    Irp=NULL;

    KeAcquireSpinLock(
        SpinLock,
        &origIrql
        );

    if (!IsListEmpty(ListToUse)) {
        //
        //  irp in list
        //
        ListElement=RemoveTailList(
            ListToUse
            );

        Irp=CONTAINING_RECORD(ListElement,IRP,Tail.Overlay.ListEntry);
    }

    KeReleaseSpinLock(
        SpinLock,
        origIrql
        );

    return Irp;

}


VOID
InitializeBufferControl(
    PBUFFER_CONTROL    BufferControl
    )

{
    KeInitializeSpinLock(&BufferControl->SpinLock);

    KeInitializeEvent(&BufferControl->Event,NotificationEvent,FALSE);

    InitializeListHead(&BufferControl->IrpQueue);

    BufferControl->IrpsInUse=0;

    BufferControl->Active=FALSE;

    return;

}


VOID
AddBuffer(
    PBUFFER_CONTROL    BufferControl,
    PIRP               Irp
    )

{

    QueueIrpToListTail(
        &BufferControl->IrpQueue,
        &BufferControl->SpinLock,
        Irp
        );

    return;

}

PIRP
EmptyBuffers(
    PBUFFER_CONTROL   BufferControl
    )

{
    return RemoveIrpFromListHead(
               &BufferControl->IrpQueue,
               &BufferControl->SpinLock
               );


}



PIRP
TryToRemoveAnIrp(
    PBUFFER_CONTROL   BufferControl
    )

{


    KIRQL              origIrql;
    PLIST_ENTRY        ListElement;
    PIRP    Irp=NULL;

    KeAcquireSpinLock(
        &BufferControl->SpinLock,
        &origIrql
        );

    if (BufferControl->Active) {
        //
        //  The queue is active, try to get an irp
        //
        if (!IsListEmpty(&BufferControl->IrpQueue)) {
            //
            //  irp in list
            //
            ListElement=RemoveTailList(
                &BufferControl->IrpQueue
                );

            Irp=CONTAINING_RECORD(ListElement,IRP,Tail.Overlay.ListEntry);

            BufferControl->IrpsInUse++;
        }
    }

    KeReleaseSpinLock(
        &BufferControl->SpinLock,
        origIrql
        );

    return Irp;

}

VOID
ReturnAnIrp(
    PBUFFER_CONTROL    BufferControl,
    PIRP               Irp
    )

{

    KIRQL              origIrql;
    PLIST_ENTRY        ListElement;
    LONG               NewCount;

    KeAcquireSpinLock(
        &BufferControl->SpinLock,
        &origIrql
        );

    InsertTailList(
        &BufferControl->IrpQueue,
        &Irp->Tail.Overlay.ListEntry
        );

    NewCount=InterlockedDecrement(&BufferControl->IrpsInUse);

    if (!BufferControl->Active && (NewCount == 0)) {
        //
        //  The queue is in active and the count has gone to zero,
        //
        KeSetEvent(
            &BufferControl->Event,
            IO_NO_INCREMENT,
            FALSE
            );
    }

    KeReleaseSpinLock(
        &BufferControl->SpinLock,
        origIrql
        );

    return;

}

VOID
PauseBufferQueue(
    PBUFFER_CONTROL     BufferControl,
    BOOLEAN             WaitForIdle
    )

{

    KIRQL              origIrql;
    LONG               NewCount;

    KeAcquireSpinLock(
        &BufferControl->SpinLock,
        &origIrql
        );

    BufferControl->Active=FALSE;

    if (BufferControl->IrpsInUse == 0) {

        KeSetEvent(
            &BufferControl->Event,
            IO_NO_INCREMENT,
            FALSE
            );
    }

    KeReleaseSpinLock(
        &BufferControl->SpinLock,
        origIrql
        );

    if (WaitForIdle) {

        KeWaitForSingleObject(
            &BufferControl->Event,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );
    }


    return;

}


VOID
ActivateBufferQueue(
    PBUFFER_CONTROL     BufferControl
    )

{
    KIRQL              origIrql;

    KeAcquireSpinLock(
        &BufferControl->SpinLock,
        &origIrql
        );

    BufferControl->Active=TRUE;

    if (BufferControl->IrpsInUse == 0) {

        KeResetEvent(
            &BufferControl->Event
            );
    }

    KeReleaseSpinLock(
        &BufferControl->SpinLock,
        origIrql
        );

    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\sys\modemcsa\modemcsa.c ===
/*++

Copyright (c) 1996 Microsoft Corporation.

Module Name:

    msfsio.c

Abstract:

    Pin property support.

--*/

#include "modemcsa.h"

//#define CREATE_ALLOCATOR


NTSTATUS
WaveAction(
    PFILE_OBJECT   ModemFileObject,
    ULONG          WaveAction
    );

PIRP
AllocateReadIrpForModem(
    PFILE_OBJECT   FileObject,
    ULONG          Length
    );

PIRP
AllocateStreamWriteIrp(
    PFILE_OBJECT    FileObject,
    PIRP            ModemIrp
    );

VOID
FreeInputIrps(
    PIRP    ModemIrp
    );


#ifdef ALLOC_PRAGMA
NTSTATUS
InitializeFileIoPin(
    IN PIRP             Irp,
    IN PKSDATAFORMAT    DataFormat
    );

NTSTATUS
InitializeDevIoPin(
    IN PIRP             Irp,
    PKSPIN_CONNECT      Connect
    );

NTSTATUS
PinDispatchClose(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );
PFILE_OBJECT
LockAndRetrieveFileIoObject(
    PIO_STACK_LOCATION  IrpStack
    );
NTSTATUS
ReadStream(
    IN PIRP     Irp
    );
NTSTATUS
WriteStream(
    IN PIRP     Irp
    );
NTSTATUS
PinDispatchIoControl(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );
NTSTATUS
GetTimeFormat(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    OUT GUID* TimeFormat
    );
NTSTATUS
GetPresentationTime(
    IN PIRP         Irp,
    IN PKSPROPERTY  Property,
    OUT PKSTIME     PresentationTime
    );
NTSTATUS
SetPresentationTime(
    IN PIRP         Irp,
    IN PKSPROPERTY  Property,
    IN PKSTIME      PresentationTime
    );
NTSTATUS
GetPresentationExtent(
    IN PIRP         Irp,
    IN PKSPROPERTY  Property,
    OUT PULONGLONG  PresentationExtent
    );
NTSTATUS
SetDataFormat(
    IN PIRP             Irp,
    IN PKSPROPERTY      Property,
    IN PKSDATAFORMAT    DataFormat
    );
NTSTATUS
GetDataFormat(
    IN PIRP             Irp,
    IN PKSPROPERTY      Property,
    OUT PKSDATAFORMAT   DataFormat
    );
NTSTATUS
AllocatorDispatchCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
PinDeviceState(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    IN OUT PKSSTATE DeviceState
    );

NTSTATUS
PinAllocatorFraming(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    IN OUT PKSALLOCATOR_FRAMING Framing
    );

NTSTATUS
GetStreamAllocator(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    IN OUT ULONG *AllocatorHandle
    );

NTSTATUS
SetStreamAllocator(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    IN OUT ULONG *AllocatorHandle
    );

#pragma alloc_text(PAGE, InitializeFileIoPin)
#pragma alloc_text(PAGE, InitializeDevIoPin)
#pragma alloc_text(PAGE, PinDispatchCreate)
#pragma alloc_text(PAGE, PinDispatchClose)
#pragma alloc_text(PAGE, LockAndRetrieveFileIoObject)
#pragma alloc_text(PAGE, ReadStream)
//#pragma alloc_text(PAGE, WriteStream)
#pragma alloc_text(PAGE, PinDispatchIoControl)
#pragma alloc_text(PAGE, GetTimeFormat)
#pragma alloc_text(PAGE, GetPresentationTime)
#pragma alloc_text(PAGE, GetPresentationTime)
#pragma alloc_text(PAGE, SetPresentationTime)
#pragma alloc_text(PAGE, GetPresentationExtent)
#pragma alloc_text(PAGE, SetDataFormat)
#pragma alloc_text(PAGE, GetDataFormat)
#pragma alloc_text(PAGE, AllocatorDispatchCreate)
#endif // ALLOC_PRAGMA

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif // ALLOC_DATA_PRAGMA

#if 1
static const WCHAR AllocatorTypeName[] = KSSTRING_Allocator;

static const DEFINE_KSCREATE_DISPATCH_TABLE(PinObjectCreateDispatch)
{
    DEFINE_KSCREATE_ITEM(AllocatorDispatchCreate, AllocatorTypeName, 0)
};
#endif

static DEFINE_KSDISPATCH_TABLE(
    PinDevIoDispatchTable,
    PinDispatchIoControl,
    NULL,
    NULL,
    NULL,
    PinDispatchClose,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL);



#if 1
DEFINE_KSPROPERTY_TABLE(DevIoStreamProperties) {
    DEFINE_KSPROPERTY_ITEM_STREAM_ALLOCATOR(GetStreamAllocator,SetStreamAllocator)

};
#endif
#if 1
DEFINE_KSPROPERTY_TABLE(DevIoConnectionProperties) {
    DEFINE_KSPROPERTY_ITEM_CONNECTION_STATE(PinDeviceState,PinDeviceState ),
    DEFINE_KSPROPERTY_ITEM_CONNECTION_ALLOCATORFRAMING(PinAllocatorFraming)
};
#endif

DEFINE_KSPROPERTY_SET_TABLE(DevIoPropertySets) {
#if 1
    DEFINE_KSPROPERTY_SET(
        &KSPROPSETID_Stream,
        SIZEOF_ARRAY(DevIoStreamProperties),
        DevIoStreamProperties,
        0,
        NULL)

    ,
#endif
    DEFINE_KSPROPERTY_SET(
        &KSPROPSETID_Connection,
        SIZEOF_ARRAY(DevIoConnectionProperties),
        DevIoConnectionProperties,
        0,
        NULL)

};

DEFINE_KSEVENT_TABLE(ConnectionItems) {
    DEFINE_KSEVENT_ITEM(
        KSEVENT_CONNECTION_ENDOFSTREAM,
        sizeof(KSEVENTDATA),
        0, NULL, NULL, NULL)
};

DEFINE_KSEVENT_SET_TABLE(EventSets) {
    DEFINE_KSEVENT_SET(&KSEVENTSETID_Connection,
                       SIZEOF_ARRAY(ConnectionItems),
                       ConnectionItems)
};
#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif // ALLOC_DATA_PRAGMA





NTSTATUS
InitializeDevIoPin(
    IN PIRP             Irp,
    PKSPIN_CONNECT      Connect
    )
/*++

Routine Description:

    Allocates the Dev I/O Pin specific structure and initializes it.

Arguments:

    Irp -
        Creation Irp.


Return Values:

    Returns STATUS_SUCCESS if everything could be allocated and opened, else an error.

--*/
{
    PPIN_INSTANCE PinInstance;
    NTSTATUS            Status;
    PIO_STACK_LOCATION  IrpStack;
    PFILTER_INSTANCE    FilterInstance;

    D_INIT(DbgPrint("MODEMCSA: InitializeDevIoPin\n");)

    IrpStack = IoGetCurrentIrpStackLocation(Irp);

    FilterInstance = (PFILTER_INSTANCE)IrpStack->FileObject->RelatedFileObject->FsContext;


    //
    // Create the instance information. This contains the Pin factory identifier, and
    // event queue information.
    //
    PinInstance = ALLOCATE_NONPAGED_POOL(sizeof(PIN_INSTANCE));

    if (PinInstance) {

            RtlZeroMemory(PinInstance,sizeof(PIN_INSTANCE));

            Status = KsAllocateObjectHeader(
                &PinInstance->Header,
#ifndef CREATE_ALLOCATOR
                0,
                NULL,
#else
                SIZEOF_ARRAY(PinObjectCreateDispatch),
                (PKSOBJECT_CREATE_ITEM)PinObjectCreateDispatch,
#endif
                Irp,
                &PinDevIoDispatchTable
                );

            if (NT_SUCCESS(Status)) {

                KeInitializeSpinLock(&PinInstance->SpinLock);

                PinInstance->DeviceState=KSSTATE_STOP;
//                PinInstance->ModemStreamStarted=FALSE;

                //
                // KS expects that the object data is in FsContext.
                //
                IoGetCurrentIrpStackLocation(Irp)->FileObject->FsContext = PinInstance;
                return STATUS_SUCCESS;
            }

        ExFreePool(PinInstance);

    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }
    return Status;
}


NTSTATUS
PinDispatchCreate(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

    Dispatches the creation of a Pin instance. Allocates the object header and initializes
    the data for this Pin instance.

Arguments:

    DeviceObject -
        Device object on which the creation is occuring.

    Irp -
        Creation Irp.

Return Values:

    Returns STATUS_SUCCESS on success, or an error.

--*/
{
    PIO_STACK_LOCATION  IrpStack;
    PKSPIN_CONNECT      Connect;
    NTSTATUS            Status;

    PFILTER_INSTANCE    FilterInstance;
    PFILE_OBJECT        NextFileObject=NULL;

    D_INIT(DbgPrint("MODEMCSA: PinDispatchCreate\n");)

    IrpStack = IoGetCurrentIrpStackLocation(Irp);

    FilterInstance = (PFILTER_INSTANCE)IrpStack->FileObject->RelatedFileObject->FsContext;

    //
    // Determine if this request is being sent to a valid Pin factory with valid
    // connection parameters. All the descriptors are the same except for the
    // data flow description, which is not specified in a connection request.
    //

    Status = KsValidateConnectRequest(
        Irp,
        SIZEOF_ARRAY(PinDescriptors),
        PinDescriptors,
        &Connect
        );

    D_INIT(DbgPrint("MODEMCSA: PinDispatchCreate filter=%08lx PinId=%d PinToHandle=%08lx,\n",FilterInstance,Connect->PinId,Connect->PinToHandle);)

    if (NT_SUCCESS(Status)) {
        //
        // Exclude other Pin creation at this point.
        //
        PVOID                      DuplexHandle;
        PKSDATAFORMAT              DataFormat= (PKSDATAFORMAT)(Connect + 1);
        PKSDATAFORMAT_WAVEFORMATEX WaveFormatEx=(PKSDATAFORMAT_WAVEFORMATEX)DataFormat;

        if (DataFormat->FormatSize >= sizeof(PKSDATAFORMAT_WAVEFORMATEX)
            &&
//            ((WaveFormatEx->WaveFormatEx.wBitsPerSample == 16)
//             ||
             (WaveFormatEx->WaveFormatEx.wBitsPerSample == 8)) {

            D_INIT(DbgPrint("MODEMCSA: size=%d, rate=%d\n",WaveFormatEx->WaveFormatEx.wBitsPerSample,WaveFormatEx->WaveFormatEx.nSamplesPerSec);)

//            ExAcquireFastMutexUnsafe(&FilterInstance->ControlMutex);

            if (!FilterInstance->PinFileObjects[Connect->PinId]) {

                DuplexHandle=OpenDuplexControl(
                    ((PDEVICE_INSTANCE)DeviceObject->DeviceExtension),
                    Connect->PinId == ID_DEVIO_PIN_OUTPUT ? INPUT_PIN : OUTPUT_PIN,
                    Connect->PinToHandle,
                    WaveFormatEx->WaveFormatEx.wBitsPerSample
                    );

                Status = InitializeDevIoPin(Irp, Connect);

                if (!NT_SUCCESS(Status)) {

                    CloseDuplexControl(DuplexHandle);

                }

                if (NT_SUCCESS(Status)) {

                    PPIN_INSTANCE    PinInstance;

                    //
                    // Store the common Pin information and increment the reference
                    // count on the parent Filter.
                    //
                    PinInstance = (PPIN_INSTANCE)IrpStack->FileObject->FsContext;
                    PinInstance->PinId = Connect->PinId;

                    PinInstance->DuplexHandle=DuplexHandle;

                    ObReferenceObject(IrpStack->FileObject->RelatedFileObject);
                    FilterInstance->PinFileObjects[Connect->PinId] = IrpStack->FileObject;

                }
            } else {

                Status = STATUS_CONNECTION_REFUSED;
            }
//            ExReleaseFastMutexUnsafe(&FilterInstance->ControlMutex);
        } else {

            D_ERROR(DbgPrint("MODEMCSA: FormatSize too small or bad BitsPerSample\n");)
        }
    }
    Irp->IoStatus.Status = Status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return Status;
}


NTSTATUS
PinDispatchClose(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

    Closes a previously opened Pin instance. This can occur at any time in any order.

Arguments:

    DeviceObject -
        Device object on which the close is occuring.

    Irp -
        Close Irp.

Return Values:

    Returns STATUS_SUCCESS.

--*/
{
    PIO_STACK_LOCATION      IrpStack;
    PFILTER_INSTANCE        FilterInstance;
    PPIN_INSTANCE    PinInstance;

    D_INIT(DbgPrint("MODEMCSA: PinDispatchClose\n");)

    IrpStack = IoGetCurrentIrpStackLocation(Irp);
    PinInstance = (PPIN_INSTANCE)IrpStack->FileObject->FsContext;
    FilterInstance = (PFILTER_INSTANCE)IrpStack->FileObject->RelatedFileObject->FsContext;
    //
    // The closing of the File I/O Pin instance must be synchronized with any access to
    // that object.
    //
    ExAcquireFastMutexUnsafe(&FilterInstance->ControlMutex);
    //
    // Clean up the event list of anything still outstanding.
    //
    FreeEventList(
        ((PPIN_INSTANCE)PinInstance)->DuplexHandle,
        Irp
        );

    //
    // These were allocated during the creation of the Pin instance.
    //
    KsFreeObjectHeader(PinInstance->Header);
    //
    // As soon as the entry has been set to NULL, the mutex can allow access again.
    //
    FilterInstance->PinFileObjects[PinInstance->PinId] = NULL;
    ExReleaseFastMutexUnsafe(&FilterInstance->ControlMutex);
    //
    // All Pins are created with a root file object, which is the Filter, and was
    // previously referenced during creation.
    //
    ObDereferenceObject(IrpStack->FileObject->RelatedFileObject);

    CloseDuplexControl(((PPIN_INSTANCE)PinInstance)->DuplexHandle);


    ExFreePool(PinInstance);
    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}



NTSTATUS
PinDispatchIoControl(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

    Dispatches property, event, and streaming requests on the Dev I/O Pin instance.

Arguments:

    DeviceObject -
        Device object on which the device control is occuring.

    Irp -
        Device control Irp.

Return Values:

    Returns STATUS_SUCCESS if the property was successfully manipulated, else an error.

--*/
{
    PIO_STACK_LOCATION  IrpStack;
    NTSTATUS            Status;
    CCHAR               PriorityBoost;
    PPIN_INSTANCE PinInstance;

    PFILTER_INSTANCE        FilterInstance;

//    D_INIT(DbgPrint("MODEMCSA: PinDispatchIoControl\n");)

    PriorityBoost = IO_NO_INCREMENT;
    IrpStack = IoGetCurrentIrpStackLocation(Irp);

    PinInstance = (PPIN_INSTANCE)IrpStack->FileObject->FsContext;

    switch (IrpStack->Parameters.DeviceIoControl.IoControlCode) {

    case IOCTL_KS_PROPERTY: {

            KSPROPERTY          LocalProperty;

            RtlCopyMemory(
                &LocalProperty,
                IrpStack->Parameters.DeviceIoControl.Type3InputBuffer,
                sizeof(LocalProperty) < IrpStack->Parameters.DeviceIoControl.InputBufferLength ?
                    sizeof(LocalProperty) : IrpStack->Parameters.DeviceIoControl.InputBufferLength
                );

            D_PROP(DbgPrint(
                "MODEMCSA: Property, guid=%08lx-%04x, id=%d, flags=%08lx\n",
                LocalProperty.Set.Data1,
                LocalProperty.Set.Data2,
                LocalProperty.Id,
                LocalProperty.Flags
                );)

            Status = KsPropertyHandler(
                Irp,
                SIZEOF_ARRAY(DevIoPropertySets),
                DevIoPropertySets
                );

            D_PROP(DbgPrint(
                "MODEMCSA: Property, Status=%08lx\n",Status);)

        }
        break;
    case IOCTL_KS_ENABLE_EVENT:
        //
        // Only a rendering device can generate an EOS notification.
        //
        Status=EnableEvent(
            PinInstance->DuplexHandle,
            Irp,
            EventSets,
            SIZEOF_ARRAY(EventSets)
            );

        break;

    case IOCTL_KS_DISABLE_EVENT:

        Status=DisableEvent(
            PinInstance->DuplexHandle,
            Irp
            );

        break;



    case IOCTL_KS_WRITE_STREAM:
//        D_INIT(DbgPrint("MODEMCSA: PinDispatchIoControl: WriteStream\n");)

        FilterInstance = (PFILTER_INSTANCE) IrpStack->FileObject->RelatedFileObject->FsContext;

        ExAcquireFastMutexUnsafe(&FilterInstance->ControlMutex);

        if (PinInstance->PinId != ID_DEVIO_PIN_OUTPUT) {

            if ((PinInstance->DeviceState == KSSTATE_RUN) || (PinInstance->DeviceState == KSSTATE_PAUSE)) {

                Status = KsProbeStreamIrp(
                    Irp,
                    KSPROBE_STREAMWRITE |  (KSPROBE_ALLOCATEMDL | KSPROBE_PROBEANDLOCK),
                    sizeof(KSSTREAM_HEADER)
                    );

                if (NT_SUCCESS(Status)) {

                    IoMarkIrpPending(Irp);
                    Irp->IoStatus.Status=STATUS_PENDING;

                    QueueOutputIrp(
                        PinInstance->DuplexHandle,
                        Irp
                        );

                    ExReleaseFastMutexUnsafe(&FilterInstance->ControlMutex);

                    KickWriteProcessing(PinInstance->DuplexHandle);

                    return STATUS_PENDING;

                } else {

                    D_ERROR(DbgPrint("MODEMCSA: KsProbeStreamFailed %08lx\n",Status);)
                }
            } else {

              D_ERROR(DbgPrint("MODEMCSA: WriteStream: bad pin state %d\n",PinInstance->DeviceState);)

            }
        } else {

            D_ERROR(DbgPrint("MODEMCSA: WriteStream: input pin\n");)
        }

        ExReleaseFastMutexUnsafe(&FilterInstance->ControlMutex);

        Status=STATUS_UNSUCCESSFUL;

        break;

    case IOCTL_KS_READ_STREAM:
//        D_INIT(DbgPrint("MODEMCSA: PinDispatchIoControl: ReadStream\n");)

        FilterInstance = (PFILTER_INSTANCE) IrpStack->FileObject->RelatedFileObject->FsContext;

        ExAcquireFastMutexUnsafe(&FilterInstance->ControlMutex);

        if (PinInstance->PinId != ID_DEVIO_PIN) {

            if ((PinInstance->DeviceState == KSSTATE_RUN) || (PinInstance->DeviceState == KSSTATE_PAUSE)) {

                Status = KsProbeStreamIrp(
                    Irp,
                    KSPROBE_STREAMREAD |  (KSPROBE_ALLOCATEMDL | KSPROBE_PROBEANDLOCK),
                    sizeof(KSSTREAM_HEADER)
                    );

                if (NT_SUCCESS(Status)) {

                    IoMarkIrpPending(Irp);
                    Irp->IoStatus.Status=STATUS_PENDING;

                    QueueOutputIrp(
                        PinInstance->DuplexHandle,
                        Irp
                        );

                    ExReleaseFastMutexUnsafe(&FilterInstance->ControlMutex);

                    KickWriteProcessing(PinInstance->DuplexHandle);

                    return STATUS_PENDING;

                } else {

                    D_ERROR(DbgPrint("MODEMCSA: KsProbeStreamFailed %08lx\n",Status);)
                }
            } else {

              D_ERROR(DbgPrint("MODEMCSA: READStream: bad pin state %d\n",PinInstance->DeviceState);)

            }
        } else {

            D_ERROR(DbgPrint("MODEMCSA: ReadStream: output pin\n");)
        }

        ExReleaseFastMutexUnsafe(&FilterInstance->ControlMutex);

        Status=STATUS_UNSUCCESSFUL;

        break;



    default:
        return KsDefaultDeviceIoCompletion(DeviceObject, Irp);
    }
    Irp->IoStatus.Status = Status;
    IoCompleteRequest(Irp, PriorityBoost);
    return Status;
}


NTSTATUS
AllocatorDispatchCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Forwards the allocator creation request to the default allocator.

Arguments:

    DeviceObject -
        Pointer to the device object

    Irp -
        Pointer to the I/O request packet

Return:

    STATUS_SUCCESS or an appropriate error code.

--*/
{
    NTSTATUS Status;

    D_INIT(DbgPrint("MODEMCSA: AllocatorDispatchCreate\n");)

    Status = KsCreateDefaultAllocator(Irp);
    Irp->IoStatus.Status = Status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return Status;
}



NTSTATUS
PinDeviceState(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    IN OUT PKSSTATE DeviceState
    )

/*++

Routine Description:


Arguments:
	IN PIRP Irp -
		pointer to I/O request packet

	IN PKSPROPERTY Property -
		pointer to the property structure

	IN OUT PKSSTATE DeviceState -
		pointer to a KSSTATE, filled on GET otherwise contains
		the new state to set the pin

Return:
	STATUS_SUCCESS or an appropriate error code

--*/

{

    NTSTATUS                Status=STATUS_SUCCESS;
    PFILE_OBJECT            FileObject;
    PIO_STACK_LOCATION      irpSp;
    PFILTER_INSTANCE        FilterInstance;
    PPIN_INSTANCE           PinInstance;

    irpSp = IoGetCurrentIrpStackLocation( Irp );

//    FilterInstance = (PFILTER_INSTANCE) irpSp->FileObject->RelatedFileObject->FsContext;

    PinInstance = (PPIN_INSTANCE) irpSp->FileObject->FsContext;

//    ExAcquireFastMutexUnsafe(&FilterInstance->ControlMutex);

    //
    // Both sides of the connection must exist.
    //

    //
    // Synchronize pin state changes
    //


    if (Property->Flags & KSPROPERTY_TYPE_GET) {

        if (PinInstance->DeviceState == KSSTATE_PAUSE) {

            Status=STATUS_NO_DATA_DETECTED ;
        }

        *DeviceState = PinInstance->DeviceState;

        D_INIT(DbgPrint("MODEMCSA: PinDeviceState: Get, state %d\n",*DeviceState);)

        Irp->IoStatus.Information = sizeof( KSSTATE );
        goto Exit;
    }

    Irp->IoStatus.Information=0;

    if (PinInstance->DeviceState == *DeviceState) {

        D_INIT(DbgPrint("MODEMCSA: PinDeviceState: Already in state %d\n",*DeviceState);)

        goto Exit;
    }

    switch(*DeviceState) {

        case KSSTATE_RUN: {

            D_INIT(DbgPrint("MODEMCSA: PinDeviceState: RUN\n");)

            Status=StartStream(PinInstance->DuplexHandle);

        }
        break;

        case KSSTATE_PAUSE:

        	D_INIT(DbgPrint("MODEMCSA: PinDeviceState: PAUSE\n");)

                StopStream(PinInstance->DuplexHandle);

        	break;

        case KSSTATE_ACQUIRE:

        	D_INIT(DbgPrint("MODEMCSA: PinDeviceState: ACQUIRE\n");)

                Status=AcquireDevice(PinInstance->DuplexHandle);

        	break;


        case KSSTATE_STOP: {

               PIRP    ModemIrp;

               D_INIT(DbgPrint("MODEMCSA: PinDeviceState: STOP\n");)

               ReleaseDevice(PinInstance->DuplexHandle);

               break;
           }

        default:

            D_INIT(DbgPrint("MODEMCSA: PinDeviceState: Other\n");)
            break;


    }

    if (Status == STATUS_SUCCESS) {

        PinInstance->DeviceState = *DeviceState;

    }

    D_INIT(DbgPrint("MODEMCSA: PinDeviceState: Exit %08lx\n",Status);)
Exit:
//    ExReleaseFastMutexUnsafe(&FilterInstance->ControlMutex);



    return Status;

}


typedef enum
{
    AIPC_REQUEST_WAVEACTION = 1,        // implemented by TSP
    AIPC_COMPLETE_WAVEACTION            // implemented by wave driver

} AIPC_FUNCTION_ID;


// Parameter block for the TSP's AIPC_REQUEST_WAVEACTION function
typedef struct _tagREQ_WAVE_PARAMS
{
    ULONG   dwWaveAction;               // WAVE_ACTION_xxx

} REQ_WAVE_PARAMS, *LPREQ_WAVE_PARAMS;


// Parameter block for the wave driver's AIPC_COMPLETE_WAVEACTION function
typedef struct _tagCOMP_WAVE_PARAMS
{
    int     bResult;
    ULONG   dwWaveAction;               // function that completed (WAVE_ACTION_xxx)

} COMP_WAVE_PARAMS, *LPCOMP_WAVE_PARAMS;


// Parameter block for an Async IPC message
typedef struct _tagAIPC_PARAMS
{

    MODEM_MESSAGE       ModemMessage;
    AIPC_FUNCTION_ID    dwFunctionID;
    union {
        COMP_WAVE_PARAMS    CompParams;         // cast address of this member to
                                         // the correct parameter set

        REQ_WAVE_PARAMS     ReqParams;
    };

} AIPC_PARAMS, *LPAIPC_PARAMS;



NTSTATUS
WaveAction(
    PFILE_OBJECT   ModemFileObject,
    ULONG          WaveAction
    )

{
    NTSTATUS      Status;
    AIPC_PARAMS   Params;
    ULONG         BytesTransfered;

    Params.dwFunctionID=AIPC_REQUEST_WAVEACTION;
    Params.ReqParams.dwWaveAction=WaveAction; //wave play

    Status=KsSynchronousIoControlDevice(
        ModemFileObject,
        KernelMode,
        IOCTL_MODEM_SEND_GET_MESSAGE,
        &Params,
        sizeof(Params),
        &Params,
        sizeof(Params),
        &BytesTransfered
        );

    if (!NT_SUCCESS(Status)) {

        D_ERROR(DbgPrint("WaveAction: Send IO failed\n");)
        goto Exit;
    }

    if (!Params.CompParams.bResult) {

        D_ERROR(DbgPrint("WaveAction: Result bad\n");)
        Status=STATUS_UNSUCCESSFUL;
        goto Exit;
    }

Exit:

    return Status;

}


NTSTATUS
PinAllocatorFraming(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    IN OUT PKSALLOCATOR_FRAMING Framing
    )

{

    NTSTATUS      Status;

    Framing->OptionsFlags=KSALLOCATOR_REQUIREMENTF_SYSTEM_MEMORY;
    Framing->PoolType=PagedPool;

    Framing->Frames=STREAM_BUFFERS;

    Framing->FrameSize=STREAM_BYTES_PER_SAMPLE * STREAM_BUFFER_SIZE;

    Framing->FileAlignment=FILE_QUAD_ALIGNMENT;

    Irp->IoStatus.Information=sizeof(KSALLOCATOR_FRAMING);

    return STATUS_SUCCESS;
}

NTSTATUS
GetStreamAllocator(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    IN OUT ULONG *AllocatorHandle
    )
{
    PPIN_INSTANCE           PinInstance;
    PIO_STACK_LOCATION      irpSp;

    D_INIT(DbgPrint("MODEMCSA: GetStreamAllocator\n");)

    irpSp = IoGetCurrentIrpStackLocation( Irp );
    PinInstance = (PPIN_INSTANCE) irpSp->FileObject->FsContext;

    *AllocatorHandle=0;

    Irp->IoStatus.Information=sizeof(ULONG);

    return STATUS_SUCCESS;


}


NTSTATUS
SetStreamAllocator(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    IN OUT ULONG *AllocatorHandle
    )
{
    PPIN_INSTANCE           PinInstance;
    PIO_STACK_LOCATION      irpSp;
    NTSTATUS                Status=STATUS_SUCCESS;

    D_INIT(DbgPrint("MODEMCSA: SetStreamAllocator\n");)

    irpSp = IoGetCurrentIrpStackLocation( Irp );
    PinInstance = (PPIN_INSTANCE) irpSp->FileObject->FsContext;

    if (AllocatorHandle != NULL) {

        Status=ObReferenceObjectByHandle(
            LongToHandle(*AllocatorHandle),
            0,
            NULL,
            KernelMode,
            &PinInstance->AllocatorObject,
            NULL
            );


        if (NT_SUCCESS(Status)) {

            Irp->IoStatus.Information=sizeof(ULONG);

        } else {

            Irp->IoStatus.Information=0;
        }

    }

    return Status;


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\sys\modemcsa\modemcsa.h ===
/*++

Copyright (c) 1996 Microsoft Corporation.

Module Name:

    msfsio.h

Abstract:

    Internal header file for filter.

--*/

#include <wdm.h>
//#include <ntddk.h>
#include <windef.h>
#define NOBITMAP
#include <mmreg.h>
#include <ks.h>
#include <ksmedia.h>
#include <ksdebug.h>
#include <ntddmodm.h>

#include "..\inc\modemp.h"
#include "util.h"

#define STREAM_BUFFER_SIZE      (400)
#define STREAM_BYTES_PER_SAMPLE (1)
#define SAMPLES_PER_SECOND      (8000)

#define STREAM_BUFFERS          ((SAMPLES_PER_SECOND*STREAM_BYTES_PER_SAMPLE)/STREAM_BUFFER_SIZE)


#define BITS_PER_BYTE   8
#define NANOSECONDS     10000000


extern ULONG  DebugFlags;

#define SINGLE_FILTER

#if DBG

#define DEBUG_FLAG_ERROR  0x0001
#define DEBUG_FLAG_INIT   0x0002
#define DEBUG_FLAG_PNP    0x0004
#define DEBUG_FLAG_POWER  0x0008
#define DEBUG_FLAG_TRACE  0x0010
#define DEBUG_FLAG_INPUT  0x0020
#define DEBUG_FLAG_OUTPUT 0x0040
#define DEBUG_FLAG_PROP   0x0080

#define D_INIT(_x)  if (DebugFlags & DEBUG_FLAG_INIT) {_x}

#define D_PNP(_x)   if (DebugFlags & DEBUG_FLAG_PNP) {_x}

#define D_POWER(_x) if (DebugFlags & DEBUG_FLAG_POWER) {_x}

#define D_TRACE(_x) if (DebugFlags & DEBUG_FLAG_TRACE) {_x}

#define D_ERROR(_x) if (DebugFlags & DEBUG_FLAG_ERROR) {_x}

#define D_INPUT(_x) if (DebugFlags & DEBUG_FLAG_INPUT) {_x}

#define D_OUTPUT(_x) if (DebugFlags & DEBUG_FLAG_OUTPUT) {_x}

#define D_PROP(_x) if (DebugFlags & DEBUG_FLAG_PROP) {_x}

#else

#define D_INIT(_x)  {}

#define D_PNP(_x)   {}

#define D_POWER(_x) {}

#define D_TRACE(_x) {}

#define D_ERROR(_x) {}

#define D_INPUT(_x) {}

#define D_OUTPUT(_x) {}

#define D_PROP(_x) {}

#endif

#define ALLOCATE_PAGED_POOL(_y)  ExAllocatePoolWithTag(PagedPool,_y,'ASCM')

#define ALLOCATE_NONPAGED_POOL(_y) ExAllocatePoolWithTag(NonPagedPool,_y,'ASCM')

#define FREE_POOL(_x) {ExFreePool(_x);_x=NULL;};


#if (DBG)
#define STR_MODULENAME  "msfsio: "
#endif // DBG

extern const KSPIN_DESCRIPTOR PinDescriptors[2];

extern const KSDATARANGE_AUDIO PinDevIoRange;

#define ID_DEVIO_PIN 0
#define ID_DEVIO_PIN_OUTPUT 1

#if 0
typedef enum {
    FILTER_TYPE_READER = 1,
    FILTER_TYPE_WRITER
} FILTER_TYPE;
#endif



#define INPUT_PIN   1
#define OUTPUT_PIN  2


typedef struct _DUPLEX_CONTROL {

    BOOLEAN          Initialized;

    ULONG            OpenCount;
    ULONG            OpenFlags;
    ULONG            AcquireCount;
    ULONG            AcquireFlags;

    ULONG            StartCount;
    ULONG            StartFlags;

    FAST_MUTEX          ControlMutex;

    PFILE_OBJECT     ModemFileObject;

    LIST_ENTRY              EventQueue;
    FAST_MUTEX              EventQueueLock;


    KSPIN_LOCK              SpinLock;

    PUNICODE_STRING          ModemName;

    struct {

        BUFFER_CONTROL           BufferControl;

#ifdef DBG
        LONG                    IrpsDownStream;
        LONG                    FilledModemIrps;
        LONG                    CurrentFilledIrps;
        LONG                    EmptyIrps;
        LONG                    WorkItemsOutstanding;

#endif


        BOOLEAN                 ModemStreamDead;

        LIST_ENTRY              FilledModemIrpQueue;

        PIRP                    CurrentFilledModemIrp;

        KSPIN_LOCK              FilledModemIrpSpinLock;

        ULONG                   BytesUsedInModemIrp;

        LIST_ENTRY              ReadStreamIrpQueue;

        PIRP                    CurrentReadStreamIrp;

        KSPIN_LOCK              ReadStreamSpinLock;



        ULONG                   IrpsInModemDriver;

        KEVENT                  ModemDriverEmpty;

        PFILE_OBJECT            DownStreamFileObject;

        LONG                    BytesToThrowAway;

        ULONG                   BytesPerSample;

        LONGLONG                StreamPosition;
    } Input;

    struct {

        LIST_ENTRY              WriteStreamIrpQueue;
        PIRP                    CurrentIrp;
        ULONG                   OutstandingChildIrps;

        LIST_ENTRY              FreeReadStreamIrps;
        PFILE_OBJECT            DownStreamFileObject;

        ULONG                   BytesPerSample;

        BUFFER_CONTROL          BufferControl;
    } Output;

} DUPLEX_CONTROL, *PDUPLEX_CONTROL;

typedef struct {

    KSDEVICE_HEADER    Header;
    PDEVICE_OBJECT     Pdo;
    PDEVICE_OBJECT     LowerDevice;
    UNICODE_STRING     InterfaceName;

    GUID               PermanentGuid;

    DUPLEX_CONTROL     DuplexControl;

    UNICODE_STRING     ModemDeviceName;

    ULONG             DuplexSupport;

} DEVICE_INSTANCE, *PDEVICE_INSTANCE;



typedef struct {

    KSOBJECT_HEADER     Header;
    ULONG               PinId;

    KSSTATE                 DeviceState;

    PVOID                   AllocatorObject;

    KSPIN_LOCK              SpinLock;

    PVOID                   DuplexHandle;

} PIN_INSTANCE, *PPIN_INSTANCE;



typedef struct {
    KSOBJECT_HEADER     Header;
    FAST_MUTEX          ControlMutex;

    PDEVICE_OBJECT      DeviceObject;
    PFILE_OBJECT        PinFileObjects[2];

} FILTER_INSTANCE, *PFILTER_INSTANCE;




NTSTATUS
PnpAddDevice(
    IN PDRIVER_OBJECT   DriverObject,
    IN PDEVICE_OBJECT   PhysicalDeviceObject
    );
NTSTATUS
PinDispatchCreate(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );



VOID
ProcessWriteIrps(
    PDUPLEX_CONTROL    DuplexControl
    );

NTSTATUS
InputPinDeviceState(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    IN OUT PKSSTATE DeviceState
    );

NTSTATUS
OutputPinDeviceState(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    IN OUT PKSSTATE DeviceState
    );



//
//  Start playback
//
#define  WAVE_ACTION_START_PLAYBACK       (0x00)

//
//  Start RECORD
//
#define  WAVE_ACTION_START_RECORD         (0x01)

//
//  Start DUPLEX
//
#define  WAVE_ACTION_START_DUPLEX         (0x02)


//
//  Stop streaming
//
#define  WAVE_ACTION_STOP_STREAMING       (0x04)

//
//  Abort streaming
//
#define  WAVE_ACTION_ABORT_STREAMING      (0x05)


//
//  enable wave actions to handset
//
#define  WAVE_ACTION_OPEN_HANDSET         (0x06)

//
//  disable handset actions
//
#define  WAVE_ACTION_CLOSE_HANDSET        (0x07)





NTSTATUS
WaveAction(
    PFILE_OBJECT   ModemFileObject,
    ULONG          WaveAction
    );


NTSTATUS
GetFileObjectForModem(
    PFILTER_INSTANCE    FilterInstance,
    DWORD               Flags,
    PFILE_OBJECT       *ReturnFileObject
    );

NTSTATUS
FreeModemFileObject(
    PFILTER_INSTANCE    FilterInstance,
    DWORD               Flags
    );


PVOID
InitializeDuplexControl(
    PDUPLEX_CONTROL    DuplexControl,
    PUNICODE_STRING    ModemDeviceName
    );

VOID
CleanUpDuplexControl(
    PDUPLEX_CONTROL    DuplexControl
    );


PVOID
OpenDuplexControl(
    PDEVICE_INSTANCE    DeviceInstance,
    DWORD               Flags,
    HANDLE              DownStreamFilterHandle,
    DWORD               BitsPerSample
    );



VOID
CloseDuplexControl(
    PVOID               Handle
    );

VOID
QueueOutputIrp(
    PVOID        DuplexHandle,
    PIRP         Irp
    );

PIRP
AllocateIrpForModem(
    PFILE_OBJECT   FileObject,
    ULONG          Length
    );

PIRP
AllocateStreamIrp(
    PFILE_OBJECT    FileObject,
    PIRP            ModemIrp
    );

PIRP
AllocateOutputIrpPair(
    PFILE_OBJECT    ModemFileObject,
    PFILE_OBJECT    StreamFileObject,
    ULONG           Length
    );


VOID
FreeInputIrps(
    PIRP    ModemIrp
    );



NTSTATUS
AcquireDevice(
    PVOID        DuplexHandle
    );

VOID
ReleaseDevice(
    PVOID      DuplexHandle
    );

NTSTATUS
StartStream(
    PVOID        DuplexHandle
    );

VOID
StopStream(
    PVOID        DuplexHandle
    );

NTSTATUS
EnableEvent(
    PVOID        DuplexHandle,
    PIRP         Irp,
    const KSEVENT_SET* EventSets,
    ULONG        EventCount
    );

NTSTATUS
DisableEvent(
    PVOID        DuplexHandle,
    PIRP         Irp
    );

VOID
FreeEventList(
    PVOID        DuplexHandle,
    PIRP         Irp
    );


VOID
StartRead(
    PDUPLEX_CONTROL     DuplexControl
    );

VOID
KickWriteProcessing(
    PVOID        DuplexHandle
    );


VOID
GenerateEvent(
    PVOID        DuplexHandle
    );

VOID
FinishUpIrp(
    PDUPLEX_CONTROL    DuplexControl,
    PIRP               ModemIrp
    );

VOID
ProcessReadStreamIrp(
    PDUPLEX_CONTROL    DuplexControl
    );




VOID
FreeOutputPair(
    PIRP    StreamIrp
    );


NTSTATUS
FilterDispatchCreate(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\sys\modemcsa\util.h ===
/*++

Copyright (c) 1996 Microsoft Corporation.

Module Name:

    util.h

Abstract:

    Internal header file for filter.

--*/

typedef struct _BUFFER_CONTROL {
    KEVENT         Event;
    LIST_ENTRY     IrpQueue;
    KSPIN_LOCK     SpinLock;

    LONG           IrpsInUse;
    BOOLEAN        Active;

} BUFFER_CONTROL, *PBUFFER_CONTROL;



VOID
InitializeBufferControl(
    PBUFFER_CONTROL    BufferControl
    );

VOID
AddBuffer(
    PBUFFER_CONTROL    BufferControl,
    PIRP               Irp
    );

PIRP
EmptyBuffers(
    PBUFFER_CONTROL   BufferControl
    );

PIRP
TryToRemoveAnIrp(
    PBUFFER_CONTROL   BufferControl
    );

VOID
ReturnAnIrp(
    PBUFFER_CONTROL    BufferControl,
    PIRP               Irp
    );

VOID
PauseBufferQueue(
    PBUFFER_CONTROL     BufferControl,
    BOOLEAN             WaitForIdle
    );

VOID
ActivateBufferQueue(
    PBUFFER_CONTROL     BufferControl
    );


VOID
QueueIrpToListTail(
    PLIST_ENTRY        ListToUse,
    PKSPIN_LOCK        SpinLock,
    PIRP               Irp
    );

PIRP
RemoveIrpFromListHead(
    PLIST_ENTRY        ListToUse,
    PKSPIN_LOCK        SpinLock
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\sys\rootmdm\init.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    init.c

Abstract:

    This module contains the code that is very specific to initialization
    and unload operations in the modem driver

Author:

    Brian Lieuallen 6-21-1997

Environment:

    Kernel mode

Revision History :

--*/


#include "internal.h"

#if DBG

ULONG DebugFlags=0;

#endif

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );


NTSTATUS
FakeModemAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT Pdo
    );

VOID
FakeModemUnload(
    IN PDRIVER_OBJECT DriverObject
    );


NTSTATUS
RootModemPassThrough(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );


NTSTATUS
GetAttachedPort(
    PDEVICE_OBJECT   Pdo,
    PUNICODE_STRING  PortName
    );


NTSTATUS
RootModemWmi(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,DriverEntry)
#pragma alloc_text(PAGE,FakeModemAddDevice)
#pragma alloc_text(PAGE,GetAttachedPort)
#pragma alloc_text(PAGE,RootModemWmi)
#endif



NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    The entry point that the system point calls to initialize
    any driver.

Arguments:

    DriverObject - Just what it says,  really of little use
    to the driver itself, it is something that the IO system
    cares more about.

    PathToRegistry - points to the entry for this driver
    in the current control set of the registry.

Return Value:

    STATUS_SUCCESS if we could initialize a single device,
    otherwise STATUS_NO_SUCH_DEVICE.

--*/

{

    NTSTATUS   status;


    RTL_QUERY_REGISTRY_TABLE paramTable[3];
    ULONG zero = 0;
    ULONG debugLevel = 0;
    ULONG shouldBreak = 0;
    PWCHAR path;
    ULONG   i;


    D_INIT(DbgPrint("ROOTMODEM: DriverEntry\n");)

    //
    // Since the registry path parameter is a "counted" UNICODE string, it
    // might not be zero terminated.  For a very short time allocate memory
    // to hold the registry path zero terminated so that we can use it to
    // delve into the registry.
    //
    // NOTE NOTE!!!! This is not an architected way of breaking into
    // a driver.  It happens to work for this driver because the author
    // likes to do things this way.
    //

    path = ALLOCATE_PAGED_POOL(RegistryPath->Length+sizeof(WCHAR));

    if (path != NULL) {

        RtlZeroMemory(
            &paramTable[0],
            sizeof(paramTable)
            );
        RtlZeroMemory(
            path,
            RegistryPath->Length+sizeof(WCHAR)
            );
        RtlMoveMemory(
            path,
            RegistryPath->Buffer,
            RegistryPath->Length
            );
        paramTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
        paramTable[0].Name = L"BreakOnEntry";
        paramTable[0].EntryContext = &shouldBreak;
        paramTable[0].DefaultType = REG_DWORD;
        paramTable[0].DefaultData = &zero;
        paramTable[0].DefaultLength = sizeof(ULONG);
        paramTable[1].Flags = RTL_QUERY_REGISTRY_DIRECT;
        paramTable[1].Name = L"DebugFlags";
        paramTable[1].EntryContext = &debugLevel;
        paramTable[1].DefaultType = REG_DWORD;
        paramTable[1].DefaultData = &zero;
        paramTable[1].DefaultLength = sizeof(ULONG);

        if (!NT_SUCCESS(RtlQueryRegistryValues(
                            RTL_REGISTRY_ABSOLUTE | RTL_REGISTRY_OPTIONAL,
                            path,
                            &paramTable[0],
                            NULL,
                            NULL
                            ))) {

            shouldBreak = 0;
            debugLevel = 0;

        }

        FREE_POOL(path);
    }

#if DBG
    DebugFlags= debugLevel;
#endif

    if (shouldBreak) {

        DbgBreakPoint();

    }


    //
    //  pnp driver entry point
    //
    DriverObject->DriverExtension->AddDevice = FakeModemAddDevice;


    //
    // Initialize the Driver Object with driver's entry points
    //

    DriverObject->DriverUnload = FakeModemUnload;

    for (i=0; i < IRP_MJ_MAXIMUM_FUNCTION; i++) {

        DriverObject->MajorFunction[i]=RootModemPassThrough;
    }

    DriverObject->MajorFunction[IRP_MJ_CREATE]            = FakeModemOpen;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]             = FakeModemClose;
    DriverObject->MajorFunction[IRP_MJ_PNP]               = FakeModemPnP;

    DriverObject->MajorFunction[IRP_MJ_POWER]             = FakeModemPower;

    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL]    = RootModemWmi;

    return STATUS_SUCCESS;

}


#if DBG
NTSTATUS
RootModemDebugIoCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID    Context
    )
{
#if 0
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);

#endif
    return STATUS_SUCCESS;

}
#endif

#define NDIS_NOT_BROKEN 1


NTSTATUS
RootModemPassThrough(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

{

    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PDEVICE_OBJECT    AttachedDevice=deviceExtension->AttachedDeviceObject;


    if (AttachedDevice != NULL) {

#ifdef NDIS_NOT_BROKEN
#if DBG

        NTSTATUS  Status;
        IO_STACK_LOCATION  CurrentStack;

        RtlCopyMemory(&CurrentStack,IoGetCurrentIrpStackLocation(Irp), sizeof(CurrentStack));

        IoCopyCurrentIrpStackLocationToNext(Irp);

        IoSetCompletionRoutine(
                 Irp,
                 RootModemDebugIoCompletion,
                 deviceExtension,
                 TRUE,
                 TRUE,
                 TRUE
                 );


        IoMarkIrpPending( Irp );

        Status = IoCallDriver(
                   AttachedDevice,
                   Irp
                   );

        if (!(NT_SUCCESS(Status))) {
            D_ERROR(DbgPrint("ROOTMODEM: IoCallDriver() mj=%d mn=%d Arg3=%08lx failed %08lx\n",
            CurrentStack.MajorFunction,
            CurrentStack.MinorFunction,
            CurrentStack.Parameters.Others.Argument3,
            Status);)
        }

        Status = STATUS_PENDING;

        return Status;


#else
        IoSkipCurrentIrpStackLocation(Irp);

        return IoCallDriver(
                   AttachedDevice,
                   Irp
                   );
#endif //DBG
#else

        PIO_STACK_LOCATION NextSp = IoGetNextIrpStackLocation(Irp);

        IoCopyCurrentIrpStackLocationToNext(Irp);
        NextSp->FileObject=deviceExtension->AttachedFileObject;

        return IoCallDriver(
                   AttachedDevice,
                   Irp
                   );
#endif
    } else {

        Irp->IoStatus.Status = STATUS_PORT_DISCONNECTED;
        Irp->IoStatus.Information=0L;

        IoCompleteRequest(
            Irp,
            IO_NO_INCREMENT
            );

        return STATUS_PORT_DISCONNECTED;

    }

}



VOID
FakeModemUnload(
    IN PDRIVER_OBJECT DriverObject
    )
{

    D_INIT(DbgPrint("ROOTMODEM: Unload\n");)

    return;

}

NTSTATUS
FakeModemAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT Pdo
    )
/*++

Routine Description:

    Create a FDO for our device an attach it to the PDO



Arguments:

    DriverObject - Just what it says,  really of little use
    to the driver itself, it is something that the IO system
    cares more about.

    Pdo - Physical device object created by a bus enumerator to represent
          the hardware

Return Value:

    STATUS_SUCCESS if we could initialize a single device,
    otherwise STATUS_NO_SUCH_DEVICE.

--*/

{
    NTSTATUS    status=STATUS_SUCCESS;
    PDEVICE_OBJECT     Fdo;
    PDEVICE_EXTENSION  DeviceExtension;



    //
    //  create our FDO device object
    //
    status=IoCreateDevice(
        DriverObject,
        sizeof(DEVICE_EXTENSION),
        NULL,
        FILE_DEVICE_SERIAL_PORT,
        FILE_AUTOGENERATED_DEVICE_NAME,
        FALSE,
        &Fdo
        );

    if (status != STATUS_SUCCESS) {

        D_ERROR(DbgPrint("ROOTMODEM: Could create FDO\n");)

        return status;
    }



    Fdo->Flags |= DO_BUFFERED_IO | DO_POWER_PAGABLE;


    DeviceExtension=Fdo->DeviceExtension;

    DeviceExtension->DeviceObject=Fdo;

    DeviceExtension->Pdo=Pdo;

    status=GetAttachedPort(
        Pdo,
        &DeviceExtension->PortName
        );

    if (!NT_SUCCESS(status)) {

        D_ERROR(DbgPrint("ROOTMODEM: Could not get attached port name\n");)

        IoDeleteDevice(Fdo);

        return status;
    }


    //
    //  attach our FDO to the PDO supplied
    //
    DeviceExtension->LowerDevice=IoAttachDeviceToDeviceStack(
        Fdo,
        Pdo
        );



    if (NULL == DeviceExtension->LowerDevice) {
        //
        //  could not attach
        //
        D_ERROR(DbgPrint("ROOTMODEM: Could not attach to PDO\n");)

        if (DeviceExtension->PortName.Buffer != NULL) {

            FREE_POOL(DeviceExtension->PortName.Buffer);
        }

        IoDeleteDevice(Fdo);

        return STATUS_UNSUCCESSFUL;
    }

    //
    //  clear this flag so the device object can be used
    //
    Fdo->Flags &= ~(DO_DEVICE_INITIALIZING);

    //
    //  init the spinlock
    //
    KeInitializeSpinLock(
        &DeviceExtension->SpinLock
        );


    //
    //  initialize the device extension
    //
    DeviceExtension->ReferenceCount=1;

    DeviceExtension->Removing=FALSE;

    DeviceExtension->OpenCount=0;

    KeInitializeEvent(
        &DeviceExtension->RemoveEvent,
        NotificationEvent,
        FALSE
        );

    ExInitializeResourceLite(
        &DeviceExtension->Resource
        );

    return STATUS_SUCCESS;

}








NTSTATUS
GetAttachedPort(
    PDEVICE_OBJECT   Pdo,
    PUNICODE_STRING  PortName
    )

{

    UNICODE_STRING   attachedDevice;
    RTL_QUERY_REGISTRY_TABLE paramTable[2];
    ACCESS_MASK              accessMask = FILE_READ_ACCESS;
    NTSTATUS                 Status;
    HANDLE                   instanceHandle;

    RtlInitUnicodeString(
        PortName,
        NULL
        );

    RtlInitUnicodeString(
        &attachedDevice,
        NULL
        );



    attachedDevice.MaximumLength = sizeof(WCHAR)*256;
    attachedDevice.Buffer = ALLOCATE_PAGED_POOL(attachedDevice.MaximumLength+sizeof(UNICODE_NULL));

    if (!attachedDevice.Buffer) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Given our device instance go get a handle to the Device.
    //
    Status=IoOpenDeviceRegistryKey(
        Pdo,
        PLUGPLAY_REGKEY_DRIVER,
        accessMask,
        &instanceHandle
        );

    if (!NT_SUCCESS(Status)) {

        FREE_POOL(attachedDevice.Buffer);
        return Status;
    }

    RtlZeroMemory(
        &paramTable[0],
        sizeof(paramTable)
        );

    paramTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[0].Name = L"AttachedTo";
    paramTable[0].EntryContext = &attachedDevice;
    paramTable[0].DefaultType = REG_SZ;
    paramTable[0].DefaultData = L"";
    paramTable[0].DefaultLength = 0;


    Status= RtlQueryRegistryValues(
                        RTL_REGISTRY_HANDLE,
                        instanceHandle,
                        &paramTable[0],
                        NULL,
                        NULL
                        );

    //
    //  done with the handle close it now
    //
    ZwClose(instanceHandle);
    instanceHandle=NULL;


    if (!NT_SUCCESS(Status)) {

        FREE_POOL(attachedDevice.Buffer);
        return Status;
    }


    //
    // We have the attached device name.  Append it to the
    // object directory.
    //


    PortName->MaximumLength = sizeof(OBJECT_DIRECTORY) + attachedDevice.Length+sizeof(WCHAR);

    PortName->Buffer = ALLOCATE_PAGED_POOL(
                                   PortName->MaximumLength
                                   );

    if (PortName->Buffer == NULL) {

        Status = STATUS_INSUFFICIENT_RESOURCES;
        FREE_POOL(attachedDevice.Buffer);
        return Status;
    }

    RtlZeroMemory(
        PortName->Buffer,
        PortName->MaximumLength
        );

    RtlAppendUnicodeToString(
        PortName,
        OBJECT_DIRECTORY
        );

    RtlAppendUnicodeStringToString(
        PortName,
        &attachedDevice
        );

    FREE_POOL(
        attachedDevice.Buffer
        );

    return STATUS_SUCCESS;

}


NTSTATUS
RootModemWmi(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

{

    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;

    return ForwardIrp(deviceExtension->LowerDevice,Irp);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\sys\rootmdm\internal.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    internal.h

Abstract:

    This module contains the code that is very specific to initialization
    and unload operations in the modem driver

Author:

    Brian Lieuallen 6-21-1997

Environment:

    Kernel mode

Revision History :

--*/

//#include <wdm.h>
#include <ntddk.h>
#include <ntddser.h>
#include <ntddmodm.h>

#define PNP_DEBUG 1

#define ROOTMODEM_POWER 1


#define ALLOCATE_PAGED_POOL(_y)  ExAllocatePoolWithTag(PagedPool,_y,'MDMR')

#define ALLOCATE_NONPAGED_POOL(_y) ExAllocatePoolWithTag(NonPagedPool,_y,'MDMR')

#define FREE_POOL(_x) {ExFreePool(_x);_x=NULL;};



extern ULONG  DebugFlags;

#if DBG

#define DEBUG_FLAG_ERROR  0x0001
#define DEBUG_FLAG_INIT   0x0002
#define DEBUG_FLAG_PNP    0x0003
#define DEBUG_FLAG_POWER  0x0008
#define DEBUG_FLAG_TRACE  0x0010


#define D_INIT(_x)  if (DebugFlags & DEBUG_FLAG_INIT) {_x}

#define D_PNP(_x)   if (DebugFlags & DEBUG_FLAG_PNP) {_x}

#define D_POWER(_x) if (DebugFlags & DEBUG_FLAG_POWER) {_x}

#define D_TRACE(_x) if (DebugFlags & DEBUG_FLAG_TRACE) {_x}

#define D_ERROR(_x) if (DebugFlags & DEBUG_FLAG_ERROR) {_x}

#else

#define D_INIT(_x)  {}

#define D_PNP(_x)   {}

#define D_POWER(_x) {}

#define D_TRACE(_x) {}

#define D_ERROR(_x) {}

#endif


#define OBJECT_DIRECTORY L"\\DosDevices\\"



typedef struct _DEVICE_EXTENSION {

    PDEVICE_OBJECT   AttachedDeviceObject;
    PFILE_OBJECT     AttachedFileObject;

    PDEVICE_OBJECT   DeviceObject;

    PDEVICE_OBJECT   Pdo;

    PDEVICE_OBJECT   LowerDevice;

    KSPIN_LOCK       SpinLock;

    LONG             ReferenceCount;

    ULONG            OpenCount;

    BOOLEAN          Removing;

    KEVENT           RemoveEvent;

    ERESOURCE        Resource;

    UNICODE_STRING   PortName;

#ifdef ROOTMODEM_POWER
    DEVICE_POWER_STATE  SystemPowerStateMap[PowerSystemMaximum];

    SYSTEM_POWER_STATE SystemWake;
    DEVICE_POWER_STATE DeviceWake;
#endif

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;





//
//  dispatch handlers
//

NTSTATUS
FakeModemPnP(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );


NTSTATUS
FakeModemPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );


NTSTATUS
FakeModemOpen(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FakeModemClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );



//
//  misc. public services
//




NTSTATUS
CheckStateAndAddReference(
    PDEVICE_OBJECT   DeviceObject,
    PIRP             Irp
    );


VOID
RemoveReferenceAndCompleteRequest(
    PDEVICE_OBJECT    DeviceObject,
    PIRP              Irp,
    NTSTATUS          StatusToReturn
    );


VOID
RemoveReference(
    PDEVICE_OBJECT    DeviceObject
    );


#define RemoveReferenceForDispatch  RemoveReference
#define RemoveReferenceForIrp       RemoveReference

#define LEAVE_NEXT_AS_IS      FALSE
#define COPY_CURRENT_TO_NEXT  TRUE

NTSTATUS
WaitForLowerDriverToCompleteIrp(
    PDEVICE_OBJECT    TargetDeviceObject,
    PIRP              Irp,
    BOOLEAN           CopyCurrentToNext
    );



NTSTATUS
ForwardIrp(
    PDEVICE_OBJECT   NextDevice,
    PIRP   Irp
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\sys\rootmdm\open.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    open.c

Abstract:

    This module contains the code that is very specific to initialization
    and unload operations in the modem driver

Author:

    Brian Lieuallen 6-21-1997

Environment:

    Kernel mode

Revision History :

--*/


#include "internal.h"

NTSTATUS
EnableDisableSerialWaitWake(
    PDEVICE_EXTENSION    deviceExtension,
    BOOLEAN              Enable
    );


#pragma alloc_text(PAGE,FakeModemOpen)
#pragma alloc_text(PAGE,FakeModemClose)
#pragma alloc_text(PAGE,WaitForLowerDriverToCompleteIrp)




NTSTATUS
FakeModemOpen(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

{

    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    NTSTATUS          status=STATUS_UNSUCCESSFUL;
    ACCESS_MASK              accessMask = FILE_ALL_ACCESS;

    //
    //  make sure the device is ready for irp's
    //
    status=CheckStateAndAddReference(
        DeviceObject,
        Irp
        );

    if (STATUS_SUCCESS != status) {
        //
        //  not accepting irp's. The irp has already been complted
        //
        return status;

    }

    KeEnterCriticalRegion();

    ExAcquireResourceExclusiveLite(
        &deviceExtension->Resource,
        TRUE
        );

    if (deviceExtension->OpenCount != 0) {
        //
        //  serial devices are exclusive
        //
        status=STATUS_ACCESS_DENIED;

    } else {

        //
        // Open up the attached device.
        //

        deviceExtension->AttachedFileObject = NULL;
        deviceExtension->AttachedDeviceObject = NULL;

        status = IoGetDeviceObjectPointer(
                     &deviceExtension->PortName,
                     accessMask,
                     &deviceExtension->AttachedFileObject,
                     &deviceExtension->AttachedDeviceObject
                     );

        if (!NT_SUCCESS(status)) {

            D_ERROR(DbgPrint("ROOTMODEM: IoGetDeviceObjectPointer() failed %08lx\n",status);)

            Irp->IoStatus.Status = status;
            goto leaveOpen;

        } else {

            PIRP   TempIrp;
            KEVENT Event;
            IO_STATUS_BLOCK   IoStatus;

            ObReferenceObject(deviceExtension->AttachedDeviceObject);

            KeInitializeEvent(
                &Event,
                NotificationEvent,
                FALSE
                );

            //
            //  build an IRP to send to the attched to driver to see if modem
            //  is in the stack.
            //
            TempIrp=IoBuildDeviceIoControlRequest(
                IOCTL_MODEM_CHECK_FOR_MODEM,
                deviceExtension->AttachedDeviceObject,
                NULL,
                0,
                NULL,
                0,
                FALSE,
                &Event,
                &IoStatus
                );

            if (TempIrp == NULL) {

                status = STATUS_INSUFFICIENT_RESOURCES;

            } else {

                PIO_STACK_LOCATION NextSp = IoGetNextIrpStackLocation(Irp);
                NextSp->FileObject=deviceExtension->AttachedFileObject;

                status = IoCallDriver(deviceExtension->AttachedDeviceObject, TempIrp);

                if (status == STATUS_PENDING) {

                     D_ERROR(DbgPrint("ROOTMODEM: Waiting for PDO\n");)

                     KeWaitForSingleObject(
                         &Event,
                         Executive,
                         KernelMode,
                         FALSE,
                         NULL
                         );

                     status=IoStatus.Status;
                }

                TempIrp=NULL;

                if (status == STATUS_SUCCESS) {
                    //
                    //  if success, then modem.sys is layered under us, fail
                    //
                    status = STATUS_PORT_DISCONNECTED;

                    D_ERROR(DbgPrint("ROOTMODEM: layered over PnP modem, failing open\n");)

                } else {
                    //
                    //  it didn't succeed so modem must not be below us
                    //
                    status=STATUS_SUCCESS;
                }
            }
        }
    }


leaveOpen:


    if (!NT_SUCCESS(status)) {
        //
        //  failed remove ref's
        //
        PVOID    Object;

        Object=InterlockedExchangePointer(&deviceExtension->AttachedFileObject,NULL);

        if (Object != NULL) {

            ObDereferenceObject(Object);
        }

        Object=InterlockedExchangePointer(&deviceExtension->AttachedDeviceObject,NULL);

        if (Object != NULL) {

            ObDereferenceObject(Object);
        }

    } else {
        //
        //  opened successfully
        //
        deviceExtension->OpenCount++;

        //
        // We have the device open.  Increment our irp stack size
        // by the stack size of the attached device.
        //
        {
            UCHAR    StackDepth;

            StackDepth= deviceExtension->AttachedDeviceObject->StackSize > deviceExtension->LowerDevice->StackSize ?
                            deviceExtension->AttachedDeviceObject->StackSize : deviceExtension->LowerDevice->StackSize;

            DeviceObject->StackSize = StackDepth + 1;
        }
    }



    Irp->IoStatus.Information = 0;


    ExReleaseResourceLite(&deviceExtension->Resource);

    KeLeaveCriticalRegion();

    RemoveReferenceAndCompleteRequest(
        DeviceObject,
        Irp,
        status
        );

    RemoveReferenceForDispatch(DeviceObject);

    return status;
}





NTSTATUS
FakeModemClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

{

    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    NTSTATUS          status=STATUS_SUCCESS;
    PVOID             Object;


    KeEnterCriticalRegion();

    ExAcquireResourceExclusiveLite(
        &deviceExtension->Resource,
        TRUE
        );

    deviceExtension->OpenCount--;

    Object=InterlockedExchangePointer(&deviceExtension->AttachedFileObject,NULL);

    if (Object != NULL) {

        ObDereferenceObject(Object);
    }

    Object=InterlockedExchangePointer(&deviceExtension->AttachedDeviceObject,NULL);

    if (Object != NULL) {

        ObDereferenceObject(Object);
    }

    ExReleaseResourceLite(&deviceExtension->Resource);

    KeLeaveCriticalRegion();


    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(
        Irp,
        IO_SERIAL_INCREMENT
        );

    return status;
}




NTSTATUS
IoCompletionSetEvent(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT pdoIoCompletedEvent
    )
{


#if DBG
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);

    UCHAR    *Pnp="PnP";
    UCHAR    *Power="Power";
    UCHAR    *Create="Create";
    UCHAR    *Close="Close";
    UCHAR    *Other="Other";


    PUCHAR   IrpType;

    switch(irpSp->MajorFunction) {

        case IRP_MJ_PNP:

            IrpType=Pnp;
            break;

        case IRP_MJ_CREATE:

            IrpType=Create;
            break;

        case IRP_MJ_CLOSE:

            IrpType=Close;
            break;

        default:

            IrpType=Other;
            break;

    }

    D_PNP(DbgPrint("ROOTMODEM: Setting event for %s wait, completed with %08lx\n",IrpType,Irp->IoStatus.Status);)
#endif

    KeSetEvent(pdoIoCompletedEvent, IO_NO_INCREMENT, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}



NTSTATUS
WaitForLowerDriverToCompleteIrp(
    PDEVICE_OBJECT    TargetDeviceObject,
    PIRP              Irp,
    BOOLEAN           CopyCurrentToNext
    )

{
    NTSTATUS         Status;
    KEVENT           Event;

#if DBG
    PIO_STACK_LOCATION  IrpSp=IoGetCurrentIrpStackLocation(Irp);
#endif

    KeInitializeEvent(
        &Event,
        NotificationEvent,
        FALSE
        );


    if (CopyCurrentToNext) {

        IoCopyCurrentIrpStackLocationToNext(Irp);
    }

    IoSetCompletionRoutine(
                 Irp,
                 IoCompletionSetEvent,
                 &Event,
                 TRUE,
                 TRUE,
                 TRUE
                 );

    Status = IoCallDriver(TargetDeviceObject, Irp);

    if (Status == STATUS_PENDING) {

         D_ERROR(DbgPrint("ROOTMODEM: Waiting for PDO\n");)

         KeWaitForSingleObject(
             &Event,
             Executive,
             KernelMode,
             FALSE,
             NULL
             );
    }

#if DBG
    ASSERT(IrpSp == IoGetCurrentIrpStackLocation(Irp));

    RtlZeroMemory(&Event,sizeof(Event));
#endif

    return Irp->IoStatus.Status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\sys\rootmdm\pnp.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    pnp.c

Abstract:

    This module contains the code that is very specific to initialization
    and unload operations in the modem driver

Author:

    Brian Lieuallen 6-21-1997

Environment:

    Kernel mode

Revision History :

--*/


#include "internal.h"

NTSTATUS ForwardIrp(
    PDEVICE_OBJECT   NextDevice,
    PIRP   Irp
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,FakeModemPnP)
#pragma alloc_text(PAGE,ForwardIrp)
#endif



#if DBG

NTSTATUS
UnhandledPnpIrpCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);

    D_PNP(DbgPrint("ROOTMODEM: Forwarded IRP, MN func=%d, completed with %08lx\n",irpSp->MinorFunction,Irp->IoStatus.Status);)

    return STATUS_SUCCESS;

}

#endif

NTSTATUS ForwardIrp(
    PDEVICE_OBJECT   NextDevice,
    PIRP   Irp
    )

{

#if DBG
            IoMarkIrpPending(Irp);
            IoCopyCurrentIrpStackLocationToNext(Irp);
            IoSetCompletionRoutine(
                         Irp,
                         UnhandledPnpIrpCompletion,
                         NULL,
                         TRUE,
                         TRUE,
                         TRUE
                         );

            IoCallDriver(NextDevice, Irp);

            return STATUS_PENDING;
#else
            IoSkipCurrentIrpStackLocation(Irp);
            return IoCallDriver(NextDevice, Irp);
#endif

}




NTSTATUS
FakeModemPnP(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

{

    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS    status;


    switch (irpSp->MinorFunction) {

        case IRP_MN_START_DEVICE:

            D_PNP(DbgPrint("ROOTMODEM: IRP_MN_START_DEVICE\n");)

            //
            //  Send this down to the PDO first so the bus driver can setup
            //  our resources so we can talk to the hardware
            //

            status=WaitForLowerDriverToCompleteIrp(
                deviceExtension->LowerDevice,
                Irp,
                COPY_CURRENT_TO_NEXT
                );


            Irp->IoStatus.Status = status;
            Irp->IoStatus.Information=0L;
            IoCompleteRequest(
                Irp,
                IO_NO_INCREMENT
                );

            return status;

        case IRP_MN_QUERY_DEVICE_RELATIONS: {

            PDEVICE_RELATIONS    CurrentRelations=(PDEVICE_RELATIONS)Irp->IoStatus.Information;

            D_PNP(DbgPrint("ROOTMODEM: IRP_MN_QUERY_DEVICE_RELATIONS type=%d\n",irpSp->Parameters.QueryDeviceRelations.Type);)
            D_PNP(DbgPrint("                                         Information=%08lx\n",Irp->IoStatus.Information);)


            return ForwardIrp(deviceExtension->LowerDevice, Irp);

        }

        case IRP_MN_QUERY_REMOVE_DEVICE:

            D_PNP(DbgPrint("ROOTMODEM: IRP_MN_QUERY_REMOVE_DEVICE\n");)

            Irp->IoStatus.Status=STATUS_SUCCESS;

            return ForwardIrp(deviceExtension->LowerDevice, Irp);

        case IRP_MN_CANCEL_REMOVE_DEVICE:

            D_PNP(DbgPrint("ROOTMODEM: IRP_MN_CANCEL_REMOVE_DEVICE\n");)

            Irp->IoStatus.Status=STATUS_SUCCESS;

            return ForwardIrp(deviceExtension->LowerDevice, Irp);

        case IRP_MN_SURPRISE_REMOVAL: {

            PVOID             Object;

            D_PNP(DbgPrint("ROOTMODEM: IRP_MN_SURPRISE_REMOVAL\n");)

            deviceExtension->Removing=TRUE;

            Irp->IoStatus.Status=STATUS_SUCCESS;

            return ForwardIrp(deviceExtension->LowerDevice, Irp);
        }

        case IRP_MN_REMOVE_DEVICE: {

            ULONG    NewReferenceCount;
            NTSTATUS StatusToReturn;
            PVOID    Object;

            D_PNP(DbgPrint("ROOTMODEM: IRP_MN_REMOVE_DEVICE\n");)

            //
            //  the device is going away, block new requests
            //
            deviceExtension->Removing=TRUE;

            //
            // send it down to the PDO
            //
            IoSkipCurrentIrpStackLocation(Irp);

            StatusToReturn=IoCallDriver(deviceExtension->LowerDevice, Irp);

            //
            //  remove the ref for the AddDevice
            //
            NewReferenceCount=InterlockedDecrement(&deviceExtension->ReferenceCount);

            if (NewReferenceCount != 0) {
                //
                //  Still have outstanding request, wait
                //
                D_PNP(DbgPrint("ROOTMODEM: IRP_MN_REMOVE_DEVICE- waiting for refcount to drop, %d\n",NewReferenceCount);)

                KeWaitForSingleObject(&deviceExtension->RemoveEvent, Executive, KernelMode, FALSE, NULL);

                D_PNP(DbgPrint("ROOTMODEM: IRP_MN_REMOVE_DEVICE- Done waiting\n");)
            }

            ASSERT(deviceExtension->ReferenceCount == 0);

            if (deviceExtension->PortName.Buffer != NULL) {

                FREE_POOL(deviceExtension->PortName.Buffer);
            }

            IoDetachDevice(deviceExtension->LowerDevice);

            ExDeleteResourceLite(&deviceExtension->Resource);

            deviceExtension=NULL;

            IoDeleteDevice(DeviceObject);

            D_PNP(DbgPrint("ROOTMODEM: IRP_MN_REMOVE_DEVICE %08lx\n",StatusToReturn);)

            return StatusToReturn;
        }


        case IRP_MN_QUERY_STOP_DEVICE:

            D_PNP(DbgPrint("ROOTMODEM: IRP_MN_QUERY_STOP_DEVICE\n");)

            Irp->IoStatus.Status=STATUS_SUCCESS;

            if (deviceExtension->OpenCount != 0) {
                //
                //  no can do
                //
                D_PNP(DbgPrint("ROOTMODEM: IRP_MN_QUERY_STOP_DEVICE -- failing\n");)

                Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
                IoCompleteRequest(
                    Irp,
                    IO_NO_INCREMENT
                    );

                return STATUS_UNSUCCESSFUL;
            }

            return ForwardIrp(deviceExtension->LowerDevice, Irp);

        case IRP_MN_CANCEL_STOP_DEVICE:

            D_PNP(DbgPrint("ROOTMODEM: IRP_MN_CANCEL_STOP_DEVICE\n");)

            Irp->IoStatus.Status=STATUS_SUCCESS;

            return ForwardIrp(deviceExtension->LowerDevice, Irp);

        case IRP_MN_STOP_DEVICE:

            D_PNP(DbgPrint("ROOTMODEM: IRP_MN_STOP_DEVICE\n");)

            Irp->IoStatus.Status=STATUS_SUCCESS;

            return ForwardIrp(deviceExtension->LowerDevice, Irp);

#ifdef ROOTMODEM_POWER
        case IRP_MN_QUERY_CAPABILITIES: {

            ULONG   i;

            //
            // Send this down to the PDO first
            //

            status=WaitForLowerDriverToCompleteIrp(
                deviceExtension->LowerDevice,
                Irp,
                COPY_CURRENT_TO_NEXT
                );

            irpSp = IoGetCurrentIrpStackLocation(Irp);

            for (i = PowerSystemUnspecified; i < PowerSystemMaximum;   i++) {

                deviceExtension->SystemPowerStateMap[i]=PowerDeviceD3;
            }

            for (i = PowerSystemUnspecified; i < PowerSystemHibernate;  i++) {

                D_POWER(DbgPrint("ROOTMODEM: DevicePower for System %d is %d\n",i,irpSp->Parameters.DeviceCapabilities.Capabilities->DeviceState[i]);)
                deviceExtension->SystemPowerStateMap[i]=irpSp->Parameters.DeviceCapabilities.Capabilities->DeviceState[i];
            }

            deviceExtension->SystemPowerStateMap[PowerSystemWorking]=PowerDeviceD0;

            deviceExtension->SystemWake=irpSp->Parameters.DeviceCapabilities.Capabilities->SystemWake;
            deviceExtension->DeviceWake=irpSp->Parameters.DeviceCapabilities.Capabilities->DeviceWake;

            D_POWER(DbgPrint("ROOTMODEM: DeviceWake=%d, SystemWake=%d\n",deviceExtension->DeviceWake,deviceExtension->SystemWake);)

            IoCompleteRequest(
                Irp,
                IO_NO_INCREMENT
                );
            return status;


            break;
        }
#endif



        default:

            D_PNP(DbgPrint("ROOTMODEM: PnP IRP, MN func=%d\n",irpSp->MinorFunction);)
            return ForwardIrp(deviceExtension->LowerDevice, Irp);


    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\sys\rootmdm\power.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    power.c

Abstract:

    This module contains the code that is very specific to initialization
    and unload operations in the modem driver

Author:

    Brian Lieuallen 6-21-1997

Environment:

    Kernel mode

Revision History :

--*/


#include "internal.h"


#pragma alloc_text(PAGE,FakeModemPower)




#ifdef ROOTMODEM_POWER
VOID
DevicePowerCompleteRoutine(
    PDEVICE_OBJECT    DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
//
//  This rountine id the completeion handler for the device power irp that
//  was requested, as a result of the system power irp. It completes the system
//  irp
//

{

    D_POWER(DbgPrint("ROOTMODEM: PoRequestPowerIrp: completion %08lx\n",IoStatus->Status);)


    return;
}
#endif



NTSTATUS
FakeModemPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

{

    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS    status;

    POWER_STATE  PowerState;

    D_POWER(DbgPrint("ROOTMODEM: Power IRP, MN func=%d\n",irpSp->MinorFunction);)

#ifdef ROOTMODEM_POWER
    switch (irpSp->MinorFunction) {

        case IRP_MN_SET_POWER:

            D_POWER(DbgPrint("ROOTMODEM: IRP_MN_SET_POWER, Type=%s, state=%d\n",irpSp->Parameters.Power.Type == SystemPowerState ? "SystemPowerState" : "DevicePowerState",irpSp->Parameters.Power.State.SystemState);)

            if (irpSp->Parameters.Power.Type == SystemPowerState) {
                //
                //  system power state change
                //
                //
                //  request the change in device power state based on systemstate map
                //
                PowerState.DeviceState=deviceExtension->SystemPowerStateMap[irpSp->Parameters.Power.State.SystemState];


                PoRequestPowerIrp(
                    deviceExtension->Pdo,
                    IRP_MN_SET_POWER,
                    PowerState,
                    DevicePowerCompleteRoutine,
                    Irp,
                    NULL
                    );


            }  else {
                //
                //  changing device state
                //
                PoSetPowerState(
                    deviceExtension->Pdo,
                    irpSp->Parameters.Power.Type,
                    irpSp->Parameters.Power.State
                    );

            }

            break;

        case IRP_MN_QUERY_POWER:

            D_POWER(DbgPrint("ROOTMODEM: IRP_MN_QUERY_POWER, Type=%s, state=%d\n",irpSp->Parameters.Power.Type == SystemPowerState ? "SystemPowerState" : "DevicePowerState",irpSp->Parameters.Power.State.DeviceState);)

            Irp->IoStatus.Status = STATUS_SUCCESS;

            break;

        default:

            D_POWER(DbgPrint("ROOTMODEM: Power IRP, MN func=%d\n",irpSp->MinorFunction);)

            break;

    }
#endif



    PoStartNextPowerIrp(Irp);

    IoSkipCurrentIrpStackLocation(Irp);

    status=PoCallDriver(deviceExtension->LowerDevice, Irp);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\sys\rootmdm\util.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    util.c

Abstract:

    This module contains the code that is very specific to initialization
    and unload operations in the modem driver

Author:

    Brian Lieuallen 6-21-1997

Environment:

    Kernel mode

Revision History :

--*/


#include "internal.h"



NTSTATUS
CheckStateAndAddReference(
    PDEVICE_OBJECT   DeviceObject,
    PIRP             Irp
    )

{

    PDEVICE_EXTENSION    DeviceExtension=(PDEVICE_EXTENSION)DeviceObject->DeviceExtension;
    KIRQL                OldIrql;


    InterlockedIncrement(&DeviceExtension->ReferenceCount);

    if (DeviceExtension->Removing) {
        //
        //  driver not accepting requests
        //
        PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);

        D_ERROR(DbgPrint("ROOTMODEM: removing!\n");)

        if (irpSp->MajorFunction == IRP_MJ_POWER) {

            PoStartNextPowerIrp(Irp);
        }

        RemoveReferenceAndCompleteRequest(
            DeviceObject,
            Irp,
            STATUS_UNSUCCESSFUL
            );

        return STATUS_UNSUCCESSFUL;

    }

    InterlockedIncrement(&DeviceExtension->ReferenceCount);

    return STATUS_SUCCESS;

}


VOID
RemoveReferenceAndCompleteRequest(
    PDEVICE_OBJECT    DeviceObject,
    PIRP              Irp,
    NTSTATUS          StatusToReturn
    )

{

    PDEVICE_EXTENSION    DeviceExtension=(PDEVICE_EXTENSION)DeviceObject->DeviceExtension;
    KIRQL                OldIrql;
    LONG                 NewReferenceCount;

    NewReferenceCount=InterlockedDecrement(&DeviceExtension->ReferenceCount);

    if (NewReferenceCount == 0) {
        //
        //  device is being removed, set event
        //
        ASSERT(DeviceExtension->Removing);

        D_PNP(DbgPrint("FAKEMODEM: RemoveReferenceAndCompleteRequest: setting event\n");)

        KeSetEvent(
            &DeviceExtension->RemoveEvent,
            0,
            FALSE
            );

    }

    Irp->IoStatus.Status = StatusToReturn;

    IoCompleteRequest(
        Irp,
        IO_SERIAL_INCREMENT
        );

    return;


}



VOID
RemoveReference(
    PDEVICE_OBJECT    DeviceObject
    )

{
    PDEVICE_EXTENSION    DeviceExtension=(PDEVICE_EXTENSION)DeviceObject->DeviceExtension;
    LONG                 NewReferenceCount;

    NewReferenceCount=InterlockedDecrement(&DeviceExtension->ReferenceCount);

    D_TRACE(
        if (DeviceExtension->Removing) {DbgPrint("FAKEMODEM: RemoveReference: %d\n",NewReferenceCount);}
        )

    if (NewReferenceCount == 0) {
        //
        //  device is being removed, set event
        //
        ASSERT(DeviceExtension->Removing);

        D_PNP(DbgPrint("FAKEMODEM: RemoveReference: setting event\n");)

        KeSetEvent(
            &DeviceExtension->RemoveEvent,
            0,
            FALSE
            );

    }

    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\tsp\app.h ===
//
// Copyright (c) 1996-1997 Microsoft Corporation.
//
//
// Component
//
//		Unimodem 5.0 TSP (Win32, user mode DLL)
//
// File
//
//		APP.H
//		Header file for stuff that executes in the client app's context.
//
// History
//
//		04/05/1997  JosephJ Created, taking stuff from wndthrd.h, talkdrop.h,
//                  etc. in NT4.0 unimodem.
//
//

// Dialog node
//
typedef struct tagDlgNode {
    struct tagDlgNode   *pNext;
    CRITICAL_SECTION    hSem;
    HWND                hDlg;
    DWORD               idLine;
    DWORD               dwType;
    DWORD               dwStatus;
    HWND                Parent;
} DLGNODE, *PDLGNODE;



//extern TUISPIDLLCALLBACK gpfnUICallback;


TUISPIDLLCALLBACK WINAPI
GetCallbackProc(
    HWND    hdlg
    );

TUISPIDLLCALLBACK WINAPI
GetCallbackProcFromParent(
    HWND    hdlg
    );

void EndMdmDialog(HWND Parent, ULONG_PTR idLine, DWORD dwType, DWORD dwStatus);
void EnterUICritSect(void);
void LeaveUICritSect(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\tsp\appdlg.cpp ===
//
// Copyright (c) 1996-1997 Microsoft Corporation.
//
//
// Component
//
//		Unimodem 5.0 TSP (Win32, user mode DLL)
//
// File
//
//		APPDLG.CPP
//		Implements Generic Dialog functionality in
//      the client app.
//      (RUNS IN CLIENT APP CONTEXT)
//
// History
//
//		04/05/1997  JosephJ Created, taking stuff from NT 4.0 TSP's wndthrd.c
//

#include "tsppch.h"
#include "rcids.h"
#include "tspcomm.h"
#include "globals.h"
#include "apptspi.h"
#include "app.h"



#define  UNIMODEM_WNDCLASS TEXT("UM5")


#define DPRINTF(_str) (0)


// Remote handle
//
typedef struct tagRemHandle {
    HANDLE handle;
    DWORD  pid;
} REMHANDLE, *PREMHANDLE;

#define INITCRITICALSECTION(_x) InitializeCriticalSection(&(_x))
#define DELETECRITICALSECTION(_x) DeleteCriticalSection(&(_x))
#define ENTERCRITICALSECTION(_x) EnterCriticalSection(&(_x))
#define LEAVECRITICALSECTION(_x) LeaveCriticalSection(&(_x))

typedef struct _UI_THREAD_NODE {

    struct _UI_THREAD_NODE *Next;

    CRITICAL_SECTION        CriticalSection;

    HWND                    hWnd;
    HTAPIDIALOGINSTANCE     htDlgInst;
    TUISPIDLLCALLBACK       pfnUIDLLCallback;

    PDLGNODE                DlgList;

    UINT                    RefCount;

} UI_THREAD_NODE, *PUI_THREAD_NODE;


typedef struct UI_THREAD_LIST {

    CRITICAL_SECTION     CriticalSection;

    PUI_THREAD_NODE      ListHead;

} UI_THREAD_LIST, *PUI_THREAD_LIST;


#define WM_MDM_TERMINATE            WM_USER+0x0100
#define WM_MDM_TERMINATE_WND        WM_USER+0x0101
#define WM_MDM_TERMINATE_WND_NOTIFY WM_USER+0x0102
#define WM_MDM_DLG                  WM_USER+0x0113

//****************************************************************************
// Function Prototypes
//****************************************************************************

PDLGNODE NewDlgNode (HWND Parent,DWORD idLine, DWORD dwType);
BOOL     DeleteDlgNode (HWND Parent,PDLGNODE pDlgNode);
PDLGNODE FindDlgNode (HWND Parent, ULONG_PTR idLine, DWORD dwType);
BOOL     IsDlgListMessage(HWND Parent,MSG* pmsg);
void     CleanupDlgList (HWND Parent);
DWORD    StartMdmDialog(HWND hwnd, DWORD idLine, DWORD dwType);
DWORD    DestroyMdmDialog(HWND hwnd,DWORD idLine, DWORD dwType);
LRESULT  MdmWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);

HWND     CreateTalkDropDlg(HWND hwndOwner, ULONG_PTR idLine);
HWND     CreateManualDlg(HWND hwndOwner, ULONG_PTR idLine);
HWND     CreateTerminalDlg(HWND hwndOwner, ULONG_PTR idLine);

TCHAR   gszMdmWndClass[]    = UNIMODEM_WNDCLASS;

UI_THREAD_LIST   UI_ThreadList;


VOID WINAPI
UI_ProcessAttach(
    VOID
    )

{

    UI_ThreadList.ListHead=NULL;

    InitializeCriticalSection(&UI_ThreadList.CriticalSection);


    return;

}

VOID WINAPI
UI_ProcessDetach(
    VOID
    )

{

    UI_ThreadList.ListHead=NULL;

    DeleteCriticalSection(&UI_ThreadList.CriticalSection);

    return;

}



VOID WINAPI
AddThreadNode(
    PUI_THREAD_LIST   List,
    PUI_THREAD_NODE   Node
    )

{
    EnterCriticalSection(&List->CriticalSection);

    Node->Next=List->ListHead;

    List->ListHead=Node;

    LeaveCriticalSection(&List->CriticalSection);

    return;

}

VOID WINAPI
RemoveNode(
    PUI_THREAD_LIST   List,
    PUI_THREAD_NODE   Node
    )

{
    PUI_THREAD_NODE   Current;
    PUI_THREAD_NODE   Prev;

    EnterCriticalSection(&List->CriticalSection);

    Prev=NULL;
    Current=List->ListHead;

    while (Current != NULL) {

        if (Current == Node) {

            if (Current == List->ListHead) {

                List->ListHead=Current->Next;

            } else {

                Prev->Next=Current->Next;
            }

            break;
        }
        Prev=Current;
        Current=Current->Next;
    }

    EnterCriticalSection(&Node->CriticalSection);

    Node->RefCount--;

    LeaveCriticalSection(&Node->CriticalSection);

    LeaveCriticalSection(&List->CriticalSection);

    return;

}


UINT WINAPI
RemoveReference(
    PUI_THREAD_NODE   Node
    )

{
    UINT              TempCount;

    EnterCriticalSection(&Node->CriticalSection);

    TempCount=--Node->RefCount;

    LeaveCriticalSection(&Node->CriticalSection);

    return TempCount;

}



HWND WINAPI
FindThreadWindow(
    PUI_THREAD_LIST  List,
    HTAPIDIALOGINSTANCE   htDlgInst
    )

{

    PUI_THREAD_NODE   Node;
    HWND              Window=NULL;

    EnterCriticalSection(&List->CriticalSection);

    Node=List->ListHead;

    while (Node != NULL && Window == NULL) {

        EnterCriticalSection(&Node->CriticalSection);

        if (Node->htDlgInst == htDlgInst) {
            //
            //  found it
            //
            Window=Node->hWnd;

            Node->RefCount++;
        }

        LeaveCriticalSection(&Node->CriticalSection);


        Node=Node->Next;
    }


    LeaveCriticalSection(&List->CriticalSection);

    return Window;

}


TUISPIDLLCALLBACK WINAPI
GetCallbackProc(
    HWND    hdlg
    )

{

    PUI_THREAD_NODE   Node;

    Node=(PUI_THREAD_NODE)GetWindowLongPtr(hdlg,GWLP_USERDATA);

    return Node->pfnUIDLLCallback;

}



//****************************************************************************
// LONG TSPIAPI TUISPI_providerGenericDialog(
//  TUISPIDLLCALLBACK     pfnUIDLLCallback,
//  HTAPIDIALOGINSTANCE   htDlgInst,
//  LPVOID                lpParams,
//  DWORD                 dwSize)
//
// Functions: Create modem instance
//
// Return:    ERROR_SUCCESS if successful
//****************************************************************************

LONG TSPIAPI TUISPI_providerGenericDialog(
  TUISPIDLLCALLBACK     pfnUIDLLCallback,
  HTAPIDIALOGINSTANCE   htDlgInst,
  LPVOID                lpParams,
  DWORD                 dwSize,
  HANDLE                hEvent)
{
    MSG       msg;
    WNDCLASS  wc;
    DWORD     dwRet, dwTemp;
    HDESK     hInputDesktop = NULL, hThreadDesktop;
    BOOL      bResetDesktop = FALSE;
    PUI_THREAD_NODE  Node;
    TCHAR     szInput[256], szThread[256];
    HWINSTA   CurrentWindowStation=NULL;
    HWINSTA   UserWindowStation=NULL;
    BOOL      bResult;
    BOOL      NewWindowStationSet=FALSE;

    Node = (PUI_THREAD_NODE) ALLOCATE_MEMORY(sizeof(UI_THREAD_NODE));

    if (Node == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    InitializeCriticalSection(&Node->CriticalSection);

    Node->pfnUIDLLCallback=pfnUIDLLCallback;
    Node->htDlgInst=htDlgInst;
    Node->RefCount=1;


    Node->DlgList=NULL;

    //
    //  get the current window station so we can put it back later
    //
    CurrentWindowStation=GetProcessWindowStation();

    if (CurrentWindowStation == NULL) {

#if DBG
        OutputDebugString(TEXT("UNIMDM: GetProcessWindowStation() failed\n"));
#endif

        goto Cleanup_Exit;
    }

    szInput[0]=TEXT('\0');

    bResult=GetUserObjectInformation(CurrentWindowStation, UOI_NAME, szInput, sizeof(szInput), &dwTemp);

    if (!bResult) {
#if DBG
            OutputDebugString(TEXT("UNIMDM: GetUserObjectIformation() failed\n"));
#endif

        goto Cleanup_Exit;
    }

    if (lstrcmpi(szInput,TEXT("WinSta0")) != 0) {
        //
        //  The current window statation is not the interactive user, need to swtich so they
        //  can see the ui
        //

        //
        //  get the interactive users desktop, just hard code it for now, since we don't know
        //
        UserWindowStation=OpenWindowStation(TEXT("WinSta0"),FALSE,MAXIMUM_ALLOWED);

        if (UserWindowStation == NULL) {
#if DBG
            OutputDebugString(TEXT("UNIMDM: OpenWindowStation() failed\n"));
#endif

            goto Cleanup_Exit;
        }

        //
        //  set to the new window station
        //
        bResult=SetProcessWindowStation(UserWindowStation);

        if (!bResult) {
#if DBG
            OutputDebugString(TEXT("UNIMDM: SetProcessWindowStation() failed\n"));
#endif

            goto Cleanup_Exit;
        }

        NewWindowStationSet=TRUE;


        hThreadDesktop = GetThreadDesktop (GetCurrentThreadId ());

        if (hThreadDesktop == NULL) {
#if DBG
            OutputDebugString(TEXT("UNIMDM: GetThreadDesktop() failed\n"));
#endif
            goto Cleanup_Exit;
        }


        hInputDesktop = OpenInputDesktop (0, FALSE, DESKTOP_CREATEWINDOW | DESKTOP_CREATEMENU);

        if (hInputDesktop == NULL) {
#if DBG
            OutputDebugString(TEXT("UNIMDM: OpenInputDesktop() failed\n"));
#endif
            goto Cleanup_Exit;
        }

        bResult=SetThreadDesktop(hInputDesktop);

        if (!bResult) {
#if DBG
            OutputDebugString(TEXT("UNIMDM: SetThreadDeskTop() failed\n"));
#endif
            goto Cleanup_Exit;
        }

        bResetDesktop = TRUE;

    } else {
        //
        //  we are current on the users window station, just make sure we are on the right desktop
        //
        szInput[0]=TEXT('\0');
        szThread[0]=TEXT('\0');


        //
        //  just set this thread to the input desktop, incase irmon in running in this process
        //  and messes with the windostation
        //
        //  BRL  10/26/99
        //
        hInputDesktop = OpenInputDesktop (0, FALSE, DESKTOP_CREATEWINDOW | DESKTOP_CREATEMENU);

        if (hInputDesktop != NULL) {

            SetThreadDesktop(hInputDesktop);

        } else {

            dwRet = GetLastError ();
            goto Cleanup_Exit;
        }


#if 0
        // Now, switch the desktop, if need be
        if ((hInputDesktop = OpenInputDesktop (0, FALSE, DESKTOP_CREATEWINDOW)))
        {
            if ((hThreadDesktop = GetThreadDesktop (GetCurrentThreadId ())))
            {
                if (!GetUserObjectInformation (hInputDesktop, UOI_NAME, szInput, sizeof(szInput), &dwTemp) ||
                    !GetUserObjectInformation (hThreadDesktop, UOI_NAME, szThread, sizeof(szThread), &dwTemp) ||
                    lstrcmpi(szInput, szThread))
                {
                    // need be, so switch it
                    if (SetThreadDesktop (hInputDesktop))
                    {
                        bResetDesktop = TRUE;
                    }
                    else
                    {
                        dwRet = GetLastError ();
                        goto Cleanup_Exit;
                    }
                }
            }
            else
            {
                dwRet = GetLastError ();
                goto Cleanup_Exit;
            }
        }
        else
        {
            dwRet = GetLastError ();
            goto Cleanup_Exit;
        }
#endif
    }

    wc.style         = CS_NOCLOSE;         // Do not allow end-user to close
    wc.cbClsExtra    = 0;                  // No per-class extra data.
    wc.cbWndExtra    = 0;                  // No per-window extra data.
    wc.hInstance     = g.hModule;         // Application that owns the class.
    wc.hIcon         = LoadIcon(NULL, MAKEINTRESOURCE(IDI_APPLICATION));
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
    wc.lpszMenuName  = NULL;
    wc.lpfnWndProc   = MdmWndProc;         // Function to retrieve messages.
    wc.lpszClassName = gszMdmWndClass;     // Name used in call to CreateWindow.



    RegisterClass(&wc);


    // Create the main invisible window
    //
    Node->hWnd = CreateWindow (
                               gszMdmWndClass,            // The window class
                               TEXT(""),                  // Text for window title bar.
                               WS_OVERLAPPEDWINDOW,       // Window style.
                               CW_USEDEFAULT,             // Default horizontal position.
                               CW_USEDEFAULT,             // Default vertical position.
                               CW_USEDEFAULT,             // Default width.
                               CW_USEDEFAULT,             // Default height.
                               NULL,                      // Overlapped windows have no parent.
                               NULL,                      // Use the window class menu.
                               g.hModule,                 // This instance owns this window.
                               Node);                     // Pointer not needed.

    if (NULL != Node->hWnd)
    {
        AddThreadNode (&UI_ThreadList, Node);
    }

    SetEvent(hEvent);


    // Cannot create a window, bail out
    //
    if (Node->hWnd == NULL)
    {
        dwRet = LINEERR_OPERATIONFAILED;
        goto Cleanup_Exit;
    }

    // Get message loop
    //
    while (GetMessage(&msg, NULL, 0, 0))
    {
        __try {

            if (msg.hwnd != NULL)
            {
                // The message is for a specific UI window, dispatch the message
                //
                if (!IsDlgListMessage(Node->hWnd,&msg))
                {
                    TranslateMessage(&msg);     // Translate virtual key code
                    DispatchMessage(&msg);      // Dispatches message to the window
                }
            }
        } __except(EXCEPTION_EXECUTE_HANDLER) {

        }
    }
    DestroyWindow(Node->hWnd);


    ASSERT(Node->RefCount == 0);

    dwRet = ERROR_SUCCESS;


Cleanup_Exit:

    if (NewWindowStationSet) {

        SetProcessWindowStation(CurrentWindowStation);
    }

    if (UserWindowStation != NULL) {

        CloseWindowStation(UserWindowStation);
    }


    // Set the desktop back
    if (bResetDesktop)
    {
        SetThreadDesktop (hThreadDesktop);
    }

    if (hInputDesktop)
    {
        CloseDesktop (hInputDesktop);
    }

    // Free the allocated resources
    //

    FREE_MEMORY(Node);

    return ERROR_SUCCESS;
}

//****************************************************************************
// LONG TSPIAPI TUISPI_providerGenericDialogData(
//    HTAPIDIALOGINSTANCE htDlgInst,
//    LPVOID              lpParams,
//    DWORD               dwSize)
//
// Functions: Request an action from the modem instance
//
// Return:    ERROR_SUCCESS if successful
//****************************************************************************

LONG TSPIAPI TUISPI_providerGenericDialogData(
    HTAPIDIALOGINSTANCE htDlgInst,
    LPVOID              lpParams,
    DWORD               dwSize
    )
{
  PDLGINFO  pDlgInfo = (PDLGINFO)lpParams;
  HWND      ParentWindow;
  UINT      RefCount;
  PUI_THREAD_NODE  Node;


  ParentWindow=FindThreadWindow(
     &UI_ThreadList,
     htDlgInst
     );

  if (ParentWindow == NULL) {

     return ERROR_SUCCESS;
  }

  Node=(PUI_THREAD_NODE)GetWindowLongPtr(ParentWindow, GWLP_USERDATA);


  if (NULL == lpParams) {
    //
    //  tapi want thread to exit, remove from list and dec ref count
    //
    RemoveNode(
        &UI_ThreadList,
        Node
        );


  }
  else
  {
    ASSERT(dwSize == sizeof(*pDlgInfo));

    switch(pDlgInfo->dwCmd)
    {
      case DLG_CMD_CREATE:
        StartMdmDialog(ParentWindow,pDlgInfo->idLine, pDlgInfo->dwType);
        break;

      case DLG_CMD_DESTROY:
        DestroyMdmDialog(ParentWindow,pDlgInfo->idLine, pDlgInfo->dwType);
        break;

      case DLG_CMD_FREE_INSTANCE:
        //
        //  server wants thread to exit, remove from list and dec refcount
        //
        RemoveNode(
            &UI_ThreadList,
            Node
            );

        break;

      default:
        break;
    }
  }

  if (0 == RemoveReference(Node)) {
      //
      //  it's gone, count dec'ed when remove from list
      //
      PostMessage(ParentWindow, WM_MDM_TERMINATE, 0, 0);
  }

  return ERROR_SUCCESS;
}

//****************************************************************************
// PDLGNODE NewDlgNode(DWORD, DWORD)
//
// Function: Add a new dialog box to the list
//
// Returns:  a pointer to the dialog node if the dialog can be added
//
//****************************************************************************

PDLGNODE NewDlgNode (HWND Parent, DWORD idLine, DWORD dwType)
{
  PDLGNODE   pDlgNode;

  PUI_THREAD_NODE  UI_Node=(PUI_THREAD_NODE)GetWindowLongPtr(Parent, GWLP_USERDATA);

  // Allocate a new dialog node
  //
  if ((pDlgNode = (PDLGNODE)ALLOCATE_MEMORY(sizeof(*pDlgNode)))
      == NULL)
    return NULL;

  // Insert the new node into the dialog list
  //
  pDlgNode->idLine = idLine;
  pDlgNode->dwType = dwType;
  pDlgNode->Parent = Parent;
  INITCRITICALSECTION(pDlgNode->hSem);

  // Insert the new node to the list
  //
  ENTERCRITICALSECTION(UI_Node->CriticalSection);
  pDlgNode->pNext    = UI_Node->DlgList;
  UI_Node->DlgList     = pDlgNode;
  LEAVECRITICALSECTION(UI_Node->CriticalSection);

  return pDlgNode;
}

//****************************************************************************
// BOOL DeleteDlgNode(PDLGNODE)
//
// Function: Remove a dialog box to the list
//
// Returns:  TRUE if the dialog exist and removed
//
//****************************************************************************

BOOL DeleteDlgNode (HWND Parent, PDLGNODE pDlgNode)
{
  PDLGNODE pCurDlg, pPrevDlg;
  PUI_THREAD_NODE  UI_Node=(PUI_THREAD_NODE)GetWindowLongPtr(Parent, GWLP_USERDATA);
  // Exclusively access the modem list
  //
  ENTERCRITICALSECTION(UI_Node->CriticalSection);

  // Start from the head of the CB list
  //
  pPrevDlg = NULL;
  pCurDlg  = UI_Node->DlgList;

  // traverse the list to find the specified CB
  //
  while (pCurDlg != NULL)
  {
    if (pCurDlg == pDlgNode)
    {
      // Is there a previous control block?
      //
      if (pPrevDlg == NULL)
      {
        // head of the list
        //
        UI_Node->DlgList = pCurDlg->pNext;
      }
      else
      {
        pPrevDlg->pNext = pCurDlg->pNext;
      }
      break;
    }

    pPrevDlg = pCurDlg;
    pCurDlg  = pCurDlg->pNext;
  }

  // Finish accessing the modem list
  //
  LEAVECRITICALSECTION(UI_Node->CriticalSection);

  // Have we found the dialog box in the list?
  //
  if (pCurDlg != NULL)
  {
    // Wait until no one else is using the line
    //
    ENTERCRITICALSECTION(pCurDlg->hSem);
    DELETECRITICALSECTION(pCurDlg->hSem);
    FREE_MEMORY(pCurDlg);
    return TRUE;
  }
  else
  {
    return FALSE;
  }
}

//****************************************************************************
// PDLGNODE FindDlgNode(DWORD, ULONG_PTR, DWORD)
//
// Function: Find the dialog node for the line dev
//
// Returns:  a pointer to the dialog node if the dialog exist and removed.
//           The dialog node's semaphore is claimed.
//
//****************************************************************************

PDLGNODE FindDlgNode (HWND Parent, ULONG_PTR idLine, DWORD dwType)
{
  PDLGNODE pCurDlg;
  PUI_THREAD_NODE  UI_Node=(PUI_THREAD_NODE)GetWindowLongPtr(Parent, GWLP_USERDATA);
  // Exclusively access the modem list
  //
  ENTERCRITICALSECTION(UI_Node->CriticalSection);

  // Start from the head of the CB list
  //
  pCurDlg  = UI_Node->DlgList;

  // traverse the list to find the specified CB
  //
  while (pCurDlg != NULL)
  {
    ENTERCRITICALSECTION(pCurDlg->hSem);

    if ((pCurDlg->idLine == idLine) &&
        (pCurDlg->dwType == dwType) &&
        (pCurDlg->Parent == Parent) )
    {
      break;
    }

    LEAVECRITICALSECTION(pCurDlg->hSem);

    pCurDlg  = pCurDlg->pNext;
  }

  // Finish accessing the modem list
  //
  LEAVECRITICALSECTION(UI_Node->CriticalSection);

  return pCurDlg;
}


//****************************************************************************
// BOOL IsDlgListMessage(MSG* pmsg)
//
// Function: Run the message throught the dialogbox list
//
// Returns:  TRUE if the message is one of the dialog box's and FALSE otherwise
//
//****************************************************************************

BOOL IsDlgListMessage(HWND Parent, MSG* pmsg)
{
  PDLGNODE pDlgNode, pNext;
  BOOL     fRet = FALSE;
  PUI_THREAD_NODE  UI_Node=(PUI_THREAD_NODE)GetWindowLongPtr(Parent, GWLP_USERDATA);
  // Exclusively access the modem list
  //
  ENTERCRITICALSECTION(UI_Node->CriticalSection);

  // Walk the dialog box list
  //
  pDlgNode = UI_Node->DlgList;
  while(pDlgNode != NULL && !fRet)
  {
    ENTERCRITICALSECTION(pDlgNode->hSem);

    // Check whether the message belongs to this dialog
    //
    if (IsWindow(pDlgNode->hDlg) && IsDialogMessage(pDlgNode->hDlg, pmsg))
    {
      // Yes, we are done!
      //
      fRet = TRUE;
    }

    LEAVECRITICALSECTION(pDlgNode->hSem);

    // Check the next dialog
    //
    pDlgNode = pDlgNode->pNext;
  }

  // Finish accessing the modem list
  //
  LEAVECRITICALSECTION(UI_Node->CriticalSection);

  return fRet;
}
//****************************************************************************
// void CleanupDlgList()
//
// Function: Clean up the dialogbox list
//
// Returns:  None
//
//****************************************************************************

void CleanupDlgList (HWND Parent)
{
  PDLGNODE pDlgNode, pNext;
  PUI_THREAD_NODE  UI_Node=(PUI_THREAD_NODE)GetWindowLongPtr(Parent, GWLP_USERDATA);
  // Exclusively access the modem list
  //
  ENTERCRITICALSECTION(UI_Node->CriticalSection);

  // Walk the dialog box list
  //
  pDlgNode =  UI_Node->DlgList;
  while(pDlgNode != NULL)
  {
    ENTERCRITICALSECTION(pDlgNode->hSem);

    // Destroy the dialog box first
    //
    DestroyWindow(pDlgNode->hDlg);

    // Free the CB and move onto the next dialog
    //
    pNext = pDlgNode->pNext;
    DELETECRITICALSECTION(pDlgNode->hSem);
    FREE_MEMORY(pDlgNode);
    pDlgNode = pNext;
  }

  // Finish accessing the modem list
  //
  UI_Node->DlgList=NULL;

  LEAVECRITICALSECTION(UI_Node->CriticalSection);

  return;
}

//****************************************************************************
// DWORD StartMdmDialog(DWORD, DWORD)
//
// Function: Start modem dialog
//
// Notes: This function is called from the state machine thread
//
// Return:  ERROR_SUCCESS if dialog box is successfully created
//          ERROR_OUTOFMEMORY if fails
//
//****************************************************************************

DWORD StartMdmDialog(HWND Parent, DWORD idLine, DWORD dwType)
{
  PDLGNODE pDlgNode;
  DWORD    dwRet;

  // Create the talk/drop dialog node
  //
  pDlgNode = NewDlgNode(Parent, idLine, dwType);

  if (pDlgNode != NULL)
  {
    PostMessage(Parent, WM_MDM_DLG, (WPARAM)idLine, (LPARAM)dwType);
    dwRet = ERROR_SUCCESS;
  }
  else
  {
    dwRet = ERROR_OUTOFMEMORY;
  }

  return dwRet;
}

//****************************************************************************
// DWORD DestroyMdmDialog(DWORD, DWORD)
//
// Function: destroy talk/drop dialog
//
// Notes: This function is called from the state machine thread
//
// Returns:  none
//
//****************************************************************************

DWORD DestroyMdmDialog(HWND Parent,DWORD idLine, DWORD dwType)
{
#ifdef DEBUG
  PDLGNODE pDlgNode;

  // Search for the dialog
  //
  pDlgNode = FindDlgNode(Parent, idLine, dwType);

  // Check if the talkdrop dialog is available
  //
  if (pDlgNode != NULL)
  {
    LEAVECRITICALSECTION(pDlgNode->hSem);
  }
  else
  {
    DPRINTF("Could not find the associated dialog node");
    ASSERT(0);
  }
#endif // DEBUG

  PostMessage(Parent, WM_MDM_TERMINATE_WND, (WPARAM)idLine,
              (LPARAM)dwType);
  return ERROR_SUCCESS;
}

//****************************************************************************

//****************************************************************************
// LRESULT MdmWndProc(HWND, UINT, WPARAM, LPARAM)
//
// Function: Main window for the modem window thread.
//
// Returns:  0 or 1
//
//****************************************************************************

LRESULT MdmWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
  // Determine the command
  //
  switch(message)
  {

    case WM_CREATE:
        {
        LPCREATESTRUCT  lpcs=(LPCREATESTRUCT) lParam;

        SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)lpcs->lpCreateParams);

        break;
        }
    case WM_MDM_TERMINATE:
      //
      // The thread is being terminated
      // Destroy all the windows
      //
      CleanupDlgList(hwnd);
      PostQuitMessage(ERROR_SUCCESS);
      break;

    case WM_MDM_TERMINATE_WND:
    case WM_MDM_TERMINATE_WND_NOTIFY:
    {
      PDLGNODE pDlgNode;

      // Search for the dialog node
      //
      if ((pDlgNode = FindDlgNode(hwnd,(DWORD)wParam, (DWORD)lParam)) == NULL)
      {
        break;
      }

      // The window is requested to be destroyed
      //
      DestroyWindow(pDlgNode->hDlg);

      // If the modem dialog structure is available
      // notify the state machine thread
      //
      if (message == WM_MDM_TERMINATE_WND_NOTIFY)
      {
        DLGREQ  DlgReq;

        TUISPIDLLCALLBACK   Callback;

        DlgReq.dwCmd = UI_REQ_COMPLETE_ASYNC;
        DlgReq.dwParam = pDlgNode->dwStatus;

        Callback=GetCallbackProc(hwnd);

        (*Callback)(pDlgNode->idLine, TUISPIDLL_OBJECT_LINEID,
                          (LPVOID)&DlgReq, sizeof(DlgReq));

      }

      // Remove it from the dialog list
      //
      LEAVECRITICALSECTION(pDlgNode->hSem);
      DeleteDlgNode(hwnd,pDlgNode);

      break;
    }
    case WM_MDM_DLG:
    {
      PDLGNODE pDlgNode;

      //
      // Find the dialog node
      //
      pDlgNode = FindDlgNode(hwnd,(DWORD)wParam, (DWORD)lParam);

      if (pDlgNode != NULL)
      {
        if (pDlgNode->hDlg == NULL)
        {
          switch(lParam)
          {
            case TALKDROP_DLG:
              //
              // Create a talk-drop dialog box
              //
              pDlgNode->hDlg = CreateTalkDropDlg(hwnd, (ULONG_PTR)pDlgNode);
              SetForegroundWindow(pDlgNode->hDlg);
              break;

            case MANUAL_DIAL_DLG:
              //
              // Create a talk-drop dialog box
              //
              pDlgNode->hDlg = CreateManualDlg(hwnd, (ULONG_PTR)pDlgNode);
              SetForegroundWindow(pDlgNode->hDlg);
              break;

            case TERMINAL_DLG:
              //
              // Create a talk-drop dialog box
              //
              pDlgNode->hDlg = CreateTerminalDlg(hwnd, (ULONG_PTR)wParam);
              SetForegroundWindow(pDlgNode->hDlg);
              break;

            default:
              break;
          }
        }
        else
        {
          DPRINTF("Another dialog of the same type exists.");
          ASSERT(0);
        }

        LEAVECRITICALSECTION(pDlgNode->hSem);
      }
      break;
    }

    default:
      return(DefWindowProc(hwnd, message, wParam, lParam));
  }
  return 0;
}



//****************************************************************************
// void EndMdmDialog(DWORD, ULONG_PTR, DWORD)
//
// Function: Request to end dialog from the dialog itself.
//
// Returns:  None
//
//****************************************************************************

void EndMdmDialog(HWND Parent, ULONG_PTR idLine, DWORD dwType, DWORD dwStatus)
{
  PDLGNODE pDlgNode;

  // Look for the dialog node
  //
  if ((pDlgNode = FindDlgNode(Parent, idLine, dwType)) != NULL)
  {
    pDlgNode->dwStatus = dwStatus;

    // Notify the dialog box result
    //
    PostMessage(Parent, WM_MDM_TERMINATE_WND_NOTIFY, (WPARAM)idLine,
                (LPARAM)dwType);

    LEAVECRITICALSECTION(pDlgNode->hSem);
  }
  return;
}

void EnterUICritSect(void)
{
    ENTERCRITICALSECTION(UI_ThreadList.CriticalSection);

}

void LeaveUICritSect(void)
{
    LEAVECRITICALSECTION(UI_ThreadList.CriticalSection);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\tsp\apptdrop.cpp ===
//
// Copyright (c) 1996-1997 Microsoft Corporation.
//
//
// Component
//
//		Unimodem 5.0 TSP (Win32, user mode DLL)
//
// File
//
//		APPTERM.CPP
//		Implements the Talk/Drop Terminal Dlg.
//      (RUNS IN CLIENT APP CONTEXT)
//
// History
//
//		04/05/1997  JosephJ Created, taking stuff from terminal.c in NT4 TSP.

#include "tsppch.h"
#include <regstr.h>
#include <commctrl.h>
#include <windowsx.h>
#include "rcids.h"
#include "tspcomm.h"
#include "globals.h"
#include "app.h"
#include "apptspi.h"



//****************************************************************************
// LRESULT TalkDropDlgProc(HWND hwnd, UINT wMsg, WPARAM wParam, LPARAM lParam)
//
// Function: Talk-Drop dialog routine
//
// Returns:  varies
//
//****************************************************************************

INT_PTR TalkDropDlgProc(HWND hwnd, UINT wMsg, WPARAM wParam, LPARAM lParam )
{
  DWORD idLine;

  switch(wMsg)
  {
    case WM_INITDIALOG:

      // remember the hLineDev passed in
      //
      SetWindowLongPtr(hwnd, DWLP_USER, (LONG_PTR)lParam);
      return 1;
      break;

    case WM_COMMAND:
    {
      UINT idCmd=GET_WM_COMMAND_ID(wParam, lParam);
      TUISPIDLLCALLBACK   Callback;
      //
      // One of the buttons (Talk/Drop) is pressed
      //
      if (idCmd == IDTALK || idCmd == IDDROP || idCmd == IDCANCEL)
      {
        DLGREQ  DlgReq;
        PDLGNODE pDlgNode;

        pDlgNode= (PDLGNODE)GetWindowLongPtr(hwnd, DWLP_USER);

        idLine =  pDlgNode->idLine;

        // Make a direct call to unimodem to drop the line
        //
        DlgReq.dwCmd = UI_REQ_HANGUP_LINE;
        DlgReq.dwParam = (idCmd == IDTALK) ? 0 : IDERR_OPERATION_ABORTED;

        Callback=GetCallbackProc(pDlgNode->Parent);

        (*Callback)(idLine, TUISPIDLL_OBJECT_LINEID,
                          (LPVOID)&DlgReq, sizeof(DlgReq));

        // Return the result
        //
        EndMdmDialog(pDlgNode->Parent,idLine, TALKDROP_DLG,
                     (idCmd == IDTALK) ? 0 : IDERR_OPERATION_ABORTED);
        return 1;
        break;
      }
      break;
    }

    case WM_DESTROY:
    {
      TUISPIDLLCALLBACK   Callback;
      DLGREQ  DlgReq;

      PDLGNODE pDlgNode;

      pDlgNode= (PDLGNODE)GetWindowLongPtr(hwnd, DWLP_USER);

      idLine =  pDlgNode->idLine;


      DlgReq.dwCmd = UI_REQ_END_DLG;
      DlgReq.dwParam = TALKDROP_DLG;

      Callback=GetCallbackProc(pDlgNode->Parent);

      (*Callback)(idLine, TUISPIDLL_OBJECT_LINEID,
                        (LPVOID)&DlgReq, sizeof(DlgReq));
      break;
    }
    default:
      break;
  };

  return 0;
}





//****************************************************************************
// HWND CreateTalkDropDlg(HWND hwndOwner, ULONG_PTR idLine)
//
// Function: creates a modeless talk/drop dialog box
//
// Returns:  the modeless window handle
//
//****************************************************************************

HWND CreateTalkDropDlg(HWND hwndOwner, ULONG_PTR idLine)
{
  HWND hwnd;

  // Create dialog
  //
  hwnd = CreateDialogParam(g.hModule,
                           MAKEINTRESOURCE(IDD_TALKDROP),
                           hwndOwner,
                           TalkDropDlgProc,
                           (LPARAM)idLine);
  return hwnd;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\tsp\appman.cpp ===
//
// Copyright (c) 1996-1997 Microsoft Corporation.
//
//
// Component
//
//		Unimodem 5.0 TSP (Win32, user mode DLL)
//
// File
//
//		APPMAN.CPP
//		Implements modeless manual-dial dialog.
//      (RUNS IN CLIENT APP CONTEXT)
//
// History
//
//		04/05/1997  JosephJ Created, taking stuff from manual.c in NT4 TSP.

#include "tsppch.h"
#include <regstr.h>
#include <commctrl.h>
#include <windowsx.h>
#include "rcids.h"
#include "tspcomm.h"
#include "globals.h"
#include "app.h"
#include "apptspi.h"



//****************************************************************************
// LRESULT ManualDialDlgProc(HWND hwnd, UINT wMsg, WPARAM wParam, LPARAM lParam)
//
// Function: Talk-Drop dialog routine
//
// Returns:  varies
//
//****************************************************************************

INT_PTR WINAPI
ManualDialDlgProc(
    HWND hwnd,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    )

{
    DWORD idLine;

    switch(wMsg)
    {
      case WM_INITDIALOG:

        {
        NUMBERREQ   NumberReq;
        TCHAR       szUnicodeBuf[MAXDEVICENAME+1];
        PDLGNODE pDlgNode;
        TUISPIDLLCALLBACK   Callback;

        pDlgNode=(PDLGNODE)lParam;

        idLine =  pDlgNode->idLine;

        // remember the Line ID passed in
        //
        SetWindowLongPtr(hwnd, DWLP_USER, (LONG_PTR)lParam);

        NumberReq.DlgReq.dwCmd = UI_REQ_GET_PHONENUMBER;
        NumberReq.DlgReq.dwParam = MANUAL_DIAL_DLG;

        Callback=GetCallbackProc(pDlgNode->Parent);

        lstrcpyA(NumberReq.szPhoneNumber,"");

        (*Callback)(idLine, TUISPIDLL_OBJECT_LINEID,
                          (LPVOID)&NumberReq, sizeof(NumberReq));

#ifdef UNICODE
        if (MultiByteToWideChar(CP_ACP,
                                0,
                                NumberReq.szPhoneNumber,
                                -1,
                                szUnicodeBuf,
                                sizeof(szUnicodeBuf) / sizeof(TCHAR)))
        {
            SetDlgItemText(
                hwnd,
                IDC_PHONENUMBER,
                szUnicodeBuf
                );


        }
#else // UNICODE

        SetDlgItemText(
            hwnd,
            IDC_PHONENUMBER,
            NumberReq.szPhoneNumber
            );


#endif // UNICODE

        // SetFocus(hwndScrn);
        // SetActiveWindow(hwndScrn);


        return 1;
        break;
        }
      case WM_COMMAND:
      {
        UINT idCmd = GET_WM_COMMAND_ID(wParam, lParam);



        if (idCmd == IDCONNECT || idCmd == IDCANCEL)
        {
          PDLGNODE pDlgNode;

          pDlgNode= (PDLGNODE)GetWindowLongPtr(hwnd, DWLP_USER);

          idLine =  pDlgNode->idLine;

          EndMdmDialog(pDlgNode->Parent,idLine, MANUAL_DIAL_DLG,
                       (idCmd == IDCONNECT) ? 0 : IDERR_OPERATION_ABORTED);
          return 1;
          break;
        }
        break;
      }
      case WM_DESTROY:
      {
        DLGREQ  DlgReq;
        TUISPIDLLCALLBACK   Callback;

        PDLGNODE pDlgNode;

        pDlgNode= (PDLGNODE)GetWindowLongPtr(hwnd, DWLP_USER);

        idLine =  pDlgNode->idLine;


        DlgReq.dwCmd = UI_REQ_END_DLG;
        DlgReq.dwParam = MANUAL_DIAL_DLG;

        Callback=GetCallbackProc(pDlgNode->Parent);

        (*Callback)(idLine, TUISPIDLL_OBJECT_LINEID,
                          (LPVOID)&DlgReq, sizeof(DlgReq));
        break;
      }
    }

    return 0;
}



//****************************************************************************
// HWND CreateManualDlg(HWND hwndOwner, ULONG_PTR idLine)
//
// Function: creates a modeless talk/drop dialog box
//
// Returns:  the modeless window handle
//
//****************************************************************************

HWND CreateManualDlg(HWND hwndOwner, ULONG_PTR idLine)
{
 HWND hwnd, hwndForeground;

    hwndForeground = GetForegroundWindow ();
    if (NULL == hwndForeground)
    {
        hwndForeground = hwndOwner;
    }

    // Create dialog
    //
    hwnd = CreateDialogParam (g.hModule,
                              MAKEINTRESOURCE(IDD_MANUAL_DIAL),
                              hwndForeground,//hwndOwner,
                              ManualDialDlgProc,
                              (LPARAM)idLine);
    return hwnd;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\tsp\apptspi.h ===
// 
// Copyright (c) 1996-1997 Microsoft Corporation.
//
//
// Component
//
//		Unimodem 5.0 TSP (Win32, user mode DLL)
//
// File
//
//		TSPIAPP.H
//
//      This header file is used both by code that executes in the TSP's
//      context and by code that executes in the client app's context.
//
//		It defines the objects that are passed back-and-between
//      the client app and the tsp using TUISPI_providerGenericDialogData
//      and TSPI_providerGenericDialogData.
//
//
// History
//
//		04/05/1997  JosephJ Created, taking stuff from wndthrd.h, talkdrop.h,
//                          etc. in NT4.0 unimodem.
//
//



#define DLG_CMD_FREE_INSTANCE   0
#define DLG_CMD_CREATE          1
#define DLG_CMD_DESTROY         2


// Dialog Types
//
#define TALKDROP_DLG            0
#define MANUAL_DIAL_DLG         1
#define TERMINAL_DLG            2

// Dialog Information: format of blobs sent from TSP to APP.
//
typedef struct tagDlgInfo {
    DWORD   dwCmd;
    DWORD   idLine;
    DWORD   dwType;
} DLGINFO, *PDLGINFO;



// Dialog Information: format of blobs sent from app to TSP.
//
typedef struct tagDlgReq {
    DWORD   dwCmd;
    DWORD   dwParam;
} DLGREQ, *PDLGREQ;

typedef struct tagTermReq {
    DLGREQ  DlgReq;
    HANDLE  hDevice;
    DWORD   dwTermType;
} TERMREQ, *PTERMREQ;

#define MAXDEVICENAME 128

typedef struct tagPropReq {
    DLGREQ  DlgReq;
    DWORD   dwCfgSize;
    DWORD   dwMdmType;
    DWORD   dwMdmCaps;
    DWORD   dwMdmOptions;
    TCHAR   szDeviceName[MAXDEVICENAME+1];
} PROPREQ, *PPROPREQ;    

typedef struct tagNumberReq {
    DLGREQ  DlgReq;
    DWORD   dwSize;
    CHAR    szPhoneNumber[MAXDEVICENAME+1];
} NUMBERREQ, *PNUMBERREQ;


#define UI_REQ_COMPLETE_ASYNC   0
#define UI_REQ_END_DLG          1
#define UI_REQ_HANGUP_LINE      2
#define UI_REQ_TERMINAL_INFO    3
#define UI_REQ_GET_PROP         4
#define UI_REQ_GET_UMDEVCFG     5
#define UI_REQ_SET_UMDEVCFG     6
#define UI_REQ_GET_PHONENUMBER  7
#define UI_REQ_GET_UMDEVCFG_DIALIN     8
#define UI_REQ_SET_UMDEVCFG_DIALIN     9
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\tsp\appcfg.cpp ===
// 
// Copyright (c) 1996-1997 Microsoft Corporation.
//
//
// Component
//
//		Unimodem 5.0 TSP (Win32, user mode DLL)
//
// File
//
//		APPDLG.CPP
//		Implements Generic Dialog functionality in
//      the client app.
//      (RUNS IN CLIENT APP CONTEXT)
//
// History
//
//		04/05/1997  JosephJ Created, taking stuff from cfgdlg.c in NT4 TSP.

#include "tsppch.h"
#include "rcids.h"
#include "tspcomm.h"
#include "globals.h"
#include "app.h"
#include "apptspi.h"

FL_DECLARE_FILE(0x7cb8c92f, "Implements Generic Dialog functionality")

#define COLOR_APP FOREGROUND_GREEN


LONG ValidateDevCfgClass(LPCTSTR lpszDeviceClass)
{
    //
    //  1/28/1998 JosephJ
    //  Following code attempts to return meaningful errors. The NT4.0
    //  tsp would always succeed if it was any known class, but
    //  for NT5 we are more picky. Also unlike the processing
    //  of device classes in the TSP itself, we do not take into
    //  account the specific modem's properties -- whether it is
    //  a voice modem or not, for example.
    //
    //  At any rate, the only valid classes associated with
    // UMDEVCFG are NULL, "", tapi/line, comm and comm/datamodem.
    //
    if (
            !lpszDeviceClass
        ||  !*lpszDeviceClass
        ||  !lstrcmpi(lpszDeviceClass, TEXT("tapi/line"))
        ||  !lstrcmpi(lpszDeviceClass,  TEXT("comm"))
        ||  !lstrcmpi(lpszDeviceClass,  TEXT("comm/datamodem"))
        ||  !lstrcmpi(lpszDeviceClass,  TEXT("comm/datamodem/dialin"))
        ||  !lstrcmpi(lpszDeviceClass,  TEXT("comm/datamodem/dialout")))
    {
        return ERROR_SUCCESS;
    }
    else if (    !lstrcmpi(lpszDeviceClass, TEXT("tapi/line/diagnostics"))
             ||  !lstrcmpi(lpszDeviceClass,  TEXT("comm/datamodem/portname"))
             ||  !lstrcmpi(lpszDeviceClass,  TEXT("tapi/phone"))
             ||  !lstrcmpi(lpszDeviceClass,  TEXT("wave/in"))
             ||  !lstrcmpi(lpszDeviceClass,  TEXT("wave/out")))
    {
        return LINEERR_OPERATIONUNAVAIL;
    }
    else
    {
        return  LINEERR_INVALDEVICECLASS;
    }

}

typedef struct tagDevCfgDlgInfo {
    DWORD       dwType;
    DWORD       dwDevCaps;
    DWORD       dwOptions;
    PUMDEVCFG    lpDevCfg;
} DCDI, *PDCDI, FAR* LPDCDI;


// Private prototype exported by MODEMUI.DLL

// #define MODEMUI4 1

#if (MODEMUI4)
typedef DWORD (WINAPI *LPFNMDMDLG)(LPWSTR, HWND, LPCOMMCONFIG, LPVOID, DWORD);
#endif // MODEMUI4

int UnimdmSettingProc (HWND hWnd, UINT message, 
                           WPARAM  wParam, LPARAM  lParam);

//****************************************************************************
//*********************** The Device ID Specific Calls************************
//****************************************************************************

//****************************************************************************
// void DevCfgDialog(HWND hwndOwner,
//                   DWORD dwType,
//                   DWORD dwDevCaps,
//                   DWORD dwOptions,
//                   PUMDEVCFG lpDevCfg)
//
// Functions: Displays the modem property pages
//
// Return:    None.
//****************************************************************************

void DevCfgDialog (HWND hwndOwner,
                   PPROPREQ pPropReq,
                   PUMDEVCFG lpDevCfg)
{
  HMODULE         hMdmUI;
  PROPSHEETPAGE   psp;
  DCDI            dcdi;
  #if (MODEMUI4)
  LPFNMDMDLG      lpfnMdmDlg;
  #else // !MODEMUI4
  PFNUNIMODEMDEVCONFIGDIALOG lpfnMdmDlg;
  #endif // !MODEMUI4
  UINT            uNumWideChars;
#ifndef UNICODE
  LPWSTR          lpwszDeviceName;

  // Convert pPropReq->szDeviceName (Ansi) to lpwszDeviceName (Unicode)

  // Get number of wide chars to alloc
  uNumWideChars = MultiByteToWideChar(CP_ACP,
                                      MB_PRECOMPOSED,
                                      pPropReq->szDeviceName,
                                      -1,
                                      NULL,
                                      0);

  // Alloc with room for terminator
  lpwszDeviceName = (LPWSTR)ALLOCATE_MEMORY(
                                       (1 + uNumWideChars) * sizeof(WCHAR)
                                       );
  if (NULL == lpwszDeviceName)
  {
    return;
  }

  // Do the conversion and call modemui.dll if it succeeds.
  if (MultiByteToWideChar(CP_ACP,
                          MB_PRECOMPOSED,
                          pPropReq->szDeviceName,
                          -1,
                          lpwszDeviceName,
                          uNumWideChars))
  {
#endif // UNICODE

  // Load the modemui library
  //
  TCHAR szLib[MAX_PATH];
  GetSystemDirectory(szLib,sizeof(szLib) / sizeof(TCHAR));
  lstrcat(szLib,TEXT("\\modemui.dll"));
  if ((hMdmUI = LoadLibrary(szLib)) != NULL)
  {
#if (MODEMUI4)
    lpfnMdmDlg = (LPFNMDMDLG)GetProcAddress(hMdmUI, "Mdm_CommConfigDialog");
    if (lpfnMdmDlg != NULL)
    {
      dcdi.dwType     = pPropReq->dwMdmType;
      dcdi.dwDevCaps  = pPropReq->dwMdmCaps;
      dcdi.dwOptions  = pPropReq->dwMdmOptions;
      dcdi.lpDevCfg   = lpDevCfg;

      // Prepare our own property page
      //
      psp.dwSize      = sizeof(PROPSHEETPAGE);
      psp.dwFlags     = 0;
      psp.hInstance   = g.hModule;
      psp.pszTemplate = MAKEINTRESOURCE(IDD_TERMINALSETTING);
      psp.pfnDlgProc  = UnimdmSettingProc;
      psp.lParam      = (LPARAM)(LPDCDI)&dcdi;
      psp.pfnCallback = NULL;
      
      // Bring up property sheets for modems and get the updated commconfig
      //
    #ifdef UNICODE
      (*lpfnMdmDlg)(pPropReq->szDeviceName, hwndOwner,
    #else // UNICODE
      (*lpfnMdmDlg)(lpwszDeviceName, hwndOwner,
    #endif // UNICODE
                    (LPCOMMCONFIG)&(lpDevCfg->commconfig),
                    &psp , 1);
    };

#else // !MODEMUI4

    lpfnMdmDlg =  (PFNUNIMODEMDEVCONFIGDIALOG) GetProcAddress(
                                                    hMdmUI,
                                                    "UnimodemDevConfigDialog"
                                                    );

    if (lpfnMdmDlg != NULL)
    {
      // dcdi.dwType     = pPropReq->dwMdmType;
      // dcdi.dwDevCaps  = pPropReq->dwMdmCaps;
      // dcdi.dwOptions  = pPropReq->dwMdmOptions;
      // dcdi.lpDevCfg   = lpDevCfg;

      // Bring up property sheets for modems and get the updated commconfig
      //
      (*lpfnMdmDlg)(
        #ifdef UNICODE
            pPropReq->szDeviceName, hwndOwner,
        #else // UNICODE
            (*lpfnMdmDlg)(lpwszDeviceName, hwndOwner,
        #endif // UNICODE
            UMDEVCFGTYPE_COMM,
            0,
            NULL,
            (void *) lpDevCfg,
            NULL,
            0
            );
    };

#endif // !MODEMUI4

    FreeLibrary(hMdmUI);
  };
#ifndef UNICODE
  };
  FREE_MEMORY(lpwszDeviceName);
#endif // UNICODE
  return;
}

//****************************************************************************
// LONG
// TSPIAPI
// TUISPI_lineConfigDialog(
//     TUISPIDLLCALLBACK       pfnUIDLLCallback,
//     DWORD   dwDeviceID,
//     HWND    hwndOwner,
//     LPCSTR  lpszDeviceClass)
//
// Functions: Allows the user to edit the modem configuration through UI. The
//            modification is applied to the line immediately.
//
// Return:    ERROR_SUCCESS if successful
//            LINEERR_INVALDEVICECLASS if invalid device class
//            LINEERR_NODEVICE if invalid device ID
//****************************************************************************

LONG
TSPIAPI
TUISPI_lineConfigDialog(
    TUISPIDLLCALLBACK       pfnUIDLLCallback,
    DWORD   dwDeviceID,
    HWND    hwndOwner,
    LPCTSTR lpszDeviceClass
    )
{
  PDLGREQ     pDlgReq;
  DWORD       cbSize;
  DWORD       dwRet;
  PROPREQ     PropReq;
  BOOL        DialIn;


  // Validate the requested device class
  //
  dwRet = ValidateDevCfgClass(lpszDeviceClass);

  if (dwRet)
  {
      goto end;
  }

  //
  //  if the class pointer is null, assume dialin
  //
  DialIn = (lpszDeviceClass == NULL) ||
           (0 == lstrcmpi(lpszDeviceClass,  TEXT("comm/datamodem/dialin")));

  // Get the modem properties
  //
  PropReq.DlgReq.dwCmd   = UI_REQ_GET_PROP;
  PropReq.DlgReq.dwParam = 0;

  (*pfnUIDLLCallback)(dwDeviceID, TUISPIDLL_OBJECT_LINEID,
                     (LPVOID)&PropReq, sizeof(PropReq));                          

  // Bring up property sheets for modems and get the updated commconfig
  //
  cbSize = PropReq.dwCfgSize+sizeof(DLGREQ);
  if ((pDlgReq = (PDLGREQ)ALLOCATE_MEMORY(cbSize)) != NULL)
  {
    pDlgReq->dwCmd = DialIn ? UI_REQ_GET_UMDEVCFG_DIALIN : UI_REQ_GET_UMDEVCFG;
    pDlgReq->dwParam = PropReq.dwCfgSize;

    (*pfnUIDLLCallback)(dwDeviceID, TUISPIDLL_OBJECT_LINEID,
                        (LPVOID)pDlgReq, cbSize);
    
    DevCfgDialog(hwndOwner, &PropReq, (PUMDEVCFG)(pDlgReq+1));

    // Save the changes back
    //
    pDlgReq->dwCmd = DialIn ? UI_REQ_SET_UMDEVCFG_DIALIN : UI_REQ_SET_UMDEVCFG;

    (*pfnUIDLLCallback)(dwDeviceID, TUISPIDLL_OBJECT_LINEID,
                        (LPVOID)pDlgReq, cbSize);

    FREE_MEMORY(pDlgReq);
    dwRet = ERROR_SUCCESS;
  }
  else
  {
    dwRet = LINEERR_NOMEM;
  };

end:

  return dwRet;
}

//****************************************************************************
// LONG
// TSPIAPI
// TUISPI_lineConfigDialogEdit(
//     TUISPIDLLCALLBACK       pfnUIDLLCallback,
//     DWORD   dwDeviceID,
//     HWND    hwndOwner,
//     LPCSTR  lpszDeviceClass,
//     LPVOID  const lpDeviceConfigIn,
//     DWORD   dwSize,
//     LPVARSTRING lpDeviceConfigOut)
//
// Functions: Allows the user to edit the modem configuration through UI. The
//            modem configuration is passed in and modified in the config
//            structure. The modification does not applied to the line.
//
// Return:    ERROR_SUCCESS if successful
//            LINEERR_INVALPOINTER if invalid input/output buffer pointer
//            LINEERR_INVALDEVICECLASS if invalid device class
//            LINEERR_STRUCTURETOOSMALL if output buffer is too small
//            LINEERR_NODEVICE if invalid device ID
//****************************************************************************

LONG
TSPIAPI
TUISPI_lineConfigDialogEdit(
    TUISPIDLLCALLBACK       pfnUIDLLCallback,
    DWORD   dwDeviceID,
    HWND    hwndOwner,
    LPCTSTR lpszDeviceClass,
    LPVOID  const lpDeviceConfigIn,
    DWORD   dwSize,
    LPVARSTRING lpDeviceConfigOut)
{
  PDLGREQ     pDlgReq;
  DWORD       cbSize;
  DWORD       dwRet;
  PROPREQ     PropReq;


  // Validate the input/output buffer
  //
  if (lpDeviceConfigOut == NULL)
  {
    return LINEERR_INVALPOINTER;
  }

  if (lpDeviceConfigIn == NULL)
  {
    return LINEERR_INVALPOINTER;
  }

  if (lpDeviceConfigOut->dwTotalSize < sizeof(VARSTRING))
  {
    return LINEERR_STRUCTURETOOSMALL;
  }

  // Validate the requested device class
  //
  dwRet =  ValidateDevCfgClass(lpszDeviceClass);
  if (dwRet)
  {
      return dwRet;
  }

  // Get the modem properties
  //
  PropReq.DlgReq.dwCmd   = UI_REQ_GET_PROP;
  PropReq.DlgReq.dwParam = 0;

  (*pfnUIDLLCallback)(dwDeviceID, TUISPIDLL_OBJECT_LINEID,
                     (LPVOID)&PropReq, sizeof(PropReq));                          

  // Bring up property sheets for modems and get the updated commconfig
  //
  cbSize = PropReq.dwCfgSize+sizeof(DLGREQ);
  if ((pDlgReq = (PDLGREQ)ALLOCATE_MEMORY(cbSize)) != NULL)
  {
    PUMDEVCFG pDevCfg = (PUMDEVCFG)(pDlgReq+1);
    
    pDlgReq->dwCmd = UI_REQ_GET_UMDEVCFG;
    pDlgReq->dwParam = PropReq.dwCfgSize;
    (*pfnUIDLLCallback)(dwDeviceID, TUISPIDLL_OBJECT_LINEID,
                        (LPVOID)pDlgReq, cbSize);
    
    // Validate the device configuration structure
    //
    cbSize  = ((PUMDEVCFG)lpDeviceConfigIn)->dfgHdr.dwSize;
    if ((cbSize > pDevCfg->dfgHdr.dwSize) ||
        (pDevCfg->dfgHdr.dwVersion != ((PUMDEVCFG)lpDeviceConfigIn)->dfgHdr.dwVersion))
    {
      dwRet = LINEERR_INVALPARAM;
    }
    else
    {
      dwRet = ERROR_SUCCESS;
    };

    FREE_MEMORY(pDlgReq);
  }
  else
  {
    dwRet = LINEERR_NOMEM;
  };

  if (dwRet == ERROR_SUCCESS)
  {
    // Set the output buffer size
    //
    lpDeviceConfigOut->dwUsedSize = sizeof(VARSTRING);
    lpDeviceConfigOut->dwNeededSize = sizeof(VARSTRING) + cbSize;

    // Validate the output buffer size
    //
    if (lpDeviceConfigOut->dwTotalSize >= lpDeviceConfigOut->dwNeededSize)
    {
      PUMDEVCFG    lpDevConfig;

      // Initialize the buffer
      //
      lpDeviceConfigOut->dwStringFormat = STRINGFORMAT_BINARY;
      lpDeviceConfigOut->dwStringSize   = cbSize;
      lpDeviceConfigOut->dwStringOffset = sizeof(VARSTRING);
      lpDeviceConfigOut->dwUsedSize    += cbSize;

      lpDevConfig = (PUMDEVCFG)(lpDeviceConfigOut+1);
      CopyMemory((LPBYTE)lpDevConfig, (LPBYTE)lpDeviceConfigIn, cbSize);

      // Bring up property sheets for modems and get the updated commconfig
      //
      DevCfgDialog(hwndOwner, &PropReq, (PUMDEVCFG)lpDevConfig);
    };
  };
  return dwRet;
}

//****************************************************************************
// ErrMsgBox()
//
// Function: Displays an error message box from resource text.
//
// Returns:  None.
//
//****************************************************************************

void ErrMsgBox(HWND hwnd, UINT idsErr, UINT uStyle)
{
  LPTSTR    pszTitle, pszMsg;
  int       iRet;

  // Allocate the string buffer
  if ((pszTitle = (LPTSTR)ALLOCATE_MEMORY(
                                     (MAXTITLE+MAXMESSAGE) * sizeof(TCHAR)))
       == NULL)
    return;

  // Fetch the UI title and message
  iRet   = LoadString(g.hModule, IDS_ERR_TITLE, pszTitle, MAXTITLE) + 1;
  pszMsg = pszTitle + iRet;
  LoadString(g.hModule, idsErr, pszMsg, MAXTITLE+MAXMESSAGE-iRet);

  // Popup the message
  MessageBox(hwnd, pszMsg, pszTitle, uStyle);

  FREE_MEMORY(pszTitle);
  return;
}

//****************************************************************************
// IsInvalidSetting()
//
// Function: Validate the option settings.
//
//****************************************************************************

BOOL IsInvalidSetting(HWND hWnd)
{
  BOOL fValid = TRUE;
  UINT uSet;

  // Wait-for-bong setting
  //
  if(IsWindowEnabled(GetDlgItem(hWnd, IDC_WAIT_SEC)))
  {
    uSet = (UINT)GetDlgItemInt(hWnd, IDC_WAIT_SEC, &fValid, FALSE);

    // Check the valid setting
    //
    if ((!fValid) || (uSet > UMMAX_WAIT_BONG) || ((uSet + 1) < (UMMIN_WAIT_BONG + 1)))
    {
      HWND hCtrl = GetDlgItem(hWnd, IDC_WAIT_SEC);

      // It is invalid, tell the user to reset.
      //
      ErrMsgBox(hWnd, IDS_ERR_INV_WAIT, MB_OK | MB_ICONEXCLAMATION);
      SetFocus(hCtrl);
      Edit_SetSel(hCtrl, 0, 0x7FFFF);
      fValid = FALSE;
    };
  };

  return (!fValid);
}

//****************************************************************************
// UnimdmSettingProc()
//
// Function: A callback function to handle the terminal setting property page.
//
//****************************************************************************

int UnimdmSettingProc (HWND    hWnd,
                           UINT    message,
                           WPARAM  wParam,
                           LPARAM  lParam)
{
  PUMDEVCFG  lpDevCfg;
  DWORD     fdwOptions;

  switch (message)
  {
    case WM_INITDIALOG:
    {
      LPDCDI    lpdcdi;

      // Remember the pointer to the line device
      //
      lpdcdi   = (LPDCDI)(((LPPROPSHEETPAGE)lParam)->lParam);

      lpDevCfg = lpdcdi->lpDevCfg;
      SetWindowLongPtr(hWnd, DWLP_USER, (LONG_PTR)lpDevCfg);
      fdwOptions = lpDevCfg->dfgHdr.fwOptions;

      // Initialize the appearance of the dialog box
      CheckDlgButton(hWnd, IDC_TERMINAL_PRE,
                     fdwOptions & UMTERMINAL_PRE ? BST_CHECKED : BST_UNCHECKED);
      CheckDlgButton(hWnd, IDC_TERMINAL_POST,
                     fdwOptions & UMTERMINAL_POST ? BST_CHECKED : BST_UNCHECKED);

      // Don't enable manual dial unless the modem supports BLIND dialing
      // We need that capability to be able to do it.
      //
      if (lpdcdi->dwOptions & MDM_BLIND_DIAL)
      {
        CheckDlgButton(hWnd, IDC_MANUAL_DIAL,
                       fdwOptions & UMMANUAL_DIAL ? BST_CHECKED : BST_UNCHECKED);
      }
      else
      {
        EnableWindow(GetDlgItem(hWnd, IDC_MANUAL_DIAL), FALSE);
      };

      // Enable for bong UI only for a modem that does not support bong
      if ((lpdcdi->dwType != DT_NULL_MODEM) &&
          !(lpdcdi->dwDevCaps & LINEDEVCAPFLAGS_DIALBILLING))
      {
        UDACCEL udac;

        SetDlgItemInt(hWnd, IDC_WAIT_SEC, lpDevCfg->dfgHdr.wWaitBong, FALSE);
        SendDlgItemMessage(hWnd, IDC_WAIT_SEC_ARRW, UDM_SETRANGE, 0,
                           MAKELPARAM(UMMAX_WAIT_BONG, UMMIN_WAIT_BONG));
        SendDlgItemMessage(hWnd, IDC_WAIT_SEC_ARRW, UDM_GETACCEL, 1,
                           (LPARAM)(LPUDACCEL)&udac);
        udac.nInc = UMINC_WAIT_BONG;
        SendDlgItemMessage(hWnd, IDC_WAIT_SEC_ARRW, UDM_SETACCEL, 1,
                           (LPARAM)(LPUDACCEL)&udac);
      }
      else
      {
        EnableWindow(GetDlgItem(hWnd, IDC_WAIT_TEXT), FALSE);
        EnableWindow(GetDlgItem(hWnd, IDC_WAIT_SEC), FALSE);
        EnableWindow(GetDlgItem(hWnd, IDC_WAIT_SEC_ARRW), FALSE);
        EnableWindow(GetDlgItem(hWnd, IDC_WAIT_UNIT), FALSE);
      };

      // Never display lights for null modem
      //
      if (lpdcdi->dwType == DT_NULL_MODEM)
      {
        ShowWindow(GetDlgItem(hWnd, IDC_LAUNCH_LIGHTSGRP), SW_HIDE);
        ShowWindow(GetDlgItem(hWnd, IDC_LAUNCH_LIGHTSGRP), SW_HIDE);
        EnableWindow(GetDlgItem(hWnd, IDC_LAUNCH_LIGHTS), FALSE);
        EnableWindow(GetDlgItem(hWnd, IDC_LAUNCH_LIGHTS), FALSE);
      }
      else
      {
        CheckDlgButton(hWnd, IDC_LAUNCH_LIGHTS,
                       fdwOptions & UMLAUNCH_LIGHTS ? BST_CHECKED : BST_UNCHECKED);
      };
      break;
    }

#ifdef UNDER_CONSTRUCTION
    case WM_HELP:
    case WM_CONTEXTMENU:
      ContextHelp(gaUmdmOptions, message, wParam, lParam);
      break;
#endif // UNDER_CONSTRUCTION

    case WM_NOTIFY:
      switch(((NMHDR FAR *)lParam)->code)
      {
        case PSN_KILLACTIVE:
          SetWindowLongPtr(hWnd, DWLP_MSGRESULT, (LONG_PTR)IsInvalidSetting(hWnd));
          return TRUE;

        case PSN_APPLY:
          //
          // The property sheet information is permanently applied
          //
          lpDevCfg = (PUMDEVCFG)GetWindowLongPtr(hWnd, DWLP_USER);

          // Wait-for-bong setting. We already validate it
          //
          if(IsWindowEnabled(GetDlgItem(hWnd, IDC_WAIT_SEC)))
          {
            BOOL fValid;
            UINT uWait;

            uWait = (WORD)GetDlgItemInt(hWnd, IDC_WAIT_SEC, &fValid, FALSE);
            lpDevCfg->dfgHdr.wWaitBong = (WORD) uWait;
            ASSERT(fValid);
          };

          // Other options
          //
          fdwOptions = UMTERMINAL_NONE;

          if(IsDlgButtonChecked(hWnd, IDC_TERMINAL_PRE))
            fdwOptions |= UMTERMINAL_PRE;

          if(IsDlgButtonChecked(hWnd, IDC_TERMINAL_POST))
            fdwOptions |= UMTERMINAL_POST;

          if(IsDlgButtonChecked(hWnd, IDC_MANUAL_DIAL))
            fdwOptions |= UMMANUAL_DIAL;

          if(IsDlgButtonChecked(hWnd, IDC_LAUNCH_LIGHTS))
            fdwOptions |= UMLAUNCH_LIGHTS;

          // Record the setting
          lpDevCfg->dfgHdr.fwOptions = (WORD) fdwOptions;

          return TRUE;

        default:
          break;
      };
      break;

    default:
      break;
  }
  return FALSE;
}


LONG
TSPIAPI
TUISPI_phoneConfigDialog(
		TUISPIDLLCALLBACK lpfnUIDLLCallback,
		DWORD dwDeviceID,
		HWND hwndOwner,
		LPCWSTR lpszDeviceClass
)
{
	FL_DECLARE_FUNC(0xa6d3803f,"TUISPI_phoneConfigDialog");
	FL_DECLARE_STACKLOG(sl, 1000);
	LONG lRet = PHONEERR_OPERATIONUNAVAIL;

	sl.Dump(COLOR_APP);

	return lRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\tsp\appterm.cpp ===
//
// Copyright (c) 1996-1997 Microsoft Corporation.
//
//
// Component
//
//		Unimodem 5.0 TSP (Win32, user mode DLL)
//
// File
//
//		APPTERM.CPP
//		Implements Pre/Post Terminal UI.
//      (RUNS IN CLIENT APP CONTEXT)
//
// History
//
//		04/05/1997  JosephJ Created, taking stuff from terminal.c in NT4 TSP.

#include "tsppch.h"
#include <regstr.h>
#include <commctrl.h>
#include <windowsx.h>
#include "rcids.h"
#include "tspcomm.h"
#include "globals.h"
#include "app.h"
#include "apptspi.h"


//****************************************************************************
// Constants Declaration
//****************************************************************************

#define MAXTITLE               32
#define MAXMESSAGE             256

#define WM_MODEMNOTIFY         (WM_USER + 998)
#define WM_EOLFROMDEVICE       (WM_USER + 999)

#define SIZE_ReceiveBuf        1024
#define SIZE_SendBuf           1

#define Y_MARGIN               4
#define X_SPACING              2
#define MIN_X                  170
#define MIN_Y                  80

#define TERMINAL_BK_COLOR      (RGB( 0, 0, 0 ))
#define TERMINAL_FR_COLOR      (RGB( 255, 255, 255 ))
#define MAXTERMLINE            24

#define READ_EVENT             0
#define STOP_EVENT             1
#define MAX_EVENT              2

//****************************************************************************
// Type Definitions
//****************************************************************************

typedef struct  tagTERMDLG {
    BOOL     fStop;
    HANDLE   hport;
    HANDLE   hThread;
    HANDLE   hEvent[MAX_EVENT];
    HWND     hwnd;
    PBYTE    pbyteReceiveBuf;
    PBYTE    pbyteSendBuf;
    HBRUSH   hbrushScreenBackground;
    HFONT    hfontTerminal;
    WNDPROC  WndprocOldTerminalScreen;
    ULONG_PTR idLine;
    HWND     ParenthWnd;
}   TERMDLG, *PTERMDLG, FAR* LPTERMDLG;

//****************************************************************************
// Function prototypes
//****************************************************************************

LRESULT FAR PASCAL TerminalDlgWndProc(HWND   hwnd,
                                      UINT   wMsg,
                                      WPARAM wParam,
                                      LPARAM lParam );
LRESULT FAR PASCAL TerminalScreenWndProc(HWND   hwnd,
                                         UINT   wMsg,
                                         WPARAM wParam,
                                         LPARAM lParam );
BOOL NEAR PASCAL OnCommand (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
BOOL NEAR PASCAL GetInput  (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
VOID NEAR PASCAL SendCharacter( HWND hwnd, BYTE byte );
VOID NEAR PASCAL AdjustTerminal (HWND hwnd, int wWidth, int wHeight);
DWORD WINAPI      TerminalThread (PTERMDLG  pTerminaldialog);

//****************************************************************************
// HWND CreateTerminalDlg(HWND hwndOwner, ULONG_PTR idLine)
//
// Function: creates a modeless terminal dialog box
//
// Returns:  the modeless window handle
//
//****************************************************************************

HWND CreateTerminalDlg(HWND hwndOwner, ULONG_PTR idLine)
{
  HANDLE    hComm;
  HWND      hwnd;
  COMMTIMEOUTS commtimeout;
  PTERMDLG  pTerminaldialog;
  DWORD     id;
  int       i;
  int       iRet;
  TERMREQ   TermReq;

  TUISPIDLLCALLBACK   Callback;

  Callback=GetCallbackProc(hwndOwner);

  // Get the terminal parameters
  //
  TermReq.DlgReq.dwCmd   = UI_REQ_TERMINAL_INFO;
  TermReq.DlgReq.dwParam = GetCurrentProcessId();

  (*Callback)(idLine, TUISPIDLL_OBJECT_LINEID,
                    (LPVOID)&TermReq, sizeof(TermReq));
  hComm = TermReq.hDevice;

  // Allocate the terminal buffer
  //
  if ((pTerminaldialog = (PTERMDLG)ALLOCATE_MEMORY(sizeof(*pTerminaldialog)))
      == NULL)
    return NULL;

  if ((pTerminaldialog->pbyteReceiveBuf = (PBYTE)ALLOCATE_MEMORY(
							    SIZE_ReceiveBuf
                                                            + SIZE_SendBuf))
      == NULL)
  {
    FREE_MEMORY(pTerminaldialog);
    return NULL;
  };
  pTerminaldialog->pbyteSendBuf = pTerminaldialog->pbyteReceiveBuf + SIZE_ReceiveBuf;

  // Initialize the terminal buffer
  //
  pTerminaldialog->ParenthWnd= hwndOwner;
  pTerminaldialog->hport   = hComm;
  pTerminaldialog->idLine  = idLine;
  pTerminaldialog->hbrushScreenBackground = (HBRUSH)GetStockObject( BLACK_BRUSH );
  pTerminaldialog->hfontTerminal = (HFONT)GetStockObject( SYSTEM_FIXED_FONT );

  // Start receiving from the port
  //
  commtimeout.ReadIntervalTimeout = MAXDWORD;
  commtimeout.ReadTotalTimeoutMultiplier = 0;
  commtimeout.ReadTotalTimeoutConstant   = 0;
  commtimeout.WriteTotalTimeoutMultiplier= 0;
  commtimeout.WriteTotalTimeoutConstant  = 1000;
  SetCommTimeouts(hComm, &commtimeout);

  SetCommMask(hComm, EV_RXCHAR);

  if (TermReq.dwTermType == UMTERMINAL_PRE) {

#define ECHO_OFF "ATE1\r"

      COMMTIMEOUTS commtimeout;
      HANDLE       hEvent;

      hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);


      if (hEvent != NULL) {

          DWORD        cb;
          OVERLAPPED   ov;
          BOOL         bResult;

          ov.Offset       = 0;
          ov.OffsetHigh   = 0;

          // OR with 1 to prevent it from being posted to the completion port.
          //
          ov.hEvent       = (HANDLE)((ULONG_PTR)hEvent | 1);

          bResult=WriteFile(
              hComm,
              ECHO_OFF,
              sizeof(ECHO_OFF)-1,
              &cb,
              &ov
              );


          if (!bResult) {

              DWORD dwResult = GetLastError();

              if (ERROR_IO_PENDING == dwResult) {

                  GetOverlappedResult(
                      hComm,
                      &ov,
                      &cb,
                      TRUE
                      );
              }
          }

          CloseHandle(hEvent);
      }
  }


  // Create read thread and the synchronization objects
  for (i = 0; i < MAX_EVENT; i++)
  {
    pTerminaldialog->hEvent[i] = CreateEvent(NULL, FALSE, FALSE, NULL);
  };

  pTerminaldialog->hThread = CreateThread(NULL, 0,
                                         (LPTHREAD_START_ROUTINE) TerminalThread,
                                         pTerminaldialog, 0, &id);

  // Create the terminal window
  hwnd = CreateDialogParam(g.hModule,
                        MAKEINTRESOURCE(IDD_TERMINALDLG),
                        hwndOwner,
                        (DLGPROC)TerminalDlgWndProc,
                        (LPARAM)pTerminaldialog);

  if (IsWindow(hwnd))
  {
    TCHAR szTitle[MAXTITLE];

    // Set window caption
    //
    LoadString (g.hModule,
                (TermReq.dwTermType == UMTERMINAL_POST)?
                IDS_POSTTERM_TITLE : IDS_PRETERM_TITLE,
                szTitle, sizeof(szTitle) / sizeof(TCHAR));
    SetWindowText(hwnd, szTitle);
  }
  else
  {
    // The terminal dialog was terminalted, free resources
    //
    SetEvent(pTerminaldialog->hEvent[STOP_EVENT]);

    SetCommMask(hComm, 0);
    WaitForSingleObject(pTerminaldialog->hThread, INFINITE);
    CloseHandle(pTerminaldialog->hThread);

    for (i = 0; i < MAX_EVENT; i++)
    {
      CloseHandle(pTerminaldialog->hEvent[i]);
    };

    FREE_MEMORY(pTerminaldialog->pbyteReceiveBuf);
    FREE_MEMORY(pTerminaldialog);

    hwnd = NULL;
  };

  return hwnd;
}


/*----------------------------------------------------------------------------
** Terminal Window Procedure
**----------------------------------------------------------------------------
*/

LRESULT FAR PASCAL TerminalDlgWndProc(HWND   hwnd,
                                      UINT   wMsg,
                                      WPARAM wParam,
                                      LPARAM lParam )
{
  PTERMDLG pTerminaldialog;
  HWND     hwndScrn;
  RECT     rect;

  switch (wMsg)
  {
    case WM_INITDIALOG:
      pTerminaldialog = (PTERMDLG)lParam;
      SetWindowLongPtr(hwnd, DWLP_USER, (LONG_PTR)lParam);
      SetForegroundWindow(hwnd);
      pTerminaldialog->hwnd = hwnd;

      // Install subclassed WndProcs.
      //
      hwndScrn = GetDlgItem(hwnd, CID_T_EB_SCREEN);
      pTerminaldialog->WndprocOldTerminalScreen =
          (WNDPROC)SetWindowLongPtr( hwndScrn, GWLP_WNDPROC,
                                  (LONG_PTR)TerminalScreenWndProc );

      // Set the terminal screen font
      //
      SendMessage(hwndScrn, WM_SETFONT, (WPARAM)pTerminaldialog->hfontTerminal,
                  0L);

      // Adjust the dimension
      //
      GetClientRect(hwnd, &rect);
      AdjustTerminal(hwnd, rect.right-rect.left, rect.bottom-rect.top);

      // Start receiving from the port
      //
      PostMessage(hwnd, WM_MODEMNOTIFY, 0, 0);

      // Set the input focus to the screen
      //
      SetFocus(hwndScrn);
      SetActiveWindow(hwndScrn);
      return 0;

    case WM_CTLCOLOREDIT:
    {
      pTerminaldialog = (PTERMDLG)GetWindowLongPtr(hwnd, DWLP_USER);

      /* Set terminal screen colors to TTY-ish green on black.
      */
      if (pTerminaldialog->hbrushScreenBackground)
      {
        SetBkColor( (HDC)wParam,  TERMINAL_BK_COLOR );
        SetTextColor((HDC)wParam, TERMINAL_FR_COLOR );

        return (LRESULT)pTerminaldialog->hbrushScreenBackground;
      }

      break;
    };

    case WM_MODEMNOTIFY:
      return GetInput(hwnd, wMsg, wParam, lParam);


    case WM_COMMAND:

      // Handle the control activities
      //
      return OnCommand(hwnd, wMsg, wParam, lParam);

    case WM_DESTROY:
    {
      DLGREQ  DlgReq;
      int   i;
      TUISPIDLLCALLBACK   Callback;

      pTerminaldialog = (PTERMDLG)GetWindowLongPtr(hwnd, DWLP_USER);
      SetWindowLongPtr( GetDlgItem(hwnd, CID_T_EB_SCREEN), GWLP_WNDPROC,
                     (LONG_PTR)pTerminaldialog->WndprocOldTerminalScreen );

      // Destroy the dialog
      //
      DlgReq.dwCmd = UI_REQ_END_DLG;
      DlgReq.dwParam = TERMINAL_DLG;

      Callback=GetCallbackProc(pTerminaldialog->ParenthWnd);

      (*Callback)(pTerminaldialog->idLine, TUISPIDLL_OBJECT_LINEID,
                        (LPVOID)&DlgReq, sizeof(DlgReq));


      EnterUICritSect();
      pTerminaldialog->fStop=TRUE;

      //
      // The terminal dialog was terminated, free resources
      //
      SetEvent(pTerminaldialog->hEvent[STOP_EVENT]);

      if (pTerminaldialog->hport != NULL)
      {
        if (!SetCommMask(pTerminaldialog->hport, 0))
        {
            //
            // 2/12/1998 JosephJ
            //
            //  We can get here if the comm handle has been invalidated ...
            //  See comments in function TerminalThread, where it's
            //  waiting on WaitCommEvent.
            //
            // OutputDebugString(TEXT("WndProc: SetCommMask fails.\r\n"));
            //
            // Anyway, we do nothing here -- we've already set the
            // stop event.
            //
            // Note -- the terminal code is poorly written -- it was
            // inhereted from nt4/win9x.
            //

        }
      };
      LeaveUICritSect();

      if (pTerminaldialog->hThread != NULL)
      {
        WaitForSingleObject(pTerminaldialog->hThread, INFINITE);
        CloseHandle(pTerminaldialog->hThread);
      };

      CloseHandle(pTerminaldialog->hport);

      for (i = 0; i < MAX_EVENT; i++)
      {
        CloseHandle(pTerminaldialog->hEvent[i]);
      };

      FREE_MEMORY(pTerminaldialog->pbyteReceiveBuf);
      FREE_MEMORY(pTerminaldialog);
      break;
    }
    case WM_SIZE:
      AdjustTerminal(hwnd, (int)LOWORD(lParam), (int)HIWORD(lParam));
      break;

    case WM_GETMINMAXINFO:
    {
      MINMAXINFO FAR* lpMinMaxInfo = (MINMAXINFO FAR*)lParam;
      DWORD           dwUnit = GetDialogBaseUnits();

      lpMinMaxInfo->ptMinTrackSize.x = (MIN_X*LOWORD(dwUnit))/4;
      lpMinMaxInfo->ptMinTrackSize.y = (MIN_Y*LOWORD(dwUnit))/4;
      break;
    };
  };

  return 0;
}

/*----------------------------------------------------------------------------
** Terminal Screen Subclasses Window Procedure
**----------------------------------------------------------------------------
*/

LRESULT FAR PASCAL TerminalScreenWndProc(HWND   hwnd,
                                         UINT   wMsg,
                                         WPARAM wParam,
                                         LPARAM lParam )
{
  HWND     hwndParent;
  PTERMDLG pTerminaldialog;

  hwndParent      = GetParent(hwnd);
  pTerminaldialog = (PTERMDLG)GetWindowLongPtr(hwndParent, DWLP_USER);

  if (wMsg == WM_PASTE)
  {
      if (IsClipboardFormatAvailable(CF_TEXT) == TRUE)
      {
          if (OpenClipboard(hwnd))
          {
              HANDLE hMem;
              char * pStr;
              int i;

              if ((hMem = GetClipboardData(CF_TEXT)))
              {
                  if ((pStr = (char *)GlobalLock(hMem)))
                  {
                      for(i=0;i<(int)strlen(pStr);i++)
                      {
                        if ((BYTE)pStr[i] != (BYTE)'\n')
                        {
                            SendCharacter(hwndParent, (BYTE)pStr[i]);
                            Sleep(10);
                        }
                      }

                      SendCharacter(hwndParent, (BYTE)'\r');
                      Sleep(10);

                      GlobalUnlock(hMem);
                  }
              }
          }
          CloseClipboard();
      }

      return 0;
  } else if (wMsg == WM_EOLFROMDEVICE)
  {
    /* Remove the first line if the next line exceeds the maximum line
    */
    if (SendMessage(hwnd, EM_GETLINECOUNT, 0, 0L) == MAXTERMLINE)
    {
      SendMessage(hwnd, EM_SETSEL, 0,
                  SendMessage(hwnd, EM_LINEINDEX, 1, 0L));
      SendMessage(hwnd, EM_REPLACESEL, 0, (LPARAM)(LPTSTR)TEXT(""));
      SendMessage(hwnd, EM_SETSEL, 32767, 32767);
      SendMessage(hwnd, EM_SCROLLCARET, 0, 0);
    };

    /* An end-of-line in the device input was received.  Send a linefeed
    ** character to the window.
    */
    wParam = '\n';
    wMsg = WM_CHAR;
  }
  else
  {
    BOOL fCtrlKeyDown = (GetKeyState( VK_CONTROL ) < 0);
    BOOL fShiftKeyDown = (GetKeyState( VK_SHIFT ) < 0);

    if (wMsg == WM_KEYDOWN)
    {
      /* The key was pressed by the user.
      */
      if (wParam == VK_RETURN && !fCtrlKeyDown && !fShiftKeyDown)
      {
        /* Enter key pressed without Shift or Ctrl is discarded.  This
        ** prevents Enter from being interpreted as "press default
        ** button" when pressed in the edit box.
        */
        return 0;
      }

      if (fCtrlKeyDown && wParam == VK_TAB)
      {
        /* Ctrl+Tab pressed.  Send a tab character to the device.
        ** Pass tab thru to let the edit box handle the visuals.
        ** Ctrl+Tab doesn't generate a WM_CHAR.
        */
        SendCharacter( hwndParent, (BYTE )VK_TAB );
      }

      if (GetKeyState( VK_MENU ) < 0)
      {
        return (CallWindowProc(pTerminaldialog->WndprocOldTerminalScreen, hwnd, wMsg, wParam, lParam ));
      };
    }
    else if (wMsg == WM_CHAR)
    {
      /* The character was typed by the user.
      */
      if (wParam == VK_TAB)
      {
        /* Ignore tabs...Windows sends this message when Tab (leave
        ** field) is pressed but not when Ctrl+Tab (insert a TAB
        ** character) is pressed...weird.
        */
        return 0;
      }

#ifdef UNICODE
      {
        CHAR chAnsi;

        if (WideCharToMultiByte(CP_ACP,
                                0,
                                (LPWSTR)&wParam,
                                1,
                                &chAnsi,
                                1,
                                NULL,
                                NULL))
        {
          SendCharacter( hwndParent, (BYTE )chAnsi );
        }
      }
#else // UNICODE
      SendCharacter( hwndParent, (BYTE )wParam );
#endif // UNICODE

      return 0;
    }
  }

  /* Call the previous window procedure for everything else.
  */
  return (CallWindowProc(pTerminaldialog->WndprocOldTerminalScreen, hwnd, wMsg, wParam, lParam ));
}

/*----------------------------------------------------------------------------
** Terminal Window's Control Handler
**----------------------------------------------------------------------------
*/

BOOL NEAR PASCAL OnCommand (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
  switch (GET_WM_COMMAND_ID(wParam, lParam))
  {
    case CID_T_EB_SCREEN:
    {
      switch (HIWORD(wParam))
      {
        case EN_SETFOCUS:
        {
          /* Turn off the default button whenever the terminal
          ** window has the focus.  Pressing [Return] in the
          ** terminal acts like a normal terminal.
          */
          SendDlgItemMessage(hwnd, CID_T_PB_ENTER, BM_SETSTYLE,
                             (WPARAM)BS_DEFPUSHBUTTON, TRUE);

          /* Don't select the entire string on entry.
          */
          SendDlgItemMessage(hwnd, CID_T_EB_SCREEN, EM_SETSEL,
                             32767, 32767);
          SendMessage(hwnd, EM_SCROLLCARET, 0, 0);
          break;
        };
      };

      break;
    };

    case IDOK:
    case IDCANCEL:
    {
      PTERMDLG  pTerminaldialog;

      pTerminaldialog = (PTERMDLG)GetWindowLongPtr(hwnd, DWLP_USER);
      EndMdmDialog(pTerminaldialog->ParenthWnd,pTerminaldialog->idLine, TERMINAL_DLG,
                   (GET_WM_COMMAND_ID(wParam, lParam) == IDOK) ?
                   0 : IDERR_OPERATION_ABORTED);
      break;
    }
  };
  return 0;
}


/*----------------------------------------------------------------------------
** Terminal Input Handler
**----------------------------------------------------------------------------
*/

BOOL NEAR PASCAL GetInput (HWND   hwnd,
                           UINT   usMsg,
                           WPARAM wParam,
                           LPARAM lParam )
{
  PTERMDLG  pTerminaldialog;
  DWORD     cbRead;
  OVERLAPPED ov;
  HANDLE    hEvent;
  COMMTIMEOUTS commtimeout;

  pTerminaldialog = (PTERMDLG)GetWindowLongPtr(hwnd, DWLP_USER);

  if ((hEvent = CreateEvent(NULL, TRUE, FALSE, NULL)) == NULL)
  {
    return FALSE;
  }

  // Set write timeout to one second
  //
  commtimeout.ReadIntervalTimeout = MAXDWORD;
  commtimeout.ReadTotalTimeoutMultiplier = 0;
  commtimeout.ReadTotalTimeoutConstant   = 0;
  commtimeout.WriteTotalTimeoutMultiplier= 0;
  commtimeout.WriteTotalTimeoutConstant  = 1000;
  SetCommTimeouts(pTerminaldialog->hport, &commtimeout);

  do
  {
    /* Make sure we still have the comm port
    */
    if (pTerminaldialog->hport == NULL)
      break;

    /* A character has been received from the device.
    */
    ov.Internal     = 0;
    ov.InternalHigh = 0;
    ov.Offset       = 0;
    ov.OffsetHigh   = 0;
    ov.hEvent       = (HANDLE)((ULONG_PTR)hEvent | 1);

    cbRead          = 0;

    if (FALSE == ReadFile(pTerminaldialog->hport,
                          pTerminaldialog->pbyteReceiveBuf,
                          SIZE_ReceiveBuf, (LPDWORD)&cbRead, &ov))
    {
      DWORD dwResult = GetLastError();

      if (ERROR_IO_PENDING == dwResult)
      {
        GetOverlappedResult(pTerminaldialog->hport,
                            &ov,
                            &cbRead,
                            TRUE);
      }
      else
      {
        // TBD:DPRINTF1("ReadFile() in GetInput() failed (0x%8x)!", dwResult);
      }
    };

    SetEvent(pTerminaldialog->hEvent[READ_EVENT]);

    /* Send the device talk to the terminal edit box.
    */
    if (cbRead != 0)
    {
        char  szBuf[ SIZE_ReceiveBuf + 1 ];
#ifdef UNICODE
        WCHAR szUnicodeBuf[ SIZE_ReceiveBuf + 1 ];
#endif // UNICODE
        LPSTR pch = szBuf;
        int   i, cb;
        HWND  hwndScrn = GetDlgItem(hwnd, CID_T_EB_SCREEN);

        cb = cbRead;
        for (i = 0; i < cb; ++i)
        {
            char ch = pTerminaldialog->pbyteReceiveBuf[ i ];

            /* Formatting: Converts CRs to LFs (there seems to be no VK_
            ** for LF) and throws away LFs.  This prevents the user from
            ** exiting the dialog when they press Enter (CR) in the
            ** terminal screen.  LF looks like CRLF in the edit box.  Also,
            ** throw away TABs because otherwise they change focus to the
            ** next control.
            */
            if (ch == VK_RETURN)
            {
                /* Must send whenever end-of-line is encountered because
                ** EM_REPLACESEL doesn't handle VK_RETURN characters well
                ** (prints garbage).
                */
                *pch = '\0';

                /* Turn off current selection, if any, and replace the null
                ** selection with the current buffer.  This has the effect
                ** of adding the buffer at the caret.  Finally, send the
                ** EOL to the window which (unlike EM_REPLACESEL) handles
                ** it correctly.
                */
                SendMessage(hwndScrn, WM_SETREDRAW, (WPARAM )FALSE, 0);

                SendMessage(hwndScrn, EM_SETSEL, 32767, 32767 );
#ifdef UNICODE
                if (MultiByteToWideChar(CP_ACP,
                                        0,
                                        szBuf,
                                        -1,
                                        szUnicodeBuf,
                                        sizeof(szUnicodeBuf) / sizeof(WCHAR)))
                {
                    SendMessage(hwndScrn, EM_REPLACESEL, 0, (LPARAM )szUnicodeBuf );
                }
#else // UNICODE
                SendMessage(hwndScrn, EM_REPLACESEL, 0, (LPARAM )szBuf );
#endif // UNICODE
                SendMessage(hwndScrn, WM_EOLFROMDEVICE, 0, 0 );

                SendMessage(hwndScrn, WM_SETREDRAW, (WPARAM )TRUE, 0);
                SendMessage(hwndScrn, EM_SCROLLCARET, 0, 0);
                InvalidateRect(hwndScrn, NULL, FALSE);

                /* Start afresh on the output buffer.
                */
                pch = szBuf;
                continue;
            }
            else if (ch == '\n' || ch == VK_TAB)
                continue;

            *pch++ = ch;
        }

        *pch = '\0';

        if (pch != szBuf)
        {
            /* Send the last remnant of the line.
            */
            SendMessage(hwndScrn, EM_SETSEL, 32767, 32767);
#ifdef UNICODE
            if (MultiByteToWideChar(CP_ACP,
                                    0,
                                    szBuf,
                                    -1,
                                    szUnicodeBuf,
                                    sizeof(szUnicodeBuf) / sizeof(TCHAR)))
            {
                SendMessage(hwndScrn, EM_REPLACESEL, 0, (LPARAM)szUnicodeBuf );
            }
#else // UNICODE
            SendMessage(hwndScrn, EM_REPLACESEL, 0, (LPARAM)szBuf );
#endif // UNICODE
            SendMessage(hwndScrn, EM_SCROLLCARET, 0, 0);
        }
    }
  }while (cbRead != 0);

  CloseHandle(hEvent);

  return TRUE;
}

/*----------------------------------------------------------------------------
** Terminal Output Handler
**----------------------------------------------------------------------------
*/

VOID NEAR PASCAL SendCharacter( HWND hwnd, BYTE byte )

    /* Send character 'byte' to the device.
    */
{
  PTERMDLG  pTerminaldialog;
  DWORD     cbWrite;
  OVERLAPPED ov;
  HANDLE    hEvent;
  COMMTIMEOUTS commtimeout;

  pTerminaldialog = (PTERMDLG)GetWindowLongPtr(hwnd, DWLP_USER);

  /* Make sure we still have the comm port
  */
  if (pTerminaldialog->hport == NULL)
    return;

  /* Send the character to the device.  It is not passed thru
  ** because the device will echo it.
  */
  pTerminaldialog->pbyteSendBuf[ 0 ] = (BYTE )byte;

  // Set write timeout to one second
  //
  commtimeout.ReadIntervalTimeout = MAXDWORD;
  commtimeout.ReadTotalTimeoutMultiplier = 0;
  commtimeout.ReadTotalTimeoutConstant   = 0;
  commtimeout.WriteTotalTimeoutMultiplier= 0;
  commtimeout.WriteTotalTimeoutConstant  = 1000;
  SetCommTimeouts(pTerminaldialog->hport, &commtimeout);

  if ((hEvent = CreateEvent(NULL, TRUE, FALSE, NULL)) != NULL)
  {
    ov.Internal     = 0;
    ov.InternalHigh = 0;
    ov.Offset       = 0;
    ov.OffsetHigh   = 0;
    ov.hEvent       = (HANDLE)((ULONG_PTR)hEvent | 1);

    cbWrite = 0;

    if (FALSE == WriteFile(pTerminaldialog->hport,
                           pTerminaldialog->pbyteSendBuf,
                           SIZE_SendBuf, &cbWrite, &ov))
    {
      DWORD dwResult = GetLastError();
      DWORD dwNumBytesWritten;

      if (ERROR_IO_PENDING == dwResult)
      {
        GetOverlappedResult(pTerminaldialog->hport,
                            &ov,
                            &dwNumBytesWritten,
                            TRUE);
        if (dwNumBytesWritten != SIZE_SendBuf)
        {
          // TBD:DPRINTF1("WriteFile() in SendCharacter() only wrote %d bytes!",
          //         dwNumBytesWritten);
        }
      }
      else
      {
        // TBD:DPRINTF1("WriteFile() in SendCharacter() failed (0x%8x)!", dwResult);
      }
    }

    CloseHandle(hEvent);
  }

  return;
}

/*----------------------------------------------------------------------------
** Terminal Apperance Adjuster
**----------------------------------------------------------------------------
*/

VOID NEAR PASCAL AdjustTerminal (HWND hwnd, int wWidth, int wHeight)
{
  HWND  hwndCtrl;
  RECT  rect;
  SIZE  sizeButton;
  POINT ptPos;
  DWORD dwUnit;

  // Get the sizes of the push buttons
  //
  dwUnit = GetDialogBaseUnits();
  hwndCtrl = GetDlgItem(hwnd, IDOK);
  GetWindowRect(hwndCtrl, &rect);
  sizeButton.cx = rect.right  - rect.left;
  sizeButton.cy = rect.bottom - rect.top;
  ptPos.x   = wWidth/2 - ((X_SPACING*LOWORD(dwUnit))/4)/2 - sizeButton.cx;
  ptPos.y   = wHeight - (sizeButton.cy+((Y_MARGIN*HIWORD(dwUnit))/4));

  // Move the push buttons
  MoveWindow(hwndCtrl, ptPos.x, ptPos.y, sizeButton.cx, sizeButton.cy, TRUE);

  ptPos.x  += ((X_SPACING*LOWORD(dwUnit))/4) + sizeButton.cx;
  MoveWindow(GetDlgItem(hwnd, IDCANCEL), ptPos.x, ptPos.y,
             sizeButton.cx, sizeButton.cy, TRUE);

  // Get the current position of the terminal screen
  hwndCtrl = GetDlgItem(hwnd, CID_T_EB_SCREEN);
  GetWindowRect(hwndCtrl, &rect);

  // Convert co-ordinates so as to deal with mirroring issues in ARA and HEB versions.
  MapWindowPoints(NULL,hwnd,(LPPOINT)&rect,2);

  // Move Window
  MoveWindow(hwndCtrl, rect.left, rect.top,
             wWidth - 2*rect.left,
             ptPos.y - rect.top - ((Y_MARGIN*HIWORD(dwUnit))/4),
             TRUE);

  InvalidateRect(hwnd, NULL, TRUE);
  return;
}

/*----------------------------------------------------------------------------
** Terminal read-notification thread
**----------------------------------------------------------------------------
*/

DWORD WINAPI TerminalThread (PTERMDLG  pTerminaldialog)
{
  DWORD     dwEvent;
  DWORD     dwMask;

  while((dwEvent = WaitForMultipleObjects(MAX_EVENT, pTerminaldialog->hEvent,
                                          FALSE, INFINITE))
         < WAIT_OBJECT_0+MAX_EVENT)
  {
    switch (dwEvent)
    {
      case READ_EVENT:
      {
            //
            // If we are stopped already, just get out of here
            //
            EnterUICritSect();
            if (pTerminaldialog->fStop)
            {
                LeaveUICritSect();
                goto end;
            }
            else
            {
                //
                // Crit sect is entered -- it should stay entered
                // until we return from overlapped WaitCommEvent...
                //

                HANDLE hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

                if (hEvent != NULL)
                {

                    OVERLAPPED   ov;
                    ZeroMemory(&ov, sizeof(ov));
                    ov.Offset       = 0;
                    ov.OffsetHigh   = 0;
                    ov.hEvent       = (HANDLE)((ULONG_PTR)hEvent | 1);
                    dwMask = 0;

                    BOOL fRet = WaitCommEvent(
                                    pTerminaldialog->hport,
                                    &dwMask,
                                    &ov
                                    );

                    LeaveUICritSect();


                    if (!fRet && ERROR_IO_PENDING==GetLastError())
                    {
                        //
                        // 2/12/1998 JosephJ
                        //  It's possible that the WaitCommEvent will
                        //  never complete, because the handle has
                        //  been invalidated because the line is dropped.
                        //
                        //  Therefore we wait on BOTH the overlapped
                        //  event and the stopped event.
                        //
                        //  If the stop event is signalled we exit the thread
                        //  after canceling I/O on the thread for the comm
                        //  handle.
                        //

                        HANDLE   rghEvents[2] =
                                    {
                                        ov.hEvent,
                                        pTerminaldialog->hEvent[STOP_EVENT]
                                    };

                        DWORD dwRet = WaitForMultipleObjects(
                                            2,
                                            rghEvents,
                                            FALSE,
                                            INFINITE
                                            );
                        if (dwRet == WAIT_OBJECT_0)
                        {
                            //
                            // The i/o completed...
                            ///
                            DWORD dwBytes=0;

                            fRet = GetOverlappedResult(
                                    pTerminaldialog->hport,
                                    &ov,
                                    &dwBytes,
                                    FALSE       // DO NOT block!
                                    );
                        }
                        else
                        {
                            //
                            // Hmm... the i/o event wasn't signalled...
                            // Let's cancel it and treat this as a failure...
                            //
                            CancelIo(pTerminaldialog->hport);
                            fRet=FALSE;
                        }
                    }


                    CloseHandle(ov.hEvent); ov.hEvent=NULL;

                    if (   fRet
                            && (dwMask & EV_RXCHAR)
                            && (pTerminaldialog->hwnd != NULL))
                    {
                        PostMessage(pTerminaldialog->hwnd, WM_MODEMNOTIFY, 0,0);
                    };

                 }

                 //
                 // Note: pTerminaldialog->fStop could have been set while
                 //       we're waiting for the WaitCommEvent to complete above.
                 //
                 if (pTerminaldialog->fStop)
                 {
                    goto end;
                 }
            }

        }
        break; // end case READ_EVENT

      case STOP_EVENT:
        goto end;

    }; // switch(dwEvent)


  }; // while

end:

  return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\tsp\asyncipc.h ===
// 
// Copyright (c) 1996-1997 Microsoft Corporation.
//
//
// Component
//
//		Unimodem 5.0 TSP (Win32, user mode DLL)
//
// File
//
//		ASYNCIPC.H
//
// Description
//
//		Header file for asyncronous IPC services for use between TAPISRV (TSP)
//      and application (UMWAV.DLL, etc) process contexts.
//
// History
//
//		2/26/1997  HeatherA Created
//
//

#include <ntddmodm.h>
//
//  Async IPC function IDs
//
typedef enum
{
    AIPC_REQUEST_WAVEACTION = 1,        // implemented by TSP
    AIPC_COMPLETE_WAVEACTION            // implemented by wave driver
    
} AIPC_FUNCTION_ID;


// Parameter block for the TSP's AIPC_REQUEST_WAVEACTION function
typedef struct _tagREQ_WAVE_PARAMS
{
    DWORD   dwWaveAction;               // WAVE_ACTION_xxx

} REQ_WAVE_PARAMS, *LPREQ_WAVE_PARAMS;


// Parameter block for the wave driver's AIPC_COMPLETE_WAVEACTION function
typedef struct _tagCOMP_WAVE_PARAMS
{
    BOOL    bResult;
    DWORD   dwWaveAction;               // function that completed (WAVE_ACTION_xxx)

} COMP_WAVE_PARAMS, *LPCOMP_WAVE_PARAMS;


// Parameter block for an Async IPC message
typedef struct _tagAIPC_PARAMS
{
    MODEM_MESSAGE       ModemMessage;

    AIPC_FUNCTION_ID    dwFunctionID;
    union {
        COMP_WAVE_PARAMS    Params;         // cast address of this member to
                                            // the correct parameter set

        REQ_WAVE_PARAMS     ReqParams;
    };
} AIPC_PARAMS, *LPAIPC_PARAMS;

#define AIPC_MSG_SIZE    sizeof(AIPC_PARAMS)


#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */


#define COLOR_AIPC_INIT             (FOREGROUND_RED | FOREGROUND_GREEN)
#define COLOR_AIPC_SUBMIT_COMPLETE  (FOREGROUND_RED | FOREGROUND_GREEN)


//
//  Async IPC states
//
typedef enum
{
    // server side states
    AIPC_STATE_LISTENING,
    AIPC_STATE_PROCESSING_CALL,
    AIPC_STATE_COMPLETING_CALL,

    // client side states
    AIPC_STATE_CALL_SUBMITTED
    
} AIPC_STATE;


//----------------------------------------------------------------------


typedef VOID (*PFN_AIPC_FUNC)
//typedef VOID (*AIPC_FUNCTION)
(
    LPVOID  pAipc
    
//    AIPC_FUNCTION_ID    dwFunctionID,
//    LPVOID              pvParams

//    AIPC_PARAMS aipcParams
);




//
// Values for LPAIPCINFO->dwFlags
//
#define AIPC_FLAG_LISTEN    1
#define AIPC_FLAG_SUBMIT    2


//
// Maintain state of asyncronous IPC use, one per device instance.  This
// is actually an extended OVERLAPPED structure, providing context for the
// async IPC mechanism.
//
typedef struct _tagAIPCINFO
{
    // This must be first.
    OVERLAPPED      Overlapped;

    HANDLE          hComm;

    DWORD           dwState;                        // AIPC_STATE_xxx
    DWORD           dwFlags;                        // AIPC_FLAG_xxx
    
    LPVOID          pvContext;      	            // CTspDev *pDev;
    
    CHAR            rcvBuffer[AIPC_MSG_SIZE];
    CHAR            sndBuffer[AIPC_MSG_SIZE];

    PFN_AIPC_FUNC   pfnAipcFunction;
    
} AIPCINFO, *LPAIPCINFO;



BOOL WINAPI AIPC_ListenForCall(LPAIPCINFO pAipc);

BOOL WINAPI AIPC_SubmitCall(LPAIPCINFO pAipc);


#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\tsp\cdev.cpp ===
// 
// Copyright (c) 1996-1997 Microsoft Corporation.
//
//
// Component
//
//		Unimodem 5.0 TSP (Win32, user mode DLL)
//
// File
//
//		CDEV.CPP
//		Implements class CTspDev
//
// History
//
//		11/16/1996  JosephJ Created
//
//
#include "tsppch.h"
#include "tspcomm.h"
//#include <umdmmini.h>
#include "cmini.h"
#include "cdev.h"
#include "diag.h"
#include "rcids.h"
#include "globals.h"
#include <Memory.h>

FL_DECLARE_FILE(0x986d98ed, "Implements class CTspDev")


TCHAR cszFriendlyName[] = TEXT("FriendlyName");
TCHAR cszDeviceType[]   = TEXT("DeviceType");
TCHAR cszID[]           = TEXT("ID");
TCHAR cszProperties[]   = TEXT("Properties");
TCHAR cszSettings[]     = TEXT("Settings");
TCHAR cszDialSuffix[]   = TEXT("DialSuffix");


TCHAR cszVoiceProfile[]             = TEXT("VoiceProfile");
// 2/26/1997 JosephJ Many other registry keys related to forwarding, distinctive
//      ringing and mixer were here in unimodem/v but I have not
//      migrated them.

// 2/28/1997 JosephJ
//      The following are new for NT5.0. These contain the wave device ID
//      for record and play. As of 2/28/1997, we haven't addressed how these
//      get in the registry -- basically this is a hack.
//
const TCHAR cszWaveInstance[]             = TEXT("WaveInstance");
const TCHAR cszWaveDriver[]               = TEXT("WaveDriver");

//
// The list of classes supported by unimodem
//


//
// 3/29/98 JosephJ following set of static class lists is not elegant,
//                 but works.
//
const TCHAR       g_szzLineNoVoiceClassList[] = {
                                TEXT("tapi/line\0")
                                TEXT("comm\0")
                                TEXT("comm/datamodem\0")
                                TEXT("comm/datamodem/portname\0")
                                TEXT("comm/datamodem/dialin\0")
                                TEXT("comm/datamodem/dialout\0")
                                TEXT("comm/extendedcaps\0")
                                TEXT("tapi/line/diagnostics\0")
                                };

const TCHAR       g_szzLineWithWaveClassList[] = {
                                TEXT("tapi/line\0")
                                TEXT("comm\0")
                                TEXT("comm/datamodem\0")
                                TEXT("comm/datamodem/portname\0")
                                TEXT("comm/datamodem/dialin\0")
                                TEXT("comm/datamodem/dialout\0")
                                TEXT("comm/extendedcaps\0")
                                TEXT("wave/in\0")
                                TEXT("wave/out\0")
                                TEXT("tapi/line/diagnostics\0")
                                };

const TCHAR       g_szzLineWithWaveAndPhoneClassList[] = {
                                TEXT("tapi/line\0")
                                TEXT("comm\0")
                                TEXT("comm/datamodem\0")
                                TEXT("comm/datamodem/portname\0")
                                TEXT("comm/datamodem/dialin\0")
                                TEXT("comm/datamodem/dialout\0")
                                TEXT("comm/extendedcaps\0")
                                TEXT("wave/in\0")
                                TEXT("wave/out\0")
                                TEXT("tapi/phone\0")
                                TEXT("tapi/line/diagnostics\0")
                                };

const TCHAR       g_szzPhoneWithAudioClassList[] = {
                                TEXT("tapi/line\0")
                                TEXT("wave/in\0")
                                TEXT("wave/out\0")
                                TEXT("tapi/phone\0")
                                };


const TCHAR       g_szzPhoneWithoutAudioClassList[] = {
                                TEXT("tapi/line\0")
                                TEXT("tapi/phone\0")
                                };



const TCHAR g_szComm[]  = TEXT("comm");
const TCHAR g_szCommDatamodem[]  = TEXT("comm/datamodem");
// const TCHAR g_szDiagnosticsCall[] 

DWORD
get_volatile_key_value(HKEY hkParent);


char *
ConstructNewPreDialCommands(
     HKEY hKey,
     DWORD dwNewProtoOpt,
     CStackLog *psl
     );
//
//  Will try to construct a multisz string containing the commands associated
//  with the specified protocol.
//  Returns NULL on error.
//
//  The command is in RAW form -- i.e,
//  with CR and LF present in their raw form, not template ("<cr>")
//  form.
//
//      
//


CTspDev::CTspDev(void)

	: m_sync(),
	  m_pLine(NULL)
{
	  ZeroMemory(&m_Line, sizeof(m_Line));
	  ZeroMemory(&m_Phone, sizeof(m_Phone));
	  ZeroMemory(&m_LLDev, sizeof(m_LLDev));


	  m_StaticInfo.pMD=NULL;
	  m_StaticInfo.hSessionMD=0;
}

CTspDev::~CTspDev()
{
	  ASSERT(m_StaticInfo.pMD==NULL);
	  ASSERT(m_StaticInfo.hSessionMD==0);
}


TSPRETURN
CTspDev::AcceptTspCall(
            BOOL fFromExtension,
			DWORD dwRoutingInfo,
			void *pvParams,
			LONG *plRet,
            CStackLog *psl
			)
{
	FL_DECLARE_FUNC(0x86571252, "CTspDev::AcceptTspCall")
	TSPRETURN tspRet= 0;

	FL_LOG_ENTRY(psl);

	*plRet =  LINEERR_OPERATIONUNAVAIL; // Default (not handled) is failure.

	m_sync.EnterCrit(dwLUID_CurrentLoc);

	if (!m_sync.IsLoaded())
	{
		// Not in a position to handle this call now!
		*plRet = LINEERR_OPERATIONFAILED;
		goto end;
	}

    // 
    //
    //
    if (!fFromExtension && m_StaticInfo.pMD->ExtIsEnabled())
    {

        // 4/30/1997 JosephJ We must leave the critical section because
        // the extension DLL can call back, wherepon we will enter
        // the critical section a 2nd time, and later if we try
        // to leave the critical section (specifically while waiting
        // for synchronous completion of lineDrop) we will
        // actually not have truly released it and hence the async
        // completion from the minidriver (typically in a different
        // thread's context) will block at our critical section.
        // Simple way to hit this is to do a lineCloseCall with a call
        // still active.

	    m_sync.LeaveCrit(dwLUID_CurrentLoc);

		*plRet = m_StaticInfo.pMD->ExtAcceptTspCall(
                    m_StaticInfo.hExtBinding,
                    this,
                    dwRoutingInfo,
                    pvParams
                    );
	    m_sync.EnterCrit(dwLUID_CurrentLoc);

        goto end;
    }


    // Set stacklog that will be in effect while we hold our critical
    // section.
    //
    if (m_pLLDev && m_pLLDev->IsLoggingEnabled())
    {
        char rgchName[128];

        rgchName[0] = 0;
        UINT cbBuf = DumpTSPIRECA(
                        0, // Instance (unused)
                        dwRoutingInfo,
                        pvParams,
                        0, // dwFlags
                        rgchName,
                        sizeof(rgchName)/sizeof(*rgchName),
                        NULL,
                        0
                        );
       if (*rgchName)
       {
            m_StaticInfo.pMD->LogStringA(
                                        m_pLLDev->hModemHandle,
                                        LOG_FLAG_PREFIX_TIMESTAMP,
                                        rgchName,
                                        psl
                                        );
       }
    }

	switch(ROUT_TASKDEST(dwRoutingInfo))
	{

	case	TASKDEST_LINEID:
		switch(ROUT_TASKID(dwRoutingInfo))
		{

		case TASKID_TSPI_lineOpen:
			{
				TASKPARAM_TSPI_lineOpen *pParams = 
								(TASKPARAM_TSPI_lineOpen *) pvParams;
				ASSERT(pParams->dwStructSize ==
					sizeof(TASKPARAM_TSPI_lineOpen));
				ASSERT(pParams->dwTaskID == TASKID_TSPI_lineOpen);

				SLPRINTF1(
					psl,
					"lineOpen (ID=%lu)",
					pParams->dwDeviceID
					);

                if (m_fUserRemovePending) {

                    *plRet = LINEERR_OPERATIONFAILED;
                    tspRet = FL_GEN_RETVAL(IDERR_WRONGSTATE);
                    break;
                }

			    tspRet = mfn_LoadLine(pParams,psl);

			    if (!tspRet)
			    {
					*plRet = 0;
			    }
			}
			break;

		case TASKID_TSPI_lineGetDevCaps:
			{
				TASKPARAM_TSPI_lineGetDevCaps *pParams = 
								(TASKPARAM_TSPI_lineGetDevCaps *) pvParams;
				ASSERT(pParams->dwStructSize ==
					sizeof(TASKPARAM_TSPI_lineGetDevCaps));
				ASSERT(pParams->dwTaskID == TASKID_TSPI_lineGetDevCaps);


				SLPRINTF1(
					psl,
					"DEVICE %lu",
					pParams->dwDeviceID
					);

				// Verify version
				if (pParams->dwTSPIVersion != TAPI_CURRENT_VERSION)
				{
					FL_SET_RFR(0x94949c00, "Incorrect TSPI version");
					*plRet = LINEERR_INCOMPATIBLEAPIVERSION;
				}
				else
				{
					tspRet = mfn_get_LINDEVCAPS (
						pParams->lpLineDevCaps,
						plRet,
						psl
						);
				}
			}
			break;

		case TASKID_TSPI_lineGetAddressCaps:
			{
				TASKPARAM_TSPI_lineGetAddressCaps *pParams = 
								(TASKPARAM_TSPI_lineGetAddressCaps *) pvParams;
				ASSERT(pParams->dwStructSize ==
					sizeof(TASKPARAM_TSPI_lineGetAddressCaps));
				ASSERT(pParams->dwTaskID == TASKID_TSPI_lineGetAddressCaps);


				SLPRINTF1(
					psl,
					"DEVICE %lu",
					pParams->dwDeviceID
					);

				// Verify version
				if (pParams->dwTSPIVersion != TAPI_CURRENT_VERSION)
				{
					FL_SET_RFR(0xb949f900, "Incorrect TSPI version");
					*plRet = LINEERR_INCOMPATIBLEAPIVERSION;
				}
				else if (pParams->dwAddressID)
				{
					FL_SET_RFR(0xb1776700, "Invalid address ID");
					*plRet = LINEERR_INVALADDRESSID;
				}
				else
				{
					tspRet = mfn_get_ADDRESSCAPS(
						pParams->dwDeviceID,
						pParams->lpAddressCaps,
						plRet,
						psl
						);
				}
			}
			break;

		case TASKID_TSPI_lineGetDevConfig:
			{
				TASKPARAM_TSPI_lineGetDevConfig *pParams = 
								(TASKPARAM_TSPI_lineGetDevConfig *) pvParams;
				ASSERT(pParams->dwStructSize ==
					sizeof(TASKPARAM_TSPI_lineGetDevConfig));
				ASSERT(pParams->dwTaskID == TASKID_TSPI_lineGetDevConfig);

                LPVARSTRING lpVarString  = pParams->lpDeviceConfig;
                LPCTSTR     lpszDeviceClass = pParams->lpszDeviceClass;
                BOOL        DialIn          = FALSE;


			    CALLINFO   *pCall           = (m_pLine) ? m_pLine->pCall : NULL;

                DWORD       dwDeviceClass   =  parse_device_classes(
                                                   lpszDeviceClass,
                                                   FALSE
                                                   );
                HKEY        hKey;

                if (lpVarString->dwTotalSize < sizeof(VARSTRING))
                {
                    *plRet =  LINEERR_STRUCTURETOOSMALL;
                    goto end;
                }

                switch(dwDeviceClass)
                {
                case DEVCLASS_COMM_DATAMODEM_DIALIN:

                    if (RegOpenKeyA(HKEY_LOCAL_MACHINE,
                                   m_StaticInfo.rgchDriverKey,
                                   &hKey) == ERROR_SUCCESS)
                    {
#if DBG
                        OutputDebugString(TEXT("Unimodem TSP: Opened reg key\n"));
#endif
                        DWORD dwcbSize = sizeof(m_Settings.rgbDialTempCommCfgBuf);

                        DWORD dwRet = UmRtlGetDefaultCommConfig(hKey,
                                                                m_Settings.pDialTempCommCfg,
                                                                &dwcbSize);

                        if (dwRet == ERROR_SUCCESS)
                        {
#if DBG
                            OutputDebugString(TEXT("Unimodem TSP: Read temp config\n"));
#endif
                            CopyMemory(m_Settings.pDialInCommCfg,
                                       m_Settings.pDialTempCommCfg,
                                       dwcbSize);
                        } else
                        {
#if DBG
                            OutputDebugString(TEXT("Unimodem TSP: could not read temp config\n"));
#endif
                        }

                        RegCloseKey(hKey);

                    }

                    DialIn=TRUE;
                    break;


                case DEVCLASS_COMM:             
                case DEVCLASS_COMM_DATAMODEM:
                case DEVCLASS_COMM_DATAMODEM_DIALOUT:

                // 1/29/1998 JosephJ.
                //      The following case is added for
                //      backwards compatibility with NT4 TSP, which
                //      simply checked if the class was a valid class,
                //      and treated all valid classes (including
                //      (comm/datamodem/portname) the same way
                //      for lineGet/SetDevConfig. We, however, don't
                //      allow comm/datamodem/portname here -- only
                //      the 2 above and two below represent
                //      setting DEVCFG
                //
                case DEVCLASS_TAPI_LINE:
                     // we deal this below the switch statement.
                     break;

                case DEVCLASS_COMM_EXTENDEDCAPS:
                    {
                        *plRet = mfn_GetCOMM_EXTENDEDCAPS(
                                lpVarString,
                                psl
                                );
                        goto end;
                    }

                case DEVCLASS_TAPI_LINE_DIAGNOSTICS:
                    {
                        // New in NT5.0
                        // Process call/diagnostics configuration

                        const UINT cbLDC = sizeof(LINEDIAGNOSTICSCONFIG);

                        lpVarString->dwStringSize = 0;
                        lpVarString->dwUsedSize = sizeof(VARSTRING);
                        lpVarString->dwNeededSize = sizeof(VARSTRING)
                                           +  cbLDC;

                
                        if (lpVarString->dwTotalSize
                             >= lpVarString->dwNeededSize)
                        {
                            LINEDIAGNOSTICSCONFIG *pLDC = 
                            (LINEDIAGNOSTICSCONFIG *) (((LPBYTE)lpVarString)
                                               + sizeof(VARSTRING));
                            pLDC->hdr.dwSig  =  LDSIG_LINEDIAGNOSTICSCONFIG;
                            pLDC->hdr.dwTotalSize = cbLDC;
                            pLDC->hdr.dwFlags =  m_StaticInfo.dwDiagnosticCaps;
                            pLDC->hdr.dwParam
                                         = m_Settings.dwDiagnosticSettings;
                            lpVarString->dwStringFormat =STRINGFORMAT_BINARY;
                            lpVarString->dwStringSize =  cbLDC;
                            lpVarString->dwStringOffset = sizeof(VARSTRING);
                            lpVarString->dwUsedSize   +=  cbLDC;
                        }
                        *plRet =  0; // success
                        goto end;
                    }
                    break;

                default:
	                *plRet =  LINEERR_OPERATIONUNAVAIL;
                    //          we don't support lineGetDevConfig
                    //          for any other class.
                    goto end;

                case DEVCLASS_UNKNOWN:
                    *plRet =  LINEERR_INVALDEVICECLASS;
                    goto end;
                }

                
                // TODO: Fail if out-of-service
                //
                // if (pLineDev->fdwResources&LINEDEVFLAGS_OUTOFSERVICE)
                // {
                // lRet = LINEERR_RESOURCEUNAVAIL;
                //     goto end;
                // }
                
                // New in NT5.0
                lpVarString->dwStringSize = 0;

                LPCOMMCONFIG   CommConfigToUse=DialIn ? m_Settings.pDialInCommCfg : m_Settings.pDialOutCommCfg;
                DWORD       cbDevCfg        = CommConfigToUse->dwSize + sizeof(UMDEVCFGHDR);

                // Validate the buffer size
                //
                lpVarString->dwUsedSize = sizeof(VARSTRING);
                lpVarString->dwNeededSize = sizeof(VARSTRING)
                                               + cbDevCfg;
                
                if (lpVarString->dwTotalSize >= lpVarString->dwNeededSize)
                {
                    UMDEVCFGHDR CfgHdr;

                    ZeroMemory(&CfgHdr, sizeof(CfgHdr));
                    CfgHdr.dwSize = cbDevCfg;
                    CfgHdr.dwVersion =  UMDEVCFG_VERSION;
                    CfgHdr.fwOptions =  (WORD) m_Settings.dwOptions;
                    CfgHdr.wWaitBong =  (WORD) m_Settings.dwWaitBong;

                    SLPRINTF2(
                        psl,
                        "Reporting dwOpt = 0x%04lx; dwBong = 0x%04lx", 
                        m_Settings.dwOptions,
                        m_Settings.dwWaitBong
                        );


                    // Fill with the default value
                    //
                    UMDEVCFG *pCfg = (UMDEVCFG *) (((LPBYTE)lpVarString)
                                               + sizeof(VARSTRING));

                    // Copy the header
                    //
                    pCfg->dfgHdr = CfgHdr;

                    // Copy the commconfig
                    //
                    CopyMemory(
                        &(pCfg->commconfig),
                        CommConfigToUse,
                        CommConfigToUse->dwSize
                        );
                
                    if (!pCfg->commconfig.dcb.BaudRate)
                    {
                        // JosephJ Todo: clean out all this stuff post-beta.
                        // DebugBreak();

                        pCfg->commconfig.dcb.BaudRate = 57600;
                    }
                    lpVarString->dwStringFormat = STRINGFORMAT_BINARY;
                    lpVarString->dwStringSize = cbDevCfg;
                    lpVarString->dwStringOffset = sizeof(VARSTRING);
                    lpVarString->dwUsedSize += cbDevCfg;


                    // 9/06/97 JosephJ Bug#.106683
                    //                 If there is datamodem call in the
                    //                 connected state, pick up the
                    //                 connection information like
                    //                 Negotiated DCE rate and Connection
                    //                 options.
                    if (pCall && pCall->IsConnectedDataCall())
                    {
                        LPMODEMSETTINGS pMS = (LPMODEMSETTINGS)
                                        (pCfg->commconfig.wcProviderData);

                        // Note: We've already verified that the target
                        // pCfg structure is large enough.


                        // 9/06/1997 JosephJ Set negotiated options.
                        // The use of the mask 
                        // below is taken from atmini\dialansw.c, which
                        // does it before calling SetCommConfig.
                        // Not sure if we need to mask them out or not, but
                        // for not it's there...
                        pMS->dwNegotiatedModemOptions |=
                                         (pCall->dwConnectionOptions
                                          & (  MDM_COMPRESSION
                                             | MDM_ERROR_CONTROL
                                             | MDM_CELLULAR));

                        pMS->dwNegotiatedDCERate = pCall->dwNegotiatedRate;
                    }

                }

                *plRet =  0; // success

			} // end case TASKID_TSPI_lineGetDevConfig:
			break;

		case TASKID_TSPI_lineSetDevConfig:
			{

				TASKPARAM_TSPI_lineSetDevConfig *pParams = 
								(TASKPARAM_TSPI_lineSetDevConfig *) pvParams;
				ASSERT(pParams->dwStructSize ==
					sizeof(TASKPARAM_TSPI_lineSetDevConfig));
				ASSERT(pParams->dwTaskID == TASKID_TSPI_lineSetDevConfig);

                BOOL  DialIn=FALSE;

                DWORD dwSize = pParams->dwSize;
                LPCTSTR lpszDeviceClass = pParams->lpszDeviceClass;
                DWORD dwDeviceClass =  parse_device_classes(
                                        lpszDeviceClass,
                                        FALSE);
                
                switch(dwDeviceClass)
                {
                case DEVCLASS_COMM_DATAMODEM_DIALIN:

                    DialIn=TRUE;
                    break;

                case DEVCLASS_COMM:             
                case DEVCLASS_COMM_DATAMODEM:
                case DEVCLASS_COMM_DATAMODEM_DIALOUT:

                // 1/29/1998 JosephJ.
                //      The following case is added for
                //      backwards compatibility with NT4 TSP, which
                //      simply checked if the class was a valid class,
                //      and treated all valid classes (including
                //      (comm/datamodem/portname) the same way
                //      for lineGet/SetDevConfig. We, however, don't
                //      allow comm/datamodem/portname here -- only
                //      the 2 above and two below represent
                //      setting DEVCFG
                //
                case DEVCLASS_TAPI_LINE:
                     // we deal this below the switch statement.
                     break;

                case DEVCLASS_TAPI_LINE_DIAGNOSTICS:
                    {
                        LINEDIAGNOSTICSCONFIG *pLDC = 
                        (LINEDIAGNOSTICSCONFIG *)  pParams->lpDeviceConfig;

                        if (   pLDC->hdr.dwSig  !=  LDSIG_LINEDIAGNOSTICSCONFIG
                            || dwSize != sizeof(LINEDIAGNOSTICSCONFIG)
                            || pLDC->hdr.dwTotalSize !=  dwSize
                            || (pLDC->hdr.dwParam &&
                            pLDC->hdr.dwParam != m_StaticInfo.dwDiagnosticCaps))
                        {
                            *plRet =  LINEERR_INVALPARAM;
                            goto end;
                        }
                        else
                        {
                            // Note, by design, we ignore the dwCaps passed in.
                            //

                            m_Settings.dwDiagnosticSettings =
                                pLDC->hdr.dwParam;
                        }

                        *plRet =  0; // success
                        goto end;
                    }
                    break;

                default:
	                *plRet =  LINEERR_OPERATIONUNAVAIL;
                    //          we don't support lineSetDevConfig
                    //          for any other class.
                    goto end;

                case DEVCLASS_UNKNOWN:
                    *plRet =  LINEERR_INVALDEVICECLASS;
                    goto end;
                }

                // This is the comm or comm/datamodem case ...

                UMDEVCFG *pDevCfgNew = (UMDEVCFG *) pParams->lpDeviceConfig;

                tspRet = CTspDev::mfn_update_devcfg_from_app(
                                    pDevCfgNew,
                                    dwSize,
                                    DialIn,
                                    psl
                                    );
                *plRet = 0; // success
                 if (tspRet)
                 {
                    tspRet = 0;
                    *plRet =  LINEERR_INVALPARAM;
                    goto end;
                 }

                *plRet = 0; // success

            }
			break;

		case TASKID_TSPI_lineNegotiateTSPIVersion:
			{
				TASKPARAM_TSPI_lineNegotiateTSPIVersion *pParams = 
					(TASKPARAM_TSPI_lineNegotiateTSPIVersion *) pvParams;
				ASSERT(pParams->dwStructSize ==
					sizeof(TASKPARAM_TSPI_lineNegotiateTSPIVersion));
				ASSERT(pParams->dwTaskID ==
                     TASKID_TSPI_lineNegotiateTSPIVersion);


                // Check the version range
                //
                if (pParams->dwHighVersion<TAPI_CURRENT_VERSION
                    || pParams->dwLowVersion>TAPI_CURRENT_VERSION)
                {
                  *plRet= LINEERR_INCOMPATIBLEAPIVERSION;
                }
                else
                {
                  *(pParams->lpdwTSPIVersion) =  TAPI_CURRENT_VERSION;
                  *plRet= 0;
                }
			}
			break;


		case TASKID_TSPI_providerGenericDialogData:
			{
				TASKPARAM_TSPI_providerGenericDialogData *pParams = 
                        (TASKPARAM_TSPI_providerGenericDialogData *) pvParams;
				ASSERT(pParams->dwStructSize ==
					sizeof(TASKPARAM_TSPI_providerGenericDialogData));
				ASSERT(pParams->dwTaskID
                                     == TASKID_TSPI_providerGenericDialogData);


				SLPRINTF1(
					psl,
					"DEVICE %lu",
					pParams->dwObjectID
					);

                *plRet = mfn_GenericLineDialogData(
                                pParams->lpParams,
                                pParams->dwSize,
                                psl
                                );
			}
			break;

		case TASKID_TSPI_lineGetIcon:
			{
				TASKPARAM_TSPI_lineGetIcon *pParams = 
								(TASKPARAM_TSPI_lineGetIcon *) pvParams;
				ASSERT(pParams->dwStructSize ==
					sizeof(TASKPARAM_TSPI_lineGetIcon));
				ASSERT(pParams->dwTaskID == TASKID_TSPI_lineGetIcon);
                const TCHAR *lpszDeviceClass = pParams->lpszDeviceClass;

                //
                // Validate device class -- we only support this for
                // tapi/[line|phone]. This check is new for NT5.0
                //
                //  NOTE: according to tapi docs, NULL or empty device
                //  class is valid...
                //
                if (lpszDeviceClass && *lpszDeviceClass)
                {
                    
                    DWORD dwDeviceClass =  parse_device_classes(
                                            lpszDeviceClass,
                                            FALSE
                                            );
    
    
                    switch (dwDeviceClass)
                    {
                    case DEVCLASS_TAPI_PHONE:
                        if (!mfn_IsPhone())
                        {
                            *plRet = LINEERR_OPERATIONUNAVAIL;
                            goto end;
                        }
    
                    case DEVCLASS_TAPI_LINE:

                        // OK
                        break;
    
                    case  DEVCLASS_UNKNOWN:
                        *plRet = LINEERR_INVALDEVICECLASS;
                        goto end;
    
                    default:
                        *plRet = LINEERR_OPERATIONUNAVAIL;
                        goto end;
                    }
                }
            
                //
                // If we haven't loaded an icon, load it...
                //
                if (m_StaticInfo.hIcon == NULL)
                {
                    int iIcon=-1;
                
                    switch (m_StaticInfo.dwDeviceType)
                    {
                      case DT_NULL_MODEM:       iIcon = IDI_NULL;       break;
                      case DT_EXTERNAL_MODEM:   iIcon = IDI_EXT_MDM;    break;
                      case DT_INTERNAL_MODEM:   iIcon = IDI_INT_MDM;    break;
                      case DT_PCMCIA_MODEM:     iIcon = IDI_PCM_MDM;    break;
                      default:                  iIcon = -1;             break;
                    }
                
                    if (iIcon != -1)
                    {
                        m_StaticInfo.hIcon = LoadIcon(
                                                g.hModule,
                                                MAKEINTRESOURCE(iIcon)
                                                );
                    }
                };

                *(pParams->lphIcon) = m_StaticInfo.hIcon;
                *plRet = 0;

			}
			break;
		}
		break; // end case TASKDEST_LINEID

	case	TASKDEST_PHONEID:

	    *plRet =  PHONEERR_OPERATIONUNAVAIL;

		switch(ROUT_TASKID(dwRoutingInfo))
		{

		case TASKID_TSPI_phoneOpen:
			{
				TASKPARAM_TSPI_phoneOpen *pParams = 
								(TASKPARAM_TSPI_phoneOpen *) pvParams;
				ASSERT(pParams->dwStructSize ==
					sizeof(TASKPARAM_TSPI_phoneOpen));
				ASSERT(pParams->dwTaskID == TASKID_TSPI_phoneOpen);

				SLPRINTF1(
					psl,
					"phoneOpen (ID=%lu)",
					pParams->dwDeviceID
					);

			    tspRet = mfn_LoadPhone(pParams, psl);

			    if (!tspRet)
			    {
					*plRet = 0;
			    }
			}
			break;

		case TASKID_TSPI_phoneNegotiateTSPIVersion:
			{
				TASKPARAM_TSPI_phoneNegotiateTSPIVersion *pParams = 
					(TASKPARAM_TSPI_phoneNegotiateTSPIVersion *) pvParams;
				ASSERT(pParams->dwStructSize ==
					sizeof(TASKPARAM_TSPI_phoneNegotiateTSPIVersion));
				ASSERT(pParams->dwTaskID ==
                     TASKID_TSPI_phoneNegotiateTSPIVersion);


                // Check the version range
                //
                if (pParams->dwHighVersion<TAPI_CURRENT_VERSION
                    || pParams->dwLowVersion>TAPI_CURRENT_VERSION)
                {
                  *plRet= LINEERR_INCOMPATIBLEAPIVERSION;
                }
                else
                {
                  *(pParams->lpdwTSPIVersion) =  TAPI_CURRENT_VERSION;
                  *plRet= 0;
                }
			}
			break;

		case TASKID_TSPI_providerGenericDialogData:
			{
				TASKPARAM_TSPI_providerGenericDialogData *pParams = 
                        (TASKPARAM_TSPI_providerGenericDialogData *) pvParams;
				ASSERT(pParams->dwStructSize ==
					sizeof(TASKPARAM_TSPI_providerGenericDialogData));
				ASSERT(pParams->dwTaskID
                                     == TASKID_TSPI_providerGenericDialogData);


				SLPRINTF1(
					psl,
					"DEVICE %lu",
					pParams->dwObjectID
					);

                *plRet = mfn_GenericPhoneDialogData(
                                pParams->lpParams,
                                pParams->dwSize
                                );
			}
			break;

		case TASKID_TSPI_phoneGetDevCaps:
			{
				TASKPARAM_TSPI_phoneGetDevCaps *pParams = 
								(TASKPARAM_TSPI_phoneGetDevCaps *) pvParams;
				ASSERT(pParams->dwStructSize ==
					sizeof(TASKPARAM_TSPI_phoneGetDevCaps));
				ASSERT(pParams->dwTaskID == TASKID_TSPI_phoneGetDevCaps);


				SLPRINTF1(
					psl,
					"DEVICE %lu",
					pParams->dwDeviceID
					);

				// Verify version
				if (   (pParams->dwTSPIVersion <  0x00010004)
                    || (pParams->dwTSPIVersion > TAPI_CURRENT_VERSION))
				{
					FL_SET_RFR(0x9db11a00, "Incorrect TSPI version");
					*plRet = PHONEERR_INCOMPATIBLEAPIVERSION;
				}
				else
				{
					tspRet = mfn_get_PHONECAPS (
						pParams->lpPhoneCaps,
						plRet,
						psl
						);
				}
			}
			break;

		case TASKID_TSPI_phoneGetExtensionID:
			{
				TASKPARAM_TSPI_phoneGetExtensionID *pParams = 
								(TASKPARAM_TSPI_phoneGetExtensionID *) pvParams;
				ASSERT(pParams->dwStructSize ==
					sizeof(TASKPARAM_TSPI_phoneGetExtensionID));
				ASSERT(pParams->dwTaskID == TASKID_TSPI_phoneGetExtensionID);

                ZeroMemory(
                    pParams->lpExtensionID,
                    sizeof(*(pParams->lpExtensionID))
                    );
                *plRet = 0;
			}
			break;

		case TASKID_TSPI_phoneGetIcon:
			{
				TASKPARAM_TSPI_phoneGetIcon *pParams = 
								(TASKPARAM_TSPI_phoneGetIcon *) pvParams;
				ASSERT(pParams->dwStructSize ==
					sizeof(TASKPARAM_TSPI_phoneGetIcon));
				ASSERT(pParams->dwTaskID == TASKID_TSPI_phoneGetIcon);
                const TCHAR *lpszDeviceClass = pParams->lpszDeviceClass;

                //
                // Validate device class -- we only support this for
                // tapi/[line|phone]. This check is new for NT5.0 and win9x
                //
                //
                //  NOTE: according to tapi docs, NULL or empty device
                //  class is valid...
                //
                if (lpszDeviceClass && *lpszDeviceClass)
                {
                    DWORD dwDeviceClass =  parse_device_classes(
                                            pParams->lpszDeviceClass,
                                            FALSE
                                            );
    
    
                    switch (dwDeviceClass)
                    {
                    case DEVCLASS_TAPI_LINE:
                        if (!mfn_IsLine())
                        {
                            *plRet = PHONEERR_OPERATIONUNAVAIL;
                            goto end;
                        }
                        // fall through...
    
                    case DEVCLASS_TAPI_PHONE:
                        // OK
                        break;
    
                    case  DEVCLASS_UNKNOWN:
                        *plRet = PHONEERR_INVALDEVICECLASS;
                        goto end;
    
                    default:
                        *plRet = PHONEERR_OPERATIONUNAVAIL;
                        goto end;
                    }
                }

                //
                // If we haven't loaded an icon, load it...
                //
                if (m_StaticInfo.hIcon == NULL)
                {
                    int iIcon=-1;
                
                    switch (m_StaticInfo.dwDeviceType)
                    {
                      case DT_NULL_MODEM:       iIcon = IDI_NULL;       break;
                      case DT_EXTERNAL_MODEM:   iIcon = IDI_EXT_MDM;    break;
                      case DT_INTERNAL_MODEM:   iIcon = IDI_INT_MDM;    break;
                      case DT_PCMCIA_MODEM:     iIcon = IDI_PCM_MDM;    break;
                      default:                  iIcon = -1;             break;
                    }
                
                    if (iIcon != -1)
                    {
                        m_StaticInfo.hIcon = LoadIcon(
                                                g.hModule,
                                                MAKEINTRESOURCE(iIcon)
                                                );
                    }
                }
                *(pParams->lphIcon) = m_StaticInfo.hIcon;
                *plRet = 0;
			}
			break;
		}
		break; // End TASKDEST_PHONEID;

	case	TASKDEST_HDRVLINE:

		if (m_pLine)
		{
			mfn_accept_tsp_call_for_HDRVLINE(
						dwRoutingInfo,
						pvParams,
						plRet,
						psl
					);
		}
		
		break;

	case	TASKDEST_HDRVPHONE:

	    *plRet =  PHONEERR_OPERATIONUNAVAIL;

		if (m_pPhone)
		{
			mfn_accept_tsp_call_for_HDRVPHONE(
						dwRoutingInfo,
						pvParams,
						plRet,
						psl
					);
		}
		break;

	case	TASKDEST_HDRVCALL:
		if (m_pLine && m_pLine->pCall)
		{
			mfn_accept_tsp_call_for_HDRVCALL(
						dwRoutingInfo,
						pvParams,
						plRet,
						psl
					);
		}
		break;

	default:

		FL_SET_RFR(0x57d39b00, "Unknown destination");
		break;
	}

end:

	m_sync.LeaveCrit(dwLUID_CurrentLoc);

	FL_LOG_EXIT(psl, tspRet);

	return  tspRet;

}


TSPRETURN
CTspDev::Load(
		HKEY hkDevice,
		HKEY hkUnimodem,
		LPTSTR lptszProviderName,
		LPSTR lpszDriverKey,
		CTspMiniDriver *pMD,
    	HANDLE hThreadAPC,
		CStackLog *psl
		)
{
	//
	// TODO: 1/5/1997 JosephJ -- Replace code that roots into the device
	//		registry by calls into the mini driver. The minidriver should
	// 		be the only thing that looks into the driver node.
	//
	FL_DECLARE_FUNC(0xd328ab03, "CTspDev::Load")
	TSPRETURN tspRet = FL_GEN_RETVAL(IDERR_INVALID_ERR);
	UINT cbDriverKey = 1+lstrlenA(lpszDriverKey);
	DWORD dwRegSize;
	DWORD dwRegType;
	DWORD dwRet;
  	REGDEVCAPS regdevcaps;
	HSESSION hSession=0;

	FL_LOG_ENTRY(psl);

	m_sync.EnterCrit(dwLUID_CurrentLoc);
	tspRet = m_sync.BeginLoad();

	if (tspRet) goto end;

	FL_ASSERT(psl, !m_StaticInfo.hSessionMD);
    ZeroMemory(&m_StaticInfo, sizeof(m_StaticInfo));
	m_hThreadAPC = NULL;
	ZeroMemory(&m_Settings, sizeof(m_Settings));
    ZeroMemory(&m_Line, sizeof(m_Line));
    ZeroMemory(&m_Phone, sizeof(m_Phone));
    ZeroMemory(&m_LLDev, sizeof(m_LLDev));
    m_pLine = NULL;
    m_pPhone = NULL;
    m_pLLDev = NULL;
    fdwResources=0; 
    m_fUnloadPending = FALSE;
    m_fUserRemovePending = FALSE;

	// Start a session with the mini driver. The mini driver will only
	// allow sessions if it in the loaded state. Furthermore,  it will not
	// distroy itself until all sessions are closed. This is the standard
	// semantics supported by class CSync -- look at csync.h for details.
	//
	if (!pMD)
    {
		FL_SET_RFR(0xefaf5900, "NULL pMD passed in");
		tspRet = FL_GEN_RETVAL(IDERR_GENERIC_FAILURE);
		goto end_load;
    }
	
	tspRet = pMD->BeginSession(
					&hSession,
					dwLUID_CurrentLoc
					);

	if (tspRet)
	{
		FL_SET_RFR(0x5371c600, "Couldn't begin session with MD");
		goto end_load;
	}

	if (cbDriverKey>sizeof(m_StaticInfo.rgchDriverKey))
	{
		FL_SET_RFR(0x528e2a00, "Driver Key too large");
		tspRet = FL_GEN_RETVAL(IDERR_INTERNAL_OBJECT_TOO_SMALL);
		goto end_load;
	}

	ASSERT(!m_pLine);

	m_StaticInfo.lptszProviderName = lptszProviderName;

	mfn_init_default_LINEDEVCAPS();

	// Only keep ANSI version of driver key -- it's only  used
	// for the devspecific (legacy hack) part of LINEDEVCAPS.
	lstrcpyA(m_StaticInfo.rgchDriverKey, lpszDriverKey);


	// 01/04/97 -- This stuff taken from NT4.0 CreateLineDev...

    // Get the Friendly Name
	dwRegSize = sizeof(m_StaticInfo.rgtchDeviceName);
    dwRet = RegQueryValueExW(
                hkDevice,
                cszFriendlyName,
                NULL,
                &dwRegType,
                (BYTE*) m_StaticInfo.rgtchDeviceName,
                &dwRegSize
            );
        
    if (dwRet != ERROR_SUCCESS || dwRegType != REG_SZ)
    {
		FL_SET_RFR(0x5a5cd100, "RegQueryValueEx(FriendlyName) fails");
		tspRet = FL_GEN_RETVAL(IDERR_REG_QUERY_FAILED);
        goto end_load;
    }

    // Read in the permanent ID
    {
        // Get the permanent ID
        DWORD dwID=0;
        DWORD cbSize=sizeof(dwID);
        DWORD dwRegType=0;
        const TCHAR cszPermanentIDKey[]   = TEXT("ID");
        DWORD dwRet = RegQueryValueEx(
                                hkDevice,
                                cszPermanentIDKey,
                                NULL,
                                &dwRegType,
                                (BYTE*) &dwID,
                                &cbSize
                            );

        if (dwRet == ERROR_SUCCESS
            && (dwRegType == REG_BINARY || dwRegType == REG_DWORD)
            && cbSize == sizeof(dwID)
            && dwID)
        {
            m_StaticInfo.dwPermanentLineID = dwID;
        }
    }

    // Read in the permanent GUID
    {
        // Get the permanent ID
        DWORD dwID=0;
        DWORD cbSize=sizeof(m_StaticInfo.PermanentDeviceGuid);
        DWORD dwRegType=0;

        DWORD dwRet = RegQueryValueEx(
                                hkDevice,
                                TEXT("PermanentGuid"),
                                NULL,
                                &dwRegType,
                                (BYTE*) &m_StaticInfo.PermanentDeviceGuid,
                                &cbSize
                                );

    }


    // Read in the REGDEVCAPS
    dwRegSize = sizeof(regdevcaps);
    dwRet = RegQueryValueEx(
			hkDevice,
			cszProperties,
			NULL,
			&dwRegType,
			(BYTE *)&regdevcaps,
			&dwRegSize
			);
	

	if (dwRet != ERROR_SUCCESS || dwRegType != REG_BINARY)
    {
		FL_SET_RFR(0xb7010000, "RegQueryValueEx(cszProperties) fails");
		tspRet = FL_GEN_RETVAL(IDERR_REG_QUERY_FAILED);
        goto end_load;
    }
	
    //
    // We want to make sure the following flags are identical
    //
    #if (LINEDEVCAPFLAGS_DIALBILLING != DIALOPTION_BILLING)
    #error LINEDEVCAPFLAGS_DIALBILLING != DIALOPTION_BILLING (check tapi.h vs. mcx16.h)
    #endif
    #if (LINEDEVCAPFLAGS_DIALQUIET != DIALOPTION_QUIET)
    #error LINEDEVCAPFLAGS_DIALQUIET != DIALOPTION_QUIET (check tapi.h vs. mcx16.h)
    #endif
    #if (LINEDEVCAPFLAGS_DIALDIALTONE != DIALOPTION_DIALTONE)
    #error LINEDEVCAPFLAGS_DIALDIALTONE != DIALOPTION_DIALTONE (check tapi.h vs. mcx16.h)
    #endif
    //

    // Make sure this is the dwDialOptions DWORD we want.
    ASSERT(!(regdevcaps.dwDialOptions & ~(LINEDEVCAPFLAGS_DIALBILLING |
                                          LINEDEVCAPFLAGS_DIALQUIET |
                                          LINEDEVCAPFLAGS_DIALDIALTONE)));
    m_StaticInfo.dwDevCapFlags = regdevcaps.dwDialOptions | LINEDEVCAPFLAGS_LOCAL;

    m_StaticInfo.dwMaxDCERate = regdevcaps.dwMaxDCERate;

    m_StaticInfo.dwModemOptions = regdevcaps.dwModemOptions;


    // Analyze device type and set mediamodes appropriately
	BYTE bDeviceType;
    dwRegSize = sizeof(bDeviceType);
    dwRet = RegQueryValueEx(
					hkDevice,
					cszDeviceType,
					NULL,
					&dwRegType,
                    &bDeviceType,
					&dwRegSize
					);
	if (	dwRet != ERROR_SUCCESS || dwRegType != REG_BINARY
		 || dwRegSize != sizeof(BYTE))
    {
		FL_SET_RFR(0x00164300, "RegQueryValueEx(cszDeviceType) fails");
		tspRet = FL_GEN_RETVAL(IDERR_REG_QUERY_FAILED);
        goto end_load;
    }
   
    m_StaticInfo.dwDeviceType = bDeviceType;
  
    switch (bDeviceType)
    {
        case DT_PARALLEL_PORT:
          m_StaticInfo.dwDeviceType = DT_NULL_MODEM;    // Map back to null modem
          // FALLTHROUGH
  
        case DT_NULL_MODEM:
          m_StaticInfo.dwDefaultMediaModes = LINEMEDIAMODE_DATAMODEM;
          m_StaticInfo.dwBearerModes       = LINEBEARERMODE_DATA
											 | LINEBEARERMODE_PASSTHROUGH;
          m_StaticInfo.fPartialDialing     = FALSE;
          break;
              
        case DT_PARALLEL_MODEM:
          m_StaticInfo.dwDeviceType = DT_EXTERNAL_MODEM;  // Map back to
														 // external modem
          // FALLTHROUGH
  
        case DT_EXTERNAL_MODEM:
        case DT_INTERNAL_MODEM:
        case DT_PCMCIA_MODEM:
          m_StaticInfo.dwDefaultMediaModes = LINEMEDIAMODE_DATAMODEM
											 | LINEMEDIAMODE_INTERACTIVEVOICE;
          m_StaticInfo.dwBearerModes = LINEBEARERMODE_VOICE
									   | LINEBEARERMODE_PASSTHROUGH;
  
          // read in Settings\DialSuffix to check whether we can partial dial
          m_StaticInfo.fPartialDialing = FALSE;
          HKEY hkSettings;
          dwRet = RegOpenKey(hkDevice, cszSettings, &hkSettings);
          if (dwRet == ERROR_SUCCESS)
          {
			#define HAYES_COMMAND_LENGTH 40
			TCHAR rgtchBuf[HAYES_COMMAND_LENGTH];
			dwRegSize = sizeof(rgtchBuf);
            dwRet = RegQueryValueEx(
							hkSettings,
							cszDialSuffix,
							NULL,
							&dwRegType,
							(BYTE *)rgtchBuf,
							&dwRegSize
							);
			if (dwRet == ERROR_SUCCESS && dwRegSize > sizeof(TCHAR))
            {
               m_StaticInfo.fPartialDialing = TRUE;
            }
            RegCloseKey(hkSettings);
            hkSettings=NULL;
          }
		  else
		  {
			// TODO: 1/5/97 JosephJ -- is this a failure or harmless???
		  }

         mfn_GetVoiceProperties(hkDevice,psl);


          break;
    
        default:
			FL_SET_RFR(0x0cea5400, "Invalid bDeviceType");
			tspRet = FL_GEN_RETVAL(IDERR_REG_CORRUPT);
			goto end_load;
    }
  

	// Get the default commconfig structure and fill out the other settings
	// (these used to be stored in the CommCfg structure in nt4.0 unimodem).
	// TODO 1/5/97 JosephJ -- this needs to be cleaned up to work with
	// 3rd-party mini drivers -- see note at head of this function.
	{
		DWORD dwcbSize = sizeof(m_Settings.rgbCommCfgBuf);
		m_Settings.pDialOutCommCfg = (COMMCONFIG *) m_Settings.rgbCommCfgBuf;
        m_Settings.pDialInCommCfg = (COMMCONFIG *) m_Settings.rgbDialInCommCfgBuf;
        m_Settings.pDialTempCommCfg = (COMMCONFIG *) m_Settings.rgbDialTempCommCfgBuf;

		dwRet =	UmRtlGetDefaultCommConfig(
						hkDevice,
						m_Settings.pDialOutCommCfg,
						&dwcbSize
						);

		if (dwRet != ERROR_SUCCESS)
		{
				FL_SET_RFR(0x55693500, "UmRtlGetDefaultCommConfig fails");
				tspRet = FL_GEN_RETVAL(IDERR_REG_CORRUPT);
				goto end_load;
		}

        //
        //  dialin and dialout start out the same.
        //
        CopyMemory(
            m_Settings.pDialInCommCfg,
            m_Settings.pDialOutCommCfg,
            dwcbSize
            );



        // 1/27/1998 JosephJ -- no longer use this field..
        // m_Settings.dcbDefault = m_Settings.pCommCfg->dcb; // Structure Copy

		if (mfn_IS_NULL_MODEM())
		{
			m_Settings.dwOptions = UMTERMINAL_NONE;
		}
		else
		{
			m_Settings.dwOptions = UMTERMINAL_NONE | UMLAUNCH_LIGHTS;
		}
		m_Settings.dwWaitBong = UMDEF_WAIT_BONG;
	}

    //// TODO: make the diagnostic caps based on the modem properties,
    /// For now, pretend that it's enabled.
    //  ALSO: don't support the tapi/line/diagnostics class
    //  if the modem doesn't support it...
    //
    if (m_StaticInfo.dwDeviceType != DT_NULL_MODEM)
    {
        m_StaticInfo.dwDiagnosticCaps   =  fSTANDARD_CALL_DIAGNOSTICS;
    }

    //
    // Set the m_Settings.dwNVRamState to non-zero only if there
    // are commands under the NVInit key, as well as the volatile value
    // NVInited is nonexistant or set to 0.
    //
    {
        m_Settings.dwNVRamState = 0;


        //
        // JosephJ - the following key used to be "NVInit", but changed this
        // to "ISDN\NVSave", because the NVInit commands may not be present at
        // the time we load the device.
        //
        UINT cCommands = ReadCommandsA(
                                hkDevice,
                                "ISDN\\NvSave",
                                NULL
                                );

        //
        // We don't care about the commands themselves at this point -- just
        // whether they exist or not...
        //
        if (cCommands)
        {
            //OutputDebugString(TEXT("FOUND NVINIT KEY\r\n"));
            m_Settings.dwNVRamState = fNVRAM_AVAILABLE|fNVRAM_SETTINGS_CHANGED;
    
            if (get_volatile_key_value(hkDevice))
            {
                //OutputDebugString(TEXT("NVRAM UP-TO-DATE -- NOT INITING\r\n"));
               //
               // non-zero value indicates that we don't need to re-init
               // nvram. This non-zero value is set ONLY when we
               // actually send out the nv-init commands to the modem.
               //
               mfn_ClearNeedToInitNVRam();
            }
            else
            {
                //OutputDebugString(TEXT("NVRAM STALE -- NEED TO INIT\r\n"));
            }

        }
    }

    //
    // Construct the various class lists -- this must be done after
    // all the basic capabilities have been determined.
    // Classes such as tapi/phone are only added if the device supports
    // the capability. This is new for NT5 (Even win95 unimodem/v simply made
    // ALL devices support tapi/phone, wave/in, etc).
    //
    // This is done so that basic device capabilities can be obtained
    // by looking at the device classes supported.
    //
    //
    // Currently (7/15/1997) Address device classes are the same as line
    // device classes. This may diverge in the future.
    //
    {

        m_StaticInfo.cbLineClassList = 0;
        m_StaticInfo.szzLineClassList = NULL;
        m_StaticInfo.cbPhoneClassList = 0;
        m_StaticInfo.szzPhoneClassList = NULL;
        m_StaticInfo.cbAddressClassList = 0;
        m_StaticInfo.szzAddressClassList = NULL;

        if (mfn_CanDoVoice())
        {
            if (mfn_IsPhone())
            {
                // ---- Line Class List ---------------------------
                //
                m_StaticInfo.cbLineClassList = 
                                sizeof(g_szzLineWithWaveAndPhoneClassList);
                m_StaticInfo.szzLineClassList = 
                                g_szzLineWithWaveAndPhoneClassList;

                // ---- Phone Class List ---------------------------
                //
                // Note that we only support wave audio if the device
                // supports handset functionality. Win9x unimodem does not
                // do this (in fact it reports phone classes even
                // for non-voice modems!).
                //
                m_StaticInfo.cbPhoneClassList =
                      (mfn_Handset())
                      ? sizeof(g_szzPhoneWithAudioClassList)
                      : sizeof(g_szzPhoneWithoutAudioClassList);
    
                m_StaticInfo.szzPhoneClassList = 
                      (mfn_Handset())
                      ?  g_szzPhoneWithAudioClassList
                      :  g_szzPhoneWithoutAudioClassList;

                // ---- Address Class List -------------------------
                //
                m_StaticInfo.cbAddressClassList =
                                sizeof(g_szzLineWithWaveAndPhoneClassList);
                m_StaticInfo.szzAddressClassList = 
                                g_szzLineWithWaveAndPhoneClassList;

            }
            else
            {
                // ---- Line Class List ---------------------------
                //
                m_StaticInfo.cbLineClassList = 
                                sizeof(g_szzLineWithWaveClassList);
                m_StaticInfo.szzLineClassList = 
                                g_szzLineWithWaveClassList;


                // ---- Address Class List -------------------------
                //
                m_StaticInfo.cbAddressClassList =
                                sizeof(g_szzLineWithWaveClassList);
                m_StaticInfo.szzAddressClassList = 
                                g_szzLineWithWaveClassList;
            }
        }
        else
        {
                // ---- Line Class List ---------------------------
                //
                m_StaticInfo.cbLineClassList = 
                                sizeof(g_szzLineNoVoiceClassList);
                m_StaticInfo.szzLineClassList = 
                                g_szzLineNoVoiceClassList;


                // ---- Address Class List -------------------------
                //
                m_StaticInfo.cbAddressClassList =
                                sizeof(g_szzLineNoVoiceClassList);
                m_StaticInfo.szzAddressClassList = 
                                g_szzLineNoVoiceClassList;
        }
	}

    // Init task stack ...
    {
        DEVTASKINFO *pInfo = m_rgTaskStack;
        DEVTASKINFO *pEnd=pInfo+sizeof(m_rgTaskStack)/sizeof(m_rgTaskStack[0]);
    
        // Init the task array to valid (but empty values).
        //
        ZeroMemory (m_rgTaskStack, sizeof(m_rgTaskStack));
        while(pInfo<pEnd)
        {
            pInfo->hdr.dwSigAndSize = MAKE_SigAndSize(sizeof(*pInfo));
            pInfo++;
        }
        m_uTaskDepth = 0;
        m_dwTaskCounter = 0;
        m_pfTaskPending = NULL;
        m_hRootTaskCompletionEvent = NULL;
    }


    m_hThreadAPC = hThreadAPC;

end_load:

	if (tspRet)
	{
		// Cleanup

		if (hSession)
		{
			pMD->EndSession(hSession);
		}
	}
	else
	{
		if (hkDevice) 
		{
			RegCloseKey(hkDevice);
			hkDevice=NULL;
		}
		m_StaticInfo.hSessionMD = hSession;
		m_StaticInfo.pMD 		= pMD;
	}


	m_sync.EndLoad(!(tspRet));

end:
	m_sync.LeaveCrit(dwLUID_CurrentLoc);

	FL_LOG_EXIT(psl, tspRet);

	return  tspRet;

}


void
CTspDev::Unload(
		HANDLE hEvent,
		LONG *plCounter
		)
{
    BOOL fLocalEvent = FALSE;

    //
    // NULL hEvent implies synchronous unload. We still need to potentially
    // wait for unload to complete, so we create our own event instead.
    //
    if (!hEvent)
    {
        hEvent = CreateEvent(
                        NULL,
                        TRUE,
                        FALSE,
                        NULL
                        );
        LONG lCounter=1;
        plCounter = &lCounter;
        fLocalEvent = TRUE;
    }

	TSPRETURN tspRet= m_sync.BeginUnload(hEvent, plCounter);

	m_sync.EnterCrit(0);


	if (!tspRet)
	{
		if (m_pLine)
		{
            mfn_UnloadLine(NULL);
            ASSERT(m_pLine == NULL);
		}

		if (m_pPhone)
		{
		    mfn_UnloadPhone(NULL);
            ASSERT(m_pPhone == NULL);
		}
#if 0
        //
        // 1/3/1998 JosephJ DYNAMIC PROTOCOL SELECTION
        //          TODO: move this to the minidriver
        //
        if (m_Settings.szzPreDialCommands)
        {
            FREE_MEMORY(m_Settings.szzPreDialCommands);
            m_Settings.szzPreDialCommands=NULL;
        }
#endif

		if (m_pLLDev)
		{
		    // This implies that there is pending activity, so
		    // we can't complete unload now...
		    // Unloading of CTspDev will deferred until
		    // m_pLLDev becomes NULL, at which point
		    // m_sync.EndUnload() will be called.

		    m_fUnloadPending  = TRUE;
		}
		else
		{
            goto end_unload;
        }
	}


	m_sync.LeaveCrit(0);

	//
    // We get here if there is a pending task. We don't
    // call EndUnload here because EndUnload will be called
    // when the task is completed.
    //
	// If we created this event locally, we wait for it to be set here itself...
	//
    if (fLocalEvent)
    {
        WaitForSingleObject(hEvent, INFINITE);
        CloseHandle(hEvent);
        hEvent=NULL;
    }

    return;


end_unload:


    //
    // We get here if there is no lldev activity.
    // We actually signal end of unload here (synchronously).
    //

    if (m_StaticInfo.hSessionMD)
    {
        ASSERT(m_StaticInfo.pMD);
        m_StaticInfo.pMD->EndSession(m_StaticInfo.hSessionMD);
        m_StaticInfo.hSessionMD=0;
        m_StaticInfo.pMD=NULL;
    }

    // After EndUnload returns, we should assume that the this pointer
    // is no longer valid, which is why we leave the critical section
    // first...
	m_sync.LeaveCrit(0);

    UINT uRefs = m_sync.EndUnload();


    if (fLocalEvent)
    {
        //
        // At this point, either the ref count was zero and so the event
        // has been signaled or the ref count was nonzero and so
        // the event remains to be signalled (but the state is unloaded) --
        // in this case we'll wait until the last person calls
        // EndSession, which will also set the event...
        //
    
        if (uRefs)
        {
            //
            // The ref count is nonzero, which means there are one
            // or more sessions active. We've already called EndUnload,
            // so now we simply wait -- the next time the ref count
            // goes to zero in a call to EndSession, EndSession will
            // set this event.
            //

            WaitForSingleObject(hEvent, INFINITE);
        }

        //
        // We allocated this ourselves, so we free it here ...
        //
        CloseHandle(hEvent);
        hEvent=NULL;
    }

    return;

}


LONG
ExtensionCallback(
    void *pvTspToken,
    DWORD dwRoutingInfo,
    void *pTspParams
    )
{
    LONG lRet = LINEERR_OPERATIONFAILED;
	FL_DECLARE_FUNC(0xeaf0b34f,"ExtensionCallback");
	FL_DECLARE_STACKLOG(sl, 1000);

    CTspDev *pDev = (CTspDev*) pvTspToken;

    TSPRETURN tspRet = pDev->AcceptTspCall(
                                    TRUE,
                                    dwRoutingInfo,
                                    pTspParams,
                                    &lRet,
                                    &sl
                                    );
                                        
    #define COLOR_DEV_EXTENSION FOREGROUND_RED

    sl.Dump(COLOR_DEV_EXTENSION);

    return lRet;
}

TSPRETURN
CTspDev::RegisterProviderInfo(
            ASYNC_COMPLETION cbCompletionProc,
            HPROVIDER hProvider,
            CStackLog *psl
            )
{
	FL_DECLARE_FUNC(0xccba5b51, "CTspDev::RegisterProviderInfo");
	TSPRETURN tspRet = 0;

	FL_LOG_ENTRY(psl);

	m_sync.EnterCrit(FL_LOC);


	if (m_sync.IsLoaded())
	{
		m_StaticInfo.pfnTAPICompletionProc  = cbCompletionProc;
        m_StaticInfo.hProvider = hProvider;

        //
        // LineID and PhoneID are filled out in subsequent calls
        // to ActivateLineDevice and ActivatePhoneDevice, respectively.
        //
        // This reason for this is tapi notifies us of line-device and
        // phone-device creation separately.
        //
        //
        // We are guaranteed not to be called with an line (phone) api
        // until after ActivateLine(Phone)Device is called.
        //
        //
		m_StaticInfo.dwTAPILineID= 0xffffffff; // bogus value
		m_StaticInfo.dwTAPIPhoneID= 0xffffffff; // bogus value

		//
		// Now lets bind to the extension DLL if required...
		//
		if (m_StaticInfo.pMD->ExtIsEnabled())
		{
		    HANDLE h = m_StaticInfo.pMD->ExtOpenExtensionBinding(
                                    NULL, // TODO: hKeyDevice,
                                    cbCompletionProc,
                                    // dwLineID, << OBSOLETE 10/13/1997
                                    // dwPhoneID, << OBSOLETE 10/13/1997
                                    ExtensionCallback
                                    );
            m_StaticInfo.hExtBinding = h;

            if (!h)
            {
	            FL_SET_RFR(0x33d90700, "ExtOpenExtensionBinding failed");
		        tspRet = FL_GEN_RETVAL(IDERR_MDEXT_BINDING_FAILED);
            }

            // We are hardcore about ONLY using the extension proc here...
		    m_StaticInfo.pfnTAPICompletionProc  = NULL;
		    
		}

	}
	else
	{
		FL_SET_RFR(0xb8b24200, "wrong state");
		tspRet = FL_GEN_RETVAL(IDERR_WRONGSTATE);
	}

	m_sync.LeaveCrit(FL_LOC);

	FL_LOG_EXIT(psl,tspRet);

	return  tspRet;

}

#define ROUND_TO_DWORD(_x) ( (_x + (sizeof(DWORD) - 1) ) & ~(sizeof(DWORD)-1))

TSPRETURN
CTspDev::mfn_get_LINDEVCAPS (
	LPLINEDEVCAPS lpLineDevCaps,
	LONG *plRet,
	CStackLog *psl
)
//
// mfn_get_LINEDEVCAPS uses cached information to fill out the passed-in
// LINEDEVCAPS structure in large chunks.
//
{
	FL_DECLARE_FUNC(0x7e77dd17, "CTspDev::mfn_get_LINEDEVCAPS")
	BYTE *pbStart = (BYTE*)lpLineDevCaps;
	BYTE *pbCurrent = pbStart;
	BYTE *pbEnd = pbStart + lpLineDevCaps->dwTotalSize;
	UINT cbItem=0;
	DWORD dwNeededSize = sizeof (LINEDEVCAPS);

	FL_LOG_ENTRY(psl);

	*plRet = 0; // Assume success;

	if ((pbEnd-pbCurrent) < sizeof(LINEDEVCAPS))
	{
		*plRet = LINEERR_STRUCTURETOOSMALL;
		FL_SET_RFR(0x8456cb00, "LINEDEVCAPS structure too small");
		goto end;
	}

	//
	// Zero out the the first sizeof(LINEDEVCAPS) of the passed-in structure,
	// copy in our own default cached structure, and fixup the total size.
	//
	ZeroMemory(lpLineDevCaps,(sizeof(LINEDEVCAPS)));
	CopyMemory(lpLineDevCaps,&m_StaticInfo.DevCapsDefault,sizeof(LINEDEVCAPS));
    ASSERT(lpLineDevCaps->dwUsedSize == sizeof(LINEDEVCAPS));
	lpLineDevCaps->dwTotalSize = (DWORD)(pbEnd-pbStart);
	pbCurrent += sizeof(LINEDEVCAPS);
  
	//
	// Fill in some of the modem-specific caps
	//
    lpLineDevCaps->dwMaxRate      = m_StaticInfo.dwMaxDCERate;
    lpLineDevCaps->dwBearerModes  = m_StaticInfo.dwBearerModes;
    lpLineDevCaps->dwMediaModes = m_StaticInfo.dwDefaultMediaModes;
	// 		Note NT4.0 unimodem set lpLineDevCaps->dwMediaModes to
	// 		LINEDEV.dwMediaModes, not to .dwDefaultMediaModes. Howerver the
	// 		two are always the same in NT4.0 -- neither is changed from its
	// 		initial value, created when LINEDEV is created.
  	// We can simulate wait-for-bong....
    lpLineDevCaps->dwDevCapFlags         = m_StaticInfo.dwDevCapFlags |
                                         LINEDEVCAPFLAGS_DIALBILLING |
                                         LINEDEVCAPFLAGS_CLOSEDROP;
    lpLineDevCaps->dwPermanentLineID = m_StaticInfo.dwPermanentLineID;

    if(mfn_CanDoVoice())
    {
       lpLineDevCaps->dwGenerateDigitModes       = LINEDIGITMODE_DTMF;
       lpLineDevCaps->dwMonitorToneMaxNumFreq    = 1;      // silence monitor
       lpLineDevCaps->dwMonitorToneMaxNumEntries = 1;
       lpLineDevCaps->dwMonitorDigitModes        = LINEDIGITMODE_DTMF
                                                   | LINEDIGITMODE_DTMFEND;

       // 6/2/1997 JosephJ TBD: the following was enabled in unimodem/v.
       //          Enable it at the point when forwarding is implemented....
       // lpLineDevCaps->dwLineFeatures |= LINEFEATURE_FORWARD;

#if (TAPI3)
        
       //
       // If this is a duplex device, say we support MSP stuff...
       //

       if (m_StaticInfo.Voice.dwProperties & fVOICEPROP_DUPLEX)
       {
            lpLineDevCaps->dwDevCapFlags      |=  LINEDEVCAPFLAGS_MSP;
       }

#endif // TAPI3

    }

#if (TAPI3)
    lpLineDevCaps->dwAddressTypes =  LINEADDRESSTYPE_PHONENUMBER;
    lpLineDevCaps->ProtocolGuid =  TAPIPROTOCOL_PSTN;
    lpLineDevCaps->dwAvailableTracking = 0;
    CopyMemory(
        (LPBYTE)&lpLineDevCaps->PermanentLineGuid,
        (LPBYTE)&m_StaticInfo.PermanentDeviceGuid,
        sizeof(GUID)
        );

#endif // TAPI3
	//
    // Copy in the provider info if it fits
	//
	cbItem = sizeof(TCHAR)*(1+lstrlen(m_StaticInfo.lptszProviderName));
	dwNeededSize += ROUND_TO_DWORD(cbItem);
    if ((pbCurrent+cbItem)<=pbEnd)
    {
		CopyMemory((LPTSTR) pbCurrent, m_StaticInfo.lptszProviderName, cbItem);
		lpLineDevCaps->dwProviderInfoSize = cbItem;
		lpLineDevCaps->dwProviderInfoOffset = (DWORD)(pbCurrent-pbStart);
		pbCurrent += ROUND_TO_DWORD(cbItem);
    }

  
	//
    // Copy the device name if it fits
	//
	cbItem =  sizeof(TCHAR)*(1+lstrlen(m_StaticInfo.rgtchDeviceName));
	dwNeededSize += ROUND_TO_DWORD(cbItem);
    if ((pbCurrent+cbItem)<=pbEnd)
    {
		CopyMemory((LPTSTR) pbCurrent, m_StaticInfo.rgtchDeviceName, cbItem);
		lpLineDevCaps->dwLineNameSize = cbItem;
		lpLineDevCaps->dwLineNameOffset = (DWORD)(pbCurrent-pbStart);
		pbCurrent += ROUND_TO_DWORD(cbItem);
    }

	//
	// Copy device-specific stuff
	// This is a hack structure used by MSFAX and a few others.
	//
	// First move up to a dword aligned address
	//
	//
    {
        BYTE *pb = pbCurrent;
        pbCurrent = (BYTE*) ((ULONG_PTR) (pbCurrent+3) & (~0x3));

        if (pbCurrent >= pbEnd)
        {
            pbCurrent = pbEnd;

            // Since we've already exhausted available space, we need to
            // ask for the most space that we may need for this allignment
            // stuff, because the next time the allignment situation may
            // be different.
            //
            dwNeededSize += sizeof(DWORD);
        }
        else
        {
            dwNeededSize += (DWORD)(pbCurrent-pb);
        }
    }


	
	{
		struct _DevSpecific
		{
			DWORD dwSig;
			DWORD dwKeyOffset;
			#pragma warning (disable : 4200)
			char szDriver[];
			#pragma warning (default : 4200)

		} *pDevSpecific = (struct _DevSpecific*) pbCurrent;

		// Note that the driver key is in ANSI
		//
		cbItem = sizeof(*pDevSpecific)+1+lstrlenA(m_StaticInfo.rgchDriverKey);
        dwNeededSize += ROUND_TO_DWORD(cbItem);
		if ((pbCurrent+cbItem)<=pbEnd)
		{
			pDevSpecific->dwSig = 0x1;
			pDevSpecific->dwKeyOffset = 8; // Offset in bytes of szDriver
                                           // from start
			CopyMemory(
				pDevSpecific->szDriver,
				m_StaticInfo.rgchDriverKey,
				cbItem-sizeof(*pDevSpecific)
				);
			  lpLineDevCaps->dwDevSpecificSize   = cbItem;
			  lpLineDevCaps->dwDevSpecificOffset = (DWORD)(pbCurrent-pbStart);
			  pbCurrent += ROUND_TO_DWORD(cbItem);
		}
	}

    //
    // Copy line device Class list if it fits....
    //

    cbItem =  mfn_GetLineClassListSize();

	dwNeededSize += ROUND_TO_DWORD(cbItem);
    if ((pbCurrent+cbItem)<=pbEnd)
    {
		CopyMemory(
			(LPTSTR) pbCurrent,
            mfn_GetLineClassList(),
			cbItem
			);
    	lpLineDevCaps->dwDeviceClassesSize  = cbItem;
    	lpLineDevCaps->dwDeviceClassesOffset= (DWORD)(pbCurrent-pbStart);
		pbCurrent += ROUND_TO_DWORD(cbItem);
    }

	ASSERT(pbCurrent<=pbEnd);
	ASSERT(dwNeededSize>= (DWORD)(pbCurrent-pbStart));
    lpLineDevCaps->dwNeededSize  = dwNeededSize;
    lpLineDevCaps->dwUsedSize  = (DWORD)(pbCurrent-pbStart);
    lpLineDevCaps->dwNeededSize  = dwNeededSize;
 
	SLPRINTF3(
		psl,
		"Tot=%u,Used=%lu,Needed=%lu",
		lpLineDevCaps->dwTotalSize,
		lpLineDevCaps->dwUsedSize,
		lpLineDevCaps->dwNeededSize
		);
	ASSERT(*plRet==ERROR_SUCCESS);

end:	

	FL_LOG_EXIT(psl, 0);
	return 0;
}


TSPRETURN
CTspDev::mfn_get_PHONECAPS (
    LPPHONECAPS lpPhoneCaps,
	LONG *plRet,
	CStackLog *psl
)
//
// mfn_get_LINEDEVCAPS uses cached information to fill out the passed-in
// LINEDEVCAPS structure in large chunks.
//
//
//  6/2/1997 JosephJ: this is taken more-or-less verbatim from win9x unimodem/v
//              (phoneGetDevCaps in cfgdlg.c).
//
{
	FL_DECLARE_FUNC(0x9b9459e3, "CTspDev::mfn_get_PHONECAPS")
	BYTE *pbStart = (BYTE*)lpPhoneCaps;
	BYTE *pbCurrent = pbStart;
	BYTE *pbEnd = pbStart + lpPhoneCaps->dwTotalSize;
	UINT cbItem=0;
	DWORD dwNeededSize = sizeof (PHONECAPS);

	FL_LOG_ENTRY(psl);

	*plRet = 0; // Assume success;

    if (!mfn_IsPhone())
    {
		*plRet = PHONEERR_NODEVICE;
		FL_SET_RFR(0xd191ae00, "Device doesn't support phone capability");
		goto end;
    }

	if ((pbEnd-pbCurrent) < sizeof(PHONECAPS))
	{
		*plRet = LINEERR_STRUCTURETOOSMALL;
		FL_SET_RFR(0x9e30ec00, "PHONECAPS structure too small");
		goto end;
	}

	//
	// Fill out the static portion of the capabilities
	//

    // Zero out the entire structure prior to starting. We then only explicitly
    // set non-zero values. This is different than unimodem/v.
    //
	ZeroMemory(lpPhoneCaps,(sizeof(PHONECAPS)));
    lpPhoneCaps->dwTotalSize = (DWORD)(pbEnd-pbStart);
    lpPhoneCaps->dwUsedSize = sizeof(PHONECAPS);
	pbCurrent += sizeof(PHONECAPS);

    // no phone info  
    lpPhoneCaps->dwPhoneInfoSize = 0;
    lpPhoneCaps->dwPhoneInfoOffset = 0;
    
    //
    // 6/2/1997 JosephJ: unimodem/v used the following formula for generating
    //      the PermanentPhoneID: MAKELONG(LOWORD(pLineDev->dwPermanentLineID),
    //                                     LOWORD(gdwProviderID));
    //      We simply use the device's permanent ID (i.e., report the same
    //      permanent id for both line and phone.)
    //
    lpPhoneCaps->dwPermanentPhoneID =   m_StaticInfo.dwPermanentLineID;
    lpPhoneCaps->dwStringFormat = STRINGFORMAT_ASCII;
    
    // initialize the real non-zero phone variables
    
    if(mfn_Handset())
    {
        lpPhoneCaps->dwPhoneFeatures = PHONEFEATURE_GETHOOKSWITCHHANDSET;

        lpPhoneCaps->dwMonitoredHandsetHookSwitchModes = PHONEHOOKSWITCHMODE_MICSPEAKER |
                                                         PHONEHOOKSWITCHMODE_ONHOOK;

        lpPhoneCaps->dwHookSwitchDevs |= PHONEHOOKSWITCHDEV_HANDSET;
        lpPhoneCaps->dwHandsetHookSwitchModes = PHONEHOOKSWITCHMODE_UNKNOWN |
                                                PHONEHOOKSWITCHMODE_ONHOOK |
                                                PHONEHOOKSWITCHMODE_MICSPEAKER;
        lpPhoneCaps->dwPhoneStates |= PHONESTATE_HANDSETHOOKSWITCH;
    }

    if(mfn_IsSpeaker())
    {
        lpPhoneCaps->dwPhoneFeatures |= PHONEFEATURE_GETGAINSPEAKER       |
                                        PHONEFEATURE_GETVOLUMESPEAKER     |
                                        PHONEFEATURE_GETHOOKSWITCHSPEAKER |
                                        PHONEFEATURE_SETGAINSPEAKER       |
                                        PHONEFEATURE_SETVOLUMESPEAKER     |
                                        PHONEFEATURE_SETHOOKSWITCHSPEAKER;

        lpPhoneCaps->dwSettableSpeakerHookSwitchModes = PHONEHOOKSWITCHMODE_MICSPEAKER |
                                                        PHONEHOOKSWITCHMODE_ONHOOK;
        if (mfn_IsMikeMute())
        {
            lpPhoneCaps->dwSettableSpeakerHookSwitchModes |= PHONEHOOKSWITCHMODE_SPEAKER;
        }

        lpPhoneCaps->dwHookSwitchDevs |= PHONEHOOKSWITCHDEV_SPEAKER;
        lpPhoneCaps->dwSpeakerHookSwitchModes = PHONEHOOKSWITCHMODE_UNKNOWN |
                                                PHONEHOOKSWITCHMODE_ONHOOK |
                                                PHONEHOOKSWITCHMODE_MICSPEAKER;

        if (mfn_IsMikeMute())
        {
           lpPhoneCaps->dwSpeakerHookSwitchModes |= PHONEHOOKSWITCHMODE_SPEAKER;
        }

        lpPhoneCaps->dwPhoneStates |= ( PHONESTATE_SPEAKERHOOKSWITCH |
                                        PHONESTATE_SPEAKERVOLUME );
        lpPhoneCaps->dwVolumeFlags |= PHONEHOOKSWITCHDEV_SPEAKER;
        lpPhoneCaps->dwGainFlags |= PHONEHOOKSWITCHDEV_SPEAKER;
    }

	//
    // Copy in the provider info if it fits
	//
	cbItem = sizeof(TCHAR)*(1+lstrlen(m_StaticInfo.lptszProviderName));
	dwNeededSize += cbItem;
    if ((pbCurrent+cbItem)<=pbEnd)
    {
		CopyMemory((LPTSTR) pbCurrent, m_StaticInfo.lptszProviderName, cbItem);
		lpPhoneCaps->dwProviderInfoSize = cbItem;
		lpPhoneCaps->dwProviderInfoOffset = (DWORD)(pbCurrent-pbStart);
		pbCurrent += cbItem;
    }
  
	//
    // Copy the device name if it fits
	//
	cbItem =  sizeof(TCHAR)*(1+lstrlen(m_StaticInfo.rgtchDeviceName));
	dwNeededSize += cbItem;
    if ((pbCurrent+cbItem)<=pbEnd)
    {
		CopyMemory((LPTSTR) pbCurrent, m_StaticInfo.rgtchDeviceName, cbItem);
		lpPhoneCaps->dwPhoneNameSize = cbItem;
		lpPhoneCaps->dwPhoneNameOffset = (DWORD)(pbCurrent-pbStart);
		pbCurrent += cbItem;
    }

    #if 0
	// 
	// Copy class names if they fit.
    // 6/2/1997 JosephJ TBD: this is new for TAPI2.0, so this must be added --
    // determine the class names we support for phone devices and add it here.
	//
	cbItem = sizeof(g_szzPhoneClassList);
	dwNeededSize += cbItem;
    if ((pbCurrent+cbItem)<=pbEnd)
    {
		CopyMemory(
			(LPTSTR) pbCurrent,
            g_szzClassList,
			cbItem
			);
    	lpPhoneCaps->dwDeviceClassesSize  = cbItem;
    	lpPhoneCaps->dwDeviceClassesOffset= pbCurrent-pbStart;
		pbCurrent += cbItem;
    }
    #endif // 0

    //
    // Copy phone device Class list if it fits....
    //

    cbItem =  mfn_GetPhoneClassListSize();

	dwNeededSize += cbItem;
    if ((pbCurrent+cbItem)<=pbEnd)
    {
		CopyMemory(
			(LPTSTR) pbCurrent,
            mfn_GetPhoneClassList(),
			cbItem
			);
    	lpPhoneCaps->dwDeviceClassesSize  = cbItem;
    	lpPhoneCaps->dwDeviceClassesOffset= (DWORD)(pbCurrent-pbStart);
		pbCurrent += cbItem;
    }


	ASSERT(pbCurrent<=pbEnd);
	ASSERT(dwNeededSize>= (DWORD)(pbCurrent-pbStart));
    lpPhoneCaps->dwNeededSize  = dwNeededSize;
    lpPhoneCaps->dwUsedSize  = (DWORD)(pbCurrent-pbStart);

	SLPRINTF3(
		psl,
		"Tot=%u,Used=%lu,Needed=%lu",
		lpPhoneCaps->dwTotalSize,
		lpPhoneCaps->dwUsedSize,
		lpPhoneCaps->dwNeededSize
		);
	ASSERT(*plRet==ERROR_SUCCESS);

end:	

	FL_LOG_EXIT(psl, 0);
	return 0;
}


//
// Initialize default capability structures, such as default linedevcaps
//
void
CTspDev::mfn_init_default_LINEDEVCAPS(void)
{
	#define CAPSFIELD(_field) m_StaticInfo.DevCapsDefault._field

	ZeroMemory(
		&(m_StaticInfo.DevCapsDefault),
		sizeof (m_StaticInfo.DevCapsDefault)
		);
  CAPSFIELD(dwUsedSize) = sizeof(LINEDEVCAPS);

  CAPSFIELD(dwStringFormat) = STRINGFORMAT_ASCII;
  
  CAPSFIELD(dwAddressModes) = LINEADDRESSMODE_ADDRESSID;
  CAPSFIELD(dwNumAddresses) = 1;


  CAPSFIELD(dwRingModes)           = 1;
  CAPSFIELD(dwMaxNumActiveCalls)   = 1;

  CAPSFIELD(dwLineStates) = LINEDEVSTATE_CONNECTED |
                                LINEDEVSTATE_DISCONNECTED |
                                LINEDEVSTATE_OPEN |
                                LINEDEVSTATE_CLOSE |
                                LINEDEVSTATE_INSERVICE |
                                LINEDEVSTATE_OUTOFSERVICE |
                                LINEDEVSTATE_REMOVED |
                                LINEDEVSTATE_RINGING |
                                LINEDEVSTATE_REINIT;

  CAPSFIELD(dwLineFeatures) = LINEFEATURE_MAKECALL;

  // As required for bug #26507
  // [brwill-060700]

  CAPSFIELD(dwDevCapFlags) = LINEDEVCAPFLAGS_LOCAL;

}

TSPRETURN
CTspDev::mfn_get_ADDRESSCAPS (
		DWORD dwDeviceID,
		LPLINEADDRESSCAPS lpAddressCaps,
		LONG *plRet,
		CStackLog *psl
		)
{
	FL_DECLARE_FUNC(0xed6c4370, "CTspDev::mfn_get_ADDRESSCAPS")

	// We constuct the AddressCaps on the stack, and if all goes well,
	// copy it over to *lpAddressCaps.
	//
	LINEADDRESSCAPS AddressCaps;

	FL_LOG_ENTRY(psl);

	ZeroMemory(&AddressCaps, sizeof(LINEADDRESSCAPS));
	AddressCaps.dwTotalSize = lpAddressCaps->dwTotalSize;

    // Check to see if we have enough memory in the structure.
    //
	*plRet = 0; // Assume success;

	if (AddressCaps.dwTotalSize < sizeof(AddressCaps))
	{
		*plRet = LINEERR_STRUCTURETOOSMALL;
		FL_SET_RFR(0x72f00800, "ADDRESSCAPS structure too small");
		goto end;
	}
   
    AddressCaps.dwLineDeviceID      = dwDeviceID;

    AddressCaps.dwAddressSharing     = LINEADDRESSSHARING_PRIVATE;
    AddressCaps.dwCallInfoStates     = LINECALLINFOSTATE_APPSPECIFIC
									   | LINECALLINFOSTATE_MEDIAMODE
                                       | LINECALLINFOSTATE_CALLERID;
                                    // TODO: From Unimodem/V add:
                                    //  LINECALLINFOSTATE_MONITORMODES

    AddressCaps.dwCallerIDFlags      =  LINECALLPARTYID_UNAVAIL |
                                        LINECALLPARTYID_UNKNOWN |
                                        LINECALLPARTYID_NAME    |
                                        LINECALLPARTYID_BLOCKED |
                                        LINECALLPARTYID_OUTOFAREA |
                                        LINECALLPARTYID_ADDRESS;
    

    AddressCaps.dwCalledIDFlags      = LINECALLPARTYID_UNAVAIL;
    AddressCaps.dwConnectedIDFlags   = LINECALLPARTYID_UNAVAIL;
    AddressCaps.dwRedirectionIDFlags = LINECALLPARTYID_UNAVAIL;
    AddressCaps.dwRedirectingIDFlags = LINECALLPARTYID_UNAVAIL;

    AddressCaps.dwCallStates = LINECALLSTATE_IDLE
                               | LINECALLSTATE_OFFERING
                               | LINECALLSTATE_ACCEPTED
                               | LINECALLSTATE_DIALTONE
                               | LINECALLSTATE_DIALING
                               | LINECALLSTATE_CONNECTED
                               | LINECALLSTATE_PROCEEDING
                               | LINECALLSTATE_DISCONNECTED
                               | LINECALLSTATE_UNKNOWN;

    AddressCaps.dwDialToneModes   = LINEDIALTONEMODE_UNAVAIL;
    AddressCaps.dwBusyModes       = LINEBUSYMODE_UNAVAIL;

    AddressCaps.dwSpecialInfo     = LINESPECIALINFO_UNAVAIL;

    AddressCaps.dwDisconnectModes = LINEDISCONNECTMODE_UNAVAIL
                                    |  LINEDISCONNECTMODE_NORMAL
                                    |  LINEDISCONNECTMODE_BUSY
                                    |  LINEDISCONNECTMODE_NODIALTONE
                                    |  LINEDISCONNECTMODE_NOANSWER;

    AddressCaps.dwMaxNumActiveCalls          = 1;

    // dwAddrCapFlags
    if (!mfn_IS_NULL_MODEM())
    {
      AddressCaps.dwAddrCapFlags = LINEADDRCAPFLAGS_DIALED;
    }
    if (m_StaticInfo.fPartialDialing)
    {
      AddressCaps.dwAddrCapFlags |= LINEADDRCAPFLAGS_PARTIALDIAL;
    }

    AddressCaps.dwCallFeatures = LINECALLFEATURE_ANSWER
                                 |  LINECALLFEATURE_ACCEPT
                                 |  LINECALLFEATURE_SETCALLPARAMS
                                 |  LINECALLFEATURE_DIAL
                                 |  LINECALLFEATURE_DROP;

    AddressCaps.dwAddressFeatures = LINEADDRFEATURE_MAKECALL;               

    AddressCaps.dwUsedSize = sizeof(LINEADDRESSCAPS);

	// Note NT4.0 unimodem set AddressCaps->dwMediaModes to
	// LINEDEV.dwMediaModes, not to .dwDefaultMediaModes. Howerver the
	// two are always the same in NT4.0 -- neither is changed from its
	// initial value, created when LINEDEV is created.
	//
    AddressCaps.dwAvailableMediaModes = m_StaticInfo.dwDefaultMediaModes;


    // Get Address class list
    {
        UINT cbClassList = mfn_GetAddressClassListSize();

        AddressCaps.dwNeededSize = AddressCaps.dwUsedSize + cbClassList;

        if (AddressCaps.dwTotalSize >= AddressCaps.dwNeededSize)
        {
          AddressCaps.dwUsedSize          += cbClassList;
          AddressCaps.dwDeviceClassesSize  = cbClassList;
          AddressCaps.dwDeviceClassesOffset= sizeof(LINEADDRESSCAPS);
    
          // Note that we are copying this into the passed in lpAddressCaps...
          CopyMemory(
                (LPBYTE)(lpAddressCaps+1),
                mfn_GetAddressClassList(),
                cbClassList
                );
        }
        else
        {
          AddressCaps.dwDeviceClassesSize  = 0;
          AddressCaps.dwDeviceClassesOffset= 0;
        }
    }

	// Now copy the AddressCaps structure itself
	CopyMemory(lpAddressCaps, &AddressCaps, sizeof(AddressCaps));

	ASSERT(*plRet==ERROR_SUCCESS);

end:
	
	FL_LOG_EXIT(psl, 0);
	return 0;
}


PFN_CTspDev_TASK_HANDLER

//
// Utility task handlers
//
CTspDev::s_pfn_TH_UtilNOOP             = &(CTspDev::mfn_TH_UtilNOOP),


//
// PHONE-specific task handlers
//
CTspDev::s_pfn_TH_PhoneAsyncTSPICall   = &(CTspDev::mfn_TH_PhoneAsyncTSPICall),
CTspDev::s_pfn_TH_PhoneSetSpeakerPhoneState
                                 = &(CTspDev::mfn_TH_PhoneSetSpeakerPhoneState),


//
// LINE-specific task handlers
//
// CTspDev::s_pfn_TH_LineAsyncTSPICall = &(CTspDev::mfn_TH_LineAsyncTSPICall),

//
// CALL-specific task handlers
//
CTspDev::s_pfn_TH_CallAnswerCall      = &(CTspDev::mfn_TH_CallAnswerCall),
CTspDev::s_pfn_TH_CallGenerateDigit   = &(CTspDev::mfn_TH_CallGenerateDigit),
CTspDev::s_pfn_TH_CallMakeCall        = &(CTspDev::mfn_TH_CallMakeCall),
CTspDev::s_pfn_TH_CallMakeCall2       = &(CTspDev::mfn_TH_CallMakeCall2),
CTspDev::s_pfn_TH_CallMakeTalkDropCall= &(CTspDev::mfn_TH_CallMakeTalkDropCall),
CTspDev::s_pfn_TH_CallWaitForDropToGoAway= &(CTspDev::mfn_TH_CallWaitForDropToGoAway),
CTspDev::s_pfn_TH_CallDropCall        = &(CTspDev::mfn_TH_CallDropCall),
CTspDev::s_pfn_TH_CallMakePassthroughCall
                                      = &(CTspDev::mfn_TH_CallMakePassthroughCall),
CTspDev::s_pfn_TH_CallStartTerminal   = &(CTspDev::mfn_TH_CallStartTerminal),
CTspDev::s_pfn_TH_CallPutUpTerminalWindow
                                      = &(CTspDev::mfn_TH_CallPutUpTerminalWindow),
CTspDev::s_pfn_TH_CallSwitchFromVoiceToData
                              = &(CTspDev::mfn_TH_CallSwitchFromVoiceToData),


//
// LLDEV-specifc task handlers
//

CTspDev::s_pfn_TH_LLDevStartAIPCAction= &(CTspDev::mfn_TH_LLDevStartAIPCAction),
CTspDev::s_pfn_TH_LLDevStopAIPCAction = &(CTspDev::mfn_TH_LLDevStopAIPCAction),
CTspDev::s_pfn_TH_LLDevNormalize      = &(CTspDev::mfn_TH_LLDevNormalize),
CTspDev::s_pfn_TH_LLDevUmMonitorModem = &(CTspDev::mfn_TH_LLDevUmMonitorModem),
CTspDev::s_pfn_TH_LLDevUmInitModem    = &(CTspDev::mfn_TH_LLDevUmInitModem),
CTspDev::s_pfn_TH_LLDevUmDialModem    = &(CTspDev::mfn_TH_LLDevUmDialModem),
CTspDev::s_pfn_TH_LLDevUmAnswerModem  = &(CTspDev::mfn_TH_LLDevUmAnswerModem),
CTspDev::s_pfn_TH_LLDevUmHangupModem  = &(CTspDev::mfn_TH_LLDevUmHangupModem),
CTspDev::s_pfn_TH_LLDevUmWaveAction   = &(CTspDev::mfn_TH_LLDevUmWaveAction),
CTspDev::s_pfn_TH_LLDevHybridWaveAction
                             = &(CTspDev::mfn_TH_LLDevHybridWaveAction),
CTspDev::s_pfn_TH_LLDevUmGenerateDigit
                             = &(CTspDev::mfn_TH_LLDevUmGenerateDigit),
CTspDev::s_pfn_TH_LLDevUmGetDiagnostics
                             = &(CTspDev::mfn_TH_LLDevUmGetDiagnostics),
CTspDev::s_pfn_TH_LLDevUmSetPassthroughMode
                             = &(CTspDev::mfn_TH_LLDevUmSetPassthroughMode),
CTspDev::s_pfn_TH_LLDevUmSetSpeakerPhoneMode
                             = &(CTspDev::mfn_TH_LLDevUmSetSpeakerPhoneMode),
CTspDev::s_pfn_TH_LLDevUmSetSpeakerPhoneVolGain
                             = &(CTspDev::mfn_TH_LLDevUmSetSpeakerPhoneVolGain),
CTspDev::s_pfn_TH_LLDevUmSetSpeakerPhoneState
                             = &(CTspDev::mfn_TH_LLDevUmSetSpeakerPhoneState),
CTspDev::s_pfn_TH_LLDevUmIssueCommand
                             = &(CTspDev::mfn_TH_LLDevUmIssueCommand),
CTspDev::s_pfn_TH_LLDevIssueMultipleCommands
                             = &(CTspDev::mfn_TH_LLDevIssueMultipleCommands);



BOOL validate_DWORD_aligned_zero_buffer(
        void *pv,
        UINT cb
        )
{
    DWORD *pdw = (DWORD *) pv;
    DWORD *pdwEnd = pdw + (cb>>2);

    // Buffer and count MUST be dword aligned!
    ASSERT(!(((ULONG_PTR)pv) & 0x3) && !(cb&0x3));

    while(pdw<pdwEnd && !*pdw)
    {
        pdw++;
    }

    return  pdw==pdwEnd;
}


void
CTspDev::mfn_GetVoiceProperties (
            HKEY hkDrv,
            CStackLog *psl
        )
{
	FL_DECLARE_FUNC(0xb9547d21, "CTspDev::mfn_GetVoiceProperties")
    DWORD dwRet = 0;
    DWORD dwData = 0;
    DWORD dwRegSize = 0;
    DWORD dwRegType = 0;

	FL_LOG_ENTRY(psl);

    ZeroMemory(&m_StaticInfo.Voice, sizeof(m_StaticInfo.Voice));

    //
    // Get the voice-profile flags
    //
    dwRegSize = sizeof(DWORD);

    dwRet =  RegQueryValueEx(
                    hkDrv,
                    cszVoiceProfile,
                    NULL,
                    &dwRegType, 
                    (BYTE*) &dwData,
                    &dwRegSize);

    if (dwRet || dwRegType != REG_BINARY)
    {
        // no voice operation
        dwData = 0;

        // Unimodem/V did this...
        //dwData =
        //    VOICEPROF_NO_DIST_RING |
        //    VOICEPROF_NO_CALLER_ID |
        //    VOICEPROF_NO_GENERATE_DIGITS |
        //    VOICEPROF_NO_MONITOR_DIGITS;
    }
    else
    {


    }

    // 2/26/1997 JosephJ
    //      Unimodem/V implemented call forwarding and distinctive
    //      ring handling. NT5.0 currently doesn't. The
    //      specific property fields that I have not migrated
    //      from unimodem/v are: ForwardDelay and SwitchFeatures.
    //      Look at unimodem/v, umdminit.c for that stuff.
    //
    //      Same deal with Mixer-related stuff. I don't understand
    //      this and if and when the time comes we can add it.
    //      Look for VOICEPROF_MIXER, GetMixerValues(...),
    //      dwMixer, etc in the unimodem/v sources for mixer-
    //      related stuff.


    //
    // Save voice info.
    //
    // 3/1/1997 JosephJ
    //  Currently, for 5.0, we just set the CLASS_8 bit.
    //  The following value of VOICEPROF_CLASS8ENABLED is stolen from
    //  unimodem/v file inc\vmodem.h.
    //  TODO: replace this whole scheme by getting back an appropriate
    //  structure from the minidriver, so we don't root around in the
    //  registry and interpret the value of VoiceProfile. 
    //
    #define VOICEPROF_CLASS8ENABLED           0x00000001
    #define VOICEPROF_MODEM_OVERRIDES_HANDSET 0x00200000
    #define VOICEPROF_NO_MONITOR_DIGITS       0x00040000
    #define VOICEPROF_MONITORS_SILENCE        0x00010000
    #define VOICEPROF_NO_GENERATE_DIGITS      0x00020000
    #define VOICEPROF_HANDSET                 0x00000002
    #define VOICEPROF_SPEAKER                 0x00000004
    #define VOICEPROF_NO_SPEAKER_MIC_MUTE     0x00400000
    #define VOICEPROF_NT5_WAVE_COMPAT         0x02000000 

    // JosephJ 7/14/1997
    //      Note that on NT4, we explicitly require the
    //      VOICEPROF_NT5_WAVE_COMPAT bit to be set to recognize this as
    //      a class8 modem.

    if (
        (dwData & (VOICEPROF_CLASS8ENABLED|VOICEPROF_NT5_WAVE_COMPAT))
        != (VOICEPROF_CLASS8ENABLED|VOICEPROF_NT5_WAVE_COMPAT))
    {
        if (dwData & VOICEPROF_CLASS8ENABLED)
        {
	     FL_SET_RFR(0x1b053100, "Modem voice capabilities not supported on NT");
        }
        else
        {
	        FL_SET_RFR(0x9cb1a400, "Modem does not have voice capabilities");
        }
    }
    else
    {
        DWORD dwProp = fVOICEPROP_CLASS_8;

        // JosephJ 3/20/1998: The code commented out below, between
        //          [UNIMODEM/V] is from unimodem/v
        //          According to brian, this is because cirrus modems
        //          can't be dialed in voice for interactive calls, so
        //          they are dialed in data (even for interactive voice
        //          calls), and hence can't do lineGenerateDigits.
        //          On NT5, we don't disable this here, but do not allow
        //          linegeneratedigits for interactive voice calls if
        //          the  VOICEPROF_MODEM_OVERRIDES_HANDSET bit is set.
        //
        // [UNIMODEM/V]
        // // just to be on the safe side
        // if (dwData & VOICEPROF_MODEM_OVERRIDES_HANDSET)
        // {
        //    dwData  |= VOICEPROF_NO_GENERATE_DIGITS;
        //     //     dwData  &= ~VOICEPROF_SPEAKER;
        // }
        // end [UNIMODEM/V]
        //

        // JosephJ: This code is ok...

        #if 1
        if (dwData & VOICEPROF_MODEM_OVERRIDES_HANDSET)
        {
            dwProp |= fVOICEPROP_MODEM_OVERRIDES_HANDSET;
        }
        #endif

        if (!(dwData & VOICEPROF_NO_MONITOR_DIGITS))
        {
            dwProp |= fVOICEPROP_MONITOR_DTMF;
        }

        if (dwData & VOICEPROF_MONITORS_SILENCE)
        {
            dwProp |= fVOICEPROP_MONITORS_SILENCE;
        }

        if (!(dwData & VOICEPROF_NO_GENERATE_DIGITS))
        {
            dwProp |= fVOICEPROP_GENERATE_DTMF;
        }

        if (dwData & VOICEPROF_SPEAKER)
        {
            dwProp |= fVOICEPROP_SPEAKER;
        }

        if (dwData & VOICEPROF_HANDSET)
        {
            dwProp |= fVOICEPROP_HANDSET;
        }

        if (!(dwData & VOICEPROF_NO_SPEAKER_MIC_MUTE))
        {
            dwProp |= fVOICEPROP_MIKE_MUTE;
        }

        // Determine Duplex capability... (hack)
        {
            HKEY hkStartDuplex=NULL;
            dwRet = RegOpenKey(hkDrv, TEXT("StartDuplex"), &hkStartDuplex);
            if (ERROR_SUCCESS == dwRet)
            {
                RegCloseKey(hkStartDuplex);
                hkStartDuplex=NULL;
                dwProp |= fVOICEPROP_DUPLEX;
                SLPRINTF0(psl, "Duplex modem!");
            }
        }

        m_StaticInfo.Voice.dwProperties = dwProp;

        m_StaticInfo.dwDefaultMediaModes |= LINEMEDIAMODE_AUTOMATEDVOICE
                                         // 8/5/97 Removed | LINEMEDIAMODE_G3FAX
                                         // 2/15/98 Added back, in order to
                                         // support lineSetMediaMode
                                         // 2/20/98 Removed -- not sure if its
                                         // required.
                                         //
                                         // | LINEMEDIAMODE_G3FAX
                                         | LINEMEDIAMODE_UNKNOWN;

        // 2/26/1997 JosephJ
        //      Unimodem/V used helper function GetWaveDriverName to get the
        //      associated wave driver info.  This function searched for
        //      the devnode and soforth. On lineGetID(wavein/waveout),
        //      unimodem/v would actually call the wave apis, enumerating
        //      each wave device and doing a waveInGetDevCaps and comparing
        //      the device name with this device's associated device name.
        //      
        //      Note: Unimodem/V appended "handset" and "line" to the root
        //      device name to generate the device names for handset and line.
        //
        //      TODO: add wave instance ID to list of things
        //      we get from the mini-driver via API.
        //
        {
            HKEY hkWave = NULL;
            DWORD dwRet = RegOpenKey(hkDrv, cszWaveDriver, &hkWave);
            BOOL fFoundIt=FALSE;

            if (dwRet == ERROR_SUCCESS)
            {
                dwRegSize = sizeof(DWORD);
                dwRet =  RegQueryValueEx(
                                hkWave,
                                cszWaveInstance,
                                NULL,
                                &dwRegType, 
                                (BYTE*) &dwData,
                                &dwRegSize);
        
                if (dwRet==ERROR_SUCCESS && dwRegType == REG_DWORD)
                {
                    fFoundIt=TRUE;
                }
                RegCloseKey(hkWave);hkWave=NULL;
            }

            if (fFoundIt)
            {
                SLPRINTF1(psl, "WaveInstance=0x%lu", dwData);
                m_StaticInfo.Voice.dwWaveInstance = dwData;
            }
            else
            {
	            FL_SET_RFR(0x254efe00, "Couldn't get WaveInstance");
                m_StaticInfo.Voice.dwWaveInstance = (DWORD)-1;
            }
        }

    }

	FL_LOG_EXIT(psl, 0);
}


TSPRETURN
CTspDev::mfn_GetDataModemDevCfg(
    UMDEVCFG *pDevCfg,
    UINT uSize,
    UINT *puRequiredSize,
    BOOL  DialIn,
    CStackLog *psl
    )
{
	FL_DECLARE_FUNC(0x896ec204, "mfn_GetDataModemDevCfg")
    TSPRETURN tspRet = 0;
    DWORD cbDevCfg = m_Settings.pDialInCommCfg->dwSize + sizeof(UMDEVCFGHDR);


	FL_LOG_ENTRY(psl);

    if (puRequiredSize)
    {
        *puRequiredSize = cbDevCfg;
    }

    if (pDevCfg)
    {
    
        if (uSize >= cbDevCfg)
        {
            UMDEVCFGHDR CfgHdr;
    
            ZeroMemory(&CfgHdr, sizeof(CfgHdr));
            CfgHdr.dwSize = cbDevCfg;
            CfgHdr.dwVersion =  UMDEVCFG_VERSION;
            CfgHdr.fwOptions =  (WORD) m_Settings.dwOptions;
            CfgHdr.wWaitBong =  (WORD) m_Settings.dwWaitBong;
    
            SLPRINTF3(
                psl,
                " %s: Reporting dwOpt = 0x%04lx; dwBong = 0x%04lx",
                DialIn ? "DialIn" : "DialOut",
                m_Settings.dwOptions,
                m_Settings.dwWaitBong
                );
    

            // Fill with the default value
            //
    
            // Copy the header
            //
            pDevCfg->dfgHdr = CfgHdr; // structure copy
    
            // Copy the commconfig
            //
            CopyMemory(
                &(pDevCfg->commconfig),
                DialIn ? m_Settings.pDialInCommCfg : m_Settings.pDialOutCommCfg,
                DialIn ? m_Settings.pDialInCommCfg->dwSize : m_Settings.pDialOutCommCfg->dwSize
                );
        }
        else
        {
            tspRet = IDERR_INTERNAL_OBJECT_TOO_SMALL;
        }
    }

	FL_LOG_EXIT(psl, tspRet);

    return tspRet;
}

TSPRETURN
CTspDev::mfn_SetDataModemDevCfg(
    UMDEVCFG *pDevCfgNew,
    BOOL      DialIn,
    CStackLog *psl
    )
{
	FL_DECLARE_FUNC(0x864b149d, "SetDataModemConfig")
    TSPRETURN tspRet = IDERR_GENERIC_FAILURE;
	FL_LOG_ENTRY(psl);

    tspRet = CTspDev::mfn_update_devcfg_from_app(
                        pDevCfgNew,
                        pDevCfgNew->dfgHdr.dwSize,
                        DialIn,
                        psl
                        );

	FL_LOG_EXIT(psl, tspRet);

    return tspRet;
}

void
CTspDev::mfn_LineEventProc(
            HTAPICALL           htCall,
            DWORD               dwMsg,
            ULONG_PTR               dwParam1,
            ULONG_PTR               dwParam2,
            ULONG_PTR               dwParam3,
            CStackLog           *psl
            )
{
	FL_DECLARE_FUNC(0x672aa19c, "mfn_LineEventProc")
    LINEINFO *pLine = m_pLine;
    HTAPILINE htLine = pLine->htLine;
    
    SLPRINTF4(
        psl,
        "LINEEVENT(0x%lu,0x%lu,0x%lu,0x%lu)",
        dwMsg,
        dwParam1,
        dwParam2,
        dwParam3
        );

    if (m_pLLDev && m_pLLDev->IsLoggingEnabled())
    {
        char rgchName[128];

        rgchName[0] = 0;
        UINT cbBuf = DumpLineEventProc(
                        0, // dwInstance(unused)
                        0, // dwFlags
                        dwMsg,
                        (DWORD)dwParam1,
                        (DWORD)dwParam2,
                        (DWORD)dwParam3,
                        rgchName,
                        sizeof(rgchName)/sizeof(*rgchName),
                        NULL,
                        0
                        );
       if (*rgchName)
       {
            m_StaticInfo.pMD->LogStringA(
                                        m_pLLDev->hModemHandle,
                                        LOG_FLAG_PREFIX_TIMESTAMP,
                                        rgchName,
                                        NULL
                                        );
       }
    }

    if (m_StaticInfo.hExtBinding)
    {
        m_StaticInfo.pMD->ExtTspiLineEventProc(
                            m_StaticInfo.hExtBinding,
                            htLine,
                            htCall,
                            dwMsg,
                            dwParam1,
                            dwParam2,
                            dwParam3
                            );
    }
    else
    {
                pLine->lpfnEventProc(
                            htLine,
                            htCall,
                            dwMsg,
                            dwParam1,
                            dwParam2,
                            dwParam3
                            );
    }
}   


void
CTspDev::mfn_PhoneEventProc(
            DWORD               dwMsg,
            ULONG_PTR               dwParam1,
            ULONG_PTR               dwParam2,
            ULONG_PTR               dwParam3,
            CStackLog           *psl
            )
{
	FL_DECLARE_FUNC(0xc25a41c7, "mfn_PhoneEventProc")

    SLPRINTF4(
        psl,
        "PHONEEVENT(0x%lu,0x%lu,0x%lu,0x%lu)",
        dwMsg,
        dwParam1,
        dwParam2,
        dwParam3
        );

    if (!m_pPhone)
    {
        ASSERT(FALSE);
        goto end;
    }


    if (m_pLLDev && m_pLLDev->IsLoggingEnabled())
    {
        char rgchName[128];

        rgchName[0] = 0;
        UINT cbBuf = DumpPhoneEventProc(
                        0, // Instance (unused)
                        0, // dwFlags
                        dwMsg,
                        (DWORD)dwParam1,
                        (DWORD)dwParam2,
                        (DWORD)dwParam3,
                        rgchName,
                        sizeof(rgchName)/sizeof(*rgchName),
                        NULL,
                        0
                        );
       if (*rgchName)
       {
            m_StaticInfo.pMD->LogStringA(
                                        m_pLLDev->hModemHandle,
                                        LOG_FLAG_PREFIX_TIMESTAMP,
                                        rgchName,
                                        NULL
                                        );
       }
    }

    if (0 && m_StaticInfo.hExtBinding) // TODO: unimdmex can't deal with this!
    {
        m_StaticInfo.pMD->ExtTspiPhoneEventProc(
                            m_StaticInfo.hExtBinding,
                            m_pPhone->htPhone,
                            dwMsg,
                            dwParam1,
                            dwParam2,
                            dwParam3
                            );
    }
    else
    {
            m_pPhone->lpfnEventProc(
                        m_pPhone->htPhone,
                        dwMsg,
                        dwParam1,
                        dwParam2,
                        dwParam3
                        );
    }

end:    
    return;
}   

void
CTspDev::mfn_TSPICompletionProc(
            DRV_REQUESTID       dwRequestID,
            LONG                lResult,
            CStackLog           *psl
            )
{
	FL_DECLARE_FUNC(0x9dd08553, "CTspDev::mfn_TSPICompletionProc")
	FL_LOG_ENTRY(psl);

    if (m_pLLDev && m_pLLDev->IsLoggingEnabled())
    {
        char rgchName[128];

        rgchName[0] = 0;
        UINT cbBuf = DumpTSPICompletionProc(
                        0, // Instance (unused)
                        0, // dwFlags
                        dwRequestID,
                        lResult,
                        rgchName,
                        sizeof(rgchName)/sizeof(*rgchName),
                        NULL,
                        0
                        );


       if (*rgchName)
       {
            m_StaticInfo.pMD->LogStringA(
                                        m_pLLDev->hModemHandle,
                                        LOG_FLAG_PREFIX_TIMESTAMP,
                                        rgchName,
                                        NULL
                                        );
       }
    }

    if (m_StaticInfo.hExtBinding)
    {
        FL_SET_RFR(0x1b3f6d00, "Calling ExtTspiAsyncCompletion");
        m_StaticInfo.pMD->ExtTspiAsyncCompletion(
            m_StaticInfo.hExtBinding,
            dwRequestID,
            lResult
            );
    }
    else
    {
        FL_SET_RFR(0xd89afb00, "Calling pfnTapiCompletionProc");
        m_StaticInfo.pfnTAPICompletionProc(dwRequestID, lResult);
    }
	FL_LOG_EXIT(psl, 0);
}


void
CTspDev::NotifyDefaultConfigChanged(CStackLog *psl)
{
    TSPRETURN tspRet = 0;
	FL_DECLARE_FUNC(0x4b8c1643, "CTspDev::NotifyDefaultConfigChanged")

	FL_LOG_ENTRY(psl);
    m_sync.EnterCrit(FL_LOC);

    BYTE rgbCommCfgBuf[sizeof(m_Settings.rgbCommCfgBuf)];
    DWORD dwcbSize = sizeof(rgbCommCfgBuf);
    COMMCONFIG *pDefCommCfg = (COMMCONFIG *) rgbCommCfgBuf;

    {
        HKEY hKey=NULL;
        DWORD dwRet =  RegOpenKeyA(
                            HKEY_LOCAL_MACHINE,
                            m_StaticInfo.rgchDriverKey,
                            &hKey
                            );
        if (dwRet!=ERROR_SUCCESS)
        {
            FL_SET_RFR(0x6e834e00, "Couldn't open driverkey!");
            goto end;
        }
    
        //
        // If we support nvram init, check if we must re-do nvram init...
        //
        if (mfn_CanDoNVRamInit())
        {
            if (!get_volatile_key_value(hKey))
            {
               //
               // zero value indicates that we need to re-init
               // nvram. 
               //
               mfn_SetNeedToInitNVRam();
            }
        }
    
        dwRet =	UmRtlGetDefaultCommConfig(
                                hKey,
                                pDefCommCfg,
                                &dwcbSize
                                );
        RegCloseKey(hKey);
        hKey=NULL;
    
        if (dwRet != ERROR_SUCCESS)
        {
            FL_SET_RFR(0x5cce0a00, "UmRtlGetDefaultCommConfig fails");
            tspRet = FL_GEN_RETVAL(IDERR_REG_CORRUPT);
            goto end;
        }
    }

    //
    //  Only change a few things in the dialout config
    //
    {
        // selective copy....

        LPMODEMSETTINGS pMSFrom = (LPMODEMSETTINGS)
                                (pDefCommCfg->wcProviderData);
        LPMODEMSETTINGS pMSTo = (LPMODEMSETTINGS)
                                (m_Settings.pDialOutCommCfg->wcProviderData);


        // speaker volume & mode...
        pMSTo->dwSpeakerMode =  pMSFrom->dwSpeakerMode;
        pMSTo->dwSpeakerVolume =  pMSFrom->dwSpeakerVolume;

        // set Blind-dial bit...
        pMSTo->dwPreferredModemOptions &= ~MDM_BLIND_DIAL;
        pMSTo->dwPreferredModemOptions |= 
                        (pMSFrom->dwPreferredModemOptions &MDM_BLIND_DIAL);

        // max port speed (TBD)
    }

    //
    //  completely replace dialin config
    //
    CopyMemory(m_Settings.pDialInCommCfg, pDefCommCfg, dwcbSize);


    // re-init modem with new settings if the
    // line is open for monitoring and no call in progress
    if (m_pLine && m_pLine->IsMonitoring() && !m_pLine->pCall)
    {
        ASSERT(m_pLLDev);

        //
        // TODO: this is a bit hacky way of forcing a re-init .. need
        // to make things more straightforward...
        //
        m_pLLDev->fModemInited=FALSE;


        TSPRETURN  tspRet = mfn_StartRootTask(
                                &CTspDev::s_pfn_TH_LLDevNormalize,
                                &m_pLLDev->fLLDevTaskPending,
                                0,  // Param1
                                0,  // Param2
                                psl
                                );
        if (IDERR(tspRet)==IDERR_TASKPENDING)
        {
            // can't do this now, we've got to defer it!
            m_pLLDev->SetDeferredTaskBits(LLDEVINFO::fDEFERRED_NORMALIZE);
            tspRet = 0;
        }
    }
    
end:

    m_sync.LeaveCrit(FL_LOC);
	FL_LOG_EXIT(psl, tspRet);
}


typedef struct
{
    DWORD   dwClassToken;
    LPCTSTR ptszClass;

} CLASSREC;

const CLASSREC ClassRec[] =
{
    {DEVCLASS_TAPI_LINE,                TEXT("tapi/line")},
    {DEVCLASS_TAPI_PHONE,               TEXT("tapi/phone")},
    {DEVCLASS_COMM,                     TEXT("comm")},
    {DEVCLASS_COMM_DATAMODEM,           TEXT("comm/datamodem")},
    {DEVCLASS_COMM_DATAMODEM_PORTNAME,  TEXT("comm/datamodem/portname")},
    {DEVCLASS_COMM_EXTENDEDCAPS,        TEXT("comm/extendedcaps")},
    {DEVCLASS_WAVE_IN,                  TEXT("wave/in")},
    {DEVCLASS_WAVE_OUT,                 TEXT("wave/out")},
    {DEVCLASS_TAPI_LINE_DIAGNOSTICS,    TEXT("tapi/line/diagnostics")},
    {DEVCLASS_COMM_DATAMODEM_DIALIN,    TEXT("comm/datamodem/dialin")},
    {DEVCLASS_COMM_DATAMODEM_DIALOUT,   TEXT("comm/datamodem/dialout")},
    {DEVCLASS_UNKNOWN, NULL} // MUST be last (sentinel)
};

UINT
gen_device_classes(
    DWORD dwClasses,
    BOOL fMultiSz,
    LPTSTR lptsz,
    UINT cch
    );;

DWORD    parse_device_classes(LPCTSTR ptszClasses, BOOL fMultiSz);

UINT
gen_device_classes(
    DWORD dwClasses,
    BOOL fMultiSz,
    LPTSTR lptsz,
    UINT cch
    )
//
// If cch=0 is passed in, will not derefernce lptsz and will return
// the required length. Else it will try to copy over if there is enough
// space. If there is not enough space it will return 0.
//
// If it does copy over, it will tack on an extra '\0' at the end of the
// string iff fMultiSz is specified.
//
// Both cb and the return value is the size in TCHARS, including
// any terminating null char required.
//
// If dwClasses contains an unknown class, it will return 0 (fail).
//
{
    DWORD cchRequired=0;
    const CLASSREC *pcr = NULL;
    BOOL fError = FALSE;

    // 1st round: calculate required size...
    for (
            DWORD dw = 0x1, dwTmp = dwClasses;
            dwTmp && (fMultiSz || !pcr);
            (dwTmp&=~dw), (dw<<=1))
    {
        if (dw & dwTmp)
        {
            //
            // search through array...
            // The last token in the array is a sentinal, and 
            // therefore has dwClassToken == DEVCLASS_UNKNOWN
            //
            for (
                pcr = ClassRec;
                pcr->dwClassToken != DEVCLASS_UNKNOWN;
                pcr++
                )
            {
                if ((dw & dwTmp) == pcr->dwClassToken)
                {
                    cchRequired += lstrlen(pcr->ptszClass)+1;
                    break;
                }
            }

            if (pcr->dwClassToken == DEVCLASS_UNKNOWN)
            {
                // didn't find this token!
                //
                fError = TRUE;
                break;
            }
        }
    }

    if (!pcr || fError || (!fMultiSz && pcr->dwClassToken != dwClasses))
    {
        // Didn't find anything and/or invalid tokens...
        cchRequired = 0;
        goto end;
    }

    if (fMultiSz)
    {
        // Add an extra zero...
        cchRequired++;
    }
    
    if (!cch) goto end; // Just report cchRequired...

    if (cch<cchRequired)
    {
        // not enough space, go to end...
        cchRequired = 0;
        goto end;
    }

    // 2nd round -- actually construct the strings...

    if (!fMultiSz)
    {
        // For the single case, we already have a pointer to
        // the pch...
        CopyMemory(lptsz, pcr->ptszClass, cchRequired*sizeof(*pcr->ptszClass));
        goto end;
    }

    // fMultiSz case ...

    for (
            dw = 0x1, dwTmp = dwClasses;
            dwTmp;
            (dwTmp&=~dw), (dw<<=1))
    {
        if (dw & dwTmp)
        {
            //
            // search through array...
            // The last token in the array is a sentinal, and 
            // therefore has dwClassToken == DEVCLASS_UNKNOWN
            //
            for (
                pcr = ClassRec;
                pcr->dwClassToken != DEVCLASS_UNKNOWN;
                pcr++
                )
            {
                if ((dw & dwTmp) == pcr->dwClassToken)
                {
                    UINT cchCur = lstrlen(pcr->ptszClass)+1;
                    CopyMemory(lptsz, pcr->ptszClass, cchCur*sizeof(TCHAR));
                    lptsz += cchCur;
                    break;
                }
            }
        }
    }

    *lptsz = 0; // Add extra null at the end...

end:

    return cchRequired;
}

DWORD    parse_device_classes(LPCTSTR ptszClasses, BOOL fMultiSz)
{
    DWORD dwClasses = 0;

    if (!ptszClasses || !*ptszClasses) goto end;

    do
    {
        UINT cchCur = lstrlen(ptszClasses);

        //
        // search through array...
        // The last token in the array is a sentinal, and 
        // therefore has dwClassToken == DEVCLASS_UNKNOWN
        //
        for (
            const CLASSREC *pcr = ClassRec;
            pcr->dwClassToken != DEVCLASS_UNKNOWN;
            pcr++
            )
        {
            if (!lstrcmpi(ptszClasses, pcr->ptszClass))
            {
                dwClasses |= pcr->dwClassToken;
                break;
            }
        }

        if (pcr->dwClassToken == DEVCLASS_UNKNOWN)
        {
            // didn't find this token -- return 0 for error.
            dwClasses = 0;
            break;
        }


        ptszClasses += cchCur+1;

    } while (fMultiSz && *ptszClasses);

end:

    return dwClasses;

}

UINT
CTspDev::mfn_IsCallDiagnosticsEnabled(void)
{
    return m_Settings.dwDiagnosticSettings & fSTANDARD_CALL_DIAGNOSTICS;
}

void
CTspDev::ActivateLineDevice(
            DWORD dwLineID,
            CStackLog *psl
            )
{
    m_sync.EnterCrit(NULL);

    m_StaticInfo.dwTAPILineID = dwLineID;
    if (m_StaticInfo.pMD->ExtIsEnabled())
    {

        // 10/13/1997 JosephJ We DO NOT leave the crit section before
        // calling into the extension DLL. The semantics of UmExControl are
        // such that the extension DLL is to expect that the TSP has the
        // critical section held.

		m_StaticInfo.pMD->ExtControl(
                    m_StaticInfo.hExtBinding,
                    UMEXTCTRL_DEVICE_STATE,
                    UMEXTPARAM_ACTIVATE_LINE_DEVICE,
                    dwLineID,
                    0
                    );
    }

    m_sync.LeaveCrit(NULL);
}

void
CTspDev::ActivatePhoneDevice(
                DWORD dwPhoneID,
                CStackLog *psl
                )
{
    m_sync.EnterCrit(NULL);

    m_StaticInfo.dwTAPIPhoneID = dwPhoneID;
    if (m_StaticInfo.pMD->ExtIsEnabled())
    {

        // 10/13/1997 JosephJ We DO NOT leave the crit section before
        // calling into the extension DLL. The semantics of UmExControl are
        // such that the extension DLL is to expect that the TSP has the
        // critical section held.

		m_StaticInfo.pMD->ExtControl(
                    m_StaticInfo.hExtBinding,
                    UMEXTCTRL_DEVICE_STATE,
                    UMEXTPARAM_ACTIVATE_PHONE_DEVICE,
                    dwPhoneID,
                    0
                    );
    }

    m_sync.LeaveCrit(NULL);
}

void
CTspDev::mfn_ProcessResponse(
            ULONG_PTR dwRespCode,
            LPSTR lpszResp,
            CStackLog *psl
            )
{
	FL_DECLARE_FUNC(0x6b8ddbbb, "ProcessResponse")
	FL_LOG_ENTRY(psl);
    if (dwRespCode == RESPONSE_CONNECT && mfn_IsCallDiagnosticsEnabled())
    {
    #if 1
        mfn_AppendDiagnostic(
                DT_MDM_RESP_CONNECT,
                (BYTE*)lpszResp,
                lstrlenA(lpszResp)
                );
    #endif // 0
    }
	FL_LOG_EXIT(psl, 0);
}

void
CTspDev::mfn_HandleRootTaskCompletedAsync(BOOL *pfEndUnload, CStackLog *psl)
{
    TSPRETURN tspRet = 0;
    *pfEndUnload = FALSE;

    do
    {
        tspRet = IDERR_SAMESTATE;

        //
        // Note -- each time through, m_pLine, m_pPhone or m_pLLDev
        // may or may not be NULL.
        //

        if (m_pLine)
        {
            tspRet =  mfn_TryStartLineTask(psl);
        }

        if (m_pPhone && IDERR(tspRet) != IDERR_PENDING)
        {
            tspRet =  mfn_TryStartPhoneTask(psl);
        }

        if (m_pLLDev && IDERR(tspRet) != IDERR_PENDING)
        {
            tspRet =  mfn_TryStartLLDevTask(psl);
        }

    } while (IDERR(tspRet)!=IDERR_SAMESTATE && IDERR(tspRet)!=IDERR_PENDING);

    if (    m_fUnloadPending
        &&  IDERR(tspRet) != IDERR_PENDING
        &&  !m_pLine
        &&  !m_pPhone
        &&  !m_pLLDev)
    {
        *pfEndUnload = TRUE;
    }
}
#if 0

char *
ConstructNewPreDialCommands(
     HKEY hkDrv,
     DWORD dwNewProtoOpt,
     CStackLog *psl
     )
//
//  1. Extract Bearermode and protocol info
//  2. Depending on  whether bearermode is GSM or ISDN or ANALOG,
//     construct the appropriate key name (Protoco\GSM, Protocol\ISDN or
//     NULL).
//  3. If NON-NULL, call read-commands.
//  4. Do the in-place macro translation.
//
{
    char *szzCommands = NULL;
    UINT u = 0;
	FL_DECLARE_FUNC(0x5360574c, "ConstructNewPreDialCommands")
	FL_LOG_ENTRY(psl);
    UINT uBearerMode = MDM_GET_BEARERMODE(dwNewProtoOpt);
    UINT uProtocolInfo = MDM_GET_PROTOCOLINFO(dwNewProtoOpt);
    char *szKey  =  NULL;
    char *szProtoKey = NULL;
    UINT cCommands = 0;

    switch(uBearerMode)
    {
        case MDM_BEARERMODE_ANALOG:
            FL_SET_RFR(0x3a274e00, "Analog bearermode -- no pre-dial commmands.");
            break;

        case MDM_BEARERMODE_GSM:
            szKey = "PROTOCOL\\GSM";
            break;

        case MDM_BEARERMODE_ISDN:
            szKey = "PROTOCOL\\ISDN";
            break;

        default:
            FL_SET_RFR(0xff803300, "Invalid Bearermode in modem options!");
            break;
    }

    if (!szKey) goto end;

    //
    // Determine protocol key (TODO: this should all be consolidated under
    // the mini driver!).
    //
    switch(uProtocolInfo)
    {

    case MDM_PROTOCOL_AUTO_1CH:            szProtoKey = "AUTO_1CH";
        break;
    case MDM_PROTOCOL_AUTO_2CH:            szProtoKey = "AUTO_2CH";
        break;

    case MDM_PROTOCOL_HDLCPPP_56K:         szProtoKey = "HDLC_PPP_56K";
        break;
    case MDM_PROTOCOL_HDLCPPP_64K:         szProtoKey = "HDLC_PPP_64K";
        break;

    case MDM_PROTOCOL_HDLCPPP_112K:        szProtoKey = "HDLC_PPP_112K";
        break;
    case MDM_PROTOCOL_HDLCPPP_112K_PAP:    szProtoKey = "HDLC_PPP_112K_PAP";
        break;
    case MDM_PROTOCOL_HDLCPPP_112K_CHAP:   szProtoKey = "HDLC_PPP_112K_CHAP";
        break;
    case MDM_PROTOCOL_HDLCPPP_112K_MSCHAP: szProtoKey = "HDLC_PPP_112K_MSCHAP";
        break;

    case MDM_PROTOCOL_HDLCPPP_128K:        szProtoKey = "HDLC_PPP_128K";
        break;
    case MDM_PROTOCOL_HDLCPPP_128K_PAP:    szProtoKey = "HDLC_PPP_128K_PAP";
        break;
    case MDM_PROTOCOL_HDLCPPP_128K_CHAP:   szProtoKey = "HDLC_PPP_128K_CHAP";
        break;
    case MDM_PROTOCOL_HDLCPPP_128K_MSCHAP: szProtoKey = "HDLC_PPP_128K_MSCHAP";
        break;

    case MDM_PROTOCOL_V120_64K:            szProtoKey = "V120_64K";
        break;
    case MDM_PROTOCOL_V120_56K:            szProtoKey = "V120_56K";
        break;
    case MDM_PROTOCOL_V120_112K:           szProtoKey = "V120_112K";
        break;
    case MDM_PROTOCOL_V120_128K:           szProtoKey = "V120_128K";
        break;

    case MDM_PROTOCOL_X75_64K:             szProtoKey = "X75_64K";
        break;
    case MDM_PROTOCOL_X75_128K:            szProtoKey = "X75_128K";
        break;
    case MDM_PROTOCOL_X75_T_70:            szProtoKey = "X75_T_70";
        break;
    case MDM_PROTOCOL_X75_BTX:             szProtoKey = "X75_BTX";
        break;

    case MDM_PROTOCOL_V110_1DOT2K:         szProtoKey = "V110_1DOT2K";
        break;
    case MDM_PROTOCOL_V110_2DOT4K:         szProtoKey = "V110_2DOT4K";
        break;
    case MDM_PROTOCOL_V110_4DOT8K:         szProtoKey = "V110_4DOT8K";
        break;
    case MDM_PROTOCOL_V110_9DOT6K:         szProtoKey = "V110_9DOT6K";
        break;
    case MDM_PROTOCOL_V110_12DOT0K:        szProtoKey = "V110_12DOT0K";
        break;
    case MDM_PROTOCOL_V110_14DOT4K:        szProtoKey = "V110_14DOT4K";
        break;
    case MDM_PROTOCOL_V110_19DOT2K:        szProtoKey = "V110_19DOT2K";
        break;
    case MDM_PROTOCOL_V110_28DOT8K:        szProtoKey = "V110_28DOT8K";
        break;
    case MDM_PROTOCOL_V110_38DOT4K:        szProtoKey = "V110_38DOT4K";
        break;
    case MDM_PROTOCOL_V110_57DOT6K:        szProtoKey = "V110_57DOT6K";
        break;

    case MDM_PROTOCOL_PIAFS_INCOMING:      szProtKey  = "PIAFS_INCOMING";
        break;
    case MDM_PROTOCOL_PIAFS_OUTGOING:      szProtKey  = "PIAFS_OUTGOING";
        break;

    //
    // The following two are GSM specific, but we don't bother to assert that
    // here -- if we find the key under the chosen protocol, we use it.
    //
    case MDM_PROTOCOL_ANALOG_RLP:        szProtoKey = "ANALOG_RLP";
        break;
    case MDM_PROTOCOL_ANALOG_NRLP:       szProtoKey = "ANALOG_NRLP";
        break;
    case MDM_PROTOCOL_GPRS:              szProtoKey = "GPRS";
        break;

    default:
        FL_SET_RFR(0x6e42a700, "Invalid Protocol info in modem options!");
        goto end;

    }
    
    char rgchTmp[256];
    if ( (lstrlenA(szKey) + lstrlenA(szProtoKey) + sizeof "\\")
          > sizeof(rgchTmp))
    {
        FL_SET_RFR(0xddf38d00, "Internal error: tmp buffer too small.");
    }

    wsprintfA(rgchTmp, "%s\\%s", szKey, szProtoKey);

    cCommands = ReadCommandsA(
                                hkDrv,
                                rgchTmp,
                                &szzCommands
                                );

    if (!cCommands)
    {
        FL_SET_RFR(0x07a87200, "ReadCommandsA failed.");
        szzCommands=NULL;
        goto end;
    }

    expand_macros_in_place(szzCommands);
    
end:

	FL_LOG_EXIT(psl, 0);

    return szzCommands;
}

#endif

void
CTspDev::DumpState(
            CStackLog *psl
            )
{

	FL_DECLARE_FUNC(0x9a8df7e6, "CTspDev::DumpState")
	FL_LOG_ENTRY(psl);
    char szName[128];

    m_sync.EnterCrit(NULL);

    UINT cb = WideCharToMultiByte(
                      CP_ACP,
                      0,
                      m_StaticInfo.rgtchDeviceName,
                      -1,
                      szName,
                      sizeof(szName),
                      NULL,
                      NULL
                      );

    if (!cb)
    {
        CopyMemory(szName, "<unknown>", sizeof("<unknown>"));
    }

    SLPRINTF1(
         psl,
        "Name = %s",
         szName
         );
    
    mfn_dump_global_state(psl);
    mfn_dump_line_state(psl);
    mfn_dump_phone_state(psl);
    mfn_dump_lldev_state(psl);
    mfn_dump_task_state(psl);

    m_sync.LeaveCrit(NULL);

	FL_LOG_EXIT(psl, 0);
}

void
CTspDev::mfn_dump_global_state(
            CStackLog *psl
            )
{
	FL_DECLARE_FUNC(0x296438cf, "GLOBAL STATE:")

    SLPRINTF3(
        psl,
        "&m_Settings=0x%08lx; m_pLLDev=0x%08lx; m_pLine=0x%08lx",
        &m_Settings,
        m_pLLDev,
        m_pLine
        );
}


void
CTspDev::mfn_dump_line_state(
            CStackLog *psl
            )
{
	FL_DECLARE_FUNC(0xa038177f, "LINE STATE:")
	FL_LOG_ENTRY(psl);
    if (m_pLine)
    {
        if (m_pLine->pCall)
        {
            SLPRINTF1(psl, "m_pLine->pCall=0x%08lx", m_pLine->pCall);
        }
    }
	FL_LOG_EXIT(psl, 0);
}


void
CTspDev::mfn_dump_phone_state(
            CStackLog *psl
            )
{
	FL_DECLARE_FUNC(0x22f22a59, "PHONE STATE:")
	FL_LOG_ENTRY(psl);
	FL_LOG_EXIT(psl, 0);
}


void
CTspDev::mfn_dump_lldev_state(
            CStackLog *psl
            )
{
	FL_DECLARE_FUNC(0x68c9e1e1, "LLDEV STATE:")
	FL_LOG_ENTRY(psl);
	FL_LOG_EXIT(psl, 0);
}



TSPRETURN
CTspDev::mfn_update_devcfg_from_app(
                UMDEVCFG *pDevCfgNew,
                UINT cbDevCfgNew,
                BOOL      DialIn,
                CStackLog *psl
                )
{
	FL_DECLARE_FUNC(0xcf159c50, "xxxx")
    TSPRETURN tspRet = IDERR_GENERIC_FAILURE;
    COMMCONFIG *pCCNew = &(pDevCfgNew->commconfig);
    COMMCONFIG *pCCCur = DialIn ? m_Settings.pDialInCommCfg : m_Settings.pDialOutCommCfg;
    BOOL        ConfigChanged=TRUE;

	FL_LOG_ENTRY(psl);

    if (cbDevCfgNew < sizeof(UMDEVCFGHDR)
        || pDevCfgNew->dfgHdr.dwVersion !=  UMDEVCFG_VERSION
        || pDevCfgNew->dfgHdr.dwSize !=  cbDevCfgNew)
    {
       FL_SET_RFR(0x25423f00, "Invalid DevCfg specified");
       goto end;
    }

    // In NT4.0 the following were asserts. For NT5.0 we convert
    // them  to parameter validation tests, because the commconfig
    // is specified by the app and hence can be a bogus structure.
    //
    if (   pCCNew->wVersion != pCCCur->wVersion
        || pCCNew->dwProviderSubType != pCCCur->dwProviderSubType
        || pCCNew->dwProviderSize != pCCCur->dwProviderSize )
    {
        FL_SET_RFR(0x947cc100, "Invalid COMMCONFIG specified");
        goto end;
    }

    // Extract settings and waitbong.
    m_Settings.dwOptions    = pDevCfgNew->dfgHdr.fwOptions;
    m_Settings.dwWaitBong   = pDevCfgNew->dfgHdr.wWaitBong;

    SLPRINTF3(
        psl,
        " %s New dwOpt = 0x%04lx; dwBong = 0x%04lx",
        DialIn ? "Dialin" : "Dialout",
        m_Settings.dwOptions,
        m_Settings.dwWaitBong
        );

    // Copy over selected parts of commconfig (taken from
    // NT4.0 unimodem)
    {
        DWORD dwProvSize   =  pCCCur->dwProviderSize;
        BYTE *pbSrc  = ((LPBYTE)pCCNew)
                       + pCCNew->dwProviderOffset;
        BYTE *pbDest = ((LPBYTE) pCCCur)
                       + pCCCur->dwProviderOffset;
        {
            PMODEMSETTINGS  ms=(PMODEMSETTINGS)(((LPBYTE)pCCNew)
                       + pCCNew->dwProviderOffset);

            SLPRINTF1(
                psl,
                "options=%08lx",
                 ms->dwPreferredModemOptions);
        }

        if (((memcmp((PBYTE)&pCCCur->dcb,(PBYTE)&pCCNew->dcb,sizeof(pCCCur->dcb)) == 0) &&
            (memcmp(pbDest, pbSrc, dwProvSize) == 0))) {

            ConfigChanged=FALSE;
        }

        // TODO: although NT4.0 unimodem simply copied the dcb
        // and other info and so do we here, we should think about
        // doing a more careful and selective copy here...

        pCCCur->dcb  = pCCNew->dcb; // structure copy.

        if (!pCCCur->dcb.BaudRate)
        {
            // JosephJ Todo: clean out all this stuff post-beta.
            // DebugBreak();
        }

        CopyMemory(pbDest, pbSrc, dwProvSize);

    }


    if (DialIn) {
        //
        //  update default config for dialin change
        //
        HKEY hKey=NULL;
        DWORD dwRet =  RegOpenKeyA(
                            HKEY_LOCAL_MACHINE,
                            m_StaticInfo.rgchDriverKey,
                            &hKey
                            );

        if (dwRet == ERROR_SUCCESS) {

            UmRtlSetDefaultCommConfig(
                hKey,
                m_Settings.pDialInCommCfg,
                m_Settings.pDialInCommCfg->dwSize
                );

            RegCloseKey(hKey);
            hKey=NULL;
        }
    }


    //
    // re-init modem with new settings if the
    // line is open for monitoring and no call in progress
    //
    // DebugBreak();
    if (m_pLine && m_pLLDev && ConfigChanged && DialIn)
    {
        //
        // TODO: this is a bit hacky way of forcing a re-init .. need
        // to make things more straightforward...
        //
        m_pLLDev->fModemInited=FALSE;
    
        if (m_pLine->IsMonitoring() && !m_pLine->pCall)
        {
            TSPRETURN  tspRet = mfn_StartRootTask(
                                    &CTspDev::s_pfn_TH_LLDevNormalize,
                                    &m_pLLDev->fLLDevTaskPending,
                                    0,  // Param1
                                    0,  // Param2
                                    psl
                                    );
            if (IDERR(tspRet)==IDERR_TASKPENDING)
            {
                // can't do this now, we've got to defer it!
                m_pLLDev->SetDeferredTaskBits(LLDEVINFO::fDEFERRED_NORMALIZE);
                tspRet = 0;
            }
        }
    }

    //
    // Set the bit...
    // Onse set, this bit doesn't get cleared until provider shutdown!
    //
#ifdef OLD_COMMCONFIG
    m_Settings.fConfigUpdatedByApp = TRUE;
#endif
    FL_SET_RFR(0x94fadd00, "Success; set fConfigUpdatedByApp.");

    tspRet = 0;

end:

	FL_LOG_EXIT(psl, 0);

    return tspRet;
}

void
CTspDev::NotifyDeviceRemoved(
        CStackLog *psl
        )
//
// HW has been removed.
//
{
	m_sync.EnterCrit(0);

    if (m_pLLDev && m_StaticInfo.pMD) // pMD may be NULL if we're unloading!
    {
        // 
        // If there is no current modem command this does nothing.
        //
        m_StaticInfo.pMD->AbortCurrentModemCommand(
                                    m_pLLDev->hModemHandle,
                                    psl
                                );
        m_pLLDev->fDeviceRemoved = TRUE;
    }

	m_sync.LeaveCrit(0);
}


DWORD
get_volatile_key_value(HKEY hkParent)
{
    HKEY hkVolatile =  NULL;
    DWORD dw = 0;
    DWORD dwRet =  RegOpenKeyEx(
                    hkParent,
                    TEXT("VolatileSettings"),
                    0,
                    KEY_READ,
                    &hkVolatile
                    );

    if (dwRet==ERROR_SUCCESS)
    {
        DWORD cbSize = sizeof(dw);
        DWORD dwRegType = 0;

        dwRet =  RegQueryValueEx(
                        hkVolatile,
                        TEXT("NVInited"),
                        NULL,
                        &dwRegType, 
                        (BYTE*) &dw,
                        &cbSize
                        );

        if (    dwRet!=ERROR_SUCCESS
             || dwRegType != REG_DWORD)
        {
            dw=0;
        }

        RegCloseKey(hkVolatile);
        hkVolatile=NULL;
    }

    return dw;
}

// 
// Following is the template of UnimodemGetExtendedCaps ...
//
typedef DWORD (*PFNEXTCAPS)(
					IN        HKEY  hKey,
					IN OUT    LPDWORD pdwTotalSize,
					OUT    MODEM_CONFIG_HEADER *pFirstObj // OPTIONAL
					);

LONG
CTspDev::mfn_GetCOMM_EXTENDEDCAPS(
                 LPVARSTRING lpDeviceConfig,
                 CStackLog *psl
                 )
{
    // New in NT5.0
    // Process call/diagnostics configuration

    //
    // NOTE: we dynamically load modemui.dll here because we don't expect
    // this call to be called too often and no one else in the TSP uses any
	// functions in modemui.dll.
    //

	HKEY 	hKey=NULL;
	DWORD 	dwRet =  0;
	LONG	lRet = LINEERR_OPERATIONFAILED;
	DWORD	cbSize=0;
	TCHAR   szLib[MAX_PATH];
	HINSTANCE hInst = NULL;
	PFNEXTCAPS pfnExtCaps = NULL;

	GetSystemDirectory(szLib,sizeof(szLib) / sizeof(TCHAR));
	lstrcat(szLib,TEXT("\\modemui.dll"));
	hInst = LoadLibrary(szLib);


    lpDeviceConfig->dwStringSize    = 0;
    lpDeviceConfig->dwStringOffset  = 0;
    lpDeviceConfig->dwUsedSize      = sizeof(VARSTRING);
    lpDeviceConfig->dwStringFormat  = STRINGFORMAT_BINARY;
    lpDeviceConfig->dwNeededSize    = sizeof(VARSTRING);

	if (!hInst) goto end;

	pfnExtCaps = (PFNEXTCAPS)  GetProcAddress(hInst, "UnimodemGetExtendedCaps");

	if (!pfnExtCaps) goto end;

	dwRet =  RegOpenKeyA(
						HKEY_LOCAL_MACHINE,
						m_StaticInfo.rgchDriverKey,
						&hKey
						);
	if (dwRet!=ERROR_SUCCESS)
	{    
		hKey = NULL;
		goto end;
	}

	cbSize = 0;
	
	dwRet =  (pfnExtCaps)(
				hKey,
				&cbSize,
				NULL 
				);

	if (ERROR_SUCCESS==dwRet)
    {
        if (cbSize)
	    {
		    MODEM_PROTOCOL_CAPS *pMPC = 
							    (MODEM_PROTOCOL_CAPS *) (((LPBYTE)lpDeviceConfig)
							    + sizeof(VARSTRING));

		    lpDeviceConfig->dwNeededSize += cbSize;

		    if (lpDeviceConfig->dwTotalSize < lpDeviceConfig->dwNeededSize)
		    {
			    //
			    // Not enough space.
			    //

			    lRet = 0;
			    goto end;
		    }

		    dwRet =  (pfnExtCaps)(
					    hKey,
					    &cbSize,
					    (MODEM_CONFIG_HEADER*) pMPC
					    );
		    if (ERROR_SUCCESS==dwRet)
		    {
			    //
			    // Success ....
			    //
			    lRet = 0;
			    lpDeviceConfig->dwUsedSize = lpDeviceConfig->dwNeededSize;
			    lpDeviceConfig->dwStringSize =  cbSize;
			    lpDeviceConfig->dwStringOffset = sizeof(VARSTRING);
		    }
	    }
        else
        {
            lRet = LINEERR_INVALDEVICECLASS;
        }
    }
    
end:

	if (hKey)
	{
		RegCloseKey(hKey);
		hKey=NULL;
	}

	if (hInst)
	{
		FreeLibrary(hInst);
		hInst = NULL;
	}

    return lRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\tsp\cdevll.cpp ===
// 
// Copyright (c) 1996-1997 Microsoft Corporation.
//
//
// Component
//
//		Unimodem 5.0 TSP (Win32, user mode DLL)
//
// File
//
//		CDEVLL.CPP
//		Implements mini-driver-instance-related functionality of class CTspDev
//
// History
//
//		01/25/1996  JosephJ Created (moved stuff from cdev.cpp)
//
//
#include "tsppch.h"
#include <devioctl.h>
#include <objbase.h>
#include <ntddmodm.h>
#include <ntddser.h>
#include "tspcomm.h"
#include "cmini.h"
#include "cdev.h"
#include "diag.h"

FL_DECLARE_FILE(0xaca81db7, "Implements minidriver-related features of CTspDev")

#define COLOR_MD_ASYNC_NOTIF (FOREGROUND_BLUE | FOREGROUND_GREEN)

#if (0)
#define        THROW_PENDING_EXCEPTION() \
                    throw PENDING_EXCEPTION()
#else
#define        THROW_PENDING_EXCEPTION() 0
#endif

void
md_async_notification_proc (
    HANDLE    Context,
    DWORD     MessageType,
    ULONG_PTR  dwParam1,
    ULONG_PTR  dwParam2
    );

void
set_volatile_key(HKEY hkParent, DWORD dwValue);

TSPRETURN
CTspDev::mfn_LoadLLDev(CStackLog *psl)
{
	FL_DECLARE_FUNC(0x86d1a6e1, "CTspDev::mfn_LoadLLDev")
	FL_LOG_ENTRY(psl);
    TSPRETURN tspRet=IDERR_INVALID_ERR;

    if (m_pLLDev)
    {
        ASSERT(FALSE);
        goto end;
    }
    else
    {
        HANDLE hModemHandle = NULL;
        HANDLE hComm = NULL;
        HKEY hKey = NULL;

        // Note m_LLDev should be all zeros when it is in the unloaded state.
        // If it is not, it is an assertfail condition. We keep things clean
        // this way.
        //
        FL_ASSERT(
            psl,
            validate_DWORD_aligned_zero_buffer(
                    &(m_LLDev),
                    sizeof (m_LLDev)));
    
        LONG lRet = RegOpenKeyA(
                        HKEY_LOCAL_MACHINE,
                        m_StaticInfo.rgchDriverKey,
                        &hKey
                        );
        if (lRet)
        {
            FL_SET_RFR(0x71d1b200, "RegOpenKey failed");
            tspRet = FL_GEN_RETVAL(IDERR_REG_OPEN_FAILED);
            goto end;
        }
        
        hModemHandle = m_StaticInfo.pMD->OpenModem(
                                        m_StaticInfo.hExtBinding,
                                        hKey,
                                        NULL, // TODO: unused for now.
                                              // Replace completion port handle by
                                              // APC thread later.
                                        md_async_notification_proc,
                                        (HANDLE) this,
                                        m_StaticInfo.dwTAPILineID,
                                        &hComm,
                                        psl
                                        );
    
        if (!hModemHandle)
        {
            FL_SET_RFR(0x25033700, "pMD->OpenModem failed");
            RegCloseKey(hKey); hKey=0;
            tspRet = FL_GEN_RETVAL(IDERR_MD_OPEN_FAILED);
            goto end;
        }
    
        m_LLDev.dwRefCount      = 0;
        m_LLDev.hKeyModem       = hKey;
        m_LLDev.hModemHandle    = hModemHandle;
        m_LLDev.hComm           = hComm; // NOTE: you shouldn't close this
                               // handle. It is valid as long as hModemHandle
                               // is valid.
    
        {
            // TODO: Make this one of the properties passed back ...
            //
            DWORD dw=0;
            DWORD dwRet = UmRtlRegGetDWORD(
                                hKey,
                                TEXT("Logging"),
                                UMRTL_GETDWORD_FROMANY,
                                &dw
                                );
    
            m_LLDev.fLoggingEnabled = FALSE;
    
            if (!dwRet)
            {
                if (dw)
                {
                    m_LLDev.fLoggingEnabled = TRUE;
    
                    if (m_LLDev.IsLoggingEnabled())
                    {
                        m_StaticInfo.pMD->LogStringA(
                                                hModemHandle,
                                                LOG_FLAG_PREFIX_TIMESTAMP,
                                                "Opening Modem\r\n",
                                                NULL
                                                );
                    }
                }
            }
        }

        if(mfn_Handset())
        {
            //
            // Set default values for handset
            //
            m_LLDev.HandSet.dwVolume = 0xffff;
            m_LLDev.HandSet.dwGain   = 0xffff;
            m_LLDev.HandSet.dwMode   = PHONEHOOKSWITCHMODE_ONHOOK;
        }

        if (mfn_IsSpeaker())
        {
            //
            // Set default values for speakerphone
            //
            m_LLDev.SpkrPhone.dwVolume = 0xffff;
            m_LLDev.SpkrPhone.dwGain   = 0xffff;
            m_LLDev.SpkrPhone.dwMode   = PHONEHOOKSWITCHMODE_ONHOOK;
        }

        m_pLLDev = &m_LLDev;

        tspRet = 0;
    }

end:

	FL_LOG_EXIT(psl, tspRet);

	return tspRet;
}


void
CTspDev::mfn_UnloadLLDev(CStackLog *psl)
{
	FL_DECLARE_FUNC(0x3257150a, "CTspDev::mfn_UnloadLLDev")

    if (    !m_pLLDev
         || !m_pLLDev->CanReallyUnload())
    {
        ASSERT(FALSE);
        goto end;
    }

    ASSERT(m_LLDev.hKeyModem);
    ASSERT(m_LLDev.hModemHandle);


	FL_SET_RFR(0xd61eec00, "Actually Unloading Modem");

    // Note: m_LLDev.hComm is not explicitly closed -- it is implicitly
    // closed by calling CloseModem.

    //
    // No business to be either off-hook or for anyone to be using our resources
    // in this state!
    //
    ASSERT(!m_pLLDev->fdwExResourceUsage);
    ASSERT(m_pLLDev->IsDeviceRemoved() || !m_pLLDev->IsLineOffHook());

    {
        HANDLE   hModemHandle=m_LLDev.hModemHandle;
        HKEY     hKeyModem=m_LLDev.hKeyModem;

        ZeroMemory(&m_LLDev, sizeof(m_LLDev));
        m_pLLDev=NULL;

        //
        //  BRL  10-23-99
        //
        //  leave the critical section here so we don't deadlock if the minidriver has sent
        //  a notification that is blocked
        //
        //  brl 11/3/99
        //
        //  Don't leave critical section because it seems the device may well disappear
        //  Changed the callback code to poll the critical section checking to see if the lldev
        //  pointer is null. IT will return immediatly if it is.
        //
        //
//        m_sync.LeaveCrit(dwLUID_CurrentLoc);

        m_StaticInfo.pMD->CloseModem(hModemHandle,psl);

//        m_sync.EnterCrit(dwLUID_CurrentLoc);

        RegCloseKey(hKeyModem); // TODO -- shouldn't need to keep this
                                        // open whole time?
    }

end:

    return;
}


void
md_async_notification_proc (
    HANDLE    Context,
    DWORD     MessageType,
    ULONG_PTR  dwParam1,
    ULONG_PTR  dwParam2
    )
{
    CTspDev *pDev = (CTspDev *) Context;

    //
    // We get a whole slew of GOOD_RESPONSEs -- the
    // only one we care about is RESPONSE_CONNECT.
    //
    if (    MessageType==MODEM_GOOD_RESPONSE
        &&  dwParam1 != RESPONSE_CONNECT)
    {
        return;
    }

    pDev->MDAsyncNotificationHandler(
                MessageType,
                dwParam1,
                dwParam2
                );
}

void
CTspDev::MDAsyncNotificationHandler(
        DWORD     MessageType,
        ULONG_PTR  dwParam1,
        ULONG_PTR  dwParam2
        )
{

	FL_DECLARE_FUNC(0x2cfa0572, "CTspDev::MDAsyncNotificationHandler")
	FL_DECLARE_STACKLOG(sl, 1000);
    TSPRETURN tspRet = FL_GEN_RETVAL(IDERR_INVALID_ERR);
	FL_LOG_ENTRY(&sl);

#define POLL_IN_CALLBACK 1

#ifdef POLL_IN_CALLBACK

    while (!m_sync.TryEnterCrit(FL_LOC)) {
        //
        //  could not get the critical section,
        //
        if (m_pLLDev == NULL) {
            //
            //  the lldev pointer is null, must be trying to close,
            //  Just return so we don't deadlock
            //
            goto endNoLock;

        } else {
            //
            //  the lldev is active, sleep awhile.
            //
            Sleep(10);
        }
    }
    //
    //  we got the critical section, party on
    //
#else

    m_sync.EnterCrit(FL_LOC);

#endif

    sl.SetDeviceID(mfn_GetLineID());

    // The low-lever driver instance data had better be around, because
    // we got a callback!
    //
    if (!m_pLLDev)
    {
        FL_ASSERT(&sl,FALSE);
        goto end;
    }

    switch(MessageType)
    {
    default:
        break;

    case MODEM_ASYNC_COMPLETION:

        {
        
	    HTSPTASK htspTask = m_pLLDev->htspTaskPending;
        SLPRINTF1(&sl, "Async Complete. dwResult = 0x%08lx", dwParam1);
        FL_ASSERT(&sl, htspTask);
	    m_pLLDev->htspTaskPending = 0;

        //
        // Since dwParam2 can contain a pointer to a struct which will
        // only be valid in the context of this call, we need to save
        // away the data before we return from this call.
        // 4/16/97 JosephJ TODO: I don't like the arbitraryness of this
        //  should alter minidriver spec so that it is very clear when we need
        //  to copy stuff while in the context of the call itself -- something
        //  like, if MODEM_ASYNC_COMPLETION is nonzero, it points to the
        //  following structure:
        //   typedef struct
        //   {
        //       DWORD dwSize;
        //       DWORD dwType;           // one of a set of predefined types.
        //       BYTE [ANYSIZE_ARRAY];   // type-specific information.
        //   }
        //
        // Anyway for now we assume a UM_NEGOTIATED_OPTIONS struct if this
        // is a successful async return and there is a datamodem call pending.
        // This is quite arbitrary, but will do for now.
        //
        if (!dwParam1  // indicates success
            && dwParam2
            && m_pLine
            && m_pLine->pCall
            && !(m_pLine->pCall->IsAborting())
            && (m_pLine->pCall->dwCurMediaModes & LINEMEDIAMODE_DATAMODEM))
        {
            UM_NEGOTIATED_OPTIONS *pNegOpt =
                                             (UM_NEGOTIATED_OPTIONS *) dwParam2;
            m_pLine->pCall->dwNegotiatedRate = pNegOpt->DCERate;
            m_pLine->pCall->dwConnectionOptions = pNegOpt->ConnectionOptions;

            SLPRINTF1(
                 &sl,
                 "NegRate=%lu",
                 pNegOpt->DCERate,
                 );
        }

        CTspDev::AsyncCompleteTask(
                        htspTask,
                        m_StaticInfo.pMD->MapMDError((DWORD)dwParam1),
                        TRUE,
                        &sl
                        );
        }
        break;

    case MODEM_RING:
        CTspDev::mfn_ProcessRing(TRUE,&sl);
        break;

    case MODEM_DISCONNECT:
        mfn_ProcessDisconnect(&sl);
        break;

    case MODEM_POWER_RESUME:
        mfn_ProcessPowerResume(&sl);
        break;

    case MODEM_USER_REMOVE:
        //
        //  the user wants to remove the modem, set this flag so it can't be reopened
        //
        m_fUserRemovePending=TRUE;

        //
        //  fall throught to the hardware failure code which will send a line close
        //

    case MODEM_HARDWARE_FAILURE:
        mfn_ProcessHardwareFailure(&sl);
        break;
    
    //
    //  the some unrecogized data has been received from the modem
    //
    //  dwParam is a pointer to the SZ string.
    //
    case MODEM_UNRECOGIZED_DATA:
        break;
    
    
    //
    //  dtmf detected, dwParam1 id the ascii value of the detect tone 0-9,
    //  a-d,#,*
    //
    case MODEM_DTMF_START_DETECTED:
        mfn_ProcessDTMFNotification(dwParam1, FALSE, &sl);
        break;

    case MODEM_DTMF_STOP_DETECTED:
        mfn_ProcessDTMFNotification(dwParam1, TRUE, &sl);
        break;

    
    //
    //  handset state change
    //
    //    dwParam1 = 0 for on hook or 1 for offhook
    //
    case MODEM_HANDSET_CHANGE:
        mfn_ProcessHandsetChange(dwParam1==1, &sl);
        break;
    
    
    //
    //  reports the distinctive time times
    //
    //  dwParam1 id the ring time in ms
    //
    case MODEM_RING_ON_TIME:
        break;

    case MODEM_RING_OFF_TIME:
        break;
    
    
    //
    //  caller id info recieved
    //
    //    dwParam1 is pointer to SZ that represents the name/number
    //
    case MODEM_CALLER_ID_DATE:
    case MODEM_CALLER_ID_TIME :
    case MODEM_CALLER_ID_NUMBER:
    case MODEM_CALLER_ID_NAME:
    case MODEM_CALLER_ID_MESG:
        mfn_ProcessCallerID(MessageType, (char *) dwParam1, &sl);
        break;
    
    case MODEM_HANDSET_OFFHOOK:
        mfn_ProcessHandsetChange(TRUE, &sl);
        break;

    case MODEM_HANDSET_ONHOOK:
        mfn_ProcessHandsetChange(FALSE, &sl);
        break;
    
    case MODEM_DLE_RING :
        break;

    case MODEM_RINGBACK:
        break;
    
    case MODEM_2100HZ_ANSWER_TONE:
        break;

    case MODEM_BUSY:
        mfn_ProcessBusy(&sl);
        break;
    
    case MODEM_FAX_TONE:
        mfn_ProcessMediaTone(LINEMEDIAMODE_G3FAX, &sl);
        break;

    case MODEM_DIAL_TONE:
        mfn_ProcessDialTone(&sl);
        break;
    
    case MODEM_SILENCE:
    case MODEM_QUIET:
        mfn_ProcessSilence(&sl);
        break;
    
    case MODEM_1300HZ_CALLING_TONE:
        mfn_ProcessMediaTone(LINEMEDIAMODE_DATAMODEM, &sl);
        break;

    case MODEM_2225HZ_ANSWER_TONE:
        break;
    
    case MODEM_LOOP_CURRENT_INTERRRUPT:
    case MODEM_LOOP_CURRENT_REVERSAL:
        if (m_pLLDev->IsLineOffHook())
        {
            mfn_ProcessDisconnect(&sl);
        }
        break;
    
    case    MODEM_GOOD_RESPONSE:
        //  dwParam1 id a resonse type defined below
        //  dwparam2 is a PSZ to the response string.
        mfn_ProcessResponse(dwParam1, (LPSTR)dwParam2, &sl);
        break;
    }

end:

    m_sync.LeaveCrit(FL_LOC);

endNoLock:
	FL_LOG_EXIT(&sl, tspRet);

    sl.Dump(COLOR_MD_ASYNC_NOTIF);
}

// =========================================================================
//              AIPC (Device-based Async IPC) Functions
// =========================================================================


TSPRETURN
CTspDev::mfn_LoadAipc(CStackLog *psl)
{
    TSPRETURN tspRet = 0;
    AIPC2 *pAipc2 = NULL;
	FL_DECLARE_FUNC(0x4fd91c62, "mfn_LoadAipc")

    if (!m_pLLDev || m_pLLDev->pAipc2)
    {
        ASSERT(FALSE);
        tspRet = IDERR_CORRUPT_STATE;
        goto end;
    }
    pAipc2 = &(m_pLLDev->Aipc2);

    ZeroMemory(pAipc2, sizeof(*pAipc2));
    pAipc2->dwState = AIPC2::_IDLE;
    pAipc2->hEvent = CreateEvent(NULL,TRUE,FALSE,NULL);
                                         // TODO: error check above ..
    pAipc2->OverlappedEx.pDev = this;
    pAipc2->dwRefCount=0;
    m_pLLDev->pAipc2 = pAipc2;

end:

    return tspRet;
}


void
CTspDev::mfn_UnloadAipc(CStackLog *psl)
{
	FL_DECLARE_FUNC(0xf257d3ac, "mfn_UnloadAipc")
	    AIPC2 *pAipc2 = (m_pLLDev) ? m_pLLDev->pAipc2 : NULL;

    if (!pAipc2 || pAipc2->dwRefCount)
    {
        ASSERT(FALSE);
        goto end;
    }

    FL_ASSERT(psl, pAipc2->dwState == AIPC2::_IDLE);
    CloseHandle(pAipc2->hEvent);
    ZeroMemory(pAipc2, sizeof(*pAipc2));
    m_pLLDev->pAipc2=NULL;

end:

    return;
}


VOID WINAPI
apcAIPC2_ListenCompleted
(
    DWORD              dwErrorCode,
    DWORD              dwBytes,
    LPOVERLAPPED       lpOv
)
{
    
	FL_DECLARE_FUNC(0x049c517d,"apcAIPC2_ListenCompleted");
	FL_DECLARE_STACKLOG(sl, 1000);

    CTspDev *pDev = (((OVERLAPPED_EX*)lpOv)->pDev);

    sl.SetDeviceID(pDev->GetLineID());
    pDev->AIPC_ListenCompleted(dwErrorCode, dwBytes, &sl);

    #define COLOR_AIPC_CALL             (BACKGROUND_GREEN | BACKGROUND_RED)

    sl.Dump(COLOR_AIPC_CALL);
}


BOOL CTspDev::mfn_AIPC_Listen(CStackLog *psl)
{
    BOOL fRet = TRUE;

    if (m_pLLDev)
    {
        AIPC2 *pAipc2 = m_pLLDev->pAipc2;

        if (!pAipc2 || pAipc2->IsStarted() || pAipc2->fAborting)
        {
            fRet = FALSE;
        }
        else
        {
            OVERLAPPED *pov = &pAipc2->OverlappedEx.ov;

            ZeroMemory(pov, sizeof(*pov));
            fRet = UnimodemDeviceIoControlEx(
                                      m_pLLDev->hComm,
                                      IOCTL_MODEM_GET_MESSAGE,
                                      NULL,
                                      0,
                                      pAipc2->rcvBuffer,
                                      sizeof(pAipc2->rcvBuffer),
                                      pov,
                                      apcAIPC2_ListenCompleted);
        
            if (fRet)
            {
                pAipc2->dwState = AIPC2::_LISTENING;
            }
        }
    }
    else
    {
        fRet = FALSE;
        ASSERT(FALSE);
        goto end;
    }

end:

    return fRet;

}


void CTspDev::mfn_AIPC_AsyncReturn(BOOL fAsyncResult, CStackLog *psl)
//
// This fn is called to notify the remote client that the AIPC request
// has been completed.
//
{
    LLDEVINFO *pLLDev = m_pLLDev;
    FL_DECLARE_FUNC(0x1be5f472, "AIPC2::AsyncReturn")
    FL_LOG_ENTRY(psl);

    if (!pLLDev || !pLLDev->pAipc2)
    {
        ASSERT(FALSE);
    }
    else
    {

        AIPC2 *pAipc2 = pLLDev->pAipc2;
        if (pAipc2->dwState!=AIPC2::_SERVICING_CALL)
        {
            ASSERT(FALSE);
        }
        else
        {

            OVERLAPPED *pov = &pAipc2->OverlappedEx.ov;
            LPAIPC_PARAMS pAipcParams = (LPAIPC_PARAMS)(pAipc2->sndBuffer);
            LPCOMP_WAVE_PARAMS pCWP = (LPCOMP_WAVE_PARAMS)&pAipcParams->Params;
            BOOL fRet = FALSE;

            LPAIPC_PARAMS ReceiveParams = (LPAIPC_PARAMS)(pAipc2->rcvBuffer);

            pAipcParams->dwFunctionID = AIPC_COMPLETE_WAVEACTION;
            pCWP->dwWaveAction =  pAipc2->dwPendingParam;
            pCWP->bResult = fAsyncResult;
        
            ZeroMemory(pov, sizeof(*pov));
            ResetEvent(pAipc2->hEvent);
            pov->hEvent = pAipc2->hEvent;

            //
            //  copy over the message sequence numbers
            //
            pAipcParams->ModemMessage.SessionId = ReceiveParams->ModemMessage.SessionId;
            pAipcParams->ModemMessage.RequestId = ReceiveParams->ModemMessage.RequestId;

            //
            // We do a synchronous submission here. No sense in complicating
            // matters!
            //
            fRet = DeviceIoControl(
                             pLLDev->hComm,
                             IOCTL_MODEM_SEND_MESSAGE,
                             pAipc2->sndBuffer,
                             sizeof(pAipc2->sndBuffer),
                             NULL,
                             0L,
                             NULL,
                             pov
                             );
    
            if (!fRet &&  GetLastError() == ERROR_IO_PENDING)
            {
                #if 1

                // TODO: wait for completion. For now, we don't wait.

                DWORD dw = WaitForSingleObject(
                                pAipc2->hEvent,
                                60*1000
                            );
            
                if (dw==WAIT_TIMEOUT)
                {
                    FL_SET_RFR(0xceb3eb00, "Wait timed out");
                    CancelIo(pLLDev->hComm);
                }
                #else
                FL_SET_RFR(0x30c1dc00, "WARNING: not waiting for completion of pending IOCTL_MODEM_SEND_MESSAGE");
                #endif

            }
            else if (!fRet)
            {
                FL_SET_RFR(0xf54b5300, "DeviceIoControl failed!");
            }
    
            pAipc2->dwPendingParam=0;
            pAipc2->dwState = AIPC2::_IDLE;

        }

        if (pAipc2->fAborting) {

            if (pAipc2->hPendingTask) {

                DWORD   BytesTransfered;
                DWORD   Action=0;

                //
                //  tell the modem driver we are not accepting request now
                //
                SyncDeviceIoControl(
                    m_pLLDev->hComm,
                    IOCTL_SET_SERVER_STATE,
                    &Action,
                    sizeof(Action),
                    NULL,
                    0,
                    &BytesTransfered
                    );


                HTSPTASK htspTask = pAipc2->hPendingTask;
                pAipc2->hPendingTask = 0;

                CTspDev::AsyncCompleteTask(
                                htspTask,
                                0,
                                TRUE,
//                                FALSE, // We don't queue, because we're
                                       // already in an APC thread.
                                psl
                                );
            }
        } else {
            //
            // Start listening for the next APIC command...
            //
            if (!mfn_AIPC_Listen(psl))
            {
                FL_SET_RFR(0xb0284f00,  "WARNING: mfn_AIPC_Listen failed!");
            }
        }



    }

    FL_LOG_EXIT(psl, 0);
    return;
}


void
CTspDev::AIPC_ListenCompleted(
            DWORD dwErrorCode,
            DWORD dwBytes,
            CStackLog *psl
                )
{
    FL_DECLARE_FUNC(0x6f1cc3ac, "CTspDev::AIPC_ListenCompleted")
    FL_LOG_ENTRY(psl);
    m_sync.EnterCrit(FL_LOC);

    SLPRINTF1(psl, "AIPC_ListenCompleted: error code = %lu", dwErrorCode);

    // TODO: deal with error code.

    // TODO: even if we are not going to process a request,  we
    // must neverthless complete it!

    if (m_pLLDev && m_pLLDev->pAipc2) {

        AIPC2 *pAipc2 = m_pLLDev->pAipc2;

        if (pAipc2->dwState!=AIPC2::_LISTENING) {

            FL_ASSERT(psl, FALSE);
            FL_SET_RFR(0x1a032e00, "request ignored because state != LISTENING");

        } else {
            //
            //  good state
            //
            if (pAipc2->fAborting) {
                //
                //  shutting down aipc server
                //
                FL_SET_RFR(0xb50dfd00, "Failing AIPC request because fAborting");

                if (!dwErrorCode) {
                    //
                    //  a valid request made in before we canceled, just fail it
                    //
                    pAipc2->dwState = AIPC2::_SERVICING_CALL;
                    mfn_AIPC_AsyncReturn(FALSE, psl);
                    ASSERT(pAipc2->dwState==AIPC2::_IDLE);

                } else {
                    //
                    //  the get request was canceled when stopped.
                    //
                    // We ignore this.
                    pAipc2->dwState = AIPC2::_IDLE;
                }

                //  If there is a task that is waiting to be completed
                //  after processing this request, we complete it here.
                //
                if (pAipc2->hPendingTask) {

                    HTSPTASK htspTask = pAipc2->hPendingTask;
                    pAipc2->hPendingTask = 0;

                    CTspDev::AsyncCompleteTask(
                                    htspTask,
                                    0,
                                    FALSE, // We don't queue, because we're
                                           // already in an APC thread.
                                    psl
                                    );
                }

            } else {
                //
                //  not aborting, normal request
                //
                if (!dwErrorCode) {
                    //
                    //  completed with success
                    //
                    LLDEVINFO  *pLLDev = m_pLLDev;
                    LPAIPC_PARAMS  pAipcParams = (LPAIPC_PARAMS)(pAipc2->rcvBuffer);
                    DWORD dwParam=0;
                    LPREQ_WAVE_PARAMS pRWP = (LPREQ_WAVE_PARAMS)
                                                        &pAipcParams->Params;
                    dwParam = pRWP->dwWaveAction;

                    if (((dwParam == WAVE_ACTION_STOP_STREAMING) || (dwParam == WAVE_ACTION_ABORT_STREAMING))
                         &&
                         ((pLLDev == NULL) ?  TRUE :  !pLLDev->IsStreamingVoice())) {

                        //
                        //  we got a stop streaming when we are not currently streaming,
                        //  fail it now to avoid pending a call that will failed
                        //
                        pAipc2->dwState = AIPC2::_SERVICING_CALL;
                        mfn_AIPC_AsyncReturn(FALSE, psl);
                        ASSERT(pAipc2->dwState==AIPC2::_IDLE);

                    } else {
                        //
                        //  state seems ok, try to start the task
                        //
                        pAipc2->dwState = AIPC2::_SERVICING_CALL;
                        pAipc2->dwPendingParam = dwParam;
                        SLPRINTF1(psl, "Servicing WAVE ACTION. dwParam=%lu", dwParam);

                        TSPRETURN   tspRet = mfn_StartRootTask(
                                            &CTspDev::s_pfn_TH_LLDevHybridWaveAction,
                                            &m_pLLDev->fLLDevTaskPending,
                                            dwParam,
                                             0,
                                            psl
                                            );

                        if (IDERR(tspRet) == IDERR_TASKPENDING) {
                            //
                            // Another task is active, so we defer it...
                            //
                            //
                            // We can't already have a deferred hybrid wave action,
                            // because we don't listen again until the
                            // current wave action has been serviced...
                            //
                            ASSERT(!m_pLLDev->AreDeferredTaskBitsSet(
                                        LLDEVINFO::fDEFERRED_HYBRIDWAVEACTION
                                        ));

                            m_pLLDev->dwDeferredHybridWaveAction = dwParam;
                            m_pLLDev->SetDeferredTaskBits(
                                        LLDEVINFO::fDEFERRED_HYBRIDWAVEACTION
                                        );
                            tspRet = IDERR_PENDING;
                        }
                    }

                } else {
                    //
                    //  request complete with failure
                    //
                    // We could start listening again, or we could simply silently
                    // switch to Idle state.
	                FL_SET_RFR(0x62fdf000, "Listen completed with error, going _IDLE");
                    pAipc2->dwState = AIPC2::_IDLE;
                }
            }
        }
    } else {
        //
        //  bad state
        //
        ASSERT(FALSE);
    }

    m_sync.LeaveCrit(FL_LOC);
    FL_LOG_EXIT(psl, 0);
}

typedef void (*pfnAIPC_CALLBACK)(
                       void *context,
                       DWORD dwFuncID,
                       DWORD dwParam
                       );

TSPRETURN
CTspDev::mfn_TH_LLDevStartAIPCAction(
					HTSPTASK htspTask,
                    TASKCONTEXT *pContext,
					DWORD dwMsg,
					ULONG_PTR dwParam1,
					ULONG_PTR dwParam2,
					CStackLog *psl
					)
{
	FL_DECLARE_FUNC(0x0aba95da, "CTspDev::mfn_TH_LLDevStartAIPCAction")
	FL_LOG_ENTRY(psl);
	TSPRETURN tspRet=FL_GEN_RETVAL(IDERR_INVALID_ERR);
	AIPC2 *pAipc2 = m_pLLDev ? m_pLLDev->pAipc2 : NULL;

    //
    // We should not be called if pAipc2 doesn't exist!
    //
    if (!pAipc2)
    {
        tspRet = IDERR_CORRUPT_STATE;
        FL_ASSERT(psl, FALSE);
        goto end;
    }

    enum
    {
        STARTAIPC_SWITCH_TO_APC
    };

    switch(dwMsg)
    {
    case MSG_START:
        goto start;

	case MSG_SUBTASK_COMPLETE:
        ASSERT(dwParam1==STARTAIPC_SWITCH_TO_APC);
        tspRet = (TSPRETURN) dwParam2;
        goto switched_to_apc_thread;
        break;

	case MSG_TASK_COMPLETE: // obsolete
        tspRet = (TSPRETURN) dwParam2;
        goto end;

    case MSG_DUMPSTATE:
        tspRet = 0;
        goto end;

    default:
        FL_SET_RFR(0x27934100, "Unknown Msg");
        tspRet=FL_GEN_RETVAL(IDERR_CORRUPT_STATE);
        goto end;

    }

    ASSERT(FALSE);

start:

    if (m_pLLDev->IsDeviceRemoved())
    {
        tspRet = IDERR_DEVICE_NOTINSTALLED;
        FL_SET_RFR(0x636deb00, "Device not present.");
        goto end;
    }

    {
        DWORD   BytesTransfered;
        DWORD   Action=1;


        SyncDeviceIoControl(
            m_pLLDev->hComm,
            IOCTL_SET_SERVER_STATE,
            &Action,
            sizeof(Action),
            NULL,
            0,
            &BytesTransfered
            );
    }

    //
    // AIPC server needs to start listening....
    //
    // We start off by  executing
    // NOOP task to switch to the APC thread's context.
    //
    tspRet = mfn_StartSubTask (
                        htspTask,
                        &CTspDev::s_pfn_TH_UtilNOOP,
                        STARTAIPC_SWITCH_TO_APC,
                        0x1234,
                        0x2345,
                        psl
                        );

    FL_ASSERT(psl, IDERR(tspRet)==IDERR_PENDING);
    goto end;

switched_to_apc_thread:

    {
        //
        // WARNING: The code in this block is expected to run in an APC thread.
        //

        if (mfn_AIPC_Listen(psl))
        {
            tspRet = 0;
        }
        else
        {
            FL_SET_RFR(0xe74ef400, "mfn_AIPC_Listen fails!");
            tspRet=FL_GEN_RETVAL(IDERR_GENERIC_FAILURE);
        }

    }

end:

	FL_LOG_EXIT(psl, tspRet);
	return tspRet;

}



TSPRETURN
CTspDev::mfn_TH_LLDevStopAIPCAction(
					HTSPTASK htspTask,
                    TASKCONTEXT *pContext,
					DWORD dwMsg,
					ULONG_PTR dwParam1,
					ULONG_PTR dwParam2,
					CStackLog *psl
					)
{
	FL_DECLARE_FUNC(0x4e315394, "CTspDev::mfn_TH_LLDevStopAIPCAction")
	FL_LOG_ENTRY(psl);
	TSPRETURN tspRet=FL_GEN_RETVAL(IDERR_INVALID_ERR);
    AIPC2 *pAipc2 = (m_pLLDev) ? m_pLLDev->pAipc2 : NULL;

    //
    // We should not be called if pAipc2 doesn't exist!
    //
    if (!pAipc2)
    {
        tspRet = IDERR_CORRUPT_STATE;
        FL_ASSERT(psl, FALSE);
        goto end;
    }

    enum
    {
        STOPAIPC_SWITCH_TO_APC
    };

    switch(dwMsg)
    {
    case MSG_START:
        goto start;

	case MSG_SUBTASK_COMPLETE:
        tspRet = dwParam2;
        ASSERT(dwParam1==STOPAIPC_SWITCH_TO_APC);
        goto switched_to_apc_thread;
        break;

	case MSG_TASK_COMPLETE:
        tspRet = (TSPRETURN) dwParam2;
        goto cancelio_completed;

    case MSG_DUMPSTATE:
        tspRet = 0;
        goto end;

    default:
        FL_SET_RFR(0xb0dd7600, "Unknown Msg");
        tspRet=FL_GEN_RETVAL(IDERR_CORRUPT_STATE);
        goto end;

    }

    ASSERT(FALSE);

start:

    //
    // We really do need to stop listening because the refcount==l
    // We must be in LISTENING state...
    //
    ASSERT(pAipc2->dwState == AIPC2::_LISTENING);

    //
    // First, we set fAborting to prevent
    // any further service requests from being handled (they will be
    // synchronously failed in the apc completion routine of the pending
    // listen itself...)
    //

    pAipc2->fAborting = TRUE;

#if 0
    //
    // Next, we execute the NOOP task to switch to the APC thread's context.
    //
    tspRet = mfn_StartSubTask (
                        htspTask,
                        &CTspDev::s_pfn_TH_UtilNOOP,
                        STOPAIPC_SWITCH_TO_APC,
                        0x1234,
                        0x2345,
                        psl
                        );

    FL_ASSERT(psl, IDERR(tspRet)==IDERR_PENDING);
    if (IDERR(tspRet)==IDERR_PENDING) goto end;
#endif
switched_to_apc_thread:

    // we keep going even on failure...
    {
        //
        // WARNING: The code in this block is expected to run in an APC thread.
        //

        ASSERT(pAipc2->fAborting);


        if(pAipc2->dwState == AIPC2::_IDLE) {

            tspRet = 0;

        } else {

            if (pAipc2->dwState == AIPC2::_LISTENING) {


                DWORD   BytesTransfered;
                DWORD   Action=0;

                // This is the task which will be completed when
                // the current AIPC call is complete/aborted.
                //
                pAipc2->hPendingTask = htspTask;

                // We cancel the listen. This will
                // cause the completion to be queued. When the callback
                // corresponding to the completion is executed it
                // will call AIPC_ListenCompleted, which will
                // check the aborting state and ignore the call and
                // complete this task.
                //

                SyncDeviceIoControl(
                    m_pLLDev->hComm,
                    IOCTL_SET_SERVER_STATE,
                    &Action,
                    sizeof(Action),
                    NULL,
                    0,
                    &BytesTransfered
                    );


                SyncDeviceIoControl(
                    m_pLLDev->hComm,
                    IOCTL_CANCEL_GET_SEND_MESSAGE,
                    NULL,
                    0,
                    NULL,
                    0,
                    &BytesTransfered
                    );

                tspRet = IDERR_PENDING;
                THROW_PENDING_EXCEPTION();

            }  else {
                //
                // On stopping the server we expect to be either in the
                // LISTENING or IDLE states...
                //
                ASSERT(FALSE);

            }
        }
    }

    if (IDERR(tspRet)==IDERR_PENDING) goto end;

cancelio_completed:
end:

	FL_LOG_EXIT(psl, tspRet);
	return tspRet;
}


TSPRETURN
CTspDev::mfn_TH_LLDevUmInitModem(
					HTSPTASK htspTask,
                    TASKCONTEXT *pContext,
					DWORD dwMsg,
					ULONG_PTR dwParam1,
					ULONG_PTR dwParam2,
					CStackLog *psl
					)
{
	FL_DECLARE_FUNC(0x3f2e666c, "CTspDev::mfn_TH_LLDevUmInitModem")
	FL_LOG_ENTRY(psl);
	TSPRETURN tspRet=FL_GEN_RETVAL(IDERR_PENDING);

    switch(dwMsg)
    {
    case MSG_START:
        goto start;

	case MSG_TASK_COMPLETE:
        tspRet = (TSPRETURN) dwParam2;
        goto init_complete;

    case MSG_DUMPSTATE:
        tspRet = 0;
        goto end;

    default:
        FL_SET_RFR(0x0e14a200, "Unknown Msg");
        tspRet=FL_GEN_RETVAL(IDERR_CORRUPT_STATE);
        goto end;

    }

    ASSERT(FALSE);

start:

    if (m_pLLDev->IsDeviceRemoved())
    {
        tspRet = IDERR_DEVICE_NOTINSTALLED;
        FL_SET_RFR(0x0ea16700, "Device not present.");
        goto end;
    }

    { 
        // Initialize the modem ...

        // 1/28/1998 JosephJ
        // It is important to set this here, because the modem will
        // be inited using the current snapshot of pCommCfg. If during
        // async processing of the init command the pComCfg is updated
        // (via lineSetDevConfig, lineConfigDialog, or change in the CPL,
        // fModemInited will be set to FALSE so that the modem will
        // be re-inited again. If we were to set fModemInited to TRUE
        // following flag AFTER the async completion of the call below, not
        // BEFORE calling InitModem as we are doing, we would overwrite
        // the FALSE value and the modem would not then be inited a 2nd time,
        // and hence would not pick up the changed config.
        //
        //
        // This is not a hypohetical situation -- one case when i've
        // seen this happen is when the app opens the line as owner and
        // the immediately calls lineSetDevConfig to change the commconfig.
        // Tapisrv calls TSPI_lineSetDefaultMediaDetection immediately
        // after lineOpen, at which time we start to initialize the modem.
        // While this is happening, tapisrv calls us with
        // TSPI_lineSetDevConfig, with the new commconfig -- the
        // code for TSPI_lineSetDevConfig (in cdev.cpp) picks up the
        // new commconfig and then sets llDev->fInited to FALSE.
        //
        m_pLLDev->fModemInited=TRUE;
        m_pLLDev->LineState = LLDEVINFO::LS_ONHOOK_NOTMONITORING;
    
        DWORD dwRet =  m_StaticInfo.pMD->InitModem(
                                m_pLLDev->hModemHandle,
                                NULL,
                                (dwParam1 == TRUE) ? m_Settings.pDialOutCommCfg : m_Settings.pDialInCommCfg,
                                psl
                                );
    
        tspRet =  m_StaticInfo.pMD->MapMDError(dwRet);
    }


init_complete:

    if (IDERR(tspRet)==IDERR_PENDING)
    {
	    FL_SET_RFR(0x56e84300, "UmInitModem returns PENDING");

        m_pLLDev->htspTaskPending = htspTask;
        THROW_PENDING_EXCEPTION();
    }
    else if (tspRet)
    {
        m_pLLDev->fModemInited=FALSE;

        FL_SET_RFR(0x8ae41e00, "UmdmInitModem failed");
    }

end:

	FL_LOG_EXIT(psl, tspRet);
	return tspRet;

}


TSPRETURN
CTspDev::mfn_TH_LLDevUmDialModem(
					HTSPTASK htspTask,
                    TASKCONTEXT *pContext,
					DWORD dwMsg,
					ULONG_PTR dwParam1,
					ULONG_PTR dwParam2,
					CStackLog *psl
					)
{
	FL_DECLARE_FUNC(0xef87876a, "CTspDev::mfn_TH_LLDevUmDialModem")
	FL_LOG_ENTRY(psl);
	TSPRETURN tspRet=IDERR_INVALID_ERR;

    switch(dwMsg)
    {
	case MSG_TASK_COMPLETE:
        tspRet = (TSPRETURN) dwParam2;
        goto dial_complete;

    case MSG_START:
        goto start;

    case MSG_DUMPSTATE:
        tspRet = 0;
        goto end;

    default:
        FL_SET_RFR(0xadd29500, "Unknown Msg");
        tspRet=FL_GEN_RETVAL(IDERR_CORRUPT_STATE);
        goto end;

    }

    ASSERT(FALSE);

start:

    if (m_pLLDev->IsDeviceRemoved())
    {
        tspRet = IDERR_DEVICE_NOTINSTALLED;
        FL_SET_RFR(0x68599800, "Device not present.");
        goto end;
    }

    // Dial ...
    {
        DWORD  dwFlags = (DWORD)dwParam1;
        LPCSTR szAddress = (LPCSTR) dwParam2;
        m_pLLDev->fModemInited=FALSE;

        DWORD dwRet = m_StaticInfo.pMD->DialModem(
                                m_pLLDev->hModemHandle,
                                NULL,
                                (char *) szAddress, // change to const char *
                                dwFlags,
                                psl
                                );
        if (dwFlags & DIAL_FLAG_VOICE_INITIALIZE)
        {
            m_pLLDev->LineMediaMode = LLDEVINFO::LMM_VOICE;
        }

        tspRet =  m_StaticInfo.pMD->MapMDError(dwRet);
    }


dial_complete:

    //
    // Remember that Param1 and Param2 are dwFlags and szAddress ONLY
    // on MSG_START!
    //

    if (IDERR(tspRet) == IDERR_PENDING)
    {
        FL_SET_RFR(0x09584c00,  "UmDialModem returns PENDING.");
        m_pLLDev->LineState =  LLDEVINFO::LS_OFFHOOK_DIALING;
        m_pLLDev->htspTaskPending = htspTask;
        THROW_PENDING_EXCEPTION();
    }
    else if (tspRet)
    {
        m_pLLDev->LineState =  LLDEVINFO::LS_OFFHOOK_UNKNOWN;
        FL_SET_RFR(0xe9a60b00, "UmdmDialModem failed.");
    }
    else
    {
        // success...

        m_pLLDev->LineState =  LLDEVINFO::LS_OFFHOOK_CONNECTED;
        FL_SET_RFR(0x56833500, "UmdmDialModem succeeded.");
    }

end:


	FL_LOG_EXIT(psl, tspRet);
	return tspRet;

}


TSPRETURN
CTspDev::mfn_TH_LLDevUmAnswerModem(
					HTSPTASK htspTask,
                    TASKCONTEXT *pContext,
					DWORD dwMsg,
					ULONG_PTR dwParam1,
					ULONG_PTR dwParam2,
					CStackLog *psl
					)
{
	FL_DECLARE_FUNC(0x4c361125, "CTspDev::mfn_TH_LLDevUmAnswerModem")
	FL_LOG_ENTRY(psl);
	TSPRETURN tspRet=FL_GEN_RETVAL(IDERR_PENDING);


    switch(dwMsg)
    {
	case MSG_TASK_COMPLETE:
        tspRet = (TSPRETURN) dwParam2;
        goto answer_complete;

    case MSG_START:
        goto start;

    case MSG_DUMPSTATE:
        tspRet = 0;
        goto end;

    default:
        FL_SET_RFR(0xe8ecc600, "Unknown Msg");
        tspRet=FL_GEN_RETVAL(IDERR_CORRUPT_STATE);
        goto end;

    }

    ASSERT(FALSE);

start:

    if (m_pLLDev->IsDeviceRemoved())
    {
        tspRet = IDERR_DEVICE_NOTINSTALLED;
        FL_SET_RFR(0x463dec00, "Device not present.");
        goto end;
    }

    // Answer ...
    {

        DWORD dwAnswerFlags = (DWORD)dwParam1;
        m_pLLDev->fModemInited=FALSE;

        // Answer away....
        //
        DWORD dwRet  = m_StaticInfo.pMD->AnswerModem(
                                m_pLLDev->hModemHandle,
                                NULL,
                                dwAnswerFlags,
                                psl
                                );

        if (dwAnswerFlags & ANSWER_FLAG_VOICE)
        {
            m_pLLDev->LineMediaMode = LLDEVINFO::LMM_VOICE;
        }
    
        tspRet = m_StaticInfo.pMD->MapMDError(dwRet);
    }

answer_complete:

    //
    // Remember that Param1 is dwAnswerFlags ONLY
    // on MSG_START!
    //

    if (IDERR(tspRet) == IDERR_PENDING)
    {
        m_pLLDev->LineState =  LLDEVINFO::LS_OFFHOOK_ANSWERING;
        m_pLLDev->htspTaskPending = htspTask;
        FL_SET_RFR(0xff435100,  "UmAnswerModem returns PENDING.");
        THROW_PENDING_EXCEPTION();

    }
    else if (tspRet)
    {
        m_pLLDev->LineState =  LLDEVINFO::LS_OFFHOOK_UNKNOWN;

        FL_SET_RFR(0xb8f72000, "UmdmAnswerModem failed.");
    }
    else
    {
        m_pLLDev->LineState =  LLDEVINFO::LS_OFFHOOK_CONNECTED;

        FL_SET_RFR(0xd685e100, "UmdmAnswerModem succeeded.");
    }

end:

	FL_LOG_EXIT(psl, tspRet);
	return tspRet;

}


TSPRETURN
CTspDev::mfn_TH_LLDevUmHangupModem(
					HTSPTASK htspTask,
                    TASKCONTEXT *pContext,
					DWORD dwMsg,
					ULONG_PTR dwParam1,
					ULONG_PTR dwParam2,
					CStackLog *psl
					)
{
	FL_DECLARE_FUNC(0xb21793e0, "CTspDev::mfn_TH_LLDevUmHangupModem")
	FL_LOG_ENTRY(psl);
	TSPRETURN  tspRet=FL_GEN_RETVAL(IDERR_INVALID_ERR);

    switch(dwMsg)
    {
    case MSG_START:
        goto start;

	case MSG_TASK_COMPLETE:
        tspRet = (TSPRETURN) dwParam2;
        goto hangup_complete;
        break;

    case MSG_DUMPSTATE:
        tspRet = 0;
        goto end;

    default:
        FL_SET_RFR(0xb205e400, "Unknown Msg");
        tspRet=FL_GEN_RETVAL(IDERR_CORRUPT_STATE);
        goto end;
    }

    ASSERT(FALSE);

start:

    if (m_pLLDev->IsDeviceRemoved())
    {
        tspRet = IDERR_DEVICE_NOTINSTALLED;
        FL_SET_RFR(0xfd568d00, "Device not present.");
        goto end;
    }

    {
        m_pLLDev->fModemInited=FALSE;
    
        DWORD dwRet  = m_StaticInfo.pMD->HangupModem(
                                m_pLLDev->hModemHandle,
                                NULL,
                                0, // HangupFlags
                                psl
                                );
    
        tspRet = m_StaticInfo.pMD->MapMDError(dwRet);
    }

hangup_complete:

    if (IDERR(tspRet) == IDERR_PENDING)
    {
        FL_SET_RFR(0x262c0500, "UmHangupModem returns PENDING.");

        m_pLLDev->LineState =   LLDEVINFO::LS_OFFHOOK_DROPPING;
        m_pLLDev->htspTaskPending = htspTask;
        THROW_PENDING_EXCEPTION();
    }
    else if (tspRet)
    {
        // m_pLLDev->LineState =   LLDEVINFO::LS_OFFHOOK_UNKNOWN;
        // 1/31/1998 JosephJ: if hangup fails, we ignore the error ...
        // and set state to on-hook anyway...
        // Else it screws up other code, like mfn_TH_LLDevNormalize,
        // which uses the OFFHOOK/ONHOOK status to decide what to do..
        m_pLLDev->LineState =   LLDEVINFO::LS_ONHOOK_NOTMONITORING;
        FL_SET_RFR(0x529ed400, "UmHangupModem failed.");
    }
    else
    {
        // success...
        FL_SET_RFR(0x74002000, "UmHangupModem succeeds.");
        m_pLLDev->LineState = LLDEVINFO::LS_ONHOOK_NOTMONITORING;
    }

end:

	FL_LOG_EXIT(psl, tspRet);
	return tspRet;
}


TSPRETURN
CTspDev::mfn_TH_LLDevHybridWaveAction(
					HTSPTASK htspTask,
                    TASKCONTEXT *pContext,
					DWORD dwMsg,
					ULONG_PTR dwParam1,
					ULONG_PTR dwParam2,
					CStackLog *psl
					)
//
// This is called for handset audio when two actions need to be done:
// either open-handset + start-streaming
// or     stop-streaming + close-handset.
//
{
	FL_DECLARE_FUNC(0x8e8f3894, "CTspDev::mfn_TH_LLDevHybridWaveAction")
	FL_LOG_ENTRY(psl);
	TSPRETURN tspRet = FL_GEN_RETVAL(IDERR_INVALID_ERR);
	LLDEVINFO  *pLLDev = m_pLLDev;
    ULONG_PTR  *pdwWaveAction = &(pContext->dw0); // local context;;
    ULONG_PTR  *pdwIsHandset = &(pContext->dw1); // local context;
//    BOOL  fAsyncCompletion = TRUE;

    enum {
        HYBRIDWAVE_OPEN_HANDSET,
        HYBRIDWAVE_START_STREAMING,
        HYBRIDWAVE_STOP_STREAMING,
        HYBRIDWAVE_CLOSE_HANDSET
    };

    if (!pLLDev)
    {
        FL_SET_RFR(0x43571f00, "No lldevice!");
        ASSERT(FALSE);
        goto end;
    }

    switch(dwMsg)
    {
    default:
        FL_SET_RFR(0x17be9e00, "Unknown Msg");
        tspRet=FL_GEN_RETVAL(IDERR_CORRUPT_STATE);
        goto end;

    case MSG_START:

        *pdwWaveAction = dwParam1;
        *pdwWaveAction &= 0x7fffffff;
        *pdwIsHandset = (dwParam1 & 0x80000000)!=0;
        // pContext->dw0 = dwWaveAction;     // <- Save to context
        // pContext->dw1 = (DWORD) fHandset; // <- Save to context
        goto start;

	case MSG_SUBTASK_COMPLETE:

        if (pLLDev->IsDeviceRemoved())
        {
            tspRet = IDERR_DEVICE_NOTINSTALLED;
            FL_SET_RFR(0xc18bf600, "Device not present.");
            goto end;
        }

        // dwWaveAction = pContext->dw0;     // <- Restore from context
        // fHandset = (BOOL) pContext->dw1;  // <- Restore from context
        tspRet = dwParam2;
        switch(dwParam1) // Param1 is Subtask ID
        {
        case HYBRIDWAVE_OPEN_HANDSET:       goto open_handset_complete;
        case HYBRIDWAVE_START_STREAMING:    goto start_streaming_complete;
        case HYBRIDWAVE_STOP_STREAMING:     goto stop_streaming_complete;
        case HYBRIDWAVE_CLOSE_HANDSET:      goto close_handset_complete;
        default:
            ASSERT(FALSE);
        }
        break;

    case MSG_DUMPSTATE:
        tspRet = 0;
        goto DumpEnd;
    }

    ASSERT(FALSE);

start:

    if (pLLDev->IsDeviceRemoved())
    {
        tspRet = IDERR_DEVICE_NOTINSTALLED;
        FL_SET_RFR(0x47475200, "Device not present.");
        goto end;
    }

    {

        BOOL fCurrentlyStreamingVoice =  pLLDev->IsStreamingVoice();
        BOOL fStartStreaming = FALSE;
//        fAsyncCompletion = FALSE;
        tspRet = IDERR_WRONGSTATE;

        // First make sure that we are an a position to do this wave action.
        switch(*pdwWaveAction)
        {

        case WAVE_ACTION_START_PLAYBACK:    // fallthrough
        case WAVE_ACTION_START_RECORD:      // fallthrough
        case WAVE_ACTION_START_DUPLEX:      // fallthrough
            fStartStreaming = TRUE;
            break;


        case WAVE_ACTION_STOP_STREAMING:
        case WAVE_ACTION_ABORT_STREAMING:
            if (!pLLDev->IsStreamModePlay() && !pLLDev->IsStreamModeRecord() && !pLLDev->IsStreamModeDuplex())
            {
                 FL_SET_RFR(0x6a3e7d00, "Wrong mode for STOP_STREAMING");
                 goto end;
            }
            break;


        case WAVE_ACTION_OPEN_HANDSET:      // fallthrough
        case WAVE_ACTION_CLOSE_HANDSET:      // fallthrough
        //      the above two should never be sent.
        //
        default:
            ASSERT(FALSE);
            FL_SET_RFR(0x6a31e100, "Unexpected/unknown wave action");
            goto end;
            break;
        }

        if (fStartStreaming)
        {
            //
            // We won't allow starting wave action unless there is a valid
            // reason to do so.
            //

            if (!pLLDev->dwRefCount)
            {
            FL_SET_RFR(0x75b7f100, "Failing wave because !pLLDev->dwRefCount");
            goto end;
            }
            
            CALLINFO *pCall = (m_pLine) ? m_pLine->pCall : NULL;

            if (*pdwIsHandset)
            {
                if (    pLLDev->IsLineOffHook()
                    || !m_pPhone
                    || m_pLLDev->IsPassthroughOn()
                    || m_pPhone->IsAborting()
                    || pCall)
                {
                   FL_SET_RFR(0x9d1f8500, "Can't do phone wave in this state.");
                   goto end;
                }
            }
            else if (   !pLLDev->IsLineConnectedVoice()
                     || !pCall
                     || m_pLLDev->IsPassthroughOn()
                     || pCall->IsAborting())
            {
                FL_SET_RFR(0x2de01c00, "Can't do line wave in this state.");
                goto end;
            }

            if (fCurrentlyStreamingVoice)
            {
	            FL_SET_RFR(0x6abe3200, "Already streaming voice!");
                goto end;
            }
        }
        else
        {
            // We SHOULD allow WaveAction requests to
            // STOP play/record regardless of the TAPI line/phone state,
            // because there could have been onging wave
            // activity at the time the lineDrop came from TAPI or the
            // disconnect notification came from the mini driver.
            //
            if (!fCurrentlyStreamingVoice)
            {
	            FL_SET_RFR(0x8b637400, "Not currently streaming voice!");
	            ASSERT(FALSE);
	            tspRet = 0;
                goto end;
            }
        }

        if (*pdwIsHandset)
        {
            if (fStartStreaming)
            {
                goto open_handset;
            }
            else
            {
                goto stop_streaming;
            }
        }
        else
        {
            if (fStartStreaming)
            {
                goto start_streaming;
            }
            else
            {
                goto stop_streaming;
            }
        }
    }

    ASSERT(FALSE);

open_handset:

    tspRet = mfn_StartSubTask (
                        htspTask,
                        &CTspDev::s_pfn_TH_LLDevUmWaveAction,
                        HYBRIDWAVE_OPEN_HANDSET,
                        WAVE_ACTION_OPEN_HANDSET,
                        0x0,
                        psl
                        );

open_handset_complete:

    if (tspRet) goto end;

    // fall through on success ...

start_streaming:

    tspRet = mfn_StartSubTask (
                        htspTask,
                        &CTspDev::s_pfn_TH_LLDevUmWaveAction,
                        HYBRIDWAVE_START_STREAMING,
                        *pdwWaveAction,
                        0x0,
                        psl
                        );


start_streaming_complete:

    goto end;


//========= stop streaming case ===============================

stop_streaming:

    tspRet = mfn_StartSubTask (
                        htspTask,
                        &CTspDev::s_pfn_TH_LLDevUmWaveAction,
                        HYBRIDWAVE_STOP_STREAMING,
                        *pdwWaveAction,
                        0x0,
                        psl
                        );

stop_streaming_complete:

    if (!*pdwIsHandset || IDERR(tspRet)==IDERR_PENDING) goto end;

    // fall through on sync success or sync failure, but only
    // if we're doing handset audio (obviously).

//close_handset:

    tspRet = mfn_StartSubTask(
                        htspTask,
                        &CTspDev::s_pfn_TH_LLDevUmWaveAction,
                        HYBRIDWAVE_CLOSE_HANDSET,
                        WAVE_ACTION_CLOSE_HANDSET,
                        0x0,
                        psl
                        );

close_handset_complete:

    goto end;

    
end:

//    if (IDERR(tspRet)!=IDERR_PENDING && fAsyncCompletion)
    if (IDERR(tspRet)!=IDERR_PENDING )
    {
        //
        // We should get get here only on
        // async completion.
        // We must only  call mfn_AIPC_AsyncReturn if this has been
        // an async completion. Sync completion is  handled in the
        // function which started the root task.
        //
    
        mfn_AIPC_AsyncReturn(tspRet==IDERR_SUCCESS, psl);

    }

DumpEnd:
	FL_LOG_EXIT(psl, tspRet);
	return tspRet;

}


TSPRETURN
CTspDev::mfn_TH_LLDevUmWaveAction(
					HTSPTASK htspTask,
                    TASKCONTEXT *pContext,
					DWORD dwMsg,
					ULONG_PTR dwParam1,
					ULONG_PTR dwParam2,
					CStackLog *psl
					)
{
	FL_DECLARE_FUNC(0x1bd9db10, "CTspDev::mfn_TH_LLDevUmWaveAction")
	FL_LOG_ENTRY(psl);
	TSPRETURN tspRet = FL_GEN_RETVAL(IDERR_INVALID_ERR);
	LLDEVINFO  *pLLDev = m_pLLDev;
    DWORD dwWaveAction = 0;

    if (!pLLDev)
    {
        FL_SET_RFR(0xaeae2b00, "No lldevice!");
        ASSERT(FALSE);
        goto end;
    }

    switch(dwMsg)
    {
    default:
        FL_SET_RFR(0x3bde4a00, "Unknown Msg");
        tspRet=FL_GEN_RETVAL(IDERR_CORRUPT_STATE);
        goto end;

    case MSG_START:
        dwWaveAction = (DWORD)dwParam1;
        pContext->dw0 = dwWaveAction; // save to context
        goto start;

	case MSG_TASK_COMPLETE:
        dwWaveAction = (DWORD)pContext->dw0; // restore from context.
        tspRet = (TSPRETURN)dwParam2;
        goto action_complete;

    case MSG_DUMPSTATE:
        tspRet = 0;
        goto end;
    }

    ASSERT(FALSE);

start:

    if (pLLDev->IsDeviceRemoved())
    {
        tspRet = IDERR_DEVICE_NOTINSTALLED;
        FL_SET_RFR(0x46d41b00, "Device not present.");
        goto end;
    }

    {
        if (pLLDev->IsLoggingEnabled())
        {
            char rgchName[128];
            static DWORD sInstance;
            rgchName[0] = 0;

            UINT cbBuf =  DumpWaveAction(
                            sInstance,
                            0, // dwFlags
                            dwWaveAction,
                            rgchName,
                            sizeof(rgchName)/sizeof(*rgchName),
                            NULL,
                            0
                            );

            if (*rgchName)
            {
                m_StaticInfo.pMD->LogStringA(
                                            m_pLLDev->hModemHandle,
                                            LOG_FLAG_PREFIX_TIMESTAMP,
                                            rgchName,
                                            psl
                                            );
            }
        }

        // Start or stop voice playback or record...
        //
        DWORD dwRet  = m_StaticInfo.pMD->WaveAction(
                                m_pLLDev->hModemHandle,
                                NULL,
                                dwWaveAction,
                                psl
                                );
        tspRet = m_StaticInfo.pMD->MapMDError(dwRet);
    }

action_complete:

    if (IDERR(tspRet) == IDERR_PENDING)
    {
        FL_SET_RFR(0x2da72100, "UmWaveAction() returns PENDING");
        m_pLLDev->htspTaskPending = htspTask;
        THROW_PENDING_EXCEPTION();
    }
    else if (tspRet)
    {
        FL_SET_RFR(0x16cda500, "UmWaveAction() failed");
    }
    else
    {
        switch (dwWaveAction)
        {
        case WAVE_ACTION_START_PLAYBACK:
            if (m_pLLDev->IsHandsetOpen())
            {
                m_pLLDev->StreamingState = LLDEVINFO::STREAMING_PLAY_TO_PHONE;
	            FL_SET_RFR(0xde384200, "NewState: Streaming play to phone.");
            }
            else
            {
                m_pLLDev->StreamingState = LLDEVINFO::STREAMING_PLAY_TO_LINE;
	            FL_SET_RFR(0xf26bbf00, "NewState: Streaming play to line.");
            }
            break;

        case WAVE_ACTION_START_RECORD:
            if (m_pLLDev->IsHandsetOpen())
            {
                m_pLLDev->StreamingState = LLDEVINFO::STREAMING_RECORD_TO_PHONE;
	           FL_SET_RFR(0x1d18f200, "NewState: Streaming record from phone.");
            }
            else
            {
                m_pLLDev->StreamingState = LLDEVINFO::STREAMING_RECORD_TO_LINE;
	            FL_SET_RFR(0x55eee200, "NewState: Streaming record from line.");
            }
            break;

        case WAVE_ACTION_START_DUPLEX:
            if (m_pLLDev->IsHandsetOpen())
            {
                m_pLLDev->StreamingState = LLDEVINFO::STREAMING_DUPLEX_TO_PHONE;
	           FL_SET_RFR(0x322fc700, "NewState: Streaming duplex with phone.");
            }
            else
            {
                m_pLLDev->StreamingState = LLDEVINFO::STREAMING_DUPLEX_TO_LINE;
	            FL_SET_RFR(0xc6359700, "NewState: Streaming duplex with line.");
            }
            break;

        case WAVE_ACTION_STOP_STREAMING:
        case WAVE_ACTION_ABORT_STREAMING:
            m_pLLDev->StreamingState = LLDEVINFO::STREAMING_NONE;
            FL_SET_RFR(0x4f8c9f00, "NewState: Not streaming.");
            break;


        case WAVE_ACTION_OPEN_HANDSET:
            m_pLLDev->PhoneState = LLDEVINFO::PHONEOFFHOOK_HANDSET_OPENED;
            FL_SET_RFR(0x3278b300, "NewHandsetState: Opened.");
            break;

        case WAVE_ACTION_CLOSE_HANDSET:
            m_pLLDev->PhoneState = LLDEVINFO::PHONEONHOOK_NOTMONITORNING;
            FL_SET_RFR(0xdecc8300, "NewHandsetState: Closed.");
            break;
        }
    }

end:

	FL_LOG_EXIT(psl, tspRet);
	return tspRet;

}


TSPRETURN
CTspDev::mfn_TH_LLDevUmSetPassthroughMode(
					HTSPTASK htspTask,
                    TASKCONTEXT *pContext,
					DWORD dwMsg,
					ULONG_PTR dwParam1,
					ULONG_PTR dwParam2,
					CStackLog *psl
					)
{
    //
    // START:
    //  dwParam1 = dwMode
    //
    // pContext use:
    //   dw0: *pdwMode
    //

	FL_DECLARE_FUNC(0x3d024075, "CTspDev::mfn_TH_LLDevUmSetPassthroughMode")
	FL_LOG_ENTRY(psl);
	TSPRETURN tspRet=FL_GEN_RETVAL(IDERR_PENDING);
    DWORD dwRet = 0;
    ULONG_PTR *pdwMode = &pContext->dw0;
    LLDEVINFO *pLLDev = m_pLLDev;

    if (!pLLDev)
    {
        ASSERT(FALSE);
        goto end;
    }


    switch(dwMsg)
    {
    case MSG_START:
        goto start;

	case MSG_TASK_COMPLETE:
        tspRet = (TSPRETURN) dwParam2;
        goto end;

    case MSG_DUMPSTATE:
        tspRet = 0;
        goto end;

    default:
        FL_SET_RFR(0xf75dac00, "Unknown Msg");
        tspRet=FL_GEN_RETVAL(IDERR_CORRUPT_STATE);
        goto end;

    }

    ASSERT(FALSE);

start:

    if (pLLDev->IsDeviceRemoved())
    {
        tspRet = IDERR_DEVICE_NOTINSTALLED;
        FL_SET_RFR(0xde45e500, "Device not present.");
        goto end;
    }

    if (pLLDev->IsStreamingVoice()) {
        //
        //  can't do this if we are streaming
        //
        tspRet = IDERR_WRONGSTATE;
        FL_SET_RFR(0xb3e8e100, "Device not present.");
        goto end;
    }


    {
        *pdwMode = dwParam1; // save state to pContext.

        pLLDev->fModemInited=FALSE;

        SLPRINTF1(psl, "Calling UmSetPassthroughMode (%lu)", *pdwMode);

        // Switch on passthrough ...
        DWORD dwRet  = m_StaticInfo.pMD->SetPassthroughMode(
                                pLLDev->hModemHandle,
                                (DWORD)*pdwMode,
                                psl
                                );
    
        tspRet = m_StaticInfo.pMD->MapMDError(dwRet);

    }

end:

    if (IDERR(tspRet)==IDERR_PENDING)
    {
        FL_SET_RFR(0x79a6f000, "UmSetPassthroughMode returns PENDING.");
    
        pLLDev->htspTaskPending = htspTask;
        THROW_PENDING_EXCEPTION();
    }
    else if (tspRet)
    {
        FL_SET_RFR(0x1d301b00, "UmSetPassthroughMode sync failure");
    }
    else
    {
        // success, let's update our state...
        switch(*pdwMode)
        {
        case PASSTHROUUGH_MODE_ON_DCD_SNIFF:
            //
            //  if we go into this mode it would indicate that we are in a connected state will
            //  a data call. BRL (5/17/98)
            //
            pLLDev->LineState = LLDEVINFO::LS_CONNECTED_PASSTHROUGH;

            break;

        case PASSTHROUUGH_MODE_ON:

            if (pLLDev->IsLineOffHook())
            {
                if (pLLDev->IsLineConnected())
                {
                    pLLDev->LineState = LLDEVINFO::LS_CONNECTED_PASSTHROUGH;
                }
                else
                {
                    pLLDev->LineState = LLDEVINFO::LS_OFFHOOK_PASSTHROUGH;
                }
            }
            else
            {
                pLLDev->LineState = LLDEVINFO::LS_ONHOOK_PASSTHROUGH;
            }
            break;

        case PASSTHROUUGH_MODE_OFF:
            if (pLLDev->IsLineOffHook())
            {
                if (pLLDev->IsLineConnected())
                {
                    pLLDev->LineState = LLDEVINFO::LS_OFFHOOK_CONNECTED;
                }
                else
                {
                    pLLDev->LineState = LLDEVINFO::LS_OFFHOOK_UNKNOWN;
                }
            }
            else
            {
                pLLDev->LineState = LLDEVINFO::LS_ONHOOK_NOTMONITORING;
            }
            break;

        default:
            ASSERT(FALSE);
        }
    }

	FL_LOG_EXIT(psl, tspRet);
	return tspRet;

}

TSPRETURN
CTspDev::mfn_TH_LLDevUmGenerateDigit(
					HTSPTASK htspTask,
                    TASKCONTEXT *pContext,
					DWORD dwMsg,
					ULONG_PTR dwParam1,
					ULONG_PTR dwParam2,
					CStackLog *psl
					)
{
	FL_DECLARE_FUNC(0xe47653d0, "CTspDev::mfn_TH_LLDevUmGenerateDigit")
	FL_LOG_ENTRY(psl);
	TSPRETURN tspRet=FL_GEN_RETVAL(IDERR_PENDING);

    switch(dwMsg)
    {
    case MSG_START:
        goto start;

	case MSG_TASK_COMPLETE:
        tspRet = (TSPRETURN) dwParam2;
        goto generate_complete;

    case MSG_DUMPSTATE:
        tspRet = 0;
        goto end;

    default:
        FL_SET_RFR(0x0fd2f100, "Unknown Msg");
        tspRet=FL_GEN_RETVAL(IDERR_CORRUPT_STATE);
        goto end;

    }

    ASSERT(FALSE);

start:

    if (m_pLLDev->IsDeviceRemoved())
    {
        tspRet = IDERR_DEVICE_NOTINSTALLED;
        FL_SET_RFR(0xd5c08c00, "Device not present.");
        goto end;
    }

    {
        LPSTR lpszDigits   = (LPSTR) dwParam1;

        if (   m_pLLDev->IsLineConnectedVoice()
            && !m_pLLDev->IsStreamingVoice()
            && lpszDigits
            && *lpszDigits)
        {
    
            // Generate away...
            DWORD dwRet  = m_StaticInfo.pMD->GenerateDigit(
                                    m_pLLDev->hModemHandle,
                                    NULL,
                                    lpszDigits,
                                    psl
                                    );
            tspRet = m_StaticInfo.pMD->MapMDError(dwRet);
    
        }
        else
        {
        FL_SET_RFR(0x23bfaa00, "Can't call UmGenerateDigit in current state!");
            tspRet = IDERR_WRONGSTATE;
            goto end;
        }
    }


generate_complete:

    //
    // Remember that Param1 is lpszDigits ONLY
    // on MSG_START, and that the memory is freed by the caller of this task
    // right after the task returns for the 1st time.
    //

    if (IDERR(tspRet) == IDERR_PENDING)
    {
        m_pLLDev->htspTaskPending = htspTask;
        FL_SET_RFR(0x09964700,  "UmGenerateDigits returns PENDING.");
        THROW_PENDING_EXCEPTION();
    }
    else if (tspRet)
    {
        FL_SET_RFR(0x8150f000, "UmGenerateDigits failed.");
    }
    else
    {
        // success..
        FL_SET_RFR(0x400c4500, "UmGenerateDigits succeeded.");
    }

end:

	FL_LOG_EXIT(psl, tspRet);
	return tspRet;

}

LONG BuildParsedDiagnostics(LPVARSTRING lpVarString);


TSPRETURN
CTspDev::mfn_TH_LLDevUmGetDiagnostics(
					HTSPTASK htspTask,
                    TASKCONTEXT *pContext,
					DWORD dwMsg,
					ULONG_PTR dwParam1,
					ULONG_PTR dwParam2,
					CStackLog *psl
					)
{
	FL_DECLARE_FUNC(0xc25c8c50, "CTspDev::mfn_TH_LLDevUmGetDiagnostics")
	FL_LOG_ENTRY(psl);
	TSPRETURN tspRet=IDERR_CORRUPT_STATE;
    CALLINFO *pCall = (m_pLine)  ? m_pLine->pCall : NULL;

    struct _TH_LLDevUmGetDiagnostics_context
    {
        BYTE *pbRaw;
        UINT cbRaw;
        DWORD cbUsed;
    } *pMyCtxt = (struct _TH_LLDevUmGetDiagnostics_context *) pContext;

    switch(dwMsg)
    {
    case MSG_START:
        goto start;

	case MSG_TASK_COMPLETE:
        tspRet = (TSPRETURN) dwParam2;
        goto operation_complete;

    case MSG_DUMPSTATE:
        tspRet = 0;
        goto end;

    default:
        FL_SET_RFR(0xc8cd4200, "Unknown Msg");
        goto end;
    }

    ASSERT(FALSE);

start:

    if (m_pLLDev->IsDeviceRemoved())
    {
        tspRet = IDERR_DEVICE_NOTINSTALLED;
        FL_SET_RFR(0x45118100, "Device not present.");
        goto end;
    }

    // Note: the context is zero'd out on start...
    ASSERT(!pMyCtxt->pbRaw);

    if (mfn_IsCallDiagnosticsEnabled() && pCall)
    {
        // Allocate space to store the diagnostic info.
        pMyCtxt->cbRaw = 2048;
        pMyCtxt->pbRaw = (BYTE *) ALLOCATE_MEMORY(pMyCtxt->cbRaw);

        if (pMyCtxt->pbRaw)
        {
            // Request diagnostic info...
        
            DWORD dwRet = dwRet  = m_StaticInfo.pMD->GetDiagnostics(
                                    m_pLLDev->hModemHandle,
                                    0, // DiagnosticType, must be 0
                                    pMyCtxt->pbRaw, // Buffer
                                    pMyCtxt->cbRaw, // BufferSize
                                    &(pMyCtxt->cbUsed), // UsedSize
                                    psl
                                    );

            tspRet = m_StaticInfo.pMD->MapMDError(dwRet);
            if (IDERR(tspRet) == IDERR_PENDING)
            {
                FL_SET_RFR(0x2c9e1b00, "UmGetDiagnostics returns PENDING");
                m_pLLDev->htspTaskPending = htspTask;
                THROW_PENDING_EXCEPTION();
            }
            else if (tspRet)
            {
                FL_SET_RFR(0xa0c1b400, "UmGetDiagnostics failed synchronously");
            }
            else
            {
                // success...
                FL_SET_RFR(0x9732f300, "UmGetDiagnostics succeeds.");
            }
        }
    }
    else
    {
        // Doesn't make sense to do diagnostics now...
        // Let's suceed
        FL_SET_RFR(0x14d64e00, "Can't do call diagnostics now");
        tspRet = IDERR_GENERIC_FAILURE;
        goto end;
    }

operation_complete:

    if (IDERR(tspRet)==IDERR_PENDING) goto end;

    //
    // WARNING WARNING WARNING
    //
    //      m_pLine and m_pCall may well be NULL....
    //

    // Either failure or success, either sync or async...
    // On Success, we call mfn_AppendDiagnostic to transfer
    // the buffer to the CALLINFO's diagnostics buffer, possibly
    // truncating the diagnostics we collected here.
    // 

    if (!tspRet)
    {
        
        if (pMyCtxt->pbRaw && (pMyCtxt->cbUsed>1))
        {
            // NOTE: mfn_AppendDiagnostic will do nothing if there is
            // no call active...

            mfn_AppendDiagnostic(
                    DT_TAGGED,
                    pMyCtxt->pbRaw,
                    pMyCtxt->cbUsed-1 // not including final NULL.
                    );
            {

                #define DIAG_TEMP_BUFFER_SIZE  4096

                VARSTRING   *VarString;
                LONG         lRet;

                VarString=(VARSTRING*)ALLOCATE_MEMORY(DIAG_TEMP_BUFFER_SIZE);

                if (VarString != NULL) {

                    VarString->dwTotalSize=DIAG_TEMP_BUFFER_SIZE;

                    lRet = mfn_fill_RAW_LINE_DIAGNOSTICS(
                        VarString,
                        DIAG_TEMP_BUFFER_SIZE-sizeof(*VarString),
                        psl
                        );

                    if (lRet == ERROR_SUCCESS) {

                        lRet = BuildParsedDiagnostics(VarString);

                        if (lRet == ERROR_SUCCESS) {

                            m_StaticInfo.pMD->LogDiagnostics(
                                    m_pLLDev->hModemHandle,
                                    VarString,
                                    psl
                                    );


                        }

                    }
                    FREE_MEMORY(VarString);
                }

            }

        }
    }

    if (pMyCtxt->pbRaw)
    {
        FREE_MEMORY(pMyCtxt->pbRaw);
    }

    ZeroMemory(pMyCtxt, sizeof(*pMyCtxt));

end:

	FL_LOG_EXIT(psl, tspRet);
	return tspRet;

}


TSPRETURN
CTspDev::mfn_TH_LLDevUmMonitorModem(
                    HTSPTASK htspTask,
                    TASKCONTEXT *pContext,
                    DWORD dwMsg,
                    ULONG_PTR dwParam1, // dwFlags
                    ULONG_PTR dwParam2,
                    CStackLog *psl
                    )
//
//  START_MSG Params:
//      dwParam1: dwMonitorFlags.
//
{

	FL_DECLARE_FUNC(0xa068526e, "CTspDev::mfn_TH_LLDevUmMonitorModem")
	FL_LOG_ENTRY(psl);
	TSPRETURN tspRet=FL_GEN_RETVAL(IDERR_INVALID_ERR);

    switch(dwMsg)
    {
    default:
        tspRet=FL_GEN_RETVAL(IDERR_CORRUPT_STATE);
        goto end;

    case MSG_START:
        goto start;

	case MSG_TASK_COMPLETE:
        tspRet = (TSPRETURN) dwParam2;
        goto monitor_complete;
        break;

    case MSG_DUMPSTATE:
        tspRet = 0;
        goto end;
    }

    ASSERT(FALSE);
    goto end;

start:

    if (m_pLLDev->IsDeviceRemoved())
    {
        tspRet = IDERR_DEVICE_NOTINSTALLED;
        FL_SET_RFR(0x342cd900, "Device not present.");
        goto end;
    }

    { 
        DWORD dwFlags = (DWORD)dwParam1;

        DWORD dwRet  = m_StaticInfo.pMD->MonitorModem(
                                m_pLLDev->hModemHandle,
                                dwFlags,
                                NULL,
                                psl
                                );
    
        tspRet = m_StaticInfo.pMD->MapMDError(dwRet);

    }

monitor_complete:

    if (IDERR(tspRet) == IDERR_PENDING)
    {
        FL_SET_RFR(0xe8255e00, "UmdmMonitorModem returns PENDING.");
        m_pLLDev->htspTaskPending = htspTask;
        THROW_PENDING_EXCEPTION();
    }
    else if (tspRet)
    {
        FL_SET_RFR(0xd9d29800, "UmdmMonitorModem failed.");
    }
    else
    {
        FL_SET_RFR(0xf37af300, "UmdmMonitorModem succeeded.");
        m_pLLDev->LineState =  LLDEVINFO::LS_ONHOOK_MONITORING;
        // Update line state..
    }

end:

	FL_LOG_EXIT(psl, tspRet);

	return tspRet;
}


TSPRETURN
CTspDev::mfn_TH_LLDevUmSetSpeakerPhoneMode(
                    HTSPTASK htspTask,
                    TASKCONTEXT *pContext,
                    DWORD dwMsg,
                    ULONG_PTR dwParam1,
                    ULONG_PTR dwParam2,
                    CStackLog *psl
                    )
//
//  START_MSG Params:
//      dwParam1: unused
//
{

	FL_DECLARE_FUNC(0x3c66bd57, "CTspDev::mfn_TH_LLDevUmSetSpeakerPhoneMode")
	FL_LOG_ENTRY(psl);
	TSPRETURN tspRet=FL_GEN_RETVAL(IDERR_INVALID_ERR);

    switch(dwMsg)
    {
    default:
        FL_SET_RFR(0xcbd61b00, "Unknown Msg");
        tspRet=FL_GEN_RETVAL(IDERR_CORRUPT_STATE);
        goto end;

    case MSG_START:
        goto start;

	case MSG_TASK_COMPLETE:
        tspRet = (TSPRETURN) dwParam2;
        goto action_complete;
        break;

    case MSG_DUMPSTATE:
        tspRet = 0;
        goto end;
    }

    ASSERT(FALSE);
    goto end;

start:
    if (m_pLLDev->IsDeviceRemoved())
    {
        tspRet = IDERR_DEVICE_NOTINSTALLED;
        FL_SET_RFR(0x3c05cc00, "Device not present.");
        goto end;
    }

    { 
        DWORD     CurrentMode = m_pLLDev->SpkrPhone.dwMode;

    #if 0 
        DWORD     NewMode = dwParam1;
    #else // hack -- dwParam1 is not filled in from TH_AsyncPhone
        DWORD     NewMode = m_pPhone->dwPendingSpeakerMode;
    #endif

        DWORD     Volume = m_pLLDev->SpkrPhone.dwVolume;
        DWORD     Gain = m_pLLDev->SpkrPhone.dwGain;

        DWORD dwRet  = m_StaticInfo.pMD->SetSpeakerPhoneState(
                                m_pLLDev->hModemHandle,
                                NULL,
                                CurrentMode,
                                NewMode,
                                Volume,
                                Gain,
                                psl
                                );
    
        pContext->dw0 = NewMode;    // save to context
        tspRet = m_StaticInfo.pMD->MapMDError(dwRet);
    }

action_complete:

    if (IDERR(tspRet) == IDERR_PENDING)
    {

        FL_SET_RFR(0x992f5f00, "UmSpeakerPhoneState() returns PENDING");
        m_pLLDev->htspTaskPending = htspTask;
        THROW_PENDING_EXCEPTION();
    }
    else if (tspRet)
    {
        FL_SET_RFR(0xa0351e00, "UmSpeakerPhoneState() failed");
    }
    else
    {
        // success -- update mode
        m_pLLDev->SpkrPhone.dwMode = (DWORD)pContext->dw0;   // restore from context
    }

end:

	FL_LOG_EXIT(psl, tspRet);

	return tspRet;

}


TSPRETURN
CTspDev::mfn_TH_LLDevUmSetSpeakerPhoneVolGain(
                    HTSPTASK htspTask,
                    TASKCONTEXT *pContext,
                    DWORD dwMsg,
                    ULONG_PTR dwParam1,
                    ULONG_PTR dwParam2,
                    CStackLog *psl
                    )
//
//  START_MSG Params:
//      dwParam1: unused
//
{

	FL_DECLARE_FUNC(0x0ee72c32, "CTspDev::mfn_TH_LLDevUmSetSpeakerPhoneVolGain")
	FL_LOG_ENTRY(psl);
	TSPRETURN tspRet=FL_GEN_RETVAL(IDERR_INVALID_ERR);

    switch(dwMsg)
    {
    default:
        FL_SET_RFR(0x041cb300, "Unknown Msg");
        tspRet=FL_GEN_RETVAL(IDERR_CORRUPT_STATE);
        goto end;

    case MSG_START:
        goto start;

	case MSG_TASK_COMPLETE:
        tspRet = (TSPRETURN) dwParam2;
        goto action_complete;
        break;

    case MSG_DUMPSTATE:
        tspRet = 0;
        goto end;
    }

    ASSERT(FALSE);
    goto end;

start:

    if (m_pLLDev->IsDeviceRemoved())
    {
        tspRet = IDERR_DEVICE_NOTINSTALLED;
        FL_SET_RFR(0x50f12200, "Device not present.");
        goto end;
    }

    { 
        DWORD     CurrentMode = m_pLLDev->SpkrPhone.dwMode;
        DWORD     NewMode = CurrentMode;

    #if (0)
        DWORD     Volume = dwParam1;
        DWORD     Gain = dwParam2;
    #else // hack -- dwParam1 & dwParam2 are not filled in from TH_AsyncPhone
        DWORD     Volume =  m_pPhone->dwPendingSpeakerVolume;
        DWORD     Gain   =  m_pPhone->dwPendingSpeakerGain;
    #endif

        DWORD dwRet  = m_StaticInfo.pMD->SetSpeakerPhoneState(
                                m_pLLDev->hModemHandle,
                                NULL,
                                CurrentMode,
                                NewMode,
                                Volume,
                                Gain,
                                psl
                                );
    
        pContext->dw0 = Volume;     // save to context
        pContext->dw1 = Gain;       // save to context
        tspRet = m_StaticInfo.pMD->MapMDError(dwRet);
    }

action_complete:

    if (IDERR(tspRet) == IDERR_PENDING)
    {

        FL_SET_RFR(0xcca57f00, "UmSpeakerPhoneState() returns PENDING");
        m_pLLDev->htspTaskPending = htspTask;
        THROW_PENDING_EXCEPTION();
    }
    else if (tspRet)
    {
        FL_SET_RFR(0x1b58be00, "UmSpeakerPhoneState() failed");
    }
    else
    {
        // success -- update volume and gain
        m_pLLDev->SpkrPhone.dwVolume = (DWORD)pContext->dw0;   // restore from context
        m_pLLDev->SpkrPhone.dwGain   = (DWORD)pContext->dw1;   // restore from context
    }

end:

	FL_LOG_EXIT(psl, tspRet);

	return tspRet;

}


TSPRETURN
CTspDev::mfn_TH_LLDevUmSetSpeakerPhoneState(
                    HTSPTASK htspTask,
                    TASKCONTEXT *pContext,
                    DWORD dwMsg,
                    ULONG_PTR dwParam1,
                    ULONG_PTR dwParam2,
                    CStackLog *psl
                    )
//
//  START_MSG Params:
//      dwParam1: *HOOKDEVSTATE of new state requested.
//
{

	FL_DECLARE_FUNC(0xfd72d99e, "CTspDev::mfn_TH_LLDevUmSetSpeakerPhoneState")
	FL_LOG_ENTRY(psl);
	TSPRETURN tspRet=IDERR_CORRUPT_STATE;

    //
    // Local context ...
    //
    ULONG_PTR *pdwNewVol = &(pContext->dw0);
    ULONG_PTR *pdwNewGain = &(pContext->dw1);
    ULONG_PTR *pdwNewMode = &(pContext->dw2);

    switch(dwMsg)
    {
    default:
        FL_SET_RFR(0x68ed0300, "Unknown Msg");
        goto end;

    case MSG_START:
        goto start;

	case MSG_TASK_COMPLETE:
        tspRet = (TSPRETURN) dwParam2;
        goto action_complete;
        break;

    case MSG_DUMPSTATE:
        tspRet = 0;
        goto end;
    }

    ASSERT(FALSE);
    goto end;

start:

    if (m_pLLDev->IsDeviceRemoved())
    {
        tspRet = IDERR_DEVICE_NOTINSTALLED;
        FL_SET_RFR(0x6e0dd800, "Device not present.");
        goto end;
    }

    { 
        //
        // Save context ....
        //
        {
            HOOKDEVSTATE *pNewState = (HOOKDEVSTATE*) dwParam1;
            *pdwNewVol = pNewState->dwVolume;
            *pdwNewGain = pNewState->dwGain;
            *pdwNewMode = pNewState->dwMode;
        }

        DWORD dwRet  = m_StaticInfo.pMD->SetSpeakerPhoneState(
                                m_pLLDev->hModemHandle,
                                NULL,
                                m_pLLDev->SpkrPhone.dwMode,
                                (DWORD)*pdwNewMode,
                                (DWORD)*pdwNewVol,
                                (DWORD)*pdwNewGain,
                                psl
                                );
    
        tspRet = m_StaticInfo.pMD->MapMDError(dwRet);
    }

action_complete:

    if (IDERR(tspRet) == IDERR_PENDING)
    {

        FL_SET_RFR(0x427a1f00, "UmSpeakerPhoneState() returns PENDING");
        m_pLLDev->htspTaskPending = htspTask;
        THROW_PENDING_EXCEPTION();
    }
    else if (tspRet)
    {
        FL_SET_RFR(0x2f2e3400, "UmSpeakerPhoneState() failed");
    }
    else
    {
        // success -- update volume, gain and mode...
        m_pLLDev->SpkrPhone.dwVolume = (DWORD)*pdwNewVol;
        m_pLLDev->SpkrPhone.dwGain   = (DWORD)*pdwNewGain;
        m_pLLDev->SpkrPhone.dwMode   = (DWORD)*pdwNewMode;
    }

end:

	FL_LOG_EXIT(psl, tspRet);

	return tspRet;

}


TSPRETURN
CTspDev::mfn_TH_LLDevUmIssueCommand(
					HTSPTASK htspTask,
                    TASKCONTEXT *pContext,
					DWORD dwMsg,
					ULONG_PTR dwParam1,
					ULONG_PTR dwParam2,
					CStackLog *psl
					)
{
	FL_DECLARE_FUNC(0x4f0054f8, "CTspDev::mfn_TH_LLDevUmIssueCommand")
	FL_LOG_ENTRY(psl);
	TSPRETURN tspRet=FL_GEN_RETVAL(IDERR_CORRUPT_STATE);

    switch(dwMsg)
    {
    case MSG_START:
        goto start;

	case MSG_TASK_COMPLETE:
        tspRet = (TSPRETURN) dwParam2;
        goto command_complete;

    case MSG_DUMPSTATE:
        tspRet = 0;
        goto end;

    default:
        goto end;

    }

    ASSERT(FALSE);

start:

    if (m_pLLDev->IsDeviceRemoved())
    {
        tspRet = IDERR_DEVICE_NOTINSTALLED;
        FL_SET_RFR(0x73ba1800, "Device not present.");
        goto end;
    }

    //
    // Start Params:
    //  dwParam1: szCommand (ASCII)
    //  dwParam2: timeout (ms)
    //



    { 
        // Issue command
        DWORD dwRet =  m_StaticInfo.pMD->IssueCommand(
                                m_pLLDev->hModemHandle,
                                NULL,
                                (LPSTR) dwParam1,
                                "OK\r\n",
                                (DWORD)dwParam2,
                                psl
                                );
    
        tspRet =  m_StaticInfo.pMD->MapMDError(dwRet);
    }


command_complete:

    if (IDERR(tspRet)==IDERR_PENDING)
    {
	    FL_SET_RFR(0xd9666100, "UmIssueCommand returns PENDING");

        m_pLLDev->htspTaskPending = htspTask;
        THROW_PENDING_EXCEPTION();
    }
    else if (tspRet)
    {
        FL_SET_RFR(0x4fcc8900, "UmdmIssueCommand failed");
    }
    else

end:

	FL_LOG_EXIT(psl, tspRet);
	return tspRet;

}



TSPRETURN
CTspDev::mfn_OpenLLDev(
        DWORD fdwResources, // resources to addref
        DWORD dwMonitorFlags,
        BOOL fStartSubTask,
        HTSPTASK htspParentTask,
        DWORD dwSubTaskID,
        CStackLog *psl
        )
//
// It will load lldev if required, and up the ref count, and
// load pLLDev->pAipc2 if required and up its ref count, and
// start or queue a task to actualy init/monitor/start-aipc-server.
//
{
	FL_DECLARE_FUNC(0x6b8b6257, "CTspDev::mfn_OpenLLDev")
	FL_LOG_ENTRY(psl);
    TSPRETURN tspRet=0;

    //
    // The following indicate what sorts of resources are requested
    //
    BOOL fResLoadAIPC      =  0!=(fdwResources & LLDEVINFO::fRES_AIPC);
    BOOL fResMonitor       =  0!=(fdwResources & LLDEVINFO::fRESEX_MONITOR);

    LLDEVINFO *pLLDev = m_pLLDev;
    BOOL fLoadedLLDev = FALSE;
    BOOL fLoadedAIPC = FALSE;


    if (!pLLDev)
    {
        tspRet = mfn_LoadLLDev(psl);
        if (tspRet)
        {
            goto end;
        }
        else
        {
            pLLDev = m_pLLDev;
            fLoadedLLDev = TRUE;
        }
    }

    ASSERT(pLLDev);
    pLLDev->dwRefCount++;

    //
    // See if we can grant all the requested resources at this time...
    // Some of them are exclusive, others can't be granted if the device
    // is in a particular state...
    //
    {
        BOOL fResPassthrough   =  0!=(fdwResources & LLDEVINFO::fRESEX_PASSTHROUGH);
        BOOL fResUseLine       =  0!=(fdwResources & LLDEVINFO::fRESEX_USELINE);
        //
        // First check for exclusive resource usage...
        //
        if (   fdwResources
             & pLLDev->fdwExResourceUsage // &, not &&
             & fEXCLUSIVE_RESOURCE_MASK)  // &, not &&
        {
            FL_SET_RFR(0x68a4b900, "Can't get exclusive resource");
            goto fail_unload_lldev;
        }

        //
        // Then check for requests which can't be granted based on current
        // state.
        //
        if (fResPassthrough | fResUseLine)
        {
            // can't be using handset or streaming voice...
            if (pLLDev->IsHandsetOpen() ||  pLLDev->IsStreamingVoice())
            {
                FL_SET_RFR(0x34d29100, "Can't get some resource in this state");
                goto fail_unload_lldev;
            }
        }
    }



    // Load AIPC if required.
    if (fResLoadAIPC)
    {
        if (!pLLDev->pAipc2)
        {
            tspRet = mfn_LoadAipc(psl);
            if (tspRet)
            {
                ASSERT(!pLLDev->pAipc2);
                goto fail_unload_lldev;
            }
            else
            {
                fLoadedAIPC=TRUE;
                ASSERT(pLLDev->pAipc2);
            }
        }
        pLLDev->pAipc2->dwRefCount++;
    }

    //
    // Update resource usae...
    //
    pLLDev->fdwExResourceUsage |=  fdwResources & fEXCLUSIVE_RESOURCE_MASK;

    //
    // Save away monitor flags if needed.
    //
    if (fResMonitor)
    {
        m_pLLDev->dwMonitorFlags = dwMonitorFlags;
    }

    //
    // Start the task to enable the resources
    // if necessary...
    //

    if (fStartSubTask)
    {
        tspRet = mfn_StartSubTask (
                            htspParentTask,
                            &CTspDev::s_pfn_TH_LLDevNormalize,
                            dwSubTaskID,
                            0,
                            0,
                            psl
                            );
    }
    else
    {
        tspRet = mfn_StartRootTask(
                        &CTspDev::s_pfn_TH_LLDevNormalize,
                        &m_pLLDev->fLLDevTaskPending,
                        0,
                        0,
                        psl
                        );

        if (IDERR(tspRet) == IDERR_TASKPENDING)
        {
            // can't do this now, we've got to defer it!
            m_pLLDev->SetDeferredTaskBits(LLDEVINFO::fDEFERRED_NORMALIZE);
            tspRet = IDERR_PENDING;
        }
    }

    // Process synchronous failure...
    if (tspRet && IDERR(tspRet) != IDERR_PENDING)
    {
        // sync failure
        if (fResMonitor)
        {
            m_pLLDev->dwMonitorFlags = 0;
        }

        // Clear exclusive resources granted...
        pLLDev->fdwExResourceUsage &= ~(fdwResources&fEXCLUSIVE_RESOURCE_MASK);

        //
        // Unload AIPC if we loaded...
        //
        if (fResLoadAIPC)
        {
            ASSERT(pLLDev->pAipc2 && pLLDev->pAipc2->dwRefCount);
            pLLDev->pAipc2->dwRefCount--;
            if (fLoadedAIPC)
            {
                ASSERT(!pLLDev->pAipc2->dwRefCount);
                mfn_UnloadAipc(psl);
                ASSERT(!pLLDev->pAipc2);
            }
        }
    }
    else
    {
       goto end;
    }

    ASSERT(tspRet && IDERR(tspRet)!=IDERR_PENDING);

    // fallthrough on  failure ...

fail_unload_lldev:

    if (!tspRet) {
        //
        //  make sure we return a failure code.
        //
        tspRet = IDERR_GENERIC_FAILURE;
    }


    ASSERT(pLLDev && pLLDev->dwRefCount);
    pLLDev->dwRefCount--;
    if (fLoadedLLDev)
    {
        ASSERT(!pLLDev->dwRefCount);
        mfn_UnloadLLDev(psl);
        pLLDev = NULL;
        ASSERT(!m_pLLDev);
    }

end:

	FL_LOG_EXIT(psl, tspRet);

	return tspRet;
}


TSPRETURN
CTspDev::mfn_CloseLLDev(
        DWORD fdwResources, // resources to release
        BOOL fStartSubTask,
        HTSPTASK htspParentTask,
        DWORD dwSubTaskID,
        CStackLog *psl
        )
//
// Close decrements the refcount of lldev and if fdwResources contains
// LLDEVINFO::fRES_AIPC, the refcount of pLLDev->pAipc2.
//
// EVEN if the refcount of pAipc2 or pLLDev go to zero, it does not
// necessarily mean that they will be freed in this function call -- it
// could be that there is pending activity that must finish first before
// these objects can be freed -- in which case mfn_CloseLLDev will make
// sure that the activity is queued or deferred.
//
{
	FL_DECLARE_FUNC(0xb3025a91, "CTspDev::mfn_CloseLLDev")
	TSPRETURN tspRet = 0;
	LLDEVINFO *pLLDev = m_pLLDev;
    BOOL fLoadAIPC =  0!=(fdwResources & LLDEVINFO::fRES_AIPC);


    if (!pLLDev || !pLLDev->dwRefCount)
    {
        // this should never happen...
        ASSERT(FALSE);
        goto end;
    }

    //
    // Clear any exclusive requests specified
    //
    {
        DWORD fdwExRes =  fdwResources & fEXCLUSIVE_RESOURCE_MASK;

        //
        // Those resource which are supposed to be released had better
        // be enabled!
        //
        FL_ASSERT(psl, fdwExRes == (fdwExRes & pLLDev->fdwExResourceUsage));

        //
        // Clear them...
        //
        pLLDev->fdwExResourceUsage &= ~fdwExRes;
    }

    //
    // Decrement refcount of AIPC if specified
    //
    if (fLoadAIPC)
    {
    	//
    	// If the device is streaming we force it to stop
    	//
		if (pLLDev->IsStreamingVoice())
		{
               {
                    DWORD   BytesTransfered;

                    AIPC_PARAMS AipcParams;
                    LPREQ_WAVE_PARAMS pRWP = (LPREQ_WAVE_PARAMS)&AipcParams.Params;

                    AipcParams.dwFunctionID = AIPC_REQUEST_WAVEACTION;
                    pRWP->dwWaveAction = WAVE_ACTION_ABORT_STREAMING;

                    m_sync.LeaveCrit(dwLUID_CurrentLoc);

                    SyncDeviceIoControl(
                        m_pLLDev->hComm,
                        IOCTL_MODEM_SEND_LOOPBACK_MESSAGE,
                        (PUCHAR)&AipcParams,
                        sizeof(AipcParams),
                        NULL,
                        0,
                        &BytesTransfered
                        );

                    m_sync.EnterCrit(dwLUID_CurrentLoc);
                }


//    		[Insert stop streaming code here]
		}

        if (m_pLLDev->pAipc2 && m_pLLDev->pAipc2->dwRefCount) // lazy
        {
            m_pLLDev->pAipc2->dwRefCount--;
        }
        else
        {
            ASSERT(FALSE);
        }
    }

    //
    // Decrement refcount of the lldev structure itself...
    //
    m_LLDev.dwRefCount--;


    //
    // The TH_LLDevNormalize will stop the AIPC server if necessary,
    // as well as hangup and re-init and re-monitor if necessary.
    //
    // TH_LLDevNormalize will actually m_pLLDev->pAipc2 if its refcount
    // is zero.
    //
    // m_pLLDev itself will be unloaded not in TH_LLDevNormalize, but rather
    // mfn_TryStartLLDevTask.

	if (pLLDev->IsStreamingVoice())
	{
		//
		// We can't run normalize now because the modem is actively streaming.
		// We have to defer the normalization.
		//
		m_pLLDev->SetDeferredTaskBits(LLDEVINFO::fDEFERRED_NORMALIZE);
		tspRet = 0; // we return success here -- the normalization will
					// happen in the background.
	}
    else if (fStartSubTask)
    {
        tspRet = mfn_StartSubTask (
                            htspParentTask,
                            &CTspDev::s_pfn_TH_LLDevNormalize,
                            dwSubTaskID,
                            0,
                            0,
                            psl
                            );
    }
    else
    {
        tspRet = mfn_StartRootTask(
                        &CTspDev::s_pfn_TH_LLDevNormalize,
                        &m_pLLDev->fLLDevTaskPending,
                        0,
                        0,
                        psl
                        );

        if (IDERR(tspRet) == IDERR_TASKPENDING)
        {
            // can't do this now, we've got to defer it!
            m_pLLDev->SetDeferredTaskBits(LLDEVINFO::fDEFERRED_NORMALIZE);
            tspRet = IDERR_PENDING;
        }
    }

    //
    // Have to make sure that we DO unload on sync return, because on
    // sync return of the root task mfn_TryStartLLDevTask is not called.
    //
    // So we unload here if possible...
    //
    if (IDERR(tspRet)!=IDERR_PENDING && pLLDev->CanReallyUnload())
    {
        pLLDev = NULL;
        mfn_UnloadLLDev(psl);
        ASSERT(!m_pLLDev);
    }


end:

    return tspRet;
}


TSPRETURN
CTspDev::mfn_TryStartLLDevTask(CStackLog *psl)
//
// Called to see if any LLDev-related tasks need to be started....
// NOTE: MUST return IDERR_SAMESTATE if there are no tasks to run.
//
{
    ASSERT(m_pLLDev);
    LLDEVINFO *pLLDev = m_pLLDev;
    TSPRETURN tspRet = IDERR_SAMESTATE;
    
    if (!pLLDev->HasDeferredTasks())
    {
        // Check if we can unload...
        if (pLLDev->CanReallyUnload())
        {
            pLLDev = NULL;
            mfn_UnloadLLDev(psl);
            ASSERT(!m_pLLDev);
            tspRet = 0;
        }
        goto end;
    }

    //
    // If there is a deferred NORMALIZE request, and we
    // are able
    //
    if (pLLDev->AreDeferredTaskBitsSet(LLDEVINFO::fDEFERRED_NORMALIZE))
    {
        if (!m_pLLDev->IsStreamingVoice())
        {
            pLLDev->ClearDeferredTaskBits(LLDEVINFO::fDEFERRED_NORMALIZE);
            tspRet = mfn_StartRootTask(
                            &CTspDev::s_pfn_TH_LLDevNormalize,
                            &m_pLLDev->fLLDevTaskPending,
                            0,
                            0,
                            psl
                            );
        }
    }

    if (IDERR(tspRet) == IDERR_PENDING) goto end;

    //
    // Any other LLDEVINFO deferred tasks...
    //

    //
    // If there is a deferred hybrid-wave-action request, we
    // execute it...
    //
    if (pLLDev->AreDeferredTaskBitsSet(LLDEVINFO::fDEFERRED_HYBRIDWAVEACTION))
    {
        DWORD dwParam = pLLDev->dwDeferredHybridWaveAction;
        pLLDev->dwDeferredHybridWaveAction=0;
        pLLDev->ClearDeferredTaskBits(LLDEVINFO::fDEFERRED_HYBRIDWAVEACTION);

        tspRet = mfn_StartRootTask(
                        &CTspDev::s_pfn_TH_LLDevHybridWaveAction,
                        &m_pLLDev->fLLDevTaskPending,
                        dwParam,
                        0,
                        psl
                        );
    }

    if (IDERR(tspRet) == IDERR_PENDING) goto end;

    //
    // Any other LLDEVINFO deferred tasks...
    //
end:

    //
    // Heading out of here...
    // IDERR_SAMESTATE implies that we couldn't start a task this time.
    // IDERR_PENDING implies we started a task and it's pending.
    // Any other value for tspRet implies we started and completed a task.
    //
    //
    // NOTE: m_pLLDev could be NULL now...
    //

    ASSERT(   (IDERR(tspRet)==IDERR_PENDING && m_uTaskDepth)
           || (IDERR(tspRet)!=IDERR_PENDING && !m_uTaskDepth));

    return tspRet;
}


TSPRETURN
CTspDev::mfn_TH_LLDevNormalize(
                    HTSPTASK htspTask,
                    TASKCONTEXT *pContext,
                    DWORD dwMsg,
                    ULONG_PTR dwParam1,
                    ULONG_PTR dwParam2,
                    CStackLog *psl
                    )
//
//  START_MSG Params: None
//
{
	FL_DECLARE_FUNC(0x340a07a4, "CTspDev::mfn_TH_LLDevNormalize")
	FL_LOG_ENTRY(psl);
	TSPRETURN  tspRet=FL_GEN_RETVAL(IDERR_INVALID_ERR);
    DWORD dwRet = 0;
    LLDEVINFO *pLLDev = m_pLLDev;
    BOOL fSkipDiagnostics = FALSE;

    //
    // Setup local context.
    //
    BOOL *fDoInit = (BOOL*) &(pContext->dw0);
    char **pszzNVInitCommands = (char**) &(pContext->dw1);

    if (!pLLDev)
    {
        ASSERT(FALSE);
        goto end;
    }

    enum {
        NORMALIZE_PASSTHROUGHOFF,
        NORMALIZE_HANGUP,
        NORMALIZE_GETDIAGNOSTICS,
        NORMALIZE_STOP_AIPC,
        NORMALIZE_INIT,
        NORMALIZE_NVRAM_INIT,
        NORMALIZE_MONITOR,
        NORMALIZE_START_AIPC,
        NORMALIZE_PASSTHROUGHON,
    };

    switch(dwMsg)
    {
    case MSG_START:
        goto start;

	case MSG_SUBTASK_COMPLETE:
        tspRet = dwParam2;
        switch(dwParam1) // Param1 is Subtask ID
        {
        case NORMALIZE_PASSTHROUGHOFF:      goto passthroughoff_complete;
        case NORMALIZE_HANGUP:              goto hangup_complete;
        case NORMALIZE_GETDIAGNOSTICS:      goto getdiagnostics_complete;
        case NORMALIZE_STOP_AIPC:           goto stop_aipc_complete;
        case NORMALIZE_INIT:                goto init_complete;
        case NORMALIZE_NVRAM_INIT:          goto nvram_init_complete;
        case NORMALIZE_MONITOR:             goto monitor_complete;
        case NORMALIZE_START_AIPC:          goto start_aipc_complete;
        case NORMALIZE_PASSTHROUGHON:       goto passthroughon_complete;

        default:
            ASSERT(FALSE);
            goto end;
        }
        break;

    case MSG_DUMPSTATE:
        tspRet = 0;
        goto end;

    default:
        ASSERT(FALSE);
        tspRet=IDERR_CORRUPT_STATE;
        goto end;
    }

    ASSERT(FALSE);

start:

    // Note if the device is removed (pLLDev->IsDeviceRemoved()) we still
    // continue with the motions -- the lower-level functions will fail
    // synchronously if the device is removed.

    tspRet = 0;

    //
    // Following are for NVRam Init -- fDoInit is set if we need to init,
    // and *pszzNVInitCommands is set to a multisz ascii string of commandws.
    //
    *fDoInit = FALSE;
    *pszzNVInitCommands = NULL;

    //
    // If we need to, we go out of passthrough...
    //
    if (pLLDev->IsPassthroughOn() && !pLLDev->IsPassthroughRequested())
    {

        tspRet = mfn_StartSubTask (
                            htspTask,
                            &s_pfn_TH_LLDevUmSetPassthroughMode,
                            NORMALIZE_PASSTHROUGHOFF,
                            PASSTHROUUGH_MODE_OFF,
                            0,
                            psl
                            );
    }

    if (IDERR(tspRet)==IDERR_PENDING) goto end;

passthroughoff_complete:

    //
    // ignore error..
    //
    tspRet = 0;

    //
    // If we need to, we hangup the modem
    //
    if (pLLDev->IsLineOffHook() && !pLLDev->IsLineUseRequested())
    {

        tspRet = mfn_StartSubTask (
                            htspTask,
                            &CTspDev::s_pfn_TH_LLDevUmHangupModem,
                            NORMALIZE_HANGUP,
                            0,
                            0,
                            psl
                            );
    }
    else
    {
        fSkipDiagnostics = TRUE;
    }


    if (IDERR(tspRet)==IDERR_PENDING) goto end;

hangup_complete:

    // ignore error...
    tspRet = 0;

    //
    // If we're asked to, try to get call diagnostics ...
    // Note: we refer to m_pLine and m_pLine->pCall  here -- Since this
    // is an lldev task, we should not assume that these things are
    // going to be preserved across async stages, so always verify
    // that they still exist. This means that TH_LLDevUmGetDiagnostics
    // should also make sure that m_pLine and m_pLine->pCall are
    // still around after the async operation completes...
    //
    //
    if (    !fSkipDiagnostics
         && m_pLine
         && m_pLine->pCall
         && mfn_IsCallDiagnosticsEnabled())
    {
        tspRet = mfn_StartSubTask (
                            htspTask,
                            &CTspDev::s_pfn_TH_LLDevUmGetDiagnostics,
                            NORMALIZE_GETDIAGNOSTICS,
                            0,
                            0,
                            psl
                            );
    }

    if (IDERR(tspRet)==IDERR_PENDING) goto end;

getdiagnostics_complete:

    // ignore error...
    tspRet = 0;

    //
    // If required, go out of AIPC
    //
    if (   pLLDev->pAipc2
        && pLLDev->pAipc2->IsStarted()
        && !pLLDev->pAipc2->dwRefCount)
    {
        ASSERT(!pLLDev->IsStreamingVoice());

        tspRet = mfn_StartSubTask (
                            htspTask,
                            &CTspDev::s_pfn_TH_LLDevStopAIPCAction,
                            NORMALIZE_STOP_AIPC,
                            0,  // dwParam1 (unused)
                            0,  // dwParam2 (unused)
                            psl
                            );
    }

    if (IDERR(tspRet)==IDERR_PENDING) goto end;

stop_aipc_complete:

    // ignore error ...
    tspRet = 0;

    //
    // Actually unload AIPC if its ref count is zero.
    //
    // Note that it's quite possible that while waiting for the above
    // pending operation to complete some other thread has 
    // called mfn_OpenLLDev specifying it wants AIPC, in which case
    // pLLDev->pAipc2->dwRefCount would be back up again!
    //
    if (   pLLDev->pAipc2
        && !pLLDev->pAipc2->dwRefCount)
    {
        mfn_UnloadAipc(psl);
        ASSERT(!pLLDev->pAipc2);
    }

    //
    // See if it makes sense to init and monitor the modem ....
    //
    // Note that if HangupModem above failed, the state could still
    // be OFFHOOK, so we shouldn't necessarily skip Init if the state is 
    // offhook -- instead we check m_pLLDev->IsLineUseRequested().
    //
    // 1/31/1998 JosephJ above comment is wrong -- we now make
    // HangupModem always set the state to ONHOOK on completion.
    //
    if (
           // !m_pLLDev->IsLineUseRequested()
           m_pLLDev->IsLineOffHook()
        || m_pLLDev->IsStreamingVoice()
        || m_pLLDev->IsPassthroughOn()
        || m_pLLDev->IsHandsetOpen()
        )
    {
        // NAH -- skip em...
        goto monitor_complete;
    }


    //
    // If required, initialize the modem.
    //
    if (   !m_pLLDev->IsModemInited()
        && m_pLLDev->dwRefCount )
    {
        *fDoInit = TRUE;
        tspRet = mfn_StartSubTask (
                            htspTask,
                            &CTspDev::s_pfn_TH_LLDevUmInitModem,
                            NORMALIZE_INIT,
                            0,  // dwParam1 (unused)
                            0,  // dwParam2 (unused)
                            psl
                            );
    }
      
init_complete:

    if (tspRet) goto end;

    // From now on, fail on error...

    //
    // If required, prepare and issue the NVRAM Init sequence. This
    // is done only if the NVRAM settings need to be reset -- either because
    // the static configuration has changed or because this is the first time
    // we're initing this modem after the machine was rebooted.
    //
    // TODO: Move this logic into the mini driver.
    //
    if (*fDoInit)
    {
        //
        // 1st: find out if we need to do this, and if so
        //      construct the multisz string representing the NV-Init commands.
        //      If the following function returns non-NULL, it implies that
        //      we need to init, and MOREOVER, the function has set the
        //      registry to indicate that we've picked up the nvram init
        //      commands. This indicates that we must restore the 
        //      "nvram-inited" state on failure. We do things this way because
        //      it's possible that the static configuration is changed WHILE
        //      we're executing the nv-ram init commands, in which case we'd
        //      want to re-init: if we waited till after the nv-init state
        //      to set the "nv-inited" bit, we'll miss the config change.
        //
        if (mfn_NeedToInitNVRam())
        {
            //OutputDebugString(TEXT("NVRAM STALE -- NEED TO INIT\r\n"));
            
            mfn_ClearNeedToInitNVRam();
            *pszzNVInitCommands =  mfn_TryCreateNVInitCommands(psl);
            if (*pszzNVInitCommands)
            {
                //OutputDebugString(TEXT("BEGIN NVRAM INIT\r\n"));
                tspRet = mfn_StartSubTask (
                                htspTask,
                                &CTspDev::s_pfn_TH_LLDevIssueMultipleCommands,
                                NORMALIZE_NVRAM_INIT,
                                (ULONG_PTR) *pszzNVInitCommands,  // dwParam1
                                15000,  // dwParam2 (timeout)
                                        // we put an extra long, but hardcoded,
                                        // command here because some of these
                                        // nv-init related commands can be
                                        // quite long.
                                psl
                                );
                if (IDERR(tspRet)==IDERR_PENDING) goto end;
            }
        }
        else
        {
            //OutputDebugString(TEXT("NVRAM UP-TO-DATE -- NOT INITING\r\n"));
        }
    }
    
nvram_init_complete:


    //
    // If there was an nvinit string, we free it here, and on success,
    // mark the volatile key in the registry so we don't issue the NVRAM
    // init until reboot or the static configuration is changed.
    //
    if (*pszzNVInitCommands)
    {
        FREE_MEMORY(*pszzNVInitCommands);
        *pszzNVInitCommands=NULL;
        
        if (tspRet)
        {
            //
            // Since there was a problem, we must make a note in the registry
            // that the nvram was not inited, as well as reset our internal
            // state.
            //
            mfn_SetNeedToInitNVRam();
            HKEY hKey=NULL;
            DWORD dwRet =  RegOpenKeyA(
                                HKEY_LOCAL_MACHINE,
                                m_StaticInfo.rgchDriverKey,
                                &hKey
                                );
            if (dwRet==ERROR_SUCCESS)
            {
                //
                // Clear the volatile value, indicating that we've NOT read
                // the commands...
                //
                set_volatile_key(hKey, 0);
                RegCloseKey(hKey);
                hKey=NULL;
            }
        }
    }

    //
    // Fail on error...
    //
    if (tspRet) goto end;

    //
    // If required, monitor the modem
    //
    if (
            m_pLLDev->IsMonitorRequested()
        && !pLLDev->IsCurrentlyMonitoring())
    {
        tspRet = mfn_StartSubTask (
                            htspTask,
                            &CTspDev::s_pfn_TH_LLDevUmMonitorModem,
                            NORMALIZE_MONITOR,
                            pLLDev->dwMonitorFlags,  // dwParam1
                            0,                       // dwParam2 (unused)
                            psl
                            );
    }

monitor_complete:

    if (tspRet) goto end;

    //
    // If required, start AIPC
    //

    // If we need to, we start the AIPC service...
    if (   pLLDev->pAipc2
        && !pLLDev->pAipc2->IsStarted()
        && pLLDev->pAipc2->dwRefCount)
    {
        tspRet = mfn_StartSubTask (
                            htspTask,
                            &CTspDev::s_pfn_TH_LLDevStartAIPCAction,
                            NORMALIZE_START_AIPC,
                            0,  // dwParam1 (unused)
                            0,  // dwParam2 (unused)
                            psl
                            );
    }

start_aipc_complete:

    if (tspRet) goto end;

    //
    // If we need to, we switch into passthrough...
    //
    if (!pLLDev->IsPassthroughOn() && pLLDev->IsPassthroughRequested())
    {

        tspRet = mfn_StartSubTask (
                            htspTask,
                            &s_pfn_TH_LLDevUmSetPassthroughMode,
                            NORMALIZE_PASSTHROUGHOFF,
                            PASSTHROUUGH_MODE_ON,
                            0,
                            psl
                            );
    }

passthroughon_complete:

end:

    if (tspRet && IDERR(tspRet)!=IDERR_PENDING)
    {
        // Failure...

        // Treat this like a hw error...
        mfn_ProcessHardwareFailure(psl);
    }

	FL_LOG_EXIT(psl, tspRet);
	return tspRet;
}


TSPRETURN
CTspDev::mfn_TH_LLDevIssueMultipleCommands(
                    HTSPTASK htspTask,
                    TASKCONTEXT *pContext,
                    DWORD dwMsg,
                    ULONG_PTR dwParam1,
                    ULONG_PTR dwParam2,
                    CStackLog *psl
                    )
//
//  START_MSG Params:
//      dwParam1 == multisz ASCII string of ready-to-issue commands.
//      dwParam2 == Per-command timeout.
//
{
	FL_DECLARE_FUNC(0xb9e3037c, "CTspDev::mfn_TH_LLDevIssueMultipleCommands")
	FL_LOG_ENTRY(psl);
	TSPRETURN  tspRet = IDERR_CORRUPT_STATE;
    DWORD dwRet = 0;
    LLDEVINFO *pLLDev = m_pLLDev;
    BOOL fSkipDiagnostics = FALSE;

    //
    // Context Variables...
    //
    LPSTR *ppCurrentCommand  =  (LPSTR*)  &(pContext->dw0);
    DWORD *pdwTimeout        =  (DWORD*)  &(pContext->dw1);


    if (!pLLDev)
    {
        ASSERT(FALSE);
        goto end;
    }

    enum {
        COMMAND_COMPLETE
    };

    switch(dwMsg)
    {
    case MSG_START:
        goto start;

	case MSG_SUBTASK_COMPLETE:

        if (pLLDev->IsDeviceRemoved())
        {
            tspRet = IDERR_DEVICE_NOTINSTALLED;
            FL_SET_RFR(0xbafd3300, "Device not present.");
            goto end;
        }

        tspRet = dwParam2;
        switch(dwParam1) // Param1 is Subtask ID
        {
        case COMMAND_COMPLETE:             goto command_complete;

        default:
            ASSERT(FALSE);
            goto end;
        }
        break;

    case MSG_DUMPSTATE:
        tspRet = 0;
        goto end;

    default:
        ASSERT(FALSE);
        goto end;
    }

    ASSERT(FALSE);

start:

    if (pLLDev->IsDeviceRemoved())
    {
        tspRet = IDERR_DEVICE_NOTINSTALLED;
        FL_SET_RFR(0xf903a800, "Device not present.");
        goto end;
    }

    //
    // Save context...
    //
    //  ppCurrentCommand is initialized to the start of the multisz string
    //  passed in as dwParam1 at the start of the task. After each command
    //  executes, ppCurrentCommand is set to the next string in the multisz
    //  string.
    //
    *ppCurrentCommand = (LPSTR) dwParam1;
    *pdwTimeout       = (DWORD)dwParam2; // dwParam2 is the per-command timeout.
    tspRet = 0;

    if (!*ppCurrentCommand || !**ppCurrentCommand)
    {
        // null command list or empty command list -- we're done...
        goto end;
    }

do_next_command:

    ASSERT(*ppCurrentCommand && **ppCurrentCommand);

    tspRet = mfn_StartSubTask (
                        htspTask,
                        &CTspDev::s_pfn_TH_LLDevUmIssueCommand,
                        COMMAND_COMPLETE,
                        (ULONG_PTR) *ppCurrentCommand,  // dwParam1 (cmd)
                        *pdwTimeout,  // dwParam2 (timeout)
                        psl
                        );

    //
    // Now move the ppCurrentCommand pointer to the next string in the
    // list of multi-sz string.
    //
    *ppCurrentCommand += lstrlenA(*ppCurrentCommand)+1;

    
command_complete:

    if (!tspRet && **ppCurrentCommand)
    {
        //
        // On success, move to the next command if there are more commands left
        // (we're not at the end of the multisz string).
        //
        goto do_next_command;
    }

end:

    if (tspRet && IDERR(tspRet)!=IDERR_PENDING)
    {
        // Failure...

        // Treat this like a hw error...
        mfn_ProcessHardwareFailure(psl);
    }

	FL_LOG_EXIT(psl, tspRet);
	return tspRet;
}


char *
CTspDev::mfn_TryCreateNVInitCommands(CStackLog *psl)
//
//  Checks if we need to do an nv-ram init, and if so, builds a multisz
//  asci string of commands.
//
//  It is the caller's responsibility to FREE_MEMORY the returned
//  value.
{
    char *szzCommands = NULL;

#if 0  // test

    if (0)
    {
        char rgTmp[] = "ATE0V1\r\0ATE0E0V1\r\0ATE0E0E0V1\r\0";
        szzCommands = (char*)ALLOCATE_MEMORY(sizeof(rgTmp));
    
        if (szzCommands)
        {
            CopyMemory(szzCommands, rgTmp, sizeof(rgTmp));
        }

        goto end;
    }

#else // 1

    // OK -- let's pick up the commands from the NVInit section.

    HKEY hKey=NULL;
    UINT cCommands = 0;
    DWORD dwRet =  RegOpenKeyA(
                        HKEY_LOCAL_MACHINE,
                        m_StaticInfo.rgchDriverKey,
                        &hKey
                        );
    if (dwRet==ERROR_SUCCESS)
    {
        cCommands = ReadCommandsA(
                            hKey,
                            "NVInit", // pSubKeyName
                            &szzCommands
                            );

        //
        // Set the volatile value, indicating that we've read
        // the commands...
        // Later, if when executing the commands we run into a problem,
        // we'll reset this value to 0.
        // In between, if the use changes the config in the cpl, the value
        // could also be set to 0.
        //
        set_volatile_key(hKey, 1);

        RegCloseKey(hKey);
        hKey=NULL;

        if (cCommands)
        {
            //OutputDebugString(TEXT("PICKED UP NVRAM COMMANDS\r\n"));
            expand_macros_in_place(szzCommands);
        }
        else
        {
            /*OutputDebugString(
                TEXT("COULD NOT GET ANY NVRAM COMMANDS FROM REGISTRY\r\n")
                );*/
            szzCommands=NULL;
        }
    }
    else
    {
        /*OutputDebugString(
            TEXT("COULD NOT GET ANY NVRAM COMMANDS FROM REGISTRY(2)\r\n")
            );*/
    }

#endif // 1

    return szzCommands;
}


void
set_volatile_key(HKEY hkParent, DWORD dwValue)
{
    HKEY hkVolatile =  NULL;
    DWORD dwDisp = 0;
    DWORD dwRet   = RegCreateKeyEx(
                        hkParent,
                        TEXT("VolatileSettings"),
                        0,
                        NULL,
                        0, // dwToRegOptions
                        KEY_ALL_ACCESS,
                        NULL,
                        &hkVolatile,
                        &dwDisp
                        );
    //
    // (Don't do anything if the key doesn't exist or on error.)
    //

    if (dwRet==ERROR_SUCCESS)
    {
        // Set NVInited to 1.

        RegSetValueEx(
            hkVolatile,
            TEXT("NVInited"),
            0,
            REG_DWORD, 
            (LPBYTE)(&dwValue),
            sizeof(dwValue)
            );
        RegCloseKey(hkVolatile);
        hkVolatile=NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\tsp\cdevline.cpp ===
// 
// Copyright (c) 1996-1997 Microsoft Corporation.
//
//
// Component
//
//		Unimodem 5.0 TSP (Win32, user mode DLL)
//
// File
//
//		CDEVLINE.CPP
//		Implements line-related functionality  of class CTspDev
//
// History
//
//		01/24/1997  JosephJ Created
//
//
#include "tsppch.h"
#include <mmsystem.h>
#include "tspcomm.h"
#include "cmini.h"
#include "cdev.h"
#include "ParsDiag.h"		// parsing functions
LONG BuildParsedDiagnostics(LPVARSTRING lpVarString);

FL_DECLARE_FILE(0x04a097ae, "Line-related functionality of class CTspDev")


// Ascii versions of device class names,
// for returning in lineGetID's varstring.
//
const char cszCLASS_TAPI_LINE_A[]   =  "tapi/line";
const char cszCLASS_COMM_A[]        =  "comm";
const char cszCLASS_COMM_DATAMODEM_A[] =  "comm/datamodem";
const char cszCLASS_COMM_DATAMODEM_PORTNAME_A[]
                                    = "comm/datamodem/portname";
const char cszCLASS_NDIS[]        = "ndis";

const char cszCLASS_WAVE_IN[] = "wave/in";
const char cszCLASS_WAVE_OUT[] = "wave/out";
const char cszCLASS_TAPI_PHONE[] = "tapi/phone";

const char cszATTACHED_TO[]        = "AttachedTo";
const char cszPNP_ATTACHED_TO[]        = "PnPAttachedTo";

// Wide char versions (unicode only)
//
#ifdef UNICODE

    const TCHAR ctszCLASS_TAPI_LINE[] =  TEXT("tapi/line");
    const TCHAR ctszCLASS_COMM[] =  TEXT("comm");
    const TCHAR ctszCLASS_COMM_DATAMODEM[] =  TEXT("comm/datamodem");
    const TCHAR ctszCLASS_COMM_DATAMODEM_PORTNAME[]
                                         = TEXT("comm/datamodem/portname");
    const TCHAR ctszCLASS_NDIS[] = TEXT("ndis");

    const TCHAR ctszCLASS_WAVE_IN[]     = TEXT("wave/in");
    const TCHAR ctszCLASS_WAVE_OUT[]    = TEXT("wave/out");
    const TCHAR ctszCLASS_TAPI_PHONE[]  = TEXT("tapi/phone");

#else //!UNICODE

    #define ctszCLASS_TAPI_LINE_A cszCLASS_TAPI_LINE_A
    #define ctszCLASS_COMM_A cszCLASS_COMM_A
    #define ctszCLASS_COMM_DATAMODEM_A cszCLASS_COMM_DATAMODEM_A
    #define ctszCLASS_COMM_DATAMODEM_PORTNAME_A \
                                         cszCLASS_COMM_DATAMODEM_PORTNAME_A
    #define ctszCLASS_NDIS cszCLASS_NDIS

    #define ctszCLASS_WAVE_IN[]     = TEXT("wave/in");
    #define ctszCLASS_WAVE_OUT[]    = TEXT("wave/out");
    #define ctszCLASS_TAPI_PHONE[]  = TEXT("tapi/phone");

#endif //!UNICODE



LONG
CTspDev::mfn_monitor(
	DWORD dwMediaModes,
    CStackLog *psl
	)
// Changes monitoring state.
//
//
{
	FL_DECLARE_FUNC(0x3b2c98e4, "CTspDev::mfn_monitor")
	LONG lRet = 0;
	FL_LOG_ENTRY(psl);


    // Check the requested modes. There must be only our media modes.
    if (dwMediaModes & ~m_StaticInfo.dwDefaultMediaModes)
    {
    	FL_SET_RFR(0x0037c000, "Invalid mediamode");
        lRet = LINEERR_INVALMEDIAMODE;
	    goto end;
  	}

    // In addition, don't allow INTERACTIVEVOICE to be used for listening
    // unless modem doesn't  override handset (true for some voice modems).
    if (dwMediaModes & LINEMEDIAMODE_INTERACTIVEVOICE)
    {
        if (mfn_ModemOverridesHandset())
        {
            FL_SET_RFR(0xdeb9ec00, "Can't answer INTERACTIVEVOICE calls");
            lRet = LINEERR_INVALMEDIAMODE;
            goto end;
        }
    }


    if (m_pLine->dwDetMediaModes == dwMediaModes)
    {
    	FL_SET_RFR(0xa19f8100, "no change in det media modes");
        goto end;
    }

    if (!dwMediaModes)
    {
        // STOP MONITORING

        if (m_pLine->IsOpenedLLDev())
        {
            // ignore failure of mfn_CloseLLDev.

            mfn_CloseLLDev(
                        LLDEVINFO::fRESEX_MONITOR,
                        FALSE,
                        NULL,
                        0,
                        psl
                        );
            m_pLine->ClearStateBits(LINEINFO::fLINE_OPENED_LLDEV);
        }
    
        FL_SET_RFR(0x3c7fef00, "Closed LLDev from Line");
        m_pLine->dwDetMediaModes =  0;
    }
    else
    {
        if (m_pLine->dwDetMediaModes != 0) {
            //
            //  already monitoring, just set the new media modes
            //
            FL_SET_RFR(0xd23f4c00, "no change in det media modes");
            m_pLine->dwDetMediaModes =  dwMediaModes;
            goto end;
        }


        // START MONITORING

        DWORD dwLLDevMonitorFlags = MONITOR_FLAG_CALLERID;

        // Translate TAPI's idea of monitor modes into Mini-driver
        // monitor mode flags.... (Note: NT4.0 tsp used dwDetMediaModes
        // just for book keeping). NT5.0 supports voice in addition to data,
        // so mini driver needs to be told which.
        //
        if (dwMediaModes & LINEMEDIAMODE_AUTOMATEDVOICE)
        {
            dwLLDevMonitorFlags |=  MONITOR_VOICE_MODE;
            // TODO: MONITOR_FLAG_DISTINCTIVE_RING
            // TODO: deal with the case that both data and voice are
            // being monitored!
        }


        // If we need to, we open the modem device.
        // mfn_OpenLLDev keeps a ref count so ok to call if already loaded.

        TSPRETURN tspRet =  mfn_OpenLLDev(
                                LLDEVINFO::fRESEX_MONITOR,
                                dwLLDevMonitorFlags,
                                FALSE,          // fStartSubTask
                                NULL,
                                0,
                                psl
                                );
    
        if (!tspRet  || IDERR(tspRet)==IDERR_PENDING)
        {
            m_pLine->SetStateBits(LINEINFO::fLINE_OPENED_LLDEV);
            m_pLine->dwDetMediaModes =  dwMediaModes;
        }
        else
        {
            lRet = LINEERR_OPERATIONFAILED;
        }
        
    }

end:

	FL_LOG_EXIT(psl, 0);
	return lRet;
}



void
CTspDev::mfn_accept_tsp_call_for_HDRVLINE(
	DWORD dwRoutingInfo,
	void *pvParams,
	LONG *plRet,
	CStackLog *psl
	)
{
	FL_DECLARE_FUNC(0xe41274db, "CTspDev::mfn_accept_tsp_call_for_HDRVLINE")
	FL_LOG_ENTRY(psl);
    TSPRETURN tspRet=0; // Assume success
    LONG lRet = 0;
    LINEINFO *pLine = m_pLine;

	ASSERT(pLine);


	switch(ROUT_TASKID(dwRoutingInfo))
	{

	case TASKID_TSPI_lineClose:
		{
			mfn_UnloadLine(psl);
		}
		break;

	case TASKID_TSPI_lineGetNumAddressIDs:
		{
			TASKPARAM_TSPI_lineGetNumAddressIDs *pParams = 
						(TASKPARAM_TSPI_lineGetNumAddressIDs *) pvParams;
			ASSERT(pParams->dwStructSize ==
				sizeof(TASKPARAM_TSPI_lineGetNumAddressIDs));
			ASSERT(pParams->dwTaskID == TASKID_TSPI_lineGetNumAddressIDs);

			// Unimodem TSP supports on one address by default.
			//
			*pParams->lpdwNumAddressIDs = 1;
			
		}
		break;


	case TASKID_TSPI_lineSetDefaultMediaDetection:

		{
			TASKPARAM_TSPI_lineSetDefaultMediaDetection *pParams = 
					(TASKPARAM_TSPI_lineSetDefaultMediaDetection *) pvParams;
			ASSERT(pParams->dwStructSize ==
				sizeof(TASKPARAM_TSPI_lineSetDefaultMediaDetection));
			ASSERT(pParams->dwTaskID==TASKID_TSPI_lineSetDefaultMediaDetection);

			lRet = mfn_monitor(pParams->dwMediaModes, psl);
			
		}
		break;

	case TASKID_TSPI_lineMakeCall:


		{



			TASKPARAM_TSPI_lineMakeCall *pParams = 
					(TASKPARAM_TSPI_lineMakeCall *) pvParams;
            PFN_CTspDev_TASK_HANDLER *ppfnHandler = NULL;
			ASSERT(pParams->dwStructSize ==
				sizeof(TASKPARAM_TSPI_lineMakeCall));
			ASSERT(pParams->dwTaskID==TASKID_TSPI_lineMakeCall);


            // Check if we are in a position to make a call, i.e., no call
            //  currently active.

            // TODO: deal with deferring the call if a task is in progress, eg.,
            // initializing and monitoring the line...

            if (pLine->pCall)
            {
                FL_SET_RFR(0xce944f00, "Call already exists/queued");
                lRet = LINEERR_CALLUNAVAIL;
                goto end;
            }

            // Allocate a call...
            tspRet = mfn_LoadCall(pParams, &lRet, psl);
            if (tspRet || lRet) goto end;

            // Choose the appropriate task handler for the call type
            //
            ppfnHandler = (pLine->pCall->IsPassthroughCall())
                         ?  &(CTspDev::s_pfn_TH_CallMakePassthroughCall)
                         :  &(CTspDev::s_pfn_TH_CallMakeCall);

            // We set the call handle to be the same as the line handle.
            //
            *(pParams->lphdCall) = (HDRVCALL) pParams->hdLine;

	        tspRet = mfn_StartRootTask(
                                ppfnHandler,
                                &pLine->pCall->fCallTaskPending,
                                pParams->dwRequestID, // Param1
                                0,
								psl
								);

            if (!tspRet || (IDERR(tspRet)==IDERR_PENDING))
            {
                // One either synchronous success of pending, we return the
                // request ID to TAPI. In the synchronous success case
                // the task we started above will already have notified
                // completion via the TAPI callback function.
                //
                tspRet = 0;
                lRet = pParams->dwRequestID;
            }
            else if (IDERR(tspRet)==IDERR_TASKPENDING)
            {
                //
                // Oops -- some other task is going on,
                // we'll defer this call...
                //
                pLine->pCall->SetDeferredTaskBits(
                        CALLINFO::fDEFERRED_TSPI_LINEMAKECALL
                        );
                pLine->pCall->dwDeferredMakeCallRequestID =pParams->dwRequestID;
                tspRet = 0;
                lRet = pParams->dwRequestID;
            }
            else if (m_pLine->pCall)
            {
                // Sync failure
                // We could get here if mfn_StartRootTask fails for some
                // reason...
                //
                mfn_UnloadCall(FALSE, psl);
            }
        }
		break; // end case TASKID_TSPI_lineMakeCall


	case TASKID_TSPI_lineGetID:
		{
		    UINT idClass = 0;
			TASKPARAM_TSPI_lineGetID *pParams = 
						(TASKPARAM_TSPI_lineGetID *) pvParams;
			ASSERT(pParams->dwStructSize ==
				sizeof(TASKPARAM_TSPI_lineGetID));
			ASSERT(pParams->dwTaskID == TASKID_TSPI_lineGetID);
            LPCTSTR lpszDeviceClass = pParams->lpszDeviceClass;
            HANDLE hTargetProcess = pParams->hTargetProcess;
            LPVARSTRING lpDeviceID = pParams->lpDeviceID;
            DWORD cbMaxExtra =  0;
            DWORD dwDeviceClass =  parse_device_classes(
                                    lpszDeviceClass,
                                    FALSE);

            // Do some rudimentary parameter validation...
            //
            lRet = 0;
            switch (pParams->dwSelect)
            {
            case LINECALLSELECT_ADDRESS:

                if (pParams->dwAddressID != 0)
                {
                    lRet =  LINEERR_INVALADDRESSID;
                }
                break;
            
            case LINECALLSELECT_LINE:

                // Nothing to check..
                break;
            
            case LINECALLSELECT_CALL:

                // Note by convention we set hdCall to be the same as
                // hdLine.
                //
	            if (pParams->hdCall != (HDRVCALL)pLine->hdLine || !pLine->pCall)
                {
                  lRet = LINEERR_INVALCALLHANDLE;
                }
                break;
            
            default:

                lRet = LINEERR_OPERATIONFAILED;
                break;

            }

            // 2/12/1997 JosephJ
            //     Added these checks which weren't in NT4.0.
            //     Note that to emulate NT4.0 behaviour, we should NOT return
            //     error is the structure is too small to add the variable part.
            //     Instead we should  set dwNeededSize to the required value,
            //     dwStringSize to zero, and return success.
            //
            //     NT4.0 lineGetID was quite botched up in terms of handling
            //     the sizes. For example, it assumed that dwUsedSize was set.
            //     on entry.
            //
            if (lpDeviceID->dwTotalSize < sizeof(VARSTRING))
            {
                lRet = LINEERR_STRUCTURETOOSMALL;
            }

			if (lRet)
			{
		        FL_SET_RFR(0x86b03000, "Invalid params");
                goto end;
			}

            // This is new for NT5.0

            lpDeviceID->dwNeededSize    = sizeof(VARSTRING);
            lpDeviceID->dwStringOffset  = sizeof(VARSTRING);
            lpDeviceID->dwUsedSize      = sizeof(VARSTRING);
            lpDeviceID->dwStringSize    = 0;
            cbMaxExtra =  lpDeviceID->dwTotalSize - sizeof(VARSTRING);

            switch(dwDeviceClass)
            {
            case DEVCLASS_TAPI_LINE:
			    lRet = mfn_linephoneGetID_TAPI_LINE(
                                        lpDeviceID,
                                        hTargetProcess,
                                        cbMaxExtra,
                                        psl
                                        );
                break;

            case DEVCLASS_TAPI_PHONE:
                lRet = mfn_linephoneGetID_TAPI_PHONE(
                                lpDeviceID,
                                hTargetProcess,
                                cbMaxExtra,
                                psl
                                );
                break;

            case DEVCLASS_COMM:
			    lRet = mfn_lineGetID_COMM(
                                lpDeviceID,
                                hTargetProcess,
                                cbMaxExtra,
                                psl
                                );
                break;

            case DEVCLASS_COMM_DATAMODEM:
			    lRet = mfn_lineGetID_COMM_DATAMODEM(
                                lpDeviceID,
                                hTargetProcess,
                                cbMaxExtra,
                                psl
                                );
                break;

            case DEVCLASS_COMM_DATAMODEM_PORTNAME:
			    lRet = mfn_lineGetID_COMM_DATAMODEM_PORTNAME(
                                lpDeviceID,
                                hTargetProcess,
                                cbMaxExtra,
                                psl
                                );
                break;

            case DEVCLASS_WAVE_IN:
                lRet = mfn_linephoneGetID_WAVE(
                                FALSE,  // <- fPhone
                                TRUE,   // <- fIn
                                lpDeviceID,
                                hTargetProcess,
                                cbMaxExtra,
                                psl
                                );
                break;

            case DEVCLASS_WAVE_OUT:
                lRet = mfn_linephoneGetID_WAVE(
                                FALSE,  // <- fPhone
                                FALSE,  // <- fIn
                                lpDeviceID,
                                hTargetProcess,
                                cbMaxExtra,
                                psl
                                );
                break;

            case DEVCLASS_TAPI_LINE_DIAGNOSTICS:
                lRet = mfn_lineGetID_LINE_DIAGNOSTICS(
                                pParams->dwSelect,
                                lpDeviceID,
                                hTargetProcess,
                                cbMaxExtra,
                                psl
                                );
                break;

            case DEVCLASS_UNKNOWN:
		        FL_SET_RFR(0x2a6a4400, "Unknown device class");
                lRet = LINEERR_INVALDEVICECLASS;
                break;

			default:
		        FL_SET_RFR(0x82df8d00, "Unsupported device class");
	            lRet = LINEERR_OPERATIONUNAVAIL;
			    break;
            }


            if (!lRet)
            {
                FL_ASSERT(psl, lpDeviceID->dwUsedSize<=lpDeviceID->dwTotalSize);
                FL_ASSERT(psl,
                     (lpDeviceID->dwStringOffset+lpDeviceID->dwStringSize)
                                                    <=lpDeviceID->dwTotalSize);
            }
		}
		break;

	case TASKID_TSPI_lineGetLineDevStatus:
		{
			TASKPARAM_TSPI_lineGetLineDevStatus *pParams = 
						(TASKPARAM_TSPI_lineGetLineDevStatus *) pvParams;
			ASSERT(pParams->dwStructSize ==
				sizeof(TASKPARAM_TSPI_lineGetLineDevStatus));
			ASSERT(pParams->dwTaskID == TASKID_TSPI_lineGetLineDevStatus);
            LPLINEDEVSTATUS lpLineDevStatus = pParams->lpLineDevStatus;

            // Following (including ZeroMemory) is new for NT5.0
            // 
            DWORD dwTotalSize = lpLineDevStatus->dwTotalSize;
            if (dwTotalSize < sizeof(LINEDEVSTATUS))
            {
                lRet = LINEERR_STRUCTURETOOSMALL;
                break;
            }
            ZeroMemory(lpLineDevStatus, sizeof(LINEDEVSTATUS));
            lpLineDevStatus->dwTotalSize = dwTotalSize;

            lpLineDevStatus->dwUsedSize   = sizeof(LINEDEVSTATUS);
            lpLineDevStatus->dwNeededSize = sizeof(LINEDEVSTATUS);
            
            // Having zeroed memory, only set non-zero things...

            // Call information
            if (pLine->pCall)
            {
                if (pLine->pCall->IsActive())
                {
                    lpLineDevStatus->dwNumActiveCalls = 1;
                }
            }
            else
            {
                lpLineDevStatus->dwLineFeatures = LINEFEATURE_MAKECALL;
                lpLineDevStatus->dwAvailableMediaModes
                                          = m_StaticInfo.dwDefaultMediaModes;
            }
            
            // Line hardware information
            //
            // Don't know what this means, but NT4.0 did it...
            //
            lpLineDevStatus->dwSignalLevel  = 0x0000FFFF;
            lpLineDevStatus->dwBatteryLevel = 0x0000FFFF;
            lpLineDevStatus->dwRoamMode     = LINEROAMMODE_UNAVAIL;
           
            // Always allow TAPI calls
            //
            lpLineDevStatus->dwDevStatusFlags = LINEDEVSTATUSFLAGS_CONNECTED;

            lpLineDevStatus->dwDevStatusFlags |= LINEDEVSTATUSFLAGS_INSERVICE;


		} // end case TASKID_TSPI_lineGetLineDevStatus:
		break;
	

	case TASKID_TSPI_lineSetStatusMessages:
		{
			TASKPARAM_TSPI_lineSetStatusMessages *pParams = 
						(TASKPARAM_TSPI_lineSetStatusMessages *) pvParams;
			ASSERT(pParams->dwStructSize ==
				sizeof(TASKPARAM_TSPI_lineSetStatusMessages));
			ASSERT(pParams->dwTaskID == TASKID_TSPI_lineSetStatusMessages);

            // pParams->dwLineStates;
            // pParams->dwAddressStates;

            //
            //  Maybe add some logic to actually filter these messages
            //
            //
        	FL_SET_RFR(0xe8271600, "lineSetStatusMessages handled");

            lRet = 0;

		} // end case TASKID_TSPI_lineSetStatusMessages:
		break;

	case TASKID_TSPI_lineGetAddressStatus:
		{
			TASKPARAM_TSPI_lineGetAddressStatus *pParams = 
						(TASKPARAM_TSPI_lineGetAddressStatus *) pvParams;
			ASSERT(pParams->dwStructSize ==
				sizeof(TASKPARAM_TSPI_lineGetAddressStatus));
			ASSERT(pParams->dwTaskID == TASKID_TSPI_lineGetAddressStatus);

        	FL_SET_RFR(0xfc498200, "lineGetAddressStatus handled");

            //
            // We support only one address, and it must be zero.
            //
            if (pParams->dwAddressID)
            {
                lRet = LINEERR_INVALADDRESSID;
            }
            else
            {
                LPLINEADDRESSSTATUS lpAddressStatus = pParams->lpAddressStatus;
                DWORD dwTotalSize = lpAddressStatus->dwTotalSize;

                // 9/10/1997 JosephJ
                // In NT4.0 TSP, we didn't check the dwTotalSize and didn't
                // set the dwNeededSize or dwUsed size, and we didn't
                // zero-out the elements which we didn't explicitly set.
                // We do all of this for NT5.0.

                if (dwTotalSize < sizeof(LINEADDRESSSTATUS))
                {
                    lRet = LINEERR_STRUCTURETOOSMALL;
                    break;
                }

                ZeroMemory(lpAddressStatus, sizeof(LINEADDRESSSTATUS));
                lpAddressStatus->dwTotalSize = dwTotalSize;
                lpAddressStatus->dwUsedSize   = sizeof(LINEADDRESSSTATUS);
                lpAddressStatus->dwNeededSize = sizeof(LINEADDRESSSTATUS);
                
                // Having zeroed memory, only set non-zero things...

                if (pLine->pCall)
                {
                    lpAddressStatus->dwNumInUse = 1;

                    if (pLine->pCall->IsActive())
                    {
                        lpAddressStatus->dwNumActiveCalls = 1;
                    }
                }
                else
                {
                    lpAddressStatus->dwAddressFeatures = 
                                                    LINEADDRFEATURE_MAKECALL;
                }

                lRet = 0;
            }

		} // end case TASKID_TSPI_lineGetAddressStatus
		break;

	case TASKID_TSPI_lineConditionalMediaDetection:
		{
			TASKPARAM_TSPI_lineConditionalMediaDetection *pParams = 
                    (TASKPARAM_TSPI_lineConditionalMediaDetection *) pvParams;
			ASSERT(pParams->dwStructSize ==
				sizeof(TASKPARAM_TSPI_lineConditionalMediaDetection));
		    ASSERT(pParams->dwTaskID == TASKID_TSPI_lineConditionalMediaDetection);

        	FL_SET_RFR(0xaca5f600, "lineConditionalMediaDetection handled");

            lRet = 0;

            // 2/20/1998 JosephJ Taken from unimdm/v
            // Check the requested modes. There must be only our media modes.
            //
            if (pParams->dwMediaModes &  ~m_StaticInfo.dwDefaultMediaModes)
            {
                lRet = LINEERR_INVALMEDIAMODE;
            }
            else
            {
		        LPLINECALLPARAMS const lpCallParams = pParams->lpCallParams;
                // Check the call paramaters
                //
                if (    ( lpCallParams->dwBearerMode
                         & ~m_StaticInfo.dwBearerModes)
                    ||
                        ( lpCallParams->dwMediaMode
                         & ~m_StaticInfo.dwDefaultMediaModes)
                    || (   lpCallParams->dwAddressMode
                         !=LINEADDRESSMODE_ADDRESSID))
                {
                  lRet = LINEERR_INVALMEDIAMODE;
                }
            }


            // 2/20/1998 JosephJ
            // The following, code, added by ViroonT on Oct 12 43 1995,
            // is in NT4 but not in Win9x unimdm/v -- I don't see why
            // it should be doing this check if an outbound call can be made
            // -- this is not what the documentation for
            // TSPI_lineConditionalMediaDetection says...
            //
            //  if (lRet == ERROR_SUCCESS)
            //  {
            //    // Check whether we can make an outbound call
            //    //
            //    if (pLineDev->dwCall & (CALL_ACTIVE | CALL_ALLOCATED))
            //    {
            //      lRet = LINEERR_RESOURCEUNAVAIL;
            //    }
            //  }

        }
        break;

    case TASKID_TSPI_lineCreateMSPInstance: {

            TASKPARAM_TSPI_lineCreateMSPInstance *pParams = (TASKPARAM_TSPI_lineCreateMSPInstance*)pvParams;

            ASSERT(pParams->dwStructSize == sizeof(TASKPARAM_TSPI_lineCreateMSPInstance));
            ASSERT(pParams->dwTaskID == TASKID_TSPI_lineCreateMSPInstance);

            *pParams->lphdMSPLine=(HDRVMSPLINE)pParams->hdLine;

//            pLine->T3Info.htMSPLine=pParams->htMSPLine;
            pLine->T3Info.MSPClients++;

            lRet=ERROR_SUCCESS;

        }
        break;

    case TASKID_TSPI_lineCloseMSPInstance: {

            TASKPARAM_TSPI_lineCloseMSPInstance *pParams = (TASKPARAM_TSPI_lineCloseMSPInstance*)pvParams;

            ASSERT(pParams->dwStructSize == sizeof(TASKPARAM_TSPI_lineCloseMSPInstance));
            ASSERT(pParams->dwTaskID == TASKID_TSPI_lineCloseMSPInstance);

            pLine->T3Info.MSPClients--;

            lRet=ERROR_SUCCESS;
        }
        break;

	default:

		FL_SET_RFR(0xc5752400, "*** UNHANDLED HDRVLINE CALL ****");
        // we  return 0 and set lRet to
        // LINEERR_OPERATIONUNAVAIL
	    lRet = LINEERR_OPERATIONUNAVAIL;
		break;

	}

end:

    if (tspRet && !lRet)
    {
        lRet = LINEERR_OPERATIONFAILED;
    }

    *plRet = lRet;

    SLPRINTF1(psl, "lRet = 0x%08lx", lRet);

	FL_LOG_EXIT(psl, tspRet);
	return;
}

TSPRETURN
CTspDev::mfn_LoadLine(
    TASKPARAM_TSPI_lineOpen  *pParams,
    CStackLog *psl
    )
{
	FL_DECLARE_FUNC(0xe4df9b1f, "CTspDev::mfn_LoadLine")
    TSPRETURN tspRet=0;
	FL_LOG_ENTRY(psl);


    if (!m_pLine)
    {
        // Note m_Line should be all zeros when it is in the unloaded state.
        // If it is not, it is an assertfail condition. We keep things clean
        // this way.
        //
        FL_ASSERT(
            psl,
            validate_DWORD_aligned_zero_buffer(
                    &(m_Line),
                    sizeof (m_Line)));

        m_Line.lpfnEventProc = pParams->lpfnEventProc;
	    m_Line.htLine = pParams->htLine;
	    m_Line.hdLine =  *(pParams->lphdLine);
        m_pLine = &m_Line;

        // TODO -- Perhaps update comm config
    }
    else
    {
        FL_SET_RFR(0xa62f2e00, "Device already loaded (m_pLine!=NULL)!");
        tspRet = FL_GEN_RETVAL(IDERR_WRONGSTATE);
    }

	FL_LOG_EXIT(psl, tspRet);

    return tspRet;
}


// The "inverse" of mfn_LoadLine. Synchronous, assumes object's crit sect is
// already claimed. On entry m_pLine must be non-null. On exit m_pLine
// WILL be NULL. mfn_UnloadLine is typically called only after all
// asynchronous activity on the line is complete. If there is pending
// asynchronous activity, mfn_UnloadLine will abort that activity and
// wait indefinately until that activity completes. Since this wait is
// done once per device, it is better to first go through and abort all
// the devices, then wait once for them all to complete.
//
void
CTspDev::mfn_UnloadLine(CStackLog *psl)
{
	FL_DECLARE_FUNC(0x5bbf75ef, "UnloadLine")

    // Unload Line
    if (m_pLine)
    {
        ASSERT(m_pLine == &m_Line);

        if (m_pLine->pCall)
        {
            mfn_UnloadCall(FALSE, psl);
            ASSERT(!m_pLine->pCall);
        }

        //
        // The line would have opened the lldev iff we were monitoring for
        // incoming calls. Note that mfn_CloseLLDev keeps a ref-count.
        //
        if (m_pLine->IsOpenedLLDev())
        {
            mfn_CloseLLDev(
                        LLDEVINFO::fRESEX_MONITOR,
                        FALSE,
                        NULL,
                        0,
                        psl
                        );
            m_pLine->ClearStateBits(LINEINFO::fLINE_OPENED_LLDEV);
        }

        ZeroMemory(&m_Line, sizeof(m_Line));
        m_pLine=NULL;
    }
}


void
CTspDev::mfn_ProcessPowerResume(CStackLog *psl)
{
	FL_DECLARE_FUNC(0xf0bdd5c1, "CTspDev::mfn_ProcessPowerResume")
	TSPRETURN tspRet = 0;
    LLDEVINFO *pLLDev = m_pLLDev;
	FL_LOG_ENTRY(psl);

    if (!pLLDev || !pLLDev->dwRefCount)
    {
	    FL_SET_RFR(0x3d02a200, "Doing nothing because no clients to lldev.");
	    goto end;
    }

    if ((m_pLine && m_pLine->pCall) || pLLDev->IsStreamingVoice())
    {
        // Received POWER_RESUME when call in progress -- hmmm...
        ASSERT(FALSE);

        // At any rate, we don't need to do anything because we re-init
        // at the end of the call if required.
    }
    else
    {
        //
        // No activity, as we would expect..
        //

        m_pLLDev->fModemInited=FALSE;

        TSPRETURN  tspRet = mfn_StartRootTask(
                                &CTspDev::s_pfn_TH_LLDevNormalize,
                                &pLLDev->fLLDevTaskPending,
                                0,  // Param1
                                0,  // Param2
                                psl
                                );
        if (IDERR(tspRet)==IDERR_TASKPENDING)
        {
            // can't do this now, we've got to defer it!
            m_pLLDev->SetDeferredTaskBits(LLDEVINFO::fDEFERRED_NORMALIZE);
            tspRet = 0;
        }

    }

end:
	FL_LOG_EXIT(psl, tspRet);
}



LONG CTspDev::mfn_linephoneGetID_TAPI_LINE(
        LPVARSTRING lpDeviceID,
        HANDLE hTargetProcess,
        UINT cbMaxExtra,
        CStackLog *psl
        )
{
    UINT cbRequired = sizeof(DWORD);
    LONG lRet = 0;

    if (!mfn_IsLine())
    {
        lRet = LINEERR_OPERATIONUNAVAIL;
        goto end; 
    }
    // Return the structure information
    //
    lpDeviceID->dwNeededSize += cbRequired;

    if (cbMaxExtra>=cbRequired)
    {
          LPDWORD lpdwDeviceID = (LPDWORD)(((LPBYTE)lpDeviceID)
                                            + sizeof(VARSTRING));
          *lpdwDeviceID = m_StaticInfo.dwTAPILineID;
          lpDeviceID->dwStringFormat = STRINGFORMAT_BINARY;
          lpDeviceID->dwStringSize   = cbRequired;
          lpDeviceID->dwUsedSize   += cbRequired;
    }

end:

    return lRet;
}

LONG CTspDev::mfn_lineGetID_COMM(
        LPVARSTRING lpDeviceID,
        HANDLE hTargetProcess,
        UINT cbMaxExtra,
        CStackLog *psl
        )
{
    UINT cbRequired = 0;
    LONG lRet = 0;

    #ifdef UNICODE
        cbRequired = WideCharToMultiByte(
                          CP_ACP,
                          0,
                          m_StaticInfo.rgtchDeviceName,
                          -1,
                          NULL,
                          0,
                          NULL,
                          NULL);
    #else
        cbRequired = lstrlen(m_StaticInfo.rgtchDeviceName)+1;
    #endif

    // Return the structure information
    //

    lpDeviceID->dwNeededSize += cbRequired; 
    if (cbRequired<=cbMaxExtra)
    {
        // Note -- don't assume that we have so start copying right after
        // VARSTRING -- start at offset lpDeviceID->dwUsedSize instead.
        // This is needed specifically because this function is called
        // by CTspDev::mfn_lineGetID_COMM_DATAMODEM.
        //
        #ifdef UNICODE
            UINT cb = WideCharToMultiByte(
                              CP_ACP,
                              0,
                              m_StaticInfo.rgtchDeviceName,
                              -1,
                              (LPSTR)((LPBYTE)lpDeviceID
                                       + lpDeviceID->dwUsedSize),
                              cbMaxExtra,
                              NULL,
                              NULL);
    
            if (!cb) lRet = LINEERR_OPERATIONFAILED;
        #else // !UNICODE
            CopyMemory(
                (LPBYTE)lpDeviceID + sizeof(VARSTRING),
                m_StaticInfo.rgtchDeviceName,
                cbRequired
                );
        #endif //!UNICODE

        lpDeviceID->dwStringFormat = STRINGFORMAT_ASCII;
        lpDeviceID->dwStringSize   = cbRequired;
        lpDeviceID->dwUsedSize   += cbRequired;
    }

    return lRet;
}

LONG CTspDev::mfn_lineGetID_COMM_DATAMODEM(
        LPVARSTRING lpDeviceID,
        HANDLE hTargetProcess,
        UINT cbMaxExtra,
        CStackLog *psl
        )
{
	FL_DECLARE_FUNC(0x81e0d3f9, "mfn_lineGetID_COMM_DATAMODEM")

    UINT cbRequired = sizeof(HANDLE); // for the comm handle...
    LONG lRet = 0;


    // Following cases commented out because MCT wants handle before call
    // is made to get modem properties (via GetCommProperties).
    // TODO: make new lineGetID catigory to retrieve modem properties.
    //
    #if 0
    if (!m_pLine->pCall)
    {
        lRet = LINEERR_INVALCALLHANDLE;
    }
    else if (!m_pLine->pCall->IsActive())
    {
        lRet = LINEERR_CALLUNAVAIL;
    }
    else
    #endif 

    //
    // 9/10/1997 JosephJ
    //           Bug# 83347 +B1: SmarTerm 95 V7.0 a is unable to
    //           use installed modems on NT 5.0.
    //         
    //           Unfortunately, apps, such as SmarTerm95, expect 
    //          lineGetID(comm/datamodem) to succeed with a NULL comm
    //          handle if the device is not open, not to fail.
    //
    //          So instead of failing here, we later insert a NULL handle..
    //
    // if (!m_pLLDev)
    // {
    //      lRet = LINEERR_OPERATIONFAILED;
    // }
    // if (lRet) goto end;

    // Add space required for the device name...
    #ifdef UNICODE
        cbRequired += WideCharToMultiByte(
                          CP_ACP,
                          0,
                          m_StaticInfo.rgtchDeviceName,
                          -1,
                          NULL,
                          0,
                          NULL,
                          NULL);
    #else
        cbRequired += lstrlen(m_StaticInfo.rgtchDeviceName)+1;
    #endif

    lpDeviceID->dwNeededSize   +=cbRequired;

    if (cbMaxExtra>=cbRequired)
    {
        // There is enough space....
        // copy the device name and if that succeeds duplicate and copy
        // the handle.

        FL_ASSERT(psl, lpDeviceID->dwUsedSize == sizeof(VARSTRING));
        FL_ASSERT(psl, lpDeviceID->dwStringOffset == sizeof(VARSTRING));

        LPSTR szDestDeviceName =  (LPSTR)((LPBYTE)lpDeviceID
                                       + lpDeviceID->dwUsedSize
                                       + sizeof(HANDLE));

        // Tack on device name first ...
        #ifdef UNICODE
            UINT cb = WideCharToMultiByte(
                              CP_ACP,
                              0,
                              m_StaticInfo.rgtchDeviceName,
                              -1,
                              szDestDeviceName,
                              cbRequired-sizeof(HANDLE),
                              NULL,
                              NULL);
    
            if (!cb) lRet = LINEERR_OPERATIONFAILED;
        #else // !UNICODE
            CopyMemory(
                szDestDeviceName,
                m_StaticInfo.rgtchDeviceName,
                cbRequired-sizeof(HANDLE)
                );
        #endif //!UNICODE

        // Duplicate handle
        //
        if (!lRet)
        {
            LPHANDLE lphClientDevice = (LPHANDLE)
                                (((LPBYTE)lpDeviceID)
                                 + lpDeviceID->dwUsedSize);

            HANDLE hClientDevice2;


            // 9/10/1997 JosephJ
            //           See comments about Bug# 83347 above..
            //           TODO: make the test more stringent, such as having
            //                 a data or passthrough call in effect.
            if (m_pLLDev)
            {
                hClientDevice2 =  m_StaticInfo.pMD->DuplicateDeviceHandle(
                                      m_pLLDev->hModemHandle,
                                      hTargetProcess,
                                      psl
                                      );
    
            }
            else
            {
                hClientDevice2 =  NULL;
            }

            CopyMemory(lphClientDevice,&hClientDevice2,sizeof(HANDLE));

            lpDeviceID->dwUsedSize     += cbRequired;
            lpDeviceID->dwStringSize   = cbRequired;
            lpDeviceID->dwStringFormat = STRINGFORMAT_BINARY;
        }

    }

    return lRet;
}

LONG CTspDev::mfn_lineGetID_COMM_DATAMODEM_PORTNAME(
        LPVARSTRING lpDeviceID,
        HANDLE hTargetProcess,
        UINT cbMaxExtra,
        CStackLog *psl
        )
{
    DWORD cbRequired;
    LONG lRet = 0;
    HKEY  hKey = NULL;
    DWORD dwType;
    const char *cszKeyName =  cszATTACHED_TO;
    DWORD dwRet =  RegOpenKeyA(
                        HKEY_LOCAL_MACHINE,
                        m_StaticInfo.rgchDriverKey,
                        &hKey);
    if (!dwRet)
    {

        // 8/21/97 JosephJ Fix for bug 101797. Currently PnP modems don't have
        //          the AttachedTo Key. So I modified the class installer to
        //          add an PnPAttachedTo Key, and I look here first for
        //          AttachedTo and then for PnPAttachedTo.
        //
          cbRequired = cbMaxExtra;
          dwRet = RegQueryValueExA(
                            hKey,
                            cszKeyName,
                            NULL,
                            &dwType,
                            NULL,
                            &cbRequired);
          if (dwRet)
          {
              cszKeyName = cszPNP_ATTACHED_TO;
              cbRequired = cbMaxExtra;
              dwRet = RegQueryValueExA(
                                hKey,
                                cszKeyName,
                                NULL,
                                &dwType,
                                NULL,
                                &cbRequired);
             
          }
    }

    if (dwRet)
    {
        cbRequired = 1;
    }

    lpDeviceID->dwNeededSize += cbRequired;

    if (cbMaxExtra>=cbRequired)
    {
        LPBYTE lpszAttachedTo = ((LPBYTE)lpDeviceID)
                                                + sizeof(VARSTRING);
        *lpszAttachedTo = 0;
        if (cbRequired>1)
        {
            DWORD dwSize=cbRequired;
            dwRet = RegQueryValueExA(
                            hKey,
                            cszKeyName,
                            NULL,
                            &dwType,
                            lpszAttachedTo,
                            &dwSize);
            if (dwRet) cbRequired = 1;
        }
        lpDeviceID->dwStringFormat = STRINGFORMAT_ASCII;
        lpDeviceID->dwStringSize   = cbRequired;
        lpDeviceID->dwUsedSize   += cbRequired;
    }

	if (hKey)
	{
        RegCloseKey(hKey);
        hKey = NULL;
    }

    return lRet;
}


LONG CTspDev::mfn_lineGetID_NDIS(
        LPVARSTRING lpDeviceID,
        HANDLE hTargetProcess,
        UINT cbMaxExtra,
	    CStackLog *psl
        )
{
	FL_DECLARE_FUNC(0x816f0bba, "lineGetID_NDIS");
	FL_ASSERT(psl, FALSE);
    return  LINEERR_OPERATIONUNAVAIL;
}
 

LONG CTspDev::mfn_linephoneGetID_WAVE(
        BOOL fPhone,
        BOOL fIn,
        LPVARSTRING lpDeviceID,
        HANDLE hTargetProcess,
        UINT cbMaxExtra,
        CStackLog *psl
        )
{
    UINT cbRequired = sizeof(DWORD);
    LONG lRet = LINEERR_NODEVICE;

	FL_DECLARE_FUNC(0x18972e4d, "CTspDev::mfn_lineGetID_WAVE")
	FL_LOG_ENTRY(psl);
    if (!mfn_CanDoVoice())
    {
        lRet = LINEERR_OPERATIONUNAVAIL;
        goto end; 
    }

    // Return the structure information
    //
    lpDeviceID->dwNeededSize += cbRequired;

    if (cbMaxExtra<cbRequired)
    {
        lRet = 0; // By convention, we succeed in this case, after
                  // setting the dwNeededSize.
    }
    else
    {
          LPDWORD lpdwDeviceID = (LPDWORD)(((LPBYTE)lpDeviceID)
                                            + sizeof(VARSTRING));
        TCHAR rgName[256];


          // 3/1/1997 JosephJ
          //    We used to call the MM Wave APIs to enumerate
          //    the devices and match the one with the name of this modem's
          //    wave devices.
          //
          //    TODO: need to do something better here -- like use the TAPI3.0
          //          MSP.
          //

        {
            #include "..\inc\waveids.h"

            TCHAR rgString[256];
            HINSTANCE hInst = LoadLibrary(TEXT("SERWVDRV.DLL"));
            int i;

            if (!hInst) {

                lRet = LINEERR_OPERATIONFAILED;
                goto end;
            }

            i=LoadString(
                hInst,
                fIn ? (fPhone ? IDS_WAVEIN_HANDSET : IDS_WAVEIN_LINE)
                    : (fPhone ? IDS_WAVEOUT_HANDSET : IDS_WAVEOUT_LINE),
                rgString,
                sizeof(rgString)/sizeof(TCHAR)
                );

            FreeLibrary(hInst);

            if (i == 0) {

                lRet = LINEERR_OPERATIONFAILED;
                goto end;
            }

            wsprintf(
                rgName,
                rgString,
                m_StaticInfo.Voice.dwWaveInstance
                );


        }

        HINSTANCE hInst = LoadLibrary(TEXT("WINMM.DLL"));
        if (!hInst)
        {
            FL_SET_RFR(0xac6c8a00, "Couldn't LoadLibrary(winmm.dll)");
            lRet = LINEERR_OPERATIONFAILED;
        }
        else
        {
            
            UINT          u;
            UINT          uNumDevices;
              
            
            typedef UINT (*PFNWAVEINGETNUMDEVS) (void);
            typedef MMRESULT (*PFNWAVEINGETDEVCAPS) (
                                    UINT uDeviceID,
                                    LPWAVEINCAPS pwic,
                                    UINT cbwic
                                    );
            typedef UINT (*PFNWAVEOUTGETNUMDEVS) (void);
            typedef (*PFNWAVEOUTGETDEVCAPS) (
                                    UINT uDeviceID,
                                    LPWAVEOUTCAPS pwoc,
                                    UINT cbwoc
                                    );

            #ifdef UNICODE
                #define szwaveInGetDevCaps "waveInGetDevCapsW"
                #define szwaveOutGetDevCaps "waveOutGetDevCapsW"
            #else // !UNICODE
                #define szwaveInGetDevCaps "waveInGetDevCapsA"
                #define szwaveOutGetDevCaps "waveOutGetDevCapsA"
            #endif // !UNICODE

            PFNWAVEINGETNUMDEVS pfnwaveInGetNumDevs=
                    (PFNWAVEINGETNUMDEVS) GetProcAddress(
                                            hInst,
                                            "waveInGetNumDevs"
                                            );
            PFNWAVEINGETDEVCAPS pfnwaveInGetDevCaps=
                    (PFNWAVEINGETDEVCAPS) GetProcAddress(
                                            hInst,
                                            szwaveInGetDevCaps
                                            );
            PFNWAVEOUTGETNUMDEVS pfnwaveOutGetNumDevs=
                    (PFNWAVEOUTGETNUMDEVS) GetProcAddress(
                                            hInst,
                                            "waveOutGetNumDevs"
                                            );
            PFNWAVEOUTGETDEVCAPS pfnwaveOutGetDevCaps=
                    (PFNWAVEOUTGETDEVCAPS) GetProcAddress(
                                            hInst,
                                            szwaveOutGetDevCaps
                                            );


            if (!pfnwaveInGetNumDevs
                || !pfnwaveInGetDevCaps 
                || !pfnwaveOutGetNumDevs
                || !pfnwaveOutGetDevCaps)
            {
                FL_SET_RFR(0x282bc900, "Couldn't loadlib mmsystem apis");
                lRet = LINEERR_OPERATIONFAILED;
            }
            else
            {
                if (fIn)
                {
                    WAVEINCAPS    waveInCaps;
            
                    uNumDevices = pfnwaveInGetNumDevs();
                    
                    for( u=0; u<uNumDevices; u++ )
                    {    
                        if(pfnwaveInGetDevCaps(
                            u,
                            &waveInCaps,
                            sizeof(WAVEINCAPS)) == 0)
                        {
                          SLPRINTF2(psl, "%lu=\"%s\"\n", u, waveInCaps.szPname);
                          if (!lstrcmpi(waveInCaps.szPname, rgName))
                          {
                            *lpdwDeviceID = u;
                            lRet=0;
                            break;
                          }
                        }
                    }
                
                } 
                else
                {
                    WAVEOUTCAPS   waveOutCaps;
                
                    uNumDevices = pfnwaveOutGetNumDevs();
                    for( u=0; u<uNumDevices; u++ )
                    {
                        if(pfnwaveOutGetDevCaps(u,
                           &waveOutCaps,
                           sizeof(WAVEOUTCAPS)) == 0)
                        {
                          SLPRINTF2(psl, "%lu=\"%s\"\n", u, waveOutCaps.szPname);
                          if (!lstrcmpi(waveOutCaps.szPname, rgName))
                          {
                            *lpdwDeviceID = u;
                            lRet=0;
                            break;
                          }
                        }
                    }
                }

                if (lRet)
                {
                    FL_SET_RFR(0xf391f200, "Could not find wave device");
                }
            }

            FreeLibrary(hInst); hInst=NULL;
            
          }
          
          lpDeviceID->dwStringFormat = STRINGFORMAT_BINARY;
          lpDeviceID->dwStringSize   = cbRequired;
          lpDeviceID->dwUsedSize   += cbRequired;
    }

end:


	FL_LOG_EXIT(psl, lRet);
    return lRet;
}


LONG CTspDev::mfn_linephoneGetID_TAPI_PHONE(
        LPVARSTRING lpDeviceID,
        HANDLE hTargetProcess,
        UINT cbMaxExtra,
        CStackLog *psl
        )
{
    UINT cbRequired = sizeof(DWORD);
    LONG lRet = 0;

    if (!mfn_IsPhone())
    {
        lRet = LINEERR_OPERATIONUNAVAIL;
        goto end; 
    }

    // Return the structure information
    //
    lpDeviceID->dwNeededSize += cbRequired;

    if (cbMaxExtra>=cbRequired)
    {
          LPDWORD lpdwDeviceID = (LPDWORD)(((LPBYTE)lpDeviceID)
                                            + sizeof(VARSTRING));
          *lpdwDeviceID = m_StaticInfo.dwTAPIPhoneID;
          lpDeviceID->dwStringFormat = STRINGFORMAT_BINARY;
          lpDeviceID->dwStringSize   = cbRequired;
          lpDeviceID->dwUsedSize   += cbRequired;
    }

end:
    return lRet;

}

LONG
CTspDev::mfn_fill_RAW_LINE_DIAGNOSTICS(
            LPVARSTRING lpDeviceID,
            UINT cbMaxExtra,
            CStackLog *psl
            )
{
	FL_DECLARE_FUNC(0xf3d8ee16, "CTspDev::mfn_fill_RAW_LINE_DIAGNOSTICS")
	FL_LOG_ENTRY(psl);

    UINT cbRequired = sizeof(LINEDIAGNOSTICS);
    LONG lRet = 0;
    CALLINFO *pCall = m_pLine->pCall;
    UINT cbRaw = (pCall) ? pCall->DiagnosticData.cbUsed : 0;


    if (!pCall)
    {
        // We should not get here because we've already checked
        // in the handling of lineGetID that if LINECALLSELECT_CALL is
        // specified pCall is not null...
        //
        ASSERT(FALSE);
        lRet = LINEERR_OPERATIONFAILED;
        goto end;
    }
   
    if (cbRaw)
    {
        // we add the size of the raw data plus the header for that
        // raw data + 1 for the terminating NULL
        cbRequired += cbRaw + sizeof(LINEDIAGNOSTICSOBJECTHEADER) + 1;
    }

    // Note: By convention, we succeed even if there is not enough space,
    // setting the dwNeededSize.

    lpDeviceID->dwNeededSize += cbRequired;

    if (cbMaxExtra>=cbRequired)
    {
        LINEDIAGNOSTICS *pLD = (LINEDIAGNOSTICS*)(((LPBYTE)lpDeviceID)
                                            + sizeof(VARSTRING));


        ZeroMemory(pLD, cbRequired);

        pLD->hdr.dwSig = LDSIG_LINEDIAGNOSTICS;
        pLD->hdr.dwTotalSize = cbRequired;
        pLD->hdr.dwParam = sizeof(*pLD);
        pLD->dwDomainID =  DOMAINID_MODEM;
        pLD->dwResultCode =  LDRC_UNKNOWN;
       
        if (cbRaw)
        {
            pLD->dwRawDiagnosticsOffset = sizeof(*pLD);

            LINEDIAGNOSTICSOBJECTHEADER *pRawHdr = RAWDIAGNOSTICS_HDR(pLD);
            BYTE *pbDest = RAWDIAGNOSTICS_DATA(pLD);
            pRawHdr->dwSig =  LDSIG_RAWDIAGNOSTICS;
            // the + 1 in the next two statements accounts for the
            // terminating NULL;
            pRawHdr->dwTotalSize = cbRaw + sizeof(LINEDIAGNOSTICSOBJECTHEADER) + 1;
            pRawHdr->dwParam = cbRaw + 1;

            ASSERT(IS_VALID_RAWDIAGNOSTICS_HDR(pRawHdr));
            ASSERT(RAWDIAGNOSTICS_DATA_SIZE(pRawHdr)==cbRaw);

            CopyMemory(
                pbDest,
                pCall->DiagnosticData.pbRaw,
                cbRaw
                );
        }

        lpDeviceID->dwStringFormat = STRINGFORMAT_BINARY;
        lpDeviceID->dwStringSize   = cbRequired;
        lpDeviceID->dwStringOffset = sizeof(VARSTRING);
        lpDeviceID->dwUsedSize   += cbRequired;
    }

end:

	FL_LOG_EXIT(psl, lRet);
    return lRet;
}


LONG
CTspDev::mfn_lineGetID_LINE_DIAGNOSTICS(
            DWORD dwSelect,
            LPVARSTRING lpDeviceID,
            HANDLE hTargetProcess,
            UINT cbMaxExtra,
            CStackLog *psl
            )
{
	FL_DECLARE_FUNC(0x209b4261, "CTspDev::mfn_lineGetID_LINE_DIAGNOSTICS")
	FL_LOG_ENTRY(psl);

    UINT cbRequired = sizeof(LINEDIAGNOSTICS);
    LONG lRet = 0;
    CALLINFO *pCall = m_pLine->pCall;
    UINT cbRaw = (pCall) ? pCall->DiagnosticData.cbUsed : 0;


    if (dwSelect != LINECALLSELECT_CALL)
    {
        lRet  =  LINEERR_INVALPARAM;
        goto end;
    }

    lRet = mfn_fill_RAW_LINE_DIAGNOSTICS(
               lpDeviceID,
               cbMaxExtra,
               psl
                );

    //
    // 4/5/1998 JosephJ
    //  Following code adapted from Sorin (CostelR) 's code from the
    //  extension DLL (parsed diagnostics functionality was implemeted by
    //  costelr in the extension DLL, and was moved on 4/5/1998 to the
    //  actual TSP).
    //
	if (lpDeviceID->dwNeededSize >  lpDeviceID->dwTotalSize)
	{
	    //
        //	Need more space to get the raw diagnostics...
		//	Temporarily allocate enough to obtain the raw data
		//
	    LPVARSTRING	lpExtensionDeviceID =
                (LPVARSTRING) ALLOCATE_MEMORY(
                                 lpDeviceID->dwNeededSize
                                 );

		if (lpExtensionDeviceID == NULL)
		{
        	// the parsing cannot be done
			lRet = LINEERR_OPERATIONFAILED;
			goto end;
		}

		lpExtensionDeviceID->dwTotalSize = lpDeviceID->dwNeededSize;
        lpExtensionDeviceID->dwNeededSize    = sizeof(VARSTRING);
        lpExtensionDeviceID->dwStringOffset  = sizeof(VARSTRING);
        lpExtensionDeviceID->dwUsedSize      = sizeof(VARSTRING);
        lpExtensionDeviceID->dwStringSize    = 0;
        cbMaxExtra =  lpExtensionDeviceID->dwTotalSize - sizeof(VARSTRING);

        lRet = mfn_fill_RAW_LINE_DIAGNOSTICS(
                   lpExtensionDeviceID,
                   cbMaxExtra,
                   psl
                   );


		//	here we can parse the diagnostics and find the needed size
		if (lRet == ERROR_SUCCESS)
		{
		    //
			// check the structure and parse the diagnostics
			//
			lRet = BuildParsedDiagnostics(lpExtensionDeviceID);
            //
			//	since lpExtensionDeviceID is very small
			//	we expect to have filled in only the dwNeededSize
			//	copy it to the original structure
			//

            //
			//	eventualy the size grows up
            //
			ASSERT(lpDeviceID->dwNeededSize
                    <= lpExtensionDeviceID->dwNeededSize);
			lpDeviceID->dwNeededSize = lpExtensionDeviceID->dwNeededSize;
		}

		FREE_MEMORY(lpExtensionDeviceID);
	}
	else
	{
		// check the structure and parse the diagnostics
		lRet = BuildParsedDiagnostics(lpDeviceID);
	}

end:

	FL_LOG_EXIT(psl, lRet);
    return lRet;
}

TSPRETURN
CTspDev::mfn_TryStartLineTask(CStackLog *psl)
{
    // NOTE: MUST return IDERR_SAMESTATE if there are no tasks to run.

    ASSERT(m_pLine);
    LINEINFO *pLine = m_pLine;
    TSPRETURN tspRet = IDERR_SAMESTATE;
    
    if (pLine->pCall)
    {
        tspRet =  mfn_TryStartCallTask(psl);
    }

    if (IDERR(tspRet) != IDERR_PENDING)
    {
        //
        // do stuff...
        //
        // be careful about the return value...
    }

    return tspRet;
}



//
//	we assume here lpVarString givse a LINEDIAGNOSTICS structure with 
//	raw diagnostics filled in. 
//
LONG BuildParsedDiagnostics(LPVARSTRING lpVarString)
{
    LINEDIAGNOSTICS	*lpLineDiagnostics	= NULL;
    LINEDIAGNOSTICSOBJECTHEADER *lpParsedDiagnosticsHeader;
    LPBYTE	lpszRawDiagnostics;
    DWORD	dwRawDiagSize;
    DWORD	dwParseError;
    DWORD	dwRequiredSize;
    DWORD	dwParsedDiagAvailableSize;
    DWORD	dwParsedOffset;

    if (lpVarString == NULL)
    	return LINEERR_INVALPARAM;

    if (lpVarString->dwStringFormat != STRINGFORMAT_BINARY ||
    	lpVarString->dwStringSize < sizeof(LINEDIAGNOSTICS) )
    	return LINEERR_OPERATIONFAILED;

    lpLineDiagnostics	= (LINEDIAGNOSTICS *)
    		((LPBYTE) lpVarString + lpVarString->dwStringOffset);

    if (lpLineDiagnostics->hdr.dwSig != LDSIG_LINEDIAGNOSTICS ||
    	lpLineDiagnostics->dwRawDiagnosticsOffset == 0 ||
    	!IS_VALID_RAWDIAGNOSTICS_HDR(RAWDIAGNOSTICS_HDR(lpLineDiagnostics))
    	)
    	return LINEERR_OPERATIONFAILED;

    lpszRawDiagnostics	= RAWDIAGNOSTICS_DATA(lpLineDiagnostics);
    dwRawDiagSize		= RAWDIAGNOSTICS_DATA_SIZE(
    							RAWDIAGNOSTICS_HDR(lpLineDiagnostics));

    //	check if lpszRawDiagnostics ends with null char
    //	ToRemove: commented lines below
    if (lpszRawDiagnostics[dwRawDiagSize-1] != 0)
    	return LINEERR_OPERATIONFAILED;

    //	calculate the parsed diagnostics offset as what remains not used in the
    //	lpVarString structure
    lpParsedDiagnosticsHeader	= (LINEDIAGNOSTICSOBJECTHEADER *)
    								((LPBYTE) lpLineDiagnostics +
    									lpLineDiagnostics->hdr.dwTotalSize);
    //	align to multiple of 4
    //	TODO: align to multiple of 8
    if ( (((ULONG_PTR)lpParsedDiagnosticsHeader) & 0x3) != 0)
    {
    	lpParsedDiagnosticsHeader	= (LINEDIAGNOSTICSOBJECTHEADER *)
    					( ( ((ULONG_PTR)lpParsedDiagnosticsHeader) + 3) & (ULONG_PTR) ~3);
    }

    dwParsedOffset	= (DWORD)((LPBYTE) lpParsedDiagnosticsHeader -
    						(LPBYTE) lpLineDiagnostics);

    dwParsedDiagAvailableSize	= 0;
    if (lpVarString->dwTotalSize - sizeof(VARSTRING) >= dwParsedOffset)
    {
    	dwParsedDiagAvailableSize = lpVarString->dwTotalSize -
    								sizeof(VARSTRING) -
    								dwParsedOffset;
    }
    	// check if space for at least the header
    if (dwParsedDiagAvailableSize < sizeof(LINEDIAGNOSTICSOBJECTHEADER))
    {
    	dwParsedDiagAvailableSize = 0;
    	lpParsedDiagnosticsHeader	= NULL;
    }

    if (lpParsedDiagnosticsHeader != NULL)
    {
    	lpParsedDiagnosticsHeader->dwTotalSize	= dwParsedDiagAvailableSize;
    	lpParsedDiagnosticsHeader->dwSig		= LDSIG_PARSEDDIAGNOSTICS;
    	lpParsedDiagnosticsHeader->dwFlags		= 0;
    	lpParsedDiagnosticsHeader->dwParam		= 0;
    	lpParsedDiagnosticsHeader->dwNextObjectOffset	= 0;
    }

    dwRequiredSize	= 0;
    dwParseError = ParseRawDiagnostics(lpszRawDiagnostics,
    									lpParsedDiagnosticsHeader,
    									&dwRequiredSize);

    //	needed space, include the need for parsed structure plus alignment
    lpVarString->dwNeededSize	+= dwRequiredSize +
    			(dwParsedOffset - lpLineDiagnostics->hdr.dwTotalSize);

    //	if structure filled in, update all the information in the given structures
    if (lpParsedDiagnosticsHeader != NULL)
    {
    	lpParsedDiagnosticsHeader->dwTotalSize	=
    			min(dwParsedDiagAvailableSize, dwRequiredSize);

    	lpLineDiagnostics->dwParsedDiagnosticsOffset = dwParsedOffset;

    	// include the alignment as well, assuming the parsed part is at the end
    	lpLineDiagnostics->hdr.dwTotalSize	= dwParsedOffset +
    					lpParsedDiagnosticsHeader->dwTotalSize;

    	lpVarString->dwUsedSize		= lpLineDiagnostics->hdr.dwTotalSize +
    									sizeof(VARSTRING);
    	lpVarString->dwStringSize	= lpLineDiagnostics->hdr.dwTotalSize;
    }

	return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\tsp\cdev.h ===
// 
// Copyright (c) 1996-1997 Microsoft Corporation.
//
//
// Component
//
//		Unimodem 5.0 TSP (Win32, user mode DLL)
//
// File
//
//		CDEV.H
//		Defines class CTspDev
//
// History
//
//		11/16/1996  JosephJ Created
//
//
#include "csync.h"
#include "asyncipc.h"

class CTspDevFactory;
class CTspMiniDriver;

#define MAX_DEVICE_LENGTH 128
#define MAX_REGKEY_LENGTH 128
#define MAX_ADDRESS_LENGTH 128


// Class CTspDev maintains all the state associated with a tapi device,
// including the state of any call in progress.
//
// CTspDev contains the following embedded objects -- each of which maintain
// open-line state, call state, lower-level device state, etc:
//		LINEINFO, PHONEINFO, LLDEVINFO 
// For efficiency reasons, these objects are members of the enclosing (CTspDev)
// object, even when they are "out of scope." However these objects
// are accessed via pointers which are only valid when the objects are in
// scope. For example, the pointer for the line object is m_pLine, and it
// is set to &m_Line only when there is a line open, else it is set
// to NULL.
//
// Within LINEINFO is as a single call object, CALLINFO which maintains
// all call state information. It is referenced via m_pLine->pCall, which
// is set to NULL when there is no call in effect.


// Following are messages sent do the device task message proc.
enum
{
	MSG_ABORT,
	MSG_START,
	MSG_SUBTASK_COMPLETE,
	MSG_TASK_COMPLETE,
    MSG_DUMPSTATE    
};

DECLARE_OPAQUE32(HTSPTASK);

typedef UINT PENDING_EXCEPTION;

// Fixed-size task-specific context.
// This is the structure passed as the pContext
// in the task's handler function.
//
// Each task can choose how to use this structure.
//
typedef struct
{
    ULONG_PTR dw0;
    ULONG_PTR dw1;
    ULONG_PTR dw2;
    ULONG_PTR dw3;

}  TASKCONTEXT;

class CTspDev;


// The generic form of all TSPDEVTASK handlers
//
// A zero return value indicates a successful completion of the task.
// A nonzero return value indicates an UNsuccessful completion of the task,
// EXCEPT if it is  IDERR_PENDING, in which case the task is not done
// yet -- it will complete by returning a value other than IDERR_PENDING
// for some future call into this function.
//
// If a task completes asynchronously, the parent task (if any) is notified of
// the completion by receiving a MSG_SUBTASK_COMPLETE message, with dwParam2
// set to the return value.
//

typedef TSPRETURN (CTspDev::*PFN_CTspDev_TASK_HANDLER) (
					HTSPTASK htspTask,
					TASKCONTEXT *pContext,
					DWORD dwMsg, // SUBTASK_COMPLETE/ABORT/...
					ULONG_PTR dwParam1, //START/SUBTASK_COMPLETE: dwPhase
					ULONG_PTR dwParam2, //SUBTASK_COMPLETE: dwResult
					CStackLog *psl
					);

void
apcTaskCompletion(ULONG_PTR dwParam);


// Task Structure
//
// After partially implementing several schemes for tracking tasks and subtasks,
// I settled on a simple scheme allowing just one task (and it's stack of sub
// tasks) to exist per device at any one time. This allows us to keep the
// state in a simple array, the 1st element being the root task, and not
// maintain pointers to parents, children, and not maintain a freelist.
// If in the future we decide to impliment multiple independant tasks active
// at the same time, I recommend implementing them as an array of arrays,
// where each sub-array has the current scheme.
//
// hdr.dwFlags maintains task state:
//				fLOADED
//				fABORTING
//				fCOMPLETE
//				fASYNC_SUBTASK_PENDING
//				fROOT
//
// Note: it is important that the following structure contain no pointers
// to itself, so that it can be moved (rebased) and still be valid. This
// allows the space allocated for stack of tasks to be reallocated if required.
//


class CTspDev;

typedef struct
{
        OVERLAPPED ov;
        CTspDev *pDev;

} OVERLAPPED_EX;

// The AIPC2 structure maintains the state associated witht he async IPC
// communication between the media drivers and the device object.
// It is actually contained in the CALLINFO structure, thus enforcing
// the requirement that it is only valid (in scope) when a call is
// active.
//

typedef struct // AIPC2
{

    enum  {
        _UNINITED=0,
        _IDLE,
        _LISTENING,
        _SERVICING_CALL

    } dwState;

    BOOL fAborting; // When set, don't allow new listens to be posted.
    HTSPTASK hPendingTask; // A task waiting (pending completion)
                    // for current listen/service to complete.
    

    OVERLAPPED_EX  OverlappedEx;

    CHAR            rcvBuffer[AIPC_MSG_SIZE];
    CHAR            sndBuffer[AIPC_MSG_SIZE];

    DWORD dwPendingParam;
    HANDLE  hEvent;

    DWORD dwRefCount; // When this goes to zero, we stop the AIPC server.

    BOOL IsStarted(void)
    {
        return dwState != AIPC2::_IDLE;
    }

} AIPC2;

typedef struct
{
    DWORD dwMode;     // TAPI PHONEHOOKSWITCHMODE_* constants.
    DWORD dwGain;     // TAPI gain
    DWORD dwVolume;   // TAPI volume

} HOOKDEVSTATE;// TAPI PHONEHOOKSWITCHDEV_*


typedef struct
{

#define MAX_CALLERID_NAME_LENGTH    127
#define MAX_CALLERID_NUMBER_LENGTH  127

    // We store this stuff in ANSI and convert it to unicode on demand...
    // These are null-terminated, and 1st char is 0 if undefined.
    //

    char Name[MAX_CALLERID_NAME_LENGTH+1];
    char Number[MAX_CALLERID_NUMBER_LENGTH+1];
    
    // TODO: Time
    // TODO: Message

} CALLERIDINFO;


// This struct keeps state of one instance of a low-level device, which is
// a device which exports the mini-driver entrypoints.
typedef struct // LLDEVINFO
{
    DWORD dwDeferredTasks;
    //
    // LLDev-related tasks waiting to be scheduled.
    //
    // One or more of the flags below.
    //
    enum
    {
        fDEFERRED_NORMALIZE                    = 0x1<<0,
        fDEFERRED_HYBRIDWAVEACTION             = 0x1<<1,
    };


    DWORD dwDeferredHybridWaveAction;

    UINT HasDeferredTasks(void)
    {
        return LLDEVINFO::dwDeferredTasks;
    }

    void SetDeferredTaskBits(DWORD dwBits)
    {
        LLDEVINFO::dwDeferredTasks |= dwBits;
    }

    void ClearDeferredTaskBits(DWORD dwBits)
    {
        LLDEVINFO::dwDeferredTasks &= ~dwBits;
    }

    UINT AreDeferredTaskBitsSet(DWORD dwBits)
    {
        return LLDEVINFO::dwDeferredTasks & dwBits;
    }


    HOOKDEVSTATE HandSet;
    HOOKDEVSTATE SpkrPhone;

    enum
    {
        fOFFHOOK            = 0x1,
        fMONITORING         = 0x1<<1,
        fSTREAMING_VOICE    = 0x1<<2,
        fHANDSET_OPENED     = 0x1<<3,
        fSTREAMMODE_PLAY    = 0x1<<4,
        fSTREAMMODE_RECORD  = 0x1<<5,
        fSTREAMMODE_DUPLEX  = 0x1<<6,
        fSTREAMDEST_PHONE   = 0x1<<7,
        fSTREAMDEST_LINE    = 0x1<<8,

        fDIALING            = 0x1<<9,
        fANSWERING          = 0x1<<10,
        fCONNECTED          = 0x1<<11,
        fDROPPING           = 0x1<<12,


        fPASSTHROUGH        = 0x1<<13
    };

    enum
    {
        LS_ONHOOK_NOTMONITORING = 0,
        LS_ONHOOK_MONITORING    = fMONITORING, // for incoming calls
        LS_ONHOOK_PASSTHROUGH   = fPASSTHROUGH,
        LS_PASSTHROUGH          = fPASSTHROUGH,

        LS_OFFHOOK_DIALING     = fOFFHOOK | fDIALING,
        LS_OFFHOOK_ANSWERING   = fOFFHOOK | fANSWERING,
        LS_OFFHOOK_CONNECTED   = fOFFHOOK | fCONNECTED,
        LS_OFFHOOK_DROPPING    = fOFFHOOK | fDROPPING,
        LS_OFFHOOK_PASSTHROUGH  = fOFFHOOK | fPASSTHROUGH,
        LS_CONNECTED_PASSTHROUGH  = fOFFHOOK | fPASSTHROUGH | fCONNECTED,
        LS_OFFHOOK_UNKNOWN     = fOFFHOOK

    } LineState;

    enum
    {
        LMM_NONE,
        LMM_VOICE,
        LMM_OTHER

    } LineMediaMode;


    enum
    {
        PHONEONHOOK_NOTMONITORNING  = 0, // for handset events
        PHONEONHOOK_MONITORNING     = fMONITORING,    // for handset events
        PHONEOFFHOOK_IDLE           = fOFFHOOK,

        PHONEOFFHOOK_HANDSET_OPENED = fOFFHOOK | fHANDSET_OPENED,
            //
            // This is done for audio to/from phone.
            // Can only switch to this state
            // if line is on-hook (LineState is in one of
            // the LINEONHOOK_* states).
            //

    } PhoneState;

    enum
    {
        STREAMING_NONE     = 0,

        STREAMING_PLAY_TO_PHONE
                      = fSTREAMING_VOICE|fSTREAMDEST_PHONE|fSTREAMMODE_PLAY,
        STREAMING_RECORD_TO_PHONE
                      = fSTREAMING_VOICE|fSTREAMDEST_PHONE|fSTREAMMODE_RECORD,
        STREAMING_DUPLEX_TO_PHONE
                      = fSTREAMING_VOICE|fSTREAMDEST_PHONE|fSTREAMMODE_DUPLEX,

        STREAMING_PLAY_TO_LINE
                      = fSTREAMING_VOICE|fSTREAMDEST_LINE|fSTREAMMODE_PLAY,
        STREAMING_RECORD_TO_LINE
                      = fSTREAMING_VOICE|fSTREAMDEST_LINE|fSTREAMMODE_RECORD,
        STREAMING_DUPLEX_TO_LINE
                      = fSTREAMING_VOICE|fSTREAMDEST_LINE|fSTREAMMODE_DUPLEX,

    } StreamingState;

    UINT IsStreamingVoice(void)
    {
        return StreamingState & fSTREAMING_VOICE;
    }

    UINT IsStreamingToPhone(void)
    {
        return StreamingState & fSTREAMDEST_PHONE;
    }

    UINT IsStreamingToLine(void)
    {
        return StreamingState & fSTREAMDEST_LINE;
    }

    UINT IsStreamModePlay(void)
    {
        return StreamingState & fSTREAMMODE_PLAY;
    }

    UINT IsStreamModeRecord(void)
    {
        return StreamingState & fSTREAMMODE_RECORD;
    }

    UINT IsStreamModeDuplex(void)
    {
        return StreamingState & fSTREAMMODE_DUPLEX;
    }

    UINT IsPhoneOffHook(void)
    {
        return PhoneState & fOFFHOOK;
    }

    UINT IsLineOffHook(void)
    {
        return LineState & fOFFHOOK;
    }

    UINT IsPassthroughOn(void)
    {
        return LineState & fPASSTHROUGH;
    }

    UINT IsCurrentlyMonitoring(void)
    {
        return LineState == LS_ONHOOK_MONITORING;
    }


    UINT IsLineConnected(void)
    {
        return      LineState     & fCONNECTED;
    }

    UINT IsLineConnectedVoice(void)
    {
        return      LineState     == LS_OFFHOOK_CONNECTED
               &&   LineMediaMode == LMM_VOICE;
    }

    UINT IsHandsetOpen(void)
    {
        return PhoneState == PHONEOFFHOOK_HANDSET_OPENED;
    }

    UINT  CanReallyUnload(void)
    {
        return   ! (    LLDEVINFO::dwRefCount
                    ||  LLDEVINFO::IsStreamingVoice()
                    ||  LLDEVINFO::fdwExResourceUsage
                    ||  LLDEVINFO::fLLDevTaskPending
                    ||  LLDEVINFO::htspTaskPending
                    ||  LLDEVINFO::pAipc2
                   );
    }


    BOOL IsModemInited(void)
    {
        return fModemInited;
    }

	enum {
	fRES_AIPC           = 0x1<<0,  // need to do AIPC
	fRESEX_MONITOR      = 0x1<<1,  // need to monitor.
	fRESEX_PASSTHROUGH  = 0x1<<2,  // need to switch to passthrough.
	fRESEX_USELINE      = 0x1<<3   // need to use line actively
	};

    #define  fEXCLUSIVE_RESOURCE_MASK  (   LLDEVINFO::fRESEX_MONITOR      \
                                         | LLDEVINFO::fRESEX_PASSTHROUGH  \
                                         | LLDEVINFO::fRESEX_USELINE)     

    // keeping track of resources opened...
	DWORD dwRefCount;
	DWORD fdwExResourceUsage; // One or more fRESEX*, indicating which
                              // exclusive resources the clients have claimed...

    UINT  IsLineUseRequested (void)
    {
        return fdwExResourceUsage & fRESEX_USELINE;
    }

    UINT  IsPassthroughRequested (void)
    {
        return fdwExResourceUsage & fRESEX_PASSTHROUGH;
    }

    UINT  IsMonitorRequested (void)
    {
        return fdwExResourceUsage & fRESEX_MONITOR;
    }

    DWORD dwMonitorFlags;
    //
    // If Monitoring is requested, this saves the current monitor flags.
    //

	HANDLE hModemHandle;    // Handle returned by UmOpenModem
	HANDLE hComm;           // COMM handle returned by UmOpenModem() (for aipc)
    HKEY hKeyModem;
	HTSPTASK htspTaskPending;
    BOOL fModemInited;
    BOOL fLoggingEnabled;
    BOOL fLLDevTaskPending;
    BOOL fDeviceRemoved;



    BOOL IsLoggingEnabled(void) {return fLoggingEnabled;}


    AIPC2 Aipc2;
    AIPC2 *pAipc2;
    //      See comments above the AIPC definition above for details. Note
    //      the pAipc is set to &Aipc2 IFF the AIPC information is in scope,
    //      otherwise it is set to NULL.
    //


    BOOL IsLLDevTaskPending(void)
    {
        return LLDEVINFO::fLLDevTaskPending;
    }


    BOOL IsDeviceRemoved(void)
    {
        //
        // If TRUE, this means that the h/w has gone. Don't bother issueing any
        // more commands, even hangup.
        //
        return LLDEVINFO::fDeviceRemoved;
    }

} LLDEVINFO;


// CALLINFO maintains all state that is relevant only when a call is
// in progress.
//
typedef struct
{
	DWORD        dwState;
    //
    // dwState can be one or more valid combinations of...
    // Note: NT4.0 Unimodem had CALL_ALLOCATED -- this is equivalent to
    // m_pLine->pCall being NON-NULL...
    //
    enum
    {
        fCALL_ACTIVE                 = 0x1<<0,
        fCALL_INBOUND                = 0x1<<1,
        fCALL_ABORTING               = 0x1<<2,
        fCALL_HW_BROKEN              = 0x1<<3,
        fCALL_VOICE                  = 0x1<<4,
        fCALL_MONITORING_DTMF        = 0x1<<6,
        fCALL_MONITORING_SILENCE     = 0x1<<7,
        fCALL_GENERATE_DIGITS_IN_PROGRESS
                                     = 0x1<<8,
        fCALL_OPENED_LLDEV           = 0x1<<9,
        fCALL_WAITING_IN_UNLOAD      = 0x1<<10,
    #if (TAPI3)
        fCALL_MSP                    = 0x1<<11,
        //
        //      This is an MSP call...
        //
    #endif // TAPI3

        fCALL_ANSWERED               = 0x1<<12

        // fCALL__ACTIVE is set while the call exists from TAPI's perspective.
        // More specifically ...
        //     Outgoing calls: set just before successful  async completion of
        //         lineMakeCall, which is just after initiating dialing, and if
        //         dialtone detection is enabled, just after successfully 
        //         verifying dialtone.
        //
        //     Incoming calls: set just after notifying TAPI via the
        //         LINE_NEWCALL message, which is on receiving the 1st ring.
        //
        //     fCALL_ACTIVE is cleared at the point of sending
        //     LINECALLSTATE_IDLE.

        // fCALL_INBOUND is set for incoming calls at the point fCALL_ACTIVE
        // is set. It is cleared on unloading the call (mfn_UnloadCall).

        // fCALL_ABORTING is called if a TAPI-initiated hangup is in progress
        // (via lineDrop or lineCloseCall). It is cleared on the async
        // completion of lineDrop and on completion of lineCloseCall, just
        // before sending the LINECALLSTATE_IDLE.
        
        // fCALL_HW_BROKEN if set indicates a possibly
        // non-recoverable hardware error
        // was detected during the course of the call. HW_BROKEN is set if
        // (a) the minidriver sends an unsolicited hw-failure async response or
        // (b) if there was a failure while re-starting monitoring after
        // the call (note that unlike in NT4.0, we re-start monitoring
        // as part of the post-call processing, and only send LINECALLSTATE_IDLE
        // AFTER the monitoring is complete).
        //
        // If this bit is set, and if the line is open for monitoring,
        // then a LINE_CLOSE event is sent up to TAPI when unloading the
        // call (mfn_UnloadCall).
        //

        // NOTE: LINECALLSTATE_IDLE is only sent on the following circumstances:
        // * Async completion of lineDrop
        // * Completion of lineCloseCall
        // * Inter-ring timeout when call is still on-hook.

        // fCALL_VOICE  is set IFF the modem supports class 8 and it 
        // is an interactive or automated voice call -- i.e, modem is in class8.

        // fCALL_OPENED_LLDEV  is set IFF the call had loaded the device
        // (this should always be set!). Note that LoadLLDev keeps a refcount.

        // fCALL_GENERATE_DIGITS_IN_PROGRESS is set IFF the currently active
        // task is the one that is generating digits.

        //
        // fCALL_ANSWER_PENDING is set if lineanswer has been called and we
        // are waiting to send on async reply. If this is set we won't send
        // more rings to the app, so it won't call line answer again.

    };

    DWORD dwMonitoringMediaModes;
    //
    //  See implementation of TSPI_lineMonitorMedia -- we use this
    //  field to decide whether to report fax and/or data media notifications
    //  from the minidriver.
    //


    DWORD dwLLDevResources;
    //
    //  Lower-level device (LLDev) resources used by this call, one
    //  or more LLDEVINFO:fRES* flags. These were specified when the call
    //  called mfn_OpenLLDev and must be specified when calling
    //  mfn_CloseLLDev for this call. the fRESEX_PASSTHROUGH flag
    //  may be set/cleared while the call is in progress if the app
    //  changes the passthrough mode in the middle of the call.
    //

    DWORD dwDeferredTasks;
    //
    // Call-related tasks waiting to be scheduled.
    // For example we are in connected voice
    // mode now and need to wait until we are out of it before
    // we try to process a TSPI_lineDrop.
    //
    // One or more of the flags below.
    //
    enum
    {
        fDEFERRED_TSPI_LINEMAKECALL     = 0x1<<0, // Associated ReqID below...
        fDEFERRED_TSPI_LINEDROP         = 0x1<<1, // Associated ReqID below...
        fDEFERRED_TSPI_GENERATEDIGITS   = 0x1<<3
    };

    DWORD dwDeferredMakeCallRequestID;
    DWORD dwDeferredLineDropRequestID;

    //
    // Following is for deferred lineGenerateDigits -- only valid
    // if the fDEFERRED_TSPI_GENERATEDIGITS bit is set in dwDeferedTasks.
    // Note that the Tones and end-to-end-id of a lineGenerateDigits in
    // progress is maintained in the task handler (TH_CallGenerateDigits)
    // context.
    //
    char   *pDeferredGenerateTones;
    DWORD  dwDeferredEndToEndID;

	HTAPIDIALOGINSTANCE hDlgInst;        // Dialog thread instance
	DWORD        fUIDlg;                 // current dialogs

	HTAPICALL    htCall;                 // TAPI's version of the call handle. 

	HANDLE       hLights;                // Lights thread handle
	DWORD        dwNegotiatedRate;       // Negotiated BPS speed returned
										 // from mini driver
    DWORD        dwConnectionOptions;    // These are the datamodem connection
                                         // options that are reported by
                                         // the minidriver via 
                                         // UM_NEGOTIATED_OPTIONS, and back 
                                         // up to the TSPI via MODEMSETTINGS
                                         // structure in COMMCONFIG.



	DWORD        dwAppSpecific;          // Application specific
	DWORD        dwCallState;            // Current TAPI call state
	DWORD        dwCallStateMode;        // Current TAPI call state mode
    SYSTEMTIME   stStateChange;          // Time the call entered current state.

	DWORD        dwDialOptions;          // Options set in a lineMakeCall


	CHAR         szAddress[MAX_ADDRESS_LENGTH+1];
	DWORD        dwCurBearerModes;   // The current media bearer modes.
									 // Plural because we keep track of
									 // PASSTHROUGH _and_ the real b-mode
	DWORD        dwCurMediaModes;        // The current media modes

    DWORD        dwRingCount;       // Count of the number of rings for an
									// incoming call.
    DWORD        dwRingTick;        // TickCount for when the last ring occured

    // This for monitoring tone stuff (lineMonitorTones). Unimodem
    // can only monitor silence tones.
    //
    DWORD        dwToneAppSpecific;
    DWORD        dwToneListID;
    DWORD        dwDTMFMonitorModes; // One or more TAPI LINEDIGITMODE_*



    BOOL fCallTaskPending;  // True IFF a call-related task is pending.
                        // This is used when deciding to abort the
                        // current task on killing the call. The
                        // task could be for some other purpose, such
                        // as phone-related  -- in which case fCallTaskPending 
                        // would be false.


    // The following keeps track of raw call diagnostic info.
    // It is only assigned if there is valid diagnostic info.
    // It is the responsibility of UnloadCall to LocalFree pbRawDiagnostics
    // if it is non-null.
    struct
    {
        BYTE *pbRaw; // Will be null-terminated.
        UINT cbUsed; // == lstrlen(pbRaw).
                     // Will be < the true allocated size of pbRaw.
                     // Note that this does NOT include the terminating NULL,

    } DiagnosticData;

    #define DIAGNOSTIC_DATA_BUFFER_SIZE 1024
             // Size of the dignostics data buffer. This is the max
             // amount of diagnostic information that is reported.

    void SetStateBits(DWORD dwBits)
    {
        CALLINFO::dwState |= dwBits;
    }

    void ClearStateBits(DWORD dwBits)
    {
        CALLINFO::dwState &= ~dwBits;
    }

    UINT IsOpenedLLDev(void)
    {
        return CALLINFO::dwState & fCALL_OPENED_LLDEV;
    }

    UINT IsUsingAIPC(void)
    {
        return CALLINFO::dwLLDevResources &  LLDEVINFO::fRES_AIPC;
    }

    // Returns nonzero value if call is in the active state...
    UINT IsActive(void)
    {
        return CALLINFO::dwState & fCALL_ACTIVE;
    }

    // Returns nonzero value if it is an inbound call...
    UINT IsInbound(void)
    {
        return CALLINFO::dwState & fCALL_INBOUND;
    }

    // Returns nonzero value if it is an inbound call...
    UINT IsAborting(void)
    {
        return CALLINFO::dwState & fCALL_ABORTING;
    }

    UINT IsCallAnswered(void)
    {
        return CALLINFO::dwState & fCALL_ANSWERED;
    }


    BOOL IsConnectedDataCall(void)
    {
            return      (CALLINFO::dwCallState == LINECALLSTATE_CONNECTED)
                    &&  (CALLINFO::dwCurMediaModes & LINEMEDIAMODE_DATAMODEM)
                    &&  !(CALLINFO::dwState & fCALL_ABORTING);
    }

    BOOL IsConnectedVoiceCall(void)
    {
            return      (CALLINFO::dwCallState == LINECALLSTATE_CONNECTED)
                    &&  (CALLINFO::dwState & fCALL_VOICE)
                    &&  !(CALLINFO::dwState & fCALL_ABORTING);
    }

    // Returns nonzero value if there was a possibly-unrecoverable error
    // during the call.
    //
    UINT IsHWBroken(void)
    {
        return CALLINFO::dwState &  fCALL_HW_BROKEN;
    }

    UINT IsVoice(void)
    {
        return CALLINFO::dwState & fCALL_VOICE;
    }

    UINT IsMonitoringSilence(void)
    {
        return CALLINFO::dwState & fCALL_MONITORING_SILENCE;
    }

    UINT IsMonitoringDTMF(void)
    {
        return CALLINFO::dwState & fCALL_MONITORING_DTMF;
    }

    UINT IsPassthroughCall(void)
    {
	    return CALLINFO::dwCurBearerModes&LINEBEARERMODE_PASSTHROUGH;
    }

    UINT IsWaitingInUnload()
    {
	    return CALLINFO::dwState & fCALL_WAITING_IN_UNLOAD;
    }


#if (TAPI3)
    UINT IsMSPCall()
    {
	    return CALLINFO::dwState &  fCALL_MSP;
    }
#endif // TAPI3

    UINT IsGeneratingDigits(void)
    {
        return CALLINFO::dwState &  fCALL_GENERATE_DIGITS_IN_PROGRESS;
    }

    BOOL IsCallTaskPending(void)
    {
        return CALLINFO::fCallTaskPending;
    }

    UINT HasDeferredTasks(void)
    {
        return CALLINFO::dwDeferredTasks;
    }

    void SetDeferredTaskBits(DWORD dwBits)
    {
        CALLINFO::dwDeferredTasks |= dwBits;
    }

    void ClearDeferredTaskBits(DWORD dwBits)
    {
        CALLINFO::dwDeferredTasks &= ~dwBits;
    }

    UINT AreDeferredTaskBitsSet(DWORD dwBits)
    {
        return CALLINFO::dwDeferredTasks & dwBits;
    }

    struct
    {
        DWORD               dwOptions;
        HTAPIDIALOGINSTANCE htDlgInst;

        //
        // The following is only valid when a dialog, such as pre-connect
        // terminal, is actually up.
        //
        DWORD dwType;
        HTSPTASK htspTaskTerminal;

    } TerminalWindowState;

    // The following is used for call timeout
    HANDLE hTimer;

    CALLERIDINFO CIDInfo;

    TSPRETURN    TalkDropStatus;
    BOOL         TalkDropButtonPressed;
    HTSPTASK     TalkDropWaitTask;

    BOOL         bDialTone;

} CALLINFO;


// LINEINFO maintains all state that is relevant only when a line
// is open. This includes CALLINFO, obviously.
//
typedef struct // LINEINFO;
{
	DWORD       dwDetMediaModes;   // The current detection media modes
	DWORD 		dwState;

    enum
    {
        fLINE_OPENED_LLDEV           = 0x1<<0,
        fLINE_SENT_LINECLOSE         = 0x1<<1
    };

    void SetStateBits(DWORD dwBits)
    {
        LINEINFO::dwState |= dwBits;
    }

    void ClearStateBits(DWORD dwBits)
    {
        LINEINFO::dwState &= ~dwBits;
    }

    UINT IsOpenedLLDev(void)
    {
        return LINEINFO::dwState & fLINE_OPENED_LLDEV;
    }

    UINT HasSentLINECLOSE(void)
    {
        return LINEINFO::dwState & fLINE_SENT_LINECLOSE;
    }

    LINEEVENT   lpfnEventProc;
	HTAPILINE   htLine;
	HDRVLINE    hdLine;

	// The CALLINFO struct Call is "in scope" only when a TAPI call is active.
	// pCall is to &Call IFF a call is active, NULL otherwise. Most functions
	// access the call-info via pCall.
	//
	CALLINFO	Call;
	CALLINFO	*pCall;

    #if 0
    BOOL    fConfigChanged; // TRUE IFF config has changed so modem
                            // needs to be re-inited before next call
                            // is dialed/answered.
    #endif // 0

    UINT IsMonitoring(void)
    {
	    return  dwDetMediaModes;
    }
    //
    // T3-related information (MSP stuff) is maintained in the structure
    // below...
    //

#if (TAPI3)
    struct
    {
//        HTAPIMSPLINE htMSPLine;
          DWORD   MSPClients;

    } T3Info;
#endif // TAPI3


} LINEINFO;


typedef struct // PHONEINFO
{
	DWORD 		dwState;

    enum
    {
        fPHONE_OPENED_LLDEV          = 0x1<<0,
        fPHONE_SENT_PHONECLOSE         = 0x1<<1,
        fPHONE_IS_ABORTING           = 0x1<<2,
        fPHONE_OFFHOOK                = 0x1<<4,
        fPHONE_HW_BROKEN              = 0x1<<5,
        fPHONE_WAITING_IN_UNLOAD      = 0x1<<6

        // fPHONE_SENT_PHONECLOSE is sent after the PHONE_CLOSE event
        // is sent up to tapi. We keep this state so that we don't
        // send up more than PHONE_CLOSE messages.

        // fPHONE_OFFHOOK is set when the phone is off-hook -- one of
        // the hookswitchdevs is off hook.

        // fPHONE_IS_ABORTING is called if a phone close is in process.
        
        // fPHONE_HW_BROKEN if set indicates a possibly
        // non-recoverable hardware error
        // was detected during the course of the using the phone.
        // HW_BROKEN is set if
        // (a) the minidriver sends an unsolicited hw-failure async response or
        // If this bit is set,
        // then a PHONE_CLOSE event is sent up to TAPI.
        

        // fPHONE_LOADED_AIPC  is set IFF the call is in a mode where it
        // is accepting IPC calls via the AIPC mechanism.

        // fCALL_OPENED_LLDEV  is set IFF the call had loaded the device
        // (this should always be set!). Note that LoadLLDev keeps a refcount.

        // fPHONE_WAITING_IN_UNLOAD if it is blocked in phoneClose, waiting on
        // the phone completion event.
        //

    };



    DWORD dwDeferredTasks;
    //
    // Phone-related tasks waiting to be scheduled.
    // For example we are in connected voice
    // mode now and need to wait until we are out of it before
    // we try to process a Gain message...
    //
    // One or more of the flags below.
    //
    enum
    {
        blah = 0x1<<0
    };

    void SetStateBits(DWORD dwBits)
    {
        PHONEINFO::dwState |= dwBits;
    }

    void ClearStateBits(DWORD dwBits)
    {
        PHONEINFO::dwState &= ~dwBits;
    }

    UINT IsOpenedLLDev(void)
    {
        return PHONEINFO::dwState & fPHONE_OPENED_LLDEV;
    }

    // Returns nonzero value if it is an inbound call...
    UINT IsOffHook(void)
    {
        return PHONEINFO::dwState & fPHONE_OFFHOOK;
    }

    // Returns nonzero value if it is an inbound call...
    UINT IsAborting(void)
    {
        return PHONEINFO::dwState & fPHONE_IS_ABORTING;
    }

    // Returns nonzero value if there was a possibly-unrecoverable error
    // during the call.
    //
    UINT IsHWBroken(void)
    {
        return PHONEINFO::dwState &  fPHONE_HW_BROKEN;
    }

    UINT IsWaitingInUnload()
    {
	    return PHONEINFO::dwState & fPHONE_WAITING_IN_UNLOAD;
    }

    UINT HasSentPHONECLOSE()
    {
	    return PHONEINFO::dwState & fPHONE_SENT_PHONECLOSE;
    }


    BOOL IsPhoneTaskPending(void)
    {
        BOOL fRet = PHONEINFO::fPhoneTaskPending;

        // ASSERT(!fRet || (fRet && m_uTaskDepth));
        
        return fRet;
    }

    UINT HasDeferredTasks(void)
    {
        return PHONEINFO::dwDeferredTasks;
    }

    void SetDeferredTaskBits(DWORD dwBits)
    {
        PHONEINFO::dwDeferredTasks |= dwBits;
    }

    void ClearDeferredTaskBits(DWORD dwBits)
    {
        PHONEINFO::dwDeferredTasks &= ~dwBits;
    }

    UINT AreDeferredTaskBitsSet(DWORD dwBits)
    {
        return PHONEINFO::dwDeferredTasks & dwBits;
    }


    PHONEEVENT   lpfnEventProc;
	HTAPIPHONE   htPhone;
	HDRVPHONE    hdPhone;

    // Only one TAPI phone call may be "current" at a time.
    // Current implies there is
    // a task active that is processing the TSPI call. There could be
    // other TSPI calls that have arrived subsequently and are queued for
    // execution after the current task is complete. These queued calls
    // are located in QueuedTask (only one task may be queued currently).
    //
    // State for the "current" TSPI call is maintained in the structure below.
    // When the request is completed asynchronously, the
    // LONG result is saved in lResult until the callback function
    // is called.
    //
    struct
    {
        DRV_REQUESTID dwRequestID;
        LONG   lResult;

    } CurTSPIPhoneCallInfo;



    DWORD dwPendingSpeakerMode;
    DWORD dwPendingSpeakerVolume;
    DWORD dwPendingSpeakerGain;

    BOOL fPhoneTaskPending;  // True IFF a call-related task is pending.
                        // This is used when deciding to abort the
                        // current task on killing the call. The
                        // task could be for some other purpose, such
                        // as phone-related  -- in which case fPhoneTaskPending 
                        // would be false.

} PHONEINFO;




class CTspDev
{

public:

	void
	Unload(
		HANDLE hEvent,
		LONG *plCounter
		);


	TSPRETURN
	AcceptTspCall(
        BOOL fFromExtension,
		DWORD dwRoutingInfo,
		void *pvParams,
		LONG *plRet,
		CStackLog *psl
		);


	TSPRETURN
	BeginSession(
		HSESSION *pSession,
		DWORD dwFromID
	)
	{
		return m_sync.BeginSession(pSession, dwFromID);
	}

    void
    NotifyDefaultConfigChanged(CStackLog *psl);
    //  The device's default settings have changed, by some external
    //  component (most likely the CPL), so we need to re-read them.
    //

	void EndSession(HSESSION hSession)
	{
		m_sync.EndSession(hSession);
	}


    TSPRETURN
    RegisterProviderInfo(
                ASYNC_COMPLETION cbCompletionProc,
                HPROVIDER hProvider,
                CStackLog *psl
                );

    void
    ActivateLineDevice(
                DWORD dwLineID,
                CStackLog *psl
                );


    void
    ActivatePhoneDevice(
                DWORD dwPhoneID,
                CStackLog *psl
                );
    
    void
    DumpState(
            CStackLog *psl
            );
    

	~CTspDev();


	DWORD GetLineID (void)
	{
        return m_StaticInfo.dwTAPILineID;
	}

	DWORD GetPhoneID (void)
	{
        return m_StaticInfo.dwTAPIPhoneID;
	}

	DWORD GetPermanentID (void)
	{
        return m_StaticInfo.dwPermanentLineID;
	}

    TSPRETURN
    GetName(
		    TCHAR rgtchDeviceName[],
		    UINT cbName
        )
    {
        TSPRETURN tspRet = 0;

        UINT u = (lstrlen(m_StaticInfo.rgtchDeviceName)+1)*sizeof(TCHAR);

        if (u>cbName)
        {
            tspRet = IDERR_GENERIC_FAILURE;
            goto end;
        }

        CopyMemory(
            rgtchDeviceName,
            m_StaticInfo.rgtchDeviceName,
            u
            );

    end:

        return tspRet;
    }


    BOOL IsPhone(void)
    {
        return (mfn_IsPhone()!=0); // Note that mfn_IsPhone returns a UINT,
                                   // not BOOL.
    }

    BOOL IsLine(void)
    {
        return (mfn_IsLine()!=0); // Note that mfn_IsPhone returns a UINT,
                                   // not BOOL.
    }

	void
    MDAsyncNotificationHandler(
            DWORD     MessageType,
            ULONG_PTR  dwParam1,
            ULONG_PTR  dwParam2
            );

    void
    NotifyDeviceRemoved(
        CStackLog *psl
        );
        //
        //  The h/w has been removed. Don't bother to issue any more
        //  mini-driver commands.
        //

    static void APIENTRY
    MDSetTimeout (
        CTspDev *pThis);

    static void CALLBACK
    MDRingTimeout (
        CTspDev *pThis,
        DWORD,
        DWORD);


private:

    const TCHAR       *
    mfn_GetLineClassList(void)
    {
        return m_StaticInfo.szzLineClassList;
    }

    UINT
    mfn_GetLineClassListSize(void)
    {
        return m_StaticInfo.cbLineClassList;
    }

    const TCHAR       *
    mfn_GetPhoneClassList(void)
    {
        return m_StaticInfo.szzPhoneClassList;
    }

    UINT
    mfn_GetPhoneClassListSize(void)
    {
        return m_StaticInfo.cbPhoneClassList;
    }

    const TCHAR       *
    mfn_GetAddressClassList(void)
    {
        return m_StaticInfo.szzAddressClassList;
    }

    UINT
    mfn_GetAddressClassListSize(void)
    {
        return m_StaticInfo.cbAddressClassList;
    }

    void
    mfn_KillCurrentDialog(
        CStackLog *psl
    );

    void
    mfn_KillTalkDropDialog(
        CStackLog *psl
        );


	friend class CTspDevFactory;
	friend void tCTspDev0(void);  // For component testing.
    friend void apcTaskCompletion(ULONG_PTR dwParam);

    friend
    VOID WINAPI
    apcAIPC2_ListenCompleted
    (
        DWORD              dwErrorCode,
        DWORD              dwBytes,
        LPOVERLAPPED       lpOv
    );


	// Only CTspDevFactory is authorized to create and load CTSPDevs.
	CTspDev(void);


	TSPRETURN
	Load(
		HKEY hkDevice,
		HKEY hkUnimodem,
		LPWSTR lpwszProviderName,
		LPSTR lpszDriverKey,
		CTspMiniDriver *pMD,
		HANDLE hThreadAPC,
		CStackLog *psl
		);

    //=========================================================================
    // UTILITY Task Handlers
    //
    //      These handlers are not tied (and do not refer to)
    //      m_pLine, m_pLine->pCall or m_pPhone.
    //
    //  All utility tasks names begin with prefix "mfn_TH_Util"
    //  They are implemented in cdevtask.cpp
    //
    //=========================================================================

	TSPRETURN
	mfn_TH_UtilNOOP(
                HTSPTASK htspTask,
                TASKCONTEXT *pContext,
                DWORD dwMsg,
                ULONG_PTR dwParam1,
                ULONG_PTR dwParam2,
                CStackLog *psl
                );
    static PFN_CTspDev_TASK_HANDLER s_pfn_TH_UtilNOOP;
    //
    // Any task that wants to make sure that it's called in the APC
    // thread's context can start by executing this task, which
    // does nothing but completes asynchronously.
    //
    //
    //  START_MSG Params: None
    //


    //=========================================================================
    // CALL-RELATED Task Handlers
    //
    //      These handlers expect a valid m_pLine and m_pLine->m_pCall
    //
    //  All tasks names begin with prefix "mfn_TH_Call"
    //  They are implemented in cdevcall.cpp
    //
    //=========================================================================

     TSPRETURN
     mfn_TH_CallWaitForDropToGoAway(
					HTSPTASK htspTask,
                    TASKCONTEXT *pContext,
					DWORD dwMsg,
					ULONG_PTR dwParam1,
					ULONG_PTR dwParam2,
					CStackLog *psl
					);
    static PFN_CTspDev_TASK_HANDLER s_pfn_TH_CallWaitForDropToGoAway;


     TSPRETURN
     mfn_TH_CallMakeTalkDropCall(
					HTSPTASK htspTask,
                    TASKCONTEXT *pContext,
					DWORD dwMsg,
					ULONG_PTR dwParam1,
					ULONG_PTR dwParam2,
					CStackLog *psl
					);
    static PFN_CTspDev_TASK_HANDLER s_pfn_TH_CallMakeTalkDropCall;


	TSPRETURN
	mfn_TH_CallMakeCall(
						HTSPTASK htspTask,
					    TASKCONTEXT *pContext,
						DWORD dwMsg, // SUBTASK_COMPLETE/ABORT/...
						ULONG_PTR dwParam1, //SUBTASK_COMPLETE: dwPhase
						ULONG_PTR dwParam2, // SUBTASK_COMPLTE: dwResult
						CStackLog *psl
						);
    static PFN_CTspDev_TASK_HANDLER s_pfn_TH_CallMakeCall;

	TSPRETURN
	mfn_TH_CallMakeCall2(
						HTSPTASK htspTask,
					    TASKCONTEXT *pContext,
						DWORD dwMsg, // SUBTASK_COMPLETE/ABORT/...
						ULONG_PTR dwParam1, //SUBTASK_COMPLETE: dwPhase
						ULONG_PTR dwParam2, // SUBTASK_COMPLTE: dwResult
						CStackLog *psl
						);
    static PFN_CTspDev_TASK_HANDLER s_pfn_TH_CallMakeCall2;
    //
    //  START_MSG Params:
    //      dwParam1: Tapi Request ID
    //

    TSPRETURN
    mfn_TH_CallMakePassthroughCall(
                        HTSPTASK htspTask,
					    TASKCONTEXT *pContext,
                        DWORD dwMsg,
                        ULONG_PTR dwParam1,
                        ULONG_PTR dwParam2,
                        CStackLog *psl
                        );
    static PFN_CTspDev_TASK_HANDLER s_pfn_TH_CallMakePassthroughCall;
    //
    //  START_MSG Params:
    //      dwParam1: Tapi Request ID
    //

	TSPRETURN
	mfn_TH_CallDropCall(
						HTSPTASK htspTask,
					    TASKCONTEXT *pContext,
						DWORD dwMsg,
						ULONG_PTR dwParam1,
						ULONG_PTR dwParam2,
						CStackLog *psl
						);
    static PFN_CTspDev_TASK_HANDLER s_pfn_TH_CallDropCall;
    //
    //  START_MSG Params:
    //      dwParam1: Tapi Request ID
    //


	TSPRETURN
	mfn_TH_CallAnswerCall(
						HTSPTASK htspTask,
					    TASKCONTEXT *pContext,
						DWORD dwMsg,
						ULONG_PTR dwParam1,
						ULONG_PTR dwParam2,
						CStackLog *psl
						);
    static PFN_CTspDev_TASK_HANDLER s_pfn_TH_CallAnswerCall;
    //
    //  START_MSG Params:
    //      dwParam1: Tapi Request ID
    //


	TSPRETURN
	mfn_TH_CallGenerateDigit(
						HTSPTASK htspTask,
					    TASKCONTEXT *pContext,
						DWORD dwMsg,
						ULONG_PTR dwParam1,
						ULONG_PTR dwParam2,
						CStackLog *psl
						);
    static PFN_CTspDev_TASK_HANDLER s_pfn_TH_CallGenerateDigit;
    //
    //  START_MSG Params:
    //      dwParam1: dwEndToEndID
    //      dwParam2: lpszDigits (will only be valid on START_MSG)
    //

	TSPRETURN
	mfn_TH_CallStartTerminal(
						HTSPTASK htspTask,
					    TASKCONTEXT *pContext,
						DWORD dwMsg,
						ULONG_PTR dwParam1,
						ULONG_PTR dwParam2,
						CStackLog *psl
						);
    static PFN_CTspDev_TASK_HANDLER s_pfn_TH_CallStartTerminal;
    //
    //  START_MSG Params:
    //      dwParam1: dwType ((UMTERMINAL_[PRE|POST])|UMMANUAL_DIAL)
    //      dwParam2: Unused
    //

	TSPRETURN
	mfn_TH_CallPutUpTerminalWindow(
						HTSPTASK htspTask,
					    TASKCONTEXT *pContext,
						DWORD dwMsg,
						ULONG_PTR dwParam1,
						ULONG_PTR dwParam2,
						CStackLog *psl
						);
    static PFN_CTspDev_TASK_HANDLER s_pfn_TH_CallPutUpTerminalWindow;
    //
    //  START_MSG Params:
    //      dwParam1: dwType ((UMTERMINAL_[PRE|POST])|UMMANUAL_DIAL)
    //      dwParam2: Unused
    //

	TSPRETURN
	mfn_TH_CallSwitchFromVoiceToData(
						HTSPTASK htspTask,
					    TASKCONTEXT *pContext,
						DWORD dwMsg,
						ULONG_PTR dwParam1,
						ULONG_PTR dwParam2,
						CStackLog *psl
						);
    static PFN_CTspDev_TASK_HANDLER s_pfn_TH_CallSwitchFromVoiceToData;
    //
    //  START_MSG Params:
    //      dwParam1: Unused
    //      dwParam2: Unused
    //


    //=========================================================================
    // LINE-RELATED Task Handlers
    //
    //      These handlers expect a valid m_pLine
    //      They are implemented in cdevline.cpp
    //
    //
    // All tasks names begin with prefix "mfn_TH_Line"
    //
    //=========================================================================

    // There are currently no line-related task handlers...

    //=========================================================================
    // PHONE-RELATED Task Handlers
    //
    //      These handlers expect a valid m_pPhone
    //
    //      All tasks names begin with prefix "mfn_TH_Phone"
    //      They are implemented in cdevphon.cpp
    //
    //=========================================================================

    TSPRETURN
    CTspDev::mfn_TH_PhoneSetSpeakerPhoneState(
                        HTSPTASK htspTask,
                        TASKCONTEXT *pContext,
                        DWORD dwMsg,
                        ULONG_PTR dwParam1,
                        ULONG_PTR dwParam2,
                        CStackLog *psl
                        );
    static PFN_CTspDev_TASK_HANDLER s_pfn_TH_PhoneSetSpeakerPhoneState;

    //
    //  START_MSG Params:
    //      dwParam1:  *HOOKDEVSTATE of new params...
    //      dwParam2: request ID for the async phone-related TAPI call.
    //


    TSPRETURN
    CTspDev::mfn_TH_PhoneAsyncTSPICall(
                        HTSPTASK htspTask,
                        TASKCONTEXT *pContext,
                        DWORD dwMsg,
                        ULONG_PTR dwParam1,
                        ULONG_PTR dwParam2,
                        CStackLog *psl
                        );
    static PFN_CTspDev_TASK_HANDLER s_pfn_TH_PhoneAsyncTSPICall;
    //
    //  START_MSG Params:
    //      dwParam1: request ID for the async phone-related TAPI call.
    //      dwParam2: handler function for the call.
    //


    //=========================================================================
    // LLDEV-RELATED Task Handlers
    //
    //      These handlers expect a valid m_pLLDev. They SHOULD AVOID
    //      refer to m_pLine, m_pLine->pCall or m_pPhone.
    //
    //      It's quite possible for m_pLine, m_pLine->pCall, or m_pPhone
    //      to be nuked while these tasks are still pending, so if
    //      the tasks must refer to one of the above pointers, they should
    //      check to see if they are still defined each async completion.
    //
    //      Abstenance is the best policy, however, so once again, avoid
    //      references to m_pLine, m_pLine->pCall or m_pPhone in TH_LLDev_*
    //      handlers.
    //
    //      All tasks names begin with prefix "mfn_TH_LLDev"
    //      They are implemented in cdevll.cpp
    //
    //=========================================================================

    TSPRETURN
    mfn_TH_LLDevNormalize(
                        HTSPTASK htspTask,
                        TASKCONTEXT *pContext,
                        DWORD dwMsg,
                        ULONG_PTR dwParam1,
                        ULONG_PTR dwParam2,
                        CStackLog *psl
                        );
    static PFN_CTspDev_TASK_HANDLER s_pfn_TH_LLDevNormalize;
    //
    //  START_MSG Params: None
    //

	TSPRETURN
	mfn_TH_LLDevStopAIPCAction(
						HTSPTASK htspTask,
					    TASKCONTEXT *pContext,
						DWORD dwMsg,
						ULONG_PTR dwParam1,
						ULONG_PTR dwParam2,
						CStackLog *psl
						);
    static PFN_CTspDev_TASK_HANDLER s_pfn_TH_LLDevStopAIPCAction;
    //
    //  START_MSG Params: None
    //


	TSPRETURN
	mfn_TH_LLDevStartAIPCAction(
						HTSPTASK htspTask,
					    TASKCONTEXT *pContext,
						DWORD dwMsg,
						ULONG_PTR dwParam1,
						ULONG_PTR dwParam2,
						CStackLog *psl
						);
    static PFN_CTspDev_TASK_HANDLER s_pfn_TH_LLDevStartAIPCAction;
    //
    //  START_MSG Params: None
    //


	TSPRETURN
	mfn_TH_LLDevHybridWaveAction(
						HTSPTASK htspTask,
					    TASKCONTEXT *pContext,
						DWORD dwMsg,
						ULONG_PTR dwParam1,
						ULONG_PTR dwParam2,
						CStackLog *psl
						);
    static PFN_CTspDev_TASK_HANDLER s_pfn_TH_LLDevHybridWaveAction;
    //
    //  START_MSG Params:
    //      dwParam1: dwWaveAction from the AIPC message from a client.
    //      dwParam2: unused.
    //



    //=========================================================================
    // LLDEV-RELATED Task Handlers (Contd...)
    //
    //      The following task handlers are specific to supporting individual
    //      minidriver asynchronous calls. See notes above that apply to
    //      all LLDEV-related task handlers.
    //
    //      All tasks are named mfn_TH_LLDevXXX, where 
    //      XXX is the corresponding minidriver call.
    //
    //      Sample name: mfnTH_LLDevUmInitModem
    //
    //      They are implemented in cdevll.cpp
    //
    //=========================================================================


	TSPRETURN
	mfn_TH_LLDevUmMonitorModem(
						HTSPTASK htspTask,
					    TASKCONTEXT *pContext,
						DWORD dwMsg,
						ULONG_PTR dwParam1,
						ULONG_PTR dwParam2,
						CStackLog *psl
						);
    static PFN_CTspDev_TASK_HANDLER s_pfn_TH_LLDevUmMonitorModem;
    //
    //  START_MSG Params:
    //      dwParam1: dwMonitorFlags.
    //


	TSPRETURN
	mfn_TH_LLDevUmInitModem(
						HTSPTASK htspTask,
					    TASKCONTEXT *pContext,
						DWORD dwMsg,
						ULONG_PTR dwParam1,
						ULONG_PTR dwParam2,
						CStackLog *psl
						);
    static PFN_CTspDev_TASK_HANDLER s_pfn_TH_LLDevUmInitModem;
    //
    //  START_MSG Params: unused
    //


	TSPRETURN
	mfn_TH_LLDevUmSetPassthroughMode(
						HTSPTASK htspTask,
					    TASKCONTEXT *pContext,
						DWORD dwMsg,
						ULONG_PTR dwParam1,
						ULONG_PTR dwParam2,
						CStackLog *psl
						);
    static PFN_CTspDev_TASK_HANDLER s_pfn_TH_LLDevUmSetPassthroughMode;
    //
    //  START_MSG Params: dwParam1==dwMode
    //


	TSPRETURN
	mfn_TH_LLDevUmDialModem(
						HTSPTASK htspTask,
					    TASKCONTEXT *pContext,
						DWORD dwMsg,
						ULONG_PTR dwParam1,
						ULONG_PTR dwParam2,
						CStackLog *psl
						);
    static PFN_CTspDev_TASK_HANDLER s_pfn_TH_LLDevUmDialModem;
    //
    //  START_MSG Params: dwParam1==dwFlags; dwParam2==szAddress
    //


	TSPRETURN
	mfn_TH_LLDevUmAnswerModem(
						HTSPTASK htspTask,
					    TASKCONTEXT *pContext,
						DWORD dwMsg,
						ULONG_PTR dwParam1,
						ULONG_PTR dwParam2,
						CStackLog *psl
						);
    static PFN_CTspDev_TASK_HANDLER s_pfn_TH_LLDevUmAnswerModem;
    //
    //  START_MSG Params: dwParam1==dwAnswerFlags; dwParam2 is unused.
    //


	TSPRETURN
	mfn_TH_LLDevUmHangupModem(
						HTSPTASK htspTask,
					    TASKCONTEXT *pContext,
						DWORD dwMsg,
						ULONG_PTR dwParam1,
						ULONG_PTR dwParam2,
						CStackLog *psl
						);
    static PFN_CTspDev_TASK_HANDLER s_pfn_TH_LLDevUmHangupModem;
    //
    //  START_MSG Params: unused
    //


	TSPRETURN
	mfn_TH_LLDevUmWaveAction(
						HTSPTASK htspTask,
					    TASKCONTEXT *pContext,
						DWORD dwMsg,
						ULONG_PTR dwParam1,
						ULONG_PTR dwParam2,
						CStackLog *psl
						);
    static PFN_CTspDev_TASK_HANDLER s_pfn_TH_LLDevUmWaveAction;
    //
    //  START_MSG Params:
    //      dwParam1: "Pure" dwWaveAction, as defined in <umdmmini.h>
    //      dwParam2: unused.
    //


	TSPRETURN
	mfn_TH_LLDevUmGenerateDigit(
						HTSPTASK htspTask,
					    TASKCONTEXT *pContext,
						DWORD dwMsg,
						ULONG_PTR dwParam1,
						ULONG_PTR dwParam2,
						CStackLog *psl
						);
    static PFN_CTspDev_TASK_HANDLER s_pfn_TH_LLDevUmGenerateDigit;
    //
    //  START_MSG Params: dwParam1==szDigits; dwParam2 is unused.
    //

	TSPRETURN
	mfn_TH_LLDevUmGetDiagnostics(
						HTSPTASK htspTask,
					    TASKCONTEXT *pContext,
						DWORD dwMsg,
						ULONG_PTR dwParam1,
						ULONG_PTR dwParam2,
						CStackLog *psl
						);
    static PFN_CTspDev_TASK_HANDLER s_pfn_TH_LLDevUmGetDiagnostics;
    //
    //  START_MSG Params: unused
    //

	TSPRETURN
	mfn_TH_LLDevUmSetSpeakerPhoneMode(
						HTSPTASK htspTask,
					    TASKCONTEXT *pContext,
						DWORD dwMsg,
						ULONG_PTR dwParam1,
						ULONG_PTR dwParam2,
						CStackLog *psl
						);
    static PFN_CTspDev_TASK_HANDLER s_pfn_TH_LLDevUmSetSpeakerPhoneMode;
    //
    //  START_MSG Params: unused
    //

	TSPRETURN
	mfn_TH_LLDevUmSetSpeakerPhoneVolGain(
						HTSPTASK htspTask,
					    TASKCONTEXT *pContext,
						DWORD dwMsg,
						ULONG_PTR dwParam1,
						ULONG_PTR dwParam2,
						CStackLog *psl
						);
    static PFN_CTspDev_TASK_HANDLER s_pfn_TH_LLDevUmSetSpeakerPhoneVolGain;
    //
    //  START_MSG Params: unused
    //

	TSPRETURN
	mfn_TH_LLDevUmSetSpeakerPhoneState(
						HTSPTASK htspTask,
					    TASKCONTEXT *pContext,
						DWORD dwMsg,
						ULONG_PTR dwParam1,
						ULONG_PTR dwParam2,
						CStackLog *psl
						);
    static PFN_CTspDev_TASK_HANDLER s_pfn_TH_LLDevUmSetSpeakerPhoneState;
    //
    //  START_MSG Params:
    //      dwParam1: *HOOKDEVSTATE of new state requested.
    //


	TSPRETURN
	mfn_TH_LLDevUmIssueCommand(
						HTSPTASK htspTask,
					    TASKCONTEXT *pContext,
						DWORD dwMsg,
						ULONG_PTR dwParam1,
						ULONG_PTR dwParam2,
						CStackLog *psl
						);
    static PFN_CTspDev_TASK_HANDLER s_pfn_TH_LLDevUmIssueCommand;
    //
    //  START_MSG Params:
    //      dwParam1: szCommand (ASCII)
    //      dwParam2: timeout (ms)
    //

	TSPRETURN
	mfn_TH_LLDevIssueMultipleCommands(
						HTSPTASK htspTask,
					    TASKCONTEXT *pContext,
						DWORD dwMsg,
						ULONG_PTR dwParam1,
						ULONG_PTR dwParam2,
						CStackLog *psl
						);
    static PFN_CTspDev_TASK_HANDLER s_pfn_TH_LLDevIssueMultipleCommands;
    //
    //  START_MSG Params:
    //      dwParam1: szCommand (ASCII)
    //      dwParam2: per-command timeout (ms)
    //


    //===========================================================
    // 
    //      END OF TASK HANDLER PROTOTYPES
    //
    //===========================================================



	TSPRETURN
	mfn_StartRootTask(
		PFN_CTspDev_TASK_HANDLER *ppfnTaskHandler,  // See mfn_StartTSPITask
        BOOL *pfPending,    // *pfPending is set to TRUE if pending and is
                            // cleared on async completion.
        ULONG_PTR dwParam1,
        ULONG_PTR dwParam2,
		CStackLog *psl
		);


	TSPRETURN
	mfn_StartSubTask(
		HTSPTASK htspParentTask,		    // Task to start the subtask under.
		PFN_CTspDev_TASK_HANDLER *ppfnTaskHandler,  // See mfn_StartTSPITask
        DWORD dwTaskID,
        ULONG_PTR dwParam1,
        ULONG_PTR dwParam2,
		CStackLog *psl
		);



	void
	mfn_AbortRootTask(
		DWORD dwAbortParam,
		CStackLog *psl
		);
    //
	//  Causes the task's handler function to be called with 
	//  MSG_ABORT, and dwParam1 set to dwAbortParam. To abort a sub-task,
	//  use mfn_AbortCurrentSubTask(...) (the handle to the sub-task is hidden
	//  so you can't call mfn_AbortRootTask on it).
	//
    //  Note that this function is merely a notification mechanism -- the
    //  task manager doesn't do anything besides sending the message, except
    //  for setting internal state to indicate that an abort is in progress.
    //  Tasks can call mfn_IsTaskAborting(...) to determine whether the
    //  specified task is aborting. Once the task is in the aborting stage
    //  subsequent calls to abort the task are ignored -- i.e., only ONE
    //  MSG_ABORT is sent per task.
    //
    //  The task manager will not propogate the MSG_ABORT message to subbtasks--
    //  it is the responsibility of the task to abort any subtasks if
    //  it wants to.


	void
	mfn_AbortCurrentSubTask(
		HTSPTASK htspTask,
		DWORD dwAbortParam,
		CStackLog *psl
		);
    //
	//  Causes the specified task's sub-task's handler function to be
    //  called with MSG_ABORT, and dwParam1 set to dwAbortParam.
    //  If there is no current sub-tsk, this does nothing.
	//
	//  See also documentation of mfn_AbortRootTask
	//


	void
    AsyncCompleteTask(
        HTSPTASK htspTask,
	    TSPRETURN tspRetAsync,
        BOOL    fQueueAPC,
        CStackLog *psl
        );
	//  Does an asynchronous completion of the specified task, with the
    //  specified result.
	//  NOTE: this action typically results in further processing by the
	//  task, including completing the task and further processing by
	//  the parent task and so forth. If this further processing needs to
	//  be deferred, specify a nonzero value for fQueueAPC, in which the actual
    //  completion of the task is carried out in an APC.


	TSPRETURN
	mfn_get_LINDEVCAPS (
		LPLINEDEVCAPS lpLineDevCaps,
		LONG *plRet,
		CStackLog *psl
		);


	TSPRETURN
	mfn_get_ADDRESSCAPS (
		DWORD dwDeviceID,
		LPLINEADDRESSCAPS lpAddressCaps,
		LONG *plRet,
		CStackLog *psl
		);

	TSPRETURN
	mfn_get_PHONECAPS (
		LPPHONECAPS lpPhoneCaps,
		LONG *plRet,
		CStackLog *psl
		);

	void mfn_init_default_LINEDEVCAPS(void);


	BOOL mfn_IS_NULL_MODEM(void)
	{
		return (m_StaticInfo.dwDeviceType == DT_NULL_MODEM);
	}


	void
	mfn_accept_tsp_call_for_HDRVLINE(
		DWORD dwRoutingInfo,
		void *pvParams,
		LONG *plRet,
		CStackLog *psl
		);


	void
	mfn_accept_tsp_call_for_HDRVPHONE(
		DWORD dwRoutingInfo,
		void *pvParams,
		LONG *plRet,
		CStackLog *psl
		);


	void
	mfn_accept_tsp_call_for_HDRVCALL(
		DWORD dwRoutingInfo,
		void *pvParams,
		LONG *plRet,
		CStackLog *psl
		);


	LONG
	mfn_monitor(
		DWORD dwMediaModes,
        CStackLog *psl
		);

    LONG
    mfn_GenericLineDialogData(
        void *pParams,
        DWORD dwSize,
        CStackLog *psl
        );

    LONG
    mfn_GenericPhoneDialogData(
        void *pParams,
        DWORD dwSize
        );

    // Fills out the *lpCallStatus structure
    //
    void
    mfn_GetCallStatus(
            LPLINECALLSTATUS lpCallStatus
    );


	CSync m_sync;


	#define MAX_TASKS 10
    #define INVALID_SUBTASK_ID ((DWORD)-1)

    // Task states
    #define fALLOCATED          0x1
    #define fPENDING            (0x1<<1)
    #define fSUBTASK_PENDING    (0x1<<2)
    #define fAPC_QUEUED         (0x1<<3)
    #define fABORTING           (0x1<<4)

    #define IS_ALLOCATED(_pTask)    (((_pTask)->hdr.dwFlags) & fALLOCATED)
    #define IS_PENDING(_pTask)      (((_pTask)->hdr.dwFlags) & fPENDING)
    #define IS_SUBTASK_PENDING(_pTask) \
                                    (((_pTask)->hdr.dwFlags) & fSUBTASK_PENDING)
    #define IS_APC_QUEUED(_pTask)   (((_pTask)->hdr.dwFlags) & fAPC_QUEUED)
    #define IS_ABORTING(_pTask)     (((_pTask)->hdr.dwFlags) & fABORTING)


    #define SET_ALLOCATED(_pTask)    ((_pTask)->hdr.dwFlags|= fALLOCATED)
    #define SET_PENDING(_pTask)      ((_pTask)->hdr.dwFlags|= fPENDING)
    #define SET_SUBTASK_PENDING(_pTask) \
                                     ((_pTask)->hdr.dwFlags|= fSUBTASK_PENDING)
    #define SET_APC_QUEUED(_pTask)   ((_pTask)->hdr.dwFlags|= fAPC_QUEUED)
    #define SET_ABORTING(_pTask)     ((_pTask)->hdr.dwFlags|= fABORTING)

    #define CLEAR_ALLOCATED(_pTask)    ((_pTask)->hdr.dwFlags&= ~fALLOCATED)
    #define CLEAR_PENDING(_pTask)      ((_pTask)->hdr.dwFlags&= ~fPENDING)
    #define CLEAR_SUBTASK_PENDING(_pTask) \
                                     ((_pTask)->hdr.dwFlags&= ~fSUBTASK_PENDING)
    #define CLEAR_APC_QUEUED(_pTask)   ((_pTask)->hdr.dwFlags&= ~fAPC_QUEUED)
    #define CLEAR_ABORTING(_pTask)     ((_pTask)->hdr.dwFlags&= ~fABORTING)


	typedef struct _DEVTASKINFO
	{
		GENERIC_SMALL_OBJECT_HEADER hdr;
		PFN_CTspDev_TASK_HANDLER *ppfnHandler;
		CTspDev *pDev;          // Pointer to this. We need this because
		                        // if tasks complete asynchronously, then need
		                        // to retrieve the device context.
        HTSPTASK hTask; // This task's task handle

		DWORD dwCurrentSubtaskID;
		TSPRETURN tspRetAsync;
        TASKCONTEXT TaskContext;

        void Load(
                CTspDev *pDev1,
        		PFN_CTspDev_TASK_HANDLER *ppfnHandler1,
                HTSPTASK hNewTask
             )
             {
                // See notes under Unload below
                //
		        ASSERT(hdr.dwSigAndSize==MAKE_SigAndSize(sizeof(*this)));
                ASSERT(!hdr.dwFlags);

            	hdr.dwFlags = fALLOCATED;
                dwCurrentSubtaskID = INVALID_SUBTASK_ID;
            	pDev = pDev1;
            	ppfnHandler = ppfnHandler1;
                hTask = hNewTask;
             }

        void Unload(void)
            {
             //
             // We save away the SigAndSize, zero the entire structure, and
             // put back SigAndSize. If SigAndSize is corrupted, it remains
             // corrupted. SigAndSize is originally set when the array of
             // DEVTASKINFO structs is first initialized, and is checked
             // each time Load above is called. This ensures that
             // task-specific data is not corrupted easily without causing
             // Load to fail.
             //
             DWORD dwSigAndSize = hdr.dwSigAndSize;
             ZeroMemory(this, sizeof(*this));
		     hdr.dwSigAndSize = dwSigAndSize;
            };

	} DEVTASKINFO;


    TSPRETURN
    mfn_GetTaskInfo(
        HTSPTASK htspTask,
        DEVTASKINFO **ppInfo, // OPTIONAL
        CStackLog *psl
        );


	TSPRETURN
	mfn_LoadLine(
		TASKPARAM_TSPI_lineOpen  *pvParams,
		CStackLog *psl
        );
    //
    //  mfn_LoadLine is an internal function to initialize a line.
    //  Synchronous, assumes object's crit sect is already claimed.
    //  On entry m_pLine must be NULL. On successful exit, m_pLine will be
    //  defined (actually set to point to m_Line).
    //


    void
    mfn_UnloadLine(CStackLog *psl);
    //
    //  The "inverse" of mfn_LoadLine. Synchronous, assumes object's crit sect
    //  is already claimed. On entry m_pLine must be non-null. On exit m_pLine
    //  WILL be NULL. mfn_UnloadLine is typically called only after all
    //  asynchronous activity on the line is complete. If there is pending
    //  asynchronous activity, mfn_UnloadLine will abort that activity and
    //  wait indefinately until that activity completes. Since this wait is
    //  done once per device, it is better to first go through and abort all
    //  the devices, then wait once for them all to complete.
    //


	TSPRETURN
	mfn_LoadPhone(
		TASKPARAM_TSPI_phoneOpen  *pvParams,
		CStackLog *psl
        );
    //
    //  mfn_LoadPhone is an internal function to initialize a phone.
    //  Synchronous, assumes object's crit sect is already claimed.
    //  On entry m_pPhone must be NULL. On successful exit, m_pPhone will be
    //  defined (actually set to point to m_Phone).
    //


    void
    mfn_UnloadPhone(CStackLog *psl);
    //
    //  The "inverse" of mfn_LoadPhone. Synchronous, assumes object's crit sect
    //  is already claimed. On entry m_pPhone must be non-null. On exit m_pPhone
    //  WILL be NULL. mfn_UnloadPhone is typically called only after all
    //  asynchronous activity on the phone is complete. If there is pending
    //  asynchronous activity, mfn_UnloadPhone will abort that activity and
    //  wait indefinately until that activity completes. Since this wait is
    //  done once per device, it is better to first go through and abort all
    //  the devices, then wait once for them all to complete.
    //


	TSPRETURN
	mfn_LoadCall(


        TASKPARAM_TSPI_lineMakeCall *pParams,


        LONG *plRet,
		CStackLog *psl
        );
    //
    //  mfn_LoadCall is an internal function to initialize a call.
    //  Synchronous, assumes object's crit sect is already claimed.
    //  On entry m_pCall must be NULL. On successful exit, m_pCall will be
    //  defined (actually set to point to m_Call).
    //
    //  if pParams is not null, indicates outgoing call (lineMakeCall), else
    //  indicates incoming call (ring received).
    //


    void
    mfn_UnloadCall(BOOL fDontBlock, CStackLog *psl);
    //
    //  mfn_UnloadCall is the "inverse" of mfn_LoadCall.
    //  Synchronous, assumes object's crit sect is already claimed.
    //  On entry m_pCall must be non-null. On exit m_pCall
    //  WILL be NULL. mfn_UnloadCall is typically called only after all
    //  asynchronous activity on the call is complete. If there is pending
    //  asynchronous activity, mfn_UnloadCall will abort that activity and
    //  wait indefinately until that activity completes. Since this wait is
    //  done once per device, it is better to first go through and abort the
    //  calls on all the devices, then wait once for them all to complete.


	TSPRETURN
	mfn_LoadLLDev(CStackLog *psl);
    //
    //  mfn_LoadLLDev is an internal function to open the Low-level (LL)
    //  modem device.
    //  It calls the mini-driver's UmOpenModem entry point. Synchronous,
    //  assumes object's crit sect is already claimed.
    //
    //  On entry, m_pLLDev MUST be NULL.
    //  On successful return, m_pLLDev will be valid.
    //


    void
    mfn_UnloadLLDev(CStackLog *psl);
    //
    //  mfn_UnloadLLDev is the "inverse" of mfn_UnloadLLDev.
    //  Synchronous, assumes object's crit sect is already claimed.
    //
    //  On entry, m_pLLDev MUST be valid.
    //  On successful return, m_pLLDev will be NULL.
    //



    TSPRETURN
	mfn_OpenLLDev(
        DWORD fdwResources, // resources to addref
        DWORD dwMonitorFlags,
        BOOL fStartSubTask,
        HTSPTASK htspParentTask,
        DWORD dwSubTaskID,
        CStackLog *psl
        );


    TSPRETURN
    CTspDev::mfn_CreateDialogInstance (
        DWORD dwRequestID,
        CStackLog *psl
        );

    void
    CTspDev::mfn_FreeDialogInstance (
        void
        );

	//
	//  fdwResources is one or more of the LINEINFO::fRES* flags..
	//


    TSPRETURN
	mfn_CloseLLDev(
        DWORD fdwResources, // resources to release
        BOOL fStartSubTask,
        HTSPTASK htspParentTask,
        DWORD dwSubTaskID,
        CStackLog *psl
        );

    TSPRETURN
    mfn_LoadAipc(CStackLog *psl);
    //
    // mfn_LoadAipc initializes the AIPC (device-based async  IPC)
    // structure AIPC2, which is part of the LLDEVINFO structure.
    //
    // NOTE: On entry m_pLLDev->pAipc2 must be NULL.
    // on successful exit m_pLLDev-pAipc2 will point to an initialized
    // AIPC2 structure.
    //
    

    void
    mfn_UnloadAipc(CStackLog *psl);
    //
    // Inverse of mfn_UnloadAIPC. On exit m_pLLDev->pAipc2 will be
    // set to NULL.
    //
    

    //
    // Each of the following mfn_lineGetID_* functions handles lineGetID
    // for a specific device class...
    //

    LONG mfn_linephoneGetID_TAPI_LINE(
            LPVARSTRING lpDeviceID,
            HANDLE hTargetProcess,
            UINT cbMaxExtra,
            CStackLog *psl
            );

    LONG mfn_lineGetID_COMM(
            LPVARSTRING lpDeviceID,
            HANDLE hTargetProcess,
            UINT cbMaxExtra,
            CStackLog *psl
            );

    LONG mfn_lineGetID_COMM_DATAMODEM(
            LPVARSTRING lpDeviceID,
            HANDLE hTargetProcess,
            UINT cbMaxExtra,
            CStackLog *psl
            );

    LONG mfn_lineGetID_COMM_DATAMODEM_PORTNAME(
            LPVARSTRING lpDeviceID,
            HANDLE hTargetProcess,
            UINT cbMaxExtra,
            CStackLog *psl
            );

    LONG mfn_lineGetID_NDIS(
            LPVARSTRING lpDeviceID,
            HANDLE hTargetProcess,
            UINT cbMaxExtra,
            CStackLog *psl
            );
    
    LONG mfn_linephoneGetID_WAVE(
            BOOL fPhone,
            BOOL fIn,
            LPVARSTRING lpDeviceID,
            HANDLE hTargetProcess,
            UINT cbMaxExtra,
            CStackLog *psl
            );

    LONG mfn_linephoneGetID_TAPI_PHONE(
            LPVARSTRING lpDeviceID,
            HANDLE hTargetProcess,
            UINT cbMaxExtra,
            CStackLog *psl
            );

    LONG mfn_lineGetID_LINE_DIAGNOSTICS(
            DWORD dwSelect,
            LPVARSTRING lpDeviceID,
            HANDLE hTargetProcess,
            UINT cbMaxExtra,
            CStackLog *psl
            );

    LONG mfn_fill_RAW_LINE_DIAGNOSTICS(
            LPVARSTRING lpDeviceID,
            UINT cbMaxExtra,
            CStackLog *psl
            );

    LONG mfn_ConstructDialableString(
                     LPCTSTR  lptszInAddress,
                     LPSTR  lptszOutAddress,
                     UINT cbOutAddress,
                     BOOL *pfTone
                     );

    //
    // Following functions process various mini driver notifications....
    //
    void mfn_ProcessRing(BOOL ReportRing,CStackLog *psl);
    void mfn_ProcessDisconnect(CStackLog *psl);
    void mfn_ProcessHardwareFailure(CStackLog *psl);
    void mfn_ProcessDialTone(CStackLog *psl);
    void mfn_ProcessBusy(CStackLog *psl);
    void mfn_ProcessPowerResume(CStackLog *psl);
    void mfn_ProcessDTMFNotification(ULONG_PTR dwDigit, BOOL fEnd, CStackLog *psl);
    void mfn_ProcessResponse(ULONG_PTR dwRespCode, LPSTR lpszResp, CStackLog *psl);
    void mfn_ProcessHandsetChange(BOOL fOffHook, CStackLog *psl);
    void mfn_ProcessMediaTone(ULONG_PTR dwMediaMode, CStackLog *psl);
    void mfn_ProcessSilence(CStackLog *psl);
    void mfn_ProcessCallerID(UINT uMsg, char *szInfo, CStackLog *psl);

    LONG
    mfn_GetCallInfo(LPLINECALLINFO lpCallInfo);

    void
    mfn_HandleSuccessfulConnection(CStackLog *psl);

    void
    mfn_NotifyDisconnection(
        TSPRETURN tspRetAsync,
        CStackLog *psl
        );


	DEVTASKINFO m_rgTaskStack[MAX_TASKS];
	DWORD m_dwTaskCounter; // keeps incrementing each time a task is created.
	                       // could roll-over, no mind -- this is just
	                       // used to make HTASK relatively unique.
	UINT m_uTaskDepth;
    BOOL *m_pfTaskPending;
    //      This is passed into StartRootTask and is set if the task
    //      is to be completed asynchronously, and is cleared on
    //      async completion of the task.
    //      This is unused for subtasks.

    HANDLE m_hRootTaskCompletionEvent;
    //  This stores one optional event. This event, if present (non NULL),
    //  will be set on async completion of the pending root task.

    //
	// Information about a device that doesn't change once it's installed
	// is stored in the structure below.
	// This information is candidate for moving to a common place for
	// all devices of the same type, except for rgtchDeviceName and 
	// rgchDriverKey -- even those can be made into templates.
    //
	struct 
	{
		TCHAR rgtchDeviceName[MAX_DEVICE_LENGTH+1];

		// We maintain only the ANSI version of the driver key, and
		// it is used ONLY for returning in the dev-specific section of
		// LINEDEVCAPS....
		char rgchDriverKey[MAX_REGKEY_LENGTH+1];


        // Same for PortName (COMx, etc....)
        #define MAX_PORTNAME_LENGTH 10
        char rgchPortName[MAX_PORTNAME_LENGTH+1];

		DWORD        dwPermanentLineID;    // Permanent ID for this device
        GUID         PermanentDeviceGuid;  //  tapi3 permanent guid

		DWORD        dwDeviceType;         // the modem type, from registry.
										   // (is a BYTE in the registry, but
										   //  DWORD here).
		HICON        hIcon;                // Device icon
		DWORD        dwDevCapFlags;        // LINEDEVCAPSFLAGS (ie. DIALBILLING,
										   // DIALQUIET, DIALDIALTONE)
		DWORD        dwMaxDCERate;         // Max DCE froms the Properties line
										   // of the registry
		DWORD        dwModemOptions;       // dwModemOptions from the Properties
										   // line of the registry
		BOOL         fPartialDialing;      // TRUE if partial dialing using ";"
										   // is supported


		DWORD        dwBearerModes;        // supported bearer modes
		DWORD        dwDefaultMediaModes;  // Default supported media modes

		LINEDEVCAPS  DevCapsDefault;	   // Pre-initialized devcaps.

		CTspMiniDriver *pMD;			   // Pointer to mini driver instance
		HSESSION hSessionMD;			   // Session handle to above
										   // driver.
        HANDLE   hExtBinding;              // Extension binding handle to
                                           // above driver.

		LPTSTR lptszProviderName;		   // Pointer to provider name.

        // These things are passed in by the CTspDevMgr calling
        // RegisterProviderInfo
        //
        DWORD dwTAPILineID;
        DWORD dwTAPIPhoneID;
	    ASYNC_COMPLETION  pfnTAPICompletionProc;

        
        // <T V>
        const TCHAR       *szzLineClassList;
        UINT              cbLineClassList;
        const TCHAR       *szzPhoneClassList;
        UINT              cbPhoneClassList;
        const TCHAR       *szzAddressClassList;
        UINT              cbAddressClassList;
        // </T V>

        struct
        {
            #if 0
            // 3/1/1997 JosephJ. The following are the voice profile flags
            //      used by Unimdoem/V, and the files where they were used.
            //      For NT5.0, we don't use the voice profile flags directly.
            //      Rather we define our own internal ones and define only
            //      those that we need. These internal properties are maintained
            //      in field dwProperties of this struct.
            //      TODO: define minidriver capabilities structure and api to
            //      get a set of meaningful properties without the TSP having
            //      to get it directly from the registry.
            //
            // VOICEPROF_CLASS8ENABLED             : <many places>
            // VOICEPROF_HANDSET                   : cfgdlg.c phone.c
            // VOICEPROF_NO_SPEAKER_MIC_MUTE       : cfgdlg.c phone.c
            // VOICEPROF_SPEAKER                   : cfgdlg.c modem.c phone.c
            // VOICEPROF_NO_CALLER_ID              : modem.c mdmutil.c
            // VOICEPROF_MODEM_EATS_RING           : modem.c
            // VOICEPROF_MODEM_OVERRIDES_HANDSET   : modem.c
            // VOICEPROF_MODEM_OVERRIDES_HANDSET   : modem.c
            // 
            // VOICEPROF_NO_DIST_RING              : modem.c
            // VOICEPROF_SIERRA                    : modem.c
            // VOICEPROF_MIXER                     : phone.c
            // 
            // VOICEPROF_MONITORS_SILENCE          : unimdm.c
            // VOICEPROF_NO_GENERATE_DIGITS        : unimdm.c
            // VOICEPROF_NO_MONITOR_DIGITS         : unimdm.c
            //
            //

            // Following bit set IFF the mode supports automated voice.
            //
            #define fVOICEPROP_CLASS_8                  (0x1<<0)

            // If set, following bit indicates that the handset is deactivated
            // when the modem is active (whatever "active" means -- perhaps off
            //  hook?).
            //
            // If set, incoming interactive voice calls are not permitted, and
            // the TSP brings up a TalkDrop dialog on outgoing interactive
            // voice calls (well not yet as of 3/1/1997, but unimodem/v did
            // this).
            //
            #define fVOICEPROP_MODEM_OVERRIDES_HANDSET  (0x1<<1)


            #define fVOICEPROP_MONITOR_DTMF             (0x1<<2)
            #define fVOICEPROP_MONITORS_SILENCE         (0x1<<3)
            #define fVOICEPROP_GENERATE_DTMF            (0x1<<4)

            // Following two are set iff the device supports handset and 
            // speakerphone, respectively.
            //
            #define fVOICEPROP_HANDSET                  (0x1<<5)
            #define fVOICEPROP_SPEAKER                  (0x1<<6)


            // Supports mike mute
            #define fVOICEPROP_MIKE_MUTE                (0x1<<7)

            #endif // 0

            DWORD dwProperties; // one or more fVOICEPROP_* flags.

            // 2/28/1997 JosephJ
            //      The following are new for NT5.0. These contain the
            //      wave device Instance ID for record and play. This
            //      is set by the class installer when installing the modem.
            //
            //      Unimodem/V used the following scheme: On creating the device
            //      it reads in the discriptive names of the wave devices
            //      associated with the modem (the wave deviceis a child device)
            //      Then lineGetID would use the multimedia wave apis to
            //      enumerate.

            DWORD dwWaveInstance;

        } Voice;

        DWORD dwDiagnosticCaps;

        HPROVIDER hProvider;

	} m_StaticInfo;

    void
    mfn_GetVoiceProperties (HKEY hkDrv, CStackLog *psl);

    HPROVIDER
    mfn_GetProvider (void)
    {
        return m_StaticInfo.hProvider;
    }

    DWORD
    mfn_GetLineID (void)
    {
        return m_StaticInfo.dwTAPILineID;
    }

    // The following function returns true iff
    // once modem is off hook, handset is deactivated.
    // We assume true for non voice-enabled modems, and for those voice-enabled
    // modems with the specific "MODEM_OVERRIDES_HANDSET" bit set....
    //
    UINT
    mfn_ModemOverridesHandset(void)
    {
            return !(m_StaticInfo.Voice.dwProperties)
                     || (m_StaticInfo.Voice.dwProperties
                         & fVOICEPROP_MODEM_OVERRIDES_HANDSET);
    }

    UINT
    mfn_CanDoVoice(void)
    {
            return m_StaticInfo.Voice.dwProperties & fVOICEPROP_CLASS_8;
    }

    UINT
    mfn_CanMonitorDTMF(void)
    {
            return m_StaticInfo.Voice.dwProperties &  fVOICEPROP_MONITOR_DTMF;
    }

    UINT
    mfn_CanMonitorSilence(void)
    {
          return m_StaticInfo.Voice.dwProperties &  fVOICEPROP_MONITORS_SILENCE;
    }

    UINT
    mfn_CanGenerateDTMF(void)
    {
        return m_StaticInfo.Voice.dwProperties & fVOICEPROP_GENERATE_DTMF;
    }

    UINT
    mfn_Handset(void)
    {
            return m_StaticInfo.Voice.dwProperties & fVOICEPROP_HANDSET;
    }

    UINT
    mfn_IsSpeaker(void)
    {
            return m_StaticInfo.Voice.dwProperties & fVOICEPROP_SPEAKER;
    }

    UINT
    mfn_IsPhone(void)
    {
    #ifdef DISABLE_PHONE
        return 0;
    #else // !DISABLE_PHONE
        return mfn_CanDoVoice() && (mfn_IsSpeaker() | mfn_Handset());
    #endif // !DISABLE_PHONE
    }

    UINT
    mfn_IsLine(void)
    {
        // TODO: Currently we don't support pure phone devices, so
        // we always return true here. In the future, the TSP will
        // support pure phone devices.
        //
    #ifdef DISABLE_LINE
        return 0;
    #else // !DISABLE_LINE
        return 1;
    #endif // !DISABLE_LINE
    }

    UINT
    mfn_IsMikeMute(void)
    {
            return m_StaticInfo.Voice.dwProperties &  fVOICEPROP_MIKE_MUTE;
    }

    UINT mfn_IsCallDiagnosticsEnabled(void);

    //
    // Appends the specified string (expected to already in Diagnostic (tagged)
    // format to the diagnostics information recorded. The string may
    // be truncated if there is not enough space.
    //
    // If this is the 1st piece of data to be appended, this function will
    // 1st allocate space for the diagnostics data buffer.
    //
    // Diagnostic data is maintained in CALLINFO:DiagnosticData;
    //
    enum DIAGNOSTIC_TYPE
    {
        DT_TAGGED,
        DT_MDM_RESP_CONNECT

    };

    void
    mfn_AppendDiagnostic(
            DIAGNOSTIC_TYPE dt,
            const BYTE *pb,
            UINT  cb
            );

    
    // Following two utility functions to get and set the specified UMDEVCFG
    // structure...
    //
    TSPRETURN mfn_GetDataModemDevCfg(
                UMDEVCFG *pDevCfg,
                UINT uSize,
                UINT *puSize,
                BOOL  DialIn,
                CStackLog *psl
                );

    TSPRETURN mfn_SetDataModemDevCfg(
                UMDEVCFG *pDevCfg,
                BOOL       DialIn,
                CStackLog *psl);


    void mfn_LineEventProc(
                HTAPICALL           htCall,
                DWORD               dwMsg,
                ULONG_PTR               dwParam1,
                ULONG_PTR               dwParam2,
                ULONG_PTR               dwParam3,
                CStackLog *psl
                );

    void mfn_PhoneEventProc(
                DWORD               dwMsg,
                ULONG_PTR               dwParam1,
                ULONG_PTR               dwParam2,
                ULONG_PTR               dwParam3,
                CStackLog *psl
                );

    void mfn_TSPICompletionProc(
                DRV_REQUESTID       dwRequestID,
                LONG                lResult,
                CStackLog           *psl
                );

#if (TAPI3)

     void mfn_SendMSPCmd(
                CALLINFO *pCall,
                DWORD dwCmd,
                CStackLog *psl
                );

#endif // TAPI3

    TSPRETURN
    mfn_AIPC_Abort(HTSPTASK hPendingTask);


    void AIPC_ListenCompleted(
            DWORD dwErrorCode,
            DWORD dwBytes,
            CStackLog *psl
                );
     
    // ---------------------------------------------------------------
    // PHONE DEVICE HELPER FUNCTIONS .......

    LONG
    mfn_phoneSetVolume(
        DRV_REQUESTID  dwRequestID,
        HDRVPHONE      hdPhone,
        DWORD          dwHookSwitchDev,
        DWORD          dwVolume,
        CStackLog      *psl
        );

    LONG
    mfn_phoneSetHookSwitch(
        DRV_REQUESTID  dwRequestID,
        HDRVPHONE      hdPhone,
        DWORD          dwHookSwitchDevs,
        DWORD          dwHookSwitchMode,
        CStackLog      *psl
        );

    LONG
    mfn_phoneSetGain(
        DRV_REQUESTID  dwRequestID,
        HDRVPHONE      hdPhone,
        DWORD          dwHookSwitchDev,
        DWORD          dwGain,
        CStackLog      *psl
        );

    void
    mfn_HandleRootTaskCompletedAsync(BOOL *pfEndUnload, CStackLog *psl);
    //
    //      This is called when the root task completes asynchronously.
    //      This function will start more root tasks if there are any
    //      to be started, until one of the tasks returns PENDING.
    //
    //      If *pfEndUnload is TRUE on return, it means that it's
    //      time to signal the end of the unload of the entire TSP
    //      object.

    TSPRETURN
    mfn_TryStartLineTask(CStackLog *psl);
    //      mfn_HandleRootTaskCompletion calls this fn to try and start
    //      a line-related task. The function will return IDERR_PENDING
    //      if it did start an async task, IDERR_SAMESTATE if it has
    //      no more tasks to run, or 0 or some other error if it
    //      started and completed a task synchronously (and hence could
    //      potentially have more tasks to run).

    TSPRETURN
    mfn_TryStartPhoneTask(CStackLog *psl);
    //      mfn_HandleRootTaskCompletion calls this fn to try and start
    //      a line-related task. For return value, see mfn_TryStartLineTask.

    TSPRETURN
    mfn_TryStartCallTask(CStackLog *psl);
    //      mfn_TryStartLineTask calls this fn to try and start
    //      a call-related task, if a call is defined (m_pLine->pCall non NULL).
    //      For return value, see mfn_TryStartLineTask.

    TSPRETURN
    mfn_TryStartLLDevTask(CStackLog *psl);
    //      mfn_HandleRootTaskCompletion calls this fn to try and start
    //      a lldev-related task. The function will return IDERR_PENDING
    //      if it did start an async task, IDERR_SAMESTATE if it has
    //      no more tasks to run, or 0 or some other error if it
    //      started and completed a task synchronously (and hence could
    //      potentially have more tasks to run).


    HTSPTASK
    mfn_NewTaskHandle(UINT uLevel)
    //
    //  Constructs a new task handle from the level of task in the stack
    //  and  the current task counter, also incrementing the task counter.
    //  This task-couter is used only for self-checking purposes --
    //  the  loword of the handle is uLevel and the hi-word is
    //  the  counter value with the high-bit set, thus ensuring that each
    //  time a handle is created, it stays unique until the counter rolls
    //  over at 64k.
    //
    //  mfn_GetTaskInfo uses the loword to get to the task info, but then
    //  validates the entire handle by checking to see if it matches
    //  the handle value stored inside pInfo.
    //
    {
        ASSERT(uLevel<MAX_TASKS);
        return (HTSPTASK)
         ((DWORD)uLevel | (++m_dwTaskCounter<<16) | (0x1<<31));
    }

    // ---------------------------------------------------------------

    BOOL mfn_AIPC_Listen(CStackLog *psl);
    void mfn_AIPC_AsyncReturn(BOOL fAsyncResult, CStackLog *psl);

    TSPRETURN
    mfn_update_devcfg_from_app(
                UMDEVCFG *pDevCfgNew,
                UINT cbDevCfgNew,
                BOOL DialIn,
                CStackLog *psl
                );
    //
    //          Updates the UMDEVCFG passed either via TSPI_lineSetDevConfig or
    //          indirectly via lineConfigDialog.
    //

    char *
    mfn_TryCreateNVInitCommands(CStackLog *psl);
    //
    //  Checks if we need to do an nv-ram init, and if so, builds a multisz
    //  asci string of commands.
    //
    //  It is the caller's responsibility to FREE_MEMORY the returned
    //  value.

    void mfn_dump_global_state(CStackLog *psl);
    void mfn_dump_line_state(CStackLog *psl);
    void mfn_dump_phone_state(CStackLog *psl);
    void mfn_dump_lldev_state(CStackLog *psl);
    void mfn_dump_task_state(CStackLog *psl);

	// Device settings which may change -- these were stored in the
	// now-obsolete pDevCfg field of the NT4.0 tsp LINEDEVCAPS structure.
	// We constract pDevCfg on demand now, using the settings below
	struct 
	{
		DWORD dwOptions;  		// LAUNCH_LIGHTS, etc -- go in UMDEVCFG
		DWORD dwWaitBong;		// go in UMDEVCFG

		COMMCONFIG *pDialOutCommCfg;   // Gets set to the following buffer...
		BYTE rgbCommCfgBuf[sizeof(MODEMSETTINGS)+ 
							FIELD_OFFSET(COMMCONFIG, wcProviderData)];

        COMMCONFIG *pDialInCommCfg;   // Gets set to the following buffer...
		BYTE rgbDialInCommCfgBuf[sizeof(MODEMSETTINGS)+
							FIELD_OFFSET(COMMCONFIG, wcProviderData)];

        COMMCONFIG *pDialTempCommCfg;   // Gets set to the following buffer...
		BYTE rgbDialTempCommCfgBuf[sizeof(MODEMSETTINGS)+
							FIELD_OFFSET(COMMCONFIG, wcProviderData)];


//        BOOL fConfigUpdatedByApp;
        //
        //          Set to true after
        //          TSPI_lineSetDevConfig called or
        //          config updated indirectly via app calling
        //          lineConfigDialog.
        //          once this is set, we no longer update
        //          the default config when we get a notification
        //          from the cpl that the default config has
        //          changed -- instead we selectively
        //          update some settings (speaker volume, etc.)
        //
        //          See notes.txt, entry on on 01-25-98 for
        //          details. See also the code
        //          for handling TSPI_lineSetDevConfig
        //          and CTspDev::NotifyDefaultConfigChanged.
        // 


        DWORD dwDiagnosticSettings; // Where call diagnostics, etc are
                                    // enabled..

        DWORD  dwNVRamState; 
        //
        //  3/8/1998 JosephJ The above indicates that settings saved to NVRAM
        //           are stale and must be re-set.
        //           This applies only to ISDN modems which need
        //           static configuration saved to NVRAM.
        //
        //           The fNVRAM_SETTINGS_CHANGED field is only set when this
        //           object (CTspDev) is
        //           loaded or when we get a notification from the CPL that
        //           the settings have changed.
        //
        //           It is cleared at the point we issue the NV-Init commands
        //           (issued just after UmInitModem, in function
        //           mfn_TH_LLDevNormalize.)
        //
        #define fNVRAM_AVAILABLE          (0x1<<0)
        #define fNVRAM_SETTINGS_CHANGED   (0x1<<1)

	} m_Settings;

    UINT
    mfn_CanDoNVRamInit(void)
    {
        return (m_Settings.dwNVRamState & fNVRAM_AVAILABLE);
    }

    UINT
    mfn_NeedToInitNVRam(void)
    {
        return (m_Settings.dwNVRamState & fNVRAM_SETTINGS_CHANGED);
    }

    void
    mfn_ClearNeedToInitNVRam(void)
    {
        m_Settings.dwNVRamState &= ~fNVRAM_SETTINGS_CHANGED;
    }

    void
    mfn_SetNeedToInitNVRam(void)
    {
        m_Settings.dwNVRamState |= fNVRAM_SETTINGS_CHANGED;
    }

    LONG
    mfn_GetCOMM_EXTENDEDCAPS(
                 LPVARSTRING lpDeviceConfig,
                 CStackLog *psl
                 );

	// This struct is "in scope" only when a TAPI line is open.
    LINEINFO  m_Line;

	// This struct is "in scope" only when a TAPI phone is open.
    PHONEINFO m_Phone;

	// This object is "in scope" only when an instance of the low-level
	// device is open (mini driver UmOpenModem is called).
    LLDEVINFO  m_LLDev;

	//
	// The following point to the above internal objects only the objects are
	// "in scope."  For example, m_pLine is set to &m_Line only when a line
	// is open.
	//
    LINEINFO *m_pLine;
    PHONEINFO *m_pPhone;
    LLDEVINFO   *m_pLLDev;

	// CTspDev state variables
	
    // DWORD        dwMediaModes;      // Current supported media modes
    DWORD        fdwResources;      // Flags for various resources


	HANDLE m_hThreadAPC; // Handle of thread on which to queue APC calls.
	                   // Note -- we could have a single global APC thread --
	                   // I put this here just to avoid any reference to
	                   // a global variable from CTspDev member functions, and
	                   // also to allow load sharing among multiple threads.
	                   // The latter reason is purely academic -- in practice
	                   // unimodem should be able to run with a single
	                   // APC thread and support more than enough calls.

   BOOL	m_fUnloadPending;

   BOOL m_fUserRemovePending;

};

// Returns TRUE IFF the specified DWORD-aligned buffer contains only zeros.
// size of the buffer also must be a multiple of DWORD size.
// Basically used to validate that LINEINFO and CALLINFO are zero when
// calling mfn_LoadLine and mfn_LoadCall.
//
BOOL validate_DWORD_aligned_zero_buffer(
        void *pv,
        UINT cb
        );


// Tokens for device classes...
enum {
            DEVCLASS_UNKNOWN                        =0,
            DEVCLASS_TAPI_LINE                      =(0x1<<0),
            DEVCLASS_TAPI_PHONE                     =(0x1<<1),
            DEVCLASS_COMM                           =(0x1<<2),
            DEVCLASS_COMM_DATAMODEM                 =(0x1<<3),
            DEVCLASS_COMM_DATAMODEM_PORTNAME        =(0x1<<4),
            DEVCLASS_COMM_EXTENDEDCAPS              =(0x1<<5),
            DEVCLASS_WAVE_IN                        =(0x1<<6),
            DEVCLASS_WAVE_OUT                       =(0x1<<7),
            DEVCLASS_TAPI_LINE_DIAGNOSTICS          =(0x1<<8),
            DEVCLASS_COMM_DATAMODEM_DIALIN          =(0x1<<9),
            DEVCLASS_COMM_DATAMODEM_DIALOUT         =(0x1<<10)
};

UINT
gen_device_classes(
    DWORD dwClasses,
    BOOL fMultiSz,
    LPTSTR lptsz,
    UINT cch
    );;

DWORD    parse_device_classes(LPCTSTR ptszClasses, BOOL fMultiSz);

DWORD
APIENTRY 
UmRtlSetDefaultCommConfig(
    IN HKEY         hKey,
    IN LPCOMMCONFIG pcc,
    IN DWORD        dwSize           // This is ignored
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\tsp\cdevdlg.cpp ===
// 
// Copyright (c) 1996-1997 Microsoft Corporation.
//
//
// Component
//
//		Unimodem 5.0 TSP (Win32, user mode DLL)
//
// File
//
//		CDEVDLG.CPP
//		Implements sending and accepting requests concerning UI (dialog)-
//      related stuff.
//
// History
//
//		04/05/1996  JosephJ Created (moved stuff from NT4.0 TSP's wndthrd.c).
//
//
#include "tsppch.h"
#include "tspcomm.h"
#include "globals.h"
#include "cmini.h"
#include "cdev.h"
#include "apptspi.h"

#include "resource.h"
FL_DECLARE_FILE(0x4126abc0, "Implements UI-related features of CTspDev")


// TBD:
#define STOP_UI_DLG(_XXX)


enum
{
UI_DLG_TALKDROP,
UI_DLG_MANUAL,
UI_DLG_TERMINAL
};

static
void
dump_terminal_state(
        DWORD dwType,
        DWORD dwState,
        CStackLog *psl
        );

LONG
CTspDev::mfn_GenericLineDialogData(
    void *pParams,
    DWORD dwSize,
    CStackLog *psl
    )
{
  FL_DECLARE_FUNC(0x0b6af2d4, "GenericLineDialogData")
  PDLGREQ  pDlgReq = (PDLGREQ) pParams;
  LONG lRet = 0;
  CALLINFO *pCall = m_pLine ? m_pLine->pCall : NULL;

  FL_LOG_ENTRY(psl);

  // Determine the request
  //
  switch(pDlgReq->dwCmd)
  {
    case UI_REQ_COMPLETE_ASYNC:

        //
        // We may get here after the line and/or call instance has gone
        // away (this can happen if the user hits cancel, plus the 
        // line is disconnected remotely plus the app hits lineClose
        // all at more-or-less the same time.
        //
        // So let's check first...
        //
        if  (    pCall
             &&  NULL != pCall->TerminalWindowState.htspTaskTerminal)
        {
            HTSPTASK htspTask = pCall->TerminalWindowState.htspTaskTerminal;
            pCall->TerminalWindowState.htspTaskTerminal = NULL;
            AsyncCompleteTask (htspTask,            // task
                               pDlgReq->dwParam,    // async return
                               TRUE,                // Queue APC
                               psl);
        }
      break;

    case UI_REQ_END_DLG:
      switch(pDlgReq->dwParam)
      {
        case TALKDROP_DLG:
            STOP_UI_DLG(UI_DLG_TALKDROP);
            break;

        case MANUAL_DIAL_DLG:
            STOP_UI_DLG(UI_DLG_MANUAL);
            break;

        case TERMINAL_DLG:
            STOP_UI_DLG(UI_DLG_TERMINAL);
            break;
      };
      break;

    case UI_REQ_HANGUP_LINE:


      if (pCall != NULL) {

          pCall->TalkDropButtonPressed=TRUE;
          pCall->TalkDropStatus=pDlgReq->dwParam;


          if (pCall->TalkDropWaitTask != NULL) {
              //
              //  The dial task has already completed and the talk drop dialog is up.
              //  Complete the task that is waiting for the dialog to go away
              //
              HTSPTASK htspTask=pCall->TalkDropWaitTask;
              pCall->TalkDropWaitTask=NULL;

              AsyncCompleteTask (htspTask,            // task
                                 pDlgReq->dwParam,    // async return
                                 TRUE,                // Queue APC
                                 psl);
          }


      }

      if (m_pLLDev && m_pLLDev->htspTaskPending) {
           //
           //  the dial task is still pending, try to abort it so the modem will
           //  return an response from the dial attempt, probably NO_CARRIER.
           //
           m_StaticInfo.pMD->AbortCurrentModemCommand(
               m_pLLDev->hModemHandle,
               psl
               );
      }

      break;

    case UI_REQ_TERMINAL_INFO:
    {
      PTERMREQ   pTermReq = (PTERMREQ)pDlgReq;
      HANDLE     hTargetProcess;

      pTermReq->dwTermType = 0;
      pTermReq->hDevice = NULL;

      if (pCall && m_pLLDev)
      {
          // Duplicate sync event handle
          //

          if ((hTargetProcess = OpenProcess(PROCESS_DUP_HANDLE, TRUE,
                                            pTermReq->DlgReq.dwParam)) != NULL)
          {
              pTermReq->hDevice = m_StaticInfo.pMD->DuplicateDeviceHandle (
                                      m_pLLDev->hModemHandle,
                                      hTargetProcess,
                                      psl);
    
              CloseHandle(hTargetProcess);
          };

          // Get the terminal type
          //        
          pTermReq->dwTermType = pCall->TerminalWindowState.dwType;
      }
      
      break;
    }



    case UI_REQ_GET_PROP:
    {
      PPROPREQ   pPropReq = (PPROPREQ)pDlgReq;

      ASSERT(m_Settings.pDialInCommCfg);

      pPropReq->dwCfgSize =  m_Settings.pDialInCommCfg->dwSize +  sizeof(UMDEVCFGHDR);
      pPropReq->dwMdmType =  m_StaticInfo.dwDeviceType;
      pPropReq->dwMdmCaps =  m_StaticInfo.dwDevCapFlags;
      pPropReq->dwMdmOptions = m_StaticInfo.dwModemOptions;
      lstrcpyn(pPropReq->szDeviceName, m_StaticInfo.rgtchDeviceName,
               sizeof(pPropReq->szDeviceName)); 
      lRet = 0;
      break;
    }

    case UI_REQ_GET_UMDEVCFG:
    case UI_REQ_GET_UMDEVCFG_DIALIN:
    {
      if (mfn_GetDataModemDevCfg(
            (UMDEVCFG *) (pDlgReq+1),
             pDlgReq->dwParam,
            NULL,
            pDlgReq->dwCmd == UI_REQ_GET_UMDEVCFG_DIALIN,
            psl
            ))
      {
        lRet = LINEERR_OPERATIONFAILED;
      }
      break;
    }

    case UI_REQ_SET_UMDEVCFG:
    case UI_REQ_SET_UMDEVCFG_DIALIN:
    {
      if (mfn_SetDataModemDevCfg(
            (UMDEVCFG *) (pDlgReq+1),
            pDlgReq->dwCmd == UI_REQ_SET_UMDEVCFG_DIALIN,
            psl
            ))
      {
        lRet = LINEERR_OPERATIONFAILED;
      }
      break;
    }

    case UI_REQ_GET_PHONENUMBER:
    {
      PNUMBERREQ   pNumberReq = (PNUMBERREQ)pDlgReq;

      *(pNumberReq->szPhoneNumber)=0;

      if (pCall)
      {
        UINT u = lstrlenA(pCall->szAddress);
        if ((u+1) > sizeof(pNumberReq->szPhoneNumber))
        {
            u = sizeof(pNumberReq->szPhoneNumber)-1;
        }
        CopyMemory(pNumberReq->szPhoneNumber, pCall->szAddress, u);
        pNumberReq->szPhoneNumber[u]=0;
      }

      break;
    }

    default:
      break;
  }

  FL_LOG_EXIT(psl, lRet);

  return lRet;
}

LONG
CTspDev::mfn_GenericPhoneDialogData(
    void *pParams,
    DWORD dwSize
    )
{
	return LINEERR_OPERATIONUNAVAIL;
}



void
CTspDev::mfn_FreeDialogInstance (void)
{
    ASSERT(m_pLine);
    ASSERT(m_pLine->pCall);

    if (NULL != m_pLine->pCall->TerminalWindowState.htDlgInst)
    {
     DLGINFO DlgInfo;

        ASSERT(m_pLine);
        ASSERT(m_pLine->pCall);

        // Tell the application side
        // to free the dialog instance
        DlgInfo.idLine = 0;
        DlgInfo.dwType = 0;
        DlgInfo.dwCmd  = DLG_CMD_FREE_INSTANCE;

        m_pLine->lpfnEventProc ((HTAPILINE)(LONG_PTR)m_pLine->pCall->TerminalWindowState.htDlgInst,
                                0,
                                LINE_SENDDIALOGINSTANCEDATA,
                                (ULONG_PTR)(&DlgInfo),
                                sizeof(DlgInfo),
                                0);
        m_pLine->pCall->TerminalWindowState.htDlgInst = NULL;
    }
}



TSPRETURN
CTspDev::mfn_CreateDialogInstance (
    DWORD dwRequestID,
    CStackLog *psl)
{
 TSPRETURN tspRet = 0;
 TUISPICREATEDIALOGINSTANCEPARAMS cdip;
 TCHAR szTSPFilename[MAX_PATH];

    FL_DECLARE_FUNC(0xa00d3f43, "CTspDev::mfn_CreateDialogInstance")
    FL_LOG_ENTRY(psl);

    ASSERT(m_pLine);
    ASSERT(m_pLine->pCall);

    if ((m_pLine->pCall->TerminalWindowState.dwOptions != 0)
        ||
        ((m_Line.Call.dwCurMediaModes & LINEMEDIAMODE_INTERACTIVEVOICE)
         &&
         !mfn_CanDoVoice() ) )

    {
        GetModuleFileName (g.hModule, szTSPFilename, MAX_PATH);

        cdip.dwRequestID = dwRequestID;
        cdip.hdDlgInst   = (HDRVDIALOGINSTANCE)this;
        cdip.htDlgInst   = NULL;
        cdip.lpszUIDLLName = szTSPFilename;
        cdip.lpParams    = NULL;
        cdip.dwSize      = 0;

        m_pLine->lpfnEventProc ((HTAPILINE)mfn_GetProvider(),
                                0,
                                LINE_CREATEDIALOGINSTANCE,
                                (ULONG_PTR)(&cdip),
                                0,
                                0);

        m_pLine->pCall->TerminalWindowState.htDlgInst = cdip.htDlgInst;

        if (NULL == cdip.htDlgInst)
        {
            tspRet = FL_GEN_RETVAL(IDERR_GENERIC_FAILURE);
        }
    }

    FL_LOG_EXIT(psl, tspRet);
    return tspRet;
}




TSPRETURN
CTspDev::mfn_TH_CallStartTerminal(
	HTSPTASK htspTask,
	TASKCONTEXT *pContext,
	DWORD dwMsg,
	ULONG_PTR dwParam1,
	ULONG_PTR dwParam2,     // unused
	CStackLog *psl
	)
{

	FL_DECLARE_FUNC(0xd582711d, "CTspDev::mfn_TH_CallStartTerminal")
	FL_LOG_ENTRY(psl);

    TSPRETURN tspRet = 0;
    ULONG_PTR *pdwType = &(pContext->dw0); // saved context.
    TSPRETURN *ptspTrueReturn = &(pContext->dw1); // saved context.

    enum
    {
        STARTTERMINAL_PASSTHROUGHON,
        STARTTERMINAL_TERMINALWINDOWDONE,
        STARTTERMINAL_PASSTHROUGHOFF,
        STARTTERMINAL_INITDONE
    };

    switch(dwMsg)
    {
    default:
        FL_SET_RFR(0xc393d700, "Unknown Msg");
        goto end;

    case MSG_START:
        goto start;

	case MSG_SUBTASK_COMPLETE:
        tspRet = dwParam2;
        switch(dwParam1) // Param1 is Subtask ID
        {

        case STARTTERMINAL_PASSTHROUGHON:         goto passthrough_on;
        case STARTTERMINAL_TERMINALWINDOWDONE:    goto terminal_done;
        case STARTTERMINAL_PASSTHROUGHOFF:        goto passthrough_off;
        case STARTTERMINAL_INITDONE:              goto init_done;

        default:
            tspRet = IDERR_CORRUPT_STATE;
            goto end;
        }
        break;

    case MSG_DUMPSTATE:

        switch(*pdwType)
        {
        case UMTERMINAL_PRE:
	        FL_SET_RFR(0x62e06c00, "PRECONNECT TERMINAL");
            break;

        case UMTERMINAL_POST:
	        FL_SET_RFR(0x2b676900, "POSTCONNECT TERMINAL");
            break;

        case UMMANUAL_DIAL:
	        FL_SET_RFR(0x45fca600, "MANUAL DIAL");
            break;
        }
        tspRet = 0;

        goto end;
    }

start:

    // Start params:
    //  dwParam1: dwType ((UMTERMINAL_[PRE|POST])|UMMANUAL_DIAL)
    //  dwParam2: unused;

    tspRet = 0; // assume success...
    *pdwType = dwParam1; // save dwType in context.
    *ptspTrueReturn = 0; // save "true return" value in context. This is
                         // the return value from the dialog session.


    //
    // If required, 1st go to passthrough mode
    //
    if (*pdwType==UMTERMINAL_PRE)
    {
        tspRet = mfn_StartSubTask (
                            htspTask,
                            &s_pfn_TH_LLDevUmSetPassthroughMode,
                            STARTTERMINAL_PASSTHROUGHON,
                            PASSTHROUUGH_MODE_ON,
                            0,
                            psl);

    }

passthrough_on:

    if (tspRet) goto end;
    //
    //          If we got an error (including IDERR_PENDING)
    //          just return to the caller;
    //          In case we got IDERR_PENDING, we'll be back
    //          in this handler, with a MSG_SUBTASK_COMPLETE
    //          and and ID of STARTTERMINAL_PASSTHROUGHON
    //

    // This is the second step;
    // when we get here we're in passthrough mode
    // and we need to actually bring up the
    // terminal window
    tspRet = mfn_StartSubTask (
                        htspTask,
                        &s_pfn_TH_CallPutUpTerminalWindow,
                        STARTTERMINAL_TERMINALWINDOWDONE,
                        *pdwType,
                        0,
                        psl);

terminal_done:
         
    if (IDERR(tspRet)==IDERR_PENDING) goto end;
    
    // even on error, we must switch out of passthrough mode if required...
    // meanwhile, we save the return value from the UI side of things...
    *ptspTrueReturn = tspRet;

    if (*pdwType==UMTERMINAL_PRE)
    {

        tspRet = mfn_StartSubTask (
                            htspTask,
                            &s_pfn_TH_LLDevUmSetPassthroughMode,
                            STARTTERMINAL_PASSTHROUGHOFF,
                            PASSTHROUUGH_MODE_OFF,
                            0,
                            psl);

    }

passthrough_off:
    
    if (IDERR(tspRet)==IDERR_PENDING) goto end;

    //
    // Even on error, we try to re-init the modem on pre-connect terminal...
    //
    if (*pdwType==UMTERMINAL_PRE)
    {
        tspRet = mfn_StartSubTask (
                            htspTask,
                            &CTspDev::s_pfn_TH_LLDevUmInitModem,
                            STARTTERMINAL_INITDONE,
                            0,  // dwParam1 (unused)
                            0,  // dwParam2 (unused)
                            psl);
    }

init_done:

    if (tspRet) goto end;

    // Success -- let's retrieve the true return value from the dialog...
    tspRet  = *ptspTrueReturn;

end:

	FL_LOG_EXIT(psl, tspRet);

	return tspRet;
}



TSPRETURN
CTspDev::mfn_TH_CallPutUpTerminalWindow(
					HTSPTASK htspTask,
					TASKCONTEXT *pContext,
					DWORD dwMsg,
					ULONG_PTR dwParam1,
					ULONG_PTR dwParam2,
					CStackLog *psl
					)
{
    TSPRETURN tspRet = IDERR_CORRUPT_STATE;

    FL_DECLARE_FUNC(0x1b009123, "mfn_TH_CallPutUpTerminalWindow");
    FL_LOG_ENTRY(psl);

    switch(dwMsg)
    {
    case MSG_START:
        goto start;

	case MSG_TASK_COMPLETE:
        tspRet = dwParam2;
        goto task_complete;

    case MSG_DUMPSTATE:
        tspRet = 0;
        goto end;

    default:
        ASSERT(FALSE);
        goto end;

    }

start:
    // start params: dwParam1 == terminal type.

    {
        DLGINFO DlgInfo;

        ASSERT(m_pLine);
        ASSERT(m_pLine->pCall);
        ASSERT(NULL != m_pLine->pCall->TerminalWindowState.htDlgInst);

        if (NULL == m_pLine->pCall->TerminalWindowState.htDlgInst)
        {
            goto end;
        }


        if (m_pLLDev && m_pLLDev->IsLoggingEnabled()) {

            CHAR    ResourceString[256];
            int     StringSize;

            StringSize=LoadStringA(
                g.hModule,
                (dwParam1 == UMMANUAL_DIAL) ? IDS_MANUAL_DIAL_DIALOG : IDS_TERMINAL_DIALOG,
                ResourceString,
                sizeof(ResourceString)
                );

            if (StringSize > 0) {

                m_StaticInfo.pMD->LogStringA(
                                    m_pLLDev->hModemHandle,
                                    LOG_FLAG_PREFIX_TIMESTAMP,
                                    ResourceString,
                                    NULL
                                    );
            }
        }


        m_pLine->pCall->TerminalWindowState.htspTaskTerminal = htspTask;
        m_pLine->pCall->TerminalWindowState.dwType = (DWORD)dwParam1;

        // Tell the application side
        // to start running the dialog instance
        DlgInfo.idLine = mfn_GetLineID ();
        DlgInfo.dwType =    (dwParam1==UMMANUAL_DIAL)
                        ? MANUAL_DIAL_DLG
                        : TERMINAL_DLG;
        DlgInfo.dwCmd  = DLG_CMD_CREATE;





        m_pLine->lpfnEventProc (
                    (HTAPILINE)(LONG_PTR)m_pLine->pCall->TerminalWindowState.htDlgInst,
                    0,
                    LINE_SENDDIALOGINSTANCEDATA,
                    (ULONG_PTR)(&DlgInfo),
                    sizeof(DlgInfo),
                    0);

        // At this point the terminal is up;
        // we wait for the user to close it
        //
        // NOTE: what if the above call fails -- perhaps because the app
        // dies?
        // ANSWER: on TSPI_lineDrop or TSPI_lineCloseCall we will
        // unilaterally complete this task.
        //
        tspRet = IDERR_PENDING;
        goto end;
    }


task_complete:

    ASSERT(!(m_pLine->pCall->TerminalWindowState.htspTaskTerminal));
    m_pLine->pCall->TerminalWindowState.htspTaskTerminal = NULL;
    m_pLine->pCall->TerminalWindowState.dwType = 0;

end:

    FL_LOG_EXIT(psl, tspRet);
    return tspRet;
}


void
CTspDev::mfn_KillCurrentDialog(
            CStackLog *psl
            )
//
// If there is a dialog put in the application's context, take it down
// and complete the TSP Task that is pending waiting for the dialog to
// go away.
//
{
	FL_DECLARE_FUNC(0x1fb58214, "mfn_KillCurrentDialog")
	CALLINFO *pCall = (m_pLine) ? m_pLine->pCall : NULL;

    if (!pCall) goto end;

    if (NULL != pCall->TerminalWindowState.htspTaskTerminal)
    {
        DLGINFO DlgInfo;


        //
        // Bring down the terminal dialog that's up in the apps context.
        //
        SLPRINTF0(psl, "Killing terminal dialog");
    
        // Package the parameters
        //
        DlgInfo.idLine = mfn_GetLineID ();
        DlgInfo.dwType   = m_pLine->pCall->TerminalWindowState.dwType;
        DlgInfo.dwCmd    = DLG_CMD_DESTROY;
    
        m_pLine->lpfnEventProc (
                       (HTAPILINE)(LONG_PTR)m_pLine->pCall->TerminalWindowState.htDlgInst,
                        0,
                        LINE_SENDDIALOGINSTANCEDATA,
                        (ULONG_PTR)(&DlgInfo),
                        sizeof(DlgInfo),
                        0);

        SLPRINTF0(psl, "Completing terminal task");

        //
        // Complete the a task pending because of this.
        //

        HTSPTASK htspTask =
             m_pLine->pCall->TerminalWindowState.htspTaskTerminal;
        m_pLine->pCall->TerminalWindowState.htspTaskTerminal = NULL;
        this->AsyncCompleteTask (
                htspTask,            // task
                IDERR_OPERATION_ABORTED, // async return value.
                TRUE,                // Queue APC
                psl
                );
    }

end:
    return;
}


void
CTspDev::mfn_KillTalkDropDialog(
            CStackLog *psl
            )
//
// If there is a dialog put in the application's context, take it down
// and complete the TSP Task that is pending waiting for the dialog to
// go away.
//
{
	FL_DECLARE_FUNC(0x1fb68214, "mfn_KillTalkDropDialog")
	CALLINFO *pCall = (m_pLine) ? m_pLine->pCall : NULL;

    if (!pCall) goto end;

    if (NULL != pCall->TalkDropWaitTask) {

        DLGINFO DlgInfo;


        //
        // Bring down the terminal dialog that's up in the apps context.
        //
        SLPRINTF0(psl, "Killing talkdrop dialog");
    
        // Package the parameters
        //
        DlgInfo.idLine = mfn_GetLineID ();
        DlgInfo.dwType   = TALKDROP_DLG;
        DlgInfo.dwCmd    = DLG_CMD_DESTROY;
    
        m_pLine->lpfnEventProc (
                       (HTAPILINE)(LONG_PTR)m_pLine->pCall->TerminalWindowState.htDlgInst,
                        0,
                        LINE_SENDDIALOGINSTANCEDATA,
                        (ULONG_PTR)(&DlgInfo),
                        sizeof(DlgInfo),
                        0);

        SLPRINTF0(psl, "Completing talkdrop task");

        //
        // Complete the a task pending because of this.
        //
        HTSPTASK htspTask = pCall->TalkDropWaitTask;
        pCall->TalkDropWaitTask=NULL;


        this->AsyncCompleteTask (
                htspTask,            // task
                IDERR_OPERATION_ABORTED, // async return value.
                TRUE,                // Queue APC
                psl
                );
    }

end:
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\tsp\cdevtask.cpp ===
// 
// Copyright (c) 1996-1997 Microsoft Corporation.
//
//
// Component
//
//		Unimodem 5.0 TSP (Win32, user mode DLL)
//
// File
//
//		CDEVTASK.CPP
//		Implements task functionality of class CTspDev
//
// History
//
//		01/24/1997  JosephJ Created (moved stuff from cdev.cpp)
//
//
#include "tsppch.h"
#include "tspcomm.h"
//#include <umdmmini.h>
#include "cmini.h"
#include "cdev.h"

FL_DECLARE_FILE(0x39c8667c, "CTspDev Task Functionality")

#define COLOR_APC_TASK_COMPLETION (FOREGROUND_RED | FOREGROUND_GREEN)

#if (0)
    #define        THROW_PENDING_EXCEPTION() throw PENDING_EXCEPTION()
#else
    #define        THROW_PENDING_EXCEPTION() 0
#endif


TSPRETURN
CTspDev::mfn_GetTaskInfo(
	HTSPTASK htspTask,
    DEVTASKINFO **ppInfo, // OPTIONAL
	CStackLog *psl
	)
{
	FL_DECLARE_FUNC(0xc495426f, "mfn_GetTaskInfo")
    ULONG_PTR uIndex = ((ULONG_PTR)htspTask) & 0xffff;
    //              LOWORD of htspTask is the 0-based index of the task.
	DEVTASKINFO *pInfo = m_rgTaskStack + uIndex;

    //
    // In our current implementation, we'll be hardcore about
    // only allowing dereferincing the handle of the top task of the stack...
    //
    if (!htspTask || (uIndex+1) != m_uTaskDepth)
    {
        goto failure;
    }


    // Validate the pInfo structure and make sure it's the
    // task associated with htspTask..
    //
	if (   pInfo->hdr.dwSigAndSize != MAKE_SigAndSize(sizeof(*pInfo))
	    || !IS_ALLOCATED(pInfo)
	    || htspTask!=pInfo->hTask)
    {
		goto failure;
    }

	if (ppInfo)
    {
        *ppInfo =  pInfo;
    }

    return 0;

failure:

    FL_SET_RFR(0x98f08500, "Invalid htspTask");
    // TODO: allow logging of DWORDs!

    ASSERT(FALSE);

    return  FL_GEN_RETVAL(IDERR_INVALIDHANDLE);

}



TSPRETURN
CTspDev::mfn_StartRootTask(
	PFN_CTspDev_TASK_HANDLER *ppfnTaskHandler,
    BOOL *pfTaskPending,
    ULONG_PTR dwParam1,
    ULONG_PTR dwParam2,
	CStackLog *psl
	)
{
	FL_DECLARE_FUNC(0xdb1ef3ee, "CTspDev::mfn_StartRootTask")
	FL_LOG_ENTRY_EX(psl);
	TSPRETURN tspRet=0;
	DEVTASKINFO *pInfo = NULL;

    if (m_uTaskDepth)
	{
	    // There is already a task active.

        FL_SET_RFR(0x7aafbd00, "Task already pending");
        tspRet = FL_GEN_RETVAL(IDERR_TASKPENDING);
        goto end;

    }
    
    ASSERT(!m_pfTaskPending);
    ASSERT(!m_hRootTaskCompletionEvent);

    m_pfTaskPending = NULL;
    m_hRootTaskCompletionEvent=NULL;

    *pfTaskPending = FALSE;
    pInfo = m_rgTaskStack;
    pInfo->Load(this, ppfnTaskHandler, mfn_NewTaskHandle(0));
	m_uTaskDepth = 1;

    // Having just created the task, it's handle
    // had better be valid!
    {
        DEVTASKINFO *pInfo1;
        ASSERT(    !mfn_GetTaskInfo(pInfo->hTask, &pInfo1, psl)
                && pInfo1 == pInfo);
    }


#if (1)

	// Call the task's handler function
	tspRet = (this->**ppfnTaskHandler)(
				pInfo->hTask,
				&(pInfo->TaskContext),
				MSG_START,
				dwParam1,
				dwParam2,
				psl
				);

	if (IDERR(tspRet)==IDERR_PENDING)
	{
        // fPENDING and fSUBTASK_PENDING are used simply to validate
        // state transitions. See, for example, CTspDev::AsyncCompleteTask.

        SET_PENDING(pInfo);

        *pfTaskPending = TRUE;
        m_pfTaskPending = pfTaskPending;

	}
    else
    {
        // Pop the current task off the stack.
        pInfo->Unload();
        m_uTaskDepth=0;
    }

#else // !OBSOLETE

    try
    {
        // Call the task's handler function
        tspRet = (this->**ppfnTaskHandler)(
                    pInfo->hTask,
                    &(pInfo->TaskContext),
                    MSG_START,
                    dwParam1,
                    dwParam2,
                    psl
                    );

        if (IDERR(tspRet)==IDERR_PENDING)
        {
            ASSERT(FALSE);
            THROW_PENDING_EXCEPTION();
        }

        // Pop the current task off the stack.
        pInfo->Unload();
        m_uTaskDepth=0;

    }
    catch (PENDING_EXCEPTION pe)
    {
        FL_RESET_LOG(psl);
        SET_PENDING(pInfo);

        *pfTaskPending = TRUE;
        m_pfTaskPending = pfTaskPending;
        tspRet = IDERR_PENDING;
    }
    
#endif // !OBSOLETE

end:

	FL_LOG_EXIT(psl, tspRet);
	return tspRet;
}


TSPRETURN
CTspDev::mfn_StartSubTask(
	HTSPTASK  htspParentTask,
	PFN_CTspDev_TASK_HANDLER *ppfnTaskHandler,
    DWORD dwTaskID,
    ULONG_PTR dwParam1,
    ULONG_PTR dwParam2,
	CStackLog *psl
	)
{
	FL_DECLARE_FUNC(0xc831339f, "CTspDev::mfn_StartSubTask")
	FL_LOG_ENTRY(psl);
	TSPRETURN tspRet=0;
	DEVTASKINFO *pInfo = NULL;
	DEVTASKINFO *pParentInfo = NULL;

    tspRet = mfn_GetTaskInfo(htspParentTask, &pParentInfo, psl);
    if (tspRet) goto end;

	// Verify we have enough space in the task stack.
	if (m_uTaskDepth >= MAX_TASKS)
	{
		FL_SET_RFR(0x37557c00, "Out of task stack space");
		tspRet = FL_GEN_RETVAL(IDERR_INTERNAL_OBJECT_TOO_SMALL);
		goto end;
	}
	
    pInfo = m_rgTaskStack+m_uTaskDepth;
    pInfo->Load(
            this,
            ppfnTaskHandler,
            mfn_NewTaskHandle(m_uTaskDepth)
        );
	m_uTaskDepth++;

    // Having just created the task, it's handle
    // had better be valid!
    {
        DEVTASKINFO *pInfo1;
        ASSERT(    !mfn_GetTaskInfo(pInfo->hTask, &pInfo1, psl)
                && pInfo1 == pInfo);
    }

#if (1) 

	// Call the task's handler function
	tspRet = (this->**ppfnTaskHandler)(
				pInfo->hTask,
				&(pInfo->TaskContext),
				MSG_START,
				dwParam1,
				dwParam2,
				psl
				);

	if (IDERR(tspRet)==IDERR_PENDING)
	{
        // fPENDING and fSUBTASK_PENDING are used simply to validate
        // state transitions. See, for example, CTspDev::AsyncCompleteTask.

        SET_PENDING(pInfo);
        FL_ASSERT(psl, pParentInfo);
        pParentInfo->dwCurrentSubtaskID = dwTaskID;
        SET_SUBTASK_PENDING(pParentInfo);
	}
    else
    {
        // Pop the current task off the stack.
        ASSERT(m_uTaskDepth);
        pInfo->Unload();
        m_uTaskDepth--;

        // Since we are a sub task, on completion m_uTaskDepth had
        // better be non-zero!
        //
        FL_ASSERT(psl, m_uTaskDepth);

    }

#else // !OBSOLETE

    try
    {
        // Call the task's handler function
        tspRet = (this->**ppfnTaskHandler)(
                    pInfo->hTask,
                    &(pInfo->TaskContext),
                    MSG_START,
                    dwParam1,
                    dwParam2,
                    psl
                    );

        if (IDERR(tspRet)==IDERR_PENDING)
        {
            ASSERT(FALSE);
            THROW_PENDING_EXCEPTION();
        }
        
        // Pop the current task off the stack.
        ASSERT(m_uTaskDepth);
        pInfo->Unload();
        m_uTaskDepth--;

        // Since we are a sub task, on completion m_uTaskDepth had
        // better be non-zero!
        //
        FL_ASSERT(psl, m_uTaskDepth);
    
    }
    catch (PENDING_EXCEPTION pe)
    {


        // fPENDING and fSUBTASK_PENDING are used simply to validate
        // state transitions. See, for example, CTspDev::AsyncCompleteTask.

        SET_PENDING(pInfo);
        ASSERT(pParentInfo);
        pParentInfo->dwCurrentSubtaskID = dwTaskID;
        SET_SUBTASK_PENDING(pParentInfo);
        THROW_PENDING_EXCEPTION();
    }
    
#endif // !OBSOLETE

end:

	FL_LOG_EXIT(psl, tspRet);
	return tspRet;
}

void
CTspDev::mfn_AbortRootTask(
    DWORD dwAbortParam,
    CStackLog *psl
    )
{
    return;
}

// Following causes the sub-task's handler function to be called with
// MSG_ABORT, and dwParam1 set to dwAbortFlags. If there is no
// current sub-tsk, this does nothing.
//
void
CTspDev::mfn_AbortCurrentSubTask(
	HTSPTASK htspTask,
	DWORD dwAbortParam,
	CStackLog *psl
	)
{
	FL_DECLARE_FUNC(0x0c4deb87, "CTspDev::mfn_AbortCurrentSubTask")
	FL_LOG_ENTRY(psl);
	TSPRETURN tspRet=0;

    // TODO: unimplemented.

	FL_LOG_EXIT(psl, 0);
	return;
}

void
apcTaskCompletion(ULONG_PTR dwParam)
//
// This APC handler calls pDev->AsyncTaskComplete in the context of
// an APC. The APC was queued by an earlier call to pDev->AsyncTaskComplete
// which requested that the completion be queued in an APC.
//
{

	FL_DECLARE_FUNC(0x57298aa5, "apcTaskCompletion")
    FL_DECLARE_STACKLOG(sl, 1000);

    // TODO: replace individual checks below (IS_PENDING,IS_APC_QUEUED)
    // by something more efficient -- no big deal.
    //
	CTspDev::DEVTASKINFO *pInfo = (CTspDev::DEVTASKINFO*)dwParam;
	CTspDev *pDev = pInfo->pDev;
    sl.SetDeviceID(pDev->GetLineID()); // even for phone, we report lineID --
                                       // oh-well..

    // TODO: move all this into pDev->AsyncCompleteTask.
    pDev->m_sync.EnterCrit(FL_LOC);

	if ( (pInfo->hdr.dwSigAndSize != MAKE_SigAndSize(sizeof(*pInfo)))
	     || !IS_PENDING(pInfo)
         || !IS_APC_QUEUED(pInfo))
    {
        SLPRINTF1(&sl, "Invalid pInfo: 0x%08lx", dwParam);
        pDev->m_sync.LeaveCrit(FL_LOC);
		goto end;
    }

    CLEAR_APC_QUEUED(pInfo);

    pDev->m_sync.LeaveCrit(FL_LOC);

    pDev->AsyncCompleteTask(
            pInfo->hTask,
            pInfo->tspRetAsync,
	        FALSE,
            &sl
	        );

end:

    // NOTE: async complete may well change the state of *pInfo, so
    // don't refer to *pInfo here! This is why we save the location
    // of pDev in the stack!
    //
    // pDev->m_sync.LeaveCrit(FL_LOC);

    sl.Dump(COLOR_APC_TASK_COMPLETION);

}

void
CTspDev::AsyncCompleteTask(
	HTSPTASK htspTask,
	TSPRETURN tspRetAsync,
	BOOL    fQueueAPC,
	CStackLog *psl
	)
{
	FL_DECLARE_FUNC(0x38f145c4, "CTspDev:AsyncCompleteTask")
	DEVTASKINFO *pInfo = NULL;
	DWORD dwContextSize = 0;
    TSPRETURN tspRet=FL_GEN_RETVAL(IDERR_INVALID_ERR);
	FL_LOG_ENTRY_EX(psl);

    // NOTE: This is a public function and hence we can't assume that the
    // critical section to the device is held on entry.
    //
	m_sync.EnterCrit(FL_LOC);

    // AsyncCompleteTask should never be called with a return value indicating
    // that the operation is pending!
	FL_ASSERT(psl, IDERR(tspRetAsync)!=IDERR_PENDING);

    tspRet = mfn_GetTaskInfo(htspTask, &pInfo, psl);
    if (tspRet) goto end;


    if (fQueueAPC)
    {
        // Save away dwResult ...
        pInfo->tspRetAsync =  tspRetAsync;
        ASSERT(pInfo->pDev == this);
        SET_APC_QUEUED(pInfo);

        // Note -- we can expect that the context will now switch to
        // the APC thread handle the completion. This is why we set
        // the state to indicate queued above, before the call to
        // QueueUserAPC.
        //
        if (!QueueUserAPC(apcTaskCompletion, m_hThreadAPC, (ULONG_PTR) pInfo))
        {
            FL_SET_RFR(0x42177c00, "Aargh, QueueUserAPC failed!");
            SLPRINTF1(psl, "m_hThreadAPC=0x%lx", m_hThreadAPC);
            CLEAR_APC_QUEUED(pInfo);
	        tspRet=FL_GEN_RETVAL(IDERR_CORRUPT_STATE);
        }
        else
        {
            FL_SET_RFR(0x55e7c800, "Queued completion");
            tspRet = IDERR_PENDING;
        }
        goto end;
    }

    // TODO -- more checking of state: eg, can't have two completions, must
    //  complete phase you started, deal with aborted condition, etc....
    if (!IS_PENDING(pInfo))
    {
        FL_ASSERTEX(psl, 0x62e05002, FALSE, "Task not in PENDING state");
        goto end;
    }

    FL_ASSERT(psl, !IS_APC_QUEUED(pInfo));

    ASSERT(m_uTaskDepth);

    // Send TASK_COMPLETE msg to the current task's task handler.
    tspRetAsync = (this->**(pInfo->ppfnHandler))(
                        pInfo->hTask,
                        //pInfo->rgbContextData,
				        &(pInfo->TaskContext),
                        MSG_TASK_COMPLETE,
                        0,
                        tspRetAsync,
                        psl
                        );
    ASSERT(IDERR(tspRetAsync)!=IDERR_PENDING);

    // We start walking backwards towards the root task, completing each
    // of the subtasks until one of the subtasks returns IDERR_PENDING.
    //
    do
    {
        // Pop the current task off the stack.
        pInfo->Unload();
        m_uTaskDepth--;

        if (m_uTaskDepth)
        {
            // Get parent task info
            //
            pInfo = m_rgTaskStack + m_uTaskDepth-1;
            FL_ASSERT(psl, IS_SUBTASK_PENDING(pInfo));
            CLEAR_SUBTASK_PENDING(pInfo);
            FL_ASSERT(psl, IS_PENDING(pInfo));

       #if (1)
            // Call the parent task's task handler.
            tspRetAsync = (this->**(pInfo->ppfnHandler))(
                                pInfo->hTask,
                                //pInfo->rgbContextData,
                                &(pInfo->TaskContext),
                                MSG_SUBTASK_COMPLETE,
                                pInfo->dwCurrentSubtaskID,
                                tspRetAsync,
                                psl
                                );
       #else // 0
            try
            {
                // Call the parent task's task handler.
                tspRetAsync = (this->**(pInfo->ppfnHandler))(
                                    pInfo->hTask,
                                    //pInfo->rgbContextData,
                                    &(pInfo->TaskContext),
                                    MSG_SUBTASK_COMPLETE,
                                    pInfo->dwCurrentSubtaskID,
                                    tspRetAsync,
                                    psl
                                    );

                if (IDERR(tspRetAsync)==IDERR_PENDING)
                {
                    ASSERT(FALSE);
                    THROW_PENDING_EXCEPTION();
                }
            }
            catch (PENDING_EXCEPTION pe)
            {
	            FL_RESET_LOG(psl);
                tspRetAsync = IDERR_PENDING;
            }
       #endif // 0
        }

    }
    while (m_uTaskDepth && IDERR(tspRetAsync)!=IDERR_PENDING);

    if (!m_uTaskDepth)
    {
        BOOL fEndUnload = FALSE;
        //
        // The caller to StartRootTask specified this pointer. StartRootTask
        // would have set *m_pfTaskPending to TRUE because the task was
        // being completed asynchronously. We set it to false here because
        // we've just completed the task.
        //
        ASSERT(m_pfTaskPending && *m_pfTaskPending);
        *m_pfTaskPending = FALSE;

        //
        // If a task completion event has been specified, set it here.
        //
        if (m_hRootTaskCompletionEvent)
        {
            SetEvent(m_hRootTaskCompletionEvent);
            m_hRootTaskCompletionEvent=NULL;
        }
        m_pfTaskPending  = NULL;

        //
        // The root task completed. We now look around to see if there is
        // another task to be done.
        //
        // Note: mfn_HandleRootTaskCompleted will call StartRootTask if
        // it decides to start another task -- it will typically keep
        // starting new root tasks for as long as they are available until
        // one of the StartRootTasks returns PENDING...
        //
        mfn_HandleRootTaskCompletedAsync(&fEndUnload, psl);

        if (fEndUnload)
        {
            //
            // This means it's time to signal the end of a deferred unload
            // of the entire TSP object. The unload was initiated
            // by Tsp::Unload -- refer to that function for details...
            //
            goto end_unload;
        }

    }

end:

	m_sync.LeaveCrit(FL_LOC);
	FL_LOG_EXIT(psl, 0);
    return;

end_unload:

    //
    // We've been tasked to signal the end of a deferred unload.....
    //
    if (m_StaticInfo.hSessionMD)
    {
        ASSERT(m_StaticInfo.pMD);
        m_StaticInfo.pMD->EndSession(m_StaticInfo.hSessionMD);
        m_StaticInfo.hSessionMD=0;
        m_StaticInfo.pMD=NULL;
    }

    // After EndUnload returns, we should assume that the this pointer
    // is no longer valid, which is why we reave the critical section
    // first...
	m_sync.LeaveCrit(0);

    //OutputDebugString(
    //        TEXT("CTspDev::AsyncCompleteTask: going to EndUnload\r\n")
    //        );
    m_sync.EndUnload();
	FL_LOG_EXIT(psl, 0);

}

//
// The following TASK does nothing and simply completes in the APC thread's
// context. This is called by other tasks if they want to be sure to
// do something in an APC thread's context.
//
TSPRETURN
CTspDev::mfn_TH_UtilNOOP(
					HTSPTASK htspTask,
                    TASKCONTEXT *pContext,
					DWORD dwMsg,
					ULONG_PTR dwParam1,
					ULONG_PTR dwParam2,
					CStackLog *psl
					)
{
	FL_DECLARE_FUNC(0x80cce3c7, "CTspDev::mfn_TH_UtilNOOP")
	FL_LOG_ENTRY(psl);
	TSPRETURN tspRet=FL_GEN_RETVAL(IDERR_PENDING);
    DWORD dwRet = 0;

    switch(dwMsg)
    {
    case MSG_START:
        goto start;

	case MSG_TASK_COMPLETE:
        tspRet = (TSPRETURN) dwParam2;
        goto end;

    case MSG_DUMPSTATE:
        tspRet = 0;
        goto end;

    default:
        FL_SET_RFR(0x29cce300, "Unknown Msg");
        tspRet=FL_GEN_RETVAL(IDERR_CORRUPT_STATE);
        goto end;

    }

    ASSERT(FALSE);

start:

    // We start off by complete ourselves asynchronously! This is a trick to 
    // make sure that what follows is in the APC thread's context.
    //
    CTspDev::AsyncCompleteTask(
                    htspTask,
                    0,
                    TRUE,
                    psl
                    );

    tspRet = IDERR_PENDING;
    THROW_PENDING_EXCEPTION();


end:

	FL_LOG_EXIT(psl, tspRet);
	return tspRet;

}


void
CTspDev::mfn_dump_task_state(
            CStackLog *psl
            )
{
	FL_DECLARE_FUNC(0xaf041de9, "TASK STATE:")
	FL_LOG_ENTRY(psl);

    SLPRINTF1(
        psl,
        "taskdepth=%lu",
        m_uTaskDepth
        );


    for (UINT u = 0; u<m_uTaskDepth; u++)
    {
	    DEVTASKINFO *pInfo = m_rgTaskStack + u;

        // Call the parent task's task handler.
        (this->**(pInfo->ppfnHandler))(
                            pInfo->hTask,
                            &(pInfo->TaskContext),
                            MSG_DUMPSTATE,
                            pInfo->dwCurrentSubtaskID,
                            0,
                            psl
                            );
    }
	FL_LOG_EXIT(psl, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\tsp\cdevphon.cpp ===
// 
// Copyright (c) 1996-1997 Microsoft Corporation.
//
//
// Component
//
//		Unimodem 5.0 TSP (Win32, user mode DLL)
//
// File
//
//		CDEVLINE.CPP
//		Implements line-related functionality  of class CTspDev
//
// History
//
//		01/24/1997  JosephJ Created
//
//
#include "tsppch.h"
#include <mmsystem.h>
#include "tspcomm.h"
#include "cmini.h"
#include "cdev.h"

FL_DECLARE_FILE(0x14dd4afb, "Phone-related functionality of class CTspDev")

LONG   
validate_phone_devs_and_modes(
                DWORD dwHookSwitchDevs,
                DWORD dwHookSwitchMode,
                BOOL fIsSpeaker,
                BOOL fIsHandset,
                BOOL fCanDoMicMute
                );

void
CTspDev::mfn_accept_tsp_call_for_HDRVPHONE(
	DWORD dwRoutingInfo,
	void *pvParams,
	LONG *plRet,
	CStackLog *psl
	)
{
	FL_DECLARE_FUNC(0x82499cab, "CTspDev::mfn_accept_tsp_call_for_HDRVPHONE")
	FL_LOG_ENTRY(psl);
    TSPRETURN tspRet=0; // Assume success
    LONG lRet = 0;
    PHONEINFO *pPhone = m_pPhone;

	ASSERT(pPhone);


	switch(ROUT_TASKID(dwRoutingInfo))
	{

	case TASKID_TSPI_phoneClose:
		{
			mfn_UnloadPhone(psl);
		}
		break;

	case TASKID_TSPI_phoneGetID:
		{
		    UINT idClass = 0;
			TASKPARAM_TSPI_phoneGetID *pParams = 
						(TASKPARAM_TSPI_phoneGetID *) pvParams;
			ASSERT(pParams->dwStructSize ==
				sizeof(TASKPARAM_TSPI_phoneGetID));
			ASSERT(pParams->dwTaskID == TASKID_TSPI_phoneGetID);
            LPCTSTR lpszDeviceClass = pParams->lpszDeviceClass;
            HANDLE hTargetProcess = pParams->hTargetProcess;
            LPVARSTRING lpDeviceID = pParams->lpDeviceID;
            DWORD cbMaxExtra =  0;
            DWORD dwDeviceClass =  parse_device_classes(
                                        lpszDeviceClass,
                                        FALSE
                                        );
		    DWORD dwSupportedDeviceClasses = parse_device_classes(
                                        m_StaticInfo.szzPhoneClassList,
                                        TRUE);
		    if (dwDeviceClass & ~dwSupportedDeviceClasses)
		    {
			    // This device doesn't support this device class...
			    lRet = PHONEERR_OPERATIONUNAVAIL;
			    break;
		    }

            // Do some rudimentary parameter validation...
            //
            lRet = 0;

            if (lpDeviceID->dwTotalSize < sizeof(VARSTRING))
            {
                lRet = PHONEERR_STRUCTURETOOSMALL;
		        FL_SET_RFR(0xd7fcf300, "Invalid params");
                goto end;
            }

            lpDeviceID->dwNeededSize    = sizeof(VARSTRING);
            lpDeviceID->dwStringOffset  = sizeof(VARSTRING);
            lpDeviceID->dwUsedSize      = sizeof(VARSTRING);
            lpDeviceID->dwStringSize    = 0;
            cbMaxExtra =  lpDeviceID->dwTotalSize - sizeof(VARSTRING);

            switch(dwDeviceClass)
            {
            case DEVCLASS_TAPI_LINE:
			    lRet = mfn_linephoneGetID_TAPI_LINE(
                                        lpDeviceID,
                                        hTargetProcess,
                                        cbMaxExtra,
                                        psl
                                        );
                break;

            case DEVCLASS_TAPI_PHONE:
                lRet = mfn_linephoneGetID_TAPI_PHONE(
                                lpDeviceID,
                                hTargetProcess,
                                cbMaxExtra,
                                psl
                                );
                break;


            case DEVCLASS_WAVE_IN:
                lRet = mfn_linephoneGetID_WAVE(
                                TRUE,   // <- fPhone
                                TRUE,   // <- fIn
                                lpDeviceID,
                                hTargetProcess,
                                cbMaxExtra,
                                psl
                                );
                break;

            case DEVCLASS_WAVE_OUT:
                lRet = mfn_linephoneGetID_WAVE(
                                TRUE,   // <- fPhone
                                FALSE,   // <- fIn
                                lpDeviceID,
                                hTargetProcess,
                                cbMaxExtra,
                                psl
                                );
                break;

            case DEVCLASS_UNKNOWN:
		        FL_SET_RFR(0x09091200, "Unknown device class");
                lRet = PHONEERR_INVALDEVICECLASS;
                break;

			default:
		        FL_SET_RFR(0xe967b300, "Unsupported device class");
	            lRet = PHONEERR_OPERATIONUNAVAIL;
			    break;
            }


            if (!lRet)
            {
                FL_ASSERT(psl, lpDeviceID->dwUsedSize<=lpDeviceID->dwTotalSize);
                FL_ASSERT(psl,
                     (lpDeviceID->dwStringOffset+lpDeviceID->dwStringSize)
                                                    <=lpDeviceID->dwTotalSize);
            }
		}
		break;

	case TASKID_TSPI_phoneSetStatusMessages:
		{
			TASKPARAM_TSPI_phoneSetStatusMessages *pParams = 
						(TASKPARAM_TSPI_phoneSetStatusMessages *) pvParams;
			ASSERT(pParams->dwStructSize ==
				sizeof(TASKPARAM_TSPI_phoneSetStatusMessages));
			ASSERT(pParams->dwTaskID == TASKID_TSPI_phoneSetStatusMessages);
            //
            //  we should record this settings and filter the
            //  notification based on this settings.
            //
            FL_SET_RFR(0x9cba1400, "phoneSetStatusMessages handled");
            lRet = 0;
        }
		break;

	case TASKID_TSPI_phoneGetStatus:
		{
			TASKPARAM_TSPI_phoneGetStatus *pParams = 
						(TASKPARAM_TSPI_phoneGetStatus *) pvParams;
			ASSERT(pParams->dwStructSize ==
				sizeof(TASKPARAM_TSPI_phoneGetStatus));
			ASSERT(pParams->dwTaskID == TASKID_TSPI_phoneGetStatus);
            LPPHONESTATUS   lpPhoneStatus = pParams->lpPhoneStatus;
        
            if (!m_pLLDev)
            {
                FL_SET_RFR(0x2cf25300, "Failing phoneGetStatus: NULL pLLDev");
                lRet = PHONEERR_OPERATIONFAILED;
                goto end;
            }
    
            //
            // 10/27/1997 JosephJ: following taken from unimodem/v phone.c
            //
            lpPhoneStatus->dwStatusFlags   = PHONESTATUSFLAGS_CONNECTED;
            lpPhoneStatus->dwRingMode = 0;
            lpPhoneStatus->dwRingVolume = 0;
            if(mfn_Handset())
            {

                lpPhoneStatus->dwHandsetHookSwitchMode =
                                         m_pLLDev->HandSet.dwMode;
            }
            else
            {
                lpPhoneStatus->dwHandsetHookSwitchMode = 0;
            }
            lpPhoneStatus->dwHandsetVolume = 0;
            lpPhoneStatus->dwHandsetGain = 0;
            if(mfn_IsSpeaker())
            {
                lpPhoneStatus->dwSpeakerHookSwitchMode
                                 = m_pLLDev->SpkrPhone.dwMode;
                lpPhoneStatus->dwSpeakerVolume
                                 = m_pLLDev->SpkrPhone.dwVolume;
                lpPhoneStatus->dwSpeakerGain
                                 = m_pLLDev->SpkrPhone.dwGain;
            }
            else
            {
                lpPhoneStatus->dwSpeakerHookSwitchMode = 0;
                lpPhoneStatus->dwSpeakerVolume = 0;
                lpPhoneStatus->dwSpeakerGain = 0;
            }
        
            lpPhoneStatus->dwHeadsetHookSwitchMode = 0;
            lpPhoneStatus->dwHeadsetVolume = 0;
            lpPhoneStatus->dwHeadsetGain = 0;
            lpPhoneStatus->dwDisplaySize = 0;
            lpPhoneStatus->dwDisplayOffset = 0;
            lpPhoneStatus->dwLampModesSize = 0;
            lpPhoneStatus->dwLampModesOffset = 0;
            lpPhoneStatus->dwDevSpecificSize = 0;
            lpPhoneStatus->dwDevSpecificOffset = 0;

            FL_SET_RFR(0xc03cc900, "phoneGetStatus handled");
            lRet = 0;
        }
		break;

	case TASKID_TSPI_phoneGetVolume:
		{
			TASKPARAM_TSPI_phoneGetVolume *pParams = 
						(TASKPARAM_TSPI_phoneGetVolume *) pvParams;
			ASSERT(pParams->dwStructSize ==
				sizeof(TASKPARAM_TSPI_phoneGetVolume));
			ASSERT(pParams->dwTaskID == TASKID_TSPI_phoneGetVolume);

            if (!m_pLLDev)
            {
                FL_SET_RFR(0x716f7e00, "Failing phoneGetStatus: NULL pLLDev");
                lRet = PHONEERR_OPERATIONFAILED;
                goto end;
            }

            lRet = validate_phone_devs_and_modes(
                        pParams->dwHookSwitchDev,
                        0,
                        mfn_IsSpeaker(),
                        mfn_Handset(),
                        mfn_IsMikeMute()
                        );


            if (!lRet)
            {
                ASSERT(pParams->dwHookSwitchDev == PHONEHOOKSWITCHDEV_SPEAKER);
                *pParams->lpdwVolume = m_pLLDev->SpkrPhone.dwVolume;
                lRet = 0;
            }
            else
            {
                *pParams->lpdwVolume = 0;
            }

            FL_SET_RFR(0x095e4b00, "phoneGetVolume handled");
        }
		break;

	case TASKID_TSPI_phoneGetHookSwitch:
		{
			TASKPARAM_TSPI_phoneGetHookSwitch *pParams = 
						(TASKPARAM_TSPI_phoneGetHookSwitch *) pvParams;
			ASSERT(pParams->dwStructSize ==
				sizeof(TASKPARAM_TSPI_phoneGetHookSwitch));
			ASSERT(pParams->dwTaskID == TASKID_TSPI_phoneGetHookSwitch);
            if (!m_pLLDev)
            {
                FL_SET_RFR(0x0fcc6500, "Failing phoneGetStatus: NULL pLLDev");
                lRet = PHONEERR_OPERATIONFAILED;
                goto end;
            }

            *pParams->lpdwHookSwitchDevs = 0;
            switch(m_pLLDev->HandSet.dwMode)
            {
            case PHONEHOOKSWITCHMODE_ONHOOK:
            case PHONEHOOKSWITCHMODE_UNKNOWN:
                break;
            case PHONEHOOKSWITCHMODE_MIC:
            case PHONEHOOKSWITCHMODE_SPEAKER:
            case PHONEHOOKSWITCHMODE_MICSPEAKER:
                *pParams->lpdwHookSwitchDevs |= PHONEHOOKSWITCHDEV_HANDSET;
                break;
            default: 
                break;
            }

            switch(m_pLLDev->SpkrPhone.dwMode)
            {
            case PHONEHOOKSWITCHMODE_ONHOOK:
            case PHONEHOOKSWITCHMODE_UNKNOWN:
                break;
            case PHONEHOOKSWITCHMODE_MIC:
            case PHONEHOOKSWITCHMODE_SPEAKER:
            case PHONEHOOKSWITCHMODE_MICSPEAKER:
                *pParams->lpdwHookSwitchDevs |= PHONEHOOKSWITCHDEV_SPEAKER;
                break;
            default: 
                break;
            }

            FL_SET_RFR(0x18978a00, "phoneGetHookSwitch handled");
            lRet = 0;
        }
		break;


	case TASKID_TSPI_phoneGetGain:
		{
			TASKPARAM_TSPI_phoneGetGain *pParams = 
						(TASKPARAM_TSPI_phoneGetGain *) pvParams;
			ASSERT(pParams->dwStructSize ==
				sizeof(TASKPARAM_TSPI_phoneGetGain));
			ASSERT(pParams->dwTaskID == TASKID_TSPI_phoneGetGain);
            if (!m_pLLDev)
            {
                FL_SET_RFR(0x5f068200, "Failing phoneGetStatus: NULL pLLDev");
                lRet = PHONEERR_OPERATIONFAILED;
                goto end;
            }

            lRet = validate_phone_devs_and_modes(
                        pParams->dwHookSwitchDev,
                        0,
                        mfn_IsSpeaker(),
                        mfn_Handset(),
                        mfn_IsMikeMute()
                        );


            if (!lRet)
            {
                ASSERT(pParams->dwHookSwitchDev == PHONEHOOKSWITCHDEV_SPEAKER);
                *pParams->lpdwGain = m_pLLDev->SpkrPhone.dwGain;
                lRet = 0;
            }
            else
            {
                *pParams->lpdwGain = 0;
            }

            FL_SET_RFR(0xf8231700, "phoneGetGain handled");
        }
		break;

	case TASKID_TSPI_phoneSetVolume:
		{
			TASKPARAM_TSPI_phoneSetVolume *pParams = 
						(TASKPARAM_TSPI_phoneSetVolume *) pvParams;
			ASSERT(pParams->dwStructSize ==
				sizeof(TASKPARAM_TSPI_phoneSetVolume));
			ASSERT(pParams->dwTaskID == TASKID_TSPI_phoneSetVolume);

            lRet = mfn_phoneSetVolume(
                        pParams->dwRequestID,
                        pParams->hdPhone,
                        pParams->dwHookSwitchDev,
                        pParams->dwVolume,
                        psl
                        );

            FL_SET_RFR(0x5d8bff00, "phoneSetVolume handled");
        }
		break;
    
	case TASKID_TSPI_phoneSetHookSwitch:
		{
			TASKPARAM_TSPI_phoneSetHookSwitch *pParams = 
						(TASKPARAM_TSPI_phoneSetHookSwitch *) pvParams;
			ASSERT(pParams->dwStructSize ==
				sizeof(TASKPARAM_TSPI_phoneSetHookSwitch));
			ASSERT(pParams->dwTaskID == TASKID_TSPI_phoneSetHookSwitch);

            lRet = mfn_phoneSetHookSwitch(
                        pParams->dwRequestID,
                        pParams->hdPhone,
                        pParams->dwHookSwitchDevs,
                        pParams->dwHookSwitchMode,
                        psl
                        );


            FL_SET_RFR(0xa79dd500, "phoneSetHookSwitch handled");
        }
		break;

	case TASKID_TSPI_phoneSetGain:
		{
			TASKPARAM_TSPI_phoneSetGain *pParams = 
						(TASKPARAM_TSPI_phoneSetGain *) pvParams;
			ASSERT(pParams->dwStructSize ==
				sizeof(TASKPARAM_TSPI_phoneSetGain));
			ASSERT(pParams->dwTaskID == TASKID_TSPI_phoneSetGain);

            lRet = mfn_phoneSetGain(
                        pParams->dwRequestID,
                        pParams->hdPhone,
                        pParams->dwHookSwitchDev,
                        pParams->dwGain,
                        psl
                        );


            FL_SET_RFR(0xc4aec300, "phoneSetGain handled");
        }
		break;


	default:

		FL_SET_RFR(0x2e6f8400, "*** UNHANDLED HDRVPHONE CALL ****");
        // we  return 0 and set lRet to
        // PHONEERR_OPERATIONUNAVAIL
	    lRet = PHONEERR_OPERATIONUNAVAIL;
		break;

	}

end:

    if (tspRet && !lRet)
    {
        lRet = PHONEERR_OPERATIONFAILED;
    }

    *plRet = lRet;

    SLPRINTF1(psl, "lRet = 0x%08lx", lRet);

	FL_LOG_EXIT(psl, tspRet);
	return;
}


TSPRETURN
CTspDev::mfn_LoadPhone(
    TASKPARAM_TSPI_phoneOpen  *pParams,
    CStackLog *psl
    )
{
	FL_DECLARE_FUNC(0xdcef2b73, "CTspDev::mfn_LoadPhone")
    TSPRETURN tspRet=0;
	FL_LOG_ENTRY(psl);


    if (!m_pPhone)
    {
        // Note m_Phone should be all zeros when it is in the unloaded state.
        // If it is not, it is an assertfail condition. We keep things clean
        // this way.
        //
        FL_ASSERT(
            psl,
            validate_DWORD_aligned_zero_buffer(
                    &(m_Phone),
                    sizeof (m_Phone)));

        m_Phone.lpfnEventProc = pParams->lpfnEventProc;
	    m_Phone.htPhone = pParams->htPhone;
	    m_Phone.hdPhone =  *(pParams->lphdPhone);
        m_pPhone = &m_Phone;


        //
        // Open the modem device.
        // mfn_OpenLLDev keeps a ref count so ok to call it if already loaded.
        // The inverse of this function,  CTspDev::mfn_UnloadPhone, closes
        // the modem  (decrements the ref count and closes device if
        // refcount is zero and there is no pending activity.
        //
        tspRet =  mfn_OpenLLDev(
                        LLDEVINFO::fRES_AIPC,
                        0,              // monitor flags (unused)
                        FALSE,          // fStartSubTask
                        NULL,
                        0,
                        psl
                        );
    
        if (!tspRet  || IDERR(tspRet)==IDERR_PENDING)
        {
            m_Phone.SetStateBits(PHONEINFO::fPHONE_OPENED_LLDEV);

            // Treat pending open as success...
            tspRet = 0;
        }
        else
        {
            ZeroMemory(m_pPhone, sizeof(*m_pPhone));
            m_pPhone = NULL;
        }
        
    }
    else
    {
        FL_SET_RFR(0xcce52400, "Device already loaded (m_pPhone!=NULL)!");
        tspRet = FL_GEN_RETVAL(IDERR_WRONGSTATE);
    }

	FL_LOG_EXIT(psl, tspRet);

    return tspRet;
}


void
CTspDev::mfn_UnloadPhone(CStackLog *psl)
{
	FL_DECLARE_FUNC(0x54328a21, "UnloadPhone")
    PHONEINFO *pPhone =  m_pPhone;

    if (!pPhone) goto end;

    ASSERT(pPhone == &m_Phone);

    if (pPhone->fPhoneTaskPending)
    {
        //
        // If there is a call-related task pending  we wait for it to complete.
        //
        //
        // Obviously if there is a phone task pending, there must be a
        // task pending. Furthermore, the mfn_UnloadPhone (that's us),
        // is the ONLY entity which will set a completion event for a
        // phone-related root task, so m_hRootTaskCompletionEvent had better
        // be NULL!
        //
        ASSERT(m_uTaskDepth);
        ASSERT(!m_hRootTaskCompletionEvent);

    
        HANDLE hEvent =  CreateEvent(NULL,TRUE,FALSE,NULL);
        m_hRootTaskCompletionEvent = hEvent;

        m_sync.LeaveCrit(0);
        SLPRINTF0(psl, "Waiting for completion event");
        FL_SERIALIZE(psl, "Waiting for completion event");
        WaitForSingleObject(hEvent, INFINITE);
        FL_SERIALIZE(psl, "Done waiting for completion event");
        // SLPRINTF0(psl, "Done waiting for completion event");
        m_sync.EnterCrit(0);

        //
        // Although it may be tempting to do so, we should not set
        // m_hRootTaskCompletionEvent to NULL here, because it's possible
        // for some other thread to have set this event in-between
        // the time the root task completes and we enter the crit sect above.
        // So instead the tasking system NULLs the above handle after setting
        // it (see CTspDev::AsyncCompleteTask, just after the call to SetEvent).
        //
        CloseHandle(hEvent);
    }

    if (pPhone->IsOpenedLLDev())
    {
        mfn_CloseLLDev(
            	LLDEVINFO::fRES_AIPC,
                FALSE,
                NULL,
                0,
                psl
                );
        pPhone->ClearStateBits(PHONEINFO::fPHONE_OPENED_LLDEV);
    }

    ASSERT(!pPhone->IsPhoneTaskPending());

    ZeroMemory(&m_Phone, sizeof(m_Phone));
    m_pPhone=NULL;

end:

    return;

}


LONG
CTspDev::mfn_phoneSetVolume(
    DRV_REQUESTID  dwRequestID,
    HDRVPHONE      hdPhone,
    DWORD          dwHookSwitchDev,
    DWORD          dwVolume,
    CStackLog      *psl)
{
    LONG lRet = PHONEERR_OPERATIONFAILED;
    PHONEINFO *pPhone = m_pPhone;
    ASSERT(pPhone);
    TSPRETURN tspRet= 0;

    lRet = validate_phone_devs_and_modes(
                dwHookSwitchDev,
                0,
                mfn_IsSpeaker(),
                mfn_Handset(),
                mfn_IsMikeMute()
                );

    if (lRet)
    {
        goto end;
    }

    lRet = PHONEERR_OPERATIONFAILED;

    if (!m_pLLDev)
    {
        lRet = PHONEERR_OPERATIONFAILED;
        goto end;
    }

    dwVolume = dwVolume & 0xffff; // ??? from unimodem/v

    switch (m_pLLDev->SpkrPhone.dwMode)
    {

    case PHONEHOOKSWITCHMODE_ONHOOK:
        //
        //  On hook, don't do anything
        //
        mfn_TSPICompletionProc(dwRequestID, 0, psl);
        m_pLLDev->SpkrPhone.dwVolume = dwVolume;
        lRet = dwRequestID;
        goto end;

    case PHONEHOOKSWITCHMODE_SPEAKER:
        break;

    case PHONEHOOKSWITCHMODE_MICSPEAKER:
        break;

    default:

        ASSERT(FALSE);
        goto end;

    }


    if (!m_pLine || !m_pLine->pCall || !m_pLine->pCall->IsConnectedVoiceCall())
    {
        //
        //  Not a connected voice call, don't actually do anything...
        //
        m_pLLDev->SpkrPhone.dwVolume = dwVolume;
        mfn_TSPICompletionProc(dwRequestID, 0, psl);
        lRet =  dwRequestID;
        goto end;
    }

#if (OBSOLETE)
    m_pPhone->dwPendingSpeakerVolume = dwVolume;
    m_pPhone->dwPendingSpeakerGain = m_pLLDev->SpkrPhone.dwGain;
    
    tspRet = mfn_StartRootTask(
                      &CTspDev::s_pfn_TH_PhoneAsyncTSPICall,
                      &pPhone->fPhoneTaskPending,
                      dwRequestID,
                      (DWORD) &CTspDev::s_pfn_TH_LLDevUmSetSpeakerPhoneVolGain,
                      psl
                      );
#else // !OBSOLETE

    {

        HOOKDEVSTATE NewState = m_pLLDev->SpkrPhone; // structure copy.
        NewState.dwVolume = dwVolume;
    
        tspRet = mfn_StartRootTask(
                          &CTspDev::s_pfn_TH_PhoneSetSpeakerPhoneState,
                          &pPhone->fPhoneTaskPending,
                          (ULONG_PTR) &NewState,
                          dwRequestID,
                          psl
                          );
    
    }
#endif // !OBSOLETE

    if (!tspRet || (IDERR(tspRet)==IDERR_PENDING))
    {
           tspRet = 0;

          // One either synchronous success of pending, we return the
          // request ID to TAPI. In the synchronous success case
          // the task we started above will already have notified
          // completion via the TAPI callback function.
          //
          lRet = dwRequestID;
    }

    // TODO: deal with the case that there is already a task
    // active (IDERR_TASKPENDING)

end:
    return lRet;

}


LONG
CTspDev::mfn_phoneSetHookSwitch(
    DRV_REQUESTID  dwRequestID,
    HDRVPHONE      hdPhone,
    DWORD          dwHookSwitchDevs,
    DWORD          dwHookSwitchMode,
    CStackLog      *psl
    )
{
    LONG lRet = PHONEERR_OPERATIONFAILED;
    PHONEINFO *pPhone = m_pPhone;
    ASSERT(pPhone);
    TSPRETURN tspRet = 0;

    lRet = validate_phone_devs_and_modes(
                dwHookSwitchDevs,
                dwHookSwitchMode,
                mfn_IsSpeaker(),
                mfn_Handset(),
                mfn_IsMikeMute()
                );

    if (lRet)
    {
        goto end;
    }

    lRet = PHONEERR_OPERATIONFAILED;

    if (!m_pLLDev)
    {
        goto end;
    }


    //TODO: MuteSpeakerMixer(pLineDev, PHONEHOOKSWITCHMODE_ONHOOK ==
    //        pLineDev->Voice.dwSpeakerMicHookState);

    if (!m_pLine || !m_pLine->pCall || !m_pLine->pCall->IsConnectedVoiceCall())
    {
        lRet = PHONEERR_INVALPHONESTATE;
    }
    else
    {

#if (OBSOLETE)
        // hack...
        m_pPhone->dwPendingSpeakerMode =  dwHookSwitchMode;
        
        tspRet = mfn_StartRootTask(
                          &CTspDev::s_pfn_TH_PhoneAsyncTSPICall,
                          &pPhone->fPhoneTaskPending,
                          dwRequestID,
                          (DWORD) &CTspDev::s_pfn_TH_LLDevUmSetSpeakerPhoneMode,
                          psl
                          );

#else // !OBSOLETE

    {

        HOOKDEVSTATE NewState = m_pLLDev->SpkrPhone; // structure copy.
        NewState.dwMode = dwHookSwitchMode;
    
        tspRet = mfn_StartRootTask(
                          &CTspDev::s_pfn_TH_PhoneSetSpeakerPhoneState,
                          &pPhone->fPhoneTaskPending,
                          (ULONG_PTR) &NewState,
                          dwRequestID,
                          psl
                          );
    
    }

#endif // !OBSOLETE

    
        if (!tspRet || (IDERR(tspRet)==IDERR_PENDING))
        {
               tspRet = 0;
    
              // One either synchronous success of pending, we return the
              // request ID to TAPI. In the synchronous success case
              // the task we started above will already have notified
              // completion via the TAPI callback function.
              //
              lRet = dwRequestID;
        }
    
        // TODO: deal with the case that there is already a task
        // active (IDERR_TASKPENDING)
    }


end:

    return lRet;
}


LONG
CTspDev::mfn_phoneSetGain(
    DRV_REQUESTID  dwRequestID,
    HDRVPHONE      hdPhone,
    DWORD          dwHookSwitchDev,
    DWORD          dwGain,
    CStackLog      *psl
    )
{
    BYTE    SpeakerMode;
    LONG lRet = PHONEERR_OPERATIONFAILED;
    PHONEINFO *pPhone = m_pPhone;
    ASSERT(pPhone);
    TSPRETURN tspRet= 0;

    lRet = validate_phone_devs_and_modes(
                dwHookSwitchDev,
                0,
                mfn_IsSpeaker(),
                mfn_Handset(),
                mfn_IsMikeMute()
                );

    if (lRet)
    {
        goto end;
    }

    lRet = PHONEERR_OPERATIONFAILED;

    if (!m_pLLDev)
    {
        lRet = PHONEERR_OPERATIONFAILED;
        goto end;
    }


    dwGain = dwGain & 0xffff; // ??? from unimodem/v

    if (!m_pLine || !m_pLine->pCall || !m_pLine->pCall->IsConnectedVoiceCall())
    {
        //
        // update value, but do nothing else, because there
        // is not a connected voice call at this time...
        //
        m_pLLDev->SpkrPhone.dwGain = dwGain;
        mfn_TSPICompletionProc(dwRequestID, 0, psl);
        lRet = dwRequestID;
        goto end;
    }

    switch (m_pLLDev->SpkrPhone.dwMode)
    {

    case PHONEHOOKSWITCHMODE_ONHOOK:
        //
        //  On hook, don't do anything
        //
        mfn_TSPICompletionProc(dwRequestID, 0, psl);
        m_pLLDev->SpkrPhone.dwGain = dwGain;
        lRet = dwRequestID;
        goto end;


    case PHONEHOOKSWITCHMODE_SPEAKER:
    case PHONEHOOKSWITCHMODE_MICSPEAKER:
        break;

    default:

        lRet =  PHONEERR_INVALHOOKSWITCHMODE;
        goto end;
    }

#if (OBSOLETE)

    m_pPhone->dwPendingSpeakerVolume = m_pLLDev->SpkrPhone.dwVolume;
    m_pPhone->dwPendingSpeakerGain = dwGain;
    
    tspRet = mfn_StartRootTask(
                      &CTspDev::s_pfn_TH_PhoneAsyncTSPICall,
                      &pPhone->fPhoneTaskPending,
                      dwRequestID,
                      (DWORD) &CTspDev::s_pfn_TH_LLDevUmSetSpeakerPhoneVolGain,
                      psl
                      );
#else // !OBSOLETE

    {

        HOOKDEVSTATE NewState = m_pLLDev->SpkrPhone; // structure copy.
        NewState.dwGain = dwGain;
    
        tspRet = mfn_StartRootTask(
                          &CTspDev::s_pfn_TH_PhoneSetSpeakerPhoneState,
                          &pPhone->fPhoneTaskPending,
                          (ULONG_PTR) &NewState,
                          dwRequestID,
                          psl
                          );
    
    }
#endif // !OBSOLETE

    if (!tspRet || (IDERR(tspRet)==IDERR_PENDING))
    {
           tspRet = 0;

          // One either synchronous success of pending, we return the
          // request ID to TAPI. In the synchronous success case
          // the task we started above will already have notified
          // completion via the TAPI callback function.
          //
          lRet = dwRequestID;
    }

    // TODO: deal with the case that there is already a task
    // active (IDERR_TASKPENDING)

end:

    return lRet;
}


TSPRETURN
CTspDev::mfn_TryStartPhoneTask(CStackLog *psl)
{
    // NOTE: MUST return IDERR_SAMESTATE if there are no tasks to run.

    ASSERT(m_pPhone);
    PHONEINFO *pPhone = m_pPhone;
    TSPRETURN tspRet = IDERR_SAMESTATE;
    
    //
    // do stuff...
    //
    // be careful about the return value...
    //

    //
    // Were we to implement deferring with the various Set_*, where's
    // where we would implement it...
    //

    return IDERR_SAMESTATE;
}

TSPRETURN
CTspDev::mfn_TH_PhoneAsyncTSPICall(
					HTSPTASK htspTask,
                    TASKCONTEXT *pContext,
					DWORD dwMsg,
					ULONG_PTR dwParam1,
					ULONG_PTR dwParam2,
					CStackLog *psl
					)
//
//  START_MSG Params:
//      dwParam1: request ID for the async phone-related TAPI call.
//      dwParam2: handler function for the call.
//
{
	FL_DECLARE_FUNC(0x8bc3ba08, "CTspDev::mfn_TH_PhoneAsyncTSPICall")
	FL_LOG_ENTRY(psl);
	TSPRETURN tspRet=FL_GEN_RETVAL(IDERR_INVALID_ERR);

    enum {
        ASYNCTSPI_CALL_COMPLETE
    };

    switch(dwMsg)
    {
    default:
        FL_SET_RFR(0x1dfbae00, "Unknown Msg");
        tspRet=FL_GEN_RETVAL(IDERR_CORRUPT_STATE);
        goto end;

    case MSG_START:
        goto start;

	case MSG_SUBTASK_COMPLETE:
        tspRet = dwParam2;
        switch(dwParam1) // Param1 is Subtask ID
        {
        case ASYNCTSPI_CALL_COMPLETE:
             goto call_complete;

        default:
	        FL_SET_RFR(0xe5d2e000, "invalid subtask");
            FL_GEN_RETVAL(IDERR_CORRUPT_STATE);
            goto end;
        }
        break;

    case MSG_DUMPSTATE:
        tspRet = 0;
        goto end_end;
    }

    ASSERT(FALSE);


start:

    {
        // Param1 is the request ID for the async phone-related TAPI call.
        // Param2 is the handler function for the call.
        // 
        PFN_CTspDev_TASK_HANDLER *ppfnHandler =
                                     (PFN_CTspDev_TASK_HANDLER*) dwParam2;
    
        // Note m_Phone->CurTSPIPhoneCallInfo should be all zeros on entry.
        // If it is not, it is an assertfail condition. We keep things clean
        // this way.
        //
        FL_ASSERT(
            psl,
            validate_DWORD_aligned_zero_buffer(
                    &(m_pPhone->CurTSPIPhoneCallInfo),
                    sizeof (m_pPhone->CurTSPIPhoneCallInfo)));

    	m_pPhone->CurTSPIPhoneCallInfo.dwRequestID = (DWORD)dwParam1;
    	m_pPhone->CurTSPIPhoneCallInfo.lResult = 0;

        tspRet = mfn_StartSubTask (
                            htspTask,
                            ppfnHandler,
                            ASYNCTSPI_CALL_COMPLETE,
                            0,
                            0,
                            psl
                            );
    }

call_complete:


    if (IDERR(tspRet)!=IDERR_PENDING)
    {
        // The task is complete ...


        // tspRet==0 indicates successful execution of the tspi call.
        //
        // tspRet!=0 indicates some problem executing the tspi call.
        // The TAPI LONG result is saved in CurTSPIPhoneCallInfo.dwRequestID;

        DWORD dwRequestID = m_pPhone->CurTSPIPhoneCallInfo.dwRequestID;
        LONG lRet = 0;
        if (tspRet)
        {
            lRet =  m_pPhone->CurTSPIPhoneCallInfo.lResult;
            if (!lRet)
            {
           FL_SET_RFR(0x90228d00,"tspRet!=0, but lCurrentRequestResult==0");
               lRet = PHONEERR_OPERATIONFAILED;
            }
        }
        else
        {
            FL_ASSERT(psl, !m_pPhone->CurTSPIPhoneCallInfo.lResult);
        }
        // m_StaticInfo.pfnTAPICompletionProc(dwRequestID, lRet);
        mfn_TSPICompletionProc(dwRequestID, lRet, psl);

        // Note, we assert that this structure is zero on starting the async
        // tspi task -- see start: above.
        //
        ZeroMemory(&(m_pPhone->CurTSPIPhoneCallInfo),
                                             sizeof(m_pPhone->CurTSPIPhoneCallInfo));
    }

end:
end_end:

	FL_LOG_EXIT(psl, tspRet);
	return tspRet;

}


TSPRETURN
CTspDev::mfn_TH_PhoneSetSpeakerPhoneState(
					HTSPTASK htspTask,
                    TASKCONTEXT *pContext,
					DWORD dwMsg,
					ULONG_PTR dwParam1,
					ULONG_PTR dwParam2,
					CStackLog *psl
					)
//
//  START_MSG Params:
//      dwParam1:  *HOOKDEVSTATE of new params...
//      dwParam2: request ID for the async phone-related TAPI call.
//
{
	FL_DECLARE_FUNC(0x71046de2, "CTspDev::mfn_TH_PhoneSetSpeakerPhoneState")
	FL_LOG_ENTRY(psl);
	TSPRETURN tspRet=IDERR_CORRUPT_STATE;

    enum {
        LLDEV_OPERATION_COMPLETE
    };

    //
    // Local context 
    //
    LONG *plRequestID = (LONG*) &(pContext->dw0);

    switch(dwMsg)
    {
    default:
        FL_SET_RFR(0x29e80d00, "Unknown Msg");
        goto end;

    case MSG_START:
        goto start;

	case MSG_SUBTASK_COMPLETE:
        tspRet = dwParam2;
        switch(dwParam1) // Param1 is Subtask ID
        {
        case LLDEV_OPERATION_COMPLETE:
             goto lldev_operation_complete;

        default:
	        FL_SET_RFR(0xc8296a00, "invalid subtask");
            goto end;
        }
        break;

    case MSG_DUMPSTATE:
        tspRet = 0;
        goto end;
    }

    ASSERT(FALSE);


start:

    // save context ....
    *plRequestID = (LONG) dwParam2;

    tspRet = mfn_StartSubTask (
                        htspTask,
                        &CTspDev::s_pfn_TH_LLDevUmSetSpeakerPhoneState,
                        LLDEV_OPERATION_COMPLETE,
                        dwParam1, // New hookdevstate...
                        0,
                        psl
                        );


lldev_operation_complete:


    if (IDERR(tspRet)!=IDERR_PENDING)
    {
        // The task is complete ...
        LONG lRet = 0;

        if (tspRet)
        {
            lRet = PHONEERR_OPERATIONFAILED;
            tspRet = 0;
        }

        mfn_TSPICompletionProc(*plRequestID, lRet, psl);
    }

end:

	FL_LOG_EXIT(psl, tspRet);
	return tspRet;

}


void
CTspDev::mfn_ProcessHandsetChange(
    BOOL fOffHook,
    CStackLog *psl
    )
{
    DWORD dwMode = (fOffHook)
                     ? PHONEHOOKSWITCHMODE_MICSPEAKER
                     : PHONEHOOKSWITCHMODE_ONHOOK;

    if (m_pLLDev)
    {
        m_pLLDev->HandSet.dwMode = dwMode;

        if (m_pPhone && !m_pPhone->IsAborting())
        {

            mfn_PhoneEventProc(
                        PHONE_STATE,
                        PHONESTATE_HANDSETHOOKSWITCH,
                        dwMode,
                        NULL,
                        psl
                        );
        }
    }
}

LONG   
validate_phone_devs_and_modes(
                DWORD dwHookSwitchDevs,
                DWORD dwHookSwitchMode,
                BOOL fIsSpeaker,
                BOOL fIsHandset,
                BOOL fCanDoMicMute
                )
{
    //
    // Validate hookswitch devs
    //

    if (dwHookSwitchDevs
        & ~( PHONEHOOKSWITCHDEV_SPEAKER
            |PHONEHOOKSWITCHDEV_HEADSET
            |PHONEHOOKSWITCHDEV_HANDSET))
    {
        return PHONEERR_INVALHOOKSWITCHDEV;
    }

    //
    // We support only changing hookswitchstate/vol/gain on
    // the speakerphone...
    //
    //
    if (!fIsSpeaker || dwHookSwitchDevs!=PHONEHOOKSWITCHDEV_SPEAKER)
    {
        return PHONEERR_OPERATIONUNAVAIL;
    }

#if 0
    if (dwHookSwitchDevs &  PHONEHOOKSWITCHDEV_HEADSET)
    {
        return PHONEERR_OPERATIONUNAVAIL;
    }

    if (!fIsSpeaker && (dwHookSwitchDevs&PHONEHOOKSWITCHDEV_SPEAKER))
    {
        return PHONEERR_OPERATIONUNAVAIL;
    }

    if (!fIsHandset && (dwHookSwitchDevs&PHONEHOOKSWITCHDEV_HANDSET))
    {
        return PHONEERR_OPERATIONUNAVAIL;
    }
#endif // 0

    //
    // Validate hookswitch mode
    //
    switch(dwHookSwitchMode)
    {
    case 0:         // don't check...
        break;

    case PHONEHOOKSWITCHMODE_MIC:
        return PHONEERR_OPERATIONUNAVAIL;

    case PHONEHOOKSWITCHMODE_MICSPEAKER:
        break;

    case PHONEHOOKSWITCHMODE_SPEAKER:
        if (!fCanDoMicMute)
        {
            return PHONEERR_OPERATIONUNAVAIL;
        }                
        break;

    case PHONEHOOKSWITCHMODE_ONHOOK:
        break;

    default:
        return PHONEERR_INVALHOOKSWITCHMODE;

    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\tsp\cdevcall.cpp ===
//
// Copyright (c) 1996-1997 Microsoft Corporation.
//
//
// Component
//
//		Unimodem 5.0 TSP (Win32, user mode DLL)
//
// File
//
//		CDEVCALL.CPP
//		Implements Call-related functionality of class CTspDev
//
// History
//
//		01/24/1997  JosephJ Created (moved over stuff from CTspDev)
//
//
// <@t call>
//
#include "tsppch.h"
#include <devioctl.h>
#include <objbase.h>
#include <ntddser.h>
#include "tspcomm.h"

#include "cmini.h"
#include "cdev.h"
#include "globals.h"
#include "resource.h"
FL_DECLARE_FILE(0xe135f7c4, "Call-related functionality of class CTspDev")

const char szSEMICOLON[] = ";";

#define NEW_CALLSTATE(_X,_S,_M,_psl)\
                    {\
                        CALLINFO *pCall = m_pLine->pCall; \
                        pCall->dwCallState = (_S); \
                        pCall->dwCallStateMode = (_M); \
                        GetSystemTime (&pCall->stStateChange); \
                             mfn_LineEventProc( \
                             pCall->htCall, \
                             LINE_CALLSTATE, \
                             (_S), (_M), \
                             pCall->dwCurMediaModes, \
                             _psl\
                             );\
                    }


#define TOUT_SEC_RING_SEPARATION            12   // 12 seconds between rings
#define TOUT_100NSEC_TO_SEC_RELATIVE -10000000 // 1s = 10000000ns; -1 because we
                                       // need relative time (see description
                                       // of SetWaitableTimer).


void fill_caller_id(LPLINECALLINFO lpCallInfo, CALLERIDINFO *pCIDInfo);

TSPRETURN
LaunchModemLight (
        LPTSTR szModemName,
        HANDLE hModem,
        LPHANDLE lphLight,
        CStackLog *psl
        );

void
CTspDev::mfn_accept_tsp_call_for_HDRVCALL(
	DWORD dwRoutingInfo,
	void *pvParams,
	LONG *plRet,
	CStackLog *psl
	)
{
	FL_DECLARE_FUNC(0x5691bd34, "CTspDev::mfn_accept_tsp_call_for_HDRVCALL")
	FL_LOG_ENTRY(psl);
    TSPRETURN tspRet=0;
    LONG lRet = 0;
    LINEINFO *pLine = m_pLine;
	ASSERT(pLine && pLine->pCall);
    CALLINFO *pCall = pLine->pCall;


	switch(ROUT_TASKID(dwRoutingInfo))
	{

        case TASKID_TSPI_lineDial:
            {
                TASKPARAM_TSPI_lineDial *pParams = (TASKPARAM_TSPI_lineDial *)pvParams;
                PFN_CTspDev_TASK_HANDLER *ppfnHandler = NULL;
                ASSERT(pParams->dwStructSize == sizeof(TASKPARAM_TSPI_lineDial));
                ASSERT(pParams->dwTaskID==TASKID_TSPI_lineDial);
		BOOL bTone;

		


                if (!pCall)
                {
                    FL_SET_RFR(0x4e74c600,"No call exists");
                    lRet = LINEERR_CALLUNAVAIL;
                    goto end;
                }

		// Put new phone number in
		//
		//

		pCall->szAddress[0] = '\0';

		bTone = (pCall->dwDialOptions & MDM_TONE_DIAL) ? TRUE : FALSE;

		lRet = mfn_ConstructDialableString(
				pParams->lpszDestAddress,
				pCall->szAddress,
				MAX_ADDRESS_LENGTH,
				&bTone);

		if (lRet)
		{
			goto end;
		}

                ppfnHandler = (pCall->IsPassthroughCall())
                    ? &(CTspDev::s_pfn_TH_CallMakePassthroughCall)
                    : &(CTspDev::s_pfn_TH_CallMakeCall2);

                tspRet = mfn_StartRootTask(
                        ppfnHandler,
                        &pCall->fCallTaskPending,
                        pParams->dwRequestID,
                        0,
                        psl);

                if (!tspRet || (IDERR(tspRet) == IDERR_PENDING))
                {
                    // One either synchronous success of pending, we return the
                    // request ID to TAPI. In the synchronous success case
                    // the task we started above will already have notified
                    // completion via the TAPI callback function.

                    tspRet = 0;
                    lRet = pParams->dwRequestID;
                } else if (IDERR(tspRet) == IDERR_TASKPENDING)
                {
                    // Some other task is taking place
                    // we shall defer this call

                    pCall->SetDeferredTaskBits(CALLINFO::fDEFERRED_TSPI_LINEMAKECALL);
                    pCall->dwDeferredMakeCallRequestID = pParams->dwRequestID;
                    tspRet = 0;
                    lRet = pParams->dwRequestID;
                }

                FL_SET_RFR(0x9680a600,"lineDial handled successfully");

            }

            break;

	case TASKID_TSPI_lineGetCallAddressID:
		{
			TASKPARAM_TSPI_lineGetCallAddressID *pParams =
					(TASKPARAM_TSPI_lineGetCallAddressID *) pvParams;
			ASSERT(pParams->dwStructSize ==
				sizeof(TASKPARAM_TSPI_lineGetCallAddressID));
			ASSERT(pParams->dwTaskID==TASKID_TSPI_lineGetCallAddressID);
		    FL_SET_RFR(0x4f356100, "lineGetCallAddressID handled successfully");

            // We support only one address ID....
			*(pParams->lpdwAddressID) = 0;
		}
		break;

	case TASKID_TSPI_lineDrop:
        {
			TASKPARAM_TSPI_lineDrop *pParams =
					(TASKPARAM_TSPI_lineDrop *) pvParams;
			ASSERT(pParams->dwStructSize ==
				sizeof(TASKPARAM_TSPI_lineDrop));
			ASSERT(pParams->dwTaskID==TASKID_TSPI_lineDrop);

            //
            // Assume success
            //
            tspRet = 0;
            lRet = pParams->dwRequestID;

            // If we're already aborting the call, return async success
            // right away and get outa here.
            //
            if (pCall->IsAborting())
            {
                mfn_TSPICompletionProc(pParams->dwRequestID, 0, psl);
                break;
            }

            pCall->SetStateBits(CALLINFO::fCALL_ABORTING);


        #if (TAPI3)
            // --> This does not appear to be required, because TAPI calls
            // the CTMSPCall::CloseMSPCall function. Furthermore, I seemed
            // to have got an av in tapi3's context, not sure in response to
            // this
            if (pLine->T3Info.MSPClients > 0) {
                mfn_SendMSPCmd(
                    pCall,
                    CSATSPMSPCMD_DISCONNECTED,
                    psl
                    );
            }
        #endif  // TAPI3

            //
            // Cancel deferred tasks...
            //
            if (pCall->AreDeferredTaskBitsSet(
                            CALLINFO::fDEFERRED_TSPI_GENERATEDIGITS
                            ))
            {
                //
                // Only non-null digit lists are deferred.
                //
                ASSERT(pCall->pDeferredGenerateTones);
                mfn_LineEventProc(
                                pCall->htCall,
                                LINE_GENERATE,
                                LINEGENERATETERM_CANCEL,
                                pCall->dwDeferredEndToEndID,
                                GetTickCount(),
                                psl
                                );
                FREE_MEMORY(pCall->pDeferredGenerateTones);
                pCall->pDeferredGenerateTones = NULL;
                pCall->dwDeferredEndToEndID = 0;
                pCall->ClearDeferredTaskBits(
                            CALLINFO::fDEFERRED_TSPI_GENERATEDIGITS
                            );
            }

            //
            // We can't have a deferred linedrop if we're not in already
            // in the aborting state! So there should be no more deferred tasks!
            //
            ASSERT(!pCall->dwDeferredTasks);

            if (!m_pLLDev)
            {
                //
                // No device -- we're done...
                //
                mfn_TSPICompletionProc(pParams->dwRequestID, 0, psl);
                break;
            }


            // 6/17/1997 JosephJ
            //      We have do do some tricky things in the case that
            //      the modem is in a connected state other than data.
            //      Most notably VOICE. We can't just to a hangup, because
            //      the modem may be in voice connected state. In fact
            //      if we do hangup without notice the modem often gets
            //      into an unrecoverable state and must be powercycled (
            //      typically it is stuck in voice connected state).
            //
            //      In principle,
            //      it's possible for the minidriver to take care of doing the
            //      proper hangup, and at the same time invalidating any
            //      ongoing reads/writes that may be posted by the
            //      wave driver, but instead what I'm doing is to
            //      delay hangup until the modem is known to be in
            //      command state. So we track here whether the modem
            //      is in connected voice mode and if it is we wait
            //      until it next gets out of that state. At that point
            //      we disallow any further requests to go into
            //      connected state and initiate proper hangup.
            //
            //      TODO: consider moving this intelligence into the minidriver.
            //      The cons of doing this is that it adds complexity to
            //      the minidriver, which is supposed to be as simple as
            //      possible.
            //
            if (m_pLLDev->IsStreamingVoice())
            {
                pCall->SetDeferredTaskBits(
                        CALLINFO::fDEFERRED_TSPI_LINEDROP
                        );
                pCall->dwDeferredLineDropRequestID = pParams->dwRequestID;

                {
                    DWORD   BytesTransfered;

                    AIPC_PARAMS AipcParams;
                    LPREQ_WAVE_PARAMS pRWP = (LPREQ_WAVE_PARAMS)&AipcParams.Params;

                    AipcParams.dwFunctionID = AIPC_REQUEST_WAVEACTION;
                    pRWP->dwWaveAction = WAVE_ACTION_ABORT_STREAMING;

                    m_sync.LeaveCrit(dwLUID_CurrentLoc);

                    SyncDeviceIoControl(
                        m_pLLDev->hComm,
                        IOCTL_MODEM_SEND_LOOPBACK_MESSAGE,
                        (PUCHAR)&AipcParams,
                        sizeof(AipcParams),
                        NULL,
                        0,
                        &BytesTransfered
                        );

                    m_sync.EnterCrit(dwLUID_CurrentLoc);
                }
            }
            else
            {

                // If there is a call-related task pending
                // we abort the task...
                //
                if (pCall->IsCallTaskPending())
                {
                    //
                    // This is a hack, replace this by use of AbortRootTask
                    //

                    if (m_pLLDev->htspTaskPending) {

                        m_StaticInfo.pMD->AbortCurrentModemCommand(
                                                m_pLLDev->hModemHandle,
                                                psl
                                                );

                    } else if (NULL!=pCall->TerminalWindowState.htspTaskTerminal) {

                        mfn_KillCurrentDialog(psl);

                    } else if (pCall->TalkDropWaitTask != NULL) {
                        //
                        //  kill the talk drop dialog
                        //
                        mfn_KillTalkDropDialog(psl);
                    }


                }

                tspRet = mfn_StartRootTask(
                                    &CTspDev::s_pfn_TH_CallDropCall,
                                    &pCall->fCallTaskPending,
                                    pParams->dwRequestID,                // P1
                                    0,
                                    psl
                                    );
                //
                // Note: on sync success, the task is expected to have already
                // called the TAPI callback function
                //

                if (IDERR(tspRet) == IDERR_PENDING)
                {
                    tspRet = 0; // treat this as success...
                }
                else if (IDERR(tspRet) == IDERR_TASKPENDING)
                {
                    //
                    // Oops, a task is already on the stack,
                    // we'll defer the lineDrop.
                    //
                    pCall->SetDeferredTaskBits(CALLINFO::fDEFERRED_TSPI_LINEDROP);
                    pCall->dwDeferredLineDropRequestID = pParams->dwRequestID;
                    tspRet = 0;

                    //
                    // We cleared any other deferred on entry, so this should
                    // be the only one!
                    //
                    ASSERT(   pCall->dwDeferredTasks
                           == CALLINFO::fDEFERRED_TSPI_LINEDROP);
                }
            }

            if (tspRet)
            {
                ASSERT(IDERR(tspRet)!=IDERR_PENDING);
                lRet = LINEERR_OPERATIONFAILED;
            }
		}
		break;

	case TASKID_TSPI_lineCloseCall:
		{
	        FL_SET_RFR(0x08c6de00, "lineCloseCall handled");

            // Do NOT do this:
            //      m_pLine->pCall->ClearStateBits(CALLINFO::fCALL_ACTIVE);
            // because there could be a pending call-related task, such
            // as lineMakeCall, which will get confused if the bit is
            // cleared in the middle of processing the task -- the task
            // may unload the call when it shouldn't and while we're
            // waiting in mfn_UnloadCall below.

            mfn_UnloadCall(FALSE, psl);
            ASSERT(!pLine->pCall);
		}
		break;
	
	case TASKID_TSPI_lineGetCallStatus:
		{
			TASKPARAM_TSPI_lineGetCallStatus *pParams =
					(TASKPARAM_TSPI_lineGetCallStatus *) pvParams;
			ASSERT(pParams->dwStructSize ==
				sizeof(TASKPARAM_TSPI_lineGetCallStatus));
			ASSERT(pParams->dwTaskID==TASKID_TSPI_lineGetCallStatus);
		    FL_SET_RFR(0x1cd1ed00, "lineGetCallStatus handled successfully");
            mfn_GetCallStatus(
                    pParams->lpCallStatus
            );

		}
        break;

	case TASKID_TSPI_lineGetCallInfo:
		{
			TASKPARAM_TSPI_lineGetCallInfo *pParams =
					(TASKPARAM_TSPI_lineGetCallInfo *) pvParams;
			ASSERT(pParams->dwStructSize ==
				sizeof(TASKPARAM_TSPI_lineGetCallInfo));
			ASSERT(pParams->dwTaskID==TASKID_TSPI_lineGetCallInfo);
		    FL_SET_RFR(0x80bb0100, "lineGetCallInfo handled successfully");
            lRet = mfn_GetCallInfo(pParams->lpCallInfo);

		}
        break;


    case TASKID_TSPI_lineAccept:
        {
            TASKPARAM_TSPI_lineAccept *pParams =
                (TASKPARAM_TSPI_lineAccept *) pvParams;
            ASSERT(pParams->dwStructSize ==
                    sizeof(TASKPARAM_TSPI_lineAccept));
            ASSERT(pParams->dwTaskID==TASKID_TSPI_lineAccept);

            FL_SET_RFR(0x0b882700, "lineAccept handled successfully");

            if (pCall->IsPassthroughCall())
            {
                lRet = LINEERR_OPERATIONUNAVAIL;
            } else
            {
                if (LINECALLSTATE_OFFERING != pCall->dwCallState)
                {
                    lRet = LINEERR_INVALCALLSTATE;
                } else
                {
                    NEW_CALLSTATE(pline,LINECALLSTATE_ACCEPTED,0,psl);
                }
            }
        }
        break;

	case TASKID_TSPI_lineAnswer:


		{
		

			TASKPARAM_TSPI_lineAnswer *pParams =
					(TASKPARAM_TSPI_lineAnswer *) pvParams;
			ASSERT(pParams->dwStructSize ==
				sizeof(TASKPARAM_TSPI_lineAnswer));
			ASSERT(pParams->dwTaskID==TASKID_TSPI_lineAnswer);


		  FL_SET_RFR(0xf7baee00, "lineAnswer handled successfully");

          // Validate the line capabilties and call state
          //
          if (pCall->IsPassthroughCall())
          {
              lRet = LINEERR_OPERATIONUNAVAIL;
          }
          else
          {
              if (LINECALLSTATE_OFFERING != pCall->dwCallState &&
                  LINECALLSTATE_ACCEPTED != pCall->dwCallState)
              {
                  lRet = LINEERR_INVALCALLSTATE;
              }
              else
              {
                  // 3/1/1997 JosephJ
                  //    NOTE: Unimodem/V did not make this check even if
                  //    it was just a data modem, thus changing behaviour
                  //    for plain datamodems. By design or a bug? Anyway,
                  //    for NT5.0 I added this check.
                  //
                  if (!mfn_CanDoVoice())
                  {
                      // We can only answer DATAMODEM calls
                      if ((pCall->dwCurMediaModes & LINEMEDIAMODE_DATAMODEM)
                                                                         == 0)
                      {
                          lRet = LINEERR_OPERATIONUNAVAIL;
                      };
                  }

              };
          };

          // At this point, kill the ring timer if we have one
          if (NULL != pCall->hTimer)
          {
              CancelWaitableTimer (pCall->hTimer);
              CloseHandle (pCall->hTimer);
              pCall->hTimer = NULL;
          }

          if (lRet) break;


          // If there is a task pending, we queue this request
          // TODO: unimplemented
          if (m_uTaskDepth)
          {
              FL_SET_RFR(0xc22a1600, "Task pending on lineAnswer, can't handle.");
              lRet = LINEERR_OPERATIONUNAVAIL;
              break;
          }



          tspRet = mfn_StartRootTask(
                              &CTspDev::s_pfn_TH_CallAnswerCall,
                              &pCall->fCallTaskPending,
                              pParams->dwRequestID,                // P1
                              0,
                              psl
                              );



          if (!tspRet || (IDERR(tspRet)==IDERR_PENDING))
          {
               tspRet = 0;

              // One either synchronous success of pending, we return the
              // request ID to TAPI. In the synchronous success case
              // the task we started above will already have notified
              // completion via the TAPI callback function.
              //
              lRet = pParams->dwRequestID;

              // Taken from NT4.0 unimodem ...
              //
              // if a lineAccept wasn't done, notify acceptance
              //
              if (LINECALLSTATE_OFFERING == pCall->dwCallState)
              {
                   NEW_CALLSTATE(pLine, LINECALLSTATE_ACCEPTED, 0, psl);
              };
          }

		}
        break;

	case TASKID_TSPI_lineMonitorDigits:
		{
			TASKPARAM_TSPI_lineMonitorDigits *pParams =
					(TASKPARAM_TSPI_lineMonitorDigits *) pvParams;
			ASSERT(pParams->dwStructSize ==
				sizeof(TASKPARAM_TSPI_lineMonitorDigits));
			ASSERT(pParams->dwTaskID==TASKID_TSPI_lineMonitorDigits);
		    FL_SET_RFR(0x7217c400, "lineMonitorDigits handled successfully");
            if (mfn_CanMonitorDTMF())
            {
                // Unimodem/V didn't selectively report DTMF and DTMFEND --
                // if either or both were specified it would report both --
                // clearly a bug.

                 DWORD  dwDigitModes = pParams->dwDigitModes;

                if (dwDigitModes&~(LINEDIGITMODE_DTMF|LINEDIGITMODE_DTMFEND))
                {
                    FL_SET_RFR(0x0479b600, "INVALID DIGITMODES");
                    lRet = LINEERR_INVALDIGITMODE;
                }
                else
                {
                    pCall->dwDTMFMonitorModes = dwDigitModes;

                    if (!dwDigitModes)
                    {
                        FL_SET_RFR(0x58df2b00, "Disabling Monitoring");
                    }
                    else
                    {
	                    FL_SET_RFR(0x43601800, "Enabling Monitoring");
                    }
                }
            }
            else
            {
                lRet = LINEERR_OPERATIONUNAVAIL;
	            FL_SET_RFR(0xc0124700, "This modem can't monior DTMF");
            }

		}
        break;

	case TASKID_TSPI_lineMonitorTones:
		{
			TASKPARAM_TSPI_lineMonitorTones *pParams =
					(TASKPARAM_TSPI_lineMonitorTones *) pvParams;
			ASSERT(pParams->dwStructSize ==
				sizeof(TASKPARAM_TSPI_lineMonitorTones));
			ASSERT(pParams->dwTaskID==TASKID_TSPI_lineMonitorTones);
		    FL_SET_RFR(0xd57dcf00, "lineMonitorTones handled successfully");
            if (!mfn_CanMonitorSilence())
            {
                FL_SET_RFR(0x70ecc800, "This modem can't monitor silence");
                lRet = LINEERR_OPERATIONUNAVAIL;
            }
            else
            {
                DWORD dwNumEntries = pParams->dwNumEntries;
                LPLINEMONITORTONE lpToneList = pParams->lpToneList;

                // This is all adapted from Unimodem/V (unimdm.c)...
                // Basically we only allow silence monitoring...

                if (lpToneList || dwNumEntries)
                {
                    if (lpToneList
                        && dwNumEntries==1
                        && (lpToneList->dwFrequency1 == 0)
                        && (lpToneList->dwFrequency2 == 0)
                        && (lpToneList->dwFrequency3 == 0))
                    {
                        pCall->SetStateBits(CALLINFO::fCALL_MONITORING_SILENCE);
                        pCall->dwToneAppSpecific = lpToneList->dwAppSpecific;

                        // Unimodem/V used to require this ID is the
                        // same as the ID for the previous call to
                        // lineMonitorTones if any. I don't know why
                        // it did that extra check and I don't do it here.
                        //
                        pCall->dwToneListID = pParams->dwToneListID;
	                    FL_SET_RFR(0xdf123e00, "ENABLING MONITOR SILENCE");
                    }
                    else
                    {
                        lRet = LINEERR_INVALTONE;
	                    FL_SET_RFR(0x72b77d00, "INVALID TONELIST");
                    }
                }
                else
                {
                    pCall->ClearStateBits(CALLINFO::fCALL_MONITORING_SILENCE);
                    FL_SET_RFR(0x5eb73400, "DIABLING MONITOR SILENCE");
            }

            }

		}
        break;


	case TASKID_TSPI_lineGenerateDigits:
		{

// From the TAPI SDK documentation of lineGenerateDigits....
//
// The lineGenerateDigits function is considered to have completed successfully
// when the digit generation has been successfully initiated,
// not when all digits have been generated.
// In contrast to lineDial, which dials digits in a network-dependent fashion,
// lineGenerateDigits guarantees to produce the digits as inband tones
// over the voice channel using DTMF or hookswitch dial pulses when using
// pulse. The lineGenerateDigits function is generally not suitable for
// making calls or dialing. It is intended for end-to-end signaling over an
// established call.
//
// After all digits in lpszDigits have been generated, or after digit generation
// has been aborted or canceled, a LINE_GENERATE message is sent to the
// application.
//
// Only one inband generation request (tone generation or digit generation)
// is allowed to be in progress per call across all applications that are
// owners of the call. Digit generation on a call is canceled by initiating
// either another digit generation request or a tone generation request.
// To cancel the current digit generation, the application can invoke
// lineGenerateDigits and specify NULL for the lpszDigits parameter.
//
// Depending on the service provider and hardware, the application can
// monitor the digits it generates itself. If that is not desired,
// the application can disable digit monitoring while generating digits.
//
// ---- end TAPI documentation -----

			TASKPARAM_TSPI_lineGenerateDigits *pParams =
					(TASKPARAM_TSPI_lineGenerateDigits *) pvParams;
			ASSERT(pParams->dwStructSize ==
				sizeof(TASKPARAM_TSPI_lineGenerateDigits));
			ASSERT(pParams->dwTaskID==TASKID_TSPI_lineGenerateDigits);
		    FL_SET_RFR(0x27417e00, "lineGenerateDigits handled successfully");

            // Fail if device doesn't support this....
            if (!mfn_CanGenerateDTMF())
            {
                lRet = LINEERR_OPERATIONUNAVAIL;
	            FL_SET_RFR(0x17348700, "GenerateDigits: device doesn't support it!");
                goto end;
            }

            // HDRVCALL hdCall,
            // DWORD    dwEndToEndID
            // DWORD    dwDigitMode
            // LPCWSTR  lpszDigits
            // DWORD    dwDuration

            if(pParams->dwDigitMode != LINEDIGITMODE_DTMF)
            {
                FL_SET_RFR(0x6770ef00, "lineGenerateDigit: Unsupported/invalid digitmode");
                lRet = LINEERR_INVALDIGITMODE;
                goto end;
            }

            if ((pParams->lpszDigits != NULL) && (*(pParams->lpszDigits)=='\0')) {
                //
                //  empty string specified
                //
                lRet =LINEERR_INVALDIGITLIST;

                goto end;
            }

            // If we're in the aborting or disconnected state, we do nothing,
            // but return the appropriate status...
            //
            if (pCall->IsAborting() ||
                pCall->dwCallState != LINECALLSTATE_CONNECTED)
            {
                if (!pParams->lpszDigits)
                {
                    FL_SET_RFR(0x83f84100, "lineGenerateDigit: Ignoring request for aborting/disconnected call...");
                    lRet = 0;
                }
                else
                {
                    FL_SET_RFR(0x511e2400, "lineGenerateDigit: Can't handle request while aborting/disconnected call...");
                    lRet = LINEERR_INVALLINESTATE;
                }
                goto end;
            }

            // 3/20/1998 JosephJ. Brian suggests the following:
            //
            //    [Brianl] I think that the code for lineGenerateDigits()
            //    should be changed to check if  (dwVoiceProfile &
            //    VOICEPROF_MODEM_OVERRIDES_HANDSET) is set and if the call
            //    is an automated voice call then it should allow the call
            //    to proceed. If it is interactive voice and
            //    VOICEPROF_MODEM_OVERRIDES_HANDSET then the call
            //    should fail.
            //
            //    See notes.txt entry on 3/20/1998 for more details.
            if (    mfn_ModemOverridesHandset()
                &&  !(pCall->dwCurMediaModes & LINEMEDIAMODE_AUTOMATEDVOICE))
            {
                lRet = LINEERR_OPERATIONUNAVAIL;
	            FL_SET_RFR(0x4c39cf00, "GenerateDigits: only works with AUTOMATEDVOICE!");
	            goto end;
            }


            //
            // If there's a deferred linegeneratedigit, we kill them right
            // here...
            //
            if (pCall->AreDeferredTaskBitsSet(
                            CALLINFO::fDEFERRED_TSPI_GENERATEDIGITS
                            ))
            {
                // only send up a notification if there were
                // non-null tones specified in the request..
                // (null ==> cancel)
                //
                if (pCall->pDeferredGenerateTones)
                {
                    mfn_LineEventProc(
                                    pCall->htCall,
                                    LINE_GENERATE,
                                    LINEGENERATETERM_CANCEL,
                                    pCall->dwDeferredEndToEndID,
                                    GetTickCount(),
                                    psl
                                    );
                    FREE_MEMORY(pCall->pDeferredGenerateTones);
                    pCall->pDeferredGenerateTones = NULL;
                }
                pCall->dwDeferredEndToEndID = 0;

                pCall->ClearDeferredTaskBits(
                            CALLINFO::fDEFERRED_TSPI_GENERATEDIGITS
                            );
            }


            //
            // Abort currently generating digits if any...
            //
            if (pCall->IsGeneratingDigits())
            {
                 // TODO: implement Abort task scheme...

                if (m_pLLDev && m_pLLDev->htspTaskPending)
                {
                    m_StaticInfo.pMD->AbortCurrentModemCommand(
                                                m_pLLDev->hModemHandle,
                                                psl
                                                );
                }
                else
                {
                    // we shouldn't get here!
                    FL_ASSERT(psl, FALSE);

                }
            }

            //
            // If digits are specified, we create ANSI versions of it,
            // and either start the task to generate the digits or
            // defer it.
            //
            //
            #ifndef UNICODE
            #error  "Following code assumes UNICODE.
            #endif // !UNICODE
            if(pParams->lpszDigits && *(pParams->lpszDigits))
            {
                // We ignore dwDuration (from unimodem /v )
                char *lpszAnsiDigits = NULL;

                UINT cb = WideCharToMultiByte(
                                  CP_ACP,
                                  0,
                                  pParams->lpszDigits,
                                  -1,
                                  NULL,
                                  0,
                                  NULL,
                                  NULL);
                if (cb)
                {
                    lpszAnsiDigits =  (char*)ALLOCATE_MEMORY(
                                                cb
                                                );

                    if (lpszAnsiDigits)
                    {
                        cb = WideCharToMultiByte(
                                          CP_ACP,
                                          0,
                                          pParams->lpszDigits,
                                          -1,
                                          lpszAnsiDigits,
                                          cb,
                                          NULL,
                                          NULL
                                          );

                    }
                }

                if (!cb)
                {
                    if (lpszAnsiDigits)
                    {
                        FREE_MEMORY(lpszAnsiDigits);
                        lpszAnsiDigits=NULL;
                    }
                    lRet = LINEERR_OPERATIONFAILED;
                    FL_SET_RFR(0x8ee76c00, "Couldn't convert tones to ANSI!");
                    goto end;
                }

                if (!lpszAnsiDigits)
                {
                    FL_SET_RFR(0xf7736900, "Couldn't alloc space for tones!");
                    lRet =  LINEERR_RESOURCEUNAVAIL;
                    goto end;
                }

                // Start the root task if we can...
                tspRet = mfn_StartRootTask(
                          &CTspDev::s_pfn_TH_CallGenerateDigit,
                          &pCall->fCallTaskPending,
                          pParams->dwEndToEndID,
                          (ULONG_PTR) lpszAnsiDigits,
                          psl
                          );

                if (IDERR(tspRet)==IDERR_TASKPENDING)
                {
                    //
                    // We've already cancelled any deferred generate task
                    // earlier...
                    //
                    ASSERT(     !pCall->AreDeferredTaskBitsSet(
                                    CALLINFO::fDEFERRED_TSPI_GENERATEDIGITS
                                    )
                            &&  !pCall->pDeferredGenerateTones);

                    pCall->SetDeferredTaskBits(
                                    CALLINFO::fDEFERRED_TSPI_GENERATEDIGITS
                                    );
                    pCall->pDeferredGenerateTones = lpszAnsiDigits;
                    pCall->dwDeferredEndToEndID = pParams->dwEndToEndID;
                    lpszAnsiDigits = NULL; // do this so we don't free it below.
                    tspRet = 0;
                    lRet = 0;
                }
                else if (!tspRet || (IDERR(tspRet)==IDERR_PENDING))
                {
                    // success (either pending or sync)

                    tspRet = 0;
                    lRet = 0;
                }
                else
                {
                    // FAILURE
                    //
                    //  brianl: fix problem with sending LINE_GENERATE if sync failure
                    //  tapisrv frees the end to end buffer if we return failure and
                    //  if free it again if we later send LINE_GENERATE
                    //
                    tspRet = 0;
                    lRet = 0;

//                    lRet = LINEERR_OPERATIONFAILED;
                }

                if (lpszAnsiDigits)
                {
                    //
                    // Note: even on pending return, TH_CallGenerateDigit
                    // doesn't expect the passed in string to be valid
                    // after the initial start request, so it's OK to free it
                    // here.
                    //
                    FREE_MEMORY(lpszAnsiDigits);
                    lpszAnsiDigits=NULL;
                }
            }
		}
        break; // lineGenerateDigits...


	case TASKID_TSPI_lineSetCallParams:
		{
            // <@t passthrough>
			TASKPARAM_TSPI_lineSetCallParams *pParams =
					(TASKPARAM_TSPI_lineSetCallParams *) pvParams;
			ASSERT(pParams->dwStructSize ==
				sizeof(TASKPARAM_TSPI_lineSetCallParams));
			ASSERT(pParams->dwTaskID==TASKID_TSPI_lineSetCallParams);
		    FL_SET_RFR(0x2d0a4600, "lineSetCallParams handled successfully");
            DWORD dwBearerMode = pParams->dwBearerMode;


            // New for NT5.0 ...
            //
            if (!pCall->IsActive() || pCall->IsAborting())
            {
                lRet =  LINEERR_INVALCALLSTATE;
                FL_SET_RFR(0xf4a36800, "Callstate aborting or not active");
                goto end;
            }

            // This check was in NT4.0...
            //
            if (LINECALLSTATE_OFFERING != pCall->dwCallState &&
                LINECALLSTATE_ACCEPTED != pCall->dwCallState &&
                LINECALLSTATE_CONNECTED != pCall->dwCallState)
            {
                lRet =  LINEERR_INVALCALLSTATE;
                FL_SET_RFR(0x7079be00, "Callstate not OFFERING/ACCEPTED/CONNECTED");
                goto end;
            }

            // Cancel the timer, if we have one
            //
            if (NULL != pCall->hTimer)
            {
                CancelWaitableTimer (pCall->hTimer);
                CloseHandle (pCall->hTimer);
                pCall->hTimer = NULL;
            }

            // verify bearer mode (was in NT4.0)
            //
            if ((~m_StaticInfo.dwBearerModes) & dwBearerMode)
            {
                FL_SET_RFR(0x34301c00, "lineSetCallParams: Invalid bearermode");
                lRet =  LINEERR_INVALBEARERMODE;
                goto end;
            }

            // Do we need to change passthrough state?
            //
            if (   (pCall->dwCurBearerModes & LINEBEARERMODE_PASSTHROUGH)
                != (dwBearerMode & LINEBEARERMODE_PASSTHROUGH))
            {

                //
                // TODO: use appropriate tasks (TH_LLDevNormalize,...)
                //
                // For now this is a HACK:
                // We call TH_LLDevUmSetPassthroughMode ourselves and expect
                // it to succeed synchronously, and then munge the
                // pLLDev->fdwExResourceUsage values here itself.
                //
                // What we should do is start a TH_Call* task which
                // should start the TH_LLDevNormalize task and send
                // the completion on actual completion of the task.
                //


                BOOL fSucceeded = FALSE;
                DWORD dwPassthroughMode = 0;

                lRet = 0;
                tspRet = 0;

		        if (dwBearerMode & LINEBEARERMODE_PASSTHROUGH)
		        {
		            // we're asked to switch into passthrough...

		            ASSERT(!(  pCall->dwLLDevResources
                             & LLDEVINFO::fRESEX_PASSTHROUGH));

		            if (    !(  m_pLLDev->fdwExResourceUsage
                              & LLDEVINFO::fRESEX_PASSTHROUGH)
                            //
                            // ^^ This  means that no one *else* has requested
                            //    passthrough to go on
                         &&
                            !m_pLLDev->IsPassthroughOn())
                            //
                            // ^^ This  means that passthrough is not
                            //    currently on
                    {
                        // We open the device if required...
                        if (!pCall->IsOpenedLLDev())
                        {
                            tspRet =  mfn_OpenLLDev(
                                            0,      // Ask for no resources
                                            0,
                                            FALSE,          // fStartSubTask
                                            NULL,
                                            0,
                                            psl
                                            );

                            if (!tspRet || IDERR(tspRet)==IDERR_PENDING)
                            {
                                //
                                // Note: Even if mfn_OpenLLDev fails
                                // Asynchronously, we're still
                                // open with the requested resources,
                                // and to cleanup we need to
                                // mfn_CloseLLDev specifying the same resources we claimed here.
                                //
                                pCall->SetStateBits(CALLINFO::fCALL_OPENED_LLDEV);
                                pCall->dwLLDevResources = 0;
                            }
                            else
                            {
                                // Failure to open -- fail the whole thing...
                                FL_SET_RFR(0x345de200, "Failed to get resources for passthrough");
                                goto end;
                            }
                        }
                        // actually switch on...

                        tspRet = mfn_StartRootTask(
                                        &s_pfn_TH_LLDevUmSetPassthroughMode,
                                        &m_pLLDev->fLLDevTaskPending,
                                        // ^^^ note we specify fLLDevTaskPending
                                        // this is part of the hack -- we're
                                        // basically acting on behalf of
                                        // LLDev.
                                        PASSTHROUUGH_MODE_ON,
                                        0,
                                        psl
                                        );

                        if (IDERR(tspRet)==IDERR_PENDING)
                        {
                            // TODO: we  can't deal with this now
                            ASSERT(FALSE);
                            tspRet = 0;
                        }

                        if (tspRet)
                        {
                            FL_SET_RFR(0x82cda200, "UmSetPassthroughOn failed");
                        }
                        else
                        {
                            fSucceeded = TRUE;

                            // This records that the CALL has requested
                            // to switch passthrough on.
                            //
                            pCall->dwLLDevResources
                                             |= LLDEVINFO::fRESEX_PASSTHROUGH;

                            // This records the fact that someone has
                            // requested lldev to enable passthrough (in this
                            // case the call).
                            //
                            m_pLLDev->fdwExResourceUsage
                                             |= LLDEVINFO::fRESEX_PASSTHROUGH;


                         FL_SET_RFR(0x43ec3000, "UmSetPassthroughOn succedded");

                        }
                    }
                    else
                    {
                        // error...
                    FL_SET_RFR(0x0ca8d700, "Wrong state for passthrough on");
                    }
		        }
		        else
		        {
		            // we're asked to switch out of passthrough...

		            ASSERT(  pCall->dwLLDevResources
                           & LLDEVINFO::fRESEX_PASSTHROUGH);


                    // This records that the CALL no-longer wants
                    // passthrough.
                    //
                    pCall->dwLLDevResources
                                     &= ~LLDEVINFO::fRESEX_PASSTHROUGH;

                    // This records the fact that no one has
                    // requested lldev to enable passthrough.
                    //
                    m_pLLDev->fdwExResourceUsage
                                     &= ~LLDEVINFO::fRESEX_PASSTHROUGH;
                    //
                    // We do the above even if the folllowing call fails,
                    // because they serve as refcounts. A subsequent
                    // TH_LLDevNormalize will switch-off passthrough if
                    // the no one is useing it.
                    //

		            if (m_pLLDev->IsPassthroughOn())
                            //
                            // ^^ This  means that passthrough is actually
                            //    on
                    {
                        //
                        //  if the call is a voice call just to passthrough off, else it should
                        //  be a data call so go to dcd sniff so that ras can talk to the modem
                        //  if ras hands off the call.
                        //

                        tspRet = mfn_StartRootTask(
                                        &s_pfn_TH_LLDevUmSetPassthroughMode,
                                        &m_pLLDev->fLLDevTaskPending,
                                        pCall->IsVoice() ? PASSTHROUUGH_MODE_OFF : PASSTHROUUGH_MODE_ON_DCD_SNIFF,
                                        0,
                                        psl
                                        );

                        if (IDERR(tspRet)==IDERR_PENDING)
                        {
                            // TODO: we  can't deal with this now
                            ASSERT(FALSE);
                            tspRet = 0;
                        }

                        if (tspRet)
                        {
                           FL_SET_RFR(0x82300f00, "UmSetPassthroughOff failed");
                        }
                        else
                        {

                            fSucceeded = TRUE;
                        FL_SET_RFR(0x7c710f00, "UmSetPassthroughOff succedded");
                        }
                    }
                    else
                    {
                        // shouldn't get here...
                        ASSERT(FALSE);
                    }
		        }

                if (fSucceeded)
                {
                    // Notify TAPI here of success ....
                    //
                    lRet = pParams->dwRequestID;
                    pCall->dwCurBearerModes = dwBearerMode;
                    mfn_TSPICompletionProc(pParams->dwRequestID, 0, psl);

                    mfn_LineEventProc(
                        pCall->htCall,
                        LINE_CALLINFO,
                        LINECALLINFOSTATE_BEARERMODE,
                        0,
                        0,
                        psl
                        );


                    // Also send the callstate-connected message...
                    //
                    if (dwBearerMode&LINEBEARERMODE_PASSTHROUGH)
                    {
                        if (LINECALLSTATE_CONNECTED != pCall->dwCallState)
                        {
                          NEW_CALLSTATE(pLine, LINECALLSTATE_CONNECTED, 0, psl);
                        }
                    }
                }
                else
                {
                    lRet = LINEERR_OPERATIONFAILED;
                }
                tspRet = 0; // error is reported in lret.

            }


		} // end case TASKID_TSPI_lineSetCallParams
        break;

	case TASKID_TSPI_lineSetAppSpecific:
		{
			TASKPARAM_TSPI_lineSetAppSpecific *pParams =
					(TASKPARAM_TSPI_lineSetAppSpecific *) pvParams;
			ASSERT(pParams->dwStructSize ==
				sizeof(TASKPARAM_TSPI_lineSetAppSpecific));
			ASSERT(pParams->dwTaskID==TASKID_TSPI_lineSetAppSpecific);
		    FL_SET_RFR(0xece6f100, "lineSetAppSpecific handled successfully");

            //
            // 8/5/1997 JosephJ following adapted from nt4 unimdm.tsp
            //
            pCall->dwAppSpecific = pParams->dwAppSpecific;

            mfn_LineEventProc(
                            pCall->htCall,
                            LINE_CALLINFO,
                            LINECALLINFOSTATE_APPSPECIFIC,
                            0,
                            0,
                            psl
                            );
		}
        break;

	case TASKID_TSPI_lineSetMediaMode:
		{
			TASKPARAM_TSPI_lineSetMediaMode *pParams =
					(TASKPARAM_TSPI_lineSetMediaMode *) pvParams;
			ASSERT(pParams->dwStructSize ==
				sizeof(TASKPARAM_TSPI_lineSetMediaMode));
			ASSERT(pParams->dwTaskID==TASKID_TSPI_lineSetMediaMode);
		    FL_SET_RFR(0x9472a000, "lineSetMediaMode handled successfully");
            DWORD dwMediaMode = pParams->dwMediaMode;

            //
            // We support only the switch from VOICE to DATA on an
            // incoming call when there is no streaming going on -- in
            // this case, we issue UmAnswerModem specifying
            // flag ANSWER_FLAG_VOICE_TO_DATA.
            //

            // Check the requested modes. There must only be our media modes.
            if (dwMediaMode & ~(m_StaticInfo.dwDefaultMediaModes))
            {
                lRet = LINEERR_INVALMEDIAMODE;
                break;
            }
            else
            {
                switch(dwMediaMode)
                {
                case LINEMEDIAMODE_DATAMODEM:

                    if (
                            pCall->IsConnectedVoiceCall()
                         && pCall->IsInbound()
                         && !m_pLLDev->IsStreamingVoice()
                         && !pCall->IsPassthroughCall())
                    {


                        tspRet = mfn_StartRootTask(
                                &CTspDev::s_pfn_TH_CallSwitchFromVoiceToData,
                                &pCall->fCallTaskPending,
                                0,
                                0,
                                psl
                                );


                        if (!tspRet || IDERR(tspRet) == IDERR_PENDING)
                        {
    	                    lRet = 0;; // treat pending as success...
                            tspRet = 0;
                        }
                        else
                        {
                            //
                            // Oops, a task is already on the stack,
                            // fail ....
                            //
    	                    lRet = LINEERR_OPERATIONFAILED;
                        }
                    }
                    else
                    {
                        lRet = LINEERR_INVALCALLSTATE;
                    }
                    break;

                default:
    	            lRet = LINEERR_OPERATIONUNAVAIL;
                }
            }
		}
        break;


	case TASKID_TSPI_lineMonitorMedia:
		{
			TASKPARAM_TSPI_lineMonitorMedia *pParams =
					(TASKPARAM_TSPI_lineMonitorMedia *) pvParams;
			ASSERT(pParams->dwStructSize ==
				sizeof(TASKPARAM_TSPI_lineMonitorMedia));
			ASSERT(pParams->dwTaskID==TASKID_TSPI_lineMonitorMedia);
		    FL_SET_RFR(0xfdf96a00, "lineMonitorMedia handled successfully");
		    DWORD dwMediaModes = pParams->dwMediaModes;
            if (mfn_CanDoVoice())
            {
                DWORD dwOurMonitorMedia =   LINEMEDIAMODE_G3FAX
                                          | LINEMEDIAMODE_DATAMODEM;

                // FOLLOWING line from win9x unimodem/v:
                //
                //   removed 8/22/95 as the phone wants to monitor for numerous
                //   media modes
                //
                //    if (LINEMEDIAMODE_G3FAX != dwMediaModes) {
                //        return LINEERR_INVALMEDIAMODE;
                //    }
                if (dwMediaModes & ~dwOurMonitorMedia)
                {
                    lRet = LINEERR_INVALMEDIAMODE;
                    break;
                }
                pCall->dwMonitoringMediaModes = dwMediaModes;
            }
            else
            {
                // can't do media detection if a data/null modem...

                lRet = LINEERR_OPERATIONUNAVAIL;
            }
		}
		break;


	default:
		FL_SET_RFR(0x87a0b000, "*** UNHANDLED HDRVCALL CALL ****");

	    lRet = LINEERR_OPERATIONUNAVAIL;
		break;
	}

end:

    if (tspRet && !lRet)
    {
        lRet = LINEERR_OPERATIONFAILED;
    }

    *plRet = lRet;

	FL_LOG_EXIT(psl, tspRet);
}


#include "apptspi.h"

TSPRETURN
CTspDev::mfn_TH_CallMakeTalkDropCall(
					HTSPTASK htspTask,
                    TASKCONTEXT *pContext,
					DWORD dwMsg,
					ULONG_PTR dwParam1,
					ULONG_PTR dwParam2,
					CStackLog *psl
					)

{
	FL_DECLARE_FUNC(0xb7f98764, "CTspDev::mfn_TH_CallMakeTalkDropCall")
	FL_LOG_ENTRY(psl);
	TSPRETURN tspRet=FL_GEN_RETVAL(IDERR_CORRUPT_STATE);

    CALLINFO *pCall = m_pLine->pCall;

    enum
    {
    MAKETALKDROPCALL_DIALCOMPLETE,
    MAKETALKDROPCALL_HANGUPCOMPLETE,
    MAKETALKDROPCALL_DIALOG_GONE
    };

    switch(dwMsg)
    {
    default:
        FL_SET_RFR(0xb72c4600, "Unknown Msg");
        goto end;

    case MSG_START:
        goto start;

	case MSG_SUBTASK_COMPLETE:
        tspRet = dwParam2;


        switch(dwParam1) // Param1 is Subtask ID
        {
        case MAKETALKDROPCALL_DIALCOMPLETE:  goto dial_complete;
        case MAKETALKDROPCALL_HANGUPCOMPLETE: goto hangup_complete;
        case MAKETALKDROPCALL_DIALOG_GONE:    goto dialog_gone;
        }
        break;

    case MSG_DUMPSTATE:
        tspRet = 0;
        goto end;
    }

    ASSERT(FALSE);


start:
    {
        DWORD    dwFlags=(DWORD)dwParam1;
        CHAR*    szAddress=(CHAR*)dwParam2;

        pCall->TalkDropButtonPressed=FALSE;
        //
        // Dial away....
        //
        tspRet = mfn_StartSubTask (
                            htspTask,
                            &CTspDev::s_pfn_TH_LLDevUmDialModem,
                            MAKETALKDROPCALL_DIALCOMPLETE,
                            dwFlags,
                            (ULONG_PTR) szAddress,
                            psl
                            );


        if (IDERR(tspRet) == IDERR_PENDING) {

            SLPRINTF0(psl,"Putting up the talkdrop dialog");

            pCall->TalkDropStatus=0;

            DLGINFO DlgInfo;

            //
            //   bring up the talk drop dialog
            //

            if (m_pLLDev && m_pLLDev->IsLoggingEnabled()) {

                CHAR    ResourceString[256];
                int     StringSize;

                StringSize=LoadStringA(
                    g.hModule,
                    IDS_TALK_DROP_DIALOG,
                    ResourceString,
                    sizeof(ResourceString)
                    );

                if (StringSize > 0) {

                    lstrcatA(ResourceString,"\r");

                    m_StaticInfo.pMD->LogStringA(
                                        m_pLLDev->hModemHandle,
                                        LOG_FLAG_PREFIX_TIMESTAMP,
                                        ResourceString,
                                        NULL
                                        );
                }
            }


            // Tell the application side
            // to start running the dialog instance
            //
            DlgInfo.idLine = mfn_GetLineID ();
            DlgInfo.dwType = TALKDROP_DLG;
            DlgInfo.dwCmd  = DLG_CMD_CREATE;

            m_pLine->lpfnEventProc (
                        (HTAPILINE)(LONG_PTR)m_pLine->pCall->TerminalWindowState.htDlgInst,
                        0,
                        LINE_SENDDIALOGINSTANCEDATA,
                        (ULONG_PTR)(&DlgInfo),
                        sizeof(DlgInfo),
                        0);

            goto end;

        }
    }

dial_complete:

    if (tspRet == 0) {
        //
        //  the dial attempt returned a successful result, need to wait for the user to
        //  do something with talk drop dialog
        //
        tspRet = mfn_StartSubTask (
                        htspTask,
                        &CTspDev::s_pfn_TH_CallWaitForDropToGoAway,
                        MAKETALKDROPCALL_DIALOG_GONE,
                        0,
                        0,
                        psl
                        );

        if (IDERR(tspRet)==IDERR_PENDING) goto end;

    } else {
        //
        //  the dial attempt returned with some sort of error, see if it was because the
        //  talkdrop code aborted the dial or if was busy or something
        //
        if (pCall->TalkDropButtonPressed) {
            //
            //  the user has apparently pressed one of the buttons on the talkdrop
            //  dialog, so that is probably why we are here.
            //
            //  TalkDropStatus is set according to what which button was pressed
            //

        } else {
            //
            //  The user has not pressed any buttons so this is some other error, like busy or
            //  no carrier
            //
            pCall->TalkDropStatus=tspRet;
        }
    }

dialog_gone:

    //
    //  always issue the hangup commands
    //
    tspRet = mfn_StartSubTask (
                        htspTask,
                        &CTspDev::s_pfn_TH_LLDevUmHangupModem,
                        MAKETALKDROPCALL_HANGUPCOMPLETE,
                        0,
                        0,
                        psl
                        );

    if (IDERR(tspRet)==IDERR_PENDING) goto end;


hangup_complete:

    //
    //  want to return the status so the calling code knows to report connect or not.
    //
    tspRet=pCall->TalkDropStatus;



end:
    FL_LOG_EXIT(psl, tspRet);
    return tspRet;


}



TSPRETURN
CTspDev::mfn_TH_CallWaitForDropToGoAway(
					HTSPTASK htspTask,
                    TASKCONTEXT *pContext,
					DWORD dwMsg,
					ULONG_PTR dwParam1,
					ULONG_PTR dwParam2,
					CStackLog *psl
					)

{
    FL_DECLARE_FUNC(0xb7e98764, "CTspDev::mfn_TH_CallWaitForDropToGoAway")
    FL_LOG_ENTRY(psl);
    TSPRETURN tspRet=FL_GEN_RETVAL(IDERR_CORRUPT_STATE);

    CALLINFO *pCall = m_pLine->pCall;


    switch(dwMsg)
    {
    default:
        FL_SET_RFR(0xb73c4600, "Unknown Msg");
        goto end;

    case MSG_START:
        goto start;

    case MSG_SUBTASK_COMPLETE:
        tspRet = dwParam2;
        pCall->TalkDropWaitTask=NULL;
        goto end;

    case MSG_DUMPSTATE:
        tspRet = 0;
        goto end;
    }

    ASSERT(FALSE);


start:

    pCall->TalkDropWaitTask = htspTask;
    tspRet = IDERR_PENDING;



//    if (IDERR(tspRet)==IDERR_PENDING) goto end;



end:
    FL_LOG_EXIT(psl, tspRet);
    return tspRet;


}

TSPRETURN
CTspDev::mfn_TH_CallMakeCall2(
					HTSPTASK htspTask,
                    TASKCONTEXT *pContext,
					DWORD dwMsg,
					ULONG_PTR dwParam1,
					ULONG_PTR dwParam2,
					CStackLog *psl
					)
//
//  START: dwParam1  == TAPI request ID.
//
//  We could get called either directly in the context of TSPI_lineMakeCall
//  or from the deferred task handler.
//
//  In the former case, we don't need to call the completion callback
//  if we're failing synchronously, but in the latter case, we do need
//  to call the completion routine because TAPI will be expecting
//  a callback.
//
//  We must also keep track of whether we have returned success
//  (in which case the call is active as far as TAPI is concerned),
//  or failure, in which case the call handle is not valid.
//
{
    //
    // Context Use:
    //  dw0: *pdwRequestID
    //  dw1: *ptspTrueResult;
    //  dw2: none

	FL_DECLARE_FUNC(0xded1f0a9, "CTspDev::mfn_TH_CallMakeCall2")
	FL_LOG_ENTRY(psl);
	TSPRETURN tspRet=FL_GEN_RETVAL(IDERR_CORRUPT_STATE);
	CALLINFO *pCall = m_pLine->pCall;

    ULONG_PTR *pdwRequestID             = &(pContext->dw0);
    TSPRETURN  *ptspTrueResult      = &(pContext->dw1);

    LONG lTspiRet = LINEERR_OPERATIONFAILED;
    //
    //  lTspiRet is the tspi return value in case we fail the lineMakeCall,
    //  either sync or async.


    enum
    {
    MAKECALL_OPEN_COMPLETE,
    MAKECALL_PREDIALCOMMAND_COMPLETE,
    MAKECALL_PRE_TRM_COMPLETE,
    MAKECALL_MANUAL_DIAL_COMPLETE,
    MAKECALL_DIAL_COMPLETE,
    MAKECALL_POST_TRM_COMPLETE,
    MAKECALL_CLEANUP_COMPLETE
    };

    switch(dwMsg)
    {
    default:
        FL_SET_RFR(0xbbe6ff00, "Unknown Msg");
        goto end;

    case MSG_START:
        goto start;

	case MSG_SUBTASK_COMPLETE:
        tspRet = dwParam2;

        // We force tspRet to failure
        // in the special case that the call is being aborted so that it
        // doesn't continue with the state diagram.
        //
        // TODO: Implement AbortTask/SubTask to deal with this sort of thing.
        //
        if (pCall->IsAborting() && !tspRet)
        {
            tspRet = IDERR_OPERATION_ABORTED;
        }

        switch(dwParam1) // Param1 is Subtask ID
        {
        case MAKECALL_DIAL_COMPLETE:    goto dial_complete;
        case MAKECALL_POST_TRM_COMPLETE:goto post_term_complete;
        case MAKECALL_CLEANUP_COMPLETE: goto cleanup_complete;
        }
        break;

    case MSG_DUMPSTATE:
        tspRet = 0;
        goto end;
    }

    ASSERT(FALSE);


    // The following code would be straightline code with no labels if all the
    //  async calls ompleted aynchronously, or were implemented using fibers.
    //  In other words, this is is our homebrew implementation of fibers.

start:

    *pdwRequestID = dwParam1; // save context..

    //
    // Let's actually dial...
    //
    {

        PFN_CTspDev_TASK_HANDLER *ppfnHandler = &CTspDev::s_pfn_TH_LLDevUmDialModem;


        DWORD dwFlags =  DIAL_FLAG_ORIGINATE; // TODO
        CHAR  *szAddress = pCall->szAddress;
        pCall->bDialTone = 0;

        if (!mfn_IS_NULL_MODEM())
        {
            CHAR  *szAddress2;

            pCall->bDialTone = (szAddress[0] == '\0');

            szAddress2 = szAddress;
            while(*szAddress2 != '\0')
            {
                if (*szAddress2 == ';')
                {
                     *szAddress2 = '\0';
                     pCall->bDialTone = 1;
                } else
                {
                     szAddress2++;
                }
            }

            if (pCall->bDialTone)
            {
                    dwFlags = 0;
            }
        }

        if (pCall->TerminalWindowState.dwOptions & UMMANUAL_DIAL) {
            //
            // For manual dial, we do a blind dial with an empty string...
            //

            szAddress = "";
            dwFlags |= DIAL_FLAG_BLIND;
        }



        if (m_Line.Call.dwDialOptions & MDM_TONE_DIAL)
        {
            dwFlags |= DIAL_FLAG_TONE;
        }

        if (m_Line.Call.dwDialOptions & MDM_BLIND_DIAL)
        {
            dwFlags |= DIAL_FLAG_BLIND;
        }

        if (m_Line.Call.dwCurMediaModes & LINEMEDIAMODE_DATAMODEM)
        {
            dwFlags |=  DIAL_FLAG_DATA;
        }
        else if (m_Line.Call.dwCurMediaModes & LINEMEDIAMODE_AUTOMATEDVOICE)
        {
            dwFlags |= DIAL_FLAG_AUTOMATED_VOICE
                        |  DIAL_FLAG_VOICE_INITIALIZE;
            // TODO: DIAL_FLAG_VOICE_INITIALIZE should only be specified in
            //          the first call to Dial -- subsequent calls
            //          (lineDial...) should not have this flag specified.
            //
        }
        else
        {

            if (mfn_CanDoVoice()) {
                //
                //  this is a voice modem, let dial a voice call
                //
                dwFlags |=  DIAL_FLAG_VOICE_INITIALIZE;

            } else {
                //
                //  this a data only modem and we are attempting to dial an interactive
                //  voice call. We will dial the call and put up a talk drop dialog
                //  to allow the user to cause the modem to hangup so the handset is
                //  connected to the line
                //
                dwFlags &=  ~DIAL_FLAG_ORIGINATE;

                ppfnHandler = &CTspDev::s_pfn_TH_CallMakeTalkDropCall;

            }

            dwFlags |= DIAL_FLAG_INTERACTIVE_VOICE;
        }


        // Dial away....
        //
        tspRet = mfn_StartSubTask (
                            htspTask,
                            ppfnHandler,
                            MAKECALL_DIAL_COMPLETE,
                            dwFlags,
                            (ULONG_PTR) szAddress,
                            psl
                            );
    }

    if (!tspRet || IDERR(tspRet) == IDERR_PENDING)
    {
        // Set call state to active and notify TAPI of completion here,
        // rather than wait for after the dial completes.

	if (pCall->bDialTone)
	{
		mfn_TSPICompletionProc((DWORD)*pdwRequestID, 0, psl);

		NEW_CALLSTATE(m_pLine, LINECALLSTATE_DIALTONE, 0, psl);

	} else
	{
		pCall->dwState |= CALLINFO::fCALL_ACTIVE;

		mfn_TSPICompletionProc((DWORD)*pdwRequestID, 0, psl);

		NEW_CALLSTATE(m_pLine, LINECALLSTATE_DIALING, 0, psl);
		NEW_CALLSTATE(m_pLine, LINECALLSTATE_PROCEEDING, 0, psl);
	}
    }

    if (IDERR(tspRet)==IDERR_PENDING) goto end;

dial_complete:
    if (tspRet)
    {
        lTspiRet = LINEERR_OPERATIONFAILED;
        goto cleanup;
    }

    ASSERT(m_pLine);
    ASSERT(m_pLine->pCall);

    if ( (NULL != m_pLine->pCall->TerminalWindowState.htDlgInst) &&
         (m_pLine->pCall->TerminalWindowState.dwOptions & UMTERMINAL_POST) )
    {
        tspRet = mfn_StartSubTask (htspTask,
                                   &CTspDev::s_pfn_TH_CallStartTerminal,
                                   MAKECALL_POST_TRM_COMPLETE,
                                   UMTERMINAL_POST,    // got to passthrough
                                   0,
                                   psl);
    }

    if (IDERR(tspRet)==IDERR_PENDING)
    {
        goto end;
    }

post_term_complete:
    if (!tspRet)
    {
        // IsActive indicates that we've completed the async TSPI_lineMakeCall.
        //
        ASSERT(pCall->IsActive());
        // If a dialog instance is not created,
        // this is a no-op
        mfn_FreeDialogInstance ();

	if (!pCall->bDialTone)
	{
		mfn_HandleSuccessfulConnection(psl);
	}

#if (TAPI3)
        if (m_pLine->T3Info.MSPClients > 0) {
//        if (pCall->IsMSPCall())
//        {
            mfn_SendMSPCmd(
                pCall,
                CSATSPMSPCMD_CONNECTED,
                psl
                );
        }
#endif  // TAPI3

        goto end;
    }

cleanup:

    // If a dialog instance is not created,
    // this is a no-op
    mfn_FreeDialogInstance ();
    // Failure ...
    *ptspTrueResult = tspRet; // save it away so we report
                              // the correct status when we're done
                              // cleaning up.

    if (pCall->bDialTone)
    {
	    goto end;
    }

    if (pCall->IsOpenedLLDev())
    {
        tspRet = mfn_CloseLLDev(
                    pCall->dwLLDevResources,
                    TRUE,
                    htspTask,
                    MAKECALL_CLEANUP_COMPLETE,
                    psl
                    );
        //
        // even on failure (shouldn't get failure) we clear our
        // bit indicating we'd opened the lldev....
        //
        pCall->ClearStateBits(CALLINFO::fCALL_OPENED_LLDEV);
        pCall->dwLLDevResources = 0;
    }

cleanup_complete:

    if (IDERR(tspRet)==IDERR_PENDING) goto end;

    if (tspRet)
    {
        // If there was a problem during cleanup, we treat it
        // like a hw error
        //
        pCall->dwState |=  CALLINFO::fCALL_HW_BROKEN;
        tspRet = 0;
    }
    else
    {
        // If cleanup was successful, we clear the hw-error bit, even
        // if it was set, because the monitor and init went OK...
        pCall->dwState &=  ~CALLINFO::fCALL_HW_BROKEN;
    }

    //
    // Ignore failure during cleanup...
    //
    tspRet = 0;

    // IsActive indicates that we've completed the async TSPI_lineMakeCall.
    //
    if (pCall->IsActive())
    {
        if (!pCall->IsAborting())
        {
            mfn_NotifyDisconnection(*ptspTrueResult, psl);
            NEW_CALLSTATE(pLine, LINECALLSTATE_IDLE, 0, psl);
            pCall->dwState &= ~CALLINFO::fCALL_ACTIVE;
        }
        else
        {
            // This implies that there is a lineDrop or lineCloseCall
            // in effect. We won't handle the disconnection here.
            SLPRINTF0(psl, "NOT notifying callstate because aborting");
        }
    }
    else
    {
        mfn_TSPICompletionProc((DWORD)*pdwRequestID, lTspiRet, psl);
        //
        // We are going to fail lineMakeCall via the callback -- doing
        // so means TAPI will not call lineCloseCall, so we must cleanup
        // ourselves. If for some reason TAPI does call lineCloseCall,
        // lineCloseCall will fail because m_pLine->pCall will
        // be NULL -- whick is OK.
        //
        // Note that we get here even if this is a synchronous failure
        // of mfn_TH_CallMakeCall. The code in cdevline.cpp which processes
        // lineMakeCall (and launches mfn_TH_CallMakeCall) also
        // tries to unload the call if the failure is synchronous -- but
        // it first checks that m_pLine->pCall is not NULL, so it does fine.
        //
        mfn_UnloadCall(TRUE, psl);
        FL_ASSERT(psl, !m_pLine->pCall);
        pCall=NULL;
    }

end:

	FL_LOG_EXIT(psl, tspRet);
	return tspRet;
}


TSPRETURN
CTspDev::mfn_TH_CallMakeCall(
					HTSPTASK htspTask,
                    TASKCONTEXT *pContext,
					DWORD dwMsg,
					ULONG_PTR dwParam1,
					ULONG_PTR dwParam2,
					CStackLog *psl
					)
//
//  START: dwParam1  == TAPI request ID.
//
//  We could get called either directly in the context of TSPI_lineMakeCall
//  or from the deferred task handler.
//
//  In the former case, we don't need to call the completion callback
//  if we're failing synchronously, but in the latter case, we do need
//  to call the completion routine because TAPI will be expecting
//  a callback.
//
//  We must also keep track of whether we have returned success
//  (in which case the call is active as far as TAPI is concerned),
//  or failure, in which case the call handle is not valid.
//
{
    //
    // Context Use:
    //  dw0: *pdwRequestID
    //  dw1: *ptspTrueResult;
    //  dw2: none

	FL_DECLARE_FUNC(0xded1d0a9, "CTspDev::mfn_TH_CallMakeCall")
	FL_LOG_ENTRY(psl);
	TSPRETURN tspRet=FL_GEN_RETVAL(IDERR_CORRUPT_STATE);
	CALLINFO *pCall = m_pLine->pCall;

    ULONG_PTR *pdwRequestID             = &(pContext->dw0);
    TSPRETURN  *ptspTrueResult      = &(pContext->dw1);

    LONG lTspiRet = LINEERR_OPERATIONFAILED;
    //
    //  lTspiRet is the tspi return value in case we fail the lineMakeCall,
    //  either sync or async.


    enum
    {
    MAKECALL_OPEN_COMPLETE,
    MAKECALL_PREDIALCOMMAND_COMPLETE,
    MAKECALL_PRE_TRM_COMPLETE,
    MAKECALL_MANUAL_DIAL_COMPLETE,
    MAKECALL_DIAL_COMPLETE,
    MAKECALL_POST_TRM_COMPLETE,
    MAKECALL_CLEANUP_COMPLETE
    };

    switch(dwMsg)
    {
    default:
        FL_SET_RFR(0xbbe5ff00, "Unknown Msg");
        goto end;

    case MSG_START:
        goto start;

	case MSG_SUBTASK_COMPLETE:
        tspRet = dwParam2;

        // We force tspRet to failure
        // in the special case that the call is being aborted so that it
        // doesn't continue with the state diagram.
        //
        // TODO: Implement AbortTask/SubTask to deal with this sort of thing.
        //
        if (pCall->IsAborting() && !tspRet)
        {
            tspRet = IDERR_OPERATION_ABORTED;
        }

        switch(dwParam1) // Param1 is Subtask ID
        {
        case MAKECALL_OPEN_COMPLETE:    goto open_complete;
        case MAKECALL_PREDIALCOMMAND_COMPLETE:    goto predialcommand_complete;
        case MAKECALL_PRE_TRM_COMPLETE: goto pre_term_complete;
        case MAKECALL_MANUAL_DIAL_COMPLETE: goto manual_dial_complete;
        case MAKECALL_DIAL_COMPLETE:    goto dial_complete;
        case MAKECALL_POST_TRM_COMPLETE:goto post_term_complete;
        case MAKECALL_CLEANUP_COMPLETE: goto cleanup_complete;
        }
        break;

    case MSG_DUMPSTATE:
        tspRet = 0;
        goto end;
    }

    ASSERT(FALSE);


    // The following code would be straightline code with no labels if all the
    //  async calls ompleted aynchronously, or were implemented using fibers.
    //  In other words, this is is our homebrew implementation of fibers.

start:

    *pdwRequestID = dwParam1; // save context..


    //
    // Open the modem device.
    // mfn_OpenLLDev keeps a ref count so ok to call if already loaded.
    //

    {
        ASSERT(!pCall->dwLLDevResources);
        DWORD dwLLDevResources = LLDEVINFO::fRESEX_USELINE;
        //
        //                        ^ this means we want to use the line
        //                          for going off hook.

        if (pCall->IsVoice())
        {
            dwLLDevResources |= LLDEVINFO::fRES_AIPC;
            //
            //                  ^ this means we want to use the AIPC server.
            //
        }

        tspRet =  mfn_OpenLLDev(
                        dwLLDevResources,
                        0,
                        TRUE,          // fStartSubTask
                        htspTask,
                        MAKECALL_OPEN_COMPLETE,
                        psl
                        );

        if (!tspRet  || IDERR(tspRet)==IDERR_PENDING)
        {
            //
            // Note: Even if mfn_OpenLLDev fails Asynchronously, we're still
            // open with the requested resources, and to cleanup we need to
            // mfn_CloseLLDev specifying the same resources we claimed here.
            //
            pCall->SetStateBits(CALLINFO::fCALL_OPENED_LLDEV);
            pCall->dwLLDevResources = dwLLDevResources;
        }
    }

    if (IDERR(tspRet)==IDERR_PENDING) goto end;

open_complete:

#if 1
    //
    //  1/3/1997 JosephJ If this is a data call and we have a pre-dial
    //                   command, issue it -- this is for dynamic protocol
    //
    //  4/5/1998 JosephJ We allocate our own copy here JUST BECAUSE
    //           while we're in the process of executing this multiple
    //           command sequence the app may call lineSetDevConfig which
    //            could result in m_Settings.szzPreDialCommands being changed.
    //           So just for that prett unlikely situation, we must
    //           allocate our own copy every time here...
    //
    if ( (tspRet == ERROR_SUCCESS)
          &&
         (0 != memcmp(m_Settings.pDialInCommCfg, m_Settings.pDialOutCommCfg, m_Settings.pDialInCommCfg->dwSize))
          &&
         (m_pLine->Call.dwCurMediaModes & LINEMEDIAMODE_DATAMODEM)) {


        tspRet = mfn_StartSubTask (
                htspTask,
                &CTspDev::s_pfn_TH_LLDevUmInitModem,
                MAKECALL_PREDIALCOMMAND_COMPLETE,
                TRUE,  // use dialout commconfig
                0,  // dwParam2 (unused)
                psl
                );

        if (IDERR(tspRet)==IDERR_PENDING) goto end;
    }
#endif

predialcommand_complete:



    if (tspRet)
    {
        // Sync or async failure: We make lineMakeCall fail with
        // RESOURCE_UNAVAIL...
        //
        mfn_ProcessHardwareFailure(psl);
        lTspiRet = LINEERR_RESOURCEUNAVAIL;
        goto cleanup;
    }

    // If a dialog instance is not required,
    // this is a no-op
    tspRet = mfn_CreateDialogInstance ((DWORD)*pdwRequestID,
                                       psl);

    if (tspRet)
    {
        lTspiRet = LINEERR_OPERATIONFAILED;
        goto cleanup;
    }

    ASSERT(m_pLine);
    ASSERT(m_pLine->pCall);

    if ( (NULL != m_pLine->pCall->TerminalWindowState.htDlgInst) &&
         (m_pLine->pCall->TerminalWindowState.dwOptions & UMTERMINAL_PRE) )
    {
        tspRet = mfn_StartSubTask (htspTask,
                                   &CTspDev::s_pfn_TH_CallStartTerminal,
                                   MAKECALL_PRE_TRM_COMPLETE,
                                   UMTERMINAL_PRE,
                                   0,
                                   psl);
    }

    if (IDERR(tspRet)==IDERR_PENDING)
    {
        goto end;
    }

pre_term_complete:

    if (tspRet)
    {
        if (IDERR(tspRet) == IDERR_OPERATION_ABORTED)
        {
            // Operation was cancelled by user
            // We complete the lineMakecall, and then treate it like
            // a user-cancelled disconnection...
            //
            pCall->dwState |= CALLINFO::fCALL_ACTIVE;
            mfn_TSPICompletionProc((DWORD)*pdwRequestID, 0, psl);
        }
        else
        {
            lTspiRet = LINEERR_OPERATIONFAILED;
        }
        goto cleanup;
    }


    //
    //  MANUAL DIAL (OPTIONAL)
    //
    //      Manual dial puts up a dialog in the apps context -- the
    //      user is instructed to dial some other way (typically with
    //      a handset, or a separate phone sharing the line. Once the user
    //      hears the remote side being picked up, he/she closes the dialog,
    //      whereapon we move to the next stage. The next stage for us
    //      is to do a UmDialModem, but with an empty dial string and
    //      specifying BLIND dial.
    //
    if ( (NULL != m_pLine->pCall->TerminalWindowState.htDlgInst) &&
         (m_pLine->pCall->TerminalWindowState.dwOptions & UMMANUAL_DIAL) )
    {
        tspRet = mfn_StartSubTask (htspTask,
                                   &CTspDev::s_pfn_TH_CallStartTerminal,
                                   MAKECALL_MANUAL_DIAL_COMPLETE,
                                   UMMANUAL_DIAL,
                                   0,
                                   psl);
    }

    if (IDERR(tspRet)==IDERR_PENDING)
    {
        goto end;
    }

manual_dial_complete:

    if (tspRet)
    {
        if (IDERR(tspRet) == IDERR_OPERATION_ABORTED)
        {
            // Operation was cancelled by user
            // We complete the lineMakecall, and then treate it like
            // a user-cancelled disconnection...
            //
            pCall->dwState |= CALLINFO::fCALL_ACTIVE;
            mfn_TSPICompletionProc((DWORD)*pdwRequestID, 0, psl);
        }
        else
        {
            lTspiRet = LINEERR_OPERATIONFAILED;
        }
        goto cleanup;
    }

    //
    // Let's actually dial...
    //
    {

        PFN_CTspDev_TASK_HANDLER *ppfnHandler = &CTspDev::s_pfn_TH_LLDevUmDialModem;


        DWORD dwFlags =  DIAL_FLAG_ORIGINATE; // TODO
        CHAR  *szAddress = pCall->szAddress;

        if (!mfn_IS_NULL_MODEM())
        {
            CHAR  *szAddress2;

            pCall->bDialTone = (szAddress[0] == '\0');

            szAddress2 = szAddress;
            while(*szAddress2 != '\0')
            {
                if (*szAddress2 == ';')
                {
                    *szAddress2 = '\0';
                    pCall->bDialTone = 1;
                } else
                {
                    szAddress2++;
                }
            }

            if (pCall->bDialTone)
            {
                dwFlags = 0;
            }
        }

        if (pCall->TerminalWindowState.dwOptions & UMMANUAL_DIAL) {
            //
            // For manual dial, we do a blind dial with an empty string...
            //

            szAddress = "";
            dwFlags |= DIAL_FLAG_BLIND;
        }



        if (m_Line.Call.dwDialOptions & MDM_TONE_DIAL)
        {
            dwFlags |= DIAL_FLAG_TONE;
        }

        if (m_Line.Call.dwDialOptions & MDM_BLIND_DIAL)
        {
            dwFlags |= DIAL_FLAG_BLIND;
        }

        if (m_Line.Call.dwCurMediaModes & LINEMEDIAMODE_DATAMODEM)
        {
            dwFlags |=  DIAL_FLAG_DATA;
        }
        else if (m_Line.Call.dwCurMediaModes & LINEMEDIAMODE_AUTOMATEDVOICE)
        {
            dwFlags |= DIAL_FLAG_AUTOMATED_VOICE
                        |  DIAL_FLAG_VOICE_INITIALIZE;
            // TODO: DIAL_FLAG_VOICE_INITIALIZE should only be specified in
            //          the first call to Dial -- subsequent calls
            //          (lineDial...) should not have this flag specified.
            //
        }
        else
        {

            if (mfn_CanDoVoice()) {
                //
                //  this is a voice modem, let dial a voice call
                //
                dwFlags |=  DIAL_FLAG_VOICE_INITIALIZE;

            } else {
                //
                //  this a data only modem and we are attempting to dial an interactive
                //  voice call. We will dial the call and put up a talk drop dialog
                //  to allow the user to cause the modem to hangup so the handset is
                //  connected to the line
                //
                dwFlags &=  ~DIAL_FLAG_ORIGINATE;

                ppfnHandler = &CTspDev::s_pfn_TH_CallMakeTalkDropCall;

            }

            dwFlags |= DIAL_FLAG_INTERACTIVE_VOICE;
        }


        // Dial away....
        //
        tspRet = mfn_StartSubTask (
                            htspTask,
                            ppfnHandler,
                            MAKECALL_DIAL_COMPLETE,
                            dwFlags,
                            (ULONG_PTR) szAddress,
                            psl
                            );
    }

    if (!tspRet || IDERR(tspRet) == IDERR_PENDING)
    {
        // Set call state to active and notify TAPI of completion here,
        // rather than wait for after the dial completes.

	if (pCall->bDialTone)
	{
		mfn_TSPICompletionProc((DWORD)*pdwRequestID, 0, psl);

		NEW_CALLSTATE(m_pLine, LINECALLSTATE_DIALTONE, 0, psl);

	} else
	{
		pCall->dwState |= CALLINFO::fCALL_ACTIVE;

		mfn_TSPICompletionProc((DWORD)*pdwRequestID, 0, psl);

		NEW_CALLSTATE(m_pLine, LINECALLSTATE_DIALING, 0, psl);
		NEW_CALLSTATE(m_pLine, LINECALLSTATE_PROCEEDING, 0, psl);
	}
    }

    if (IDERR(tspRet)==IDERR_PENDING) goto end;

dial_complete:
    if (tspRet)
    {
        lTspiRet = LINEERR_OPERATIONFAILED;
        goto cleanup;
    }

    ASSERT(m_pLine);
    ASSERT(m_pLine->pCall);

    if ( (NULL != m_pLine->pCall->TerminalWindowState.htDlgInst) &&
         (m_pLine->pCall->TerminalWindowState.dwOptions & UMTERMINAL_POST) )
    {
        tspRet = mfn_StartSubTask (htspTask,
                                   &CTspDev::s_pfn_TH_CallStartTerminal,
                                   MAKECALL_POST_TRM_COMPLETE,
                                   UMTERMINAL_POST,    // got to passthrough
                                   0,
                                   psl);
    }

    if (IDERR(tspRet)==IDERR_PENDING)
    {
        goto end;
    }

post_term_complete:
    if (!tspRet)
    {
        // IsActive indicates that we've completed the async TSPI_lineMakeCall.
        //
        ASSERT(pCall->IsActive());
        // If a dialog instance is not created,
        // this is a no-op
        mfn_FreeDialogInstance ();

	if (!pCall->bDialTone)
	{
		mfn_HandleSuccessfulConnection(psl);
	}

#if (TAPI3)
        if (m_pLine->T3Info.MSPClients > 0) {
//        if (pCall->IsMSPCall())
//        {
            mfn_SendMSPCmd(
                pCall,
                CSATSPMSPCMD_CONNECTED,
                psl
                );
        }
#endif  // TAPI3

        goto end;
    }

cleanup:

    // If a dialog instance is not created,
    // this is a no-op
    mfn_FreeDialogInstance ();
    // Failure ...
    *ptspTrueResult = tspRet; // save it away so we report
                              // the correct status when we're done
                              // cleaning up.

    if (pCall->bDialTone)
    {
	    goto end;
    }

    if (pCall->IsOpenedLLDev())
    {
        tspRet = mfn_CloseLLDev(
                    pCall->dwLLDevResources,
                    TRUE,
                    htspTask,
                    MAKECALL_CLEANUP_COMPLETE,
                    psl
                    );
        //
        // even on failure (shouldn't get failure) we clear our
        // bit indicating we'd opened the lldev....
        //
        pCall->ClearStateBits(CALLINFO::fCALL_OPENED_LLDEV);
        pCall->dwLLDevResources = 0;
    }

cleanup_complete:

    if (IDERR(tspRet)==IDERR_PENDING) goto end;

    if (tspRet)
    {
        // If there was a problem during cleanup, we treat it
        // like a hw error
        //
        pCall->dwState |=  CALLINFO::fCALL_HW_BROKEN;
        tspRet = 0;
    }
    else
    {
        // If cleanup was successful, we clear the hw-error bit, even
        // if it was set, because the monitor and init went OK...
        pCall->dwState &=  ~CALLINFO::fCALL_HW_BROKEN;
    }

    //
    // Ignore failure during cleanup...
    //
    tspRet = 0;

    // IsActive indicates that we've completed the async TSPI_lineMakeCall.
    //
    if (pCall->IsActive())
    {
        if (!pCall->IsAborting())
        {
            mfn_NotifyDisconnection(*ptspTrueResult, psl);
            NEW_CALLSTATE(pLine, LINECALLSTATE_IDLE, 0, psl);
            pCall->dwState &= ~CALLINFO::fCALL_ACTIVE;
        }
        else
        {
            // This implies that there is a lineDrop or lineCloseCall
            // in effect. We won't handle the disconnection here.
            SLPRINTF0(psl, "NOT notifying callstate because aborting");
        }
    }
    else
    {
        mfn_TSPICompletionProc((DWORD)*pdwRequestID, lTspiRet, psl);
        //
        // We are going to fail lineMakeCall via the callback -- doing
        // so means TAPI will not call lineCloseCall, so we must cleanup
        // ourselves. If for some reason TAPI does call lineCloseCall,
        // lineCloseCall will fail because m_pLine->pCall will
        // be NULL -- whick is OK.
        //
        // Note that we get here even if this is a synchronous failure
        // of mfn_TH_CallMakeCall. The code in cdevline.cpp which processes
        // lineMakeCall (and launches mfn_TH_CallMakeCall) also
        // tries to unload the call if the failure is synchronous -- but
        // it first checks that m_pLine->pCall is not NULL, so it does fine.
        //
        mfn_UnloadCall(TRUE, psl);
        FL_ASSERT(psl, !m_pLine->pCall);
        pCall=NULL;
    }

end:

	FL_LOG_EXIT(psl, tspRet);
	return tspRet;

}



TSPRETURN
CTspDev::mfn_TH_CallMakePassthroughCall(
					HTSPTASK htspTask,
					//void *pvContext,
                    TASKCONTEXT *pContext,
					DWORD dwMsg,
					ULONG_PTR dwParam1,
					ULONG_PTR dwParam2,
					CStackLog *psl
					)
//
//  START: dwParam1  == TAPI request ID.
//
//  We could get called either directly in the context of TSPI_lineMakeCall
//  or from the deferred task handler.
//
//  In the former case, we don't need to call the completion callback
//  if we're failing synchronously, but in the latter case, we do need
//  to call the completion routine because TAPI will be expecting
//  a callback.
//
//  We must also keep track of whether we have returned success
//  (in which case the call is active as far as TAPI is concerned),
//  or failure, in which case the call handle is not valid.
//
{
    //
    // Context Use:
    //  dw0: *pdwRequestID
    //

	FL_DECLARE_FUNC(0xe30ecd42, "CTspDev::mfn_TH_CallMakePassthroughCall")
	FL_LOG_ENTRY(psl);
	TSPRETURN tspRet= IDERR_CORRUPT_STATE;
	CALLINFO *pCall = m_pLine->pCall;
    ULONG_PTR *pdwRequestID             = &(pContext->dw0);

    FL_ASSERT(psl, pCall->IsPassthroughCall());

    enum
    {
    MAKEPTCALL_OPEN_COMPLETE,
    MAKEPTCALL_CLEANUP_COMPLETE
    };


    switch(dwMsg)
    {
    default:
        FL_SET_RFR(0xa596d200, "Unknown Msg");
        goto end;

    case MSG_START:
        goto start;

	case MSG_SUBTASK_COMPLETE:
        tspRet = dwParam2;

        // We force tspRet to failure
        // in the special case that the call is being aborted so that it
        // doesn't continue with the state diagram.
        //
        // TODO: Implement AbortTask/SubTask to deal with this sort of thing.
        //
        if (pCall->IsAborting() && !tspRet)
        {
            tspRet = IDERR_OPERATION_ABORTED;
        }

        switch(dwParam1) // Param1 is Subtask ID
        {
        case MAKEPTCALL_OPEN_COMPLETE:           goto open_complete;
        case MAKEPTCALL_CLEANUP_COMPLETE:        goto cleanup_complete;
        }
        break;

    case MSG_DUMPSTATE:
        tspRet = 0;
        goto end;
    }

    ASSERT(FALSE);


start:

        *pdwRequestID = dwParam1; // save context..

    //
    // Open the modem device.
    // mfn_OpenLLDev keeps a ref count so ok to call if already loaded.
    //
    {
        ASSERT(!pCall->dwLLDevResources);
        DWORD dwLLDevResources =  LLDEVINFO::fRESEX_USELINE
        //
        //                        ^ this means we want to use the line
        //                          for going off hook.
        //
                                | LLDEVINFO::fRESEX_PASSTHROUGH;
        //
        //                        ^ this means we want to enable passthrough.
        //


        tspRet =  mfn_OpenLLDev(
                        dwLLDevResources,
                        0,              // dwMonitorFlag -- unused
                        TRUE,           // fStartSubTask
                        htspTask,
                        MAKEPTCALL_OPEN_COMPLETE,
                        psl
                        );

        if (!tspRet  || IDERR(tspRet)==IDERR_PENDING)
        {
            //
            // Note: Even if mfn_OpenLLDev fails Asynchronously, we're still
            // open with the requested resources, and to cleanup we need to call
            // mfn_CloseLLDev specifying the same resources we claimed here.
            //
            pCall->SetStateBits(CALLINFO::fCALL_OPENED_LLDEV);
            pCall->dwLLDevResources = dwLLDevResources;
        }

    }

   if (IDERR(tspRet)==IDERR_PENDING) goto end;

open_complete:

    if (!tspRet)
    {
        // success ....

        // Because the sequence is first to complete the async lineMakecall
        // and THEN send callstate CONNECTED, we do the completion
        // here instead of relying on the parent task to complete it.
        //

        pCall->dwState |= CALLINFO::fCALL_ACTIVE;

        mfn_TSPICompletionProc((DWORD)*pdwRequestID, 0, psl);

        NEW_CALLSTATE(m_pLine, LINECALLSTATE_CONNECTED, 0, psl);
        goto end;
    }

    // Failure ...
    //
    // We want to deal with failure during cleanup as a h/w failure, so
    // we start by clearing tspRet.
    //
    tspRet = 0;

    if (pCall->IsOpenedLLDev())
    {
        tspRet = mfn_CloseLLDev(
                    pCall->dwLLDevResources,
                    TRUE,
                    htspTask,
                    MAKEPTCALL_CLEANUP_COMPLETE,
                    psl
                    );
        //
        // even on failure we clear our
        // bit indicating we'd opened the lldev....
        //
        pCall->ClearStateBits(CALLINFO::fCALL_OPENED_LLDEV);
        pCall->dwLLDevResources = 0;
    }

    if (IDERR(tspRet)==IDERR_PENDING) goto end;

cleanup_complete:

    FL_ASSERT(psl, !(pCall->IsActive()));

    // Sync or Async failure: we make lineMakeCall fail with
    // RESOURCE_UNAVAIL...
    //
    mfn_TSPICompletionProc((DWORD)*pdwRequestID, LINEERR_RESOURCEUNAVAIL, psl);


    if (tspRet)
    {
        // If there was a problem during cleanup, we treat it
        // like a hw error
        //
        pCall->dwState |=  CALLINFO::fCALL_HW_BROKEN;
        tspRet = 0;
    }

    //
    // We are going to fail TSPI_lineMakeCall -- doing
    // so means TAPI will not call lineCloseCall, so we must cleanup
    // ourselves. See more comments under TH_CallMakeCall...
    //
    mfn_UnloadCall(TRUE, psl);
    FL_ASSERT(psl, !m_pLine->pCall);
    pCall=NULL;

end:

	FL_LOG_EXIT(psl, tspRet);
	return tspRet;
}



TSPRETURN
CTspDev::mfn_TH_CallDropCall(
					HTSPTASK htspTask,
                    TASKCONTEXT *pContext,
					DWORD dwMsg,
					ULONG_PTR dwParam1,
					ULONG_PTR dwParam2,
					CStackLog *psl
					)
//
//  START: dwParam1  == TAPI request ID.
//
//  We could get called either directly in the context of TSPI_lineDrop
//  or from the deferred task handler.
//
//  In the former case, we don't need to call the completion callback
//  if we're failing synchronously, but in the latter case, we do need
//  to call the completion routine because TAPI will be expecting
//  a callback.
//
{
	FL_DECLARE_FUNC(0x45a9fa21, "CTspDev::mfn_TH_CallDropCall")
	FL_LOG_ENTRY(psl);
	TSPRETURN  tspRet= IDERR_CORRUPT_STATE;
    LINEINFO *pLine = m_pLine;
    CALLINFO *pCall = pLine->pCall;
    ULONG_PTR *pdwRequestID             = &(pContext->dw0);

    enum {
        DROPCALL_CLOSE_COMPLETE
    };

    switch(dwMsg)
    {
    case MSG_START:
        *pdwRequestID = dwParam1; // save context..
        goto start;

	case MSG_SUBTASK_COMPLETE:
        tspRet = dwParam2;
        switch(dwParam1) // Param1 is Subtask ID
        {
        case DROPCALL_CLOSE_COMPLETE:        goto close_complete;

        default:
	        FL_SET_RFR(0x27fc4e00, "invalid subtask");
            goto end;
        }
        break;

    case MSG_DUMPSTATE:
        tspRet = 0;
        goto end;

    default:
        FL_SET_RFR(0xa706a600, "Unknown Msg");
        goto end;
    }

    ASSERT(FALSE);

start:

    tspRet = 0;

    // This call could have been queued and so now there's no call to drop....
    if (!pCall || !pCall->IsActive())
    {
        mfn_TSPICompletionProc((DWORD)*pdwRequestID, 0, psl);
        goto end;
    }


    if (pCall->IsOpenedLLDev())
    {
        tspRet = mfn_CloseLLDev(
                    pCall->dwLLDevResources,
                    TRUE,
                    htspTask,
                    DROPCALL_CLOSE_COMPLETE,
                    psl
                    );
        //
        // even on failure  we clear our
        // bit indicating we'd opened the lldev....
        //
        pCall->ClearStateBits(CALLINFO::fCALL_OPENED_LLDEV);
        pCall->dwLLDevResources = 0;
    }

    if (IDERR(tspRet)==IDERR_PENDING) goto end;

close_complete:


    if(mfn_Handset())
    {
        //
        // Set default values for handset
        //
        m_LLDev.HandSet.dwVolume = 0xffff;
        m_LLDev.HandSet.dwGain   = 0xffff;
        m_LLDev.HandSet.dwMode   = PHONEHOOKSWITCHMODE_ONHOOK;
    }

    if (mfn_IsSpeaker())
    {
        //
        // Set default values for speakerphone
        //
        m_LLDev.SpkrPhone.dwVolume = 0xffff;
        m_LLDev.SpkrPhone.dwGain   = 0xffff;
        m_LLDev.SpkrPhone.dwMode   = PHONEHOOKSWITCHMODE_ONHOOK;
    }

    mfn_NotifyDisconnection(0, psl);

    NEW_CALLSTATE(pLine, LINECALLSTATE_IDLE, 0, psl);
    pCall->dwState &= ~CALLINFO::fCALL_ACTIVE;


    if (tspRet)
    {
        // If there was a problem during hangup, we treat it
        // like a hw error, but make TH_CallDropCall return
        // success anyways...
        //
        pCall->dwState |=  CALLINFO::fCALL_HW_BROKEN;
        tspRet = 0;
    }
    else
    {
        // If hangup was successful, we clear the hw-error bit, even
        // if it was set, because the monitor and init went OK...
        pCall->dwState &=  ~CALLINFO::fCALL_HW_BROKEN;
    }

    mfn_TSPICompletionProc((DWORD)*pdwRequestID, 0, psl);

end:

	FL_LOG_EXIT(psl, tspRet);
	return tspRet;
}


// 1/21/1997 JosephJ adapated from similarly-named function in NT4.0 unimodem
//                   (mdmutil.c)
//
// Major changes:
//    *  Since we explicitly refer to 'T' 'P', and special characters,
//       I don't call WideCharToMultyByte and instead directly refer to
//       the input WCHAR characters.
//
// Note *pfTone is not modified if InAddress doesn't contain a T or P.
//
LONG CTspDev::mfn_ConstructDialableString(
                     LPCTSTR  lptszInAddress,
                     LPSTR  lpszOutAddress,
                     UINT cbOutLen,
                     BOOL *pfTone)
{
    LPCTSTR  lptszSrc;

    DWORD dwDevCapFlags     = m_StaticInfo.dwDevCapFlags;
    DWORD dwWaitBong        = m_Settings.dwWaitBong;
    BOOL  fPartialDialing   = m_StaticInfo.fPartialDialing;

    LONG lRet = ERROR_SUCCESS;

    if (!lptszInAddress || !*lptszInAddress)
    {
        *lpszOutAddress = 0;
        return ERROR_SUCCESS;
    }

    // tone or pulse?  set *pfTone appropriately
    // also, set lptszSrc
    //
    if (*lptszInAddress == 'T' || *lptszInAddress == 't')  // tone
    {
        lptszSrc = lptszInAddress + 1;
        *pfTone = TRUE;
    }
    else
    {
        if (*lptszInAddress == 'P' || *lptszInAddress == 'p')  // pulse
        {
            lptszSrc = lptszInAddress + 1;
            *pfTone = FALSE;
        }
        else
        {
            lptszSrc = lptszInAddress;
        }
    }

    // copy In to Out scanning for various dialoptions, returning error if we
    // don't support something.
    //
    //   Note that lptszSrc is TCHAR, i.e., potentially UNICODE.
    while (*lptszSrc && cbOutLen)
    {
        switch (*lptszSrc)
        {
        case '$':
            if (!(dwDevCapFlags & LINEDEVCAPFLAGS_DIALBILLING))
            {
              UINT  cCommas;

              // Get the wait-for-bong period
              //
              cCommas = dwWaitBong;

              // Calculate the number of commas we need to insert
              //
              cCommas = (cCommas/UMINC_WAIT_BONG) +
                        (cCommas%UMINC_WAIT_BONG ? 1 : 0);

              // Insert the strings of commas
              //
              while (cbOutLen && cCommas)
              {
                *lpszOutAddress++ = ',';
                cbOutLen--;
                cCommas--;
              };
              goto Skip_This_Character;
            }
            break;

        case '@':
            if (!(dwDevCapFlags & LINEDEVCAPFLAGS_DIALQUIET))
            {
                lRet = LINEERR_DIALQUIET;
                goto end;
            }
            break;

        case 'W':
        case 'w':
            if (!(dwDevCapFlags & LINEDEVCAPFLAGS_DIALDIALTONE))
            {
                lRet =  LINEERR_DIALDIALTONE;
                goto end;
            }
            break;

        case '?':
            lRet = LINEERR_DIALPROMPT;
            goto end;

        case '|':  // subaddress
        case '^':  // name field
            goto Skip_The_Rest;

        case ';':
            if (!fPartialDialing)
            {
                lRet =  LINEERR_INVALADDRESS;
                goto end;
            }

            // This signifies the end of a dialable address.
            // Use it and skip the rest.
            //
            *lpszOutAddress++ = (CHAR) *lptszSrc;
            goto Skip_The_Rest;

        case ' ':
    //  case '-': <- 11/20/97 JosephJ Commented this out:
    //                  Bug 109644: Richochet modems want the '-' to be
    //                  preserved, and JDecuir says that no modem he knows
    //                  has problems with '-' -- so we preserve it!

           // skip these characters
            //
            goto Skip_This_Character;
        }

        // Copy this character
        //
        *lpszOutAddress++ = (CHAR) *lptszSrc;
        cbOutLen--;

Skip_This_Character:
        lptszSrc++;
    }

    // Did we run out of space in the outgoing buffer?
    //
    if (*lptszSrc && cbOutLen == 0)
    {
        // yes
        lRet = LINEERR_INVALADDRESS;
    }

Skip_The_Rest:
    *lpszOutAddress = 0;
    lRet =  ERROR_SUCCESS;

end:
    return lRet;

}

void
CTspDev::mfn_GetCallStatus(
        LPLINECALLSTATUS lpCallStatus
)
{
    CALLINFO *pCall = m_pLine->pCall;
    DWORD dwCallState = pCall->dwCallState;
    DWORD dwCallStateMode = pCall->dwCallStateMode;
    DWORD dwCallFeatures  = 0;
    DWORD dwCurMediaModes = pCall->dwCurMediaModes;


  if (!pCall->IsPassthroughCall())
  {
    switch(dwCallState)
    {
      case LINECALLSTATE_OFFERING:
        dwCallFeatures  = LINECALLFEATURE_ACCEPT |
                                        LINECALLFEATURE_SETCALLPARAMS |
                                        LINECALLFEATURE_DROP;
        // We can only answer if a possible media mode is DATAMODEM.
        if (dwCurMediaModes & LINEMEDIAMODE_DATAMODEM)
        {
          dwCallFeatures |= LINECALLFEATURE_ANSWER;
        }
        break;

      case LINECALLSTATE_DIALTONE:
        dwCallFeatures  = LINECALLFEATURE_DROP;
        break;

      case LINECALLSTATE_DIALING:
        dwCallFeatures  = LINECALLFEATURE_DROP;

        // 9/6/1997 JosephJ TODO: this was in NT4.0. In NT5 we do not
        //          detailed state explicitly like this, and not having this
        //          enabled doesn't seem to have caused problems, so it
        //          stays commented out until further notice...
        //
        //if (DEVST_PORTCONNECTWAITFORLINEDIAL == dwDevState)
        //{
        //  dwCallFeatures |= LINECALLFEATURE_DIAL;
        //}
        break;

      case LINECALLSTATE_ACCEPTED:
        dwCallFeatures  = LINECALLFEATURE_SETCALLPARAMS |
                                        LINECALLFEATURE_DROP;
        // We can only answer if a possible media mode is DATAMODEM.
        if (dwCurMediaModes & LINEMEDIAMODE_DATAMODEM)
        {
          dwCallFeatures |= LINECALLFEATURE_ANSWER;
        }
        break;

      case LINECALLSTATE_CONNECTED:
        dwCallFeatures  = LINECALLFEATURE_SETCALLPARAMS |
                                        LINECALLFEATURE_DROP;
        if (mfn_CanDoVoice())
        {
            DWORD dwProps = m_StaticInfo.Voice.dwProperties;
            if (dwProps & fVOICEPROP_MONITOR_DTMF)
            {
                lpCallStatus->dwCallFeatures |= LINECALLFEATURE_MONITORDIGITS;
            }

            if (dwProps & fVOICEPROP_MONITORS_SILENCE)
            {
                lpCallStatus->dwCallFeatures |= LINECALLFEATURE_MONITORTONES;
            }

            if (dwProps & fVOICEPROP_GENERATE_DTMF)
            {
                lpCallStatus->dwCallFeatures |= LINECALLFEATURE_GENERATEDIGITS;
            }
        }

        break;

      case LINECALLSTATE_UNKNOWN:
      case LINECALLSTATE_PROCEEDING:
      case LINECALLSTATE_DISCONNECTED:
        dwCallFeatures  = LINECALLFEATURE_DROP;
        break;

      case LINECALLSTATE_IDLE:
      default:
        dwCallFeatures  = 0;
        break;
    };
  }
  else
  {
    // Make sure the call feature are all off in takeover mode;
    //
    dwCallFeatures = 0;
  };

  lpCallStatus->dwCallState     = dwCallState;
  lpCallStatus->dwCallStateMode = dwCallStateMode;
  lpCallStatus->dwCallFeatures  = dwCallFeatures;
  lpCallStatus->tStateEntryTime = pCall->stStateChange;

}


// Note: NULL pParams indicates incoming call, else indicates outgoing call...
//
TSPRETURN
CTspDev::mfn_LoadCall(


    TASKPARAM_TSPI_lineMakeCall *pParams,


    LONG *plRet,
    CStackLog *psl
    )
{
    LONG lRet = 0;
    TSPRETURN tspRet = 0;
	FL_DECLARE_FUNC(0xdaf3d4a0, "CTspDev::mfn_LoadCall")
	FL_LOG_ENTRY(psl);
	FL_ASSERT(psl, m_pLine == &m_Line);
    LPCTSTR lptszDestAddress = (pParams)? pParams->lpszDestAddress: NULL;
    LPLINECALLPARAMS const lpCallParams = (pParams)? pParams->lpCallParams:NULL;
    DWORD dwDialOptions=0;
    BOOL fPassthroughCall = FALSE;

    if (m_Line.pCall)
    {
	    FL_SET_RFR(0x4e05cb00, "Call already exists!");
	    lRet = LINEERR_CALLUNAVAIL;
	    goto end;
    }

    // Note m_Line.Call should be all zeros when it is in the unloaded state.
    // If it is not, it is an assertfail condition. We keep things clean
    // this way.
    //
    FL_ASSERT(
        psl,
        validate_DWORD_aligned_zero_buffer(
                &(m_Line.Call),
                sizeof (m_Line.Call)));

    if (!pParams)
    {
        // Initialize pCall on 1st incoming ring....
        // From NT4.0

        FL_ASSERT(psl, NULL == m_Line.Call.hTimer);
        if (NULL != m_Line.Call.hTimer)
        {
            // We seem to have a ring timer;
            // close it first
            CloseHandle (m_Line.Call.hTimer);
        }

        //
        //  create a timer so we can detect the modem stopping ringing.
        //  and tell the app the call went idle
        //
        m_Line.Call.hTimer = CreateWaitableTimer (NULL, TRUE, NULL);

        if (m_Line.Call.hTimer == NULL) {
            //
            //  could not get a timer, can't proceed
            //
            goto end_cleanup;
        }


        // TODO: further checks...

        // OR in UNKNOWN since we don't know what kind of media mode this
        // call is
        m_Line.Call.dwCurMediaModes  =  m_pLine->dwDetMediaModes
                                        | LINEMEDIAMODE_UNKNOWN;

        // default our bearermode to be what we support, excluding the
        // passthrough bit
        //
        m_Line.Call.dwCurBearerModes =  m_StaticInfo.dwBearerModes
                                        & ~LINEBEARERMODE_PASSTHROUGH;

        m_Line.Call.dwState = CALLINFO::fCALL_INBOUND;

        goto load_device;
    }

    // Remainder of this function deals with the dialout case (pParms!=NULL)
    //

    // Set default dwDialOptions
    dwDialOptions  = m_StaticInfo.dwModemOptions
                     &  (MDM_TONE_DIAL | MDM_BLIND_DIAL);

    FL_ASSERT(psl, m_Settings.pDialOutCommCfg);
    dwDialOptions &= ((LPMODEMSETTINGS)(m_Settings.pDialOutCommCfg->wcProviderData))
                       ->dwPreferredModemOptions;


    if (lpCallParams)
    {
        // Takeover via BEARERMODE_PASSTHROUGH?
        if (lpCallParams->dwBearerMode & LINEBEARERMODE_PASSTHROUGH)
        {
            fPassthroughCall = TRUE;
        }

        // Validate media mode. It must be one of the supported media modes.
        // Furthermore, if this is not a passthrough call, we
        // support dialout only for DATAMODEM and INTERACTIVEVOICE calls

        #define DIALABLE_MEDIAMODES\
             (LINEMEDIAMODE_DATAMODEM \
              | LINEMEDIAMODE_INTERACTIVEVOICE \
              | LINEMEDIAMODE_AUTOMATEDVOICE)

        if (0 == lpCallParams->dwMediaMode)
        {
            lpCallParams->dwMediaMode = LINEMEDIAMODE_INTERACTIVEVOICE;
        }

        if ((lpCallParams->dwMediaMode & ~m_StaticInfo.dwDefaultMediaModes)
            ||
            (!fPassthroughCall
              &&
             !(lpCallParams->dwMediaMode & DIALABLE_MEDIAMODES)
           ))
        {
            FL_SET_RFR(0xd8f55f00, "Invalid MediaMode");
            lRet = LINEERR_INVALMEDIAMODE;
            goto end_cleanup;
        }

        // validate bearer mode
        if ((~m_StaticInfo.dwBearerModes) & lpCallParams->dwBearerMode)
        {
            FL_SET_RFR(0x0485b800, "Invalid BearerMode");
            lRet =  LINEERR_INVALBEARERMODE;
            goto end_cleanup;
        }

        if (lpCallParams->dwAddressType != 0) {
            //
            //  dwAddressType is set
            //
            if ((lpCallParams->dwAddressType & LINEADDRESSTYPE_PHONENUMBER) == 0) {
               //
               //  dwAddressType is not correct for modems
               //
               lRet =  LINEERR_INVALADDRESSTYPE;
               goto end_cleanup;
            }
        }


        if ((lpCallParams->dwDeviceConfigSize != 0) && (lpCallParams->dwDeviceClassSize != 0)) {
            //
            //  The app want's to change the dev config, validate the class string and call the
            //  the same helper function as tspi_LineSetDevConfig() would
            //

            UMDEVCFG *pDevCfgNew = (UMDEVCFG *) (LPVOID)(((LPBYTE)lpCallParams)+lpCallParams->dwDeviceConfigOffset);
            LPCTSTR lpszDeviceClass = (LPTSTR)((((LPBYTE)lpCallParams)+lpCallParams->dwDeviceClassOffset));
            DWORD dwDeviceClass =  parse_device_classes(
                                    lpszDeviceClass,
                                    FALSE);

            switch(dwDeviceClass) {

                case DEVCLASS_COMM:
                case DEVCLASS_COMM_DATAMODEM:
                case DEVCLASS_COMM_DATAMODEM_DIALOUT:

                // 1/29/1998 JosephJ.
                //      The following case is added for
                //      backwards compatibility with NT4 TSP, which
                //      simply checked if the class was a valid class,
                //      and treated all valid classes (including
                //      (comm/datamodem/portname) the same way
                //      for lineGet/SetDevConfig. We, however, don't
                //      allow comm/datamodem/portname here -- only
                //      the 2 above and two below represent
                //      setting DEVCFG
                //
                case DEVCLASS_TAPI_LINE:

                    tspRet = CTspDev::mfn_update_devcfg_from_app(
                                        pDevCfgNew,
                                        lpCallParams->dwDeviceConfigSize,
                                        FALSE,
                                        psl
                                        );
                    break;

                default:

                    FL_ASSERT(psl, FALSE);
            }

        }

        m_Line.Call.dwCurBearerModes = lpCallParams->dwBearerMode;
        m_Line.Call.dwCurMediaModes  = lpCallParams->dwMediaMode;

#if 0
        //
        //  BRL, 9/3/98 bug 218104
        //  lets, just use what the user puts in CPL
        //
        if (!(lpCallParams->dwCallParamFlags & LINECALLPARAMFLAGS_IDLE))
        {
            // Turn on blind dialing
            dwDialOptions |= MDM_BLIND_DIAL;
        }
#endif

        // TODO: should preserve other fields of call params for
        //  call info

    }
    else
    {
        // NULL lpCallParams, so set the standard defaults

        // use INTERACTIVEVOICE if we can, else use DATAMODEM
        if (m_StaticInfo.dwDefaultMediaModes & LINEMEDIAMODE_INTERACTIVEVOICE)
        {
          m_Line.Call.dwCurMediaModes = LINEMEDIAMODE_INTERACTIVEVOICE;
        }
        else
        {
            ASSERT(m_StaticInfo.dwDefaultMediaModes & LINEMEDIAMODE_DATAMODEM);
            m_Line.Call.dwCurMediaModes = LINEMEDIAMODE_DATAMODEM;
        }
        m_Line.Call.dwCurBearerModes = m_StaticInfo.dwBearerModes
                                       & ~LINEBEARERMODE_PASSTHROUGH;
    }

    m_Line.Call.TerminalWindowState.dwOptions = 0;
    if (LINEMEDIAMODE_DATAMODEM == m_Line.Call.dwCurMediaModes)
    {
        m_Line.Call.TerminalWindowState.dwOptions =
            m_Settings.dwOptions & (UMTERMINAL_PRE | UMTERMINAL_POST | UMMANUAL_DIAL);
    }

    // Following code rearranged extensively from NT4.0 lineMakeCall code.
    // Semantics not exactly preserved, but should effectively be the same.
    //

    m_Line.Call.szAddress[0] = '\0';

    if (!fPassthroughCall && !mfn_IS_NULL_MODEM())
    {
        // We are dialling using  a real modem
        //
        BOOL fTone =   (dwDialOptions &  MDM_TONE_DIAL) ? TRUE: FALSE;

        lRet =  mfn_ConstructDialableString(
                         lptszDestAddress,
                         m_Line.Call.szAddress,
                         sizeof(m_Line.Call.szAddress),
                         &fTone
                         );

        if (lRet)
        {

            // We treat a failed ValidateAddress on manual dial as a null
            // dial string.
            //
            if (m_Settings.dwOptions & UMMANUAL_DIAL)
            {
                m_Line.Call.szAddress[0] = '\0';
                lRet = 0;
            }
            else
            {
                FL_SET_RFR(0xf9599200, "Invalid Phone Number");
                goto end_cleanup;
            }
        }
        else
        {
            // mfn_ConstructDialableString may have modified fTone if the
            // dialable string contains a T or P prefix.
            //
            if (fTone)
            {
                dwDialOptions |= MDM_TONE_DIAL;
            }
            else
            {
                dwDialOptions &= ~MDM_TONE_DIAL;
            }
        }

        if (m_Settings.dwOptions & UMMANUAL_DIAL)
        {
            dwDialOptions |= MDM_BLIND_DIAL;
        }
        else
        {
            // Unimodem is responsible for dialing...

            if (!lptszDestAddress)
            {
                //
                // if the lpszDestAddress was NULL then we just want to do a
                // dialtone detection.  We expect that lineDial will be
                // called.
                // Setting the szAddress to ";" will do this.
                // TODO: perhaps make the "semicolon" character
                // configurable?
                //

//                lstrcpyA(m_Line.Call.szAddress, szSEMICOLON);
//
//  BRL 9/3/98
//  change this to send an empty string, and disable originate
//

                m_Line.Call.szAddress[0] = '\0';
                dwDialOptions &= ~DIAL_FLAG_ORIGINATE;

            }
            else if (!m_Line.Call.szAddress[0])
            {
                // We're not doing manual dial and the processed
                // dial string is empty. We should not expect dial tone.
                //
                dwDialOptions |= MDM_BLIND_DIAL;
            }
        }

    } // endif (not null modem and not fPassthroughCall)

	m_Line.Call.dwDialOptions  = dwDialOptions;

    m_Line.Call.htCall = pParams->htCall;


load_device:

    //
    // Determine if this is a class-8 voice call. This information is
    // used to determine if we need to start up the AIPC (async IPC)
    // mechanism.
    //
    if (mfn_CanDoVoice() &&
         (  (m_Line.Call.dwCurMediaModes & LINEMEDIAMODE_INTERACTIVEVOICE)
         || (m_Line.Call.dwCurMediaModes & LINEMEDIAMODE_AUTOMATEDVOICE)))
    {
        m_Line.Call.dwState |= CALLINFO::fCALL_VOICE;
    }


    //
    //  tell the platform driver about the call, so it will delay suspends, until the modem is
    //  hungup
    //
    CallBeginning();

    // Success ... doing this officially creates the call instance....
    m_Line.pCall = &m_Line.Call;

    // However it's status is still not active...
    FL_ASSERT(psl, !(m_Line.pCall->IsActive()));

    lRet=0;
    goto end;

end_cleanup:

    // We're careful about keeping the buffer which holds the CallInfo full
    // of zeros when the call is not defined, and assert this fact when
    // we try to allocate the call (see the "validate_..." call above).
    ZeroMemory(&m_Line.Call, sizeof(m_Line.Call));

    // Fall through...

end:

    if (tspRet && !lRet)
    {
        lRet = LINEERR_OPERATIONFAILED;
        tspRet = 0;
    }

    *plRet = lRet;

	FL_LOG_EXIT(psl, tspRet);
    return tspRet;
}


void
CTspDev::mfn_UnloadCall(BOOL fDontBlock, CStackLog *psl)
{
	FL_DECLARE_FUNC(0x888d2a98, "mfn_UnloadCall")
	FL_LOG_ENTRY(psl);
    LINEINFO *pLine = m_pLine;
    CALLINFO *pCall = (m_pLine) ? m_pLine->pCall: NULL;
    BOOL fHandleHWFailure = FALSE;
    TSPRETURN tspRet = 0;

    if (!pCall) goto end;

    FL_ASSERT(psl, pCall == &(m_Line.Call));

    // First thing, destroy the ring timer
    // if there is one (we don't want it to fire anymore)
    if (NULL != pCall->hTimer)
    {
        CancelWaitableTimer (pCall->hTimer);
        CloseHandle (pCall->hTimer);
        pCall->hTimer = NULL;
    }

    fHandleHWFailure = pCall->IsHWBroken();

    //
    // mfn_Unload is called with fDontBlock set to TRUE only from
    // one of the tasks that create a call, in the failure case where they
    // want to unload the call in the context of the task itself -- obviously
    // in that case pCall->fCallTaskPending is true.
    //
    //
    if (!fDontBlock && pCall->fCallTaskPending)
    {
        //
        // Obviously if there is a call task pending, there must be a
        // task pending. Furthermore, the mfn_UnloadCall (that's us),
        // is the ONLY entity which will set a completion event for a
        // call-related root task, so m_hRootTaskCompletionEvent had better
        // be NULL!
        //
        ASSERT(m_uTaskDepth);
        ASSERT(!m_hRootTaskCompletionEvent);

        //
        // If there is a call-related task pending  we wait for it to complete.
        // If we're not already in the aborting state, we abort the task...
        //
        if (!pCall->IsAborting())
        {
            pCall->SetStateBits(CALLINFO::fCALL_ABORTING);

            //
            // This is a hack, replace this by use of AbortRootTask
            //

            if (m_pLLDev->htspTaskPending) {

                m_StaticInfo.pMD->AbortCurrentModemCommand(
                                            m_pLLDev->hModemHandle,
                                            psl
                                            );

            } else if (NULL!=pCall->TerminalWindowState.htspTaskTerminal) {

                mfn_KillCurrentDialog(psl);

            } else if (pCall->TalkDropWaitTask != NULL) {
                //
                //  kill the talk drop dialog
                //
                mfn_KillTalkDropDialog(psl);
            }
        }

        HANDLE hEvent =  CreateEvent(NULL,TRUE,FALSE,NULL);
        m_hRootTaskCompletionEvent = hEvent;
        pCall->SetStateBits(CALLINFO::fCALL_WAITING_IN_UNLOAD);

        m_sync.LeaveCrit(0);
        // SLPRINTF0(psl, "Waiting for completion event");
        FL_SERIALIZE(psl, "Waiting for completion event");
        WaitForSingleObject(hEvent, INFINITE);
        FL_SERIALIZE(psl, "Done waiting for completion event");
        // SLPRINTF0(psl, "Done waiting for completion event");
        m_sync.EnterCrit(0);

        CloseHandle(hEvent);

        //
        // There may not be a call anymore! This should not happen,
        // because that would mean that we've reentered mfn_UnloadCall,
        // and the only places from which mfn_UnloadCall are called
        // are when processing TSPI_lineCloseCall and if
        // mfn_TH_CallMake[Passthrough]Call fails BEFORE the call is active
        // (in which case mfn_lineCloseCall should NOT be called).
        //
        // 12/18/1997 JosephJ NO NO NO
        // Above comment is wrong. DanKn said that according to the spec,
        // once TSPI_lineMakeCall returns, hdrvCall is expected to be valid.
        // This means the tapisrv CAN potentially call TSPI_lineCloseCall
        // before the async completion of TSPI_lineMakeCall!
        //
        if (!m_pLine || !m_pLine->pCall) goto end;

        //
        // Although it may be tempting to do so, we should not set
        // m_hRootTaskCompletionEvent to NULL here, because it's possible
        // for some other thread to have set this event in-between
        // the time the root task completes and we enter the crit sect above.
        // So instead the tasking system NULLs the above handle after setting
        // it (see CTspDev::AsyncCompleteTask, just after the call to SetEvent).
        //
        pCall->ClearStateBits(CALLINFO::fCALL_WAITING_IN_UNLOAD);
        pCall = m_pLine->pCall;
    }


    ASSERT(!(   (pCall->IsCallTaskPending() && !fDontBlock)
             || pCall->IsWaitingInUnload()
             || (pCall->IsActive() && fDontBlock)));

    if (pCall->IsOpenedLLDev())
    {

            mfn_CloseLLDev(
                    pCall->dwLLDevResources,
                    FALSE,
                    NULL,
                    0,
                    psl
                    );
            pCall->ClearStateBits(CALLINFO::fCALL_OPENED_LLDEV);
            pCall->dwLLDevResources = 0;
    }
    ASSERT (!pCall->dwLLDevResources);

    // Free raw call diagnostics info if present.
    if (pCall->DiagnosticData.pbRaw)
    {
        FREE_MEMORY(pCall->DiagnosticData.pbRaw);
        // cbUsed and pCall->DiagnosticData.pbRaw are zero'd below...
    }

    // Free Deferred generate tones buffer if present..
    if (pCall->pDeferredGenerateTones)
    {
        FREE_MEMORY(pCall->pDeferredGenerateTones);
        // pCall->pDeferredGenerateTones is zero'd below...
    }
    //
    // The following is a very significant act -- all information about
    // this call is nuked here...
    //
    ZeroMemory(&(m_Line.Call), sizeof(m_Line.Call));

    CallEnding();

    m_pLine->pCall = NULL;

    // We have to do the following AFTER zeroing out the call because
    // mfn_ProcessHardwareFailure simply updates call state if
    // the call exists (m_pLine->pCall != NULL).
    //
    if (fHandleHWFailure)
    {
        mfn_ProcessHardwareFailure(psl);
    }

end:

	FL_LOG_EXIT(psl, tspRet);

    return;
}



void
CTspDev::mfn_ProcessRing(
    BOOL       ReportRing,
    CStackLog *psl
    )
{
	FL_DECLARE_FUNC(0x8aa894d6, "CTspDev::mfn_ProcessRing")
    LINEINFO *pLine = m_pLine;
	CALLINFO *pCall = NULL;
	TSPRETURN tspRet = 0;
	FL_LOG_ENTRY(psl);

    if (!pLine || !pLine->IsMonitoring())
    {
	    FL_SET_RFR(0xa5b6ad00, "Line not open/not monitoring!");
	    goto end;
    }

    pCall = pLine->pCall;


    if (!pCall)
    {
        // 12/03/1997 JosephJ
        //  HACK: since we currently fail TSPI_lineAnswer if there
        // is a task pending, we'll ignore the ring if there is a task
        // pending. We hit this situation if we're still in the process
        // of initing/monitoring when the call comes in.
        if (m_uTaskDepth)
        {
            FL_SET_RFR(0xb28c2f00, "Ignoring ring because task pending!");
            goto end;
        }

        // New call!
        LONG lRet=0;

        tspRet =  mfn_LoadCall(NULL, &lRet, psl);
        pCall = pLine->pCall;
        if (tspRet || lRet)
        {
            goto end;
        }

        FL_ASSERT(psl, pCall->dwRingCount == 0);

        //
        // We need to request TAPI for a new call handle.
        //
        mfn_LineEventProc(
                 NULL,
                 LINE_NEWCALL,
                 (ULONG_PTR)(pLine->hdLine), // (Our hdCall is the same as hdLine)
                 (ULONG_PTR)(&(pCall->htCall)),
                 0,
                 psl
                 );

        if (pCall->htCall == NULL) {
            //
            //  Tapi could not handle the call now, unload the call. If we get another ring will
            //  will try again
            //
            mfn_UnloadCall(FALSE,psl);

            goto end;
        }

        // Make the call active.
        pCall->dwState |= CALLINFO::fCALL_ACTIVE;

        // Notify TAPI of callstate.
        //
        NEW_CALLSTATE(pLine, LINECALLSTATE_OFFERING, 0, psl);

    }


    //
    // A ring is coming in (either the first ring or a subsequent one.)
    // Handle the ring count
    //

    if (!pCall->IsCallAnswered()) {
        //
        // make the request to set the ring timer;
        // we cannot just set the timer here, because
        // the thread that calls SetWaitableTimer has to
        // become alertable at some point, and we don't know
        // that about the thread we're on right now. So, let's
        // queue an APC for the APC thread.
        // MDSetTimeout will just call SetWaitableTimer.
        // We don't check the return value, because there's nothing
        // we can do about it if it fails.
        //
        ASSERT (NULL != pCall->hTimer);
        SLPRINTF1(psl, "Queueing MDSetTimeout at tc=%lu", GetTickCount());
        QueueUserAPC ((PAPCFUNC)MDSetTimeout,
                      m_hThreadAPC,
                      (ULONG_PTR)this);


        if (ReportRing) {
            //
            //  This function was really called because of a ring, do send a message
            //  to tapi. This function will also be called from the caller message
            //  handler to get a call setup so we can report the caller id info
            //  in case it shows up before the first ring.
            //

            pCall->dwRingCount++;

            mfn_LineEventProc(
                            NULL,
                            LINE_LINEDEVSTATE,
                            LINEDEVSTATE_RINGING,
                            1L,
                            pCall->dwRingCount,
                            psl
                            );

            SLPRINTF1(psl, "RING#%d notified", pCall->dwRingCount);
        }

    } else {

        SLPRINTF1(psl, "ignoring RING#%d after answer", pCall->dwRingCount);
    }

end:
	FL_LOG_EXIT(psl, 0);
}

void
CTspDev::mfn_ProcessDisconnect(CStackLog *psl)
{
	FL_DECLARE_FUNC(0xe55cd68b, "CTspDev::mfn_ProcessDisconnect")
    LINEINFO *pLine = m_pLine;
	CALLINFO *pCall = NULL;
	TSPRETURN tspRet = 0;
	FL_LOG_ENTRY(psl);

    if (!pLine)
    {
	    FL_SET_RFR(0xf2fa9900, "Line not open!");
	    goto end;
    }

    pCall = pLine->pCall;

    if (pCall && pCall->IsActive() && !pCall->IsAborting())
    {
         mfn_NotifyDisconnection(0, psl);
    }
    else
    {
	    FL_SET_RFR(0xb2a25c00, "Call doesn't exist/dropping!");
	    goto end;
    }

end:
	FL_LOG_EXIT(psl, 0);
}


void
CTspDev::mfn_ProcessHardwareFailure(CStackLog *psl)
{
	FL_DECLARE_FUNC(0xc2a949b4, "CTspDev::mfn_ProcessHardwareFailure")
    LINEINFO *pLine = m_pLine;
    PHONEINFO *pPhone = m_pPhone;
	TSPRETURN tspRet = 0;
	FL_LOG_ENTRY(psl);

    if (pPhone &&  !pPhone->HasSentPHONECLOSE())
    {
	    pPhone->SetStateBits(PHONEINFO::fPHONE_SENT_PHONECLOSE);

        mfn_PhoneEventProc(
                    PHONE_CLOSE,
                    0,
                    0,
                    0,
                    psl
                    );
    }

    if (pLine)
    {
        CALLINFO *pCall = pLine->pCall;

        if (pCall)
        {
            if (m_fUserRemovePending) {
                //
                //  The user has requested the device stop, while a call is active.
                //  send disconnect with the hope it will drop the call and close the line
                //
                NEW_CALLSTATE(pLine, LINECALLSTATE_DISCONNECTED, LINEDISCONNECTMODE_NORMAL, psl);
            }

            // If there is in progress we simply set its state -- on completion
            // of the call it will send up a LINE_CLOSE if required....
            //

            pCall->dwState |=  CALLINFO::fCALL_HW_BROKEN;
        }
        else if (pLine->IsMonitoring() && !pLine->HasSentLINECLOSE())
        {
            // We are monitoring for incoming calls and no call is in progress--
            // notify TAPI.
	
	        pLine->SetStateBits(LINEINFO::fLINE_SENT_LINECLOSE);

            mfn_LineEventProc(
                        NULL,
                        LINE_CLOSE,
                        0,
                        0,
                        0,
                        psl
                        );
        }

    }


	FL_LOG_EXIT(psl, 0);
}

LONG
CTspDev::mfn_GetCallInfo(LPLINECALLINFO lpCallInfo)
{
    LONG lRet = ERROR_SUCCESS;
    CALLINFO *pCall =  m_pLine->pCall;
// xxx
    if (lpCallInfo->dwTotalSize<sizeof(LINECALLINFO)) // New for NT5.0...
    {
        lpCallInfo->dwNeededSize = sizeof(LINECALLINFO);
        lRet = LINEERR_STRUCTURETOOSMALL;
        goto end;
    }

    //
    // Zero structure to start with...
    //
    {
        DWORD dwTot = lpCallInfo->dwTotalSize;
        ZeroMemory(lpCallInfo, dwTot);
        lpCallInfo->dwTotalSize = dwTot;
        lpCallInfo->dwNeededSize = sizeof(LINECALLINFO);
        lpCallInfo->dwUsedSize   = sizeof(LINECALLINFO);
    }

    lpCallInfo->dwLineDeviceID = m_StaticInfo.dwTAPILineID;

    lpCallInfo->dwAddressID    = 0;
    lpCallInfo->dwBearerMode   = pCall->dwCurBearerModes;
    lpCallInfo->dwRate         = pCall->dwNegotiatedRate;
    lpCallInfo->dwMediaMode    = pCall->dwCurMediaModes;

    lpCallInfo->dwAppSpecific  = pCall->dwAppSpecific;

    lpCallInfo->dwCallerIDFlags       = LINECALLPARTYID_UNAVAIL;
    lpCallInfo->dwCalledIDFlags       = LINECALLPARTYID_UNAVAIL;
    lpCallInfo->dwConnectedIDFlags    = LINECALLPARTYID_UNAVAIL;
    lpCallInfo->dwRedirectionIDFlags  = LINECALLPARTYID_UNAVAIL;
    lpCallInfo->dwRedirectingIDFlags  = LINECALLPARTYID_UNAVAIL;

    if (pCall->IsInbound())
    {
        lpCallInfo->dwCallStates =   LINECALLSTATE_IDLE         |
                                     LINECALLSTATE_OFFERING     |
                                     LINECALLSTATE_ACCEPTED     |
                                     LINECALLSTATE_CONNECTED    |
                                     LINECALLSTATE_DISCONNECTED |
                                     LINECALLSTATE_UNKNOWN;

        lpCallInfo->dwOrigin = LINECALLORIGIN_INBOUND;
        lpCallInfo->dwReason =  LINECALLREASON_UNAVAIL;
        fill_caller_id(lpCallInfo,  &(pCall->CIDInfo));
    }
    else
    {
            // Outbound call.
        lpCallInfo->dwCallStates =   LINECALLSTATE_IDLE         |
                                     LINECALLSTATE_DIALTONE     |
                                     LINECALLSTATE_DIALING      |
                                     LINECALLSTATE_PROCEEDING   |
                                     LINECALLSTATE_CONNECTED    |
                                     LINECALLSTATE_DISCONNECTED |
                                     LINECALLSTATE_UNKNOWN;

        lpCallInfo->dwOrigin = LINECALLORIGIN_OUTBOUND;
        lpCallInfo->dwReason = LINECALLREASON_DIRECT;

    }


    // Fall through...

end:

    return lRet;
}


TSPRETURN
CTspDev::mfn_TH_CallAnswerCall(
					HTSPTASK htspTask,
                    TASKCONTEXT *pContext,
					DWORD dwMsg,
					ULONG_PTR dwParam1,
					ULONG_PTR dwParam2,
					CStackLog *psl
					)
//
//  START: dwParam1  == TAPI request ID.
//
//  We could get called either directly in the context of TSPI_lineMakeCall
//  or from the deferred task handler.
//
//  In the former case, we don't need to call the completion callback
//  if we're failing synchronously, but in the latter case, we do need
//  to call the completion routine because TAPI will be expecting
//  a callback.
//
{
	FL_DECLARE_FUNC(0xdd37f0bd, "CTspDev::mfn_TH_CallAnswerCall")
	FL_LOG_ENTRY(psl);
	TSPRETURN tspRet=FL_GEN_RETVAL(IDERR_INVALID_ERR);
	LINEINFO *pLine = m_pLine;
	CALLINFO *pCall = pLine->pCall;
    ULONG_PTR *pdwRequestID             = &(pContext->dw0);
    TSPRETURN  *ptspTrueResult      = &(pContext->dw1);

    enum
    {
        ANSWER_OPEN_COMPLETE,
        ANSWER_ANSWER_COMPLETE,
        ANSWER_CLEANUP_COMPLETE
    };

    switch(dwMsg)
    {
    default:
        FL_SET_RFR(0xa9d4fb00, "Unknown Msg");
        tspRet=FL_GEN_RETVAL(IDERR_CORRUPT_STATE);
        goto end;

    case MSG_START:
        goto start;


	case MSG_SUBTASK_COMPLETE:
        tspRet = dwParam2;

        // We force tspRet to failure
        // in the special case that the call is being aborted so that it
        // doesn't continue with the state diagram.
        //
        // TODO: Implement AbortTask/SubTask to deal with this sort of thing.
        //
        if (pCall->IsAborting() && !tspRet)
        {
            tspRet = IDERR_OPERATION_ABORTED;
        }

        switch(dwParam1) // Param1 is Subtask ID
        {
        case ANSWER_OPEN_COMPLETE:      goto open_complete;
        case ANSWER_ANSWER_COMPLETE:    goto answer_complete;
        case ANSWER_CLEANUP_COMPLETE:   goto cleanup_complete;
        }
        break;

    case MSG_DUMPSTATE:
        tspRet = 0;
        goto end;
    }

    ASSERT(FALSE);

    // The following code would be straightline code with no labels if all the
    //  async calls ompleted aynchronously.
    //  In other words, this is is our homebrew implementation of fibers.

start:

    *pdwRequestID             = dwParam1; // save context.


    pCall->SetStateBits(CALLINFO::fCALL_ANSWERED);

    //
    // Open the modem device.
    // mfn_OpenLLDev keeps a ref count so ok to call if already loaded.
    //
    {
        ASSERT(!pCall->dwLLDevResources);
        DWORD dwLLDevResources = LLDEVINFO::fRESEX_USELINE;
        //
        //                        ^ this means we want to use the line
        //                          for going off hook.

        if (pCall->IsVoice())
        {
            dwLLDevResources |= LLDEVINFO::fRES_AIPC;
            //
            //                  ^ this means we want to use the AIPC server.
            //
        }

        tspRet =  mfn_OpenLLDev(
                        dwLLDevResources,
                        0,          // dwMonitorFlags (unused)
                        TRUE,          // fStartSubTask
                        htspTask,
                        ANSWER_OPEN_COMPLETE,
                        psl
                        );

        if (!tspRet  || IDERR(tspRet)==IDERR_PENDING)
        {
            //
            // Note: Even if mfn_OpenLLDev fails Asynchronously, we're still
            // open with the requested resources, and to cleanup we need to call
            // mfn_CloseLLDev specifying the same resources we claimed here.
            //
            pCall->dwLLDevResources = dwLLDevResources;
            pCall->SetStateBits(CALLINFO::fCALL_OPENED_LLDEV);
        }
    }

    if (IDERR(tspRet)==IDERR_PENDING) goto end;

open_complete:

    if  (tspRet) goto cleanup;

    // Answer ...
    {

        DWORD dwAnswerFlags = ANSWER_FLAG_DATA;

        if (pCall->IsVoice())
        {
            dwAnswerFlags = ANSWER_FLAG_VOICE;
        }


        tspRet = mfn_StartSubTask (
                            htspTask,
                            &CTspDev::s_pfn_TH_LLDevUmAnswerModem,
                            ANSWER_ANSWER_COMPLETE,
                            dwAnswerFlags,
                            0,
                            psl
                            );
    }

    if (IDERR(tspRet)==IDERR_PENDING) goto end;

answer_complete:

//    pCall->ClearStateBits(CALLINFO::fCALL_ANSWER_PENDING);

    if (!tspRet)
    {
        mfn_TSPICompletionProc(
            (DWORD)*pdwRequestID,
            0,
            psl
            );
        mfn_HandleSuccessfulConnection(psl);


    #if (TAPI3)
        if (pLine->T3Info.MSPClients > 0) {

            mfn_SendMSPCmd(
                pCall,
                CSATSPMSPCMD_CONNECTED,
                psl
                );
        }
    #endif  // TAPI3

        goto end;
    }

    // fall through on failure...

cleanup:

    *ptspTrueResult = tspRet; // save it away so we report
                              // the correct status when we're done
                              // cleaning up.

//    pCall->ClearStateBits(CALLINFO::fCALL_ANSWER_PENDING);
    //
    // If we fallthrough this section, we want to make sure that
    // we don't report a h/w error, so we set tspRet to 0...
    //
    tspRet = 0;

    if (pCall->IsOpenedLLDev())
    {
        tspRet = mfn_CloseLLDev(
                    pCall->dwLLDevResources,
                    TRUE,
                    htspTask,
                    ANSWER_CLEANUP_COMPLETE,
                    psl
                    );
        //
        // even on failure, we clear our
        // bit indicating we'd opened the lldev....
        //
        pCall->ClearStateBits(CALLINFO::fCALL_OPENED_LLDEV);
        pCall->dwLLDevResources = 0;
    }

    if (IDERR(tspRet)==IDERR_PENDING) goto end;

cleanup_complete:


    mfn_TSPICompletionProc(
        (DWORD)*pdwRequestID,
        LINEERR_OPERATIONFAILED, // TODO: more useful error?
        psl
        );

    if (!pCall->IsAborting())
    {
        // The call failed and not because we're aborting it.
        //
        mfn_NotifyDisconnection(*ptspTrueResult, psl);
        NEW_CALLSTATE(pLine, LINECALLSTATE_IDLE, 0, psl);
        pCall->dwState &= ~CALLINFO::fCALL_ACTIVE;
    }

    if (tspRet)
    {
        // If there was a problem during cleanup after answer, we treat it
        // like a hw error.
        //
        pCall->dwState |=  CALLINFO::fCALL_HW_BROKEN;
        tspRet = 0;
    }
    else
    {
        // If hangup was successful, we clear the hw-error bit, even
        // if it was set, because the monitor and init went OK...
        pCall->dwState &=  ~CALLINFO::fCALL_HW_BROKEN;
    }

end:

	FL_LOG_EXIT(psl, tspRet);
	return tspRet;
}



// JosephJ 2/11/97 Adapted from NT4.0 msmadyn.c state diagram,
//                 case DEVST_PORTLISTENANSWER
//
void
CTspDev::mfn_HandleSuccessfulConnection(CStackLog *psl)
{
	FL_DECLARE_FUNC(0x3df24801, "HandleSuccessfulConnection")
	FL_LOG_ENTRY(psl);
    CALLINFO *pCall = m_pLine->pCall;

    //
    // The modem is connected (with either incoming or outgoing call.)
    // Ready to notify TAPI of the connected line.
    //
    // Treat INTERACTIVEVOICE connections differently.
    //
    if (LINEMEDIAMODE_INTERACTIVEVOICE != pCall->dwCurMediaModes)
    {
        //
        // We launch the light when the light was selected, but not for NULL
        // modems.
        //
        if (!mfn_IS_NULL_MODEM() && (m_Settings.dwOptions & UMLAUNCH_LIGHTS))
        {
            HANDLE hLight;

            if (LaunchModemLight(
                           m_StaticInfo.rgtchDeviceName,
                           NULL, // TODO m_CallpLineDev->hDevice,
                           &hLight,
                           psl) == ERROR_SUCCESS)
            {
                pCall->hLights = hLight;
            }
        };
    };


    // Notify TAPI of the connected line
    //
    NEW_CALLSTATE(m_pLine, LINECALLSTATE_CONNECTED, 0, psl);

	FL_LOG_EXIT(psl, 0);

    return;
}

// 2/11/1997 JosephJ -- Essentially unchanged from NT4.0 LaunchModemLight
//
TSPRETURN
LaunchModemLight (
            LPTSTR szModemName,
            HANDLE hModem,
            LPHANDLE lphLight,
            CStackLog *psl
            )
{
	FL_DECLARE_FUNC(0x45352124, "LaunchModemLights")
    HANDLE              hEvent;
    STARTUPINFO         sti;
    TCHAR               szCmdline[256];
    SERIALPERF_STATS    serialstats;
    DWORD               dwBytes;
    DWORD               dwRet;
    OVERLAPPED          ov;
    TSPRETURN           tspRet = IDERR_INVALID_ERR;
    PROCESS_INFORMATION pi;

	FL_LOG_ENTRY(psl);

    // Check to see if any bytes have been transferred or receive.  If none
    // has, there is no need to launch lights because this is probably a
    // port driver that doesn't support this ioctl.
    //
    ov.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    if (ov.hEvent == NULL)
    {
        tspRet = IDERR_CREATE_RESOURCE_FAILED;
    }

    // This is done to prevent the completion showing in some completion port.
    // This is not required for NT5.0 since we use don't use completion ports,
    // but it's here anyway.
    //
    ov.hEvent = (HANDLE)((ULONG_PTR)ov.hEvent | 1);

    dwRet = DeviceIoControl(hModem,
                            IOCTL_SERIAL_GET_STATS,
                            &serialstats,
                            sizeof(SERIALPERF_STATS),
                            &serialstats,
                            sizeof(SERIALPERF_STATS),
                            &dwBytes,
                            &ov);

    if (!dwRet)
    {
        if (ERROR_IO_PENDING == GetLastError())
        {
            dwRet = GetOverlappedResult(
                            hModem,
                            &ov,
                            &dwBytes,
                            TRUE);
        }
    }

    ov.hEvent = (HANDLE)((ULONG_PTR)ov.hEvent & (~1));
    CloseHandle(ov.hEvent);


    if (!dwRet ||
        (serialstats.ReceivedCount == 0 &&
        serialstats.TransmittedCount == 0))
    {
        tspRet =  IDERR_FUNCTION_UNAVAIL;
        goto end;
    }


    // OK, the GET_STATS ioctl seems to work, so let's really launch lights.


    // Create the lights shutdown event handle.
    hEvent = CreateEvent( NULL, FALSE, FALSE, NULL );
    if (!hEvent)
    {
        tspRet =  IDERR_CREATE_RESOURCE_FAILED;
        goto end;
    }
    else
    {
      // Create a global handle for use in other processes and close the
      // local handle.
      *lphLight = hEvent;

      // Compose a modem lights process command line
      //
      wsprintf(
         szCmdline,
         TEXT("lights.exe %lu %lu %lu %s"),
         GetCurrentProcessId(),
         hEvent,
         hModem,
         szModemName
         );

      // Create the modem lights process and store ID for use in CloseModem.
      ZeroMemory(&sti, sizeof(sti));
      sti.cb = sizeof(STARTUPINFO);
      if ( !CreateProcess(NULL, szCmdline,    // Start up command line
                          NULL, NULL, FALSE, 0, NULL, NULL, &sti, &pi) )
      {
            SLPRINTF1(psl, "CreateProcess failed (%d).", GetLastError());
            CloseHandle(hEvent);
            *lphLight = NULL;

            tspRet = IDERR_CREATE_RESOURCE_FAILED;
      }

      CloseHandle(pi.hProcess);
      CloseHandle(pi.hThread);

      tspRet = 0;
    }

end:

	FL_LOG_EXIT(psl, tspRet);
    return tspRet;
}

//****************************************************************************
// DWORD TerminateModemLight (HANDLE hLight)
//
// Function: Terminate the modem lights applet
//
// Returns:  ERROR_SUCCESS always
//
//****************************************************************************

DWORD TerminateModemLight (HANDLE hLight)
{
  SetEvent(hLight);
  CloseHandle(hLight);
  return ERROR_SUCCESS;
}


void
CTspDev::mfn_NotifyDisconnection(
    TSPRETURN tspRetAsync,
    CStackLog *psl)
{
	FL_DECLARE_FUNC(0x885cdd5c, "NotifyDisconnection")
	FL_LOG_ENTRY(psl);
	LINEINFO *pLine = m_pLine;
	CALLINFO *pCall = pLine->pCall;
	DWORD dwDisconnectMode =  LINEDISCONNECTMODE_UNAVAIL;

    if (!pCall->IsActive())
    {
        FL_ASSERT(psl, FALSE);
        goto end;
    }

    switch(IDERR(tspRetAsync))
    {

    case 0:
        dwDisconnectMode = LINEDISCONNECTMODE_NORMAL;
        break;

    case IDERR_MD_LINE_NOANSWER:
    case IDERR_MD_LINE_NOCARRIER:
        dwDisconnectMode = LINEDISCONNECTMODE_NOANSWER;
        break;

    case IDERR_MD_LINE_NODIALTONE:
        //
        // We were dialing out but no dial tone on the line
        //
        dwDisconnectMode = LINEDISCONNECTMODE_NODIALTONE;
        break;

    case IDERR_MD_LINE_BUSY:
        dwDisconnectMode = LINEDISCONNECTMODE_BUSY;
        break;

    case IDERR_MD_LINE_BLACKLISTED:
        dwDisconnectMode = LINEDISCONNECTMODE_BLOCKED;
        break;

    case IDERR_MD_LINE_DELAYED:
        dwDisconnectMode = LINEDISCONNECTMODE_TEMPFAILURE;
        break;

    // Following disconnect modes new for TAPI2.0 and for NT5.0.
    //
    case IDERR_MD_DEVICE_ERROR:
    case IDERR_MD_DEVICE_NOT_RESPONDING:
        dwDisconnectMode = LINEDISCONNECTMODE_OUTOFORDER;
        break;
    case IDERR_OPERATION_ABORTED:
        dwDisconnectMode = LINEDISCONNECTMODE_CANCELLED;
        break;

    default:
        dwDisconnectMode = LINEDISCONNECTMODE_UNAVAIL;
        break;

    }

    // The DISCONNECTED state msg may have already been sent up because
    // of a remote-originated disconnection (see
    //  CDevCall::ProcessDisconnection) -- so we check if the state is
    // disconnected. Note the dwCallState is always set at the same
    // time as we send up a CALLSTATE message -- this is done in macro
    // NEW_CALLSTATE.
    //
    if (pCall->dwCallState != LINECALLSTATE_DISCONNECTED)
    {
        NEW_CALLSTATE(pLine, LINECALLSTATE_DISCONNECTED, dwDisconnectMode, psl);
    }

end:

	FL_LOG_EXIT(psl, 0);
}


void fill_caller_id(LPLINECALLINFO lpCallInfo, CALLERIDINFO *pCIDInfo)
{
    TCHAR *lptstrBuf = 0;
    UINT cchBuf = 0;
    UINT cchRequired = 0;
    UINT cchActual = 0;


    // Nuke all these to start with...
    //
    lpCallInfo->dwCallerIDSize   = 0;
    lpCallInfo->dwCallerIDOffset = 0;
    lpCallInfo->dwCallerIDNameSize   = 0;
    lpCallInfo->dwCallerIDNameOffset = 0;
    lpCallInfo->dwCallerIDFlags  =    0;


    if (lstrcmpA(pCIDInfo->Number,MODEM_CALLER_ID_OUTSIDE) == 0) {
        //
        //  the caller id info is outside of the reporting area
        //
        lpCallInfo->dwCallerIDFlags |= LINECALLPARTYID_OUTOFAREA;

        pCIDInfo->Number[0]='\0';
    }

    if (lstrcmpA(pCIDInfo->Number,MODEM_CALLER_ID_PRIVATE) == 0) {
        //
        //  the caller id info is private
        //
        lpCallInfo->dwCallerIDFlags |= LINECALLPARTYID_BLOCKED;

        pCIDInfo->Number[0]='\0';
    }



    if (!pCIDInfo->Name[0] && !pCIDInfo->Number[0])
    {
        //
        // nothing to add...
        //
        goto end;
    }

#if (!UNICODE)
    #error "Non-unicode version needs work here !"
#endif  // UNICODE

    // Compute remaining size left and offset to this buffer.
    if  (   (lpCallInfo->dwUsedSize & 0x1)
         && (lpCallInfo->dwTotalSize > lpCallInfo->dwUsedSize))
    {
        // need to pad up the the nearest WORD-aligned bouindary.

        lpCallInfo->dwUsedSize++;
        lpCallInfo->dwNeededSize++;
    }

    cchBuf = (lpCallInfo->dwTotalSize - lpCallInfo->dwUsedSize)/sizeof(TCHAR);
    lptstrBuf =  (TCHAR*) (((BYTE*)lpCallInfo)+lpCallInfo->dwUsedSize);


    if (pCIDInfo->Number[0])
    {
        cchRequired = MultiByteToWideChar(
                                    CP_ACP,
                                    0,
                                    pCIDInfo->Number,
                                    -1,
                                    NULL,
                                    0
                                    );

        lpCallInfo->dwNeededSize += cchRequired*sizeof(TCHAR);

        if (cchRequired <= cchBuf)
        {

            cchActual = MultiByteToWideChar(
                                        CP_ACP,
                                        0,
                                        pCIDInfo->Number,
                                        -1,
                                        lptstrBuf,
                                        cchBuf
                                        );

            if (cchActual)
            {
                lpCallInfo->dwCallerIDFlags  |=    LINECALLPARTYID_ADDRESS;
                lpCallInfo->dwCallerIDSize = cchActual*sizeof(TCHAR);
                lpCallInfo->dwCallerIDOffset = lpCallInfo->dwUsedSize;
                lpCallInfo->dwUsedSize +=    cchActual*sizeof(TCHAR);

                lptstrBuf+=cchActual;
                cchBuf-=cchActual;

#if (TAPI3)
                lpCallInfo->dwCallerIDAddressType =  LINEADDRESSTYPE_PHONENUMBER;
#endif // TAPI3
            }

        }
    }


    if (pCIDInfo->Name[0])
    {
        cchRequired = MultiByteToWideChar(
                                    CP_ACP,
                                    0,
                                    pCIDInfo->Name,
                                    -1,
                                    NULL,
                                    0
                                    );

        lpCallInfo->dwNeededSize += cchRequired*sizeof(TCHAR);

        if (cchRequired <= cchBuf)
        {

            cchActual = MultiByteToWideChar(
                                        CP_ACP,
                                        0,
                                        pCIDInfo->Name,
                                        -1,
                                        lptstrBuf,
                                        cchBuf
                                        );

            if (cchActual)
            {
                lpCallInfo->dwCallerIDFlags  |=  LINECALLPARTYID_NAME;
                lpCallInfo->dwCallerIDNameSize = cchActual*sizeof(TCHAR);
                lpCallInfo->dwCallerIDNameOffset = lpCallInfo->dwUsedSize;
                lpCallInfo->dwUsedSize +=  cchActual*sizeof(TCHAR);



            }
        }
    }

end:
    if (0 == lpCallInfo->dwCallerIDFlags)
    {
        lpCallInfo->dwCallerIDFlags =  LINECALLPARTYID_UNKNOWN;
    }

    return;

}


void
CTspDev::mfn_ProcessDialTone(CStackLog *psl)
{
	FL_DECLARE_FUNC(0xc26c1348, "CTspDev::mfn_ProcessDialTone")
    LINEINFO *pLine = m_pLine;
	CALLINFO *pCall = NULL;
	TSPRETURN tspRet = 0;
	FL_LOG_ENTRY(psl);

    if (!pLine)
    {
	    FL_SET_RFR(0xaddee800, "Line not open!");
	    goto end;
    }

    pCall = pLine->pCall;

    if (pCall && pCall->IsActive() && !pCall->IsAborting())
    {
         // 0 below == disconnect mode is DISCONNECT_NORMAL. This
         //  is unimodem/V behavior.

         mfn_NotifyDisconnection(0, psl);
    }
    else
    {
	    FL_SET_RFR(0x210b2f00, "Call doesn't exist!");
	    goto end;
    }

end:
	FL_LOG_EXIT(psl, 0);
}

void
CTspDev::mfn_ProcessBusy(CStackLog *psl)
{
	FL_DECLARE_FUNC(0x761795f2, "CTspDev::mfn_ProcessBusy")
    LINEINFO *pLine = m_pLine;
	CALLINFO *pCall = NULL;
	TSPRETURN tspRet = 0;
	FL_LOG_ENTRY(psl);

    if (!pLine)
    {
	    FL_SET_RFR(0xf67d1a00, "Line not open!");
	    goto end;
    }

    pCall = pLine->pCall;

    if (pCall && pCall->IsActive() && !pCall->IsAborting())
    {
         // 0 below == disconnect mode is DISCONNECT_NORMAL. This
         //  is unimodem/V behavior.

         mfn_NotifyDisconnection(IDERR_MD_LINE_BUSY, psl);
    }
    else
    {
	    FL_SET_RFR(0xfff8f100, "Call doesn't exist!");
	    goto end;
    }

end:
	FL_LOG_EXIT(psl, 0);
}


void
CTspDev::mfn_ProcessDTMFNotification(ULONG_PTR dwDigit, BOOL fEnd, CStackLog *psl)
{
	FL_DECLARE_FUNC(0xa4097846, "CTspDev::mfn_ProcessDTMFNotif")
    LINEINFO *pLine = m_pLine;
	CALLINFO *pCall = NULL;
	TSPRETURN tspRet = 0;
	FL_LOG_ENTRY(psl);

    if (!pLine)
    {
	    FL_SET_RFR(0x7cdb4c00, "Line not open!");
	    goto end;
    }

    pCall = pLine->pCall;

    if (pCall && pCall->IsActive() && !pCall->IsAborting())
    {
        DWORD dwMode =
                (fEnd) ? (pCall->dwDTMFMonitorModes & LINEDIGITMODE_DTMFEND)
                       : (pCall->dwDTMFMonitorModes & LINEDIGITMODE_DTMF);

        if (dwMode)
        {
            mfn_LineEventProc(
                            pCall->htCall,
                            LINE_MONITORDIGITS,
                            dwDigit,
                            dwMode,
                            0,
                            psl
                            );
        }
    }
    else
    {
	    FL_SET_RFR(0x63657f00, "Call doesn't exist!");
	    goto end;
    }

end:
	FL_LOG_EXIT(psl, 0);
}


void
CTspDev::mfn_AppendDiagnostic(
            DIAGNOSTIC_TYPE dt,
            const BYTE *pbIn,
            UINT  cbIn          // << not including final NULL, if any
            )
//
// WARNING: should expect NULL m_pLine or NULL m_pLine->pCall because this
// function is called from an LLDev task handler, which could complete
// after the line or call have been nuked.
//
// This routine adds diagnostic information in tagged format to
// the buffer maintained in m_pLine->pCall->DiagnosticData, allocating
// the buffer first if necessary. The buffer size if fixed
//  (DIAGNOSTIC_DATA_BUFFER_SIZE). This routine will truncate the
// added dignostic so that it fits into the buffer. Depending on the
// value of dt, it may encose the passed in data in tagged format or
// expect the data to already be in tagged format. In the latter case,
// when truncating, it will truncate upto the last '>' it finds.
// In the former case, it makes sure the copied data contains
// no HTML delimiter characters: '>', '<', and '"'. In both cases,
// it make sure the data contains no NULL characters. "makes sure"
// is done by or-ing the offending character with 0x80, which is
// the documented method of representing these characters in our
// tagged format.
//
//
{
    CALLINFO *pCall = (m_pLine) ? m_pLine->pCall : NULL;
    UINT cbUsed = 0;
    BYTE *pbRaw = 0;

    if (!pCall || !cbIn) goto end;


    pbRaw = pCall->DiagnosticData.pbRaw;
    cbUsed = pCall->DiagnosticData.cbUsed;

    //
    // Make sure we're consistant on entry ....
    //
    ASSERT(cbUsed <  DIAGNOSTIC_DATA_BUFFER_SIZE);
    ASSERT(    (pbRaw && (UINT)lstrlenA((char*)pbRaw)==cbUsed)
            || (!pbRaw && !cbUsed) );

    //
    // Allocate the diagnostics buffer if necessary ...
    //

    if (!pbRaw)
    {

        pbRaw = (BYTE*)ALLOCATE_MEMORY(
                            DIAGNOSTIC_DATA_BUFFER_SIZE
                            );

        if (!pbRaw) goto end;

        pCall->DiagnosticData.pbRaw = pbRaw;
    }


    //
    // Check if there's any space left ...
    //

    if ((cbUsed+1) >= DIAGNOSTIC_DATA_BUFFER_SIZE)
    {
        ASSERT((cbUsed+1) == DIAGNOSTIC_DATA_BUFFER_SIZE);
        goto end;
    }


    //
    // At-least one character is left in the buffer, so we'll try to
    // construct the diagnostics data
    //

    {
        BYTE *pbStart = pbRaw + cbUsed;
        UINT cbLeft = DIAGNOSTIC_DATA_BUFFER_SIZE - (cbUsed+1);
        UINT cbCopy = 0; // This is NOT including the final null character.

        ASSERT(cbLeft);
        //
        // On exit of this switch statement, cbCopy contains the
        // amount of bytes copied, but the buffer is not expected to
        // be null-terminated. pbStart and cbLeft are not preserved.
        //

        switch(dt)
        {

        case DT_TAGGED:
            {
                //
                // The information is already html-tagged. We truncate
                // it to fit the available space.
                //

                cbCopy = cbIn;

                if (cbCopy > cbLeft)
                {
                    cbCopy = cbLeft;
                }

                ASSERT(cbCopy);

                CopyMemory(pbStart, pbIn, cbCopy);

                if (cbCopy != cbIn)
                {
                    // We've had to truncate it, so let's go backwards,
                    // looking for the last valid tag...

                    for ( BYTE *pb = pbStart+cbCopy-1;
                          pb>=pbStart && *pb!='>';
                          pb-- )
                    {
                        *pb = 0;
                    }

                    cbCopy  = (UINT)(pb + 1 - pbStart);
                }

                //
                // The passed-in string may contain NULLS -- we nuke
                // embedded null's here ...
                //
                {
                    for (  BYTE *pb = pbStart, *pbEnd=(pbStart+cbCopy);
                           pb<pbEnd;
                           pb++ )
                    {
                        if (!*pb)
                        {
                            *pb |= 0x80;
                        }
                    }
                }
            }
            break;

        case DT_MDM_RESP_CONNECT:

            {
                UINT cbMyCopy=0;
                // This is the connect response directly from the modem.
                // We convert it to tagged format...

                #define CONNECT_TAG_PREFIX "<5259091C 1=\""

                #define CONNECT_TAG_SUFFIX "\">"

                #define CONNECT_TAG_SUFFIX_LENGTH (sizeof(CONNECT_TAG_SUFFIX)-sizeof(CHAR))

                //
                // The '3' below is: at-least 1 byte of passed in
                //                   data + the 2 bytes for ending '">'.
                //
                // Note the cbLeft doesn't include 1 byte reserved for
                // the ending NULL.
                //
                if (cbLeft < (sizeof(CONNECT_TAG_PREFIX) + 1 + CONNECT_TAG_SUFFIX_LENGTH ))
                {
                    goto end;
                }

                cbCopy = sizeof(CONNECT_TAG_PREFIX)-1;
                //
                //          "-1" above because we don't care about the
                //          terminating NULL.
                //

                CopyMemory(
                    pbStart,
                    CONNECT_TAG_PREFIX,
                    cbCopy
                    );

                pbStart += cbCopy;
                cbLeft -= cbCopy;
                ASSERT(cbLeft>1); // we already checked this above ..

                cbMyCopy = cbIn;

                // truncate...
                if ((cbMyCopy + CONNECT_TAG_SUFFIX_LENGTH) >= cbLeft  )
                {
                    cbMyCopy = cbLeft-CONNECT_TAG_SUFFIX_LENGTH;
                }


                CopyMemory(
                    pbStart,
                    pbIn,
                    cbMyCopy
                    );

                cbCopy += cbMyCopy;


                //
                // Now turn on the high-bit of any charaters that are passed
                // in that NULL or look like HTML delimiters '<', '>' and '"'.
                //
                for (  BYTE *pb = pbStart, *pbEnd=(pbStart+cbMyCopy);
                       pb<pbEnd;
                       pb++ )
                {
                    BYTE b = *pb;
                    if (   b == '<'
                        || b == '>'
                        || b == '"'
                        || !b )
                    {
                        *pb |= 0x80;
                    }
                }

                //
                // Add the trailing '">'. There will be enough space for this.
                //
                *pbEnd++ = '"';
                *pbEnd++ = '>';
                cbCopy += 2;

            }
            break;
        }

        //
        // We add the terminating null.
        //
        cbUsed += cbCopy;
        pbRaw[cbUsed] = 0;

        pCall->DiagnosticData.cbUsed = cbUsed;;

    }

end:

    if (pCall)
    {
        //
        // Make sure we're consistant on exit....
        //

        pbRaw = pCall->DiagnosticData.pbRaw;
        cbUsed =  pCall->DiagnosticData.cbUsed;
        ASSERT(cbUsed <  DIAGNOSTIC_DATA_BUFFER_SIZE);
        ASSERT(    (pbRaw && (UINT)lstrlenA((char*)pbRaw)==cbUsed)
                || (!pbRaw && !cbUsed) );
    }

    return;
}


TSPRETURN
CTspDev::mfn_TryStartCallTask(CStackLog *psl)
{
    // NOTE: MUST return IDERR_SAMESTATE if there are no tasks to run.

    ASSERT(m_pLine && m_pLine->pCall);
    CALLINFO *pCall = m_pLine->pCall;
    TSPRETURN tspRet = IDERR_SAMESTATE;

    if (!pCall->HasDeferredTasks() || pCall->IsWaitingInUnload())
    {
        goto end;
    }

    //
    // If there is a deferred tspi_linedrop
    // we do that now...
    //
    if (pCall->AreDeferredTaskBitsSet( CALLINFO::fDEFERRED_TSPI_LINEDROP ))
    {
        //
        // We should NOT have any other deferred tasks!
        //
        ASSERT(pCall->dwDeferredTasks==CALLINFO::fDEFERRED_TSPI_LINEDROP);

        // 6/17/1997 JosephJ
        //      We have do do some tricky things in the case that
        //      the modem is in a connected state other than data.
        //      Most notably VOICE. We can't just to a hangup, because
        //      the modem may be in voice connected state. In fact
        //      if we do hangup without notice the modem often gets
        //      into an unrecoverable state and must be powercycled (
        //      typically it is stuck in voice connected state).
        //
        if (!m_pLLDev || !m_pLLDev->IsStreamingVoice()) // lazy
        {
            DWORD    dwRequestID = pCall->dwDeferredLineDropRequestID;
            pCall->dwDeferredLineDropRequestID = 0;
            pCall->ClearDeferredTaskBits(CALLINFO::fDEFERRED_TSPI_LINEDROP);

            tspRet = mfn_StartRootTask(
                                &CTspDev::s_pfn_TH_CallDropCall,
                                &pCall->fCallTaskPending,
                                dwRequestID,                // P1
                                0,
                                psl
                                );

            ASSERT(IDERR(tspRet) != IDERR_TASKPENDING);
        }
    }

    if (IDERR(tspRet) == IDERR_PENDING) goto end;

    //
    // If we have a deferred make call, we do that here ....
    //
    if (pCall->AreDeferredTaskBitsSet(CALLINFO::fDEFERRED_TSPI_LINEMAKECALL ))
    {

        // Choose the appropriate task handler for the call type
        //
        PFN_CTspDev_TASK_HANDLER *ppfnHandler
                = (pCall->IsPassthroughCall())
                     ?  &(CTspDev::s_pfn_TH_CallMakePassthroughCall)
                     :  &(CTspDev::s_pfn_TH_CallMakeCall);
        DWORD dwRequestID = pCall->dwDeferredMakeCallRequestID;

        pCall->ClearDeferredTaskBits(CALLINFO::fDEFERRED_TSPI_LINEMAKECALL);
        pCall->dwDeferredMakeCallRequestID = 0;

        //
        // Couldn't possibly have anything else deferred for this call at this
        // point -- the call isn't valid until we callback TAPI with lRet=0.
        //
        ASSERT(!pCall->dwDeferredTasks);


        tspRet = mfn_StartRootTask(
                        ppfnHandler,
                        &pCall->fCallTaskPending,
                        dwRequestID,
                        0,
                        psl
                        );

        ASSERT(IDERR(tspRet) != IDERR_TASKPENDING);
        if (IDERR(tspRet) != IDERR_PENDING)
        {
            if (tspRet && m_pLine->pCall)
            {
                // Sync failure...
                //
                // We could get here if mfn_StartRootTask fails for some
                // reason...
                //
                mfn_UnloadCall(FALSE, psl);
            }

            //
            // map any non-pending error to 0.
            //
            tspRet = 0;
        }
    }

    //
    // Note: there may not be a call anymore...
    //
    if (!m_pLine->pCall || IDERR(tspRet) == IDERR_PENDING) goto end;

    //
    // If we have a deferred generate digits, we do that here ...
    //
    if (pCall->AreDeferredTaskBitsSet(CALLINFO::fDEFERRED_TSPI_GENERATEDIGITS))
    {
        DWORD dwEndToEndID = pCall->dwDeferredEndToEndID;
        char *lpszAnsiTones = pCall->pDeferredGenerateTones;

        tspRet = 0;

        //
        // Clear deferred state...
        //
        pCall->pDeferredGenerateTones=NULL;
        pCall->ClearDeferredTaskBits(
                    CALLINFO::fDEFERRED_TSPI_GENERATEDIGITS
                    );
        pCall->dwDeferredEndToEndID = 0;
        //
        // Given the current set of deferable call-related tasks, we
        // couldn't possibly have anything else deferred for this call at this
        // point (the only other kinds of things that can be deferred
        // are lineMakeCall and lineDrop. When processing TSPI_lineDrop,
        // we clear any deferred bits, including our bit
        // (fDEFERRED_TSPI_GENERATEDIGITS).
        //
        // Note: once you start adding other deferred tasks, relax this
        // assertion appropriately.
        //
        ASSERT(!pCall->dwDeferredTasks);

        //
        // We only defer a GENERATEDIGITS if the specified tones is non-null.
        //
        if (!lpszAnsiTones)
        {
            ASSERT(FALSE);
            goto end;
        }

        //
        // If we're in the aborting or disconnected state, we
        // cancel the thing.
        //
        if (   pCall->IsAborting()
            || pCall->dwCallState != LINECALLSTATE_CONNECTED)
        {
            mfn_LineEventProc(
                            pCall->htCall,
                            LINE_GENERATE,
                            LINEGENERATETERM_CANCEL,
                            dwEndToEndID,
                            GetTickCount(),
                            psl
                            );
        }
        else
        {
            // Start the root task if we can (ignore the result)
            mfn_StartRootTask(
                      &CTspDev::s_pfn_TH_CallGenerateDigit,
                      &pCall->fCallTaskPending,
                      dwEndToEndID,
                      (ULONG_PTR) lpszAnsiTones,
                      psl
                      );
        }

        //
        // Note: even on pending return, TH_CallGenerateDigit
        // doesn't expect the passed in string to be valid
        // after the initial start request, so it's OK to free it
        // here.
        //
        FREE_MEMORY(lpszAnsiTones);
        lpszAnsiTones = NULL;
    }

end:

    //
    // Heading out of here...
    // IDERR_SAMESTATE implies that we couldn't start a task this time.
    // IDERR_PENDING implies we started a task and it's pending.
    // Any other value for tspRet implies we started and completed a task.
    //

    ASSERT(   (IDERR(tspRet)==IDERR_PENDING && m_uTaskDepth)
           || (IDERR(tspRet)!=IDERR_PENDING && !m_uTaskDepth));

    return tspRet;
}


TSPRETURN
CTspDev::mfn_TH_CallGenerateDigit(
					HTSPTASK htspTask,
                    TASKCONTEXT *pContext,
					DWORD dwMsg,
					ULONG_PTR dwParam1,
					ULONG_PTR dwParam2,
					CStackLog *psl
					)
//
//  START_MSG Params:
//      dwParam1: dwEndToEndID
//      dwParam2: lpszDigits (will only be valid on START_MSG)
//
{
    //
    // Context Use:
    //      dw0: pdwEndToEndID;
    //

	FL_DECLARE_FUNC(0x21b243f0, "CTspDev::mfn_TH_CallGenerateDigit")
	FL_LOG_ENTRY(psl);
	TSPRETURN tspRet=FL_GEN_RETVAL(IDERR_PENDING);
    DWORD dwRet = 0;
    CALLINFO *pCall = m_pLine->pCall;
    ULONG_PTR   *pdwEndToEndID = &pContext->dw0;

    enum
    {
        CALLGENDIG_COMPLETE
    };

    switch(dwMsg)
    {
    case MSG_START:
        goto start;

    case MSG_TASK_COMPLETE:
        tspRet = dwParam2;
        goto start;

	case MSG_SUBTASK_COMPLETE:
	    ASSERT(dwParam1==CALLGENDIG_COMPLETE);
        tspRet = (TSPRETURN) dwParam2;
        goto generate_complete;

    case MSG_DUMPSTATE:
        tspRet = 0;
        goto end;

    default:
        FL_SET_RFR(0x172b7b00, "Unknown Msg");
        tspRet=FL_GEN_RETVAL(IDERR_CORRUPT_STATE);
        goto end;

    }

    ASSERT(FALSE);

start:

    {
        LPSTR lpszDigits =  (LPSTR) dwParam2;
        *pdwEndToEndID   = dwParam1;

        if (!pCall->IsAborting() && lpszDigits && *lpszDigits)
        {
            pCall->SetStateBits(CALLINFO::fCALL_GENERATE_DIGITS_IN_PROGRESS);

            tspRet = mfn_StartSubTask (
                                htspTask,
                                &CTspDev::s_pfn_TH_LLDevUmGenerateDigit,
                                CALLGENDIG_COMPLETE,
                                (ULONG_PTR) lpszDigits,
                                0,
                                psl
                                );
        }
        else
        {
            FL_SET_RFR(0xa914c600, "Can't call UmGenerateDigit in current state!");

            //
            //  BRL: fix problem with calling line_generate if we return failure.
            //  set this to success
            //
            pCall->SetStateBits(CALLINFO::fCALL_GENERATE_DIGITS_IN_PROGRESS);

            tspRet = 0;

//            tspRet = IDERR_WRONGSTATE;
//            goto end;
        }
    }

generate_complete:

    if (IDERR(tspRet)!=IDERR_PENDING && pCall->IsGeneratingDigits())
    {
        // We need to notify TAPI of completion, and clear the flag indicating
        // that we're in the process of generating digits...
        DWORD dwTerminationMode = LINEGENERATETERM_DONE;

        if (tspRet)
        {
            dwTerminationMode = LINEGENERATETERM_CANCEL;
        }

        mfn_LineEventProc(
                        pCall->htCall,
                        LINE_GENERATE,
                        dwTerminationMode,
                        *pdwEndToEndID,
                        GetTickCount(),
                        psl
                        );

        pCall->ClearStateBits(CALLINFO::fCALL_GENERATE_DIGITS_IN_PROGRESS);

    }

end:

	FL_LOG_EXIT(psl, tspRet);
	return tspRet;

}



TSPRETURN
CTspDev::mfn_TH_CallSwitchFromVoiceToData(
					HTSPTASK htspTask,
                    TASKCONTEXT *pContext,
					DWORD dwMsg,
					ULONG_PTR dwParam1,
					ULONG_PTR dwParam2,
					CStackLog *psl
					)
//
//  START: dwParam1, dwParam2: Unused.
//
//  Switch an answered, incoming call from voice to data.
//
{
	FL_DECLARE_FUNC(0x79fa3c83, "CTspDev::mfn_TH_CallSwitchFromVoiceToData")
	FL_LOG_ENTRY(psl);
	TSPRETURN tspRet=FL_GEN_RETVAL(IDERR_CORRUPT_STATE);
	CALLINFO *pCall = m_pLine->pCall;

    enum
    {
    ANSWER_COMPLETE,
    HANGUP_COMPLETE
    };

    switch(dwMsg)
    {
    default:
        ASSERT(FALSE);
        goto end;

    case MSG_START:
        goto start;

	case MSG_SUBTASK_COMPLETE:
        tspRet = dwParam2;

        switch(dwParam1) // Param1 is Subtask ID
        {
        case ANSWER_COMPLETE:    goto answer_complete;
        case HANGUP_COMPLETE:    goto hangup_complete;
        }
        break;

    case MSG_DUMPSTATE:
        tspRet = 0;
        goto end;
    }

    ASSERT(FALSE);

start:


    ASSERT( pCall->IsConnectedVoiceCall()
            && pCall->IsInbound()
            && !m_pLLDev->IsStreamingVoice()
            && !pCall->IsPassthroughCall());

    // Let's answer...
    //
    tspRet = mfn_StartSubTask(
                    htspTask,
                    &CTspDev::s_pfn_TH_LLDevUmAnswerModem,
                    ANSWER_COMPLETE,
                    ANSWER_FLAG_VOICE_TO_DATA,
                    0,
                    psl
                    );


    if (IDERR(tspRet)==IDERR_PENDING) goto end;

answer_complete:

    if (!tspRet)
    {
        // success ....

        // Switch our mode to data...
        //
        pCall->ClearStateBits(CALLINFO::fCALL_VOICE);
        pCall->dwCurMediaModes = LINEMEDIAMODE_DATAMODEM;

        // notify tapi...
        //
        mfn_LineEventProc(
                        pCall->htCall,
                        LINE_CALLINFO,
                        LINECALLINFOSTATE_MEDIAMODE,
                        0,
                        0,
                        psl
                        );

        // not needed? mfn_HandleSuccessfulConnection(psl);
        goto end;
    }
    else
    {
        tspRet = mfn_StartSubTask (
                            htspTask,
                            &CTspDev::s_pfn_TH_LLDevUmHangupModem,
                            HANGUP_COMPLETE,
                            0,
                            0,
                            psl
                            );
    }

    if (IDERR(tspRet)==IDERR_PENDING) goto end;

hangup_complete:

    ASSERT(m_pLine);
    ASSERT(m_pLine->pCall);

    if (!pCall->IsAborting())
    {
        mfn_NotifyDisconnection(IDERR_GENERIC_FAILURE , psl);
    }

end:

	FL_LOG_EXIT(psl, tspRet);
	return tspRet;

}

void
CTspDev::mfn_ProcessMediaTone(
    ULONG_PTR dwMediaMode,
    CStackLog *psl)
{
    CALLINFO *pCall = (m_pLine) ? m_pLine->pCall : NULL;

    if (    pCall
         && (pCall->dwMonitoringMediaModes & dwMediaMode)
         && pCall->IsActive()
         && !pCall->IsAborting())
    {

        mfn_LineEventProc(
                        pCall->htCall,
                        LINE_MONITORMEDIA,
                        dwMediaMode,
                        NULL,
                        NULL,
                        psl
                        );
    }
}


void
CTspDev::mfn_ProcessSilence(
    CStackLog *psl)
{
    CALLINFO *pCall = (m_pLine) ? m_pLine->pCall : NULL;

    if (    pCall && pCall->IsActive() && !pCall->IsAborting()
         && pCall->IsMonitoringSilence())
    {

        mfn_LineEventProc(
                        pCall->htCall,
                        LINE_MONITORTONE,
                        pCall->dwAppSpecific,
                        pCall->dwToneListID,
                        NULL,
                        psl
                        );
    }
}


void APIENTRY
CTspDev::MDSetTimeout (CTspDev *pThis)
{
 FL_DECLARE_FUNC(0xd34b7688, "CTspDev::MDSetTimeout")
 FL_DECLARE_STACKLOG(sl, 1024);

    pThis->m_sync.EnterCrit(0);

    FL_ASSERT(&sl, NULL != pThis->m_pLine);
    if (NULL != pThis->m_pLine)
    {
     CALLINFO *pCall = pThis->m_pLine->pCall;

        SLPRINTF1(&sl, "CTspDev::MDSetTimeout at tc=%lu", GetTickCount());

        if (NULL != pCall &&
            NULL != pCall->hTimer)
        {
            LARGE_INTEGER Timeout;

            Timeout.QuadPart = Int32x32To64 (TOUT_SEC_RING_SEPARATION,
                                             TOUT_100NSEC_TO_SEC_RELATIVE);
            //
            //  Should we do something if this fails?
            //  (it means we won't have time-out if the
            //  line stops ringing before the app answers)
            //
            //  As it is the call will exist until the
            //  the app calls linedeallocate call. When the next call
            //  comes along we will send more rings and the app probably answer then
            //
            //  we could probably just send idle now, but I don't know if that is really
            //  going to help anything any better. The line would just ring again
            //  and we will be right back here.
            //
            SetWaitableTimer (pThis->m_Line.Call.hTimer,
                              &Timeout,
                              0,
                              (PTIMERAPCROUTINE)MDRingTimeout,
                              pThis,
                              FALSE);
        }
    }

    pThis->m_sync.LeaveCrit(0);

    sl.Dump (FOREGROUND_GREEN | FOREGROUND_BLUE | FOREGROUND_INTENSITY);
}



void CALLBACK
CTspDev::MDRingTimeout (
    CTspDev *pThis,
    DWORD dwLow,
    DWORD dwHigh)
{
 FL_DECLARE_FUNC(0x156032a9, "CTspDev::MDRingTimeout")
 FL_DECLARE_STACKLOG(sl, 1024);

    pThis->m_sync.EnterCrit(0);

    FL_ASSERT(&sl, NULL != pThis->m_pLine);
    if (NULL != pThis->m_pLine)
    {
     CALLINFO *pCall = pThis->m_pLine->pCall;

        SLPRINTF1(&sl, "CTspDev::MDRingTimeout at tc=%lu", GetTickCount());

        if (NULL != pCall &&
            NULL != pCall->hTimer)
        {
            CloseHandle (pCall->hTimer);
            pCall->hTimer = NULL;

            if (LINECALLSTATE_OFFERING == pCall->dwCallState)
            {
                //
                // The following code is the actual implementation of
                // NEW_CALLSTATE(pLine, LINECALLSTATE_IDLE, 0, NULL);
                // we put it here because MDRingTimeout is a static function
                // and must qualify access to the members with the actual
                // pointer to the object.
                //
                pCall->dwCallState = LINECALLSTATE_IDLE;
                pCall->dwCallStateMode = 0;
                pThis->mfn_LineEventProc (pCall->htCall,
                                          LINE_CALLSTATE,
                                          LINECALLSTATE_IDLE,
                                          0,
                                          pCall->dwCurMediaModes,
                                          &sl);
                // End of NEW_CALLSTATE

                pCall->dwState &= ~CALLINFO::fCALL_ACTIVE;
            }
        }
    }

    pThis->m_sync.LeaveCrit(0);

    sl.Dump (FOREGROUND_GREEN | FOREGROUND_BLUE | FOREGROUND_INTENSITY);
}


#if (TAPI3)

void
CTspDev::mfn_SendMSPCmd(
            CALLINFO *pCall,
            DWORD dwCmd,
            CStackLog *psl
            )
{
    // DBGOUT((INFO, "Send MSP data, size:%d", dwSize));

    CSATSPMSPBLOB Blob;
    ZeroMemory(&Blob, sizeof(Blob));
    Blob.dwSig            = SIG_CSATSPMSPBLOB;
    Blob.dwTotalSize      = sizeof(CSATSPMSPBLOB);
    CopyMemory(&Blob.PermanentGuid,&m_StaticInfo.PermanentDeviceGuid, sizeof(GUID));
    Blob.dwCmd            = dwCmd;

    mfn_LineEventProc(
        pCall->htCall,
        LINE_SENDMSPDATA,
        (ULONG_PTR)NULL,
        (ULONG_PTR)&Blob,
        Blob.dwTotalSize,
        psl
        );

    return;
}

#endif  // (TAPI3)

void
CTspDev::mfn_ProcessCallerID( UINT uMsg, char *szInfo, CStackLog *psl)
{
	FL_DECLARE_FUNC(0x0e357d3f, "CTspDev::mfn_ProcessCallerID")
	TSPRETURN tspRet = 0;
	FL_LOG_ENTRY(psl);
    CALLINFO *pCall = (m_pLine) ? m_pLine->pCall : NULL;


    //
    //  call the process rings handler to makesure a call is created prior to
    //  attempting to report the caller id info. THis is needed for countries where
    //  caller id info shows up before the first ring
    //
    //  the first parameter tells it not to report a devstate ringing message since we don't have one
    //  of those yet.
    //
    CTspDev::mfn_ProcessRing(FALSE,psl);

    if (m_pLine)
    {
        pCall = m_pLine->pCall;
    } else
    {
        pCall = NULL;
    }


    if (    pCall && pCall->IsActive() && !pCall->IsAborting())
    {
        if (pCall->IsActive())
        {
            BOOL fSendNotification = FALSE;

            switch(uMsg)
            {

            case MODEM_CALLER_ID_DATE:
                SLPRINTF1(psl, "CALLER_ID_DATE:%s", szInfo);
                break;

            case MODEM_CALLER_ID_TIME:
                SLPRINTF1(psl, "CALLER_ID_TIME", szInfo);
                break;

            case MODEM_CALLER_ID_NUMBER:
                SLPRINTF1(psl, "CALLER_ID_NUMBER", szInfo);
                if (szInfo)
                {
                    UINT u = lstrlenA(szInfo); // not including NULL.
                    if (u>=sizeof(pCall->CIDInfo.Number))
                    {
                        u = sizeof(pCall->CIDInfo.Number)-1;
                    }

                    if (u)
                    {
                        CopyMemory(pCall->CIDInfo.Number, szInfo, u);
                        pCall->CIDInfo.Number[u]=0;
                        fSendNotification = TRUE;
                    }
                }
                break;

            case MODEM_CALLER_ID_NAME:
                SLPRINTF1(psl, "CALLER_ID_NAME", szInfo);
                if (szInfo)
                {

                    UINT u = lstrlenA(szInfo); // not including NULL.
                    if (u>=sizeof(pCall->CIDInfo.Name))
                    {
                        u = sizeof(pCall->CIDInfo.Name)-1;
                    }

                    if (u)
                    {
                        CopyMemory(pCall->CIDInfo.Name, szInfo, u);
                        pCall->CIDInfo.Name[u]=0;
                        fSendNotification = TRUE;
                    }
                }
                break;

            case MODEM_CALLER_ID_MESG:
                SLPRINTF1(psl, "CALLER_ID_MESG", szInfo);
                break;

            }

            if (fSendNotification)
            {
                mfn_LineEventProc(
                                pCall->htCall,
                                LINE_CALLINFO,
                                LINECALLINFOSTATE_CALLERID,
                                NULL,
                                NULL,
                                psl
                                );
            }
        }
    }

	FL_LOG_EXIT(psl, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\tsp\cfact.cpp ===
// 
// Copyright (c) 1996-1997 Microsoft Corporation.
//
//
// Component
//
//		Unimodem 5.0 TSP (Win32, user mode DLL)
//
// File
//
//		CFACT.CPP
//		Implements class CTspDevFactory
//
// History
//
//		11/16/1996  JosephJ Created
//
//
#include "tsppch.h"
#include "tspcomm.h"
//#include <umdmmini.h>
//#include <uniplat.h>
#include "cmini.h"
#include "cdev.h"
#include "cfact.h"
#include "globals.h"
#include <setupapi.h>
extern "C" {
#include <cfgmgr32.h>
}


#define USE_SETUPAPI 1
//          1/21/1998 JosephJ
//          Setting the following key to 0 will make use use the registry
//          directly to enumerate devices. This works as of 1/21 (use it to
//          help isolate suspected setupapi/configapi-related problems.

FL_DECLARE_FILE(0x6092d46c, "Implements class CTspDevFactory")

TCHAR cszHWNode[]       = TEXT("SYSTEM\\CurrentControlSet\\Control\\Class\\{4D36E96D-E325-11CE-BFC1-08002BE10318}");

static DWORD g_fQuitAPC;

const TCHAR cszMiniDriverGUID[] = TEXT("MiniDriverGUID");
const TCHAR cszPermanentIDKey[]   = TEXT("ID");

// JosephJ 5/15/1997
//  This is the modem device class GUID. It is cast in stone, and also
//  defined in the header <devguid.h>, but I do not want to include
//  the ole-related headers just for this.
//

const GUID  cguidDEVCLASS_MODEM =
         {
             0x4d36e96dL, 0xe325, 0x11ce,
             { 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 }
         };

static
UINT
get_installed_permanent_ids(
                    DWORD **ppIDs,
                    UINT  *pcLines, // OPTIONAL
                    UINT  *pcPhones, // OPTIONAL
                    CStackLog *psl
                    );


void
apcQuit (ULONG_PTR dwParam)
{
    ConsolePrintfA("apcQuit: called\n");
    g_fQuitAPC = TRUE;
    return;
}




CTspDevFactory::CTspDevFactory()
	: m_sync(),
	  m_ppMDs(NULL),
	  m_cMDs(0),
      m_DeviceChangeThreadStarted(FALSE)
{
}

CTspDevFactory::~CTspDevFactory()
{
}

// #define DUMMY_FACT
#ifdef DUMMY_FACT
#define NUM_CDEVS 1000
#endif // DUMMY_FACT

TSPRETURN
CTspDevFactory::Load(CStackLog *psl)
{
	FL_DECLARE_FUNC(0x0485e9ea, "CTspDevFactory::Load")
	TSPRETURN tspRet=m_sync.BeginLoad();
    HKEY hkRoot = NULL;
	DWORD dwRet;

	#define DRIVER_ROOT_KEY \
     "SYSTEM\\CurrentControlSet\\Control\\Class\\" \
     "{4D36E96D-E325-11CE-BFC1-08002BE10318}"

	UINT u=0;
	DWORD dwAPC_TID;
	const char * lpcszDriverRoot = DRIVER_ROOT_KEY;

	FL_LOG_ENTRY(psl);

	m_sync.EnterCrit(FL_LOC);
	m_pslCurrent=psl;

	if (tspRet) goto end;

    // Start APC thread(s)
    //
    m_hThreadAPC = CreateThread(
                        NULL,           // default security
					    64*1024,        // set stack size to 64K
					    tepAPC,         // thread entry point
					    &g_fQuitAPC,   // thread info
					    CREATE_SUSPENDED, // Start suspended
					    &dwAPC_TID
                        );  // thread id

    if (m_hThreadAPC)
    {
        SLPRINTF2(
            psl,
            "Created APC Thread;(TID=%lu,h=0x%lx)",
            dwAPC_TID,
            m_hThreadAPC
            );
        g_fQuitAPC = FALSE;
        ResumeThread(m_hThreadAPC);

        //
        //  give it a little boost. BRL
        //
        SetThreadPriority(
            m_hThreadAPC,
            THREAD_PRIORITY_ABOVE_NORMAL
            );

    }
    else
    {
		FL_SET_RFR(0x0a656000,  "Could not create APC Thread!");
		tspRet = FL_GEN_RETVAL(IDERR_ALLOCFAILED);
		goto end_load;
    }


	// Note: mini drivers get loaded as a side-effect of loading the devices --
    // see mfn_construct_device.
	//
	FL_ASSERT(psl,!m_ppMDs);

    #if OBSOLETE_CODE
	m_pMD = new CTspMiniDriver;
	if (!m_pMD)
	{
		tspRet = FL_GEN_RETVAL(IDERR_ALLOCFAILED);
		goto end_load;
	}
	tspRet = m_pMD->Load(TEXT(""), psl);
	if (tspRet) goto end_load;
    #endif // OBSOLETE_CODE

#ifdef DUMMY_FACT
    {
        char cszDummyDriverEntry[]       = DRIVER_ROOT_KEY "\\0000";
    
        m_ppDevs = (CTspDev**)  ALLOCATE_MEMORY(NUM_CDEVS*sizeof(m_ppDevs));
        if (!m_ppDevs)
        {
            tspRet = FL_GEN_RETVAL(IDERR_ALLOCFAILED);
            goto end_load;
        }
    
        m_cDevs = 0;
    
        for (u=0;u<NUM_CDEVS;u++)
        {
            CTspDev *pDev=NULL;
            TSPRETURN tspRet1 = mfn_construct_device(
                                    cszDummyDriverEntry,
                                    &pDev
                                    );
            if (!tspRet1)
            {
                FL_ASSERT(psl, pDev);
                m_ppDevs[u] = pDev;
                m_cDevs++;
            }
        }
    }

#else // !DUMMY_FACT

#endif  // !DUMMY_FACT

	// SLPRINTF1(psl, "Constructed %lu devices", m_cDevs);

end_load:

	if(tspRet)
	{
	    if (hkRoot)
	    {
	        RegCloseKey(hkRoot);
	        hkRoot = NULL;
	    }
		mfn_cleanup(psl);
	}

	m_sync.EndLoad(tspRet==0);

end:

	m_pslCurrent=NULL;
	m_sync.LeaveCrit(FL_LOC);

	FL_LOG_EXIT(psl, tspRet);

	return tspRet;

}

// Synchronous cleanup
void
CTspDevFactory::mfn_cleanup(CStackLog *psl)
{
	FL_DECLARE_FUNC(0x0db8f222, "Fct::mfn_cleanup")
	HANDLE hEvent = NULL;

	FL_LOG_ENTRY(psl);

	if (m_ppMDs)
	{
		hEvent = CreateEvent(
					NULL,
					TRUE,
					FALSE,
					NULL
					);
	}

	// Unload and delete the mini drivers.
	// Note: if hEvent is null, we don't try to unload, because there could
	// be devices in the process of unloading still -- this is a highly
	// unsual event.
	//
	if (!hEvent)
    {
        m_cMDs = 0;
        m_ppMDs = NULL;
    }
    else if (m_ppMDs)
	{
	    // Free any loaded drivers ...
        UINT cMDs = m_cMDs;
		LONG lMDCounter = (LONG) cMDs;

        ASSERT(lMDCounter);

		for (UINT u=0;u<cMDs;u++)
		{
			CTspMiniDriver *pMD=m_ppMDs[u];
            ASSERT(pMD);
            pMD->Unload(hEvent, &lMDCounter);
		}

		// Wait for all the drivers to finish unloading.
        // SLPRINTF0(psl, "Waiting for drivers to unload");
        FL_SERIALIZE(psl, "Waiting for drivers to unload");
        WaitForSingleObject(hEvent, INFINITE);
        FL_SERIALIZE(psl, "drivers done unloading");
        // SLPRINTF0(psl, "drivers done unloading");
        //OutputDebugString(TEXT("CFACT:drivers done unloading. Deleting...\r\n"));
        
        // Now nuke it
        for (u=0;u<cMDs;u++)
        {
            CTspMiniDriver *pMD=m_ppMDs[u];
            ASSERT(pMD);
            delete pMD;
        }

        // Nuke the array of pointers to drivers.
        FREE_MEMORY(m_ppMDs);
        m_cMDs = 0;
        m_ppMDs=NULL;
	}

	if (hEvent)
	{
		CloseHandle(hEvent); hEvent = NULL;
	}

	// Kill the APC thread(s) .... 
	if (m_hThreadAPC)
	{
        BOOL fRet= QueueUserAPC(
                        apcQuit,
                        m_hThreadAPC,
                        0
                        );
        if (fRet)
        {
            FL_SERIALIZE(psl, "Waiting for apc thread to exit");
            WaitForSingleObject(m_hThreadAPC, INFINITE);
            FL_SERIALIZE(psl, "Apc thread exited");
            CloseHandle(m_hThreadAPC);
        }
        else
        {
            // Well we can't do much here -- leave the thread dangling and
            // get out of here.
        }
        m_hThreadAPC=NULL;
        g_fQuitAPC = FALSE;
    }

	FL_LOG_EXIT(psl, 0);
}

void
CTspDevFactory::Unload(
    HANDLE hEvent,
    LONG  *plCounter,
	CStackLog *psl
	)
{
	FL_DECLARE_FUNC(0x2863bc3b, "CTspDevFactory::Unload")
	TSPRETURN tspRet= m_sync.BeginUnload(hEvent,plCounter);

	if (tspRet)
	{
		// We only consider the "SAMESTATE" error harmless.
		ASSERT(IDERR(tspRet)==IDERR_SAMESTATE);
		goto end;
	}

	m_sync.EnterCrit(FL_LOC);

	mfn_cleanup(psl);


	m_sync.EndUnload();

    ASSERT(m_cMDs==0);
    ASSERT(m_ppMDs==NULL);

	m_sync.LeaveCrit(FL_LOC);

end:
	
	return;

}

TSPRETURN
CTspDevFactory::mfn_construct_device(
					char *szDriver,
					CTspDev **ppDev,
                    const DWORD *pInstalledPermanentIDs,
                    UINT cPermanentIDs
					)
{
	FL_DECLARE_FUNC(0x8474d30c, "Fact::mfn_construct_device")
	HKEY hkDevice = NULL;
	CStackLog *psl = m_pslCurrent;
	CTspDev *pDev = new CTspDev;
	TSPRETURN tspRet = FL_GEN_RETVAL(IDERR_INVALID_ERR);
	DWORD dwRet;
    CTspMiniDriver *pMD = NULL;
    DWORD dwRegType=0;
    UINT u;

    GUID guid = UNIMDMAT_GUID; // structure copy;

	FL_LOG_ENTRY(psl);

	if (!pDev)
	{
		tspRet = FL_GEN_RETVAL(IDERR_ALLOCFAILED);
		goto end;
	}

	dwRet = RegOpenKeyA(
				HKEY_LOCAL_MACHINE,
				szDriver,
				&hkDevice
				);

	if (dwRet != ERROR_SUCCESS)
	{
		FL_SET_RFR(0xfbe34d00, "Couldn't open driver key");
		tspRet = FL_GEN_RETVAL(IDERR_REG_OPEN_FAILED);
		goto end;
	}

	//
	// Get it's permanent ID and check if its in the passed-in
	// list of permanent IDs. This is a hacky way of determining
	// if this device is really installed.
	//
    {
        DWORD dw=0;
        DWORD dwRegSize = sizeof(dw);
        BOOL fRet = FALSE;

        // 5/17/1997 JosephJ
        // TODO: because setup apis don't work we
        // ignore pInstalledPermanentIDs for now
        // fRet = TRUE;

        dwRet = RegQueryValueExW(
                    hkDevice,
                    cszPermanentIDKey,
                    NULL,
                    &dwRegType,
                    (BYTE*) &dw,
                    &dwRegSize
                );

        // TODO: Change ID from REG_BINARY to REG_DWORD in modem
        //       class installer.
        if (dwRet == ERROR_SUCCESS 
            && (dwRegType == REG_BINARY || dwRegType == REG_DWORD)
            && dwRegSize == sizeof(dw))
        {
            while(cPermanentIDs--)
            {
                if (*pInstalledPermanentIDs++ == dw)
                {
                    fRet = TRUE;
                    break;
                }
            }
        }

        if (!fRet)
        {
            FL_SET_RFR(0x60015d00, "Device not in list of installed devices");

            tspRet = FL_GEN_RETVAL(IDERR_DEVICE_NOTINSTALLED);
            goto end;
        }
    }


    //
    //  Determine GUID of the mini-driver to use for this device.
    //

    // First check that the field exists -- if it doesnt, we default 
    // to the standard GUID.
    dwRet = RegQueryValueExW(
                hkDevice,
                cszMiniDriverGUID,
                NULL,
                &dwRegType,
                NULL,
                NULL
            );
        
    if (dwRet==ERROR_SUCCESS)
    {
        // It exists, now we query the key. An error now is FATAL.
        DWORD dwRegSize = sizeof(guid);
        dwRet = RegQueryValueExW(
                    hkDevice,
                    cszMiniDriverGUID,
                    NULL,
                    &dwRegType,
                    (BYTE*) &guid,
                    &dwRegSize
                );

        if (dwRet != ERROR_SUCCESS
            || dwRegType != REG_BINARY
            || dwRegSize != sizeof(GUID))
        {
            FL_SET_RFR(0x0ed9fe00, "RegQueryValueEx(GUID) fails");
            tspRet = FL_GEN_RETVAL(IDERR_REG_QUERY_FAILED);
            goto end;
        }
    }

    SLPRINTF3(
        psl,
        "GUID={0x%lu,0x%lu,0x%lu,...}",
        guid.Data1,
        guid.Data2,
        guid.Data3);

    
    // If we've already loaded the mini-driver with this GUID, find it.
    for (u = 0; u < m_cMDs; u++)
    {
        CTspMiniDriver *pMD1 = m_ppMDs[u];
        if (pMD1->MatchGuid(&guid))
        {
            pMD = pMD1;
            break;
        }
    }


    if (!pMD)
    {
        // We haven't loaded the mini-driver with this GUID -- so load it
        // here ....

        // Since the list of loaded mini-drivers is a simple array, we
        // re-allocate it here, creating an array with one-greater number
        // of elements.
        //
        CTspMiniDriver **ppMD = NULL;

	    pMD = new CTspMiniDriver;
        if (pMD)
        {
            ppMD = (CTspMiniDriver **) ALLOCATE_MEMORY(
                                           (m_cMDs+1)*sizeof(*m_ppMDs));
            if (!ppMD)
            {
                delete pMD;
                pMD=NULL;
            }
        }

        if (!pMD)
        {
            tspRet = FL_GEN_RETVAL(IDERR_ALLOCFAILED);
            goto end;
        }


	    tspRet = pMD->Load(&guid, psl);
	    if (tspRet)
        {
            delete pMD;
            FREE_MEMORY(ppMD);
            pMD=NULL;
            ppMD=NULL;
            goto end;
        }

        // Add the mini driver to the list of the mini drivers.
        CopyMemory(ppMD, m_ppMDs, m_cMDs*sizeof(*ppMD));
        ppMD[m_cMDs]=pMD;
        if (m_ppMDs) {FREE_MEMORY(m_ppMDs);}
        m_ppMDs = ppMD;
        m_cMDs++;
    }

	// pDev->Load is responsible for closing hkDevice, unless it
	// return failure, in which case we are responsible for closing it.
	//
	tspRet = pDev->Load(
					hkDevice,
					NULL,
	                g.rgtchProviderInfo,
					szDriver,
					pMD,
					m_hThreadAPC,
					psl
					);

    // Note -- we don't bother to unload the mini-driver if the device
    // fails to load. This mini-driver will get unloaded when providerShutdown
    // down is called (when CFact::Unload is called).

end:

	if (tspRet)
	{
		if (hkDevice)
		{
			RegCloseKey(hkDevice);
			hkDevice=NULL;
		}
		delete pDev;
		pDev = NULL;
	}
	else
	{
		*ppDev = pDev;
	}

	FL_LOG_EXIT(psl, tspRet);

	return tspRet;

}

static
UINT
get_installed_permanent_ids(
                    DWORD **ppIDs,
                    UINT  *pcLines, // OPTIONAL
                    UINT  *pcPhones, // OPTIONAL
                    CStackLog *psl
                    )
//
// Enumerate installed modems, and create and return a list of
// DWORD permanent IDs of the installed modems...
//
//
{
  FL_DECLARE_FUNC(0x0a435f46, "get permanent ID list")
  FL_LOG_ENTRY(psl);

  UINT cIDs = 0;
  DWORD *pIDs = NULL;
  DWORD cPhones=0;
  DWORD cLines=0;

  // Get the device info set
  //
#if (USE_SETUPAPI)
 
  HDEVINFO          hdevinfo = SetupDiGetClassDevsW(
                                            (GUID*)&cguidDEVCLASS_MODEM,
                                            NULL,
                                            NULL,
                                            DIGCF_PRESENT
                                            );
#else // !USE_SETUPAPI
  HKEY hkRoot =  NULL;
  DWORD dwRet = RegOpenKeyA(
                        HKEY_LOCAL_MACHINE,
                        DRIVER_ROOT_KEY,
                        &hkRoot
                        );
#endif // !USE_SETUPAPI


#if (USE_SETUPAPI)
  if (hdevinfo)
#else
  if (dwRet==ERROR_SUCCESS)
#endif
  {
    
    //
    // We build a list of IDs because we don't know how many we have
    // up-front. Later we convert this into an array which we return.
    //

    class Node
    {
    public:
        Node(DWORD dwID, Node *pNext) {m_dwID=dwID; m_pNext = pNext;}
        ~Node() {}

        DWORD m_dwID;
        Node *m_pNext;

    };

    Node *pNode = NULL;

#if (USE_SETUPAPI)
    SP_DEVINFO_DATA   diData;

    diData.cbSize = sizeof(diData);
#else 
        FILETIME ft;
        char rgchNodeName[128];
        DWORD cchSubKeyLength = 
             (sizeof(rgchNodeName)/sizeof(rgchNodeName[0]));
#endif 


    // Enumerate each installed modem
    //
    for (
        DWORD iEnum=0;
    #if (USE_SETUPAPI)
        SetupDiEnumDeviceInfo(hdevinfo, iEnum, &diData);
    #else
        !RegEnumKeyExA(
                    hkRoot,  // handle of key to enumerate 
                    iEnum,  // index of subkey to enumerate 
                    rgchNodeName,  // buffer for subkey name 
                    &cchSubKeyLength,   // ptr to size of subkey buffer 
                    NULL, // reserved 
                    NULL, // address of buffer for class string 
                    NULL,  // address for size of class buffer 
                    &ft // address for time key last written to 
                    );
    #endif // !USE_SETUAPI
        iEnum++
        )
    {

    #if (USE_SETUPAPI)
        // 9/12/1997 JosephJ -- commented this out, because we will also
        //              exclude devices which "need restart" and this
        //              MAY confuse ras installation -- interaction between
        //              ras coclassinstaller, which would have just
        //              installed the net adapter, and ras, which
        //              might (not sure) expect to query tapi and
        //              enumerate the newly-installed line.

        //
        // 9/12/97 JosephJ Don't include modems which "have a problem."
        //
        {
            ULONG ulStatus=0, ulProblem = 0;
            DWORD dwRet = CM_Get_DevInst_Status (
                            &ulStatus,
                            &ulProblem,
                            diData.DevInst,
                            0);
            if (   (CR_SUCCESS != dwRet)
                || (ulProblem != 0))
            {
		        SLPRINTF0(psl,  "Skipping this one...");
                continue;
            }
        }
    #endif // !USE_SETUPAPI

        // Get the driver key
        //
    #if (USE_SETUPAPI)
        HKEY hKey = SetupDiOpenDevRegKey(
                            hdevinfo,
                            &diData,
                            DICS_FLAG_GLOBAL,
                            0,
                            DIREG_DRV,
                            KEY_READ
                            );
    #else
        HKEY hKey = NULL;
        dwRet = RegOpenKeyA(
                        hkRoot,
                        rgchNodeName,
                        &hKey
                        );

        if (dwRet!=ERROR_SUCCESS)
        {
            hKey =NULL;
        }
    #endif // !USE_SETUPAPI

        if (!hKey || hKey == INVALID_HANDLE_VALUE)
        {
	        SLPRINTF1(
                psl,
                "SetupDiOpenDevRegKey failed with 0x%08lx",
                GetLastError()
                );
        }
        else
        {
            DWORD dwID=0;
            BOOL fSuccess = FALSE;

            #if (DONT_USE_BLOB)
            DWORD cbSize=sizeof(dwID);
            DWORD dwRegType=0;
            DWORD dwRet = 0;

            // TODO: use MiniDriver APIs to interpret the registry key....
           
            // Get the permanent ID
            dwRet = RegQueryValueEx(
                                    hKey,
                                    cszPermanentIDKey,
                                    NULL,
                                    &dwRegType,
                                    (BYTE*) &dwID,
                                    &cbSize
                                );

            if (dwRet == ERROR_SUCCESS
                && (dwRegType == REG_BINARY || dwRegType == REG_DWORD)
                && cbSize == sizeof(dwID)
                && dwID)
            {
                //
                // Add to our litle list of permanent IDs...
                //
                pNode = new Node(dwID, pNode);
            }

            #else   // !DONT_USE_BLOB

            HCONFIGBLOB hBlob = UmRtlDevCfgCreateBlob(hKey);
            
            if (hBlob)
            {
                if (UmRtlDevCfgGetDWORDProp(
                        hBlob,
                        UMMAJORPROPID_IDENTIFICATION,
                        UMMINORPROPID_PERMANENT_ID,
                        &dwID
                        ))
                {
                    // Get basic caps
                    DWORD dwBasicCaps = 0;
                    if (UmRtlDevCfgGetDWORDProp(
                            hBlob,
                            UMMAJORPROPID_BASICCAPS,
                            UMMINORPROPID_BASIC_DEVICE_CAPS,
                            &dwBasicCaps
                        ))
                    {

                        fSuccess = TRUE;
        
                        //
                        // Add to our litle list of permanent IDs...
                        //
                        pNode = new Node(dwID, pNode);

                        if (dwBasicCaps & BASICDEVCAPS_IS_LINE_DEVICE)
                        {
                            cLines++;
                        }

                        if (dwBasicCaps & BASICDEVCAPS_IS_PHONE_DEVICE)
                        {
                            #ifndef DISABLE_PHONE
                            cPhones++;
                            #endif // DISABLE_PHONE
                        }
                    }
                }
                        

                UmRtlDevCfgFreeBlob(hBlob);
                hBlob = NULL;
            }

            if (!fSuccess)
            {
                SLPRINTF0(
                    psl, "WARNING: Error processing driver key for device",
                    );
            }

            #endif // !DONT_USE_BLOB

            RegCloseKey(hKey);
        };

    #if (!USE_SETUPAPI)
        cchSubKeyLength = 
             (sizeof(rgchNodeName)/sizeof(rgchNodeName[0]));

    #endif
    }

  #if (USE_SETUPAPI)
    SetupDiDestroyDeviceInfoList(hdevinfo);
    hdevinfo=NULL;
  #else 
    RegCloseKey(hkRoot);
    hkRoot = NULL;
  #endif // !USE_SETUPAPI

    // Now count up...
    for (Node *pTemp = pNode; pTemp; pTemp = pTemp->m_pNext)
    {
        cIDs++;
    }

    if (cIDs)
    {
        // Alloc the exact sized array.
        pIDs = (DWORD*) ALLOCATE_MEMORY(cIDs*sizeof(DWORD));
        DWORD *pdw = pIDs;
        
        // Fill up the array and delete the nodes as we go along...
        while(pNode)
        {
            if (pIDs)
            {
                *pdw++ = pNode->m_dwID;
            }                    

            Node *pTemp = pNode;
            pNode = pNode->m_pNext;
            delete pTemp;

        }

        if (pIDs)
        {
            ASSERT((pdw-pIDs)==(LONG)cIDs);
        }
        else
        {
            // Alloc failed...
		    FL_SET_RFR(0xecbbaf00,  "Could not alloc for Perm ID array!");
		    cIDs=0;
        }
            
    }
  };

  if (!cIDs)
  {
    cLines = cPhones = 0;
  }

  *ppIDs = pIDs;

  if (pcLines)
  {
    *pcLines = cLines;
  }

  if (pcPhones)
  {
    *pcPhones = cPhones;
  }

  FL_LOG_EXIT(psl, cIDs);

  return cIDs;

}

TSPRETURN
CTspDevFactory::GetInstalledDevicePIDs(
		DWORD *prgPIDs[],
		UINT  *pcPIDs,
		UINT  *pcLines,  // OPTIONAL
		UINT  *pcPhones, // OPTIONAL
        CStackLog *psl
		)
{
	FL_DECLARE_FUNC(0x54aa404d, "Factory: get installed device PIDs")
    TSPRETURN tspRet=0;
	FL_LOG_ENTRY(psl);

    *pcPIDs =  get_installed_permanent_ids(
                    prgPIDs,
                    pcLines,
                    pcPhones,
                    psl
                    );

	FL_LOG_EXIT(psl, tspRet);
    return tspRet;
}

TSPRETURN
CTspDevFactory::CreateDevices(
		DWORD rgPIDs[],
		UINT  cPIDs,
		CTspDev **prgpDevs[],
		UINT *pcDevs,
        CStackLog *psl
		)
//
// On success **prgpDevs will contain a ALLOCATE_MEMORY'd array of pointers to
// the created device. It is the responsibility of the caller to free this
// array.
//
{
	FL_DECLARE_FUNC(0xb34e357b, "Factory: Create Devices")
    TSPRETURN tspRet=0; // success
	const char * lpcszDriverRoot = DRIVER_ROOT_KEY;
	CTspDev **rgpDevs = NULL;
	UINT cDevs=0;
    UINT u=0;
    char rgchDeviceName[MAX_REGKEY_LENGTH+1];
    DWORD cSubKeys=0;
    DWORD cbMaxSubKeyLen=0;
    UINT  cPermanentIDs=0;
    LONG cchRoot;
    LONG lRet;
    DWORD dwRet;
    HKEY hkRoot=NULL;

	FL_LOG_ENTRY(psl);

    m_sync.EnterCrit(FL_LOC);

    *pcDevs=0;
    *prgpDevs=NULL;

    if (!cPIDs) goto end;

    //
    // Find out how many subkeys exist under the driver root, allocate
    // space for as many devices,  then enumerate the subkeys, attempting
    // to create one device for each subkey.
    //
    // The final device count is the number
    // of successfully created devices. "Create" includes reading the relevant
    // modem subkeys. There is a potential race condition here -- the count
    // of devices may change after we call RegQueryInfoKey on the root. This
    // is not really a problem -- we may miss some *just* added devices,
    // or try to query for too many.
    // We call RegEnumKey on the number we initially got, and 
    // if RegEnumKey fails we continue to the next one.
    //
    // We will only create device objects for devices whose permanent
    // IDs (PIDs) are in the list of supplied PIDs. Typically this list of PIDs
    // was created in an earlier call to CTspDevFactory::GetInstalledDevicePIDs.
    //
    // In the case of a re-enumeration while the TSP is running, this list
    // will be a subset (constructed by the device manager) of only the PIDs
    // of devices objects which have not previously been created -- see
    // CTspDevMgr::ReEnumerateDevices for more details.
    //


    dwRet = RegOpenKeyA(
                HKEY_LOCAL_MACHINE,
                lpcszDriverRoot,
                &hkRoot
                );
    if(dwRet!=ERROR_SUCCESS)
    {
        FL_SET_RFR(0xdc682200, "Couldn't open driver root key");
        tspRet = FL_GEN_RETVAL(IDERR_REG_OPEN_FAILED);
        goto end;
    }
    
    lRet =  RegQueryInfoKey (
                    hkRoot,       // handle of key to query 
                    NULL,       // buffer for class string 
                    NULL,  // place to put class string buffer size
                    NULL, // reserved 
                    &cSubKeys,  // place to put number of subkeys 
                    &cbMaxSubKeyLen, // place to put longetst subkey name length
                    NULL,       // place to put longest class string length 
                    NULL,       // place to put number of value entries 
                    NULL,       // place to put longest value name length 
                    NULL,       // place to put longest value data length 
                    NULL,       // place to put security descriptor length 
                    NULL        // place to put last write time 
                   );   
 
    if (lRet != ERROR_SUCCESS)
    {
        FL_SET_RFR(0xc9088600, "RegQueryInfoKey(root key) failed");
        tspRet = FL_GEN_RETVAL(IDERR_REG_QUERY_FAILED);
        goto end;
    }
    
    SLPRINTF1(  
        psl,
        "RegQueryInfoKey(root) says there are %lu subkeys",
        cSubKeys
        );

    cchRoot =  lstrlenA(lpcszDriverRoot);
    if ((cchRoot+1) >= (sizeof(rgchDeviceName)/sizeof(rgchDeviceName[0])))
    {
        FL_SET_RFR(0xdcc7fe00, "Driver root name too long");
        tspRet = FL_GEN_RETVAL(IDERR_INTERNAL_OBJECT_TOO_SMALL);
        goto end;
    }

    if (!cSubKeys)
    {
        goto end;
    }


    // Remember that this is all explicitly ANSI, not TCHAR
    //
    CopyMemory(rgchDeviceName, lpcszDriverRoot, cchRoot*sizeof(char));
    CopyMemory(rgchDeviceName+cchRoot, "\\", sizeof("\\"));

    //
    // Allocate space for the array of pointers to Devices. We expect that 
    // we will be able to create all cPIDs Devices. If we get less it's
    // not considered an error case. *pcDevs will be set to the actual
    // number of devices created, which will be <= cPIDs.
    //
    rgpDevs = (CTspDev**)  ALLOCATE_MEMORY(cPIDs*sizeof(rgpDevs));
    if (!rgpDevs)
    {
        tspRet = FL_GEN_RETVAL(IDERR_ALLOCFAILED);
        goto end;
    }

    //
    // Enum keys, creating a device for each key. We stop either when we've
    // enumerated all the keys or if we create upto cPIDs devices,
    // whichever happens first.
    //
    for (u=0;u<cSubKeys && cDevs<cPIDs;u++)
    {
        FILETIME ft;
        CTspDev *pDev=NULL;
        DWORD cchSubKeyLength =
             (sizeof(rgchDeviceName)/sizeof(rgchDeviceName[0]))
             -(cchRoot+1);
        lRet = RegEnumKeyExA(
                    hkRoot,  // handle of key to enumerate 
                    u,  // index of subkey to enumerate 
                    rgchDeviceName+cchRoot+1,  // buffer for subkey name 
                    &cchSubKeyLength,   // ptr to size of subkey buffer 
                    NULL, // reserved 
                    NULL, // address of buffer for class string 
                    NULL,  // address for size of class buffer 
                    &ft // address for time key last written to 
                    );

        if (lRet) continue;

        // Note: mfn_construct_device will not construct the device if it's
        // PID is not in the array of pids, rgPIDs.

        TSPRETURN tspRet1 = mfn_construct_device(
                                rgchDeviceName,
                                &pDev,
                                rgPIDs,
                                cPIDs
                                );
        if (!tspRet1)
        {
            FL_ASSERT(psl, pDev);
            rgpDevs[cDevs++] = pDev;
        }
     }


    //
    // If we got no devices, we free the array here..
    //
    if (!cDevs)
    {
        FREE_MEMORY(rgpDevs);
        rgpDevs=NULL;
    }

    *pcDevs=cDevs;
    *prgpDevs=rgpDevs;

end:
     if (hkRoot)
     {
       RegCloseKey(hkRoot);
     }


    m_sync.LeaveCrit(FL_LOC);
	FL_LOG_EXIT(psl, tspRet);

    return tspRet;
}

void
CTspDevFactory::RegisterProviderState(BOOL fInit)
{
    if (fInit)
    {

        // 10/15/1997 JosephJ AWFUL HACK:
        // Because we don't get PNP device state change notifications as a service
        // we start a process here to monitor for these messages. This process
        // then calls NotifyTsp mailslot functions. The sole purpose of this
        // is to track PCMCIA removals and insertions, which do not trigger the
        // class installer.
        //
        // This must be fixed pror to rtm because it's an extra proces just
        // to track pcmcia modem removals and insertions!
        //
        // Bug 115764 tracks this.
        //

        m_DeviceChangeThreadStarted=StartMonitorThread();

    } else {

        if (m_DeviceChangeThreadStarted) {

            StopMonitorThread();
            m_DeviceChangeThreadStarted=FALSE;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\tsp\cmgr.cpp ===
//
// Copyright (c) 1996-1997 Microsoft Corporation.
//
//
// Component
//
//		Unimodem 5.0 TSP (Win32, user mode DLL)
//
// File
//
//		CMGR.CPP
//		Implements class CTspDevMgr
//
// History
//
//		11/16/1996  JosephJ Created
//
//
#include "tsppch.h"
#include "tspcomm.h"
#include "cdev.h"
#include "cfact.h"
#include "cmgr.h"
#include "globals.h"


FL_DECLARE_FILE(0x30713fa0, "Implements class CTspDevMgr")

DWORD
get_sig_name(CTspDev *pDev);

class CDevRec
{


	#define fTSPREC_ALLOCATED				(0x1L<<0)
	#define fTSPREC_DEVICE_AVAILABLE		(0x1L<<1)
	#define fTSPREC_DEVICE_TO_BE_REMOVED    (0x1L<<2)

	#define fTSPREC_LINE_CREATE_PENDING     (0x1L<<5)
	#define fTSPREC_LINE_CREATED            (0x1L<<6)
	#define fTSPREC_LINE_OPENED             (0x1L<<7)
	#define fTSPREC_LINE_REMOVE_PENDING     (0x1L<<8)

	#define fTSPREC_PHONE_CREATE_PENDING    (0x1L<<10)
	#define fTSPREC_PHONE_CREATED           (0x1L<<11)
	#define fTSPREC_PHONE_OPENED            (0x1L<<12)
	#define fTSPREC_PHONE_REMOVE_PENDING    (0x1L<<13)

	#define fTSPREC_IS_LINE_DEVICE          (0x1L<<14)
	#define fTSPREC_IS_PHONE_DEVICE         (0x1L<<15)

	// #define fTSPREC_LINESTATE_CREATE_PENDING	        (0x1L<<0)
	// #define fTSPREC_LINESTATE_CREATED	                (0x1L<<1)
	// #define fTSPREC_LINESTATE_CREATED_OPENED \
    //                      (fTSPREC_LINESTATE_CREATED & 0x1L<<2)
	// #define fTSPREC_LINESTATE_CREATED_OPENED_REMOVEPENDING \
    //              (fTSPREC_LINESTATE_CREATED_OPENED & 0x1L<<3)
	// #define fTSPREC_PHONESTATE_CREATE_PENDING	        (0x1L<<0)
	// #define fTSPREC_PHONESTATE_CREATED	                (0x1L<<1)
	// #define fTSPREC_PHONESTATE_CREATED_OPENED \
    //                    (fTSPREC_PHONESTATE_CREATED & 0x1L<<2)
	// #define fTSPREC_LINESTATE_CREATED_OPENED_REMOVEPENDING \
    //            (fTSPREC_PHONESTATE_CREATED_OPENED & 0x1L<<3)


	// Maybe use these someday...
	//
	// #define fTSPREC_LINEDEVICE_AVAILABLE			(0x1L<<1)
	// #define fTSPREC_PHONEDEVICE_AVAILABLE		(0x1L<<2)
	// #define fTSPREC_HDRVLINE_AVAILABLE			(0x1L<<3)
	// #define fTSPREC_HDRVPHONE_AVAILABLE			(0x1L<<4)
	// #define fTSPREC_HDRVCALL_AVAILABLE			(0x1L<<5)

public:

	
	DWORD DeviceAvailable(void)
	{
		return (m_dwFlags & fTSPREC_DEVICE_AVAILABLE);
	}

	DWORD IsLineDevice(void)
	{
		return (m_dwFlags & fTSPREC_IS_LINE_DEVICE);
	}

	DWORD IsPhoneDevice(void)
	{
		return (m_dwFlags & fTSPREC_IS_PHONE_DEVICE);
	}

	void MarkDeviceAsAvailable(void)
	{
		m_dwFlags |= fTSPREC_DEVICE_AVAILABLE;
	}

	// Use this when you get PnP OutOfService messages -- it will
	// automatically make all incoming TSPI calls fail -- check out,
	// for example, CTspDevMgr::TspDevFromLINEID.
	//
	void MarkDeviceAsUnavailable(void)
	{
		m_dwFlags &= ~fTSPREC_DEVICE_AVAILABLE;
	}

    UINT IsAllocated(void)
    {
        return m_dwFlags & fTSPREC_ALLOCATED;
    }

	void  MarkDeviceForRemoval(void)
	{
		m_dwFlags |= fTSPREC_DEVICE_TO_BE_REMOVED;
	}
         
	UINT  IsDeviceMarkedForRemoval(void)
	{
		return m_dwFlags & fTSPREC_DEVICE_TO_BE_REMOVED;
	}

	void  MarkLineOpen(void)
	{
		m_dwFlags |= fTSPREC_LINE_OPENED;
	}
         
	void  MarkLineClose(void)
	{
		m_dwFlags &= ~fTSPREC_LINE_OPENED;
	}

	UINT  IsLineOpen(void)
	{
		return m_dwFlags & fTSPREC_LINE_OPENED;
	}

	void  MarkLineCreatePending(void)
	{
		m_dwFlags |= fTSPREC_LINE_CREATE_PENDING;
	}

	UINT  IsLineCreatePending(void)
	{
		return m_dwFlags &  fTSPREC_LINE_CREATE_PENDING;
	}

	void  MarkLineRemovePending(void)
	{
		m_dwFlags |= fTSPREC_LINE_REMOVE_PENDING;
	}

	UINT  IsLineRemovePending(void)
	{
		return m_dwFlags &  fTSPREC_LINE_REMOVE_PENDING;
	}


	void  MarkLineCreated(DWORD dwDeviceID)
	{
		m_dwFlags |= fTSPREC_LINE_CREATED;
		m_dwFlags &= ~fTSPREC_LINE_CREATE_PENDING;
		m_dwLineID = dwDeviceID;
	}
         

	UINT  IsLineCreated(void)
	{
		return m_dwFlags & fTSPREC_LINE_CREATED;
	}

	void  MarkPhoneCreatePending(void)
	{
		m_dwFlags |= fTSPREC_PHONE_CREATE_PENDING;
	}

	UINT  IsPhoneCreatePending(void)
	{
		return m_dwFlags &  fTSPREC_PHONE_CREATE_PENDING;
	}

	void  MarkPhoneCreated(DWORD dwDeviceID)
	{
		m_dwFlags |= fTSPREC_PHONE_CREATED;
		m_dwFlags &= ~fTSPREC_PHONE_CREATE_PENDING;
		m_dwPhoneID = dwDeviceID;
	}
         

	UINT  IsPhoneCreated(void)
	{
		return m_dwFlags & fTSPREC_PHONE_CREATED;
	}

	void  MarkPhoneOpen(void)
	{
		m_dwFlags |= fTSPREC_PHONE_OPENED;
	}
         
	void  MarkPhoneClose(void)
	{
		m_dwFlags &= ~fTSPREC_PHONE_OPENED;
	}

	UINT  IsPhoneOpen(void)
	{
		return m_dwFlags & fTSPREC_PHONE_OPENED;
	}

	void  MarkPhoneRemovePending(void)
	{
		m_dwFlags |= fTSPREC_PHONE_REMOVE_PENDING;
	}

	UINT  IsPhoneRemovePending(void)
	{
		return m_dwFlags &  fTSPREC_PHONE_REMOVE_PENDING;
	}

	UINT  IsDeviceOpen(void)
	{
		return m_dwFlags & (fTSPREC_PHONE_OPENED|fTSPREC_LINE_OPENED);
	}

	CTspDev *
	TspDev(void)
	{
		ASSERT(!m_pTspDev || m_dwFlags & fTSPREC_ALLOCATED);
		return m_pTspDev;
	}

	DWORD
	LineID(void)
	{
		return m_dwLineID;
	}

	TSPRETURN
	GetName(
		    TCHAR rgtchDeviceName[],
		    UINT cbName)
	{
	    if (m_pTspDev) 
	    {
		    return m_pTspDev->GetName(rgtchDeviceName, cbName);
        }
        else
        {
            return IDERR_CORRUPT_STATE;
        }
	}

	DWORD
	SigName(void)
	{
		return  m_dwSigName;
	}

	DWORD
	PhoneID(void)
	{
		return m_dwPhoneID;
	}

	DWORD
	PermanentID(void)
	{
		return m_dwPermanentID;
	}

	DWORD
	Flags(void)
    // For DUMPING purposes only...
	{
		return m_dwFlags;
	}

	void Load(
		CTspDev *pTspDev
		)
	{
		ASSERT(!(m_dwFlags & fTSPREC_ALLOCATED));
		ASSERT(pTspDev);

		m_dwPermanentID =  pTspDev->GetPermanentID();
		m_dwSigName		=  get_sig_name(pTspDev);
		m_pTspDev		= pTspDev;

		m_dwFlags=fTSPREC_ALLOCATED;

        if (pTspDev->IsLine())
        {
		    m_dwFlags |=fTSPREC_IS_LINE_DEVICE;
        }

        if (pTspDev->IsPhone())
        {
		    m_dwFlags |=fTSPREC_IS_PHONE_DEVICE;
        }
	}

	void Unload(void)
	{
		ASSERT(m_dwFlags & fTSPREC_ALLOCATED);
		ZeroMemory((void *) this, sizeof(*this));
		m_dwLineID	= (DWORD)-1;
		m_dwPhoneID	= (DWORD)-1;
		// Note: m_dwFlags set to zero by above ZeroMemory
	}


private:

	// Constructor and Distructor are unused...
	CDevRec(void) {ASSERT(FALSE);}
	~CDevRec() 	  {ASSERT(FALSE);}

	DWORD m_dwFlags;
	DWORD m_dwLineID;
	DWORD m_dwPhoneID;
	DWORD m_dwPermanentID;
	DWORD m_dwSigName;
	CTspDev *m_pTspDev;

};


CTspDevMgr::CTspDevMgr()
	: m_sync (),
 	  m_rgDevRecs(NULL),
	  m_cDevRecs(0),
	  m_pFactory(NULL),

	  m_dwTSPIVersion(0),
	  m_dwPermanentProviderID(0),
	  m_dwLineDeviceIDBase(0),
	  m_dwPhoneDeviceIDBase(0),
	  m_dwNumLines(0),
	  m_dwNumPhones(0),
	  m_hProvider(NULL),
	  m_lpfnLineCreateProc(NULL),
	  m_lpfnPhoneCreateProc(NULL),
	  m_cbCompletionProc(NULL),
	  m_lpdwTSPIOption(NULL),
      m_pCachedEnumPIDs(NULL),
      m_cCachedEnumPIDs(0),
	  m_dwState(0)

{
}

CTspDevMgr::~CTspDevMgr()
{
 	  ASSERT(!m_rgDevRecs);
	  ASSERT(!m_cDevRecs);
	  ASSERT(!m_pFactory);
}

TSPRETURN
CTspDevMgr::Load(CStackLog *psl)
{
	FL_DECLARE_FUNC(0xe67d4034, "CTspDevMgr::Load")
	TSPRETURN tspRet=m_sync.BeginLoad();

	FL_LOG_ENTRY(psl);

	if (tspRet) goto end;

	m_sync.EnterCrit(FL_LOC);

	mfn_validate_state();

	m_pFactory  = new CTspDevFactory;

	if (m_pFactory)
	{
		tspRet = m_pFactory->Load(psl);
		if (tspRet)
		{
			delete m_pFactory;
			m_pFactory = NULL;
		}
	}
	else
	{
		tspRet = FL_GEN_RETVAL(IDERR_ALLOCFAILED);
	}

	m_sync.EndLoad(tspRet==0);

	mfn_validate_state();

	m_sync.LeaveCrit(FL_LOC);

end:

	FL_LOG_EXIT(psl, tspRet);
	return  tspRet;

}


TSPRETURN
CTspDevMgr::providerEnumDevices(
	DWORD dwPermanentProviderID,
	LPDWORD lpdwNumLines,
	LPDWORD lpdwNumPhones,
	HPROVIDER hProvider,
	LINEEVENT lpfnLineCreateProc,
	PHONEEVENT lpfnPhoneCreateProc,
	CStackLog *psl
)
{
	FL_DECLARE_FUNC( 0xf0025586,"Mgr::providerEnum");
	FL_LOG_ENTRY(psl);

	TSPRETURN tspRet=0;

	m_sync.EnterCrit(FL_LOC);

	mfn_validate_state();

	if (!m_sync.IsLoaded())
	{
		ASSERT(FALSE);
		tspRet = FL_GEN_RETVAL(IDERR_WRONGSTATE);
		goto end;
	}

    // Determine the number of devices by asking the factory for an array
    // of PIDs of installed devices. In anticipation of being called later
    // to actually create the device, we keep this array around.
    {
        DWORD *prgPIDs;
        UINT cPIDs=0;
        UINT cLines=0;
        UINT cPhones=0;
        tspRet = m_pFactory->GetInstalledDevicePIDs(
                                    &prgPIDs,
                                    &cPIDs,
                                    &cLines,
                                    &cPhones,
                                    psl
                                    );

        if (!tspRet)
        {
            ASSERT(!m_pCachedEnumPIDs && !m_cCachedEnumPIDs);
            *lpdwNumLines  = cLines;
            *lpdwNumPhones = cPhones;

            // Supporting devices which could be either line devices,
            // phone devices or both.
            //
            ASSERT( cLines<=cPIDs &&  cPhones<=cPIDs );

            // Cache away the list of PIDs.
            // On a subsequent providerInit, we will use this list
            // to actually create device instances.
            
            m_cCachedEnumPIDs = cPIDs;

            if (cPIDs)
            {
                m_pCachedEnumPIDs  = prgPIDs;
            }
            prgPIDs=NULL;
        }
    }

	if (tspRet) goto end;

	m_dwPermanentProviderID = dwPermanentProviderID;
	m_hProvider = hProvider;
	m_lpfnLineCreateProc = lpfnLineCreateProc;
	m_lpfnPhoneCreateProc = lpfnPhoneCreateProc;


end:

	mfn_validate_state();

	m_sync.LeaveCrit(FL_LOC);

	FL_LOG_EXIT(psl, tspRet);

	return tspRet;
}


TSPRETURN
CTspDevMgr::providerInit(
		DWORD             dwTSPIVersion,
		DWORD             dwPermanentProviderID,
	    DWORD             dwLineDeviceIDBase,
	    DWORD             dwPhoneDeviceIDBase,
	    DWORD             dwNumLines,
	    DWORD             dwNumPhones,
	    ASYNC_COMPLETION  cbCompletionProc,
	    LPDWORD           lpdwTSPIOptions,
		CStackLog *psl
)
{
	FL_DECLARE_FUNC(0xabed3ce9, "CTspMgr::providerInit");
	FL_LOG_ENTRY(psl);

	TSPRETURN tspRet=0;
	UINT cDevActual;
	CTspDev **ppDevs=NULL;
	UINT  u=0;
    UINT iLine=0;
    UINT iPhone=0;
    UINT uDeviceBase=0;

	m_sync.EnterCrit(FL_LOC);

	ASSERT(m_sync.IsLoaded());
	ASSERT(m_pFactory);
	ASSERT(m_pFactory->IsLoaded());

	// We support a max of 65K lines and phones, because of the way we create
	// our call handles (LOWORD==HDRVLINE, HIWORD==CallHandle).
	// Not that we expect to hit this limitation in real life :-)
	//
	if ((dwNumLines&0xFFFF0000L) || (dwNumPhones&0xFFFF0000L))
	{
		tspRet = FL_GEN_RETVAL(IDERR_INTERNAL_OBJECT_TOO_SMALL);
		goto end;
	}

    //
    if (  dwNumLines > m_cCachedEnumPIDs
       || dwNumPhones > m_cCachedEnumPIDs)
    {
        //
        // We should never get here, because providerInit should just return
        // what we reported in the previous call to providerEnum, and in
        // the call the latter we cache away the list of PIDs of devices
        // that were present at that time...
        //
        //
        // Note that each device can be a line-device or a phone-device or
        // both, but to TAPI they appear as a disjoint set of line- and
        // phone- devices.
        //
        tspRet = FL_GEN_RETVAL(IDERR_CORRUPT_STATE);
        goto end;
    }

	// Allocate enough space for the table;
	//
	m_cDevRecs = m_cCachedEnumPIDs;
    if (m_cDevRecs)
    {
        m_rgDevRecs = (CDevRec *) ALLOCATE_MEMORY(
                                        m_cDevRecs*sizeof(*m_rgDevRecs)
                                        );
    
        if (!m_rgDevRecs)
        {
            // fatal error....
            m_cDevRecs=0;
            FL_SET_RFR( 0x9f512b00, "Alloc m_rgDevRecs failed");
            tspRet = FL_GEN_RETVAL(IDERR_ALLOCFAILED);
            goto end;
        }
	}
	else
	{
        m_rgDevRecs = NULL;
	}

    {
        DWORD *rgPIDs = m_pCachedEnumPIDs;

        //
        // Reset the cached PID list.
        //
        m_pCachedEnumPIDs = NULL;
        m_cCachedEnumPIDs = NULL;

        tspRet = m_pFactory->CreateDevices(
                    rgPIDs,
	                m_cDevRecs,
                    &ppDevs,
                    &cDevActual,
                    psl
                    );

        // Free the PID array (on success or failure) ...
        if (rgPIDs)
        {
            FREE_MEMORY(rgPIDs);
            rgPIDs=NULL;
        }

    }

	if (tspRet)
	{
		FREE_MEMORY(m_rgDevRecs);
		m_rgDevRecs=NULL;
		m_cDevRecs=0;
		goto end;
	}

	// Squirrel away the parameters

	m_dwTSPIVersion 		= dwTSPIVersion;
	m_dwPermanentProviderID = dwPermanentProviderID;
	m_dwLineDeviceIDBase 	= dwLineDeviceIDBase;
	m_dwPhoneDeviceIDBase 	= dwPhoneDeviceIDBase;
	m_dwNumLines 			= dwNumLines;
	m_dwNumPhones 			= dwNumPhones;
	m_cbCompletionProc 		= cbCompletionProc;

	// TODO -- options -- alloc mem for them and copy them over if we ever
	// want to do anything with them.
	// m_lpdwTSPIOptions = lpdwTSPIOptions;

	ASSERT(m_cDevRecs>=cDevActual);


    //
    // To optimize lookup of devices on the basis of the lineID
    // (see mfn_find_by_LINEID)
    // in the common case that every device is a line device,
    // the devices are started at offset 
    // [LineDeviceIDBase % cdevices].
    //
   
    if (dwNumLines)
    {
        uDeviceBase = dwLineDeviceIDBase;
    }

	// Init the table. We go through the list of devices, and assign
	// lineIDs and phoneIDs starting from lineDeviceIDBase and phoneDeviceIDBase
	// provided the device is a linedevice or phonedevice, respectedly.
	// When we are done, we should have exhausted our allocate lineIDs and
	// phoneIDs because we told TAPI, via providerEnumDevices, exactly
	// how many line devices and phoneDevices we had.

	for (iLine=0,iPhone=0,u=0; u<cDevActual;u++)
	{
		CDevRec *pRec = m_rgDevRecs+((uDeviceBase+u)%m_cDevRecs);
		CTspDev *pDev = ppDevs[u];
		DWORD dwLineID =    0xffffffff; // Invalid lineID
		DWORD dwPhoneID =	0xffffffff; // Invalid PhoneID
		BOOL fLine=FALSE;
		BOOL fPhone=FALSE;

		
        pRec->Load(
            pDev
        );
        
        if (pRec->IsLineDevice())
        {
            dwLineID = dwLineDeviceIDBase + iLine++;
            fLine = TRUE;
        }

        if (pRec->IsPhoneDevice())
        {
            dwPhoneID = dwPhoneDeviceIDBase + iPhone++;
            fPhone = TRUE;
        }

        if ( (iLine > dwNumLines) || (iPhone > dwNumPhones) )
        {
            //
            // This should NEVER happen -- because we precomputed
            // how many lines and phones we had. Note that this test
            // should be AFTER the increments iLine++ and iPhone++ above..
            //

            FL_ASSERTEX(psl, FALSE, 0xa31b13dc, "Too many lines/phones!");

            // We don't give up entirely, instead we skip on to the next
            // device....
        }
        else
        {
            //
            // Note the device doesn't support a line (phone), the
            // lineID (phoneID) wil be set to a bogus value of 0xffffffff.
            //

            ULONG_PTR tspRet1 = pDev->RegisterProviderInfo(
                                        m_cbCompletionProc,
                                        m_hProvider,
                                        psl
                                        );
    
            //
            //  If the above call fails, we still keep the pointer to the device
            //  in our list so that we can unload it later, however we make sure
            //  that it is unavailable for TSPI calls by not marking it available.
            //
            if (!tspRet1)
            {

                if (fLine)
                {
                    pDev->ActivateLineDevice(dwLineID, psl);
                    pRec->MarkLineCreated(dwLineID);
                }

                if (fPhone)
                {
                    pDev->ActivatePhoneDevice(dwPhoneID, psl);
                    pRec->MarkPhoneCreated(dwPhoneID);
                }

                pRec->MarkDeviceAsAvailable();
            }
        }
	}

    FL_ASSERT(psl, (iLine == dwNumLines) && (iPhone == dwNumPhones) );
        
	// Note: if cDevActual is less than m_cDevRecs, the empty slots
	// in rgDevRecs are available for future new devices.

    // TODO: if there are empty slots, perhaps we should send up LINE_REMOVEs
    // or PHONE_REMOVEs for those slots, because TAPI still thinks that
    // they are valid devices.

end:

	if (ppDevs) {FREE_MEMORY(ppDevs); ppDevs=NULL;}

    //
    // On success, 
    // set our internal state to indicate that we've inited the provider
    //
    if (!tspRet)
    {
	    mfn_set_ProviderInited();

        CTspDevMgr::ValidateState(psl);

        m_pFactory->RegisterProviderState(TRUE);

        //
        //  reset the call counts in the platform driver
        //
        ResetCallCount();
    }
    else
    {
    	mfn_clear_ProviderInited();
	    // No cleanup to do here.
    }


	m_sync.LeaveCrit(FL_LOC);

	FL_LOG_EXIT(psl,tspRet);

	return tspRet;

}


TSPRETURN
CTspDevMgr::providerShutdown(
	DWORD dwTSPIVersion,
	DWORD dwPermanentProviderID,
	CStackLog *psl
	)
{
	FL_DECLARE_FUNC(0x795d7fb4, "CTspDevMgr::providerShutdown")
	FL_LOG_ENTRY(psl);

	m_sync.EnterCrit(FL_LOC);

    mfn_clear_ProviderInited();

	if (m_sync.IsLoaded())
	{
        m_sync.LeaveCrit(FL_LOC);

        m_pFactory->RegisterProviderState(FALSE);

		mfn_provider_shutdown(psl);

	} else {

        m_sync.LeaveCrit(FL_LOC);
    }

	FL_LOG_EXIT(psl, 0);
	return 0;
}


void   
CTspDevMgr::Unload(
	HANDLE hMgrEvent,
	LONG *plCounter,
	CStackLog *psl
	)
{
	TSPRETURN tspRet= m_sync.BeginUnload(hMgrEvent,plCounter);

	if (tspRet)
	{
		// We only consider the "SAMESTATE" error harmless.
		ASSERT(IDERR(tspRet)==IDERR_SAMESTATE);
		goto end;
	}


	mfn_provider_shutdown(psl);

	//
	// unload and delete the TspDevFactory
	//
	ASSERT(m_pFactory);
	m_pFactory->Unload(NULL,NULL,psl);
	delete m_pFactory;
	m_pFactory = NULL;

	m_sync.EndUnload();


end:

	return;
}



TSPRETURN
CTspDevMgr::TspDevFromLINEID(
	DWORD dwDeviceID,
	CTspDev **ppDev,
	HSESSION *phSession
	)
{
	FL_DECLARE_FUNC(0xd857f92a, "CTspDevMgr::TspDevFromLINEID")
	TSPRETURN tspRet=0;
	CTspDev *pDev = NULL;
	CDevRec *pRec = NULL;

	m_sync.EnterCrit(FL_LOC);


	// If we're loading or unloading, don't entertain any requests to dole
	// out  TspDevs...

	if (!m_sync.IsLoaded()) goto leave_crit;
	

	pRec = mfn_find_by_LINEID(dwDeviceID);
	if (pRec && pRec->DeviceAvailable())
	{
		pDev = pRec->TspDev();
		tspRet = pDev->BeginSession(phSession, FL_LOC);
	}

leave_crit:

	if (!pDev && !tspRet)
	{
		tspRet = FL_GEN_RETVAL(IDERR_INVALIDHANDLE);
	}

	if (!tspRet)
	{
		*ppDev = pDev;
	}

	m_sync.LeaveCrit(FL_LOC);

	return  tspRet;

}


TSPRETURN
CTspDevMgr::TspDevFromPHONEID(
	DWORD dwDeviceID,
	CTspDev **ppDev,
	HSESSION *phSession
	)
{
	FL_DECLARE_FUNC(0x4048221b, "CTspDevMgr::TspDevFromPHONEID")
	TSPRETURN tspRet=0;
	CTspDev *pDev = NULL;
	CDevRec *pRec = NULL;

	m_sync.EnterCrit(FL_LOC);


	// If we're loading or unloading, don't entertain any requests to dole
	// out  TspDevs...

	if (!m_sync.IsLoaded()) goto leave_crit;
	

	pRec = mfn_find_by_PHONEID(dwDeviceID);
	if (pRec && pRec->DeviceAvailable())
	{
		pDev = pRec->TspDev();
		tspRet = pDev->BeginSession(phSession, FL_LOC);
	}

leave_crit:

	if (!pDev && !tspRet)
	{
		tspRet = FL_GEN_RETVAL(IDERR_INVALIDHANDLE);
	}

	if (!tspRet)
	{
		*ppDev = pDev;

	}

	m_sync.LeaveCrit(FL_LOC);

	return  tspRet;
}


TSPRETURN
CTspDevMgr::TspDevFromHDRVCALL(
	HDRVCALL hdCall,
	CTspDev **ppDev,
	HSESSION *phSession
	)
{
	FL_DECLARE_FUNC(0x450b3cc5, "CTspDevMgr::TspDevFromHDRVCALL")
	TSPRETURN tspRet=0;
	CTspDev *pDev = NULL;

	m_sync.EnterCrit(FL_LOC);


	// If we're loading or unloading, don't entertain any requests to dole
	// out  TspDevs...

	if (!m_sync.IsLoaded()) goto leave_crit;
	

	// Get device
	{
		UINT u = LOWORD(hdCall);
		if (u < m_cDevRecs)
		{
			CDevRec *pRec = m_rgDevRecs+u;
			if (pRec->DeviceAvailable())
			{
				pDev = pRec->TspDev();
				tspRet = pDev->BeginSession(phSession, FL_LOC);
			}
		}
	}
leave_crit:

	if (!pDev && !tspRet)
	{
		tspRet = FL_GEN_RETVAL(IDERR_INVALIDHANDLE);
	}

	if (!tspRet)
	{
		*ppDev = pDev;
	}

	m_sync.LeaveCrit(FL_LOC);

	return  tspRet;

}

TSPRETURN
CTspDevMgr::TspDevFromHDRVLINE(
	HDRVLINE hdLine,
	CTspDev **ppDev,
	HSESSION *phSession
	)
{
	FL_DECLARE_FUNC(0x5872c234, "CTspDevMgr::TspDevFromHDRVLINE")
	TSPRETURN tspRet=0;
	CTspDev *pDev = NULL;

	m_sync.EnterCrit(FL_LOC);


	// If we're loading or unloading, don't entertain any requests to dole
	// out  TspDevs...

	if (!m_sync.IsLoaded()) goto leave_crit;
	

	// Get device
	{
		CDevRec *pRec = mfn_find_by_HDRVLINE(hdLine);
		if (pRec && pRec->DeviceAvailable())
		{
			pDev = pRec->TspDev();
			tspRet = pDev->BeginSession(phSession, FL_LOC);
		}
	}

leave_crit:

	if (!pDev && !tspRet)
	{
		tspRet = FL_GEN_RETVAL(IDERR_INVALIDHANDLE);
	}

	if (!tspRet)
	{
		*ppDev = pDev;
	}

	m_sync.LeaveCrit(FL_LOC);

	return  tspRet;

}

TSPRETURN
CTspDevMgr::TspDevFromHDRVPHONE(
	HDRVPHONE hdPhone,
	CTspDev **ppDev,
	HSESSION *phSession
	)
{
	FL_DECLARE_FUNC(0x98638065, "CTspDevMgr::TspDevFromHDRVPHONE")
	TSPRETURN tspRet=0;
	CTspDev *pDev = NULL;

	m_sync.EnterCrit(FL_LOC);


	// If we're loading or unloading, don't entertain any requests to dole
	// out  TspDevs...

	if (!m_sync.IsLoaded()) goto leave_crit;
	

	// Get device
	{
		CDevRec *pRec = mfn_find_by_HDRVPHONE(hdPhone);
		if (pRec &&  pRec->DeviceAvailable())
        {
            pDev = pRec->TspDev();
            tspRet = pDev->BeginSession(phSession, FL_LOC);
        }
	}
leave_crit:

	if (!pDev && !tspRet)
	{
		tspRet = FL_GEN_RETVAL(IDERR_INVALIDHANDLE);
	}

	if (!tspRet)
	{
		*ppDev = pDev;
	}

	m_sync.LeaveCrit(FL_LOC);


	return  tspRet;

}

CDevRec *
CTspDevMgr::mfn_find_by_LINEID(DWORD dwLineID)
{

	// Start looking sequentially from (dwDeviceID modulo m_cDevRecs) -- this
	// will be the exact location if this device existed since lineInitialize
	// and there were no pnp events since then....
	//
	// This function will be constant-time 
	// if there have been no PnP events since TAPI was initialized.

	UINT u  = m_cDevRecs;
	CDevRec *pRecEnd = m_rgDevRecs+u;
	CDevRec *pRec = u ? (m_rgDevRecs + (dwLineID % u)) : NULL ;

	while(u--)
	{
		if (pRec->IsLineDevice() && pRec->LineID() == dwLineID)
		{
			return pRec;
		}
		if (++pRec >= pRecEnd) {pRec = m_rgDevRecs;}
	}

	return NULL;
}


CDevRec *
CTspDevMgr::mfn_find_by_PHONEID(DWORD dwPhoneID)
{
    // Unlike find_by_LINEID, we simply start from the beginning and
    // sequentially look for the phone device -- it's unlikely that we'll
    // be using tons of phone devices!

    // Note that there need not be as many Phone devices as line devices.
    // or vice versa.

	CDevRec *pRecEnd = m_rgDevRecs+m_cDevRecs;

	for (CDevRec *pRec = m_rgDevRecs; pRec < pRecEnd; pRec++)
	{
		if (pRec->IsPhoneDevice() && pRec->PhoneID() == dwPhoneID)
		{
			return pRec;
		}
	}

	return NULL;
}

CDevRec *
CTspDevMgr::mfn_find_by_HDRVLINE(HDRVLINE hdLine)
{
	CDevRec *pRec = m_rgDevRecs + (ULONG_PTR)hdLine;

	// hdLine is simply the offset of the pRec in the m_rgDevRecs array.
	// Note: if hdLine is some large bogus value, above + could rollover, hence
	// the >= check below.
	//
	if (   pRec >= m_rgDevRecs
        && pRec < (m_rgDevRecs+m_cDevRecs)
        && pRec->IsLineDevice())
	{
		return pRec;
	}
	else
	{
		return NULL;
	}
}

CDevRec *
CTspDevMgr::mfn_find_by_HDRVPHONE(HDRVPHONE hdPhone)
{
	CDevRec *pRec = m_rgDevRecs + (ULONG_PTR)hdPhone;

	// hdPhone is simply the offset of the pRec in the m_rgDevRecs array.
	// Note: if hdPhone is some large bogus value, above + could rollover, hence
	// the >= check below.
	//
	if (   pRec >= m_rgDevRecs
        && pRec < (m_rgDevRecs+m_cDevRecs)
        && pRec->IsPhoneDevice())
	{
		return pRec;
	}
	else
	{
		return NULL;
	}
}

void
CTspDevMgr::mfn_validate_state(void)
{
	if (m_sync.IsLoaded())
	{
		ASSERT(m_pFactory);
		ASSERT(m_pFactory->IsLoaded());
	}
	else
	{
		ASSERT(!m_rgDevRecs);
		ASSERT(!m_cDevRecs);
		ASSERT(!m_pFactory);
		ASSERT(!m_dwTSPIVersion);
		ASSERT(!m_dwPermanentProviderID);
		ASSERT(!m_dwLineDeviceIDBase);
		ASSERT(!m_dwPhoneDeviceIDBase);
		ASSERT(!m_dwNumLines);
		ASSERT(!m_dwNumPhones);
		ASSERT(!m_hProvider);
		ASSERT(!m_lpfnLineCreateProc);
		ASSERT(!m_lpfnPhoneCreateProc);
		ASSERT(!m_cbCompletionProc);
		ASSERT(!m_lpdwTSPIOption);
	}
}

void
CTspDevMgr::mfn_provider_shutdown(
	CStackLog *psl
    )
{
	FL_DECLARE_FUNC(0xbc8280db, "CTspDevMgr::mfn_provider_shutdown")
	HANDLE hEvent = CreateEvent(
					NULL,
					TRUE,
					FALSE,
					NULL
					);

	LONG lCount = 0;
	CDevRec *pRec = NULL;
	CDevRec *pRecEnd = NULL;

	m_sync.EnterCrit(FL_LOC);

	if (!hEvent)
	{
		// We need this event to be able to wait for all the devices to finisn
		// unloading, so if this fails we simply orphan all the devices -- we
		// don't unload them.
		ASSERT(FALSE);
		goto end;
	}


	// Set the counter to the number of existing pDevs. Later we call
	// Unload on each pDev and each call will cause an interlocked
	// decrement of this counter ...
	pRec = m_rgDevRecs;
	pRecEnd = m_rgDevRecs+m_cDevRecs;
	for(; pRec<pRecEnd; pRec++)
	{
		if (pRec->TspDev())
		{
			pRec->MarkDeviceAsUnavailable();
			lCount++;
		}
	}

    if (lCount)
    {

        // Start unload for each of them ...
        pRec = m_rgDevRecs;
        pRecEnd = m_rgDevRecs+m_cDevRecs;
        for(; pRec<pRecEnd; pRec++)
        {
            CTspDev *pDev  = pRec->TspDev();
            if (pDev)
            {
                pDev->Unload(hEvent, &lCount);
            }
        }
    
        m_sync.LeaveCrit(FL_LOC);
    
        FL_SERIALIZE(psl, "Waiting for devices to unload");
        WaitForSingleObject(hEvent,INFINITE);
        FL_SERIALIZE(psl, "Devices done unloading");
    
        m_sync.EnterCrit(FL_LOC);
    }

	CloseHandle(hEvent);
	hEvent = NULL;


	// Delete...
	pRec = m_rgDevRecs;
	pRecEnd = m_rgDevRecs+m_cDevRecs;
	for(; pRec<pRecEnd; pRec++)
	{
		CTspDev *pDev  = pRec->TspDev();
		if (pDev)
		{
			delete pDev;
		}
	}

end:

	if (m_rgDevRecs)
	{
		FREE_MEMORY(m_rgDevRecs);
	}

	m_rgDevRecs=NULL;
	m_cDevRecs=0;

	m_dwLineDeviceIDBase = 0;
	m_dwPhoneDeviceIDBase = 0;
	m_dwNumLines = 0;
	m_dwNumPhones = 0;
	m_cbCompletionProc = NULL;

	m_sync.LeaveCrit(FL_LOC);

}


TSPRETURN
CTspDevMgr::lineOpen(
	DWORD dwDeviceID,
	HTAPILINE htLine,
	LPHDRVLINE lphdLine,
	DWORD dwTSPIVersion,
	LINEEVENT lpfnEventProc,
	LONG *plRet,
	CStackLog *psl
	)
//
// TODO
//  -- Deal with OUTOFSERVICE/DEVICEREMOVED
//  -- Maybe pass eventproc into tracing function?
//  -- Maybe fail if we're already open?
{
	FL_DECLARE_FUNC(0x69be2d10, "CTspDevMgr::lineOpen")
	LONG lRet = LINEERR_OPERATIONFAILED;

	FL_LOG_ENTRY(psl);

	m_sync.EnterCrit(FL_LOC);

	CDevRec *pRec = mfn_find_by_LINEID(dwDeviceID);

	if (!pRec)
	{
		FL_SET_RFR(0x4fa75b00, "Could not find the device");
		lRet = LINEERR_BADDEVICEID;
	}
	else
	{

        TSPRETURN tspRet;

		// We determine the HDRVLINE associated with
		// this device and pass on the lineOpenCall down to the device.

		FL_ASSERT(psl, (pRec->LineID() == dwDeviceID));

		// TODO: maybe check some state here -- line is not open or so forth.

		// The HDRVLINE associated with a device is simply the zero-based
		// index of pRec from the start of the internally-maintained array,
		// m_rgDevRecs.
		//
		// We set the hDrvLine here, so the device gets to know what its
		// hdrvline is, if it cares (it has no reason to really,
		// except perhaps for logging purposes).
		//
		// 2/9/1997 Well the device needs to know hdrvline because it needs
		// to provider the hdrvline when reporting a new call.
		//
		*lphdLine = (HDRVLINE) (pRec - m_rgDevRecs);

		// Lets pass on down the open request to the device.....
		TASKPARAM_TSPI_lineOpen params;
		params.dwStructSize = sizeof(params);
		params.dwTaskID = TASKID_TSPI_lineOpen;
		params.dwDeviceID = dwDeviceID;
		params.htLine = htLine;
		params.lphdLine = lphdLine;
		params.dwTSPIVersion = dwTSPIVersion;
		params.lpfnEventProc = lpfnEventProc;

		CTspDev *pDev = pRec->TspDev();
		DWORD dwRoutingInfo = ROUTINGINFO(
							TASKID_TSPI_lineOpen,
							TASKDEST_LINEID
							);

        if (pDev != NULL)
        {
            tspRet = pDev->AcceptTspCall(
                    FALSE,
                    dwRoutingInfo,
                    &params,
                    &lRet,
                    psl
                                        );

            if (tspRet)
            {
                lRet = LINEERR_OPERATIONFAILED;
            }

            if (!lRet)
            {
                pRec->MarkLineOpen();
            }
        } else
        {
            lRet = LINEERR_OPERATIONFAILED;
        }

	}

	*plRet = lRet;

	m_sync.LeaveCrit(FL_LOC);

	FL_LOG_EXIT(psl, 0);

	return 0;
}

TSPRETURN
CTspDevMgr::lineClose(
	HDRVLINE hdLine,
	LONG *plRet,
	CStackLog *psl
	)
{

	FL_DECLARE_FUNC(0x7bc6c17a, "CTspDevMgr::lineClose")
	LONG lRet = LINEERR_OPERATIONFAILED;

	FL_LOG_ENTRY(psl);

	m_sync.EnterCrit(FL_LOC);

	CDevRec *pRec = mfn_find_by_HDRVLINE(hdLine);

	if (!pRec)
	{
		FL_SET_RFR(0x5fd56200, "Could not find the device");
		lRet = LINEERR_INVALLINEHANDLE;
	}
	else
	{
	    psl->SetDeviceID(pRec->LineID());

		// TODO: maybe check some state here -- line is open and so forth.

		// Lets pass on down the open request to the device.....
		CTspDev *pDev = pRec->TspDev();

        if (pDev != NULL) {

	    	HSESSION hSession=NULL;
            TSPRETURN tspRet = pDev->BeginSession(&hSession, FL_LOC);

            if (!tspRet)
            {
                TASKPARAM_TSPI_lineClose params;
                DWORD dwRoutingInfo = ROUTINGINFO(
                                    TASKID_TSPI_lineClose,
                                    TASKDEST_HDRVLINE
                                    );
                params.dwStructSize = sizeof(params);
                params.dwTaskID = TASKID_TSPI_lineClose;
                params.hdLine = hdLine;

                //
                // 7/29/1997 JosephJ
                //          We now leave our crit section here, before
                //          calling lineClose, because lineClose could
                //          block for a loooong time, and we don't want
                //          to hold the CTspDevMgr's critical section for
                //          all that time!
                //
                m_sync.LeaveCrit(FL_LOC);
                tspRet = pDev->AcceptTspCall(
                                        FALSE,
                                        dwRoutingInfo,
                                        &params,
                                        &lRet,
                                        psl
                                        );
                m_sync.EnterCrit(FL_LOC);
                pDev->EndSession(hSession);
                hSession=NULL;
            }

	    	if (tspRet)
	    	{
	    		lRet = LINEERR_OPERATIONFAILED;
	    	}

	    	if (!lRet)
	    	{
	    		// TODO: maybe set some state here -- line is open or so forth.
	    	}

            // Actually we force unloading of device state here
            pRec->MarkLineClose();

            if (pRec->IsDeviceMarkedForRemoval() && !pRec->IsDeviceOpen())
            {
                SLPRINTF1(psl, "Unloading Device with LineID %lu", pRec->LineID());
                pDev->Unload(NULL, NULL);
                delete pDev;

                // Following frees up the pRec slot.
                //
                pRec->Unload();
            }

        } else {

            FL_SET_RFR(0x5fd5d200, "pRec->TspDev() == NULL");
            lRet = LINEERR_OPERATIONFAILED;
        }

	}

	*plRet = lRet;

	m_sync.LeaveCrit(FL_LOC);

	FL_LOG_EXIT(psl, 0);

	return 0;
}

TSPRETURN
CTspDevMgr::phoneOpen(
	DWORD dwDeviceID,
	HTAPIPHONE htPhone,
	LPHDRVPHONE lphdPhone,
	DWORD dwTSPIVersion,
	PHONEEVENT lpfnEventProc,
	LONG *plRet,
	CStackLog *psl
	)
{
	FL_DECLARE_FUNC(0x1c7158c4, "CTspDevMgr::phoneOpen")
	FL_LOG_ENTRY(psl);
	LONG lRet = PHONEERR_OPERATIONFAILED;


	m_sync.EnterCrit(FL_LOC);

	CDevRec *pRec = mfn_find_by_PHONEID(dwDeviceID);

	if (!pRec)
	{
		FL_SET_RFR(0x47116d00, "Could not find the device");
		lRet = PHONEERR_BADDEVICEID;
	}
	else
	{
		// We determine the HDRVPHONE associated with
		// this device and pass on the lineOpenCall down to the device.

		FL_ASSERT(psl, (pRec->PhoneID() == dwDeviceID));

		// TODO: maybe check some state here -- phone is not open or so forth.

		// The HDRVPHONE associated with a device is simply the zero-based
		// index of pRec from the start of the internally-maintained array,
		// m_rgDevRecs.
		//
		// We set the hDrvPhone here, so the device gets to know what its
		// hdrvPhone is, if it cares (it has no reason to really,
		// except perhaps for logging purposes).
		//
		*lphdPhone = (HDRVPHONE) (pRec - m_rgDevRecs);

		// Lets pass on down the open request to the device.....
		TASKPARAM_TSPI_phoneOpen params;
		params.dwStructSize = sizeof(params);
		params.dwTaskID = TASKID_TSPI_phoneOpen;
		params.dwDeviceID = dwDeviceID;
		params.htPhone = htPhone;
		params.lphdPhone = lphdPhone;
		params.dwTSPIVersion = dwTSPIVersion;
		params.lpfnEventProc = lpfnEventProc;

		CTspDev *pDev = pRec->TspDev();

        if (pDev != NULL) {

       		DWORD dwRoutingInfo = ROUTINGINFO(
       							TASKID_TSPI_phoneOpen,
       							TASKDEST_PHONEID
       							);
       		TSPRETURN tspRet = pDev->AcceptTspCall(
       		                        FALSE,
       								dwRoutingInfo,
       								&params,
       								&lRet,
       								psl
       								);

       		if (tspRet)
       		{
       			lRet = PHONEERR_OPERATIONFAILED;
       		}

        } else {

            FL_SET_RFR(0x47216d00, "pRec->TspDev() == NULL");
            lRet = PHONEERR_OPERATIONFAILED;
        }

		if (!lRet)
		{
			pRec->MarkPhoneOpen();
		}
	}

	*plRet = lRet;

	m_sync.LeaveCrit(FL_LOC);

	FL_LOG_EXIT(psl, 0);

	return 0;
}

TSPRETURN
CTspDevMgr::phoneClose(
	HDRVPHONE hdPhone,
	LONG *plRet,
	CStackLog *psl
	)
{

	FL_DECLARE_FUNC(0xa17874e0, "CTspDevMgr::phoneClose")
	LONG lRet = PHONEERR_OPERATIONFAILED;

	FL_LOG_ENTRY(psl);

	m_sync.EnterCrit(FL_LOC);

	CDevRec *pRec = mfn_find_by_HDRVPHONE(hdPhone);

	if (!pRec)
	{
		FL_SET_RFR(0xdf3c8300, "Could not find the device");
		lRet = PHONEERR_INVALPHONEHANDLE;
	}
	else
	{
	    psl->SetDeviceID(pRec->PhoneID());

		// TODO: maybe check some state here -- phone is open and so forth.

		// Lets pass on down the open request to the device.....
		CTspDev *pDev = pRec->TspDev();

        if (pDev != NULL) {

	    	HSESSION hSession=NULL;
            TSPRETURN tspRet = pDev->BeginSession(&hSession, FL_LOC);

            if (!tspRet)
            {
                TASKPARAM_TSPI_phoneClose params;
                DWORD dwRoutingInfo = ROUTINGINFO(
                                    TASKID_TSPI_phoneClose,
                                    TASKDEST_HDRVPHONE
                                    );
                params.dwStructSize = sizeof(params);
                params.dwTaskID = TASKID_TSPI_phoneClose;
                params.hdPhone = hdPhone;

                //          We now leave our crit section here, before
                //          calling lineClose, because phoneClose could
                //          block for a loooong time, and we don't want
                //          to hold the CTspDevMgr's critical section for
                //          all that time!
                //
                m_sync.LeaveCrit(FL_LOC);
                tspRet = pDev->AcceptTspCall(
                                        FALSE,
                                        dwRoutingInfo,
                                        &params,
                                        &lRet,
                                        psl
                                        );
                m_sync.EnterCrit(FL_LOC);
                pDev->EndSession(hSession);
                hSession=NULL;
            }

	    	if (tspRet)
	    	{
	    		lRet = PHONEERR_OPERATIONFAILED;
	    	}

	    	if (!lRet)
	    	{
	    		// TODO: maybe set some state here -- line is open or so forth.
	    	}

            // Actually we force unloading of device state here
            pRec->MarkPhoneClose();

            if (pRec->IsDeviceMarkedForRemoval() && !pRec->IsDeviceOpen())
            {
                SLPRINTF1(psl, "Unloading Device with PhoneID %lu",pRec->PhoneID());
                pDev->Unload(NULL, NULL);
                delete pDev;

                // Following frees up the pRec slot.
                //
                pRec->Unload();
            }

        } else {

            FL_SET_RFR(0xdf3c9300, "pRec->TspDev == NULL");
            lRet = PHONEERR_OPERATIONFAILED;

        }

	}

	*plRet = lRet;

	m_sync.LeaveCrit(FL_LOC);

	FL_LOG_EXIT(psl, 0);

	return 0;
}


TSPRETURN
CTspDevMgr::TspDevFromPermanentID(
    DWORD dwPermanentID,
    CTspDev **ppDev,
    HSESSION *phSession
    )
{
    return  IDERR_UNIMPLEMENTED;
}

TSPRETURN
CTspDevMgr::ReEnumerateDevices(
        CStackLog *psl
        )
{
	FL_DECLARE_FUNC(0x77d6a00f, "ReEnumerate Devices")
    TSPRETURN tspRet = 0;
    DWORD *rgLatestPIDs=NULL;
    UINT cLatestPIDs=0;

    DWORD *rgNewPIDs=NULL;
    UINT cNewPIDs=0;
    UINT cExistingDevices=0;
    UINT cDevicesPendingRemoval=0;
    UINT u;

	FL_LOG_ENTRY(psl);

    m_sync.EnterCrit(FL_LOC);

    //
    // For now we do the whole shebang in a critical section.
    //
    //
    // We do something only if we have an active TAPI session going (i.e.,
    // in between TSPI_providerInit and TSPI_providerShutdown)
    // Note that in practise it will be hard to get here when the
    // TAPI session is not active.
    //
    if (!mfn_get_ProviderInited()) goto end;
    

    //
    // Ask Device Factory for list of currently installed device.
    // We'll use this list to decide which are the new devices, the
    // existing devices, and the gone (removed) devices.
    //
    tspRet = m_pFactory->GetInstalledDevicePIDs(
                                &rgLatestPIDs,
                                &cLatestPIDs,
                                NULL,
                                NULL,
                                psl
                                );

    if (tspRet)
    {
        rgLatestPIDs = NULL;
        goto end;
    }

    if (cLatestPIDs > 0)
    {
        // Allocate space to store array of new PIDs. Assume all PIDs are new,
        // for starters.
        rgNewPIDs =    (DWORD*) ALLOCATE_MEMORY(
                                    cLatestPIDs*sizeof(*rgNewPIDs)
                                    );
    }

    ASSERT(rgNewPIDs);

    // Go through our internal table of devices, disabling and removing
    // devices which no longer exist
    {

	    CDevRec *pRec = m_rgDevRecs;
        CDevRec *pRecEnd = pRec + m_cDevRecs;

        for(; pRec<pRecEnd; pRec++)
        {
            if (pRec->IsAllocated())
            {
                CTspDev *pDev  = pRec->TspDev();
                DWORD dwPID = pRec->PermanentID();
                BOOL fFound = FALSE;
                
                ASSERT(pDev);

                // check if it's in the "latest" list.
                for (u=0; u<cLatestPIDs;u++)
                {
                    if (dwPID==rgLatestPIDs[u])
                    {
                        fFound=TRUE;
                        cExistingDevices++;
                        break;
                    }
                }

                if (!fFound)
                {
                    SLPRINTF2(
                        psl,
                        "Removing dev%lu with PID=0x%08lx\n",
                        pRec->LineID(),
                        dwPID
                        );

                    //
                    // First thing we do is to inform the device that
                    // it's about to go away. This is so that it does not
                    // make any more mini-driver calls.
                    //
                    pDev->NotifyDeviceRemoved(psl);


                    if (pRec->IsLineDevice())
                    {
                        pRec->MarkLineRemovePending();
    
                        m_lpfnLineCreateProc(
                                0,
                                0,
                                LINE_REMOVE,
                                pRec->LineID(),
                                0,
                                0
                                );
                    }

                    if (pRec->IsPhoneDevice())
                    {
                        pRec->MarkPhoneRemovePending();
    
                        m_lpfnPhoneCreateProc(
                                0,
                                PHONE_REMOVE,
                                pRec->PhoneID(),
                                0,
                                0
                                );
                    }

                    if (!pRec->IsDeviceOpen())
                    {
	                    if (pDev)
	                    {
                            // DebugBreak();
	                        //
	                        // Note: This is synchronous unloading.
	                        // We could do all the unloads in parallel
	                        // and do async unload. However this is no
	                        // big deal because the line is anyway closed
	                        // so there is nothing to teardown.
	                        //
                            SLPRINTF1(psl, "Unloading Device with LineID %lu", pRec->LineID());
                            pDev->Unload(NULL, NULL);
			                delete pDev;

			                // Following frees up the pRec slot.
			                //
		                    pRec->Unload();	
                        }
                    }
                    else
                    {
                        // A line or phone device is open. We set a flag
                        // so that we unload the device when the line
                        // and phone are closed.

                        // We DON'T mark the device as unavailable here.
                        // There may be ongoing activity. According to TAPI
                        // docs, sending LINE/PHONE_REMOVE guarantees that
                        // the TSPI will not be called with dwDeviceID.

                        pRec->MarkDeviceForRemoval();

                        cDevicesPendingRemoval++;
                    }
                }
            }
        }
    }


    // Having removed old devices, we now look for new devices.
    // This time the outer loop is the LatestPID array. If we don't
    // Find the PID in our internal rable, we add this PID to the
    // rgNewPIDs array.

    // After bulding the rgNewPIDs array, we then
    // decide whether we need to re-allocate the table to fit all the new
    // IDs of if we can simply use existing free space in the internal
    // table.

    // Finally we go through and create the devices, and send up
    // LineCreateMessages and PhoneCreateMessages to TAPI.
    // TAPI will in-turn call TSPI_providerCreateLineDevice and
    // TSPI_providerCreatePhoneDevice to complete creation of the devices.

    // Here we build the rgNewPIDs array ...
    //
    for (u=0; u<cLatestPIDs;u++)
    {
        // check if we have this device ...
        CDevRec *pRec = m_rgDevRecs;
        CDevRec *pRecEnd = pRec + m_cDevRecs;
        DWORD dwPID = rgLatestPIDs[u];
        BOOL fFound = FALSE;

        for(; pRec<pRecEnd; pRec++)
        {

            if (pRec->IsAllocated())
            {
                CTspDev *pDev  = pRec->TspDev();
                
                ASSERT(pDev);

                if (dwPID==pRec->PermanentID())
                {
                    fFound=TRUE;
                    break;
                }
            }
        }

        if (!fFound)
        {
            SLPRINTF1(psl, "Found new dev with PID=0x%08lx\n", dwPID);
            rgNewPIDs[cNewPIDs++]=dwPID;
        }
    }

    // Total devices == (cExistingDevices+cNewPIDs+cDevicesPendingRemoval)
    // So lets now see if we have enough space in our existing table.
    //
    {
        UINT cTot =  cExistingDevices+cNewPIDs+cDevicesPendingRemoval;
        if (m_cDevRecs< cTot)
        {
            // Nope, let's realloc the table
            CDevRec *pRecNew = (CDevRec*) ALLOCATE_MEMORY(
                                                cTot*sizeof(*pRecNew)
                                                );
            if (!pRecNew)
            {
                FL_SET_RFR(0xabb35000, "Couldn't realloc space for resized table!");
                goto end;
            }

            CopyMemory(pRecNew, m_rgDevRecs, m_cDevRecs*sizeof(*pRecNew));

            if (m_rgDevRecs != NULL) {

               FREE_MEMORY(m_rgDevRecs);
            }
            m_rgDevRecs = pRecNew;
            m_cDevRecs = cTot;
    
            // Note any extra space will be zero-initialized.
        }
    }

    // Let us now go about creating the new devices, filling them
    // into free spaces in our table. By the above cTot calculations, there
    // WILL be enough space available.
    //
    if (cNewPIDs)
    {
        CTspDev **ppDevs=NULL;
        UINT cDevActual=0;
        CDevRec *pRec = m_rgDevRecs;
        CDevRec *pRecEnd = m_rgDevRecs+m_cDevRecs;

        tspRet = m_pFactory->CreateDevices(
                                rgNewPIDs,
                                cNewPIDs,
                                &ppDevs,
                                &cDevActual,
                                psl
                                );

        if (rgNewPIDs != NULL) {

            FREE_MEMORY(rgNewPIDs);
            rgNewPIDs=NULL;
        }


        if (!tspRet)
        {
            for (u=0;u<cDevActual;u++)
            {
                CTspDev *pDev = ppDevs[u];
                ASSERT(pDev);

                // Find a spot for it.
                for (; pRec<pRecEnd; pRec++)
                {
                    if (!(pRec->IsAllocated()))
                    {
                        UINT uIndex = (UINT)(pRec - m_rgDevRecs);

                        pRec->Load(
                            pDev
                        );
                    
                        // Notify TAPI that we have a new line and phone.

                        if (pRec->IsLineDevice())
                        {
                            pRec->MarkLineCreatePending();
    
                            m_lpfnLineCreateProc(
                                    0,
                                    0,
                                    LINE_CREATE,
                                    (ULONG_PTR) m_hProvider,
                                    uIndex,
                                    0
                                    );
                        }

                        if (pRec->IsPhoneDevice())
                        {
                            pRec->MarkPhoneCreatePending();
        
                            m_lpfnPhoneCreateProc(
                                    0,
                                    PHONE_CREATE,
                                    (ULONG_PTR) m_hProvider,
                                    uIndex,
                                    0
                                    );
                        }

                        pDev=NULL;
                        break;
                    }

                    // Note: we don't mark device as available here...
                }
                ASSERT(!pDev);
            }
        }
    }

end:


    //
    // rgLatestPIDs was allocated implicitly in the call to
    // m_pFactory->GetInstalledDevicePIDs. We free it here...
    //
    if (rgLatestPIDs != NULL)
    {
        FREE_MEMORY(rgLatestPIDs);
        rgLatestPIDs = NULL;
    }

    m_sync.LeaveCrit(FL_LOC);

	FL_LOG_EXIT(psl, tspRet);
    return tspRet;
}

// This function is called by a notication from unimodem when a driver
// update is occuring. It is responsible for causing the removal of
// the device
TSPRETURN
CTspDevMgr::UpdateDriver(
		DWORD dwPermanentID,
        CStackLog *psl
        )
{
    // Go through our internal table of devices
	CDevRec *pRec = m_rgDevRecs;
    CDevRec *pRecEnd = pRec + m_cDevRecs;
    TSPRETURN tspRet = 0;

	FL_DECLARE_FUNC(0x6b8a12e1, "CTspDevMgr::UpdateDriver")
	FL_LOG_ENTRY(psl);

    m_sync.EnterCrit(FL_LOC);

    for(; pRec<pRecEnd; pRec++)
    {
        if (pRec->IsAllocated())
        {
            CTspDev *pDev  = pRec->TspDev();
            DWORD dwPID = pRec->PermanentID();
            BOOL fFound = FALSE;
                
            ASSERT(pDev);

			if (dwPID == dwPermanentID)
			{
				SLPRINTF2(
					    psl,
                        "Removing dev%lu with PID=0x%08lx\n",
                        pRec->LineID(),
                        dwPID
                        );

                //
                // First thing we do is to inform the device that
                // it's about to go away. This is so that it does not
                // make any more mini-driver calls.
                //
                pDev->NotifyDeviceRemoved(psl);


                if (pRec->IsLineDevice())
                {
                    pRec->MarkLineRemovePending();
    
                    m_lpfnLineCreateProc(
                            0,
                            0,
                            LINE_REMOVE,
                            pRec->LineID(),
                            0,
                            0
                            );
                }			

                if (pRec->IsPhoneDevice())
                {
                    pRec->MarkPhoneRemovePending();
    
                    m_lpfnPhoneCreateProc(
                            0,
                            PHONE_REMOVE,
                            pRec->PhoneID(),
                            0,
                            0
                            );
                }

                if (!pRec->IsDeviceOpen())
                {
	                if (pDev)
	                {
                        // DebugBreak();
	                    //
	                    // Note: This is synchronous unloading.
	                    // We could do all the unloads in parallel
	                    // and do async unload. However this is no
	                    // big deal because the line is anyway closed
	                    // so there is nothing to teardown.
	                    //
                        SLPRINTF1(psl, "Unloading Device with LineID %lu", pRec->LineID());
                        pDev->Unload(NULL, NULL);
			            delete pDev;

			            // Following frees up the pRec slot.
			            //
		                pRec->Unload();	
                    }
                }
                else
                {
                    // A line or phone device is open. We set a flag
                    // so that we unload the device when the line
                    // and phone are closed.

                    // We DON'T mark the device as unavailable here.
                    // There may be ongoing activity. According to TAPI
                    // docs, sending LINE/PHONE_REMOVE guarantees that
                    // the TSPI will not be called with dwDeviceID.

					pRec->MarkDeviceForRemoval();

                    //cDevicesPendingRemoval++;
                }
				
            }
        }
    }
    m_sync.LeaveCrit(FL_LOC);

	FL_LOG_EXIT(psl, tspRet);
    return tspRet;
}

TSPRETURN
CTspDevMgr::providerCreateLineDevice(
                        DWORD dwTempID,
                        DWORD dwDeviceID,
                        CStackLog *psl
						)
{
	FL_DECLARE_FUNC(0xedb057ec, "CTspDevMgr::providerCreateLineDevice")
	FL_LOG_ENTRY(psl);
    TSPRETURN tspRet = 0;
    CDevRec *pRec = mfn_find_by_HDRVLINE((HDRVLINE)ULongToPtr(dwTempID)); // sundown: dwTempID is an offset that we zero-extend.

    //
    // TAPI calls us with CreateLineDevice and CreatePhoneDevice
    // A device can be a line or phone or both, and we can't
    // assume TAPI is calling createline or createphone in any order.
    // So, for any particular device, the 1st call to either is used
    // to call pDev->RegisterProviderInfo().
    //
    if (pRec && pRec->IsLineDevice())
    {
        CTspDev *pDev = pRec->TspDev();

        if (pDev != NULL) {

            if (!pRec->DeviceAvailable())
            {
                tspRet = pDev->RegisterProviderInfo(
                                        m_cbCompletionProc,
                                        m_hProvider,
                                        psl
                                        );
            }

            if (!tspRet)
            {
                pDev->ActivateLineDevice(dwDeviceID,psl);
                pRec->MarkLineCreated(dwDeviceID);
                pRec->MarkDeviceAsAvailable();
            }
        } else {

            FL_SET_RFR(0xab74bc00, "pRec->TspDev == NULL");
            tspRet = FL_GEN_RETVAL(IDERR_CORRUPT_STATE);

        }
    }
    else
    {
        FL_SET_RFR(0xaa74bc00, "Could not find specified new line device!");
        tspRet = FL_GEN_RETVAL(IDERR_CORRUPT_STATE);
    }

	FL_LOG_EXIT(psl, tspRet);

	return  tspRet;
}

TSPRETURN
CTspDevMgr::providerCreatePhoneDevice(
                        DWORD dwTempID,
                        DWORD dwDeviceID,
                        CStackLog *psl
						)
{
	FL_DECLARE_FUNC(0x7289f623, "CTspDevMgr::providerCreatePhoneDevice")
	FL_LOG_ENTRY(psl);
    TSPRETURN tspRet = 0;
    CDevRec *pRec = mfn_find_by_HDRVPHONE((HDRVPHONE)ULongToPtr(dwTempID)); // sundown: dwTempID is an offset that we zero-extend.

    //
    // See comments under providerPhoneDevice...
    //
    if (pRec && pRec->IsPhoneDevice())
    {
        CTspDev *pDev = pRec->TspDev();

        if (pDev != NULL) {

            if (!pRec->DeviceAvailable())
            {
                tspRet = pDev->RegisterProviderInfo(
                                        m_cbCompletionProc,
                                        m_hProvider,
                                        psl
                                        );
            }

            if (!tspRet)
            {
                pDev->ActivatePhoneDevice(dwDeviceID,psl);
                pRec->MarkPhoneCreated(dwDeviceID);
                pRec->MarkDeviceAsAvailable();
            }

        } else {

            FL_SET_RFR(0x7f36eb00, "Could not find specified new phone device!");
            tspRet = FL_GEN_RETVAL(IDERR_CORRUPT_STATE);
        }
    }
    else
    {
        FL_SET_RFR(0x7f37eb00, "pRec->TspDev() == NULL");
        tspRet = FL_GEN_RETVAL(IDERR_CORRUPT_STATE);
    }

	FL_LOG_EXIT(psl, tspRet);

	return  tspRet;
}


TSPRETURN
CTspDevMgr::TspDevFromName(
    LPCTSTR pctszName,
	CTspDev **ppDev,
	HSESSION *phSession
	)
{
	FL_DECLARE_FUNC(0xe4551645, "CTspDevMgr::TspDevFromName")
	TSPRETURN tspRet=0;
	CTspDev *pDev = NULL;
	CDevRec *pRec = NULL;

	m_sync.EnterCrit(FL_LOC);


	// If we're loading or unloading, don't entertain any requests to dole
	// out  TspDevs...

	if (!m_sync.IsLoaded()) goto leave_crit;
	

	pRec = mfn_find_by_Name(pctszName);
	if (pRec && pRec->DeviceAvailable())
	{
		pDev = pRec->TspDev();
		tspRet = pDev->BeginSession(phSession, FL_LOC);
	}

leave_crit:

	if (!pDev && !tspRet)
	{
		tspRet = FL_GEN_RETVAL(IDERR_INVALIDHANDLE);
	}

	if (!tspRet)
	{
		*ppDev = pDev;

	}

	m_sync.LeaveCrit(FL_LOC);

	return  tspRet;
}

CDevRec *
CTspDevMgr::mfn_find_by_Name(LPCTSTR pctszName)
{

    CDevRec *pRec = m_rgDevRecs;
	CDevRec *pRecEnd = pRec+m_cDevRecs;
	DWORD dwSig = Checksum(
                    (BYTE*)pctszName,
                    (lstrlen(pctszName)+1)*sizeof(*pctszName)
                    );

    for (; pRec<pRecEnd; pRec++)
	{
		if (pRec->SigName() == dwSig)
		{
            TCHAR rgtchDeviceName[MAX_DEVICE_LENGTH+1];
            TSPRETURN tspRet = pRec->GetName(
                                        rgtchDeviceName,
                                        sizeof(rgtchDeviceName)
                                        );
            
            if (!tspRet)
            {
                if (!lstrcmp(rgtchDeviceName, pctszName))
                {
                    goto end;
                }
            }
		}
	}
	pRec = NULL;

end:

	return pRec;
}


DWORD
get_sig_name(CTspDev *pDev)
{
    DWORD dwSig = 0;
    TCHAR rgtchDeviceName[MAX_DEVICE_LENGTH+1];
    TSPRETURN tspRet1 =  pDev->GetName(
                            rgtchDeviceName,
                            sizeof(rgtchDeviceName)
                            );
    
    if (!tspRet1)
    {
        dwSig = Checksum(
                    (BYTE*) rgtchDeviceName,
                    (lstrlen(rgtchDeviceName)+1)*sizeof(TCHAR)
                    );
    }
    else
    {
        // Should never get here, because rgtchDeviceName should always
        // be large enough...

        ASSERT(FALSE);
    }

    return dwSig;
} 

TSPRETURN
CTspDevMgr::ValidateState(CStackLog *psl)
{
	FL_DECLARE_FUNC(0x144ce138, "Mgr::ValidateState")
	FL_LOG_ENTRY(psl);

	TSPRETURN tspRet = 0;
	m_sync.EnterCrit(FL_LOC);

    CDevRec *pRec = m_rgDevRecs;
	CDevRec *pRecEnd = pRec+m_cDevRecs;

    // Enumerate all devices, and validate our internal state about them...
    for (; pRec<pRecEnd; pRec++)
	{
        TCHAR rgtchDeviceName[MAX_DEVICE_LENGTH+1];


        TSPRETURN tspRet = pRec->GetName(
                                    rgtchDeviceName,
                                    sizeof(rgtchDeviceName)
                                    );
        
        if (!tspRet)
        {
            HSESSION hSession=NULL;
            CTspDev *pDev = NULL;

            tspRet =  TspDevFromName(
                            rgtchDeviceName,
                            &pDev,
                            &hSession
                            );

            if (tspRet)
            {
                SLPRINTF1(  
                    psl,
                    "TspDevFromName FAILED    for device ID %lu",
                    pRec->LineID()
                    );
            }
            else
            {
		        pDev->EndSession(hSession);
                hSession=NULL;
                SLPRINTF1(  
                    psl,
                    "TspDevFromName succeeded for device ID %lu",
                    pRec->LineID()
                    );
                CTspDev *pDev1 = pRec->TspDev();
                FL_ASSERT(psl, (pDev1 == pDev));
            }
        }
	}

	m_sync.LeaveCrit(FL_LOC);
	FL_LOG_EXIT(psl, tspRet);

	return tspRet;
}

void
CTspDevMgr::DumpState(CStackLog *psl)
{
	FL_DECLARE_FUNC(0xb7fa261c, "DumpState")
	FL_LOG_ENTRY(psl);

	m_sync.EnterCrit(FL_LOC);

    CDevRec *pRec = m_rgDevRecs;
	CDevRec *pRecEnd = pRec+m_cDevRecs;

    // Enumerate all devices, and validate our internal state about them...
    for (; pRec<pRecEnd; pRec++)
	{
        TCHAR rgtchDeviceName[MAX_DEVICE_LENGTH+1];


        TSPRETURN tspRet = pRec->GetName(
                                    rgtchDeviceName,
                                    sizeof(rgtchDeviceName)
                                    );
        
        if (!tspRet)
        {
            char szName[128];
        
            UINT cb = WideCharToMultiByte(
                              CP_ACP,
                              0,
                              rgtchDeviceName,
                              -1,
                              szName,
                              sizeof(szName),
                              NULL,
                              NULL
                              );
        
            if (!cb)
            {
                CopyMemory(szName, "<unknown>", sizeof("<unknown>"));
            }
        
            SLPRINTFX(  
                psl,
                (
                    dwLUID_CurrentLoc,
                    "HDEV=%lu LiID=%lu PhID=%lu PeID=%lu Flags=0x%08lx\n"
                    "\t\"%s\"\n"
                    "\tSTATE:%s%s%s%s",
                    pRec-m_rgDevRecs,
                    pRec->LineID(),
                    pRec->PhoneID(),
                    pRec->PermanentID(),
                    pRec->Flags(),

                    szName,

                    pRec->DeviceAvailable()?" AVAIL":"",
                    pRec->IsLineOpen()?" LiOPEN":"",
                    pRec->IsPhoneOpen()?" PhOPEN":"",
                    pRec->IsDeviceMarkedForRemoval()?" REMOVE_PENDING":""
                )
            );
        }
	}

	m_sync.LeaveCrit(FL_LOC);
	FL_LOG_EXIT(psl, 0);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\tsp\cfact.h ===
// 
// Copyright (c) 1996-1997 Microsoft Corporation.
//
//
// Component
//
//		Unimodem 5.0 TSP (Win32, user mode DLL)
//
// File
//
//		CFACT.H
//		Defines class CTspDevFactory
//
// History
//
//		11/16/1996  JosephJ Created
//
//
#include "csync.h"

class CTspDevFactory
{

public:    

	CTspDevFactory();
	~CTspDevFactory();

	TSPRETURN Load(CStackLog *psl);

	void
	Unload(
		HANDLE hEvent,
		LONG *plCounter,
		CStackLog *psl
		);


    TSPRETURN
    GetInstalledDevicePIDs(
		DWORD *prgPIDs[],
		UINT  *pcPIDs,
		UINT  *pcLines,  // OPTIONAL
		UINT  *pcPhones, // OPTIONAL
        CStackLog *psl
		);

    TSPRETURN
    CreateDevices(
		DWORD rgPIDs[],
		UINT  cPIDs,
		CTspDev **rgpDevs[],
		UINT *pcDevs,
        CStackLog *psl
		);

    void
    RegisterProviderState(BOOL fInit);
    // This function is called just after successful providerInit,
    // with fInit==TRUE, and just before providerShutdown.


	BOOL IsLoaded(void)
	{
		return m_sync.IsLoaded();
	}

private:

	TSPRETURN
	mfn_construct_device(
            char *szDriver,
            CTspDev **pDev,
            const DWORD *pInstalledPermanentIDs,
            UINT cPermanentIDs
            );

	void
	mfn_cleanup(CStackLog *psl);

	CSync m_sync;
	CTspMiniDriver **m_ppMDs;  // Pointer to array of loaded devices.
	UINT m_cMDs;    // Number of loaded mini-drivers.

	CStackLog *m_pslCurrent;
	HANDLE m_hThreadAPC; // Could have multiple APC threads if required here.

    BOOL       m_DeviceChangeThreadStarted;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\tsp\cmgr.h ===
// 
// Copyright (c) 1996-1997 Microsoft Corporation.
//
//
// Component
//
//		Unimodem 5.0 TSP (Win32, user mode DLL)
//
// File
//
//		CMGR.H
//		Defines class CTspDevMgr
//
// History
//
//		11/16/1996  JosephJ Created
//
//
#include "csync.h"

class CDevRec;

class CTspDevMgr
{

public:

	CTspDevMgr();
	~CTspDevMgr();

	TSPRETURN Load(CStackLog *psl);

    TSPRETURN
    ValidateState(CStackLog *psl);

	void
	Unload(
		HANDLE hEvent,
		LONG *plCounter,
		CStackLog *psl
		);

	TSPRETURN
	TspDevFromLINEID(
		DWORD dwDeviceID,
		CTspDev **ppDev,
		HSESSION *phSession
		);

	TSPRETURN
	TspDevFromPHONEID(
		DWORD dwDeviceID,
		CTspDev **ppDev,
		HSESSION *phSession
		);

	TSPRETURN
	TspDevFromHDRVCALL(
		HDRVCALL hdCall,
		CTspDev **ppDev,
		HSESSION *phSession
		);

	TSPRETURN
	TspDevFromHDRVLINE(
		HDRVLINE hdLine,
		CTspDev **ppDev,
		HSESSION *phSession
		);

	TSPRETURN
	TspDevFromHDRVPHONE(
		HDRVPHONE hdPhone,
		CTspDev **ppDev,
		HSESSION *phSession
		);


	TSPRETURN
	TspDevFromPermanentID(
		DWORD dwPermanentID,
		CTspDev **ppDev,
		HSESSION *phSession
		);

	TSPRETURN
	TspDevFromName(
		LPCTSTR pctszName,
		CTspDev **ppDev,
		HSESSION *phSession
		);

	TSPRETURN
	providerEnumDevices(
		DWORD dwPermanentProviderID,
		LPDWORD lpdwNumLines,
		LPDWORD lpdwNumPhones,
		HPROVIDER hProvider,
		LINEEVENT lpfnLineCreateProc,
		PHONEEVENT lpfnPhoneCreateProc,
		CStackLog *psl
		);

	TSPRETURN
	providerInit(
		DWORD             dwTSPIVersion,
		DWORD             dwPermanentProviderID,
	    DWORD             dwLineDeviceIDBase,
	    DWORD             dwPhoneDeviceIDBase,
	    DWORD             dwNumLines,
	    DWORD             dwNumPhones,
	    ASYNC_COMPLETION  cbCompletionProc,
	    LPDWORD           lpdwTSPIOptions,
		CStackLog *psl
		);

	TSPRETURN
	providerShutdown(
		DWORD dwTSPIVersion,
		DWORD dwPermanentProviderID,
		CStackLog *psl
		);

	TSPRETURN
	lineOpen(
		DWORD dwDeviceID,
		HTAPILINE htLine,
		LPHDRVLINE lphdLine,
		DWORD dwTSPIVersion,
		LINEEVENT lpfnEventProc,
		LONG *plRet,
		CStackLog *psl
		);

	TSPRETURN
	lineClose(
		HDRVLINE hdLine,
		LONG *plRet,
		CStackLog *psl
		);

	TSPRETURN
	phoneOpen(
		DWORD dwDeviceID,
		HTAPIPHONE htPhone,
		LPHDRVPHONE lphdPhone,
		DWORD dwTSPIVersion,
		PHONEEVENT lpfnEventProc,
		LONG *plRet,
		CStackLog *psl
		);

	TSPRETURN
	phoneClose(
		HDRVPHONE hdPhone,
		LONG *plRet,
		CStackLog *psl
		);

    TSPRETURN
    ReEnumerateDevices(
        CStackLog *psl
        );

    TSPRETURN
    UpdateDriver(
		DWORD dwPermanentID,
        CStackLog *psl
        );

	TSPRETURN
    providerCreateLineDevice(
                        DWORD dwTempID,
                        DWORD dwDeviceID,
                        CStackLog *psl
						);

	TSPRETURN
    providerCreatePhoneDevice(
                        DWORD dwTempID,
                        DWORD dwDeviceID,
                        CStackLog *psl
						);
	TSPRETURN
	BeginSession(
		HSESSION *pSession,
		DWORD dwFromID
	)
	{
		return m_sync.BeginSession(pSession, dwFromID);
	}


	void EndSession(HSESSION hSession)
	{
		m_sync.EndSession(hSession);
	}

    void DumpState(CStackLog *psl);



private:

    // Following two are set during providerEnum, and cleared during
    // a subsequent providerInit.
    //
    DWORD *m_pCachedEnumPIDs;
    UINT   m_cCachedEnumPIDs;

	CDevRec * mfn_find_by_LINEID(DWORD dwLineID);

	CDevRec * mfn_find_by_PHONEID(DWORD dwPhoneID);

	CDevRec * mfn_find_by_HDRVLINE(HDRVLINE hdLine);

	CDevRec * mfn_find_by_HDRVPHONE(HDRVPHONE hdLine);

	CDevRec * mfn_find_by_Name(LPCTSTR pctszName);

	void mfn_provider_shutdown(
                CStackLog *psl
                );

    enum {
        fProviderInited = (0x1<<0)
    };

	void mfn_validate_state(void);

	void mfn_set_ProviderInited(void)
	{
		m_dwState |= fProviderInited;
	}

	void mfn_clear_ProviderInited(void)
	{
		m_dwState &= ~fProviderInited;
	}

	DWORD mfn_get_ProviderInited(void)
	{
		return m_dwState & fProviderInited;
	}

	DWORD			    m_dwState;

	CSync 				m_sync;

	CDevRec *			m_rgDevRecs;

	UINT 				m_cDevRecs;

	DWORD          		m_dwTSPIVersion;
	DWORD           	m_dwPermanentProviderID;
	DWORD             	m_dwLineDeviceIDBase;
	DWORD             	m_dwPhoneDeviceIDBase;
	DWORD             	m_dwNumLines;
	DWORD             	m_dwNumPhones;
	HPROVIDER 		  	m_hProvider;
	LINEEVENT 		  	m_lpfnLineCreateProc;
	PHONEEVENT 		  	m_lpfnPhoneCreateProc;

	ASYNC_COMPLETION  	m_cbCompletionProc;
	LPDWORD           	m_lpdwTSPIOption;

	CTspDevFactory 	*	m_pFactory;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\tsp\cmini.h ===
// 
// Copyright (c) 1996-1997 Microsoft Corporation.
//
//
// Component
//
//		Unimodem 5.0 TSP (Win32, user mode DLL)
//
// File
//
//		CMINI.H
//		Defines class CTspMiniDriver
//
// History
//
//		12/08/1996  JosephJ Created
//
//

#include "csync.h"
#include <umdmext.h>


class CTspMiniDriver
{
public:

	CTspMiniDriver(void);

	~CTspMiniDriver();

    TSPRETURN Load(const GUID *pGuid, CStackLog *psl);

	void
	CTspMiniDriver::Unload(
		HANDLE hEvent,
		LONG  *plCounter
		);
    

	TSPRETURN
	BeginSession(HSESSION *pSession, DWORD dwFromID)
	{
		return m_sync.BeginSession(pSession, dwFromID);
	}

	void	   
	EndSession(HSESSION hSession)
	{
		m_sync.EndSession(hSession);
	}
	
    TSPRETURN MapMDError(DWORD dwError)
    {
        // The common cases first ...
        //
        if (!dwError)                         {return 0;}
        else if (dwError == ERROR_IO_PENDING) {return IDERR_PENDING;}

        switch(dwError)
        {

        case ERROR_UNIMODEM_RESPONSE_TIMEOUT:
            return IDERR_MD_DEVICE_NOT_RESPONDING;
    
        case ERROR_UNIMODEM_RESPONSE_ERROR:
            return IDERR_MD_DEVICE_ERROR;
    
        case ERROR_UNIMODEM_RESPONSE_NOCARRIER:
            return IDERR_MD_LINE_NOCARRIER;
    
        case ERROR_UNIMODEM_RESPONSE_NODIALTONE:
            return IDERR_MD_LINE_NODIALTONE;
    
        case ERROR_UNIMODEM_RESPONSE_BUSY:
            return IDERR_MD_LINE_BUSY;
    
        case ERROR_UNIMODEM_RESPONSE_NOANSWER:
            return IDERR_MD_LINE_NOANSWER;
    
        case ERROR_UNIMODEM_RESPONSE_BAD:
            return IDERR_MD_DEVICE_ERROR;
    
        case ERROR_UNIMODEM_MODEM_EVENT_TIMEOUT:
            return IDERR_MD_DEVICE_NOT_RESPONDING;
    
        case ERROR_UNIMODEM_INUSE:
            return IDERR_MD_DEVICE_INUSE;
        
        case ERROR_UNIMODEM_MISSING_REG_KEY:
            return IDERR_MD_REG_ERROR;
    
        case ERROR_UNIMODEM_NOT_IN_VOICE_MODE:
            return IDERR_MD_DEVICE_WRONGMODE;
    
        case ERROR_UNIMODEM_NOT_VOICE_MODEM:
            return IDERR_MD_DEVICE_NOT_CAPABLE;
    
        case ERROR_UNIMODEM_BAD_WAVE_REQUEST:
            return IDERR_MD_BAD_PARAM;

        case ERROR_UNIMODEM_RESPONSE_BLACKLISTED:
            return IDERR_MD_LINE_BLACKLISTED;

        case ERROR_UNIMODEM_RESPONSE_DELAYED:
            return IDERR_MD_LINE_DELAYED;
        
        
        
        case ERROR_UNIMODEM_GENERAL_FAILURE:
            return IDERR_MD_GENERAL_ERROR;
    
        }

        return IDERR_MD_UNMAPPED_ERROR;
    }

	HANDLE
	OpenModem(
        HANDLE      ExtensionBindingHandle,
		HKEY        ModemRegistry,
		HANDLE      CompletionPort,
		LPUMNOTIFICATIONPROC  AsyncNotificationProc,
		HANDLE      AsyncNotifcationContext,
        DWORD       DebugDeviceId,
        HANDLE     *CommPortHandle,
        CStackLog *psl
		)
    {
        // FL_DECLARE_FUNC(0x3d7f02eb, "MD:OpenModem")
        // FL_LOG_ENTRY(psl);
        HANDLE h =  m_pfnUmOpenModem(
                        m_hModemDriverHandle,
                        ExtensionBindingHandle,
                        ModemRegistry,
                        CompletionPort,
                        AsyncNotificationProc,
                        AsyncNotifcationContext,
                        DebugDeviceId,
                        CommPortHandle
                        );
        // FL_LOG_EXIT(psl, (DWORD)h);
        SLPRINTFX(psl, (0,"OpenModem returns 0x%lu", h));

        return h;
    }
	

	void
	CloseModem(
		HANDLE    ModemHandle,
        CStackLog *psl
		);
	
    DWORD 
    InitModem(
        HANDLE    ModemHandle,
        PUM_COMMAND_OPTION  CommandOptionList,
        LPCOMMCONFIG  CommConfig,
        CStackLog *psl
    );


    DWORD
    MonitorModem(
        HANDLE    ModemHandle,
        DWORD     MonitorFlags,
        PUM_COMMAND_OPTION  CommandOptionList,
        CStackLog *psl
        );

    DWORD
    GenerateDigit(
        HANDLE    ModemHandle,
        PUM_COMMAND_OPTION  CommandOptionList,
        LPSTR     DigitString,
        CStackLog *psl
        );

    DWORD
    SetSpeakerPhoneState(
        HANDLE    ModemHandle,
        PUM_COMMAND_OPTION  CommandOptionList,
        DWORD     CurrentMode,
        DWORD     NewMode,
        DWORD     Volume,
        DWORD     Gain,
        CStackLog *psl
        );

    DWORD
    IssueCommand(
        HANDLE    ModemHandle,
        PUM_COMMAND_OPTION  CommandOptionList,
        LPSTR     ComandToIssue,
        LPSTR     TerminationSequnace,
        DWORD     MaxResponseWaitTime,
        CStackLog *psl
        );

    VOID
    LogStringA(
        HANDLE   ModemHandle,
        DWORD    LogFlags,
        LPCSTR   Text,
        CStackLog *psl
        );

    void
    AbortCurrentModemCommand (
        HANDLE    ModemHandle,
        CStackLog *psl
        );
    
    DWORD
    AnswerModem(
        HANDLE    ModemHandle,
        PUM_COMMAND_OPTION  CommandOptionList,
        DWORD     AnswerFlags,
        CStackLog *psl
        );

    DWORD
    DialModem(
        HANDLE    ModemHandle,
        PUM_COMMAND_OPTION  CommandOptionList,
        LPSTR     szNumber,
        DWORD     DialFlags,
        CStackLog *psl
        );


    DWORD
    HangupModem(
        HANDLE    ModemHandle,
        PUM_COMMAND_OPTION  CommandOptionList,
        DWORD     HangupFlags,
        CStackLog *psl
        );


    DWORD
    WaveAction(
        HANDLE    ModemHandle,
        PUM_COMMAND_OPTION  CommandOptionList,
        DWORD     WaveActionFlags,
        CStackLog *psl
        );
    

    HANDLE
    DuplicateDeviceHandle(
        HANDLE    ModemHandle,
        HANDLE    ProcessHandle,
        CStackLog *psl
        );

    DWORD
    SetPassthroughMode(
        HANDLE    ModemHandle,
        DWORD     PasssthroughMode,
        CStackLog *psl
        );

    DWORD
    GetDiagnostics(
        HANDLE    ModemHandle,
        DWORD    DiagnosticType,    // Reserved, must be zero.
        BYTE    *Buffer,
        DWORD    BufferSize,
        LPDWORD  UsedSize,
        CStackLog *psl
        );

    VOID
    LogDiagnostics(
        HANDLE    ModemHandle,
        LPVARSTRING  VarString,
        CStackLog *psl
        );


    BOOL
    MatchGuid( const GUID *pGuid)
    // Returns true IFF Specified GUID matches
    // the GUID that represents this
    // mini driver.
    {
        return sfn_match_guid(&m_Guid, pGuid);
    }


    //
    // Optional Extension Entrypoints.
    //

    BOOL
    ExtIsEnabled(void)
    {
        return m_fExtensionsEnabled;
    }


    HANDLE
    ExtOpenExtensionBinding(
        HKEY hKeyDevice,    // Device registry key
        ASYNC_COMPLETION pfnCompletion,
        // DWORD dwTAPILineID, << OBSOLETE
        // DWORD dwTAPIPhoneID, << OBSOLETE
        PFNEXTENSIONCALLBACK pfnCallback
        )
    {
        return m_pfnUmExtOpenExtensionBinding(
	                        m_hModemDriverHandle,
	                        TAPI_CURRENT_VERSION,
                            hKeyDevice,
                            pfnCompletion,
                            // dwTAPILineID, << OBSOLETE
                            // dwTAPIPhoneID, << OBSOLETE
                            pfnCallback
                            );
    }
    
    void
    ExtCloseExtensionBinding(
        HANDLE hBinding
        )
    {
        m_pfnUmExtCloseExtensionBinding(hBinding);
        
    }
    
    LONG
    ExtAcceptTspCall(
        HANDLE hBinding,        // handle to extension binding
        void *pvTspToken,       // Token to be specified in callback.
        DWORD dwRoutingInfo,    // Flags that help categorize TSPI call
        void *pTspParams        // one of almost 100 TASKPARRAM_* structures,
        )
    {
        return m_pfnUmExtAcceptTspCall(
                    hBinding,
                    pvTspToken,
                    dwRoutingInfo,
                    pTspParams
                    );
    }
    
    
    void
    ExtTspiAsyncCompletion(
        HANDLE hBinding,
        DRV_REQUESTID       dwRequestID,
        LONG                lResult
        )
    {
        m_pfnUmExtTspiAsyncCompletion(
                        hBinding,
                        dwRequestID,
                        lResult
                        );
    }
    
    
    void
    ExtTspiLineEventProc(
        HANDLE hBinding,
        HTAPILINE           htLine,
        HTAPICALL           htCall,
        DWORD               dwMsg,
        ULONG_PTR               dwParam1,
        ULONG_PTR               dwParam2,
        ULONG_PTR               dwParam3
        )
    {
        m_pfnUmExtTspiLineEventProc(
            hBinding,
            htLine,
            htCall,
            dwMsg,
            dwParam1,
            dwParam2,
            dwParam3
            );
    }
    
    void
    ExtTspiPhoneEventProc(
        HANDLE hBinding,
        HTAPIPHONE          htPhone,
        DWORD               dwMsg,
        ULONG_PTR               dwParam1,
        ULONG_PTR               dwParam2,
        ULONG_PTR               dwParam3
        )
    {
        m_pfnUmExtTspiPhoneEventProc(
            hBinding,
            htPhone,
            dwMsg,
            dwParam1,
            dwParam2,
            dwParam3
            );
    }

    DWORD
    ExtControl(
        HANDLE hBinding,
        DWORD               dwMsg,
        DWORD               dwParam1,
        DWORD               dwParam2,
        DWORD               dwParam3
        )
    {
        return m_pfnUmExtControl(
                    hBinding,
                    dwMsg,
                    dwParam1,
                    dwParam2,
                    dwParam3
                    );
    }

private:

    static
    BOOL
    sfn_match_guid( const GUID *pGuid1, const GUID *pGuid2);

    static
    TSPRETURN
    sfn_load_driver (
            const GUID *pGuid,
            HINSTANCE *pHinst
            );
        

	CSync m_sync;

	HINSTANCE m_hDLL; // DLL handle
	HANDLE m_hModemDriverHandle;

    GUID m_Guid;    // GUID representing this mini-driver.

	// The mini-driver entry points...
	PFNUMOPENMODEM              m_pfnUmOpenModem;
	PFNUMCLOSEMODEM             m_pfnUmCloseModem;
	PFNUMINITMODEM              m_pfnUmInitModem;
    PFNUMANSWERMODEM            m_pfnUmAnswerModem;
    PFNUMDIALMODEM              m_pfnUmDialModem;
    PFNUMHANGUPMODEM            m_pfnUmHangupModem;
    PFNUMDUPLICATEDEVICEHANDLE  m_pfnUmDuplicateDeviceHandle;
    PFNUMWAVEACTION             m_pfnUmWaveAction;
    PFNUMABORTCURRENTMODEMCOMMAND   m_pfnUmAbortCurrentModemCommand;
    PFNUMMONITORMODEM               m_pfnUmMonitorModem;
    PFNUMSETPASSTHROUGHMODE         m_pfnUmSetPassthroughMode;
    PFNUMGETDIAGNOSTICS         m_pfnUmGetDiagnostics;
    PFNUMDEINITIALIZEMODEMDRIVER    m_pfnUmDeinitializeModemDriver;
    PFNUMGENERATEDIGIT              m_pfnUmGenerateDigit;
    PFNUMSETSPEAKERPHONESTATE       m_pfnUmSetSpeakerPhoneState;
    PFNUMISSUECOMMAND               m_pfnUmIssueCommand;
    PFNUMLOGSTRINGA                 m_pfnUmLogStringA;
    PFNUMLOGDIAGNOSTICS             m_pfnUmLogDiagnostics;

    BOOL  m_fExtensionsEnabled;

    PFNUMEXTOPENEXTENSIONBINDING   m_pfnUmExtOpenExtensionBinding;
    PFNUMEXTCLOSEEXTENSIONBINDING  m_pfnUmExtCloseExtensionBinding;
    PFNUMEXTACCEPTTSPCALL          m_pfnUmExtAcceptTspCall;
    PFNUMEXTTSPIASYNCCOMPLETION    m_pfnUmExtTspiAsyncCompletion;
    PFNUMEXTTSPILINEEVENTPROC      m_pfnUmExtTspiLineEventProc;
    PFNUMEXTTSPIPHONEEVENTPROC     m_pfnUmExtTspiPhoneEventProc;
    PFNUMEXTCONTROL                m_pfnUmExtControl;
};

// The GUID representing the official UnimdmAt.DLL minidriver
extern const GUID UNIMDMAT_GUID;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\tsp\csync.h ===
// 
// Copyright (c) 1996-1997 Microsoft Corporation.
//
//
// Component
//
//		Unimodem 5.0 TSP (Win32, user mode DLL)
//
// File
//
//		CSYNC.H
//		Defines class CSync
//
// History
//
//		11/19/1996  JosephJ Created
//
//
#ifndef _CSYNC_H_
#define _CSYNC_H_


typedef DWORD HSESSION;

///////////////////////////////////////////////////////////////////////////
//		CLASS CSync
///////////////////////////////////////////////////////////////////////////

//	Controls access to its parent object. Includes a critical section, and
//	a mechanism for waiting until all threads have finished using
//	the parent object.


class CSync
{

public:

	CSync(void);

	~CSync();

	//--------------	EnterCrit		------------------
	// Claim our critical section
	void EnterCrit(DWORD dwFromID);

	//--------------	EnterCrit		------------------
	// Try to claim our critical section
	BOOL TryEnterCrit(DWORD dwFromID);

	//--------------	LeaveCrit		------------------
	// Release our critical section
	void LeaveCrit(DWORD dwFromID);

	TSPRETURN BeginLoad(void);

	void EndLoad(BOOL fSuccess);

	TSPRETURN	BeginUnload(HANDLE hEvent, LONG *plCounter);
	UINT		EndUnload(void);

	TSPRETURN	BeginSession(HSESSION *pSession, DWORD dwFromID);
	void	    EndSession(HSESSION hSession);


	BOOL IsLoaded(void)
	{
		return m_eState==LOADED;
	}

private:

	HANDLE mfn_notify_unload(void);

	CRITICAL_SECTION	m_crit;
	DWORD				m_dwCritFromID;
	UINT				m_uNestingLevel;

	UINT				m_uRefCount;

	enum {
		UNLOADED=0,
		LOADING,
		LOADED,
		UNLOADING
	} 					m_eState;
	
	HANDLE 				m_hNotifyOnUnload;
	LONG 			*	m_plNotifyCounter;
};

#endif _CSYNC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\tsp\csync.cpp ===
// 
// Copyright (c) 1996-1997 Microsoft Corporation.
//
//
// Component
//
//		Unimodem 5.0 TSP (Win32, user mode DLL)
//
// File
//
//		CSYNC.H
//		Defines class CSync
//
// History
//
//		11/19/1996  JosephJ Created
//
//
#include "tsppch.h"
#include "tspcomm.h"
#include "csync.h"

FL_DECLARE_FILE(0x97868d74, "Implements CSync")

///////////////////////////////////////////////////////////////////////////
//		CLASS CSync
///////////////////////////////////////////////////////////////////////////

CSync::CSync(void)
	: m_dwCritFromID(0),
	  m_uNestingLevel(0),
	  m_uRefCount(0),
	  m_eState(UNLOADED),
	  m_hNotifyOnUnload(NULL),
	  m_plNotifyCounter(0)
{
	InitializeCriticalSection(&m_crit);
}

CSync::~CSync()
{
	ASSERT(!m_uNestingLevel);
	ASSERT(!m_uRefCount);
	ASSERT(m_eState == UNLOADED);
	ASSERT(m_hNotifyOnUnload==NULL);
	ASSERT(m_plNotifyCounter==0);

    //OutputDebugString(TEXT("><CSync:~CSync\r\n"));

    EnterCriticalSection(&m_crit);
	DeleteCriticalSection(&m_crit);
}



void
CSync::EnterCrit(
	DWORD dwFromID
	)
{
	// DWORD gtcTryEnter = GetTickCount();
	EnterCriticalSection(&m_crit);
	if (!m_uNestingLevel++)
	{
		//m_gtcEnter = GetTickCount();
		//if ((m_gtcEnter-gtcTryEnter)>Threshold)
		//{
		//	print warning.
		//}
	}
}


BOOL
CSync::TryEnterCrit(
	DWORD dwFromID
	)
{
	// DWORD gtcTryEnter = GetTickCount();
	BOOL fRet = TryEnterCriticalSection(&m_crit);

	if (fRet && !m_uNestingLevel++)
	{
		//m_gtcEnter = GetTickCount();
		//if ((m_gtcEnter-gtcTryEnter)>Threshold)
		//{
		//	print warning.
		//}
	}

    return fRet;
}


void
CSync::LeaveCrit(
	DWORD dwFromID
	)
{
	ASSERT(m_uNestingLevel);
	m_uNestingLevel--;

	//if ((GetTickCount()-m_gtcEnter)>Threshold)
	//{
	//	log warning
	//}

	LeaveCriticalSection(&m_crit);
}


TSPRETURN
CSync::BeginLoad(void)
{
	FL_DECLARE_FUNC(0xf254fd3a, "CSync::BeginLoad")
	TSPRETURN tspRet = 0;

	EnterCrit(FL_LOC);

	if (m_eState == UNLOADED)
	{
		m_eState = LOADING;
	}
	else if (m_eState == LOADED)
	{
		tspRet = FL_GEN_RETVAL(IDERR_SAMESTATE);
	}
	else
	{
		tspRet = FL_GEN_RETVAL(IDERR_WRONGSTATE);
	}

	LeaveCrit(FL_LOC);

	return tspRet;

}

void
CSync::EndLoad(BOOL fSuccess)
{
	FL_DECLARE_FUNC(0xd3ceea77, "CSync::EndLoad")

	EnterCrit(FL_LOC);

	ASSERT (m_eState == LOADING);

	m_eState = (fSuccess) ? LOADED : UNLOADED;

	LeaveCrit(FL_LOC);

}


TSPRETURN
CSync::BeginUnload(
	HANDLE hEvent,
	LONG *plCounter
	)
{
	FL_DECLARE_FUNC(0x3ad965eb, "CSync::BeginUnload")
	TSPRETURN tspRet = 0;

    //OutputDebugString(TEXT(">CSync:BeginUnload\r\n"));

	EnterCrit(FL_LOC);

	if (m_eState == LOADED)
	{
		m_eState = UNLOADING;

		ASSERT(!m_hNotifyOnUnload);
		m_hNotifyOnUnload=hEvent;
		m_plNotifyCounter = plCounter;

		// Zero hEvent so we don't signal it on exiting this function
		hEvent = NULL;
	}
	else if (m_eState == UNLOADED)
	{
		tspRet = FL_GEN_RETVAL(IDERR_SAMESTATE);
	}
	else
	{
		tspRet = FL_GEN_RETVAL(IDERR_WRONGSTATE);
	}


    //OutputDebugString(TEXT("<CSync:BeginUnload\r\n"));

	LeaveCrit(FL_LOC);

	if (hEvent) SetEvent(hEvent);

	return tspRet;

}


UINT
CSync::EndUnload(void)
{
	FL_DECLARE_FUNC(0xf0bd6a4e, "CSync::EndUnload")
	HANDLE hEvent = NULL;
	CStackLog *psl=NULL;
	UINT		uRet  = 0;

    //OutputDebugString(TEXT(">CSync:EndUnload\r\n"));

	EnterCrit(FL_LOC);

	FL_ASSERT (psl, m_eState == UNLOADING);

	uRet  = m_uRefCount;

	m_eState = UNLOADED;

	if (!m_uRefCount)
	{
		hEvent = mfn_notify_unload();
	}

	LeaveCrit(FL_LOC);

	if (hEvent)
    {
        //OutputDebugString(TEXT(" CSync:EndUnload -- setting event.\r\n"));
        SetEvent(hEvent);
    }

	// After the signal, assume CSync is distroyed, so don't touch
	// this object.

    //OutputDebugString(TEXT("<CSync:EndUnload\r\n"));

    return uRet; // ref  count -- if 0 indicates object was deleted.

}

HANDLE
CSync::mfn_notify_unload(void)
{
	HANDLE hRet = NULL;

	if (m_hNotifyOnUnload)
	{
		LONG l = 0;
		
		if (m_plNotifyCounter)
		{
			l = InterlockedDecrement(m_plNotifyCounter);
		}

		ASSERT(l>=0);

		if (!l)
		{
            ConsolePrintfA("mfn_notify_unload: GOING TO SET EVENT\n");
			hRet = m_hNotifyOnUnload;
		}

		m_hNotifyOnUnload = NULL;
		m_plNotifyCounter = NULL;
	}

	return hRet;
}



TSPRETURN
CSync::BeginSession(
	HSESSION *pSession,
	DWORD dwFromID
	)
{
	FL_DECLARE_FUNC(0xb3e0f8a1, "CSync::BeginSession")
	TSPRETURN tspRet = 0;	

	EnterCrit(FL_LOC);

	if (m_eState==LOADED)
	{
		m_uRefCount++;
		*pSession = 1;
	}
	else
	{
		tspRet = FL_GEN_RETVAL(IDERR_WRONGSTATE);
	}

	LeaveCrit(FL_LOC);

	return tspRet;

}
	


void
CSync::EndSession(
	HSESSION hSession
	)
{
	FL_DECLARE_FUNC(0x6b56edc1, "CSync::EndSession")
	HANDLE hEvent=NULL;

	EnterCrit(FL_LOC);

	ASSERT(hSession==1);
	ASSERT(m_uRefCount);

	if (!--m_uRefCount)
	{
		if (m_eState==UNLOADED)
		{
			//
			// There are no more sessions, and the state is unloaded.
			// If we need to signal a handle when reaching this state,
			// mfn_notify_unload will return the handle and we signal it
			// just before exiting this function.
			//
			hEvent = mfn_notify_unload();
		}
	}

	LeaveCrit(FL_LOC);

	if (hEvent) SetEvent(hEvent);

	// After the signal, assume CSync is distroyed, so don't touch
	// this object.
}


//LONG lCounter = count;
//HANDLE h = CreateEvent(...);
//
//for (i=0;i<count;i++)
//{
//	pDev[i]->Unload(&lCounter, h);
//}
//
//WaitForSingleObject(h,INFINITE);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\tsp\cmini.cpp ===
// 
// Copyright (c) 1996-1997 Microsoft Corporation.
//
//
// Component
//
//		Unimodem 5.0 TSP (Win32, user mode DLL)
//
// File
//
//		CMINI.CPP
//		Implements class CTspMiniDriver
//
// History
//
//		12/08/1996  JosephJ Created
//
//
#include "tsppch.h"
#include "tspcomm.h"
//#include <umdmmini.h>

#include "cmini.h"

// #define DUMMY_MD

FL_DECLARE_FILE(0x759a2886, "Implements CTspMiniDriver")

// The GUID representing the official UnimdmAt.DLL minidriver
// {BAC61572-BA10-11d0-8434-00C04FC9B6FD}
const GUID UNIMDMAT_GUID =
{ 0xbac61572, 0xba10, 0x11d0, { 0x84, 0x34, 0x0, 0xc0, 0x4f, 0xc9, 0xb6, 0xfd } };

// The GUID representing the sample extension minidriver UnimdmEx.DLL
// {BAC61572-BA10-11d0-8434-00C04FC9B6FD}
const GUID UNIMDMEX_GUID =
{ 0xbac61573, 0xba10, 0x11d0, { 0x84, 0x34, 0x0, 0xc0, 0x4f, 0xc9, 0xb6, 0xfd } };


//
// FUNCREC and bind_procs defined below are helper-routines to get the
//          function addresses of the dynamically-loaded mini-driver DLL.
//
typedef struct
{
    void **pvFn;
    const char *szFnName;

} FUNCREC;

static BOOL bind_procs(HINSTANCE hInst, FUNCREC rgFuncRecs[])
{
    for (FUNCREC *pFR = rgFuncRecs; pFR->pvFn; pFR++)
    {
        void *pv =  GetProcAddress(hInst, pFR->szFnName);

        if (!pv) return FALSE;

        *(pFR->pvFn) = pv;
    }

    return TRUE;
}


CTspMiniDriver::CTspMiniDriver()
	: m_sync(),
	  m_pfnUmOpenModem(NULL),
	  m_pfnUmCloseModem(NULL)
{
}

CTspMiniDriver::~CTspMiniDriver()
{
	ASSERT(!m_sync.IsLoaded());
	ASSERT(!m_pfnUmOpenModem);
	ASSERT(!m_pfnUmCloseModem);
}

TSPRETURN
CTspMiniDriver::Load(const GUID *pGuid, CStackLog *psl)
{
	FL_DECLARE_FUNC(0x1eb79253, "CTspMiniDriver::Load")
	TSPRETURN tspRet=m_sync.BeginLoad();
	FL_LOG_ENTRY(psl);
    HINSTANCE hInst = NULL;

	if (tspRet) goto end;

	m_sync.EnterCrit(FL_LOC);

    m_Guid = *pGuid; // structure copy.

    // Find load driver DLL associated with this GUID
    tspRet = CTspMiniDriver::sfn_load_driver(pGuid, &hInst);

    if (tspRet)
    {
        hInst=NULL;
        // TODO: need to clean this up:
        dwLUID_RFR = ((DWORD)tspRet)&0xFFFFFF00;
        goto end_load;
    }

    // Get its entry points.
    {
        typedef
        HANDLE
        (*PFNUMINITIALIZEMODEMDRIVER) (void*);

        PFNUMINITIALIZEMODEMDRIVER pfnUmInitializeModemDriver = NULL;

        HANDLE h=NULL;
        

        FUNCREC FuncTab[] =
        {
            {(void**)&pfnUmInitializeModemDriver,
                                            "UmInitializeModemDriver"},
            {(void**)&m_pfnUmOpenModem,     "UmOpenModem"},
            {(void**)&m_pfnUmCloseModem,    "UmCloseModem"},
            {(void**)&m_pfnUmInitModem,     "UmInitModem"},
            {(void**)&m_pfnUmDialModem,     "UmDialModem"},
            {(void**)&m_pfnUmHangupModem,   "UmHangupModem"},
            {(void**)&m_pfnUmMonitorModem,  "UmMonitorModem"},
            {(void**)&m_pfnUmGenerateDigit, "UmGenerateDigit"},
            {(void**)&m_pfnUmSetSpeakerPhoneState,
                                            "UmSetSpeakerPhoneState"},
            {(void**)&m_pfnUmIssueCommand,  "UmIssueCommand"},
            {(void**)&m_pfnUmLogStringA,    "UmLogStringA"},
            {(void**)&m_pfnUmAnswerModem,   "UmAnswerModem"},
            {(void**)&m_pfnUmWaveAction,    "UmWaveAction"},
            {(void**)&m_pfnUmDuplicateDeviceHandle,
                                            "UmDuplicateDeviceHandle"},
            {(void**)&m_pfnUmAbortCurrentModemCommand,
                                            "UmAbortCurrentModemCommand"},
            {(void**)&m_pfnUmSetPassthroughMode,
                                            "UmSetPassthroughMode"},
            {(void**)&m_pfnUmGetDiagnostics,
                                            "UmGetDiagnostics"},
            {(void**)&m_pfnUmLogDiagnostics,
                                            "UmLogDiagnostics"},
            {(void**)&m_pfnUmDeinitializeModemDriver,
                                            "UmDeinitializeModemDriver"},
            {NULL, NULL}
        };


        if (!bind_procs(hInst, FuncTab))
        {
            FL_SET_RFR(0xccdf7700, "Couldn't GetProcAddress all driver funcs.");
        }
        else
        {
            // Load optional extension entry points
            {

                FUNCREC ExtFuncTab[] =
                {
                    {(void**)&m_pfnUmExtOpenExtensionBinding,
                                                "UmExtOpenExtensionBinding"},
                    {(void**)&m_pfnUmExtCloseExtensionBinding,
                                                "UmExtCloseExtensionBinding"},
                    {(void**)&m_pfnUmExtAcceptTspCall,    "UmExtAcceptTspCall"},
                    {(void**)&m_pfnUmExtTspiAsyncCompletion,
                                                 "UmExtTspiAsyncCompletion"},
                    {(void**)&m_pfnUmExtTspiLineEventProc,    
                                                 "UmExtTspiLineEventProc"},
                    {(void**)&m_pfnUmExtTspiPhoneEventProc,  
                                                 "UmExtTspiPhoneEventProc"},
                    {(void**)&m_pfnUmExtControl,  
                                                 "UmExtControl"},
                    {NULL, NULL}
                };
                if (bind_procs(hInst, ExtFuncTab))
                {
                    m_fExtensionsEnabled = TRUE;
                }
                else
                {
                    // TODO: note that if even one of the entrypoints
                    // is missing we default to extensions not enabled,
                    // and DONT TREAT THIS AS FAILURE -- this is a problem.
                    // Perhaps we should include in our internal table,
                    // whether extensions are enabled or not, and if extensions
                    // are enabled, we would fail here.
                    //
                    m_fExtensionsEnabled = FALSE;
                }
            }
            

            // TBD: add opaque validation object to argument.
            h =  pfnUmInitializeModemDriver(NULL);
            if (!h)
            {
                FL_SET_RFR(0x2bb91c00, "UmInitializeModemDriver returns NULL");
            }
        }

        if (!h)
        {
           tspRet = FL_GEN_RETVAL(IDERR_GENERIC_FAILURE);
        }
        else
        {
            ASSERT(!tspRet);
            m_hModemDriverHandle =  h;
            m_hDLL =  hInst;
            hInst=NULL;
        }

    }

	m_sync.LeaveCrit(FL_LOC);

end_load:

    if (tspRet)
    {
        // Cleanup on error...

        if (hInst)
        {
            FreeLibrary(hInst);
            hInst = NULL;
        }
    }

	m_sync.EndLoad(tspRet==0);

end:

	FL_LOG_EXIT(psl, tspRet);

	return tspRet;
}

void
CTspMiniDriver::Unload(
    HANDLE hEvent,
    LONG  *plCounter
	)
{
	FL_DECLARE_FUNC(0x04356188, "CTspMiniDriver::Unload")
	TSPRETURN tspRet= m_sync.BeginUnload(hEvent,plCounter);

	if (tspRet)
	{
		// We only consider the "SAMESTATE" error harmless.
		ASSERT(IDERR(tspRet)==IDERR_SAMESTATE);
		goto end;
	}

	m_sync.EnterCrit(FL_LOC);

	if (m_hModemDriverHandle)
    {
        m_pfnUmDeinitializeModemDriver(m_hModemDriverHandle);
        m_hModemDriverHandle = NULL;
    }

    if (m_hDLL)
    {
        FreeLibrary(m_hDLL);
        m_hDLL=NULL;
    }

	m_pfnUmOpenModem = NULL;
	m_pfnUmCloseModem = NULL;

	m_sync.EndUnload();


	m_sync.LeaveCrit(FL_LOC);

end:
	
	return;

}

#if 0
HANDLE
WINAPI
CTspMiniDriver::OpenModem(
    HKEY        ModemRegistry,
    HANDLE      ExtensionBindingHandle,
    HANDLE      CompletionPort,
    LPUMNOTIFICATIONPROC  AsyncNotificationProc,
    HANDLE      AsyncNotifcationContext,
    CStackLog *psl
    )
{
    // FL_DECLARE_FUNC(0x3d7f02eb, "MD:OpenModem")
    // FL_LOG_ENTRY(psl);
    HANDLE h =  m_pfnUmOpenModem(
                    m_hModemDriverHandle,
                    ExtensionBindingHandle,
                    ModemRegistry,
                    CompletionPort,
                    AsyncNotificationProc,
                    AsyncNotifcationContext
                    );
    // FL_LOG_EXIT(psl, (DWORD)h);
    return h;
}
#endif

VOID
CTspMiniDriver::CloseModem(
    HANDLE    ModemHandle,
    CStackLog *psl
    )
{
    FL_DECLARE_FUNC(0xa60d16e9, "MD:CloseModem")
    FL_LOG_ENTRY(psl);
    m_pfnUmCloseModem(
            ModemHandle
            );
    FL_LOG_EXIT(psl,0);
}

DWORD 
CTspMiniDriver::InitModem(
    HANDLE    ModemHandle,
    PUM_COMMAND_OPTION  CommandOptionList,
    LPCOMMCONFIG  CommConfig,
    CStackLog *psl
)
{
	FL_DECLARE_FUNC(0x603eeaed, "MD:InitModem")
	FL_LOG_ENTRY(psl);

    //Sleep(2000);

    DWORD dwRet =  m_pfnUmInitModem(
                    ModemHandle,
                    CommandOptionList,
                    CommConfig
                    );

	FL_LOG_EXIT(psl, dwRet);

    return dwRet;
}


DWORD
CTspMiniDriver::MonitorModem(
    HANDLE    ModemHandle,
    DWORD     MonitorFlags,
    PUM_COMMAND_OPTION  CommandOptionList,
    CStackLog *psl
    )
{
	FL_DECLARE_FUNC(0x61f991b8, "MD:MonitorModem")
	FL_LOG_ENTRY(psl);

    DWORD dwRet =  m_pfnUmMonitorModem(
                    ModemHandle,
                    MonitorFlags,
                    CommandOptionList
                    );

	FL_LOG_EXIT(psl, dwRet);

    return dwRet;
}

DWORD
CTspMiniDriver::GenerateDigit(
    HANDLE    ModemHandle,
    PUM_COMMAND_OPTION  CommandOptionList,
    LPSTR     DigitString,
    CStackLog *psl
    )
{
	FL_DECLARE_FUNC(0xc7b0b439, "MD:GenerateDigit")
	FL_LOG_ENTRY(psl);

    DWORD dwRet =  m_pfnUmGenerateDigit(
                    ModemHandle,
                    CommandOptionList,
                    DigitString
                    );

	FL_LOG_EXIT(psl, dwRet);

    return dwRet;
}

DWORD
CTspMiniDriver::SetSpeakerPhoneState(
    HANDLE    ModemHandle,
    PUM_COMMAND_OPTION  CommandOptionList,
    DWORD     CurrentMode,
    DWORD     NewMode,
    DWORD     Volume,
    DWORD     Gain,
    CStackLog *psl
    )
{
	FL_DECLARE_FUNC(0xa73746a5, "MD:SetSpeakerPhoneState")
	FL_LOG_ENTRY(psl);

    DWORD dwRet =  m_pfnUmSetSpeakerPhoneState(
                            ModemHandle,
                            CommandOptionList,
                            CurrentMode,
                            NewMode,
                            Volume,
                            Gain
                            );

	FL_LOG_EXIT(psl, dwRet);

    return dwRet;
}

DWORD
CTspMiniDriver::IssueCommand(
    HANDLE    ModemHandle,
    PUM_COMMAND_OPTION  CommandOptionList,
    LPSTR     ComandToIssue,
    LPSTR     TerminationSequence,
    DWORD     MaxResponseWaitTime,
    CStackLog *psl
    )
{
	FL_DECLARE_FUNC(0x040db71f, "MD:IssueCommand")
	FL_LOG_ENTRY(psl);

    DWORD dwRet =  m_pfnUmIssueCommand(
                        ModemHandle,
                        CommandOptionList,
                        ComandToIssue,
                        TerminationSequence,
                        MaxResponseWaitTime
                        );

	FL_LOG_EXIT(psl, dwRet);

    return dwRet;
}

VOID
CTspMiniDriver::LogStringA(
    HANDLE   ModemHandle,
    DWORD    LogFlags,
    LPCSTR   Text,
    CStackLog *psl
    )
{
	FL_DECLARE_FUNC(0x8f1962b2, "MD:LogStringA")
	FL_LOG_ENTRY(psl);

    m_pfnUmLogStringA(
            ModemHandle,
            LogFlags,
            Text
            );

	FL_LOG_EXIT(psl, 0);

    return;
}

void
CTspMiniDriver::AbortCurrentModemCommand (
    HANDLE    ModemHandle,
    CStackLog *psl
    )
{
	FL_DECLARE_FUNC(0x174e55b8, "MD:AbortModemCmd")
	FL_LOG_ENTRY(psl);

    m_pfnUmAbortCurrentModemCommand(
                    ModemHandle
                    );

	FL_LOG_EXIT(psl, 0);

}

DWORD
CTspMiniDriver::AnswerModem(
    HANDLE    ModemHandle,
    PUM_COMMAND_OPTION  CommandOptionList,
    DWORD     AnswerFlags,
    CStackLog *psl
    )
{
	FL_DECLARE_FUNC(0x8eed98ca, "MD:AnswerModem")
	FL_LOG_ENTRY(psl);

    DWORD dwRet =  m_pfnUmAnswerModem(
                    ModemHandle,
                    CommandOptionList,
                    AnswerFlags
                    );

	FL_LOG_EXIT(psl, dwRet);

    return dwRet;
}

DWORD
CTspMiniDriver::DialModem(
    HANDLE    ModemHandle,
    PUM_COMMAND_OPTION  CommandOptionList,
    LPSTR     szNumber,
    DWORD     DialFlags,
    CStackLog *psl
    )
{
	FL_DECLARE_FUNC(0x266fb09c, "MD:DialModem")
	FL_LOG_ENTRY(psl);

    DWORD dwRet =  m_pfnUmDialModem(
                    ModemHandle,
                    CommandOptionList,
                    szNumber,
                    DialFlags
                    );

	FL_LOG_EXIT(psl, dwRet);

    return dwRet;
}


DWORD
CTspMiniDriver::HangupModem(
    HANDLE    ModemHandle,
    PUM_COMMAND_OPTION  CommandOptionList,
    DWORD     HangupFlags,
    CStackLog *psl
    )
{
	FL_DECLARE_FUNC(0xce995ee7, "MD:HangupModem")
	FL_LOG_ENTRY(psl);

    DWORD dwRet =  m_pfnUmHangupModem(
                    ModemHandle,
                    CommandOptionList,
                    HangupFlags
                    );

	FL_LOG_EXIT(psl, dwRet);

    return dwRet;
}


DWORD
CTspMiniDriver::WaveAction(
    HANDLE    ModemHandle,
    PUM_COMMAND_OPTION  CommandOptionList,
    DWORD     WaveActionFlags,
    CStackLog *psl
    )
{
	FL_DECLARE_FUNC(0xce6951e7, "MD:WaveAction")
	FL_LOG_ENTRY(psl);

    DWORD dwRet =  m_pfnUmWaveAction(
                    ModemHandle,
                    CommandOptionList,
                    WaveActionFlags
                    );

	FL_LOG_EXIT(psl, dwRet);

    return dwRet;
}


HANDLE
CTspMiniDriver::DuplicateDeviceHandle(
    HANDLE    ModemHandle,
    HANDLE    ProcessHandle,
    CStackLog *psl
    )
{
	FL_DECLARE_FUNC(0xd8ce8125, "MD:DuplicateHandle")
	FL_LOG_ENTRY(psl);

    HANDLE h =  m_pfnUmDuplicateDeviceHandle(
                    ModemHandle,
                    ProcessHandle
                    );

	FL_LOG_EXIT(psl, (ULONG_PTR) h);

    return h;
}

DWORD
CTspMiniDriver::SetPassthroughMode(
    HANDLE    ModemHandle,
    DWORD     PassthroughMode,
    CStackLog *psl
    )
{
	FL_DECLARE_FUNC(0x5fe1ec35, "MD:SetPassthroughMode")
	FL_LOG_ENTRY(psl);

    DWORD dwRet =  m_pfnUmSetPassthroughMode(
                    ModemHandle,
                    PassthroughMode 
                    );

	FL_LOG_EXIT(psl, dwRet);

    return dwRet;
}


DWORD
CTspMiniDriver::GetDiagnostics(
    HANDLE    ModemHandle,
    DWORD    DiagnosticType,    // Reserved, must be zero.
    BYTE    *Buffer,
    DWORD    BufferSize,
    LPDWORD  UsedSize,
    CStackLog *psl
    )
{
	FL_DECLARE_FUNC(0xf7ea50f5, "MD:GetDiagnostics")
	FL_LOG_ENTRY(psl);

    #if 1
    DWORD dwRet =  m_pfnUmGetDiagnostics(
                    ModemHandle,
                    DiagnosticType,
                    Buffer,
                    BufferSize,
                    UsedSize
                    );
    #else // !0
    
    #define SAMPLE_RAW "<yo name=coolbeans>"
    DWORD dwRet = 0;
    *UsedSize = 0;
        
    if (BufferSize > sizeof(SAMPLE_RAW))
    {
        CopyMemory(Buffer, SAMPLE_RAW, sizeof(SAMPLE_RAW));
        *UsedSize = sizeof (SAMPLE_RAW);
    }

    #endif // !0


	FL_LOG_EXIT(psl, dwRet);

    return dwRet;
}


VOID
CTspMiniDriver::LogDiagnostics(
    HANDLE    ModemHandle,
    LPVARSTRING  VarString,
    CStackLog *psl
    )
{
//	FL_DECLARE_FUNC(0xf7ea50f5, "MD:GetDiagnostics")
//	FL_LOG_ENTRY(psl);

    m_pfnUmLogDiagnostics(
        ModemHandle,
        VarString
        );

//	FL_LOG_EXIT(psl, dwRet);

    return;
}


BOOL
CTspMiniDriver::sfn_match_guid(const GUID *pGuid1, const GUID *pGuid2)
{
    DWORD *pdw1 = (DWORD *) pGuid1;
    DWORD *pdw2 = (DWORD *) pGuid2;

    ASSERT(sizeof(GUID)==4*sizeof(DWORD));

    return      pdw1[0] == pdw2[0]
                && pdw1[1] == pdw2[1]
                && pdw1[2] == pdw2[2]
                && pdw1[3] == pdw2[3];

}

TSPRETURN
CTspMiniDriver::sfn_load_driver (
    const GUID *pGuid,
    HINSTANCE *phInst
)
{
	FL_DECLARE_FUNC(0x5613f234, "load_driver")
	TSPRETURN tspRet = 0;
    // TODO: read from the registry...
    // for now we use an internal table mapping GUIDs to DLL names.

    typedef struct {
        const GUID *pGuid;
        const TCHAR *szDll;
    } TABLE;

    static TABLE gTable[] = {
            {&UNIMDMAT_GUID, TEXT("unimdmat.dll")},
            {&UNIMDMEX_GUID, TEXT("unimdmex.dll")},
            {NULL, NULL}
    };

    HINSTANCE hInst = NULL;


    for  (TABLE *pTable = gTable; pTable->pGuid; pTable++)
    {
        if (sfn_match_guid(pTable->pGuid, pGuid))
        {
            // Found it, load library...
            hInst = LoadLibrary(pTable->szDll);

            if (!hInst)
            {
	            FL_SET_RFR(0x36465d00, "Couldn't LoadLibrary(mini-driver dll)");
	            tspRet = FL_GEN_RETVAL(IDERR_OPEN_RESOURCE_FAILED);
            }
            else
            {
                *phInst = hInst;
            }

            goto end;
        }
    }

    FL_SET_RFR(0x667b7e00, "No driver associated with this GUID");
    tspRet = FL_GEN_RETVAL(IDERR_OPEN_RESOURCE_FAILED);

end:

    ASSERT(tspRet || *phInst);

    return tspRet;
}


#if (0) // (DBG)

// FOLLOWING CODE JUST VERIFIES THAT THE PNF* typedefs are in sync
// with the function prototypes.

    // The mini-driver entry points...
    static PFNUMOPENMODEM               spfnUmOpenModem = UmOpenModem;
	static PFNUMCLOSEMODEM              spfnUmCloseModem = UmCloseModem;
	static PFNUMINITMODEM               spfnUmInitModem = UmInitModem;
    static PFNUMANSWERMODEM             spfnUmAnswerModem = UmAnswerModem;
    static PFNUMDIALMODEM               spfnUmDialModem = UmDialModem;
    static PFNUMHANGUPMODEM             spfnUmHangupModem = UmHangupModem;
    static PFNUMDUPLICATEDEVICEHANDLE   spfnUmDuplicateDeviceHandle
                                                 = UmDuplicateDeviceHandle;
    static PFNUMWAVEACTION              spfnUmWaveAction = UmWaveAction;
    static PFNUMABORTCURRENTMODEMCOMMAND   spfnUmAbortCurrentModemCommand
                                                 = UmAbortCurrentModemCommand;
    static PFNUMMONITORMODEM            spfnUmMonitorModem = UmMonitorModem;
    static PFNUMSETPASSTHROUGHMODE      spfnUmSetPassthroughMode
                                                 = UmSetPassthroughMode;
    static PFNUMGETDIAGNOSTICS          spfnUmGetDiagnostics
                                                 = UmGetDiagnostics;
    static PFNUMDEINITIALIZEMODEMDRIVER spfnUmDeinitializeModemDriver
                                                 = UmDeinitializeModemDriver;
    static PFNUMGENERATEDIGIT           spfnUmGenerateDigit
                                                 = UmGenerateDigit;
    static PFNUMSETSPEAKERPHONESTATE    spfnUmSetSpeakerPhoneState
                                                 = UmSetSpeakerPhoneState;
    static PFNUMISSUECOMMAND            spfnUmIssueCommand = UmIssueCommand;
    static PFNUMLOGSTRINGA              spfnUmLogStringA = UmLogStringA;



    static PFNUMEXTOPENEXTENSIONBINDING spfnUmExtOpenExtensionBinding
                                                = UmExtOpenExtensionBinding;
    static PFNUMEXTCLOSEEXTENSIONBINDING spfnUmExtCloseExtensionBinding
                                                = UmExtCloseExtensionBinding;
    static PFNUMEXTACCEPTTSPCALL        spfnUmExtAcceptTspCall
                                                = UmExtAcceptTspCall;
    static PFNUMEXTTSPIASYNCCOMPLETION  spfnUmExtTspiAsyncCompletion
                                                = UmExtTspiAsyncCompletion;
    static PFNUMEXTTSPILINEEVENTPROC    spfnUmExtTspiLineEventProc
                                                = UmExtTspiLineEventProc;
    static PFNUMEXTTSPIPHONEEVENTPROC   spfnUmExtTspiPhoneEventProc
                                                = UmExtTspiPhoneEventProc;
    static PFNUMEXTCONTROL              spfnUmExtControl = UmExtControl;

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\tsp\debug.h ===
// 
// Copyright (c) 1996-1997 Microsoft Corporation.
//
//
// Component
//
//		Unimodem 5.0 TSP (Win32, user mode DLL)
//
// File
//
//		DEBUG.H
//		
//
// History
//
//		11/24/1996  JosephJ Created
//
//
#define DEBUG

#ifdef ASSERT
#   undef ASSERT
#endif

#define ASSERT(cond) \
((cond) ? 0 : ConsolePrintfA( \
                "**** ASSERT(%s) **** %d %s\n", \
                #cond, \
                __LINE__, \
                __FILE__ \
                ))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\tsp\dbgext.cpp ===
// 
// Copyright (c) 1996-1997 Microsoft Corporation.
//
//
// Component
//
//		Unimodem 5.0 TSP (Win32, user mode DLL)
//
// File
//
//		DBGEXT.CPP
//		Windbg Extension APIs for the TSP.
//
// History
//
//		06/03/1997  JosephJ Created
//
//
//  
// Notes:
//
// 06/03/1997 JosephJ
//      The extension apis are poorly documented. There is mention of it
//      in the NT4.0 DDK -- under:
//           Chapter 4 Debuggind Windows NT Drivers
//                   4.4 Debugger extensions
//
//      Chapter 4.4.2 Creating custom extensions aludes to sample code
//      but doesn't give good detail. There is some sample code in the DDK:
//        Code Samples 
//              KRNLDBG
//                  KDAPIS
//                  KDEXTS      <- debugger extensions
//
//
//     But this is obsolete (as far as I can see). The most up-to-date
//     "documentation" is wdbgexts.h in the NT5 public\sdk\inc directory.
//     It contains the DECLARE_API and other helper macros.
//
//     For working sample code, I referred to Amritansh Raghav's extensions
//     for the 5.0 network filter driver
//     (private\net\routing\ip\fltrdrvr\kdexts)
//
//     It is well worth looking at wdbgexts.h in detail. The most frequently
//     used macros are reproduced here for convenience of discussion:
//
//      #define DECLARE_API(s)                             \ 
//          CPPMOD VOID                                    \ 
//          s(                                             \ 
//              HANDLE                 hCurrentProcess,    \ 
//              HANDLE                 hCurrentThread,     \ 
//              ULONG                  dwCurrentPc,        \ 
//              ULONG                  dwProcessor,        \ 
//              PCSTR                  args                \ 
//           )
// 
//      #ifndef NOEXTAPI
// 
//      #define dprintf          (ExtensionApis.lpOutputRoutine)
//      #define GetExpression    (ExtensionApis.lpGetExpressionRoutine)
//      #define GetSymbol        (ExtensionApis.lpGetSymbolRoutine)
//      #define Disassm          (ExtensionApis.lpDisasmRoutine)
//      #define CheckControlC    (ExtensionApis.lpCheckControlCRoutine)
//      #define ReadMemory       (ExtensionApis.lpReadProcessMemoryRoutine)
//      #define WriteMemory      (ExtensionApis.lpWriteProcessMemoryRoutine)
//      #define GetContext       (ExtensionApis.lpGetThreadContextRoutine)
//      #define SetContext       (ExtensionApis.lpSetThreadContextRoutine)
//      #define Ioctl            (ExtensionApis.lpIoctlRoutine)
//      #define StackTrace       (ExtensionApis.lpStackTraceRoutine)
//      ...
//
//
//     As you can see, the function macros above all assume that the 
//     extension helper functions are saved away in the specific global
//     structure "ExtensionApis." Therefore you should make sure that
//     you name such a structure and you initialize it when your
//     WinDbgExtensionDllInit entrypoint is called.
//
//     Note: I tried and failed, to import extensions from the dll "unimdm.tsp"
//           Simply renaming the dll unimdm.dll worked.


//
// 7/24/1997 JosephJ
//             For some reason, even though unicode is defined in tsppch.h,
//             if I don't define it here, it causes an error in cdev.h,
//             only for this file. Don't know why this is happening, but this
//             is the workaround...
//
#define UNICODE 1

// The following four includes must be included for the debugging extensions
// to compile.
//
#include <nt.h>
#include <ntverp.h>
#include <ntrtl.h>
#include <nturtl.h>

#include "tsppch.h"

#include <wdbgexts.h>

#include "tspcomm.h"
//#include <umdmmini.h>
#include "cmini.h"
#include "cdev.h"
//#include "umrtl.h"


EXT_API_VERSION        ApiVersion = { 3, 5, EXT_API_VERSION_NUMBER, 0 };
WINDBG_EXTENSION_APIS  ExtensionApis;
USHORT                 SavedMajorVersion;
USHORT                 SavedMinorVersion;
BOOLEAN                 ChkTarget;
INT                     Item;

DWORD      g_dwFilterInfo;
DWORD      g_dwIfLink;
DWORD      g_dwInIndex,g_dwOutIndex;
DWORD      g_dwCacheSize;

#define CHECK_SIZE(dwRead,dwReq,bRes){                                        \
        if((dwRead) < (dwReq))                                                \
        {                                                                     \
            dprintf("Requested %s (%d) read %d \n",#dwReq,dwReq,dwRead);      \
            dprintf("Error in %s at %d\n",__FILE__,__LINE__);                 \
            bRes = FALSE;                                                     \
        }                                                                     \
        else                                                                  \
        {                                                                     \
            bRes = TRUE;                                                      \
        }                                                                     \
    }

#define READ_MEMORY_ERROR                                                     \
        dprintf("Error in ReadMemory() in %s at line %d\n",__FILE__,__LINE__);


VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;
    
    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;
    ChkTarget = SavedMajorVersion == 0x0c ? TRUE : FALSE;
    
    g_dwIfLink = 0;
    g_dwInIndex = g_dwOutIndex = 0;
    
    return;
}


DECLARE_API( version )
{
#if DBG
    PCHAR DebuggerType = "Checked";
#else
    PCHAR DebuggerType = "Free";
#endif

    dprintf( "%s Extension dll for Build %d debugging %s kernel for Build %d\n",
             DebuggerType,
             VER_PRODUCTBUILD,
             SavedMajorVersion == 0x0c ? "Checked" : "Free",
             SavedMinorVersion
             );
}

VOID
CheckVersion(
             VOID
             )
{
    
    return;
    
#if DBG
    if ((SavedMajorVersion != 0x0c) || (SavedMinorVersion != VER_PRODUCTBUILD)) 
    {
        dprintf("\r\n*** Extension DLL(%d Checked) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, 
                (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#else
    if ((SavedMajorVersion != 0x0f) || (SavedMinorVersion != VER_PRODUCTBUILD)) 
    {
        dprintf("\r\n*** Extension DLL(%d Free) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, 
                (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#endif
}

LPEXT_API_VERSION
ExtensionApiVersion(
                    VOID
                    )
{
    return &ApiVersion;
}

//
// Exported functions
//
DECLARE_API( uhelp )

/*++

Routine Description:

    Command help for IP Filter debugger extensions.

Arguments:

    None

Return Value:

    None
    
--*/

{
    dprintf("\n\tIP Filter debugger extension commands:\n\n");
    dprintf("\tNumIf                 - Print the number of interfaces in the filter\n");
    dprintf("\tIfByIndex <index>     - Print the ith interface in the list\n");
    dprintf("\tIfByAddr <ptr>        - Print the interface with given address\n");
    dprintf("\tIfEnumInit            - Inits the If enumerator (to 0)\n");
    dprintf("\tNextIf                - Print the next If enumerated\n");
    dprintf("\tPrintCache <index>    - Print the contents of the ith cache bucket\n");
    dprintf("\tCacheSize             - Print the current cache size\n");
    dprintf("\tPrintPacket           - Dump a packet header and first DWORD of data\n");
    dprintf("\tFilterEnumInit <ptr>  - Inits the in and out filter enumerator for If at addr\n");
    dprintf("\tNextInFilter          - Print the next In Filter\n");
    dprintf("\tNextOutFilter         - Print the next Out Filter\n");
    dprintf("\n\tCompiled on " __DATE__ " at " __TIME__ "\n" );
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\tsp\diag.h ===
UINT
DumpTSPIRECA(

IN    DWORD dwInstance,
IN	  DWORD dwRoutingInfo,
IN    void *pvParams,
IN    DWORD dwFlags,

OUT   char *rgchName,
IN    UINT cchName,
OUT   char *rgchBuf,
IN    UINT cchBuf
      );

UINT
DumpLineEventProc(
IN    DWORD dwInstance,
IN    DWORD dwFlags,
IN    DWORD dwMsg,
IN    DWORD dwParam1,
IN    DWORD dwParam2,
IN    DWORD dwParam3,
OUT   char *rgchName,
IN    UINT cchName,
OUT   char *rgchBuf,
IN    UINT cchBuf
      );

UINT
DumpPhoneEventProc(
IN    DWORD dwInstance,
IN    DWORD dwFlags,
IN    DWORD dwMsg,
IN    DWORD dwParam1,
IN    DWORD dwParam2,
IN    DWORD dwParam3,
OUT   char *rgchName,
IN    UINT cchName,
OUT   char *rgchBuf,
IN    UINT cchBuf
      );


UINT
DumpTSPICompletionProc(
IN    DWORD dwInstance,
IN    DWORD dwFlags,

IN    DWORD dwRequestID,
IN    LONG  lResult,

OUT   char *rgchName,
IN    UINT cchName,
OUT   char *rgchBuf,
IN    UINT cchBuf
      );

UINT
DumpWaveAction(
IN    DWORD dwInstance,
IN    DWORD dwFlags,

IN    DWORD dwLLWaveAction,

OUT   char *rgchName,
IN    UINT cchName,
OUT   char *rgchBuf,
IN    UINT cchBuf
      );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\tsp\dllmain.cpp ===
// 
// Copyright (c) 1996-1997 Microsoft Corporation.
//
//
// Component
//
//		Unimodem 5.0 TSP (Win32, user mode DLL)
//
// File
//
//		DLLMAIN.CPP
//		"Main" -- dll entrypoint.
//
// History
//
//		11/16/1996  JosephJ Created
//
//
#include "tsppch.h"
#include "tspcomm.h"
#include "cdev.h"
#include "cmgr.h"
#include "cfact.h"
#include "globals.h"

FL_DECLARE_FILE(0xfce43aad, "DLLMAIN--process attach, etc.")

void tspProcessAttach(HMODULE hDll);
void tspProcessDetach(HMODULE hDll);
void Log_OnProcessAttach(HMODULE hDLL);
void Log_OnProcessDetach(HMODULE hDll);

void WINAPI
UI_ProcessAttach (void);

void WINAPI
UI_ProcessDetach (void);


BOOL
APIENTRY
DllMain(
	HINSTANCE hDll,
	DWORD dwReason,
	LPVOID lpReserved
	)
{
  switch(dwReason)
  {
    case DLL_PROCESS_ATTACH:
            DEBUG_MEMORY_PROCESS_ATTACH("UNIMDM");
            tspProcessAttach(hDll);
            UI_ProcessAttach ();
            DisableThreadLibraryCalls(hDll);
            break;

    case DLL_PROCESS_DETACH:

            UI_ProcessDetach();
            tspProcessDetach(hDll);

            DEBUG_MEMORY_PROCESS_DETACH();
            break;

    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:

    default:
            break;
  }

  return TRUE;

}

void
tspProcessAttach(
	HMODULE hDll
	)
{
	tspGlobals_OnProcessAttach(hDll);
    Log_OnProcessAttach(hDll);
}


void
tspProcessDetach(
	HMODULE hDll
)
{
	tspGlobals_OnProcessDetach();
    Log_OnProcessDetach(hDll);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\tsp\diag.cpp ===
// 
// Copyright (c) 1996-1997 Microsoft Corporation.
//
//
// Component
//
//		Unimodem 5.0 TSP (Win32, user mode DLL)
//
// File
//
//		DIAG.CPP
//		Defines class CTspDev
//
// History
//
//		11/16/1996  JosephJ Created
//
//
#include "tsppch.h"
#include "diag.h"

#include "fastlog.h"
#include "globals.h"
#include "resource.h"

UINT
DumpTSPIRECA(
    IN    DWORD dwInstance,
    IN    DWORD dwRoutingInfo,
    IN    void *pvParams,
    IN    DWORD dwFlags,
    OUT   char *rgchName,
    IN    UINT cchName,
    OUT   char *rgchBuf,
    IN    UINT cchBuf
    )
{
    UINT uRet = 0;

    UINT   StringId=(UINT)-1;
    CHAR   ResourceString[128];

    if (cchName)
    {
        *rgchName = 0;
    }

    if (cchBuf)
    {
        *rgchBuf = 0;
    }

	switch(ROUT_TASKDEST(dwRoutingInfo))
	{

	case	TASKDEST_LINEID:
        break;

	case	TASKDEST_PHONEID:
		break;

	case	TASKDEST_HDRVLINE:

        switch(ROUT_TASKID(dwRoutingInfo))
        {
    
        case TASKID_TSPI_lineClose:
            {
                
            }
            break;
    
        case TASKID_TSPI_lineSetDefaultMediaDetection:
    
            {
                TASKPARAM_TSPI_lineSetDefaultMediaDetection *pParams = 
                        (TASKPARAM_TSPI_lineSetDefaultMediaDetection *) pvParams;
                if (pParams->dwMediaModes)
                {
                    StringId=IDS_MONITORING;
                }
                else
                {
                    StringId=IDS_STOP_MONITORING;
                }
            }
            break;
    
        case TASKID_TSPI_lineMakeCall:
    
            {
                TASKPARAM_TSPI_lineMakeCall *pParams = 
                        (TASKPARAM_TSPI_lineMakeCall *) pvParams;
    
                 // passthrough call?
                 StringId=IDS_MAKING_CALL;
    
            }
            break; // end case TASKID_TSPI_lineMakeCall
        }
		break; // HDRVLINE

	case	TASKDEST_HDRVPHONE:
		break; // HDRVPHONE

	case	TASKDEST_HDRVCALL:

        switch(ROUT_TASKID(dwRoutingInfo))
        {
    
        case TASKID_TSPI_lineDrop:
            {
                TASKPARAM_TSPI_lineDrop *pParams = 
                        (TASKPARAM_TSPI_lineDrop *) pvParams;

                StringId=IDS_DROPPING_CALL;
    
            }
            break;
    
        case TASKID_TSPI_lineCloseCall:
            {
                StringId=IDS_CLOSING_CALL;
            }
            break;
        
        case TASKID_TSPI_lineAnswer:
            {
                TASKPARAM_TSPI_lineAnswer *pParams = 
                        (TASKPARAM_TSPI_lineAnswer *) pvParams;
                StringId=IDS_ANSWERING_CALL;
            }
            break;

        case TASKID_TSPI_lineAccept:
            {
                TASKPARAM_TSPI_lineAccept *pParams = 
                        (TASKPARAM_TSPI_lineAccept *) pvParams;
                StringId=IDS_ACCEPTING_CALL;
            }
            break;
    
        case TASKID_TSPI_lineMonitorDigits:
            {
                TASKPARAM_TSPI_lineMonitorDigits *pParams = 
                        (TASKPARAM_TSPI_lineMonitorDigits *) pvParams;

                 DWORD  dwDigitModes = pParams->dwDigitModes;
    
                if (!dwDigitModes)
                {
                    StringId=IDS_DISABLE_DIGIT_MONITORING;
                }
                else
                {
                    StringId=IDS_ENABLE_DIGIT_MONITORING;
                }
            }
            break;
    
        case TASKID_TSPI_lineMonitorTones:
            {
                TASKPARAM_TSPI_lineMonitorTones *pParams = 
                        (TASKPARAM_TSPI_lineMonitorTones *) pvParams;
                DWORD dwNumEntries = pParams->dwNumEntries;
                LPLINEMONITORTONE lpToneList = pParams->lpToneList;
    
                if (lpToneList || dwNumEntries)
                {
                    if (lpToneList
                        && dwNumEntries==1
                        && (lpToneList->dwFrequency1 == 0)
                        && (lpToneList->dwFrequency2 == 0)
                        && (lpToneList->dwFrequency3 == 0))
                    {
                        StringId=IDS_MONITOR_SILENCE;
                    }
                    else
                    {
                        StringId=IDS_MONITOR_TONES;
                    }
                }
                else
                {
                    StringId=IDS_STOP_MONITORING_TONES;
                }
            }
            break;
    
    
        case TASKID_TSPI_lineGenerateDigits:
            {
    
                TASKPARAM_TSPI_lineGenerateDigits *pParams = 
                        (TASKPARAM_TSPI_lineGenerateDigits *) pvParams;
        
                if(pParams->lpszDigits == NULL )
                {
                    StringId=IDS_CANCEL_DIGIT_GENERATION;
                }
                else
                {
                    StringId=IDS_GENERATE_DIGITS;
                }
    
            }
            break; // lineGenerateDigits...
    
    
        case TASKID_TSPI_lineSetCallParams:
            {
                TASKPARAM_TSPI_lineSetCallParams *pParams = 
                        (TASKPARAM_TSPI_lineSetCallParams *) pvParams;
                DWORD dwBearerMode = pParams->dwBearerMode;
    
                if (dwBearerMode&LINEBEARERMODE_PASSTHROUGH)
                {
                    StringId=IDS_PASSTHROUGH_ON;
                }
                else
                {
                    StringId=IDS_PASSTHROUGH_OFF;
                }
    
            } // end case TASKID_TSPI_lineSetCallParams
            break;

        default:
            break;
        }

		break; // HDRVCALL

	default:
		break;
	}

	if (StringId != (UINT)-1)
	{
        DWORD    StringSize;

        StringSize=LoadStringA(
            g.hModule,
            StringId,
            ResourceString,
            sizeof(ResourceString)
            );


        if ((cchName > 0) && (StringSize > 0))
        {
            wsprintfA(rgchName, "TSP(%04lx): %s\r\n", dwInstance, ResourceString);
        }
    }

    return 0;
}


UINT
DumpLineEventProc(
IN    DWORD dwInstance,
IN    DWORD dwFlags,
IN    DWORD dwMsg,
IN    DWORD dwParam1,
IN    DWORD dwParam2,
IN    DWORD dwParam3,
OUT   char *rgchName,
IN    UINT cchName,
OUT   char *rgchBuf,
IN    UINT cchBuf
)
{
    UINT uRet = 0;
//    LPCSTR sz = NULL;
    BOOL fAddDword = FALSE;
    DWORD dwInfo =0;
    UINT StringId=(UINT)-1;

    if (cchName)
    {
        *rgchName = 0;
    }

    if (cchBuf)
    {
        *rgchBuf = 0;
    }

    switch(dwMsg)
    {
    case LINE_CALLSTATE:
        switch(dwParam1)
        {

        case LINECALLSTATE_ACCEPTED:
            StringId=IDS_LINECALLSTATE_ACCEPTED;
            break;

        case LINECALLSTATE_CONNECTED:
            StringId=IDS_LINECALLSTATE_CONNECTED;

            break;
        case LINECALLSTATE_DIALING:
            StringId=IDS_LINECALLSTATE_DIALING;
            break;

        case LINECALLSTATE_DIALTONE:
            StringId=IDS_LINECALLSTATE_DIALTONE;
            break;

        case LINECALLSTATE_DISCONNECTED:
            StringId=IDS_LINECALLSTATE_DISCONNECTED;
            fAddDword = TRUE;
            dwInfo = dwParam2;
            break;

        case LINECALLSTATE_IDLE:
            StringId=IDS_LINECALLSTATE_IDLE;
            break;

        case LINECALLSTATE_OFFERING:
            StringId=IDS_LINECALLSTATE_OFFERING;
            break;

        case LINECALLSTATE_PROCEEDING:
            StringId=IDS_LINECALLSTATE_PROCEEDING;
            break;

        default:
            StringId=IDS_LINECALLSTATE_UNKNOWN;
            break;
        }
        break;

    case LINE_CALLINFO:
        fAddDword = TRUE;
        dwInfo = dwParam1;
        break;

    case LINE_LINEDEVSTATE:
        if (dwParam1 == LINEDEVSTATE_RINGING)
        {
            StringId=IDS_LINEDEVSTATE_RINGING;
            fAddDword = TRUE;
            dwInfo = dwParam2; // #rings
        }
        break;

    case LINE_CLOSE:
        StringId=IDS_LINE_CLOSE;
        break;

    case LINE_NEWCALL:
        StringId=IDS_LINE_NEWCALL;
        break;

    case LINE_MONITORDIGITS:
        StringId=IDS_LINE_MONITORDIGITS;
        fAddDword = TRUE;
        dwInfo = dwParam1; // dwDigit.
        break;

    case LINE_GENERATE:
        switch(dwParam1)
        {

        case LINEGENERATETERM_DONE:
            StringId=IDS_LINEGENERATETERM_DONE;
            break;

        case LINEGENERATETERM_CANCEL:
            StringId=IDS_LINEGENERATETERM_CANCEL;
            break;

        default:
            StringId=IDS_LINE_GENERATE;
            fAddDword = TRUE;
            dwInfo = dwParam1;
            break;
        }
        break;

    default:
        StringId=IDS_UNKNOWN_MSG;
        break;
    }

    if (StringId != (UINT)-1)
    {

        CHAR    String[128];

        DWORD    StringSize;

        StringSize=LoadStringA(
            g.hModule,
            StringId,
            String,
            sizeof(String)
            );


        if ((cchName > 0) && (StringSize > 0))
        {
            if (fAddDword)
            {
                wsprintfA(
                    rgchName,
                    "TSP(%04lx): LINEEVENT: %s(0x%lx)\r\n",
                    dwInstance,
                    String,
                    dwInfo
                    );
            }
            else
            {
                wsprintfA(
                    rgchName,
                    "TSP(%04lx): LINEEVENT: %s\r\n",
                    dwInstance,
                    String
                    );
            }
        }
    }

    return uRet;
}


UINT
DumpPhoneEventProc(
IN    DWORD dwInstance,
IN    DWORD dwFlags,
IN    DWORD dwMsg,
IN    DWORD dwParam1,
IN    DWORD dwParam2,
IN    DWORD dwParam3,
OUT   char *rgchName,
IN    UINT cchName,
OUT   char *rgchBuf,
IN    UINT cchBuf
)
{
    UINT uRet = 0;
    LPCSTR lpsz = NULL;

    if (cchName)
    {
        *rgchName = 0;
    }

    if (cchBuf)
    {
        *rgchBuf = 0;
    }

    return uRet;
}



UINT
DumpTSPICompletionProc(
     IN    DWORD dwInstance,
     IN    DWORD dwFlags,
     IN    DWORD dwRequestID,
     IN    LONG  lResult,
     OUT   char *rgchName,
     IN    UINT cchName,
     OUT   char *rgchBuf,
     IN    UINT cchBuf
     )
{
    UINT uRet = 0;
    LPCSTR lpsz = NULL;
    CHAR        TempString[256];

    if (cchName > 0)
    {
        *rgchName = 0;
    }

    if (cchBuf > 0)
    {
        *rgchBuf = 0;
    }

    LoadStringA(
        g.hModule,
        IDS_ASYNCREPLY,
        TempString,
        sizeof(TempString)
        );

    wsprintfA(
        rgchName,
        TempString,
        dwRequestID,
        lResult
        );

    lstrcatA(
        rgchName,
        "\r\n"
        );

    return uRet;
}

UINT
DumpWaveAction(
IN    DWORD dwInstance,
IN    DWORD dwFlags,

IN    DWORD dwLLWaveAction,

OUT   char *rgchName,
IN    UINT cchName,
OUT   char *rgchBuf,
IN    UINT cchBuf
      )
{
    UINT uRet = 0;
    LPCSTR lpsz = "";

    if (cchName)
    {
        *rgchName = 0;
    }

    if (cchBuf)
    {
        *rgchBuf = 0;
    }

    switch(dwLLWaveAction)
    {
    case WAVE_ACTION_START_PLAYBACK:
        lpsz = "Start Playback";
        break;
    case WAVE_ACTION_STOP_STREAMING:
        lpsz = "Stop Streaming";
        break;
    case WAVE_ACTION_START_RECORD:
        lpsz = "Start Record";
        break;
#if 0
    case WAVE_ACTION_STOP_RECORD:
        lpsz = "Stop Record";
        break;
#endif
    case WAVE_ACTION_OPEN_HANDSET:
        lpsz = "Open Handset";
        break;
    case WAVE_ACTION_CLOSE_HANDSET:
        lpsz = "Close Handset";
        break;
    case WAVE_ACTION_ABORT_STREAMING:
        lpsz = "Abort Streaming";
        break;
    case WAVE_ACTION_START_DUPLEX:
        lpsz = "Start Duplex";
        break;
#if 0
    case WAVE_ACTION_STOP_DUPLEX:
        lpsz = "Stop Duplex";
        break;
#endif
    default:
        lpsz = "WAVE: Unknown Action";
        break;
    }

    if (cchName > (32+(UINT)lstrlenA(lpsz))) // 32 covers the extra chars below.
    {
      uRet = wsprintfA(
                rgchName,
                "TSP(%04lx): WAVE: %s\r\n",
                dwInstance,
                lpsz
                );
    }

    return uRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\tsp\fastlog.h ===
// 
// Copyright (c) 1996-1997 Microsoft Corporation.
//
//
// Component
//
//		Unimodem 5.0 TSP (Win32, user mode DLL)
//
// File
//
//		FASTLOG.H
//		Header for logging stuff, including the great CStackLog
//
// History
//
//		12/28/1996  JosephJ Created
//
//
#define FL_DECLARE_FILE(_dwLUIDFile, szDescription) \
    static const DWORD dwLUID_CurrentFile = _dwLUIDFile; \
    extern "C" const char szFL_FILE##_dwLUIDFile[] = __FILE__; \
    extern "C" const char szFL_DATE##_dwLUIDFile[] = __DATE__; \
    extern "C" const char szFL_TIME##_dwLUIDFile[] = __TIME__; \
    extern "C" const char szFL_TIMESTAMP##_dwLUIDFile[] = __TIMESTAMP__;

#define FL_DECLARE_FUNC(_dwLUIDFunc, _szDescription) \
    const DWORD dwLUID_CurrentFunc = _dwLUIDFunc; \
    const DWORD dwLUID_CurrentLoc = _dwLUIDFunc; \
	DWORD dwLUID_RFR = _dwLUIDFunc;

#define FL_DECLARE_LOC(_dwLUIDLoc, _szDescription) \
    const DWORD dwLUID_CurrentLoc = _dwLUIDLoc;

#define FL_SET_RFR(_dwLUIDRFR, _szDescription) \
    (dwLUID_RFR = (_dwLUIDRFR)&0xFFFFFF00)

#define FL_GEN_RETVAL(_byte_err_code) \
	((_byte_err_code | (dwLUID_RFR&0xFFFFFF00)))

#define FL_BYTERR_FROM_RETVAL(_retval) \
	((_retval) & 0xFF)

#define FL_RFR_FROM_RETVAL(_retval) \
	((_retval) & 0xFFFFFF00)

// TODO: define combined macro which sets both RFR and error code.
// Also: need to verify that if dwLUID_RFR is not used except to generate
// the return value, compiler replaces all reference to it by a literal.

#define FL_LOC  dwLUID_CurrentLoc

// STACKLOG hdr status flags
#define fFL_ASSERTFAIL (0x1<<0)
#define fFL_UNICODE     (0x1<<1)

// FL_DECLARE_FILE(0x0accdf13, "This is a test file")
// FL_DECLARE_FUNC(0x0930cb90, "APC Handler")
// FL_DECLARE_LOC (0x0935b989, "About to process completion port packet")
// FL_SET_RFR     (0x2350989c, "Could not open modem");

// DOMAINS
#define dwLUID_DOMAIN_UNIMODEM_TSP 0x7d7a4409

// STATIC OBJECT MESSAGES
#define LOGMSG_PRINTF 						 0x1
#define	LOGMSG_GET_SHORT_FUNC_DESCRIPTIONA   0x2
#define LOGMSG_GET_SHORT_RFR_DESCRIPTIONA    0x3
#define LOGMSG_GET_SHORT_FILE_DESCRIPTIONA   0x4
#define LOGMSG_GET_SHORT_ASSERT_DESCRIPTIONA 0x5


// SIGNATURES
#define wSIG_GENERIC_SMALL_OBJECT 0x1CEA

// Class ID LUIDs
#define dwCLASSID_STACKLOGREC_FUNC 0xdf5d6922
#define dwCLASSID_STACKLOGREC_EXPLICIT_STRING 0x0a04e1ab
#define dwCLASSID_STACKLOGREC_ASSERT 0xbb52ce97

typedef struct
{
	DWORD dwSigAndSize; // LOWORD is the size in bytes. HIWORD is 0x1CEA
						// If LOWORD is 0xFFFF, the size is encoded in the
						// ...
	DWORD dwClassID;	// Domain-specific object class ID.
	DWORD dwFlags;		// HIWORD == Domain-specific flags.
						// LOWORD == Object-specific flags.

} GENERIC_SMALL_OBJECT_HEADER;

#pragma warning (disable : 4200)
typedef struct
{
	GENERIC_SMALL_OBJECT_HEADER hdr;
	BYTE rgbData[];

} GENERIC_SMALL_OBJECT;
#pragma warning (default : 4200)


#define MAKE_SigAndSize(_size) \
		MAKELONG(_size, 0x1CEA)

#define SIZE_FROM_SigAndSize(_sas) \
		LOWORD(_sas)


void
ConsolePrintfA (
		const  char   szFormat[],
		...
		);

void
ConsolePrintfW (
		const  WCHAR   wszFormat[],
		...
		);

DWORD
SendMsgToSmallStaticObject(
    DWORD dwLUID_Domain,
    DWORD dwLUID_ObjID,
    DWORD dwMsg,
    DWORD dwParam1,
    DWORD dwParam2
);

typedef struct
{
	GENERIC_SMALL_OBJECT_HEADER hdr;
	DWORD dwLUID_RFR;
	DWORD dwcbFrameSize;
	DWORD dwcbFuncDepth;

	DWORD dwRet;

} STACKLOGREC_FUNC;

#pragma warning (disable : 4200)
typedef struct
{
	GENERIC_SMALL_OBJECT_HEADER hdr;
	DWORD dwLUID_LOC;
	DWORD dwcbString;
	BYTE rgbData[];

} STACKLOGREC_EXPLICIT_STRING;
#pragma warning (default : 4200)


typedef struct
{
	GENERIC_SMALL_OBJECT_HEADER hdr;
	DWORD dwLUID_Assert;
	DWORD dwLine;

} STACKLOGREC_ASSERT;

//===============================================================
// STACK LOG
//===============================================================


#define SHOULD_LOG(_dwFlags, _Mask) TRUE

#define SLPRINTF0(_psl,_str) \
	((_psl) \
	 ? ((_psl)->LogExplicitStringA(dwLUID_CurrentLoc, _str, lstrlenA(_str)+1)) \
	 : 0) \

#define SLPRINTF1(_psl,_fmt,_v1) \
	((_psl) \
	? ((_psl)->LogPrintfA(dwLUID_CurrentLoc, _fmt, _v1)) \
	: 0)

#define SLPRINTF2(_psl,_fmt,_v1,_v2) \
	((_psl) \
	? ((_psl)->LogPrintfA(dwLUID_CurrentLoc, _fmt, _v1, _v2)) \
	: 0)

#define SLPRINTF3(_psl,_fmt,_v1,_v2,_v3) \
	((_psl) \
	? ((_psl)->LogPrintfA(dwLUID_CurrentLoc, _fmt, _v1, _v2, _v3)) \
	: 0)

#define SLPRINTF4(_psl,_fmt,_v1,_v2,_v3,_v4) \
	((_psl) \
	? ((_psl)->LogPrintfA(dwLUID_CurrentLoc, _fmt, _v1, _v2, _v3, _v4)) \
	: 0)

#define SLPRINTFX(_psl,_args) \
	((_psl) ? (_psl)->LogPrintfA _args  : 0)
	
#define FL_ASSERT(_psl,_cond) \
	((!(_cond)) \
	 ? (  ConsolePrintfA( \
				"\n!!!! ASSERTFAIL !!!! 0x%08lx (%s,%lu)\n", \
				dwLUID_CurrentLoc, \
				__FILE__, \
				__LINE__ \
			), \
		  ((_psl)? (_psl)->LogAssert(dwLUID_CurrentLoc,__LINE__):0) \
	   ) \
	 : 0)

#define FL_ASSERTEX(_psl,_luid, _cond, _reason) \
	((!(_cond)) \
	 ? (  ConsolePrintfA( \
				"\n!!!! ASSERTFAIL !!!! 0x%08lx (%s)\n", \
				dwLUID_CurrentLoc, \
				__FILE__ \
			), \
		  ((_psl)? (_psl)->LogAssert(_luid, __LINE__):0) \
	   ) \
	 : 0)


#define FL_SERIALIZE(_psl, _str) \
	((_psl) ? (_psl)->LogPrintfA(  \
                        dwLUID_CurrentLoc, \
                        "SERIALIZE(%ld):%s", \
                        (_psl)->IncSyncCounter(), \
                        (_str) \
                        ) : 0)

class CStackLog
{
public:

	static DWORD ClassID(void) {return 0xbf09e514;}

    CStackLog(
        BYTE *pbStack,
        UINT cbStack,
        LONG *plSyncCounter,
        DWORD dwFlags,
		DWORD dwLUID_Func
        )
        {

            ASSERT(!(((ULONG_PTR)pbStack)&0x3) && cbStack>4);

			m_hdr.dwSigAndSize = MAKE_SigAndSize(sizeof(*this));
			m_hdr.dwClassID = ClassID();
			m_hdr.dwFlags = dwFlags;

			m_dwLUID_Func = dwLUID_Func;
            m_pbStackTop =  pbStack;
            m_pbEnd = pbStack+cbStack;
            m_pbStackBase = pbStack;
            m_dwThreadID = GetCurrentThreadId();
            m_dwDeviceID = (DWORD)-1;
            m_plSyncCounter = plSyncCounter;
            m_lStartSyncCounterValue = InterlockedIncrement(plSyncCounter);
            m_dwcbFuncDepth = 0;
        }


    ~CStackLog()
		{
			m_hdr.dwSigAndSize=0;
        	m_pbStackTop=NULL;
        };

    BYTE *mfn_reserve_space(UINT cbSpace)
    {
        // No attempt at error checking -- m_pbStackTop could well be beyond
        // the end of the stack, or could have rolled over. We check
        // only when we decide to actually write to this space.

        BYTE *pb = m_pbStackTop;

		ASSERT(!(cbSpace&0x3));

        m_pbStackTop+=cbSpace;


        return pb;
    }

    BOOL mfn_check_space(
            BYTE *pb,
            UINT cbSize
            )
    {

		// Check if there is space.
		// The 2nd check below is for the unlikely
		// case that m_pbStackTop has rolled over. Actually it's not that
		// unlikely -- you could be in a loop, keeping on trying to 
		// add to the log -- note that mfn_reserve_space simply adds
		// to m_pbStackTop.

		if (((pb+cbSize)<m_pbEnd) &&
			m_pbStackTop>=m_pbStackBase)
		{
			return TRUE;
		}
		return FALSE;
	}


    STACKLOGREC_FUNC *
    LogFuncEntry(void)
    {
        STACKLOGREC_FUNC *pFuncRec = (STACKLOGREC_FUNC*)mfn_reserve_space(
                                                        sizeof(STACKLOGREC_FUNC)
                                                        );
        m_dwcbFuncDepth++;
        
		#ifdef DEBUG
        if (mfn_check_space(
                    (BYTE *) pFuncRec,
                    sizeof(STACKLOGREC_FUNC)))
        {
            pFuncRec->hdr.dwSigAndSize = MAKE_SigAndSize(sizeof(*pFuncRec));
            pFuncRec->hdr.dwClassID	   = dwCLASSID_STACKLOGREC_FUNC;
            pFuncRec->dwcbFuncDepth = m_dwcbFuncDepth;
        }
		#endif // DEBUG

        return pFuncRec;
    }

    STACKLOGREC_FUNC *
    LogFuncEntryEx(void)
    {
        STACKLOGREC_FUNC *pFuncRec = (STACKLOGREC_FUNC*)mfn_reserve_space(
                                                        sizeof(STACKLOGREC_FUNC)
                                                        );
        
        if (mfn_check_space(
                    (BYTE *) pFuncRec,
                    sizeof(STACKLOGREC_FUNC)))
        {
            m_dwcbFuncDepth++;
            pFuncRec->hdr.dwSigAndSize = MAKE_SigAndSize(sizeof(*pFuncRec));
            pFuncRec->hdr.dwClassID	   = dwCLASSID_STACKLOGREC_FUNC;
            pFuncRec->dwcbFuncDepth = m_dwcbFuncDepth;
        }

        return pFuncRec;
    }

    LONG
    IncSyncCounter(void)
    {
        return InterlockedIncrement(m_plSyncCounter);
    }

	#define fLOGMASK_FUNC_FAILURE 0xFFFFFFFF
	#define fLOGMASK_FUNC_SUCCESS 0xFFFFFFFF

    DWORD
    Depth(void)
    {
        return m_dwcbFuncDepth;
    }

    void
    LogFuncExit(STACKLOGREC_FUNC *pFuncRec, DWORD dwRFR, DWORD dwRet)

    {

        DWORD dwLogMask = (dwRet)
							? fLOGMASK_FUNC_FAILURE
							: fLOGMASK_FUNC_SUCCESS;

        // Check if we need to log at all 
        if (SHOULD_LOG(m_hdr.dwFlags, dwLogMask))
		{
			if (mfn_check_space(
					(BYTE *)pFuncRec,
					sizeof(STACKLOGREC_FUNC)
					))
			{
				// We've got space, record the information ....

                #ifdef DEBUG
				ASSERT(pFuncRec->hdr.dwSigAndSize == MAKE_SigAndSize(
                                                            sizeof(*pFuncRec)
                                                            ));
				ASSERT(pFuncRec->hdr.dwClassID	 == dwCLASSID_STACKLOGREC_FUNC);
				ASSERT(pFuncRec->dwcbFuncDepth ==  m_dwcbFuncDepth);
                #endif // DEBUG

				pFuncRec->hdr.dwSigAndSize = MAKE_SigAndSize(sizeof(*pFuncRec));
				pFuncRec->hdr.dwClassID	 = dwCLASSID_STACKLOGREC_FUNC;
				pFuncRec->dwcbFuncDepth =  m_dwcbFuncDepth;
				pFuncRec->dwcbFrameSize = (DWORD)(m_pbStackTop-(BYTE*)pFuncRec);
                pFuncRec->dwLUID_RFR = dwRFR;
                pFuncRec->dwRet = dwRet;

                #if 0 // def DEBUG
                printf (
                       "---- FUNCREC -----"
                       "\tFUNCREC.hdr.dwSigAndSize = 0x%08lx\n"
                       "\tFUNCREC.hdr.dwClassID    = 0x%08lx\n"
                       "\tFUNCREC.dwcbFuncDepth    = %08lu\n"
                       "\tFUNCREC.dwcbFrameSize    = %08lu\n"
                       "\tFUNCREC.dwLUID_RFR       = 0x%08lx\n"
                       "\tFUNCREC.dwRet            = 0x%08lx\n"
                       "--------------------\n",
                        pFuncRec->hdr.dwSigAndSize,
                        pFuncRec->hdr.dwClassID,
                        pFuncRec->dwcbFuncDepth,
                        pFuncRec->dwcbFrameSize,
                        pFuncRec->dwLUID_RFR,
                        pFuncRec->dwRet
                        );
                            

				DWORD dwRet = SendMsgToSmallStaticObject(
					dwLUID_DOMAIN_UNIMODEM_TSP,
					pFuncRec->dwLUID_RFR,
					LOGMSG_PRINTF,
					0,
					0
					);
				if (dwRet == (DWORD) -1)
				{
					printf (
                        "Object 0x%08lx not found\n",
    					pFuncRec->dwLUID_RFR
                        );
				}
                #endif // DEBUG

			}
			else
			{
				// Not enough space!
				ConsolePrintfA(
					"**** LogFuncExit: Out of stack space!****\n"
					);

				// clean up stack
				m_pbStackTop = (BYTE *) pFuncRec;
			}
		}
		else
		{
			// clean up stack
			m_pbStackTop = (BYTE *) pFuncRec;
		}

		// We're exiting a function, so decrement the function-depth counter.
		m_dwcbFuncDepth--;
    }

    void
    ResetFuncLog(STACKLOGREC_FUNC *pFuncRec)

    {
        // clean up stack and restore depth.
        m_pbStackTop = (BYTE *) pFuncRec;
        mfn_reserve_space(sizeof(STACKLOGREC_FUNC));

        if (mfn_check_space(
                    (BYTE *) pFuncRec,
                    sizeof(STACKLOGREC_FUNC)))
        {
            m_dwcbFuncDepth = pFuncRec->dwcbFuncDepth;
        }

        // At this time we should be in the state as though
        // just afte ra LogFuncEntryEx().
    }

    void
    LogExplicitStringA(
		DWORD dwLUID_LOC,
		const  char  szString[],
		DWORD cbString  // size of string in BYTES, including null terminating
						// character.
		)
	{

		STACKLOGREC_EXPLICIT_STRING *pslres = NULL;
		UINT cbSpace = sizeof(STACKLOGREC_EXPLICIT_STRING)+cbString;

		// Round up to dword boundary (Also implicitly truncate total size to
		// be less than 65K).
		// TODO -- deal with large size strings properly.
		cbSpace = (cbSpace+3)&0xFFFC;

    	if (mfn_check_space(m_pbStackTop, cbSpace))
		{
			pslres = (STACKLOGREC_EXPLICIT_STRING *) mfn_reserve_space(cbSpace);
			pslres->hdr.dwSigAndSize = MAKE_SigAndSize(cbSpace);
			pslres->hdr.dwClassID	 = dwCLASSID_STACKLOGREC_EXPLICIT_STRING;
		    pslres->hdr.dwFlags = 0;
			pslres->dwLUID_LOC = dwLUID_LOC;
			pslres->dwcbString = cbString; // TODO -- deal with large string
			CopyMemory(pslres->rgbData, szString, cbString);
		}

	}

    void
    LogExplicitStringW(
		DWORD dwLUID_LOC,
		const  WCHAR  wszString[],
		DWORD cbString  // size of string in BYTES, including null terminating
						// character.
		)
	{

		STACKLOGREC_EXPLICIT_STRING *pslres = NULL;
		UINT cbSpace = sizeof(STACKLOGREC_EXPLICIT_STRING)+cbString;

		// Round up to dword boundary (Also implicitly truncate total size to
		// be less than 65K).
		// TODO -- deal with large size strings properly.
		cbSpace = (cbSpace+3)&0xFFFC;

    	if (mfn_check_space(m_pbStackTop, cbSpace))
		{
			pslres = (STACKLOGREC_EXPLICIT_STRING *) mfn_reserve_space(cbSpace);
			pslres->hdr.dwSigAndSize = MAKE_SigAndSize(cbSpace);
		    pslres->hdr.dwFlags = fFL_UNICODE;
			pslres->hdr.dwClassID	 = dwCLASSID_STACKLOGREC_EXPLICIT_STRING;
			pslres->dwLUID_LOC = dwLUID_LOC;
			pslres->dwcbString = cbString; // TODO -- deal with large string
			CopyMemory(pslres->rgbData, wszString, cbString);
		}

	}


// SLPRINTF0(psl, "string");
// SLPRINTF1(psl, "This is %d", dw1);
// SLPRINTF2(psl, "This is %d and %d", dw1, dw2);
// SLPRINTFX(psl, ("This is %d %d" , dw1, dw2));

	
    void
    LogPrintfA(
		DWORD dwLUID_LOC,
		const  char   szFormat[],
		...
		)
	{
		char rgb[256];
		UINT u=0;
		va_list ArgList;

		va_start(ArgList, szFormat);

		u = 1+wvsprintfA(rgb, szFormat,  ArgList);

    	CStackLog::LogExplicitStringA(
						dwLUID_LOC,
						rgb,
						u
						);
		ASSERT(u<sizeof(rgb)); // TODO make this more robust by implementing
							   // wvsnprintf.
		va_end(ArgList);
	
	}

    void
    LogPrintfW(
		DWORD dwLUID_LOC,
		const  WCHAR   wszFormat[],
		...
		)
	{
		WCHAR rgwch[256];
		UINT u=0;
		va_list ArgList;

		va_start(ArgList, wszFormat);

		u = sizeof(WCHAR)*(1+wvsprintf(rgwch, wszFormat,  ArgList));

    	CStackLog::LogExplicitStringW(
						dwLUID_LOC,
						rgwch,
						u
						);
		ASSERT(u<sizeof(rgwch)); // TODO make this more robust by implementing
							   // wvsnprintf.
		va_end(ArgList);
	
	}
    void
    LogAssert(
		DWORD dwLUID_Assert,
        DWORD dwLineNo
		)
	{

		STACKLOGREC_ASSERT *pslra = NULL;
		UINT cbSpace = sizeof(STACKLOGREC_ASSERT);

    	if (mfn_check_space(m_pbStackTop, cbSpace))
		{
			pslra = (STACKLOGREC_ASSERT *) mfn_reserve_space(cbSpace);
			pslra->hdr.dwSigAndSize = MAKE_SigAndSize(cbSpace);
			pslra->hdr.dwClassID	 = dwCLASSID_STACKLOGREC_ASSERT;
			pslra->dwLUID_Assert = dwLUID_Assert;
			pslra->dwLine = dwLineNo;
		}
		m_hdr.dwFlags |= fFL_ASSERTFAIL;

	}
	void Dump(DWORD dwColor);

    void
    SetDeviceID(DWORD dwID)
    // Used only for display. Will override previous value, if set.
    {
        m_dwDeviceID = dwID;
    }

private:

	GENERIC_SMALL_OBJECT_HEADER m_hdr;
	DWORD m_dwLUID_Func;  // LUID of function that created that stacklog.
    BYTE  *m_pbStackTop;  // top of logging stack.
    BYTE  *m_pbEnd;       // last valid entry in logging stack.
    BYTE  *m_pbStackBase;  // origin of stack
    DWORD  m_dwcbFuncDepth;  // depth of function calls.
    DWORD m_dwThreadID;   // thread ID in whose context this is running.
    LONG *m_plSyncCounter; // pointer to do internlocked-increment on.
    LONG m_lStartSyncCounterValue; // value of this when creating log.
    DWORD m_dwDeviceID; // Identifying ID (typically lineID) of
                        // device associated with this log, if applicable.
                        // This can be filled in later, using the
                        // SetDeviceID() method.

};

extern LONG g_lStackLogSyncCounter;

#define FL_DECLARE_STACKLOG(_logname,_stacksize) \
	BYTE rgbFL_Stack[_stacksize];\
	CStackLog _logname (\
			rgbFL_Stack,\
			sizeof(rgbFL_Stack),\
			&g_lStackLogSyncCounter,\
			0,\
			dwLUID_CurrentFunc\
			)

#define FL_LOG_ENTRY(_psl) \
    STACKLOGREC_FUNC *pslrf = (_psl) ? (_psl)->LogFuncEntry(): NULL

#define FL_LOG_ENTRY_EX(_psl) \
    STACKLOGREC_FUNC *pslrf = (_psl) ? (_psl)->LogFuncEntryEx(): NULL

#define FL_LOG_EXIT(_psl, _ret) \
     ((_psl) ? (_psl)->LogFuncExit(pslrf, dwLUID_RFR, (DWORD) _ret):0)

#define FL_RESET_LOG(_psl) \
     ((_psl) ? (_psl)->ResetFuncLog(pslrf):0)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\tsp\flhash.h ===
// 
// Copyright (c) 1996-1997 Microsoft Corporation.
//
//
// Component
//
//		Unimodem 5.0 TSP (Win32, user mode DLL)
//
// File
//
//		FLHASH.H
//
//		Internal header used by logging routines to maintain a static
//      hashtable of objects.
//
// History
//
//		12/28/1996  JosephJ Created
//
//
#define UNICODE 1

#include <windows.h>
#include <stdio.h>
#include "debug.h"
#include "fastlog.h"

// All objects in the static hash table have the following form.
typedef struct
{
	GENERIC_SMALL_OBJECT_HEADER hdr;
	DWORD dwLUID_ObjID;

} STATIC_OBJECT;

typedef struct
{
	GENERIC_SMALL_OBJECT_HEADER hdr;

	DWORD dwLUID; // MUST immediately follow hdr -- to match STATIC_OBJECT

	const char *const *pszDescription;
	const char *szFILE;
	const char *szDATE;
	const char *szTIME;
	const char *szTIMESTAMP;

} FL_FILEINFO;

typedef struct
{
	GENERIC_SMALL_OBJECT_HEADER hdr;

	DWORD dwLUID; // MUST immediately follow hdr -- to match STATIC_OBJECT

	const char *const *pszDescription;
	const FL_FILEINFO *pFI;

} FL_FUNCINFO;



typedef struct
{
	GENERIC_SMALL_OBJECT_HEADER hdr;

	DWORD dwLUID; // MUST immediately follow hdr -- to match STATIC_OBJECT

	const char *const *pszDescription;

	const FL_FUNCINFO *pFuncInfo;

} FL_LOCINFO;


typedef struct
{
	GENERIC_SMALL_OBJECT_HEADER hdr;

	DWORD dwLUID; // MUST immediately follow hdr -- to match STATIC_OBJECT

	const char *const *pszDescription;

	const FL_FUNCINFO *pFuncInfo;

} FL_RFRINFO;

typedef struct
{
	GENERIC_SMALL_OBJECT_HEADER hdr;

	DWORD dwLUID; // MUST immediately follow hdr -- to match STATIC_OBJECT

	const char *const *pszDescription;

	const FL_FUNCINFO *pFuncInfo;

} FL_ASSERTINFO;

extern void ** FL_HashTable[];
extern const DWORD dwHashTableLength;

#define dwLUID_FL_FILEINFO 0xf6a98ffc
#define dwLUID_FL_FUNCINFO 0xda6f6acc
#define dwLUID_FL_LOCINFO  0x1b0d0cbb
#define dwLUID_FL_RFRINFO  0xed8bb4bd
#define dwLUID_FL_ASSERTINFO  0xf8c7a51d
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\tsp\fastlog.cpp ===
//
// Copyright (c) 1996-1997 Microsoft Corporation.
//
//
// Component
//
//		Unimodem 5.0 TSP (Win32, user mode DLL)
//
// File
//
//		FASTLOG.CPP
//		Implements logging functionality, including the great CStackLog
//
// History
//
//		12/28/1996  JosephJ Created
//
//
#include "tsppch.h"
#include "flhash.h"

#define NOLOG

#ifndef DBG
#define NOLOG
#endif // !DBG


#ifdef NOLOG
DWORD g_fDoLog = FALSE;
#else
DWORD g_fDoLog = TRUE;
#endif

#define DISABLE_LOG() (!g_fDoLog)

FL_DECLARE_FILE( 0xd13e9753 , "utilities for retrieving static diagnostic objects")

static CRITICAL_SECTION g_LogCrit;
static HANDLE g_hConsole;
LONG g_lStackLogSyncCounter;

#define VALID_GENERIC_SMALL_OBJECT(_pgso) \
        (HIWORD(*(DWORD*)(_pgso)) ==  wSIG_GENERIC_SMALL_OBJECT)


void Log_OnProcessAttach(HMODULE hDll)
{
    InitializeCriticalSection(&g_LogCrit);
}
void Log_OnProcessDetach(HMODULE hDll)
{
    DeleteCriticalSection(&g_LogCrit);
}

STATIC_OBJECT *FL_FindObject(DWORD dwLUID_ObjID)
{
	FL_DECLARE_FUNC(0x9a8fe0cd, "FL_FindObject")

	// 1/4/97 JosephJ, munge LSB of luid, because it is zeroed out for
	//       RFR luids....
	DWORD dwIndex = (dwLUID_ObjID ^ (dwLUID_ObjID>>16)) % dwHashTableLength;

    // printf ("LUID=%08lx; index=%lu\n", dwLUID_ObjID, dwIndex);

    void ** ppv = FL_HashTable[dwIndex];

    if (ppv)
    {

        while (*ppv)
        {
			FL_DECLARE_LOC(0x0d88a752, "Looking for object in bucket")
            STATIC_OBJECT *pso = (STATIC_OBJECT *) *ppv;
            // printf("looking at 0x%08lx\n", *ppv);
            ASSERT(VALID_GENERIC_SMALL_OBJECT(pso));
            if (pso->dwLUID_ObjID == dwLUID_ObjID)
            {
				FL_SET_RFR( 0xbacd5500, "Success!");
                return pso;
            }
            ppv++;
        }
    }
	return NULL;
}



DWORD
SendMsgToSmallStaticObject_UNIMODEM_TSP (
    DWORD dwLUID_ObjID,
    DWORD dwMsg,
    ULONG_PTR dwParam1,
    ULONG_PTR dwParam2
);


DWORD
SendMsgToFL_FILEINFO (
    const FL_FILEINFO *pfi,
    DWORD dwMsg,
    ULONG_PTR dwParam1,
    ULONG_PTR dwParam2
	);

DWORD
SendMsgToFL_FUNCINFO (
    const FL_FUNCINFO *pfi,
    DWORD dwMsg,
    ULONG_PTR dwParam1,
    ULONG_PTR dwParam2
);

DWORD
SendMsgToFL_LOCINFO (
    const FL_LOCINFO *pli,
    DWORD dwMsg,
    ULONG_PTR dwParam1,
    ULONG_PTR dwParam2
);

DWORD
SendMsgToFL_RFRINFO (
    const FL_RFRINFO *pri,
    DWORD dwMsg,
    ULONG_PTR dwParam1,
    ULONG_PTR dwParam2
);

DWORD
SendMsgToFL_ASSERTINFO (
    const FL_ASSERTINFO *pai,
    DWORD dwMsg,
    ULONG_PTR dwParam1,
    ULONG_PTR dwParam2
);

DWORD
SendMsgToSmallStaticObject(
    DWORD dwLUID_Domain,
    DWORD dwLUID_ObjID,
    DWORD dwMsg,
    ULONG_PTR dwParam1,
    ULONG_PTR dwParam2
)
{
	FL_DECLARE_FUNC( 0x0aff4b3d , "SendMsgToSmallStaticObject")
    DWORD dwRet = (DWORD)-1;

    switch(dwLUID_Domain)
    {
	case dwLUID_DOMAIN_UNIMODEM_TSP:
        dwRet = SendMsgToSmallStaticObject_UNIMODEM_TSP (
                dwLUID_ObjID,
                dwMsg,
                dwParam1,
                dwParam2
                );
        break;
    }

    return dwRet;
}

DWORD

SendMsgToSmallStaticObject_UNIMODEM_TSP (
    DWORD dwLUID_ObjID,
    DWORD dwMsg,
    ULONG_PTR  dwParam1,
    ULONG_PTR  dwParam2
)
{
	FL_DECLARE_FUNC( 0x80a1ad8f, "SendMsgToSmallStaticObject_UNIMODEM_TSP")
	DWORD dwRet  = (DWORD) -1;

	STATIC_OBJECT *pso = FL_FindObject(dwLUID_ObjID); // Look up object.
	if (pso)
	{

		switch (pso->hdr.dwClassID)
		{

		case dwLUID_FL_FILEINFO:
			{
				
        	const FL_FILEINFO *pfi =  (const FL_FILEINFO*) pso;
			dwRet = SendMsgToFL_FILEINFO(
					pfi,
					dwMsg,
					dwParam1,
					dwParam2
				);
			}
			break;

		case dwLUID_FL_FUNCINFO:
			{
				
        	const FL_FUNCINFO *pfi =  (const FL_FUNCINFO*) pso;
			dwRet = SendMsgToFL_FUNCINFO(
					pfi,
					dwMsg,
					dwParam1,
					dwParam2
				);
			}
			break;

		case dwLUID_FL_LOCINFO:
			{
				
        	const FL_LOCINFO *pli =  (const FL_LOCINFO*) pso;
			dwRet = SendMsgToFL_LOCINFO(
					pli,
					dwMsg,
					dwParam1,
					dwParam2
				);
			}
			break;

		case dwLUID_FL_RFRINFO:
			{
				
        	const FL_RFRINFO *pri =  (const FL_RFRINFO*) pso;
			dwRet = SendMsgToFL_RFRINFO(
					pri,
					dwMsg,
					dwParam1,
					dwParam2
				);
			}
			break;

		case dwLUID_FL_ASSERTINFO:
			{
				
        	const FL_ASSERTINFO *pai =  (const FL_ASSERTINFO*) pso;
			dwRet = SendMsgToFL_ASSERTINFO(
					pai,
					dwMsg,
					dwParam1,
					dwParam2
				);
			}
			break;
		}
	}

	return dwRet;
}

DWORD
SendMsgToFL_FILEINFO (
    const FL_FILEINFO *pfi,
    DWORD dwMsg,
    ULONG_PTR dwParam1,
    ULONG_PTR dwParam2
)
{
	DWORD dwRet = (DWORD) -1;

	ASSERT(pfi->hdr.dwClassID == dwLUID_FL_FILEINFO);
	ASSERT(pfi->hdr.dwSigAndSize == MAKE_SigAndSize(
										sizeof(FL_FILEINFO)
										));
	switch (dwMsg)
	{
		case LOGMSG_PRINTF:
        #if 0
			1 && printf (
				"------\n"
				"\tdwLUID = 0x%08lx\n"
				"\tszDescription = \"%s\"\n"
				"\tszFILE = \"%s\"\n"
				"\tszDATE = \"%s\"\n"
				"\tszTIME = \"%s\"\n"
				"\tszTIMESTAMP = \"%s\"\n",
				pfi->dwLUID,
				*(pfi->pszDescription),
				pfi->szFILE,
				pfi->szDATE,
				pfi->szTIME,
				pfi->szTIMESTAMP
				);
        #endif // 0
		dwRet = 0;
		break;

		case LOGMSG_GET_SHORT_FILE_DESCRIPTIONA:
			{
				const char *psz = pfi->szFILE+lstrlenA(pfi->szFILE);
				DWORD dwSize = 1; // the ending null

				// Extract just the file name
				while(psz>pfi->szFILE)
				{
					if (*psz == '\\')
					{
						psz++;
						dwSize--;
						break;
					}
					psz--;
					dwSize++;
				}

				if (dwSize>(DWORD)dwParam2)
				{
					dwSize = (DWORD)dwParam2;
				}
				CopyMemory((BYTE *) dwParam1, psz, dwSize);
				if (dwSize && dwSize==dwParam2)
				{
					((BYTE *) dwParam1)[dwSize-1] = 0;
				}
				dwRet = 0;
			}
			break;
	}

	return dwRet;
}

DWORD
SendMsgToFL_FUNCINFO (
    const FL_FUNCINFO *pfi,
    DWORD dwMsg,
    ULONG_PTR dwParam1,
    ULONG_PTR dwParam2
)
{
	DWORD dwRet = (DWORD) -1;

	ASSERT(pfi->hdr.dwClassID == dwLUID_FL_FUNCINFO);
	ASSERT(pfi->hdr.dwSigAndSize == MAKE_SigAndSize(
										sizeof(FL_FUNCINFO)
										));
	switch (dwMsg)
	{
		case LOGMSG_PRINTF:
            #if 0
			1 && printf (
				"-- FUNCINFO ----\n"
				"\tdwLUID = 0x%08lx\n"
				"\tszDescription = \"%s\"\n",
				pfi->dwLUID,
				*(pfi->pszDescription)
				);
			1 && printf ("File info for this func follows ...\n");
            #endif // 0
			dwRet = 0;
			break;

		case LOGMSG_GET_SHORT_FUNC_DESCRIPTIONA:
			{
				const char *psz = *(pfi->pszDescription);
				DWORD dwSize = lstrlenA(psz)+1;
				if (dwSize>dwParam2)
				{
					dwSize = (DWORD)dwParam2;
				}
				CopyMemory((BYTE *) dwParam1, psz, dwSize);
				if (dwSize && dwSize==dwParam2)
				{
					((BYTE *) dwParam1)[dwSize-1] = 0;
				}
				dwRet = 0;
			}
			break;

		case LOGMSG_GET_SHORT_RFR_DESCRIPTIONA:
			{
				if (dwParam2)
				{
					*((BYTE *) dwParam1) = 0;
				}
			}
			dwRet = 0;
			break;

		case LOGMSG_GET_SHORT_FILE_DESCRIPTIONA:

			dwRet = SendMsgToFL_FILEINFO (
								pfi->pFI,
								dwMsg,
								dwParam1,
								dwParam2
								);
			break;

	}
    #if 0
	SendMsgToFL_FILEINFO (
		pfi->pFI,
		dwMsg,
		dwParam1,
		dwParam2
	);
    #endif

	return dwRet;
}

DWORD
SendMsgToFL_LOCINFO (
    const FL_LOCINFO *pli,
    DWORD dwMsg,
    ULONG_PTR dwParam1,
    ULONG_PTR dwParam2
)
{
	DWORD dwRet = (DWORD) -1;

	ASSERT(pli->hdr.dwClassID == dwLUID_FL_LOCINFO);
	ASSERT(pli->hdr.dwSigAndSize == MAKE_SigAndSize(
										sizeof(FL_LOCINFO)
										));
	switch (dwMsg)
	{
		case LOGMSG_PRINTF:
            #if 0
			1 && printf (
				"-- LOCINFO ----\n"
				"\tdwLUID = 0x%08lx\n"
				"\tszDescription = \"%s\"\n",
				pli->dwLUID,
				*(pli->pszDescription)
				);
			1 && printf ("Func info for this location follows ...\n");
            #endif // 0
		dwRet = 0;
		break;
	}
    #if 1
	SendMsgToFL_FUNCINFO (
		pli->pFuncInfo,
		dwMsg,
		dwParam1,
		dwParam2
	);
    #endif

	return dwRet;
}


DWORD
SendMsgToFL_RFRINFO (
    const FL_RFRINFO *pri,
    DWORD dwMsg,
    ULONG_PTR dwParam1,
    ULONG_PTR dwParam2
)
{
	DWORD dwRet = (DWORD) -1;

	ASSERT(pri->hdr.dwClassID == dwLUID_FL_RFRINFO);
	ASSERT(pri->hdr.dwSigAndSize == MAKE_SigAndSize(
										sizeof(FL_RFRINFO)
										));
	switch (dwMsg)
	{
		case LOGMSG_PRINTF:
            #if 0
			1 && printf (
				"-- RFRINFO ----\n"
				"\tdwLUID = 0x%08lx\n"
				"\tszDescription = \"%s\"\n",
				pri->dwLUID,
				*(pri->pszDescription)
				);
			1 && printf ("Func info for this location follows ...\n");
            #endif//0
		dwRet = 0;
		break;

		case LOGMSG_GET_SHORT_RFR_DESCRIPTIONA:
			{
				const char *psz = *(pri->pszDescription);
				DWORD dwSize = lstrlenA(psz)+1;
				if (dwSize>(DWORD)dwParam2)
				{
					dwSize = (DWORD)dwParam2;
				}
				CopyMemory((BYTE *) dwParam1, psz, dwSize);
				if (dwSize && dwSize==dwParam2)
				{
					((BYTE *) dwParam1)[dwSize-1] = 0;
				}
			}
			dwRet = 0;
			break;

		case LOGMSG_GET_SHORT_FUNC_DESCRIPTIONA:
		dwRet = SendMsgToFL_FUNCINFO (
							pri->pFuncInfo,
							dwMsg,
							dwParam1,
							dwParam2
							);
		break;
	}
    #if 0
	SendMsgToFL_FUNCINFO (
		pri->pFuncInfo,
		dwMsg,
		dwParam1,
		dwParam2
	);
    #endif

	return dwRet;
}


DWORD
SendMsgToFL_ASSERTINFO (
    const FL_ASSERTINFO *pai,
    DWORD dwMsg,
    ULONG_PTR dwParam1,
    ULONG_PTR dwParam2
)
{
	DWORD dwRet = (DWORD) -1;

	ASSERT(pai->hdr.dwClassID == dwLUID_FL_ASSERTINFO);
	ASSERT(pai->hdr.dwSigAndSize == MAKE_SigAndSize(
										sizeof(FL_ASSERTINFO)
										));
	switch (dwMsg)
	{
		case LOGMSG_PRINTF:
            #if 0
			1 && printf (
				"-- ASSERTINFO ----\n"
				"\tdwLUID = 0x%08lx\n"
				"\tszDescription = \"%s\"\n",
				pai->dwLUID,
				*(pai->pszDescription)
				);
			1 && printf ("Func info for this location follows ...\n");
            #endif // 0
		dwRet = 0;
		break;

		case LOGMSG_GET_SHORT_ASSERT_DESCRIPTIONA:
			{
				const char *psz = *(pai->pszDescription);
				DWORD dwSize = lstrlenA(psz)+1;
				if (dwSize>(DWORD)dwParam2)
				{
					dwSize = (DWORD)dwParam2;
				}
				CopyMemory((BYTE *) dwParam1, psz, dwSize);
				if (dwSize && dwSize==dwParam2)
				{
					((BYTE *) dwParam1)[dwSize-1] = 0;
				}
			}
			dwRet = 0;
			break;

		case LOGMSG_GET_SHORT_FUNC_DESCRIPTIONA:
		case LOGMSG_GET_SHORT_FILE_DESCRIPTIONA:
		dwRet = SendMsgToFL_FUNCINFO (
							pai->pFuncInfo,
							dwMsg,
							dwParam1,
							dwParam2
							);
		break;
	}
    #if 0
	SendMsgToFL_FUNCINFO (
		pai->pFuncInfo,
		dwMsg,
		dwParam1,
		dwParam2
	);
    #endif

	return dwRet;
}



UINT
DumpSTACKLOGREC_FUNC(
	const char szPrefix[],
	char *szBuf,
	UINT cbBuf,
	STACKLOGREC_FUNC * pFuncRec
	);


UINT
DumpSTACKLOGREC_ASSERT(
	const char szPrefix[],
	char *szBuf,
	UINT cbBuf,
	STACKLOGREC_ASSERT * pAssert
	);


#include <malloc.h>

#define DUMP_BUFFER_SIZE (10000)

void
CStackLog::Dump(DWORD dwColor)
{

    if (DISABLE_LOG()) return;

    char *rgDumpBuf;

    _try {
        //
        //  use alloca so we can catch any stack faults using the exception handler.
        //  needed when the os can't commit another stack page in low memory situations
        //
        rgDumpBuf=(char*)_alloca(DUMP_BUFFER_SIZE);

    } _except (EXCEPTION_EXECUTE_HANDLER) {

        return;
    }

	BYTE *pb = m_pbStackBase;
    DWORD rgdwFrameTracker[256];
	char rgTitle[256];
	DWORD dwRet;

	char *psz = rgDumpBuf;
	UINT cbBufLeft = DUMP_BUFFER_SIZE;
	UINT cb;

	DWORD dwCurrentOffset = 0;
	DWORD dwCurrentDepth = 0;
	char szPrefix[128];

	if (!g_hConsole) {g_hConsole = GetStdHandle(STD_OUTPUT_HANDLE);}

	ZeroMemory(rgdwFrameTracker, sizeof(rgdwFrameTracker));
    rgdwFrameTracker[0] = (DWORD)(m_pbStackTop-pb);
	*szPrefix = 0;

	// Get short description of reason-for-return
	*rgTitle=0;
	SendMsgToSmallStaticObject(
		dwLUID_DOMAIN_UNIMODEM_TSP,
		m_dwLUID_Func,
		LOGMSG_GET_SHORT_FUNC_DESCRIPTIONA,
		(ULONG_PTR) rgTitle,
		sizeof(rgTitle)
		);

	cb=wsprintfA(
		rgDumpBuf,
"-------------------------------------------------------------------------------\n"
#if 1
		"STACKLOG TID=%lu DID=%ld Sync=(%ld:%ld)%s %lu\\%lu used.\n%s\n",
		m_dwThreadID,
		m_dwDeviceID,
        m_lStartSyncCounterValue,
        CStackLog::IncSyncCounter(),
		(m_hdr.dwFlags&fFL_ASSERTFAIL) ? "***ASSERTFAIL***" : "",
        (m_pbStackTop-m_pbStackBase),
        (m_pbEnd-m_pbStackBase),
		rgTitle


#else
		"STACKLOG for %s (TID=%lu; %lu/%lu bytes used;%s)/%ld:%ld\n",
		rgTitle,
		m_dwThreadID,
        (m_pbStackTop-m_pbStackBase),
        (m_pbEnd-m_pbStackBase),
		(m_hdr.dwFlags&fFL_ASSERTFAIL) ? "***ASSERTFAIL***" : "",
        m_lStartSyncCounterValue,
        CStackLog::IncSyncCounter()
#endif
		);
	psz+=cb;
	ASSERT(cbBufLeft>=cb);
	cbBufLeft -= cb;

	while (pb<m_pbStackTop && cbBufLeft)
	{
		const GENERIC_SMALL_OBJECT_HEADER *pso =
				(const GENERIC_SMALL_OBJECT_HEADER *) pb;
		DWORD dwSize = SIZE_FROM_SigAndSize(pso->dwSigAndSize);
		static char rgNullPrefixTag[] = "  ";
		static char rgPrefixTag[]     = "| ";

		ASSERT(HIWORD(pso->dwSigAndSize) == wSIG_GENERIC_SMALL_OBJECT);
		ASSERT(!(dwSize&0x3));

		//
		// Compute current depth
		//
		if(pso->dwClassID == dwCLASSID_STACKLOGREC_FUNC)
		{
			dwCurrentDepth = ((STACKLOGREC_FUNC *) pso)->dwcbFuncDepth;
			// printf("Current Depth=%lu\n", dwCurrentDepth);
			if (dwCurrentDepth)
			{
				dwCurrentDepth--;
			}
		}
		else
		{
			while (dwCurrentDepth
				   && rgdwFrameTracker[dwCurrentDepth] <= dwCurrentOffset)
			{
				dwCurrentDepth--;
			}
		}


		//
		// Compute prefix
		//

		char *sz = szPrefix;
		*sz = 0;
		for (DWORD dw = 0; dw<dwCurrentDepth; dw++)
		{
			if (rgdwFrameTracker[dw] > dwCurrentOffset)
			{
				CopyMemory(sz, rgPrefixTag, sizeof(rgPrefixTag));
				sz+=(sizeof(rgPrefixTag)-1);
			}
			else
			{
				CopyMemory(sz, rgNullPrefixTag, sizeof(rgNullPrefixTag));
				sz+=(sizeof(rgNullPrefixTag)-1);
			}
		}


		// Insert a blank line
		cb = wsprintfA(psz, "%s%s\n", szPrefix, rgPrefixTag);
		psz += cb;


		switch(pso->dwClassID)
		{

		case dwCLASSID_STACKLOGREC_FUNC:
			{
				STACKLOGREC_FUNC * pFuncRec = (STACKLOGREC_FUNC *) pso;
				DWORD dwDepth = pFuncRec->dwcbFuncDepth;

				cb=DumpSTACKLOGREC_FUNC(
						szPrefix,
						psz,
						cbBufLeft,
						pFuncRec
						);


				// Set frame offset of current depth...
				rgdwFrameTracker[dwDepth] = dwCurrentOffset
											+ pFuncRec->dwcbFrameSize;

				// If the next higher level frame is now over,
				// nuke it's entry in the frame tracker entry
				if (dwDepth)
				{
					if (rgdwFrameTracker[dwDepth-1]
						<= (dwCurrentOffset + pFuncRec->dwcbFrameSize))
					{
						rgdwFrameTracker[dwDepth-1] = 0;
					}
				}
				dwCurrentDepth = dwDepth;
			}
			break;

		case dwCLASSID_STACKLOGREC_EXPLICIT_STRING:
			{
				STACKLOGREC_EXPLICIT_STRING *pExpStr =
											(STACKLOGREC_EXPLICIT_STRING *) pso;

				if (pso->dwFlags & fFL_UNICODE)
				{
					// TODO: Support UNICODE strings.

					cb = wsprintfA (
							"%s|  %s\n",
							psz,
							szPrefix,
							"*** UNICODE STRING (can't display) ***\n"
							);
				}
				else
				{
					// Replace all embedded newlines by null...
					char *psz1 = (char*)pExpStr->rgbData;
					char *pszEnd = psz1 + pExpStr->dwcbString;
					while(psz1 < pszEnd)
					{
						if (*psz1== '\n') *psz1 = 0;
						psz1++;
					}

					psz1 = (char*)pExpStr->rgbData;
					cb = 0;
					while(psz1 < pszEnd)
					{
						cb += wsprintfA (
								psz+cb,
								"%s|  %s\n",
								szPrefix,
								psz1
								);
						psz1 += lstrlenA(psz1)+1;
					}
					// TODO: check for size, also replace embedded newlines!
				}
			}
			break;

		case dwCLASSID_STACKLOGREC_ASSERT:
			{
				STACKLOGREC_ASSERT *pAssert =
											(STACKLOGREC_ASSERT *) pso;

				cb=DumpSTACKLOGREC_ASSERT(
						szPrefix,
						psz,
						cbBufLeft,
						pAssert
						);

			}
			break;

		default:
			cb = wsprintfA (
					psz,
					"%s**Unknown classID 0x%08lx**\n",
					szPrefix,
					pso->dwClassID
					);
			break;
			
		}
		dwCurrentOffset += dwSize;
		pb += dwSize;
		psz+=cb;
		ASSERT(cbBufLeft>=cb);
		cbBufLeft -=cb;
	}
	// TODO watch for size!
	lstrcpyA(
		psz,
"-------------------------------------------------------------------------------\n"
		);

    if (g_hConsole)
    {
        EnterCriticalSection(&g_LogCrit);

        SetConsoleTextAttribute(
                        g_hConsole,
                        (WORD) dwColor
                        );

        //
        // NOTE: wvsprintfa truncates strings longer than 1024 bytes!
        // So we print to the console in stages, which is a bummer because
        // other threads could come in between (1/25/97 JosephJ -- fixed latter
        // problem by enclosing all writes to ConsolePrintfX in a
        // critical section.
        cb = lstrlenA(rgDumpBuf);
        for (psz = rgDumpBuf; (psz+512)<(rgDumpBuf+cb); psz+=512)
        {
            char c = psz[512];
            psz[512]=0;
            ConsolePrintfA ("%s", psz);
            psz[512]=c;
        }


        ConsolePrintfA ("%s", psz);

        SetConsoleTextAttribute(
                        g_hConsole,
                        FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE
                        );

        LeaveCriticalSection(&g_LogCrit);
    }

    #ifdef DBG
    //OutputDebugStringA(rgDumpBuf);
    #endif // DBG

	return;

}

UINT
DumpSTACKLOGREC_FUNC(
		const char szPrefix[],
		char *szBuf,
		UINT cbBuf,
		STACKLOGREC_FUNC * pFuncRec
		)
{
	// TODO:  use cbBuf

	char szRFRDescription[64];
	char szFuncDescription[64];

	DWORD dwRet = 0;

	*szRFRDescription = *szFuncDescription = 0;

	// Get short description of reason-for-return
	dwRet = SendMsgToSmallStaticObject(
		dwLUID_DOMAIN_UNIMODEM_TSP,
		pFuncRec->dwLUID_RFR,
		LOGMSG_GET_SHORT_RFR_DESCRIPTIONA,
		(ULONG_PTR) szRFRDescription,
		sizeof(szRFRDescription)
		);

	if (dwRet == (DWORD)-1)
    {
        wsprintfA (
			szRFRDescription,
            "*** Unknown object 0x%08lx***",
             pFuncRec->dwLUID_RFR
             );
    }
	
	// Get short description of function name.
	dwRet = SendMsgToSmallStaticObject(
		dwLUID_DOMAIN_UNIMODEM_TSP,
		pFuncRec->dwLUID_RFR,
		LOGMSG_GET_SHORT_FUNC_DESCRIPTIONA,
		(ULONG_PTR) szFuncDescription,
		sizeof(szFuncDescription)
		);
	if (dwRet == (DWORD)-1)
    {
        lstrcpyA ( szFuncDescription, "*** Unknown function name ***");
    }

	dwRet = wsprintfA(
		szBuf, "%s*%s....%s (0x%lx)\n",
		szPrefix,
		szFuncDescription,
		szRFRDescription,
        pFuncRec->dwRet
		);

	return dwRet;
}

UINT
DumpSTACKLOGREC_ASSERT(
		const char szPrefix[],
		char *szBuf,
		UINT cbBuf,
		STACKLOGREC_ASSERT * pAssert
		)
{
	// TODO:  use cbBuf

	char szAssertDescription[64];
	char szFuncDescription[64];

	DWORD dwRet = 0;

	*szAssertDescription = *szFuncDescription = 0;

	// Get short description of reason-for-return
	dwRet = SendMsgToSmallStaticObject(
		dwLUID_DOMAIN_UNIMODEM_TSP,
		pAssert->dwLUID_Assert,
		LOGMSG_GET_SHORT_ASSERT_DESCRIPTIONA,
		(ULONG_PTR) szAssertDescription,
		sizeof(szAssertDescription)
		);

	if (dwRet == (DWORD)-1)
    {
        wsprintfA (
			szAssertDescription,
            "*** Unknown object 0x%08lx***",
             pAssert->dwLUID_Assert
             );
    }
	
	// Get short description of function name.
	dwRet = SendMsgToSmallStaticObject(
		dwLUID_DOMAIN_UNIMODEM_TSP,
		pAssert->dwLUID_Assert,
		LOGMSG_GET_SHORT_FILE_DESCRIPTIONA,
		(ULONG_PTR) szFuncDescription,
		sizeof(szFuncDescription)
		);
	if (dwRet == (DWORD)-1)
    {
        lstrcpyA ( szFuncDescription, "*** Unknown function name ***");
    }

	dwRet = wsprintfA(
		szBuf,
		"%s|  !!!! ASSERTFAIL !!!! %s 0x%08lx (%s,%lu)\n",
		szPrefix,
		szAssertDescription,
		pAssert->dwLUID_Assert,
		szFuncDescription,
        pAssert->dwLine
		);

	return dwRet;
}


void ConsolePrintfA (
		const  char   szFormat[],
		...
		)
{
    if (DISABLE_LOG()) return;

    char *rgch;

    _try {
        //
        //  use alloca so we can catch any stack faults using the exception handler.
        //  needed when the os can't commit another stack page in low memory situations
        //
        rgch=(char*)_alloca(DUMP_BUFFER_SIZE);

    } _except (EXCEPTION_EXECUTE_HANDLER) {

        return;
    }

    DWORD cch=0, cchWritten;

    va_list ArgList;
    va_start(ArgList, szFormat);

    if (!g_hConsole) {g_hConsole = GetStdHandle(STD_OUTPUT_HANDLE);}

    if (g_hConsole)
    {
        EnterCriticalSection(&g_LogCrit);

        // NOTE: wvsprintfA doesn't like to deal with strings
        // larger that 1024 bytes! It simply stops processing
        // after 1024 bytes.
        //

        cch = (1+wvsprintfA(rgch, szFormat,  ArgList));

        ASSERT(cch*sizeof(char)<sizeof(rgch)); // TODO make more robust
        // wvsnprintf.

        WriteConsoleA(g_hConsole, rgch, cch, &cchWritten, NULL);


        // Don't close the handle -- it will kill the console!
        //
        // if (g_hConsole!=INVALID_HANDLE_VALUE) CloseHandle(g_hConsole);

        LeaveCriticalSection(&g_LogCrit);
    }

    va_end(ArgList);
}


void
ConsolePrintfW (
		const  WCHAR   wszFormat[],
		...
		)
{

    if (DISABLE_LOG()) return;

		WCHAR rgwch[10000];
		DWORD cch=0, cchWritten;

		va_list ArgList;
		va_start(ArgList, wszFormat);

	    if (!g_hConsole) {g_hConsole = GetStdHandle(STD_OUTPUT_HANDLE);}

        if (g_hConsole)
        {
            EnterCriticalSection(&g_LogCrit);

            cch = (1+wvsprintf(rgwch, wszFormat,  ArgList));

            ASSERT(cch*sizeof(WCHAR)<sizeof(rgwch)); // TODO make more robust
                                   // wvsnprintf.

		    WriteConsole(g_hConsole, rgwch, cch, &cchWritten, NULL);

            LeaveCriticalSection(&g_LogCrit);

        }

		va_end(ArgList);


		// Don't close the handle -- it will kill the console!
		//
		// if (g_hConsole!=INVALID_HANDLE_VALUE) CloseHandle(g_hConsole);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\tsp\flhash.cpp ===
#include "flhash.h"


extern const char *const FL_Stringtable[];


//================================================
//		 Processing appcfg.cpp
//================================================

// ========================== LUID 0x7cb8c92f ===================
//
//			FL_DECLARE_FILE [0x7cb8c92f] ["Implements Generic Dialog functionality"]
//

extern "C" const char szFL_FILE0x7cb8c92f[];
extern "C" const char szFL_DATE0x7cb8c92f[];
extern "C" const char szFL_TIME0x7cb8c92f[];
extern "C" const char szFL_TIMESTAMP0x7cb8c92f[];

FL_FILEINFO FileInfo0x7cb8c92f = 
{
	{
		MAKELONG(sizeof(FL_FILEINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_FILEINFO,
		0
	},
	0x7cb8c92f,
	FL_Stringtable+0,
	szFL_FILE0x7cb8c92f,
	szFL_DATE0x7cb8c92f,
	szFL_TIME0x7cb8c92f,
	szFL_TIMESTAMP0x7cb8c92f
};

// ========================== LUID 0xa6d3803f ===================
//
//			FL_DECLARE_FUNC [0xa6d3803f] ["TUISPI_phoneConfigDialog"]
//


FL_FUNCINFO FuncInfo0xa6d3803f = 
{
	{
		MAKELONG(sizeof(FL_FUNCINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_FUNCINFO,
		0
	},
	0xa6d3803f,
	FL_Stringtable+1,
	&FileInfo0x7cb8c92f
};



//================================================
//		 Processing appdlg.cpp
//================================================



//================================================
//		 Processing appman.cpp
//================================================



//================================================
//		 Processing apptdrop.cpp
//================================================



//================================================
//		 Processing appterm.cpp
//================================================



//================================================
//		 Processing cdev.cpp
//================================================

// ========================== LUID 0x986d98ed ===================
//
//			FL_DECLARE_FILE [0x986d98ed] ["Implements class CTspDev"]
//

extern "C" const char szFL_FILE0x986d98ed[];
extern "C" const char szFL_DATE0x986d98ed[];
extern "C" const char szFL_TIME0x986d98ed[];
extern "C" const char szFL_TIMESTAMP0x986d98ed[];

FL_FILEINFO FileInfo0x986d98ed = 
{
	{
		MAKELONG(sizeof(FL_FILEINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_FILEINFO,
		0
	},
	0x986d98ed,
	FL_Stringtable+2,
	szFL_FILE0x986d98ed,
	szFL_DATE0x986d98ed,
	szFL_TIME0x986d98ed,
	szFL_TIMESTAMP0x986d98ed
};

// ========================== LUID 0x86571252 ===================
//
//			FL_DECLARE_FUNC [0x86571252] ["CTspDev::AcceptTspCall"]
//


FL_FUNCINFO FuncInfo0x86571252 = 
{
	{
		MAKELONG(sizeof(FL_FUNCINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_FUNCINFO,
		0
	},
	0x86571252,
	FL_Stringtable+3,
	&FileInfo0x986d98ed
};

// ========================== LUID 0x94949c00 ===================
//
//			FL_SET_RFR [0x94949c00] ["Incorrect TSPI version"]
//


FL_RFRINFO RFRInfo0x94949c00 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0x94949c00,
	FL_Stringtable+4,
	&FuncInfo0x86571252
};

// ========================== LUID 0xb949f900 ===================
//
//			FL_SET_RFR [0xb949f900] ["Incorrect TSPI version"]
//


FL_RFRINFO RFRInfo0xb949f900 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0xb949f900,
	FL_Stringtable+5,
	&FuncInfo0x86571252
};

// ========================== LUID 0xb1776700 ===================
//
//			FL_SET_RFR [0xb1776700] ["Invalid address ID"]
//


FL_RFRINFO RFRInfo0xb1776700 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0xb1776700,
	FL_Stringtable+6,
	&FuncInfo0x86571252
};

// ========================== LUID 0x9db11a00 ===================
//
//			FL_SET_RFR [0x9db11a00] ["Incorrect TSPI version"]
//


FL_RFRINFO RFRInfo0x9db11a00 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0x9db11a00,
	FL_Stringtable+7,
	&FuncInfo0x86571252
};

// ========================== LUID 0x57d39b00 ===================
//
//			FL_SET_RFR [0x57d39b00] ["Unknown destination"]
//


FL_RFRINFO RFRInfo0x57d39b00 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0x57d39b00,
	FL_Stringtable+8,
	&FuncInfo0x86571252
};

// ========================== LUID 0xd328ab03 ===================
//
//			FL_DECLARE_FUNC [0xd328ab03] ["CTspDev::Load"]
//


FL_FUNCINFO FuncInfo0xd328ab03 = 
{
	{
		MAKELONG(sizeof(FL_FUNCINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_FUNCINFO,
		0
	},
	0xd328ab03,
	FL_Stringtable+9,
	&FileInfo0x986d98ed
};

// ========================== LUID 0xefaf5900 ===================
//
//			FL_SET_RFR [0xefaf5900] ["NULL pMD passed in"]
//


FL_RFRINFO RFRInfo0xefaf5900 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0xefaf5900,
	FL_Stringtable+10,
	&FuncInfo0xd328ab03
};

// ========================== LUID 0x5371c600 ===================
//
//			FL_SET_RFR [0x5371c600] ["Couldn't begin session with MD"]
//


FL_RFRINFO RFRInfo0x5371c600 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0x5371c600,
	FL_Stringtable+11,
	&FuncInfo0xd328ab03
};

// ========================== LUID 0x528e2a00 ===================
//
//			FL_SET_RFR [0x528e2a00] ["Driver Key too large"]
//


FL_RFRINFO RFRInfo0x528e2a00 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0x528e2a00,
	FL_Stringtable+12,
	&FuncInfo0xd328ab03
};

// ========================== LUID 0x5a5cd100 ===================
//
//			FL_SET_RFR [0x5a5cd100] ["RegQueryValueEx(FriendlyName) fails"]
//


FL_RFRINFO RFRInfo0x5a5cd100 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0x5a5cd100,
	FL_Stringtable+13,
	&FuncInfo0xd328ab03
};

// ========================== LUID 0xb7010000 ===================
//
//			FL_SET_RFR [0xb7010000] ["RegQueryValueEx(cszProperties) fails"]
//


FL_RFRINFO RFRInfo0xb7010000 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0xb7010000,
	FL_Stringtable+14,
	&FuncInfo0xd328ab03
};

// ========================== LUID 0x00164300 ===================
//
//			FL_SET_RFR [0x00164300] ["RegQueryValueEx(cszDeviceType) fails"]
//


FL_RFRINFO RFRInfo0x00164300 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0x00164300,
	FL_Stringtable+15,
	&FuncInfo0xd328ab03
};

// ========================== LUID 0x0cea5400 ===================
//
//			FL_SET_RFR [0x0cea5400] ["Invalid bDeviceType"]
//


FL_RFRINFO RFRInfo0x0cea5400 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0x0cea5400,
	FL_Stringtable+16,
	&FuncInfo0xd328ab03
};

// ========================== LUID 0x55693500 ===================
//
//			FL_SET_RFR [0x55693500] ["UmRtlGetDefaultCommConfig fails"]
//


FL_RFRINFO RFRInfo0x55693500 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0x55693500,
	FL_Stringtable+17,
	&FuncInfo0xd328ab03
};

// ========================== LUID 0xeaf0b34f ===================
//
//			FL_DECLARE_FUNC [0xeaf0b34f] ["ExtensionCallback"]
//


FL_FUNCINFO FuncInfo0xeaf0b34f = 
{
	{
		MAKELONG(sizeof(FL_FUNCINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_FUNCINFO,
		0
	},
	0xeaf0b34f,
	FL_Stringtable+18,
	&FileInfo0x986d98ed
};

// ========================== LUID 0xccba5b51 ===================
//
//			FL_DECLARE_FUNC [0xccba5b51] ["CTspDev::RegisterProviderInfo"]
//


FL_FUNCINFO FuncInfo0xccba5b51 = 
{
	{
		MAKELONG(sizeof(FL_FUNCINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_FUNCINFO,
		0
	},
	0xccba5b51,
	FL_Stringtable+19,
	&FileInfo0x986d98ed
};

// ========================== LUID 0x33d90700 ===================
//
//			FL_SET_RFR [0x33d90700] ["ExtOpenExtensionBinding failed"]
//


FL_RFRINFO RFRInfo0x33d90700 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0x33d90700,
	FL_Stringtable+20,
	&FuncInfo0xccba5b51
};

// ========================== LUID 0xb8b24200 ===================
//
//			FL_SET_RFR [0xb8b24200] ["wrong state"]
//


FL_RFRINFO RFRInfo0xb8b24200 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0xb8b24200,
	FL_Stringtable+21,
	&FuncInfo0xccba5b51
};

// ========================== LUID 0x7e77dd17 ===================
//
//			FL_DECLARE_FUNC [0x7e77dd17] ["CTspDev::mfn_get_LINEDEVCAPS"]
//


FL_FUNCINFO FuncInfo0x7e77dd17 = 
{
	{
		MAKELONG(sizeof(FL_FUNCINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_FUNCINFO,
		0
	},
	0x7e77dd17,
	FL_Stringtable+22,
	&FileInfo0x986d98ed
};

// ========================== LUID 0x8456cb00 ===================
//
//			FL_SET_RFR [0x8456cb00] ["LINEDEVCAPS structure too small"]
//


FL_RFRINFO RFRInfo0x8456cb00 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0x8456cb00,
	FL_Stringtable+23,
	&FuncInfo0x7e77dd17
};

// ========================== LUID 0x9b9459e3 ===================
//
//			FL_DECLARE_FUNC [0x9b9459e3] ["CTspDev::mfn_get_PHONECAPS"]
//


FL_FUNCINFO FuncInfo0x9b9459e3 = 
{
	{
		MAKELONG(sizeof(FL_FUNCINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_FUNCINFO,
		0
	},
	0x9b9459e3,
	FL_Stringtable+24,
	&FileInfo0x986d98ed
};

// ========================== LUID 0xd191ae00 ===================
//
//			FL_SET_RFR [0xd191ae00] ["Device doesn't support phone capability"]
//


FL_RFRINFO RFRInfo0xd191ae00 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0xd191ae00,
	FL_Stringtable+25,
	&FuncInfo0x9b9459e3
};

// ========================== LUID 0x9e30ec00 ===================
//
//			FL_SET_RFR [0x9e30ec00] ["PHONECAPS structure too small"]
//


FL_RFRINFO RFRInfo0x9e30ec00 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0x9e30ec00,
	FL_Stringtable+26,
	&FuncInfo0x9b9459e3
};

// ========================== LUID 0xed6c4370 ===================
//
//			FL_DECLARE_FUNC [0xed6c4370] ["CTspDev::mfn_get_ADDRESSCAPS"]
//


FL_FUNCINFO FuncInfo0xed6c4370 = 
{
	{
		MAKELONG(sizeof(FL_FUNCINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_FUNCINFO,
		0
	},
	0xed6c4370,
	FL_Stringtable+27,
	&FileInfo0x986d98ed
};

// ========================== LUID 0x72f00800 ===================
//
//			FL_SET_RFR [0x72f00800] ["ADDRESSCAPS structure too small"]
//


FL_RFRINFO RFRInfo0x72f00800 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0x72f00800,
	FL_Stringtable+28,
	&FuncInfo0xed6c4370
};

// ========================== LUID 0xb9547d21 ===================
//
//			FL_DECLARE_FUNC [0xb9547d21] ["CTspDev::mfn_GetVoiceProperties"]
//


FL_FUNCINFO FuncInfo0xb9547d21 = 
{
	{
		MAKELONG(sizeof(FL_FUNCINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_FUNCINFO,
		0
	},
	0xb9547d21,
	FL_Stringtable+29,
	&FileInfo0x986d98ed
};

// ========================== LUID 0x1b053100 ===================
//
//			FL_SET_RFR [0x1b053100] ["Modem voice capabilities not supported on NT"]
//


FL_RFRINFO RFRInfo0x1b053100 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0x1b053100,
	FL_Stringtable+30,
	&FuncInfo0xb9547d21
};

// ========================== LUID 0x9cb1a400 ===================
//
//			FL_SET_RFR [0x9cb1a400] ["Modem does not have voice capabilities"]
//


FL_RFRINFO RFRInfo0x9cb1a400 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0x9cb1a400,
	FL_Stringtable+31,
	&FuncInfo0xb9547d21
};

// ========================== LUID 0x254efe00 ===================
//
//			FL_SET_RFR [0x254efe00] ["Couldn't get WaveInstance"]
//


FL_RFRINFO RFRInfo0x254efe00 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0x254efe00,
	FL_Stringtable+32,
	&FuncInfo0xb9547d21
};

// ========================== LUID 0x896ec204 ===================
//
//			FL_DECLARE_FUNC [0x896ec204] ["mfn_GetDataModemDevCfg"]
//


FL_FUNCINFO FuncInfo0x896ec204 = 
{
	{
		MAKELONG(sizeof(FL_FUNCINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_FUNCINFO,
		0
	},
	0x896ec204,
	FL_Stringtable+33,
	&FileInfo0x986d98ed
};

// ========================== LUID 0x864b149d ===================
//
//			FL_DECLARE_FUNC [0x864b149d] ["SetDataModemConfig"]
//


FL_FUNCINFO FuncInfo0x864b149d = 
{
	{
		MAKELONG(sizeof(FL_FUNCINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_FUNCINFO,
		0
	},
	0x864b149d,
	FL_Stringtable+34,
	&FileInfo0x986d98ed
};

// ========================== LUID 0x672aa19c ===================
//
//			FL_DECLARE_FUNC [0x672aa19c] ["mfn_LineEventProc"]
//


FL_FUNCINFO FuncInfo0x672aa19c = 
{
	{
		MAKELONG(sizeof(FL_FUNCINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_FUNCINFO,
		0
	},
	0x672aa19c,
	FL_Stringtable+35,
	&FileInfo0x986d98ed
};

// ========================== LUID 0xc25a41c7 ===================
//
//			FL_DECLARE_FUNC [0xc25a41c7] ["mfn_PhoneEventProc"]
//


FL_FUNCINFO FuncInfo0xc25a41c7 = 
{
	{
		MAKELONG(sizeof(FL_FUNCINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_FUNCINFO,
		0
	},
	0xc25a41c7,
	FL_Stringtable+36,
	&FileInfo0x986d98ed
};

// ========================== LUID 0x9dd08553 ===================
//
//			FL_DECLARE_FUNC [0x9dd08553] ["CTspDev::mfn_TSPICompletionProc"]
//


FL_FUNCINFO FuncInfo0x9dd08553 = 
{
	{
		MAKELONG(sizeof(FL_FUNCINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_FUNCINFO,
		0
	},
	0x9dd08553,
	FL_Stringtable+37,
	&FileInfo0x986d98ed
};

// ========================== LUID 0x1b3f6d00 ===================
//
//			FL_SET_RFR [0x1b3f6d00] ["Calling ExtTspiAsyncCompletion"]
//


FL_RFRINFO RFRInfo0x1b3f6d00 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0x1b3f6d00,
	FL_Stringtable+38,
	&FuncInfo0x9dd08553
};

// ========================== LUID 0xd89afb00 ===================
//
//			FL_SET_RFR [0xd89afb00] ["Calling pfnTapiCompletionProc"]
//


FL_RFRINFO RFRInfo0xd89afb00 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0xd89afb00,
	FL_Stringtable+39,
	&FuncInfo0x9dd08553
};

// ========================== LUID 0x4b8c1643 ===================
//
//			FL_DECLARE_FUNC [0x4b8c1643] ["CTspDev::NotifyDefaultConfigChanged"]
//


FL_FUNCINFO FuncInfo0x4b8c1643 = 
{
	{
		MAKELONG(sizeof(FL_FUNCINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_FUNCINFO,
		0
	},
	0x4b8c1643,
	FL_Stringtable+40,
	&FileInfo0x986d98ed
};

// ========================== LUID 0x6e834e00 ===================
//
//			FL_SET_RFR [0x6e834e00] ["Couldn't open driverkey!"]
//


FL_RFRINFO RFRInfo0x6e834e00 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0x6e834e00,
	FL_Stringtable+41,
	&FuncInfo0x4b8c1643
};

// ========================== LUID 0x5cce0a00 ===================
//
//			FL_SET_RFR [0x5cce0a00] ["UmRtlGetDefaultCommConfig fails"]
//


FL_RFRINFO RFRInfo0x5cce0a00 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0x5cce0a00,
	FL_Stringtable+42,
	&FuncInfo0x4b8c1643
};

// ========================== LUID 0x6b8ddbbb ===================
//
//			FL_DECLARE_FUNC [0x6b8ddbbb] ["ProcessResponse"]
//


FL_FUNCINFO FuncInfo0x6b8ddbbb = 
{
	{
		MAKELONG(sizeof(FL_FUNCINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_FUNCINFO,
		0
	},
	0x6b8ddbbb,
	FL_Stringtable+43,
	&FileInfo0x986d98ed
};

// ========================== LUID 0x5360574c ===================
//
//			FL_DECLARE_FUNC [0x5360574c] ["ConstructNewPreDialCommands"]
//


FL_FUNCINFO FuncInfo0x5360574c = 
{
	{
		MAKELONG(sizeof(FL_FUNCINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_FUNCINFO,
		0
	},
	0x5360574c,
	FL_Stringtable+44,
	&FileInfo0x986d98ed
};

// ========================== LUID 0x3a274e00 ===================
//
//			FL_SET_RFR [0x3a274e00] ["Analog bearermode -- no pre-dial commmands."]
//


FL_RFRINFO RFRInfo0x3a274e00 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0x3a274e00,
	FL_Stringtable+45,
	&FuncInfo0x5360574c
};

// ========================== LUID 0xff803300 ===================
//
//			FL_SET_RFR [0xff803300] ["Invalid Bearermode in modem options!"]
//


FL_RFRINFO RFRInfo0xff803300 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0xff803300,
	FL_Stringtable+46,
	&FuncInfo0x5360574c
};

// ========================== LUID 0x6e42a700 ===================
//
//			FL_SET_RFR [0x6e42a700] ["Invalid Protocol info in modem options!"]
//


FL_RFRINFO RFRInfo0x6e42a700 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0x6e42a700,
	FL_Stringtable+47,
	&FuncInfo0x5360574c
};

// ========================== LUID 0xddf38d00 ===================
//
//			FL_SET_RFR [0xddf38d00] ["Internal error: tmp buffer too small."]
//


FL_RFRINFO RFRInfo0xddf38d00 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0xddf38d00,
	FL_Stringtable+48,
	&FuncInfo0x5360574c
};

// ========================== LUID 0x07a87200 ===================
//
//			FL_SET_RFR [0x07a87200] ["ReadCommandsA failed."]
//


FL_RFRINFO RFRInfo0x07a87200 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0x07a87200,
	FL_Stringtable+49,
	&FuncInfo0x5360574c
};

// ========================== LUID 0x9a8df7e6 ===================
//
//			FL_DECLARE_FUNC [0x9a8df7e6] ["CTspDev::DumpState"]
//


FL_FUNCINFO FuncInfo0x9a8df7e6 = 
{
	{
		MAKELONG(sizeof(FL_FUNCINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_FUNCINFO,
		0
	},
	0x9a8df7e6,
	FL_Stringtable+50,
	&FileInfo0x986d98ed
};

// ========================== LUID 0x296438cf ===================
//
//			FL_DECLARE_FUNC [0x296438cf] ["GLOBAL STATE:"]
//


FL_FUNCINFO FuncInfo0x296438cf = 
{
	{
		MAKELONG(sizeof(FL_FUNCINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_FUNCINFO,
		0
	},
	0x296438cf,
	FL_Stringtable+51,
	&FileInfo0x986d98ed
};

// ========================== LUID 0xa038177f ===================
//
//			FL_DECLARE_FUNC [0xa038177f] ["LINE STATE:"]
//


FL_FUNCINFO FuncInfo0xa038177f = 
{
	{
		MAKELONG(sizeof(FL_FUNCINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_FUNCINFO,
		0
	},
	0xa038177f,
	FL_Stringtable+52,
	&FileInfo0x986d98ed
};

// ========================== LUID 0x22f22a59 ===================
//
//			FL_DECLARE_FUNC [0x22f22a59] ["PHONE STATE:"]
//


FL_FUNCINFO FuncInfo0x22f22a59 = 
{
	{
		MAKELONG(sizeof(FL_FUNCINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_FUNCINFO,
		0
	},
	0x22f22a59,
	FL_Stringtable+53,
	&FileInfo0x986d98ed
};

// ========================== LUID 0x68c9e1e1 ===================
//
//			FL_DECLARE_FUNC [0x68c9e1e1] ["LLDEV STATE:"]
//


FL_FUNCINFO FuncInfo0x68c9e1e1 = 
{
	{
		MAKELONG(sizeof(FL_FUNCINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_FUNCINFO,
		0
	},
	0x68c9e1e1,
	FL_Stringtable+54,
	&FileInfo0x986d98ed
};

// ========================== LUID 0xcf159c50 ===================
//
//			FL_DECLARE_FUNC [0xcf159c50] ["xxxx"]
//


FL_FUNCINFO FuncInfo0xcf159c50 = 
{
	{
		MAKELONG(sizeof(FL_FUNCINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_FUNCINFO,
		0
	},
	0xcf159c50,
	FL_Stringtable+55,
	&FileInfo0x986d98ed
};

// ========================== LUID 0x25423f00 ===================
//
//			FL_SET_RFR [0x25423f00] ["Invalid DevCfg specified"]
//


FL_RFRINFO RFRInfo0x25423f00 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0x25423f00,
	FL_Stringtable+56,
	&FuncInfo0xcf159c50
};

// ========================== LUID 0x947cc100 ===================
//
//			FL_SET_RFR [0x947cc100] ["Invalid COMMCONFIG specified"]
//


FL_RFRINFO RFRInfo0x947cc100 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0x947cc100,
	FL_Stringtable+57,
	&FuncInfo0xcf159c50
};

// ========================== LUID 0x94fadd00 ===================
//
//			FL_SET_RFR [0x94fadd00] ["Success; set fConfigUpdatedByApp."]
//


FL_RFRINFO RFRInfo0x94fadd00 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0x94fadd00,
	FL_Stringtable+58,
	&FuncInfo0xcf159c50
};



//================================================
//		 Processing cdevcall.cpp
//================================================

// ========================== LUID 0xe135f7c4 ===================
//
//			FL_DECLARE_FILE [0xe135f7c4] ["Call-related functionality of class CTspDev"]
//

extern "C" const char szFL_FILE0xe135f7c4[];
extern "C" const char szFL_DATE0xe135f7c4[];
extern "C" const char szFL_TIME0xe135f7c4[];
extern "C" const char szFL_TIMESTAMP0xe135f7c4[];

FL_FILEINFO FileInfo0xe135f7c4 = 
{
	{
		MAKELONG(sizeof(FL_FILEINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_FILEINFO,
		0
	},
	0xe135f7c4,
	FL_Stringtable+59,
	szFL_FILE0xe135f7c4,
	szFL_DATE0xe135f7c4,
	szFL_TIME0xe135f7c4,
	szFL_TIMESTAMP0xe135f7c4
};

// ========================== LUID 0x5691bd34 ===================
//
//			FL_DECLARE_FUNC [0x5691bd34] ["CTspDev::mfn_accept_tsp_call_for_HDRVCALL"]
//


FL_FUNCINFO FuncInfo0x5691bd34 = 
{
	{
		MAKELONG(sizeof(FL_FUNCINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_FUNCINFO,
		0
	},
	0x5691bd34,
	FL_Stringtable+60,
	&FileInfo0xe135f7c4
};

// ========================== LUID 0x4e74c600 ===================
//
//			FL_SET_RFR [0x4e74c600] ["No call exists"]
//


FL_RFRINFO RFRInfo0x4e74c600 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0x4e74c600,
	FL_Stringtable+61,
	&FuncInfo0x5691bd34
};

// ========================== LUID 0x9680a600 ===================
//
//			FL_SET_RFR [0x9680a600] ["lineDial handled successfully"]
//


FL_RFRINFO RFRInfo0x9680a600 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0x9680a600,
	FL_Stringtable+62,
	&FuncInfo0x5691bd34
};

// ========================== LUID 0x4f356100 ===================
//
//			FL_SET_RFR [0x4f356100] ["lineGetCallAddressID handled successfully"]
//


FL_RFRINFO RFRInfo0x4f356100 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0x4f356100,
	FL_Stringtable+63,
	&FuncInfo0x5691bd34
};

// ========================== LUID 0x08c6de00 ===================
//
//			FL_SET_RFR [0x08c6de00] ["lineCloseCall handled"]
//


FL_RFRINFO RFRInfo0x08c6de00 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0x08c6de00,
	FL_Stringtable+64,
	&FuncInfo0x5691bd34
};

// ========================== LUID 0x1cd1ed00 ===================
//
//			FL_SET_RFR [0x1cd1ed00] ["lineGetCallStatus handled successfully"]
//


FL_RFRINFO RFRInfo0x1cd1ed00 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0x1cd1ed00,
	FL_Stringtable+65,
	&FuncInfo0x5691bd34
};

// ========================== LUID 0x80bb0100 ===================
//
//			FL_SET_RFR [0x80bb0100] ["lineGetCallInfo handled successfully"]
//


FL_RFRINFO RFRInfo0x80bb0100 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0x80bb0100,
	FL_Stringtable+66,
	&FuncInfo0x5691bd34
};

// ========================== LUID 0x0b882700 ===================
//
//			FL_SET_RFR [0x0b882700] ["lineAccept handled successfully"]
//


FL_RFRINFO RFRInfo0x0b882700 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0x0b882700,
	FL_Stringtable+67,
	&FuncInfo0x5691bd34
};

// ========================== LUID 0xf7baee00 ===================
//
//			FL_SET_RFR [0xf7baee00] ["lineAnswer handled successfully"]
//


FL_RFRINFO RFRInfo0xf7baee00 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0xf7baee00,
	FL_Stringtable+68,
	&FuncInfo0x5691bd34
};

// ========================== LUID 0xc22a1600 ===================
//
//			FL_SET_RFR [0xc22a1600] ["Task pending on lineAnswer, can't handle."]
//


FL_RFRINFO RFRInfo0xc22a1600 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0xc22a1600,
	FL_Stringtable+69,
	&FuncInfo0x5691bd34
};

// ========================== LUID 0x7217c400 ===================
//
//			FL_SET_RFR [0x7217c400] ["lineMonitorDigits handled successfully"]
//


FL_RFRINFO RFRInfo0x7217c400 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0x7217c400,
	FL_Stringtable+70,
	&FuncInfo0x5691bd34
};

// ========================== LUID 0x0479b600 ===================
//
//			FL_SET_RFR [0x0479b600] ["INVALID DIGITMODES"]
//


FL_RFRINFO RFRInfo0x0479b600 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0x0479b600,
	FL_Stringtable+71,
	&FuncInfo0x5691bd34
};

// ========================== LUID 0x58df2b00 ===================
//
//			FL_SET_RFR [0x58df2b00] ["Disabling Monitoring"]
//


FL_RFRINFO RFRInfo0x58df2b00 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0x58df2b00,
	FL_Stringtable+72,
	&FuncInfo0x5691bd34
};

// ========================== LUID 0x43601800 ===================
//
//			FL_SET_RFR [0x43601800] ["Enabling Monitoring"]
//


FL_RFRINFO RFRInfo0x43601800 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0x43601800,
	FL_Stringtable+73,
	&FuncInfo0x5691bd34
};

// ========================== LUID 0xc0124700 ===================
//
//			FL_SET_RFR [0xc0124700] ["This modem can't monior DTMF"]
//


FL_RFRINFO RFRInfo0xc0124700 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0xc0124700,
	FL_Stringtable+74,
	&FuncInfo0x5691bd34
};

// ========================== LUID 0xd57dcf00 ===================
//
//			FL_SET_RFR [0xd57dcf00] ["lineMonitorTones handled successfully"]
//


FL_RFRINFO RFRInfo0xd57dcf00 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0xd57dcf00,
	FL_Stringtable+75,
	&FuncInfo0x5691bd34
};

// ========================== LUID 0x70ecc800 ===================
//
//			FL_SET_RFR [0x70ecc800] ["This modem can't monitor silence"]
//


FL_RFRINFO RFRInfo0x70ecc800 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0x70ecc800,
	FL_Stringtable+76,
	&FuncInfo0x5691bd34
};

// ========================== LUID 0xdf123e00 ===================
//
//			FL_SET_RFR [0xdf123e00] ["ENABLING MONITOR SILENCE"]
//


FL_RFRINFO RFRInfo0xdf123e00 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0xdf123e00,
	FL_Stringtable+77,
	&FuncInfo0x5691bd34
};

// ========================== LUID 0x72b77d00 ===================
//
//			FL_SET_RFR [0x72b77d00] ["INVALID TONELIST"]
//


FL_RFRINFO RFRInfo0x72b77d00 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0x72b77d00,
	FL_Stringtable+78,
	&FuncInfo0x5691bd34
};

// ========================== LUID 0x5eb73400 ===================
//
//			FL_SET_RFR [0x5eb73400] ["DIABLING MONITOR SILENCE"]
//


FL_RFRINFO RFRInfo0x5eb73400 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0x5eb73400,
	FL_Stringtable+79,
	&FuncInfo0x5691bd34
};

// ========================== LUID 0x27417e00 ===================
//
//			FL_SET_RFR [0x27417e00] ["lineGenerateDigits handled successfully"]
//


FL_RFRINFO RFRInfo0x27417e00 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0x27417e00,
	FL_Stringtable+80,
	&FuncInfo0x5691bd34
};

// ========================== LUID 0x17348700 ===================
//
//			FL_SET_RFR [0x17348700] ["GenerateDigits: device doesn't support it!"]
//


FL_RFRINFO RFRInfo0x17348700 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0x17348700,
	FL_Stringtable+81,
	&FuncInfo0x5691bd34
};

// ========================== LUID 0x6770ef00 ===================
//
//			FL_SET_RFR [0x6770ef00] ["lineGenerateDigit: Unsupported/invalid digitmode"]
//


FL_RFRINFO RFRInfo0x6770ef00 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0x6770ef00,
	FL_Stringtable+82,
	&FuncInfo0x5691bd34
};

// ========================== LUID 0x83f84100 ===================
//
//			FL_SET_RFR [0x83f84100] ["lineGenerateDigit: Ignoring request for aborting/disconnected call..."]
//


FL_RFRINFO RFRInfo0x83f84100 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0x83f84100,
	FL_Stringtable+83,
	&FuncInfo0x5691bd34
};

// ========================== LUID 0x511e2400 ===================
//
//			FL_SET_RFR [0x511e2400] ["lineGenerateDigit: Can't handle request while aborting/disconnected call..."]
//


FL_RFRINFO RFRInfo0x511e2400 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0x511e2400,
	FL_Stringtable+84,
	&FuncInfo0x5691bd34
};

// ========================== LUID 0x4c39cf00 ===================
//
//			FL_SET_RFR [0x4c39cf00] ["GenerateDigits: only works with AUTOMATEDVOICE!"]
//


FL_RFRINFO RFRInfo0x4c39cf00 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0x4c39cf00,
	FL_Stringtable+85,
	&FuncInfo0x5691bd34
};

// ========================== LUID 0x8ee76c00 ===================
//
//			FL_SET_RFR [0x8ee76c00] ["Couldn't convert tones to ANSI!"]
//


FL_RFRINFO RFRInfo0x8ee76c00 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0x8ee76c00,
	FL_Stringtable+86,
	&FuncInfo0x5691bd34
};

// ========================== LUID 0xf7736900 ===================
//
//			FL_SET_RFR [0xf7736900] ["Couldn't alloc space for tones!"]
//


FL_RFRINFO RFRInfo0xf7736900 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0xf7736900,
	FL_Stringtable+87,
	&FuncInfo0x5691bd34
};

// ========================== LUID 0x2d0a4600 ===================
//
//			FL_SET_RFR [0x2d0a4600] ["lineSetCallParams handled successfully"]
//


FL_RFRINFO RFRInfo0x2d0a4600 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0x2d0a4600,
	FL_Stringtable+88,
	&FuncInfo0x5691bd34
};

// ========================== LUID 0xf4a36800 ===================
//
//			FL_SET_RFR [0xf4a36800] ["Callstate aborting or not active"]
//


FL_RFRINFO RFRInfo0xf4a36800 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0xf4a36800,
	FL_Stringtable+89,
	&FuncInfo0x5691bd34
};

// ========================== LUID 0x7079be00 ===================
//
//			FL_SET_RFR [0x7079be00] ["Callstate not OFFERING/ACCEPTED/CONNECTED"]
//


FL_RFRINFO RFRInfo0x7079be00 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0x7079be00,
	FL_Stringtable+90,
	&FuncInfo0x5691bd34
};

// ========================== LUID 0x34301c00 ===================
//
//			FL_SET_RFR [0x34301c00] ["lineSetCallParams: Invalid bearermode"]
//


FL_RFRINFO RFRInfo0x34301c00 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0x34301c00,
	FL_Stringtable+91,
	&FuncInfo0x5691bd34
};

// ========================== LUID 0x345de200 ===================
//
//			FL_SET_RFR [0x345de200] ["Failed to get resources for passthrough"]
//


FL_RFRINFO RFRInfo0x345de200 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0x345de200,
	FL_Stringtable+92,
	&FuncInfo0x5691bd34
};

// ========================== LUID 0x82cda200 ===================
//
//			FL_SET_RFR [0x82cda200] ["UmSetPassthroughOn failed"]
//


FL_RFRINFO RFRInfo0x82cda200 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0x82cda200,
	FL_Stringtable+93,
	&FuncInfo0x5691bd34
};

// ========================== LUID 0x43ec3000 ===================
//
//			FL_SET_RFR [0x43ec3000] ["UmSetPassthroughOn succedded"]
//


FL_RFRINFO RFRInfo0x43ec3000 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0x43ec3000,
	FL_Stringtable+94,
	&FuncInfo0x5691bd34
};

// ========================== LUID 0x0ca8d700 ===================
//
//			FL_SET_RFR [0x0ca8d700] ["Wrong state for passthrough on"]
//


FL_RFRINFO RFRInfo0x0ca8d700 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0x0ca8d700,
	FL_Stringtable+95,
	&FuncInfo0x5691bd34
};

// ========================== LUID 0x82300f00 ===================
//
//			FL_SET_RFR [0x82300f00] ["UmSetPassthroughOff failed"]
//


FL_RFRINFO RFRInfo0x82300f00 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0x82300f00,
	FL_Stringtable+96,
	&FuncInfo0x5691bd34
};

// ========================== LUID 0x7c710f00 ===================
//
//			FL_SET_RFR [0x7c710f00] ["UmSetPassthroughOff succedded"]
//


FL_RFRINFO RFRInfo0x7c710f00 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0x7c710f00,
	FL_Stringtable+97,
	&FuncInfo0x5691bd34
};

// ========================== LUID 0xece6f100 ===================
//
//			FL_SET_RFR [0xece6f100] ["lineSetAppSpecific handled successfully"]
//


FL_RFRINFO RFRInfo0xece6f100 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0xece6f100,
	FL_Stringtable+98,
	&FuncInfo0x5691bd34
};

// ========================== LUID 0x9472a000 ===================
//
//			FL_SET_RFR [0x9472a000] ["lineSetMediaMode handled successfully"]
//


FL_RFRINFO RFRInfo0x9472a000 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0x9472a000,
	FL_Stringtable+99,
	&FuncInfo0x5691bd34
};

// ========================== LUID 0xfdf96a00 ===================
//
//			FL_SET_RFR [0xfdf96a00] ["lineMonitorMedia handled successfully"]
//


FL_RFRINFO RFRInfo0xfdf96a00 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0xfdf96a00,
	FL_Stringtable+100,
	&FuncInfo0x5691bd34
};

// ========================== LUID 0x87a0b000 ===================
//
//			FL_SET_RFR [0x87a0b000] ["*** UNHANDLED HDRVCALL CALL ****"]
//


FL_RFRINFO RFRInfo0x87a0b000 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0x87a0b000,
	FL_Stringtable+101,
	&FuncInfo0x5691bd34
};

// ========================== LUID 0xb7f98764 ===================
//
//			FL_DECLARE_FUNC [0xb7f98764] ["CTspDev::mfn_TH_CallMakeTalkDropCall"]
//


FL_FUNCINFO FuncInfo0xb7f98764 = 
{
	{
		MAKELONG(sizeof(FL_FUNCINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_FUNCINFO,
		0
	},
	0xb7f98764,
	FL_Stringtable+102,
	&FileInfo0xe135f7c4
};

// ========================== LUID 0xb72c4600 ===================
//
//			FL_SET_RFR [0xb72c4600] ["Unknown Msg"]
//


FL_RFRINFO RFRInfo0xb72c4600 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0xb72c4600,
	FL_Stringtable+103,
	&FuncInfo0xb7f98764
};

// ========================== LUID 0xb7e98764 ===================
//
//			FL_DECLARE_FUNC [0xb7e98764] ["CTspDev::mfn_TH_CallWaitForDropToGoAway"]
//


FL_FUNCINFO FuncInfo0xb7e98764 = 
{
	{
		MAKELONG(sizeof(FL_FUNCINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_FUNCINFO,
		0
	},
	0xb7e98764,
	FL_Stringtable+104,
	&FileInfo0xe135f7c4
};

// ========================== LUID 0xb73c4600 ===================
//
//			FL_SET_RFR [0xb73c4600] ["Unknown Msg"]
//


FL_RFRINFO RFRInfo0xb73c4600 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0xb73c4600,
	FL_Stringtable+105,
	&FuncInfo0xb7e98764
};

// ========================== LUID 0xded1f0a9 ===================
//
//			FL_DECLARE_FUNC [0xded1f0a9] ["CTspDev::mfn_TH_CallMakeCall2"]
//


FL_FUNCINFO FuncInfo0xded1f0a9 = 
{
	{
		MAKELONG(sizeof(FL_FUNCINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_FUNCINFO,
		0
	},
	0xded1f0a9,
	FL_Stringtable+106,
	&FileInfo0xe135f7c4
};

// ========================== LUID 0xbbe6ff00 ===================
//
//			FL_SET_RFR [0xbbe6ff00] ["Unknown Msg"]
//


FL_RFRINFO RFRInfo0xbbe6ff00 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0xbbe6ff00,
	FL_Stringtable+107,
	&FuncInfo0xded1f0a9
};

// ========================== LUID 0xded1d0a9 ===================
//
//			FL_DECLARE_FUNC [0xded1d0a9] ["CTspDev::mfn_TH_CallMakeCall"]
//


FL_FUNCINFO FuncInfo0xded1d0a9 = 
{
	{
		MAKELONG(sizeof(FL_FUNCINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_FUNCINFO,
		0
	},
	0xded1d0a9,
	FL_Stringtable+108,
	&FileInfo0xe135f7c4
};

// ========================== LUID 0xbbe5ff00 ===================
//
//			FL_SET_RFR [0xbbe5ff00] ["Unknown Msg"]
//


FL_RFRINFO RFRInfo0xbbe5ff00 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0xbbe5ff00,
	FL_Stringtable+109,
	&FuncInfo0xded1d0a9
};

// ========================== LUID 0xe30ecd42 ===================
//
//			FL_DECLARE_FUNC [0xe30ecd42] ["CTspDev::mfn_TH_CallMakePassthroughCall"]
//


FL_FUNCINFO FuncInfo0xe30ecd42 = 
{
	{
		MAKELONG(sizeof(FL_FUNCINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_FUNCINFO,
		0
	},
	0xe30ecd42,
	FL_Stringtable+110,
	&FileInfo0xe135f7c4
};

// ========================== LUID 0xa596d200 ===================
//
//			FL_SET_RFR [0xa596d200] ["Unknown Msg"]
//


FL_RFRINFO RFRInfo0xa596d200 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0xa596d200,
	FL_Stringtable+111,
	&FuncInfo0xe30ecd42
};

// ========================== LUID 0x45a9fa21 ===================
//
//			FL_DECLARE_FUNC [0x45a9fa21] ["CTspDev::mfn_TH_CallDropCall"]
//


FL_FUNCINFO FuncInfo0x45a9fa21 = 
{
	{
		MAKELONG(sizeof(FL_FUNCINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_FUNCINFO,
		0
	},
	0x45a9fa21,
	FL_Stringtable+112,
	&FileInfo0xe135f7c4
};

// ========================== LUID 0x27fc4e00 ===================
//
//			FL_SET_RFR [0x27fc4e00] ["invalid subtask"]
//


FL_RFRINFO RFRInfo0x27fc4e00 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0x27fc4e00,
	FL_Stringtable+113,
	&FuncInfo0x45a9fa21
};

// ========================== LUID 0xa706a600 ===================
//
//			FL_SET_RFR [0xa706a600] ["Unknown Msg"]
//


FL_RFRINFO RFRInfo0xa706a600 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0xa706a600,
	FL_Stringtable+114,
	&FuncInfo0x45a9fa21
};

// ========================== LUID 0xdaf3d4a0 ===================
//
//			FL_DECLARE_FUNC [0xdaf3d4a0] ["CTspDev::mfn_LoadCall"]
//


FL_FUNCINFO FuncInfo0xdaf3d4a0 = 
{
	{
		MAKELONG(sizeof(FL_FUNCINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_FUNCINFO,
		0
	},
	0xdaf3d4a0,
	FL_Stringtable+115,
	&FileInfo0xe135f7c4
};

// ========================== LUID 0x4e05cb00 ===================
//
//			FL_SET_RFR [0x4e05cb00] ["Call already exists!"]
//


FL_RFRINFO RFRInfo0x4e05cb00 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0x4e05cb00,
	FL_Stringtable+116,
	&FuncInfo0xdaf3d4a0
};

// ========================== LUID 0xd8f55f00 ===================
//
//			FL_SET_RFR [0xd8f55f00] ["Invalid MediaMode"]
//


FL_RFRINFO RFRInfo0xd8f55f00 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0xd8f55f00,
	FL_Stringtable+117,
	&FuncInfo0xdaf3d4a0
};

// ========================== LUID 0x0485b800 ===================
//
//			FL_SET_RFR [0x0485b800] ["Invalid BearerMode"]
//


FL_RFRINFO RFRInfo0x0485b800 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0x0485b800,
	FL_Stringtable+118,
	&FuncInfo0xdaf3d4a0
};

// ========================== LUID 0xf9599200 ===================
//
//			FL_SET_RFR [0xf9599200] ["Invalid Phone Number"]
//


FL_RFRINFO RFRInfo0xf9599200 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0xf9599200,
	FL_Stringtable+119,
	&FuncInfo0xdaf3d4a0
};

// ========================== LUID 0x888d2a98 ===================
//
//			FL_DECLARE_FUNC [0x888d2a98] ["mfn_UnloadCall"]
//


FL_FUNCINFO FuncInfo0x888d2a98 = 
{
	{
		MAKELONG(sizeof(FL_FUNCINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_FUNCINFO,
		0
	},
	0x888d2a98,
	FL_Stringtable+120,
	&FileInfo0xe135f7c4
};

// ========================== LUID 0x8aa894d6 ===================
//
//			FL_DECLARE_FUNC [0x8aa894d6] ["CTspDev::mfn_ProcessRing"]
//


FL_FUNCINFO FuncInfo0x8aa894d6 = 
{
	{
		MAKELONG(sizeof(FL_FUNCINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_FUNCINFO,
		0
	},
	0x8aa894d6,
	FL_Stringtable+121,
	&FileInfo0xe135f7c4
};

// ========================== LUID 0xa5b6ad00 ===================
//
//			FL_SET_RFR [0xa5b6ad00] ["Line not open/not monitoring!"]
//


FL_RFRINFO RFRInfo0xa5b6ad00 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0xa5b6ad00,
	FL_Stringtable+122,
	&FuncInfo0x8aa894d6
};

// ========================== LUID 0xb28c2f00 ===================
//
//			FL_SET_RFR [0xb28c2f00] ["Ignoring ring because task pending!"]
//


FL_RFRINFO RFRInfo0xb28c2f00 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0xb28c2f00,
	FL_Stringtable+123,
	&FuncInfo0x8aa894d6
};

// ========================== LUID 0xe55cd68b ===================
//
//			FL_DECLARE_FUNC [0xe55cd68b] ["CTspDev::mfn_ProcessDisconnect"]
//


FL_FUNCINFO FuncInfo0xe55cd68b = 
{
	{
		MAKELONG(sizeof(FL_FUNCINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_FUNCINFO,
		0
	},
	0xe55cd68b,
	FL_Stringtable+124,
	&FileInfo0xe135f7c4
};

// ========================== LUID 0xf2fa9900 ===================
//
//			FL_SET_RFR [0xf2fa9900] ["Line not open!"]
//


FL_RFRINFO RFRInfo0xf2fa9900 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0xf2fa9900,
	FL_Stringtable+125,
	&FuncInfo0xe55cd68b
};

// ========================== LUID 0xb2a25c00 ===================
//
//			FL_SET_RFR [0xb2a25c00] ["Call doesn't exist/dropping!"]
//


FL_RFRINFO RFRInfo0xb2a25c00 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0xb2a25c00,
	FL_Stringtable+126,
	&FuncInfo0xe55cd68b
};

// ========================== LUID 0xc2a949b4 ===================
//
//			FL_DECLARE_FUNC [0xc2a949b4] ["CTspDev::mfn_ProcessHardwareFailure"]
//


FL_FUNCINFO FuncInfo0xc2a949b4 = 
{
	{
		MAKELONG(sizeof(FL_FUNCINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_FUNCINFO,
		0
	},
	0xc2a949b4,
	FL_Stringtable+127,
	&FileInfo0xe135f7c4
};

// ========================== LUID 0xdd37f0bd ===================
//
//			FL_DECLARE_FUNC [0xdd37f0bd] ["CTspDev::mfn_TH_CallAnswerCall"]
//


FL_FUNCINFO FuncInfo0xdd37f0bd = 
{
	{
		MAKELONG(sizeof(FL_FUNCINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_FUNCINFO,
		0
	},
	0xdd37f0bd,
	FL_Stringtable+128,
	&FileInfo0xe135f7c4
};

// ========================== LUID 0xa9d4fb00 ===================
//
//			FL_SET_RFR [0xa9d4fb00] ["Unknown Msg"]
//


FL_RFRINFO RFRInfo0xa9d4fb00 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0xa9d4fb00,
	FL_Stringtable+129,
	&FuncInfo0xdd37f0bd
};

// ========================== LUID 0x3df24801 ===================
//
//			FL_DECLARE_FUNC [0x3df24801] ["HandleSuccessfulConnection"]
//


FL_FUNCINFO FuncInfo0x3df24801 = 
{
	{
		MAKELONG(sizeof(FL_FUNCINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_FUNCINFO,
		0
	},
	0x3df24801,
	FL_Stringtable+130,
	&FileInfo0xe135f7c4
};

// ========================== LUID 0x45352124 ===================
//
//			FL_DECLARE_FUNC [0x45352124] ["LaunchModemLights"]
//


FL_FUNCINFO FuncInfo0x45352124 = 
{
	{
		MAKELONG(sizeof(FL_FUNCINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_FUNCINFO,
		0
	},
	0x45352124,
	FL_Stringtable+131,
	&FileInfo0xe135f7c4
};

// ========================== LUID 0x885cdd5c ===================
//
//			FL_DECLARE_FUNC [0x885cdd5c] ["NotifyDisconnection"]
//


FL_FUNCINFO FuncInfo0x885cdd5c = 
{
	{
		MAKELONG(sizeof(FL_FUNCINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_FUNCINFO,
		0
	},
	0x885cdd5c,
	FL_Stringtable+132,
	&FileInfo0xe135f7c4
};

// ========================== LUID 0xc26c1348 ===================
//
//			FL_DECLARE_FUNC [0xc26c1348] ["CTspDev::mfn_ProcessDialTone"]
//


FL_FUNCINFO FuncInfo0xc26c1348 = 
{
	{
		MAKELONG(sizeof(FL_FUNCINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_FUNCINFO,
		0
	},
	0xc26c1348,
	FL_Stringtable+133,
	&FileInfo0xe135f7c4
};

// ========================== LUID 0xaddee800 ===================
//
//			FL_SET_RFR [0xaddee800] ["Line not open!"]
//


FL_RFRINFO RFRInfo0xaddee800 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0xaddee800,
	FL_Stringtable+134,
	&FuncInfo0xc26c1348
};

// ========================== LUID 0x210b2f00 ===================
//
//			FL_SET_RFR [0x210b2f00] ["Call doesn't exist!"]
//


FL_RFRINFO RFRInfo0x210b2f00 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0x210b2f00,
	FL_Stringtable+135,
	&FuncInfo0xc26c1348
};

// ========================== LUID 0x761795f2 ===================
//
//			FL_DECLARE_FUNC [0x761795f2] ["CTspDev::mfn_ProcessBusy"]
//


FL_FUNCINFO FuncInfo0x761795f2 = 
{
	{
		MAKELONG(sizeof(FL_FUNCINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_FUNCINFO,
		0
	},
	0x761795f2,
	FL_Stringtable+136,
	&FileInfo0xe135f7c4
};

// ========================== LUID 0xf67d1a00 ===================
//
//			FL_SET_RFR [0xf67d1a00] ["Line not open!"]
//


FL_RFRINFO RFRInfo0xf67d1a00 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0xf67d1a00,
	FL_Stringtable+137,
	&FuncInfo0x761795f2
};

// ========================== LUID 0xfff8f100 ===================
//
//			FL_SET_RFR [0xfff8f100] ["Call doesn't exist!"]
//


FL_RFRINFO RFRInfo0xfff8f100 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0xfff8f100,
	FL_Stringtable+138,
	&FuncInfo0x761795f2
};

// ========================== LUID 0xa4097846 ===================
//
//			FL_DECLARE_FUNC [0xa4097846] ["CTspDev::mfn_ProcessDTMFNotif"]
//


FL_FUNCINFO FuncInfo0xa4097846 = 
{
	{
		MAKELONG(sizeof(FL_FUNCINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_FUNCINFO,
		0
	},
	0xa4097846,
	FL_Stringtable+139,
	&FileInfo0xe135f7c4
};

// ========================== LUID 0x7cdb4c00 ===================
//
//			FL_SET_RFR [0x7cdb4c00] ["Line not open!"]
//


FL_RFRINFO RFRInfo0x7cdb4c00 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0x7cdb4c00,
	FL_Stringtable+140,
	&FuncInfo0xa4097846
};

// ========================== LUID 0x63657f00 ===================
//
//			FL_SET_RFR [0x63657f00] ["Call doesn't exist!"]
//


FL_RFRINFO RFRInfo0x63657f00 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0x63657f00,
	FL_Stringtable+141,
	&FuncInfo0xa4097846
};

// ========================== LUID 0x21b243f0 ===================
//
//			FL_DECLARE_FUNC [0x21b243f0] ["CTspDev::mfn_TH_CallGenerateDigit"]
//


FL_FUNCINFO FuncInfo0x21b243f0 = 
{
	{
		MAKELONG(sizeof(FL_FUNCINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_FUNCINFO,
		0
	},
	0x21b243f0,
	FL_Stringtable+142,
	&FileInfo0xe135f7c4
};

// ========================== LUID 0x172b7b00 ===================
//
//			FL_SET_RFR [0x172b7b00] ["Unknown Msg"]
//


FL_RFRINFO RFRInfo0x172b7b00 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0x172b7b00,
	FL_Stringtable+143,
	&FuncInfo0x21b243f0
};

// ========================== LUID 0xa914c600 ===================
//
//			FL_SET_RFR [0xa914c600] ["Can't call UmGenerateDigit in current state!"]
//


FL_RFRINFO RFRInfo0xa914c600 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0xa914c600,
	FL_Stringtable+144,
	&FuncInfo0x21b243f0
};

// ========================== LUID 0x79fa3c83 ===================
//
//			FL_DECLARE_FUNC [0x79fa3c83] ["CTspDev::mfn_TH_CallSwitchFromVoiceToData"]
//


FL_FUNCINFO FuncInfo0x79fa3c83 = 
{
	{
		MAKELONG(sizeof(FL_FUNCINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_FUNCINFO,
		0
	},
	0x79fa3c83,
	FL_Stringtable+145,
	&FileInfo0xe135f7c4
};

// ========================== LUID 0xd34b7688 ===================
//
//			FL_DECLARE_FUNC [0xd34b7688] ["CTspDev::MDSetTimeout"]
//


FL_FUNCINFO FuncInfo0xd34b7688 = 
{
	{
		MAKELONG(sizeof(FL_FUNCINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_FUNCINFO,
		0
	},
	0xd34b7688,
	FL_Stringtable+146,
	&FileInfo0xe135f7c4
};

// ========================== LUID 0x156032a9 ===================
//
//			FL_DECLARE_FUNC [0x156032a9] ["CTspDev::MDRingTimeout"]
//


FL_FUNCINFO FuncInfo0x156032a9 = 
{
	{
		MAKELONG(sizeof(FL_FUNCINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_FUNCINFO,
		0
	},
	0x156032a9,
	FL_Stringtable+147,
	&FileInfo0xe135f7c4
};

// ========================== LUID 0x0e357d3f ===================
//
//			FL_DECLARE_FUNC [0x0e357d3f] ["CTspDev::mfn_ProcessCallerID"]
//


FL_FUNCINFO FuncInfo0x0e357d3f = 
{
	{
		MAKELONG(sizeof(FL_FUNCINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_FUNCINFO,
		0
	},
	0x0e357d3f,
	FL_Stringtable+148,
	&FileInfo0xe135f7c4
};



//================================================
//		 Processing cdevdlg.cpp
//================================================

// ========================== LUID 0x4126abc0 ===================
//
//			FL_DECLARE_FILE [0x4126abc0] ["Implements UI-related features of CTspDev"]
//

extern "C" const char szFL_FILE0x4126abc0[];
extern "C" const char szFL_DATE0x4126abc0[];
extern "C" const char szFL_TIME0x4126abc0[];
extern "C" const char szFL_TIMESTAMP0x4126abc0[];

FL_FILEINFO FileInfo0x4126abc0 = 
{
	{
		MAKELONG(sizeof(FL_FILEINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_FILEINFO,
		0
	},
	0x4126abc0,
	FL_Stringtable+149,
	szFL_FILE0x4126abc0,
	szFL_DATE0x4126abc0,
	szFL_TIME0x4126abc0,
	szFL_TIMESTAMP0x4126abc0
};

// ========================== LUID 0x0b6af2d4 ===================
//
//			FL_DECLARE_FUNC [0x0b6af2d4] ["GenericLineDialogData"]
//


FL_FUNCINFO FuncInfo0x0b6af2d4 = 
{
	{
		MAKELONG(sizeof(FL_FUNCINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_FUNCINFO,
		0
	},
	0x0b6af2d4,
	FL_Stringtable+150,
	&FileInfo0x4126abc0
};

// ========================== LUID 0xa00d3f43 ===================
//
//			FL_DECLARE_FUNC [0xa00d3f43] ["CTspDev::mfn_CreateDialogInstance"]
//


FL_FUNCINFO FuncInfo0xa00d3f43 = 
{
	{
		MAKELONG(sizeof(FL_FUNCINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_FUNCINFO,
		0
	},
	0xa00d3f43,
	FL_Stringtable+151,
	&FileInfo0x4126abc0
};

// ========================== LUID 0xd582711d ===================
//
//			FL_DECLARE_FUNC [0xd582711d] ["CTspDev::mfn_TH_CallStartTerminal"]
//


FL_FUNCINFO FuncInfo0xd582711d = 
{
	{
		MAKELONG(sizeof(FL_FUNCINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_FUNCINFO,
		0
	},
	0xd582711d,
	FL_Stringtable+152,
	&FileInfo0x4126abc0
};

// ========================== LUID 0xc393d700 ===================
//
//			FL_SET_RFR [0xc393d700] ["Unknown Msg"]
//


FL_RFRINFO RFRInfo0xc393d700 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0xc393d700,
	FL_Stringtable+153,
	&FuncInfo0xd582711d
};

// ========================== LUID 0x62e06c00 ===================
//
//			FL_SET_RFR [0x62e06c00] ["PRECONNECT TERMINAL"]
//


FL_RFRINFO RFRInfo0x62e06c00 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0x62e06c00,
	FL_Stringtable+154,
	&FuncInfo0xd582711d
};

// ========================== LUID 0x2b676900 ===================
//
//			FL_SET_RFR [0x2b676900] ["POSTCONNECT TERMINAL"]
//


FL_RFRINFO RFRInfo0x2b676900 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0x2b676900,
	FL_Stringtable+155,
	&FuncInfo0xd582711d
};

// ========================== LUID 0x45fca600 ===================
//
//			FL_SET_RFR [0x45fca600] ["MANUAL DIAL"]
//


FL_RFRINFO RFRInfo0x45fca600 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0x45fca600,
	FL_Stringtable+156,
	&FuncInfo0xd582711d
};

// ========================== LUID 0x1b009123 ===================
//
//			FL_DECLARE_FUNC [0x1b009123] ["mfn_TH_CallPutUpTerminalWindow"]
//


FL_FUNCINFO FuncInfo0x1b009123 = 
{
	{
		MAKELONG(sizeof(FL_FUNCINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_FUNCINFO,
		0
	},
	0x1b009123,
	FL_Stringtable+157,
	&FileInfo0x4126abc0
};

// ========================== LUID 0x1fb58214 ===================
//
//			FL_DECLARE_FUNC [0x1fb58214] ["mfn_KillCurrentDialog"]
//


FL_FUNCINFO FuncInfo0x1fb58214 = 
{
	{
		MAKELONG(sizeof(FL_FUNCINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_FUNCINFO,
		0
	},
	0x1fb58214,
	FL_Stringtable+158,
	&FileInfo0x4126abc0
};

// ========================== LUID 0x1fb68214 ===================
//
//			FL_DECLARE_FUNC [0x1fb68214] ["mfn_KillTalkDropDialog"]
//


FL_FUNCINFO FuncInfo0x1fb68214 = 
{
	{
		MAKELONG(sizeof(FL_FUNCINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_FUNCINFO,
		0
	},
	0x1fb68214,
	FL_Stringtable+159,
	&FileInfo0x4126abc0
};



//================================================
//		 Processing cdevline.cpp
//================================================

// ========================== LUID 0x04a097ae ===================
//
//			FL_DECLARE_FILE [0x04a097ae] ["Line-related functionality of class CTspDev"]
//

extern "C" const char szFL_FILE0x04a097ae[];
extern "C" const char szFL_DATE0x04a097ae[];
extern "C" const char szFL_TIME0x04a097ae[];
extern "C" const char szFL_TIMESTAMP0x04a097ae[];

FL_FILEINFO FileInfo0x04a097ae = 
{
	{
		MAKELONG(sizeof(FL_FILEINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_FILEINFO,
		0
	},
	0x04a097ae,
	FL_Stringtable+160,
	szFL_FILE0x04a097ae,
	szFL_DATE0x04a097ae,
	szFL_TIME0x04a097ae,
	szFL_TIMESTAMP0x04a097ae
};

// ========================== LUID 0x3b2c98e4 ===================
//
//			FL_DECLARE_FUNC [0x3b2c98e4] ["CTspDev::mfn_monitor"]
//


FL_FUNCINFO FuncInfo0x3b2c98e4 = 
{
	{
		MAKELONG(sizeof(FL_FUNCINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_FUNCINFO,
		0
	},
	0x3b2c98e4,
	FL_Stringtable+161,
	&FileInfo0x04a097ae
};

// ========================== LUID 0x0037c000 ===================
//
//			FL_SET_RFR [0x0037c000] ["Invalid mediamode"]
//


FL_RFRINFO RFRInfo0x0037c000 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0x0037c000,
	FL_Stringtable+162,
	&FuncInfo0x3b2c98e4
};

// ========================== LUID 0xdeb9ec00 ===================
//
//			FL_SET_RFR [0xdeb9ec00] ["Can't answer INTERACTIVEVOICE calls"]
//


FL_RFRINFO RFRInfo0xdeb9ec00 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0xdeb9ec00,
	FL_Stringtable+163,
	&FuncInfo0x3b2c98e4
};

// ========================== LUID 0xa19f8100 ===================
//
//			FL_SET_RFR [0xa19f8100] ["no change in det media modes"]
//


FL_RFRINFO RFRInfo0xa19f8100 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0xa19f8100,
	FL_Stringtable+164,
	&FuncInfo0x3b2c98e4
};

// ========================== LUID 0x3c7fef00 ===================
//
//			FL_SET_RFR [0x3c7fef00] ["Closed LLDev from Line"]
//


FL_RFRINFO RFRInfo0x3c7fef00 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0x3c7fef00,
	FL_Stringtable+165,
	&FuncInfo0x3b2c98e4
};

// ========================== LUID 0xd23f4c00 ===================
//
//			FL_SET_RFR [0xd23f4c00] ["no change in det media modes"]
//


FL_RFRINFO RFRInfo0xd23f4c00 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0xd23f4c00,
	FL_Stringtable+166,
	&FuncInfo0x3b2c98e4
};

// ========================== LUID 0xe41274db ===================
//
//			FL_DECLARE_FUNC [0xe41274db] ["CTspDev::mfn_accept_tsp_call_for_HDRVLINE"]
//


FL_FUNCINFO FuncInfo0xe41274db = 
{
	{
		MAKELONG(sizeof(FL_FUNCINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_FUNCINFO,
		0
	},
	0xe41274db,
	FL_Stringtable+167,
	&FileInfo0x04a097ae
};

// ========================== LUID 0xce944f00 ===================
//
//			FL_SET_RFR [0xce944f00] ["Call already exists/queued"]
//


FL_RFRINFO RFRInfo0xce944f00 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0xce944f00,
	FL_Stringtable+168,
	&FuncInfo0xe41274db
};

// ========================== LUID 0x86b03000 ===================
//
//			FL_SET_RFR [0x86b03000] ["Invalid params"]
//


FL_RFRINFO RFRInfo0x86b03000 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0x86b03000,
	FL_Stringtable+169,
	&FuncInfo0xe41274db
};

// ========================== LUID 0x2a6a4400 ===================
//
//			FL_SET_RFR [0x2a6a4400] ["Unknown device class"]
//


FL_RFRINFO RFRInfo0x2a6a4400 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0x2a6a4400,
	FL_Stringtable+170,
	&FuncInfo0xe41274db
};

// ========================== LUID 0x82df8d00 ===================
//
//			FL_SET_RFR [0x82df8d00] ["Unsupported device class"]
//


FL_RFRINFO RFRInfo0x82df8d00 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0x82df8d00,
	FL_Stringtable+171,
	&FuncInfo0xe41274db
};

// ========================== LUID 0xe8271600 ===================
//
//			FL_SET_RFR [0xe8271600] ["lineSetStatusMessages handled"]
//


FL_RFRINFO RFRInfo0xe8271600 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0xe8271600,
	FL_Stringtable+172,
	&FuncInfo0xe41274db
};

// ========================== LUID 0xfc498200 ===================
//
//			FL_SET_RFR [0xfc498200] ["lineGetAddressStatus handled"]
//


FL_RFRINFO RFRInfo0xfc498200 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0xfc498200,
	FL_Stringtable+173,
	&FuncInfo0xe41274db
};

// ========================== LUID 0xaca5f600 ===================
//
//			FL_SET_RFR [0xaca5f600] ["lineConditionalMediaDetection handled"]
//


FL_RFRINFO RFRInfo0xaca5f600 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0xaca5f600,
	FL_Stringtable+174,
	&FuncInfo0xe41274db
};

// ========================== LUID 0xc5752400 ===================
//
//			FL_SET_RFR [0xc5752400] ["*** UNHANDLED HDRVLINE CALL ****"]
//


FL_RFRINFO RFRInfo0xc5752400 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0xc5752400,
	FL_Stringtable+175,
	&FuncInfo0xe41274db
};

// ========================== LUID 0xe4df9b1f ===================
//
//			FL_DECLARE_FUNC [0xe4df9b1f] ["CTspDev::mfn_LoadLine"]
//


FL_FUNCINFO FuncInfo0xe4df9b1f = 
{
	{
		MAKELONG(sizeof(FL_FUNCINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_FUNCINFO,
		0
	},
	0xe4df9b1f,
	FL_Stringtable+176,
	&FileInfo0x04a097ae
};

// ========================== LUID 0xa62f2e00 ===================
//
//			FL_SET_RFR [0xa62f2e00] ["Device already loaded (m_pLine!=NULL)!"]
//


FL_RFRINFO RFRInfo0xa62f2e00 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0xa62f2e00,
	FL_Stringtable+177,
	&FuncInfo0xe4df9b1f
};

// ========================== LUID 0x5bbf75ef ===================
//
//			FL_DECLARE_FUNC [0x5bbf75ef] ["UnloadLine"]
//


FL_FUNCINFO FuncInfo0x5bbf75ef = 
{
	{
		MAKELONG(sizeof(FL_FUNCINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_FUNCINFO,
		0
	},
	0x5bbf75ef,
	FL_Stringtable+178,
	&FileInfo0x04a097ae
};

// ========================== LUID 0xf0bdd5c1 ===================
//
//			FL_DECLARE_FUNC [0xf0bdd5c1] ["CTspDev::mfn_ProcessPowerResume"]
//


FL_FUNCINFO FuncInfo0xf0bdd5c1 = 
{
	{
		MAKELONG(sizeof(FL_FUNCINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_FUNCINFO,
		0
	},
	0xf0bdd5c1,
	FL_Stringtable+179,
	&FileInfo0x04a097ae
};

// ========================== LUID 0x3d02a200 ===================
//
//			FL_SET_RFR [0x3d02a200] ["Doing nothing because no clients to lldev."]
//


FL_RFRINFO RFRInfo0x3d02a200 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0x3d02a200,
	FL_Stringtable+180,
	&FuncInfo0xf0bdd5c1
};

// ========================== LUID 0x81e0d3f9 ===================
//
//			FL_DECLARE_FUNC [0x81e0d3f9] ["mfn_lineGetID_COMM_DATAMODEM"]
//


FL_FUNCINFO FuncInfo0x81e0d3f9 = 
{
	{
		MAKELONG(sizeof(FL_FUNCINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_FUNCINFO,
		0
	},
	0x81e0d3f9,
	FL_Stringtable+181,
	&FileInfo0x04a097ae
};

// ========================== LUID 0x816f0bba ===================
//
//			FL_DECLARE_FUNC [0x816f0bba] ["lineGetID_NDIS"]
//


FL_FUNCINFO FuncInfo0x816f0bba = 
{
	{
		MAKELONG(sizeof(FL_FUNCINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_FUNCINFO,
		0
	},
	0x816f0bba,
	FL_Stringtable+182,
	&FileInfo0x04a097ae
};

// ========================== LUID 0x18972e4d ===================
//
//			FL_DECLARE_FUNC [0x18972e4d] ["CTspDev::mfn_lineGetID_WAVE"]
//


FL_FUNCINFO FuncInfo0x18972e4d = 
{
	{
		MAKELONG(sizeof(FL_FUNCINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_FUNCINFO,
		0
	},
	0x18972e4d,
	FL_Stringtable+183,
	&FileInfo0x04a097ae
};

// ========================== LUID 0xac6c8a00 ===================
//
//			FL_SET_RFR [0xac6c8a00] ["Couldn't LoadLibrary(winmm.dll)"]
//


FL_RFRINFO RFRInfo0xac6c8a00 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0xac6c8a00,
	FL_Stringtable+184,
	&FuncInfo0x18972e4d
};

// ========================== LUID 0x282bc900 ===================
//
//			FL_SET_RFR [0x282bc900] ["Couldn't loadlib mmsystem apis"]
//


FL_RFRINFO RFRInfo0x282bc900 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0x282bc900,
	FL_Stringtable+185,
	&FuncInfo0x18972e4d
};

// ========================== LUID 0xf391f200 ===================
//
//			FL_SET_RFR [0xf391f200] ["Could not find wave device"]
//


FL_RFRINFO RFRInfo0xf391f200 = 
{
	{
		MAKELONG(sizeof(FL_RFRINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_RFRINFO,
		0
	},
	0xf391f200,
	FL_Stringtable+186,
	&FuncInfo0x18972e4d
};

// ========================== LUID 0xf3d8ee16 ===================
//
//			FL_DECLARE_FUNC [0xf3d8ee16] ["CTspDev::mfn_fill_RAW_LINE_DIAGNOSTICS"]
//


FL_FUNCINFO FuncInfo0xf3d8ee16 = 
{
	{
		MAKELONG(sizeof(FL_FUNCINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_FUNCINFO,
		0
	},
	0xf3d8ee16,
	FL_Stringtable+187,
	&FileInfo0x04a097ae
};

// ========================== LUID 0x209b4261 ===================
//
//			FL_DECLARE_FUNC [0x209b4261] ["CTspDev::mfn_lineGetID_LINE_DIAGNOSTICS"]
//


FL_FUNCINFO FuncInfo0x209b4261 = 
{
	{
		MAKELONG(sizeof(FL_FUNCINFO), wSIG_GENERIC_SMALL_OBJECT),
		dwLUID_FL_FUNCINFO,
		0
	},
	0x209b4261,
	FL_Stringtable+188,
	&FileInfo0x04a097ae
};



#define HASH_TABLE_LENGTH 256

const DWORD dwHashTableLength = HASH_TABLE_LENGTH;

void * FLBucket0[] = 
{
	(void *) &FuncInfo0x885cdd5c,
	NULL
};

void * FLBucket1[] = 
{
	(void *) &RFRInfo0xb7010000,
	NULL
};

void * FLBucket2[] = 
{
	(void *) &RFRInfo0x3d02a200,
	NULL
};

void * FLBucket5[] = 
{
	(void *) &FuncInfo0x86571252,
	(void *) &RFRInfo0x1b053100,
	(void *) &RFRInfo0x4e05cb00,
	NULL
};

void * FLBucket6[] = 
{
	(void *) &RFRInfo0xa706a600,
	NULL
};

void * FLBucket10[] = 
{
	(void *) &RFRInfo0x2d0a4600,
	(void *) &FuncInfo0x0e357d3f,
	NULL
};

void * FLBucket11[] = 
{
	(void *) &RFRInfo0x210b2f00,
	NULL
};

void * FLBucket14[] = 
{
	(void *) &FileInfo0x04a097ae,
	NULL
};

void * FLBucket17[] = 
{
	(void *) &FuncInfo0x45352124,
	NULL
};

void * FLBucket18[] = 
{
	(void *) &RFRInfo0xc0124700,
	(void *) &RFRInfo0xdf123e00,
	NULL
};

void * FLBucket20[] = 
{
	(void *) &RFRInfo0xa914c600,
	NULL
};

void * FLBucket21[] = 
{
	(void *) &FuncInfo0x888d2a98,
	NULL
};

void * FLBucket22[] = 
{
	(void *) &RFRInfo0x00164300,
	NULL
};

void * FLBucket23[] = 
{
	(void *) &RFRInfo0x7217c400,
	NULL
};

void * FLBucket25[] = 
{
	(void *) &FuncInfo0x81e0d3f9,
	NULL
};

void * FLBucket28[] = 
{
	(void *) &FuncInfo0xed6c4370,
	NULL
};

void * FLBucket29[] = 
{
	(void *) &FuncInfo0xc2a949b4,
	NULL
};

void * FLBucket30[] = 
{
	(void *) &RFRInfo0x511e2400,
	NULL
};

void * FLBucket35[] = 
{
	(void *) &FuncInfo0x1b009123,
	NULL
};

void * FLBucket36[] = 
{
	(void *) &FuncInfo0xc26c1348,
	NULL
};

void * FLBucket39[] = 
{
	(void *) &RFRInfo0x3a274e00,
	(void *) &RFRInfo0xe8271600,
	NULL
};

void * FLBucket40[] = 
{
	(void *) &FuncInfo0x68c9e1e1,
	NULL
};

void * FLBucket42[] = 
{
	(void *) &RFRInfo0xc22a1600,
	NULL
};

void * FLBucket43[] = 
{
	(void *) &FuncInfo0xd328ab03,
	(void *) &RFRInfo0x172b7b00,
	(void *) &RFRInfo0x282bc900,
	NULL
};

void * FLBucket44[] = 
{
	(void *) &FuncInfo0x5360574c,
	(void *) &RFRInfo0xb72c4600,
	NULL
};

void * FLBucket47[] = 
{
	(void *) &RFRInfo0xa62f2e00,
	NULL
};

void * FLBucket48[] = 
{
	(void *) &RFRInfo0x9e30ec00,
	(void *) &RFRInfo0x34301c00,
	(void *) &RFRInfo0x82300f00,
	NULL
};

void * FLBucket52[] = 
{
	(void *) &RFRInfo0x17348700,
	NULL
};

void * FLBucket53[] = 
{
	(void *) &RFRInfo0x4f356100,
	NULL
};

void * FLBucket54[] = 
{
	(void *) &FuncInfo0x6b8ddbbb,
	NULL
};

void * FLBucket55[] = 
{
	(void *) &RFRInfo0x0037c000,
	NULL
};

void * FLBucket57[] = 
{
	(void *) &RFRInfo0x4c39cf00,
	NULL
};

void * FLBucket60[] = 
{
	(void *) &RFRInfo0xb73c4600,
	NULL
};

void * FLBucket63[] = 
{
	(void *) &RFRInfo0x1b3f6d00,
	(void *) &RFRInfo0xd23f4c00,
	NULL
};

void * FLBucket65[] = 
{
	(void *) &RFRInfo0x27417e00,
	NULL
};

void * FLBucket66[] = 
{
	(void *) &RFRInfo0x6e42a700,
	(void *) &RFRInfo0x25423f00,
	(void *) &FuncInfo0x21b243f0,
	NULL
};

void * FLBucket69[] = 
{
	(void *) &FuncInfo0xcf159c50,
	NULL
};

void * FLBucket71[] = 
{
	(void *) &FuncInfo0xa038177f,
	NULL
};

void * FLBucket73[] = 
{
	(void *) &RFRInfo0xb949f900,
	(void *) &RFRInfo0xfc498200,
	NULL
};

void * FLBucket76[] = 
{
	(void *) &FuncInfo0xe30ecd42,
	NULL
};

void * FLBucket78[] = 
{
	(void *) &RFRInfo0x254efe00,
	(void *) &FuncInfo0xa00d3f43,
	NULL
};

void * FLBucket79[] = 
{
	(void *) &FuncInfo0xa4097846,
	NULL
};

void * FLBucket80[] = 
{
	(void *) &FuncInfo0x5bbf75ef,
	NULL
};

void * FLBucket83[] = 
{
	(void *) &FuncInfo0xdaf3d4a0,
	NULL
};

void * FLBucket86[] = 
{
	(void *) &RFRInfo0x8456cb00,
	NULL
};

void * FLBucket89[] = 
{
	(void *) &RFRInfo0xf9599200,
	NULL
};

void * FLBucket92[] = 
{
	(void *) &RFRInfo0x5a5cd100,
	NULL
};

void * FLBucket93[] = 
{
	(void *) &RFRInfo0x345de200,
	NULL
};

void * FLBucket96[] = 
{
	(void *) &FuncInfo0x7e77dd17,
	(void *) &RFRInfo0x43601800,
	NULL
};

void * FLBucket101[] = 
{
	(void *) &RFRInfo0x63657f00,
	NULL
};

void * FLBucket103[] = 
{
	(void *) &RFRInfo0x2b676900,
	NULL
};

void * FLBucket105[] = 
{
	(void *) &RFRInfo0x55693500,
	NULL
};

void * FLBucket106[] = 
{
	(void *) &FuncInfo0x896ec204,
	(void *) &RFRInfo0x2a6a4400,
	NULL
};

void * FLBucket107[] = 
{
	(void *) &FuncInfo0x9a8df7e6,
	NULL
};

void * FLBucket108[] = 
{
	(void *) &RFRInfo0xac6c8a00,
	NULL
};

void * FLBucket112[] = 
{
	(void *) &RFRInfo0x6770ef00,
	NULL
};

void * FLBucket113[] = 
{
	(void *) &RFRInfo0x5371c600,
	(void *) &RFRInfo0x7c710f00,
	NULL
};

void * FLBucket114[] = 
{
	(void *) &RFRInfo0x9472a000,
	NULL
};

void * FLBucket115[] = 
{
	(void *) &RFRInfo0xf7736900,
	NULL
};

void * FLBucket116[] = 
{
	(void *) &RFRInfo0x4e74c600,
	NULL
};

void * FLBucket117[] = 
{
	(void *) &FuncInfo0xb9547d21,
	(void *) &RFRInfo0xc5752400,
	NULL
};

void * FLBucket119[] = 
{
	(void *) &RFRInfo0xb1776700,
	(void *) &FuncInfo0x9b9459e3,
	NULL
};

void * FLBucket120[] = 
{
	(void *) &FuncInfo0xded1f0a9,
	(void *) &FuncInfo0xded1d0a9,
	NULL
};

void * FLBucket121[] = 
{
	(void *) &RFRInfo0x0479b600,
	(void *) &RFRInfo0x7079be00,
	(void *) &FuncInfo0x79fa3c83,
	NULL
};

void * FLBucket124[] = 
{
	(void *) &RFRInfo0x947cc100,
	(void *) &FuncInfo0xf0bdd5c1,
	NULL
};

void * FLBucket125[] = 
{
	(void *) &RFRInfo0xd57dcf00,
	(void *) &RFRInfo0xf67d1a00,
	NULL
};

void * FLBucket126[] = 
{
	(void *) &FuncInfo0x8aa894d6,
	NULL
};

void * FLBucket127[] = 
{
	(void *) &RFRInfo0x3c7fef00,
	NULL
};

void * FLBucket128[] = 
{
	(void *) &FileInfo0x986d98ed,
	(void *) &RFRInfo0xff803300,
	(void *) &RFRInfo0x9680a600,
	NULL
};

void * FLBucket131[] = 
{
	(void *) &FuncInfo0x9dd08553,
	(void *) &RFRInfo0x6e834e00,
	NULL
};

void * FLBucket133[] = 
{
	(void *) &RFRInfo0x0485b800,
	NULL
};

void * FLBucket136[] = 
{
	(void *) &RFRInfo0x0b882700,
	(void *) &FuncInfo0x45a9fa21,
	NULL
};

void * FLBucket138[] = 
{
	(void *) &FuncInfo0xdd37f0bd,
	NULL
};

void * FLBucket140[] = 
{
	(void *) &RFRInfo0xb28c2f00,
	NULL
};

void * FLBucket141[] = 
{
	(void *) &FuncInfo0xb7e98764,
	NULL
};

void * FLBucket142[] = 
{
	(void *) &RFRInfo0x528e2a00,
	NULL
};

void * FLBucket145[] = 
{
	(void *) &RFRInfo0xd191ae00,
	(void *) &RFRInfo0xf391f200,
	NULL
};

void * FLBucket147[] = 
{
	(void *) &RFRInfo0xc393d700,
	NULL
};

void * FLBucket148[] = 
{
	(void *) &RFRInfo0x94949c00,
	(void *) &RFRInfo0xce944f00,
	NULL
};

void * FLBucket150[] = 
{
	(void *) &RFRInfo0xa596d200,
	NULL
};

void * FLBucket151[] = 
{
	(void *) &FileInfo0x7cb8c92f,
	NULL
};

void * FLBucket154[] = 
{
	(void *) &RFRInfo0xd89afb00,
	NULL
};

void * FLBucket157[] = 
{
	(void *) &FuncInfo0xc25a41c7,
	(void *) &FuncInfo0xb7f98764,
	NULL
};

void * FLBucket159[] = 
{
	(void *) &FuncInfo0xd582711d,
	(void *) &RFRInfo0xa19f8100,
	NULL
};

void * FLBucket160[] = 
{
	(void *) &RFRInfo0x87a0b000,
	NULL
};

void * FLBucket161[] = 
{
	(void *) &FuncInfo0x1fb58214,
	NULL
};

void * FLBucket162[] = 
{
	(void *) &RFRInfo0xb2a25c00,
	(void *) &FuncInfo0x1fb68214,
	NULL
};

void * FLBucket163[] = 
{
	(void *) &RFRInfo0xf4a36800,
	NULL
};

void * FLBucket165[] = 
{
	(void *) &FuncInfo0x5691bd34,
	(void *) &RFRInfo0xaca5f600,
	NULL
};

void * FLBucket168[] = 
{
	(void *) &RFRInfo0x07a87200,
	(void *) &RFRInfo0x0ca8d700,
	NULL
};

void * FLBucket171[] = 
{
	(void *) &FuncInfo0x296438cf,
	(void *) &FuncInfo0x22f22a59,
	NULL
};

void * FLBucket175[] = 
{
	(void *) &RFRInfo0xefaf5900,
	NULL
};

void * FLBucket176[] = 
{
	(void *) &RFRInfo0x86b03000,
	NULL
};

void * FLBucket177[] = 
{
	(void *) &RFRInfo0x9db11a00,
	(void *) &RFRInfo0x9cb1a400,
	NULL
};

void * FLBucket178[] = 
{
	(void *) &RFRInfo0xb8b24200,
	NULL
};

void * FLBucket182[] = 
{
	(void *) &FuncInfo0x672aa19c,
	(void *) &RFRInfo0xa5b6ad00,
	NULL
};

void * FLBucket183[] = 
{
	(void *) &RFRInfo0x72b77d00,
	(void *) &RFRInfo0x5eb73400,
	NULL
};

void * FLBucket185[] = 
{
	(void *) &RFRInfo0xdeb9ec00,
	NULL
};

void * FLBucket186[] = 
{
	(void *) &RFRInfo0xf7baee00,
	NULL
};

void * FLBucket187[] = 
{
	(void *) &RFRInfo0x80bb0100,
	NULL
};

void * FLBucket190[] = 
{
	(void *) &FuncInfo0x0b6af2d4,
	NULL
};

void * FLBucket191[] = 
{
	(void *) &FuncInfo0xeaf0b34f,
	NULL
};

void * FLBucket192[] = 
{
	(void *) &FuncInfo0xe4df9b1f,
	NULL
};

void * FLBucket195[] = 
{
	(void *) &FuncInfo0xd34b7688,
	NULL
};

void * FLBucket198[] = 
{
	(void *) &RFRInfo0x08c6de00,
	NULL
};

void * FLBucket200[] = 
{
	(void *) &FuncInfo0x3b2c98e4,
	NULL
};

void * FLBucket201[] = 
{
	(void *) &FuncInfo0x156032a9,
	(void *) &FuncInfo0xe41274db,
	NULL
};

void * FLBucket205[] = 
{
	(void *) &RFRInfo0x82cda200,
	NULL
};

void * FLBucket206[] = 
{
	(void *) &RFRInfo0x5cce0a00,
	(void *) &FuncInfo0xf3d8ee16,
	NULL
};

void * FLBucket207[] = 
{
	(void *) &FuncInfo0x4b8c1643,
	NULL
};

void * FLBucket209[] = 
{
	(void *) &RFRInfo0x1cd1ed00,
	NULL
};

void * FLBucket211[] = 
{
	(void *) &RFRInfo0x57d39b00,
	NULL
};

void * FLBucket212[] = 
{
	(void *) &RFRInfo0xa9d4fb00,
	NULL
};

void * FLBucket213[] = 
{
	(void *) &FuncInfo0x816f0bba,
	NULL
};

void * FLBucket214[] = 
{
	(void *) &FuncInfo0x864b149d,
	NULL
};

void * FLBucket215[] = 
{
	(void *) &FuncInfo0xe55cd68b,
	NULL
};

void * FLBucket217[] = 
{
	(void *) &RFRInfo0x33d90700,
	NULL
};

void * FLBucket218[] = 
{
	(void *) &FuncInfo0x18972e4d,
	NULL
};

void * FLBucket219[] = 
{
	(void *) &RFRInfo0x7cdb4c00,
	NULL
};

void * FLBucket222[] = 
{
	(void *) &RFRInfo0xaddee800,
	NULL
};

void * FLBucket223[] = 
{
	(void *) &RFRInfo0x58df2b00,
	(void *) &RFRInfo0x82df8d00,
	NULL
};

void * FLBucket224[] = 
{
	(void *) &RFRInfo0x62e06c00,
	NULL
};

void * FLBucket229[] = 
{
	(void *) &RFRInfo0xbbe5ff00,
	(void *) &FuncInfo0x761795f2,
	NULL
};

void * FLBucket230[] = 
{
	(void *) &RFRInfo0xece6f100,
	(void *) &RFRInfo0xbbe6ff00,
	(void *) &FileInfo0x4126abc0,
	NULL
};

void * FLBucket231[] = 
{
	(void *) &RFRInfo0x8ee76c00,
	NULL
};

void * FLBucket234[] = 
{
	(void *) &RFRInfo0x0cea5400,
	NULL
};

void * FLBucket235[] = 
{
	(void *) &FuncInfo0xccba5b51,
	NULL
};

void * FLBucket236[] = 
{
	(void *) &FuncInfo0xa6d3803f,
	(void *) &RFRInfo0x70ecc800,
	(void *) &RFRInfo0x43ec3000,
	NULL
};

void * FLBucket240[] = 
{
	(void *) &RFRInfo0x72f00800,
	NULL
};

void * FLBucket241[] = 
{
	(void *) &FileInfo0xe135f7c4,
	NULL
};

void * FLBucket243[] = 
{
	(void *) &RFRInfo0xddf38d00,
	(void *) &FuncInfo0x3df24801,
	NULL
};

void * FLBucket245[] = 
{
	(void *) &RFRInfo0xd8f55f00,
	NULL
};

void * FLBucket248[] = 
{
	(void *) &RFRInfo0x83f84100,
	(void *) &RFRInfo0xfff8f100,
	NULL
};

void * FLBucket249[] = 
{
	(void *) &RFRInfo0xfdf96a00,
	NULL
};

void * FLBucket250[] = 
{
	(void *) &RFRInfo0x94fadd00,
	(void *) &RFRInfo0xf2fa9900,
	(void *) &FuncInfo0x209b4261,
	NULL
};

void * FLBucket252[] = 
{
	(void *) &RFRInfo0x27fc4e00,
	(void *) &RFRInfo0x45fca600,
	NULL
};

void ** FL_HashTable[HASH_TABLE_LENGTH] = 
{
	FLBucket0,
	FLBucket1,
	FLBucket2,
	NULL,
	NULL,
	FLBucket5,
	FLBucket6,
	NULL,
	NULL,
	NULL,
	FLBucket10,
	FLBucket11,
	NULL,
	NULL,
	FLBucket14,
	NULL,
	NULL,
	FLBucket17,
	FLBucket18,
	NULL,
	FLBucket20,
	FLBucket21,
	FLBucket22,
	FLBucket23,
	NULL,
	FLBucket25,
	NULL,
	NULL,
	FLBucket28,
	FLBucket29,
	FLBucket30,
	NULL,
	NULL,
	NULL,
	NULL,
	FLBucket35,
	FLBucket36,
	NULL,
	NULL,
	FLBucket39,
	FLBucket40,
	NULL,
	FLBucket42,
	FLBucket43,
	FLBucket44,
	NULL,
	NULL,
	FLBucket47,
	FLBucket48,
	NULL,
	NULL,
	NULL,
	FLBucket52,
	FLBucket53,
	FLBucket54,
	FLBucket55,
	NULL,
	FLBucket57,
	NULL,
	NULL,
	FLBucket60,
	NULL,
	NULL,
	FLBucket63,
	NULL,
	FLBucket65,
	FLBucket66,
	NULL,
	NULL,
	FLBucket69,
	NULL,
	FLBucket71,
	NULL,
	FLBucket73,
	NULL,
	NULL,
	FLBucket76,
	NULL,
	FLBucket78,
	FLBucket79,
	FLBucket80,
	NULL,
	NULL,
	FLBucket83,
	NULL,
	NULL,
	FLBucket86,
	NULL,
	NULL,
	FLBucket89,
	NULL,
	NULL,
	FLBucket92,
	FLBucket93,
	NULL,
	NULL,
	FLBucket96,
	NULL,
	NULL,
	NULL,
	NULL,
	FLBucket101,
	NULL,
	FLBucket103,
	NULL,
	FLBucket105,
	FLBucket106,
	FLBucket107,
	FLBucket108,
	NULL,
	NULL,
	NULL,
	FLBucket112,
	FLBucket113,
	FLBucket114,
	FLBucket115,
	FLBucket116,
	FLBucket117,
	NULL,
	FLBucket119,
	FLBucket120,
	FLBucket121,
	NULL,
	NULL,
	FLBucket124,
	FLBucket125,
	FLBucket126,
	FLBucket127,
	FLBucket128,
	NULL,
	NULL,
	FLBucket131,
	NULL,
	FLBucket133,
	NULL,
	NULL,
	FLBucket136,
	NULL,
	FLBucket138,
	NULL,
	FLBucket140,
	FLBucket141,
	FLBucket142,
	NULL,
	NULL,
	FLBucket145,
	NULL,
	FLBucket147,
	FLBucket148,
	NULL,
	FLBucket150,
	FLBucket151,
	NULL,
	NULL,
	FLBucket154,
	NULL,
	NULL,
	FLBucket157,
	NULL,
	FLBucket159,
	FLBucket160,
	FLBucket161,
	FLBucket162,
	FLBucket163,
	NULL,
	FLBucket165,
	NULL,
	NULL,
	FLBucket168,
	NULL,
	NULL,
	FLBucket171,
	NULL,
	NULL,
	NULL,
	FLBucket175,
	FLBucket176,
	FLBucket177,
	FLBucket178,
	NULL,
	NULL,
	NULL,
	FLBucket182,
	FLBucket183,
	NULL,
	FLBucket185,
	FLBucket186,
	FLBucket187,
	NULL,
	NULL,
	FLBucket190,
	FLBucket191,
	FLBucket192,
	NULL,
	NULL,
	FLBucket195,
	NULL,
	NULL,
	FLBucket198,
	NULL,
	FLBucket200,
	FLBucket201,
	NULL,
	NULL,
	NULL,
	FLBucket205,
	FLBucket206,
	FLBucket207,
	NULL,
	FLBucket209,
	NULL,
	FLBucket211,
	FLBucket212,
	FLBucket213,
	FLBucket214,
	FLBucket215,
	NULL,
	FLBucket217,
	FLBucket218,
	FLBucket219,
	NULL,
	NULL,
	FLBucket222,
	FLBucket223,
	FLBucket224,
	NULL,
	NULL,
	NULL,
	NULL,
	FLBucket229,
	FLBucket230,
	FLBucket231,
	NULL,
	NULL,
	FLBucket234,
	FLBucket235,
	FLBucket236,
	NULL,
	NULL,
	NULL,
	FLBucket240,
	FLBucket241,
	NULL,
	FLBucket243,
	NULL,
	FLBucket245,
	NULL,
	NULL,
	FLBucket248,
	FLBucket249,
	FLBucket250,
	NULL,
	FLBucket252,
	NULL,
	NULL,
	NULL
};

const char *const FL_Stringtable[189] = {
	"Implements Generic Dialog functionality",
	"TUISPI_phoneConfigDialog",
	"Implements class CTspDev",
	"CTspDev::AcceptTspCall",
	"Incorrect TSPI version",
	"Incorrect TSPI version",
	"Invalid address ID",
	"Incorrect TSPI version",
	"Unknown destination",
	"CTspDev::Load",
	"NULL pMD passed in",
	"Couldn't begin session with MD",
	"Driver Key too large",
	"RegQueryValueEx(FriendlyName) fails",
	"RegQueryValueEx(cszProperties) fails",
	"RegQueryValueEx(cszDeviceType) fails",
	"Invalid bDeviceType",
	"UmRtlGetDefaultCommConfig fails",
	"ExtensionCallback",
	"CTspDev::RegisterProviderInfo",
	"ExtOpenExtensionBinding failed",
	"wrong state",
	"CTspDev::mfn_get_LINEDEVCAPS",
	"LINEDEVCAPS structure too small",
	"CTspDev::mfn_get_PHONECAPS",
	"Device doesn't support phone capability",
	"PHONECAPS structure too small",
	"CTspDev::mfn_get_ADDRESSCAPS",
	"ADDRESSCAPS structure too small",
	"CTspDev::mfn_GetVoiceProperties",
	"Modem voice capabilities not supported on NT",
	"Modem does not have voice capabilities",
	"Couldn't get WaveInstance",
	"mfn_GetDataModemDevCfg",
	"SetDataModemConfig",
	"mfn_LineEventProc",
	"mfn_PhoneEventProc",
	"CTspDev::mfn_TSPICompletionProc",
	"Calling ExtTspiAsyncCompletion",
	"Calling pfnTapiCompletionProc",
	"CTspDev::NotifyDefaultConfigChanged",
	"Couldn't open driverkey!",
	"UmRtlGetDefaultCommConfig fails",
	"ProcessResponse",
	"ConstructNewPreDialCommands",
	"Analog bearermode -- no pre-dial commmands.",
	"Invalid Bearermode in modem options!",
	"Invalid Protocol info in modem options!",
	"Internal error: tmp buffer too small.",
	"ReadCommandsA failed.",
	"CTspDev::DumpState",
	"GLOBAL STATE:",
	"LINE STATE:",
	"PHONE STATE:",
	"LLDEV STATE:",
	"xxxx",
	"Invalid DevCfg specified",
	"Invalid COMMCONFIG specified",
	"Success; set fConfigUpdatedByApp.",
	"Call-related functionality of class CTspDev",
	"CTspDev::mfn_accept_tsp_call_for_HDRVCALL",
	"No call exists",
	"lineDial handled successfully",
	"lineGetCallAddressID handled successfully",
	"lineCloseCall handled",
	"lineGetCallStatus handled successfully",
	"lineGetCallInfo handled successfully",
	"lineAccept handled successfully",
	"lineAnswer handled successfully",
	"Task pending on lineAnswer, can't handle.",
	"lineMonitorDigits handled successfully",
	"INVALID DIGITMODES",
	"Disabling Monitoring",
	"Enabling Monitoring",
	"This modem can't monior DTMF",
	"lineMonitorTones handled successfully",
	"This modem can't monitor silence",
	"ENABLING MONITOR SILENCE",
	"INVALID TONELIST",
	"DIABLING MONITOR SILENCE",
	"lineGenerateDigits handled successfully",
	"GenerateDigits: device doesn't support it!",
	"lineGenerateDigit: Unsupported/invalid digitmode",
	"lineGenerateDigit: Ignoring request for aborting/disconnected call...",
	"lineGenerateDigit: Can't handle request while aborting/disconnected call...",
	"GenerateDigits: only works with AUTOMATEDVOICE!",
	"Couldn't convert tones to ANSI!",
	"Couldn't alloc space for tones!",
	"lineSetCallParams handled successfully",
	"Callstate aborting or not active",
	"Callstate not OFFERING/ACCEPTED/CONNECTED",
	"lineSetCallParams: Invalid bearermode",
	"Failed to get resources for passthrough",
	"UmSetPassthroughOn failed",
	"UmSetPassthroughOn succedded",
	"Wrong state for passthrough on",
	"UmSetPassthroughOff failed",
	"UmSetPassthroughOff succedded",
	"lineSetAppSpecific handled successfully",
	"lineSetMediaMode handled successfully",
	"lineMonitorMedia handled successfully",
	"*** UNHANDLED HDRVCALL CALL ****",
	"CTspDev::mfn_TH_CallMakeTalkDropCall",
	"Unknown Msg",
	"CTspDev::mfn_TH_CallWaitForDropToGoAway",
	"Unknown Msg",
	"CTspDev::mfn_TH_CallMakeCall2",
	"Unknown Msg",
	"CTspDev::mfn_TH_CallMakeCall",
	"Unknown Msg",
	"CTspDev::mfn_TH_CallMakePassthroughCall",
	"Unknown Msg",
	"CTspDev::mfn_TH_CallDropCall",
	"invalid subtask",
	"Unknown Msg",
	"CTspDev::mfn_LoadCall",
	"Call already exists!",
	"Invalid MediaMode",
	"Invalid BearerMode",
	"Invalid Phone Number",
	"mfn_UnloadCall",
	"CTspDev::mfn_ProcessRing",
	"Line not open/not monitoring!",
	"Ignoring ring because task pending!",
	"CTspDev::mfn_ProcessDisconnect",
	"Line not open!",
	"Call doesn't exist/dropping!",
	"CTspDev::mfn_ProcessHardwareFailure",
	"CTspDev::mfn_TH_CallAnswerCall",
	"Unknown Msg",
	"HandleSuccessfulConnection",
	"LaunchModemLights",
	"NotifyDisconnection",
	"CTspDev::mfn_ProcessDialTone",
	"Line not open!",
	"Call doesn't exist!",
	"CTspDev::mfn_ProcessBusy",
	"Line not open!",
	"Call doesn't exist!",
	"CTspDev::mfn_ProcessDTMFNotif",
	"Line not open!",
	"Call doesn't exist!",
	"CTspDev::mfn_TH_CallGenerateDigit",
	"Unknown Msg",
	"Can't call UmGenerateDigit in current state!",
	"CTspDev::mfn_TH_CallSwitchFromVoiceToData",
	"CTspDev::MDSetTimeout",
	"CTspDev::MDRingTimeout",
	"CTspDev::mfn_ProcessCallerID",
	"Implements UI-related features of CTspDev",
	"GenericLineDialogData",
	"CTspDev::mfn_CreateDialogInstance",
	"CTspDev::mfn_TH_CallStartTerminal",
	"Unknown Msg",
	"PRECONNECT TERMINAL",
	"POSTCONNECT TERMINAL",
	"MANUAL DIAL",
	"mfn_TH_CallPutUpTerminalWindow",
	"mfn_KillCurrentDialog",
	"mfn_KillTalkDropDialog",
	"Line-related functionality of class CTspDev",
	"CTspDev::mfn_monitor",
	"Invalid mediamode",
	"Can't answer INTERACTIVEVOICE calls",
	"no change in det media modes",
	"Closed LLDev from Line",
	"no change in det media modes",
	"CTspDev::mfn_accept_tsp_call_for_HDRVLINE",
	"Call already exists/queued",
	"Invalid params",
	"Unknown device class",
	"Unsupported device class",
	"lineSetStatusMessages handled",
	"lineGetAddressStatus handled",
	"lineConditionalMediaDetection handled",
	"*** UNHANDLED HDRVLINE CALL ****",
	"CTspDev::mfn_LoadLine",
	"Device already loaded (m_pLine!=NULL)!",
	"UnloadLine",
	"CTspDev::mfn_ProcessPowerResume",
	"Doing nothing because no clients to lldev.",
	"mfn_lineGetID_COMM_DATAMODEM",
	"lineGetID_NDIS",
	"CTspDev::mfn_lineGetID_WAVE",
	"Couldn't LoadLibrary(winmm.dll)",
	"Couldn't loadlib mmsystem apis",
	"Could not find wave device",
	"CTspDev::mfn_fill_RAW_LINE_DIAGNOSTICS",
	"CTspDev::mfn_lineGetID_LINE_DIAGNOSTICS",
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\tsp\globals.h ===
// 
// Copyright (c) 1996-1997 Microsoft Corporation.
//
//
// Component
//
//		Unimodem 5.0 TSP (Win32, user mode DLL)
//
// File
//
//		GLOBALS.H
//		Header for global variables and functions that manipulate them.
//
// History
//
//		12/05/1996  JosephJ Created
//
//
#define MAX_PROVIDER_INFO_LENGTH 128

class CTspDevMgr;

typedef struct
{
	CRITICAL_SECTION crit;

	BOOL fLoaded;

	HMODULE hModule;

	CTspDevMgr *pTspDevMgr;
	// CTspTracer *pTspTracer;

	UINT cbProviderInfo;
	TCHAR rgtchProviderInfo[MAX_PROVIDER_INFO_LENGTH+1];

} GLOBALS;

extern GLOBALS g;

void 		tspGlobals_OnProcessAttach(HMODULE hDLL);
void 		tspGlobals_OnProcessDetach(void);
TSPRETURN	tspLoadGlobals(CStackLog *psl);
void		tspUnloadGlobals(CStackLog *psl);

void
tspSubmitTSPCallWithLINEID(
				DWORD dwRoutingInfo,
				void *pvParams,
				DWORD dwDeviceID,
				LONG *plRet,
				CStackLog *psl
				);

void
tspSubmitTSPCallWithPHONEID(
				DWORD dwRoutingInfo,
				void *pvParams,
				DWORD dwDeviceID,
				LONG *plRet,
				CStackLog *psl
				);

void
tspSubmitTSPCallWithHDRVCALL(
				DWORD dwRoutingInfo,
				void *pvParams,
				HDRVCALL hdCall,
				LONG *plRet,
				CStackLog *psl
				);

void
tspSubmitTSPCallWithHDRVLINE(
				DWORD dwRoutingInfo,
				void *pvParams,
				HDRVLINE hdLine,
				LONG *plRet,
				CStackLog *psl
				);

void
tspSubmitTSPCallWithHDRVPHONE(
				DWORD dwRoutingInfo,
				void *pvParams,
				HDRVPHONE hdPhone,
				LONG *plRet,
				CStackLog *psl
				);

DWORD
APIENTRY
tepAPC (void *pv);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\tsp\iderr.h ===
// 
// Copyright (c) 1996-1997 Microsoft Corporation.
//
//
// Component
//
//		Unimodem 5.0 TSP (Win32, user mode DLL)
//
// File
//
//		IDERR.H
//		Defines the IDERR_ values. These are 8-bit constants.
//
// History
//
//		11/23/1996  JosephJ Created
//
//

// NOTE: The following error codes MUST fit in a byte -- hence only 256 allowed
// This is so that they can be used with the fastlog FL_GEN_RETVAL and related
// macros. See fastlog.h for details

#define IDERR_SUCCESS 0x0

#define IDERR_SYS	  0x1					// Error is reported in GetLastError
											//
#define IDERR_CORRUPT_STATE 0x2				// Bad internal error/assert
											//
#define IDERR_INVALID_ERR 0x3				// Special case of an internal 
											//   error -- the error code was
											//   not assigned -- typically this
											//   is because an invalid codepath
											//   was taken. For example some
											//   case was not handled. Set
											//   the return value to this if
											//   you want to ensure that it
											//   needs to be changed to
											//   something else later.
#define IDERR_WRONGSTATE 0x4				// Not in the correct state to 
											//	 perform the function
#define IDERR_ALLOCFAILED 0x5				// Memory allocation failed
											//
#define IDERR_SAMESTATE 0x6					// Already in the state you want
											// to go to. Often harmless.
#define IDERR_UNIMPLEMENTED 0x7				// Function is unimplemented.
											//
#define IDERR_INVALIDHANDLE 0x8				// Relevant handle/id is invalid
											//
#define IDERR_INTERNAL_OBJECT_TOO_SMALL 0x9	// An internal object is too
											// small to hold what its supposed
											// to hold -- often a bad error/
											// assert condition.
#define IDERR_GENERIC_FAILURE 0xa				// Catchall error, no more info
											// available -- note you can use
											// IDERR_SYS if you want to
											// propogate the system error code
											// via Get/SetLastError
#define IDERR_REG_QUERY_FAILED 0xb			// One of the registry query apis
											// failed.
#define IDERR_REG_CORRUPT 0xc				// Invalid value in
											// registry. Could be a problem with
											// the modem registry entries due
											// to a bad INF.
#define IDERR_REG_OPEN_FAILED 0xd			// RegOpenKey failed.

#define IDERR_PENDING		  0xe 			// Task is awaiting async
											// completion.
											
#define IDERR_MD_OPEN_FAILED  0xf           // UmOpenModem failed.

#define IDERR_CREATE_RESOURCE_FAILED  0x10  // COuldn't create some resource.
#define IDERR_OPEN_RESOURCE_FAILED    0x11  // Couldn't open some resource.
#define IDERR_FUNCTION_UNAVAIL        0x12  // Don't have capabilities to
                                             // this function.

#define IDERR_MD_DEVICE_NOT_RESPONDING 0x13
#define IDERR_MD_DEVICE_ERROR          0x14
#define IDERR_MD_LINE_NOCARRIER        0x15
#define IDERR_MD_LINE_NODIALTONE       0x16
#define IDERR_MD_LINE_BUSY             0x17
#define IDERR_MD_LINE_NOANSWER         0x18
#define IDERR_MD_DEVICE_INUSE          0x19
#define IDERR_MD_DEVICE_WRONGMODE      0x1a
#define IDERR_MD_DEVICE_NOT_CAPABLE    0x1b
#define IDERR_MD_BAD_PARAM             0x1c
#define IDERR_MD_GENERAL_ERROR         0x1d
#define IDERR_MD_REG_ERROR             0x1e
#define IDERR_MD_UNMAPPED_ERROR        0x1f // Some error we have not mapped 
                                            // properly.
#define IDERR_OPERATION_ABORTED        0x20 // operation aborted

#define IDERR_MDEXT_BINDING_FAILED     0x21 // OpenExtensionBinding failed.

#define IDERR_DEVICE_NOTINSTALLED      0x22 // Device is not installed.
#define IDERR_TASKPENDING              0x23 // Task is pending, so can't start
                                            // another task.

#define IDERR_MD_LINE_BLACKLISTED      0x24
#define IDERR_MD_LINE_DELAYED          0x25

#define IDERR_LAST_ERROR 0x25


#if (IDERR_LAST_ERROR > 0xff)
#	error "IDERR value too large"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\tsp\idobj.h ===
// 
// Copyright (c) 1996-1997 Microsoft Corporation.
//
//
// Component
//
//		Unimodem 5.0 TSP (Win32, user mode DLL)
//
// File
//
//		IDOBJ.H
//		Defines the IDOBJ_ values. These are 8-bit constants.
//
// History
//
//		11/23/1996  JosephJ Created
//
//

#define IDOBJ_CSync 			0
#define IDOBJ_CTspDev	  		1
#define IDOBJ_CTspDevMgr 		2
#define IDOBJ_CTspDevFactory 	3
#define IDOBJ_TspDevRec			4
#define IDOBJ_TspMiniDriver		5
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\tsp\globals.cpp ===
// 
// Copyright (c) 1996-1997 Microsoft Corporation.
//
//
// Component
//
//		Unimodem 5.0 TSP (Win32, user mode DLL)
//
// File
//
//		GLOBALS.CPP
//		Implements global variables and functions which manipulate them.
//
// History
//
//		12/05/1996  JosephJ Created
//
//


#include "tsppch.h"
#include "tspcomm.h"
#include "cdev.h"
#include "cfact.h"
#include "cmgr.h"
#include "globals.h"
#include "rcids.h"
#include <tspnotif.h>
#include <slot.h>

FL_DECLARE_FILE(0xa31a2497, "TSP globals")

GLOBALS g;

// TODO: this goes away when there is a reall logging infrastructure in place.
//
extern DWORD g_fDoLog;

//
// The following notification-related helper functions are for processing
// external notifications, such as requests to re-enum the devices.
// See tepApc, the apc thread, and the functions themselves, for more info.
// Adapted from NT4 tsp (ProcessNotification, etc, in mdmutil.c).
//
BOOL process_notification (
    DWORD dwType,
    DWORD dwFlags,
    DWORD dwSize,
    PVOID pvData);

void process_cpl_notification (
    DWORD dwFlags,
    DWORD dwSize,
    PVOID pvData,
    CStackLog *psl);

void process_debug_notification (
    DWORD dwFlags,
    DWORD dwSize,
    PVOID pvData,
    CStackLog *psl);

void tspGlobals_OnProcessAttach(HMODULE hDLL)
{
	InitializeCriticalSection(&g.crit);

	g.hModule = hDLL;
	g.pTspDevMgr = NULL;


}


void tspGlobals_OnProcessDetach()
{
	if (g.pTspDevMgr)
	{
		g.pTspDevMgr->Unload(NULL,NULL,NULL);

		delete g.pTspDevMgr;

		g.pTspDevMgr = NULL;
		g.hModule = NULL;
		g.fLoaded = FALSE;
	}

	DeleteCriticalSection(&g.crit);
}


TSPRETURN tspLoadGlobals(CStackLog *psl)
{
	FL_DECLARE_FUNC(0x45270ee7, "TSPI_loadGlobals");
	FL_LOG_ENTRY(psl);

	TSPRETURN tspRet = 0;

	EnterCriticalSection(&g.crit);

	if (g.fLoaded)
	{
		goto end;
	}
	
	//ASSERT(!g.pTspTracer);
	//g.pTspTracer = new CTspTracer;
	//if(g.pTspTracer)
	//{
	//	tspRet = g.pTspTracer->Load();
	//}
	// if (tspRet) goto end;

    #if 1
    {
        LPTSTR lptsz =
         TEXT("Windows Telephony Service Provider for Universal Modem Driver");
	    g.cbProviderInfo =  (lstrlen(lptsz)+1)*sizeof(*lptsz);
	    CopyMemory(g.rgtchProviderInfo, lptsz, g.cbProviderInfo);
    } 
    #else
	g.cbProviderInfo = sizeof(TCHAR) *
						(LoadString(
								g.hModule,
                          		ID_PROVIDER_INFO, 
								g.rgtchProviderInfo,
                          		sizeof(g.rgtchProviderInfo)/sizeof(TCHAR)
								)
						+ 1);
    #endif

	ASSERT(!g.pTspDevMgr);
	g.pTspDevMgr = new CTspDevMgr;
	if (g.pTspDevMgr)
	{
		tspRet = g.pTspDevMgr->Load(psl);
	}

	if (tspRet)
	{
		FL_SET_RFR(0x833c9200, "CTspDevMgr->Load failed");
		goto end;
	}

    if (g_fDoLog)
    {
        AllocConsole();
    }

	g.fLoaded=TRUE;

end:

	if (tspRet)
	{
		ASSERT(!g.fLoaded);

		// cleanup...
		if (g.pTspDevMgr)
		{
			delete g.pTspDevMgr;
			g.pTspDevMgr = NULL;
		}

		// pTspTracer...
	}

	LeaveCriticalSection(&g.crit);

	FL_LOG_EXIT(psl,tspRet);

	return tspRet;
}


void tspUnloadGlobals(CStackLog *psl)
{
	FL_DECLARE_FUNC(0x0f321096, "tspUnloadGlobals")

	EnterCriticalSection(&g.crit);

	if (g.fLoaded)
	{
		HANDLE hEvent = CreateEvent(
							NULL,
							TRUE,
							FALSE,
							NULL
							);
		LONG lCount=1;

		ASSERT(g.pTspDevMgr);

        LeaveCriticalSection(&g.crit);

		g.pTspDevMgr->Unload(hEvent, &lCount, psl);

		if (hEvent)
		{

            FL_SERIALIZE(psl, "Waiting for DevMgr to unload");

			WaitForSingleObject(hEvent, INFINITE);

            EnterCriticalSection(&g.crit);
            FL_SERIALIZE(psl, "DevMgr done unloading");
			CloseHandle(hEvent);
			hEvent  = NULL;

			delete g.pTspDevMgr;
		}
		else
		{
			// Can't do much here  -- we won't delete pTspDevMgr -- just leave
			// it dangling...
            EnterCriticalSection(&g.crit);
			ASSERT(FALSE);
		}

		g.pTspDevMgr=NULL;

		//ASSERT(g.pTspTracer);
		//g.pTspTracer->Unload(TRUE);
		//delete g.pTspTracer;
		//g.pTspDevMgr=NULL;

		g.fLoaded=FALSE;
	}

	LeaveCriticalSection(&g.crit);
}

BOOL process_notification (
    DWORD dwType,
    DWORD dwFlags,
    DWORD dwSize,
    PVOID pvData)
{
	FL_DECLARE_FUNC(0x0188d4e2, "process_notification")
    FL_DECLARE_STACKLOG(sl, 1000);

 BOOL fRet = TRUE;

    switch (dwType)
    {
        case TSPNOTIF_TYPE_CPL:
            process_cpl_notification (dwFlags, dwSize, pvData, &sl);
            break;

        case TSPNOTIF_TYPE_DEBUG:
            process_debug_notification (dwFlags, dwSize, pvData, &sl);
            break;

        case TSPNOTIF_TYPE_CHANNEL:
            FL_ASSERT (&sl, sizeof(BOOL) == dwSize);
            fRet = !(*(BOOL*)pvData);
            break;

        default:
            SLPRINTF1(&sl, "WARNING:Got unknown notif type 0x%lu.\n", dwType);
            break;
    }
    
    sl.Dump(FOREGROUND_BLUE|BACKGROUND_RED|BACKGROUND_GREEN|BACKGROUND_BLUE);
    return fRet;
}


void process_cpl_notification (
    DWORD dwFlags,
    DWORD dwSize,
    PVOID pvData,
    CStackLog *psl)
{
	FL_DECLARE_FUNC(0x99bc10db, "Process CPL Notification")

 DWORD dwcbNew;
 HSESSION hSession = NULL;

	FL_LOG_ENTRY(psl);

    SLPRINTF0(psl, "Got CPL NOTIFICATION!");

    // We obtain a session handle to the device manager, do the required
    // processing, then release the session handle.
    //
    EnterCriticalSection(&g.crit);
	if (g.pTspDevMgr)
    {
        if (g.pTspDevMgr->BeginSession(&hSession, FL_LOC))
        {
            FL_SET_RFR(0x28445400, "Could not obtain session with dev mgr");
            hSession=0;
            LeaveCriticalSection(&g.crit);
            goto end;
	    }
    }
    LeaveCriticalSection(&g.crit);

    if (!hSession)
    {
        FL_SET_RFR(0x9bd78f00, "The dev mgr doesn't exist. Ignoring request.");
        goto end;
    }

    SLPRINTF1(psl, "Got a session. Flags = 0x%lx", dwFlags);

    if (dwFlags & fTSPNOTIF_FLAG_CPL_REENUM)
    {
        FL_ASSERT(psl, 0 == dwSize);
		Sleep(1000);
        g.pTspDevMgr->ReEnumerateDevices(psl);
    }
    else if (dwFlags & fTSPNOTIF_FLAG_CPL_DEFAULT_COMMCONFIG_CHANGE)
    {
        #if (!UNDER_CONSTRUCTION)
        if (!(dwFlags & fTSPNOTIF_FLAG_UNICODE))
        {
            ASSERT(FALSE);
        }
        else
        {
            // Get friendly name and refresh comm config.
            LPCTSTR lpctszFriendlyName = (LPCTSTR) pvData;
            UINT u;

            // verify string is null-terminated.
            for(u=0; u<dwSize; u++)
            {
                if (!lpctszFriendlyName[u]) break;
            }

            ASSERT(u<dwSize);

            if (u<dwSize)
            {
                ASSERT(g.pTspDevMgr);
                HSESSION hSession=0;
                CTspDev *pDev=NULL;
            
                TSPRETURN tspRet = g.pTspDevMgr->TspDevFromName(
                                        lpctszFriendlyName,
                                        &pDev,
                                        &hSession
                                        );
            
                if (tspRet)
                {
                    FL_SET_RFR(0xea0cf500, "Couldn't find device");
                }
                else
                {
                    psl->SetDeviceID(pDev->GetLineID());
                    pDev->NotifyDefaultConfigChanged(psl);
                    pDev->EndSession(hSession);
                    hSession=0;
                }
            }
        }
        #else // UNDER_CONSTRUCTION

        // extract permanent ID

        // search for device by permanent ID
        // g.pTspdevMgr->TspDevFromPermanentID(
        //                    dwPermanentID,
        //                    &pDev,
        //                    &hDevSession
		//                    );

        // ask device to update default settings.

        // release session to device

        #endif // UNDER_CONSTRUCTION
    }
    else if (dwFlags & fTSPNOTIF_FLAG_CPL_UPDATE_DRIVER)
    {
		DWORD dwID = *(LPDWORD)pvData;

		FL_ASSERT(psl, sizeof(dwID) == dwSize);

		SLPRINTF0(psl, "Got Update Driver Notification!");	
		
		g.pTspDevMgr->UpdateDriver(dwID, psl);
	}
	else
	{
	    FL_SET_RFR(0x10ce7a00, "Ignoring unknown notification.");
    }

end:
    
    if (hSession)
    {
        g.pTspDevMgr->EndSession(hSession);
        
    }

    FL_LOG_EXIT(psl, 0);

    return;
}

void process_debug_notification (
    DWORD dwFlags,
    DWORD dwSize,
    PVOID pvData,
    CStackLog *psl)
{
	FL_DECLARE_FUNC(0x8cea5041, "Process DEBUG Notification")

 DWORD dwcbNew;
 HSESSION hMgrSession = NULL;

	FL_LOG_ENTRY(psl);

    SLPRINTF0(psl, "Got DEBUG NOTIFICATION!");

    // We obtain a session handle to the device manager, do the required
    // processing, then release the session handle.
    //
    EnterCriticalSection(&g.crit);
	if (g.pTspDevMgr)
    {
        if (g.pTspDevMgr->BeginSession(&hMgrSession, FL_LOC))
        {
            FL_SET_RFR(0x3ecfb700, "Could not obtain session with dev mgr");
            hMgrSession=0;
            LeaveCriticalSection(&g.crit);
            goto end;
	    }
    }
    LeaveCriticalSection(&g.crit);

    if (!hMgrSession)
    {
        FL_SET_RFR(0x7a841400, "The dev mgr doesn't exist. Ignoring request.");
        goto end;
    }

    SLPRINTF1(psl, "Got a session. Flags = 0x%lx", dwFlags);

    FL_ASSERT (psl, 0 == dwSize);
    //
    // Now get device and ask it to dump state!
    //
    {
        CTspDev *pDev=NULL;
        HSESSION hSession = NULL;

        LONG l = (LONG)dwFlags;

        if (l>=0)
        {
        
            DWORD dwDeviceID = (DWORD) l;
            TSPRETURN tspRet = g.pTspDevMgr->TspDevFromLINEID(
                                    dwDeviceID,
                                    &pDev,
                                    &hSession
                                    );
        
            psl->SetDeviceID(dwDeviceID);
        
            if (tspRet)
            {
                FL_SET_RFR(0x73c88c00, "Couldn't find device");
            }
            else
            {
                pDev->DumpState(
                                psl
                                );
                pDev->EndSession(hSession);
                hSession=0;
            }
        }
        else
        {
            switch(-l)
            {
            case 1:
                g.pTspDevMgr->DumpState(psl);
                break;

            case 2:     // toggle logging mode.
                {
                    // TODO clean this up!
                    if (g_fDoLog)
                    {
                        SLPRINTF0(psl, "Logging DISABLED");
                        g_fDoLog=FALSE;
                    }
                    else
                    {
                        AllocConsole();
                        g_fDoLog=TRUE;
                        SLPRINTF0(psl, "Logging ENABLED");
                    }
                }
                break;

            case 3:
                g_fDoLog = FALSE;
                FreeConsole ();
                break;

            default:
                break;
            }
        }
    }

end:
    
    if (hMgrSession)
    {
        g.pTspDevMgr->EndSession(hMgrSession);
        
    }

    FL_LOG_EXIT(psl, 0);

    return;
}


DWORD
APIENTRY
tepAPC (void *pv)
//
// This is the thread entry point for the main APC thread for the TSP. This
// thread is the workhorse thread in whose context most things happen.
// It is created by the device factory (cfact.cpp) when the factory is loaded,
// and asked to terminate when the factory is unloaded. The thread info (pv)
// is a pointer to a boolean value which is set to TRUE to make
// the thread exit (see below).
//
// In addition to servicing APC calls, the thread also handles external
// notifications to the TSP (see below).
//
{
 FL_DECLARE_FUNC(0x1ba6fc2d, "tepAPC")
 BOOL *pfQuit = (BOOL *)pv;
 DWORD dwRet;

    ASSERT(pfQuit);

    //
    // Create a notification server object to receive notifications from
    // outside (typically requests to reenumerate the modem after a PnP event,
    // and also diagnostic-related requests).
    //
    HNOTIFCHANNEL hChannel = notifCreateChannel (SLOTNAME_UNIMODEM_NOTIFY_TSP,
                                                 MAX_NOTIFICATION_FRAME_SIZE,
                                                 10);

    if (NULL != hChannel)
    {
        dwRet = notifMonitorChannel (hChannel,
                                     process_notification,
                                     sizeof (*pfQuit),
                                     pfQuit);
        notifCloseChannel (hChannel);
        if (NO_ERROR == dwRet)
        {
            goto _Exit;
        }
    }

    // We get here if either we couldn't open the channel
    // or we couldn't monitor it; either way, just wait for
    // APCs to come by.
    while (!*pfQuit)
    {
        FL_DECLARE_STACKLOG(sl, 1000);

        SLPRINTF1(&sl, "Going to SleepEx at tc=%lu", GetTickCount());

        SleepEx(INFINITE, TRUE);

        SLPRINTF1(&sl, "SleepEx return at tc=%lu", GetTickCount());
    
        sl.Dump(FOREGROUND_BLUE|BACKGROUND_RED|BACKGROUND_GREEN|BACKGROUND_BLUE);
    }

_Exit:
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\tsp\idfrom.h ===
// 
// Copyright (c) 1996-1997 Microsoft Corporation.
//
//
// Component
//
//		Unimodem 5.0 TSP (Win32, user mode DLL)
//
// File
//
//		IDFROM.H
//		Defines the IDFROM_ values. These are 16-bit constants.
//
// History
//
//		11/23/1996  JosephJ Created
//
//

//
// BASE IDs
//

// The following base IDs have 2^12 or 4096 slots assigned to them.
#define IDFROM_GLOBAL_BASE					0x0000
#define IDFROM_TSPIFN_BASE					0x1000
#define IDFROM_CTspDevMgr_BASE				0x2000
#define IDFROM_CTspDevFactory_BASE			0x3000
#define IDFROM_CTspDev_BASE				    0x4000
#define IDFROM_CTspMiniDriver_BASE		    0x5000

// The following base IDs have 2^8 or 256 slots assigned to them.
#define IDFROM_CSync_BASE					0xFF00U
#define IDFROM_CAPC_BASE					0xFE00U
#define IDFROM_CAPCMgr_BASE					0xFD00U


// TSPI_line*
#define IDFROM_TSPI_lineAccept				(IDFROM_TSPIFN_BASE+(    10))
#define IDFROM_TSPI_lineAccept				(IDFROM_TSPIFN_BASE+(    10))
#define IDFROM_TSPI_lineAnswer				(IDFROM_TSPIFN_BASE+(    20))
#define IDFROM_TSPI_lineClose				(IDFROM_TSPIFN_BASE+(    30))
#define IDFROM_TSPI_lineCloseCall			(IDFROM_TSPIFN_BASE+(    40))
#define IDFROM_TSPI_lineConditionalMediaDetection	(IDFROM_TSPIFN_BASE+(    50))
#define IDFROM_TSPI_lineDial				(IDFROM_TSPIFN_BASE+(    60))
#define IDFROM_TSPI_lineDrop				(IDFROM_TSPIFN_BASE+(    70))
#define IDFROM_TSPI_lineDropOnClose			(IDFROM_TSPIFN_BASE+(    80))
#define IDFROM_TSPI_lineGetAddressCaps		(IDFROM_TSPIFN_BASE+(    90))
#define IDFROM_TSPI_lineGetAddressStatus	(IDFROM_TSPIFN_BASE+(   100))
#define IDFROM_TSPI_lineGetCallAddressID	(IDFROM_TSPIFN_BASE+(   110))
#define IDFROM_TSPI_lineGetCallInfo			(IDFROM_TSPIFN_BASE+(   120))
#define IDFROM_TSPI_lineGetCallStatus		(IDFROM_TSPIFN_BASE+(   130))
#define IDFROM_TSPI_lineGetDevCaps			(IDFROM_TSPIFN_BASE+(   140))
#define IDFROM_TSPI_lineGetDevConfig		(IDFROM_TSPIFN_BASE+(   150))
#define IDFROM_TSPI_lineGetIcon				(IDFROM_TSPIFN_BASE+(   160))
#define IDFROM_TSPI_lineGetID				(IDFROM_TSPIFN_BASE+(   170))
#define IDFROM_TSPI_lineGetLineDevStatus	(IDFROM_TSPIFN_BASE+(   180))
#define IDFROM_TSPI_lineGetNumAddressIDs	(IDFROM_TSPIFN_BASE+(   190))
#define IDFROM_TSPI_lineMakeCall			(IDFROM_TSPIFN_BASE+(   200))
#define IDFROM_TSPI_lineNegotiateTSPIVersion (IDFROM_TSPIFN_BASE+(   210))
#define IDFROM_TSPI_lineOpen				(IDFROM_TSPIFN_BASE+(   220))
#define IDFROM_TSPI_lineSetAppSpecific		(IDFROM_TSPIFN_BASE+(   230))
#define IDFROM_TSPI_lineSetCallParams		(IDFROM_TSPIFN_BASE+(   240))
#define IDFROM_TSPI_lineSetDefaultMediaDetection	(IDFROM_TSPIFN_BASE+(   250))
#define IDFROM_TSPI_lineSetDevConfig		(IDFROM_TSPIFN_BASE+(   260))
#define IDFROM_TSPI_lineSetMediaMode		(IDFROM_TSPIFN_BASE+(   270))
#define IDFROM_TSPI_lineSetStatusMessages	(IDFROM_TSPIFN_BASE+(   280))

// TSPI_provider*
#define IDFROM_TSPI_providerConfig			(IDFROM_TSPIFN_BASE+(   500))
#define IDFROM_TSPI_providerCreateLineDevice (IDFROM_TSPIFN_BASE+(   510))
#define IDFROM_TSPI_providerEnumDevices		(IDFROM_TSPIFN_BASE+(   520))
#define IDFROM_TSPI_providerFreeDialogInstance (IDFROM_TSPIFN_BASE+(   530))
#define IDFROM_TSPI_providerGenericDialogData (IDFROM_TSPIFN_BASE+(   540))
#define IDFROM_TSPI_providerInit			(IDFROM_TSPIFN_BASE+(   550))
#define IDFROM_TSPI_providerInstall			(IDFROM_TSPIFN_BASE+(   560))
#define IDFROM_TSPI_providerRemove			(IDFROM_TSPIFN_BASE+(   570))
#define IDFROM_TSPI_providerShutdown		(IDFROM_TSPIFN_BASE+(   580))
#define IDFROM_TSPI_providerUIIdentify		(IDFROM_TSPIFN_BASE+(   590))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\tsp\parsdiag.cpp ===
// 
// Copyright (c) 1996-1997 Microsoft Corporation.
//
//
// Component
//
//		Unimodem 5.0 TSP (Win32, user mode DLL)
//
// File
//
//		PARSDIAG.CPP
//		Implements code to extract parsed diagnostic information from the
//      the raw "AT#UD" information.
//
// History
//
//		4/0/98 JosephJ <- Copied over from the extension DLL (This code
//             was written by CostelR (sorin).
//
//

#include "tsppch.h"
#include "tspcomm.h"
#include	"ParsDiag.h"

/**********************************************************************************/
//	BOOL	SkipSpaces(LPBYTE lpInputBuffer, LPDWORD lpInputIndex, 
//						DWORD dwLengthToParse)
//
//	Skips the spaces and stop to the first not space character
//	*lpInputIndex will contain the current index position
//	Parameters
//		lpszInputBuffer	- buffer to parse
//		lpdwInputIndex	- current position in the buffer (changed at output)
//		dwLengthToParse	- length of the buffer
//	Returns FALSE if reached the end of of the buffer
//
/**********************************************************************************/
BOOL	SkipSpaces(LPBYTE lpszInputBuffer, LPDWORD lpdwInputIndex,
					DWORD dwLengthToParse)
{
	while ((*lpdwInputIndex < dwLengthToParse) && 
			(lpszInputBuffer[*lpdwInputIndex] == DIAG_DELIMITER_SPACE))	// skip any spaces
	{	(*lpdwInputIndex)++;		}

	return (*lpdwInputIndex < dwLengthToParse);
}

/**********************************************************************************/
//	DWORD	NextPair(LPBYTE lpszInputBuffer, LPDWORD lpdwLengthParsed,
//				 LPVARBUFFER lpKeyString, LPVARBUFFER lpValueString)
//
//	Parse the input string and find the next pair (key, value).
//	The format looking for is 'key = value'. The trailing and inner spaces
//	are ignored.
//	delimiters = '=', '<', '>', '\0' or SPACE
//	key = consecutive characters not containing a delimiter
//	value = consecutive characters not containing a delimiter or
//			a quoted string not containing delimiters
//	Parameters:
//		lpszInputBuffer		- input buffer (NULL terminated)
//		lpdwLengthParsed	- pointer to a DWORD value that
//							  on return will contain the length parsed
//		lpKeyString			- pointer to a valid VARBUFFER structure that will 
//								contain the "key" (null terminated)
//		lpValueString		- pointer to a valid VARBUFFER structure that will 
//								contain the "value"  (null terminated)
//	Returns ERROR_DIAG_SUCCESS on success
//		otherwise an error value: 
//					ERROR_DIAG_INVALID_PARAMETER, 
//					ERROR_DIAG_XXXX (if the format of the input buffer is bad, 
//						*lpLengthToParse updated and  lpKeyString, 
//						lpValueString  contain partial results)
//					ERROR_DIAG_VALUE_TOO_LONG or ERROR_DIAG_KEY_TOO_LONG
//						(output buffers are too small, *lpLengthToParse not changed,
//						lpKeyString->dwNeededSize and lpValueString->dwNeededSize contain
//						the required length)
//
/**********************************************************************************/
DWORD	NextPair(LPBYTE lpszInputBuffer, LPDWORD lpdwLengthParsed,
				 LPVARBUFFER lpKeyString, LPVARBUFFER lpValueString)
{
	DWORD	dwLengthToParse	= 0;
	DWORD	dwInputIndex	= 0;	// current pos in input buffer
	LPBYTE	lpszNextDelimiter	= 0;	// pointer to the next delimiter in the input buffer

	DWORD	dwKeyIndex		= 0;	// current pos in Key buffer
	DWORD	dwKeyUsedLength	= 0;
	DWORD	dwKeyLength		= 0;

	DWORD	dwValueIndex	= 0;	// current pos in Value buffer
	DWORD	dwValueUsedLength	= 0;
	DWORD	dwValueLength	= 0;

	DWORD	dwReturnValue	= ERROR_DIAG_SUCCESS;
	BOOL	bAllCharsCopied	= FALSE;
	BOOL	bQuoteString	= FALSE;

	if (lpszInputBuffer == NULL || lpdwLengthParsed == NULL || 
		lpValueString == NULL || lpKeyString == NULL)
		return ERROR_DIAG_INVALID_PARAMETER;

	//	input buffer initialization
	dwLengthToParse	= strlen((char *)lpszInputBuffer);
	dwInputIndex	= 0;

	//	output buffer initialization
	dwKeyIndex		= 0;
	dwValueIndex	= 0;
	lpKeyString->dwNeededSize = 0;
	lpValueString->dwNeededSize = 0;

	if (!SkipSpaces(lpszInputBuffer, 
					&dwInputIndex, dwLengthToParse))	// skip any leading spaces
	{
		dwReturnValue	= ERROR_DIAG_EMPTY_PAIR;
		goto EndFunction;
	}

	//	collect the key up to the next delimiter
	lpszNextDelimiter	= (LPBYTE) strpbrk((char *)(lpszInputBuffer + dwInputIndex),
									DIAG_DELIMITERS);

	if (lpszNextDelimiter == NULL)	//	end of the bufffer
		dwKeyLength = dwLengthToParse - dwInputIndex;
	else
		dwKeyLength = (DWORD)(lpszNextDelimiter - lpszInputBuffer) - dwInputIndex;

	//	copy in the output buffer
	if (lpKeyString->dwBufferSize > 0 && 
		lpKeyString->lpBuffer != NULL)
	{
		DWORD	dwLengthToCopy	= 0;

		dwLengthToCopy = min(dwKeyLength, 
							 lpKeyString->dwBufferSize - dwKeyIndex - 1);
						// room for the null char

		if (dwLengthToCopy > 0)
		{
			strncpy((char *)&(lpKeyString->lpBuffer[dwKeyIndex]),
					 (char *)&lpszInputBuffer[dwInputIndex],
					 dwLengthToCopy);

			lpKeyString->lpBuffer[dwKeyIndex+dwLengthToCopy] = 0;	// null char
			dwKeyUsedLength	= dwLengthToCopy;
		}
	}
	if (dwKeyLength == 0)
	{
		dwReturnValue = ERROR_DIAG_KEY_MISSING;
		//	assume key is empty and go further
	}
	dwKeyIndex		+= dwKeyLength;
	dwInputIndex	+= dwKeyLength;


	//	find the '=' sign
	//	skip the spaces and look for '=' that separates the key and value
	if (!SkipSpaces(lpszInputBuffer, 
					&dwInputIndex, dwLengthToParse))
	{
		dwReturnValue	= ERROR_DIAG_SEPARATOR_MISSING;
		goto EndFunction;
	}

	if (lpszInputBuffer[dwInputIndex] != DIAG_DELIMITER_PAIR)
	{									// '=' not found, but still look for
										// the value
		dwReturnValue	= ERROR_DIAG_SEPARATOR_MISSING;
	}
	else
	{
		dwInputIndex++;
			// Skip next spaces
		if (!SkipSpaces(lpszInputBuffer, 
						&dwInputIndex, dwLengthToParse))
		{
			dwReturnValue	= ERROR_DIAG_VALUE_MISSING;
			goto EndFunction;
		}
	}

	// Get the value (that might be a string in quotes)
	bQuoteString = (lpszInputBuffer[dwInputIndex] == DIAG_DELIMITER_QUOTE);

	lpszNextDelimiter	= (LPBYTE) strpbrk((char *) (lpszInputBuffer + dwInputIndex + 
											((bQuoteString) ? 1 : 0)),	// skip first quote
											((bQuoteString) ? 
											DIAG_DELIMITERS_NOT_SPACE : DIAG_DELIMITERS));

	//	include both quotes in the value
	if (bQuoteString)
	{
		if (lpszNextDelimiter != NULL && 
			*lpszNextDelimiter == DIAG_DELIMITER_QUOTE)
			lpszNextDelimiter++;
		else
			dwReturnValue	= ERROR_DIAG_QUOTE_MISSING;
	}

	if (lpszNextDelimiter == NULL)	//	end of the bufffer
		dwValueLength = dwLengthToParse - dwInputIndex;
	else
		dwValueLength = (DWORD)(lpszNextDelimiter - lpszInputBuffer) - dwInputIndex;

	//	copy in the output buffer
	if (lpValueString->dwBufferSize > 0 && 
		lpValueString->lpBuffer != NULL)
	{
		DWORD	dwLengthToCopy	= 0;

		dwLengthToCopy = min(dwValueLength, 
							 lpValueString->dwBufferSize - dwValueIndex - 1);
						// room for the null char

		if (dwLengthToCopy > 0)
		{
			strncpy((char *)&(lpValueString->lpBuffer[dwValueIndex]),
					 (char *)&lpszInputBuffer[dwInputIndex],
					 dwLengthToCopy);
			lpValueString->lpBuffer[dwValueIndex+dwLengthToCopy] = 0; // null char
			dwValueUsedLength	= dwLengthToCopy;
		}
	}
	if (dwValueLength == 0)
	{
		dwReturnValue = ERROR_DIAG_VALUE_MISSING;
		//	assume value is empty and go further
	}
	dwValueIndex	+= dwValueLength;
	dwInputIndex	+= dwValueLength;


EndFunction:
	// NULL terminated strings
	if (dwKeyIndex < lpKeyString->dwBufferSize &&
		lpKeyString->lpBuffer != NULL)
	{
		lpKeyString->lpBuffer[dwKeyIndex] = 0;
		dwKeyUsedLength++;
	}
	dwKeyIndex++;

	if (dwValueIndex < lpValueString->dwBufferSize &&
		lpValueString->lpBuffer != NULL)
	{
		lpValueString->lpBuffer[dwValueIndex] = 0;
		dwValueUsedLength++;
	}
	dwValueIndex++;

	//	update the output parameters
	lpKeyString->dwNeededSize	= dwKeyIndex;
	lpValueString->dwNeededSize	= dwValueIndex;
	*lpdwLengthParsed			= dwInputIndex;		// the parsed length

	if (dwKeyIndex > dwKeyUsedLength)
		dwReturnValue	= ERROR_DIAG_KEY_TOO_LONG;
	if (dwValueIndex > dwValueUsedLength)
		dwReturnValue	= ERROR_DIAG_VALUE_TOO_LONG;
		
	return dwReturnValue;
}


/**********************************************************************************/
//	DWORD	ParseHexValue(LPBYTE lpszInput, LPDWORD lpdwValue)
//
//	Verify a string to be hex digits and convert it to a dword value.
//	Returns ERROR_DIAG_SUCCESS on success
//		otherwise an error value: 
//					ERROR_DIAG_XXXX
//
/**********************************************************************************/
DWORD	ParseHexValue(LPBYTE lpszInput, LPDWORD lpdwValue)
{
	LPBYTE	lpszCurrent;

	if (lpszInput == NULL || lpdwValue == NULL)
		return ERROR_DIAG_INVALID_PARAMETER;

			// empty string
	if (lpszInput[0] == 0)
		return ERROR_DIAG_INVALID_PARAMETER;

			// hex values
	lpszCurrent = lpszInput;
	while (*lpszCurrent)
	{
		if (!isxdigit(*lpszCurrent))
			return ERROR_DIAG_HEXDIGIT_EXPECTED;
		lpszCurrent++;
	}

	if (sscanf((char *)lpszInput, "%lx", lpdwValue) != 1)
		return ERROR_DIAG_HEXVALUE_CONVERSION;

	return ERROR_DIAG_SUCCESS;
}


/**********************************************************************************/
//	DWORD	ParseStrValue(LPBYTE lpszInput, LPBYTE lpszBuffer, DWORD dwBufferLength,
//						  LPDWORD lpdwRequiredLength)
//
//	Verify the input string to be in a valid string format
//	The string is copied to lpszBuffer after first and last quote are removed
//	and special characters '"', '<', '>', '=' with high bit set are transformed.
//	If not enough space (to include also the null char) the needed length is
//	returned via lpdwRequiredLength
//	Returns ERROR_DIAG_SUCCESS on success
//		otherwise an error value: 
//					ERROR_DIAG_XXXX
//
/**********************************************************************************/
DWORD	ParseStrValue(LPBYTE lpszInput, LPBYTE lpszBuffer, DWORD dwBufferLength,
					  LPDWORD lpdwRequiredLength)
{
	LPBYTE	lpszCurrent;
	DWORD	dwPosBuffer;
	DWORD	dwNeededLength	= 0;
	DWORD	dwReturnError	= ERROR_DIAG_SUCCESS;
	BYTE	szSpecialChars[sizeof(DIAG_DELIMITERS_NOT_SPACE)+1];
	BYTE	*lpchSpecial;

	if (lpszInput == NULL)
		goto EndFunction;

	//	build special character set
	strcpy((char *)szSpecialChars, DIAG_DELIMITERS_NOT_SPACE);
	
	for (lpchSpecial = szSpecialChars; *lpchSpecial; lpchSpecial++)
	{
		*lpchSpecial |= 1 << (sizeof(BYTE)*8-1);
	}

			// check for the first quote
	if (lpszInput[0] != DIAG_DELIMITER_QUOTE)
		return ERROR_DIAG_QUOTE_MISSING;

	dwNeededLength	= 0;
	dwPosBuffer		= 0;
	//	skip first quote
	lpszCurrent	= &lpszInput[1];
	while (*lpszCurrent)
	{
		//	end of the string
		if (*lpszCurrent == DIAG_DELIMITER_QUOTE)
			break;

		if (lpszBuffer != NULL && dwPosBuffer < dwBufferLength)
		{
			if (strchr((char *)szSpecialChars, *lpszCurrent) != NULL)
			{		// special char, need translation
				lpszBuffer[dwPosBuffer] = (*lpszCurrent & 
											(BYTE)~(1 << (sizeof(BYTE)*8-1)));
			}
			else
				lpszBuffer[dwPosBuffer] = *lpszCurrent;
			dwPosBuffer++;
		}

		dwNeededLength++;
		lpszCurrent++;
	}

	//	add null character
	if (lpszBuffer != NULL && dwPosBuffer < dwBufferLength)
	{
		lpszBuffer[dwPosBuffer] = 0;
		dwPosBuffer++;
	}
	dwNeededLength++;

	if (dwNeededLength > dwPosBuffer)
		dwReturnError = ERROR_DIAG_INSUFFICIENT_BUFFER;

EndFunction:

	if (lpdwRequiredLength != NULL)
	{
		*lpdwRequiredLength	= dwNeededLength;
	}


	return dwReturnError;
}

/**********************************************************************************/
//	DWORD	TranslatePair(LPBYTE lpszKey, LPBYTE lpszValue,
//						  LINEDIAGNOSTICS_PARSEREC *lpParseRec, 
//						  LPBYTE lpszBuffer, DWORD dwBufferLength,
//						  LPDWORD lpdwRequiredLength)
//
//	Translate a pair (szKey, szValue) into a LINEDIAGNOSTICS_PARSEREC 
//	structure. Two sorts of Values are accepted: hexa digits and strings
//	The hexa strings are converted to numbers an placed in dwValue of
//	LINEDIAGNOSTICS_PARSEREC. 
//	The strings values must start with a quote. First and last quote
//	are removed, the special characters '"', '<', '>', '=' previously encoded
//	with the highest bit set are translated to normal chars. The string is
//	stored in lpszBuffer adding a null character at the end and the value of 
//	lpszBuffer is placed in dwValue of LINEDIAGNOSTICS_PARSEREC. If the buffer is 
//	too small, the needed amount is returned via lpdwRequiredLength.
//
//	lpszKey				- null terminated string containing the key
//	lpszValue			- null terminated string containing the value
//	lpParseRec			- output structure containing the translation
//	lpszBuffer			- additional output buffer to store string values
//	dwBufferLength		- length of the output buffer
//	lpdwRequiredLength	- pointer of a dword value to receive the amount of memory
//							needed to store the string value
//
//	Returns ERROR_DIAG_SUCCESS on success
//		otherwise an error value: 
//					ERROR_DIAG_XXXX
//
/**********************************************************************************/

DWORD	TranslatePair(LPBYTE lpszKey, LPBYTE lpszValue,
					  LINEDIAGNOSTICS_PARSEREC *lpParseRec,
					  LPBYTE lpszBuffer, DWORD dwOffsetFromStart, DWORD dwBufferLength,
					  LPDWORD lpdwRequiredLength)
{
	DWORD	dwKey	= 0;
	DWORD	dwValue	= 0;
	DWORD	dwValueType	= 0;
	DWORD	dwNeededLength	= 0;
	DWORD	dwReturnValue	= ERROR_DIAG_SUCCESS;

	if (lpszKey == NULL || lpszValue == NULL)
		return ERROR_DIAG_INVALID_PARAMETER;

		// Get hex value for the key
	if ((dwReturnValue = ParseHexValue(lpszKey, &dwKey)) != ERROR_DIAG_SUCCESS)
		goto EndFunction;

		// Convert the Value to number, if not a string Value
	if (lpszValue[0] != DIAG_DELIMITER_QUOTE)
	{
		dwValueType	= fPARSEKEYVALUE_INTEGER;
		if ((dwReturnValue = ParseHexValue(lpszValue, &dwValue)) != ERROR_DIAG_SUCCESS)
			goto EndFunction;
	}
	else
	{
		//	the LINEDIAGNOSTICS_PARSEREC.dwValue will be set to the given buffer
		dwValue	    = dwOffsetFromStart;
		dwValueType	= fPARSEKEYVALUE_ASCIIZ_STRING;
		if ((dwReturnValue = ParseStrValue(lpszValue, lpszBuffer+dwOffsetFromStart,
											dwBufferLength, &dwNeededLength))
					!= ERROR_DIAG_SUCCESS)
			goto EndFunction;
	}

EndFunction:

	//	fill the output diag structure
	if (lpParseRec != NULL)
	{
		//	for key 0x00 we have a special format hh (version : major.minor) 
		//	for modem diagnostics
		//	TO BE CHANGED: if version specification changes to strings
		if (dwKey == 0 &&
			lpParseRec->dwKeyType == MODEM_KEYTYPE_STANDARD_DIAGNOSTICS)
		{
			//	input is hh, first digit is major second is minor
			dwValue	= ((dwValue/16) << (sizeof(DWORD) * 4))	//	major goes to hiword
					  | (dwValue % 16);						//	minor goes to loword
		}

		lpParseRec->dwKey	= dwKey;
		lpParseRec->dwValue	= dwValue;
		lpParseRec->dwFlags	= dwValueType;
	}

	//	return the needed length
	if (lpdwRequiredLength != NULL)
	{
		*lpdwRequiredLength	= dwNeededLength;
	}

	return dwReturnValue;
}


/**********************************************************************************/
//	DWORD	ParseRawDiagnostics(LPBYTE lpszRawDiagnostics,
//								LINEDIAGNOSTICSOBJECTHEADER *lpDiagnosticsHeader,
//								LPDWORD lpdwNeededSize)
//
//	Parses the raw diagnostics given in lpszRawDiagnostics and builds the
//	parsed structure whose header is lpDiagnosticsHeader structure. If
//	the size of the parsed structure is insufficient, the needed size is
//	returned using lpdwNeededSize.
//	
//	Syntax expected: <token key=value [key=value]...>
//	token and key are all consecutive hex digits. value can by either 
//	consecutive hex digits or strings enclosed by quotes not containing
//	the delimiters '"', '=', '<', '>'.
//	
//	lpDiagnosticsHeader is followed by an array of LINEDIAGNOSTICS_PARSEREC
//	containing the parsed varsion of keys and values. All spaces (not in strings)
//	are ignored and the consecutive hex digits values are converted to 
//	dwords and placed in the corresponding items of LINEDIAGNOSTICS_PARSEREC 
//	(dwKey, dwValue). The string values are placed after the array of LINEDIAGNOSTICS_PARSEREC 
//	and LINEDIAGNOSTICS_PARSEREC.dwValue is set to the offset from the start of 
//	the whole structure (lpDiagnosticsHeader).
//
//	lpszRawDiagnostics	- null terminated string containing the raw of information
//	lpDiagnosticsHeader	- pointer to the structure to be filled in with the parsed
//							information
//	lpdwDiagnosticsToken- pointer of a dword value to receive the diagnostics token
//	lpdwNeededSize		- pointer of a dword value to receive the amount of memory
//							needed to store the parsed diagnostics
//
//	Returns ERROR_DIAG_SUCCESS on success
//		otherwise an error value: 
//					ERROR_DIAG_XXXX
//
/**********************************************************************************/
DWORD	ParseRawDiagnostics(LPBYTE lpszRawDiagnostics,
							LINEDIAGNOSTICSOBJECTHEADER *lpDiagnosticsHeader,
							LPDWORD lpdwNeededSize)
{
	VARBUFFER	structKeyBuffer;
	VARBUFFER	structValueBuffer;
	//	Temp string storage buffer
	VARBUFFER	structStringBuffer;

	LINEDIAGNOSTICS_PARSEREC	structParseRec;
	LINEDIAGNOSTICS_PARSEREC	*lpParsedDiagnostics;
	DWORD		dwAvailableSize;
	DWORD		dwNeededStringSize;		// needed string size, in bytes
	DWORD		dwVarStringSize;		// variable string size, in characters
	DWORD		dwCurrentPair;
	DWORD		dwTotalPairs;
	BOOL		bLineComplete;

	BYTE		szTokenBuffer[DIAG_MAX_TOKEN_LENGTH+1];
	DWORD		dwTokenLength;

	DWORD		dwResultError = ERROR_DIAG_SUCCESS;
	DWORD		dwRawLength;
	DWORD		dwRawPos;

	//	Key storage buffer
	memset(&structKeyBuffer, 0, sizeof(structKeyBuffer));
	//	Value storage buffer
	memset(&structValueBuffer, 0, sizeof(structValueBuffer));
	//	Temp string storage buffer
	memset(&structStringBuffer, 0, sizeof(structStringBuffer));

	if (lpszRawDiagnostics == NULL)
		return ERROR_DIAG_INVALID_PARAMETER;

	dwRawLength		= strlen((char *)lpszRawDiagnostics);

	//	Key storage buffer
	structKeyBuffer.lpBuffer		= (LPBYTE) ALLOCATE_MEMORY(dwRawLength + 1);
	if (structKeyBuffer.lpBuffer == NULL)
	{
		dwResultError = ERROR_DIAG_INSUFFICIENT_BUFFER;
		goto Cleanup;
	}
	structKeyBuffer.dwBufferSize	= dwRawLength + 1;

	//	Value storage buffer
	structValueBuffer.lpBuffer		= (LPBYTE) ALLOCATE_MEMORY(dwRawLength + 1);
	if (structValueBuffer.lpBuffer == NULL)
	{
		dwResultError = ERROR_DIAG_INSUFFICIENT_BUFFER;
		goto Cleanup;
	}
	structValueBuffer.dwBufferSize	= dwRawLength + 1;

	//	Temp string storage buffer
	structStringBuffer.lpBuffer		= (LPBYTE) ALLOCATE_MEMORY(dwRawLength + 1);
	if (structStringBuffer.lpBuffer == NULL)
	{
		dwResultError = ERROR_DIAG_INSUFFICIENT_BUFFER;
		goto Cleanup;
	}
	structStringBuffer.dwBufferSize	= dwRawLength + 1;

	memset(&structParseRec, 0, sizeof(structParseRec));
	if (lpDiagnosticsHeader == NULL || 
		lpDiagnosticsHeader->dwTotalSize <= sizeof(LINEDIAGNOSTICSOBJECTHEADER))
	{
		lpParsedDiagnostics = NULL;
		dwAvailableSize		= 0;
	}
	else
	{
		lpParsedDiagnostics = (LINEDIAGNOSTICS_PARSEREC*) (((LPBYTE)lpDiagnosticsHeader) + 
									sizeof(LINEDIAGNOSTICSOBJECTHEADER));
		dwAvailableSize		= lpDiagnosticsHeader->dwTotalSize -
									sizeof(LINEDIAGNOSTICSOBJECTHEADER);
	}
	dwVarStringSize	= 0;
	dwNeededStringSize	= 0;
	dwCurrentPair	= 0;
	dwTotalPairs	= 0;

	dwRawPos		= 0;

	while (dwRawPos < dwRawLength)
	{
		LPBYTE	lpszNextDelimiter;
		DWORD	dwDiagnosticsTag;
			// skip any leading spaces
		if (!SkipSpaces(lpszRawDiagnostics, 
						&dwRawPos, dwRawLength))
			//	end of string
			break;

		//	get the < delimiter
		if ((lpszNextDelimiter = (LPBYTE) strchr((char *)(lpszRawDiagnostics + dwRawPos), 
											DIAG_DELIMITER_START))
					== NULL)
		{
			dwResultError = ERROR_DIAG_LEFT_ANGLE_MISSING;
			break;
		}
		dwRawPos = (DWORD)(lpszNextDelimiter - lpszRawDiagnostics + 1);	// ++ delimiter

		if (!SkipSpaces(lpszRawDiagnostics, 
						&dwRawPos, dwRawLength))
			//	end of string
		{
			dwResultError = ERROR_DIAG_INCOMPLETE_LINE;
			break;
		}

		//	get the token, max 8 chars up to the next deleimiter
		lpszNextDelimiter	= (LPBYTE) strpbrk((char *)(lpszRawDiagnostics + dwRawPos),
										DIAG_DELIMITERS);

		if (lpszNextDelimiter == NULL)	//	end of the bufffer
			dwTokenLength = dwRawLength - dwRawPos;
		else
			dwTokenLength = (DWORD)(lpszNextDelimiter - lpszRawDiagnostics) - dwRawPos;

		//	copy the token, max 8 hex digits
		strncpy((char *)(szTokenBuffer), (char *)(lpszRawDiagnostics + dwRawPos),
				 min(dwTokenLength, DIAG_MAX_TOKEN_LENGTH)); 
		szTokenBuffer[min(dwTokenLength, DIAG_MAX_TOKEN_LENGTH)] = 0;	// null char

		dwRawPos += dwTokenLength;	// after token, raw of pairs

		//	get the token identifying the diagnostic type
		dwDiagnosticsTag	= 0;
		if ((dwResultError = ParseHexValue(szTokenBuffer, &dwDiagnosticsTag))
					!= ERROR_DIAG_SUCCESS)
		{
			//	skip up to the next <
			lpszNextDelimiter	= (LPBYTE) strchr((char *)(lpszRawDiagnostics + dwRawPos),
												  DIAG_DELIMITER_START);

			if (lpszNextDelimiter == NULL)	//	end of the bufffer
				dwRawPos = dwRawLength;
			else
				dwRawPos = (DWORD)(lpszNextDelimiter - lpszRawDiagnostics);

			continue;
		}

		bLineComplete	= FALSE;
		while (dwRawPos < dwRawLength)
		{
			DWORD	dwPairResult	= 0;
			DWORD	dwPairLength	= 0;
			DWORD	dwTranslateResult	= 0;
			DWORD	dwOffsetLength;	//	this is in chars

			//	look for the > delimiter (end of this line)
			bLineComplete	= TRUE;
			if (!SkipSpaces(lpszRawDiagnostics, 
							&dwRawPos, dwRawLength))
				//	end of string
			{
				dwResultError = ERROR_DIAG_INCOMPLETE_LINE;
				break;
			}
			if (lpszRawDiagnostics[dwRawPos] == DIAG_DELIMITER_START)
			{
				dwResultError = ERROR_DIAG_INCOMPLETE_LINE;
				break;
			}
			if (lpszRawDiagnostics[dwRawPos] == DIAG_DELIMITER_END)
			{
				dwRawPos++;
				break;
			}
			bLineComplete	= FALSE;

			//	get next valid pair
			dwPairResult = NextPair(lpszRawDiagnostics + dwRawPos, 
									&dwPairLength,
									&structKeyBuffer, &structValueBuffer);

			//	if error skip to the next < delimiter and break pair translation
			if (dwPairResult != ERROR_DIAG_SUCCESS)
			{
				//	TEMP: parse everything we can
				//	get next pair
				dwRawPos += dwPairLength;
				dwResultError = dwPairResult;
				continue;
			}

			//	NextPair should return either error or parse something
			ASSERT(dwPairLength != 0);
			dwRawPos += dwPairLength;

			//	Translate the pair
			memset(&structParseRec, 0, sizeof(structParseRec));

			structParseRec.dwKeyType	= dwDiagnosticsTag;
			dwOffsetLength = 0;

			dwTranslateResult	= 
				TranslatePair(structKeyBuffer.lpBuffer, structValueBuffer.lpBuffer,
							  &structParseRec, 
							  structStringBuffer.lpBuffer,
                              dwVarStringSize,
							  structStringBuffer.dwBufferSize - dwVarStringSize,
							  &dwOffsetLength);

			if (dwTranslateResult != ERROR_DIAG_SUCCESS)
			{
				//	get next pair
				dwResultError = dwTranslateResult;
				continue;
			}

			//	assert TranslatePair returns correct values
			ASSERT(structStringBuffer.dwBufferSize - dwVarStringSize 
						>= dwOffsetLength);

			if ((structParseRec.dwFlags & fPARSEKEYVALUE_ASCIIZ_STRING)
					== fPARSEKEYVALUE_ASCIIZ_STRING)
			{
				dwNeededStringSize += dwOffsetLength * sizeof(BYTE);
			}

			//	copy the new pair to the output if large enough to contain also the variable string part
			if (lpParsedDiagnostics != NULL &&
							//	available space is enough ?
				(dwAvailableSize >= sizeof(LINEDIAGNOSTICS_PARSEREC)*(dwCurrentPair + 1)
							+ dwVarStringSize*sizeof(BYTE) + 
							(((structParseRec.dwFlags & fPARSEKEYVALUE_ASCIIZ_STRING)
									== fPARSEKEYVALUE_ASCIIZ_STRING) ? 
									dwOffsetLength*sizeof(BYTE) : 0) ) )
			{
				//	copy LINEDIAGNOSTICS_PARSEREC structure
				CopyMemory(lpParsedDiagnostics + dwCurrentPair,
							&structParseRec, sizeof(structParseRec));

				dwVarStringSize	+= dwOffsetLength;
				dwCurrentPair++;
			}
			dwTotalPairs++;

		}	// pair translation
		if (!bLineComplete)
		{
			dwResultError = ERROR_DIAG_INCOMPLETE_LINE;
		}
	}	// <line> parsing

	//	parsing done, finish building the output structure
	//	strings needs to be copied from temporary buffer

	if (lpdwNeededSize != NULL)
	{
		*lpdwNeededSize	= sizeof(LINEDIAGNOSTICSOBJECTHEADER) + 
							dwTotalPairs*sizeof(LINEDIAGNOSTICS_PARSEREC) + 
							dwNeededStringSize;
	}

	if (lpDiagnosticsHeader != NULL)
	{
		lpDiagnosticsHeader->dwParam = dwCurrentPair;
	}

	//	copy variable part from structStringBuffer.lpBuffer to lpParsedDiagnostics
	//	and update the offset.
	if (lpParsedDiagnostics != NULL)
	{
		DWORD	dwIndexPair;
		LPBYTE	lpszBuffer;
		LPBYTE	lpszVarStringPart;

		ASSERT(dwAvailableSize >= 
				sizeof(LINEDIAGNOSTICS_PARSEREC)*dwCurrentPair + 
				dwVarStringSize*sizeof(BYTE));

		lpszVarStringPart	= (LPBYTE)&lpParsedDiagnostics[dwCurrentPair];	// after last pair

		for (dwIndexPair = 0; dwIndexPair < dwCurrentPair; dwIndexPair++)
		{
			if ((lpParsedDiagnostics[dwIndexPair].dwFlags & fPARSEKEYVALUE_ASCIIZ_STRING) 
					== fPARSEKEYVALUE_ASCIIZ_STRING)
			{
				lpszBuffer	= (LPBYTE)structStringBuffer.lpBuffer+(lpParsedDiagnostics[dwIndexPair].dwValue);

				lpParsedDiagnostics[dwIndexPair].dwValue = 
						(DWORD)((LPBYTE)lpszVarStringPart - (LPBYTE)lpDiagnosticsHeader);

				strcpy((char *)lpszVarStringPart, (char *)lpszBuffer);
				lpszVarStringPart	+= strlen((char *)lpszBuffer) + 1;
			}
		}
	}

Cleanup:
	if (structKeyBuffer.lpBuffer != NULL)
    {
		FREE_MEMORY(structKeyBuffer.lpBuffer);
    }

	if (structValueBuffer.lpBuffer != NULL)
    {
		FREE_MEMORY(structValueBuffer.lpBuffer);
    }

	if (structStringBuffer.lpBuffer != NULL)
    {
		FREE_MEMORY(structStringBuffer.lpBuffer);
    }

	return dwResultError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\tsp\rcids.h ===
//****************************************************************************
//
//  Module:     Unimdm
//  File:       rcids.h
//  Content:    This file contain all the declaration for device setting
//              resource ID
//
//  Copyright (c) 1992-1993, Microsoft Corporation, all rights reserved
//
//  History:
//      Wed 15-Jun-1993 10:38:00  -by-  Nick    Manson      [t-nickm]
//      Fri 09-Apr-1993 14:41:01  -by-  Viroon  Touranachun [viroont]
//
//****************************************************************************

#ifndef _RCIDS_
#define _RCIDS_

#define MAXTITLE        32
#define MAXMESSAGE      256

//*****************************************************************************
// Icon ID number section
//*****************************************************************************

#define IDI_ICON        100
#define IDI_NULL        101
#define IDI_EXT_MDM     102
#define IDI_INT_MDM     103
#define IDI_PCM_MDM     104

// Terminal Mode Setting
//
#define IDD_TERMINALSETTING     1000
#define IDC_TERMINAL_PRE        (IDD_TERMINALSETTING)
#define IDC_TERMINAL_POST       (IDD_TERMINALSETTING+1)
#define IDC_MANUAL_DIAL         (IDD_TERMINALSETTING+2)
#define IDC_LAUNCH_LIGHTS       (IDD_TERMINALSETTING+3)
#define IDC_TERMINALGRP         (IDD_TERMINALSETTING+4)
#define IDC_MANUAL_DIALGRP      (IDD_TERMINALSETTING+5)
#define IDC_LAUNCH_LIGHTSGRP    (IDD_TERMINALSETTING+6)
#define IDC_WAIT_TEXT           (IDD_TERMINALSETTING+7)
#define IDC_WAIT_SEC            (IDD_TERMINALSETTING+8)
#define IDC_WAIT_SEC_ARRW       (IDD_TERMINALSETTING+9)
#define IDC_WAIT_UNIT           (IDD_TERMINALSETTING+10)
#define IDC_PHONENUMBER         (IDD_TERMINALSETTING+11)

#define IDD_TERMINALDLG         1150
#define CID_T_EB_SCREEN         (IDD_TERMINALDLG)
#define CID_T_PB_ENTER          (IDD_TERMINALDLG+1)

// Talk Drop Dialog
//
#define IDD_TALKDROP            1300
#define IDTALK                  (IDD_TALKDROP)
#define IDDROP                  (IDD_TALKDROP+1)

// Manual Dial Dialog
//
#define IDD_MANUAL_DIAL         1400
#define IDCONNECT               (IDD_MANUAL_DIAL)

// Resources
//
#define ID_STRING_BASE      100
#define ID_PROVIDER_INFO    ID_STRING_BASE+0
#define IDS_PRETERM_TITLE   ID_STRING_BASE+1
#define IDS_POSTTERM_TITLE  ID_STRING_BASE+2

#define IDS_ERR_TITLE       1000
#define IDS_ERR_INSTALLED   IDS_ERR_TITLE+1
#define IDS_ERR_INV_WAIT    IDS_ERR_TITLE+2


#endif //_RCIDS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\tsp\parsdiag.h ===
#ifndef	PARSDIAG_H
#define	PARSDIAG_H

typedef	struct tagVARBUFFER
{
	LPBYTE	lpBuffer;
	DWORD	dwBufferSize;
	DWORD	dwNeededSize;
}	VARBUFFER, *LPVARBUFFER;

#define	DIAG_DELIMITER_SPACE		(0x20)			// space
#define	DIAG_DELIMITER_START		(0x3C)			// <
#define	DIAG_DELIMITER_END			(0x3E)			// >
#define	DIAG_DELIMITER_PAIR			(0x3D)			// =
#define	DIAG_DELIMITER_QUOTE		(0x22)			// "

#define DIAG_DELIMITERS				("\" <>=")	//	all delimiters in a string
#define DIAG_DELIMITERS_NOT_SPACE	("\"<>=")		//	all delimiters in a string except space

#define	DIAG_MAX_TOKEN_LENGTH			8

#define	ERROR_DIAG_SUCCESS				0x00
#define	ERROR_DIAG_INVALID_PARAMETER	0x01
#define	ERROR_DIAG_INSUFFICIENT_BUFFER	0x02
#define	ERROR_DIAG_KEY_UNKNOWN			0x03
#define	ERROR_DIAG_VALUE_WRONG_FORMAT	0x04
#define	ERROR_DIAG_EMPTY_PAIR			0x05
#define	ERROR_DIAG_KEY_MISSING			0x06
#define	ERROR_DIAG_SEPARATOR_MISSING	0x07
#define	ERROR_DIAG_VALUE_MISSING		0x08
#define	ERROR_DIAG_HEXDIGIT_EXPECTED	0x09
#define	ERROR_DIAG_HEXVALUE_CONVERSION	0x0a
#define	ERROR_DIAG_QUOTE_MISSING		0x0b
#define	ERROR_DIAG_TAGVALUE_WRONG		0x0c
#define	ERROR_DIAG_LEFT_ANGLE_MISSING	0x0d
#define	ERROR_DIAG_INCOMPLETE_LINE		0x0e
#define	ERROR_DIAG_KEY_TOO_LONG			0x0f
#define	ERROR_DIAG_VALUE_TOO_LONG		0x10


DWORD	NextPair(LPBYTE lpszInputBuffer, LPDWORD lpdwLengthParsed,
				 LPVARBUFFER lpKeyString, LPVARBUFFER lpValueString);

BOOL	SkipSpaces(LPBYTE lpszInputBuffer, LPDWORD lpdwInputIndex,
					DWORD dwLengthToParse);

DWORD	TranslatePair(LPBYTE lpszKey, LPBYTE lpszValue,
					  LINEDIAGNOSTICS_PARSEREC *lpParseRec,
					  LPBYTE lpszBuffer, DWORD dwBufferLength,
					  LPDWORD lpdwRequiredLength);

DWORD	ParseRawDiagnostics(LPBYTE lpszRawDiagnostics,
							LINEDIAGNOSTICSOBJECTHEADER *lpDiagnosticsHeader,
							LPDWORD lpdwNeededSize);

#endif	//	PARSDIAG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\tsp\public.h ===
// 
// Copyright (c) 1996-1997 Microsoft Corporation.
//
//
// Component
//
//		Unimodem 5.0 TSP (Win32, user mode DLL)
//
// File
//
//		PUBLIC.H
//		Misc stuff that needs to be put in the win32 sdk.
//
// History
//
//		04/05/1997  JosephJ Created, taking stuff from app.h, cdev.cpp, etc..
//
//

// Unimodem Service provider settings (from nt4.0 tapisp\umdmspi.h)
// (also cdev.h).
#define TERMINAL_NONE       0x00000000
#define TERMINAL_PRE        0x00000001
#define TERMINAL_POST       0x00000002
#define MANUAL_DIAL         0x00000004
#define LAUNCH_LIGHTS       0x00000008
//
#define  MIN_WAIT_BONG      0
#define  MAX_WAIT_BONG      60
#define  DEF_WAIT_BONG      8
#define  INC_WAIT_BONG      2
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\tsp\tspcomm.h ===
// Copyright (c) 1996-1997 Microsoft Corporation.
//
//
// Component
//
//		Unimodem 5.0 TSP (Win32, user mode DLL)
//
// File
//
//		TSPCOMM.H
//		Common header files not included  in tsppch.h, including common
//		c++ header files.
//
// History
//
//		11/16/1996  JosephJ Created
//
//
#include "fastlog.h"
#include "csync.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\tsp\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//
#define IDS_ASYNCREPLY                  1003
#define IDS_MONITORING                  1005
#define IDS_STOP_MONITORING             1006
#define IDS_MAKING_CALL                 1007
#define IDS_DROPPING_CALL               1008
#define IDS_CLOSING_CALL                1009
#define IDS_ANSWERING_CALL              1010
#define IDS_ENABLE_DIGIT_MONITORING     1011
#define IDS_DISABLE_DIGIT_MONITORING    1012
#define IDS_MONITOR_SILENCE             1013
#define IDS_MONITOR_TONES               1014
#define IDS_STOP_MONITORING_TONES       1015
#define IDS_GENERATE_DIGITS             1016
#define IDS_CANCEL_DIGIT_GENERATION     1017
#define IDS_PASSTHROUGH_ON              1018
#define IDS_PASSTHROUGH_OFF             1019
#define IDS_LINECALLSTATE_ACCEPTED      1020
#define IDS_LINECALLSTATE_CONNECTED     1021
#define IDS_LINECALLSTATE_DIALING       1022
#define IDS_LINECALLSTATE_DIALTONE      1023
#define IDS_LINECALLSTATE_DISCONNECTED  1024
#define IDS_LINECALLSTATE_IDLE          1025
#define IDS_LINECALLSTATE_OFFERING      1026
#define IDS_LINECALLSTATE_PROCEEDING    1027
#define IDS_LINECALLSTATE_UNKNOWN       1028
#define IDS_LINEDEVSTATE_RINGING        1029
#define IDS_LINE_CLOSE                  1030
#define IDS_LINE_NEWCALL                1031
#define IDS_LINE_MONITORDIGITS          1032
#define IDS_LINEGENERATETERM_DONE       1033
#define IDS_LINEGENERATETERM_CANCEL     1034
#define IDS_LINE_GENERATE               1035
#define IDS_UNKNOWN_MSG                 1036
#define IDS_TERMINAL_DIALOG             1037
#define IDS_MANUAL_DIAL_DIALOG          1038
#define IDS_TALK_DROP_DIALOG            1039
#define IDS_ACCEPTING_CALL              1040
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1002
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\tsp\tspi3.cpp ===
// 
// Copyright (c) 1996-1997 Microsoft Corporation.
//
//
// Component
//
//		Unimodem 5.0 TSP (Win32, user mode DLL)
//
// File
//
//		TSPI3.CPP
//		Implements TAPI3-specific TSPI  functions...
//
// History
//
//		2/18/1998  JosephJ Created
//
//
#include "tsppch.h"
#include "tspcomm.h"
#include "cdev.h"
#include "cmgr.h"
#include "cfact.h"
#include "globals.h"


FL_DECLARE_FILE( 0xc2496578, "TSPI TAPI3-specific entrypoints")

#define COLOR_TSPI FOREGROUND_GREEN

#if (TAPI3)


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Global Variables                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

// JJ static WCHAR gszMediaProviderInfo[] = T3_MSPDEVICECLASS;



static const GUID CLSID_CSAMSP =
     { 0xb9d02aa4, 0x6097, 0x11d2, { 0xa2, 0x65, 0x0, 0xc0, 0x4f, 0x8e, 0xc9, 0x51 } };



LONG                                    
TSPIAPI
TSPI_lineMSPIdentify(
    DWORD               dwDeviceID,
    GUID *              pCLSID
    )
{
    //DebugBreak();
    *pCLSID = CLSID_CSAMSP;
    return 0;
}


LONG TSPIAPI TSPI_lineReceiveMSPData(
    HDRVLINE hdLine,
    HDRVCALL hdCall,            // can be NULL
    HDRVMSPLINE hdMSPLine, // from lineCreateMSPInstance
    LPBYTE pBuffer,
    DWORD dwSize
    )
{

    // return LINEERR_OPERATIONUNAVAIL;
    return ERROR_SUCCESS;

}


LONG
TSPIAPI
TSPI_lineCreateMSPInstance(
    HDRVLINE            hdLine,
    DWORD               dwAddressID,
    HTAPIMSPLINE        htMSPLine,
    LPHDRVMSPLINE       lphdMSPLine
    )

{
    FL_DECLARE_FUNC(0xf7b70608,"TSPI_lineCreateMSPInstance");
    FL_DECLARE_STACKLOG(sl, 1000);
    TASKPARAM_TSPI_lineCreateMSPInstance params;
    LONG lRet = LINEERR_OPERATIONFAILED;

    params.dwStructSize = sizeof(params);
    params.dwTaskID = TASKID_TSPI_lineCreateMSPInstance;

    params.dwAddressID = dwAddressID;
    params.htMSPLine   = htMSPLine;
    params.lphdMSPLine = lphdMSPLine;
    DWORD dwRoutingInfo = ROUTINGINFO( TASKID_TSPI_lineCreateMSPInstance, TASKDEST_HDRVLINE);

//    OutputDebugStringA("TSPI_lineCreateMSPInstance\n");

    tspSubmitTSPCallWithHDRVLINE(
        dwRoutingInfo,
        (void *)&params,
        hdLine,
        &lRet,
        &sl
        );

    sl.Dump(COLOR_TSPI);

    return lRet;

}

LONG
TSPIAPI
TSPI_lineCloseMSPInstance(
    HDRVMSPLINE         hdMSPLine
    )

{
    FL_DECLARE_FUNC(0x0e3e9345,"TSPI_lineCloseMspInstance");
    FL_DECLARE_STACKLOG(sl, 1000);
    TASKPARAM_TSPI_lineCloseMSPInstance params;
    LONG lRet = LINEERR_OPERATIONFAILED;


    params.dwStructSize = sizeof(params);
    params.dwTaskID = TASKID_TSPI_lineCloseMSPInstance;

    DWORD dwRoutingInfo = ROUTINGINFO( TASKID_TSPI_lineCloseMSPInstance, TASKDEST_HDRVLINE );

//    OutputDebugStringA("TSPI_lineCloseMSPInstance\n");

    tspSubmitTSPCallWithHDRVLINE(
        dwRoutingInfo,
        (void *)&params,
        (HDRVLINE)hdMSPLine,
        &lRet,
        &sl
        );


    sl.Dump(COLOR_TSPI);

    return lRet;


}

#endif //  TAPI3
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\tsp\tspi0.cpp ===
// 
// Copyright (c) 1996-1997 Microsoft Corporation.
//
//
// Component
//
//		Unimodem 5.0 TSP (Win32, user mode DLL)
//
// File
//
//		TSPI0.CPP
//		Implements TSPI functions relating to provider install, init, shutdown. 
//
// History
//
//		11/16/1996  JosephJ Created
//
//
#include "tsppch.h"
#include "tspcomm.h"
#include "cdev.h"
#include "cmgr.h"
#include "cfact.h"
#include "globals.h"


FL_DECLARE_FILE( 0x95a32322, "TSPI special entrypoints")

#define COLOR_TSPI FOREGROUND_GREEN

LONG
TSPIAPI
TSPI_lineNegotiateTSPIVersion(
		DWORD dwDeviceID,
		DWORD dwLowVersion,
		DWORD dwHighVersion,
		LPDWORD lpdwTSPIVersion
)
{
	FL_DECLARE_FUNC(0x2691640a, "TSPI_lineNegotiateTSPIVersion")
	FL_DECLARE_STACKLOG(sl, 1000);
	LONG lRet = LINEERR_OPERATIONFAILED;

	if (dwDeviceID = (DWORD)-1)
	{
        if (dwHighVersion<TAPI_CURRENT_VERSION
            || dwLowVersion>TAPI_CURRENT_VERSION)
        {
            lRet = LINEERR_INCOMPATIBLEAPIVERSION;
        }
        else
        {
            *lpdwTSPIVersion = TAPI_CURRENT_VERSION;
            lRet = 0;
		}
	}
	else
	{

		TASKPARAM_TSPI_lineNegotiateTSPIVersion params;
		DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_lineAccept,
						TASKDEST_HDRVCALL
						);

		params.dwStructSize = sizeof(params);
		

		params.dwTaskID = TASKID_TSPI_lineNegotiateTSPIVersion;

		params.dwDeviceID = dwDeviceID;
		params.dwLowVersion = dwLowVersion;
		params.dwHighVersion = dwHighVersion;
		params.lpdwTSPIVersion = lpdwTSPIVersion;

		tspSubmitTSPCallWithLINEID(
				dwRoutingInfo,
				(void *)&params,
				dwDeviceID,
				&lRet,
				&sl
				);

	}

    SLPRINTFX(&sl,
             (
             FL_LOC,
            "DevID=0x%08lx;Low=0x%08lx;High=0x%08lx;Sel=0x%08lx;ret=0x%08lx",
             dwDeviceID,
             dwLowVersion,
             dwHighVersion,
             *lpdwTSPIVersion,
             lRet
             ));

    sl.Dump(COLOR_TSPI);

	return lRet;
}

#if 0
//==============================================================================
// TSPI_providerInstall
//
// Function: Let's telephony CPL know the Remove function is supported.
//
// History:
// 11/18/1996   JosephJ Taken unchanged from NT4.0 TSP
//
LONG
TSPIAPI
TSPI_providerInstall(
    HWND                hwndOwner,
    DWORD               dwPermanentProviderID
    )
{
  //
  // Although this func is never called by TAPI v2.0, we export
  // it so that the Telephony Control Panel Applet knows that it
  // can add this provider via lineAddProvider(), otherwise
  // Telephon.cpl will not consider it installable
  //
  //

  return ERROR_SUCCESS;
}
#endif

#if 0  // BRL 8/19/98  can't be remove in snapin
//==============================================================================
// TSPI_providerRemove
//
// Function: Let's telephony CPL know the Install function is supported.
//
// History:
// 11/18/1996   JosephJ Taken unchanged from NT4.0 TSP
//
LONG
TSPIAPI
TSPI_providerRemove(
    HWND                hwndOwner,
    DWORD               dwPermanentProviderID
    )
{
  //
  // Although this func is never called by TAPI v2.0, we export
  // it so that the Telephony Control Panel Applet knows that it
  // can remove this provider via lineRemoveProvider(), otherwise
  // Telephon.cpl will not consider it removable
  //

  return ERROR_SUCCESS;
}


//==============================================================================
// TSPI_providerConfig
//
//
// Function: Let's telephony CPL know the Config function is supported.
//
// History:
// 11/18/1996   JosephJ Taken unchanged from NT4.0 TSP
//
LONG
TSPIAPI
TSPI_providerConfig(
    HWND                hwndOwner,
    DWORD               dwPermanentProviderID
    )
{
  //
  // Although this func is never called by TAPI v2.0, we export
  // it so that the Telephony Control Panel Applet knows that it
  // can configure this provider via lineConfigProvider(),
  // otherwise Telephon.cpl will not consider it configurable
  //

  return ERROR_SUCCESS;
}
#endif

//==============================================================================
// TUISPI_providerInstall
//
// Function: TSPI installation 
//
// History:
// 11/18/1996   JosephJ Created
//	This was implemented differently in NT4.0. In NT4.0 we loaded TAPI32 DLL
//  and checked if we were installed. In NT5.0 we simply check in our location
//  in the registry to see if we're installed.
LONG
TSPIAPI
TUISPI_providerInstall(
    TUISPIDLLCALLBACK   lpfnUIDLLCallback,
    HWND                hwndOwner,
    DWORD               dwPermanentProviderID
    )
{
	// <@todo>  Check if we're installed by looking in registry <@/todo>
	#if 0
	if (UmRtlGetRegistryValue(TSPINSTALLED,.....&InstallStatus))
	{
		return (dwInstallStatus==0)
	}
	else
	{
		return 1;
	}
	#endif // 0

	//return 0;
    return LINEERR_OPERATIONFAILED;
}

//==============================================================================
// TUISPI_providerRemove
//
// Function: TSPI removal
//
// History:
// 11/18/1996   JosephJ Created -- see notes for TUISPI_providerInstall
//
LONG
TSPIAPI
TUISPI_providerRemove(
    TUISPIDLLCALLBACK   lpfnUIDLLCallback,
    HWND                hwndOwner,
    DWORD               dwPermanentProviderID
    )
{
	// <@todo> Set our status in the registry to "removed"</@todo>
  // return ERROR_SUCCESS;
  return LINEERR_OPERATIONFAILED;
}


//==============================================================================
// TUISPI_providerConfig
//
// Function: TUISPI configuration
//
// History:
// 11/18/1996   JosephJ Taken unchanged from NT4.0 TSP
//
LONG
TSPIAPI
TUISPI_providerConfig(
    TUISPIDLLCALLBACK   lpfnUIDLLCallback,
    HWND                hwndOwner,
    DWORD               dwPermanentProviderID
    )
{
  WinExec("control.exe telephon.cpl", SW_SHOW);
  return ERROR_SUCCESS;
}


//==============================================================================
// SPI_providerEnumDevices
//
// Function: TSPI device enumeration entry
//
// History:
// 11/18/1996   JosephJ Created
//
LONG TSPIAPI TSPI_providerEnumDevices(DWORD dwPermanentProviderID,
                                      LPDWORD lpdwNumLines,
                                      LPDWORD lpdwNumPhones,
                                      HPROVIDER hProvider,
                                      LINEEVENT lpfnLineCreateProc,
                                      PHONEEVENT lpfnPhoneCreateProc)

{

	// Load all globals, if they aren't already loaded.
	// Note: tspLoadGlobals is idempotent.
	// The globals will be unloaded on providerShutdown or on
	// process detatch.
    // DebugBreak();
	FL_DECLARE_FUNC(0x05eb2dc5, "TSPI_providerEnumDevices")
	FL_DECLARE_STACKLOG(sl, 1000);
	TSPRETURN tspRet = tspLoadGlobals(&sl);

	if (tspRet) goto end;

	tspRet = g.pTspDevMgr->providerEnumDevices(
				dwPermanentProviderID,
				lpdwNumLines,
				lpdwNumPhones,
				hProvider,
				lpfnLineCreateProc,
				lpfnPhoneCreateProc,
				&sl
				);

end:

	sl.Dump(COLOR_TSPI);

	return tspTSPIReturn(tspRet);

}


//==============================================================================
// TSPI_providerInit
//
// Function: Initializes the global data strucutres.
//
// History:
// 11/18/1996   JosephJ Created
//
LONG TSPIAPI TSPI_providerInit(DWORD             dwTSPIVersion,
                               DWORD             dwPermanentProviderID,
                               DWORD             dwLineDeviceIDBase,
                               DWORD             dwPhoneDeviceIDBase,
                               DWORD             dwNumLines,
                               DWORD             dwNumPhones,
                               ASYNC_COMPLETION  cbCompletionProc,
                               LPDWORD           lpdwTSPIOptions)
{
	FL_DECLARE_FUNC(0xf9bc62ab, "TSPI_providerInit");
	FL_DECLARE_STACKLOG(sl, 1000);

	// Load all globals, if they aren't already loaded.
	// Note: tspLoadGlobals is idempotent.
	// The globals will be unloaded on providerShutdown or on
	// process detatch.
    // DebugBreak();
	TSPRETURN tspRet = tspLoadGlobals(&sl);

	if (tspRet) goto end;

	ASSERT(g.pTspDevMgr);

	tspRet = g.pTspDevMgr->providerInit(
						dwTSPIVersion,
						dwPermanentProviderID,
						dwLineDeviceIDBase,
						dwPhoneDeviceIDBase,
						dwNumLines,
						dwNumPhones,
						cbCompletionProc,
						lpdwTSPIOptions,
						&sl
						);
end:

	sl.Dump(COLOR_TSPI);
	return tspTSPIReturn(tspRet);

}


//==============================================================================
// SPI_providerShutdown
//
// Function: Cleans up all the global data structures.
//
// History:
// 11/18/1996   JosephJ Created
//
LONG TSPIAPI TSPI_providerShutdown(
				DWORD dwTSPIVersion,
            	DWORD dwPermanentProviderID
)
{
	FL_DECLARE_FUNC( 0xc170ad38, "TSPI_providerShutdown");
	FL_DECLARE_STACKLOG(sl, 1000);

	
    // DebugBreak();
	ASSERT(g.pTspDevMgr);

	TSPRETURN tspRet = tspRet= g.pTspDevMgr->providerShutdown(
									dwTSPIVersion,
									dwPermanentProviderID,
									&sl
									);
	tspUnloadGlobals(&sl);

	sl.Dump(COLOR_TSPI);

	return tspTSPIReturn(tspRet);

}


//==============================================================================
// TSPI_providerCreateLineDevice
//
// Dynamically creates a new device.
//
// History:
// 11/18/1996   JosephJ Created
//
LONG
TSPIAPI
TSPI_providerCreateLineDevice(
    DWORD    dwTempID,
    DWORD    dwDeviceID
)
{

	FL_DECLARE_FUNC( 0x0f085e7e, "TSPI_providerCreateLineDevice");
	FL_DECLARE_STACKLOG(sl, 1000);

	TSPRETURN tspRet = g.pTspDevMgr->providerCreateLineDevice(
							dwTempID,
							dwDeviceID,
                            &sl
						);

	sl.Dump(COLOR_TSPI);

	return tspTSPIReturn(tspRet);

}


void 		tspSubmitTSPCallWithLINEID(
				DWORD dwRoutingInfo,
				void *pvParams,
				DWORD dwDeviceID,
				LONG *plRet,
				CStackLog *psl
				)
{
	FL_DECLARE_FUNC(0x04902dd0, "tspSubmitTSPCallWithLINEID")
	ASSERT(g.pTspDevMgr);
	HSESSION hSession=0;
	CTspDev *pDev=NULL;

	TSPRETURN tspRet = g.pTspDevMgr->TspDevFromLINEID(
							dwDeviceID,
							&pDev,
							&hSession
							);

    psl->SetDeviceID(dwDeviceID);

	if (tspRet)
	{
		FL_SET_RFR(0xcce27b00, "Couldn't find device");
		*plRet = LINEERR_BADDEVICEID;
	}
	else
	{
		tspRet = pDev->AcceptTspCall(FALSE, dwRoutingInfo, pvParams, plRet,psl);
		pDev->EndSession(hSession);
		hSession=0;

		if (tspRet)
		{
			// If pDev->AcceptTspCall succeeds (0 tspRet), it will have set
			// *plRet, if it fails, we set *plRet here. Note that
			// pDev->AcceptTspCall can return succes but set *plRet to some TAPI
			// error. In fact, it will be very unusual for this call to fail.
			*plRet = LINEERR_OPERATIONFAILED;
			FL_ASSERT(psl, FALSE);
		}
	}

}


void
tspSubmitTSPCallWithPHONEID(
				DWORD dwRoutingInfo,
				void *pvParams,
				DWORD dwDeviceID,
				LONG *plRet,
				CStackLog *psl
				)
{
	FL_DECLARE_FUNC(0xade6cba9, "tspSubmitTSPCallWithPHONEID")
	ASSERT(g.pTspDevMgr);
	HSESSION hSession=0;
	CTspDev *pDev=NULL;

    psl->SetDeviceID(dwDeviceID);

	TSPRETURN tspRet = g.pTspDevMgr->TspDevFromPHONEID(
							dwDeviceID,
							&pDev,
							&hSession
							);

	if (tspRet)
	{
		FL_SET_RFR(0x1eb6d200, "Couldn't find phone device");
		*plRet = LINEERR_BADDEVICEID;
	}
	else
	{
		tspRet = pDev->AcceptTspCall(FALSE, dwRoutingInfo, pvParams, plRet,psl);
		pDev->EndSession(hSession);
		hSession=0;

		if (tspRet)
		{
			// If pDev->AcceptTspCall succeeds (0 tspRet), it will have set
			// *plRet, if it fails, we set *plRet here. Note that
			// pDev->AcceptTspCall can return succes but set *plRet to some TAPI
			// error. In fact, it will be very unusual for this call to fail.
			*plRet = LINEERR_OPERATIONFAILED;
			FL_ASSERT(psl, FALSE);
		}
	}
}


void
tspSubmitTSPCallWithHDRVCALL(
				DWORD dwRoutingInfo,
				void *pvParams,
				HDRVCALL hdCall,
				LONG *plRet,
				CStackLog *psl
				)
{
	FL_DECLARE_FUNC(0x53be16e2, "tspSubmitTSPCallWithHDRVCALL")
	ASSERT(g.pTspDevMgr);
	HSESSION hSession=0;
	CTspDev *pDev=NULL;

	TSPRETURN tspRet = g.pTspDevMgr->TspDevFromHDRVCALL(
							hdCall,
							&pDev,
							&hSession
							);

	if (tspRet)
	{
		FL_SET_RFR(0x67961c00, "Couldn't find device associated with call");
		*plRet = LINEERR_INVALCALLHANDLE;
	}
	else
	{
        psl->SetDeviceID(pDev->GetLineID());
		tspRet = pDev->AcceptTspCall(FALSE, dwRoutingInfo, pvParams, plRet,psl);
		pDev->EndSession(hSession);
		hSession=0;

		if (tspRet)
		{
			// If pDev->AcceptTspCall succeeds (0 tspRet), it will have set
			// *plRet, if it fails, we set *plRet here. Note that
			// pDev->AcceptTspCall can return succes but set *plRet to some TAPI
			// error. In fact, it will be very unusual for this call to fail.
			*plRet = LINEERR_OPERATIONFAILED;
			FL_ASSERT(psl, FALSE);
		}
	}
}


void
tspSubmitTSPCallWithHDRVLINE(
				DWORD dwRoutingInfo,
				void *pvParams,
				HDRVLINE hdLine,
				LONG *plRet,
				CStackLog *psl
				)
{
	FL_DECLARE_FUNC(0x66b96bf0, "tspSubmitTSPCallWithHDRVLINE")
	ASSERT(g.pTspDevMgr);
	HSESSION hSession=0;
	CTspDev *pDev=NULL;

	TSPRETURN tspRet = g.pTspDevMgr->TspDevFromHDRVLINE(
							hdLine,
							&pDev,
							&hSession
							);

	if (tspRet)
	{
		FL_SET_RFR(0x2a124600, "Couldn't find device");
		*plRet = LINEERR_INVALLINEHANDLE;
	}
	else
	{
        psl->SetDeviceID(pDev->GetLineID());
		tspRet = pDev->AcceptTspCall(FALSE,dwRoutingInfo, pvParams, plRet, psl);
		pDev->EndSession(hSession);
		hSession=0;

		if (tspRet)
		{
			// If pDev->AcceptTspCall succeeds (0 tspRet), it will have set
			// *plRet, if it fails, we set *plRet here. Note that
			// pDev->AcceptTspCall can return succes but set *plRet to some TAPI
			// error. In fact, it will be very unusual for this call to fail.
			*plRet = LINEERR_OPERATIONFAILED;
			FL_ASSERT(psl, FALSE);
		}
	}
}


void
tspSubmitTSPCallWithHDRVPHONE(
				DWORD dwRoutingInfo,
				void *pvParams,
				HDRVPHONE hdPhone,
				LONG *plRet,
				CStackLog *psl
				)
{
	FL_DECLARE_FUNC(0x35a636ca, "tspSubmitTSPCallWithHDRVPHONE")
	ASSERT(g.pTspDevMgr);
	HSESSION hSession=0;
	CTspDev *pDev=NULL;

	TSPRETURN tspRet = g.pTspDevMgr->TspDevFromHDRVPHONE(
							hdPhone,
							&pDev,
							&hSession
							);

	if (tspRet)
	{
		FL_SET_RFR(0x7d115400, "Couldn't find device");
		*plRet = LINEERR_INVALLINEHANDLE;
	}
	else
	{
        psl->SetDeviceID(pDev->GetPhoneID());
		tspRet = pDev->AcceptTspCall(FALSE,dwRoutingInfo, pvParams, plRet, psl);
		pDev->EndSession(hSession);
		hSession=0;

		if (tspRet)
		{
			// If pDev->AcceptTspCall succeeds (0 tspRet), it will have set
			// *plRet, if it fails, we set *plRet here. Note that
			// pDev->AcceptTspCall can return succes but set *plRet to some TAPI
			// error. In fact, it will be very unusual for this call to fail.
			*plRet = LINEERR_OPERATIONFAILED;
			FL_ASSERT(psl, FALSE);
		}
	}
}


LONG
TSPIAPI
TSPI_lineSetCurrentLocation(
		DWORD dwLocation
)
{
	return LINEERR_OPERATIONFAILED;
}



LONG
TSPIAPI
TSPI_providerFreeDialogInstance(
		HDRVDIALOGINSTANCE hdDlgInst
)
{
    // TBD: propagate this somehow to CDEV? But how do we know which
    // cdev to propaget to? Not an issue for now. Could be an issue
    // for extensibility.
    //
    return ERROR_SUCCESS;
}



LONG
TSPIAPI
TSPI_providerCreatePhoneDevice(
		DWORD dwTempID,
		DWORD dwDeviceID
)
{
	FL_DECLARE_FUNC( 0x56aaa2d0, "TSPI_providerCreatePhoneDevice");
	FL_DECLARE_STACKLOG(sl, 1000);
    sl.SetDeviceID(dwDeviceID);


	TSPRETURN tspRet = g.pTspDevMgr->providerCreatePhoneDevice(
							dwTempID,
							dwDeviceID,
                            &sl
						);

	sl.Dump(COLOR_TSPI);

	return tspTSPIReturn(tspRet);
}



//
// NOTE: lineOpen,lineClose,phoneOpen,phoneClose are handled by the CTspDevMgr,
// instead of routing them directly to the relevant CTspDev.
// because it defines the line and phone driver handles (HDRVLINE and HDRVPHONE)
//

LONG
TSPIAPI
TSPI_lineOpen(
		DWORD dwDeviceID,
		HTAPILINE htLine,
		LPHDRVLINE lphdLine,
		DWORD dwTSPIVersion,
		LINEEVENT lpfnEventProc
)
{
	FL_DECLARE_FUNC(0xd1c49769,"TSPI_lineOpen");
	FL_DECLARE_STACKLOG(sl, 1000);
	LONG lRet;

	ASSERT(g.pTspDevMgr);

    sl.SetDeviceID(dwDeviceID);

	TSPRETURN tspRet = g.pTspDevMgr->lineOpen(
						dwDeviceID,
						htLine,
						lphdLine,
						dwTSPIVersion,
						lpfnEventProc,
						&lRet,
						&sl
						);

	if (tspRet) lRet = tspTSPIReturn(tspRet);

	sl.Dump(COLOR_TSPI);

	return lRet;

}



LONG
TSPIAPI
TSPI_lineClose(
		HDRVLINE hdLine
)
{
	FL_DECLARE_FUNC(0x01f87f72 ,"TSPI_lineClose");
	FL_DECLARE_STACKLOG(sl, 1000);
	LONG lRet;

	ASSERT(g.pTspDevMgr);

	TSPRETURN tspRet = g.pTspDevMgr->lineClose(
						hdLine,
						&lRet,
						&sl
						);

	if (tspRet) lRet = tspTSPIReturn(tspRet);

	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_phoneOpen(
		DWORD dwDeviceID,
		HTAPIPHONE htPhone,
		LPHDRVPHONE lphdPhone,
		DWORD dwTSPIVersion,
		PHONEEVENT lpfnEventProc
)
{
	FL_DECLARE_FUNC( 0xbe3c3cc1, "TSPI_phoneOpen");
	FL_DECLARE_STACKLOG(sl, 1000);
	LONG lRet;

	ASSERT(g.pTspDevMgr);

    sl.SetDeviceID(dwDeviceID);

	TSPRETURN tspRet = g.pTspDevMgr->phoneOpen(
							dwDeviceID,
							htPhone,
							lphdPhone,
							dwTSPIVersion,
							lpfnEventProc,
							&lRet,
							&sl
							);

	if (tspRet) lRet = tspTSPIReturn(tspRet);

	sl.Dump(COLOR_TSPI);

	return lRet;
}

LONG
TSPIAPI
TSPI_phoneClose(
		HDRVPHONE hdPhone
)
{
	FL_DECLARE_FUNC(0x6c1f91cf , "TSPI_phoneClose");
	FL_DECLARE_STACKLOG(sl, 1000);
	LONG lRet;

	ASSERT(g.pTspDevMgr);

	TSPRETURN tspRet = g.pTspDevMgr->phoneClose(
							hdPhone,
							&lRet,
							&sl
							);
	if (tspRet) lRet = tspTSPIReturn(tspRet);

	sl.Dump(COLOR_TSPI);

	return lRet;
}



// This beast needs to be handled specially because it needs to be routed
// based on the dwSelect parameter.
//
LONG
TSPIAPI
TSPI_lineGetID(
		HDRVLINE hdLine,
		DWORD dwAddressID,
		HDRVCALL hdCall,
		DWORD dwSelect,
		LPVARSTRING lpDeviceID,
		LPCWSTR lpszDeviceClass,
		HANDLE hTargetProcess
)
{
	FL_DECLARE_FUNC(0xa6d37fff,"TSPI_lineGetID");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_lineGetID params;
	LONG lRet = LINEERR_OPERATIONFAILED;
	HDRVLINE hdLineActual = hdLine;


    if(dwSelect==LINECALLSELECT_CALL)
    {
        // Note the loword of the hdCall is hdLine.
	    hdLineActual = (HDRVLINE) (LOWORD(hdCall));
    }


	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_lineGetID;

	params.hdLine = hdLine;
	params.dwAddressID = dwAddressID;
	params.hdCall = hdCall;
	params.dwSelect = dwSelect;
	params.lpDeviceID = lpDeviceID;
	params.lpszDeviceClass = lpszDeviceClass;
	params.hTargetProcess = hTargetProcess;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_lineGetID,
						TASKDEST_HDRVLINE
						);

	tspSubmitTSPCallWithHDRVLINE(
			dwRoutingInfo,
			(void *)&params,
			hdLineActual,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}

LONG
TSPIAPI
TSPI_providerUIIdentify(
		LPWSTR lpszUIDLLName
)
{
    //
    // NOTE/TBD: if we ever want to specify some other dll to handle ui, we
    // would do it here.
    //
    GetModuleFileName(g.hModule,
                      lpszUIDLLName,
                      MAX_PATH);

	return ERROR_SUCCESS;

}


//****************************************************************************
// LONG
// TSPIAPI
// TSPI_providerGenericDialogData(
//     DWORD               dwObjectID,
//     DWORD               dwObjectType,   
//     LPVOID              lpParams,
//     DWORD               dwSize)
//
// Functions: Callback from UI DLL to TSP
//
// Return:    ERROR_SUCCESS if successful
//****************************************************************************

LONG
TSPIAPI
TSPI_providerGenericDialogData(
    DWORD               dwObjectID,
    DWORD               dwObjectType,   
    LPVOID              lpParams,
    DWORD               dwSize
    )
{

	FL_DECLARE_FUNC(0x713a6b06,"TSPI_providerGenericDialogData");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_providerGenericDialogData params;
	LONG lRet = LINEERR_OPERATIONFAILED;
    DWORD dwTaskDest = 0;
    BOOL fPhone=FALSE;
	DWORD dwRoutingInfo = 0;

    switch (dwObjectType)
    {

    case TUISPIDLL_OBJECT_LINEID:
        dwTaskDest = TASKDEST_LINEID;
        break;

    case TUISPIDLL_OBJECT_PHONEID:
        dwTaskDest = TASKDEST_PHONEID;
        fPhone=TRUE;
        break;

    case TUISPIDLL_OBJECT_PROVIDERID:
        // Can't deal with this (was assert in NT4.0).
	    FL_SET_RFR(0xf8c53f00, "DIALOGINSTANCE unsupported");
	    lRet = LINEERR_OPERATIONUNAVAIL;
        break;

    case TUISPIDLL_OBJECT_DIALOGINSTANCE:
        // Can't deal with this (was assert in NT4.0).
	    FL_SET_RFR(0x9567da00, "DIALOGINSTANCE id unsupported");
	    lRet = LINEERR_OPERATIONUNAVAIL;
        break;

    default:
        // Can't deal with this (was assert in NT4.0).
	    FL_SET_RFR(0xcbf85600, "UNKNOWN id unsupported");
	    LINEERR_OPERATIONUNAVAIL;
        goto end;
    }

	

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_providerGenericDialogData;

	params.dwObjectID = dwObjectID;
	params.dwObjectType = dwObjectType;
	params.lpParams = lpParams;
	params.dwSize = dwSize;

	dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_providerGenericDialogData,
						dwTaskDest
						);

    if (fPhone)
    {
        tspSubmitTSPCallWithPHONEID(
                dwRoutingInfo,
                (void *)&params,
                dwObjectID,
                &lRet,
                &sl
                );
    }
    else
    {
        tspSubmitTSPCallWithLINEID(
                dwRoutingInfo,
                (void *)&params,
                dwObjectID,
                &lRet,
                &sl
                );
    }

end:

	sl.Dump(COLOR_TSPI);


	return lRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\tsp\tsppch.h ===
// Copyright (c) 1996-1997 Microsoft Corporation.
//
//
// Component
//
//		Unimodem 5.0 TSP (Win32, user mode DLL)
//
// File
//
//		TSPPCH.H
//		Precompiled common header file internal to the Unimodem TSP.
//
// History
//
//		11/16/1996  JosephJ Created (was tspcomm.h)
//
//

#define UNICODE 1
#define TAPI3 1

#if (TAPI3)
    #define TAPI_CURRENT_VERSION 0x00030000
#else // !TAPI3
    #define TAPI_CURRENT_VERSION 0x00020000
#endif // !TAPI3

// Define the following for the TSP to not report any phone devices....
//
// #define DISABLE_PHONE


#include <basetsd.h>
#include <windows.h>
#include <stdio.h>
#include <regstr.h>
#include <commctrl.h>
#include <windowsx.h>
#include <setupapi.h>
#include <unimodem.h>
#include <unimdmp.h>
#include <tspi.h>
#include <modemp.h>
#include <umdmmini.h>
#include <uniplat.h>
#include <debugmem.h>
#include "idfrom.h"
#include "idobj.h"
#include "iderr.h"
#include "tspret.h"
#include "debug.h"
#include <tspirec.h>
#include "umrtl.h"



#define FIELDOFFSET(type, field)    ((int)(&((type NEAR*)1)->field)-1)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\tsp\tspret.cpp ===
// 
// Copyright (c) 1996-1997 Microsoft Corporation.
//
//
// Component
//
//		Unimodem 5.0 TSP (Win32, user mode DLL)
//
// File
//
//		TSPRET.CPP
//		Functions to manipulate tsp internal function return codes
//
// History
//
//		12/04/1996  JosephJ Created
//
//
#include "tsppch.h"
#include "tspcomm.h"

LONG tspTSPIReturn(TSPRETURN tspRet)
{
		// TODO
	
		return (tspRet) ? LINEERR_OPERATIONFAILED : 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\tsp\tspi1.cpp ===
// 
// Copyright (c) 1996-1997 Microsoft Corporation.
//
//
// Component
//
//		Unimodem 5.0 TSP (Win32, user mode DLL)
//
// File
//
//		TSPI1.CPP
//		Implements TSPI functions that specify a device, line or call.
//
//
//		NOTE: This file is automatically generated by the following command:
//				gentsp tspi20_r.txt 
// History
//
//		11/16/1996  JosephJ Created
//
//
#include "tsppch.h"
#include "tspcomm.h"
#include "cdev.h"
#include "cmgr.h"
#include "cfact.h"
#include "globals.h"

FL_DECLARE_FILE(0x20d905ac, "TSPI auto-generated entrypoinets")

#define COLOR_TSPI FOREGROUND_GREEN


LONG
TSPIAPI
TSPI_lineAccept(
		DRV_REQUESTID dwRequestID,
		HDRVCALL hdCall,
		LPCSTR lpsUserUserInfo,
		DWORD dwSize
)
{
	FL_DECLARE_FUNC(0xa6d37fe3,"TSPI_lineAccept");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_lineAccept params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_lineAccept;

	params.dwRequestID = dwRequestID;
	params.hdCall = hdCall;
	params.lpsUserUserInfo = lpsUserUserInfo;
	params.dwSize = dwSize;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_lineAccept,
						TASKDEST_HDRVCALL
						);

	tspSubmitTSPCallWithHDRVCALL(
			dwRoutingInfo,
			(void *)&params,
			hdCall,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_lineAddToConference(
		DRV_REQUESTID dwRequestID,
		HDRVCALL hdConfCall,
		HDRVCALL hdConsultCall
)
{
	FL_DECLARE_FUNC(0xa6d37fe4,"TSPI_lineAddToConference");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_lineAddToConference params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_lineAddToConference;

	params.dwRequestID = dwRequestID;
	params.hdConfCall = hdConfCall;
	params.hdConsultCall = hdConsultCall;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_lineAddToConference,
						TASKDEST_HDRVCALL
						);

	tspSubmitTSPCallWithHDRVCALL(
			dwRoutingInfo,
			(void *)&params,
			hdConfCall,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_lineAnswer(
		DRV_REQUESTID dwRequestID,
		HDRVCALL hdCall,
		LPCSTR lpsUserUserInfo,
		DWORD dwSize
)
{
	FL_DECLARE_FUNC(0xa6d37fe5,"TSPI_lineAnswer");
	FL_DECLARE_STACKLOG(sl, 1000);


	TASKPARAM_TSPI_lineAnswer params;
	params.dwTaskID = TASKID_TSPI_lineAnswer;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_lineAnswer,
						TASKDEST_HDRVCALL
						);


	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);

	params.dwRequestID = dwRequestID;
	params.hdCall = hdCall;
	params.lpsUserUserInfo = lpsUserUserInfo;
	params.dwSize = dwSize;

	tspSubmitTSPCallWithHDRVCALL(
			dwRoutingInfo,
			(void *)&params,
			hdCall,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_lineBlindTransfer(
		DRV_REQUESTID dwRequestID,
		HDRVCALL hdCall,
		LPCWSTR lpszDestAddress,
		DWORD dwCountryCode
)
{
	FL_DECLARE_FUNC(0xa6d37fe6,"TSPI_lineBlindTransfer");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_lineBlindTransfer params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_lineBlindTransfer;

	params.dwRequestID = dwRequestID;
	params.hdCall = hdCall;
	params.lpszDestAddress = lpszDestAddress;
	params.dwCountryCode = dwCountryCode;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_lineBlindTransfer,
						TASKDEST_HDRVCALL
						);

	tspSubmitTSPCallWithHDRVCALL(
			dwRoutingInfo,
			(void *)&params,
			hdCall,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_lineCloseCall(
		HDRVCALL hdCall
)
{
	FL_DECLARE_FUNC(0xa6d37fe7,"TSPI_lineCloseCall");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_lineCloseCall params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_lineCloseCall;

	params.hdCall = hdCall;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_lineCloseCall,
						TASKDEST_HDRVCALL
						);

	tspSubmitTSPCallWithHDRVCALL(
			dwRoutingInfo,
			(void *)&params,
			hdCall,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_lineCompleteCall(
		DRV_REQUESTID dwRequestID,
		HDRVCALL hdCall,
		LPDWORD lpdwCompletionID,
		DWORD dwCompletionMode,
		DWORD dwMessageID
)
{
	FL_DECLARE_FUNC(0xa6d37fe8,"TSPI_lineCompleteCall");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_lineCompleteCall params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_lineCompleteCall;

	params.dwRequestID = dwRequestID;
	params.hdCall = hdCall;
	params.lpdwCompletionID = lpdwCompletionID;
	params.dwCompletionMode = dwCompletionMode;
	params.dwMessageID = dwMessageID;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_lineCompleteCall,
						TASKDEST_HDRVCALL
						);

	tspSubmitTSPCallWithHDRVCALL(
			dwRoutingInfo,
			(void *)&params,
			hdCall,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_lineCompleteTransfer(
		DRV_REQUESTID dwRequestID,
		HDRVCALL hdCall,
		HDRVCALL hdConsultCall,
		HTAPICALL htConfCall,
		LPHDRVCALL lphdConfCall,
		DWORD dwTransferMode
)
{
	FL_DECLARE_FUNC(0xa6d37fe9,"TSPI_lineCompleteTransfer");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_lineCompleteTransfer params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_lineCompleteTransfer;

	params.dwRequestID = dwRequestID;
	params.hdCall = hdCall;
	params.hdConsultCall = hdConsultCall;
	params.htConfCall = htConfCall;
	params.lphdConfCall = lphdConfCall;
	params.dwTransferMode = dwTransferMode;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_lineCompleteTransfer,
						TASKDEST_HDRVCALL
						);

	tspSubmitTSPCallWithHDRVCALL(
			dwRoutingInfo,
			(void *)&params,
			hdCall,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_lineConditionalMediaDetection(
		HDRVLINE hdLine,
		DWORD dwMediaModes,
		LPLINECALLPARAMS const lpCallParams
)
{
	FL_DECLARE_FUNC(0xa6d37fea,"TSPI_lineConditionalMediaDetection");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_lineConditionalMediaDetection params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_lineConditionalMediaDetection;

	params.hdLine = hdLine;
	params.dwMediaModes = dwMediaModes;
	params.lpCallParams = lpCallParams;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_lineConditionalMediaDetection,
						TASKDEST_HDRVLINE
						);

	tspSubmitTSPCallWithHDRVLINE(
			dwRoutingInfo,
			(void *)&params,
			hdLine,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_lineDevSpecific(
		DRV_REQUESTID dwRequestID,
		HDRVLINE hdLine,
		DWORD dwAddressID,
		HDRVCALL hdCall,
		LPVOID lpParams,
		DWORD dwSize
)
{
	FL_DECLARE_FUNC(0xa6d37feb,"TSPI_lineDevSpecific");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_lineDevSpecific params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_lineDevSpecific;

	params.dwRequestID = dwRequestID;
	params.hdLine = hdLine;
	params.dwAddressID = dwAddressID;
	params.hdCall = hdCall;
	params.lpParams = lpParams;
	params.dwSize = dwSize;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_lineDevSpecific,
						TASKDEST_HDRVLINE
						);

	tspSubmitTSPCallWithHDRVLINE(
			dwRoutingInfo,
			(void *)&params,
			hdLine,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_lineDevSpecificFeature(
		DRV_REQUESTID dwRequestID,
		HDRVLINE hdLine,
		DWORD dwFeature,
		LPVOID lpParams,
		DWORD dwSize
)
{
	FL_DECLARE_FUNC(0xa6d37fec,"TSPI_lineDevSpecificFeature");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_lineDevSpecificFeature params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_lineDevSpecificFeature;

	params.dwRequestID = dwRequestID;
	params.hdLine = hdLine;
	params.dwFeature = dwFeature;
	params.lpParams = lpParams;
	params.dwSize = dwSize;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_lineDevSpecificFeature,
						TASKDEST_HDRVLINE
						);

	tspSubmitTSPCallWithHDRVLINE(
			dwRoutingInfo,
			(void *)&params,
			hdLine,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_lineDial(
		DRV_REQUESTID dwRequestID,
		HDRVCALL hdCall,
		LPCWSTR lpszDestAddress,
		DWORD dwCountryCode
)
{
	FL_DECLARE_FUNC(0xa6d37fed,"TSPI_lineDial");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_lineDial params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_lineDial;

	params.dwRequestID = dwRequestID;
	params.hdCall = hdCall;
	params.lpszDestAddress = lpszDestAddress;
	params.dwCountryCode = dwCountryCode;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_lineDial,
						TASKDEST_HDRVCALL
						);

	tspSubmitTSPCallWithHDRVCALL(
			dwRoutingInfo,
			(void *)&params,
			hdCall,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_lineDrop(
		DRV_REQUESTID dwRequestID,
		HDRVCALL hdCall,
		LPCSTR lpsUserUserInfo,
		DWORD dwSize
)
{
	FL_DECLARE_FUNC(0xa6d37fee,"TSPI_lineDrop");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_lineDrop params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_lineDrop;

	params.dwRequestID = dwRequestID;
	params.hdCall = hdCall;
	params.lpsUserUserInfo = lpsUserUserInfo;
	params.dwSize = dwSize;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_lineDrop,
						TASKDEST_HDRVCALL
						);

	tspSubmitTSPCallWithHDRVCALL(
			dwRoutingInfo,
			(void *)&params,
			hdCall,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_lineDropOnClose(
		HDRVCALL hdCall
)
{
	FL_DECLARE_FUNC(0xa6d37fef,"TSPI_lineDropOnClose");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_lineDropOnClose params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_lineDropOnClose;

	params.hdCall = hdCall;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_lineDropOnClose,
						TASKDEST_HDRVCALL
						);

	tspSubmitTSPCallWithHDRVCALL(
			dwRoutingInfo,
			(void *)&params,
			hdCall,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_lineDropNoOwner(
		HDRVCALL hdCall
)
{
	FL_DECLARE_FUNC(0xa6d37ff0,"TSPI_lineDropNoOwner");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_lineDropNoOwner params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_lineDropNoOwner;

	params.hdCall = hdCall;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_lineDropNoOwner,
						TASKDEST_HDRVCALL
						);

	tspSubmitTSPCallWithHDRVCALL(
			dwRoutingInfo,
			(void *)&params,
			hdCall,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_lineForward(
		DRV_REQUESTID dwRequestID,
		HDRVLINE hdLine,
		DWORD bAllAddresses,
		DWORD dwAddressID,
		LPLINEFORWARDLIST const lpForwardList,
		DWORD dwNumRingsNoAnswer,
		HTAPICALL htConsultCall,
		LPHDRVCALL lphdConsultCall,
		LPLINECALLPARAMS const lpCallParams
)
{
	FL_DECLARE_FUNC(0xa6d37ff1,"TSPI_lineForward");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_lineForward params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_lineForward;

	params.dwRequestID = dwRequestID;
	params.hdLine = hdLine;
	params.bAllAddresses = bAllAddresses;
	params.dwAddressID = dwAddressID;
	params.lpForwardList = lpForwardList;
	params.dwNumRingsNoAnswer = dwNumRingsNoAnswer;
	params.htConsultCall = htConsultCall;
	params.lphdConsultCall = lphdConsultCall;
	params.lpCallParams = lpCallParams;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_lineForward,
						TASKDEST_HDRVLINE
						);

	tspSubmitTSPCallWithHDRVLINE(
			dwRoutingInfo,
			(void *)&params,
			hdLine,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_lineGatherDigits(
		HDRVCALL hdCall,
		DWORD dwEndToEndID,
		DWORD dwDigitModes,
		LPWSTR lpsDigits,
		DWORD dwNumDigits,
		LPCWSTR lpszTerminationDigits,
		DWORD dwFirstDigitTimeout,
		DWORD dwInterDigitTimeout
)
{
	FL_DECLARE_FUNC(0xa6d37ff2,"TSPI_lineGatherDigits");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_lineGatherDigits params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_lineGatherDigits;

	params.hdCall = hdCall;
	params.dwEndToEndID = dwEndToEndID;
	params.dwDigitModes = dwDigitModes;
	params.lpsDigits = lpsDigits;
	params.dwNumDigits = dwNumDigits;
	params.lpszTerminationDigits = lpszTerminationDigits;
	params.dwFirstDigitTimeout = dwFirstDigitTimeout;
	params.dwInterDigitTimeout = dwInterDigitTimeout;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_lineGatherDigits,
						TASKDEST_HDRVCALL
						);

	tspSubmitTSPCallWithHDRVCALL(
			dwRoutingInfo,
			(void *)&params,
			hdCall,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_lineGenerateDigits(
		HDRVCALL hdCall,
		DWORD dwEndToEndID,
		DWORD dwDigitMode,
		LPCWSTR lpszDigits,
		DWORD dwDuration
)
{
	FL_DECLARE_FUNC(0xa6d37ff3,"TSPI_lineGenerateDigits");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_lineGenerateDigits params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_lineGenerateDigits;

	params.hdCall = hdCall;
	params.dwEndToEndID = dwEndToEndID;
	params.dwDigitMode = dwDigitMode;
	params.lpszDigits = lpszDigits;
	params.dwDuration = dwDuration;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_lineGenerateDigits,
						TASKDEST_HDRVCALL
						);

	tspSubmitTSPCallWithHDRVCALL(
			dwRoutingInfo,
			(void *)&params,
			hdCall,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_lineGenerateTone(
		HDRVCALL hdCall,
		DWORD dwEndToEndID,
		DWORD dwToneMode,
		DWORD dwDuration,
		DWORD dwNumTones,
		LPLINEGENERATETONE const lpTones
)
{
	FL_DECLARE_FUNC(0xa6d37ff4,"TSPI_lineGenerateTone");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_lineGenerateTone params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_lineGenerateTone;

	params.hdCall = hdCall;
	params.dwEndToEndID = dwEndToEndID;
	params.dwToneMode = dwToneMode;
	params.dwDuration = dwDuration;
	params.dwNumTones = dwNumTones;
	params.lpTones = lpTones;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_lineGenerateTone,
						TASKDEST_HDRVCALL
						);

	tspSubmitTSPCallWithHDRVCALL(
			dwRoutingInfo,
			(void *)&params,
			hdCall,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_lineGetAddressCaps(
		DWORD dwDeviceID,
		DWORD dwAddressID,
		DWORD dwTSPIVersion,
		DWORD dwExtVersion,
		LPLINEADDRESSCAPS lpAddressCaps
)
{
	FL_DECLARE_FUNC(0xa6d37ff5,"TSPI_lineGetAddressCaps");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_lineGetAddressCaps params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_lineGetAddressCaps;

	params.dwDeviceID = dwDeviceID;
	params.dwAddressID = dwAddressID;
	params.dwTSPIVersion = dwTSPIVersion;
	params.dwExtVersion = dwExtVersion;
	params.lpAddressCaps = lpAddressCaps;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_lineGetAddressCaps,
						TASKDEST_LINEID
						);

	tspSubmitTSPCallWithLINEID(
			dwRoutingInfo,
			(void *)&params,
			dwDeviceID,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_lineGetAddressID(
		HDRVLINE hdLine,
		LPDWORD lpdwAddressID,
		DWORD dwAddressMode,
		LPCWSTR lpsAddress,
		DWORD dwSize
)
{
	FL_DECLARE_FUNC(0xa6d37ff6,"TSPI_lineGetAddressID");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_lineGetAddressID params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_lineGetAddressID;

	params.hdLine = hdLine;
	params.lpdwAddressID = lpdwAddressID;
	params.dwAddressMode = dwAddressMode;
	params.lpsAddress = lpsAddress;
	params.dwSize = dwSize;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_lineGetAddressID,
						TASKDEST_HDRVLINE
						);

	tspSubmitTSPCallWithHDRVLINE(
			dwRoutingInfo,
			(void *)&params,
			hdLine,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_lineGetAddressStatus(
		HDRVLINE hdLine,
		DWORD dwAddressID,
		LPLINEADDRESSSTATUS lpAddressStatus
)
{
	FL_DECLARE_FUNC(0xa6d37ff7,"TSPI_lineGetAddressStatus");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_lineGetAddressStatus params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_lineGetAddressStatus;

	params.hdLine = hdLine;
	params.dwAddressID = dwAddressID;
	params.lpAddressStatus = lpAddressStatus;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_lineGetAddressStatus,
						TASKDEST_HDRVLINE
						);

	tspSubmitTSPCallWithHDRVLINE(
			dwRoutingInfo,
			(void *)&params,
			hdLine,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_lineGetCallAddressID(
		HDRVCALL hdCall,
		LPDWORD lpdwAddressID
)
{
	FL_DECLARE_FUNC(0xa6d37ff8,"TSPI_lineGetCallAddressID");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_lineGetCallAddressID params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_lineGetCallAddressID;

	params.hdCall = hdCall;
	params.lpdwAddressID = lpdwAddressID;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_lineGetCallAddressID,
						TASKDEST_HDRVCALL
						);

	tspSubmitTSPCallWithHDRVCALL(
			dwRoutingInfo,
			(void *)&params,
			hdCall,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_lineGetCallInfo(
		HDRVCALL hdCall,
		LPLINECALLINFO lpCallInfo
)
{
	FL_DECLARE_FUNC(0xa6d37ff9,"TSPI_lineGetCallInfo");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_lineGetCallInfo params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_lineGetCallInfo;

	params.hdCall = hdCall;
	params.lpCallInfo = lpCallInfo;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_lineGetCallInfo,
						TASKDEST_HDRVCALL
						);

	tspSubmitTSPCallWithHDRVCALL(
			dwRoutingInfo,
			(void *)&params,
			hdCall,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_lineGetCallStatus(
		HDRVCALL hdCall,
		LPLINECALLSTATUS lpCallStatus
)
{
	FL_DECLARE_FUNC(0xa6d37ffa,"TSPI_lineGetCallStatus");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_lineGetCallStatus params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_lineGetCallStatus;

	params.hdCall = hdCall;
	params.lpCallStatus = lpCallStatus;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_lineGetCallStatus,
						TASKDEST_HDRVCALL
						);

	tspSubmitTSPCallWithHDRVCALL(
			dwRoutingInfo,
			(void *)&params,
			hdCall,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_lineGetDevCaps(
		DWORD dwDeviceID,
		DWORD dwTSPIVersion,
		DWORD dwExtVersion,
		LPLINEDEVCAPS lpLineDevCaps
)
{
	FL_DECLARE_FUNC(0xa6d37ffb,"TSPI_lineGetDevCaps");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_lineGetDevCaps params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_lineGetDevCaps;

	params.dwDeviceID = dwDeviceID;
	params.dwTSPIVersion = dwTSPIVersion;
	params.dwExtVersion = dwExtVersion;
	params.lpLineDevCaps = lpLineDevCaps;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_lineGetDevCaps,
						TASKDEST_LINEID
						);

	tspSubmitTSPCallWithLINEID(
			dwRoutingInfo,
			(void *)&params,
			dwDeviceID,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_lineGetDevConfig(
		DWORD dwDeviceID,
		LPVARSTRING lpDeviceConfig,
		LPCWSTR lpszDeviceClass
)
{
	FL_DECLARE_FUNC(0xa6d37ffc,"TSPI_lineGetDevConfig");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_lineGetDevConfig params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_lineGetDevConfig;

	params.dwDeviceID = dwDeviceID;
	params.lpDeviceConfig = lpDeviceConfig;
	params.lpszDeviceClass = lpszDeviceClass;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_lineGetDevConfig,
						TASKDEST_LINEID
						);

	tspSubmitTSPCallWithLINEID(
			dwRoutingInfo,
			(void *)&params,
			dwDeviceID,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_lineGetExtensionID(
		DWORD dwDeviceID,
		DWORD dwTSPIVersion,
		LPLINEEXTENSIONID lpExtensionID
)
{
	FL_DECLARE_FUNC(0xa6d37ffd,"TSPI_lineGetExtensionID");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_lineGetExtensionID params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_lineGetExtensionID;

	params.dwDeviceID = dwDeviceID;
	params.dwTSPIVersion = dwTSPIVersion;
	params.lpExtensionID = lpExtensionID;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_lineGetExtensionID,
						TASKDEST_LINEID
						);

	tspSubmitTSPCallWithLINEID(
			dwRoutingInfo,
			(void *)&params,
			dwDeviceID,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_lineGetIcon(
		DWORD dwDeviceID,
		LPCWSTR lpszDeviceClass,
		LPHICON lphIcon
)
{
	FL_DECLARE_FUNC(0xa6d37ffe,"TSPI_lineGetIcon");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_lineGetIcon params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_lineGetIcon;

	params.dwDeviceID = dwDeviceID;
	params.lpszDeviceClass = lpszDeviceClass;
	params.lphIcon = lphIcon;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_lineGetIcon,
						TASKDEST_LINEID
						);

	tspSubmitTSPCallWithLINEID(
			dwRoutingInfo,
			(void *)&params,
			dwDeviceID,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}



LONG
TSPIAPI
TSPI_lineGetLineDevStatus(
		HDRVLINE hdLine,
		LPLINEDEVSTATUS lpLineDevStatus
)
{
	FL_DECLARE_FUNC(0xa6d38000,"TSPI_lineGetLineDevStatus");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_lineGetLineDevStatus params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_lineGetLineDevStatus;

	params.hdLine = hdLine;
	params.lpLineDevStatus = lpLineDevStatus;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_lineGetLineDevStatus,
						TASKDEST_HDRVLINE
						);

	tspSubmitTSPCallWithHDRVLINE(
			dwRoutingInfo,
			(void *)&params,
			hdLine,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_lineGetNumAddressIDs(
		HDRVLINE hdLine,
		LPDWORD lpdwNumAddressIDs
)
{
	FL_DECLARE_FUNC(0xa6d38001,"TSPI_lineGetNumAddressIDs");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_lineGetNumAddressIDs params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_lineGetNumAddressIDs;

	params.hdLine = hdLine;
	params.lpdwNumAddressIDs = lpdwNumAddressIDs;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_lineGetNumAddressIDs,
						TASKDEST_HDRVLINE
						);

	tspSubmitTSPCallWithHDRVLINE(
			dwRoutingInfo,
			(void *)&params,
			hdLine,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_lineHold(
		DRV_REQUESTID dwRequestID,
		HDRVCALL hdCall
)
{
	FL_DECLARE_FUNC(0xa6d38002,"TSPI_lineHold");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_lineHold params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_lineHold;

	params.dwRequestID = dwRequestID;
	params.hdCall = hdCall;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_lineHold,
						TASKDEST_HDRVCALL
						);

	tspSubmitTSPCallWithHDRVCALL(
			dwRoutingInfo,
			(void *)&params,
			hdCall,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_lineMakeCall(
		DRV_REQUESTID dwRequestID,
		HDRVLINE hdLine,
		HTAPICALL htCall,
		LPHDRVCALL lphdCall,
		LPCWSTR lpszDestAddress,
		DWORD dwCountryCode,
		LPLINECALLPARAMS const lpCallParams
)
{
	FL_DECLARE_FUNC(0xa6d38003,"TSPI_lineMakeCall");
	FL_DECLARE_STACKLOG(sl, 1000);


	TASKPARAM_TSPI_lineMakeCall params;
	params.dwTaskID = TASKID_TSPI_lineMakeCall;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_lineMakeCall,
						TASKDEST_HDRVLINE
						);


	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);

	params.dwRequestID = dwRequestID;
	params.hdLine = hdLine;
	params.htCall = htCall;
	params.lphdCall = lphdCall;
	params.lpszDestAddress = lpszDestAddress;
	params.dwCountryCode = dwCountryCode;
	params.lpCallParams = lpCallParams;


	tspSubmitTSPCallWithHDRVLINE(
			dwRoutingInfo,
			(void *)&params,
			hdLine,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_lineMonitorDigits(
		HDRVCALL hdCall,
		DWORD dwDigitModes
)
{
	FL_DECLARE_FUNC(0xa6d38004,"TSPI_lineMonitorDigits");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_lineMonitorDigits params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_lineMonitorDigits;

	params.hdCall = hdCall;
	params.dwDigitModes = dwDigitModes;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_lineMonitorDigits,
						TASKDEST_HDRVCALL
						);

	tspSubmitTSPCallWithHDRVCALL(
			dwRoutingInfo,
			(void *)&params,
			hdCall,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_lineMonitorMedia(
		HDRVCALL hdCall,
		DWORD dwMediaModes
)
{
	FL_DECLARE_FUNC(0xa6d38005,"TSPI_lineMonitorMedia");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_lineMonitorMedia params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_lineMonitorMedia;

	params.hdCall = hdCall;
	params.dwMediaModes = dwMediaModes;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_lineMonitorMedia,
						TASKDEST_HDRVCALL
						);

	tspSubmitTSPCallWithHDRVCALL(
			dwRoutingInfo,
			(void *)&params,
			hdCall,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_lineMonitorTones(
		HDRVCALL hdCall,
		DWORD dwToneListID,
		LPLINEMONITORTONE const lpToneList,
		DWORD dwNumEntries
)
{
	FL_DECLARE_FUNC(0xa6d38006,"TSPI_lineMonitorTones");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_lineMonitorTones params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_lineMonitorTones;

	params.hdCall = hdCall;
	params.dwToneListID = dwToneListID;
	params.lpToneList = lpToneList;
	params.dwNumEntries = dwNumEntries;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_lineMonitorTones,
						TASKDEST_HDRVCALL
						);

	tspSubmitTSPCallWithHDRVCALL(
			dwRoutingInfo,
			(void *)&params,
			hdCall,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_lineNegotiateExtVersion(
		DWORD dwDeviceID,
		DWORD dwTSPIVersion,
		DWORD dwLowVersion,
		DWORD dwHighVersion,
		LPDWORD lpdwExtVersion
)
{
	FL_DECLARE_FUNC(0xa6d38007,"TSPI_lineNegotiateExtVersion");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_lineNegotiateExtVersion params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_lineNegotiateExtVersion;

	params.dwDeviceID = dwDeviceID;
	params.dwTSPIVersion = dwTSPIVersion;
	params.dwLowVersion = dwLowVersion;
	params.dwHighVersion = dwHighVersion;
	params.lpdwExtVersion = lpdwExtVersion;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_lineNegotiateExtVersion,
						TASKDEST_LINEID
						);

	tspSubmitTSPCallWithLINEID(
			dwRoutingInfo,
			(void *)&params,
			dwDeviceID,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_linePark(
		DRV_REQUESTID dwRequestID,
		HDRVCALL hdCall,
		DWORD dwParkMode,
		LPCWSTR lpszDirAddress,
		LPVARSTRING lpNonDirAddress
)
{
	FL_DECLARE_FUNC(0xa6d38008,"TSPI_linePark");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_linePark params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_linePark;

	params.dwRequestID = dwRequestID;
	params.hdCall = hdCall;
	params.dwParkMode = dwParkMode;
	params.lpszDirAddress = lpszDirAddress;
	params.lpNonDirAddress = lpNonDirAddress;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_linePark,
						TASKDEST_HDRVCALL
						);

	tspSubmitTSPCallWithHDRVCALL(
			dwRoutingInfo,
			(void *)&params,
			hdCall,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_linePickup(
		DRV_REQUESTID dwRequestID,
		HDRVLINE hdLine,
		DWORD dwAddressID,
		HTAPICALL htCall,
		LPHDRVCALL lphdCall,
		LPCWSTR lpszDestAddress,
		LPCWSTR lpszGroupID
)
{
	FL_DECLARE_FUNC(0xa6d38009,"TSPI_linePickup");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_linePickup params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_linePickup;

	params.dwRequestID = dwRequestID;
	params.hdLine = hdLine;
	params.dwAddressID = dwAddressID;
	params.htCall = htCall;
	params.lphdCall = lphdCall;
	params.lpszDestAddress = lpszDestAddress;
	params.lpszGroupID = lpszGroupID;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_linePickup,
						TASKDEST_HDRVLINE
						);

	tspSubmitTSPCallWithHDRVLINE(
			dwRoutingInfo,
			(void *)&params,
			hdLine,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_linePrepareAddToConference(
		DRV_REQUESTID dwRequestID,
		HDRVCALL hdConfCall,
		HTAPICALL htConsultCall,
		LPHDRVCALL lphdConsultCall,
		LPLINECALLPARAMS const lpCallParams
)
{
	FL_DECLARE_FUNC(0xa6d3800a,"TSPI_linePrepareAddToConference");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_linePrepareAddToConference params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_linePrepareAddToConference;

	params.dwRequestID = dwRequestID;
	params.hdConfCall = hdConfCall;
	params.htConsultCall = htConsultCall;
	params.lphdConsultCall = lphdConsultCall;
	params.lpCallParams = lpCallParams;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_linePrepareAddToConference,
						TASKDEST_HDRVCALL
						);

	tspSubmitTSPCallWithHDRVCALL(
			dwRoutingInfo,
			(void *)&params,
			hdConfCall,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_lineRedirect(
		DRV_REQUESTID dwRequestID,
		HDRVCALL hdCall,
		LPCWSTR lpszDestAddress,
		DWORD dwCountryCode
)
{
	FL_DECLARE_FUNC(0xa6d3800b,"TSPI_lineRedirect");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_lineRedirect params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_lineRedirect;

	params.dwRequestID = dwRequestID;
	params.hdCall = hdCall;
	params.lpszDestAddress = lpszDestAddress;
	params.dwCountryCode = dwCountryCode;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_lineRedirect,
						TASKDEST_HDRVCALL
						);

	tspSubmitTSPCallWithHDRVCALL(
			dwRoutingInfo,
			(void *)&params,
			hdCall,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_lineReleaseUserUserInfo(
		DRV_REQUESTID dwRequestID,
		HDRVCALL hdCall
)
{
	FL_DECLARE_FUNC(0xa6d3800c,"TSPI_lineReleaseUserUserInfo");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_lineReleaseUserUserInfo params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_lineReleaseUserUserInfo;

	params.dwRequestID = dwRequestID;
	params.hdCall = hdCall;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_lineReleaseUserUserInfo,
						TASKDEST_HDRVCALL
						);

	tspSubmitTSPCallWithHDRVCALL(
			dwRoutingInfo,
			(void *)&params,
			hdCall,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_lineRemoveFromConference(
		DRV_REQUESTID dwRequestID,
		HDRVCALL hdCall
)
{
	FL_DECLARE_FUNC(0xa6d3800d,"TSPI_lineRemoveFromConference");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_lineRemoveFromConference params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_lineRemoveFromConference;

	params.dwRequestID = dwRequestID;
	params.hdCall = hdCall;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_lineRemoveFromConference,
						TASKDEST_HDRVCALL
						);

	tspSubmitTSPCallWithHDRVCALL(
			dwRoutingInfo,
			(void *)&params,
			hdCall,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_lineSecureCall(
		DRV_REQUESTID dwRequestID,
		HDRVCALL hdCall
)
{
	FL_DECLARE_FUNC(0xa6d3800e,"TSPI_lineSecureCall");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_lineSecureCall params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_lineSecureCall;

	params.dwRequestID = dwRequestID;
	params.hdCall = hdCall;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_lineSecureCall,
						TASKDEST_HDRVCALL
						);

	tspSubmitTSPCallWithHDRVCALL(
			dwRoutingInfo,
			(void *)&params,
			hdCall,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_lineSelectExtVersion(
		HDRVLINE hdLine,
		DWORD dwExtVersion
)
{
	FL_DECLARE_FUNC(0xa6d3800f,"TSPI_lineSelectExtVersion");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_lineSelectExtVersion params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_lineSelectExtVersion;

	params.hdLine = hdLine;
	params.dwExtVersion = dwExtVersion;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_lineSelectExtVersion,
						TASKDEST_HDRVLINE
						);

	tspSubmitTSPCallWithHDRVLINE(
			dwRoutingInfo,
			(void *)&params,
			hdLine,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_lineSendUserUserInfo(
		DRV_REQUESTID dwRequestID,
		HDRVCALL hdCall,
		LPCSTR lpsUserUserInfo,
		DWORD dwSize
)
{
	FL_DECLARE_FUNC(0xa6d38010,"TSPI_lineSendUserUserInfo");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_lineSendUserUserInfo params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_lineSendUserUserInfo;

	params.dwRequestID = dwRequestID;
	params.hdCall = hdCall;
	params.lpsUserUserInfo = lpsUserUserInfo;
	params.dwSize = dwSize;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_lineSendUserUserInfo,
						TASKDEST_HDRVCALL
						);

	tspSubmitTSPCallWithHDRVCALL(
			dwRoutingInfo,
			(void *)&params,
			hdCall,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_lineSetAppSpecific(
		HDRVCALL hdCall,
		DWORD dwAppSpecific
)
{
	FL_DECLARE_FUNC(0xa6d38011,"TSPI_lineSetAppSpecific");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_lineSetAppSpecific params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_lineSetAppSpecific;

	params.hdCall = hdCall;
	params.dwAppSpecific = dwAppSpecific;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_lineSetAppSpecific,
						TASKDEST_HDRVCALL
						);

	tspSubmitTSPCallWithHDRVCALL(
			dwRoutingInfo,
			(void *)&params,
			hdCall,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_lineSetCallData(
		DRV_REQUESTID dwRequestID,
		HDRVCALL hdCall,
		LPVOID lpCallData,
		DWORD dwSize
)
{
	FL_DECLARE_FUNC(0xa6d38012,"TSPI_lineSetCallData");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_lineSetCallData params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_lineSetCallData;

	params.dwRequestID = dwRequestID;
	params.hdCall = hdCall;
	params.lpCallData = lpCallData;
	params.dwSize = dwSize;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_lineSetCallData,
						TASKDEST_HDRVCALL
						);

	tspSubmitTSPCallWithHDRVCALL(
			dwRoutingInfo,
			(void *)&params,
			hdCall,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_lineSetCallParams(
		DRV_REQUESTID dwRequestID,
		HDRVCALL hdCall,
		DWORD dwBearerMode,
		DWORD dwMinRate,
		DWORD dwMaxRate,
		LPLINEDIALPARAMS const lpDialParams
)
{
	FL_DECLARE_FUNC(0xa6d38013,"TSPI_lineSetCallParams");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_lineSetCallParams params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_lineSetCallParams;

	params.dwRequestID = dwRequestID;
	params.hdCall = hdCall;
	params.dwBearerMode = dwBearerMode;
	params.dwMinRate = dwMinRate;
	params.dwMaxRate = dwMaxRate;
	params.lpDialParams = lpDialParams;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_lineSetCallParams,
						TASKDEST_HDRVCALL
						);

	tspSubmitTSPCallWithHDRVCALL(
			dwRoutingInfo,
			(void *)&params,
			hdCall,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_lineSetCallQualityOfService(
		DRV_REQUESTID dwRequestID,
		HDRVCALL hdCall,
		LPVOID lpSendingFlowspec,
		DWORD dwSendingFlowspecSize,
		LPVOID lpReceivingFlowspec,
		DWORD dwReceivingFlowspecSize
)
{
	FL_DECLARE_FUNC(0xa6d38014,"TSPI_lineSetCallQualityOfService");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_lineSetCallQualityOfService params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_lineSetCallQualityOfService;

	params.dwRequestID = dwRequestID;
	params.hdCall = hdCall;
	params.lpSendingFlowspec = lpSendingFlowspec;
	params.dwSendingFlowspecSize = dwSendingFlowspecSize;
	params.lpReceivingFlowspec = lpReceivingFlowspec;
	params.dwReceivingFlowspecSize = dwReceivingFlowspecSize;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_lineSetCallQualityOfService,
						TASKDEST_HDRVCALL
						);

	tspSubmitTSPCallWithHDRVCALL(
			dwRoutingInfo,
			(void *)&params,
			hdCall,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_lineSetCallTreatment(
		DRV_REQUESTID dwRequestID,
		HDRVCALL hdCall,
		DWORD dwTreatment
)
{
	FL_DECLARE_FUNC(0xa6d38015,"TSPI_lineSetCallTreatment");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_lineSetCallTreatment params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_lineSetCallTreatment;

	params.dwRequestID = dwRequestID;
	params.hdCall = hdCall;
	params.dwTreatment = dwTreatment;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_lineSetCallTreatment,
						TASKDEST_HDRVCALL
						);

	tspSubmitTSPCallWithHDRVCALL(
			dwRoutingInfo,
			(void *)&params,
			hdCall,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_lineSetDefaultMediaDetection(
		HDRVLINE hdLine,
		DWORD dwMediaModes
)
{
	FL_DECLARE_FUNC(0xa6d38016,"TSPI_lineSetDefaultMediaDetection");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_lineSetDefaultMediaDetection params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_lineSetDefaultMediaDetection;

	params.hdLine = hdLine;
	params.dwMediaModes = dwMediaModes;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_lineSetDefaultMediaDetection,
						TASKDEST_HDRVLINE
						);

	tspSubmitTSPCallWithHDRVLINE(
			dwRoutingInfo,
			(void *)&params,
			hdLine,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_lineSetDevConfig(
		DWORD dwDeviceID,
		LPVOID const lpDeviceConfig,
		DWORD dwSize,
		LPCWSTR lpszDeviceClass
)
{
	FL_DECLARE_FUNC(0xa6d38017,"TSPI_lineSetDevConfig");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_lineSetDevConfig params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_lineSetDevConfig;

	params.dwDeviceID = dwDeviceID;
	params.lpDeviceConfig = lpDeviceConfig;
	params.dwSize = dwSize;
	params.lpszDeviceClass = lpszDeviceClass;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_lineSetDevConfig,
						TASKDEST_LINEID
						);

	tspSubmitTSPCallWithLINEID(
			dwRoutingInfo,
			(void *)&params,
			dwDeviceID,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_lineSetLineDevStatus(
		DRV_REQUESTID dwRequestID,
		HDRVLINE hdLine,
		DWORD dwStatusToChange,
		DWORD fStatus
)
{
	FL_DECLARE_FUNC(0xa6d38018,"TSPI_lineSetLineDevStatus");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_lineSetLineDevStatus params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_lineSetLineDevStatus;

	params.dwRequestID = dwRequestID;
	params.hdLine = hdLine;
	params.dwStatusToChange = dwStatusToChange;
	params.fStatus = fStatus;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_lineSetLineDevStatus,
						TASKDEST_HDRVLINE
						);

	tspSubmitTSPCallWithHDRVLINE(
			dwRoutingInfo,
			(void *)&params,
			hdLine,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_lineSetMediaControl(
		HDRVLINE hdLine,
		DWORD dwAddressID,
		HDRVCALL hdCall,
		DWORD dwSelect,
		LPLINEMEDIACONTROLDIGIT const lpDigitList,
		DWORD dwDigitNumEntries,
		LPLINEMEDIACONTROLMEDIA const lpMediaList,
		DWORD dwMediaNumEntries,
		LPLINEMEDIACONTROLTONE const lpToneList,
		DWORD dwToneNumEntries,
		LPLINEMEDIACONTROLCALLSTATE const lpCallStateList,
		DWORD dwCallStateNumEntries
)
{
	FL_DECLARE_FUNC(0xa6d38019,"TSPI_lineSetMediaControl");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_lineSetMediaControl params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_lineSetMediaControl;

	params.hdLine = hdLine;
	params.dwAddressID = dwAddressID;
	params.hdCall = hdCall;
	params.dwSelect = dwSelect;
	params.lpDigitList = lpDigitList;
	params.dwDigitNumEntries = dwDigitNumEntries;
	params.lpMediaList = lpMediaList;
	params.dwMediaNumEntries = dwMediaNumEntries;
	params.lpToneList = lpToneList;
	params.dwToneNumEntries = dwToneNumEntries;
	params.lpCallStateList = lpCallStateList;
	params.dwCallStateNumEntries = dwCallStateNumEntries;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_lineSetMediaControl,
						TASKDEST_HDRVLINE
						);

	tspSubmitTSPCallWithHDRVLINE(
			dwRoutingInfo,
			(void *)&params,
			hdLine,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_lineSetMediaMode(
		HDRVCALL hdCall,
		DWORD dwMediaMode
)
{
	FL_DECLARE_FUNC(0xa6d3801a,"TSPI_lineSetMediaMode");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_lineSetMediaMode params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_lineSetMediaMode;

	params.hdCall = hdCall;
	params.dwMediaMode = dwMediaMode;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_lineSetMediaMode,
						TASKDEST_HDRVCALL
						);

	tspSubmitTSPCallWithHDRVCALL(
			dwRoutingInfo,
			(void *)&params,
			hdCall,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_lineSetStatusMessages(
		HDRVLINE hdLine,
		DWORD dwLineStates,
		DWORD dwAddressStates
)
{
	FL_DECLARE_FUNC(0xa6d3801b,"TSPI_lineSetStatusMessages");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_lineSetStatusMessages params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_lineSetStatusMessages;

	params.hdLine = hdLine;
	params.dwLineStates = dwLineStates;
	params.dwAddressStates = dwAddressStates;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_lineSetStatusMessages,
						TASKDEST_HDRVLINE
						);

	tspSubmitTSPCallWithHDRVLINE(
			dwRoutingInfo,
			(void *)&params,
			hdLine,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_lineSetTerminal(
		DRV_REQUESTID dwRequestID,
		HDRVLINE hdLine,
		DWORD dwAddressID,
		HDRVCALL hdCall,
		DWORD dwSelect,
		DWORD dwTerminalModes,
		DWORD dwTerminalID,
		DWORD bEnable
)
{
	FL_DECLARE_FUNC(0xa6d3801c,"TSPI_lineSetTerminal");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_lineSetTerminal params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_lineSetTerminal;

	params.dwRequestID = dwRequestID;
	params.hdLine = hdLine;
	params.dwAddressID = dwAddressID;
	params.hdCall = hdCall;
	params.dwSelect = dwSelect;
	params.dwTerminalModes = dwTerminalModes;
	params.dwTerminalID = dwTerminalID;
	params.bEnable = bEnable;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_lineSetTerminal,
						TASKDEST_HDRVLINE
						);

	tspSubmitTSPCallWithHDRVLINE(
			dwRoutingInfo,
			(void *)&params,
			hdLine,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_lineSetupConference(
		DRV_REQUESTID dwRequestID,
		HDRVCALL hdCall,
		HDRVLINE hdLine,
		HTAPICALL htConfCall,
		LPHDRVCALL lphdConfCall,
		HTAPICALL htConsultCall,
		LPHDRVCALL lphdConsultCall,
		DWORD dwNumParties,
		LPLINECALLPARAMS const lpCallParams
)
{
	FL_DECLARE_FUNC(0xa6d3801d,"TSPI_lineSetupConference");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_lineSetupConference params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_lineSetupConference;

	params.dwRequestID = dwRequestID;
	params.hdCall = hdCall;
	params.hdLine = hdLine;
	params.htConfCall = htConfCall;
	params.lphdConfCall = lphdConfCall;
	params.htConsultCall = htConsultCall;
	params.lphdConsultCall = lphdConsultCall;
	params.dwNumParties = dwNumParties;
	params.lpCallParams = lpCallParams;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_lineSetupConference,
						TASKDEST_HDRVCALL
						);

	tspSubmitTSPCallWithHDRVCALL(
			dwRoutingInfo,
			(void *)&params,
			hdCall,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_lineSetupTransfer(
		DRV_REQUESTID dwRequestID,
		HDRVCALL hdCall,
		HTAPICALL htConsultCall,
		LPHDRVCALL lphdConsultCall,
		LPLINECALLPARAMS const lpCallParams
)
{
	FL_DECLARE_FUNC(0xa6d3801e,"TSPI_lineSetupTransfer");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_lineSetupTransfer params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_lineSetupTransfer;

	params.dwRequestID = dwRequestID;
	params.hdCall = hdCall;
	params.htConsultCall = htConsultCall;
	params.lphdConsultCall = lphdConsultCall;
	params.lpCallParams = lpCallParams;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_lineSetupTransfer,
						TASKDEST_HDRVCALL
						);

	tspSubmitTSPCallWithHDRVCALL(
			dwRoutingInfo,
			(void *)&params,
			hdCall,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_lineSwapHold(
		DRV_REQUESTID dwRequestID,
		HDRVCALL hdActiveCall,
		HDRVCALL hdHeldCall
)
{
	FL_DECLARE_FUNC(0xa6d3801f,"TSPI_lineSwapHold");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_lineSwapHold params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_lineSwapHold;

	params.dwRequestID = dwRequestID;
	params.hdActiveCall = hdActiveCall;
	params.hdHeldCall = hdHeldCall;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_lineSwapHold,
						TASKDEST_HDRVCALL
						);

	tspSubmitTSPCallWithHDRVCALL(
			dwRoutingInfo,
			(void *)&params,
			hdActiveCall,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_lineUncompleteCall(
		DRV_REQUESTID dwRequestID,
		HDRVLINE hdLine,
		DWORD dwCompletionID
)
{
	FL_DECLARE_FUNC(0xa6d38020,"TSPI_lineUncompleteCall");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_lineUncompleteCall params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_lineUncompleteCall;

	params.dwRequestID = dwRequestID;
	params.hdLine = hdLine;
	params.dwCompletionID = dwCompletionID;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_lineUncompleteCall,
						TASKDEST_HDRVLINE
						);

	tspSubmitTSPCallWithHDRVLINE(
			dwRoutingInfo,
			(void *)&params,
			hdLine,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_lineUnhold(
		DRV_REQUESTID dwRequestID,
		HDRVCALL hdCall
)
{
	FL_DECLARE_FUNC(0xa6d38021,"TSPI_lineUnhold");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_lineUnhold params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_lineUnhold;

	params.dwRequestID = dwRequestID;
	params.hdCall = hdCall;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_lineUnhold,
						TASKDEST_HDRVCALL
						);

	tspSubmitTSPCallWithHDRVCALL(
			dwRoutingInfo,
			(void *)&params,
			hdCall,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_lineUnpark(
		DRV_REQUESTID dwRequestID,
		HDRVLINE hdLine,
		DWORD dwAddressID,
		HTAPICALL htCall,
		LPHDRVCALL lphdCall,
		LPCWSTR lpszDestAddress
)
{
	FL_DECLARE_FUNC(0xa6d38022,"TSPI_lineUnpark");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_lineUnpark params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_lineUnpark;

	params.dwRequestID = dwRequestID;
	params.hdLine = hdLine;
	params.dwAddressID = dwAddressID;
	params.htCall = htCall;
	params.lphdCall = lphdCall;
	params.lpszDestAddress = lpszDestAddress;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_lineUnpark,
						TASKDEST_HDRVLINE
						);

	tspSubmitTSPCallWithHDRVLINE(
			dwRoutingInfo,
			(void *)&params,
			hdLine,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_phoneDevSpecific(
		DRV_REQUESTID dwRequestID,
		HDRVPHONE hdPhone,
		LPVOID lpParams,
		DWORD dwSize
)
{
	FL_DECLARE_FUNC(0xa6d38023,"TSPI_phoneDevSpecific");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_phoneDevSpecific params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_phoneDevSpecific;

	params.dwRequestID = dwRequestID;
	params.hdPhone = hdPhone;
	params.lpParams = lpParams;
	params.dwSize = dwSize;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_phoneDevSpecific,
						TASKDEST_HDRVPHONE
						);

	tspSubmitTSPCallWithHDRVPHONE(
			dwRoutingInfo,
			(void *)&params,
			hdPhone,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_phoneGetButtonInfo(
		HDRVPHONE hdPhone,
		DWORD dwButtonLampID,
		LPPHONEBUTTONINFO lpButtonInfo
)
{
	FL_DECLARE_FUNC(0xa6d38024,"TSPI_phoneGetButtonInfo");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_phoneGetButtonInfo params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_phoneGetButtonInfo;

	params.hdPhone = hdPhone;
	params.dwButtonLampID = dwButtonLampID;
	params.lpButtonInfo = lpButtonInfo;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_phoneGetButtonInfo,
						TASKDEST_HDRVPHONE
						);

	tspSubmitTSPCallWithHDRVPHONE(
			dwRoutingInfo,
			(void *)&params,
			hdPhone,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_phoneGetData(
		HDRVPHONE hdPhone,
		DWORD dwDataID,
		LPVOID lpData,
		DWORD dwSize
)
{
	FL_DECLARE_FUNC(0xa6d38025,"TSPI_phoneGetData");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_phoneGetData params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_phoneGetData;

	params.hdPhone = hdPhone;
	params.dwDataID = dwDataID;
	params.lpData = lpData;
	params.dwSize = dwSize;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_phoneGetData,
						TASKDEST_HDRVPHONE
						);

	tspSubmitTSPCallWithHDRVPHONE(
			dwRoutingInfo,
			(void *)&params,
			hdPhone,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_phoneGetDevCaps(
		DWORD dwDeviceID,
		DWORD dwTSPIVersion,
		DWORD dwExtVersion,
		LPPHONECAPS lpPhoneCaps
)
{
	FL_DECLARE_FUNC(0xa6d38026,"TSPI_phoneGetDevCaps");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_phoneGetDevCaps params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_phoneGetDevCaps;

	params.dwDeviceID = dwDeviceID;
	params.dwTSPIVersion = dwTSPIVersion;
	params.dwExtVersion = dwExtVersion;
	params.lpPhoneCaps = lpPhoneCaps;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_phoneGetDevCaps,
						TASKDEST_PHONEID
						);

	tspSubmitTSPCallWithPHONEID(
			dwRoutingInfo,
			(void *)&params,
			dwDeviceID,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_phoneGetDisplay(
		HDRVPHONE hdPhone,
		LPVARSTRING lpDisplay
)
{
	FL_DECLARE_FUNC(0xa6d38027,"TSPI_phoneGetDisplay");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_phoneGetDisplay params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_phoneGetDisplay;

	params.hdPhone = hdPhone;
	params.lpDisplay = lpDisplay;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_phoneGetDisplay,
						TASKDEST_HDRVPHONE
						);

	tspSubmitTSPCallWithHDRVPHONE(
			dwRoutingInfo,
			(void *)&params,
			hdPhone,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_phoneGetExtensionID(
		DWORD dwDeviceID,
		DWORD dwTSPIVersion,
		LPPHONEEXTENSIONID lpExtensionID
)
{
	FL_DECLARE_FUNC(0xa6d38028,"TSPI_phoneGetExtensionID");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_phoneGetExtensionID params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_phoneGetExtensionID;

	params.dwDeviceID = dwDeviceID;
	params.dwTSPIVersion = dwTSPIVersion;
	params.lpExtensionID = lpExtensionID;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_phoneGetExtensionID,
						TASKDEST_PHONEID
						);

	tspSubmitTSPCallWithPHONEID(
			dwRoutingInfo,
			(void *)&params,
			dwDeviceID,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_phoneGetGain(
		HDRVPHONE hdPhone,
		DWORD dwHookSwitchDev,
		LPDWORD lpdwGain
)
{
	FL_DECLARE_FUNC(0xa6d38029,"TSPI_phoneGetGain");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_phoneGetGain params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_phoneGetGain;

	params.hdPhone = hdPhone;
	params.dwHookSwitchDev = dwHookSwitchDev;
	params.lpdwGain = lpdwGain;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_phoneGetGain,
						TASKDEST_HDRVPHONE
						);

	tspSubmitTSPCallWithHDRVPHONE(
			dwRoutingInfo,
			(void *)&params,
			hdPhone,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_phoneGetHookSwitch(
		HDRVPHONE hdPhone,
		LPDWORD lpdwHookSwitchDevs
)
{
	FL_DECLARE_FUNC(0xa6d3802a,"TSPI_phoneGetHookSwitch");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_phoneGetHookSwitch params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_phoneGetHookSwitch;

	params.hdPhone = hdPhone;
	params.lpdwHookSwitchDevs = lpdwHookSwitchDevs;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_phoneGetHookSwitch,
						TASKDEST_HDRVPHONE
						);

	tspSubmitTSPCallWithHDRVPHONE(
			dwRoutingInfo,
			(void *)&params,
			hdPhone,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_phoneGetIcon(
		DWORD dwDeviceID,
		LPCWSTR lpszDeviceClass,
		LPHICON lphIcon
)
{
	FL_DECLARE_FUNC(0xa6d3802b,"TSPI_phoneGetIcon");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_phoneGetIcon params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_phoneGetIcon;

	params.dwDeviceID = dwDeviceID;
	params.lpszDeviceClass = lpszDeviceClass;
	params.lphIcon = lphIcon;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_phoneGetIcon,
						TASKDEST_PHONEID
						);

	tspSubmitTSPCallWithPHONEID(
			dwRoutingInfo,
			(void *)&params,
			dwDeviceID,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_phoneGetID(
		HDRVPHONE hdPhone,
		LPVARSTRING lpDeviceID,
		LPCWSTR lpszDeviceClass,
		HANDLE hTargetProcess
)
{
	FL_DECLARE_FUNC(0xa6d3802c,"TSPI_phoneGetID");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_phoneGetID params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_phoneGetID;

	params.hdPhone = hdPhone;
	params.lpDeviceID = lpDeviceID;
	params.lpszDeviceClass = lpszDeviceClass;
	params.hTargetProcess = hTargetProcess;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_phoneGetID,
						TASKDEST_HDRVPHONE
						);

	tspSubmitTSPCallWithHDRVPHONE(
			dwRoutingInfo,
			(void *)&params,
			hdPhone,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_phoneGetLamp(
		HDRVPHONE hdPhone,
		DWORD dwButtonLampID,
		LPDWORD lpdwLampMode
)
{
	FL_DECLARE_FUNC(0xa6d3802d,"TSPI_phoneGetLamp");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_phoneGetLamp params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_phoneGetLamp;

	params.hdPhone = hdPhone;
	params.dwButtonLampID = dwButtonLampID;
	params.lpdwLampMode = lpdwLampMode;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_phoneGetLamp,
						TASKDEST_HDRVPHONE
						);

	tspSubmitTSPCallWithHDRVPHONE(
			dwRoutingInfo,
			(void *)&params,
			hdPhone,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_phoneGetRing(
		HDRVPHONE hdPhone,
		LPDWORD lpdwRingMode,
		LPDWORD lpdwVolume
)
{
	FL_DECLARE_FUNC(0xa6d3802e,"TSPI_phoneGetRing");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_phoneGetRing params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_phoneGetRing;

	params.hdPhone = hdPhone;
	params.lpdwRingMode = lpdwRingMode;
	params.lpdwVolume = lpdwVolume;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_phoneGetRing,
						TASKDEST_HDRVPHONE
						);

	tspSubmitTSPCallWithHDRVPHONE(
			dwRoutingInfo,
			(void *)&params,
			hdPhone,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_phoneGetStatus(
		HDRVPHONE hdPhone,
		LPPHONESTATUS lpPhoneStatus
)
{
	FL_DECLARE_FUNC(0xa6d3802f,"TSPI_phoneGetStatus");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_phoneGetStatus params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_phoneGetStatus;

	params.hdPhone = hdPhone;
	params.lpPhoneStatus = lpPhoneStatus;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_phoneGetStatus,
						TASKDEST_HDRVPHONE
						);

	tspSubmitTSPCallWithHDRVPHONE(
			dwRoutingInfo,
			(void *)&params,
			hdPhone,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_phoneGetVolume(
		HDRVPHONE hdPhone,
		DWORD dwHookSwitchDev,
		LPDWORD lpdwVolume
)
{
	FL_DECLARE_FUNC(0xa6d38030,"TSPI_phoneGetVolume");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_phoneGetVolume params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_phoneGetVolume;

	params.hdPhone = hdPhone;
	params.dwHookSwitchDev = dwHookSwitchDev;
	params.lpdwVolume = lpdwVolume;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_phoneGetVolume,
						TASKDEST_HDRVPHONE
						);

	tspSubmitTSPCallWithHDRVPHONE(
			dwRoutingInfo,
			(void *)&params,
			hdPhone,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_phoneNegotiateExtVersion(
		DWORD dwDeviceID,
		DWORD dwTSPIVersion,
		DWORD dwLowVersion,
		DWORD dwHighVersion,
		LPDWORD lpdwExtVersion
)
{
	FL_DECLARE_FUNC(0xa6d38031,"TSPI_phoneNegotiateExtVersion");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_phoneNegotiateExtVersion params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_phoneNegotiateExtVersion;

	params.dwDeviceID = dwDeviceID;
	params.dwTSPIVersion = dwTSPIVersion;
	params.dwLowVersion = dwLowVersion;
	params.dwHighVersion = dwHighVersion;
	params.lpdwExtVersion = lpdwExtVersion;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_phoneNegotiateExtVersion,
						TASKDEST_PHONEID
						);

	tspSubmitTSPCallWithPHONEID(
			dwRoutingInfo,
			(void *)&params,
			dwDeviceID,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_phoneNegotiateTSPIVersion(
		DWORD dwDeviceID,
		DWORD dwLowVersion,
		DWORD dwHighVersion,
		LPDWORD lpdwTSPIVersion
)
{
	FL_DECLARE_FUNC(0xa6d38032,"TSPI_phoneNegotiateTSPIVersion");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_phoneNegotiateTSPIVersion params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_phoneNegotiateTSPIVersion;

	params.dwDeviceID = dwDeviceID;
	params.dwLowVersion = dwLowVersion;
	params.dwHighVersion = dwHighVersion;
	params.lpdwTSPIVersion = lpdwTSPIVersion;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_phoneNegotiateTSPIVersion,
						TASKDEST_PHONEID
						);

	tspSubmitTSPCallWithPHONEID(
			dwRoutingInfo,
			(void *)&params,
			dwDeviceID,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_phoneSelectExtVersion(
		HDRVPHONE hdPhone,
		DWORD dwExtVersion
)
{
	FL_DECLARE_FUNC(0xa6d38033,"TSPI_phoneSelectExtVersion");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_phoneSelectExtVersion params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_phoneSelectExtVersion;

	params.hdPhone = hdPhone;
	params.dwExtVersion = dwExtVersion;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_phoneSelectExtVersion,
						TASKDEST_HDRVPHONE
						);

	tspSubmitTSPCallWithHDRVPHONE(
			dwRoutingInfo,
			(void *)&params,
			hdPhone,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_phoneSetButtonInfo(
		DRV_REQUESTID dwRequestID,
		HDRVPHONE hdPhone,
		DWORD dwButtonLampID,
		LPPHONEBUTTONINFO const lpButtonInfo
)
{
	FL_DECLARE_FUNC(0xa6d38034,"TSPI_phoneSetButtonInfo");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_phoneSetButtonInfo params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_phoneSetButtonInfo;

	params.dwRequestID = dwRequestID;
	params.hdPhone = hdPhone;
	params.dwButtonLampID = dwButtonLampID;
	params.lpButtonInfo = lpButtonInfo;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_phoneSetButtonInfo,
						TASKDEST_HDRVPHONE
						);

	tspSubmitTSPCallWithHDRVPHONE(
			dwRoutingInfo,
			(void *)&params,
			hdPhone,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_phoneSetData(
		DRV_REQUESTID dwRequestID,
		HDRVPHONE hdPhone,
		DWORD dwDataID,
		LPVOID const lpData,
		DWORD dwSize
)
{
	FL_DECLARE_FUNC(0xa6d38035,"TSPI_phoneSetData");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_phoneSetData params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_phoneSetData;

	params.dwRequestID = dwRequestID;
	params.hdPhone = hdPhone;
	params.dwDataID = dwDataID;
	params.lpData = lpData;
	params.dwSize = dwSize;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_phoneSetData,
						TASKDEST_HDRVPHONE
						);

	tspSubmitTSPCallWithHDRVPHONE(
			dwRoutingInfo,
			(void *)&params,
			hdPhone,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_phoneSetDisplay(
		DRV_REQUESTID dwRequestID,
		HDRVPHONE hdPhone,
		DWORD dwRow,
		DWORD dwColumn,
		LPCWSTR lpsDisplay,
		DWORD dwSize
)
{
	FL_DECLARE_FUNC(0xa6d38036,"TSPI_phoneSetDisplay");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_phoneSetDisplay params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_phoneSetDisplay;

	params.dwRequestID = dwRequestID;
	params.hdPhone = hdPhone;
	params.dwRow = dwRow;
	params.dwColumn = dwColumn;
	params.lpsDisplay = lpsDisplay;
	params.dwSize = dwSize;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_phoneSetDisplay,
						TASKDEST_HDRVPHONE
						);

	tspSubmitTSPCallWithHDRVPHONE(
			dwRoutingInfo,
			(void *)&params,
			hdPhone,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_phoneSetGain(
		DRV_REQUESTID dwRequestID,
		HDRVPHONE hdPhone,
		DWORD dwHookSwitchDev,
		DWORD dwGain
)
{
	FL_DECLARE_FUNC(0xa6d38037,"TSPI_phoneSetGain");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_phoneSetGain params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_phoneSetGain;

	params.dwRequestID = dwRequestID;
	params.hdPhone = hdPhone;
	params.dwHookSwitchDev = dwHookSwitchDev;
	params.dwGain = dwGain;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_phoneSetGain,
						TASKDEST_HDRVPHONE
						);

	tspSubmitTSPCallWithHDRVPHONE(
			dwRoutingInfo,
			(void *)&params,
			hdPhone,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_phoneSetHookSwitch(
		DRV_REQUESTID dwRequestID,
		HDRVPHONE hdPhone,
		DWORD dwHookSwitchDevs,
		DWORD dwHookSwitchMode
)
{
	FL_DECLARE_FUNC(0xa6d38038,"TSPI_phoneSetHookSwitch");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_phoneSetHookSwitch params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_phoneSetHookSwitch;

	params.dwRequestID = dwRequestID;
	params.hdPhone = hdPhone;
	params.dwHookSwitchDevs = dwHookSwitchDevs;
	params.dwHookSwitchMode = dwHookSwitchMode;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_phoneSetHookSwitch,
						TASKDEST_HDRVPHONE
						);

	tspSubmitTSPCallWithHDRVPHONE(
			dwRoutingInfo,
			(void *)&params,
			hdPhone,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_phoneSetLamp(
		DRV_REQUESTID dwRequestID,
		HDRVPHONE hdPhone,
		DWORD dwButtonLampID,
		DWORD dwLampMode
)
{
	FL_DECLARE_FUNC(0xa6d38039,"TSPI_phoneSetLamp");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_phoneSetLamp params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_phoneSetLamp;

	params.dwRequestID = dwRequestID;
	params.hdPhone = hdPhone;
	params.dwButtonLampID = dwButtonLampID;
	params.dwLampMode = dwLampMode;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_phoneSetLamp,
						TASKDEST_HDRVPHONE
						);

	tspSubmitTSPCallWithHDRVPHONE(
			dwRoutingInfo,
			(void *)&params,
			hdPhone,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_phoneSetRing(
		DRV_REQUESTID dwRequestID,
		HDRVPHONE hdPhone,
		DWORD dwRingMode,
		DWORD dwVolume
)
{
	FL_DECLARE_FUNC(0xa6d3803a,"TSPI_phoneSetRing");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_phoneSetRing params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_phoneSetRing;

	params.dwRequestID = dwRequestID;
	params.hdPhone = hdPhone;
	params.dwRingMode = dwRingMode;
	params.dwVolume = dwVolume;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_phoneSetRing,
						TASKDEST_HDRVPHONE
						);

	tspSubmitTSPCallWithHDRVPHONE(
			dwRoutingInfo,
			(void *)&params,
			hdPhone,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_phoneSetStatusMessages(
		HDRVPHONE hdPhone,
		DWORD dwPhoneStates,
		DWORD dwButtonModes,
		DWORD dwButtonStates
)
{
	FL_DECLARE_FUNC(0xa6d3803b,"TSPI_phoneSetStatusMessages");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_phoneSetStatusMessages params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_phoneSetStatusMessages;

	params.hdPhone = hdPhone;
	params.dwPhoneStates = dwPhoneStates;
	params.dwButtonModes = dwButtonModes;
	params.dwButtonStates = dwButtonStates;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_phoneSetStatusMessages,
						TASKDEST_HDRVPHONE
						);

	tspSubmitTSPCallWithHDRVPHONE(
			dwRoutingInfo,
			(void *)&params,
			hdPhone,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}


LONG
TSPIAPI
TSPI_phoneSetVolume(
		DRV_REQUESTID dwRequestID,
		HDRVPHONE hdPhone,
		DWORD dwHookSwitchDev,
		DWORD dwVolume
)
{
	FL_DECLARE_FUNC(0xa6d3803c,"TSPI_phoneSetVolume");
	FL_DECLARE_STACKLOG(sl, 1000);
	TASKPARAM_TSPI_phoneSetVolume params;
	LONG lRet = LINEERR_OPERATIONFAILED;

	params.dwStructSize = sizeof(params);
	params.dwTaskID = TASKID_TSPI_phoneSetVolume;

	params.dwRequestID = dwRequestID;
	params.hdPhone = hdPhone;
	params.dwHookSwitchDev = dwHookSwitchDev;
	params.dwVolume = dwVolume;
	DWORD dwRoutingInfo = ROUTINGINFO(
						TASKID_TSPI_phoneSetVolume,
						TASKDEST_HDRVPHONE
						);

	tspSubmitTSPCallWithHDRVPHONE(
			dwRoutingInfo,
			(void *)&params,
			hdPhone,
			&lRet,
			&sl
			);
	sl.Dump(COLOR_TSPI);

	return lRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\tsp\tspret.h ===
// 
// Copyright (c) 1996-1997 Microsoft Corporation.
//
//
// Component
//
//		Unimodem 5.0 TSP (Win32, user mode DLL)
//
// File
//
//		TSPRET.H
//		All the internal TSP error codes.
//
// History
//
//		11/16/1996  JosephJ Created
//
//

typedef ULONG_PTR TSPRETURN;

#define IDERR(_retval) FL_BYTERR_FROM_RETVAL(_retval)

LONG tspTSPIReturn(TSPRETURN tspRet);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\tsp\umrtl.h ===
// Copyright (c) 1996-1997 Microsoft Corporation.
//
//
// Component
//
//		Unimodem 5.0 TSP (Win32, user mode DLL)
//
// File
//
//		UMRTL.H
//		Header for Misc. utility functions interfacing to external components.
//		Candidates for the Unimodem run-time library.
//
// History
//
//		01/06/1997  JosephJ Created
//
//


DWORD
UmRtlGetDefaultCommConfig(
    HKEY  hKey,
    LPCOMMCONFIG pcc,
    LPDWORD pdwSize
	);


//----------------	::Checksum -----------------------------------
// Compute a 32-bit checksum of the specified bytes
// 0 is retured if pb==NULL or cb==0 
DWORD Checksum(const BYTE *pb, UINT cb);

//----------------	::AddToChecksumDW ----------------------------
// Set *pdwChkSum to a new checksum, computed using it's previous value and dw.
void AddToChecksumDW(DWORD *pdwChkSum, DWORD dw);







typedef void * HCONFIGBLOB;

//
// NOTE: it is upto the caller to serialize calls to
// access the various UmRtlDevCfg apis...
// TODO: At the point where apis are added to update and commit changes,
// we can add serialization. At this point there's no point.
// Note in particular that there's no point in serializing Free and the
// other apis because the other apis will fault if accessing a free'd blob.
//
//

HCONFIGBLOB
UmRtlDevCfgCreateBlob(
        HKEY hKey
        );

void       
UmRtlDevCfgFreeBlob(
        HCONFIGBLOB hBlob
        );

BOOL 
UmRtlDevCfgGetDWORDProp(
        HCONFIGBLOB hBlob,
        DWORD dwMajorPropID,
        DWORD dwMinorPropID,
        DWORD *dwProp
        );

BOOL
UmRtlDevCfgGetStringPropW(
        HCONFIGBLOB hBlob,
        DWORD dwMajorPropID,
        DWORD dwMinorPropID,
        WCHAR **ppwsz
        );

BOOL
UmRtlDevCfgGetStringPropA(
        HCONFIGBLOB hBlob,
        DWORD dwMajorPropID,
        DWORD dwMinorPropID,
        CHAR **ppwsz
        );

// Returns ERROR code.
DWORD
UmRtlRegGetDWORD(
        HKEY hk,
        LPCTSTR lpctszName,
        DWORD dwFlags,          // One of the UMRTL_GETDWORD_ flags
        LPDWORD lpdw
        );

#define UMRTL_GETDWORD_FROMDWORD   (0x1 << 0)
#define UMRTL_GETDWORD_FROMBINARY1 (0x1 << 1)
#define UMRTL_GETDWORD_FROMBINARY4 (0x1 << 2)
#define UMRTL_GETDWORD_FROMANY  (UMRTL_GETDWORD_FROMDWORD       \
                                 | UMRTL_GETDWORD_FROMBINARY1   \
                                 | UMRTL_GETDWORD_FROMBINARY4)



//============= MAJOR PROPERTY IDS ==========================

#define UMMAJORPROPID_IDENTIFICATION 1L
#define UMMAJORPROPID_BASICCAPS      2L


//============= MINOR PROPERTY IDS ==========================

// For  UMMAJORPROPID_IDENTIFICATION
#define UMMINORPROPID_NAME              1L  // String
#define UMMINORPROPID_PERMANENT_ID      2L  // DWORD


// For UMMAJORPROPID_BASICCAPS
#define UMMINORPROPID_BASIC_DEVICE_CAPS     1L // DWORD -- BASICDEVCAPS_* below.


//============ SOME DWORD PROPERTY DEFINITIONS =============

//  FOR UMMINORPROPID_BASIC_DEVICE_CAPS
// Combination of the following flags:
#define BASICDEVCAPS_IS_LINE_DEVICE  (0x1<<0)
#define BASICDEVCAPS_IS_PHONE_DEVICE (0x1<<1)


// 3/1/1997 JosephJ. The following are the voice profile flags
//      used by Unimdoem/V, and the files where they were used.
//      For NT5.0, we don't use the voice profile flags directly.
//      Rather we define our own internal ones and define only
//      those that we need. These internal properties are maintained
//      in field dwProperties of this struct.
//      TODO: define minidriver capabilities structure and api to
//      get a set of meaningful properties without the TSP having
//      to get it directly from the registry.
//
// VOICEPROF_CLASS8ENABLED             : <many places>
// VOICEPROF_HANDSET                   : cfgdlg.c phone.c
// VOICEPROF_NO_SPEAKER_MIC_MUTE       : cfgdlg.c phone.c
// VOICEPROF_SPEAKER                   : cfgdlg.c modem.c phone.c
// VOICEPROF_NO_CALLER_ID              : modem.c mdmutil.c
// VOICEPROF_MODEM_EATS_RING           : modem.c
// VOICEPROF_MODEM_OVERRIDES_HANDSET   : modem.c
// VOICEPROF_MODEM_OVERRIDES_HANDSET   : modem.c
// 
// VOICEPROF_NO_DIST_RING              : modem.c
// VOICEPROF_SIERRA                    : modem.c
// VOICEPROF_MIXER                     : phone.c
// 
// VOICEPROF_MONITORS_SILENCE          : unimdm.c
// VOICEPROF_NO_GENERATE_DIGITS        : unimdm.c
// VOICEPROF_NO_MONITOR_DIGITS         : unimdm.c
//
//

// Following bit set IFF the mode supports automated voice.
//
#define fVOICEPROP_CLASS_8                  (0x1<<0)

// If set, following bit indicates that the handset is deactivated
// when the modem is active (whatever "active" means -- perhaps off
//  hook?).
//
// If set, incoming interactive voice calls are not permitted, and
// the TSP brings up a TalkDrop dialog on outgoing interactive
// voice calls (well not yet as of 3/1/1997, but unimodem/v did
// this).
//
#define fVOICEPROP_MODEM_OVERRIDES_HANDSET  (0x1<<1)


#define fVOICEPROP_MONITOR_DTMF             (0x1<<2)
#define fVOICEPROP_MONITORS_SILENCE         (0x1<<3)
#define fVOICEPROP_GENERATE_DTMF            (0x1<<4)

// Following two are set iff the device supports handset and 
// speakerphone, respectively.
//
#define fVOICEPROP_HANDSET                  (0x1<<5)
#define fVOICEPROP_SPEAKER                  (0x1<<6)


// Supports mike mute
#define fVOICEPROP_MIKE_MUTE                (0x1<<7)

// Supports duplex voice
#define fVOICEPROP_DUPLEX                   (0x1<<8)



#define fDIAGPROP_STANDARD_CALL_DIAGNOSTICS 0x1



typedef struct
{
    DWORD dwID;
    DWORD dwData;
    char *pStr;

} IDSTR; // for lack of a better name!


UINT ReadCommandsA(
        IN  HKEY hKey,
        IN  CHAR *pSubKeyName,
        OUT CHAR **ppValues // OPTIONAL
        );
//
// Reads all values (assumed to be REG_SZ) with names
// in the sequence "1", "2", "3".
//
// If ppValues is non-NULL it will be set to a  MULTI_SZ array
// of values.
//
// The return value is the number of values, or 0 if there is an error
// (or none).
//

UINT ReadIDSTR(
        IN  HKEY hKey,
        IN  CHAR *pSubKeyName,
        IN  IDSTR *pidstrNames,
        IN  UINT cNames,
        BOOL fMandatory,
        OUT IDSTR **ppidstrValues, // OPTIONAL
        OUT char **ppstrValues    // OPTIONAL
        );
//
//
// Reads the specified names from the specified subkey.
//
// If fMandatory is TRUE, all the specified names must exist, else the
// function will return 0 (failure).
//
// Returns the number of names that match.
//
// If ppidstrValues is non null, it will be set to
// a LocalAlloced array of IDSTRs, each IDSTR giving the ID and value
// associated with the corresponding name.
//
// The pstr pointo into a multi-sz LocalAlloced string, whose start is
// pointed to by ppstrValues on exit.
//
// If ppstrValues is NULL but ppidstrValues is non-null, the pStr field
// if the IDSTR entries is NULL.
//


void
expand_macros_in_place(
    char *szzCommands
    );
//
//  Expands <xxx> macros IN-place.
//  Currently only works for <cr> and <lf> macros.
//  Furthermore, the charecters NULL and  cFILLER are assumed to not be a
//  valid chacters, either before or after the expansion.
//
#define cFILLER '\xff'
//  Note -- don't try #define cFILLER 0xff -- it doesn't work,
//  because the test (*pc!=cFILLER) always succeeds, because when
//  *pc is upgraded to int, it becomes (-1), which does not equal 0xff
//
//  Sample Inputs->Outputs:
//  AT<cr>       -> AT\r
//  AT<lf>       -> AT\n
//  <cr>         -> \r
//  <Cr>         -> \r
//  <cR>         -> \r
//  <CR>         -> \r
//  <<cr>        -> <\r
//  <cr><lf>     -> \r\n
//  <cr>><<lf>   -> \r><\n
//  <cr<<lf<lf>> -> <cr<<lf\n>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\umcfg\docomm.h ===
void
do_open_comm(DWORD dwCom);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\umcfg\dotsp.cpp ===
//****************************************************************************
//
//  Module:     UMCONFIG
//  File:       DOTSP.C
//
//  Copyright (c) 1992-1998, Microsoft Corporation, all rights reserved
//
//  Revision History
//
//
//  10/17/98     JosephJ             Created
//
//
//      TAPI-related utilities
//
//
//****************************************************************************
#include "tsppch.h"
#include <tspnotif.h>
#include "parse.h"
#include "dotsp.h"

void
do_dump_tspdev(DWORD dwDeviceID)
{

    printf("DO dump tspdev %ld\n", dwDeviceID);
    UnimodemNotifyTSP (TSPNOTIF_TYPE_DEBUG,
                       dwDeviceID,
                       0, NULL,
                       FALSE);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\umcfg\dotapi.cpp ===
//****************************************************************************
//
//  Module:     UMCONFIG
//  File:       DOTAPI.C
//
//  Copyright (c) 1992-1996, Microsoft Corporation, all rights reserved
//
//  Revision History
//
//
//  10/17/97     JosephJ             Created
//
//
//      TAPI-related utilities
//
//
//****************************************************************************
#include "tsppch.h"
#include "parse.h"
#include "dotapi.h"

static const TCHAR cszTapiKey[] = TEXT(REGSTR_PATH_SETUP  "\\Telephony");
static const TCHAR cszTapi32DebugLevel[] = TEXT("Tapi32DebugLevel");
static const TCHAR cszTapisrvDebugLevel[] = TEXT("TapisrvDebugLevel");

void
do_get_debug_tapi(TOKEN tok)
{


    // Open the tapi registry key...
    HKEY hk=NULL;
    const TCHAR *cszValue = NULL;
	DWORD dwRet = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    cszTapiKey,
                    0,
                    KEY_READ,
                    &hk
                    );

    if (dwRet != ERROR_SUCCESS)
    {
        printf("Could not open key %s\n",cszTapiKey);
        hk=NULL;
        goto end;
    }

    if (tok==TOK_TAPI32)
    {
        cszValue = cszTapi32DebugLevel;
    }
    else if (tok==TOK_TAPISRV)
    {
        cszValue = cszTapisrvDebugLevel;
    }
    else
    {
        printf("Unknown component (%d)\n", tok);
        goto end;
    }

    // Read the Key
    {
        DWORD dwValue=0;
        DWORD dwRegType=0;
        DWORD dwRegSize = sizeof(dwValue);
        dwRet = RegQueryValueEx(
                    hk,
                    cszValue,
                    NULL,
                    &dwRegType,
                    (BYTE*) &dwValue,
                    &dwRegSize
                );

        // TODO: Change ID from REG_BINARY to REG_DWORD in modem
        //       class installer.
        if (dwRet == ERROR_SUCCESS  && dwRegType == REG_DWORD)
        {
            printf("\t%lu\n", dwValue);
        }
        else
        {
            printf("\tCouldn't read value %s\n", cszValue);
        }
    }


end:

    if (hk)
    {
        RegCloseKey(hk);
        hk=NULL;
    }
}

void
do_set_debug_tapi(TOKEN tok, DWORD dw)
{

    // Validate parameters
    if (dw > 99)
    {
        printf ("Value should be <= 99; setting it to 99.\n");
        dw = 99;
    }

    // Open the tapi registry key...
    HKEY hk=NULL;
    const TCHAR *cszValue = NULL;
	DWORD dwRet = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    cszTapiKey,
                    0,
                    KEY_WRITE,
                    &hk
                    );

    if (dwRet != ERROR_SUCCESS)
    {
        printf("Could not open key %s\n",cszTapiKey);
        hk=NULL;
        goto end;
    }

    if (tok==TOK_TAPI32)
    {
        cszValue = cszTapi32DebugLevel;
    }
    else if (tok==TOK_TAPISRV)
    {
        cszValue = cszTapisrvDebugLevel;
    }
    else
    {
        printf("Unknown component (%d)\n", tok);
        goto end;
    }

    //  Set the value.
    {
        dwRet  = RegSetValueEx(
                    hk,
                    cszValue,
                    0,
                    REG_DWORD,
                    (LPBYTE)&dw,
                    sizeof(dw)
                    );

        // TODO: Change ID from REG_BINARY to REG_DWORD in modem
        //       class installer.
        if (dwRet == ERROR_SUCCESS)
        {
            printf("\tSet %s to %lu\n", cszValue, dw);
        }
        else
        {
            printf("\tCouldn't set value %s\n", cszValue);
        }
    }


end:

    if (hk)
    {
        RegCloseKey(hk);
        hk=NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\tsp\umrtl.cpp ===
// Copyright (c) 1996-1997 Microsoft Corporation.
//
//
// Component
//
//		Unimodem 5.0 TSP (Win32, user mode DLL)
//
// File
//
//		UMRTL.CPP
//		Misc. utility functions interfacing to external components.
//		Candidates for the Unimodem run-time library.
//
// History
//
//		01/06/1997  JosephJ Created
//
//

#include "tsppch.h"
#include "fastlog.h"
//#include "umrtl.h"

//
// 01/05/1997 JosephJ
//     TODO: UmRtlGetDefaultConfig and its supporting functions
//     are brazenly stolen from modemui.dll (modemui.c).
//     Strictly speaking we should use the GetCommConfig win32 api
//     to get this information, but it's too slow. NT4.0 called
//     directly into "UnimodemGetDefaultConfig" exported by modemui.dll instead.
//     We short-circuit this further by stealing the code from modemui.dll. This
//     is a TEMPORARY solution. We should investigate why GetDefaultCommConfig
//     is taking as long as it is and fix the problem there. Anyway, this stuff
//     should not be called from the tsp -- it should be pushed down to the
//     mini driver, so that's another thing to do.
//

// Following macros taken unmodified from modemui.c in (nt4.0) modemui.dll
#define DEFAULT_INACTIVITY_SCALE   10    // == decasecond units
#define CB_COMMCONFIG_HEADER        FIELD_OFFSET(COMMCONFIG, wcProviderData)
#define CB_PRIVATESIZE              (CB_COMMCONFIG_HEADER)
#define CB_PROVIDERSIZE             (sizeof(MODEMSETTINGS))
#define CB_COMMCONFIGSIZE           (CB_PRIVATESIZE+CB_PROVIDERSIZE)
#define PmsFromPcc(pcc)             ((LPMODEMSETTINGS)(pcc)->wcProviderData)
#define CB_MODEMSETTINGS_HEADER     FIELD_OFFSET(MODEMSETTINGS, dwCallSetupFailTimer)
#define CB_MODEMSETTINGS_TAIL       (sizeof(MODEMSETTINGS) - FIELD_OFFSET(MODEMSETTINGS, dwNegotiatedModemOptions))
#define CB_MODEMSETTINGS_OVERHEAD   (CB_MODEMSETTINGS_HEADER + CB_MODEMSETTINGS_TAIL)



TCHAR const c_szDefault[] = REGSTR_KEY_DEFAULT;
TCHAR const FAR c_szDCB[] = TEXT("DCB");
TCHAR const FAR c_szInactivityScale[] = TEXT("InactivityScale");



// GetInactivityTimeoutScale taken from modemui.c in (nt4.0) modemui.dll
// Returns value of the InactivityScale value in the registry.
DWORD
GetInactivityTimeoutScale(
    HKEY hkey
	)
{
    DWORD dwInactivityScale;
    DWORD dwType;
    DWORD cbData;
	DWORD dwRet;

    cbData = sizeof(DWORD);
    dwRet = RegQueryValueEx(
					hkey,
					c_szInactivityScale,
					NULL,
					&dwType,
					(LPBYTE)&dwInactivityScale,
					&cbData
					);
    if (ERROR_SUCCESS != dwRet  ||
        REG_BINARY    != dwType ||
        sizeof(DWORD) != cbData ||
        0             == dwInactivityScale)
	{
        dwInactivityScale = DEFAULT_INACTIVITY_SCALE;
	}

    return dwInactivityScale;
}


// RegQueryModemSettings taken from modenui.c in (nt4.0) modemui.dll
// Purpose: Gets a MODEMSETTINGS struct from the registry.  Also
//          sets *pdwSize bigger if the data in the registry includes
//          extra data.
//
DWORD RegQueryModemSettings(
    HKEY hkey,
    LPMODEMSETTINGS pms,
    LPDWORD pdwSize         // Size of modem settings struct
	)
{
    DWORD dwRet;
    DWORD cbData;
    DWORD cbRequiredSize;

    // Is the MODEMSETTINGS ("Default") value in the driver key?
    dwRet = RegQueryValueEx(hkey, c_szDefault, NULL, NULL, NULL, &cbData);
    if (ERROR_SUCCESS == dwRet)
        {
        // Yes

        // (Remember the Default value is a subset of the MODEMSETTINGS
        // structure.  We also want to support variable sized structures.
        // The minimum must be sizeof(MODEMSETTINGS).)
        cbRequiredSize = cbData + CB_MODEMSETTINGS_OVERHEAD;

        // Is the size in the registry okay?
        if (*pdwSize < cbRequiredSize)
            {
            // No
            dwRet = ERROR_INSUFFICIENT_BUFFER;
            *pdwSize = cbRequiredSize;
            }
        else
            {
            // Yes; get the MODEMSETTINGS from the registry
            // Set the fields whose values are *not* in the registry
            pms->dwActualSize = cbRequiredSize;
            pms->dwRequiredSize = cbRequiredSize;
            pms->dwDevSpecificOffset = 0;
            pms->dwDevSpecificSize = 0;

            dwRet = RegQueryValueEx(hkey, c_szDefault, NULL, NULL,
                (LPBYTE)&pms->dwCallSetupFailTimer, &cbData);
            pms->dwInactivityTimeout *= GetInactivityTimeoutScale(hkey);

            *pdwSize = cbData + CB_MODEMSETTINGS_OVERHEAD;
            }
        }
    return dwRet;
}

// RegQueryDCB taken from modemui.c in (nt4.0) modemui.dll
// Purpose: Gets a WIN32DCB from the registry.
//
DWORD RegQueryDCB(
    HKEY hkey,
    WIN32DCB FAR * pdcb
	)
{
    DWORD dwRet = ERROR_BADKEY;
    DWORD cbData = 0;

    ASSERT(pdcb);

    // Does the DCB key exist in the driver key?
    if (ERROR_SUCCESS == RegQueryValueEx(hkey, c_szDCB, NULL, NULL, NULL, &cbData))
        {
        // Yes; is the size in the registry okay?
        if (sizeof(*pdcb) < cbData)
            {
            // No; the registry has bogus data
            dwRet = ERROR_BADDB;
            }
        else
            {
            // Yes; get the DCB from the registry
            if (ERROR_SUCCESS == RegQueryValueEx(hkey, c_szDCB, NULL, NULL, (LPBYTE)pdcb, &cbData))
                {
                if (sizeof(*pdcb) == pdcb->DCBlength)
                    {
                    dwRet = NO_ERROR;
                    }
                else
                    {
                    dwRet = ERROR_BADDB;
                    }
                }
            else
                {
                dwRet = ERROR_BADKEY;
                }
            }
        }

    return dwRet;
}


// UmRtlGetDefaultCommConfig adapted from UnimodemGetDefaultCommConfig
// in modemui.c (nt4.0) modemui.dll.
DWORD
UmRtlGetDefaultCommConfig(
    HKEY  hKey,
    LPCOMMCONFIG pcc,
    LPDWORD pdwSize
	)
{

    DWORD dwRet;
    DWORD cbSizeMS;
    DWORD cbRequired;

    // (The provider size is the size of MODEMSETTINGS and its
    // private data.)

    if (CB_PRIVATESIZE > *pdwSize)    // Prevent unsigned rollover
        cbSizeMS = 0;
    else
        cbSizeMS = *pdwSize - CB_PRIVATESIZE;

    dwRet = RegQueryModemSettings(hKey, PmsFromPcc(pcc), &cbSizeMS);
    ASSERT(cbSizeMS >= sizeof(MODEMSETTINGS));

    // Is the provided size too small?
    cbRequired = CB_PRIVATESIZE + cbSizeMS;

    if (cbRequired > *pdwSize)
        {
        // Yes
        dwRet = ERROR_INSUFFICIENT_BUFFER;

        // Ask for a size to fit the new format
        *pdwSize = cbRequired;
        }

    if (ERROR_SUCCESS == dwRet)
        {

        *pdwSize = cbRequired;

        // Initialize the commconfig structure
        pcc->dwSize = *pdwSize;
        pcc->wVersion = COMMCONFIG_VERSION_1;
        pcc->dwProviderSubType = PST_MODEM;
        pcc->dwProviderOffset = CB_COMMCONFIG_HEADER;
        pcc->dwProviderSize = cbSizeMS;

        dwRet = RegQueryDCB(hKey, &pcc->dcb);

        }

    return dwRet;
}


#define MIN_CALL_SETUP_FAIL_TIMER   1
#define MIN_INACTIVITY_TIMEOUT      0

/*----------------------------------------------------------
Purpose: Set dev settings info in the registry, after checking
         for legal values.

Returns: One of ERROR_
Cond:    --
*/
DWORD
RegSetModemSettings(
    HKEY hkeyDrv,
    LPMODEMSETTINGS pms)
{
    DWORD dwRet;
    DWORD cbData;
    DWORD dwInactivityScale;
    DWORD dwInactivityTimeoutTemp;
    REGDEVCAPS regdevcaps;
    REGDEVSETTINGS regdevsettings;

    TCHAR const c_szDeviceCaps[] = REGSTR_VAL_PROPERTIES;

    // Read in the Properties line from the registry.
    cbData = sizeof(REGDEVCAPS);
    dwRet = RegQueryValueEx(hkeyDrv, c_szDeviceCaps, NULL, NULL,
                            (LPBYTE)&regdevcaps, &cbData);

    if (ERROR_SUCCESS == dwRet)
        {
        // Read in existing regdevsettings, so that we can handle error cases below.
        cbData = sizeof(REGDEVSETTINGS);
        dwRet = RegQueryValueEx(hkeyDrv, c_szDefault, NULL, NULL,
                                (LPBYTE)&regdevsettings, &cbData);
        }

    if (ERROR_SUCCESS == dwRet)
        {
        // copy new REGDEVSETTINGS while checking validity of each option (ie, is the option available?)
        // dwCallSetupFailTimer - MIN_CALL_SETUP_FAIL_TIMER <= xxx <= ModemDevCaps->dwCallSetupFailTimer
        if (pms->dwCallSetupFailTimer > regdevcaps.dwCallSetupFailTimer)           // max
            {
            regdevsettings.dwCallSetupFailTimer = regdevcaps.dwCallSetupFailTimer;
            }
        else
            {
            if (pms->dwCallSetupFailTimer < MIN_CALL_SETUP_FAIL_TIMER)             // min
                {
                regdevsettings.dwCallSetupFailTimer = MIN_CALL_SETUP_FAIL_TIMER;
                }
            else
                {
                regdevsettings.dwCallSetupFailTimer = pms->dwCallSetupFailTimer;   // dest = src
                }
            }

        // convert dwInactivityTimeout to registry scale
        dwInactivityScale = GetInactivityTimeoutScale(hkeyDrv);
        dwInactivityTimeoutTemp = pms->dwInactivityTimeout / dwInactivityScale +
                                  (pms->dwInactivityTimeout % dwInactivityScale ? 1 : 0);

        // dwInactivityTimeout - MIN_INACTIVITY_TIMEOUT <= xxx <= ModemDevCaps->dwInactivityTimeout
        if (dwInactivityTimeoutTemp > regdevcaps.dwInactivityTimeout)              // max
            {
            regdevsettings.dwInactivityTimeout = regdevcaps.dwInactivityTimeout;
            }
        else
            {
            if ((dwInactivityTimeoutTemp + 1) < (MIN_INACTIVITY_TIMEOUT + 1))
                // min
                {
                regdevsettings.dwInactivityTimeout = MIN_INACTIVITY_TIMEOUT;
                }
            else
                {
                regdevsettings.dwInactivityTimeout = dwInactivityTimeoutTemp;      // dest = src
                }
            }

        // dwSpeakerVolume - check to see if selection is possible
        if ((1 << pms->dwSpeakerVolume) & regdevcaps.dwSpeakerVolume)
            {
            regdevsettings.dwSpeakerVolume = pms->dwSpeakerVolume;
            }

        // dwSpeakerMode - check to see if selection is possible
        if ((1 << pms->dwSpeakerMode) & regdevcaps.dwSpeakerMode)
            {
            regdevsettings.dwSpeakerMode = pms->dwSpeakerMode;
            }

        // dwPreferredModemOptions - mask out anything we can't set
        regdevsettings.dwPreferredModemOptions = pms->dwPreferredModemOptions &
                                                 (regdevcaps.dwModemOptions | MDM_MASK_EXTENDEDINFO);

        cbData = sizeof(REGDEVSETTINGS);
        dwRet = RegSetValueEx(hkeyDrv, c_szDefault, 0, REG_BINARY,
                              (LPBYTE)&regdevsettings, cbData);
        }
    return dwRet;
}

/*----------------------------------------------------------
Purpose: Entry point for SetDefaultCommConfig

Returns: standard error value in winerror.h
Cond:    --
*/
DWORD
APIENTRY
UmRtlSetDefaultCommConfig(
    IN HKEY         hKey,
    IN LPCOMMCONFIG pcc,
    IN DWORD        dwSize)           // This is ignored
{
    DWORD dwRet = ERROR_INVALID_PARAMETER;
    //
    // 10/26/1997 JosephJ: the last two checks below are new for NT5.0
    //            Also, for the middle two checks, ">" has been replaced
    //            by "!=".
    //
    if ( NULL == pcc
        || CB_PROVIDERSIZE != pcc->dwProviderSize
        || FIELD_OFFSET(COMMCONFIG, wcProviderData) != pcc->dwProviderOffset
        || pcc->dwSize != dwSize           // <- NT5.0
        || CB_COMMCONFIGSIZE != dwSize)    // <- NT5.0
    {
        goto end;
    }

    {
        DWORD cbData;
        LPMODEMSETTINGS pms = PmsFromPcc(pcc);

        // Write the DCB to the driver key
        cbData = sizeof(WIN32DCB);

        pcc->dcb.DCBlength=cbData;


        ASSERT (0 < pcc->dcb.BaudRate);

        dwRet = RegSetValueEx(
                    hKey,
                    c_szDCB,
                    0,
                    REG_BINARY,
                    (LPBYTE)&pcc->dcb,
                    cbData
                    );

        if (ERROR_SUCCESS == dwRet) {

            dwRet = RegSetModemSettings(hKey, pms);

        }
    }


end:


    return dwRet;
}



#if 1

// 8/16/96 JosephJ Following table built using the CRC code in cpl\detect.c.
unsigned long ulCrcTable[256] = {
	0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419,
	0x706af48f, 0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4,
	0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07,
	0x90bf1d91, 0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de,
	0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7, 0x136c9856,
	0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,
	0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4,
	0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,
	0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3,
	0x45df5c75, 0xdcd60dcf, 0xabd13d59, 0x26d930ac, 0x51de003a,
	0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599,
	0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
	0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190,
	0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f,
	0x9fbfe4a5, 0xe8b8d433, 0x7807c9a2, 0x0f00f934, 0x9609a88e,
	0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,
	0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed,
	0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,
	0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3,
	0xfbd44c65, 0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2,
	0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a,
	0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5,
	0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa, 0xbe0b1010,
	0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
	0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17,
	0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6,
	0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615,
	0x73dc1683, 0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8,
	0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1, 0xf00f9344,
	0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,
	0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a,
	0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,
	0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1,
	0xa6bc5767, 0x3fb506dd, 0x48b2364b, 0xd80d2bda, 0xaf0a1b4c,
	0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef,
	0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
	0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe,
	0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31,
	0x2cd99e8b, 0x5bdeae1d, 0x9b64c2b0, 0xec63f226, 0x756aa39c,
	0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,
	0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b,
	0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,
	0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1,
	0x18b74777, 0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c,
	0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45, 0xa00ae278,
	0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7,
	0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc, 0x40df0b66,
	0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
	0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605,
	0xcdd70693, 0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8,
	0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b,
	0x2d02ef8d
};


//----------------	::Checksum -----------------------------------
// Compute a 32-bit checksum of the specified bytes
// 0 is retured if pb==NULL or cb==0
DWORD Checksum(const BYTE *pb, UINT cb)
{
	const UINT	MAXSIZE = 1024;
	DWORD dwRet = 0;
	//DWORD rgdwBuf[MAXSIZE/sizeof(DWORD)];

	if (!pb || !cb) goto end;

    dwRet = 0xFFFFFFFF;

	while (cb--)
	{
		dwRet = 	((dwRet >> 8) & 0x00FFFFFF)
				 ^  ulCrcTable[(dwRet ^ *pb++) & 0xFF];
	}

    // Finish up CRC
    dwRet ^= 0xFFFFFFFF;

#if (TODO)
	// If buffer not dword aligned, we copy it over to a buffer which is,
	// and pad it
	if (cb & 0x3)
	{
		if (cb>=MAXSIZE)
		{
			ASSERT(FALSE);
			goto end;
		}
		CopyMemory(rgdwBuf, pb, cb);
	}
#endif (TODO)

end:
	return dwRet;
}


//----------------	::AddToChecksumDW ----------------------------
// Set *pdwChkSum to a new checksum, computed using it's previous value and dw.
void AddToChecksumDW(DWORD *pdwChkSum, DWORD dw)
{
	DWORD rgdw[2];
	rgdw[0] = *pdwChkSum;
	rgdw[1] = dw;

	*pdwChkSum  = Checksum((const BYTE *) rgdw, sizeof(rgdw));
}
#endif
// ===========================================================================
// Device Property Blob APIs. TODO: Move these to the minidriver.
//============================================================================




static const TCHAR cszFriendlyName[] = TEXT("FriendlyName");
static const TCHAR cszDeviceType[]   = TEXT("DeviceType");
static const TCHAR cszID[]           = TEXT("ID");
static const TCHAR cszProperties[]   = TEXT("Properties");
static const TCHAR cszSettings[]     = TEXT("Settings");
static const TCHAR cszDialSuffix[]   = TEXT("DialSuffix");
static const TCHAR cszVoiceProfile[]             = TEXT("VoiceProfile");
static const TCHAR cszPermanentIDKey[]   = TEXT("ID");

// 2/26/1997 JosephJ Many other registry keys related to forwarding, distinctive
//      ringing and mixer were here in unimodem/v but I have not
//      migrated them.

// 2/28/1997 JosephJ
//      The following are new for NT5.0. These contain the wave device ID
//      for record and play. As of 2/28/1997, we haven't addressed how these
//      get in the registry -- basically this is a hack.
//

#define MAX_DEVICE_LENGTH 128

typedef struct
{
    #define dwPROPERTYBLOBSIG  0x806f534d
    DWORD dwSig;    // should be set to the above.

    // Identification...
    WCHAR rgwchName[MAX_DEVICE_LENGTH];
    DWORD dwPID; // Permanent ID;

    REGDEVCAPS rdc;

    DWORD dwBasicCaps;  // LINE/PHONE
    DWORD dwLineCaps;   // VOICE/ANALOGDATA/SERIAL/PARALLEL
    DWORD dwDialCaps;   // partial dialing, etc...
    DWORD dwVoiceCaps; // voicemodem caps
    DWORD dwDiagnosticsCaps; // CALLDIAGNOSTICS..

} PROPERTYBLOB;

#define VALIDATED_PBLOB(_pblob) \
        (((_pblob) && (((PROPERTYBLOB*)(_pblob))->dwSig == dwPROPERTYBLOBSIG)) \
         ? (PROPERTYBLOB*)(_pblob) \
         : NULL)


HCONFIGBLOB
UmRtlDevCfgCreateBlob(
        HKEY hkDevice
        )
{

    PROPERTYBLOB *pBlob = (PROPERTYBLOB *)
                                 ALLOCATE_MEMORY(sizeof(PROPERTYBLOB));
    BOOL fRet = FALSE;
    DWORD dwRet = 0;
	DWORD dwRegSize;
	DWORD dwRegType;
    DWORD dwData=0;

    if (!pBlob) goto end;

    pBlob->dwSig  = dwPROPERTYBLOBSIG;


    // Get the Friendly Name
    //
	dwRegSize = sizeof(pBlob->rgwchName);
    dwRet = RegQueryValueExW(
                hkDevice,
                cszFriendlyName,
                NULL,
                &dwRegType,
                (BYTE*) pBlob->rgwchName,
                &dwRegSize
            );

    if (dwRet != ERROR_SUCCESS || dwRegType != REG_SZ)
    {
        goto end;
    }

    // Get the permanent ID
    dwRegSize = sizeof(pBlob->dwPID);
    dwRet = RegQueryValueEx(
                        hkDevice,
                        cszPermanentIDKey,
                        NULL,
                        &dwRegType,
                        (BYTE*) &(pBlob->dwPID),
                        &dwRegSize
                        );

    if (dwRet != ERROR_SUCCESS
        || !(dwRegType == REG_BINARY || dwRegType == REG_DWORD)
        || dwRegSize != sizeof(pBlob->dwPID))
    {
        goto end;
    }

    // Read in the REGDEVCAPS
    //
    dwRegSize = sizeof(pBlob->rdc);
    dwRet = RegQueryValueEx(
                hkDevice,
                cszProperties,
                NULL,
                &dwRegType,
                (BYTE *)&(pBlob->rdc),
                &dwRegSize
                );
	

	if (dwRet != ERROR_SUCCESS || dwRegType != REG_BINARY)
    {
        goto end;
    }
	
    //
    // We want to make sure the following flags are identical
    //
    #if (LINEDEVCAPFLAGS_DIALBILLING != DIALOPTION_BILLING)
    #error LINEDEVCAPFLAGS_DIALBILLING != DIALOPTION_BILLING (check tapi.h vs. mcx16.h)
    #endif
    #if (LINEDEVCAPFLAGS_DIALQUIET != DIALOPTION_QUIET)
    #error LINEDEVCAPFLAGS_DIALQUIET != DIALOPTION_QUIET (check tapi.h vs. mcx16.h)
    #endif
    #if (LINEDEVCAPFLAGS_DIALDIALTONE != DIALOPTION_DIALTONE)
    #error LINEDEVCAPFLAGS_DIALDIALTONE != DIALOPTION_DIALTONE (check tapi.h vs. mcx16.h)
    #endif
    //

    //
    // Get the voice-profile flags
    //
    dwRegSize = sizeof(DWORD);

    dwRet =  RegQueryValueEx(
                    hkDevice,
                    cszVoiceProfile,
                    NULL,
                    &dwRegType,
                    (BYTE*) &dwData,
                    &dwRegSize);

    if (dwRet || dwRegType != REG_BINARY)
    {
        // no voice operation
        dwData = 0;

        // Unimodem/V did this...
        //dwData =
        //    VOICEPROF_NO_DIST_RING |
        //    VOICEPROF_NO_CALLER_ID |
        //    VOICEPROF_NO_GENERATE_DIGITS |
        //    VOICEPROF_NO_MONITOR_DIGITS;
    }
    else
    {


    }

    // 2/26/1997 JosephJ
    //      Unimodem/V implemented call forwarding and distinctive
    //      ring handling. NT5.0 currently doesn't. The
    //      specific property fields that I have not migrated
    //      from unimodem/v are: ForwardDelay and SwitchFeatures.
    //      Look at unimodem/v, umdminit.c for that stuff.
    //
    //      Same deal with Mixer-related stuff. I don't understand
    //      this and if and when the time comes we can add it.
    //      Look for VOICEPROF_MIXER, GetMixerValues(...),
    //      dwMixer, etc in the unimodem/v sources for mixer-
    //      related stuff.


    //
    // Save voice info.
    //
    // 3/1/1997 JosephJ
    //  Currently, for 5.0, we just set the CLASS_8 bit.
    //  The following value of VOICEPROF_CLASS8ENABLED is stolen from
    //  unimodem/v file inc\vmodem.h.
    //  TODO: replace this whole scheme by getting back an appropriate
    //  structure from the minidriver, so we don't root around in the
    //  registry and interpret the value of VoiceProfile.
    //
    #define VOICEPROF_CLASS8ENABLED           0x00000001
    #define VOICEPROF_MODEM_OVERRIDES_HANDSET 0x00200000
    #define VOICEPROF_NO_MONITOR_DIGITS       0x00040000
    #define VOICEPROF_MONITORS_SILENCE        0x00010000
    #define VOICEPROF_NO_GENERATE_DIGITS      0x00020000
    #define VOICEPROF_HANDSET                 0x00000002
    #define VOICEPROF_SPEAKER                 0x00000004
    #define VOICEPROF_NO_SPEAKER_MIC_MUTE     0x00400000
    #define VOICEPROF_NT5_WAVE_COMPAT         0x02000000

    // JosephJ 7/14/1997
    //      Note that on NT4, we explicitly require the
    //      VOICEPROF_NT5_WAVE_COMPAT bit to be set to recognize this as
    //      a class8 modem.

    if (
        (dwData & (VOICEPROF_CLASS8ENABLED|VOICEPROF_NT5_WAVE_COMPAT))
        == (VOICEPROF_CLASS8ENABLED|VOICEPROF_NT5_WAVE_COMPAT))
    {
        DWORD dwProp = fVOICEPROP_CLASS_8;

        // JosephJ 3/01/1997: following comment and code from unimodem/v.
        // Don't understand it....
        // just to be on the safe side
        if (dwData & VOICEPROF_MODEM_OVERRIDES_HANDSET)
        {
            dwData  |= VOICEPROF_NO_GENERATE_DIGITS;
            //     dwData  &= ~VOICEPROF_SPEAKER;
        }

        // JosephJ: This code is ok...

        #if 0
        if (dwData & VOICEPROF_MODEM_OVERRIDES_HANDSET)
        {
            dwProp |= fVOICEPROP_MODEM_OVERRIDES_HANDSET;
        }
        #endif

        if (!(dwData & VOICEPROF_NO_MONITOR_DIGITS))
        {
            dwProp |= fVOICEPROP_MONITOR_DTMF;
        }

        if (dwData & VOICEPROF_MONITORS_SILENCE)
        {
            dwProp |= fVOICEPROP_MONITORS_SILENCE;
        }

        if (!(dwData & VOICEPROF_NO_GENERATE_DIGITS))
        {
            dwProp |= fVOICEPROP_GENERATE_DTMF;
        }

        if (dwData & VOICEPROF_SPEAKER)
        {
            dwProp |= fVOICEPROP_SPEAKER;
        }

        if (dwData & VOICEPROF_HANDSET)
        {
            dwProp |= fVOICEPROP_HANDSET;
        }

        if (!(dwData & VOICEPROF_NO_SPEAKER_MIC_MUTE))
        {
            dwProp |= fVOICEPROP_MIKE_MUTE;
        }

        {
            // Determine Duplex capability... (hack)
            HKEY hkStartDuplex=NULL;
            dwRet = RegOpenKey(hkDevice, TEXT("StartDuplex"), &hkStartDuplex);
            if (ERROR_SUCCESS == dwRet)
            {
                RegCloseKey(hkStartDuplex);
                hkStartDuplex=NULL;
                dwProp |= fVOICEPROP_DUPLEX;
            }
        }

        pBlob->dwVoiceCaps = dwProp;

        #if 0
        // 2/26/1997 JosephJ
        //      Unimodem/V used helper function GetWaveDriverName to get the
        //      associated wave driver info.  This function searched for
        //      the devnode and soforth. On lineGetID(wavein/waveout),
        //      unimodem/v would actually call the wave apis, enumerating
        //      each wave device and doing a waveInGetDevCaps and comparing
        //      the device name with this device's associated device name.
        //
        //      Note: Unimodem/V appended "handset" and "line" to the root
        //      device name to generate the device names for handset and line.
        //
        //      TODO: add wave instance ID to list of things
        //      we get from the mini-driver via API.
        //
        {
            HKEY hkWave = NULL;
            DWORD dwRet = RegOpenKey(hkDevice, cszWaveDriver, &hkWave);
            BOOL fFoundIt=FALSE;

            if (dwRet == ERROR_SUCCESS)
            {
                dwRegSize = sizeof(DWORD);
                dwRet =  RegQueryValueEx(
                                hkWave,
                                cszWaveInstance,
                                NULL,
                                &dwRegType,
                                (BYTE*) &dwData,
                                &dwRegSize);

                if (dwRet==ERROR_SUCCESS && dwRegType == REG_DWORD)
                {
                    fFoundIt=TRUE;
                }
                RegCloseKey(hkWave);hkWave=NULL;
            }

            if (fFoundIt)
            {
                SLPRINTF1(psl, "WaveInstance=0x%lu", dwData);
                m_StaticInfo.Voice.dwWaveInstance = dwData;
            }
            else
            {
                m_StaticInfo.Voice.dwWaveInstance = (DWORD)-1;
            }
        }
        #endif // 0


    }

    // Basic caps....
   pBlob->dwBasicCaps =  BASICDEVCAPS_IS_LINE_DEVICE; // ALWAYS A LINE DEVICE.


    if (pBlob->dwVoiceCaps & (fVOICEPROP_HANDSET | fVOICEPROP_SPEAKER))
    {
        pBlob->dwBasicCaps |= BASICDEVCAPS_IS_PHONE_DEVICE;
    }

    //// TODO: make the diagnostic caps based on the modem properties,
    /// For now, pretend that it's enabled.
    //  ALSO: don't support the tapi/line/diagnostics class
    //  if the modem doesn't support it...
    //
    pBlob->dwDiagnosticsCaps =  fDIAGPROP_STANDARD_CALL_DIAGNOSTICS;

    fRet = TRUE;

    // fall through ...

end:
    if (!fRet && pBlob)
    {
        FREE_MEMORY(pBlob);
        pBlob = NULL;
    }

    return pBlob;
}

void
UmRtlDevCfgFreeBlob(
        HCONFIGBLOB hBlob
        )
{
    PROPERTYBLOB *pBlob = VALIDATED_PBLOB(hBlob);

    if (pBlob)
    {
        pBlob->dwSig=0;
        FREE_MEMORY(pBlob);
    }
    else
    {
        ASSERT(FALSE);
    }

}

BOOL
UmRtlDevCfgGetDWORDProp(
        HCONFIGBLOB hBlob,
        DWORD dwMajorPropID,
        DWORD dwMinorPropID,
        DWORD *dwProp
        )
{
    DWORD dw = 0;
    PROPERTYBLOB *pBlob = VALIDATED_PBLOB(hBlob);

    if (!pBlob) goto failure;

    switch(dwMajorPropID)
    {

    case UMMAJORPROPID_IDENTIFICATION:
        switch(dwMinorPropID)
        {
        case UMMINORPROPID_PERMANENT_ID:
            dw = pBlob->dwPID;
            goto success;
        }
        break;

    case UMMAJORPROPID_BASICCAPS:
        switch(dwMinorPropID)
        {
        case UMMINORPROPID_BASIC_DEVICE_CAPS:
            dw =  pBlob->dwBasicCaps;
            goto success;
        }
        break;
    }

    // fall through ...

failure:

    return FALSE;

success:

    *dwProp = dw;

    return TRUE;

}

BOOL
UmRtlDevCfgGetStringPropW(
        HCONFIGBLOB hBlob,
        DWORD dwMajorPropID,
        DWORD dwMinorPropID,
        WCHAR **ppwsz
        )
{
    PROPERTYBLOB *pBlob = VALIDATED_PBLOB(hBlob);

    if (!pBlob) goto failure;

    // fall through ...

failure:

    return FALSE;
}

BOOL
UmRtlDevCfgGetStringPropA(
        HCONFIGBLOB hBlob,
        DWORD dwMajorPropID,
        DWORD dwMinorPropID,
        CHAR **ppwsz
        )
{
    PROPERTYBLOB *pBlob = VALIDATED_PBLOB(hBlob);

    if (!pBlob) goto failure;

    // fall through ...

failure:

    return FALSE;
}


DWORD
UmRtlRegGetDWORD(
        HKEY hk,
        LPCTSTR lpctszName,
        DWORD dwFlags,
        LPDWORD lpdw
        )
{
    DWORD dw=0;
    DWORD cbSize = sizeof(dw);
    DWORD dwRegType = 0;
    DWORD dwRet;

    dwRet = RegQueryValueExW(
                hk,
                lpctszName,
                NULL,
                &dwRegType,
                (BYTE*) &dw,
                &cbSize
            );

    if (dwRet == ERROR_SUCCESS)
    {
        dwRet = ERROR_BADKEY;

        switch(dwRegType)
        {

        case REG_DWORD:

            if (dwFlags & UMRTL_GETDWORD_FROMDWORD)
            {
                *lpdw = dw;
                dwRet  = ERROR_SUCCESS;
            }
            break;

        case REG_BINARY:

            switch(cbSize)
            {

            case 1:
                if (dwFlags & UMRTL_GETDWORD_FROMBINARY1)
                {
                    *lpdw = * ((BYTE*)&dw); // convert from byte to DWORD
                    dwRet = ERROR_SUCCESS;

                }
                break;

            case 4:
                if (dwFlags & UMRTL_GETDWORD_FROMBINARY4)
                {
                    *lpdw = dw;   // Assume stored in machinereadble format.
                    dwRet = ERROR_SUCCESS;
                }
                break;

            default:
                dwRet = ERROR_BADKEY;
            }
            break;
        }
    }

    return dwRet;
}


UINT ReadCommandsA(
        IN  HKEY hKey,
        IN  CHAR *pSubKeyName,
        OUT CHAR **ppValues // OPTIONAL
        )
{
    UINT uRet = 0;
    LONG	lRet;
    UINT	cValues=0;
    UINT   cbTot=0;
	HKEY hkSubKey = NULL;
    char *pMultiSz = NULL;

    lRet = RegOpenKeyExA(
                hKey,
                pSubKeyName,
                0,
                KEY_READ,
                &hkSubKey
                );
    if (lRet!=ERROR_SUCCESS)
    {
        hkSubKey = NULL;
        goto end;
    }

    //
    // 1st determine the count of names in the sequence "1","2",3",....
    // and also compute the size required for the MULTI_SZ array
    // will store all the value data.
    //
    {
        UINT u = 1;

        for (;;u++)
        {
            DWORD cbData=0;
            DWORD dwType=0;
            char rgchName[10];

            wsprintfA(rgchName, "%lu", u);
            lRet = RegQueryValueExA(
                        hkSubKey,
                        rgchName,
                        NULL,
                        &dwType,
                        NULL,
                        &cbData
                        );
            if (ERROR_SUCCESS != lRet || dwType!=REG_SZ || cbData<=1)
            {
                // stop looking further (empty strings not permitted)
                break;
            }
            cbTot += cbData;
            cValues++;
        }
    }

    if (!ppValues || !cValues)
    {
        // we're done...

        uRet = cValues;
        goto end;
    }

    // We need to actually get the values -- allocate space for them, including
    // the ending extra NULL for the multi-sz.
    pMultiSz = (char *) ALLOCATE_MEMORY(cbTot+1);

    if (!pMultiSz)
    {
        uRet = 0;
        goto end;
    }


    //
    // Now actually read the values.
    //
    {
        UINT cbUsed = 0;
        UINT u = 1;

        for (;u<=cValues; u++)
        {
            DWORD cbData = cbTot - cbUsed;
            DWORD dwType=0;
            char rgchName[10];

            if (cbUsed>=cbTot)
            {
                //
                // We should never get here, because we already calculated
                // the size we want (unless the values are changing on us,
                // which is assumed not to happen).
                //
                ASSERT(FALSE);
                goto end;
            }

            wsprintfA(rgchName, "%lu", u);
            lRet = RegQueryValueExA(
                        hkSubKey,
                        rgchName,
                        NULL,
                        &dwType,
                        (BYTE*) (pMultiSz+cbUsed),
                        &cbData
                        );
            if (ERROR_SUCCESS != lRet || dwType!=REG_SZ || cbData<=1)
            {
                // We really shouldn't get here!
                ASSERT(FALSE);
                goto end;
            }

            cbUsed += cbData;
        }

        ASSERT(cbUsed==cbTot); // We should have used up everything.
        ASSERT(!pMultiSz[cbTot]); // The memory was zeroed on allocation,
                                // so the last char must be still zero.
                                // (Note: we allocated cbTot+1 bytes.
    }

    // If we're here means we're succeeding....
    uRet = cValues;
    *ppValues = pMultiSz;
    pMultiSz = NULL; // so it won't get freed below...

end:

	if (hkSubKey) {RegCloseKey(hkSubKey); hkSubKey=NULL;}
	if (pMultiSz)
	{
	    FREE_MEMORY(pMultiSz);
	    pMultiSz = NULL;
	}

	return uRet;

}

UINT ReadIDSTR(
        IN  HKEY hKey,
        IN  CHAR *pSubKeyName,
        IN  IDSTR *pidstrNames,
        IN  UINT cNames,
        BOOL fMandatory,
        OUT IDSTR **ppidstrValues, // OPTIONAL
        OUT char **ppstrValues    // OPTIONAL
        )
{
    UINT uRet = 0;
    LONG lRet;
    UINT cValues=0;
    UINT cbTot=0;
	HKEY hkSubKey = NULL;
    char *pstrValues = NULL;
    IDSTR *pidstrValues = NULL;

    if (!ppidstrValues && ppstrValues)
    {
        // we don't allow this combination...
        goto end;
    }

    lRet = RegOpenKeyExA(
                hKey,
                pSubKeyName,
                0,
                KEY_READ,
                &hkSubKey
                );
    if (lRet!=ERROR_SUCCESS)
    {
        hkSubKey = NULL;
        goto end;
    }

    //
    // 1st run therough the supplied list
    // and also compute the size required for the MULTI_SZ array
    // will store all the value data.
    //
    {
        UINT u = 0;

        for (;u<cNames;u++)
        {
            DWORD cbData=0;
            DWORD dwType=0;

            lRet = RegQueryValueExA(
                        hkSubKey,
                        pidstrNames[u].pStr,
                        NULL,
                        &dwType,
                        NULL,
                        &cbData
                        );
            if (ERROR_SUCCESS != lRet || dwType!=REG_SZ)
            {
                if (fMandatory)
                {
                    // failure...
                    goto end;
                }

                // ignore this one and move on...
                continue;
            }
            cbTot += cbData;
            cValues++;
        }
    }

    if (!cValues || !ppidstrValues)
    {
        // we're done...

        uRet = cValues;
        goto end;
    }

    pidstrValues = (IDSTR*) ALLOCATE_MEMORY(cValues*sizeof(IDSTR));
    if (!pidstrValues) goto end;

    if (ppstrValues)
    {
        pstrValues = (char *) ALLOCATE_MEMORY(cbTot);

        if (!pstrValues) goto end;


    }

    //
    // Now go through once again, and optinally read the values.
    //
    {
        UINT cbUsed = 0;
        UINT u = 0;
        UINT v = 0;

        for (;u<cNames; u++)
        {
            DWORD dwType=0;
            char *pStr = NULL;
            DWORD cbData = 0;


            if (pstrValues)
            {
                cbData = cbTot - cbUsed;

                if (cbUsed>=cbTot)
                {
                    //
                    // We should never get here, because we already calculated
                    // the size we want (unless the values are changing on us,
                    // which is assumed not to happen).
                    //
                    ASSERT(FALSE);
                    goto end;
                }

                pStr = pstrValues+cbUsed;
            }

            lRet = RegQueryValueExA(
                        hkSubKey,
                        pidstrNames[u].pStr,
                        NULL,
                        &dwType,
                        (BYTE*)pStr,
                        &cbData
                        );

            if (ERROR_SUCCESS != lRet || dwType!=REG_SZ)
            {
                if (fMandatory)
                {
                    // We really shouldn't get here!
                    ASSERT(FALSE);
                    goto end;
                }
                continue;
            }

            // this is a good one...

            pidstrValues[v].dwID = pidstrNames[u].dwID;
            pidstrValues[v].dwData = pidstrNames[u].dwData;

            if (pstrValues)
            {
                pidstrValues[v].pStr = pStr;
                cbUsed += cbData;
            }

            v++;

            if (v>=cValues)
            {
                if (fMandatory)
                {
                    //
                    // This should never happen because we already counted
                    // the valid values.
                    //
                    ASSERT(FALSE);
                    goto end;
                }

                // we're done now...
                break;
            }
        }

        // We should have used up everything.
        ASSERT(!pstrValues || cbUsed==cbTot);
        ASSERT(v==cValues);
    }

    // If we're here means we're succeeding....
    uRet = cValues;
    *ppidstrValues = pidstrValues;
    pidstrValues = NULL; // so that it won't get freed below...

    if (ppstrValues)
    {
        *ppstrValues = pstrValues;
        pstrValues = NULL; // so it won't get freed below...
    }

end:

	if (hkSubKey) {RegCloseKey(hkSubKey); hkSubKey=NULL;}
	if (pstrValues)
	{
	    FREE_MEMORY(pstrValues);
	    pstrValues = NULL;
	}

	if (pidstrValues)
	{
	    FREE_MEMORY(pidstrValues);
	    pidstrValues = NULL;
	}

	return uRet;
}


void __cdecl operator delete(void *pv)
{
    FREE_MEMORY(pv);
}

void * __cdecl operator new(size_t uSize)
{
    return ALLOCATE_MEMORY(uSize);
}
void
expand_macros_in_place(
    char *szzCommands
    )
{


    if (!szzCommands) return;

    // First find length of multisz string...
    char *pcEnd = szzCommands;
    do
    {
        if (!*pcEnd)
        {
            // end of a string, skip to the next...
            pcEnd++;
        }

    } while (*pcEnd++);

    //
    // pcEnd is set to one AFTER the last character (which will be a 0) in
    // szzCommands.
    //

    //
    // Now process the macros, using cFILLER as a filler character.
    //
    for (char *pc = szzCommands; pc < pcEnd; pc++)
    {
        if (pc[0]=='<')
        {
            switch(pc[1])
            {
            case 'c':
            case 'C':
                switch(pc[2])
                {
                case 'r':
                case 'R':
                    if (pc[3]=='>')
                    {
                        // Found <cr>
                        pc[0]= '\r';
                        pc[1]= cFILLER;
                        pc[2]= cFILLER;
                        pc[3]= cFILLER;
                        pc+=3;       // note that for loop also increments pc
                        continue;
                    }
                    break;
                }
                break;

            case 'l':
            case 'L':
                switch(pc[2])
                {
                case 'f':
                case 'F':
                    if (pc[3]=='>')
                    {
                        // Found <lf>
                        pc[0]= '\n';
                        pc[1]= cFILLER;
                        pc[2]= cFILLER;
                        pc[3]= cFILLER;
                        pc+=3;       // note that for loop also increments pc
                        continue;
                    }
                    break;
                }
                break;
            }
        }
    }

    //
    // Now get rid of the fillers
    //
    char *pcTo = szzCommands;
    for (pc = szzCommands; pc < pcEnd; pc++)
    {
        if (*pc!=cFILLER)
        {
            *pcTo++ = *pc;
        }
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\umcfg\dotapi.h ===
void
do_get_debug_tapi(TOKEN tok);

void
do_set_debug_tapi(TOKEN tok, DWORD dw);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\umcfg\docomm.cpp ===
//****************************************************************************
//
//  Module:     UMCONFIG
//  File:       DOCOMM.C
//
//  Copyright (c) 1992-1996, Microsoft Corporation, all rights reserved
//
//  Revision History
//
//
//  10/17/97     JosephJ             Created
//
//
//      COMM-related utilities
//
//
//****************************************************************************
#include "tsppch.h"
#include "parse.h"
#include "docomm.h"


HANDLE ghComm;

void
do_open_comm(DWORD dwComm)
{

    TCHAR rgchComm[32];

    if (ghComm)
    {
        printf("Some comm port already opened!\n");
        goto end;
    }

    wsprintf(rgchComm, "\\\\.\\COM%lu", dwComm);

    ghComm = CreateFile(rgchComm, 
                       GENERIC_WRITE | GENERIC_READ,
                       0, NULL,
                       OPEN_EXISTING, 0, NULL);

    if (ghComm == INVALID_HANDLE_VALUE)
	{
        DWORD dwRet = GetLastError();
        if (dwRet == ERROR_ACCESS_DENIED) {
            printf("Port %s is in use by another app.\r\n", rgchComm);
        }
        else
		{
            printf("Couldn't open port %s.\r\n", rgchComm);
        }

        ghComm=NULL;
    }
    else
    {
	printf("Comm port %s opend. Handle= 0x%p\n", rgchComm, ghComm);
    }
end:

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\umcfg\tsppch.h ===
// Copyright (c) 1996-1997 Microsoft Corporation.
//
//
// Component
//
//		Unimodem 5.0 TSP (Win32, user mode DLL)
//
// File
//
//		TSPPCH.H
//		Precompiled common header file internal to the Unimodem TSP.
//
// History
//
//		11/16/1996  JosephJ Created (was tspcomm.h)
//
//

// #define UNICODE 1

#define TAPI_CURRENT_VERSION 0x00020000


#include <windows.h>
#include <stdio.h>
#include <ctype.h>
#include <regstr.h>
#include <tspi.h>

//#include "public.h"
//#include <modemp.h>
//#include <umdmmini.h>
//#include <uniplat.h>
//#include <tspirec.h>



#define FIELDOFFSET(type, field)    ((int)(&((type NEAR*)1)->field)-1)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\umcfg\parse.h ===
typedef enum
{
    TOK_UNKNOWN,
    TOK_QUIT,
    TOK_HELP,
    TOK_OPEN,
    TOK_CLOSE,
    TOK_SET,
    TOK_GET,
    TOK_DEBUG,
    TOK_TAPI32,
    TOK_TAPISRV,
    TOK_COMM,
    TOK_DUMP,
    TOK_TSPDEV

} TOKEN ;

typedef struct
{
    TOKEN tok;
    const TCHAR *szPattern;

    DWORD dwFlags; // One or more flags below

    const TCHAR *szName; // canonical name.

    #define fTOK_IGNORE    (0x1<<0) // Ignore this token when matching...
    #define fTOK_MATCHWORD (0x1<<1) // Match whole words, not including
                                    // digits.
    #define fTOK_MATCHIDENT (0x1<<2) // Match whole words, including valid
                                     // identifiers

    UINT ShouldIgnore(void)
    {
        return dwFlags & fTOK_IGNORE;
    }

    UINT ShouldMatchWord(void)
    {
        return dwFlags & fTOK_MATCHWORD;
    }

    UINT ShouldMatchIdent(void)
    {
        return dwFlags & fTOK_MATCHIDENT;
    }

} TOKREC;
TOKEN
Tokenize(
    const TCHAR **ptsz,
    TOKREC *pTokRecs
    );

const
TCHAR *
Stringize(
    TOKEN tok,
    TOKREC *pTokRecs
    );

void Parse(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\umcfg\main.cpp ===
//****************************************************************************
//
//  Module:     UNIMDM
//  File:       MAIN.C
//
//  Copyright (c) 1992-1996, Microsoft Corporation, all rights reserved
//
//  Revision History
//
//
//  3/25/96     JosephJ             Created
//
//
//  Description: Test the notification support.
//				 Tests both the higher-level api (UnimodemNotifyTSP)
//			 	 and the lower level notifXXX apis. The latter
//				 are tested later on in the file, and the header file
//				 "slot.h" is included there, not at the start of this
//				 file, because the higher-level tests do not need to
//				 include "slot.h"
//
//****************************************************************************
#include "tsppch.h"
#include "parse.h"

#define DPRINTF(_fmt) 					printf(_fmt)
#define DPRINTF1(_fmt,_arg) 			printf(_fmt,_arg)
#define DPRINTF2(_fmt,_arg,_arg2) 		printf(_fmt,_arg,_arg2)
#define DPRINTF3(_fmt,_arg,_arg2,_arg3) printf(_fmt,_arg,_arg2,_arg3)

#define ASSERT(_c) \
	((_c) ? 0: DPRINTF2("Assertion failed in %s:%d\n", __FILE__, __LINE__))


BOOL InitGlobals(int argc, char *argv[]);

int __cdecl main(int argc, char *argv[])
{
	// init globals
	if (!InitGlobals(argc, argv)) goto end;

    Parse();

end:
	return 0;
}

BOOL InitGlobals(int argc, char *argv[])
{
	BOOL fRet=FALSE;

    #if 0
	char *pc;

	if (argc!=2) goto end;

	pc=argv[1];
	if (*pc!='-' && *pc!='/') goto end;
	pc++;
	switch(*pc++)
	{
	case 's':
		gMain.fServer=TRUE;
		break;
	case 'c':
		break;
	default:
		goto end;
	}

	DPRINTF1("Ha!%d\n", gMain.fServer);
    #endif 0

	fRet=TRUE;
	
	return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\umcfg\dotsp.h ===
void
do_dump_tspdev(DWORD dwCom);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\umdmxfrm\cirrus.c ===
//---------------------------------------------------------------------------
//
//  Module:   wavein.c
//
//  Description:
//     Wave interface for MSSB16.DRV.
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Bryan A. Woodruff
//
//  History:   Date       Author      Comment
//@@END_MSINTERNAL
/**************************************************************************
 *
 *  Copyright (c) 1994 - 1995	Microsoft Corporation.	All Rights Reserved.
 *
 **************************************************************************/

#include "xfrmpriv.h"

//#include "cirrus.h"

LONG CONST  IndexTable[16]= {-1, -1, -1, -1,  2,  4,  6,  8,
                        -1, -1, -1, -1,  2,  4,  6,  8};

LONG CONST  StepSizeTable[89]= {7, 8, 9, 10, 11, 12, 13, 14,
                           16, 17, 19, 21, 23, 25, 28, 31,
                           34, 37, 41, 45, 50, 55, 60, 66,
                           73, 80, 88, 97, 107, 118, 130, 143,
                           157, 173, 190, 209, 230, 253, 279, 307,
                           337, 371, 408, 449, 494, 544, 598, 658,
                           724, 796, 876, 963, 1060, 1166, 1282, 1411,
                           1552, 1707, 1878, 2066, 2272, 2499, 2749, 3024,
                           3327, 3660, 4026, 4428, 4871, 5358, 5894, 6484,
                           7132, 7845, 8630, 9493, 10442, 11487, 12635,
                           13899, 15289, 16818, 18500, 20350, 22385, 24623,
                           27086, 29794, 32767};



VOID
InitCompressor(
    LPCOMPRESS_OBJECT   State,
    WORD                Gain
    )

{


    State->PredictedSample=0;
    State->Index=0;
    State->StepSize=7;

    State->Gain=Gain;

    return;

}


#pragma optimize("t",on)

BYTE NEAR
PCMto4bitADPCM(
    LPCOMPRESS_OBJECT   State,
    SHORT              InSample
    )

{

    LONG     Diff;
    BYTE     NewSample;
    LONG     PCMSample=InSample;


    Diff = PCMSample - State->PredictedSample;
    NewSample = 0;

    if( Diff<0 ) {
        NewSample = 8;
        Diff = -Diff;
    }

    if( Diff >= State->StepSize ) {
        NewSample |= 4;
        Diff -= State->StepSize;
    }

    State->StepSize >>= 1;
    if( Diff >= State->StepSize ) {
        NewSample |= 2;
        Diff -= State->StepSize;
    }

    State->StepSize >>= 1;
    if( Diff >= State->StepSize ) {
        NewSample |= 1;
        Diff -= State->StepSize;
    }

    if ( NewSample & 8 ) {

        State->PredictedSample = PCMSample + Diff - (State->StepSize>>1);

    } else {

        State->PredictedSample = PCMSample - Diff + (State->StepSize>>1);
    }

    if ( State->PredictedSample > 32767 ) {

        State->PredictedSample = 32767;

    } else {

        if ( State->PredictedSample < -32768 ) {

            State->PredictedSample = -32768;
        }
    }


    State->Index += IndexTable[NewSample];

    if (State->Index < 0) {

        State->Index = 0;

    } else {

        if (State->Index > 88 ) {

            State->Index = 88;

        }
    }

    State->StepSize= StepSizeTable[State->Index];

    return NewSample;

}

BYTE  WINAPI
CompressPCM(
    LPCOMPRESS_OBJECT   State,
    SHORT               Sample1,
    SHORT               Sample2
    )

{
    BYTE   ReturnValue;

    ReturnValue =  PCMto4bitADPCM(State, AdjustGain(Sample1,State->Gain));

    ReturnValue |= PCMto4bitADPCM(State, AdjustGain(Sample2,State->Gain))<<4;


    return ReturnValue;


}


VOID
InitDecompressor(
    LPDECOMPRESS_OBJECT   State,
    WORD                  Gain
    )

{


    State->Gain=Gain;


    State->Index=0;
    State->StepSize=7;
    State->NewSample=0;
    return;

}


SHORT
ADPCM4bittoPCM(
     LPDECOMPRESS_OBJECT  State,
     BYTE                Sample
     )

{

     LONG                Diff;

    //
    //  Diff= (Sample +1/2) * StepSize/4
    //

    Diff = State->StepSize >> 3;

    if (Sample & 4) {

        Diff += State->StepSize;
    }

    if (Sample & 2) {

        Diff += State->StepSize >> 1;
    }

    if (Sample & 1) {

        Diff += State->StepSize >> 2;
    }


    if (Sample & 8) {

        Diff = -Diff;
    }

    State->NewSample += Diff;

    if (State->NewSample > 0x7fff) {

        State->NewSample=0x7fff;

    } else {

        if (State->NewSample < -32768) {

            State->NewSample=-32768;

        }
    }

    State->Index += IndexTable[Sample];

    if (State->Index < 0) {

        State->Index = 0;

    } else {

        if (State->Index > 88 ) {

            State->Index = 88;

        }
    }

    State->StepSize=StepSizeTable[State->Index];

    return (SHORT)State->NewSample;

}



VOID  WINAPI
DecompressADPCM(
    LPDECOMPRESS_OBJECT   State,
    BYTE               Sample,
    PSHORT                Destination
    )

{
    DWORD   ReturnValue;

    *Destination++ = AdjustGain(ADPCM4bittoPCM(State, (BYTE)(Sample & 0x0f)),State->Gain);

    *Destination++ = AdjustGain((ADPCM4bittoPCM(State, (BYTE)(Sample>>4))),State->Gain);

    return ;


}






DWORD  WINAPI
CirrusInInit(
    LPVOID  lpvObject,
    WORD    Gain
    )
{

    if (0 == Gain) {

        Gain = 0x2000; // Gain of 32
    }

    InitDecompressor(
        (LPDECOMPRESS_OBJECT)lpvObject,
        Gain
        );


    return MMSYSERR_NOERROR;
}

VOID  WINAPI  CirrusInGetBufferSizes
(
    LPVOID  lpvObject,
    DWORD   dwBytes,
    LPDWORD lpdwBufSizeA,
    LPDWORD lpdwBufSizeB
)
{
    DWORD   Samples=dwBytes/2;

    *lpdwBufSizeA = 2*( ((Samples/5)*3) + ((Samples%5)*3/5) + 1 );
    *lpdwBufSizeB = (*lpdwBufSizeA) / 4;
}

DWORD  WINAPI  CirrusInRateConvert
(
    LPVOID  lpvObject,
    LPBYTE  lpSrc,
    DWORD   dwSrcLen,
    LPBYTE  lpDest,
    DWORD   dwDestLen
)
{
    return 2*SRConvertUp(
                 3,
                 5,
                 (short*)lpSrc,
                 dwSrcLen/2,
                 (short*)lpDest,
                 dwDestLen/2
                 );
}

DWORD WINAPI
CirrusInDecode(
    LPVOID  lpvObject,
    LPBYTE   lpSrc,
    DWORD   dwSrcLen,
    LPBYTE  lpDest,
    DWORD   dwDestLen
    )
{

    PSHORT   EndPoint;

    DWORD    Samples=dwSrcLen * 2;

    PSHORT   Dest=(PSHORT)lpDest;

    EndPoint=Dest+Samples;

    while (Dest < EndPoint) {

        DecompressADPCM(
            lpvObject,
            *lpSrc++,
            Dest
            );

        Dest+=2;

    }

    return Samples*2;
}

DWORD  WINAPI
CirrusOutInit(
    LPVOID  lpvObject,
    WORD    Gain
    )
{
    if (0 == Gain) {

        Gain = 0x0040; // Gain of 0
    }


    InitCompressor(
        (LPCOMPRESS_OBJECT)lpvObject,
        Gain
        );


    return MMSYSERR_NOERROR;
}

VOID  WINAPI  CirrusOutGetBufferSizes
(
    LPVOID  lpvObject,
    DWORD   dwBytes,
    LPDWORD lpdwBufSizeA,
    LPDWORD lpdwBufSizeB
)
{
    DWORD   SourceSamples=dwBytes/2;

    *lpdwBufSizeA =(((SourceSamples/5)*3)+((SourceSamples%5)*3/5))*2;

    *lpdwBufSizeB = *lpdwBufSizeA / 4;
}

DWORD  WINAPI  CirrusOutRateConvert
(
    LPVOID  lpvObject,
    LPBYTE  lpSrc,
    DWORD   dwSrcLen,
    LPBYTE  lpDest,
    DWORD   dwDestLen
)
{

    return 2 * SRConvertDown(
        5,
        3,
        (short*)lpSrc,
        dwSrcLen/2,
        (short*)lpDest,
        dwDestLen/2
        );

}

DWORD WINAPI
CirrusOutEncode(
    LPVOID  lpvObject,
    LPBYTE  lpSrc,
    DWORD   dwSrcLen,
    LPBYTE  lpDest,
    DWORD   dwDestLen
    )
{


    DWORD cbDest = dwSrcLen / 4;

    PSHORT  Source=(PSHORT)lpSrc;

    DWORD   Samples=dwSrcLen/2;

    LPBYTE  EndPoint=lpDest+Samples/2;

    SHORT   Sample1;
    SHORT   Sample2;

    while (lpDest < EndPoint) {

        Sample1=*Source++;
        Sample2=*Source++;

        *lpDest++=CompressPCM(
            lpvObject,
            Sample1,
            Sample2
            );

    }



    return Samples/2;
}

DWORD  WINAPI  CirrusGetPosition
(
    LPVOID  lpvObject,
    DWORD dwBytes
)
{
    return ((dwBytes * 4) * 5) / 3;
}

DWORD  WINAPI GetCirrusInfo
(
    DWORD dwID,
    LPXFORM_INFO lpxiInput,
    LPXFORM_INFO lpxiOutput
)
{
    lpxiInput->wObjectSize = sizeof(DECOMPRESS_OBJECT);
    lpxiInput->lpfnInit           = CirrusInInit;
    lpxiInput->lpfnGetPosition    = CirrusGetPosition;
    lpxiInput->lpfnGetBufferSizes = CirrusInGetBufferSizes;
    lpxiInput->lpfnTransformA     = CirrusInRateConvert;
    lpxiInput->lpfnTransformB     = CirrusInDecode;

    lpxiOutput->wObjectSize = sizeof(COMPRESS_OBJECT);
    lpxiOutput->lpfnInit           = CirrusOutInit;
    lpxiOutput->lpfnGetPosition    = CirrusGetPosition;
    lpxiOutput->lpfnGetBufferSizes = CirrusOutGetBufferSizes;
    lpxiOutput->lpfnTransformA     = CirrusOutRateConvert;
    lpxiOutput->lpfnTransformB     = CirrusOutEncode;

    return MMSYSERR_NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\umcfg\parse.cpp ===
//****************************************************************************
//
//  Module:     UMCONFIG
//  File:       PARSE.C
//
//  Copyright (c) 1992-1996, Microsoft Corporation, all rights reserved
//
//  Revision History
//
//
//  10/17/97     JosephJ             Created
//
//
//      Top-level parser  routines.
//
//
//****************************************************************************
#include "tsppch.h"
#include "parse.h"
#include "dotapi.h"
#include "docomm.h"
#include "dotsp.h"



TOKEN Tokenize(const TCHAR **ptsz, TOKREC *pTokTable)
{
    const TCHAR *tsz = *ptsz;
    UINT uOffset=0;
    UINT uLen = lstrlen(*ptsz);

    for (TOKREC *ptp = pTokTable; (ptp->tok!=TOK_UNKNOWN); ptp++)
    {
        uOffset = 0;

        if (ptp->ShouldIgnore())
        {
            continue;
        }

        sscanf(tsz, ptp->szPattern, &uOffset);

        if (uOffset)
        {
            // printf(">>>Offset=%lu\n", uOffset);
            if (uOffset < uLen)
            {
                if (ptp->ShouldMatchIdent())
                {
                    if (isalnum(tsz[uOffset]))
                    {
                        continue;
                    }
                }
                else if (ptp->ShouldMatchWord())
                {
                    if (isalpha(tsz[uOffset]))
                    {
                        continue;
                    }
                }
            }

            // found it!
            break;
        }
    }
    
    // printf("Tokenize(%s): uOffset=%lu; tok=%lu(%s)\n",
    //     *ptsz, uOffset, ptp->tok, Stringize(ptp->tok, pTokTable));

    *ptsz+=uOffset;

    return ptp->tok;
}

const TCHAR * Stringize(TOKEN tok, TOKREC *pTokTable)
{

    for (TOKREC *ptp = pTokTable; (ptp->tok!=TOK_UNKNOWN); ptp++)
    {
        if (ptp->tok == tok)
        {
            break;
        }
    }

    return ptp->szName ? ptp->szName : TEXT("<No Name>");
}


BOOL parse_set(const TCHAR *szInBuf, BOOL fHelp);
BOOL parse_get(const TCHAR *szInBuf, BOOL fHelp);
BOOL parse_open(const TCHAR *szInBuf, BOOL fHelp);
BOOL parse_close(const TCHAR *szInBuf, BOOL fHelp);
BOOL parse_dump(const TCHAR *szInBuf, BOOL fHelp);

void    Parse(void)
{
    TCHAR rgch[256];
    UINT u=0;
    UINT uOffset=0;


    static TOKREC CmdTokTable[] = 
    {
        {TOK_HELP, TEXT(" help%n"), (fTOK_MATCHIDENT), TEXT("help")},
        {TOK_HELP, TEXT(" ?%n"), (0) , NULL},
    
        {TOK_QUIT, TEXT(" quit%n"), (fTOK_MATCHIDENT), TEXT("quit")},
        {TOK_QUIT, TEXT(" q%n"), (fTOK_MATCHIDENT), NULL},
        {TOK_QUIT, TEXT(" bye%n"), (fTOK_MATCHIDENT), NULL},
        {TOK_QUIT, TEXT(" exit%n"), (fTOK_MATCHIDENT), NULL},
    
        {TOK_OPEN, TEXT(" open%n"), (fTOK_MATCHIDENT), TEXT("open")},
        {TOK_OPEN, TEXT(" o%n"), (fTOK_MATCHIDENT), NULL},
    
        {TOK_CLOSE, TEXT(" close%n"), (fTOK_MATCHIDENT), TEXT("close")},
        {TOK_CLOSE, TEXT(" c%n"), (fTOK_MATCHIDENT), NULL},
    
        {TOK_SET, TEXT(" set%n"), (fTOK_MATCHIDENT), TEXT("set")},
        {TOK_SET, TEXT(" s%n"), (fTOK_MATCHIDENT), NULL},
    
        {TOK_GET, TEXT(" get%n"), (fTOK_MATCHIDENT), TEXT("get")},
        {TOK_GET, TEXT(" g%n"), (fTOK_MATCHIDENT), NULL},

        {TOK_DUMP, TEXT(" dump%n"), (fTOK_MATCHIDENT), TEXT("dump")},
    
        {TOK_UNKNOWN, TEXT("<unknown>"), (0), TEXT("<unknown>")} // should be last.
    };

    do 
    {
        const TCHAR *ptsz = rgch;
        printf("> ");
        u=scanf("%[^\n]", rgch);
    
        if (u==EOF) goto end;

        if (u)
        {
            // printf ("input=[%s]\n", rgch);
        
            BOOL fRet = FALSE;
            TOKEN tok = TOK_UNKNOWN;
            BOOL fHelp = FALSE;
    
            tok = Tokenize(&ptsz, CmdTokTable);
            //printf("tok=0x%0lx [%s]\n", tok, Stringize(tok, CmdTokTable));
    
            // Special case: help:
            if (tok == TOK_HELP)
            {
                fHelp = TRUE;
                tok = Tokenize(&ptsz, CmdTokTable);
            }

            switch(tok)
            {

            case TOK_QUIT:
                fRet = TRUE;
                break;
    
            case TOK_GET:
                fRet = parse_get(ptsz, fHelp);
                break;
    
            case TOK_SET:
                fRet = parse_set(ptsz, fHelp);
                break;
    
            case TOK_OPEN:
                fRet = parse_open(ptsz, fHelp);
                break;

            case TOK_CLOSE:
                fRet = parse_close(ptsz, fHelp);
                break;

            case TOK_DUMP:
                fRet = parse_dump(ptsz, fHelp);
                break;
    
            default:
                if (fHelp)
                {
                    printf(" try ? [open|close|set|get|dump]\n");
                }
                break;
            }

            if (!fRet && !fHelp)
            {
                printf("command error.\n");
            }
    
            if (tok == TOK_QUIT)
            {
                break;
            }

        }

        // skip past EOL
        {
            char c;
            u = scanf("%c", &c);
        }

    } while (u!=EOF);

end:

    printf("Bye.\n");


    return;
}

static TOKREC GetSetTokTable[] = 
{

    {TOK_DEBUG, TEXT(" debug%n"), (fTOK_MATCHIDENT), TEXT("debug")},

    {TOK_UNKNOWN, TEXT("<unknown>"), (0), TEXT("<unknown>")} // should be last.
};


BOOL parse_set_debug(const TCHAR *szInBuf, BOOL fHelp);

BOOL parse_set(const TCHAR *szInBuf, BOOL fHelp)
{
    TOKEN tok = TOK_UNKNOWN;
    BOOL fRet = FALSE;

    tok = Tokenize(&szInBuf, GetSetTokTable);

    switch(tok)
    {
        case TOK_DEBUG:
            fRet = parse_set_debug(szInBuf, fHelp);
            break;
        default: 
            if (fHelp)
            {
                fRet=TRUE;
                printf(" s[et] debug ...\n");
            }
            break;
    }

    return fRet;
}

BOOL parse_get_debug(const TCHAR *szInBuf, BOOL fHelp);

BOOL parse_get(const TCHAR *szInBuf, BOOL fHelp)
{
    TOKEN tok = TOK_UNKNOWN;
    BOOL fRet = FALSE;

    tok = Tokenize(&szInBuf, GetSetTokTable);

    switch(tok)
    {
        case TOK_DEBUG:
            fRet = parse_get_debug(szInBuf, fHelp);
            break;
        default: 
            if (fHelp)
            {
                printf(" g[et] debug ...\n");
                fRet = TRUE;
            }
            break;
    }

    return fRet;
}

static TOKREC ComponentTokTable[] = 
{

    {TOK_TAPI32, TEXT(" tapi32%n"), (fTOK_MATCHIDENT), TEXT("tapi32")},
    {TOK_TAPI32, TEXT(" tapi32.dll%n"), (fTOK_MATCHIDENT), NULL},

    {TOK_TAPISRV, TEXT(" tapisrv%n"), (fTOK_MATCHIDENT), TEXT("tapisv")},
    {TOK_TAPISRV, TEXT(" tapisrv.exe%n"), (fTOK_MATCHIDENT), NULL},

    {TOK_UNKNOWN, TEXT("<unknown>"), (0), TEXT("<unknown>")} // should be last.
};

BOOL parse_set_debug_tapi32(const TCHAR *szInBuf, BOOL fHelp);
BOOL parse_set_debug_tapisrv(const TCHAR *szInBuf, BOOL fHelp);

BOOL parse_set_debug(const TCHAR *szInBuf, BOOL fHelp)
{
    TOKEN tok = TOK_UNKNOWN;
    BOOL fRet = FALSE;

    tok = Tokenize(&szInBuf, ComponentTokTable);

    switch(tok)
    {
        case TOK_TAPI32:
            fRet = parse_set_debug_tapi32(szInBuf, fHelp);
            break;

        case TOK_TAPISRV:
            fRet = parse_set_debug_tapisrv(szInBuf, fHelp);
            break;

        default: 
            if (fHelp)
            {
                printf(" s[et] debug [tapisrv|tapisrv32] ...\n");
                fRet = TRUE;
            }
            break;
    }

    return fRet;
}

BOOL parse_get_debug_tapi32(const TCHAR *szInBuf, BOOL fHelp);
BOOL parse_get_debug_tapisrv(const TCHAR *szInBuf, BOOL fHelp);

BOOL parse_get_debug(const TCHAR *szInBuf, BOOL fHelp)
{
    TOKEN tok = TOK_UNKNOWN;
    BOOL fRet = FALSE;

    tok = Tokenize(&szInBuf, ComponentTokTable);

    switch(tok)
    {
        case TOK_TAPI32:
            fRet = parse_get_debug_tapi32(szInBuf, fHelp);
            break;

        case TOK_TAPISRV:
            fRet = parse_get_debug_tapisrv(szInBuf, fHelp);
            break;

        default: 
            if (fHelp)
            {
                printf(" g[et] debug [tapisrv|tapisrv32] ...\n");
                fRet = TRUE;
            }
            break;
    }

    return fRet;
}


BOOL parse_get_debug_tapisrv(const TCHAR *szInBuf, BOOL fHelp)
{
    if (fHelp)
    {
        printf(" g[et] debug tapisrv\n");
        printf("Returns TapiSrvDebugLevel value\n");
    }
    else
    {
        do_get_debug_tapi(TOK_TAPISRV);
    }
    return TRUE;
}

BOOL parse_get_debug_tapi32(const TCHAR *szInBuf, BOOL fHelp)
{
    if (fHelp)
    {
        printf(" g[et] debug tapi32\n");
        printf("Returns Tapi32DebugLevel value\n");
    }
    else
    {
        do_get_debug_tapi(TOK_TAPI32);
    }
    return TRUE;
}


BOOL parse_set_debug_tapi32(const TCHAR *szInBuf, BOOL fHelp)
{
    TCHAR rgch[256];
    BOOL fRet = FALSE;
    DWORD dw  = 0;

    if (fHelp)
    {
        printf(" s[et] debug tapi32 <level>\n");
        printf("Sets Tapi32DebugLevel value\n");
        fRet = TRUE;
    }
    else
    {
        UINT u=sscanf(szInBuf, "%lu", &dw);
        if (u && u!=EOF)
        {
            do_set_debug_tapi(TOK_TAPI32, dw);
            fRet = TRUE;
        }
    }
    return fRet;
}

BOOL parse_set_debug_tapisrv(const TCHAR *szInBuf, BOOL fHelp)
{
    TCHAR rgch[256];
    BOOL fRet = FALSE;
    DWORD dw  = 0;

    if (fHelp)
    {
        printf(" s[et] debug tapisrv <level>\n");
        printf("Sets TapiSrvDebugLevel value\n");
        fRet = TRUE;
    }
    else
    {
        UINT u=sscanf(szInBuf, "%lu", &dw);
        if (u && u!=EOF)
        {
            do_set_debug_tapi(TOK_TAPISRV, dw);
            fRet = TRUE;
        }
    }
    return fRet;
}

static TOKREC OpenTokTable[] = 
{

    {TOK_COMM, TEXT(" COM%n"), (fTOK_MATCHWORD), TEXT("COM")},
    {TOK_COMM, TEXT(" com%n"), (fTOK_MATCHWORD), TEXT("COM")},

    {TOK_UNKNOWN, TEXT("<unknown>"), (0), TEXT("<unknown>")} // should be last.
};

BOOL parse_open_comm(const TCHAR *szInBuf, BOOL fHelp);

BOOL parse_open(const TCHAR *szInBuf, BOOL fHelp)
{
    TOKEN tok = TOK_UNKNOWN;
    BOOL fRet = FALSE;

    tok = Tokenize(&szInBuf, OpenTokTable);

    switch(tok)
    {
        case TOK_COMM:
            fRet = parse_open_comm(szInBuf, fHelp);
            break;

        default: 
            if (fHelp)
            {
                printf(" o[pen] com ...\n");
                fRet = TRUE;
            }
            break;
    }

    return fRet;
}


BOOL parse_open_comm(const TCHAR *szInBuf, BOOL fHelp)
{
    BOOL fRet = FALSE;
    DWORD dw  = 0;

    if (fHelp)
    {
        printf(" o[pen] com<n>\n");
        printf("Opens COM port <n>\n");
        fRet = TRUE;
    }
    else
    {
        UINT u=sscanf(szInBuf, "%lu", &dw);
        if (u && u!=EOF)
        {
            do_open_comm(dw);
            fRet = TRUE;
        }
    }
    return fRet;
}

static TOKREC DumpTokTable[] = 
{
    {TOK_TSPDEV, TEXT(" tspdev%n"), (fTOK_MATCHWORD), TEXT("tspdev")},

    {TOK_UNKNOWN, TEXT("<unknown>"), (0), TEXT("<unknown>")} // should be last.
};

BOOL parse_dump_tspdev(const TCHAR *szInBuf, BOOL fHelp);

BOOL parse_dump(const TCHAR *szInBuf, BOOL fHelp)
{
    TOKEN tok = TOK_UNKNOWN;
    BOOL fRet = FALSE;

    tok = Tokenize(&szInBuf, DumpTokTable);

    switch(tok)
    {
        case TOK_TSPDEV:
            fRet = parse_dump_tspdev(szInBuf, fHelp);
            break;

        default: 
            if (fHelp)
            {
                printf(" dump tspdev <device#> ...\n");
                fRet = TRUE;
            }
            break;
    }

    return fRet;
}


BOOL parse_dump_tspdev(const TCHAR *szInBuf, BOOL fHelp)
{
    BOOL fRet = FALSE;
    DWORD dw  = 0;

    if (fHelp)
    {
        printf(" dump tspdev <device#>\n");
        printf("Dumps internal state of the specified TAPI device\n");
        fRet = TRUE;
    }
    else
    {
        UINT u=sscanf(szInBuf, "%lu", &dw);
        if (u && u!=EOF)
        {
            do_dump_tspdev(dw);
            fRet = TRUE;
        }
    }
    return fRet;
}


BOOL parse_close(const TCHAR *szInBuf, BOOL fHelp)
{
    TOKEN tok = TOK_UNKNOWN;
    BOOL fRet = FALSE;

    if (fHelp)
    {
        printf(" c[lose] <handle> ...\n");
    }
    else
    {
        printf(" close not implemeted ...\n");
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\umdmxfrm\cirrus.h ===
//---------------------------------------------------------------------------
//
//  Module:   wavein.c
//
//  Description:
//     Wave interface for MSSB16.DRV.
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//
//  History:   Date       Author      Comment
//@@END_MSINTERNAL
/**************************************************************************
 *
 *  Copyright (c) 1994 - 1995	Microsoft Corporation.	All Rights Reserved.
 *
 **************************************************************************/



#define SigmaMAX16 (.366)
#define SigmaMAX8  (.465)
#define SigmaMAX4  (.66 )

#define SigmaMIN   (.001)


typedef struct tagQData
{
  int CodedQout;      // - Quantization output Code Word
  double Sigma1;        // - Sigma coefficient for previous step
  double out;           // - Quantization output signal
} CQDATA;

typedef struct tagDQData
{
  int oldCode;        // - Dequantization output Code Word for previous step
  double Sigma1;        // - Sigma coefficient for previous step
  double out;           // - Dequantization output signal
} CDQDATA;


typedef struct _COMPRESS_OBJECT {

    WORD      Gain;

    LONG      PredictedSample;
    LONG      StepSize;
    LONG      Index;

    struct {

        // Filter Z-buffers (zero initialized)
        double a[2];
        double b[6];

        double y[3];
        double q[7];

        double X1;

        CQDATA CQData;

    } RW;


} COMPRESS_OBJECT, *PCOMPRESS_OBJECT, FAR *LPCOMPRESS_OBJECT;

typedef struct _DECOMPRESS_OBJECT {

    WORD     Gain;

    LONG     NewSample;
    LONG     Index;
    LONG     StepSize;

    struct {

        // Filter Z-buffers (zero initialized) for main decoder loop
        double a0[2];
        double b0[6];
        double y0[3];
        double q0[7];

        // Filter Z-buffers (zero initialized) for second ring filter
        double a1[2];
        double b1[6];
        double y1[3];
        double q1[7];

        // Filter Z-buffers (zero initialized) for third ring filter
        double a2[2];
        double b2[6];
        double y2[3];
        double q2[7];

        BOOL   PostFilter;

        double Y1;

        CDQDATA  CDQData;

    } RW;


} DECOMPRESS_OBJECT, *PDECOMPRESS_OBJECT, FAR *LPDECOMPRESS_OBJECT;



VOID
InitCompressor(
    LPCOMPRESS_OBJECT   State,
    WORD                Gain
    );

BYTE  WINAPI
CompressPCM(
    LPCOMPRESS_OBJECT   State,
    SHORT               Sample1,
    SHORT               Sample2
    );




VOID
InitDecompressor(
    LPDECOMPRESS_OBJECT   State,
    WORD                  Gain
    );

VOID PASCAL
SRConvert8000to4800(LPINT lpSrc,
            DWORD dwSrcLen,
            LPINT lpDst,
            DWORD dwDstLen
            );



VOID PASCAL
Compress16to4(
            LPCOMPRESS_OBJECT State,
            LPSTR lpSrc,
            DWORD dwSrcLen,
            LPSTR lpDst,
            DWORD dwDstLen
            );


VOID PASCAL
SRConvert4800to8000(LPINT lpSrc,
            DWORD dwSrcLen,
            LPINT lpDst,
            DWORD dwDstLen
            );


VOID PASCAL
Decompress4to16(
            LPDECOMPRESS_OBJECT State,
            LPSTR lpSrc,
            DWORD dwSrcLen,
            LPDWORD lpDst,
            DWORD dwDstLen
            );

VOID PASCAL
Decompress4to16NS(
            LPDECOMPRESS_OBJECT State,
            LPSTR lpSrc,
            DWORD dwSrcLen,
            LPDWORD lpDst,
            DWORD dwDstLen
            );


DWORD FAR PASCAL
SRConvert8000to7200PCM(
            LPVOID    lpContext,
            LPSTR lpSrc,
            DWORD dwSrcLen,
            LPSTR lpDst,
            DWORD dwDstLen
            );


DWORD FAR PASCAL
SRConvert8000to4800PCM(
            LPVOID    lpContext,
            LPSTR lpSrc,
            DWORD dwSrcLen,
            LPSTR lpDst,
            DWORD dwDstLen
            );


DWORD FAR PASCAL
SRConvert4800to8000PCM(
            LPVOID    lpContext,
            LPSTR lpSrc,
            DWORD dwSrcLen,
            LPSTR lpDst,
            DWORD dwDstLen
            );



DWORD FAR PASCAL
SRConvert8000to7200PCMUnsigned(
            LPVOID    lpContext,
            LPSTR lpSrc,
            DWORD dwSrcLen,
            LPSTR lpDst,
            DWORD dwDstLen
            );


DWORD FAR PASCAL
SRConvert7200to8000PCMUnsigned(
            LPVOID    lpContext,
            LPSTR lpSrc,
            DWORD dwSrcLen,
            LPSTR lpDst,
            DWORD dwDstLen
            );


DWORD WINAPI
Convert16PCMto8PCM(
    LPVOID    Context,
    LPBYTE    Source,
    DWORD     SourceLength,
    LPBYTE    Destination,
    DWORD     DestinationLength
    );

DWORD WINAPI
Convert8PCMto16PCM(
    LPVOID    Context,
    LPBYTE    Source,
    DWORD     SourceLength,
    LPBYTE    Destination,
    DWORD     DestinationLength
    );


DWORD WINAPI
ConvertaLawto16PCM(
    LPVOID    Context,
    LPBYTE    Source,
    DWORD     SourceLength,
    LPBYTE    Destination,
    DWORD     DestinationLength
    );

DWORD WINAPI
ConvertuLawto16PCM(
    LPVOID    Context,
    LPBYTE    Source,
    DWORD     SourceLength,
    LPBYTE    Destination,
    DWORD     DestinationLength
    );

DWORD WINAPI
Convert16PCMtoaLaw(
    LPVOID    Context,
    LPBYTE    Source,
    DWORD     SourceLength,
    LPBYTE    Destination,
    DWORD     DestinationLength
    );

DWORD WINAPI
Convert16PCMtouLaw(
    LPVOID    Context,
    LPBYTE    Source,
    DWORD     SourceLength,
    LPBYTE    Destination,
    DWORD     DestinationLength
    );







SHORT _inline
AdjustGain(
    SHORT    Sample,
    WORD     Adjust
    )

{

    LONG     NewSample=Sample;

    if (Adjust != 0x0100) {

        NewSample=(LONG)Sample * (LONG)Adjust;

        NewSample=NewSample >> 8;

        if (NewSample > 32767) {
            //
            //  positive overflow
            //
            NewSample = 32767;

        } else {

            if (NewSample < -32768) {
                //
                //  negative overflow
                //
                NewSample = -32768;
            }
        }

    }

    return (SHORT)NewSample;

}


VOID
WINAPI
In4Bit7200to8Bit8000GetBufferSizes(
    LPVOID  lpvObject,
    DWORD   dwBytes,
    LPDWORD lpdwBufSizeA,
    LPDWORD lpdwBufSizeB
    );

DWORD
WINAPI
In7200to8000RateConvert(
    LPVOID  lpvObject,
    LPBYTE  lpSrc,
    DWORD   dwSrcLen,
    LPBYTE  lpDest,
    DWORD   dwDestLen
    );

VOID
WINAPI
Out16bit8000to4bit7200GetBufferSizes(
    LPVOID  lpvObject,
    DWORD   dwBytes,
    LPDWORD lpdwBufSizeA,
    LPDWORD lpdwBufSizeB
    );

DWORD
WINAPI
Out8000to7200RateConvert(
    LPVOID  lpvObject,
    LPBYTE  lpSrc,
    DWORD   dwSrcLen,
    LPBYTE  lpDest,
    DWORD   dwDestLen
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\umdmxfrm\thinkpad.c ===
//---------------------------------------------------------------------------
//
//  Module:   wavein.c
//
//  Description:
//     Wave interface for MSSB16.DRV.
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Bryan A. Woodruff
//
//  History:   Date       Author      Comment
//@@END_MSINTERNAL
/**************************************************************************
 *
 *  Copyright (c) 1994 - 1995	Microsoft Corporation.	All Rights Reserved.
 *
 **************************************************************************/

#include "xfrmpriv.h"




DWORD FAR PASCAL _loadds ThinkpadInInit
(
    LPVOID  lpvObject,
    WORD    Gain
)
{

    if (0 == Gain) {

        Gain = 0x0100; // no gain
    }


    InitDecompressor(
        (LPDECOMPRESS_OBJECT)lpvObject,
        Gain
        );


    return MMSYSERR_NOERROR;
}

VOID FAR PASCAL _loadds Thinkpad8000InGetBufferSizes
(
    LPVOID  lpvObject,
    DWORD   dwBytes,
    LPDWORD lpdwBufSizeA,
    LPDWORD lpdwBufSizeB
)
{
    *lpdwBufSizeA = (dwBytes + 3) / 4;
    *lpdwBufSizeB = 0;
}


DWORD FAR PASCAL _loadds ThinkpadOutInit
(
    LPVOID  lpvObject,
    WORD    Gain
)
{
    if (0 == Gain) {

        Gain = 0x0100; // no gain
    }



    InitCompressor(
        (LPCOMPRESS_OBJECT)lpvObject,
        Gain
        );


    return MMSYSERR_NOERROR;
}

VOID FAR PASCAL _loadds Thinkpad8000OutGetBufferSizes
(
    LPVOID  lpvObject,
    DWORD   dwBytes,
    LPDWORD lpdwBufSizeA,
    LPDWORD lpdwBufSizeB
)
{
    *lpdwBufSizeA = dwBytes / 4;
    *lpdwBufSizeB = 0;
}


DWORD FAR PASCAL _loadds Thinkpad7200GetPosition
(
    LPVOID  lpvObject,
    DWORD dwBytes
)
{
    return ((dwBytes * 4) * 10) / 9;
}

DWORD FAR PASCAL _loadds Thinkpad8000GetPosition
(
    LPVOID  lpvObject,
    DWORD dwBytes
)
{
    return dwBytes * 4;
}

DWORD FAR PASCAL GetThinkpad7200Info
(
    DWORD dwID,
    LPXFORM_INFO lpXformInfo,
    LPXFORM_INFO lpxiOutput
)
{
    lpXformInfo->wObjectSize = sizeof(DECOMPRESS_OBJECT);
    lpXformInfo->lpfnInit           = ThinkpadInInit;
    lpXformInfo->lpfnGetPosition    = Thinkpad7200GetPosition;
    lpXformInfo->lpfnGetBufferSizes = In4Bit7200to8Bit8000GetBufferSizes; //Thinkpad7200InGetBufferSizes;
    lpXformInfo->lpfnTransformA     = In7200to8000RateConvert; //ThinkpadInRateConvert;
    lpXformInfo->lpfnTransformB     = CirrusInDecode;

    lpxiOutput->wObjectSize = sizeof(COMPRESS_OBJECT);
    lpxiOutput->lpfnInit           = ThinkpadOutInit;
    lpxiOutput->lpfnGetPosition    = Thinkpad7200GetPosition;
    lpxiOutput->lpfnGetBufferSizes = Out16bit8000to4bit7200GetBufferSizes; //Thinkpad7200OutGetBufferSizes;
    lpxiOutput->lpfnTransformA     = Out8000to7200RateConvert; //ThinkpadOutRateConvert;
    lpxiOutput->lpfnTransformB     = CirrusOutEncode;

    return MMSYSERR_NOERROR;
}




DWORD FAR PASCAL GetThinkpad8000Info
(
    DWORD dwID,
    LPXFORM_INFO lpXformInfo,
    LPXFORM_INFO lpxiOutput
)
{
    lpXformInfo->wObjectSize = sizeof(DECOMPRESS_OBJECT);
    lpXformInfo->lpfnInit           = ThinkpadInInit;
    lpXformInfo->lpfnGetPosition    = Thinkpad8000GetPosition;
    lpXformInfo->lpfnGetBufferSizes = Thinkpad8000InGetBufferSizes;
    lpXformInfo->lpfnTransformA     = CirrusInDecode;
    lpXformInfo->lpfnTransformB     = 0;

    lpxiOutput->wObjectSize = sizeof(COMPRESS_OBJECT);
    lpxiOutput->lpfnInit           = ThinkpadOutInit;
    lpxiOutput->lpfnGetPosition    = Thinkpad8000GetPosition;
    lpxiOutput->lpfnGetBufferSizes = Thinkpad8000OutGetBufferSizes;
    lpxiOutput->lpfnTransformA     = CirrusOutEncode;
    lpxiOutput->lpfnTransformB     = 0;

    return MMSYSERR_NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\unimodem\src\umdmxfrm\rateconv.c ===
//---------------------------------------------------------------------------
//
//  Module:   init.c
//
//  Description:
//     MSSB16 initialization routines
//
//@@BEGIN_MSINTERNAL
//  Development Team:
//     Bryan A. Woodruff
//
//  History:   Date       Author      Comment
//              4/21/94   BryanW      Added this comment block.
//
//@@END_MSINTERNAL
/**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *  Copyright (c) 1994 - 1995	Microsoft Corporation.	All Rights Reserved.
 *
 **************************************************************************/




#include "xfrmpriv.h"



#pragma optimize("t",on)

DWORD WINAPI
SRConvertDown(
    LONG      NumberOfSourceSamplesInGroup,
    LONG      NumberOfDestSamplesInGroup,
    short    *Source,
    DWORD     SourceLength,
    short    *Destination,
    DWORD     DestinationLength
    )

{

    LONG      SourceIndex;

    LONG      DestPos;

    LONG      SourcePos;

    LONG      Sample1;
    LONG      Sample2;

    LONG      Difference;

    LONG      Distance;

    DWORD     FilledInSamples;

    short    *EndPoint;

    FilledInSamples=((SourceLength/NumberOfSourceSamplesInGroup)*NumberOfDestSamplesInGroup)
                    +((SourceLength%NumberOfSourceSamplesInGroup)*NumberOfDestSamplesInGroup/NumberOfSourceSamplesInGroup);

    EndPoint=Destination+FilledInSamples;


    DestPos=0;

    while (Destination < EndPoint) {

        //
        //  find the nearest source sample that is less than or equall
        //
        SourceIndex= DestPos/NumberOfDestSamplesInGroup;

        SourcePos=  SourceIndex*NumberOfDestSamplesInGroup;

        //
        //  get that source and the next one
        //
        Sample1=Source[SourceIndex];

        Sample2=Source[SourceIndex+1];

        //
        //  get the difference of the two samples
        //
        Difference=Sample2-Sample1;

        //
        //  determine the distance from the source sample to the dest sample
        //
        Distance=DestPos - SourcePos;

        //
        //  slope=Difference/(distance between source samples);
        //
        //  offset=slope*Distance;
        //
        //  DestSample=Source1+Offset;
        //

        *Destination++=(short)(Sample1+((Difference*Distance)/NumberOfDestSamplesInGroup));

        //
        //
        DestPos+=NumberOfSourceSamplesInGroup;
    }

    return FilledInSamples;

}


DWORD WINAPI
SRConvertUp(
    LONG      NumberOfSourceSamplesInGroup,
    LONG      NumberOfDestSamplesInGroup,
    short    *Source,
    DWORD     SourceLength,
    short    *Destination,
    DWORD     DestinationLength
    )

{



    LONG     NumberOfSourceSamples=9;
    LONG     NumberOfDestSamples=10;

    LONG     SourceIndex;

    LONG     DestPos;

    LONG     SourcePos;

    LONG     Sample1;
    LONG     Sample2;

    LONG     Difference;

    LONG     Distance;

    short   *EndPoint;

    DWORD    SamplesFilled;

    if (SourceLength == 0) {

        return 0;
    }


    //
    //  reduce the length, so we will have enough samples to do the conversion
    //
    SourceLength--;


    SamplesFilled=((SourceLength/NumberOfSourceSamplesInGroup)*NumberOfDestSamplesInGroup)
                       +((SourceLength%NumberOfSourceSamplesInGroup)*NumberOfDestSamplesInGroup/NumberOfSourceSamplesInGroup);


    EndPoint=Destination + SamplesFilled;


    ASSERT(EndPoint <= Destination+DestinationLength);

    DestPos=0;

    while (Destination < EndPoint) {

        //
        //  find the nearest source sample that is less than or equall
        //
        SourceIndex= DestPos/NumberOfDestSamplesInGroup;

        SourcePos=  SourceIndex*NumberOfDestSamplesInGroup;


        //
        //  determine the distance from the source sample to the dest sample
        //
        Distance=DestPos - SourcePos;

        //
        //  get that source
        //
        Sample1=Source[SourceIndex];


        if (Distance != 0) {
            //
            //  get the second sample
            //
            Sample2=Source[SourceIndex+1];

            //
            //  get the difference of the two samples
            //
            Difference=Sample2-Sample1;

            //
            //  slope=Difference/(distance between source samples);
            //
            //  offset=slope*Distance;
            //
            //  DestSample=Source1+Offset;
            //

            *Destination++=(short)(Sample1+((Difference*Distance)/NumberOfDestSamplesInGroup));

        } else {
            //
            //  source and dest are the same just copy the sample
            //
            *Destination++=(short)Sample1;
        }
        //
        //
        DestPos+=NumberOfSourceSamplesInGroup;
    }





    return SamplesFilled;

}





VOID WINAPI
SRConvert8000to7200(
    short    *Source,
    DWORD     SourceLength,
    short    *Destination,
    DWORD     DestinationLength
    )

{


    LONG      NumberOfSourceSamples=10;
    LONG      NumberOfDestSamples=9;

    LONG      SourceIndex;

    LONG      DestPos;

    LONG      SourcePos;

    LONG      Sample1;
    LONG      Sample2;

    LONG      Difference;

    LONG      Distance;


    short    *EndPoint=Destination+((SourceLength/10)*9)+((SourceLength%10)*9/10);


    DestPos=0;

    while (Destination < EndPoint) {

        //
        //  find the nearest source sample that is less than of equall
        //
        SourceIndex= DestPos/NumberOfDestSamples;

        SourcePos=  SourceIndex*NumberOfDestSamples;

        //
        //  get that source and the next one
        //
        Sample1=Source[SourceIndex];

        Sample2=Source[SourceIndex+1];

        //
        //  get the difference of the two samples
        //
        Difference=Sample2-Sample1;

        //
        //  determine the distance from the source sample to the dest sample
        //
        Distance=DestPos - SourcePos;

        //
        //  slope=Difference/(distance between source samples);
        //
        //  offset=slope*Distance;
        //
        //  DestSample=Source1+Offset;
        //

        *Destination++=(short)(Sample1+((Difference*Distance)/NumberOfDestSamples));

        //
        //
        DestPos+=NumberOfSourceSamples;
    }





    return;

}

#pragma optimize("",on)


DWORD WINAPI
SRConvert7200to8000(
    short    *Source,
    DWORD     SourceLength,
    short    *Destination,
    DWORD     DestinationLength
    )

{



    LONG     NumberOfSourceSamples=9;
    LONG     NumberOfDestSamples=10;

    LONG     SourceIndex;

    LONG     DestPos;

    LONG     SourcePos;

    LONG     Sample1;
    LONG     Sample2;

    LONG     Difference;

    LONG     Distance;

    short   *EndPoint;

    DWORD    SamplesFilled;

    if (SourceLength == 0) {

        return 0;
    }


    //
    //  reduce the length, so we will have enough samples to do the conversion
    //
    SourceLength--;


    SamplesFilled=((SourceLength/NumberOfSourceSamples)*NumberOfDestSamples)
                       +((SourceLength%NumberOfSourceSamples)*NumberOfDestSamples/NumberOfSourceSamples);


    EndPoint=Destination + SamplesFilled;


    ASSERT(EndPoint <= Destination+DestinationLength);

    DestPos=0;

    while (Destination < EndPoint) {

        //
        //  find the nearest source sample that is less than or equall
        //
        SourceIndex= DestPos/NumberOfDestSamples;

        SourcePos=  SourceIndex*NumberOfDestSamples;


        //
        //  determine the distance from the source sample to the dest sample
        //
        Distance=DestPos - SourcePos;

        //
        //  get that source
        //
        Sample1=Source[SourceIndex];


        if (Distance != 0) {
            //
            //  get the second sample
            //
            Sample2=Source[SourceIndex+1];

            //
            //  get the difference of the two samples
            //
            Difference=Sample2-Sample1;

            //
            //  slope=Difference/(distance between source samples);
            //
            //  offset=slope*Distance;
            //
            //  DestSample=Source1+Offset;
            //

            *Destination++=(short)(Sample1+((Difference*Distance)/NumberOfDestSamples));

        } else {
            //
            //  source and dest are the same just copy the sample
            //
            *Destination++=(short)Sample1;
        }
        //
        //
        DestPos+=NumberOfSourceSamples;
    }





    return SamplesFilled;

}




DWORD WINAPI
Convert8PCMto16PCM(
    LPVOID    Context,
    LPBYTE    Source,
    DWORD     SourceLength,
    LPBYTE    Destination,
    DWORD     DestinationLength
    )

{
    LPDECOMPRESS_OBJECT   State=(LPDECOMPRESS_OBJECT)Context;

    PSHORT    RealDest=(PSHORT)Destination;

    LPBYTE    EndPoint=Source+SourceLength;


    while (Source < EndPoint) {

        *RealDest++= AdjustGain(
                         (SHORT)(((WORD)*Source++ - 0x80) << 8),
                         State->Gain
                         );

    }

    return SourceLength*2;

}



DWORD WINAPI
Convert16PCMto8PCM(
    LPVOID    Context,
    LPBYTE    Source,
    DWORD     SourceLength,
    LPBYTE    Destination,
    DWORD     DestinationLength
    )

{

    LPCOMPRESS_OBJECT   State=(LPCOMPRESS_OBJECT)Context;

    LPWORD    RealSource=(LPWORD)Source;

    LPWORD    EndPoint=RealSource+SourceLength/2;


    while (RealSource < EndPoint) {

        *Destination++=(BYTE)((AdjustGain(*RealSource++,State->Gain) >> 8) +0x80);

    }

    return SourceLength/2;

}




//--------------------------------------------------------------------------;
//
//  Name:
//      AlawToPcmTable
//
//
//  Description:
//      this array maps A-law characters to 16-bit PCM
//
//
//  Arguments:
//      the index into the array is an A-law character
//
//  Return:
//      an element of the array is a 16-bit PCM value
//
//  Notes:
//
//
//  History:
//      07/28/93    Created.
//
//
//--------------------------------------------------------------------------;
const SHORT AlawToPcmTable[256] =
    {
         -5504,         // y[00]=   -688
         -5248,         // y[01]=   -656
         -6016,         // y[02]=   -752
         -5760,         // y[03]=   -720
         -4480,         // y[04]=   -560
         -4224,         // y[05]=   -528
         -4992,         // y[06]=   -624
         -4736,         // y[07]=   -592
         -7552,         // y[08]=   -944
         -7296,         // y[09]=   -912
         -8064,         // y[0a]=  -1008
         -7808,         // y[0b]=   -976
         -6528,         // y[0c]=   -816
         -6272,         // y[0d]=   -784
         -7040,         // y[0e]=   -880
         -6784,         // y[0f]=   -848
         -2752,         // y[10]=   -344
         -2624,         // y[11]=   -328
         -3008,         // y[12]=   -376
         -2880,         // y[13]=   -360
         -2240,         // y[14]=   -280
         -2112,         // y[15]=   -264
         -2496,         // y[16]=   -312
         -2368,         // y[17]=   -296
         -3776,         // y[18]=   -472
         -3648,         // y[19]=   -456
         -4032,         // y[1a]=   -504
         -3904,         // y[1b]=   -488
         -3264,         // y[1c]=   -408
         -3136,         // y[1d]=   -392
         -3520,         // y[1e]=   -440
         -3392,         // y[1f]=   -424
        -22016,         // y[20]=  -2752
        -20992,         // y[21]=  -2624
        -24064,         // y[22]=  -3008
        -23040,         // y[23]=  -2880
        -17920,         // y[24]=  -2240
        -16896,         // y[25]=  -2112
        -19968,         // y[26]=  -2496
        -18944,         // y[27]=  -2368
        -30208,         // y[28]=  -3776
        -29184,         // y[29]=  -3648
        -32256,         // y[2a]=  -4032
        -31232,         // y[2b]=  -3904
        -26112,         // y[2c]=  -3264
        -25088,         // y[2d]=  -3136
        -28160,         // y[2e]=  -3520
        -27136,         // y[2f]=  -3392
        -11008,         // y[30]=  -1376
        -10496,         // y[31]=  -1312
        -12032,         // y[32]=  -1504
        -11520,         // y[33]=  -1440
         -8960,         // y[34]=  -1120
         -8448,         // y[35]=  -1056
         -9984,         // y[36]=  -1248
         -9472,         // y[37]=  -1184
        -15104,         // y[38]=  -1888
        -14592,         // y[39]=  -1824
        -16128,         // y[3a]=  -2016
        -15616,         // y[3b]=  -1952
        -13056,         // y[3c]=  -1632
        -12544,         // y[3d]=  -1568
        -14080,         // y[3e]=  -1760
        -13568,         // y[3f]=  -1696
          -344,         // y[40]=    -43
          -328,         // y[41]=    -41
          -376,         // y[42]=    -47
          -360,         // y[43]=    -45
          -280,         // y[44]=    -35
          -264,         // y[45]=    -33
          -312,         // y[46]=    -39
          -296,         // y[47]=    -37
          -472,         // y[48]=    -59
          -456,         // y[49]=    -57
          -504,         // y[4a]=    -63
          -488,         // y[4b]=    -61
          -408,         // y[4c]=    -51
          -392,         // y[4d]=    -49
          -440,         // y[4e]=    -55
          -424,         // y[4f]=    -53
           -88,         // y[50]=    -11
           -72,         // y[51]=     -9
          -120,         // y[52]=    -15
          -104,         // y[53]=    -13
           -24,         // y[54]=     -3
            -8,         // y[55]=     -1
           -56,         // y[56]=     -7
           -40,         // y[57]=     -5
          -216,         // y[58]=    -27
          -200,         // y[59]=    -25
          -248,         // y[5a]=    -31
          -232,         // y[5b]=    -29
          -152,         // y[5c]=    -19
          -136,         // y[5d]=    -17
          -184,         // y[5e]=    -23
          -168,         // y[5f]=    -21
         -1376,         // y[60]=   -172
         -1312,         // y[61]=   -164
         -1504,         // y[62]=   -188
         -1440,         // y[63]=   -180
         -1120,         // y[64]=   -140
         -1056,         // y[65]=   -132
         -1248,         // y[66]=   -156
         -1184,         // y[67]=   -148
         -1888,         // y[68]=   -236
         -1824,         // y[69]=   -228
         -2016,         // y[6a]=   -252
         -1952,         // y[6b]=   -244
         -1632,         // y[6c]=   -204
         -1568,         // y[6d]=   -196
         -1760,         // y[6e]=   -220
         -1696,         // y[6f]=   -212
          -688,         // y[70]=    -86
          -656,         // y[71]=    -82
          -752,         // y[72]=    -94
          -720,         // y[73]=    -90
          -560,         // y[74]=    -70
          -528,         // y[75]=    -66
          -624,         // y[76]=    -78
          -592,         // y[77]=    -74
          -944,         // y[78]=   -118
          -912,         // y[79]=   -114
         -1008,         // y[7a]=   -126
          -976,         // y[7b]=   -122
          -816,         // y[7c]=   -102
          -784,         // y[7d]=    -98
          -880,         // y[7e]=   -110
          -848,         // y[7f]=   -106
          5504,         // y[80]=    688
          5248,         // y[81]=    656
          6016,         // y[82]=    752
          5760,         // y[83]=    720
          4480,         // y[84]=    560
          4224,         // y[85]=    528
          4992,         // y[86]=    624
          4736,         // y[87]=    592
          7552,         // y[88]=    944
          7296,         // y[89]=    912
          8064,         // y[8a]=   1008
          7808,         // y[8b]=    976
          6528,         // y[8c]=    816
          6272,         // y[8d]=    784
          7040,         // y[8e]=    880
          6784,         // y[8f]=    848
          2752,         // y[90]=    344
          2624,         // y[91]=    328
          3008,         // y[92]=    376
          2880,         // y[93]=    360
          2240,         // y[94]=    280
          2112,         // y[95]=    264
          2496,         // y[96]=    312
          2368,         // y[97]=    296
          3776,         // y[98]=    472
          3648,         // y[99]=    456
          4032,         // y[9a]=    504
          3904,         // y[9b]=    488
          3264,         // y[9c]=    408
          3136,         // y[9d]=    392
          3520,         // y[9e]=    440
          3392,         // y[9f]=    424
         22016,         // y[a0]=   2752
         20992,         // y[a1]=   2624
         24064,         // y[a2]=   3008
         23040,         // y[a3]=   2880
         17920,         // y[a4]=   2240
         16896,         // y[a5]=   2112
         19968,         // y[a6]=   2496
         18944,         // y[a7]=   2368
         30208,         // y[a8]=   3776
         29184,         // y[a9]=   3648
         32256,         // y[aa]=   4032
         31232,         // y[ab]=   3904
         26112,         // y[ac]=   3264
         25088,         // y[ad]=   3136
         28160,         // y[ae]=   3520
         27136,         // y[af]=   3392
         11008,         // y[b0]=   1376
         10496,         // y[b1]=   1312
         12032,         // y[b2]=   1504
         11520,         // y[b3]=   1440
          8960,         // y[b4]=   1120
          8448,         // y[b5]=   1056
          9984,         // y[b6]=   1248
          9472,         // y[b7]=   1184
         15104,         // y[b8]=   1888
         14592,         // y[b9]=   1824
         16128,         // y[ba]=   2016
         15616,         // y[bb]=   1952
         13056,         // y[bc]=   1632
         12544,         // y[bd]=   1568
         14080,         // y[be]=   1760
         13568,         // y[bf]=   1696
           344,         // y[c0]=     43
           328,         // y[c1]=     41
           376,         // y[c2]=     47
           360,         // y[c3]=     45
           280,         // y[c4]=     35
           264,         // y[c5]=     33
           312,         // y[c6]=     39
           296,         // y[c7]=     37
           472,         // y[c8]=     59
           456,         // y[c9]=     57
           504,         // y[ca]=     63
           488,         // y[cb]=     61
           408,         // y[cc]=     51
           392,         // y[cd]=     49
           440,         // y[ce]=     55
           424,         // y[cf]=     53
            88,         // y[d0]=     11
            72,         // y[d1]=      9
           120,         // y[d2]=     15
           104,         // y[d3]=     13
            24,         // y[d4]=      3
             8,         // y[d5]=      1
            56,         // y[d6]=      7
            40,         // y[d7]=      5
           216,         // y[d8]=     27
           200,         // y[d9]=     25
           248,         // y[da]=     31
           232,         // y[db]=     29
           152,         // y[dc]=     19
           136,         // y[dd]=     17
           184,         // y[de]=     23
           168,         // y[df]=     21
          1376,         // y[e0]=    172
          1312,         // y[e1]=    164
          1504,         // y[e2]=    188
          1440,         // y[e3]=    180
          1120,         // y[e4]=    140
          1056, 