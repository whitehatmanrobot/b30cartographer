                         */
    /*                                                                  */
    /********************************************************************/

#pragma init_seg(lib)
#ifdef DISABLE_STRING_LOCKS
UNIQUE<NO_LOCK> *STRING::Unique;
#else
SPINLOCK STRING::Spinlock;
UNIQUE<FULL_LOCK> *STRING::Unique = NULL;
#endif

    /********************************************************************/
    /*                                                                  */
    /*   Create the string table.                                       */
    /*                                                                  */
    /*   We create the string table on first use.  This is tricky as    */
    /*   we may have created multiple threads so we must be careful     */
    /*   to avoid race conditions.  We also arrang for the string table */
    /*   to be deleted at the end of the run unit.                      */
    /*                                                                  */
    /********************************************************************/

VOID STRING::CreateStringTable( VOID )
	{
#ifdef DISABLE_STRING_LOCKS
	STATIC DELAY<UNIQUE<NO_LOCK>> Delay;

	//
	//   Create the new string table.
	//
	Unique = new UNIQUE<NO_LOCK>;

	//
	//   Register the string table for deletion at
	//   at the end of the run unit.
	//
	Delay.DeferedDelete( Unique );
#else
	//
	//   Claim a lock to avoid race conditions.
	//
	Spinlock.ClaimLock();

	//
	//   If the string table still does not exist
	//   then create it.
	//
	if ( Unique == NULL )
		{
		STATIC DELAY< UNIQUE<FULL_LOCK> > Delay;

		//
		//   Create the new string table.
		//
		Unique = new UNIQUE<FULL_LOCK>;

		//
		//   Register the string table for deletion at
		//   at the end of the run unit.
		//
		Delay.DeferedDelete( Unique );
		}

	//
	//   Release the lock.
	//
	Spinlock.ReleaseLock();
#endif
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\library\thread.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "LibraryPCH.hpp"

#include "Thread.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants local to the class.                                  */
    /*                                                                  */
    /*   The thread class keeps track of active threads.                */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 ThreadsSize			  = 16;

    /********************************************************************/
    /*                                                                  */
    /*   Data structures local to the class.                            */
    /*                                                                  */
    /*   When we start a thread we want to configure it.  However,      */
    /*   we no longer have access to the class information.  Hence,     */
    /*   we need a structure to pass over all of the interesting        */
    /*   values to the new thread.                                      */
    /*                                                                  */
    /********************************************************************/

typedef struct
    {
    BOOLEAN							  Affinity;
    VOLATILE SBIT16					  *Cpu;
    NEW_THREAD						  Function;
    SBIT16							  MaxCpus; 
    VOID							  *Parameter;
    BOOLEAN							  Priority;
    HANDLE							  Running;
    HANDLE							  Started;
	THREAD							  *Thread;
	BOOLEAN							  Wait;
    }
SETUP_NEW_THREAD;

    /********************************************************************/
    /*                                                                  */
    /*   Static functions local to the class.                           */
    /*                                                                  */
    /*   The static functions used by this class are declared here.     */
    /*                                                                  */
    /********************************************************************/

STATIC VOID CDECL NewThread( VOID *SetupParameter );

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create a thread class and initialize it.  This call is not     */
    /*   thread safe and should only be made in a single thread         */
    /*   environment.                                                   */
    /*                                                                  */
    /********************************************************************/

THREAD::THREAD( VOID ) : 
		//
		//   Call the constructors for the contained classes.
		//
		Threads( ThreadsSize,NoAlignment,CacheLineSize )
    {
	//
	//   The inital configuration.
	//
    Affinity = False;
    Cpu = 0;
    Priority = False;
    Stack = 0;

	MaxThreads = ThreadsSize;
	ThreadsUsed = 0;

	//
	//   This event is signaled when a thread is 
	//   running.
	//
    if ( (Running = CreateEvent( NULL, FALSE, FALSE, NULL )) == NULL)
        { Failure( "Create event in constructor for THREAD" ); }

	//
	//   This event is signaled when a new thread can 
	//   be started.
	//
    if ( (Started = CreateEvent( NULL, FALSE, TRUE, NULL )) == NULL)
        { Failure( "Create event in constructor for THREAD" ); }
    }

    /********************************************************************/
    /*                                                                  */
    /*   End a thread.                                                  */
    /*                                                                  */
    /*   Delete the thread handle from the internal table and then      */
    /*   terminate the thread.                                          */
    /*                                                                  */
    /********************************************************************/

VOID THREAD::EndThread( VOID )
    {
	UnregisterThread();

	_endthread(); 
	}

    /********************************************************************/
    /*                                                                  */
    /*   Find a thread.                                                 */
    /*                                                                  */
    /*   Find a registered thread in the thread info table.             */
    /*                                                                  */
    /********************************************************************/

SBIT32 THREAD::FindThread( SBIT32 ThreadId )
    {
	REGISTER SBIT32 Count;

	//
	//   Find a thread in the active thread list.
	//
	for ( Count=0;Count < ThreadsUsed;Count ++ )
		{
		if ( ThreadId == Threads[ Count ].ThreadId )
			{ return Count; }
		}

	return NoThread;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Start a new thread.                                            */
    /*                                                                  */
    /*   When a new thread is created it executes a special initial     */
    /*   function which configures it.  When control returns to this    */
    /*   function the thread is terminated.                             */
    /*                                                                  */
    /********************************************************************/

STATIC VOID CDECL NewThread( VOID *SetupParameter )
    {
    AUTO SETUP_NEW_THREAD Setup = (*(SETUP_NEW_THREAD*) SetupParameter);

    //
    //   Set the affinity mask to the next processor if requested.
    //  
    if ( (Setup.Affinity) && (Setup.MaxCpus > 1) )
        {
        REGISTER DWORD AffinityMask;

        if ( (*Setup.Cpu) < Setup.MaxCpus )
            { AffinityMask = (1 << ((*Setup.Cpu) ++)); }
        else
            {
            AffinityMask = 1;
            (*Setup.Cpu) = 1;
            }

        if ( SetThreadAffinityMask( GetCurrentThread(),AffinityMask ) == 0 )
            { Failure( "Affinity mask invalid in NewThread()" ); }
        }

    //
    //   Set the priority to 'HIGH' if requested.
    //
    if ( Setup.Priority )
        { SetThreadPriority( GetCurrentThread(),THREAD_PRIORITY_HIGHEST ); }

	//
	//   The thread is now so add it to the table
	//   executiong threads.
	//
	Setup.Thread -> RegisterThread();

	//
	//   Wake up anyone who is waiting.
	//
	if ( Setup.Wait )
		{ SetEvent( Setup.Running ); }

	SetEvent( Setup.Started );

    //
    //   Call thread function.
    //
    Setup.Function( Setup.Parameter );

    //
    //   The thread function has returned so exit.
    //
    Setup.Thread -> EndThread();
    }

    /********************************************************************/
    /*                                                                  */
    /*   Register the current thread.                                   */
    /*                                                                  */
    /*   When a thread has created we can add the thread info to        */
    /*   our internal table.                                            */
    /*                                                                  */
    /********************************************************************/

VOID THREAD::RegisterThread( VOID )
    {
	REGISTER SBIT32 ThreadId = GetThreadId();

	//
	//   Claim a spinlock so we can update the 
	//   thread table.
	//
	Spinlock.ClaimLock();

	if ( FindThread( ThreadId ) == NoThread )
		{
		AUTO HANDLE NewHandle;
		REGISTER HANDLE Process = GetCurrentProcess();
		REGISTER HANDLE Thread = GetCurrentThread();

		//
		//   We need to duplicate the handle so we get
		//   a real thread handle and not the pretend
		//   ones supplied by NT.
		//
		if
				(
				DuplicateHandle
					(
					Process,
					Thread,
					Process,
					& NewHandle,
					DUPLICATE_SAME_ACCESS,
					False,
					DUPLICATE_SAME_ACCESS
					)
				)
			{
			REGISTER THREAD_INFO *ThreadInfo;

			//
			//   We may need to expand the table if there are
			//   a large number of threads.
			//
			while ( ThreadsUsed >= MaxThreads )
				{ Threads.Resize( (MaxThreads *= ExpandStore) ); }

			//
			//   Add the thread handle to the table.
			//
			ThreadInfo = & Threads[ ThreadsUsed ++ ];

			ThreadInfo -> Handle = NewHandle;
			ThreadInfo -> ThreadId = ThreadId;
			}
		}

	//
	//   We are finished so release the lock.
	//
	Spinlock.ReleaseLock();
    }

    /********************************************************************/
    /*                                                                  */
    /*   Set thread stack size.                                         */
    /*                                                                  */
    /*   Set thread stack size.  This will cause all new threads to     */
    /*   be created with the selected stack size.                       */
    /*                                                                  */
    /********************************************************************/

VOID THREAD::SetThreadStackSize( LONG Stack ) 
    {
#ifdef DEBUGGING
    if ( Stack >= 0 )
        {
#endif
        this -> Stack = Stack;
#ifdef DEBUGGING
        }
    else
        { Failure( "Stack size in SetThreadStack()" ); }
#endif
    }

    /********************************************************************/
    /*                                                                  */
    /*   Start a new thread.                                            */
    /*                                                                  */
    /*   Start a new thread and configure it as requested by the        */
    /*   caller.  If needed we will set the affinity and priority       */
    /*   of this thread later.                                          */
    /*                                                                  */
    /********************************************************************/

BOOLEAN THREAD::StartThread( NEW_THREAD Function,VOID *Parameter,BOOLEAN Wait )
    {
    STATIC SETUP_NEW_THREAD Setup;

	//
	//   Wait for any pending thread creations to
	//   complete.
	//
    while
        (
        WaitForSingleObject( Started,INFINITE )
            !=
        WAIT_OBJECT_0
        );

	//
	//   Create a thread activation record.
	//
    Setup.Affinity = Affinity;
    Setup.Cpu = & Cpu;
    Setup.Function = Function;
    Setup.MaxCpus = NumberOfCpus();
    Setup.Parameter = Parameter;
    Setup.Priority = Priority;
	Setup.Running = Running;
	Setup.Started = Started;
	Setup.Thread = this;
	Setup.Wait = Wait;

	//
	//   Call the operating system to start the thread.
	//
    if ( _beginthread( NewThread,(unsigned) Stack,(VOID*) & Setup ) != NULL )
		{
		//
		//   Wait for the thread to initialize is needed.
		//
		if ( Wait )
			{
			//
			//   Wait for the thread to start to run.
			//
			while
				(
				WaitForSingleObject( Running,INFINITE )
					!=
				WAIT_OBJECT_0
				);
			}

		return True;
		}
	else
		{ return False; }
    }

    /********************************************************************/
    /*                                                                  */
    /*   Unregister the current thread.                                 */
    /*                                                                  */
    /*   When a thread has terminated we can delete the thread          */
    /*   info from our internal table.                                  */
    /*                                                                  */
    /********************************************************************/

VOID THREAD::UnregisterThread( SBIT32 ThreadId )
    {
	REGISTER SBIT32 Start;

	//
	//   If no 'ThreadId' assume the current thread.
	//
	if ( ThreadId == NoThread )
		{ ThreadId = GetThreadId(); }

	//
	//   Claim a spinlock so we can update the 
	//   thread table.
	//
	Spinlock.ClaimLock();

	//
	//   Search for the thread info to delete
	//   in the table.
	//
	if ( (Start = FindThread( ThreadId )) != NoThread )
		{
		REGISTER SBIT32 Count;

		//
		//   Close the handle to the thread and
		//   update the table size.
		//
		CloseHandle( Threads[ Start ].Handle );

		ThreadsUsed --;

		//
		//   Copy down the remaining thread info.
		//
		for ( Count=Start;Count < ThreadsUsed;Count ++ )
			{ Threads[ Count ] = Threads[ (Count+1) ]; }
		}

	//
	//   We are finished so release the lock.
	//
	Spinlock.ReleaseLock();
    }

    /********************************************************************/
    /*                                                                  */
    /*   Wait for threads.                                              */
    /*                                                                  */
    /*   Wait for all threads to finish and then return.  As this may   */
    /*   take a while an optional timeout may be supplied.              */
    /*                                                                  */
    /********************************************************************/

BOOLEAN THREAD::WaitForThreads( LONG WaitTime )
    {
	//
	//   Claim a spinlock so we can read the 
	//   thread table.
	//
	Spinlock.ClaimLock();

    while ( ThreadsUsed > 0 )
		{
		REGISTER HANDLE Handle = (Threads[0].Handle);
		REGISTER SBIT32 ThreadId = (Threads[0].ThreadId);
		REGISTER DWORD Status;

		//
		//   We are finished so release the lock.
		//
		Spinlock.ReleaseLock();

		//
		//   Wait for the first thread in the thread info 
		//   table to terminate.
		//
		if 
				( 
				(Status = WaitForSingleObject( Handle,(DWORD) WaitTime ))
					==
				WAIT_TIMEOUT
				)
			{ return False; }

		//
		//   We have woken up the thread must of terminated
		//   or the handle is bad in some way.  In any case
		//   lets delete the handle and try to sleep again
		//   if there are any more active threads.
		//
		UnregisterThread( ThreadId );

		//
		//   Claim a spinlock so we can read the 
		//   thread table.
		//
		Spinlock.ClaimLock();
		}

	//
	//   We are finished so release the lock.
	//
	Spinlock.ReleaseLock();

	return True;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory the thread class.  This call is not thread safe        */
    /*   and should only be made in a single thread environment.        */
    /*                                                                  */
    /********************************************************************/

THREAD::~THREAD( VOID )
    {
	if 
			(
			! CloseHandle( Running )
				||
			! CloseHandle( Started )
			)
		{ Failure( "Event handles in destructor for THREAD" ); }
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\library\thread.hpp ===
#ifndef _THREAD_HPP_
#define _THREAD_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Environment.hpp"
#include "Spinlock.hpp"
#include "Vector.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants exported from the class.                             */
    /*                                                                  */
    /*   The thread constants indicate various thread status            */
    /*   information.                                                   */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 NoThread				  = -1;

    /********************************************************************/
    /*                                                                  */
    /*   Data structures exported from the class.                       */
    /*                                                                  */
    /*   A thread started by this class should conform to the type      */
    /*   specification given here.                                      */
    /*                                                                  */
    /********************************************************************/

typedef VOID (*NEW_THREAD)( VOID *Parameter );

    /********************************************************************/
    /*                                                                  */
    /*   Thread synchronization.                                        */
    /*                                                                  */
    /*   This class privides a method for synchronizing a number        */
    /*   of worker threads with a master thread.  Each time the         */
    /*   master thread calls 'StartThread()' a new thread is created.   */
    /*   When a thread calls 'EndThread()' the thread is terminated.    */
    /*   At any point the master thread can enquire about the number    */
    /*   of active threads or wait for them to complete.                */
    /*                                                                  */
    /********************************************************************/

class THREAD : private ENVIRONMENT
    {
		//
		//   Private type definitions.
		//
		typedef struct
			{
			HANDLE					  Handle;
			SBIT32					  ThreadId;
			}
		THREAD_INFO;

        //
        //   Private data.
        //
        BOOLEAN                       Affinity;
        VOLATILE SBIT16               Cpu;
        BOOLEAN                       Priority;
        HANDLE                        Running;
        LONG                          Stack;
        HANDLE                        Started;

        SBIT32						  MaxThreads;
        SBIT32						  ThreadsUsed;
        VECTOR<THREAD_INFO>			  Threads;

		SPINLOCK					  Spinlock;

    public:
        //
        //   Public functions.
        //
        THREAD( VOID );

        VOID EndThread( VOID );

		VOID RegisterThread( VOID );

        VOID SetThreadStackSize( LONG Stack = 0 );

        BOOLEAN StartThread
			( 
			NEW_THREAD                Function, 
			VOID                      *Parameter = NULL, 
			BOOLEAN                   Wait = True 
			);

		VOID UnregisterThread( SBIT32 ThreadId = NoThread );

        BOOLEAN WaitForThreads( LONG WaitTime = INFINITE );

        ~THREAD( VOID );

		//
		//   Public inline functions.
		//
        VOID SetThreadAffinity( BOOLEAN NewAffinity = True )
			{ Affinity = NewAffinity; }

        VOID SetThreadPriority( BOOLEAN NewPriority = True )
			{ Priority = NewPriority; }

	private:
		//
		//   Private functions.
		//
		SBIT32 FindThread( SBIT32 ThreadId );

        //
        //   Disabled operations.
        //
        THREAD( CONST THREAD & Copy );

        VOID operator=( CONST THREAD & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\library\vector.hpp ===
#ifndef _VECTOR_HPP_
#define _VECTOR_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "New.hpp"
#ifdef DEBUGGING

    /********************************************************************/
    /*                                                                  */
    /*   Constants exported from the class.                             */
    /*                                                                  */
    /*   The constants specified here control various aspects of the    */
    /*   vector classes debugging operations.                           */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 DebugDisplaySize		  = 8;
#endif

    /********************************************************************/
    /*                                                                  */
    /*   Vector creation, management and use.                           */
    /*                                                                  */
    /*   A vector is esentially an allocated array of data.  However,   */
    /*   vectors also have some special features.  A vector can be      */
    /*   aligned to any binary boundary and each element can also be    */
    /*   aligned to any binary boundary.  This is very helpful in       */
    /*   SMP systems as increased performance can be obtained by        */
    /*   using vectors on selected data structures.                     */
    /*                                                                  */
    /********************************************************************/

template <class TYPE> class VECTOR
    {
        //
        //   Private data.
        //
        SBIT32                        Alignment;
        SBIT32                        Elements;
        SBIT32                        Size;

        CHAR                          *Allocated;
        CHAR                          *Aligned;
#ifdef DEBUGGING
		TYPE                          *Display[DebugDisplaySize];
#endif


    public:
        //
        //   Public functions.
        //
        VECTOR
            ( 
            SBIT32					  NumberOfElements, 
            SBIT32					  AlignSize, 
            SBIT32					  AlignStart
            );

       VECTOR
            ( 
            SBIT32					  One, 
            SBIT32					  NumberOfElements, 
            SBIT32					  AlignSize, 
            SBIT32					  AlignStart
            );

       VECTOR
            ( 
            SBIT32					  One, 
            SBIT32					  Two, 
            SBIT32					  NumberOfElements, 
            SBIT32					  AlignSize, 
            SBIT32					  AlignStart
            );

        VOID Resize( SBIT32 Reallocate );

        ~VECTOR( VOID );

		//
		//   Public inline functions.
		//
        INLINE TYPE & operator[]( SBIT32 Index )
			{
#ifdef DEBUGGING
			if ( (Index < 0) || (Index >= Elements) )
				{ Failure( "Array subscript in VECTOR[]" ); }

#endif
			return (*((TYPE*) & Aligned[ (Index * Size) ]));
			}

        INLINE TYPE *operator&( VOID )
			{ return ((TYPE*) & Aligned[0]); }

		SBIT32 SizeOfVector( VOID ) 
			{ return Elements; }

	private:
		//
		//   Private functions.
		//
        VOID AllocateAndAlignVector
            ( 
            SBIT32                        NumberOfElements, 
            SBIT32                        AlignSize, 
            SBIT32                        AlignStart
            );

		TYPE & ComputeAddressWithMultiply( SBIT32 Index );

		TYPE & ComputeAddressWithShift( SBIT32 Index );

        //
        //   Disabled operations.
        //
        VECTOR( CONST VECTOR & Copy );

        VOID operator=( CONST VECTOR & Copy );
    };

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Ceate a memory allocation and initialize it.  This call is     */
    /*   not thread safe and should only be made in a single thread     */
    /*   environment.                                                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE> VECTOR<TYPE>::VECTOR
        ( 
        SBIT32                        NumberOfElements, 
        SBIT32                        AlignSize, 
        SBIT32                        AlignStart 
        )
    {
	REGISTER SBIT32 Count;

	//
	//   Allocate the storage.
	//
	AllocateAndAlignVector( NumberOfElements,AlignSize,AlignStart );

	//
	//   Call the constructors.
	//
	for ( Count = 0;Count < NumberOfElements;Count ++ )
		{ (VOID) PLACEMENT_NEW( & Aligned[ (Count * Size) ], TYPE ); }
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Ceate a memory allocation and initialize it.  This call is     */
    /*   not thread safe and should only be made in a single thread     */
    /*   environment.                                                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE> VECTOR<TYPE>::VECTOR
        ( 
        SBIT32                        One,
        SBIT32                        NumberOfElements, 
        SBIT32                        AlignSize,
        SBIT32                        AlignStart
        )
    {
	REGISTER SBIT32 Count;

	//
	//   Allocate the storage.
	//
	AllocateAndAlignVector( NumberOfElements,AlignSize,AlignStart );

	//
	//   Call the constructors.
	//
	for ( Count = 0;Count < NumberOfElements;Count ++ )
		{ (VOID) PLACEMENT_NEW( & Aligned[ (Count * Size) ], TYPE( One ) ); }
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Ceate a memory allocation and initialize it.  This call is     */
    /*   not thread safe and should only be made in a single thread     */
    /*   environment.                                                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE> VECTOR<TYPE>::VECTOR
        ( 
        SBIT32                        One, 
        SBIT32                        Two, 
        SBIT32                        NumberOfElements, 
        SBIT32                        AlignSize, 
        SBIT32                        AlignStart 
        )
    {
	REGISTER SBIT32 Count;

	//
	//   Allocate the storage.
	//
	AllocateAndAlignVector( NumberOfElements,AlignSize,AlignStart );

	//
	//   Call the constructors.
	//
	for ( Count = 0;Count < NumberOfElements;Count ++ )
		{ (VOID) PLACEMENT_NEW( & Aligned[ (Count * Size) ], TYPE( One,Two ) ); }
    }

    /********************************************************************/
    /*                                                                  */
    /*   Allocate and align a vector.                                   */
    /*                                                                  */
    /*   We need to allocate some memory and align it as requested      */
    /*   by the user.                                                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE> VOID VECTOR<TYPE>::AllocateAndAlignVector
        ( 
        SBIT32                        NumberOfElements, 
        SBIT32                        AlignSize, 
        SBIT32                        AlignStart 
        )
    {
    if ( NumberOfElements > 0 )
        {
#ifdef DEBUGGING
		REGISTER SBIT32 Count;

#endif
        //
        //   We need to remember the initial alignment and count of
		//   elements for later.
        //   
        Alignment = AlignStart;
        Elements = NumberOfElements;

        //
        //   Calculate the new element size using the requested alignment
		//   value.
        //
		Size = (AlignSize - (sizeof(TYPE) % AlignSize));
		Size = (Size == AlignSize) ? 0 : Size;
		Size += sizeof(TYPE);

        //
        //   Allocate memory and call constructor for each element.
        //   Calculate the start address for requested alignment.
        //
        Allocated = new CHAR [ (AlignStart + (NumberOfElements * Size)) ];

		Aligned = (CHAR*) (AlignStart - (((LONG) Allocated) % AlignStart));
		Aligned = (((SBIT32) Aligned) == AlignStart) ? 0 : Aligned;
		Aligned += (LONG) Allocated;
#ifdef DEBUGGING

		//
		//   When we are in debug mode calculate the addresses
		//   of the first few elements of the vector.
		//
		for 
				( 
				Count = 0;
				(Count < NumberOfElements) && (Count < DebugDisplaySize);
				Count ++ 
				)
			{ Display[ Count ] = (TYPE*) & Aligned[ (Count * Size) ]; }
#endif
        }
    else
        { Failure( "Allocation size in AllocateAndAlignVector" ); }
    }

    /********************************************************************/
    /*                                                                  */
    /*   Resize a memory allocation.                                    */
    /*                                                                  */
    /*   Resize a memory allocation and initialize the resized area.    */
    /*   This call is not thread safe and should only be made in a      */
    /*   single thread environment.                                     */
    /*                                                                  */
    /********************************************************************/

template <class TYPE> VOID VECTOR<TYPE>::Resize( SBIT32 Reallocate )
    {
    if ( Reallocate > 0 )
        {
		REGISTER SBIT32 Count;
		REGISTER CHAR *NewAllocated = new CHAR [ (Alignment + (Reallocate * Size)) ];
		REGISTER CHAR *NewAligned = ((CHAR*) (((LONG) NewAllocated) % Alignment));
		REGISTER SBIT32 Minimum = (Elements < Reallocate) ? Elements : Reallocate;

		//
		//   Calculate the new aligned address
		//.
		NewAligned = (CHAR*) (Alignment - ((LONG) NewAligned));
		NewAligned = (((SBIT32) NewAligned) == Alignment) ? 0 : NewAligned;
		NewAligned += (LONG) NewAllocated;

		//
		//   Copy each existing element into the new allocation.
		//
		for ( Count = 0;Count < Minimum;Count ++ )
			{ 
			REGISTER SBIT32 Offset = (Count * Size);

			(*((TYPE*) & NewAligned[ Offset ])) = 
				(*((TYPE*) & Aligned[ Offset ])); 
			}

		//
		//   Call the constructor for each new element.
		//
		for ( Count = Elements;Count < Reallocate;Count ++ )
			{ (VOID) PLACEMENT_NEW( & NewAligned[ (Count * Size) ], TYPE ); }

		//
		//   Call the destructor for each original original element.
		//
		for ( Count = (Elements - 1);Count >= 0;Count -- )
			{ PLACEMENT_DELETE( & Aligned[ (Count * Size) ], TYPE ); }

		//
		//   Delete the original allocation.
		//
		delete [] Allocated;
#ifdef DEBUGGING

		//
		//   When we are in debug mode calculate the addresses
		//   of the first few elements of the vector.
		//
		for 
				( 
				Count = 0;
				(Count < Reallocate) && (Count < DebugDisplaySize);
				Count ++ 
				)
			{ Display[ Count ] = (TYPE*) & NewAligned[ (Count * Size) ]; }
#endif
 
        //
        //   Finally, lets update the information about the new
		//   amended allocation.
        //   
        this -> Elements = Reallocate;
        this -> Allocated = NewAllocated;
        this -> Aligned = NewAligned;
        }
    else
        { Failure( "Rellocation size in Resize" ); }
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory a vector.  This call is not thread safe and should     */
    /*   only be made in a single thread environment.                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE> VECTOR<TYPE>::~VECTOR( VOID )
    {
	REGISTER SBIT32 Count;

	//
	//   Call the destructors.
	//
	for ( Count = (Elements - 1);Count >= 0;Count -- )
		{ PLACEMENT_DELETE( & Aligned[ (Count * Size) ], TYPE ); }

	//
	//   Delete the storage.
	//
    delete [] Allocated;
    }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\library\ticket.hpp ===
#ifndef _TICKET_HPP_
#define _TICKET_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Lock.hpp"
#include "Vector.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants exported from the class.                             */
    /*                                                                  */
    /*   The ticket constants specify the initial size of the           */
    /*   ticket array.                                                  */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 TicketSize			  = 128;

    /********************************************************************/
    /*                                                                  */
    /*   Ticketing to maintain ordering.                                */
    /*                                                                  */
    /*   This class provides general purpose event ordering so          */
    /*   that events can arrive in any order but processed in           */
    /*   sequential order with a minimal amount of fuss.                */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK=NO_LOCK> class TICKET : public LOCK
    {
		//
		//   Private data structure.
		//
		typedef struct
			{
			BOOLEAN					  Available;
			TYPE					  Data;
			}
		STUB;

        //
        //   Private data.
        //
        SBIT32						  MaxSize;

        SBIT32						  Back;
        SBIT32						  Front;

        SBIT32						  Base;
        SBIT32						  Stride;

        VECTOR<STUB>				  Ticket;

    public:
        //
        //   Public functions.
        //
        TICKET
			( 
			SBIT32					  Start = 0,
			SBIT32					  NewMaxSize = TicketSize,
			SBIT32					  NewStride = 1  
			);

		BOOLEAN CollectTicket( TYPE *Data,SBIT32 *Ticket );

		SBIT32 NumberOfTickets( VOID );

		SBIT32 NewTicket( VOID );

		BOOLEAN PunchTicket( CONST TYPE & Data,SBIT32 Ticket );

        ~TICKET( VOID );

		//
		//   Public inline functions.
		//
		SBIT32 LowestOutstandingTicket( VOID )
			{ return Base; }

	private:

        //
        //   Disabled operations.
        //
        TICKET( CONST TICKET & Copy );

        VOID operator=( CONST TICKET & Copy );
    };

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create a new ticket queue and prepare it for use.  This call   */
    /*   is not thread safe and should only be made in a single thread  */
    /*   environment.                                                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> TICKET<TYPE,LOCK>::TICKET
		( 
		SBIT32						  Start,
		SBIT32						  NewMaxSize,
		SBIT32						  NewStride
		) : 
		//
		//   Call the constructors for the contained classes.
		//
		Queue( NewMaxSize,1,CacheLineSize )
    {
#ifdef DEBUGGING
    if ( NewMaxSize > 0 )
        {
#endif
		//
		//   Setup the control information.
		//
        MaxSize = NewMaxSize;

		//
		//   Setup the queue so it is empty.
		//
        Back = 0;
        Front = 0;

		//
		//   Set the initial ticket number.
		//
		Base = Start;
		Stride = NewStride;
#ifdef DEBUGGING
        }
    else
        { Failure( "MaxSize in constructor for TICKET" ); }
#endif
    }

    /********************************************************************/
    /*                                                                  */
    /*   Issue a new ticket.                                            */
    /*                                                                  */
    /*   We issue a new ticket and allocate a place in the line.  We    */
    /*   also we reserve space in the ticket queue.                     */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> SBIT32 TICKET<TYPE,LOCK>::NewTicket( VOID )
    {
	REGISTER SBIT32 Result;

	//
	//   Claim an exclisive lock (if enabled).
	//
    ClaimExclusiveLock();

    //
    //   Add element to the queue.  If necessary wrap round 
    //   to the front of the array.
    //
    Ticket[ Back ++ ].Available = False;

     if ( Back >= MaxSize )
        { Back = 0; }

	//
	//   Compute the ticket number.
	//
	Result = (Base + (NumberOfTickets() * Stride));

    //
    //   Verify that the queue is not full.  If it is full then 
    //   double its size and copy wrapped data to the correct
    //   position in the new array.
    //
    if ( Front == Back )
		{
		REGISTER SBIT32 Count;
		REGISTER SBIT32 NewSize = (MaxSize * ExpandStore);

		//
		//   Expand the queue (it will be at least doubled).
		//
		Ticket.Resize( NewSize );

		//
		//   Copy the tail end of the queue to the correct
		//   place in the expanded queue.
		//
		for ( Count = 0;Count < Back;Count ++ )
			{ Ticket[ (MaxSize + Count) ] = Ticket[ Count ]; }

		//
		//   Update the control information.
		//
		Back += MaxSize;
		MaxSize = NewSize;
		}

	//
	//   Release any lock we claimed earlier.
	//
    ReleaseExclusiveLock();

	return Result;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Punch a ticket and store any associated data.                  */
    /*                                                                  */
    /*   We punch a ticket so it can be collected and store any         */
    /*   related data.                                                  */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> BOOLEAN TICKET<TYPE,LOCK>::PunchTicket
		( 
		CONST TYPE					  & Data,
		SBIT32						  Ticket
		)
    {
    REGISTER BOOLEAN Result;
	REGISTER SBIT32 TicketOffset;

	//
	//   Claim an exclusive lock (if enabled).
	//
    ClaimExclusiveLock();

	//
	//   Compute the offset in the ticket array.
	//
	TicketOffset = ((Ticket - Base) / Stride);

	//
	//   Ensure the ticket refers to and active ticket
	//   that has not already been recycled.
	//
	if ( (TicketOffset >= 0) && (TicketOffset < NumberOfTickets()) )
		{
		REGISTER STUB *Stub = & Ticket[ TicketOffset ];

		//
		//   Ensure the ticket has not already been
		//   punched.
		//
		if ( ! Stub -> Available )
			{
			Stub -> Available = True;
			Stub -> Data = Data;

			Result = True;
			}
		else
			{ Result = False; }
        }
    else
        { Result = False; }

	//
	//   Release any lock we claimed earlier.
	//
    ReleaseExclusiveLock();

    return Result;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Collect the lowest numbered ticket.                            */
    /*                                                                  */
    /*   We try to collect the lowest numbered ticket that has been     */
    /*   issued.  If it is has been punched and is available we         */
    /*   recycle it after returning any associated data to the caller.  */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> BOOLEAN TICKET<TYPE,LOCK>::CollectTicket
		( 
		TYPE						  *Data,
		SBIT32						  *Ticket
		)
    {
    REGISTER BOOLEAN Result;

	//
	//   Claim an exclusive lock (if enabled).
	//
    ClaimExclusiveLock();

	//
	//   We make sure the ticket queue is not empty.
	//
    if ( Front != Back )
        {
		REGISTER STUB *Stub = & Ticket[ Front ];

		//
		//   We can collect the first ticket in the
		//   ticket queue if it has been punched.
		//
		if ( Stub -> Available )
			{
			//
			//   We have an ticket ready so return it to 
			//   the caller.  If we walk off the end of  
			//   the ticket queue then wrap to the other
			//   end.
			//
			(*Data) = Stub -> Data;
			(*Ticket) = (Base += Stride);

			if ( (++ Front) >= MaxSize )
				{ Front = 0; }

			Result = True;
			}
		else
			{ Result = False; }
        }
    else
        { Result = False; }

	//
	//   Release any lock we claimed earlier.
	//
    ReleaseExclusiveLock();

    return Result;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Calculate the size of the reorder queue.                       */
    /*                                                                  */
    /*   Calculate the size of the queue and return it to the caller.   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> SBIT32 TICKET<TYPE,LOCK>::NumberOfTickets( VOID )
    {
    REGISTER SBIT32 Size;

	//
	//   Compute the size of the reorder queue.
	//
	Size = (Back - Front);

	//
	//   If the queue has wrapped then adjust as needed.
	//
	if ( Size < 0 )
		{ Size += MaxSize; }

    return Size;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory a queue.  This call is not thread safe and should      */
    /*   only be made in a single thread environment.                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> TICKET<TYPE,LOCK>::~TICKET( VOID )
    { /* void */ }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\urlcache\cachapiw.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    cachapiw.cxx

Abstract:

    contains the UNICODE version of cache mangemant APIs.

Author:

    Madan Appiah (madana)  12-Dec-1994

Environment:

    User Mode - Win32

Revision History:

    Ahsan Kabir (akabir)   Dec-1997
--*/

#include <wininetp.h>
#include <cache.hxx>
#include <w95wraps.h>

#define NUMBER_MEMBERS 4


const BYTE bOffsetTable[NUMBER_MEMBERS] = 
    {
        (BYTE)&(((LPINTERNET_CACHE_ENTRY_INFOW)NULL)->lpszSourceUrlName),
        (BYTE)&(((LPINTERNET_CACHE_ENTRY_INFOW)NULL)->lpszLocalFileName),
        (BYTE)&(((LPINTERNET_CACHE_ENTRY_INFOW)NULL)->lpHeaderInfo),
        (BYTE)&(((LPINTERNET_CACHE_ENTRY_INFOW)NULL)->lpszFileExtension)
    };
    
DWORD
TransformA2W(
    IN LPINTERNET_CACHE_ENTRY_INFOA pCEIA,
    IN DWORD cbCEIA,
    OUT LPINTERNET_CACHE_ENTRY_INFOW pCEIW,
    OUT LPDWORD pcbCEIW
    )
{
    DWORD cbSize = sizeof(INTERNET_CACHE_ENTRY_INFOW);
    DWORD cc;

    if (!pCEIW || (*pcbCEIW<sizeof(INTERNET_CACHE_ENTRY_INFOW)))
    {
        *pcbCEIW = 0;
        cc = 0;
    }
    else
    {
        //
        // copy fixed portion.
        //
        memcpy((PBYTE)pCEIW, (PBYTE)pCEIA, sizeof(INTERNET_CACHE_ENTRY_INFOW) );
        pCEIW->dwStructSize = sizeof(INTERNET_CACHE_ENTRY_INFOW);
        cc = (*pcbCEIW - sizeof(INTERNET_CACHE_ENTRY_INFOW))/sizeof(WCHAR);
    }

    // Destination for strings
    PWSTR pBuffer = (pCEIW ? (PWSTR)(pCEIW + 1) : NULL);
    // Convert strings
    for (int i=0; i < NUMBER_MEMBERS; i++)
    {
        PSTR *pBufferA = (PSTR*)((PBYTE)pCEIA + bOffsetTable[i]);

        if (*pBufferA)
        {
            DWORD dwTmp = MultiByteToWideChar(CP_ACP, 0,  *pBufferA, -1, NULL, 0);
            if ((dwTmp<=cc) && pCEIW)
            {
                INET_ASSERT(pBuffer);

                PWSTR *pBufferW = (PWSTR*)((PBYTE)pCEIW + bOffsetTable[i]);
                *pBufferW = pBuffer;
                MultiByteToWideChar(CP_ACP, 0,  *pBufferA, -1, *pBufferW, dwTmp);
                pBuffer += dwTmp;
                cc -= dwTmp;
            }
            cbSize += dwTmp*sizeof(WCHAR);
        }
    }

    DWORD dwErr = (*pcbCEIW>=cbSize) ? ERROR_SUCCESS : ERROR_INSUFFICIENT_BUFFER;
    *pcbCEIW = cbSize; // Tell how much space used/needed.
    return dwErr;
}


URLCACHEAPI
BOOL
WINAPI
CreateUrlCacheEntryW(
    IN LPCWSTR lpszUrlName,
    IN DWORD dwExpectedFileSize,
    IN LPCWSTR lpszFileExtension,
    OUT LPWSTR lpszFileName,
    IN DWORD dwReserved
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "CreateUrlCacheEntryW", "%wq, %wq, %d, %wq, %#x",
        lpszUrlName, lpszFileExtension, dwExpectedFileSize, lpszFileName, dwReserved));

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE, fStrNotSafe = FALSE;
    MEMORYPACKET mpUrlName, mpFileExtension, mpFileName;

    if (lpszUrlName)
    {
        ALLOC_MB(lpszUrlName,0,mpUrlName);
        if (!mpUrlName.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI_CHECKED(lpszUrlName,mpUrlName, &fStrNotSafe);
        if (fStrNotSafe)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
    }
    if (lpszFileExtension)
    {
        ALLOC_MB(lpszFileExtension,0,mpFileExtension);
        if (!mpFileExtension.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI_CHECKED(lpszFileExtension,mpFileExtension, &fStrNotSafe);
        if (fStrNotSafe)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
    }
    ALLOC_MB(NULL, MAX_PATH, mpFileName);
    if (!mpFileName.psStr)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    fResult = CreateUrlCacheEntryA(
        mpUrlName.psStr,
        dwExpectedFileSize,
        mpFileExtension.psStr,
        mpFileName.psStr,
        dwReserved);
    if (fResult)
    {
        MultiByteToWideChar(CP_ACP, 0, mpFileName.psStr, -1, lpszFileName, MAX_PATH);
    }

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}

URLCACHEAPI
BOOL
WINAPI
CommitUrlCacheEntryW(
    IN LPCWSTR lpszUrlName,
    IN LPCWSTR lpszLocalFileName,
    IN FILETIME ExpireTime,
    IN FILETIME LastModifiedTime,
    IN DWORD CacheEntryType,
    IN LPWSTR lpszHeaderInfo,
    IN DWORD dwHeaders,
    IN LPCWSTR lpszFileExtension,
    IN LPCWSTR lpszOriginalUrl
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "CommitUrlCacheEntryW",
        "%wq, %wq, <expires>, <last-mod>, %d, %wq, %d, %wq, %wq",
        lpszUrlName,
        lpszLocalFileName,
        CacheEntryType,
        lpszHeaderInfo,
        dwHeaders,
        lpszFileExtension,
        lpszOriginalUrl
    ));

    BOOL fResult = FALSE;
    BOOL fStrNotSafe = FALSE;
    DWORD dwErr = ERROR_SUCCESS;
    MEMORYPACKET mpUrlName, mpLocalFileName, mpFileExtension, mpHeaders, mpOriginalUrl;

    if( IsBadUrlW( lpszUrlName ) ||
        ( lpszLocalFileName ? IsBadStringPtrW( lpszLocalFileName, MAX_PATH ) : FALSE ) ) 
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    ALLOC_MB(lpszUrlName,0,mpUrlName);
    if (!mpUrlName.psStr)
    {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
    }
    UNICODE_TO_ANSI_CHECKED(lpszUrlName,mpUrlName, &fStrNotSafe);
    if (fStrNotSafe)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    if (lpszLocalFileName)
    {
        ALLOC_MB(lpszLocalFileName,0,mpLocalFileName);
        if (!mpLocalFileName.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI_CHECKED(lpszLocalFileName,mpLocalFileName, &fStrNotSafe);
        if (fStrNotSafe)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
    }
    
    if (lpszFileExtension)
    {
        ALLOC_MB(lpszFileExtension,0,mpFileExtension);
        if (!mpFileExtension.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI_CHECKED(lpszFileExtension,mpFileExtension, &fStrNotSafe);
        if (fStrNotSafe)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
    }
    if (lpszHeaderInfo)
    {
        ALLOC_MB(lpszHeaderInfo,0,mpHeaders);
        if (!mpHeaders.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI_CHECKED(lpszHeaderInfo,mpHeaders, &fStrNotSafe);
        if (fStrNotSafe)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }

    }
    if (lpszOriginalUrl)
    {
        ALLOC_MB(lpszOriginalUrl,0,mpOriginalUrl);
        if (!mpOriginalUrl.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI_CHECKED(lpszOriginalUrl,mpOriginalUrl, &fStrNotSafe);
        if (fStrNotSafe)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
    }

    fResult = CommitUrlCacheEntryA(
            mpUrlName.psStr,
            mpLocalFileName.psStr,
            ExpireTime,
            LastModifiedTime,
            CacheEntryType,
            (LPBYTE)mpHeaders.psStr,
            mpHeaders.dwSize,
            mpFileExtension.psStr,
            mpOriginalUrl.psStr);

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}


BOOL
RetrieveUrlCacheEntryWCore(
    IN LPCWSTR  lpszUrlName,
    OUT LPINTERNET_CACHE_ENTRY_INFOW lpCacheEntryInfo,
    IN OUT LPDWORD lpcbCacheEntryInfo,
    IN DWORD dwReserved,
    IN DWORD dwLookupFlags,
    IN DWORD dwRetrievalFlags)
{
    DWORD dwErr = ERROR_SUCCESS;
    BOOL fStrNotSafe = FALSE;
    MEMORYPACKET mpUrlName;
    LPINTERNET_CACHE_ENTRY_INFOA pCEIA = NULL;
    DWORD dwCEI = 0;
    
    if (!InitGlobals())
    {
        dwErr = ERROR_WINHTTP_INTERNAL_ERROR;
        goto cleanup;
    }
    if (!(lpszUrlName && lpcbCacheEntryInfo))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    ALLOC_MB(lpszUrlName, 0, mpUrlName);
    if (!mpUrlName.psStr)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    UNICODE_TO_ANSI_CHECKED(lpszUrlName, mpUrlName, &fStrNotSafe);
    if (fStrNotSafe)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    
    dwErr = GlobalUrlContainers->RetrieveUrl(
                        mpUrlName.psStr,
                        &pCEIA,
                        &dwCEI,
                        dwLookupFlags,
                        dwRetrievalFlags | RETRIEVE_WITH_ALLOCATION);

    if (dwErr==ERROR_SUCCESS)
    {
        dwErr = TransformA2W(
            pCEIA,
            dwCEI,
            lpCacheEntryInfo,
            lpcbCacheEntryInfo);

        if (dwErr!=ERROR_SUCCESS)
        {
            UnlockUrlCacheEntryFileW(lpszUrlName, 0);
        }
    }

cleanup:
    if (pCEIA)
    {
        FREE_MEMORY(pCEIA);
    }
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    return (dwErr == ERROR_SUCCESS);
}


URLCACHEAPI
BOOL
WINAPI
RetrieveUrlCacheEntryFileW(
    IN LPCWSTR  lpszUrlName,
    OUT LPINTERNET_CACHE_ENTRY_INFOW lpCacheEntryInfo,
    IN OUT LPDWORD lpcbCacheEntryInfo,
    IN DWORD dwReserved
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "RetrieveUrlCacheEntryFileW","%wq, %#x, %#x, %#x",
        lpszUrlName, lpCacheEntryInfo, lpcbCacheEntryInfo, dwReserved));

    BOOL fResult = RetrieveUrlCacheEntryWCore(
                        lpszUrlName,
                        lpCacheEntryInfo,
                        lpcbCacheEntryInfo,
                        dwReserved,
                        LOOKUP_URL_CREATE,
                        RETRIEVE_WITH_CHECKS);

    DEBUG_LEAVE_API(fResult);
    return fResult;
}

URLCACHEAPI
HANDLE
WINAPI
RetrieveUrlCacheEntryStreamW(
    IN LPCWSTR  lpszUrlName,
    OUT LPCACHE_ENTRY_INFOW lpCacheEntryInfo,
    IN OUT LPDWORD lpcbCacheEntryInfo,
    IN BOOL fRandomRead,
    IN DWORD dwReserved
    )
{
    ENTER_CACHE_API ((DBG_API, Handle, "RetrieveUrlCacheEntryStreamW",
        "%wq, %#x, %#x, %d, %#x",
        lpszUrlName,
        lpCacheEntryInfo,
        lpcbCacheEntryInfo,
        fRandomRead,
        dwReserved
    ));

    BOOL fLocked = FALSE;
    HANDLE hInternet = NULL;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD dwErr = ERROR_SUCCESS, dwFileSize;
    CACHE_STREAM_CONTEXT_HANDLE* pStream;

    if (!RetrieveUrlCacheEntryWCore(
                        lpszUrlName,
                        lpCacheEntryInfo,
                        lpcbCacheEntryInfo,
                        dwReserved,
                        LOOKUP_URL_NOCREATE,
                        RETRIEVE_WITHOUT_CHECKS))
    {
        goto cleanup;
    }

    fLocked = TRUE;        

    // Allocate a stream handle.
    LOCK_CACHE();
    hInternet = HandleMgr.Alloc (sizeof(CACHE_STREAM_CONTEXT_HANDLE));
    if (hInternet)
    {        
        pStream = (CACHE_STREAM_CONTEXT_HANDLE*) HandleMgr.Map (hInternet);
        INET_ASSERT (pStream);
    }
    UNLOCK_CACHE();
    if (!hInternet)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    // Open the file.
    // Does CreateFileW exist on Win9x?

    hFile = CreateFileW
    (
        lpCacheEntryInfo->lpszLocalFileName,
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL |
          (fRandomRead ? FILE_FLAG_RANDOM_ACCESS : FILE_FLAG_SEQUENTIAL_SCAN),
                // improves file read (cache) performance?
        NULL
    );
    if( hFile == INVALID_HANDLE_VALUE )
    {
        dwErr = GetLastError();
        goto cleanup;
    }

    dwFileSize = GetFileSize(hFile, NULL);
    if (dwFileSize != lpCacheEntryInfo->dwSizeLow) 
    {
        dwErr = (dwFileSize==0xFFFFFFFF) ? GetLastError() : ERROR_INVALID_DATA;
        goto cleanup;
    }

    pStream->FileHandle = hFile;

    // Copy URL name storage.
    {
        MEMORYPACKET mpUrl;
        ALLOC_MB(lpszUrlName,0,mpUrl);
        if (!mpUrl.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(lpszUrlName,mpUrl);
        
        pStream->SourceUrlName = NewString(mpUrl.psStr);
        if( !pStream->SourceUrlName)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
    }

cleanup:
    if (dwErr!=ERROR_SUCCESS)
    {
        if (hInternet)
        {
            HandleMgr.Free(hInternet);
            hInternet = NULL;
        }
        if (hFile)
            CloseHandle (hFile);

        if (fLocked)
        {
            UnlockUrlCacheEntryFileW(lpszUrlName, 0);
        }
        SetLastError (dwErr);
        DEBUG_ERROR(API, dwErr);
    }

    DEBUG_LEAVE_API(hInternet);
    return hInternet;
}


BOOL
GetUrlCacheEntryWCore(
        IN LPCWSTR lpszUrl,
        OUT LPINTERNET_CACHE_ENTRY_INFOW lpCacheEntryInfo,
        IN OUT LPDWORD lpcbCacheEntryInfo,
        DWORD dwFlags,
        DWORD dwLookupFlags,
        BOOL fConvertHeaders)
{
    BOOL fResult = FALSE;
    DWORD dwErr = ERROR_SUCCESS;
    BOOL fStrNotSafe = FALSE;
    MEMORYPACKET mpUrlName;
    LPINTERNET_CACHE_ENTRY_INFOA pCEIA = NULL;
    DWORD cbCEIA;

    if (!InitGlobals())
    {
        dwErr = ERROR_WINHTTP_INTERNAL_ERROR;
        goto cleanup;
    }

    if (IsBadUrlW(lpszUrl))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    ALLOC_MB(lpszUrl,0,mpUrlName);
    if (!mpUrlName.psStr)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    UNICODE_TO_ANSI_CHECKED(lpszUrl,mpUrlName, &fStrNotSafe);
    if (fStrNotSafe)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    if (lpcbCacheEntryInfo)
    {
        dwErr = GlobalUrlContainers->GetUrlInfo(
            mpUrlName.psStr,
            &pCEIA,
            &cbCEIA,
            dwFlags,
            dwLookupFlags,
            RETRIEVE_WITH_ALLOCATION);
            
        // convert from ansi to unicode. 
        if (dwErr==ERROR_SUCCESS)
        {
            dwErr = TransformA2W(pCEIA, cbCEIA, lpCacheEntryInfo, lpcbCacheEntryInfo);
            if (dwErr==ERROR_SUCCESS)
            {
                fResult = TRUE;
            }
        }
    }
    else
    {
        fResult = GetUrlCacheEntryInfoExA(
                mpUrlName.psStr, 
                NULL,
                NULL,
                NULL,
                NULL,
                NULL,
                dwFlags);
    }

cleanup: 
    if (pCEIA)
    {
        FREE_MEMORY(pCEIA);
    }
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    return fResult;
}


URLCACHEAPI
BOOL
WINAPI
GetUrlCacheEntryInfoW(
    IN LPCWSTR lpszUrlName,
    OUT LPINTERNET_CACHE_ENTRY_INFOW lpCacheEntryInfo,
    IN OUT LPDWORD lpcbCacheEntryInfo
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "GetUrlCacheEntryInfoW", "%wq, %#x, %#x",
        lpszUrlName, lpCacheEntryInfo, lpcbCacheEntryInfo));

    BOOL fResult = GetUrlCacheEntryWCore(
                            lpszUrlName,
                            lpCacheEntryInfo,
                            lpcbCacheEntryInfo,
                            0,
                            LOOKUP_URL_NOCREATE,
                            TRUE);

    DEBUG_LEAVE_API(fResult);
    return fResult;
}

BOOLAPI
GetUrlCacheEntryInfoExW(
        IN LPCWSTR lpszUrl,
        OUT LPINTERNET_CACHE_ENTRY_INFOW lpCacheEntryInfo,
        IN OUT LPDWORD lpcbCacheEntryInfo,
        OUT LPWSTR lpszRedirectUrl,
        IN OUT LPDWORD lpcbRedirectUrl,
        LPVOID lpReserved,
        DWORD dwFlags
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "GetUrlCacheEntryInfoExW",
        "%wq, %#x, %#x, %wq, %#x, %#x, %#x", 
        lpszUrl, lpCacheEntryInfo, lpcbCacheEntryInfo, lpszRedirectUrl, lpcbRedirectUrl, lpReserved, dwFlags));

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;
    
    if (lpszRedirectUrl
        || lpcbRedirectUrl 
        || lpReserved
       )
    {
        INET_ASSERT (FALSE);
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    
    fResult = GetUrlCacheEntryWCore(
                            lpszUrl,
                            lpCacheEntryInfo,
                            lpcbCacheEntryInfo,
                            dwFlags,
                            LOOKUP_URL_TRANSLATE | (dwFlags & INTERNET_CACHE_FLAG_ALLOW_COLLISIONS),
                            TRUE);

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}


URLCACHEAPI
BOOL
WINAPI
SetUrlCacheEntryInfoW(
    IN LPCWSTR lpszUrlName,
    IN LPCACHE_ENTRY_INFOW lpCacheEntryInfo,
    IN DWORD dwFieldControl
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "SetUrlCacheEntryInfoW", "%wq, %#x, %d",
        lpszUrlName, lpCacheEntryInfo, dwFieldControl));

    BOOL fResult = FALSE;
    BOOL fStrNotSafe = FALSE;
    DWORD dwErr = ERROR_SUCCESS;
    MEMORYPACKET mpUrlName;
    INTERNET_CACHE_ENTRY_INFOA CacheEntryInfoA;

    if (!lpszUrlName)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    memcpy( &CacheEntryInfoA, lpCacheEntryInfo, sizeof(CacheEntryInfoA) );

    ALLOC_MB(lpszUrlName,0,mpUrlName);
    if (!mpUrlName.psStr)
    {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
    }
    UNICODE_TO_ANSI_CHECKED(lpszUrlName,mpUrlName, &fStrNotSafe);
    if (fStrNotSafe)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    fResult = SetUrlCacheEntryInfoA(
            mpUrlName.psStr,
            &CacheEntryInfoA,
            dwFieldControl );

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}


BOOL FindUrlCacheEntryWCore(
    IN OUT HANDLE     *phFind,
    IN     LPCWSTR    lpszUrlSearchPattern,
    IN     DWORD     dwFlags,
    IN     DWORD     dwFilter,
    IN     GROUPID   GroupId,
    OUT    LPINTERNET_CACHE_ENTRY_INFOW pEntryInfo,
    IN OUT LPDWORD   pcbEntryInfo,
    IN     BOOL      fConvertHeaders
    )
{
    DWORD dwErr = ERROR_SUCCESS;
    BOOL fStrNotSafe = FALSE;
    MEMORYPACKET mpSearchPattern;
    LPINTERNET_CACHE_ENTRY_INFOA pCEIA = NULL;
    DWORD cbCEIA;
    BOOL fFindFirst = *phFind==NULL;
    
    // DebugBreak();
    
    if (!InitGlobals())
    {
        dwErr = ERROR_WINHTTP_INTERNAL_ERROR;
        goto cleanup;
    }
    if (!pcbEntryInfo)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    if (lpszUrlSearchPattern)
    {
        ALLOC_MB(lpszUrlSearchPattern, 0, mpSearchPattern);
        if (!mpSearchPattern.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI_CHECKED(lpszUrlSearchPattern, mpSearchPattern, &fStrNotSafe);
        if (fStrNotSafe)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
    }

    dwErr = GlobalUrlContainers->FindNextEntry(phFind, 
                                               mpSearchPattern.psStr, 
                                               &pCEIA, 
                                               &cbCEIA,
                                               dwFilter,
                                               GroupId,
                                               dwFlags,
                                               RETRIEVE_WITH_ALLOCATION);

    // TransformA2W will convert from ansi to unicode. ERROR_SUCCESS always means that
    // the cache entry has been returned.
    if (dwErr==ERROR_SUCCESS)
    {
        dwErr = TransformA2W(pCEIA,
            cbCEIA,
            pEntryInfo,
            pcbEntryInfo);
    }

cleanup: 
    if (pCEIA)
    {
        FREE_MEMORY(pCEIA);
    }
    if (dwErr!=ERROR_SUCCESS) 
    { 
        if (fFindFirst && *phFind)
        {
            GlobalUrlContainers->FreeFindHandle(*phFind);
            *phFind = NULL;
        }
        
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    return (dwErr==ERROR_SUCCESS) ;
}


URLCACHEAPI
HANDLE
WINAPI
FindFirstUrlCacheEntryW(
    IN LPCWSTR lpszUrlSearchPattern,
    OUT LPCACHE_ENTRY_INFOW lpFirstCacheEntryInfo,
    IN OUT LPDWORD lpcbCacheEntryInfo
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "FindFirstUrlCacheEntryW",
        "%wq, %#x, %#x",
        lpszUrlSearchPattern,
        lpFirstCacheEntryInfo,
        lpcbCacheEntryInfo
    ));

    HANDLE hInternet = FindFirstUrlCacheEntryExW(
                        lpszUrlSearchPattern,
                        FIND_FLAGS_OLD_SEMANTICS,
                        URLCACHE_FIND_DEFAULT_FILTER,
                        NULL,
                        lpFirstCacheEntryInfo,
                        lpcbCacheEntryInfo,
                        NULL,
                        NULL,
                        NULL);

    DEBUG_LEAVE_API(hInternet);
    return hInternet;
}

URLCACHEAPI
BOOL
WINAPI
FindNextUrlCacheEntryW(
    IN HANDLE hEnumHandle,
    OUT LPCACHE_ENTRY_INFOW pEntryInfo,
    IN OUT LPDWORD pcbEntryInfo
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "FindNextUrlCacheEntryW",
       "%#x, %#x, %#x",
        hEnumHandle, 
        pEntryInfo,
        pcbEntryInfo
    ));

    BOOL fResult = FindNextUrlCacheEntryExW(
                    hEnumHandle,
                    pEntryInfo,
                    pcbEntryInfo,
                    NULL, 
                    NULL,
                    NULL);

    DEBUG_LEAVE_API(fResult);
    return fResult;
}


INTERNETAPI
HANDLE
WINAPI
FindFirstUrlCacheEntryExW(
    IN     LPCWSTR    lpszUrlSearchPattern,
    IN     DWORD     dwFlags,
    IN     DWORD     dwFilter,
    IN     GROUPID   GroupId,
    OUT    LPINTERNET_CACHE_ENTRY_INFOW pEntryInfo,
    IN OUT LPDWORD   pcbEntryInfo,
    OUT    LPVOID    lpGroupAttributes,     // must pass NULL
    IN OUT LPDWORD   pcbGroupAttributes,    // must pass NULL
    IN     LPVOID    lpReserved             // must pass NULL
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "FindFirstUrlCacheEntryExW",
        "%wq, %#x, %#x, %#x, %#x, %#x, %#x, %#x, %#x",
        lpszUrlSearchPattern,
        dwFlags,
        dwFilter,
        GroupId,
        pEntryInfo,
        pcbEntryInfo,
        lpGroupAttributes,
        pcbGroupAttributes,
        lpReserved
    ));

    HANDLE hInternet = NULL;

    FindUrlCacheEntryWCore(
            &hInternet,
            lpszUrlSearchPattern,
            dwFlags,
            dwFilter,
            GroupId,
            pEntryInfo,
            pcbEntryInfo,
            TRUE);

    DEBUG_LEAVE_API(hInternet);
    return hInternet;
}


BOOLAPI
FindNextUrlCacheEntryExW(
    IN     HANDLE    hEnumHandle,
    OUT    LPINTERNET_CACHE_ENTRY_INFOW pEntryInfo,
    IN OUT LPDWORD   pcbEntryInfo,
    OUT    LPVOID    lpGroupAttributes,     // must pass NULL
    IN OUT LPDWORD   pcbGroupAttributes,    // must pass NULL
    IN     LPVOID    lpReserved             // must pass NULL
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "FindNextUrlCacheEntryExW",
        "%#x, %#x, %#x, %#x, %#x, %#x",
        hEnumHandle,
        pEntryInfo,
        pcbEntryInfo,
        lpGroupAttributes,
        pcbGroupAttributes,
        lpReserved
    ));

    BOOL fResult = FALSE;
    DWORD dwErr = ERROR_SUCCESS;
    
    if (!hEnumHandle)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    fResult = FindUrlCacheEntryWCore(
                        &hEnumHandle,
                        NULL,
                        0,
                        0,
                        0,
                        pEntryInfo,
                        pcbEntryInfo,
                        TRUE);

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}

URLCACHEAPI
BOOL
WINAPI
FreeUrlCacheSpaceW(
    IN LPCWSTR lpszCachePath,
    IN DWORD dwSize,
    IN DWORD dwReserved
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "FreeUrlCacheSpaceW", 
        "<path>,%d, %#x", dwSize, dwReserved));

    BOOL fResult = FALSE;
    DWORD dwErr = ERROR_SUCCESS;
    BOOL fStrNotSafe = FALSE;

    MEMORYPACKET mpCachePath;
    if (lpszCachePath)
    {
        ALLOC_MB(lpszCachePath,0,mpCachePath);
        if (!mpCachePath.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI_CHECKED(lpszCachePath,mpCachePath, &fStrNotSafe);
        if (fStrNotSafe)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
    }
    fResult = FreeUrlCacheSpaceA(
            mpCachePath.psStr,
            dwSize,
            dwReserved );

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}


URLCACHEAPI
BOOL
WINAPI
UnlockUrlCacheEntryFileW(
    LPCWSTR lpszUrlName,
    IN DWORD dwReserved
    )
/*++

Routine Description:

    This API checks in the file that was check out as part of
    RetrieveUrlFile API.

Arguments:

    lpszUrlName : name of the URL that is being retrieved.

    dwReserved : reserved for future use.

Return Value:

    Windows Error code.

--*/
{
    ENTER_CACHE_API ((DBG_API, Bool, "UnlockUrlCacheEntryFileW",
        "%wq, %#x", lpszUrlName, dwReserved));

    BOOL fResult = FALSE;
    BOOL fStrNotSafe = FALSE;
    DWORD dwErr = ERROR_SUCCESS;
    MEMORYPACKET mpUrl;

    if (!lpszUrlName)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    ALLOC_MB(lpszUrlName,0,mpUrl);
    if (!mpUrl.psStr)
    {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
    }
    UNICODE_TO_ANSI_CHECKED(lpszUrlName,mpUrl, &fStrNotSafe);
    if (fStrNotSafe)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    fResult = UnlockUrlCacheEntryFileA(mpUrl.psStr, dwReserved);

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}

URLCACHEAPI
BOOL
WINAPI
DeleteUrlCacheEntryW(
    IN LPCWSTR lpszUrlName
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "DeleteUrlCacheEntryW",
        "%wq", lpszUrlName));

    BOOL fResult = FALSE;
    BOOL fStrNotSafe = FALSE;
    DWORD dwErr = ERROR_SUCCESS;
    MEMORYPACKET mpUrl;

    if (!lpszUrlName)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    ALLOC_MB(lpszUrlName,0,mpUrl);
    if (!mpUrl.psStr)
    {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
    }
    UNICODE_TO_ANSI_CHECKED(lpszUrlName,mpUrl, &fStrNotSafe);
    if (fStrNotSafe)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    fResult = DeleteUrlCacheEntryA(mpUrl.psStr);

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}

BOOLAPI
IsUrlCacheEntryExpiredW(
    IN      LPCWSTR      lpszUrlName,
    IN      DWORD        dwFlags,
    IN OUT  FILETIME*    pftLastModifiedTime
)
{
    ENTER_CACHE_API ((DBG_API, Bool, "UrlCacheEntryExpiredW", 
        "%wq, %#x", lpszUrlName, dwFlags));

    BOOL fResult = FALSE;
    BOOL fStrNotSafe = FALSE;
    DWORD dwErr = ERROR_SUCCESS;
    MEMORYPACKET mpUrl;

    if (!lpszUrlName)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    ALLOC_MB(lpszUrlName,0,mpUrl);
    if (!mpUrl.psStr)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    UNICODE_TO_ANSI_CHECKED(lpszUrlName,mpUrl, &fStrNotSafe);
    if (fStrNotSafe)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    fResult = IsUrlCacheEntryExpiredA(
                    mpUrl.psStr,
                    dwFlags,
                    pftLastModifiedTime);

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}

BOOL CacheGroupInfoA2W(
    IN          LPINTERNET_CACHE_GROUP_INFOA    lpAnsiGroupInfo,
    IN          DWORD                           dwAnsiGroupInfoSize,
    OUT         LPINTERNET_CACHE_GROUP_INFOW    lpUnicodeGroupInfo,
    IN OUT      LPDWORD                         lpdwUnicodeGroupInfoSize
)
{
    INET_ASSERT( lpUnicodeGroupInfo && lpAnsiGroupInfo);

    lpUnicodeGroupInfo->dwGroupSize = sizeof(INTERNET_CACHE_GROUP_INFOW);
    lpUnicodeGroupInfo->dwGroupFlags = lpAnsiGroupInfo->dwGroupFlags;
    lpUnicodeGroupInfo->dwGroupType = lpAnsiGroupInfo->dwGroupType;
    lpUnicodeGroupInfo->dwDiskUsage = lpAnsiGroupInfo->dwDiskUsage;
    lpUnicodeGroupInfo->dwDiskQuota = lpAnsiGroupInfo->dwDiskQuota;

    memcpy(lpUnicodeGroupInfo->dwOwnerStorage,
           lpAnsiGroupInfo->dwOwnerStorage,
           GROUP_OWNER_STORAGE_SIZE * sizeof(DWORD) );


    BOOL fRet = MultiByteToWideChar(
               CP_ACP,
               MB_PRECOMPOSED,
               lpAnsiGroupInfo->szGroupName,
               -1,         // null terminated ansi string.
               lpUnicodeGroupInfo->szGroupName,
               GROUPNAME_MAX_LENGTH
    );

    if( fRet )
    {
        *lpdwUnicodeGroupInfoSize = lpUnicodeGroupInfo->dwGroupSize;
    }
    else
    {
        *lpdwUnicodeGroupInfoSize = 0;
        SetLastError(ERROR_INVALID_PARAMETER);
    }
    return fRet;
}

BOOL CacheGroupInfoW2A(
    IN          LPINTERNET_CACHE_GROUP_INFOW    lpUnicodeGroupInfo,
    IN          DWORD                           dwUnicodeGroupInfoSize,
    OUT         LPINTERNET_CACHE_GROUP_INFOA    lpAnsiGroupInfo,
    IN OUT      LPDWORD                         lpdwAnsiGroupInfoSize
)
{
    INET_ASSERT( lpUnicodeGroupInfo && lpAnsiGroupInfo);
    BOOL fStrNotSafe = FALSE;

    lpAnsiGroupInfo->dwGroupSize = sizeof(INTERNET_CACHE_GROUP_INFOA);
    lpAnsiGroupInfo->dwGroupFlags = lpUnicodeGroupInfo->dwGroupFlags;
    lpAnsiGroupInfo->dwGroupType = lpUnicodeGroupInfo->dwGroupType;
    lpAnsiGroupInfo->dwDiskUsage = lpUnicodeGroupInfo->dwDiskUsage;
    lpAnsiGroupInfo->dwDiskQuota = lpUnicodeGroupInfo->dwDiskQuota;

    memcpy( lpAnsiGroupInfo->dwOwnerStorage,
            lpUnicodeGroupInfo->dwOwnerStorage,
            GROUP_OWNER_STORAGE_SIZE * sizeof(DWORD) );

    BOOL fRet = WideCharToMultiByte(
                CP_ACP,
                0,              // no flags.
                lpUnicodeGroupInfo->szGroupName,
                -1,             // null terminated unicode string.
                lpAnsiGroupInfo->szGroupName,
                GROUPNAME_MAX_LENGTH,
                NULL,           // lpDefaultChar
                &fStrNotSafe    // lpUseDefaultChar
    );
    if (fStrNotSafe)
    {
        fRet = FALSE;
    }

    if( fRet )
    {
        *lpdwAnsiGroupInfoSize = lpAnsiGroupInfo->dwGroupSize;
    }
    else
    {
        *lpdwAnsiGroupInfoSize = 0;
    }
    return fRet;
}


URLCACHEAPI
BOOLAPI
SetUrlCacheEntryGroupW(
    IN LPCWSTR   lpszUrlName,
    IN DWORD    dwFlags,
    IN GROUPID  GroupId,
    IN LPBYTE   pbGroupAttributes, // must pass NULL
    IN DWORD    cbGroupAttributes, // must pass 0
    IN LPVOID   lpReserved         // must pass NULL
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "SetUrlCacheEntryGroupW", 
        "%wq, %#x, %#x, %#x, %#x, %#x", lpszUrlName, dwFlags, GroupId, pbGroupAttributes, cbGroupAttributes, lpReserved));

    BOOL fResult = FALSE;
    BOOL fStrNotSafe = FALSE;
    DWORD dwErr = ERROR_SUCCESS;
    MEMORYPACKET mpUrl;

    if (!lpszUrlName)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    ALLOC_MB(lpszUrlName,0,mpUrl);
    if (!mpUrl.psStr)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    UNICODE_TO_ANSI_CHECKED(lpszUrlName,mpUrl, &fStrNotSafe);
    if (fStrNotSafe)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    fResult = SetUrlCacheEntryGroupA(
                    mpUrl.psStr,
                    dwFlags,
                    GroupId,
                    pbGroupAttributes,
                    cbGroupAttributes,
                    lpReserved);

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}

URLCACHEAPI
BOOL
WINAPI
GetUrlCacheGroupAttributeW(
    IN      GROUPID                         gid,
    IN      DWORD                           dwFlags,
    IN      DWORD                           dwAttributes,
    OUT     LPINTERNET_CACHE_GROUP_INFOW    lpGroupInfo,
    IN OUT  LPDWORD                         lpdwGroupInfo,
    IN OUT  LPVOID                          lpReserved
)
{
    ENTER_CACHE_API ((DBG_API, Bool, "GetUrlCacheGroupAttributeW",
        "%d, %d, %d, %#x, %#x, %#x", 
        gid, dwFlags, dwAttributes, lpGroupInfo, lpdwGroupInfo, lpReserved ));

    BOOL fResult = FALSE;
    DWORD Error = ERROR_SUCCESS;
    INTERNET_CACHE_GROUP_INFOA AnsiGroupInfo;
    DWORD  dwAnsiGroupInfoSize = sizeof(INTERNET_CACHE_GROUP_INFOA);

    if( !lpGroupInfo || !lpdwGroupInfo )
    {
        Error = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    if( *lpdwGroupInfo < sizeof(INTERNET_CACHE_GROUP_INFOW) )
    {
        Error = ERROR_INSUFFICIENT_BUFFER;
        goto Cleanup;
    }

    if( IsBadWriteUrlInfo(lpGroupInfo, *lpdwGroupInfo) )
    {
        Error = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    if( GetUrlCacheGroupAttributeA(
            gid, dwFlags, dwAttributes,
            &AnsiGroupInfo, &dwAnsiGroupInfoSize, lpReserved ) )
    {
        fResult = CacheGroupInfoA2W( &AnsiGroupInfo, 
                                    dwAnsiGroupInfoSize,
                                    lpGroupInfo, 
                                    lpdwGroupInfo );
    }


Cleanup:
    if (Error!=ERROR_SUCCESS)
    {
        SetLastError(Error);
        DEBUG_ERROR(API, Error);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}

URLCACHEAPI
BOOL
WINAPI
SetUrlCacheGroupAttributeW(
    IN      GROUPID                         gid,
    IN      DWORD                           dwFlags,
    IN      DWORD                           dwAttributes,
    IN      LPINTERNET_CACHE_GROUP_INFOW    lpGroupInfo,
    IN OUT  LPVOID                          lpReserved
)
{
    ENTER_CACHE_API ((DBG_API, Bool, "SetUrlCacheGroupAttributeA",
        "%#x, %d, %d, %#x, %#x", 
        gid, dwFlags, dwAttributes, lpGroupInfo, lpReserved));

    BOOL fResult = FALSE;
    DWORD Error = ERROR_SUCCESS;
    INTERNET_CACHE_GROUP_INFOA AnsiGroupInfo;
    DWORD  dwAnsiGroupInfoSize = sizeof(INTERNET_CACHE_GROUP_INFOA);

    if( IsBadReadPtr(lpGroupInfo, sizeof(INTERNET_CACHE_GROUP_INFOW) ) )
    {
        Error = ERROR_INVALID_PARAMETER;
    }
    else if( CacheGroupInfoW2A(
            lpGroupInfo, sizeof(INTERNET_CACHE_GROUP_INFOW),
            &AnsiGroupInfo, &dwAnsiGroupInfoSize ) )
    {
        fResult = SetUrlCacheGroupAttributeA(
            gid, dwFlags, dwAttributes, &AnsiGroupInfo, lpReserved );
    }

    if (Error!=ERROR_SUCCESS)
    {
        SetLastError(Error);
        DEBUG_ERROR(API, Error);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}


// Convert all the ansi strings in a structure to unicode

/* How does this work?
    Take this structure for example:

    struct foo 
    {
        DWORD dwA;
        LPTSTR pszB;
        DWORD dwC;
        LPTSTR pszD;
    };
    where LPTSTR are embedded pointers
    
    The memory layout is thus:

    [DWORD][LPTSTR][DWORD][LPTSTR][embedded string pszB][embedded string pszD]
    ^                             ^
    |                             |
    |-struct beginning            |-beginning of embedded strings

    Assuming a 32-bit platform, we can construct pointers (relative to the struct beginning) to each element
    in the structure. In this case,

    { 0, sizeof(DWORD), sizeof(DWORD)+sizeof(LPTSTR), sizeof(DWORD)+sizeof(LPTSTR)+sizeof(DWORD) }

    Let's say we're interested in strings only, and we know that these strings are embedded. We can create a byte table thus:
    BYTE bFoo[] = { sizeof(DWORD), sizeof(DWORD)+sizeof(LPTSTR)+sizeof(DWORD) }

    Alternatively:
    BYTE bFoo[] = 
    {
        (BYTE)&(((foo*)NULL)->pszB),
        (BYTE)&(((foo*)NULL)->pszD)
    };

    This layout is the same for both Ansi and Unicode versions of a struct, UNLESS the struct contains for example 
    a TCHAR szWhat[256] (in which case, we can't use the bulk converter).

    Pass BulkConverter the following parameters, to convert strings in one swoop.

    pbSrc       = casted pointer to the beginning of the ansi structure
    pbDest      = casted pointer to the beginning of the unicode structure
    cbAvail     = number of bytes available for embedded strings
    wSkip       = offset from the beginning of the structure, at which point embedded strings may be written
    cElements   = number of elements to convert from ansi to unicode

    If BulkConverter succeeds, it'll return the number of bytes used.
    If it fails, it will return the number of bytes needed to store all the unicode strings.

BUT HOW DOES THIS THING WORK?
Oh. 

1. Using the offset table, we figure out where the pointer to the string is in both the structures.
2. Then using magic, we decided where to place the unicode string. 
3. Figure how much space we'll need to store the unicode string
4. If that much is available, convert.
5. Keep track, either way.
6. Go to 1, if we have any other strings left.
*/

LONG BulkConverter(PBYTE pbSrc, PBYTE pbDest, LONG cbAvail, WORD wSkip, CONST BYTE abTable[], WORD cElements)
{
    PWSTR pBuffer = (PWSTR)(pbDest + wSkip);
    PSTR *pBufferA;
    PWSTR *pBufferW;

    for (DWORD i=0; i < cElements; i++)
    {
        pBufferA = (PSTR*)((PBYTE)pbSrc + abTable[i]);
        pBufferW = (PWSTR*)((PBYTE)pbDest + abTable[i]);

        if (*pBufferA)
        {
            *pBufferW = pBuffer;
            LONG dwTmp = MultiByteToWideChar(CP_ACP, 0,  *pBufferA, -1,
                                             *pBufferW, 0);
            if (dwTmp<cbAvail)
            {
                MultiByteToWideChar(CP_ACP, 0,  *pBufferA, -1,
                                             *pBufferW, cbAvail);
                pBuffer += dwTmp;
            }
            cbAvail -= dwTmp;
        }
    }
    return cbAvail;
}


const BYTE bOffsetTableContainer[] = 
    {
        (BYTE)&(((LPINTERNET_CACHE_CONTAINER_INFOW)NULL)->lpszName),
        (BYTE)&(((LPINTERNET_CACHE_CONTAINER_INFOW)NULL)->lpszCachePrefix),
        (BYTE)&(((LPINTERNET_CACHE_CONTAINER_INFOW)NULL)->lpszVolumeLabel),
        (BYTE)&(((LPINTERNET_CACHE_CONTAINER_INFOW)NULL)->lpszVolumeTitle)
    };

BOOL
TransformCacheContainerInfoToW(
    IN BOOL fResult,
    IN LPINTERNET_CACHE_CONTAINER_INFOA pCCIA,
    IN DWORD cbCCIA,
    OUT LPINTERNET_CACHE_CONTAINER_INFOW pCCIW,
    OUT LPDWORD pcbCCIW
)
{
    DWORD cbSize = *pcbCCIW;

    if (fResult)
    {
        // If we have pointers, try to convert from 

        LONG cc = *pcbCCIW - sizeof(INTERNET_CACHE_CONTAINER_INFOW);
        if (*pcbCCIW > sizeof(INTERNET_CACHE_CONTAINER_INFOW))
        {
            pCCIW->dwCacheVersion = pCCIA->dwCacheVersion;
        }
        cc /= sizeof(WCHAR);
        // Convert strings
        cc = BulkConverter((PBYTE)pCCIA, 
                (PBYTE)pCCIW, 
                cc, 
                sizeof(INTERNET_CACHE_CONTAINER_INFOW), 
                bOffsetTableContainer, 
                ARRAY_ELEMENTS(bOffsetTableContainer));


       // Tell how much space was actually used.
        *pcbCCIW -= cc*sizeof(WCHAR);

        if (*pcbCCIW>cbSize)
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            fResult = FALSE;
        }
    }
    else if (GetLastError()==ERROR_INSUFFICIENT_BUFFER)
    {
        *pcbCCIW = (cbCCIA - sizeof(INTERNET_CACHE_CONTAINER_INFOA))*sizeof(WCHAR) + sizeof(INTERNET_CACHE_CONTAINER_INFOW);
    }

    return fResult;
}

#define USE_ORIGINAL_CODE

URLCACHEAPI
BOOL
WINAPI
CreateUrlCacheContainerW(
                 IN LPCWSTR Name,
                 IN LPCWSTR CachePrefix,
                 IN LPCWSTR CachePath,
                 IN DWORD KBCacheLimit,
                 IN DWORD dwContainerType,
                     IN DWORD dwOptions,
                     IN OUT LPVOID pvBuffer,
                     IN OUT LPDWORD cbBuffer)
{
    ENTER_CACHE_API ((DBG_API, Bool, "CreateUrlCacheContainerW", "%wq, %wq, %wq, %d, %d, %d, %#x, %#x",
        Name, CachePrefix, CachePath, KBCacheLimit, dwContainerType, dwOptions, pvBuffer, cbBuffer));

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;

    MEMORYPACKET mpName, mpCachePrefix, mpCachePath;
    BOOL fStrNotSafe = FALSE;

#ifdef USE_ORIGINAL_CODE
    if (Name)
    {
        ALLOC_MB(Name, 0, mpName);
        if (!mpName.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI_CHECKED(Name, mpName, &fStrNotSafe);
        if (fStrNotSafe)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
    }
    if (CachePrefix)
    {
        ALLOC_MB(CachePrefix, 0, mpCachePrefix);
        if (!mpCachePrefix.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI_CHECKED(CachePrefix, mpCachePrefix, &fStrNotSafe);
        if (fStrNotSafe)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
    }
    if (CachePath)
    {
        ALLOC_MB(CachePath,0,mpCachePath);
        if (!mpCachePath.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI_CHECKED(CachePath,mpCachePath, &fStrNotSafe);
        if (fStrNotSafe)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
    }
#else
// Theoretically, the following fragment should be smaller than the above fragment. 
// Although the retail obj shows a function that's about 100 bytes shorter, the
// actual dll doesn't show this gain. Until I figure this out, we won't use it.

    DWORD c;
    do
    {
        MEMORYPACKET* mp;
        PCWSTR psz;

        switch (c)
        {
        case 0:
            psz = Name;
            mp = &mpName;
            break;
            
        case 1:
            psz = CachePrefix;
            mp = &mpCachePrefix;
            break;

        case 2:
            psz = CachePath;
            mp = &mpCachePath;
            break;
        }
        ALLOC_MB(psz, 0, (*mp));
        if (!mp->psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI_CHECKED(psz, (*mp), &fStrNotSafe);
        if (fStrNotSafe)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
        c++;
    }
    while (c<3);

#endif

    fResult = CreateUrlCacheContainerA(
                mpName.psStr,
                mpCachePrefix.psStr,
                mpCachePath.psStr,
                KBCacheLimit,
                dwContainerType,
                dwOptions,
                pvBuffer,
                cbBuffer);

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}

URLCACHEAPI
BOOL
WINAPI
DeleteUrlCacheContainerW(
IN LPCWSTR Name,
IN DWORD dwOptions)
{
    ENTER_CACHE_API ((DBG_API, Bool, "DeleteContainerW", "%wq, %#x", Name, dwOptions));

    DWORD dwErr = ERROR_SUCCESS;
    MEMORYPACKET mpName;
    BOOL fResult = FALSE, fStrNotSafe = FALSE;

    ALLOC_MB(Name, 0, mpName);
    if (!mpName.psStr)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    UNICODE_TO_ANSI_CHECKED(Name, mpName, &fStrNotSafe);
    if (fStrNotSafe)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    fResult = DeleteUrlCacheContainerA(mpName.psStr, dwOptions);

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}


URLCACHEAPI
HANDLE
WINAPI
FindFirstUrlCacheContainerW(
    IN OUT DWORD *pdwModified,
        OUT LPINTERNET_CACHE_CONTAINER_INFOW lpContainerInfo,
        IN OUT LPDWORD lpcbContainerInfo,
    IN DWORD dwOptions
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "FindFirstContainerW",
        "%#x, %#x, %#x, %#x",
        pdwModified,
        lpContainerInfo,
        lpcbContainerInfo,
        dwOptions
    ));

    DWORD dwErr = ERROR_SUCCESS;
    MEMORYPACKET mpCacheInfo;
    HANDLE hInternet = NULL;

    if (!(lpcbContainerInfo && lpContainerInfo))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    mpCacheInfo.psStr = (PSTR)ALLOC_BYTES(*lpcbContainerInfo);
    if (!mpCacheInfo.psStr)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    mpCacheInfo.dwSize = mpCacheInfo.dwAlloc = *lpcbContainerInfo;

    hInternet = FindFirstUrlCacheContainerA(pdwModified,
        (LPINTERNET_CACHE_CONTAINER_INFOA)mpCacheInfo.psStr, &mpCacheInfo.dwSize, dwOptions);

    // TransformCacheContainerInfoToW takes the return value and decides if any further actions need to be taken
    // (eg. if successful, then try to convert from ansi to unicode; else if the ansi api failed, should we care?)
    
    if (!TransformCacheContainerInfoToW(
            hInternet ? TRUE : FALSE,
            (LPINTERNET_CACHE_CONTAINER_INFOA)mpCacheInfo.psStr,
            mpCacheInfo.dwSize,
            lpContainerInfo,
            lpcbContainerInfo))
    {
        if (hInternet)
        {
            FindCloseUrlCache(hInternet);
            hInternet = NULL;
        }
    }

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(hInternet);
    return hInternet;
}

URLCACHEAPI
BOOL
WINAPI
FindNextUrlCacheContainerW(
    IN HANDLE hEnumHandle,
        OUT LPINTERNET_CACHE_CONTAINER_INFOW lpContainerInfo,
        IN OUT LPDWORD lpcbContainerInfo
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "FindNextContainerW",
        "%#x, %#x, %#x",
        hEnumHandle, 
        lpContainerInfo,
        lpcbContainerInfo
    ));

    DWORD dwErr = ERROR_SUCCESS;
    MEMORYPACKET mpCacheInfo;
    BOOL fResult = FALSE;

    if (!(lpcbContainerInfo && lpContainerInfo))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    mpCacheInfo.psStr = (PSTR)ALLOC_BYTES(*lpcbContainerInfo);
    if (!mpCacheInfo.psStr)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    mpCacheInfo.dwSize = mpCacheInfo.dwAlloc = *lpcbContainerInfo;

    fResult = FindNextUrlCacheContainerA(
                    hEnumHandle,
                    (LPINTERNET_CACHE_CONTAINER_INFOA)mpCacheInfo.psStr, 
                    &mpCacheInfo.dwSize);

    // TransformCacheContainerInfoToW takes the return value and decides if any further actions need to be taken
    // (eg. if successful, then try to convert from ansi to unicode; else if the ansi api failed, should we care?)
    
    fResult = TransformCacheContainerInfoToW(
                fResult,
                (LPINTERNET_CACHE_CONTAINER_INFOA)mpCacheInfo.psStr,
                mpCacheInfo.dwSize,
                lpContainerInfo,
                lpcbContainerInfo);

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}

/* here's the struct referred to below 

typedef struct _INTERNET_CACHE_CONFIG_INFOA {
    DWORD dwStructSize;
    DWORD dwContainer;
    DWORD dwQuota;
    DWORD dwReserved4;
    BOOL  fPerUser;
    DWORD dwSyncMode;
    DWORD dwNumCachePaths;
    union 
    { 
        struct 
        {
            CHAR   CachePath[MAX_PATH];
            DWORD dwCacheSize;
        };
        INTERNET_CACHE_CONFIG_PATH_ENTRYA CachePaths[ANYSIZE_ARRAY];
    };
    DWORD dwNormalUsage;
    DWORD dwExemptUsage;
} INTERNET_CACHE_CONFIG_INFOA, * LPINTERNET_CACHE_CONFIG_INFOA;

*/

#define ICCIA_FIXED_PORTION_SIZE ((sizeof(DWORD)*6)+sizeof(BOOL))

/*
URLCACHEAPI
BOOL
WINAPI
GetUrlCacheConfigInfoW(
    OUT LPINTERNET_CACHE_CONFIG_INFOW pCacheConfigInfo,
    IN OUT LPDWORD pcbCacheConfigInfo,
    IN DWORD dwFieldControl
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "GetUrlCacheConfigInfoW", "%#x, %#x, %#x",
        pCacheConfigInfo, pcbCacheConfigInfo, dwFieldControl ));

    INTERNET_CACHE_CONFIG_INFOA iccia;
    
    iccia.dwContainer = pCacheConfigInfo->dwContainer;
    iccia.dwStructSize = sizeof(INTERNET_CACHE_CONFIG_INFOA);
    DWORD dwSize = sizeof(INTERNET_CACHE_CONFIG_INFOA);
    BOOL fResult = GetUrlCacheConfigInfoA(&iccia, &dwSize, dwFieldControl);
    if (fResult)
    {
        memcpy(pCacheConfigInfo, &iccia, ICCIA_FIXED_PORTION_SIZE);

        // These are appended to the _end_ of the structure.
        pCacheConfigInfo->dwNormalUsage = iccia.dwNormalUsage;
        pCacheConfigInfo->dwExemptUsage = iccia.dwExemptUsage;
        pCacheConfigInfo->dwStructSize = sizeof(INTERNET_CACHE_CONFIG_INFOW);
        if (pCacheConfigInfo->dwContainer <= HISTORY)
        {
            MultiByteToWideChar(CP_ACP, 0, iccia.CachePath, -1, pCacheConfigInfo->CachePath, ARRAY_ELEMENTS(pCacheConfigInfo->CachePath));
        }
    }

    DEBUG_LEAVE_API (fResult);
    return fResult;
}


URLCACHEAPI
BOOL
WINAPI
SetUrlCacheConfigInfoW(
    LPCACHE_CONFIG_INFOW lpConfigConfigInfo,
    DWORD dwFieldControl
    )
{
    SetLastError( ERROR_CALL_NOT_IMPLEMENTED );
    return( FALSE );
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\library\tls.hpp ===
#ifndef _THREAD_LOCAL_STORE_HPP_
#define _THREAD_LOCAL_STORE_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Assembly.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants exported from the class.                             */
    /*                                                                  */
    /*   The environment constants indicate the state of thread         */
    /*   local store.                                                   */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 NoTLSMemory			  = -1;
CONST SBIT32 NoTLSStructure			  = 0;

    /********************************************************************/
    /*                                                                  */
    /*   Thread local store.                                            */
    /*                                                                  */
    /*   A wide range of applications use threads.  It is often very    */
    /*   valuable to be able to have some private per thread data.      */
    /*   This functionality is supported by the following class.        */
    /*                                                                  */
    /********************************************************************/

class THREAD_LOCAL_STORE : public ASSEMBLY
    {
        //
        //   Private data.
        //
		BOOLEAN						  Active;

		SBIT32						  TlsIndex;
		SBIT32						  TlsOffset;

    public:
        //
        //   Public functions.
        //
        THREAD_LOCAL_STORE( VOID )
			{
			if ( Active = ((TlsIndex = TlsAlloc()) != NoTLSMemory) )
				{ TlsOffset = ((TlsIndex * sizeof(void*)) + TebSlot); }
			else
				{ Failure( "No TLS available" ); }
			}

		INLINE BOOLEAN Available( VOID )
			{ return Active; }
#ifdef ASSEMBLY_X86
#ifdef ENABLE_NON_STANDARD_ASSEMBLY

		INLINE VOID *GetAddress( VOID )
			{ return (GetTlsAddress( TlsOffset )); }
#endif
#endif

		INLINE VOID *GetPointer( VOID )
			{ return (GetTlsValue( TlsIndex,TlsOffset )); }

		INLINE VOID SetPointer( VOID *NewPointer )
			{ SetTlsValue( TlsIndex,TlsOffset,NewPointer ); }

        ~THREAD_LOCAL_STORE( VOID )
			{
			Active = False;

			if ( TlsIndex != NoTLSMemory )
				{ 
				if ( ! TlsFree( TlsIndex ) )
					{ Failure( "Unable to free TLS memory" ); }
				}
			}

	private:
        //
        //   Disabled operations.
        //
        THREAD_LOCAL_STORE( CONST THREAD_LOCAL_STORE & Copy );

        VOID operator=( CONST THREAD_LOCAL_STORE & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\rockall\library\unique.hpp ===
#ifndef _UNIQUE_HPP_
#define _UNIQUE_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Hash.hpp"
#include "List.hpp"
#include "Pool.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants exported from the class.                             */
    /*                                                                  */
    /*   The constants supplied here control how unique strings         */
    /*   are constructed.                                               */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 MinDetails				  = 16;

    /********************************************************************/
    /*                                                                  */
    /*   Class forward references.                                      */
    /*                                                                  */
    /*   We need to refer to the following classes before they are      */
    /*   fully specified so here we list them as forward references.    */
    /*                                                                  */
    /********************************************************************/

template <class LOCK> class UNIQUE;

    /********************************************************************/
    /*                                                                  */
    /*   A string description.                                          */
    /*                                                                  */
    /*   All unique strings have a string drescription which is         */
    /*   into either the active or free list.                           */
    /*                                                                  */
    /********************************************************************/

class DETAIL : public LIST
	{
	private:
		//
		//   Friend classes.
		//
		friend class				  UNIQUE<NO_LOCK>;
		friend class				  UNIQUE<PARTIAL_LOCK>;
		friend class				  UNIQUE<FULL_LOCK>;

		//
		//   Private data.
		//
		BOOLEAN						  Active;
		SBIT32						  Size;
		CHAR						  *Text;
		SBIT32						  Uses;
	};

    /********************************************************************/
    /*                                                                  */
    /*   A unique string.                                               */
    /*                                                                  */
    /*   Almost all the other classes in the library offer valuable     */
    /*   free-standing functionality.  However, this class is really    */
    /*   just a support class for the variable length string class.     */
    /*                                                                  */
    /********************************************************************/

template <class LOCK=PARTIAL_LOCK> class UNIQUE : public HASH<SBIT32,POINTER>
    {
		//
		//   Private data.
		//
		LIST						  Active;
		LIST						  Free;

		DETAIL						  *Default;
		POOL<DETAIL>				  Details;
		LOCK						  Sharelock;

    public:
        //
        //   Public functions.
        //
        UNIQUE( VOID );

		DETAIL *CreateString( CHAR *String,SBIT32 Size );

		SBIT32 CompareStrings( DETAIL *Detail1,DETAIL *Detail2 );

		DETAIL *CopyString( DETAIL *Detail1,DETAIL *Detail2 );

		VOID DeleteString( DETAIL *Detail );

        ~UNIQUE( VOID );

		//
		//   Public inline functions.
		//
		INLINE DETAIL *DefaultString( VOID )
			{ return Default; }

		INLINE SBIT32 Size( DETAIL *Detail )
			{ return Detail -> Size; }

		INLINE CHAR *Value( DETAIL *Detail )
			{ return Detail -> Text; }

	private:
		//
		//   Private functions.
		//
		VIRTUAL SBIT32 ComputeHashKey
			( 
			CONST SBIT32			  & Key 
			);

		VIRTUAL BOOLEAN MatchingKeys
			( 
			CONST SBIT32			  & Key1,
			CONST SBIT32			  & Key2 
			);

        //
        //   Disabled operations.
        //
        UNIQUE( CONST UNIQUE & Copy );

        VOID operator=( CONST UNIQUE & Copy );
    };

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create a new unique string table.  This call is not thread     */
    /*   safe and should only be made in a single thread environment.   */
    /*                                                                  */
    /********************************************************************/

template <class LOCK> UNIQUE<LOCK>::UNIQUE( VOID )
	{
	//
	//   Create the default string.
	//
	Default = CreateString( "",0 );
	}

    /********************************************************************/
    /*                                                                  */
    /*   Create a new unique string.                                    */
    /*                                                                  */
    /*   When we are handed a new string we need to find out whether    */
    /*   it is unique (and needs to be added to the table) or just a    */
    /*   duplicate of an existing string.                               */
    /*                                                                  */
    /********************************************************************/

template <class LOCK> DETAIL *UNIQUE<LOCK>::CreateString
		( 
		CHAR						  *String,
		SBIT32						  Size 
		)
	{
	AUTO DETAIL *Detail1;
	AUTO DETAIL *Detail2;

	//
	//   Claim an exclusive lock (if enabled).
	//
    Sharelock.ClaimExclusiveLock();

	//
	//   Let us assume that the string is unique and
	//   build an entry to for it.  If we later find
	//   it is not then we just back out the changes.
	//
	if ( Free.EndOfList() )
		{
		REGISTER SBIT32 Count;

		//
		//   Create a several new string descriptions 
		//   and link them into the free list.
		//
		for ( Count=0;Count < MinDetails;Count ++ )
			{
			//
			//   Create a new description and add it 
			//   to the free list.
			//
			Detail1 = new DETAIL;

			Detail1 -> Active = False;

			Detail1 -> Insert( & Free );
			}
		}

	//
	//   We know that the free list must contain 
	//   least one element (if not we would have 
	//   just made some).  We extract the oldest
	//   here.
	//
	if ( (Detail1 = ((DETAIL*) Free.Last())) -> Active )
		{
		//
		//   Delete any existing value when we
		//   recycle an old and unused string
		//   description.  Remember to remove
		//   it from the hash before deleting
		//   the string as the hash uses the
		//   string.
		//
		RemoveFromHash( ((SBIT32) Detail1) );

		delete [] Detail1 -> Text;

		Detail1 -> Active = False;
		}

	//
	//   We now setup the string description for the 
	//   new string.
	//
	Detail1 -> Size = Size;
	Detail1 -> Text = String;
	Detail1 -> Uses = 1;

	//
	//   We are now ready to search the hash table for
	//   a matching string.  We do this by overloading
	//   the hash table key comparision (see later).
	//
	if ( ! FindInHash( ((SBIT32) Detail1),((POINTER*) & Detail2) ) )
		{
		//
		//   We have found a new string so we need to
		//   make the string description active and
		//   insert it in the active list.
		//
		(Detail2 = Detail1) -> Active = True;

		Detail1 -> Delete( & Free );
		Detail1 -> Insert( & Active );

		//
		//   Add the new unique string the the hash 
		//   table so we can find it later.
		//
		AddToHash( ((SBIT32) Detail1),((POINTER) Detail1) );

		//
		//   We know the string is unique so lets
		//   allocate some space for it and copy it 
		//   into the new area.
		//
		Detail1 -> Text = 
			(
			strncpy
				( 
				new CHAR [ (Size + 1) ],
				String,
				Size 
				)
			);

		Detail1 -> Text[ Size ] = '\0';
		}
	else
		{
		//
		//   Increment the use count for an existing
		//   string.
		//
		if ( Detail2 != Default )
			{ 
			//
			//   We may be lucky and find an unused
			//   string.  If so we need to add it to
			//   the active list again.
			//
			if ( (Detail2 -> Uses ++) == 0 )
				{
				//
				//   Add an unused string back to the 
				//   active list again.
				//
				Detail1 -> Delete( & Free );
				Detail1 -> Insert( & Active );
				}
			}
		}

	//
	//   Release any lock we got earlier.
	//
	Sharelock.ReleaseExclusiveLock();

	return Detail2;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Compare two strings.                                           */
    /*                                                                  */
    /*   Compare two strings and find the relationship between them.    */
    /*                                                                  */
    /********************************************************************/

template <class LOCK> SBIT32 UNIQUE<LOCK>::CompareStrings
		( 
		DETAIL						  *Detail1,
		DETAIL						  *Detail2
		)
	{
	//
	//   We know that all strings are unique so if the
	//   string pointers match then they must be the 
	//   the same string.
	//
	if ( Detail1 != Detail2 )
		{
		REGISTER SBIT32 Result =
			(
			strncmp
				( 
				Detail1 -> Text,
				Detail2 -> Text,
				(Detail1 -> Size < Detail2 -> Size)
					? Detail1 -> Size
					: Detail2 -> Size
				)
			);

		//
		//   If the strings match pick the longest.
		//
		if ( Result == 0 )
			{ Result = ((Detail1 -> Size < Detail2 -> Size) ? -1 : 1); }

		return Result;
		}
	else
		{ return 0; }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Compute a hash key.                                            */
    /*                                                                  */
    /*   Compute a hash key for the supplied key.  This hash key        */
    /*   is used to select the hash chain to search.                    */
    /*                                                                  */
    /********************************************************************/

template <class LOCK> SBIT32 UNIQUE<LOCK>::ComputeHashKey
		( 
		CONST SBIT32				  & Key 
		)
	{
	REGISTER SBIT32 Count;
	REGISTER DETAIL *Detail = ((DETAIL*) Key);
	REGISTER SBIT32 HashKey = 2964557531;

	for ( Count=0;Count < Detail -> Size;Count ++ )
		{
		REGISTER SBIT32 Value = ((SBIT32) Detail -> Text[ Count ]);

		HashKey = ((HashKey * Value) + Value); 
		}

	return (HashKey & 0x3fffffff);
	}

    /********************************************************************/
    /*                                                                  */
    /*   Copy a string.                                                 */
    /*                                                                  */
    /*   All strings are unique so there is no need to copy a string.   */
    /*   Nonetheless, we still have to update the use counts.           */
    /*                                                                  */
    /********************************************************************/

template <class LOCK> DETAIL *UNIQUE<LOCK>::CopyString
		( 
		DETAIL						  *Detail1,
		DETAIL						  *Detail2
		)
	{
	//
	//   Claim an exclusive lock (if enabled).
	//
	Sharelock.ClaimExclusiveLock();

	//
	//   Decrement the use count for old string.
	//
	if ( Detail1 != Default )
		{ Detail1 -> Uses --; }

	//
	//   Increment the use count for new string.
	//
	if ( Detail2 != Default )
		{ Detail2 -> Uses ++; }

	//
	//   Release any lock we got earlier.
	//
	Sharelock.ReleaseExclusiveLock();

	return Detail2;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Compare two hash keys.                                         */
    /*                                                                  */
    /*   Compare two hash keys to see if they match.                    */
    /*                                                                  */
    /********************************************************************/

template <class LOCK> BOOLEAN UNIQUE<LOCK>::MatchingKeys
		( 
		CONST SBIT32				  & Key1,
		CONST SBIT32				  & Key2 
		)
	{
	REGISTER DETAIL *Detail1 = ((DETAIL*) Key1);
	REGISTER DETAIL *Detail2 = ((DETAIL*) Key2);

	return
		(
		(Detail1 -> Size == Detail2 -> Size)
			&&
		(strncmp( Detail1 -> Text,Detail2 -> Text,Detail1 -> Size ) == 0)
		);
	}

    /********************************************************************/
    /*                                                                  */
    /*   Delete a string.                                               */
    /*                                                                  */
    /*   Delete a text string.                                          */
    /*                                                                  */
    /********************************************************************/

template <class LOCK> VOID UNIQUE<LOCK>::DeleteString( DETAIL *Detail )
	{
	//
	//   Claim an exclusive lock (if enabled).
	//
	Sharelock.ClaimExclusiveLock();

	//
	//   Decrement the use count for the string.
	//
	if ( Detail != Default )
		{
		//
		//   Decrement the use count and ensure that
		//   this is not the last use of the string.
		//
		if ( (-- Detail -> Uses) == 0 )
			{
			//
			//   When we delete the last use of
			//   a string we add it to the free 
			//   list.  The string can be reclaimed
			//   if it is recreated before it is
			//   deleted.
			//
			Detail -> Delete( & Active );
			Detail -> Insert( & Free );
			}
		}

	//
	//   Release any lock we got earlier.
	//
	Sharelock.ReleaseExclusiveLock();
	}

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory the unique string table.  This call is not thread      */
    /*   safe and should only be made in a single thread environment.   */
    /*                                                                  */
    /********************************************************************/

template <class LOCK> UNIQUE<LOCK>::~UNIQUE( VOID )
	{ 
	//
	//   Delete all active strings.
	//
	while ( ! Active.EndOfList() )
		{
		REGISTER DETAIL *Detail = ((DETAIL*) Active.First());

		//
		//   Delete from the list and add to the free
		//   pool just to be tidy.
		//
		Detail -> Delete( & Active );

		//
		//   The string description may be contain an 
		//   previous value and require some cleanup.
		//
		if ( Detail -> Active )
			{
			//
			//   Delete any existing value.  Remember
			//   to remove it from the hash before
			//   deleting the string as the hash uses
			//   the string.
			//
			RemoveFromHash( ((SBIT32) Detail) );

			delete [] Detail -> Text;

			Detail -> Active = False;
			}

		//
		//   Push back into the pool.
		//
		Details.PushPool( Detail );
		}

	//
	//   Delete all free strings.
	//
	while ( ! Free.EndOfList() )
		{
		REGISTER DETAIL *Detail = ((DETAIL*) Free.First());

		//
		//   Delete from the list and add to the free
		//   pool just to be tidy.
		//
		Detail -> Delete( & Free );

		//
		//   The string description may be contain an 
		//   previous value and require some cleanup.
		//
		if ( Detail -> Active )
			{
			//
			//   Delete any existing value.  Remember
			//   to remove it from the hash before
			//   deleting the string as the hash uses
			//   the string.
			//
			RemoveFromHash( ((SBIT32) Detail) );

			delete [] Detail -> Text;

			Detail -> Active = False;
			}

		//
		//   Push back into the pool.
		//
		Details.PushPool( Detail );
		}
	}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\urlcache\cachapia.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    cachapia.cxx

Abstract:

    contains the ANSI version of cache mangemant APIs.

Author:

    Madan Appiah (madana)  12-Dec-1994

Environment:

    User Mode - Win32

Revision History:

--*/

#include <wininetp.h>
#include <cache.hxx>


/*-----------------------------------------------------------------------------
CreateContainer
----------------------------------------------------------------------------*/
URLCACHEAPI
BOOL
WINAPI
CreateUrlCacheContainerA(
                 IN LPCSTR Name, 
                 IN LPCSTR CachePrefix, 
                 IN LPCSTR CachePath, 
                 IN DWORD KBCacheLimit,
                 IN DWORD dwContainerType,
                 IN DWORD dwOptions,
                 IN OUT LPVOID pvBuffer,
                 IN OUT LPDWORD cbBuffer
)
{
    ENTER_CACHE_API ((DBG_API, Bool, "CreateUrlCacheContainerA", "%q, %q, %q, %d, %d, %d, %#x, %#x",
        Name, CachePrefix, CachePath, KBCacheLimit, dwContainerType, dwOptions, pvBuffer, cbBuffer));

    DWORD Error;

    // Initialize globals
    if (!InitGlobals())
    {
        Error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto Cleanup;
    }

    Error = GlobalUrlContainers->CreateContainer(
                        Name,
                        CachePrefix,
                        CachePath,
                        KBCacheLimit,
                        dwOptions);

    LEAVE_CACHE_API();
}

URLCACHEAPI
BOOL
WINAPI
DeleteUrlCacheContainerA(
IN LPCSTR Name,
IN DWORD dwOptions)
{
    ENTER_CACHE_API ((DBG_API, Bool, "DeleteContainerA", "%q, %d", Name, dwOptions));

    DWORD Error;

    // Initialize globals
    if (!InitGlobals())
    {
        Error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto Cleanup;
    }

    Error = GlobalUrlContainers->DeleteContainer(
                        Name,
                        0
                        );

    LEAVE_CACHE_API();
}


URLCACHEAPI
HANDLE
WINAPI
FindFirstUrlCacheContainerA(
    IN OUT LPDWORD pdwModified,
    OUT LPINTERNET_CACHE_CONTAINER_INFOA lpContainerInfo,
    IN OUT LPDWORD lpdwContainerInfoBufferSize,
    IN DWORD dwOptions
)
{
    ENTER_CACHE_API ((DBG_API, Bool, "FindFirstContainerA",
        "%#x, %#x, %#x, %#x",
        pdwModified,
        lpContainerInfo,
        lpdwContainerInfoBufferSize,
        dwOptions
    ));

    DWORD Error;
    HANDLE hFind = NULL;


    // Initialize globals.
    if (!InitGlobals())
    {
        Error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto Cleanup;
    }

    hFind = GlobalUrlContainers->FindFirstContainer(pdwModified, 
        lpContainerInfo, lpdwContainerInfoBufferSize, dwOptions);

    if (hFind)
        Error = ERROR_SUCCESS;
    else
    {
        Error = GetLastError();
        // BUGBUG: Free hFind?
        // does the free take NULL?
    }

Cleanup:
    if( Error != ERROR_SUCCESS )
    {
        SetLastError( Error );
        DEBUG_ERROR(API, Error);
    }

    DEBUG_LEAVE_API (hFind);
    return hFind;
}

    
URLCACHEAPI
BOOL
WINAPI
FindNextUrlCacheContainerA(
IN HANDLE hFind, 
OUT LPINTERNET_CACHE_CONTAINER_INFOA lpContainerInfo,
IN OUT LPDWORD lpdwContainerInfoBufferSize
)
{
    ENTER_CACHE_API ((DBG_API, Bool, "FindNextContainerA",
        "%#x, %#x, %#x",
        hFind, 
        lpContainerInfo,
        lpdwContainerInfoBufferSize
    ));

    DWORD Error;
    DWORD i;


    // Initialize globals.
    if (!InitGlobals())
    {
        Error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto Cleanup;
    }


    if (GlobalUrlContainers->FindNextContainer(hFind, 
            lpContainerInfo, lpdwContainerInfoBufferSize))
        Error = ERROR_SUCCESS;
    else
        Error = GetLastError();

    LEAVE_CACHE_API();
}

URLCACHEAPI
BOOL
WINAPI
CreateUrlCacheEntryA(
    IN LPCSTR   lpszUrlName,
    IN DWORD    dwExpectedFileSize,
    IN LPCSTR   lpszFileExtension,
    OUT LPSTR lpszFileName,
    IN DWORD dwReserved
    )
/*++

Routine Description:

    This function creates a temperary file in the cache storage. This call
    is called by the application when it receives a url file from a
    server. When the receive is completed it caches this file to url cache
    management, which will move the file to permanent cache file. The idea
    is the cache file is written only once directly into the cache store.

Arguments:

    lpszUrlName : name of the url file (unused now).

    lpszFileExtension: File extension for the saved data file

    dwExpectedFileSize : expected size of the incoming file. If it is unknown
        this value is set to null.

    lpszFileName : pointer to a buffer that receives the full path name of
        the the temp file.

    dwReserved : reserved for future use.

Return Value:

    Windows Error Code.

--*/
{
    ENTER_CACHE_API ((DBG_API, Bool, "CreateUrlCacheEntryA", "%q, %q, %d, %q, %#x",
        lpszUrlName, lpszFileExtension, dwExpectedFileSize, lpszFileName, dwReserved));

    DWORD Error;

    //
    // validate parameters.
    //

    if( IsBadUrl( lpszUrlName ) || IsBadWriteFileName( lpszFileName )  ) {
        Error =  ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    // Initialize globals
    if (!InitGlobals())
    {
        Error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto Cleanup;
    }

    // Null first char in lpszFileName cues CreateUniqueFile
    // to generate a file name from scratch. Otherwise,
    // an attempt will be made to generate the filename
    // using the contents of the buffer.
    *lpszFileName = '\0';

    Error = GlobalUrlContainers->CreateUniqueFile(
                        lpszUrlName,
                        dwExpectedFileSize,
                        lpszFileExtension,
                        lpszFileName, 
                        NULL
                        );

    LEAVE_CACHE_API();
}

URLCACHEAPI
BOOL
WINAPI
CommitUrlCacheEntryA(
    IN LPCSTR lpszUrlName,
    IN LPCSTR lpszLocalFileName,
    IN FILETIME ExpireTime,
    IN FILETIME LastModifiedTime,
    IN DWORD CacheEntryType,
    IN LPBYTE lpHeaderInfo,
    IN DWORD dwHeaderSize,
    IN LPCSTR lpszFileExtension,
    IN LPCSTR lpszOriginalUrl
    )

/*++

Routine Description:

    This API caches a specified URL in the internet service  cache
    storage. It creates a database entry of the URL info and moves the
    URL file to cache storage.

Arguments:

    lpszUrlName : name of the URL that is cached.

    lpszLocalFileName : name of the local file where the URL data is
        stored. This file will be moved to an another file in cache storage, so
        this name is invalid after this api successfully returns. The
        name should include full path.

    ExpireTime : Expire time (GMT) of the file being cached. If it is
        unknown set it to zero.

    LastModifiedTime : Last modified time of this file. if this value is
        zero, current time is set as the last modified time.

    CacheEntryType : type of this new entry.

    lpHeaderInfo : if this pointer is non-NULL, it stores the HeaderInfo
        data as part of the URL entry in the memory mapped file, otherwise
        the app may store it else where. The size of the header info is
        specified by the HeaderSize parameter.

    dwHeaderSize : size of the header info associated with this URL, this
        can be non-zero even if the HeaderInfo specified above is NULL.

    lpszFileExtension :  file extension used to create this file.

    dwReserved : reserved for future use.

Return Value:

    Windows Error code.

--*/
{
    ENTER_CACHE_API ((DBG_API, Bool, "CommitUrlCacheEntryA",
        "%q, %q, <expires>, <last-mod>, %d, %#x, %d, %q, %q",
        lpszUrlName,
        lpszLocalFileName,
        CacheEntryType,
        lpHeaderInfo,
        dwHeaderSize,
        lpszFileExtension,
        lpszOriginalUrl
    ));

    DWORD Error;

    // validate parameters.
    if( IsBadUrl( lpszUrlName ) ||
        ( lpszLocalFileName ? IsBadReadFileName( lpszLocalFileName ) : FALSE ) ) 
    {
        Error =  ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    if( lpHeaderInfo != NULL ) 
    {
        if( IsBadReadPtr(lpHeaderInfo, dwHeaderSize) ) 
        {
            Error =  ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }
    }

    if( lpszFileExtension != NULL ) 
    {
        if( IsBadReadPtr(lpszFileExtension, 3) ) 
        {
            Error =  ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }
    }

    FILETIME     ftPostCheck;
    ftPostCheck.dwLowDateTime = 0;
    ftPostCheck.dwHighDateTime = 0; 
  
    // Record args in structure.
    AddUrlArg Args;
    memset(&Args, 0, sizeof(Args));
    Args.pszUrl      = lpszUrlName;
    Args.pszFilePath = lpszLocalFileName;
    Args.dwFileSize  = 0;
    Args.qwExpires   = FT2LL(ExpireTime);
    Args.qwLastMod   = FT2LL(LastModifiedTime);
    Args.qwPostCheck = FT2LL(ftPostCheck);
    Args.ftCreate = LastModifiedTime;
    Args.dwEntryType = CacheEntryType;
    Args.pbHeaders   = (LPSTR)lpHeaderInfo;
    Args.cbHeaders   = dwHeaderSize;
    Args.pszFileExt  = lpszFileExtension;
    Args.pszRedirect = lpszOriginalUrl ? (LPSTR) lpszOriginalUrl : NULL;
    Args.fImage      = FALSE;

    Error = UrlCacheCommitFile(&Args);

    LEAVE_CACHE_API();
}



URLCACHEAPI
BOOL
WINAPI
RetrieveUrlCacheEntryFileA(
    IN LPCSTR  lpszUrlName,
    OUT LPCACHE_ENTRY_INFOA lpCacheEntryInfo,
    IN OUT LPDWORD lpdwCacheEntryInfoBufferSize,
    IN DWORD dwReserved
    )
/*++

Routine Description:

    This API retrieves the specified URL file. When the file is retrieved
    it also checked out to the user to use. The user has to call
    UnlockUrlFile when he/she finished using it.

Arguments:

    lpszUrlName : name of the URL that is being retrieved.

    lpCacheEntryInfo : pointer to the url info structure that receives the url
        info.

    lpdwCacheEntryInfoBufferSize : pointer to a location where length of
        the above buffer is passed in. On return, this contains the length
        of the above buffer that is fulled in.

    dwReserved : reserved for future use.

Return Value:

    Windows Error code.

--*/
{
    ENTER_CACHE_API ((DBG_API, Bool, "RetrieveUrlCacheEntryFileA","%q, %#x, %#x, %#x",
        lpszUrlName, lpCacheEntryInfo, lpdwCacheEntryInfoBufferSize, dwReserved));
        
    DWORD Error;

    // validate parameters.
    if( IsBadUrl( lpszUrlName ) ||
            IsBadWriteUrlInfo(
                lpCacheEntryInfo,
                *lpdwCacheEntryInfoBufferSize) ) {

        Error =  ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    if (!InitGlobals())
    {
        Error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto Cleanup;
    }

    Error = GlobalUrlContainers->RetrieveUrl(
                        lpszUrlName,
                        (lpCacheEntryInfo ? &lpCacheEntryInfo : NULL),
                        lpdwCacheEntryInfoBufferSize,
                        LOOKUP_URL_CREATE,
                        RETRIEVE_WITH_CHECKS);

    LEAVE_CACHE_API();
}

URLCACHEAPI
HANDLE
WINAPI
RetrieveUrlCacheEntryStreamA(
    IN LPCSTR  lpszUrlName,
    OUT LPCACHE_ENTRY_INFOA lpCacheEntryInfo,
    IN OUT LPDWORD lpdwCacheEntryInfoBufferSize,
    IN BOOL fRandomRead,
    IN DWORD dwReserved
    )
/*++

Routine Description:

    This API retrieves the specified URL file. When the file is retrieved
    it also checked out to the user to use. The user has to call
    UnlockUrlFile when he/she finished using it.

Arguments:

    lpszUrlName : name of the URL that is being retrieved.

    lpCacheEntryInfo : pointer to the url info structure that receives the url
        info.

    lpdwCacheEntryInfoBufferSize : pointer to a location where length of
        the above buffer is passed in. On return, this contains the length
        of the above buffer that is fulled in.

    fRandomRead : if this flag is set to TRUE, then stream is open for
        random access.

    dwReserved: must pass 0

Return Value:

    Windows Error code.

--*/
{
    ENTER_CACHE_API ((DBG_API, Handle, "RetrieveUrlCacheEntryStreamA",
        "%q, %#x, %#x, %d, %#x",
        lpszUrlName,
        lpCacheEntryInfo,
        lpdwCacheEntryInfoBufferSize,
        fRandomRead,
        dwReserved
    ));

    BOOL fLocked = FALSE;
    HANDLE hStream = NULL;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD Error, dwFileSize;

    // Validate parameters.
    if(   IsBadUrl( lpszUrlName )
       || IsBadWriteUrlInfo(lpCacheEntryInfo, *lpdwCacheEntryInfoBufferSize))
    {
        Error =  ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    // Initialize globals.
    if (!InitGlobals())
    {
        Error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto Cleanup;
    }
    
    Error = GlobalUrlContainers->RetrieveUrl
        (lpszUrlName, &lpCacheEntryInfo, lpdwCacheEntryInfoBufferSize,
            LOOKUP_URL_NOCREATE, RETRIEVE_WITHOUT_CHECKS);

    if( Error != ERROR_SUCCESS )
        goto Cleanup;
    fLocked = TRUE;        

    // Allocate a stream handle.
    CACHE_STREAM_CONTEXT_HANDLE* pStream;
    LOCK_CACHE();
    hStream = HandleMgr.Alloc (sizeof(CACHE_STREAM_CONTEXT_HANDLE));
    if (hStream)
    {        
        pStream = (CACHE_STREAM_CONTEXT_HANDLE*) HandleMgr.Map (hStream);
        INET_ASSERT (pStream);
    }
    UNLOCK_CACHE();
    if (!hStream)
    {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    // Open the file.
    hFile = CreateFile
    (
        lpCacheEntryInfo->lpszLocalFileName,
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL |
          (fRandomRead ? FILE_FLAG_RANDOM_ACCESS : FILE_FLAG_SEQUENTIAL_SCAN),
                // improves file read (cache) performance?
        NULL
    );
    if( hFile == INVALID_HANDLE_VALUE )
    {
        Error = GetLastError();
        goto Cleanup;
    }

    dwFileSize = GetFileSize(hFile, NULL);

    if (dwFileSize != lpCacheEntryInfo->dwSizeLow) 
    {
        Error = (dwFileSize==0xFFFFFFFF) ? GetLastError() : ERROR_INVALID_DATA;
        goto Cleanup;
    }

    pStream->FileHandle = hFile;

    // Copy URL name storage.
    pStream->SourceUrlName = NewString(lpszUrlName);
    if( !pStream->SourceUrlName)
    {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }
    Error = ERROR_SUCCESS;

Cleanup:

    if( Error != ERROR_SUCCESS )
    {
        if (hStream)
        {
            HandleMgr.Free (hStream);
            hStream = NULL;
        }
        if (hFile)
            CloseHandle (hFile);
        if (fLocked)
            GlobalUrlContainers->UnlockUrl(lpszUrlName);
        SetLastError (Error);
        DEBUG_ERROR(API, Error);
    }

    DEBUG_LEAVE_API (hStream);
    return hStream;
}


URLCACHEAPI
BOOL
WINAPI
GetUrlCacheEntryInfoA(
    IN LPCSTR lpszUrlName,
    OUT LPCACHE_ENTRY_INFOA lpCacheEntryInfo,
    IN OUT LPDWORD lpdwCacheEntryInfoBufferSize
    )
/*++

Routine Description:

    This function retrieves the specified cache entry info.

Arguments:

    lpszUrlName : name of the url file (unused now).

    lpCacheEntryInfo : pointer to the url info structure that receives the url
        info.

    lpdwCacheEntryInfoBufferSize : pointer to a location where length of
        the above buffer is passed in. On return, this contains the length
        of the above buffer that is fulled in.

Return Value:

    Windows Error Code.

--*/
{
    ENTER_CACHE_API ((DBG_API, Bool, "GetUrlCacheEntryInfoA", "%q, %#x, %#x",
        lpszUrlName, lpCacheEntryInfo, lpdwCacheEntryInfoBufferSize));

    DWORD Error;

    // Validate parameters.
    if( IsBadUrl( lpszUrlName ) ||
        (lpCacheEntryInfo && !lpdwCacheEntryInfoBufferSize) ||
        (lpCacheEntryInfo && lpdwCacheEntryInfoBufferSize && IsBadWriteUrlInfo(
                lpCacheEntryInfo,
                *lpdwCacheEntryInfoBufferSize) ) )
    {
        Error =  ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    // Initialize globals.
    if (!InitGlobals())
    {
        Error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto Cleanup;
    }

    Error = GlobalUrlContainers->GetUrlInfo(
                        lpszUrlName,
                        lpCacheEntryInfo,
                        lpdwCacheEntryInfoBufferSize,
                        LOOKUP_URL_NOCREATE,
                        0);

    LEAVE_CACHE_API();
}


BOOLAPI
GetUrlCacheEntryInfoExA(
    IN LPCSTR       lpszUrl,
    OUT LPINTERNET_CACHE_ENTRY_INFOA lpCEI,
    IN OUT LPDWORD  lpcbCEI,
    OUT LPSTR       lpszOut,
    IN OUT LPDWORD  lpcbOut,
    LPVOID          lpReserved,
    DWORD           dwFlags
)
{
    ENTER_CACHE_API ((DBG_API, Bool, "GetUrlCacheEntryInfoExA",
        "%q, %#x, %#x, %#x, %#x, %#x, %#x", lpszUrl, lpCEI, lpcbCEI, lpszOut, lpcbOut, lpReserved, dwFlags));

    DWORD Error;

    // Validate parameters
    // NOTE: once the following params change, edit GetUrlCacheEntryInfoExW accordingly.
    if (   IsBadUrl(lpszUrl)
        || lpszOut
        || lpcbOut 
        || lpReserved
       )
    {
        INET_ASSERT (FALSE);
        Error = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    // Initialize globals.
    if (!InitGlobals())
    {
        Error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto Cleanup;
    }

    // We allow mixing of INTERNET_CACHE_FLAG_ALLOW_COLLISIONS with lookup flags
    Error = GlobalUrlContainers->GetUrlInfo
        (lpszUrl, lpCEI, lpcbCEI, LOOKUP_URL_TRANSLATE | (dwFlags & INTERNET_CACHE_FLAG_ALLOW_COLLISIONS), dwFlags);
        
    LEAVE_CACHE_API();
}


URLCACHEAPI
BOOL
WINAPI
SetUrlCacheEntryInfoA(
    IN LPCSTR lpszUrlName,
    IN LPCACHE_ENTRY_INFOA lpCacheEntryInfo,
    IN DWORD dwFieldControl
    )
/*++

Routine Description:

    This function sets the specified fields of the cache entry info.

Arguments:

    lpszUrlName : name of the url file (unused now).

    lpCacheEntryInfo : pointer to the url info structure that has the url info to
        be set.

    dwFieldControl : Bitmask that specifies the fields to be set.

Return Value:

    Windows Error Code.

--*/
{
    ENTER_CACHE_API ((DBG_API, Bool, "SetUrlCacheEntryInfoA", "%q, %#x, %d",
        lpszUrlName, lpCacheEntryInfo, dwFieldControl));

    DWORD Error;

    //
    // validate parameters.
    //

    if( IsBadUrl( lpszUrlName ) ||
            IsBadReadUrlInfo( lpCacheEntryInfo )) {

        Error =  ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    // Initialize globals.
    if (!InitGlobals())
    {
        Error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto Cleanup;
    }

    Error = GlobalUrlContainers->SetUrlInfo(
                        lpszUrlName,
                        lpCacheEntryInfo,
                        dwFieldControl );

    LEAVE_CACHE_API();
}

URLCACHEAPI
HANDLE
WINAPI
FindFirstUrlCacheEntryA(
    IN LPCSTR lpszUrlSearchPattern,
    OUT LPCACHE_ENTRY_INFOA lpFirstCacheEntryInfo,
    IN OUT LPDWORD lpdwFirstCacheEntryInfoBufferSize
    )
/*++

Routine Description:

    This member function starts the cache entries enumeration and returns
    the first entry in the cache.

Arguments:

    lpszUrlSearchPattern : pointer to a search pattern string. Currently
        it is not implemented.

    lpFirstCacheEntryInfo : pointer to a cache entry info structure.

Return Value:

    Returns the find first handle. If the returned handle is NULL,
    GetLastError() returns the extended error code.

--*/
{
    ENTER_CACHE_API ((DBG_API, Bool, "FindFirstUrlCacheEntryA",
        "%q, %#x, %#x",
        lpszUrlSearchPattern,
        lpFirstCacheEntryInfo,
        lpdwFirstCacheEntryInfoBufferSize
    ));

    DWORD Error;
    HANDLE hFind = 0;

    // Validate parameters.
    if (IsBadWriteUrlInfo(lpFirstCacheEntryInfo,
                          *lpdwFirstCacheEntryInfoBufferSize))
    {
        Error =  ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    // Initialize globals.
    if (!InitGlobals())
    {
        Error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto Cleanup;
    }

    // Get the first entry.
    Error = GlobalUrlContainers->FindNextEntry(&hFind, 
                                               lpszUrlSearchPattern, 
                                               lpFirstCacheEntryInfo, 
                                               lpdwFirstCacheEntryInfoBufferSize, 
                                               URLCACHE_FIND_DEFAULT_FILTER,
                                               NULL,
                                               FIND_FLAGS_OLD_SEMANTICS);

Cleanup:

    if( Error != ERROR_SUCCESS )
    {
        GlobalUrlContainers->FreeFindHandle(hFind);
        hFind = NULL;
        SetLastError(Error);
        DEBUG_ERROR(API, Error);
    }

    DEBUG_LEAVE_API (hFind);
    return hFind;
}

URLCACHEAPI
BOOL
WINAPI
FindNextUrlCacheEntryA(
    IN HANDLE hFind,
    OUT LPCACHE_ENTRY_INFOA lpNextCacheEntryInfo,
    IN OUT LPDWORD lpdwNextCacheEntryInfoBufferSize
    )
/*++

Routine Description:

    This member function returns the next entry in the cache.

Arguments:

    hEnumHandle : Find First handle.

    lpFirstCacheEntryInfo : pointer to a cache entry info structure.

Return Value:

    Returns the find first handle. If the returned handle is NULL,
    GetLastError() returns the extended error code. It returns
    ERROR_NO_MORE_ITEMS after it returns the last entry in the cache.

--*/
{
    ENTER_CACHE_API ((DBG_API, Bool, "FindNextUrlCacheEntryA",
        "%#x, %#x, %#x",
        hFind, 
        lpNextCacheEntryInfo,
        lpdwNextCacheEntryInfoBufferSize
    ));

    DWORD Error = ERROR_SUCCESS;
    CACHE_FIND_FIRST_HANDLE* pFind;

    // Validate parameters.
    if (!hFind || IsBadWriteUrlInfo(lpNextCacheEntryInfo,
                                    *lpdwNextCacheEntryInfoBufferSize)) 
    {
        Error =  ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    // Initialize globals.
    if (!InitGlobals())
    {
        Error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto Cleanup;
    }


    // Get the next entry.
    Error = GlobalUrlContainers->FindNextEntry(&hFind, 
                                               NULL, 
                                               lpNextCacheEntryInfo, 
                                               lpdwNextCacheEntryInfoBufferSize,
                                               URLCACHE_FIND_DEFAULT_FILTER,
                                               NULL,
                                               FIND_FLAGS_OLD_SEMANTICS);



Cleanup:
    if (Error!=ERROR_SUCCESS)
    {
        SetLastError(Error);
        DEBUG_ERROR(INET, Error);
    }
    DEBUG_LEAVE_API(Error==ERROR_SUCCESS);
    return (Error == ERROR_SUCCESS );
}


INTERNETAPI
HANDLE
WINAPI
FindFirstUrlCacheEntryExA(
    IN     LPCSTR    lpszUrlSearchPattern,
    IN     DWORD     dwFlags,
    IN     DWORD     dwFilter,
    IN     GROUPID   GroupId,
    OUT    LPINTERNET_CACHE_ENTRY_INFOA pEntryInfo,
    IN OUT LPDWORD   pcbEntryInfo,
    OUT    LPVOID    lpGroupAttributes,     // must pass NULL
    IN OUT LPDWORD   pcbGroupAttributes,    // must pass NULL
    IN     LPVOID    lpReserved             // must pass NULL
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "FindFirstUrlCacheEntryExA",
        "%q, %#x, %#x, %#x, %#x, %#x, %#x, %#x, %#x",
        lpszUrlSearchPattern,
        dwFlags,
        dwFilter,
        GroupId,
        pEntryInfo,
        pcbEntryInfo,
        lpGroupAttributes,
        pcbGroupAttributes,
        lpReserved
    ));

    DWORD Error;
    HANDLE hFind = NULL;

    // Validate parameters.
    if (IsBadWritePtr (pcbEntryInfo, sizeof(DWORD)))
    {
        Error = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    // Initialize globals.
    if (!InitGlobals())
    {
        Error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto Cleanup;
    }

    // Get the first entry.
    Error = GlobalUrlContainers->FindNextEntry(&hFind, 
                                               lpszUrlSearchPattern, 
                                               pEntryInfo, 
                                               pcbEntryInfo,
                                               dwFilter,
                                               GroupId,
                                               dwFlags);

Cleanup:

    if( Error != ERROR_SUCCESS )
    {
        if (hFind)
        {
            GlobalUrlContainers->FreeFindHandle(hFind);
            hFind = NULL;
        }
        SetLastError(Error);
        DEBUG_ERROR(API, Error);
    }

    DEBUG_LEAVE_API (hFind);
    return hFind;    
}

BOOLAPI
FindNextUrlCacheEntryExA(
    IN     HANDLE    hFind,
    OUT    LPINTERNET_CACHE_ENTRY_INFOA pEntryInfo,
    IN OUT LPDWORD   pcbEntryInfo,
    OUT    LPVOID    lpGroupAttributes,     // must pass NULL
    IN OUT LPDWORD   pcbGroupAttributes,    // must pass NULL
    IN     LPVOID    lpReserved             // must pass NULL
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "FindNextUrlCacheEntryExA",
        "%#x, %#x, %#x, %#x, %#x, %#x",
        hFind,
        pEntryInfo,
        pcbEntryInfo,
        lpGroupAttributes,
        pcbGroupAttributes,
        lpReserved
    ));

    DWORD Error;

    // Validate parameters.
    if (!hFind || IsBadWritePtr (pcbEntryInfo, sizeof(DWORD)))
    {
        Error = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    // Initialize globals.
    if (!InitGlobals())
    {
        Error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto Cleanup;
    }
    

    // Get the next entry.
    Error = GlobalUrlContainers->FindNextEntry(&hFind, 
                                               NULL, 
                                               pEntryInfo, 
                                               pcbEntryInfo, 
                                               NULL, 
                                               NULL,
                                               NULL);
    

    LEAVE_CACHE_API();
}

URLCACHEAPI
BOOL
WINAPI
FreeUrlCacheSpaceA(
    IN LPCSTR lpszCachePath,
    IN DWORD dwFactor,
    IN DWORD dwFilter
    )
/*++

Routine Description:

    This function cleans up the cache entries in the specified ccahe
    path to make space for future cache entries.

Arguments:

    dwFactor: % of free space

Return Value:

    TRUE if the cleanup is successful. Otherwise FALSE, GetLastError()
    returns the extended error.

--*/
{
    DWORD Error;
    
    ENTER_CACHE_API ((DBG_API, Bool, "FreeUrlCacheSpace", 
        "<path>,%d, %#x", dwFactor, dwFilter));

    // Initialize globals.
    if (!InitGlobals())
    {
        Error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto Cleanup;
    }

    Error = GlobalUrlContainers->CleanupUrls(lpszCachePath, dwFactor, dwFilter);

    LEAVE_CACHE_API();
}

URLCACHEAPI
BOOL
WINAPI
UnlockUrlCacheEntryFileA(
    LPCSTR lpszUrlName,
    IN DWORD dwReserved
    )
/*++

Routine Description:

    This API checks in the file that was check out as part of
    RetrieveUrlFile API.

Arguments:

    lpszUrlName : name of the URL that is being retrieved.

    dwReserved : reserved for future use.

Return Value:

    Windows Error code.

--*/
{
   
    DWORD Error;
    DWORD i;

    ENTER_CACHE_API ((DBG_API, Bool, "UnlockUrlCacheEntryFile",
        "%q, %#x", lpszUrlName, dwReserved));

    // validate parameters.
    if( IsBadUrl( lpszUrlName )  ) {
        Error =  ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    // Initialize globals
    if (!InitGlobals())
    {
        Error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto Cleanup;
    }

    Error = GlobalUrlContainers->UnlockUrl(lpszUrlName);

    LEAVE_CACHE_API();
}

URLCACHEAPI
BOOL
WINAPI
DeleteUrlCacheEntryA(
    IN LPCSTR lpszUrlName
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "DeleteUrlCacheEntry",
        "%q", lpszUrlName));


    DWORD Error;

    // Validate parameters.
    if( IsBadUrl( lpszUrlName ) ) {
        Error =  ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    // Initialize globals
    if (!InitGlobals())
    {
        Error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto Cleanup;
    }
    
    Error = GlobalUrlContainers->DeleteUrl(lpszUrlName);

    LEAVE_CACHE_API();
}

#ifdef __URLCACHE_JUNK__
BOOLAPI
SetUrlCacheEntryGroupA(
    IN LPCSTR   lpszUrlName,
    IN DWORD    dwFlags,
    IN GROUPID  GroupId,
    IN LPBYTE   pbGroupAttributes, // must pass NULL
    IN DWORD    cbGroupAttributes, // must pass 0
    IN LPVOID   lpReserved         // must pass NULL
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "SetUrlCacheEntryGroupA", 
        "%q, %#x, %#x, %#x, %#x, %#x", lpszUrlName, dwFlags, GroupId, pbGroupAttributes, cbGroupAttributes, lpReserved));

    DWORD Error;

    // Validate parameters.
    if (IsBadUrl(lpszUrlName)
        || !GroupId
        || pbGroupAttributes
        || cbGroupAttributes
        || lpReserved
        )
    {
        Error =  ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    // Initialize globals
    if (!InitGlobals())
    {
        Error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto Cleanup;
    }

    Error = GlobalUrlContainers->SetUrlGroup (lpszUrlName, dwFlags, GroupId);

    LEAVE_CACHE_API();
}



URLCACHEAPI
BOOL
WINAPI
GetUrlCacheGroupAttributeA(
    IN      GROUPID                         gid,
    IN      DWORD                           dwFlags,
    IN      DWORD                           dwAttributes,
    OUT     LPINTERNET_CACHE_GROUP_INFOA    lpGroupInfo,
    IN OUT  LPDWORD                         lpdwGroupInfo,
    IN OUT  LPVOID                          lpReserved
)
{
    ENTER_CACHE_API ((DBG_API, Bool, "GetUrlCacheGroupAttributeA",
        "%#x, %d, %d, %#x, %#x, %#x", 
        gid, dwFlags, dwAttributes, lpGroupInfo, lpdwGroupInfo, lpReserved ));

    DWORD Error;

    // Validate parameters.
    if( !lpGroupInfo ||
        !lpdwGroupInfo ||
        IsBadWriteUrlInfo(lpGroupInfo, *lpdwGroupInfo) ) 
    {
        Error = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    if( *lpdwGroupInfo < sizeof(INTERNET_CACHE_GROUP_INFOA) )
    {
        Error = ERROR_INSUFFICIENT_BUFFER;
        goto Cleanup;
    }

    // Initialize globals.
    if (!InitGlobals())
    {
        Error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto Cleanup;
    }

    Error = GlobalUrlContainers->GetGroupAttributes(
                        gid,
                        dwAttributes,
                        lpGroupInfo,
                        lpdwGroupInfo );
    LEAVE_CACHE_API();
}

URLCACHEAPI
BOOL
WINAPI
SetUrlCacheGroupAttributeA(
    IN      GROUPID                         gid,
    IN      DWORD                           dwFlags,
    IN      DWORD                           dwAttributes,
    IN      LPINTERNET_CACHE_GROUP_INFOA    lpGroupInfo,
    IN OUT  LPVOID                          lpReserved
)
{
    ENTER_CACHE_API ((DBG_API, Bool, "SetUrlCacheGroupAttributeA",
        "%#x, %d, %d, %#x, %#x", 
        gid, dwFlags, dwAttributes, lpGroupInfo, lpReserved));

    DWORD Error;

    // validate parameters.
    if( IsBadReadPtr(lpGroupInfo, sizeof(INTERNET_CACHE_GROUP_INFOA) ) ) 
    {
        Error = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    // Initialize globals.
    if (!InitGlobals())
    {
        Error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto Cleanup;
    }

    Error = GlobalUrlContainers->SetGroupAttributes(
            gid, dwAttributes, lpGroupInfo);

    LEAVE_CACHE_API();
}
#endif // __URLCACHE_JUNK__

// This function will be removed from the export table 
BOOLAPI
IsUrlCacheEntryExpiredA(
    IN      LPCSTR       lpszUrlName,
    IN      DWORD        dwFlags,
    IN OUT  FILETIME*    pftLastModifiedTime
)
{
    return FALSE;
}

/*
    BOOL                        bRet = TRUE;
    CACHE_ENTRY_INFOEX*         pCEI = NULL;    
    DWORD                       cbCEI;
    DWORD                       dwError;
    BOOL                        bLazy = FALSE;
    BOOL                        fLocked = FALSE;

    // Validate parameters.
    if( IsBadUrl( lpszUrlName ) || !pftLastModifiedTime ) {
        INET_ASSERT(FALSE); 
        return ERROR_INVALID_PARAMETER;
    }

    // set out LastModTime to 0
    pftLastModifiedTime->dwLowDateTime = 0 ;
    pftLastModifiedTime->dwHighDateTime = 0 ;


    if (!InitGlobals())
    {
        INET_ASSERT(FALSE);
        return ERROR_WINHTTP_INTERNAL_ERROR;
    }

    //
    // BUGBUG
    // ideally, we should use GlobalUrlContainers->GetUrlInfo()
    // with NO_ALLOCATION and HEADONLY flag for perf.
    // however, there is a flag (lookup flag v.s entry flag) collision 
    // in that code path which prevents this working
    // so we use this anti-perf RetrieveUrl for now until that one
    // gets fixed 
    //                                           --DanpoZ, 98.09.09
    
    // Find the container and search the index.
    dwError = GlobalUrlContainers->RetrieveUrl(
                    lpszUrlName, 
                    (CACHE_ENTRY_INFO**) &pCEI, 
                    &cbCEI, 
                    (dwFlags & INTERNET_FLAG_FWD_BACK)?
                        LOOKUP_URL_TRANSLATE : LOOKUP_URL_NOCREATE,
                    RETRIEVE_WITHOUT_CHECKS | RETRIEVE_WITH_ALLOCATION);

    
    // not found in cache
    if( dwError != ERROR_SUCCESS )
        goto Cleanup;    

    fLocked = TRUE;

    // found in cache, get the last modified time
    *pftLastModifiedTime = pCEI->LastModifiedTime;

    bRet = IsExpired(pCEI, dwFlags, &bLazy);
    if( bRet && bLazy )
    {
        //
        // the entry is not expired, however, we need to post-fetch
        // so we have to return EXPIRED back to trident to force them
        // issue a binding, on the new binding, urlmon-wininet returns
        // the cache content and queue a background update
        // (an alternative would be to ask trident to catch this case
        //  and call background update themself)
        // 
        bRet = FALSE;
    }

Cleanup:
    if( pCEI )
        FREE_MEMORY(pCEI);

    if (fLocked)
        GlobalUrlContainers->UnlockUrl(lpszUrlName);

    return bRet;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\urlcache\cacheapi.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    cacheapi.cxx

Abstract:

    contains the URL cache mangemant APIs.

Author:

    Madan Appiah (madana)  12-Dec-1994

Environment:

    User Mode - Win32

Revision History:

    Shishir Pardikar (shishirp) added: (as of 7/6/96)

    1) Prefixed containers for supporting cookies and history
    2) Default init, for distributing winint without setup
    3) Crossprocess versionchecking scheme to allow all wininets
       to know about registry change

--*/

#include <wininetp.h>
#include <cache.hxx>
#include <time.h>
// #include <resource.h>	
    
URLCACHEAPI
BOOL
WINAPI
UnlockUrlCacheEntryStream(
    HANDLE hStream,
    IN DWORD dwReserved
    )
/*++

Routine Description:

    This API checks in the file that was check out as part of
    RetrieveUrlFile API.

Arguments:

    hStreamHandle : stream handle returned by a RetrieveUrlCacheEntryStream call.

    dwReserved : reserved for future use.

Return Value:

    Windows Error code.

--*/
{
    ENTER_CACHE_API ((DBG_API, Bool, "UnlockUrlCacheEntryStream",
        "%#x, %#x", hStream, dwReserved))

    DWORD Error;


    // Map and validate handle.
    CACHE_STREAM_CONTEXT_HANDLE *pStream;
    LOCK_CACHE();
    pStream = (CACHE_STREAM_CONTEXT_HANDLE *) HandleMgr.Map(hStream);
    UNLOCK_CACHE();
    if (!pStream)
    {
        Error = ERROR_INVALID_HANDLE;
        goto Cleanup;
    }
    
        
    TcpsvcsDbgAssert(pStream->SourceUrlName != NULL );

    //
    // close file handle.
    //

    CloseHandle( pStream->FileHandle );

    //
    // unlock cache file.
    //

    if(!UnlockUrlCacheEntryFile(pStream->SourceUrlName, dwReserved) )
        Error = GetLastError();
    else
        Error = ERROR_SUCCESS;

    //
    // freeup url name data buffer.
    //

    FREE_MEMORY (pStream->SourceUrlName);

    //
    // free up context structure.
    //

    LOCK_CACHE();
    HandleMgr.Free (hStream);
    UNLOCK_CACHE();

    LEAVE_CACHE_API();
}

URLCACHEAPI
BOOL
WINAPI
ReadUrlCacheEntryStream(
    IN HANDLE hStream,
    IN DWORD dwLocation,
    IN OUT LPVOID lpBuffer,
    IN OUT LPDWORD lpdwLen,
    IN DWORD Reserved
    )
/*++

Routine Description:

    This API provides a method  of reading the cached data from a stream
    which has been opened using the RetrieveUrlCacheEntryStream API.

Arguments:

    hStream : Handle that was returned by the RetrieveCacheEntryStream API.

    dwLocation  : file offset to read from.

    lpBuffer : Pointer to a buffer where the data is read.

    lpdwLen : Pointer to a DWORD location where the length of the above buffer passed in, on return it contains the actual length of the data read.

    dwReserved : For future use.

Return Value:

    Windows Error code.

--*/
{
    ENTER_CACHE_API ((DBG_API, Bool, "ReadUrlCacheEntryStream",
        "%#x, %d, %#x, %#x, %#x", hStream, dwLocation, lpBuffer, lpdwLen, Reserved));

    DWORD Error;

    // Map and validate handle.
    CACHE_STREAM_CONTEXT_HANDLE* pStream;
    LOCK_CACHE();
    pStream = (CACHE_STREAM_CONTEXT_HANDLE*) HandleMgr.Map(hStream);
    UNLOCK_CACHE();
    if (!pStream)
    {
        Error = ERROR_INVALID_HANDLE;
        goto Cleanup;
    }

    TcpsvcsDbgAssert( pStream->SourceUrlName);

    // PERFPERF: should we remember position to avoid this call?
    if ((DWORD) -1L == SetFilePointer
        (pStream->FileHandle, dwLocation, NULL, FILE_BEGIN))
    {
        Error = GetLastError();
        goto Cleanup;
    }

    if( !ReadFile
        (pStream->FileHandle, lpBuffer, *lpdwLen, lpdwLen, NULL ) )
    {
        Error = GetLastError();
        goto Cleanup;
    }

    Error = ERROR_SUCCESS;

    LEAVE_CACHE_API();
}


URLCACHEAPI
BOOL
WINAPI
FindCloseUrlCache(
    IN HANDLE hFind
    )
/*++

Routine Description:

    This member function returns the next entry in the cache.

Arguments:

    hEnumHandle : Find First handle.

Return Value:

    Returns the find first handle. If the returned handle is NULL,
    GetLastError() returns the extended error code. It returns
    ERROR_NO_MORE_ITEMS after it returns the last entry in the cache.

--*/
{
    ENTER_CACHE_API ((DBG_API, Bool, "FindCloseUrlCache",
        "%#x", hFind));

    DWORD Error;
    
    Error = GlobalUrlContainers->FreeFindHandle(hFind);

    if (Error != ERROR_SUCCESS)
    {
        SetLastError( Error );
        DEBUG_ERROR(INET, Error);
    }
    DEBUG_LEAVE_API (Error==ERROR_SUCCESS);
    return (Error==ERROR_SUCCESS);
}


BOOL
GetCurrentSettingsVersion(LPDWORD   lpdwVer) {

    // Initialize globals
    if (!InitGlobals())
    {
        SetLastError (ERROR_WINHTTP_INTERNAL_ERROR);
        return FALSE;
    }
    return GlobalUrlContainers->GetHeaderData(CACHE_HEADER_DATA_CURRENT_SETTINGS_VERSION, 
                                              lpdwVer);
}

BOOL
IncrementCurrentSettingsVersion(LPDWORD lpdwVer) {

    if (!InitGlobals())
    {
        SetLastError (ERROR_WINHTTP_INTERNAL_ERROR);
        return FALSE;
    }
    return GlobalUrlContainers->IncrementHeaderData(CACHE_HEADER_DATA_CURRENT_SETTINGS_VERSION, 
                                                    lpdwVer);
}


BOOL
GetUrlCacheHeaderData(IN DWORD nIdx, OUT LPDWORD lpdwData)
{
    if (!InitGlobals())
    {
        SetLastError (ERROR_WINHTTP_INTERNAL_ERROR);
        return FALSE;
    }
    return GlobalUrlContainers->GetHeaderData(nIdx, lpdwData);
}

BOOL
SetUrlCacheHeaderData(IN DWORD nIdx, IN  DWORD  dwData)
{
    if (!InitGlobals())
    {
        SetLastError (ERROR_WINHTTP_INTERNAL_ERROR);
        return FALSE;
    }
    return GlobalUrlContainers->SetHeaderData(nIdx, dwData);
}

BOOL
IncrementUrlCacheHeaderData(IN DWORD nIdx, OUT LPDWORD lpdwData)
{
    if (!InitGlobals())
    {
        SetLastError (ERROR_WINHTTP_INTERNAL_ERROR);
        return FALSE;
    }
    return GlobalUrlContainers->IncrementHeaderData(nIdx, lpdwData);
}


BOOL
LoadUrlCacheContent(VOID)
{
    DWORD dwError;
    if (!InitGlobals())
    {
        SetLastError(ERROR_WINHTTP_INTERNAL_ERROR);
        return FALSE;
    }

    dwError = GlobalUrlContainers->LoadContent();
    if (dwError == ERROR_SUCCESS)
        return TRUE;
    SetLastError(dwError);
    return FALSE;
}


BOOL
GetUrlCacheContainerInfo(
    IN LPSTR lpszUrlName,
	OUT LPINTERNET_CACHE_CONTAINER_INFOA lpContainerInfo,
	IN OUT LPDWORD lpdwContainerInfoBufferSize,
	IN DWORD dwOptions
)
{
    DWORD dwError;

    // Initialize globals.
    if (!InitGlobals())
    {
        SetLastError(ERROR_WINHTTP_INTERNAL_ERROR);
        return FALSE;
    }

    dwError = GlobalUrlContainers->GetContainerInfo(lpszUrlName,
            lpContainerInfo, lpdwContainerInfoBufferSize);

    if (dwError == ERROR_SUCCESS)
        return TRUE;
    SetLastError(dwError);
    return FALSE;
}

/*
BOOL
UpdateUrlCacheContentPath(
    IN LPSTR lpszNewPath
)
{
    ENTER_CACHE_API ((DBG_API, Bool, "UpdateUrlCacheContentPath", "%q", lpszNewPath));
    INET_ASSERT(GlobalCacheInitialized);

    BOOL fResult = GlobalUrlContainers->SetContentPath(lpszNewPath);

    DEBUG_LEAVE_API(fResult);
    return fResult;
}
*/


INTERNETAPI
GROUPID 
WINAPI
CreateUrlCacheGroup(
    IN DWORD  dwFlags,
    IN LPVOID lpReserved  // must pass NULL
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "CreateUrlCacheGroup", "%#x, %#x", dwFlags, lpReserved));
    GROUPID gid = 0;
    DWORD   Error; 

    // Initialize globals
    if (!InitGlobals())
    {
        Error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto Cleanup;
    }
    
    Error = GlobalUrlContainers->CreateGroup(dwFlags, &gid);

Cleanup:
    if( Error != ERROR_SUCCESS )
    {
        SetLastError(Error);
        DEBUG_ERROR(API, Error);
    }
    DEBUG_LEAVE_API(gid);    
    return gid;
}

BOOLAPI
DeleteUrlCacheGroup(
    IN  GROUPID GroupId,
    IN  DWORD   dwFlags,       // must pass 0
    IN  LPVOID  lpReserved    // must pass NULL
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "DeleteUrlCacheGroup", "%#x, %#x, %#x", GroupId, dwFlags, lpReserved));
    DWORD   Error;

    // Initialize globals
    if (!InitGlobals())
    {
        Error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto Cleanup;
    }

    Error = GlobalUrlContainers->DeleteGroup(GroupId, dwFlags);

    LEAVE_CACHE_API();
}



URLCACHEAPI
HANDLE
WINAPI
FindFirstUrlCacheGroup(
    IN      DWORD                           dwFlags,
    IN      DWORD                           dwFilter,
    IN      LPVOID                          lpSearchCondition,
    IN      DWORD                           dwSearchCondition,
    OUT     GROUPID*                        lpGroupId,
    IN OUT  LPVOID                          lpReserved 
) 
{
    ENTER_CACHE_API ((DBG_API, Handle, "FindFirstUrlCacheGroup",
        "%d, %d, %#x, %d, %#x, %#x", 
        dwFlags, dwFilter, lpSearchCondition, 
        dwSearchCondition, lpGroupId, lpReserved ));

    DWORD Error;
    HANDLE hFind = 0;

    // Validate parameters.
    if( !lpGroupId )
    {
        Error =  ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    // Initialize globals.
    if (!InitGlobals())
    {
        Error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto Cleanup;
    }
    
    // Get the first entry.
    Error = GlobalUrlContainers->FindNextGroup(&hFind, dwFlags, lpGroupId);

Cleanup:

    if( Error != ERROR_SUCCESS )
    {
        GlobalUrlContainers->FreeFindHandle(hFind);
        SetLastError(Error);
        DEBUG_ERROR(API, Error);
        hFind = NULL;
    }

    INET_ASSERT (hFind);
    DEBUG_LEAVE_API (hFind);
    return hFind;
}

URLCACHEAPI
BOOL
WINAPI
FindNextUrlCacheGroup(
    IN HANDLE                               hFind,
    OUT     GROUPID*                        lpGroupId,
    IN OUT  LPVOID                          lpReserved 
    )
{

    ENTER_CACHE_API ((DBG_API, Bool, "FindNextUrlCacheGroup",
        "%#x, %#x, %#x", hFind, lpGroupId, lpReserved ));

    DWORD Error;

    // Validate parameters.
    if( !lpGroupId )
    {
        Error =  ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    // Initialize globals.
    if (!InitGlobals())
    {
        Error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto Cleanup;
    }


    // Get the next entry.
    Error = GlobalUrlContainers->FindNextGroup(&hFind, 0, lpGroupId);

    LEAVE_CACHE_API();
}



BOOL
AnyFindsInProgress(DWORD ContainerID)
{
    LOCK_CACHE();
    BOOL fInProgress = HandleMgr.InUse();
    UNLOCK_CACHE();
    return fInProgress;
}


BOOL
RegisterUrlCacheNotification(
    HWND        hWnd, 
    UINT        uMsg, 
    GROUPID     gid, 
    DWORD       dwFilter, 
    DWORD       dwReserve
)
{
    DWORD Error;
    ENTER_CACHE_API ((DBG_API, Bool, "RegisterUrlCacheNotification", 
        "%#x,,%#x, %#x, %#x, %#x", hWnd, uMsg, gid, dwFilter, dwReserve));

    // Initialize globals.
    if (!InitGlobals())
    {
        Error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto Cleanup;
    }

    Error = GlobalUrlContainers->RegisterCacheNotify(hWnd, uMsg, gid, dwFilter);

    LEAVE_CACHE_API();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\urlcache\cachedef.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    cachedef.h

Abstract:

    contains data definitions for cache code.

Author:

    Madan Appiah (madana)  12-Apr-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _CACHEDEF_
#define _CACHEDEF_

//
// C++ inline code definition for retail build only.
//

#if DBG
#undef CHECKLOCK_NORMAL
#undef CHECKLOCK_PARANOID
#define INLINE
#else
#define INLINE      inline
#endif

#define PAGE_SIZE                        4096            // Grow memory mapped file by 1 page.
#define ALLOC_PAGES                      4               // was 2
#define HEADER_ENTRY_SIZE                ALLOC_PAGES * PAGE_SIZE
#define NORMAL_ENTRY_SIZE                128

#define DEFAULT_CLEANUP_FACTOR           10  // % free goal once cache quota exceeded
#define MAX_EXEMPT_PERCENTAGE            70

#define MEMMAP_FILE_NAME                 TEXT("index.dat")
#define DESKTOPINI_FILE_NAME             TEXT("desktop.ini")

#define DEFAULT_FILE_EXTENSION           ""

// Cache configuration and signature.
#define CACHE_SIGNATURE_VALUE           TEXT("Signature")
#define CACHE_SIGNATURE                 TEXT("Client UrlCache MMF Ver 5.2")
#define NUM_HEADER_DATA_DWORDS          (CACHE_HEADER_DATA_LAST + 1)
#define MAX_SIG_SIZE                     (sizeof(CACHE_SIGNATURE) / sizeof(TCHAR))

// The following values parametrize the schema for URL entries.
#define ENTRY_COPYSIZE_IE5    \
    (sizeof(IE5_URL_FILEMAP_ENTRY) - sizeof(FILEMAP_ENTRY))
#define ENTRY_VERSION_IE5               0
#define ENTRY_COPYSIZE_IE6    \
    (sizeof(IE6_URL_FILEMAP_ENTRY) - sizeof(FILEMAP_ENTRY))
#define ENTRY_VERSION_IE6               0x10

#define ENTRY_COPYSIZE_CURRENT          ENTRY_COPYSIZE_IE6
#define ENTRY_VERSION_CURRENT           ENTRY_VERSION_IE6

// If IE5-IE? sees an entry with low bits of version set, it will be placed
// on async fixup list rather than being destroyed.
#define ENTRY_VERSION_NONCOMPAT_MASK    0x0F


// Roundup
#define ROUNDUPTOPOWEROF2(bytesize, powerof2) (((bytesize) + (powerof2) - 1) & ~((powerof2) - 1))
#define ROUNDUPBLOCKS(bytesize) ((bytesize + NORMAL_ENTRY_SIZE-1) & ~(NORMAL_ENTRY_SIZE-1))
#define ROUNDUPDWORD(bytesize) ((bytesize + sizeof(DWORD)-1) & ~(sizeof(DWORD)-1))
#define ROUNDUPPAGE(bytesize) ((bytesize + PAGE_SIZE-1) & ~(PAGE_SIZE-1))
#define NUMBLOCKS(bytesize) (bytesize / NORMAL_ENTRY_SIZE)

// Power of 2 macros
#define ISPOWEROF2(val) (!((val) & ((val)-1)))
#define ASSERT_ISPOWEROF2(val) INET_ASSERT(ISPOWEROF2(val))

#define URL_CACHE_VERSION_NUM  sizeof(CACHE_ENTRY_INFO);

// Default profiles directory under %SystemRoot%.
#define DEFAULT_PROFILES_DIRECTORY TEXT("Profiles")


//
// Registry key and value names for persistent URL management.
//

// BUGBUG - wasting space. 

#define MS_BASE TEXT("Software\\Microsoft")

#define CV_BASE MS_BASE TEXT("\\Windows\\CurrentVersion")

#define EX_BASE TEXT("\\Explorer")

#define IS_BASE TEXT("\\Internet Settings")

#define CACHE_T TEXT("\\Cache")

#define SHELL_FOLDER_KEY        CV_BASE EX_BASE TEXT("\\Shell Folders")
#define USER_SHELL_FOLDER_KEY   CV_BASE EX_BASE TEXT("\\User Shell Folders")
#define CACHE5_KEY              CV_BASE IS_BASE TEXT("\\5.0") CACHE_T
#define IDENTITIES_KEY          CV_BASE IS_BASE TEXT("\\5.0\\Identities") 
#define OLD_CACHE_KEY           CV_BASE IS_BASE CACHE_T
#define CACHE_PATHS_FULL_KEY    CV_BASE IS_BASE CACHE_T TEXT("\\Paths")
#define RUN_ONCE_KEY            CV_BASE TEXT("\\RunOnce")
#define PROFILELESS_USF_KEY     TEXT(".Default\\") USER_SHELL_FOLDER_KEY
#define CONTENT_CACHE_HARD_NAME TEXT("Content.IE5")
#define OLD_VERSION_KEY         MS_BASE TEXT("\\IE Setup\\SETUP")
#define OLD_VERSION_VALUE       TEXT("UpgradeFromIESysFile")

// from wininet\inetui\inetui.rc
#define IDS_CACHE_DEFAULT_SUBDIR "Temporary Internet Files"
#define IDS_COOKIES_DEFAULT_SUBDIR "Cookies"
#define IDS_HISTORY_DEFAULT_SUBDIR "History"
#define IDS_CACHE_DEFAULT_SUBDIR_UNIX "TempInternetFiles"

//
// Cache parameters
//
#ifndef unix
#define PATH_CONNECT_STRING                    TEXT("\\")
#define PATH_CONNECT_CHAR                      TEXT('\\')
#define ALLFILES_WILDCARD_STRING               TEXT("*.*")
#define UNIX_RETURN_IF_READONLY_CACHE 
#define UNIX_RETURN_ERR_IF_READONLY_CACHE(error) 
#define UNIX_NORMALIZE_PATH_ALWAYS(szOrigPath, szEnvVar)
#define UNIX_NORMALIZE_IF_CACHE_PATH(szOrigPath, szEnvVar, szKeyName)
#else
#define PATH_CONNECT_STRING                    TEXT("/")
#define PATH_CONNECT_CHAR                      TEXT('/')
#define ALLFILES_WILDCARD_STRING               TEXT("*")
#define UNIX_RETURN_IF_READONLY_CACHE   {                        \
                                           if (g_ReadOnlyCaches) \
                                              return;            \
                                        }
#define UNIX_RETURN_ERR_IF_READONLY_CACHE(error) {                      \
                                                   if (g_ReadOnlyCaches)\
                                                      return (error);   \
                                               }
#define UNIX_NORMALIZE_PATH_ALWAYS(szOrigPath, szEnvVar) \
                                        UnixNormalisePath(szOrigPath, szEnvVar);
#define UNIX_NORMALIZE_IF_CACHE_PATH(szOrigPath, szEnvVar, szKeyName) \
                      UnixNormaliseIfCachePath(szOrigPath, szEnvVar, szKeyName);

#define UNIX_SHARED_CACHE_PATH TEXT("%HOME%/.microsoft")
#endif /* !unix */

#define CACHE_PERSISTENT                TEXT("Persistent")

// Retrieval methods
#define RETRIEVE_WITHOUT_CHECKS     0
#define RETRIEVE_WITH_CHECKS        1
#define RETRIEVE_WITH_ALLOCATION    2
#define RETRIEVE_ONLY_FILENAME      4
#define RETRIEVE_ONLY_STRUCT_INFO   8
//
// Multiple URL containters can be configured under the above key such
// as :
//
//  Cache\Paths\Path1
//  Cache\Paths\Path2
//    ...
//
// Each containter will have the following two parameters.
//

// CConMgr related defines.
#define CACHE_PATHS_KEY                 TEXT("Paths")
#define CACHE_PATH_VALUE                TEXT("CachePath")
#define CACHE_PATH_VALUE_TYPE           REG_SZ
#define CACHE_LIMIT_VALUE               TEXT("CacheLimit")
#define CACHE_LIMIT_VALUE_TYPE          REG_DWORD
#define CACHE_OPTIONS_VALUE             TEXT("CacheOptions")
#define CACHE_OPTIONS_VALUE_TYPE        REG_DWORD
#define CACHE_PATCH_VALUE               TEXT("CacheRepair")
#define CACHE_PATCH_VALUE_TYPE          REG_DWORD

#define EXTENSIBLE_CACHE_PATH_KEY       "Extensible Cache"
#define CONTENT_PATH_KEY                "Content"
#define COOKIE_PATH_KEY                 "Cookies"
#define HISTORY_PATH_KEY                "History"
#define URL_HISTORY_KEY                 "Url History"

#define PER_USER_KEY                    "PerUserItem"
#define PROFILES_ENABLED_VALUE          "Network\\Logon"
#define PROFILES_ENABLED                "UserProfiles"
#define PROFILES_PATH_VALUE             CV_BASE "\\ProfileList"
#define PROFILES_PATH                   "ProfileImagePath"

#define CONTENT_PREFIX                  ""
#define COOKIE_PREFIX                   "Cookie:"
#define HISTORY_PREFIX                  "Visited:" 

#define CONTENT_VERSION_SUBDIR          "Content.IE5"
#define IE3_COOKIES_PATH_KEY            OLD_CACHE_KEY TEXT("\\Special Paths\\Cookies")
#define IE3_HISTORY_PATH_KEY            OLD_CACHE_KEY TEXT("\\Special Paths\\History")
#define IE3_PATCHED_USER_KEY            TEXT("Patched User")
#define CACHE_SPECIAL_PATHS_KEY         TEXT("Special Paths")
#define CACHE_DIRECTORY_VALUE           TEXT("Directory")
#define CACHE_DIRECTORY_TYPE            REG_EXPAND_SZ
#define CACHE_NEWDIR_VALUE              TEXT("NewDirectory")
#define CACHE_NEWDIR_TYPE               REG_EXPAND_SZ
#define CACHE_PREFIX_VALUE	            TEXT("CachePrefix")
#define CACHE_PREFIX_MAP_VALUE          "PrefixMap"
#define CACHE_VOLUME_LABLE_VALUE        "VolumeLabel"
#define CACHE_VOLUME_TITLE_VALUE        "VolumeTitle"
#define CACHE_PREFIX_TYPE               REG_SZ
#define NEW_DIR                         TEXT("NewDirectory")
#define USER_PROFILE_SZ                 "%USERPROFILE%"
#define USER_PROFILE_LEN                (sizeof(USER_PROFILE_SZ) - 1)

// URL_CONTAINER related defines.
#define DEF_NUM_PATHS                   4
#define DEF_CACHE_LIMIT                 (2048 * DEF_NUM_PATHS)
#define NO_SPECIAL_CONTAINER            0xffffffff
#define MAX_ENTRY_SIZE                  0xFFFF
#define LONGLONG_TO_FILETIME( _p_ )     ((FILETIME *)(_p_))

// Content limit defines.
#define OLD_CONTENT_QUOTA_DEFAULT_DISK_FRACTION      64
#define NEW_CONTENT_QUOTA_DEFAULT_DISK_FRACTION      32
#define CONTENT_QUOTA_ADJUST_CHECK                   "QuotaAdjustCheck"

// CD Container related defines.
#define INTERNET_CACHE_CONTAINER_PREFIXMAP INTERNET_CACHE_CONTAINER_RESERVED1
#define MAX_FILE_SIZE_TO_MIGRATE  50000
#define MAX_EXTENSION_LEN        3


// FileMgr related defines.
#define DEFAULT_DIR_TABLE_GROW_SIZE     4
#define DEFAULT_MAX_DIRS                32
#define MAX_FILES_PER_CACHE_DIRECTORY   1024
#define MAX_COLLISSION_ATTEMPTS         150
#define INSTALLED_DIRECTORY_KEY         0xFF
#define NOT_A_CACHE_SUBDIRECTORY        0XFE

#ifdef CHECKLOCK_PARANOID
void CheckEnterCritical(CRITICAL_SECTION *_cs);
void CheckLeaveCritical(CRITICAL_SECTION *_cs);
#define ENTERCRITICAL CheckEnterCritical
#define LEAVECRITICAL CheckLeaveCritical
#else
#define ENTERCRITICAL EnterCriticalSection
#define LEAVECRITICAL LeaveCriticalSection
#endif

// Cache global variable lock -- this should not be entered while holding
// lower-level locks like URL_CONTAINER::LockContainer cross-process mutex.
#define LOCK_CACHE()                    ENTERCRITICAL( &GlobalCacheCritSect )
#define UNLOCK_CACHE()                  LEAVECRITICAL( &GlobalCacheCritSect )

//
// parameter check macros.
//

#define IsBadUrl( _x_ )               IsBadStringPtrA( _x_, (DWORD) -1)
#define IsBadUrlW( _x_ )              IsBadStringPtrW( _x_, (DWORD) -1)
#define IsBadReadFileName( _x_ )      IsBadStringPtr( _x_, MAX_PATH )
#define IsBadWriteFileName( _x_ )     IsBadWritePtr( (PVOID)_x_, MAX_PATH)
#define IsBadWriteBoolPtr( _x_ )      IsBadWritePtr( _x_, sizeof(BOOL))
#define IsBadReadUrlInfo( _x_ )       IsBadReadPtr( _x_, sizeof(CACHE_ENTRY_INFO))
#define IsBadWriteUrlInfo( _x_, _y_ ) IsBadWritePtr( _x_, _y_ )

#define MAX_URL_ENTRIES                 (BIT_MAP_ARRAY_SIZE * sizeof(DWORD) * 8)

#define OFFSET_TO_POINTER( _ep_, _offset_) \
    (LPVOID)((LPBYTE)(_ep_) + (_offset_))


#define FIND_FLAGS_OLD_SEMANTICS                0x1
#define FIND_FLAGS_RETRIEVE_ONLY_STRUCT_INFO    0x2
#define FIND_FLAGS_RETRIEVE_ONLY_FIXED_AND_FILENAME 0x04

//---------------- BUGBUG : for History Only -------------------------------
#define MAX_FILETIME   0x7fffffffffffffff
#define MAX_DOSTIME    -1
//---------------- END BUGBUG ----------------------------------------------


//
// ----------------- Allocation entry header -----------------------------//
//

#define SIG_FREE   0xbadf00d
#define SIG_ALLOC  0xdeadbeef

#define SIG_URL         ' LRU'   // URL_FILEMAP_ENTRY
#define SIG_REDIR       'RDER'   // REDR_FILEMAP_ENTRY
#define SIG_LEAK        'KAEL'   // URL_FILEMAP_ENTRY
#define SIG_GLIST       'GLST'   // LIST_GROUP_ENTRY

// signatures for entries placed on fixup list
#define SIG_UPDATE      ' DPU'   // URL_FILEMAP_ENTRY
#define SIG_DELETE      ' LED'   // URL_FILEMAP_ENTRY

enum MemMapStatus
{
    MEMMAP_STATUS_OPENED_EXISTING = 0,
    MEMMAP_STATUS_REINITIALIZED = 1
};

typedef struct FILEMAP_ENTRY
{
    DWORD dwSig;
    DWORD nBlocks;
}
    *LPFILEMAP_ENTRY;

struct LIST_FILEMAP_ENTRY : FILEMAP_ENTRY
{
    DWORD dwNext; // offset to next element in list
    DWORD nBlock; // sequence number for this block
};

//
// URL entry
//

struct IE5_URL_FILEMAP_ENTRY : FILEMAP_ENTRY
{
    LONGLONG LastModifiedTime;       // must be LONGLONG
    LONGLONG LastAccessedTime;       // should be DWORD
    DWORD    dostExpireTime;
    DWORD    dostPostCheckTime;

    DWORD    dwFileSize;
    DWORD    dwRedirHashItemOffset;  // ask DanpoZ

    DWORD    dwGroupOffset;

    union
    {
        DWORD  dwExemptDelta;   // for SIG_URL
        DWORD  dwNextLeak;      // for SIG_LEAK
    };
    
    DWORD    CopySize;               // should be WORD
    DWORD    UrlNameOffset;          // should be WORD
    
    BYTE     DirIndex;           // subdirectory bucket
    BYTE     bSyncState;         // automatic sync mode state
    BYTE     bVerCreate;         // cache version that created this entry
    BYTE     bVerUpdate;         // cache version last updated this entry (unused)
        
    DWORD    InternalFileNameOffset; // should be WORD
    DWORD    CacheEntryType;
    DWORD    HeaderInfoOffset;       // should be WORD
    DWORD    HeaderInfoSize;         // should be WORD
    DWORD    FileExtensionOffset;    // should be WORD
    DWORD    dostLastSyncTime;       
    DWORD    NumAccessed;            // should be WORD
    DWORD    NumReferences;          // should be WORD
    DWORD    dostFileCreationTime;   // should be LONGLONG?

// Do not extend this structure; use inheritance instead.
};

struct IE6_URL_FILEMAP_ENTRY : IE5_URL_FILEMAP_ENTRY 
{
    DWORD   dwIdentity;

    DWORD GetIdentity()
    {
        return (bVerCreate>=ENTRY_VERSION_IE6) ? dwIdentity : 0;
    }
};

typedef IE6_URL_FILEMAP_ENTRY URL_FILEMAP_ENTRY, *LPURL_FILEMAP_ENTRY;

// FILETIME is measured in 100-ns units.
#define FILETIME_SEC    ((LONGLONG) 10000000)
#define FILETIME_DAY    (FILETIME_SEC * 60 * 60 * 24)

// Possible values for bSyncState:
#define SYNCSTATE_VOLATILE   0 // once zero, stuck at zero
#define SYNCSTATE_IMAGE      1 // eligible to increment after MIN_AGESYNC
#define SYNCSTATE_STATIC     6 // max value

// Parameters controlling transition from _IMAGE to _VOLATILE.
// #define MIN_AGESYNC  ((LONGLONG) 5 * 60 * 10000000)  // 5 min in filetime
#define MIN_AGESYNC     (FILETIME_DAY * 7)

//
// Redirect Entry
//

struct REDIR_FILEMAP_ENTRY : FILEMAP_ENTRY
{
    DWORD dwItemOffset;  // offset to hash table item of destination URL
    DWORD dwHashValue;   // destination URL hash value (BUGBUG: collisions?)
    char  szUrl[4];      // original URL, can occupy more bytes
};

//
// Group Record
//

typedef struct GROUP_ENTRY
{
    GROUPID  gid;
    DWORD    dwGroupFlags;
    DWORD    dwGroupType;
    LONGLONG llDiskUsage;       // in Bytes (Actual Usage)
    DWORD    dwDiskQuota;       // in KB
    DWORD    dwGroupNameOffset;
    DWORD    dwGroupStorageOffset;
}
    *LPGROUP_ENTRY;


#define PAGE_SIZE_FOR_GROUPS    (PAGE_SIZE - sizeof(FILEMAP_ENTRY))
#define GROUPS_PER_PAGE         PAGE_SIZE_FOR_GROUPS / sizeof(GROUP_ENTRY)

typedef struct _GROUP_DATA_ENTRY
{
    CHAR    szName[GROUPNAME_MAX_LENGTH];
    DWORD   dwOwnerStorage[GROUP_OWNER_STORAGE_SIZE];
    DWORD   dwOffsetNext;
} GROUP_DATA_ENTRY, *LPGROUP_DATA_ENTRY;

#define GROUPS_DATA_PER_PAGE    PAGE_SIZE_FOR_GROUPS / sizeof(GROUP_DATA_ENTRY)

//
// so the sizeof(GROUPS_PAGE_FILEMAP_ENTRY) = PAGE_SIZE
// this is the allocation unit for groups entry
//
typedef struct _GROUPS_ALLOC_FILEMAP_ENTRY : FILEMAP_ENTRY
{
    BYTE    pGroupBlock[PAGE_SIZE_FOR_GROUPS];    
} GROUPS_ALLOC_FILEMAP_ENTRY, *LPGROUPS_ALLOC_FILEMAP_ENTRY;


typedef struct _LIST_GROUP_ENTRY 
{
    DWORD   dwGroupOffset;
    DWORD   dwNext;

} LIST_GROUP_ENTRY, *LPLIST_GROUP_ENTRY;

#define LIST_GROUPS_PER_PAGE    PAGE_SIZE_FOR_GROUPS / sizeof(LIST_GROUP_ENTRY)


#define SIGNATURE_CONTAINER_FIND 0xFAFAFAFA
#define SIG_CACHE_FIND 0XFBFBFBFB
#define SIG_GROUP_FIND 0XFCFCFCFC

typedef struct _CONTAINER_FIND_FIRST_HANDLE 
{
    DWORD dwSignature;
    DWORD dwNumContainers;
    DWORD dwContainer;
    LPSTR *ppNames;
    LPSTR *ppPrefixes;
    LPSTR *ppLabels;
    LPSTR *ppTitles;
    // DATA follows for Names, Prefixes, Volume labels and Volume titles.
} CONTAINER_FIND_FIRST_HANDLE, *LPCONTAINER_FIND_FIRST_HANDLE;

typedef struct _CACHE_FIND_FIRST_HANDLE 
{
    DWORD dwSig;
    BOOL  fFixed;
    DWORD nIdx;
    DWORD dwHandle;
    GROUPID GroupId;
    DWORD dwFilter;
    DWORD dwFlags;
} CACHE_FIND_FIRST_HANDLE, *LPCACHE_FIND_FIRST_HANDLE;

typedef struct _CACHE_STREAM_CONTEXT_HANDLE 
{
    HANDLE FileHandle;
    LPSTR SourceUrlName;
}  CACHE_STREAM_CONTEXT_HANDLE, *LPCACHE_STREAM_CONTEXT_HANDLE;

typedef struct _GROUP_FIND_FIRST_HANDLE : CACHE_FIND_FIRST_HANDLE
{
    DWORD dwLastItemOffset;
} GROUP_FIND_FIRST_HANDLE, *LPGROUP_FIND_FIRST_HANDLE;

#define OFFSET_NO_MORE_GROUP    -1
#define GID_INDEX_TO_NEXT_PAGE	-1
#define OFFSET_TO_NEXT_PAGE     -1

#define GID_MASK            0x0fffffffffffffff
#define GID_STICKY_BIT      0x1000000000000000

#define IsStickyGroup(gid)  (gid & GID_STICKY_BIT)
#define SetStickyBit(gid)   (gid | GID_STICKY_BIT)
#define IsInvalidGroup(gid) (gid & 0xE000000000000000)

//
// RealFileSize() - given the actual filesize,
// this macro computes the approximate real space that a file takes up
// on the disk. It only takes care of rounding to the cluster size
// It doesn't take into account any per-file overhead used in the filesystem
//

#define RealFileSize(fs)  ((LONGLONG) (fs + _ClusterSizeMinusOne) & _ClusterSizeMask)

#define MUTEX_DBG_TIMEOUT   5 * 1000    // 5 secs.

#define URLCACHE_OP_SET_STICKY   1
#define URLCACHE_OP_UNSET_STICKY 2

#ifdef unix
extern BOOL CreateAtomicCacheLockFile(BOOL *pfReadOnlyCaches, char **pszLockingHost);
extern BOOL DeleteAtomicCacheLockFile();
extern void UnixNormalisePath(LPTSTR pszOrigPath, LPCTSTR pszEnvVar);
extern void UnixNormaliseIfCachePath(LPTSTR pszOrigPath, LPCTSTR pszEnvVar,LPCTSTR szKeyName);
extern int  CopyDir(const char* src_dir, const char* dest_dir);
#endif /* unix */

extern VOID FileTime2DosTime(FILETIME, DWORD*);
extern VOID DosTime2FileTime(DWORD, FILETIME*);

#endif  // _CACHEDEF_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\urlcache\cachglob.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    cachglob.h

Abstract:

    contains global data declerations.

Author:

    Madan Appiah (madana)  12-Apr-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _GLOBAL_
#define _GLOBAL_

#ifdef __cplusplus
extern "C" {
#endif

// Prototype for async fixup callback.
typedef DWORD (CALLBACK* PFN_FIXUP) 
(
    DWORD   dwVer,      // version of cache
    LPSTR   pszPath,    // directory containing index file
    LPSTR   pszPrefix,  // protocol prefix
    BOOL*   pfDetach,   // ptr. to global indicating dll shutdown
    DWORD   dwFactor,   // as passed to CleanupUrls
    DWORD   dwFilter,   // as passed to CleanupUrls
    LPVOID  lpvReserved // reserved: pass null
);

//
// global variables.
//

extern CRITICAL_SECTION GlobalCacheCritSect;


extern BOOL GlobalCacheInitialized;
extern CConMgr *GlobalUrlContainers;
#define GlobalMapFileGrowSize (PAGE_SIZE * ALLOC_PAGES)
extern LONG GlobalScavengerRunning;
extern MEMORY *CacheHeap;
extern HNDLMGR HandleMgr;
extern DWORD GlobalRetrieveUrlCacheEntryFileCount;

// globals for async fixup handler
extern char       g_szFixup[sizeof(DWORD)];
                                 // regkey to lookup fixup dll,entry point
extern HINSTANCE  g_hFixup;      // dll containing fixup handler
extern PFN_FIXUP  g_pfnFixup;    // entry point of fixup handler


#ifdef unix
extern BOOL g_ReadOnlyCaches;
extern char* gszLockingHost;
#endif /* unix */


// -- from wininet\inc\globals.h 
extern BOOL vfPerUserCookies;

BOOL GetWininetUserName(VOID);
// BUGBUG: GetWininetUserName must be called before accessing vszCurrentUser.
// Instead, it should return the username ptr and the global not accessed.
extern char vszCurrentUser[];
extern DWORD vdwCurrentUserLen;

extern const char vszPerUserCookies[];

// --- from wininet\inetui\inetp.h
BOOL
GetCurrentSettingsVersion(
    LPDWORD lpdwVer
    );

BOOL
IncrementCurrentSettingsVersion(
    LPDWORD lpdwVer
    );

extern DWORD GlobalDiskUsageLowerBound;
extern DWORD GlobalScavengeFileLifeTime;

extern BOOL GlobalPleaseQuitWhatYouAreDoing;
extern DWORD  GlobalSettingsVersion;
extern BOOL   GlobalSettingsLoaded;
extern const char   vszInvalidFilenameChars[];


char *
StrTokExA(
    IN OUT char ** pstring, 
    IN const char * control);



#ifdef __cplusplus
}
#endif

#endif  // _GLOBAL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\urlcache\cachglob.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    cachglob.cxx

Abstract:

    contains global variables and functions of urlcache

Author:

    Madan Appiah (madana)  12-Dec-1994

Environment:

    User Mode - Win32

Revision History:

--*/

#include <wininetp.h>
#include <cache.hxx>


// Typedef for GetFileAttributeEx function
typedef BOOL (WINAPI *PFNGETFILEATTREX)(LPCTSTR, GET_FILEEX_INFO_LEVELS, LPVOID);
#ifdef unix
#include <flock.hxx>
#endif /* unix */

//
// global variables definition.
//
// from wininet\dll\globals.cxx
GLOBAL LONGLONG dwdwHttpDefaultExpiryDelta = 12 * 60 * 60 * (LONGLONG)10000000;  // 12 hours in 100ns units
GLOBAL LONGLONG dwdwSessionStartTime;       // initialized in InitGlob() in urlcache
GLOBAL LONGLONG dwdwSessionStartTimeDefaultDelta = 0;


// from wininet\dll\Dllentry.cxx
CRITICAL_SECTION GlobalCacheCritSect;
BOOL GlobalCacheInitialized = FALSE;
CConMgr *GlobalUrlContainers = NULL;
LONG GlobalScavengerRunning = -1;
DWORD GlobalRetrieveUrlCacheEntryFileCount = 0;
PFNGETFILEATTREX gpfnGetFileAttributesEx = 0;

char       g_szFixup[sizeof(DWORD)];
HINSTANCE  g_hFixup;
PFN_FIXUP  g_pfnFixup;

MEMORY *CacheHeap = NULL;
HNDLMGR HandleMgr;

GLOBAL DWORD GlobalDiskUsageLowerBound = (4*1024*1024);
GLOBAL DWORD GlobalScavengeFileLifeTime = (10*60);

GLOBAL BOOL GlobalPleaseQuitWhatYouAreDoing = FALSE;

// Identity-related globals
GLOBAL DWORD GlobalIdentity = 0;
GLOBAL GUID  GlobalIdentityGuid = { 0x00000000L, 0x0000, 0x0000, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
GLOBAL BOOL GlobalSuppressCookiesPolicy = FALSE;
#ifdef WININET6
GLOBAL HKEY GlobalCacheHKey = HKEY_CURRENT_USER;
#endif

// shfolder.dll hmod handle
HMODULE g_HMODSHFolder = NULL;
// Shell32.dll hmod handle
HMODULE g_HMODShell32 = NULL;


// GLOBAL SECURITY_CACHE_LIST GlobalCertCache;

GLOBAL DWORD GlobalSettingsVersion=0; // crossprocess settings versionstamp
GLOBAL BOOL GlobalSettingsLoaded = FALSE;

GLOBAL const char vszDisableSslCaching[] = "DisableCachingOfSSLPages";

GLOBAL char vszCurrentUser[MAX_PATH];
GLOBAL DWORD vdwCurrentUserLen = 0;


// cookies info

GLOBAL BOOL vfPerUserCookies = TRUE;
const char  vszAnyUserName[]="anyuser";
const char  vszPerUserCookies[] = "PerUserCookies";
const char  vszInvalidFilenameChars[] = "<>\\\"/:|?*";


#ifdef unix
/***********************
 * ReadOnlyCache on Unix
 * *********************
 * When the cache resides on a file system which is shared over NFS
 * and the user can access the same cache from different work-stations,
 * it causes a problem. The fix is made so that, the first process has
 * write access to the cache and any subsequent browser process which
 * is started from a different host will receive a read-only version
 * of the cache and will not be able to get cookies etc. A symbolic
 * link is created in $HOME/.microsoft named ielock. Creation and
 * deletion of this symbolic link should be atomic. The functions
 * CreateAtomicCacheLockFile and DeleteAtomicCacheLockFile implement
 * this behavior. When a readonly cache is used, cache deletion is
 * not allowed (Scavenger thread need not be launched).
 *
 * g_ReadOnlyCaches denotes if a readonly cache is being used.
 * gszLockingHost denotes the host that holds the cache lock.
 */

BOOL g_ReadOnlyCaches = FALSE;
char *gszLockingHost = 0;

extern "C" void unixGetWininetCacheLockStatus(BOOL *pBool, char **pszLockingHost)
{
    if(pBool)
        *pBool = g_ReadOnlyCaches;
    if(pszLockingHost)
        *pszLockingHost = gszLockingHost;
}
#endif /* unix */

#ifdef CHECKLOCK_PARANOID

//  Code to enforce strict ordering on resources to prevent deadlock
//  One cannot attempt to take the critical section for the first time
//  if one holds a container lock
DWORD dwThreadLocked;
DWORD dwLockLevel;

void CheckEnterCritical(CRITICAL_SECTION *_cs)
{
    EnterCriticalSection(_cs);
    if (_cs == &GlobalCacheCritSect && dwLockLevel++ == 0)
    {
        dwThreadLocked = GetCurrentThreadId();
        if (GlobalUrlContainers) GlobalUrlContainers->CheckNoLocks(dwThreadLocked);
    }
}

void CheckLeaveCritical(CRITICAL_SECTION *_cs)
{
    if (_cs == &GlobalCacheCritSect)
    {
        INET_ASSERT(dwLockLevel);
        if (dwLockLevel == 1)
        {
            if (GlobalUrlContainers) GlobalUrlContainers->CheckNoLocks(dwThreadLocked);
            dwThreadLocked = 0;
        }
        dwLockLevel--;
    }
    LeaveCriticalSection(_cs);
}
#endif

//

/*++

--*/

BOOL InitGlobals (void)
{
    if (GlobalCacheInitialized)
        return TRUE;

    LOCK_CACHE();

    if (GlobalCacheInitialized)
        goto done;

    GetWininetUserName();

    // Read registry settings.
    OpenInternetSettingsKey();

    { // Detect a fixup handler.  Open scope to avoid compiler complaint.
    
        REGISTRY_OBJ roCache (HKEY_LOCAL_MACHINE, OLD_CACHE_KEY);

        if (ERROR_SUCCESS == roCache.GetStatus())
        {
            DWORD cbFixup = sizeof(g_szFixup);
            if (ERROR_SUCCESS != roCache.GetValue
                ("FixupKey", (LPBYTE) g_szFixup, &cbFixup))
            {
                g_szFixup[0] = 0;
            }

            if (g_szFixup[0] != 'V' || g_szFixup[3] != 0)
            {
                g_szFixup[0] = 0;
            }                  
        }
    }
    
    /*
    {
        REGISTRY_OBJ roCache (HKEY_LOCAL_MACHINE, CACHE5_KEY);
        if (ERROR_SUCCESS == roCache.GetStatus())
        {
            DWORD dwDefTime;
            if (ERROR_SUCCESS == roCache.GetValue("SessionStartTimeDefaultDeltaSecs", &dwDefTime))
            {
                dwdwSessionStartTimeDefaultDelta = dwDefTime * (LONGLONG)10000000;
                dwdwSessionStartTime -= dwdwSessionStartTimeDefaultDelta;
            }
        }
    }
    */
        
    // Seed the random number generator for random file name generation.
    srand(GetTickCount());

    GetCurrentGmtTime((LPFILETIME)&dwdwSessionStartTime);

    GlobalUrlContainers = new CConMgr();
    GlobalCacheInitialized =
        GlobalUrlContainers && (GlobalUrlContainers->GetStatus() == ERROR_SUCCESS);

    if( GlobalCacheInitialized )
    {
        DWORD dwError = GlobalUrlContainers->CreateDefaultGroups();
        INET_ASSERT(dwError == ERROR_SUCCESS);
    }
    else
    {
        delete GlobalUrlContainers;
        GlobalUrlContainers = NULL;
    }

done:
    UNLOCK_CACHE();
    return GlobalCacheInitialized;
}


URLCACHEAPI
BOOL
WINAPI
DLLUrlCacheEntry(
    IN DWORD Reason
    )
/*++

Routine Description:

    Performs global initialization and termination for all protocol modules.

    This function only handles process attach and detach which are required for
    global initialization and termination, respectively. We disable thread
    attach and detach. New threads calling Wininet APIs will get an
    INTERNET_THREAD_INFO structure created for them by the first API requiring
    this structure

Arguments:

    DllHandle   - handle of this DLL. Unused

    Reason      - process attach/detach or thread attach/detach

    Reserved    - if DLL_PROCESS_ATTACH, NULL means DLL is being dynamically
                  loaded, else static. For DLL_PROCESS_DETACH, NULL means DLL
                  is being freed as a consequence of call to FreeLibrary()
                  else the DLL is being freed as part of process termination

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Failed to initialize

--*/
{
    HMODULE ModuleHandleKernel;

    switch (Reason)
    {
        case DLL_PROCESS_ATTACH:
#ifdef CHECKLOCK_PARANOID
            dwThreadLocked = 0;
            dwLockLevel = 0;
#endif
            ModuleHandleKernel = GetModuleHandle("KERNEL32");
            if (ModuleHandleKernel)
            {
                gpfnGetFileAttributesEx = (PFNGETFILEATTREX)
                    GetProcAddress(ModuleHandleKernel, "GetFileAttributesExA");
            }

            InitializeCriticalSection (&GlobalCacheCritSect);
            
            // RunOnceUrlCache (NULL, NULL, NULL, 0); // test stub
#ifdef unix
            if(CreateAtomicCacheLockFile(&g_ReadOnlyCaches,&gszLockingHost) == FALSE)
                return FALSE;
#endif /* unix */
            break;

        case DLL_PROCESS_DETACH:

            // Clean up containers list.
            if (GlobalUrlContainers != NULL)
            {
                delete GlobalUrlContainers;
                GlobalUrlContainers = NULL;
            }
            
            // Unload fixup handler.
            if (g_hFixup)
                FreeLibrary (g_hFixup);
                
            HandleMgr.Destroy();
            
#ifdef unix
        DeleteAtomicCacheLockFile();
#endif /* unix */
        DeleteCriticalSection (&GlobalCacheCritSect);

        break;
    }

    return TRUE;
}




//
// proxy info
//

// GLOBAL PROXY_INFO_GLOBAL GlobalProxyInfo;

//
// DLL version info
//
/*
GLOBAL INTERNET_VERSION_INFO InternetVersionInfo = {
    WININET_MAJOR_VERSION,
    WININET_MINOR_VERSION
};
*/
//
// HTTP version info - default 1.0
//

// GLOBAL HTTP_VERSION_INFO HttpVersionInfo = {1, 0};
BOOL
PrintFileTimeInInternetFormat(
    FILETIME *lpft,
    LPSTR lpszBuff,
    DWORD   dwSize
)
{
    SYSTEMTIME sSysTime;

    if (dwSize < INTERNET_RFC1123_BUFSIZE) {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return (FALSE);
    }
    if (!FileTimeToSystemTime(((CONST FILETIME *)lpft), &sSysTime)) {
        return (FALSE);
    }
    return (InternetTimeFromSystemTime( &sSysTime,
                                        lpszBuff));

}


BOOL
GetWininetUserName(
    VOID
)
{
    BOOL fRet = FALSE;
    DWORD dwT;
    CHAR *ptr;

    // Note this critsect could be blocked for a while if RPC gets involved...
    // EnterCriticalSection(&GeneralInitCritSec);

    if (vdwCurrentUserLen) {
        fRet = TRUE;
        goto Done;
    }

    dwT = sizeof(vszCurrentUser);

    if (vfPerUserCookies) {

        fRet = GetUserName(vszCurrentUser, &dwT);

        if (!fRet) {

            DEBUG_PRINT(HTTP,
                        ERROR,
                        ("GetUsername returns %d\n",
                        GetLastError()
                        ));
        }

    }

    if (fRet == FALSE){

        strcpy(vszCurrentUser, vszAnyUserName);

        fRet = TRUE;
    }

    // Downcase the username.
    ptr = vszCurrentUser;
    while (*ptr)
    {
        *ptr = tolower(*ptr);
        ptr++;
    }

    INET_ASSERT(fRet == TRUE);

    vdwCurrentUserLen = (DWORD) (ptr - vszCurrentUser);


Done:
    // LeaveCriticalSection(&GeneralInitCritSec);
    return (fRet);
}




/***
*char *StrTokEx(pstring, control) - tokenize string with delimiter in control
*
*Purpose:
*       StrTokEx considers the string to consist of a sequence of zero or more
*       text tokens separated by spans of one or more control chars. the first
*       call, with string specified, returns a pointer to the first char of the
*       first token, and will write a null char into pstring immediately
*       following the returned token. when no tokens remain
*       in pstring a NULL pointer is returned. remember the control chars with a
*       bit map, one bit per ascii char. the null char is always a control char.
*
*Entry:
*       char **pstring - ptr to ptr to string to tokenize
*       char *control - string of characters to use as delimiters
*
*Exit:
*       returns pointer to first token in string,
*       returns NULL when no more tokens remain.
*       pstring points to the beginning of the next token.
*
*WARNING!!!
*       upon exit, the first delimiter in the input string will be replaced with '\0'
*
*******************************************************************************/

char * StrTokExA (char ** pstring, const char * control)
{
        unsigned char *str;
        const unsigned char *ctrl = (const unsigned char *)control;
        unsigned char map[32];
        int count;

        char *tokenstr;

        if(*pstring == NULL)
            return NULL;
            
        /* Clear control map */
        for (count = 0; count < 32; count++)
                map[count] = 0;

        /* Set bits in delimiter table */
        do
        {
            map[*ctrl >> 3] |= (1 << (*ctrl & 7));
        } while (*ctrl++);

        /* Initialize str. */
        str = (unsigned char *)*pstring;
        
        /* Find beginning of token (skip over leading delimiters). Note that
         * there is no token if this loop sets str to point to the terminal
         * null (*str == '\0') */
        while ( (map[*str >> 3] & (1 << (*str & 7))) && *str )
            str++;

        tokenstr = (char *)str;

        /* Find the end of the token. If it is not the end of the string,
         * put a null there. */
        for ( ; *str ; str++ )
        {
            if ( map[*str >> 3] & (1 << (*str & 7)) ) 
            {
                *str++ = '\0';
                break;
            }
        }

        /* string now points to beginning of next token */
        *pstring = (char *)str;

        /* Determine if a token has been found. */
        if ( tokenstr == (char *)str )
            return NULL;
        else
            return tokenstr;
}

const char vszUserNameHeader[4] = "~U:";



// ---- from wininet\http\httptime.cxx

//
// external prototypes
//

/********************* Local data *******************************************/
/******************** HTTP date format strings ******************************/

// Month
static const char cszJan[]="Jan";
static const char cszFeb[]="Feb";
static const char cszMar[]="Mar";
static const char cszApr[]="Apr";
static const char cszMay[]="May";
static const char cszJun[]="Jun";
static const char cszJul[]="Jul";
static const char cszAug[]="Aug";
static const char cszSep[]="Sep";
static const char cszOct[]="Oct";
static const char cszNov[]="Nov";
static const char cszDec[]="Dec";

// DayOfWeek in rfc1123 or asctime format
static const char cszSun[]="Sun";
static const char cszMon[]="Mon";
static const char cszTue[]="Tue";
static const char cszWed[]="Wed";
static const char cszThu[]="Thu";
static const char cszFri[]="Fri";
static const char cszSat[]="Sat";

// List of weekdays for rfc1123 or asctime style date
static const char *rgszWkDay[7] =
   {
        cszSun,cszMon,cszTue,cszWed,cszThu,cszFri,cszSat
   };

// list of month strings for all date formats
static const char *rgszMon[12] =
   {
        cszJan,cszFeb,cszMar,cszApr,cszMay,cszJun,
        cszJul,cszAug,cszSep,cszOct,cszNov,cszDec
   };

/******************** HTTP date format strings ******************************/

/* Http date format: Sat, 29 Oct 1994 19:43:00 GMT */
const char cszHttpDateFmt[]="%s, %02i %s %02i %02i:%02i:%02i GMT";

/****************************************************************************/

INTERNETAPI
BOOL
WINAPI
InternetTimeFromSystemTimeA(
    IN  CONST SYSTEMTIME *pst,  // input GMT time
    IN  DWORD dwRFC,            // RFC format: must be FORMAT_RFC1123
    OUT LPSTR lpszTime,         // output string buffer
    IN  DWORD cbTime            // output buffer size
    )
/*++

Routine Description:

    Converts system time to a time string fromatted in the specified RFC format


Arguments:

    pst:    points to the SYSTEMTIME to be converted

    dwRFC:  RFC number of the format in which the result string should be returned

    lpszTime: buffer to return the string in

    cbTime: size of lpszTime buffer

Return Value:

    BOOL
        TRUE    - string converted

        FALSE   - couldn't convert string, GetLastError returns windows error code

--*/
{
    DEBUG_ENTER_API((DBG_API,
                     Handle,
                     "InternetTimeFromSystemTimeA",
                     "%#x, %d, %#x, %d",
                     pst,
                     dwRFC,
                     lpszTime,
                     cbTime
                     ));

    DWORD dwErr;
    BOOL fResult = FALSE;
    FILETIME ft;
    
    if (   dwRFC != INTERNET_RFC1123_FORMAT
        || IsBadReadPtr (pst, sizeof(*pst))
        || IsBadWritePtr (lpszTime, cbTime)
        || !SystemTimeToFileTime(pst, &ft)
       )
    {
        dwErr = ERROR_INVALID_PARAMETER;
    } 
    else if (cbTime < INTERNET_RFC1123_BUFSIZE)
    {
        dwErr = ERROR_INSUFFICIENT_BUFFER;
    }
    else
    {
        SYSTEMTIME st;
        
        if ((pst->wDay < 0)
            || (pst->wDay > 6))
        {
            // ST2FT ignores the week of the day; so if we round trip back,
            // it should place the correct week of the day.
            FileTimeToSystemTime(&ft, &st);
            pst = &st;
        }

        wsprintf (lpszTime, cszHttpDateFmt,
            rgszWkDay[pst->wDayOfWeek],
            pst->wDay,
            rgszMon[pst->wMonth-1],
            pst->wYear,
            pst->wHour,
            pst->wMinute,
            pst->wSecond);
        fResult = TRUE;
    }

    if (!fResult)
    {
        SetLastError(dwErr);
        DEBUG_ERROR(INET, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\urlcache\conlist.cxx ===
/*++
Copyright (c) 1997  Microsoft Corporation

Module Name:  conlist.cxx

Abstract:

    Linked list of URL_CONTAINERs
    
Author:
    Adriaan Canter (adriaanc) 04-02-97
    
--*/
#include <wininetp.h>
#include <cache.hxx>

/*------------------------ CConElem -----------------------------------------*/

/*-----------------------------------------------------------------------------
CConElem constructor
  ---------------------------------------------------------------------------*/
CConElem::CConElem(URL_CONTAINER* pUrlCon)
{
    _pUrlCon = pUrlCon;
    _pNext = NULL;
}

/*-----------------------------------------------------------------------------
CConElem destructor. Destructs URL_CONTAINER* member.
  ---------------------------------------------------------------------------*/
CConElem::~CConElem()
{
    delete _pUrlCon;
}


/*------------------------ CConList Private Functions------------------------*/


/*-----------------------------------------------------------------------------
CConList::Seek      Sets current pointer to element of index nElem.
  ---------------------------------------------------------------------------*/
BOOL CConList::Seek(DWORD nElem)
{   
    // Bad list or index too high.
    if (!_pHead || nElem > _n)
    {
        INET_ASSERT(FALSE);
        return FALSE;
    }

    // Seek to element from current.
    if (nElem > _nCur)        
    {
        while (_nCur < nElem)
        {
            _pCur = _pCur->_pNext;
            _nCur++;
        }
    }

//
// BUGBUG: VC5 optimizer assumes if (a < b), then (b > a), so check (a != b) instead
//
    else if (nElem != _nCur) // if (nElem < _nCur)
    {
        // Seek to element from head.
        _nCur = 0;
        _pCur = _pHead;
        while (_nCur < nElem)
        {
            _pCur = _pCur->_pNext;
            _nCur++;
        }
    }

    INET_ASSERT(_nCur != 0 || (_pCur == _pHead));

    return TRUE;
}


/*------------------------ CConList Public Functions------------------------*/


/*-----------------------------------------------------------------------------
CConList constructor.
  ---------------------------------------------------------------------------*/
CConList::CConList()
: _n(0), _nCur(0), _pCur(NULL), _pHead(NULL)
{
}

/*-----------------------------------------------------------------------------
CConList destructor.
  ---------------------------------------------------------------------------*/
CConList::~CConList()
{
}

/*-----------------------------------------------------------------------------
CConList::Size      Returns number of elements in list.
  ---------------------------------------------------------------------------*/
DWORD CConList::Size()
// THIS FUNCTION MUST BE CALLED WITH THE CACHE CRIT SEC
{
    DWORD n = (_pHead ? _n+1 : 0);
    return n;
}

/*-----------------------------------------------------------------------------
CConList::Free      Removes and destructs each element in list.
  ---------------------------------------------------------------------------*/
BOOL CConList::Free()
{
    LOCK_CACHE();

    DWORD i = Size();

    //  Delete CONTENT last, as we reference fields of it's header (dwChangeCount)
    //  in destructors of extensible containers
    while (i)
    {
        Remove(--i);
    }
    UNLOCK_CACHE();
    return TRUE;
}


/*-----------------------------------------------------------------------------
CConList::Add      Appends new element to list.
  ---------------------------------------------------------------------------*/
BOOL CConList::Add(URL_CONTAINER * pUrlCon)
{
    LOCK_CACHE();
    BOOL bSuccess = FALSE;
    CConElem *pNew;
    DWORD i;
    
    // Bad pointer.
    if (!pUrlCon)
    {
        INET_ASSERT(FALSE);
        goto exit;        
    }

    if (_pHead)
    {
        //  try to reuse a Container which has been deleted
        for (i = 0; i <= _n; i++)
        {
            if (Seek(i))
            {
                if (_pCur->_pUrlCon->GetDeleted())
                {
                    delete _pCur->_pUrlCon;
                    _pCur->_pUrlCon = pUrlCon;
                    bSuccess = TRUE;
                    goto exit;
                }
            }
        }
    }

    // Construct new element.
    pNew = new CConElem(pUrlCon);

    if (!pNew)
    {
        INET_ASSERT(FALSE);
        goto exit;
    }

    // If valid list, seek to last element and add element.
    if (_pHead)
    {
        if (_n == LARGEST_INDEX)
        {
            delete pNew;
            INET_ASSERT(FALSE);
            goto exit;        
        }
        Seek(_n);
        _pCur->_pNext = pNew;
        pNew->_pNext = _pHead;
        _n++;
    }
    // If empty list, set head and current to new element.
    else
    {
        _pHead = _pCur = pNew;
        pNew->_pNext = _pHead;
        _n = _nCur = 0;
    }
    
    bSuccess = TRUE;
exit:
    
    UNLOCK_CACHE();
    return bSuccess;
}

/*-----------------------------------------------------------------------------
CConList::Remove      Removes nElem'th element from list.
  ---------------------------------------------------------------------------*/
BOOL CConList::Remove(DWORD nElem)
// THIS FUNCTION MUST BE CALLED WITH THE CACHE CRIT SEC
{
    DWORD     nPrev;
    CConElem *pElem;
    BOOL bSuccess = FALSE;

    // Empty list or index too high.
    if (!_pHead || nElem > _n)
    {
        INET_ASSERT(FALSE);
        goto exit;
    }

    // Seek to previous element, or last if removing head.
    nPrev = (nElem == 0 ? _n : nElem - 1);
    Seek(nPrev);

    // Save pointer to element, update prevous' next pointer.
    pElem = _pCur->_pNext;
    _pCur->_pNext = _pCur->_pNext->_pNext;

    // Update head if necessary.
    if (nElem == 0)
        _pHead = _pHead->_pNext;

    // Decrement index of last, zero out values if empty.
    if (_n > 0)
        _n--;
    else
    {
        _pHead = _pCur = NULL;
        _n = _nCur = 0;
    }    
    
    // Destruct element.
    delete pElem;
    
    bSuccess = TRUE;
exit:
    return bSuccess;
}

/*-----------------------------------------------------------------------------
CConList::operator Get Returns Addref'ed reference to URL_CONTAINER* of index nElem.
  ---------------------------------------------------------------------------*/
// THIS FUNCTION MUST BE CALLED WITH THE CACHE CRIT SEC
URL_CONTAINER* CConList::Get (DWORD nElem)
{
    URL_CONTAINER* pUrlCon;
    if (Seek(nElem))
        pUrlCon = _pCur->_pUrlCon;
    else
        pUrlCon = NULL;
        
    if (pUrlCon) pUrlCon->AddRef();
    return pUrlCon;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\urlcache\conmgr.cxx ===
/*++
Copyright (c) 1997  Microsoft Corporation

Module Name:  conmgr.cxx

Abstract:

    Manages list of containers (CConList)

Author:
    Adriaan Canter (adriaanc) 04-02-97

--*/
#include <wininetp.h>
#include <cache.hxx>

#define FAILSAFE_TIMEOUT (60000)

/*---------------------  Private Functions -----------------------------------*/
/*-----------------------------------------------------------------------------
DWORD CConMgr::Init
----------------------------------------------------------------------------*/
DWORD CConMgr::Init()
{
    DWORD dwError = ConfigureCache();

    if (dwError==ERROR_SUCCESS)
    {
        // Get the extensible cache config info.
        // These containers are delay-initialized.
        dwError = GetExtensibleCacheConfigInfo(TRUE);
    }
    else
    {
        INET_ASSERT(FALSE);
    }
    return dwError;

}

#ifdef CHECKLOCK_PARANOID
void CConMgr::CheckNoLocks(DWORD dwThreadId)
{
    URL_CONTAINER *co;
    DWORD idx;

    LOCK_CACHE();
    for (idx = 0; idx < ConList.Size(); idx++)
    {
        URL_CONTAINER *co;

        co = ConList.Get(idx);
        if (co)
        {
            co->CheckNoLocks(dwThreadId);
            co->Release(FALSE);
        }
    }
    UNLOCK_CACHE();
}
#endif

/*-----------------------------------------------------------------------------
BOOL CConMgr::WasModified
----------------------------------------------------------------------------*/
BOOL CConMgr::WasModified(BOOL fUpdateMemory)
{
    DWORD dwOldCount = _dwModifiedCount;
    return dwOldCount != ReadModifiedCount(fUpdateMemory);
}

/*-----------------------------------------------------------------------------
DWORD CConMgr::ReadModifiedCount
----------------------------------------------------------------------------*/
DWORD CConMgr::ReadModifiedCount(BOOL fUpdateMemory)
{
    DWORD dwChangeCount;
    DWORD *pdwChangeCount = fUpdateMemory ? &_dwModifiedCount : &dwChangeCount;

    _coContent->GetHeaderData(CACHE_HEADER_DATA_CONLIST_CHANGE_COUNT,
                             pdwChangeCount);
    return *pdwChangeCount;
}

/*-----------------------------------------------------------------------------
DWORD CConMgr::IncrementModifiedCount
----------------------------------------------------------------------------*/
void CConMgr::IncrementModifiedCount()
{
    DWORD dwLocModified;

    _coContent->IncrementHeaderData(CACHE_HEADER_DATA_CONLIST_CHANGE_COUNT,
                                   &dwLocModified);
}

/*-----------------------------------------------------------------------------
DWORD CConMgr::InitFixedContainers
----------------------------------------------------------------------------*/
DWORD CConMgr::InitFixedContainers()
{
    DWORD idx;
    DWORD dwError = ERROR_SUCCESS;
    BOOL fInitSucceeded = TRUE;

    //  Create and init
    _hMutexExtensible = OpenMutex(SYNCHRONIZE, FALSE, TEXT("_!MSFTHISTORY!_"));
    if (_hMutexExtensible == NULL && (GetLastError() == ERROR_FILE_NOT_FOUND || GetLastError() == ERROR_INVALID_NAME))
    {
        _hMutexExtensible = CreateMutex(CreateAllAccessSecurityAttributes(NULL, NULL, NULL), FALSE, TEXT("_!MSFTHISTORY!_"));
    }
    if (_hMutexExtensible == NULL)
    {
        dwError = GetLastError();
        fInitSucceeded = FALSE;
        goto exit;
    }
    _dwLastUnmap = GetTickCountWrap();

    LOCK_CACHE();
    // Containers are configured. Attempt to initialize.
    for (idx = CONTENT; idx < ConList.Size(); idx++)
    {
        URL_CONTAINER *co;

        co = ConList.Get(idx);
        if (co)
        {
            dwError = co->Init();

            // NOTE - URL_CONTAINER::Init() returns ERROR_ALREADY_EXISTS
            // only if the the existing memory mapped file has been opened
            // successfully. If the memory mapped file was created, upgraded
            // or corrupted (in both cases the mem mapped file will be reinited)
            // the return value will be ERROR_SUCCESS.

            if(dwError != ERROR_SUCCESS && dwError != ERROR_ALREADY_EXISTS)
            {
                fInitSucceeded = FALSE;
                goto unlock_exit;
            }

            // Has the container been created, upgrade or corrupted?
            if (dwError == ERROR_SUCCESS)
            {
                if(idx==CONTENT)
                {
                    // Preload the content container.
                    LoadContent();
                }
                else if (idx==COOKIE)
                {
                    CCookieLoader cl;
                    cl.LoadCookies(co);
                }
            }
            co->Release(FALSE);
        }

    }

    // Enable cachevu for CONTENT and HISTORY.
    EnableCacheVu(_coContent->GetCachePath(), CONTENT);
    EnableCacheVu(_coHistory->GetCachePath(), HISTORY);

unlock_exit:

    UNLOCK_CACHE();

exit:
    dwError = (fInitSucceeded ? ERROR_SUCCESS : ERROR_INTERNAL_ERROR);
    if (!fInitSucceeded && _hMutexExtensible)
    {
        CloseHandle(_hMutexExtensible);
        _hMutexExtensible = NULL;
    }
    INET_ASSERT(dwError == ERROR_SUCCESS);
    return dwError;
}


/*-----------------------------------------------------------------------------
DWORD CConMgr::LoadContent()
----------------------------------------------------------------------------*/
DWORD CConMgr::LoadContent()
{
    DWORD cbFile, dwError = ERROR_FILE_NOT_FOUND;
    CHAR  szPreloadKey[MAX_PATH],
          szUrl[MAX_PATH],
          szFile[MAX_PATH];

    // Preload registry key string.
    memcpy(szPreloadKey, OLD_CACHE_KEY, sizeof(OLD_CACHE_KEY) - 1);
    szPreloadKey[sizeof(OLD_CACHE_KEY)-1] = '\\';
    memcpy(szPreloadKey + sizeof(OLD_CACHE_KEY), "Preload", sizeof("PreLoad"));

    // Construct preload registry object.
    REGISTRY_OBJ roPreload(HKEY_CURRENT_USER, szPreloadKey);
    REGISTRY_OBJ roIE5Preload;
    if (roPreload.GetStatus() != ERROR_SUCCESS)
        goto exit;

    // Get the storage directory (cdf preload) to compare against to determine if we
    // need to set EDITED_CACHE_ENTRY or not. We assume any preload entry not in the
    // store dir IS and ECE.
    DWORD cb;
    CHAR szStorePath[MAX_PATH];

    // Store dir is hardwired to "%windir%\Web\"
    if ((cb = GetWindowsDirectory(szStorePath, MAX_PATH)))
    {
        AppendSlashIfNecessary(szStorePath, &cb);
        memcpy(szStorePath + cb, WEBDIR_STRING, sizeof(WEBDIR_STRING));
        cb += sizeof(WEBDIR_STRING) - 1; //cb now equals size of szStorePath.
    }


    // Enum the registry url/file values and commit them
    // to the cache.
    while (roPreload.FindNextValue(szUrl, MAX_PATH,
        (LPBYTE) szFile, &(cbFile = MAX_PATH)) == ERROR_SUCCESS)
    {
        // Strip off any file:// off the file path/name.
        CHAR* ptr = szFile;

        if (!strnicmp(ptr, "file://", sizeof("file://") - 1))
            ptr += sizeof("file://") - 1;

        AddUrlArg Args;
        memset(&Args, 0, sizeof(Args));
        Args.pszUrl      = szUrl;
        Args.pszFilePath = ptr;

        // If this is a Store entry, set the type to 0 else ECE
        if (!strnicmp(ptr, szStorePath, cb))
            Args.dwEntryType = 0;
        else
            Args.dwEntryType = EDITED_CACHE_ENTRY;

        _coContent->AddUrl(&Args);
    }


    if (roIE5Preload.WorkWith(&roPreload, "IE5Preload")!=ERROR_SUCCESS)
        goto exit;
        
    DWORD cbMaxUrl, cbMaxEntry, cbEntry;
    LPSTR pszUrl;
    URL_FILEMAP_ENTRY *pEntry;
    KEY_QUERY_INFO QueryInfo;

    if (ERROR_SUCCESS != roIE5Preload.GetKeyInfo(&QueryInfo))
        goto exit;
                
    cbMaxUrl = QueryInfo.MaxValueNameLen + 1;
    cbMaxEntry = QueryInfo.MaxValueLen + 1;
    
    pszUrl = new CHAR[cbMaxUrl];
    pEntry = (URL_FILEMAP_ENTRY*) new CHAR[cbMaxEntry];

    if (!(pszUrl && pEntry))
        goto exit;


    __try
    {
        
        while ((dwError = roIE5Preload.FindNextValue(pszUrl, cbMaxUrl,
            (LPBYTE) pEntry, &(cbEntry = cbMaxEntry))) == ERROR_SUCCESS)
        {
            FILETIME ft;
            AddUrlArg Args;
            memset(&Args, 0, sizeof(Args));

            // Url
            Args.pszUrl      = pEntry->UrlNameOffset ? 
                (LPSTR) OFFSET_TO_POINTER(pEntry, pEntry->UrlNameOffset) : NULL;
    
            // File path
            Args.pszFilePath = pEntry->InternalFileNameOffset ? 
                (LPSTR) OFFSET_TO_POINTER(pEntry, pEntry->InternalFileNameOffset) : NULL;

            // Header info
            Args.pbHeaders = pEntry->HeaderInfoOffset ? 
                (LPSTR) OFFSET_TO_POINTER(pEntry, pEntry->HeaderInfoOffset) : NULL;
            Args.cbHeaders = pEntry->HeaderInfoSize;

            // Last modified.
            Args.qwLastMod = pEntry->LastModifiedTime;

            // Expires time.
            DosTime2FileTime(pEntry->dostExpireTime, &ft);        
            Args.qwExpires = FT2LL(ft);

            // Post check time.
            DosTime2FileTime(pEntry->dostPostCheckTime, &ft);        
            Args.qwPostCheck = FT2LL(ft);

            // File creation time.
            DosTime2FileTime(pEntry->dostFileCreationTime, &ft);        
            Args.ftCreate = ft;
        
            // File extension.
            Args.pszFileExt = pEntry->FileExtensionOffset ? 
                (LPSTR) OFFSET_TO_POINTER(pEntry, pEntry->FileExtensionOffset) : NULL;
 
            // Entry type.
            Args.dwEntryType = pEntry->CacheEntryType;

            // File size
            Args.dwFileSize = pEntry->dwFileSize;

            // Add the url.
            _coContent->AddUrl(&Args);
        }

    } // __try

    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        INET_ASSERT(FALSE);
        dwError = GetLastError();
    }
    ENDEXCEPT
     
    dwError = ERROR_SUCCESS;

    if (pszUrl)
        delete pszUrl;
    if (pEntry)
        delete pEntry;
        
exit:
    return dwError;
}


/*-----------------------------------------------------------------------------
HANDLE CConMgr::FindFirstContainer
----------------------------------------------------------------------------*/
HANDLE CConMgr::FindFirstContainer(DWORD *pdwModified, LPINTERNET_CACHE_CONTAINER_INFOA lpContainerInfo, LPDWORD lpdwContainerInfoBufferSize, DWORD dwOptions)
{
    DWORD dwError = ERROR_SUCCESS;
    CONTAINER_FIND_FIRST_HANDLE *pFind;
    DWORD dwContainers = 0;
    DWORD dwNames = 0;
    DWORD dwPrefixes = 0;
    DWORD dwLabels = 0;
    DWORD dwTitles = 0;
    DWORD dwTotal;
    HANDLE hFind = NULL;
    DWORD dwModified;

    GetExtensibleCacheConfigInfo(FALSE);

    LOCK_CACHE();
    dwModified = *pdwModified;
    *pdwModified = _dwModifiedCount;


    if ((CACHE_FIND_CONTAINER_RETURN_NOCHANGE & dwOptions) == 0 ||
        dwModified != *pdwModified)
    {
        for (DWORD i = NCONTAINERS; i < ConList.Size(); i++)
        {
            URL_CONTAINER *co = ConList.Get(i);
            if (co)
            {
                if (co->IsVisible())
                {
                    dwContainers++;
                    dwNames += strlen(co->GetCacheName()) + 1;
                    dwPrefixes += strlen(co->GetCachePrefix()) + 1;
                    dwLabels += strlen(co->GetVolumeLabel()) + 1;
                    dwTitles += strlen(co->GetVolumeTitle()) + 1;
                }
                co->Release(TRUE);
            }
        }

        dwTotal = sizeof(CONTAINER_FIND_FIRST_HANDLE)+
                         dwContainers*(4 * sizeof(LPSTR)) +
                         (dwNames+dwPrefixes+dwLabels+dwTitles) * sizeof(char);

        hFind = HandleMgr.Alloc (dwTotal);
        if (hFind)
        {
            LPSTR ps;

            pFind = (CONTAINER_FIND_FIRST_HANDLE*) HandleMgr.Map (hFind);
            pFind->dwSignature = SIGNATURE_CONTAINER_FIND;
            pFind->dwContainer = 0;
            pFind->dwNumContainers = dwContainers;
            if (dwContainers)
            {
                pFind->ppNames = (LPTSTR *) (((LPBYTE) pFind) + sizeof(CONTAINER_FIND_FIRST_HANDLE));
                pFind->ppPrefixes = pFind->ppNames + dwContainers;
                pFind->ppLabels = pFind->ppPrefixes + dwContainers;
                pFind->ppTitles = pFind->ppLabels + dwContainers;
                ps = (LPSTR) (((LPBYTE) pFind) +
                                sizeof(CONTAINER_FIND_FIRST_HANDLE)+
                                dwContainers*(4 * sizeof(LPSTR)));
                dwContainers = 0;

                for (DWORD i = NCONTAINERS; i < ConList.Size(); i++)
                {
                    URL_CONTAINER *co = ConList.Get(i);
                    if (co)
                    {
                        if (co->IsVisible())
                        {
                            pFind->ppNames[dwContainers] = ps;
                            strcpy(ps, co->GetCacheName());
                            ps += strlen(co->GetCacheName()) + 1;
                            pFind->ppPrefixes[dwContainers] = ps;
                            strcpy(ps, co->GetCachePrefix());
                            ps += strlen(co->GetCachePrefix()) + 1;
                            pFind->ppLabels[dwContainers] = ps;
                            strcpy(ps, co->GetVolumeLabel());
                            ps += strlen(co->GetVolumeLabel()) + 1;
                            pFind->ppTitles[dwContainers] = ps;
                            strcpy(ps, co->GetVolumeTitle());
                            ps += strlen(co->GetVolumeTitle()) + 1;

                            dwContainers++;
                        }
                        co->Release(TRUE);
                    }
                }

            }
        }
        else
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
        }
    }
    else
    {
        dwError = ERROR_WINHTTP_NO_NEW_CONTAINERS;
    }
    UNLOCK_CACHE();

    if (hFind)
    {
        if (FindNextContainer(hFind, lpContainerInfo, lpdwContainerInfoBufferSize))
            dwError = ERROR_SUCCESS;
        else
            dwError = GetLastError();
    }
    if( dwError != ERROR_SUCCESS )
    {
        FreeFindHandle(hFind);
        SetLastError(dwError);
        return NULL;
    }
    return hFind;
}


/*-----------------------------------------------------------------------------
BOOL CConMgr::FindNextContainer
----------------------------------------------------------------------------*/
BOOL CConMgr::FindNextContainer(HANDLE hFind, LPINTERNET_CACHE_CONTAINER_INFOA lpContainerInfo, LPDWORD lpdwContainerInfoBufferSize)
{
    // BUGBUG - this logic is borrowed from the original cachapia.cxx.

    DWORD                    dwError;
    CONTAINER_FIND_FIRST_HANDLE* pFind;

    // Map and validate the handle.
    LOCK_CACHE();
    pFind = (CONTAINER_FIND_FIRST_HANDLE*) HandleMgr.Map (hFind);
    UNLOCK_CACHE();
    if (!pFind || pFind->dwSignature != SIGNATURE_CONTAINER_FIND ||
        !lpContainerInfo ||
        *lpdwContainerInfoBufferSize < sizeof(INTERNET_CACHE_CONTAINER_INFOA))
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    // Continue the enumeration.
    if (pFind->dwContainer < pFind->dwNumContainers)
    {
        DWORD cbName = strlen(pFind->ppNames[pFind->dwContainer])+1;
        DWORD cbPrefix = strlen(pFind->ppPrefixes[pFind->dwContainer])+1;
        DWORD cbLabel = strlen(pFind->ppLabels[pFind->dwContainer])+1;
        DWORD cbTitle = strlen(pFind->ppTitles[pFind->dwContainer])+1;

        DWORD cbTotal = cbName+cbPrefix+cbLabel+cbTitle+sizeof(INTERNET_CACHE_CONTAINER_INFOA);
        if (cbTotal > *lpdwContainerInfoBufferSize)
        {
            dwError = ERROR_INSUFFICIENT_BUFFER;
        }
        else
        {
            lpContainerInfo->lpszName = (LPSTR) (((LPBYTE) lpContainerInfo) +
                sizeof(INTERNET_CACHE_CONTAINER_INFOA));
            lpContainerInfo->lpszCachePrefix = lpContainerInfo->lpszName + cbName;
            lpContainerInfo->lpszVolumeLabel = lpContainerInfo->lpszCachePrefix + cbPrefix;
            lpContainerInfo->lpszVolumeTitle = lpContainerInfo->lpszVolumeLabel + cbLabel;

            strcpy(lpContainerInfo->lpszName, pFind->ppNames[pFind->dwContainer]);
            strcpy(lpContainerInfo->lpszCachePrefix, pFind->ppPrefixes[pFind->dwContainer]);
            strcpy(lpContainerInfo->lpszVolumeLabel, pFind->ppLabels[pFind->dwContainer]);
            strcpy(lpContainerInfo->lpszVolumeTitle, pFind->ppTitles[pFind->dwContainer]);
            lpContainerInfo->dwCacheVersion = URL_CACHE_VERSION_NUM;
            pFind->dwContainer++;
            dwError = ERROR_SUCCESS;
        }
        *lpdwContainerInfoBufferSize = cbTotal;
    }
    else
    {
        dwError = ERROR_NO_MORE_ITEMS;
    }

exit:
    if (dwError != ERROR_SUCCESS)
    {
        SetLastError(dwError);
        return FALSE;
    }
    return TRUE;
}

/*-----------------------------------------------------------------------------
DWORD CConMgr::GetContainerInfo
----------------------------------------------------------------------------*/
DWORD CConMgr::GetContainerInfo(LPSTR szUrl,
                               LPINTERNET_CACHE_CONTAINER_INFOA pCI,
                               LPDWORD pcbCI)
{
    URL_CONTAINER *co;
    DWORD dwError;

    // Find the associated container.
    DWORD idx;

    LOCK_CACHE();

    idx = FindIndexFromPrefix(szUrl);
    co = ConList.Get(idx);

    if (co)
    {
        DWORD cbName = strlen(co->GetCacheName()) + 1;
        DWORD cbPrefix = strlen(co->GetCachePrefix()) + 1;
        DWORD cbLabel = strlen(co->GetVolumeLabel()) + 1;
        DWORD cbTitle = strlen(co->GetVolumeTitle()) + 1;
        DWORD cbReq = cbName + cbPrefix + cbLabel + cbTitle;
        if (cbReq > *pcbCI)
        {
            *pcbCI = cbReq;
            dwError = ERROR_INSUFFICIENT_BUFFER;
        }
        else
        {
            pCI->lpszName = (LPSTR) (((LPBYTE) pCI) +
                sizeof(INTERNET_CACHE_CONTAINER_INFOA));

            pCI->lpszCachePrefix = pCI->lpszName + cbName;
            pCI->lpszVolumeLabel = pCI->lpszName + cbName + cbPrefix;
            pCI->lpszVolumeTitle = pCI->lpszName + cbName + cbPrefix + cbLabel;

            memcpy(pCI->lpszName, co->GetCacheName(), cbName);
            memcpy(pCI->lpszCachePrefix, co->GetCachePrefix(), cbPrefix);
            memcpy(pCI->lpszVolumeLabel, co->GetVolumeLabel(), cbLabel);
            memcpy(pCI->lpszVolumeTitle, co->GetVolumeTitle(), cbTitle);
            pCI->dwCacheVersion = URL_CACHE_VERSION_NUM;

            *pcbCI = cbReq;
            dwError = ERROR_SUCCESS;
        }

        co->Release(TRUE);
    }
    else
    {
        dwError = ERROR_WINHTTP_INTERNAL_ERROR;
    }

    UNLOCK_CACHE();

    return dwError;
}

VOID CompressPath(PTSTR pszPath, PTSTR pszScratch);

/*-----------------------------------------------------------------------------
DWORD CConMgr::CreateContainer
----------------------------------------------------------------------------*/
DWORD CConMgr::CreateContainer(LPCSTR Name, LPCSTR CachePrefix, LPCSTR CachePath, DWORD KBCacheLimit, DWORD dwOptions)
{
    BOOL fInsertOk = TRUE;
    DWORD dwError = ERROR_SUCCESS;
    CHAR szVendorKey[MAX_PATH];
    CHAR szDefaultPath[MAX_PATH];
    CHAR szCachePath[MAX_PATH];
    LONGLONG CacheStartUpLimit;
    HKEY hKey;
    DWORD cbKeyLen;

    hKey = (_fProfilesCapable ? HKEY_CURRENT_USER : HKEY_LOCAL_MACHINE);
    REGISTRY_OBJ* pro = NULL;
    MUTEX_HOLDER mh;

    if (!Name || !*Name)
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto exit;
    }
    if (!CachePath || !*CachePath)
    {
        LPSTR p = _coHistory->GetCachePath();
        int len = _coHistory->GetCachePathLen();
        int clen = lstrlen(Name);

        if (len + clen + sizeof(DIR_SEPARATOR_STRING) > sizeof(szDefaultPath)) 
        {
            dwError = ERROR_WINHTTP_INTERNAL_ERROR;
            goto exit;
        }
        memcpy(szDefaultPath, p, len);

        memcpy(&szDefaultPath[len], Name, clen);
        memcpy(&szDefaultPath[len + clen], DIR_SEPARATOR_STRING, sizeof(DIR_SEPARATOR_STRING));
    }
    else 
    {
        INET_ASSERT((CachePrefix && *CachePrefix));

        // For non-history containers, we need to stuff into the appropriate subcontainer
        // Assumption: Content cache never falls here.
        if (!GenerateStringWithOrdinal(CachePath, 
                                       GlobalIdentity, 
                                       szDefaultPath, 
                                       ARRAY_ELEMENTS(szDefaultPath)))
        {
            INET_ASSERT(FALSE);
            dwError = ERROR_WINHTTP_INTERNAL_ERROR;
            goto exit;
        }
    }
    CachePath = szDefaultPath;
    
    if (KBCacheLimit == 0)
    {
        CacheStartUpLimit = _coHistory->GetCacheStartUpLimit();
        KBCacheLimit = (DWORD) (CacheStartUpLimit / 1024);
    }


    if (!CachePrefix || !*CachePrefix || !CachePath || !*CachePath)
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    pro = CreateExtensiRegObj(hKey);
    if (!pro)
    {
        dwError = ERROR_ACCESS_DENIED;
        goto exit;
    }   
    {
        REGISTRY_OBJ& roExtensibleCache = *pro;
        mh.Grab(_hMutexExtensible, FAILSAFE_TIMEOUT);

        // Get the container paths, prefixes (if any) and default limit values.
        while (roExtensibleCache.FindNextKey(szVendorKey, MAX_PATH) == ERROR_SUCCESS)
        {
            REGISTRY_OBJ roVendor(&roExtensibleCache, szVendorKey);
            if (roVendor.GetStatus()==ERROR_SUCCESS)
            {
                // Path.
                TCHAR szScratch[MAX_PATH];
                cbKeyLen = MAX_PATH;
                if (roVendor.GetValue(CACHE_PATH_VALUE,(LPBYTE) szScratch,&cbKeyLen) != ERROR_SUCCESS)
                    continue;

                ExpandEnvironmentStrings(szScratch, szCachePath, sizeof(szCachePath)-1); // don't count the NULL
                if (!stricmp(szVendorKey, Name) || !stricmp(CachePath, szCachePath))
                {
                    fInsertOk = FALSE;
                    break;
                }
            }
        }   

        if (fInsertOk)
        {
            REGISTRY_OBJ roNewVendor(&roExtensibleCache, (LPSTR)Name, CREATE_KEY_IF_NOT_EXISTS);
            if (roNewVendor.GetStatus() == ERROR_SUCCESS)
            {
                CHAR szScratch[MAX_PATH];
                CompressPath((LPTSTR)CachePath, szScratch);
                    // Path.
                if ((dwError = roNewVendor.SetValue(CACHE_PATH_VALUE, (LPSTR)szScratch, REG_EXPAND_SZ)) != ERROR_SUCCESS)
                    goto exit;

                    // Prefix.
                if ((dwError = roNewVendor.SetValue(CACHE_PREFIX_VALUE, (LPSTR)CachePrefix, REG_SZ)) != ERROR_SUCCESS)
                    goto exit;

                    // Limit.
                if ((dwError = roNewVendor.SetValue(CACHE_LIMIT_VALUE, &KBCacheLimit)) != ERROR_SUCCESS)
                        goto exit;

                    // Options.
                if ((dwError = roNewVendor.SetValue(CACHE_OPTIONS_VALUE, &dwOptions)) != ERROR_SUCCESS)
                    goto exit;
            }
        }
        else
        {
            dwError = ERROR_ALREADY_EXISTS;
        }
    }

    if (fInsertOk)
    {
        IncrementModifiedCount();
    }

exit:
    if (pro)
    {
        delete pro;
    }
    mh.Release();
    if (fInsertOk)
    {
        GetExtensibleCacheConfigInfo(TRUE);
    }
    return dwError;
}

/*-----------------------------------------------------------------------------
DWORD CConMgr::FindExtensibleContainer
----------------------------------------------------------------------------*/
// THIS FUNCTION MUST BE CALLED WITH THE CACHE CRIT SECTION
DWORD CConMgr::FindExtensibleContainer(LPCSTR Name)
{
    DWORD n = NOT_AN_INDEX;
    DWORD i;
    URL_CONTAINER *co;

    for (i = NCONTAINERS; i < ConList.Size(); i++)
    {
        co = ConList.Get(i);
        if (co)
        {
            if (!stricmp(Name, co->GetCacheName()) && co->IsVisible())
            {
                // Found a match
                n = i;
                co->Release(FALSE);
                break;
            }
            co->Release(FALSE);
        }
    }

    return n;
}

/*-----------------------------------------------------------------------------
DWORD CConMgr::DeleteContainer
----------------------------------------------------------------------------*/
DWORD CConMgr::DeleteContainer(LPCSTR Name, DWORD dwOptions)
{
    DWORD dwError = ERROR_SUCCESS;
    URL_CONTAINER *co = NULL;
    DWORD n = NOT_AN_INDEX;
    HKEY hKey;

    if (!Name || !*Name)
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    LOCK_CACHE();
    n = FindExtensibleContainer(Name);
    if (n != NOT_AN_INDEX)
    {
        co = ConList.Get(n);

        if (co)
        {
            co->SetDeletePending(TRUE);
            //  Don't release here, hold it pending until we've updated registry
        }
    }
    UNLOCK_CACHE();

    if (n!= NOT_AN_INDEX)
    {
        hKey = (_fProfilesCapable ? HKEY_CURRENT_USER : HKEY_LOCAL_MACHINE);

        REGISTRY_OBJ* pro = CreateExtensiRegObj(hKey);
        if (!pro)
        {
            dwError = ERROR_ACCESS_DENIED;
            goto exit;
        }
        
        {
            REGISTRY_OBJ& roExtensibleCache = *pro;
            MUTEX_HOLDER mh;
            mh.Grab(_hMutexExtensible, FAILSAFE_TIMEOUT);
            dwError = roExtensibleCache.DeleteKey((LPSTR)Name);
            mh.Release();
            IncrementModifiedCount();
        }
        delete pro;
    }

exit:
    LOCK_CACHE();
    SAFERELEASE(co, TRUE);
    UNLOCK_CACHE();
    return dwError;
}

/*-----------------------------------------------------------------------------
DWORD CConMgr::DeleteFileIfNotRegistered
----------------------------------------------------------------------------*/
BOOL CConMgr::DeleteFileIfNotRegistered(URL_CONTAINER *coDelete)
{
    BOOL fDelete = TRUE;
    BOOL fFound = FALSE;
    CHAR szCachePath[MAX_PATH];
    CHAR szCachePrefix[MAX_PATH];
    DWORD dwOptions;
    LONGLONG cbCacheLimit;

    HKEY hKey = (HKEY) INVALID_HANDLE_VALUE;
    DWORD cbKeyLen, cbKBLimit, dwError;
    CHAR szVendorKey[MAX_PATH];

    hKey = (_fProfilesCapable ? HKEY_CURRENT_USER : HKEY_LOCAL_MACHINE);
    REGISTRY_OBJ* pro = CreateExtensiRegObj(hKey);
    MUTEX_HOLDER mh;
    
    if (!pro)
    {
        dwError = ERROR_ACCESS_DENIED;
        goto exit;
    }
    
    if (!WasModified(FALSE))
    {
        //  If our internal cache is up to date, it can't
        //  have been deleted unless DeletePending or Deleted
        fFound = !(coDelete->GetDeletePending()||coDelete->GetDeleted());
        if (fFound)
        {
            goto exit;
        }
        //  If not found, need to look at registry to make sure we're not
        //  deleting a path that has been reused
    }

    mh.Grab(_hMutexExtensible, FAILSAFE_TIMEOUT);

    {
    REGISTRY_OBJ& roExtensibleCache = *pro;

     // Get the container paths, prefixes.
    while (roExtensibleCache.FindNextKey(szVendorKey, MAX_PATH) == ERROR_SUCCESS)
    {
        BOOL fPathMatch;
        REGISTRY_OBJ roVendor(&roExtensibleCache, szVendorKey);
        if (roVendor.GetStatus()==ERROR_SUCCESS)
        {
            // Path.
            TCHAR szScratch[MAX_PATH];
            cbKeyLen = MAX_PATH;
            if (roVendor.GetValue(CACHE_PATH_VALUE,(LPBYTE) szScratch, &cbKeyLen) != ERROR_SUCCESS)
                continue;

            ExpandEnvironmentStrings(szScratch, szCachePath, sizeof(szCachePath)-1); // don't count the NULL

            // Prefix.
            cbKeyLen = MAX_PATH;
            if (roVendor.GetValue(CACHE_PREFIX_VALUE,(LPBYTE) szCachePrefix, &cbKeyLen) != ERROR_SUCCESS)
                continue;

            // Options.
            if (roVendor.GetValue(CACHE_OPTIONS_VALUE,&dwOptions) != ERROR_SUCCESS)
                continue;

            fPathMatch = !stricmp(coDelete->GetCachePath(), szCachePath);
            if (!stricmp(coDelete->GetCacheName(), szVendorKey) && fPathMatch &&
                !stricmp(coDelete->GetCachePrefix(), szCachePrefix) &&
                coDelete->GetOptions() != dwOptions)
            {
                fFound = TRUE;
            }
            if (fPathMatch)
                fDelete = FALSE;
        }
    }
    }
    if (fDelete)
    {
        //  This will fail if another process still has the container mapped,
        //  that's ok.  They will check on exit if container needs to be
        //  deleted
        if (coDelete->GetOptions() & INTERNET_CACHE_CONTAINER_AUTODELETE)
        {
            CFileMgr::DeleteCache(coDelete->GetCachePath());
        }
    }
exit:
    if (pro)
    {
        delete pro;
    }
    mh.Release();
    
    return !fFound;
}


/*-----------------------------------------------------------------------------
DWORD CConMgr::FindIndexFromPrefix
----------------------------------------------------------------------------*/
// THIS FUNCTION MUST BE CALLED WITH THE CACHE CRIT SEC
DWORD CConMgr::FindIndexFromPrefix(LPCSTR szUrl)
{
    // Unless we find a matching prefix, CONTENT is the default.
    DWORD n = szUrl[0]==EXTENSIBLE_FIRST ? NOT_AN_INDEX : CONTENT;
    URL_CONTAINER *co = NULL;

    //  NOTE: if deleting a container is supported, ConList.Get(i) can
    //  return NULL, if list shrinks after getting size.
    //  NOTE: if deleting containers is supported, it is not safe to
    //  assume CONTENT if prefix is not found.  client may be trying to
    //  insert into a container that has been deleted, but once existed.
    //  proper response is to return an error.  the simplest way to do this
    //  is to insist that all Extensible cache prefixes start with an illegal
    //  URL character, EXTENSIBLE_FIRST

    GetExtensibleCacheConfigInfo(FALSE);
    for (DWORD i = COOKIE; i < ConList.Size(); i++)
    {
        co = ConList.Get(i);
        if (co)
        {
            if (co->PrefixMatch(szUrl))
            {
                // For content container, strnicmp (szUrl, "", 0) returns nonzero
                if (co->IsVisible())
                {
                    // Found a match
                    n = i;
                    if (!co->IsInitialized())
                    {
                        // Init the container. If this fails,
                        // Mark it as DELETED and return CONTENT.
                        switch (co->Init())
                        {
                        case ERROR_SUCCESS:
                        case ERROR_ALREADY_EXISTS:
                            if (!(co->GetOptions() & INTERNET_CACHE_CONTAINER_NODESKTOPINIT))
                                EnableCacheVu(co->GetCachePath(), n);
                            break;
                        default:
                            INET_ASSERT(FALSE);
                            co->SetDeleted(TRUE);
                            n = szUrl[0]==EXTENSIBLE_FIRST ? NOT_AN_INDEX : CONTENT;
                            break;
                        }
                    }
                    co->Release(FALSE);
                    break;
                }
            }
            co->Release(FALSE);
        }
    }
    return n;
}



/*-----------------------------------------------------------------------------
BOOL CConMgr::PathPrefixMatch
----------------------------------------------------------------------------*/
BOOL CConMgr::PathPrefixMatch(LPCSTR szPath, LPCSTR szPathRef)
{
    // BUGBUG - logic borrowed from original cacheapi.cxx

    INT len;

    // TRUE if the passed in path is NULL
    if (!szPath)
        return TRUE;

    len = lstrlen(szPath);

    // TRUE if it is 0 length.
    if (!len)
        return TRUE;

    // stripout the trailing slash
    if (szPath[len-1] == DIR_SEPARATOR_CHAR)
        --len;

    // Compare paths.
    if (!strnicmp(szPath, szPathRef, len))
        if (szPathRef[len] == DIR_SEPARATOR_CHAR || szPathRef[len] == 0)
            return TRUE;

    return FALSE;
}

/*---------------------  Public Functions -----------------------------------*/

/*-----------------------------------------------------------------------------
CConMgr::CConMgr

  Default Constructor
  ----------------------------------------------------------------------------*/
CConMgr::CConMgr()
: ConList()
{
    _coContent = NULL;
    _coCookies = NULL;
    _coHistory = NULL;
    _hMutexExtensible = 0;

    // Assume this is a profiles-capable machine. Later on, we'll make sure this is
    // the case.
    _fProfilesCapable = TRUE;

    // Assume that we'll be using the regular containers, instead of the backup
    _fUsingBackupContainers = FALSE;
    _dwStatus = Init();
}


/*-----------------------------------------------------------------------------
CConMgr::~CConMgr

  Default Destructor
  ----------------------------------------------------------------------------*/
CConMgr::~CConMgr()
{
    ConList.Free();
    if (_hMutexExtensible)
    {
        CloseHandle(_hMutexExtensible);
    }
}

/*-----------------------------------------------------------------------------
DWORD CConMgr::GetStatus()
----------------------------------------------------------------------------*/
DWORD CConMgr::GetStatus()
{
    return _dwStatus;
}

/*-----------------------------------------------------------------------------
DWORD CConMgr::UnlockUrl
----------------------------------------------------------------------------*/
DWORD CConMgr::UnlockUrl(LPCSTR szUrl)
{
    URL_CONTAINER *co;
    DWORD dwError = ERROR_FILE_NOT_FOUND;
    // Find the associated container.
    DWORD idx;

    LOCK_CACHE();

    idx = FindIndexFromPrefix(szUrl);
    co = ConList.Get(idx);

    if (co)
    {
        UNLOCK_CACHE();
        // Call UnlockUrl on the appropriate container.
        dwError = co->UnlockUrl(szUrl); // may be expensive
        LOCK_CACHE();
        co->Release(TRUE);
    }
    UNLOCK_CACHE();
    return dwError;
}

/*-----------------------------------------------------------------------------
DWORD CConMgr::DeleteUrl
----------------------------------------------------------------------------*/
DWORD CConMgr::DeleteUrl(LPCSTR szUrl)
{
    URL_CONTAINER *co;
    DWORD dwError = ERROR_FILE_NOT_FOUND;
    // Find the associated container.
    DWORD idx;

    UNIX_RETURN_ERR_IF_READONLY_CACHE(dwError);

    LOCK_CACHE();

    idx = FindIndexFromPrefix(szUrl);
    co = ConList.Get(idx);

    if (co)
    {
        UNLOCK_CACHE();
        // Call DeleteUrl on the appropriate container.
        dwError = co->DeleteUrl(szUrl); // may be expensive.
        LOCK_CACHE();

        co->Release(TRUE);

        // Update the change count for the cookies container.
        if (idx == COOKIE)
        {
            DWORD dwChange = 0;
            _coContent->IncrementHeaderData(CACHE_HEADER_DATA_COOKIE_CHANGE_COUNT, &dwChange);
        }
    }

    UNLOCK_CACHE();
    return dwError;
}

/*-----------------------------------------------------------------------------
BOOL CConMgr::GetHeaderData
----------------------------------------------------------------------------*/
BOOL CConMgr::GetHeaderData(DWORD nIdx, LPDWORD pdwData)
{
    return _coContent->GetHeaderData(nIdx, pdwData);
}

/*-----------------------------------------------------------------------------
BOOL CConMgr::SetHeaderData
----------------------------------------------------------------------------*/
BOOL CConMgr::SetHeaderData(DWORD nIdx, DWORD dwData)
{
    UNIX_RETURN_ERR_IF_READONLY_CACHE(FALSE);
    return _coContent->SetHeaderData(nIdx, dwData);
}

/*-----------------------------------------------------------------------------
BOOL CConMgr::IncrementHeaderData
----------------------------------------------------------------------------*/
BOOL CConMgr::IncrementHeaderData(DWORD nIdx, LPDWORD pdwData)
{
    UNIX_RETURN_ERR_IF_READONLY_CACHE(FALSE);
    return _coContent->IncrementHeaderData(nIdx, pdwData);
}

/*-----------------------------------------------------------------------------
DWORD CConMgr::SetUrlGroup
----------------------------------------------------------------------------*/
DWORD CConMgr::SetUrlGroup(
    IN LPCSTR   szUrl,
    IN DWORD    dwFlags,
    IN GROUPID  GroupId
    )
{
    URL_CONTAINER *co;
    DWORD dwError = ERROR_FILE_NOT_FOUND;
    // Find the associated container.

    UNIX_RETURN_ERR_IF_READONLY_CACHE(dwError);

    LOCK_CACHE();
    DWORD idx = FindIndexFromPrefix(szUrl);

    co = ConList.Get(idx);

    if (co)
    {
        UNLOCK_CACHE();
        // Call SetUrlInGroup on the appropriate container.
        dwError = co->SetUrlGroup
            (szUrl, dwFlags, GroupId);
        LOCK_CACHE();
        co->Release(TRUE);
    }

    UNLOCK_CACHE();
    return dwError;
}

/*-----------------------------------------------------------------------------
DWORD CConMgr::CreateUniqueFile
----------------------------------------------------------------------------*/
DWORD CConMgr::CreateUniqueFile(LPCSTR szUrl, DWORD dwExpectedSize,
                                       LPCSTR szFileExtension, LPTSTR szFileName,
                                       HANDLE *phfHandle,
                                       BOOL   fCreatePerUser)
{
    URL_CONTAINER *co;
    DWORD dwError = ERROR_FILE_NOT_FOUND;
    // Find the associated container.

    UNIX_RETURN_ERR_IF_READONLY_CACHE(dwError);

    LOCK_CACHE();
    DWORD idx = FindIndexFromPrefix(szUrl);


    co = ConList.Get(idx);


    if (co)
    {
        UNLOCK_CACHE();
        // Call CreateUniqueFile on the appropriate container.
        dwError = co->CreateUniqueFile(szUrl, dwExpectedSize,
            szFileExtension, szFileName, phfHandle, fCreatePerUser); // expensive call
        LOCK_CACHE();

        co->Release(TRUE);
    }

    UNLOCK_CACHE();
    return dwError;
}


/*-----------------------------------------------------------------------------
DWORD CConMgr::AddUrl
----------------------------------------------------------------------------*/
DWORD CConMgr::AddUrl(AddUrlArg* pArgs)
{
    URL_CONTAINER *co;
    DWORD dwError = ERROR_FILE_NOT_FOUND;
    // Find the associated container.

    UNIX_RETURN_ERR_IF_READONLY_CACHE(dwError);

    LOCK_CACHE();

    DWORD idx = FindIndexFromPrefix(pArgs->pszUrl);
    co = ConList.Get(idx);

    if (co)
    {
        UNLOCK_CACHE();
        // Call AddUrl on the appropriate container.
        dwError = co->AddUrl(pArgs); // may be expensive
        LOCK_CACHE();

        co->Release(TRUE);

        // Update the change count for the cookies container.
        if (idx == COOKIE)
        {
            DWORD dwChange = 0;
            _coContent->IncrementHeaderData(CACHE_HEADER_DATA_COOKIE_CHANGE_COUNT, &dwChange);
        }
    }

    UNLOCK_CACHE();
    return dwError;
}

/*-----------------------------------------------------------------------------
DWORD CConMgr::RetrieveUrl
----------------------------------------------------------------------------*/
DWORD CConMgr::RetrieveUrl( LPCSTR               szUrl,
                            LPCACHE_ENTRY_INFOA* ppCacheEntryInfo,
                            LPDWORD              pcbCacheEntryInfoBufferSize,
                            DWORD                dwLookupFlags,
                            DWORD                dwRetrievalFlags)
{
    URL_CONTAINER *co;
    DWORD dwError = ERROR_FILE_NOT_FOUND;
    // Find the associated container.

    LOCK_CACHE();
    DWORD idx = FindIndexFromPrefix(szUrl);


    co = ConList.Get(idx);

    if (co)
    {
        UNLOCK_CACHE();
        // Call RetrieveUrl on the appropriate container.
        dwError = co->RetrieveUrl(szUrl,
                                  ppCacheEntryInfo,
                                  pcbCacheEntryInfoBufferSize,
                                  dwLookupFlags, dwRetrievalFlags); // expensive?
        LOCK_CACHE();
        co->Release(TRUE);
    }

    UNLOCK_CACHE();
    return dwError;
}


/*-----------------------------------------------------------------------------
DWORD CConMgr::GetUrlInfo
----------------------------------------------------------------------------*/
DWORD CConMgr::GetUrlInfo( LPCSTR               szUrl,
                           LPCACHE_ENTRY_INFOA*  ppCacheEntryInfo,
                           LPDWORD              pcbCacheEntryInfoBufferSize,
                           DWORD                dwLookupFlags,
                           DWORD                dwEntryFlags,
                           DWORD                dwRetrievalFlags)
{
    URL_CONTAINER *co;
    DWORD dwError = ERROR_FILE_NOT_FOUND;
    // Find the associated container.

    LOCK_CACHE();
    DWORD idx = FindIndexFromPrefix(szUrl);

    co = ConList.Get(idx);

    if (co)
    {
        // Call GetUrlInfo on the appropriate container.
        dwError = co->GetUrlInfo(szUrl,
                                 ppCacheEntryInfo,
                                 pcbCacheEntryInfoBufferSize,
                                 dwLookupFlags,
                                 dwEntryFlags,
                                 dwRetrievalFlags);

        co->Release(TRUE);
    }
    UNLOCK_CACHE();
    return dwError;
}

DWORD CConMgr::GetUrlInfo(LPCSTR               szUrl,
                          LPCACHE_ENTRY_INFOA  pCacheEntryInfo,
                          LPDWORD              pcbCacheEntryInfoBufferSize,
                          DWORD                dwLookupFlags,
                          DWORD                dwEntryFlags)
{
    return GetUrlInfo(szUrl,
                     (pCacheEntryInfo) ? &pCacheEntryInfo : NULL,
                     pcbCacheEntryInfoBufferSize,
                     dwLookupFlags,
                     dwEntryFlags,
                     0);
}


/*-----------------------------------------------------------------------------
DWORD CConMgr::SetUrlInfo
----------------------------------------------------------------------------*/
DWORD CConMgr::SetUrlInfo(LPCSTR               szUrl,
                          LPCACHE_ENTRY_INFOA  pCacheEntryInfo,
                          DWORD                dwFieldControl)
{
    URL_CONTAINER *co;
    DWORD dwError = ERROR_FILE_NOT_FOUND;
    // Find the associated container.

    UNIX_RETURN_ERR_IF_READONLY_CACHE(dwError);

    LOCK_CACHE();
    DWORD idx = FindIndexFromPrefix(szUrl);

    co = ConList.Get(idx);

    if (co)
    {
        // Call SetUrlInfo on the appropriate container.
        dwError = co->SetUrlInfo(szUrl,
                                 pCacheEntryInfo,
                                 dwFieldControl);
        co->Release(TRUE);
    }

    UNLOCK_CACHE();
    return dwError;
}

DWORD CConMgr::FreeFindHandle(HANDLE hFind)
{
    DWORD dwError = ERROR_INVALID_HANDLE;

    if (hFind)
    {
        LOCK_CACHE();

        LPCACHE_FIND_FIRST_HANDLE pFind;
        pFind = (CACHE_FIND_FIRST_HANDLE*) HandleMgr.Map (hFind);
        if (pFind)
        {
            //  NOTHING SPECIAL TO DO FOR SIGNATURE_CONTAINER_FIND
            if (pFind->dwSig == SIG_CACHE_FIND && !pFind->fFixed)
            {
                URL_CONTAINER *co = ConList.Get(pFind->nIdx);
                if (co)
                {
                    //  It now has 2 AddRefs to balance
                    co->Release(FALSE);
                    co->Release(TRUE);
                }
            }

            HandleMgr.Free (hFind);
            dwError = ERROR_SUCCESS;
        }

        UNLOCK_CACHE();
    }
    
    return dwError;
}


/*-----------------------------------------------------------------------------
DWORD CConMgr::FindNextEntry
----------------------------------------------------------------------------*/
DWORD CConMgr::FindNextEntry(
      HANDLE              *phFind,
      LPCSTR               szPrefix,
      LPCACHE_ENTRY_INFOA*  ppInfo,
      LPDWORD              pcbInfo,
      DWORD                dwFilter,
      GROUPID              GroupId,
      DWORD                dwFlags,
      DWORD                dwRetrievalFlags)
{
    DWORD                      idx, dwError;
    URL_CONTAINER             *co    = NULL;
    LPCACHE_FIND_FIRST_HANDLE  pFind = NULL;

    LOCK_CACHE();

    // Null handle initiates enumeration.
    if (!*phFind)
    {
        // Allocate a handle.
        //LOCK_CACHE();
        *phFind = HandleMgr.Alloc (sizeof(CACHE_FIND_FIRST_HANDLE));
        if (*phFind)
            pFind = (CACHE_FIND_FIRST_HANDLE*) HandleMgr.Map (*phFind);
        //UNLOCK_CACHE();
        if (!*phFind)
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }

        if (!pFind)
        {
            dwError = ERROR_INVALID_HANDLE;
            goto exit;
        }

        // Set signature and initial hash table find
        // handle in the newly allocated find handle.
        pFind->dwSig     = SIG_CACHE_FIND;
        pFind->dwHandle  = 0;
        pFind->dwFlags   = dwFlags;

        // Find the associated container. NULL prefix
        // results in enumeration over fixed containers.
        if (!szPrefix)
        {
            pFind->fFixed = TRUE;
            pFind->nIdx   = CONTENT;

        }
        else
        {

            idx = FindIndexFromPrefix(szPrefix);
            if (idx == NOT_AN_INDEX)
            {
                dwError = ERROR_NO_MORE_ITEMS;
                goto exit;
            }

            // Under old semantics prefix resolving to CONTENT
            // container implies that an enumeration over all
            // the fixed containers is desired. Enumeration then
            // begins with the CONTENT container. We do not keep
            // a refcount on any fixed containers in this case.
            if (idx == CONTENT && (dwFlags & FIND_FLAGS_OLD_SEMANTICS))
            {
                pFind->fFixed = TRUE;
                pFind->nIdx   = CONTENT;
            }
            else
            {
                // Otherwise only enumeration over the found container
                // is implied. Retrieve this container. Set fFixed to FALSE.
                //  NO RELEASE: hold RefCnt until handle is closed
                co = ConList.Get(idx);

                if (co)
                {
                    pFind->fFixed   = FALSE;
                    pFind->nIdx     = idx;
                    pFind->dwHandle = co->GetInitialFindHandle();
                }
                else
                {
                    dwError = ERROR_NO_MORE_ITEMS;
                    goto exit;
                }
            }

        }
        // Set filter and group id in handle.
        pFind->dwFilter = dwFilter;
        pFind->GroupId  = GroupId;
    }
    else
    {
        // Valid handle passed in - map it.
        //LOCK_CACHE();
        pFind = (CACHE_FIND_FIRST_HANDLE*) HandleMgr.Map (*phFind);
        //UNLOCK_CACHE();
        if (!pFind)
        {
            dwError = ERROR_INVALID_HANDLE;
            goto exit;
        }
    }

    // -------------------------------------------------------------------------
    // The handle is initialized or was created via a previous FindNextEntry.
    //--------------------------------------------------------------------------

    dwError = ERROR_NO_MORE_ITEMS;

    // Are we only enumerating over one container?
    if (!pFind->fFixed)
    {
        // Get the associated container.
        co = ConList.Get(pFind->nIdx);

        if (co)
        {
            // Enum on the container and release.
            dwError = co->FindNextEntry(&pFind->dwHandle, ppInfo, pcbInfo, pFind->dwFilter, pFind->GroupId, pFind->dwFlags, dwRetrievalFlags);
            co->Release(TRUE);
        }
        else
        {
            // Getting container failed.
            dwError = ERROR_NO_MORE_ITEMS;
            goto exit;
        }

    }
    else
    {
        // fFixed is TRUE - enumerate over the fixed containers.
        while (pFind->nIdx < NCONTAINERS)
        {
            // Get the associated container.
            co = ConList.Get(pFind->nIdx);

            if (co)
            {
                // Get the initial hash find handle if not already done so.
                if (!pFind->dwHandle)
                    pFind->dwHandle = co->GetInitialFindHandle();

                // Enum on the container and release.
                dwError = co->FindNextEntry(&pFind->dwHandle, ppInfo, pcbInfo, pFind->dwFilter, pFind->GroupId, pFind->dwFlags, dwRetrievalFlags);
                co->Release(TRUE);

                // Goto exit only if ERROR_NO_MORE_ITEMS.
                // This handles ERROR_SUCCESS correctly.
                if (dwError != ERROR_NO_MORE_ITEMS)
                    goto exit;

                // ERROR_NO_MORE_ITEMS: Go to next container
                // and begin enum anew.
                pFind->nIdx++;
                pFind->dwHandle = 0;
            }
            else
            {
                // Getting container failed.
                dwError = ERROR_NO_MORE_ITEMS;
                goto exit;
            }
        }
    }

exit:

    UNLOCK_CACHE();

    INET_ASSERT(*phFind != 0);
    INET_ASSERT(pFind != NULL);

    return dwError;
}

DWORD CConMgr::FindNextEntry(
      HANDLE              *phFind,
      LPCSTR               szPrefix,
      LPCACHE_ENTRY_INFOA  pInfo,
      LPDWORD              pcbInfo,
      DWORD                dwFilter,
      GROUPID              GroupId,
      DWORD                dwFlags)
{
    return FindNextEntry(
                phFind,
                szPrefix,
                (pInfo ? &pInfo : NULL),
                pcbInfo,
                dwFilter,
                GroupId,
                dwFlags,
                0);
}

/*-----------------------------------------------------------------------------
DWORD CConMgr::CleanupUrls
----------------------------------------------------------------------------*/
DWORD CConMgr::CleanupUrls
    (LPCTSTR szCachePath, DWORD dwFactor, DWORD dwFilter)
{
    DWORD dwError = ERROR_SUCCESS;

    UNIX_RETURN_ERR_IF_READONLY_CACHE(dwError);

    // Bad cleanup parameter.
    if (dwFactor <= 0 || dwFactor > 100)
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    // For null or empty path, clean up content container.
    if (!szCachePath || !*szCachePath)
    {
        _coContent->CleanupUrls(dwFactor, dwFilter);
    }
    else
    {
        LOCK_CACHE();

        // Find the container with the matching cache path and clean it up.
        for (DWORD idx = CONTENT; idx < NCONTAINERS; idx++)
        {
            URL_CONTAINER *co = ConList.Get(idx);

            if (co)
            {
                if (PathPrefixMatch(szCachePath, co->GetCachePath()))
                {
                    UNLOCK_CACHE();
                    co->CleanupUrls(dwFactor, dwFilter); // expensive?
                    LOCK_CACHE();
                    co->Release(TRUE);
                    break;
                }
                co->Release(TRUE);
            }
        }

        UNLOCK_CACHE();
    }

exit:
    return dwError;
}

/*-----------------------------------------------------------------------------
DWORD CConMgr::GetUrlInGroup
----------------------------------------------------------------------------*/
DWORD CConMgr::GetUrlInGroup(LPCSTR szUrl, GROUPID* pGroupId, LPDWORD pdwExemptDelta)
{
    URL_CONTAINER *co;
    DWORD dwError = ERROR_FILE_NOT_FOUND;
    // Find the associated container.
    LOCK_CACHE();
    DWORD idx = FindIndexFromPrefix(szUrl);

    co = ConList.Get(idx);

    if (co)
    {
        UNLOCK_CACHE();
        // Call GetUrlInGroup on the appropriate container.
        dwError = co->GetUrlInGroup(szUrl, pGroupId, pdwExemptDelta);
        LOCK_CACHE();
        co->Release(TRUE);
    }
    UNLOCK_CACHE();
    return dwError;
}


/*-----------------------------------------------------------------------------
DWORD CConMgr::CreateGroup()
  ----------------------------------------------------------------------------*/
DWORD CConMgr::CreateGroup(DWORD dwFlags, GROUPID* pGID)
{
    INET_ASSERT(_coContent);

    LOCK_CACHE();

    GroupMgr gm;
    DWORD dwError = ERROR_WINHTTP_INTERNAL_ERROR;

    if( gm.Init(_coContent) )
    {
        dwError = gm.CreateGroup(dwFlags, pGID);
    }


    UNLOCK_CACHE();
    return dwError;
}

/*-----------------------------------------------------------------------------
DWORD CConMgr::CreateDefaultGroups()
  ----------------------------------------------------------------------------*/
DWORD CConMgr::CreateDefaultGroups()
{
    INET_ASSERT(_coContent); 

    LOCK_CACHE();

    GroupMgr gm;
    DWORD dwError = ERROR_WINHTTP_INTERNAL_ERROR;

    if( gm.Init(_coContent) )
    {
        dwError = gm.CreateDefaultGroups();
    }


    UNLOCK_CACHE();
    return dwError;
}

/*-----------------------------------------------------------------------------
DWORD CConMgr::DeleteGroup()
  ----------------------------------------------------------------------------*/
DWORD CConMgr::DeleteGroup(GROUPID gid, DWORD dwFlags)
{
    INET_ASSERT(_coContent);

    LOCK_CACHE();
    GroupMgr gm;
    DWORD dwError = ERROR_WINHTTP_INTERNAL_ERROR;

    if( gm.Init(_coContent) )
    {
        dwError = gm.DeleteGroup(gid, dwFlags);
    }

    UNLOCK_CACHE();

    return dwError;
}


/*-----------------------------------------------------------------------------
DWORD CConMgr::FindNextGroup()
  ----------------------------------------------------------------------------*/
DWORD CConMgr::FindNextGroup(
      HANDLE*                               phFind,
      DWORD                                 dwFlags,
      GROUPID*                              pGroupId
)
{
    DWORD                      dwError;
    GROUP_FIND_FIRST_HANDLE*   pFind = NULL;
    GroupMgr gm;

    INET_ASSERT(_coContent);
    LOCK_CACHE();


    // Null handle initiates enumeration.
    if (!*phFind)
    {
        // BUGBUG currently only supports SEARCH_ALL option
        if( dwFlags )
        {
            dwError = ERROR_INVALID_PARAMETER;
            goto exit;
        }


        // Allocate a handle.
        *phFind = HandleMgr.Alloc (sizeof(GROUP_FIND_FIRST_HANDLE));
        if (*phFind)
            pFind = (GROUP_FIND_FIRST_HANDLE*) HandleMgr.Map (*phFind);

        if (!*phFind)
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }

        if (!pFind)
        {
            dwError = ERROR_INVALID_HANDLE;
            goto exit;
        }

        // Set signature and initial hash table find
        // handle in the newly allocated find handle.
        pFind->dwSig  = SIG_GROUP_FIND;
        pFind->fFixed = TRUE;
        pFind->nIdx = CONTENT;
        pFind->dwLastItemOffset = 0;
    }
    else
    {
        // Valid handle passed in - map it.
        pFind = (GROUP_FIND_FIRST_HANDLE*) HandleMgr.Map (*phFind);
        if (!pFind)
        {
            dwError = ERROR_INVALID_HANDLE;
            goto exit;
        }
    }

    //
    // The handle is initialized or was created via a previous FindNextEntry.
    //

    dwError = ERROR_FILE_NOT_FOUND;

    // Enum on the container and release.
    if( gm.Init(_coContent) )
    {
        DWORD dwLastItemOffset = pFind->dwLastItemOffset;

        dwError = gm.GetNextGroup(&dwLastItemOffset, pGroupId);

        // update offset field of the find handle
        pFind->dwLastItemOffset = dwLastItemOffset;

    }

exit:

    UNLOCK_CACHE();
    INET_ASSERT(*phFind != 0);
    INET_ASSERT(pFind != NULL);

    return dwError;
}

/*-----------------------------------------------------------------------------
DWORD CConMgr::GetGroupAttributes()
  ----------------------------------------------------------------------------*/
DWORD CConMgr::GetGroupAttributes(
    GROUPID                             gid,
    DWORD                               dwAttrib,
    LPINTERNET_CACHE_GROUP_INFOA        lpGroupInfo,
    LPDWORD                             lpdwGroupInfo
    )
{
    INET_ASSERT(_coContent);
    DWORD dwError = ERROR_WINHTTP_INTERNAL_ERROR;

    LOCK_CACHE();
    GroupMgr gm;
    if( gm.Init(_coContent) )
    {
        dwError = gm.GetGroup(gid, dwAttrib, lpGroupInfo, lpdwGroupInfo);
    }

    UNLOCK_CACHE();
    return dwError;
}


/*-----------------------------------------------------------------------------
DWORD CConMgr::SetGroupAttributes()
  ----------------------------------------------------------------------------*/
DWORD CConMgr::SetGroupAttributes(
    GROUPID                             gid,
    DWORD                               dwAttrib,
    LPINTERNET_CACHE_GROUP_INFOA        lpGroupInfo
    )
{
    INET_ASSERT(_coContent);
    DWORD dwError = ERROR_WINHTTP_INTERNAL_ERROR;

    LOCK_CACHE();
    GroupMgr gm;
    if( gm.Init(_coContent))
    {
        dwError = gm.SetGroup(gid, dwAttrib, lpGroupInfo);
    }

    UNLOCK_CACHE();
    return dwError;
}


DWORD CConMgr::RegisterCacheNotify(
    HWND    hWnd,
    UINT    uMsg,
    GROUPID gid,
    DWORD   dwFilter
    )
{
    DWORD dwError;
    INET_ASSERT(_coContent);
    dwError = _coContent->RegisterCacheNotify(hWnd, uMsg, gid, dwFilter);
    return dwError;
}

DWORD CConMgr::SendCacheNotification( DWORD  dwOp)
{
    DWORD dwError;

    INET_ASSERT(_coContent);
    _coContent->SendCacheNotification(dwOp);
    return ERROR_SUCCESS;
}

/*-----------------------------------------------------------------------------
VOID CConMgr::GetCacheInfo
----------------------------------------------------------------------------*/
VOID CConMgr::GetCacheInfo(LPCSTR szPrefix, LPSTR szCachePath, LONGLONG *cbLimit)
{
    URL_CONTAINER *co;
    // Find the associated container.

    LOCK_CACHE();
    DWORD idx = FindIndexFromPrefix(szPrefix);
    
    co = ConList.Get(idx);
    
    if (co)
    {
        // Call GetCacheInfo on the appropriate container.
        co->GetCacheInfo(szCachePath, cbLimit);
        co->Release(TRUE);
    }

    UNLOCK_CACHE();
}



/*-----------------------------------------------------------------------------
VOID CConMgr::SetCacheLimit
----------------------------------------------------------------------------*/
VOID CConMgr::SetCacheLimit(LONGLONG cbLimit, DWORD idx)
{
    URL_CONTAINER *co;
    // Find the associated container.

    UNIX_RETURN_IF_READONLY_CACHE;
    
    LOCK_CACHE();
    co = ConList.Get(idx);
    
    if (co)
    {
        // Call SetCacheLimit on the container.
        co->SetCacheLimit(cbLimit);
        co->Release(TRUE);
    }

    UNLOCK_CACHE();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\urlcache\cachecfg.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    cachecfg.cxx

Abstract:

    This module contains the functions to get and set disk cache
    configuration parameters.

    Contents:
        GetCacheConfigInfoA
        SetCacheConfigInfoA

Author:

    Sophia Chung (sophiac)  1-May-1995
    
Environment:

    User Mode - Win32

Revision History:
    Mucho rewritten by Akabir   1Q 98

    To understand how the new registration code works, it might be better for you to start with ConfigureCache, 
    GetCacheConfigInfo, etc. for a high level acquaintance; _then_ start poring over the actual registry sets code.
--*/

#include <wininetp.h>
#include <cache.hxx>
#include <conmgr.hxx>
#include <time.h>

#include <shlobj.h>

#define CACHE_TAG           "Cache"

// Cache path keys.
CHAR* g_szSubKey[] = {CONTENT_PATH_KEY, COOKIE_PATH_KEY, HISTORY_PATH_KEY};
CHAR* g_szOldSubKey[] = {CACHE_TAG, COOKIE_PATH_KEY, HISTORY_PATH_KEY};

INT g_iContainerCSIDL[] = { CSIDL_INTERNET_CACHE, CSIDL_COOKIES, CSIDL_HISTORY };
                                
// Top level cache paths resource IDs
#ifndef UNIX
CHAR* g_dwCachePathResourceID[] = {IDS_CACHE_DEFAULT_SUBDIR, IDS_COOKIES_DEFAULT_SUBDIR, IDS_HISTORY_DEFAULT_SUBDIR};
#else
CHAR* g_dwCachePathResourceID[] = {IDS_CACHE_DEFAULT_SUBDIR_UNIX, IDS_COOKIES_DEFAULT_SUBDIR, IDS_HISTORY_DEFAULT_SUBDIR};
#endif /* UNIX */

// Cache prefixes.
CHAR* g_szCachePrefix[] = {CONTENT_PREFIX, COOKIE_PREFIX, HISTORY_PREFIX};
CHAR* g_szVersionName[] = { CONTENT_VERSION_SUBDIR, "", "History.IE5" };

#define OLD_CACHE_PATH      "Path1"
#define OLD_CACHE_SUBKEY    DIR_SEPARATOR_STRING##"Cache1"

typedef BOOL (WINAPI *PFNGETDISKFREESPACEEX)(LPCTSTR, PULARGE_INTEGER, PULARGE_INTEGER, PULARGE_INTEGER);

void FlushShellFolderCache()
{
    SHFlushSFCacheWrap( );
    return;
}

typedef HRESULT (*PFNSHGETFOLDERPATH)(HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, LPSTR pszPath);

VOID CheckCacheLocationConsistency();

//#define DEBUG_CACHE_UPGRADE

#ifdef DEBUG_CACHE_UPGRADE
VOID LOG_UPGRADE_DATA(PTSTR pszData)
{
    CHAR szFileName[MAX_PATH];
    DWORD dwSize = MAX_PATH;
    CHAR szComputerName[MAX_PATH];
    HANDLE hResultsFile = NULL;
    strcpy(szFileName, "\\\\BANYAN\\IPTD\\AKABIR\\cacheupgrade\\");
    if (!GetComputerNameA(szComputerName, &dwSize))
    {
        goto exit;
    }
    lstrcatA(szFileName, szComputerName);
    hResultsFile = CreateFileA( szFileName,
                        GENERIC_WRITE,
                        FILE_SHARE_WRITE | FILE_SHARE_READ,
                        NULL,
                        OPEN_ALWAYS,
                        0,
                        NULL);
    if (hResultsFile != INVALID_HANDLE_VALUE)
    {
        if (SetFilePointer(hResultsFile, 0, NULL, FILE_END)==0xFFFFFFFF)
        {
            goto exit;
        }
        DWORD dwFoo;
        if (0==WriteFile(hResultsFile, (PVOID)pszData, lstrlenA(pszData), &dwFoo, NULL))
        {
            DWORD dwE = GetLastError();
        }
    }
exit:
    if (hResultsFile)
    {
        CloseHandle(hResultsFile);
    }
}
#else
#define LOG_UPGRADE_DATA(x)
#endif

#undef SHGetFolderPath

HRESULT SHGetFolderPath(HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, LPSTR pszPath)
{
    HRESULT hr = E_POINTER;
    static PFNSHGETFOLDERPATH pfn = NULL;

    if (NULL == pfn)
    {
        if (NULL == g_HMODShell32)
            g_HMODShell32 = LoadLibrary("shell32.dll");
        if (NULL != g_HMODShell32)
            pfn = (PFNSHGETFOLDERPATH)GetProcAddress(g_HMODShell32, "SHGetFolderPathA");

        if (NULL == pfn)
        {
            if (NULL == g_HMODSHFolder)
                g_HMODSHFolder = LoadLibrary("shfolder.dll");
            if (NULL != g_HMODSHFolder)
                pfn = (PFNSHGETFOLDERPATH)GetProcAddress(g_HMODSHFolder, "SHGetFolderPathA");
        }
        
        if (NULL != pfn)
            hr = pfn(hwnd, csidl, hToken, dwFlags, pszPath);
    }
    else
        hr = pfn(hwnd, csidl, hToken, dwFlags, pszPath);

    return hr;
}

#define CACHE_SIZE_CAP 32000000

DWORD 
GetDefaultCacheQuota(
    LPSTR pszCachePath, 
    DWORD dwFraction
    )
{ 
    DWORDLONG cKBLimit = 0, cbTotal;

    if (GetDiskInfo(pszCachePath, NULL, NULL, &cbTotal))
    {
        cKBLimit = (cbTotal / (DWORDLONG)(1024*dwFraction));
    }
    if (cKBLimit<1024)
    {
        cKBLimit = DEF_CACHE_LIMIT;
    }
    else if (cKBLimit > CACHE_SIZE_CAP)
    {
        cKBLimit = CACHE_SIZE_CAP;
    }

    return (DWORD)cKBLimit;
}
        
VOID CleanPath(PTSTR pszPath);

/*-----------------------------------------------------------------------------
NormalisePath
 (code swiped from shell32\folder.c: UnexpandEnvironmentstring)

  Collapses paths of the form C:\foobar\dir1\...\dirn to
  %FOOBAR%\dir1\...\dirn
  where %FOOBAR% = "C:\foobar".
  storing result in pszOut.

  If collapse is not possible, returns FALSE and path is unchanged.
  If the given environment variable exists as the first part of the path,
  then the environment variable is inserted into the output buffer.

  Returns TRUE if pszResult is filled in.
  Example:  Input  -- C:\WINNT\SYSTEM32\FOO.TXT -and- lpEnvVar = %SystemRoot%
            Output -- %SystemRoot%\SYSTEM32\FOO.TXT

---------------------------------------------------------------------------*/


BOOL NormalisePath(LPCTSTR pszPath, LPCTSTR pszEnvVar, LPTSTR pszResult, UINT cbResult)
{
    TCHAR szEnvVar[MAX_PATH];
//     DWORD dwEnvVar = ExpandEnvironmentStrings(pszEnvVar, szEnvVar, sizeof(szEnvVar)) - 1; // don't count the NULL
//    akabir: a curious bug? causes ExpandEnvironmentStrings to return twice the number of characters.

    ExpandEnvironmentStrings(pszEnvVar, szEnvVar, sizeof(szEnvVar)-1); // don't count the NULL
    DWORD dwEnvVar = lstrlen(szEnvVar);

    if (CompareString(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, szEnvVar, dwEnvVar, pszPath, dwEnvVar) == 2) 
    {
        if (lstrlen(pszPath) + dwEnvVar < cbResult)
        {
            strncpy(pszResult, pszEnvVar, MAX_PATH);
            strncat(pszResult, pszPath + dwEnvVar, MAX_PATH);
            return TRUE;
        }
    }
    return FALSE;
}

VOID CompressPath(LPTSTR pszSrc, LPTSTR pszDest)
{
    if (!NormalisePath(pszSrc, TEXT("%USERPROFILE%"), pszDest, MAX_PATH))
    {
        if (!NormalisePath(pszSrc, TEXT("%SystemRoot%"), pszDest, MAX_PATH))
        {
            strncpy(pszDest, pszSrc, MAX_PATH);
        }
    }
}

// ------------------------------------------------------------------------------------------------
// IE 3, 4 and 5 have different registry settings. These classes help ensure they all stay in sync.


// -- IE5's registry set ------------------------------------------------------------------------------------------------
// *** If using multiple registry sets, use InitialiseKeys for IE5 first.***
// This is to ensure that profiles-capabilities are noted.

class IE5_REGISTRYSET
{
protected:
    REGISTRY_OBJ m_roHKLMCache, m_roHKCUCache, m_roShellFolder, m_roUserShellFolder, m_roWorking;
    BOOL m_fProfiles;
    BOOL m_fWorkingPerUser;
    TCHAR m_szSharedPath[MAX_PATH];
    TCHAR m_szProfilePath[MAX_PATH];
    DWORD cbP, cbS, m_dwWorking;
    BOOL m_fInitialised;
    
    DWORD InitCommonKeys(BOOL fProfilesCapable, LPSTR pszReg)
    {
        DWORD dwError, dwFlag = CREATE_KEY_IF_NOT_EXISTS;

        m_fProfiles = fProfilesCapable;
        // Shared item info are located in HKLM/[...]/Internet Settings/5.0/Cache/*
        m_roHKLMCache.WorkWith(HKEY_LOCAL_MACHINE, pszReg, dwFlag);
        if (dwError = m_roHKLMCache.GetStatus()!=ERROR_SUCCESS)
        {
            m_roHKLMCache.WorkWith(HKEY_LOCAL_MACHINE, pszReg, dwFlag, BASIC_ACCESS);
            if (dwError = m_roHKLMCache.GetStatus()!=ERROR_SUCCESS)
                goto exit;
        }

        m_roShellFolder.WorkWith(HKEY_CURRENT_USER, SHELL_FOLDER_KEY, dwFlag);
        if (dwError = m_roShellFolder.GetStatus()!=ERROR_SUCCESS)
                goto exit;

        if (fProfilesCapable)
        {
            m_roHKCUCache.WorkWith(HKEY_CURRENT_USER, pszReg, dwFlag);
            if (dwError = m_roHKCUCache.GetStatus()!=ERROR_SUCCESS)
                goto exit;
        }

        m_roUserShellFolder.WorkWith(HKEY_CURRENT_USER, USER_SHELL_FOLDER_KEY, dwFlag);
        dwError = m_roUserShellFolder.GetStatus();
        if (dwError==ERROR_SUCCESS)
        {
            m_fInitialised = TRUE;
        }
        // Per-user items are located in HKCU/[...]/Explorer/Shell Folders and /Internet Settings/[5.0/]Cache/*
    exit:
        return dwError;
    }

    virtual BOOL DetermineKeyPlacing(DWORD dwWhich)
    {
        // Determine if this is a per-user item
        // HKCU overrides HKLM
        // If any of the following fail, for content, we'll default to shared.

        if (!m_fProfiles)
        {
            return FALSE;    
        }
        
        DWORD dwTemp;
        REGISTRY_OBJ roCUContainer(&m_roHKCUCache, g_szSubKey[dwWhich], CREATE_KEY_IF_NOT_EXISTS);
        if ((roCUContainer.GetStatus()==ERROR_SUCCESS)
            &&
            (roCUContainer.GetValue(PER_USER_KEY, &dwTemp)==ERROR_SUCCESS))
        {
            return dwTemp;
        }
        
        REGISTRY_OBJ roLMContainer(&m_roHKLMCache, g_szSubKey[dwWhich], CREATE_KEY_IF_NOT_EXISTS);
        BOOL fPerUser = FALSE;

        if ((roLMContainer.GetStatus()==ERROR_SUCCESS)
            &&
            (roLMContainer.GetValue(PER_USER_KEY, &dwTemp)==ERROR_SUCCESS))
        {
            return dwTemp;
        }  

        // On NT, the default will be a per-user container.
#ifndef UNIX
        dwTemp = (GlobalPlatformType == PLATFORM_TYPE_WINNT) ? TRUE : (dwWhich!=CONTENT);
#else
        dwTemp = (GlobalPlatformType == PLATFORM_TYPE_UNIX) ? TRUE : (dwWhich!=CONTENT);
#endif /* UNIX */

        roLMContainer.SetValue(PER_USER_KEY, &dwTemp);
        roCUContainer.SetValue(PER_USER_KEY, &dwTemp);
        return (BOOL)dwTemp;
    }


    // -- ValidatePath ------
    // We always assume we've been given a valid path, but we have to test that it's there
    // and available.
    BOOL ValidatePath(PSTR pszPath)
    {
        DWORD dwAttribute = GetFileAttributes(pszPath);
        if (dwAttribute==0xFFFFFFFF)
        {
            // We assume that the directory just isn't there. So we create it.
            hConstructSubDirs(pszPath);
            dwAttribute = GetFileAttributes(pszPath);
        }
        if ((dwAttribute==0xFFFFFFFF)
            ||
            (dwAttribute & FILE_ATTRIBUTE_READONLY)
            ||
            (!(dwAttribute & FILE_ATTRIBUTE_DIRECTORY)))
        {
            // BUG BUG BUG We probably want to make sure that the old path gets deleted on other machines....
            // We'll use the system path
            // BUG BUG BUG BUG BUG We are *NOT* recording this default location in the registry. Thus, on another
            // machine, the user might still be able to use the set cache location.
            memcpy(pszPath, m_szSharedPath, cbS);

#if 0
            LoadString(GlobalDllHandle, g_dwCachePathResourceID[m_dwWorking], pszPath+cbS, MAX_PATH - cbS);
#endif
            memcpy(pszPath+cbS, g_dwCachePathResourceID[m_dwWorking], 
                    strlen(g_dwCachePathResourceID[m_dwWorking]) + 1);
            
            SetPerUserStatus(FALSE);
        }
        return ERROR_SUCCESS;
    }
    
public:
    IE5_REGISTRYSET()
    {
        m_fInitialised = FALSE;
    }

    virtual DWORD InitialiseKeys(BOOL& fProfilesCapable)
    {
        if (m_fInitialised)
        {
            fProfilesCapable = m_fProfiles;
            return ERROR_SUCCESS;
        }

        DWORD dwError = ERROR_SUCCESS;

        fProfilesCapable = TRUE;
#ifndef UNIX
        cbS = GetWindowsDirectory(m_szSharedPath, sizeof(m_szSharedPath));
#else
        /* On Unix, GetWindowsDirectory points to <install dir>/common
         * And, we don't want to put the cache here.
         */
        lstrcpy(m_szSharedPath, UNIX_SHARED_CACHE_PATH);
        cbS = lstrlen(m_szSharedPath);
#endif /* UNIX */
        if (!cbS || (cbS>sizeof(m_szSharedPath)))
            return ERROR_PATH_NOT_FOUND;
            
        AppendSlashIfNecessary(m_szSharedPath, &cbS);

        cbP = 0;
        // We think that profiles are enabled, so we want to get some info before
        // proceeding. If any of this fails, though, we'll default to no profiles.
        switch (GlobalPlatformType)
        {
#ifndef UNIX
        case PLATFORM_TYPE_WIN95:
        {
            REGISTRY_OBJ roProfilesEnabled(HKEY_LOCAL_MACHINE, PROFILES_ENABLED_VALUE);
            DWORD dwProfilesEnabled = 0;
            if (  (roProfilesEnabled.GetStatus() == ERROR_SUCCESS)
                && 
                  ((roProfilesEnabled.GetValue(PROFILES_ENABLED, &dwProfilesEnabled))==ERROR_SUCCESS)
                &&
                  dwProfilesEnabled)
            {                        
                  // Windows 95 sets the profiles path in the registry.
                CHAR szProfilesRegValue[MAX_PATH];
                memcpy(szProfilesRegValue, PROFILES_PATH_VALUE, sizeof(PROFILES_PATH_VALUE)-1);
                cbP = sizeof(PROFILES_PATH_VALUE)-1;
                AppendSlashIfNecessary(szProfilesRegValue, &cbP);
                cbP = MAX_PATH-sizeof(PROFILES_PATH_VALUE);
                if (GetUserName(szProfilesRegValue + sizeof(PROFILES_PATH_VALUE), &cbP))
                {
                    cbP = MAX_PATH;
                    REGISTRY_OBJ roProfilesDirKey(HKEY_LOCAL_MACHINE, szProfilesRegValue);

                    if (!(((dwError = roProfilesDirKey.GetStatus()) != ERROR_SUCCESS)
                        || 
                        ((dwError = roProfilesDirKey.GetValue(PROFILES_PATH, (LPBYTE) m_szProfilePath, 
                                &cbP)) != ERROR_SUCCESS)))
                    {
                        m_szProfilePath[cbP-1] = DIR_SEPARATOR_CHAR;
                        m_szProfilePath[cbP] = '\0';
                        break;
                    }
                }
            }
            // Either
            // (a) Couldn't get the profiles path from the registry.
            // (b) Couldn't get the user name! 
            // Make the directory the windows directory
            fProfilesCapable = FALSE;
            break;
        }
            
        case PLATFORM_TYPE_WINNT:
            // Windows NT sets the USERPROFILE environment
            // string which contains the user's profile path
            if (cbP = GetEnvironmentVariable("USERPROFILE", m_szProfilePath, MAX_PATH))
            {
                m_szProfilePath[cbP++] = DIR_SEPARATOR_CHAR;
                m_szProfilePath[cbP] = '\0';
            }
            else
            {
                INET_ASSERT(FALSE);
                // Getting the user profiles dir from the environment
                // failed. Set the profiles directory to default.
                memcpy(m_szProfilePath, m_szSharedPath, cbS);
                memcpy(m_szProfilePath + cbS, DEFAULT_PROFILES_DIRECTORY, sizeof(DEFAULT_PROFILES_DIRECTORY));
                cbP = cbS + sizeof(DEFAULT_PROFILES_DIRECTORY) - 1;

                DWORD cbUser = MAX_PATH - cbP;;
                GetUserName(m_szProfilePath + cbP, &cbUser);
                cbP += cbUser;
            }
            break;

#else /* UNIX */
        case PLATFORM_TYPE_UNIX:
            lstrcpy(m_szProfilePath,TEXT("%USERPROFILE%"));
            lstrcat(m_szProfilePath,DIR_SEPARATOR_STRING);
            cbP = lstrlen(m_szProfilePath);
            break;
#endif /* UNIX */

        default:
            // This should never happen.
            INET_ASSERT(FALSE);
        }

        if (dwError==ERROR_SUCCESS)
        {
            dwError = InitCommonKeys(fProfilesCapable, CACHE5_KEY);
        }
        return dwError;
    }

    DWORD SetWorkingContainer(DWORD dwWhich)
    {
        m_dwWorking = dwWhich;
        m_fWorkingPerUser = DetermineKeyPlacing(dwWhich);
        return m_roWorking.WorkWith((m_fWorkingPerUser ? &m_roHKCUCache : &m_roHKLMCache), g_szSubKey[dwWhich], CREATE_KEY_IF_NOT_EXISTS);
    }

    // VOID AttemptToUseSharedCache(PTSTR pszPath, DWORD ckbLimit);

    // Path --------------------------------------------------------------------------
    virtual DWORD GetPath(PTSTR pszPath)
    {
        if ((S_OK==SHGetFolderPath(NULL, g_iContainerCSIDL[m_dwWorking] | CSIDL_FLAG_CREATE, NULL, 0, pszPath))
            && (*pszPath!='\0'))
        {
            DWORD dwErr = ValidatePath(pszPath);
            if (dwErr==ERROR_SUCCESS)
            {
                DWORD ccPath = lstrlen(pszPath);
                // We check the lengths of the strings only when we're moving the containers. No need to do the check every
                // time (assume a valid path)
                if (m_dwWorking!=COOKIE)
                {
                    EnableCacheVu(pszPath, m_dwWorking);
                }
                AppendSlashIfNecessary(pszPath, &ccPath);

#ifdef UNIX
               /* On Unix, it is possible that IE4 and IE5 co-exist on a user's
                * installation. So, we need to keep the IE4 cookies which are
                * different from the IE5 cookies. For IE5, we have the following
                * configuration for the caches -
                *
                * cookies - %HOME%/.microsoft/ie5/Cookies
                * content - %HOME%/.microsoft/ie5/TempInternetFiles/Content.IE5
                * history - %HOME%/.microsoft/ie5/History/History.IE5
                */
               CHAR szIE5Dir[] = "ie5/";
               int  index = ccPath-2; // skip the last slash
               int  lenIE5Dir = lstrlen(szIE5Dir);

               while(index >= 0 && pszPath[index] != FILENAME_SEPARATOR) 
                    index--;

               index++;
               memmove(&pszPath[index+lenIE5Dir],&pszPath[index],ccPath-index+2);
               memcpy(&pszPath[index],szIE5Dir,lenIE5Dir);
               ccPath += lenIE5Dir;
#endif /* UNIX */

                memcpy(pszPath+ccPath, g_szVersionName[m_dwWorking], lstrlen(g_szVersionName[m_dwWorking])+1);
                if (GlobalIdentity && (m_dwWorking!=CONTENT))
                {
                    if (!GenerateStringWithOrdinal(NULL, GlobalIdentity, pszPath, MAX_PATH))
                    {
                        dwErr = ERROR_WINHTTP_INTERNAL_ERROR;
                    }
                }
            }
            return dwErr;
        }
        return ERROR_WINHTTP_INTERNAL_ERROR;
    }

    virtual DWORD SetPath(PTSTR pszPath)
    {
        INET_ASSERT(m_roWorking.GetStatus()==ERROR_SUCCESS);
        DWORD dwError;

        /* Try to preserve the environment variables on Unix */
        UNIX_NORMALIZE_PATH_ALWAYS(pszPath, TEXT("%USERPROFILE%"));
        if (m_fProfiles)
        {
            CHAR szScratch[MAX_PATH];
            CompressPath(pszPath, szScratch);
            if ((dwError = m_roUserShellFolder.SetValue(g_szOldSubKey[m_dwWorking], szScratch, REG_EXPAND_SZ))==ERROR_SUCCESS)
            {
#ifndef UNIX
               DWORD dwType = REG_SZ;
                dwError = m_roShellFolder.SetValue(g_szOldSubKey[m_dwWorking],pszPath, dwType);
#else
                dwError = m_roShellFolder.SetValue(g_szOldSubKey[m_dwWorking],szScratch, REG_EXPAND_SZ);
#endif /* UNIX */
            }
            // Possible BUG: If we move from the profiled path to the shared path, we still record it as a peruseritem.
            SetPerUserStatus(TRUE);            
        }
        // Non-profiles-enabled machine
        // On Win9x machines, with profiles disabled, we need to write the path to the 
        // HKEY_USERS/.default/blah blah/Explorer/User Shell Folders to ensure that SHGetFolderPath returns
        // the proper value for other users. 
        else
        {
            REGISTRY_OBJ roProfilesLessPath(HKEY_USERS, PROFILELESS_USF_KEY);
            dwError = roProfilesLessPath.GetStatus();
            if (dwError==ERROR_SUCCESS)
            {
                if ((dwError = roProfilesLessPath.SetValue(g_szOldSubKey[m_dwWorking],pszPath, REG_EXPAND_SZ))==ERROR_SUCCESS)
                {
#ifndef UNIX
                    DWORD dwType = REG_SZ;
#else
                    DWORD dwType = REG_EXPAND_SZ;
#endif /* UNIX */
                    dwError = m_roUserShellFolder.SetValue(g_szOldSubKey[m_dwWorking],pszPath, dwType);
                }
            }
            // For IE4 compatibility, we might have to adjust the old cache location here, as well.
        }
        return dwError;
    }


    // Prefix ------------------------------------------------------------------------
    virtual DWORD GetPrefix(LPSTR szPrefix)
    {
        DWORD dwError, cbKeyLen = MAX_PATH;
        if ((dwError = m_roWorking.GetValue(CACHE_PREFIX_VALUE, (LPBYTE) szPrefix, &cbKeyLen))==ERROR_SUCCESS)
        {
            if (cbKeyLen > 0)
            {
                // Strip trailing whitespace.
                cbKeyLen--;
                StripTrailingWhiteSpace(szPrefix, &cbKeyLen);
            }
        }
        else
        {
            // If no prefix found in registry create via
            // defaults and write back to registry.
            strncpy(szPrefix, g_szCachePrefix[m_dwWorking], MAX_PATH);
            SetPrefix(szPrefix);
            dwError = ERROR_SUCCESS;
        }
        
        return dwError;
    }

    virtual DWORD SetPrefix(PTSTR pszPrefix)
    {
        INET_ASSERT(m_roWorking.GetStatus()==ERROR_SUCCESS);
        return m_roWorking.SetValue(CACHE_PREFIX_VALUE, (pszPrefix) ? pszPrefix : g_szCachePrefix[m_dwWorking], REG_SZ);
    }

    // Limit -------------------------------------------------------------------------
    virtual DWORD GetLimit(PTSTR pszCachePath, DWORD& cbLimit)
    {
        if ((m_roWorking.GetValue(CACHE_LIMIT_VALUE, &cbLimit)!=ERROR_SUCCESS) || (cbLimit < 512))
        {
            cbLimit = 0;
            return SetLimit(pszCachePath, cbLimit);
        }
        return ERROR_SUCCESS;
    }

    // virtual DWORD SetLimit(PTSTR pszCachePath, DWORD& cbLimit);

    virtual DWORD SetLimit(PTSTR pszCachePath, DWORD& cbLimit)
    {
    INET_ASSERT(m_roWorking.GetStatus()==ERROR_SUCCESS);
    // If no limit found in registry create via
    // defaults and write back to registry.
    // Cache limit - for the content cache we calculate the cache limit
    // as being max(DEF_CACHE_LIMIT, 1/32 of the disk size) All others caches
    // are set to DEF_CACHE_LIMIT.
    if (cbLimit==0)
    {
        cbLimit = (m_dwWorking==CONTENT) 
                        ? GetDefaultCacheQuota(pszCachePath, NEW_CONTENT_QUOTA_DEFAULT_DISK_FRACTION)
                        : DEF_CACHE_LIMIT;
    }
    DWORD dwError = m_roWorking.SetValue(CACHE_LIMIT_VALUE, &cbLimit);

    /*
    if (dwError==ERROR_SUCCESS)
    {
        // Hack so that apps that read the cache quota from the registry are
        // still able to do so.
        IE4_REGISTRYSET ie4;
        dwError = ie4.InitialiseKeys(m_fProfiles);
        if (dwError==ERROR_SUCCESS)
        {
            ie4.SetWorkingContainer(m_dwWorking);
            ie4.SetLimit(pszCachePath, cbLimit);
        }
    }
    */ 
    
    return dwError;
    }

    // Use IsFirstTime* to figure out if this is the first time for this install of wininet and for marking it so ------------
private:
    BOOL IsFirstTimeFor(HKEY hKey)
    {
        DWORD cb = MAX_PATH;
        CHAR szSigKey[MAX_PATH];
        REGISTRY_OBJ roSig(hKey, CACHE5_KEY);

        return roSig.GetValue(CACHE_SIGNATURE_VALUE, (LPBYTE) szSigKey, &cb)==ERROR_SUCCESS ? 
                        strcmp(szSigKey, CACHE_SIGNATURE) : TRUE;
    }

public:
    BOOL IsFirstTimeForUser()
    {
        return IsFirstTimeFor((m_fProfiles ? HKEY_CURRENT_USER : HKEY_LOCAL_MACHINE));
    }

    BOOL IsFirstTimeForMachine()
    {
        return IsFirstTimeFor(HKEY_LOCAL_MACHINE);
    }

    VOID SetIfFirstTime()
    {
        DWORD cb = MAX_PATH;
        CHAR szSigKey[MAX_PATH];

        // On a profiles-not-enabled machine, store the signature in HKLM so we don't have to research for values
        // On a profiles-enabled machine, store there to notify IE of previous installation of IE5.
        REGISTRY_OBJ roSig(HKEY_LOCAL_MACHINE, CACHE5_KEY);
        roSig.SetValue(CACHE_SIGNATURE_VALUE, CACHE_SIGNATURE, REG_SZ);

        // On profiles-enabled machines,  we store a signature in HKCU so that we don't have to do 
        // much hunting for registry values
        if (m_fProfiles)
        {
            REGISTRY_OBJ roSig(HKEY_CURRENT_USER, CACHE5_KEY);
            roSig.SetValue(CACHE_SIGNATURE_VALUE, CACHE_SIGNATURE, REG_SZ);
        }        
    }

    // PerUserItem ---------------------------------------------------------------------
    virtual VOID SetPerUserStatus(BOOL fState)
    {
        DWORD flState = fState;
        if (m_fProfiles && fState!=m_fWorkingPerUser)
        {
            REGISTRY_OBJ roTemp(&m_roHKCUCache, g_szSubKey[m_dwWorking], CREATE_KEY_IF_NOT_EXISTS);            
            if (roTemp.GetStatus()==ERROR_SUCCESS)
            {
                roTemp.SetValue(PER_USER_KEY, &flState);
                m_roWorking.WorkWith((fState ? &m_roHKCUCache
                                             : &m_roHKLMCache), g_szSubKey[m_dwWorking], CREATE_KEY_IF_NOT_EXISTS);
                m_fWorkingPerUser = fState;
            }
        }
    }

    virtual DWORD GetPerUserStatus()
    {
        return m_fWorkingPerUser;
    }

/*
    DWORD UpdateContentPath(PSTR pszNewPath)
    {
        TCHAR szOldPath[MAX_PATH];
        DWORD dwError;

        dwError = ERROR_SUCCESS;

        if ((dwError=SetWorkingContainer(CONTENT))==ERROR_SUCCESS)
        {
            INTERNET_CACHE_CONFIG_INFOA icci;
            icci.dwContainer = CONTENT;
            GetUrlCacheConfigInfoA(&icci, NULL, CACHE_CONFIG_DISK_CACHE_PATHS_FC);
            strncpy(szOldPath, icci.CachePath, ARRAY_ELEMENTS(szOldPath));

            if (((dwError=MoveCachedFiles(szOldPath, pszNewPath))==ERROR_SUCCESS)
                &&
                ((dwError=SetPath(pszNewPath))==ERROR_SUCCESS))
            {
                EnableCacheVu(pszNewPath);

            // Right now, we're adding entries so that once we restart, we'll delete any
            // stray files.

            // BUT, there's a case that Move will be interrupted; in that case, we ought
            // to finish the move on start up -- pop up a dialog notifying user of such
            // and then delete.
            // Also, if the Move's interrupted, then this info never will get written. OTOH,
            // we can argue that the user can just move from the old location to the new.
    
                CHAR szRunOnce          [2 * MAX_PATH];
                CHAR szSystemPath       [MAX_PATH];

            // Add a RunOnce entry to be run on reboot.
                REGISTRY_OBJ roRunOnce((m_fWorkingPerUser ? HKEY_CURRENT_USER : HKEY_LOCAL_MACHINE), RUN_ONCE_KEY, CREATE_KEY_IF_NOT_EXISTS);
                if ((dwError=roRunOnce.GetStatus())!=ERROR_SUCCESS)
                    return dwError;

            // create RunOnce string in the form:
            // "rundll32.exe <system dir>\wininet.dll,RunOnceUrlCache C:\Windows\NewCacheLocation"
                if (!GetSystemDirectory(szSystemPath, MAX_PATH))
                    return ERROR_INTERNAL_ERROR;
       
                DisableCacheVu(szOldPath);
                // Get rid of content.ie5.
                PathRemoveBackslash(szOldPath);
                PathRemoveFileSpec(szOldPath);
                DisableCacheVu(szOldPath);
                GetShortPathName(szOldPath, szOldPath, ARRAY_ELEMENTS(szOldPath));
                wnsprintf(szRunOnce, sizeof(szRunOnce),
                            "rundll32.exe %s\\wininet.dll,RunOnceUrlCache %s", 
                            szSystemPath, szOldPath);
                
            // Set the RunOnce command in registry for wininet.
                roRunOnce.SetValue(TEXT("MovingCacheA Wininet Settings"), (LPSTR)szRunOnce, REG_SZ);
            }
        }
        return dwError;
    }

  */  

// DWORD GetIEVersion();


// -- AttemptToUseSharedCache
// Given a path (and limit) attempt to use the path for a shared location.
// If the path is null, then try to use any value if present, else invent one.

VOID AttemptToUseSharedCache(PTSTR pszPath, DWORD ckbLimit)
{
    TCHAR szSharedPath[MAX_PATH];
    DWORD cc = ARRAY_ELEMENTS(szSharedPath);

    REGISTRY_OBJ roContent(&m_roHKLMCache, g_szSubKey[CONTENT], CREATE_KEY_IF_NOT_EXISTS);
    if ((roContent.GetStatus()==ERROR_SUCCESS)
        &&
        (roContent.GetValue(CACHE_PATH_VALUE, (LPBYTE)szSharedPath, &cc)==ERROR_SUCCESS))
    {
        LOG_UPGRADE_DATA("Found a shared cache location...\n");
        goto write_value;
    }

    if (pszPath!=NULL)
    {
        LOG_UPGRADE_DATA(pszPath);
        LOG_UPGRADE_DATA("\n is ");
        GetUserName(szSharedPath, &cc);

        // We're going to ignore just the user name, during this comparison. And
        // if it's in the profiles directory, fuhgedaboutit.
        if (m_fProfiles && !StrCmpNI(m_szProfilePath, pszPath, cbP-cc))
        {
            pszPath = NULL;
            LOG_UPGRADE_DATA("not okay \n");
            goto carryon;
        }
        LOG_UPGRADE_DATA("okay \n");
        strcpy(szSharedPath, pszPath);
    }

carryon:
    if (pszPath==NULL)
    {
        memcpy(szSharedPath, m_szSharedPath, (cbS+1)*sizeof(TCHAR));
        CleanPath(szSharedPath);
        LOG_UPGRADE_DATA("Using a constructed shared path\n");
    }

    // We've finally decided on the path. Now let's write the value into the registry.
    roContent.SetValue(CACHE_PATH_VALUE, szSharedPath, REG_SZ);
    SetWorkingContainer(CONTENT);
    SetPerUserStatus(FALSE);
    SetLimit(szSharedPath, ckbLimit);

write_value:
    LOG_UPGRADE_DATA("The shared cache will be located at ");
    LOG_UPGRADE_DATA(szSharedPath);
    LOG_UPGRADE_DATA("\n");
    
    // This will take care of HKCU
    CHAR szScratch[MAX_PATH];
#ifndef UNIX
    if (!NormalisePath(szSharedPath, TEXT("%SystemRoot%"), szScratch, sizeof(szScratch)))
#else
    if (!NormalisePath(szSharedPath, TEXT("%USERPROFILE%"), szScratch, sizeof(szScratch)))
#endif /* UNIX */
    {
        strncpy(szScratch, szSharedPath, MAX_PATH);
    }
    if (m_roUserShellFolder.SetValue(g_szOldSubKey[CONTENT], szScratch, REG_EXPAND_SZ)==ERROR_SUCCESS)
    {
#ifndef UNIX
       DWORD dwType = REG_SZ;
        m_roShellFolder.SetValue(g_szOldSubKey[CONTENT], szSharedPath, dwType);
#else
        m_roShellFolder.SetValue(g_szOldSubKey[CONTENT], szScratch, REG_EXPAND_SZ);
#endif /* UNIX */
    }
}

};

#define m_roPaths           m_roShellFolder
#define m_roSpecialPaths    m_roHKCUCache

#if 0 
class IE3_REGISTRYSET : public IE5_REGISTRYSET
{
    // Registry keys shipped with IE 3:
    //
    // Software\Microsoft\Windows\CurrentVersion\Internet Settings\Cache\Paths
    //
    // Software\Microsoft\Windows\CurrentVersion\Internet Settings\Cache\Paths\path1
    //                                                                        \path2
    //                                                                        \path3
    //                                                                        \path4
    //
    // Software\Microsoft\Windows\CurrentVersion\Internet Settings\Cache\Special Paths
    //
    // Software\Microsoft\Windows\CurrentVersion\Internet Settings\Cache\Special Paths\Cookies
    //                                                                                \History
    //
    // Software\Microsoft\Windows\CurrentVersion\Internet Settings\Cache\Url History

private:
    REGISTRY_OBJ m_roPath[DEF_NUM_PATHS]; 
    
public:
    // Initialise the IE3 keys that we might work with.
    
    DWORD InitialiseKeys()
    {
        DWORD dwError, i;
        TCHAR szScratch[MAX_PATH];
        TCHAR pszBase[MAX_PATH];
        DWORD dwBaseLen;

        if (m_fInitialised)
        {
            return ERROR_SUCCESS;
        }
        m_roHKLMCache.WorkWith(HKEY_LOCAL_MACHINE, OLD_CACHE_KEY, CREATE_KEY_IF_NOT_EXISTS);
        if ((dwError=m_roHKLMCache.GetStatus())!=ERROR_SUCCESS)
                goto exit;

        m_roPaths.WorkWith(&m_roHKLMCache, CACHE_PATHS_KEY, CREATE_KEY_IF_NOT_EXISTS);
        if ((dwError=m_roPaths.GetStatus())!=ERROR_SUCCESS)
            goto exit;

        memcpy(pszBase, OLD_CACHE_PATH, sizeof(OLD_CACHE_PATH));
        dwBaseLen = sizeof(OLD_CACHE_PATH) - 1;
        for (i = 0; i < DEF_NUM_PATHS; i++)
        {
            pszBase[dwBaseLen-1] = (TCHAR)('1' + i);
            m_roPath[i].WorkWith(&m_roPaths, pszBase, CREATE_KEY_IF_NOT_EXISTS);
            if ((dwError=m_roPath[i].GetStatus())!=ERROR_SUCCESS)
                goto exit;
        }

        m_roSpecialPaths.WorkWith(&m_roHKLMCache, CACHE_SPECIAL_PATHS_KEY);
        m_fInitialised = TRUE;
    exit:
        return dwError;
    }

    BOOL GetContentDetails(LPSTR szPath, DWORD& cbLimit)
    {
        DWORD cbKey = MAX_PATH;
        if (m_roPaths.GetValue(CACHE_DIRECTORY_VALUE, (LPBYTE)szPath, &cbKey)!=ERROR_SUCCESS)
            return FALSE;

        cbLimit = 0;
        for (int i=0; i<DEF_NUM_PATHS; i++)
        {
            if (m_roPath[i].GetValue(CACHE_LIMIT_VALUE, &cbKey)!=ERROR_SUCCESS)
            {
                cbLimit = GetDefaultCacheQuota(szPath, NEW_CONTENT_QUOTA_DEFAULT_DISK_FRACTION);
                break;
            }
            cbLimit += cbKey;
        }
        return TRUE;
    }

    DWORD SetPath(PTSTR pszPath)
    {
        DWORD i, nPaths, dwError;
        DWORD cb = strlen((LPSTR)pszPath);
        TCHAR szBase[MAX_PATH];
#ifndef UNIX
        DWORD dwType = REG_SZ;
#else
        DWORD dwType = REG_EXPAND_SZ;
#endif /* UNIX */

        /* On Unix, try to preserve the Environment variables if possible */
        UNIX_NORMALIZE_PATH_ALWAYS(pszPath, TEXT("%USERPROFILE%"));


        // Cache content path.
        if ((dwError = m_roPaths.SetValue(CACHE_DIRECTORY_VALUE, (LPSTR)pszPath, dwType)) != ERROR_SUCCESS)
            goto exit;

        // Number of subdirectories (optional).
        nPaths = DEF_NUM_PATHS;
        if ((dwError = m_roPaths.SetValue(CACHE_PATHS_KEY, &nPaths)) != ERROR_SUCCESS)
            goto exit;
    
        memcpy(szBase, pszPath, cb);
        memcpy(szBase + cb, OLD_CACHE_SUBKEY, sizeof(OLD_CACHE_SUBKEY));
        cb += sizeof(OLD_CACHE_SUBKEY) - 2;
        // Subdirectories' paths and limits from CONTENT.
        for (i = 0; i < DEF_NUM_PATHS; i++)
        {
            szBase[cb] = (TCHAR)('1' + i);
            if ((dwError = m_roPath[i].SetValue(CACHE_PATH_VALUE, szBase, REG_SZ)) != ERROR_SUCCESS)
                goto exit;    
        }

    exit:    
        INET_ASSERT(dwError == ERROR_SUCCESS);
        return dwError;
    }

    DWORD SetLimit(DWORD dwLimit)
    {
        DWORD i, nPaths, dwError;

        for (i = 0; i < DEF_NUM_PATHS; i++)
        {
            DWORD cbCacheLimitPerSubCache = (DWORD) (dwLimit/ DEF_NUM_PATHS);
            if ((dwError = m_roPath[i].SetValue(CACHE_LIMIT_VALUE, &cbCacheLimitPerSubCache)) != ERROR_SUCCESS)
                goto exit;
        }
    exit:    
        INET_ASSERT(dwError == ERROR_SUCCESS);
        return dwError;
    }

    // Restore key IE3 values. *snicker* --------------------------------------------
    VOID FixLegacySettings(PTSTR pszPath, DWORD cbLimit)
    {
        if (InitialiseKeys()==ERROR_SUCCESS)
        {
            SetPath(pszPath);
            SetLimit(cbLimit);
        }
    }
};

class IE4_REGISTRYSET : public IE5_REGISTRYSET
{
private:
    BOOL DetermineKeyPlacing(DWORD dwWhich)
    {
        DWORD dwValue;
        if (m_fProfiles && (dwWhich==CONTENT))
        {
            if (m_roHKLMCache.GetValue(PROFILES_ENABLED, &dwValue)==ERROR_SUCCESS)
            {
                return dwValue;
            }

#ifndef UNIX
            if (GlobalPlatformType == PLATFORM_TYPE_WINNT)
#else
            if (GlobalPlatformType == PLATFORM_TYPE_UNIX)
#endif /* !UNIX */
            {
               return m_fProfiles;
            }

            // On Win9x we have to go through the following contortions to decide whether or not the
            // user is using a per-user cache or a shared cache.
         
            TCHAR szPath[MAX_PATH];
            DWORD cbPath = sizeof(szPath);
            if (m_roShellFolder.GetValue(g_szOldSubKey[m_dwWorking],(LPBYTE)szPath, &cbPath)==ERROR_SUCCESS)
            {
                cbPath = sizeof(szPath);
                return (m_roUserShellFolder.GetValue(g_szOldSubKey[m_dwWorking],(LPBYTE)szPath, &cbPath)==ERROR_SUCCESS);
            }
        }
        return m_fProfiles;
    }

public:
    DWORD InitialiseKeys(BOOL& fProfiles)
    {
        if (m_fInitialised)
        {
            return ERROR_SUCCESS;
        }
        return InitCommonKeys(fProfiles, OLD_CACHE_KEY);
    }

    DWORD GetPath(PTSTR pszCachePath)
    {
        DWORD cbKeyLen = MAX_PATH;
        LOG_UPGRADE_DATA("Getting IE4 cache location...\n");

        DWORD dwError = m_fProfiles ? m_roShellFolder.GetValue(g_szOldSubKey[m_dwWorking],(LPBYTE)pszCachePath, &cbKeyLen) 
                                          : m_roWorking.GetValue(CACHE_PATH_VALUE, (LPBYTE)pszCachePath, &cbKeyLen);
#ifndef UNIX
        if (m_fProfiles && (GlobalPlatformType == PLATFORM_TYPE_WINNT) && (dwError==ERROR_SUCCESS))
#else
        if (m_fProfiles && (GlobalPlatformType == PLATFORM_TYPE_UNIX) && (dwError==ERROR_SUCCESS))
#endif /* UNIX */
        {
           LOG_UPGRADE_DATA("Correcting IE4 cache location...\n");
           LOG_UPGRADE_DATA(pszCachePath);
           LOG_UPGRADE_DATA("\n");
           TCHAR szPath[MAX_PATH];
           DWORD cbPath = ARRAY_ELEMENTS(szPath);
            if (m_roUserShellFolder.GetValue(g_szOldSubKey[m_dwWorking],(LPBYTE)szPath, &cbPath)!=ERROR_SUCCESS)
            {
                CompressPath(pszCachePath, szPath);
                dwError = m_roUserShellFolder.SetValue(g_szOldSubKey[m_dwWorking], szPath, REG_EXPAND_SZ);
            }
        }
        return dwError;
    }

    BOOL WasIE4Present(BOOL& fProfilesCapable)
    {
        DWORD cb = MAX_PATH;
        CHAR szSigKey[MAX_PATH];
        REGISTRY_OBJ roSig((fProfilesCapable ? HKEY_CURRENT_USER : HKEY_LOCAL_MACHINE), OLD_CACHE_KEY);

        return (roSig.GetValue(CACHE_SIGNATURE_VALUE, (LPBYTE) szSigKey, &cb)==ERROR_SUCCESS);
    }

    DWORD SetLimit(PTSTR pszCachePath, DWORD& cbLimit)
    {
        INET_ASSERT(m_roWorking.GetStatus()==ERROR_SUCCESS);
        // If no limit found in registry create via
        // defaults and write back to registry.
        // Cache limit - for the content cache we calculate the cache limit
        // as being max(DEF_CACHE_LIMIT, 1/32 of the disk size) All others caches
        // are set to DEF_CACHE_LIMIT.
        if (cbLimit==0)
        {
            cbLimit = (m_dwWorking==CONTENT) 
                            ? GetDefaultCacheQuota(pszCachePath, NEW_CONTENT_QUOTA_DEFAULT_DISK_FRACTION)
                            : DEF_CACHE_LIMIT;
        }

        // Dumb hack for back compat. *sigh*
        if (m_dwWorking==CONTENT)
        {
            REGISTRY_OBJ roLimit(&m_roHKLMCache, g_szSubKey[CONTENT]);
            if (roLimit.GetStatus()==ERROR_SUCCESS)
            {
                roLimit.SetValue(CACHE_LIMIT_VALUE, &cbLimit);
            }
        }
        return m_roWorking.SetValue(CACHE_LIMIT_VALUE, &cbLimit);
    }
};

#endif




#define IsFieldSet(fc, bitFlag) (((fc) & (bitFlag)) != 0)

#define FAILSAFE_TIMEOUT (60000)
#define UNMAP_TIME (120000)

// ----------------------------------------------------------------------------
// The following functions deal with keeping the cache containers all up and ready

// -- ConfigureCache() --------------------------------------------------------
// Get the cache info from registry and try to init.

// In general, GetCacheConfigInfo should only rarely fail -- mostly whenever HKCU
// is expected but not available. In that case, we use the system root cache. 
// If _that_ fails, we panic.

DWORD CConMgr::ConfigureCache()
{
    for (DWORD iter = 0; ; iter++)
    {
        DWORD dwError;
        switch (iter)
        {
        case 0:
            dwError = GetCacheConfigInfo();
            break;

        case 1:
            dwError = GetSysRootCacheConfigInfo();
            break;

        default:
            INET_ASSERT(FALSE);
            return dwError;
        }

        if (dwError==ERROR_SUCCESS && (dwError=InitFixedContainers())==ERROR_SUCCESS)
            break;

        // If InitFixedContainers has failed, it is possible that the container list 
        // (ConList) is not empty. Make sure it has no entries.
        LOCK_CACHE();
        if (ConList.Size() != 0)
            ConList.Free();
        UNLOCK_CACHE();
    }

    return ERROR_SUCCESS;
}


/*-----------------------------------------------------------------------------
DWORD CConMgr::GetCacheConfigInfo
  ----------------------------------------------------------------------------*/
DWORD CConMgr::GetCacheConfigInfo()
{
    DWORD dwError, i;

    // Prepare and initialise a registry set for every version of IE available.
    // IE5 must be initialised first because it determines whether profiles are
    // enabled on this machine and set ConMgr's _fProfilesCapable for future
    // reference. Then IE4 and IE3 can be called in whatever order.
    IE5_REGISTRYSET ie5rs;
    if ((dwError=ie5rs.InitialiseKeys(_fProfilesCapable))!=ERROR_SUCCESS)
    {
        goto exit;
    }

#ifdef WININET6
    GlobalCacheHKey = (_fProfilesCapable ? HKEY_CURRENT_USER : HKEY_LOCAL_MACHINE);
#endif

    // In WinHttp we don't care if the user had been using IE4 or whatever,
    // thus the code commented out above    
#if 0
    // Look for a signature to indicate that this cache has been placed before.
    if (ie5rs.IsFirstTimeForUser())
    {
        LOG_UPGRADE_DATA("Install 1st time for user\n");
        DiscoverRegistrySettings(&ie5rs);
    } else {
        // If the user is roaming across machines that include IE4,
        // then safeguard against IE4 writing REG_SZ values that
        // be REG_EXPAND_SZ.
        CheckCacheLocationConsistency();
    }
#endif

    // If the user is roaming across machines that include IE4,
    // then safeguard against IE4 writing REG_SZ values that
    // be REG_EXPAND_SZ.
    // CheckCacheLocationConsistency();

    // -----------------------------------------------------------------------------------
    // Get the container paths, prefixes (if any) and default limit values.
    for (i = CONTENT; i < NCONTAINERS; i++)
    {
        CHAR szCachePath[MAX_PATH];
        CHAR szCachePrefix[MAX_PATH];
        DWORD cbCacheLimit;
        BOOL fPerUser;
        // This should only rarely fail.

        if ((dwError=ie5rs.SetWorkingContainer(i))!=ERROR_SUCCESS)
        {
            goto exit;
        }
        
        fPerUser = ie5rs.GetPerUserStatus();
        dwError = ie5rs.GetPath(szCachePath);
        LOG_UPGRADE_DATA("GetCacheConfigInfo/ie5rs.GetPath for user: ");
        LOG_UPGRADE_DATA(szCachePath);
        LOG_UPGRADE_DATA("\n");

        if (dwError==ERROR_SUCCESS) 
        {
            ie5rs.GetPrefix(szCachePrefix);
            ie5rs.GetLimit(szCachePath, cbCacheLimit);
        }
        else
        {
            break;
        }

        // Got info, now create the container --------------------------------------
        _coContainer[i] = new URL_CONTAINER(g_szSubKey[i], 
                                            szCachePath, 
                                            szCachePrefix, 
                                            (LONGLONG)cbCacheLimit*1024,
                                            0);

        if (_coContainer[i])
        {
            dwError = _coContainer[i]->GetStatus();
            if (dwError!=ERROR_SUCCESS)
            {
                delete _coContainer[i];
                break;
            }
            ConList.Add(_coContainer[i]);
            _coContainer[i]->SetPerUserItem(fPerUser);
        }
        else
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        // Maintain values for backwards compatibility
        /* We don't care in WinHTTP
        if (i==CONTENT)
        {
            // If repairing IE3's settings fails, well, who cares? IE5 is still going.
            IE3_REGISTRYSET ie3rs;
            ie3rs.FixLegacySettings(szCachePath, cbCacheLimit);
        }
        */
    }

exit:
    return dwError;
}


/*-----------------------------------------------------------------------------
DWORD CConMgr::GetSysRootCacheConfigInfo
----------------------------------------------------------------------------*/
DWORD CConMgr::GetSysRootCacheConfigInfo()
{
    CHAR szParentPath[MAX_PATH];
    DWORD cb = ARRAY_ELEMENTS(szParentPath);

#ifndef UNIX
    {
        // In case of failure to create containers in the regular location,
        // we should put the cache in a user-specifiable location HKLM\* REG_EXPAND_SZ
        // Otherwise in the temp directory
        // Otherwise in the Windows directory
        REGISTRY_OBJ roCache(HKEY_LOCAL_MACHINE, CACHE5_KEY);
        BOOL fResult = FALSE;
        if (roCache.GetStatus()==ERROR_SUCCESS)
        {
            TCHAR szTemp[MAX_PATH];
            if (roCache.GetValue(TEXT("SystemCache"), (LPBYTE)szTemp, &cb)==ERROR_SUCCESS)
            {
                cb = ExpandEnvironmentStrings(szTemp,szParentPath,ARRAY_ELEMENTS(szParentPath)) - 1;
                if (cb && (cb < ARRAY_ELEMENTS(szParentPath)))
                {
                    fResult = TRUE;
                }
            }
        }
        if (!fResult)
        {
            cb = ExpandEnvironmentStrings(TEXT("%TEMP%"),szParentPath,ARRAY_ELEMENTS(szParentPath)) - 1;
            if (!cb || (cb > ARRAY_ELEMENTS(szParentPath)))
            {
                cb = GetWindowsDirectory(szParentPath, ARRAY_ELEMENTS(szParentPath));
            }
        }
    }
#else
    /* On Unix, GetWindowsDirectory will point to <install dir>/common
     * and the cache should not be created here in any case
     */
    lstrcpy(szParentPath,UNIX_SHARED_CACHE_PATH);
    cb = lstrlen(szParentPath);
#endif /* UNIX */
    if (!cb || (cb>sizeof(szParentPath)))
    {
        return ERROR_PATH_NOT_FOUND;
    }
    AppendSlashIfNecessary(szParentPath, &cb);
    
    for (DWORD idx = CONTENT; idx < NCONTAINERS; idx++)
    {
        CHAR szCachePath[MAX_PATH];
        CHAR szCachePrefix[MAX_PATH];
        LONGLONG cbCacheLimit;

        // Get cache paths out of dll resource and form absolute
        // paths to top level cache directories.
        memcpy(szCachePath, szParentPath, cb);

#if 0
        if (!LoadString(GlobalDllHandle, g_dwCachePathResourceID[idx], szCachePath + cb, MAX_PATH - cb))
        {
            return GetLastError();
        }
#endif
        memcpy(szCachePath+cb, g_dwCachePathResourceID[idx], 
                strlen(g_dwCachePathResourceID[idx]) + 1);
    
        DWORD ccPath = lstrlen(szCachePath);
        AppendSlashIfNecessary(szCachePath, &ccPath);
        memcpy(szCachePath+ccPath, g_szVersionName[idx], lstrlen(g_szVersionName[idx])+1);

        // Cache prefix.        
        memcpy(szCachePrefix, g_szCachePrefix[idx], strlen(g_szCachePrefix[idx]) + 1);

        // Cache limit - for the content cache we calculate the cache limit
        // as being max(DEF_CACHE_LIMIT, 1/32 of the disk size) All others caches
        // are set to DEF_CACHE_LIMIT.
        if (idx == CONTENT)
        {
            
            REGISTRY_OBJ roCache(HKEY_LOCAL_MACHINE, CACHE5_KEY);
            BOOL fResult = (roCache.GetStatus()==ERROR_SUCCESS);
            if (fResult)
            {
                REGISTRY_OBJ roLimit(&roCache, CONTENT_PATH_KEY);
                fResult = FALSE;
                if (roLimit.GetStatus()==ERROR_SUCCESS)
                {
                    DWORD cKBLimit;
                    if (roLimit.GetValue(CACHE_LIMIT_VALUE, &cKBLimit)==ERROR_SUCCESS)
                    {
                        cbCacheLimit = cKBLimit * (LONGLONG)1024;
                        fResult = TRUE;
                    }
                }
            }
            if (!fResult)
            {
                cbCacheLimit = 
                        (DWORDLONG)GetDefaultCacheQuota(szCachePath, NEW_CONTENT_QUOTA_DEFAULT_DISK_FRACTION) 
                        * (DWORDLONG)1024;
            }
        }
        else
        {
            // Non-CONTENT cache; use default.
            cbCacheLimit = DEF_CACHE_LIMIT * (LONGLONG)1024;
        }

        _coContainer[idx] = new URL_CONTAINER(g_szSubKey[idx], szCachePath, szCachePrefix, cbCacheLimit, 0);

        if (_coContainer[idx])
        {
            DWORD dwError = _coContainer[idx]->GetStatus();
            if (dwError!=ERROR_SUCCESS)
            {
                delete _coContainer[idx];
                return dwError;
            }
            ConList.Add(_coContainer[idx]);
            _coContainer[idx]->SetPerUserItem(FALSE);
        }
        else
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }    

    _fUsingBackupContainers = TRUE;
    return ERROR_SUCCESS;
}


/*-----------------------------------------------------------------------------
BOOL CConMgr::GetUrlCacheConfigInfo
  ----------------------------------------------------------------------------*/
/*
BOOL CConMgr::GetUrlCacheConfigInfo(LPCACHE_CONFIG_INFO lpCacheConfigInfo,
    LPDWORD lpdwCacheConfigInfoBufferSize, DWORD dwFieldControl)
{
    LOCK_CACHE();

    BOOL fIE5Struct = (lpCacheConfigInfo->dwStructSize == sizeof(INTERNET_CACHE_CONFIG_INFO));
    
    if(IsFieldSet( dwFieldControl, CACHE_CONFIG_SYNC_MODE_FC))
    {
        lpCacheConfigInfo->dwSyncMode = GlobalUrlCacheSyncMode;
    }
    
    if (IsFieldSet(dwFieldControl, CACHE_CONFIG_QUOTA_FC))
    {
        lpCacheConfigInfo->dwQuota = (DWORD) (_coContainer[lpCacheConfigInfo->dwContainer]->GetCacheLimit()/1024L);
    }

    if (fIE5Struct && IsFieldSet(dwFieldControl, CACHE_CONFIG_CONTENT_USAGE_FC))
    {
        lpCacheConfigInfo->dwNormalUsage = (DWORD) (_coContainer[lpCacheConfigInfo->dwContainer]->GetCacheSize()/1024L);
    }
    
    if (fIE5Struct && IsFieldSet(dwFieldControl, CACHE_CONFIG_STICKY_CONTENT_USAGE_FC) && (lpCacheConfigInfo->dwContainer==CONTENT))
    {
        lpCacheConfigInfo->dwExemptUsage = (DWORD) (_coContainer[CONTENT]->GetExemptUsage()/1024L);
    }
    
    lpCacheConfigInfo->fPerUser = IsFieldSet( dwFieldControl, CACHE_CONFIG_USER_MODE_FC)
                                    ? _coContainer[lpCacheConfigInfo->dwContainer]->IsPerUserItem()
                                    : _coContent->IsPerUserItem();

    if (IsFieldSet(dwFieldControl, CACHE_CONFIG_CONTENT_PATHS_FC))
    {
        lpCacheConfigInfo->dwContainer = CONTENT;
    }
    else if (IsFieldSet(dwFieldControl, CACHE_CONFIG_HISTORY_PATHS_FC))
    {
        lpCacheConfigInfo->dwContainer = HISTORY;
    }
    else if (IsFieldSet(dwFieldControl, CACHE_CONFIG_COOKIES_PATHS_FC))
    {
        lpCacheConfigInfo->dwContainer = COOKIE;
    }
    // These are the actual field codes that should be sent for cache paths.
    // Note that the path returned *does not* contain subdirs (cache1..N).
    if (lpCacheConfigInfo->dwContainer <= HISTORY)
    {
        memcpy(lpCacheConfigInfo->CachePath, 
                _coContainer[lpCacheConfigInfo->dwContainer]->GetCachePath(), 
                _coContainer[lpCacheConfigInfo->dwContainer]->GetCachePathLen() + 1);
        lpCacheConfigInfo->dwQuota = (DWORD)
               (_coContainer[lpCacheConfigInfo->dwContainer]->GetCacheLimit() / 1024);        

        lpCacheConfigInfo->dwNumCachePaths = (DWORD) 1;    
    }

    UNLOCK_CACHE();
    return TRUE;
}
*/

/*-----------------------------------------------------------------------------
BOOL CConMgr::SetUrlCacheConfigInfo
  ----------------------------------------------------------------------------*/
/*
BOOL CConMgr::SetUrlCacheConfigInfo(LPCACHE_CONFIG_INFO pConfig, 
                                              DWORD dwFieldControl)
{         
    DWORD i, dwError = ERROR_SUCCESS;

    UNIX_RETURN_ERR_IF_READONLY_CACHE(dwError);
    
    LOCK_CACHE();
    
    //  Check FieldControl bits and set the values for set fields
    if( IsFieldSet( dwFieldControl, CACHE_CONFIG_SYNC_MODE_FC ))
    {

        INET_ASSERT(pConfig->dwSyncMode <= WININET_SYNC_MODE_AUTOMATIC);

        InternetWriteRegistryDword(vszSyncMode, pConfig->dwSyncMode);

        GlobalUrlCacheSyncMode = pConfig->dwSyncMode;

        // set a new version and simultaneously
        // increment copy for this process, so we don't
        // read registry for this process
        IncrementHeaderData(CACHE_HEADER_DATA_CURRENT_SETTINGS_VERSION, 
                            &GlobalSettingsVersion);
    }

    if ( IsFieldSet( dwFieldControl, CACHE_CONFIG_DISK_CACHE_PATHS_FC ))
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    if ( IsFieldSet( dwFieldControl, CACHE_CONFIG_QUOTA_FC ) && pConfig->dwContainer==CONTENT)
    {
        DWORD cbSize = pConfig->dwQuota;
        INET_ASSERT(cbSize);

        if (!_fUsingBackupContainers)
        {
            IE5_REGISTRYSET ie5;
            IE3_REGISTRYSET ie3;
            
            if ((dwError=ie5.InitialiseKeys(_fProfilesCapable))!=ERROR_SUCCESS)
            {
                goto exit;
            }
            ie5.SetWorkingContainer(CONTENT);
            TCHAR szTemp[MAX_PATH];
            ie5.GetPath(szTemp);
            ie5.SetLimit(szTemp, cbSize);

            if (ie3.InitialiseKeys()==ERROR_SUCCESS)
            {
                ie3.FixLegacySettings(szTemp, cbSize);
            }
        }
        else
        {
            REGISTRY_OBJ roCache(HKEY_LOCAL_MACHINE, CACHE5_KEY, CREATE_KEY_IF_NOT_EXISTS);
            BOOL fResult = (roCache.GetStatus()==ERROR_SUCCESS);
            if (fResult)
            {
                REGISTRY_OBJ roLimit(&roCache, CONTENT_PATH_KEY, CREATE_KEY_IF_NOT_EXISTS);
                if (roLimit.GetStatus()==ERROR_SUCCESS)
                {
                    roLimit.SetValue(CACHE_LIMIT_VALUE, &cbSize);
                }
            }
        }

        if ((((LONGLONG)cbSize * 1024) < _coContent->GetCacheSize()))
            _coContent->CleanupUrls (DEFAULT_CLEANUP_FACTOR, 0);
        _coContent->SetCacheLimit(cbSize* (LONGLONG)1024);
    }

exit:
    UNLOCK_CACHE();
    BOOL fRet = (dwError==ERROR_SUCCESS);
    if (!fRet)
    {
        SetLastError(dwError);
        DEBUG_ERROR(INET, dwError);
    }
    return fRet;
}
*/

/*-----------------------------------------------------------------------------
DWORD CConMgr::SetContentPath

UpdateUrlCacheContentPath leads to this function.
This initiates the cache move. Should be called just before shutdown.

----------------------------------------------------------------------------*/
/*
BOOL CConMgr::SetContentPath(PTSTR pszNewPath)
{
    IE5_REGISTRYSET ie5rs;
    DWORD dwError;
    BOOL fLock;

    if (_coContent->LockContainer(&fLock)
        && (dwError=ie5rs.InitialiseKeys(_fProfilesCapable))==ERROR_SUCCESS)
    {
        dwError = ie5rs.UpdateContentPath(pszNewPath);
    }
    
    if (fLock)
    {
        _coContent->UnlockContainer();
    }

    if (dwError==ERROR_SUCCESS)
    {
        return TRUE;
    }
    SetLastError(dwError);
    return FALSE;
}
*/
    
/*-----------------------------------------------------------------------------
DWORD CConMgr::GetExtensibleCacheConfigInfo
----------------------------------------------------------------------------*/
DWORD CConMgr::GetExtensibleCacheConfigInfo(BOOL fAlways)
{
    CHAR szCachePath[MAX_PATH];
    CHAR szCachePrefix[MAX_PATH];
    CHAR szPrefixMap[MAX_PATH];
    CHAR szVolumeLabel[MAX_PATH];
    CHAR szVolumeTitle[MAX_PATH];

    LONGLONG cbCacheLimit;

    HKEY hKey = (HKEY) INVALID_HANDLE_VALUE;
    DWORD cbKeyLen, cbKBLimit, dwError = ERROR_SUCCESS;
    CHAR szVendorKey[MAX_PATH];

    URL_CONTAINER* pNewContainer;
    URL_CONTAINER* co;
    MUTEX_HOLDER mh;

    DWORD idx;
    DWORD idxPrefix;
    DWORD dwNow;
    DWORD dwOptions;
    BOOL fModified;
    BOOL fCDContainer;

    REGISTRY_OBJ* pro = NULL;

    LOCK_CACHE();
    fModified = WasModified(TRUE);

    hKey = _fProfilesCapable ? HKEY_CURRENT_USER : HKEY_LOCAL_MACHINE;

    //  WasModified MUST come first, so that we update our cached count!
    if (!fModified && !fAlways)
    {
         //  Unmap every container that hasn't be referenced in UNMAP_TIME
        dwNow = GetTickCountWrap();
        if ((dwNow - _dwLastUnmap) > UNMAP_TIME)
        {
            for (idx = ConList.Size()-1; idx >= NCONTAINERS; idx--)
            {
                co = ConList.Get(idx);
                if (co)
                {
                    if (co->GetDeletePending() ||
                        ((dwNow - co->GetLastReference()) > UNMAP_TIME))
                    {
                        co->TryToUnmap(1);    //  RefCount should be 1 == Us
                    }
                    co->Release(FALSE);
                }
            }

            _dwLastUnmap = dwNow;
        }
        goto exit;
    }

    // Create registry object and entry.
    pro = CreateExtensiRegObj(hKey);
    if (!pro)
    {
        dwError = ERROR_ACCESS_DENIED;
        goto exit;
    }
    
    {
        REGISTRY_OBJ& roExtensibleCache = *pro;
        for (idx = NCONTAINERS; idx < ConList.Size(); idx++)
        {
            URL_CONTAINER *co = ConList.Get(idx);
            if (co)
            {
                co->Mark(FALSE);
                co->Release(FALSE);
            }
        }

        mh.Grab(_hMutexExtensible, FAILSAFE_TIMEOUT);

        idx = NCONTAINERS;
        // Get the container paths, prefixes (if any) and default limit values.
        while (roExtensibleCache.FindNextKey(szVendorKey, MAX_PATH) == ERROR_SUCCESS)
        {
            REGISTRY_OBJ roVendor(&roExtensibleCache, szVendorKey);
            if (roVendor.GetStatus()==ERROR_SUCCESS)
            {
                    // Path.
                cbKeyLen = MAX_PATH;
                DWORD dwRepair = TRUE;
                CHAR szScratch[MAX_PATH];

                roVendor.GetValue(CACHE_PATCH_VALUE, &dwRepair);

                if (roVendor.GetValue(CACHE_PATH_VALUE, (LPBYTE) szScratch, &cbKeyLen) != ERROR_SUCCESS)
                    continue;

                if (!*szScratch)
                {
                    roExtensibleCache.DeleteKey(szVendorKey);
                    continue;
                }

                if (dwRepair)
                {
                    CompressPath(szScratch, szCachePath);
                    cbKeyLen = lstrlen(szCachePath)+1;
                    roVendor.SetValue(CACHE_PATH_VALUE, szCachePath, REG_EXPAND_SZ);
                    dwRepair = FALSE;
                    roVendor.SetValue(CACHE_PATCH_VALUE, &dwRepair);
                }
                ExpandEnvironmentStrings(szScratch, szCachePath, sizeof(szCachePath)-1); // don't count the NULL
                    
                // Prefix.
                cbKeyLen = MAX_PATH;
                if (roVendor.GetValue(CACHE_PREFIX_VALUE, (LPBYTE) szCachePrefix, &cbKeyLen) != ERROR_SUCCESS)
                    continue;
            
                // Limit.
                if (roVendor.GetValue(CACHE_LIMIT_VALUE, &cbKBLimit) != ERROR_SUCCESS)
                    continue;    

            // Options.
                if (roVendor.GetValue(CACHE_OPTIONS_VALUE, &dwOptions) != ERROR_SUCCESS)
                    continue;
            
                if (dwOptions & INTERNET_CACHE_CONTAINER_MAP_ENABLED)
                {
                    fCDContainer = TRUE;

                    // PrefixMap
                    cbKeyLen = MAX_PATH;
                    if ((roVendor.GetValue(CACHE_PREFIX_MAP_VALUE, (LPBYTE) szPrefixMap, &cbKeyLen) != ERROR_SUCCESS)
                        || (*szPrefixMap == '\0'))
                        continue;

                    // Volume label.
                    cbKeyLen = MAX_PATH;
                    if ((roVendor.GetValue(CACHE_VOLUME_LABLE_VALUE, (LPBYTE) szVolumeLabel, &cbKeyLen) != ERROR_SUCCESS)
                        || (*szVolumeLabel == '\0'))
                        continue;
            
                    // Volume title.
                    cbKeyLen = MAX_PATH;
                    if ((roVendor.GetValue(CACHE_VOLUME_TITLE_VALUE, (LPBYTE) szVolumeTitle, &cbKeyLen) != ERROR_SUCCESS)
                        || (*szVolumeTitle == '\0'))
                        continue;
                }
                else
                {
                    fCDContainer = FALSE;
                    *szPrefixMap = '\0';
                    dwOptions &= ~INTERNET_CACHE_CONTAINER_PREFIXMAP;
                }
    
                cbCacheLimit = ((LONGLONG) cbKBLimit) * 1024;
                
                idxPrefix = FindExtensibleContainer(szVendorKey);
                if (idxPrefix != NOT_AN_INDEX)
                {
                    co = ConList.Get(idxPrefix);

                    if (co)
                    {
                        //  what if the container has been added
                        //  with the same name but a different path, prefix, or options!
                        if (stricmp(co->GetCachePath(), szCachePath) ||
                            stricmp(co->GetCachePrefix(), szCachePrefix) ||
                            co->GetOptions() != dwOptions)
                        {
                            idxPrefix = NOT_AN_INDEX;
                        }
                        else if (fCDContainer && stricmp(co->GetPrefixMap(), szPrefixMap))
                        {
                            idxPrefix = NOT_AN_INDEX;
                        }
                        else
                        {
                            co->Mark(TRUE);
                        }
                        co->Release(FALSE);
                    }
                }
            
                if (idxPrefix == NOT_AN_INDEX)
                {
                    // Construct either a normal container, or a CD container.
                    if (!fCDContainer)                        
                    {
                        pNewContainer = new URL_CONTAINER(szVendorKey, szCachePath, szCachePrefix,
                                            cbCacheLimit, dwOptions);
                    }
                    else
                    {
                        // We'll never run into CD containers in WinHTTP, so we'll force an error
                        // if some strange things happen which leads to this codepath
#if 0                
                        pNewContainer = new CInstCon(szVendorKey, szVolumeLabel, szVolumeTitle,
                                             szCachePath, szCachePrefix, szPrefixMap, 
                                             cbCacheLimit, dwOptions);
#endif
                        pNewContainer = NULL;
                    }
                    if (pNewContainer)
                    {
                        dwError = pNewContainer->GetStatus();
                        if (dwError!=ERROR_SUCCESS)
                        {
                            delete pNewContainer;
                            pNewContainer = NULL;
                        }
                        else
                        {
                            pNewContainer->Mark(TRUE);
                            ConList.Add(pNewContainer);
                        }
                    }
                    else
                    {
                        dwError = ERROR_NOT_ENOUGH_MEMORY;
                    }
                }
                 idx++;
            }
        }
    mh.Release();

    //  Mark every container that's no longer in the registry for pending delete
    //  Unmap every container that hasn't be referenced in UNMAP_TIME
    dwNow = GetTickCountWrap();

    idx = ConList.Size() - 1;

    while (idx >= NCONTAINERS)
    {
        co = ConList.Get(idx);
        if (co)
        {
            if (!co->GetMarked() && !co->GetDeleted())
            {
                co->SetDeletePending(TRUE);
            }
            if (co->GetDeletePending() ||
                ((dwNow - co->GetLastReference()) > UNMAP_TIME))
            {
                co->TryToUnmap(1);    //  RefCount should be 1 == Us, unless enumerator
                                      //  is still open
            }
            co->Release(FALSE);
        }
        idx--;
    }

    _dwLastUnmap = dwNow;
    }
    delete pro;
    
exit:  
    UNLOCK_CACHE();
    return dwError;
}


//
//  Mixed environment of IE4 and IE5 sharing a server causes HKCU keys to get resaved as REG_SZ incorrectly
//  so we repair it here
/*
VOID CheckCacheLocationConsistency()
{
    // Read user shell folders (necessary only in HKCU) and write back as REG_EXPAND_SZ if necessary
    REGISTRY_OBJ roUserShellFolders(HKEY_CURRENT_USER, USER_SHELL_FOLDER_KEY);
    if (roUserShellFolders.GetStatus()!=ERROR_SUCCESS)
    {
        return;
    }
    for (int i=0; i<NCONTAINERS; i++)
    {
        TCHAR szPath[MAX_PATH];
        DWORD cc = ARRAY_ELEMENTS(szPath);
        DWORD ValueSize;
        DWORD ValueType;

        //  speed things up a bit by checking if we don't need to do this
        if (roUserShellFolders.GetValueSizeAndType(g_szOldSubKey[i], &ValueSize, &ValueType ) != ERROR_SUCCESS 
            || ValueType != REG_SZ)
        {
            continue;
        }
        if (roUserShellFolders.GetValue(g_szOldSubKey[i], (LPBYTE)szPath, &cc)!=ERROR_SUCCESS)
        {
            continue;
        }
        // First reconcile path to whatever it should be
        // and rename the containers accordingly.

        TCHAR szRealPath[MAX_PATH];
        
        // Expand string
        ExpandEnvironmentStrings(szPath, szRealPath, ARRAY_ELEMENTS(szRealPath));

        // Contract string
        if (!NormalisePath(szRealPath, TEXT("%USERPROFILE%"), szPath, sizeof(szPath)))
        {
            NormalisePath(szRealPath, TEXT("%SystemRoot%"), szPath, sizeof(szPath));
        }
        
        // Then write it back
        roUserShellFolders.DeleteValue(g_szOldSubKey[i]);
        roUserShellFolders.SetValue(g_szOldSubKey[i], szPath, REG_EXPAND_SZ);
    }
}


VOID MakeCacheLocationsConsistent()
{
    // Delete any 5.0 cache signatures from previous installs
    REGISTRY_OBJ roHKCU(HKEY_CURRENT_USER, CACHE5_KEY);
    if (roHKCU.GetStatus()==ERROR_SUCCESS)
    {
        roHKCU.DeleteValue(CACHE_SIGNATURE_VALUE);
    }
    
    // Read user shell folders (necessary only in HKCU) and write back as REG_EXPAND_SZ
    REGISTRY_OBJ roUserShellFolders(HKEY_CURRENT_USER, USER_SHELL_FOLDER_KEY);
    if (roUserShellFolders.GetStatus()!=ERROR_SUCCESS)
    {
        return;
    }
    roUserShellFolders.DeleteValue(TEXT("Content"));

    for (int i=0; i<NCONTAINERS; i++)
    {
        TCHAR szPath[MAX_PATH];
        DWORD cc = ARRAY_ELEMENTS(szPath);
        if (roUserShellFolders.GetValue(g_szOldSubKey[i], (LPBYTE)szPath, &cc)!=ERROR_SUCCESS)
        {
            continue;
        }
        // First reconcile path to whatever it should be
        // and rename the containers accordingly.
        // i. Get rid of all the trailing content.ie5 (History.IE5)
        // ii. Get rid of any trailing Temporary Internet Files (History)
        // iii. Append Temporary Internet Files (History)

        // We want to skip this for cookies, though.

        // PROBLEM: When we have upgrade on top of 0901+, we started appending content.ie5
        // internally. Thus, files start getting misplaced. How do I work around this?

        // Idea: We append Content.ie5 to the USF path, and test for existence. If it's there,
        // then we'll use that. (We won't bother with anymore detective work. Though we could also
        // verify that the index dat there is newer than the index.dat in the parent directory.)
        TCHAR szRealPath[MAX_PATH];
        
        // Expand string
        ExpandEnvironmentStrings(szPath, szRealPath, ARRAY_ELEMENTS(szRealPath));
        DisableCacheVu(szRealPath);

        if (i!=1)
        {
        }
        
        // Contract string
        if (!NormalisePath(szRealPath, TEXT("%USERPROFILE%"), szPath, sizeof(szPath)))
        {
            NormalisePath(szRealPath, TEXT("%SystemRoot%"), szPath, sizeof(szPath));
        }
        
        // Then write it back
        roUserShellFolders.DeleteValue(g_szOldSubKey[i]);
        roUserShellFolders.SetValue(g_szOldSubKey[i], szPath, REG_EXPAND_SZ);

        // Then append Content.IE5 and move the files to this subdirectory
        // Ideally, we should rename this to an intermediate folder,
        // delete the old location (UNLESS THIS IS THE ROOT OR SYSTEM DIRECTORY),
        // and then move intermediate folder to its new location

    }

    FlushShellFolderCache();
}
*/

// External hooks -------------------------------------------------------------------------------------------------------

// -- RunOnceUrlCache -------------------------
// This code is called on reboot to clean up moving the cache.
// If the shutdown was successful, this will move only the few files that were open
// at that point; we assume that we'll move quickly enough to prevent collisions.
// The old index.dat is erased.

DWORD
WINAPI
RunOnceUrlCache( HWND hwnd, HINSTANCE hinst, PSTR pszCmd, int nCmdShow)
{
    // This will clean up the move, especially important if the move was interrupted. (Not too likely.)
    if (pszCmd && *pszCmd)
    {
        CFileMgr::DeleteCache(pszCmd);
    }
    return ERROR_SUCCESS;
}

#ifdef __URLCACHE_JUNK__      
DWORD
WINAPI
DeleteIE3Cache( HWND hwnd, HINSTANCE hinst, PSTR lpszCmd, int nCmdShow)
{
    IE3_REGISTRYSET ie3rs;
   
    if (ie3rs.InitialiseKeys()==ERROR_SUCCESS)
    {
        TCHAR szTemp[MAX_PATH];
        DWORD cbLimit;
        
        // This fragment will look for a cache location, and test for its share-ability. If it is,
        // we'll use the location; otherwise, we'll use our own shared location.
        if (ie3rs.GetContentDetails(szTemp, cbLimit))
        {
            DWORD cb = lstrlen(szTemp);
            AppendSlashIfNecessary(szTemp, &cb);

            PTSTR psz = szTemp+cb-2;
            while (*psz!='\\' && psz>szTemp)
            {
                psz--;
            }
            if ((psz>szTemp) && !StrCmpNI(psz+1, TEXT("content."), ARRAY_ELEMENTS("content.")-1))
            {
                *(psz+1) = TEXT('\0');
            }
            StrCatBuff(szTemp, TEXT("cache1"), MAX_PATH);
            cb = lstrlen(szTemp) - 1;

            for (int i=0; i<4; i++)
            {
                szTemp[cb] = TEXT('1')+i;
                DeleteCachedFilesInDir(szTemp);
                RemoveDirectory(szTemp);
            }
        }
    }

    return ERROR_SUCCESS;
}

// -- Externally available apis

URLCACHEAPI
BOOL
WINAPI
SetUrlCacheConfigInfoA(
    LPCACHE_CONFIG_INFO pConfig,
    DWORD dwFieldControl
    )
/*++

Routine Description:

    This function sets the cache configuration parameters.

Arguments:

    lpCacheConfigInfo - place holding cache configuration information to be set

    dwFieldControl - items to get

Return Value:

    Error Code

--*/
{
    // Initialize globals
    if (!InitGlobals())
    {
        SetLastError (ERROR_WINHTTP_INTERNAL_ERROR);
        return FALSE;
    }
    return GlobalUrlContainers->SetUrlCacheConfigInfo(pConfig,dwFieldControl);
}

URLCACHEAPI
BOOL
WINAPI
GetUrlCacheConfigInfoA(
    LPCACHE_CONFIG_INFO lpCacheConfigInfo,
    IN OUT LPDWORD lpdwCacheConfigInfoBufferSize,
    DWORD dwFieldControl
    )
/*++

Routine Description:

    This function retrieves cache configuration values from globals

Arguments:

    pConfig - pointer to a location where configuration information
                  is stored on a successful return

    lpdwCacheConfigInfoBufferSize : pointer to a location where length of
        the above buffer is passed in. On return, this contains the length
        of the above buffer that is fulled in.

    dwFieldControl - items to get

Return Value:

    Error Code

--*/
{
    ENTER_CACHE_API ((DBG_API, Bool, "GetUrlCacheConfigInfoA", "%#x, %#x, %#x",
        lpCacheConfigInfo, lpdwCacheConfigInfoBufferSize, dwFieldControl ));

    BOOL fError;
    
    // Initialize globals
    if (!InitGlobals())
    {
        SetLastError (ERROR_WINHTTP_INTERNAL_ERROR);
        DEBUG_ERROR(API, ERROR_WINHTTP_INTERNAL_ERROR);
        fError = FALSE;
    }
    else
    {
        fError = GlobalUrlContainers->GetUrlCacheConfigInfo(lpCacheConfigInfo,
            lpdwCacheConfigInfoBufferSize, dwFieldControl);
    }
    
    DEBUG_LEAVE_API (fError);
    return fError;
}
#endif // __URLCACHE_JUNK__      


// declared in wininet\inc\urlcache.h
BOOL GetIE5ContentPath( LPSTR szPath)
{
    BOOL retVal = FALSE;
    
    IE5_REGISTRYSET ie5rs;
    BOOL fProfilesCapable;

    if( ie5rs.InitialiseKeys(fProfilesCapable) != ERROR_SUCCESS)
        goto doneGetContentPath;

    if( ie5rs.SetWorkingContainer(CONTENT) != ERROR_SUCCESS)
        goto doneGetContentPath;

    if( ie5rs.GetPath( szPath) != ERROR_SUCCESS)
        goto doneGetContentPath;

    retVal = TRUE;

doneGetContentPath:
    return retVal;
}

// SHDOCVW needs to know whether profiles are enabled, to determine whether
// or not it needs to filter out user names. This function will help keep things simple.
// And minimise perf impact.
#ifdef UNIX
extern "C"
#endif

BOOL IsProfilesEnabled()
{
    IE5_REGISTRYSET ie5rs;
    BOOL fProfilesEnabled;

    if (ie5rs.InitialiseKeys(fProfilesEnabled) != ERROR_SUCCESS)
    {
        fProfilesEnabled = FALSE;
    }
    return fProfilesEnabled;
}

#if 0 
BOOL CConMgr::DiscoverIE4Settings(IE5_REGISTRYSET* pie5rs)
{
    IE4_REGISTRYSET ie4rs;

    CHAR szTemp[MAX_PATH+1], szPrefix[MAX_PATH+1];
    DWORD cbLimit, dwTemp;
    BOOL fPerUser, fCaughtIE4;
        
    // Try to find IE4 settings. If any paths are found, we will not look for IE3 settings
    fCaughtIE4 = FALSE;

    if (ie4rs.WasIE4Present(_fProfilesCapable))
    {
        if (ie4rs.InitialiseKeys(_fProfilesCapable)!=ERROR_SUCCESS)
        {
           LOG_UPGRADE_DATA("IE4 initialisation failed...\n");
           return FALSE;
        }

        for (dwTemp=0;dwTemp < NCONTAINERS; dwTemp++)
        {
            ie4rs.SetWorkingContainer(dwTemp);
            if (ie4rs.GetPath(szTemp)!=ERROR_SUCCESS)
            {
                continue;
            }
            LOG_UPGRADE_DATA("DIE4Settings: ");
            LOG_UPGRADE_DATA(szTemp);
            LOG_UPGRADE_DATA("\n");
            DisableCacheVu(szTemp);

            pie5rs->SetWorkingContainer(dwTemp);

            // Because SHGetFolderPath uses shell folders to determine where the items are, we have to accomodate this
            // on no-profiles machines. 
            if (!_fProfilesCapable)
            {
                pie5rs->SetPath(szTemp);
            }
            else if (dwTemp==CONTENT)
            {
#ifndef UNIX
                if (ie4rs.GetPerUserStatus() || GlobalPlatformVersion5)
#else
                if (ie4rs.GetPerUserStatus() || GlobalPlatformType == PLATFORM_TYPE_UNIX)
#endif /* UNIX */
                {
                // If it's NT5, we want to go to a per-user, non-roaming location
                // which is the NT5 default anyway
                    LOG_UPGRADE_DATA("DIE4Settings: If NT5, ignore shared cache. Else this isn't shared anyway.");
                    pie5rs->SetPerUserStatus(TRUE);
                }
                else
                {
                // Because IE4 locates a shared cache differently from IE5, we need to
                // save the path and status.
                    LOG_UPGRADE_DATA("DIE4Settings: Will try to use shared cache");
                    pie5rs->AttemptToUseSharedCache(szTemp, 0);
                }
            }
        
            fCaughtIE4 = TRUE;

            // We don't need to check return values since we come up with
            // reasonable values on our own.
            ie4rs.GetLimit(szTemp, cbLimit);
            pie5rs->SetLimit(szTemp, cbLimit);

            ie4rs.GetPrefix(szPrefix);
            pie5rs->SetPrefix(szPrefix);
        }
    }
    if (!fCaughtIE4)
    {
        LOG_UPGRADE_DATA("No IE4 settings...\n");
    }
    else
    {
        FlushShellFolderCache();
    }
    return fCaughtIE4;
}

VOID CConMgr::DiscoverIE3Settings(IE5_REGISTRYSET* pie5rs)
{
    IE3_REGISTRYSET ie3rs;
   
    if (ie3rs.InitialiseKeys()!=ERROR_SUCCESS)
    {
        return;
    }

    TCHAR szTemp[MAX_PATH];
    DWORD cbLimit;
    
    // This fragment will look for a cache location, and test for its share-ability. If it is,
    // we'll use the location; otherwise, we'll use our own shared location.
    if (ie3rs.GetContentDetails(szTemp, cbLimit))
    {
        DeleteCachedFilesInDir(szTemp);
       // No IE4. Steal IE3's settings? We only care about content cache.
       // Is that a good idea? There's no UI for modifying the cookies/history path; 
       // if someone plumbs into the registry, do we want to support that? *sigh*
       // BUG? We're moving the cache one level deeper. We probably want to be a
       // bit more intelligent about this.
        CleanPath(szTemp);
        pie5rs->AttemptToUseSharedCache(szTemp, cbLimit);
    }

    // This fragment deletes the shared history. It should happen ONLY ONCE.
    DWORD cbKeyLen = ARRAY_ELEMENTS(szTemp);
    REGISTRY_OBJ roHist(HKEY_LOCAL_MACHINE, IE3_HISTORY_PATH_KEY);
    if ((roHist.GetStatus()==ERROR_SUCCESS)
        &&
        (roHist.GetValue(NULL,(LPBYTE)szTemp, &cbKeyLen)==ERROR_SUCCESS))
    {
        REGISTRY_OBJ roUrlHist(HKEY_LOCAL_MACHINE, szTemp);
        cbKeyLen = ARRAY_ELEMENTS(szTemp);
        if ((roUrlHist.GetStatus()==ERROR_SUCCESS)
            &&
            (roUrlHist.GetValue(CACHE_DIRECTORY_VALUE, (LPBYTE)szTemp, &cbKeyLen)==ERROR_SUCCESS))
        {
            DeleteCachedFilesInDir(szTemp);
        }
    }
}


// Logic for determining the location of the cache -------------------------------------------------------------

// PROFILES ENABLED --------------------------
// [on logon]
// If profiles are enabled, look in HKCU/Software/Microsoft/Windows/Internet Settings/5.0/Cache
//      for a signature. 
// If a signature is present, [carry on]
// Look in HKLM/Software/Microsoft/Windows/Internet Settings/5.0/Cache
//      for a signature.
// If a signature is not present, jump to [over IE4 install]
// For history and cookies, the containers will be located in the profiles directory
// For content, 
//      if it's marked per user, 
//          and there isn't a shell folder/user shell folder value, construct and put it in
//      otherwise feed the HKLM shared location into (user) shell folder.
// Insert signature and [carry on].

// [over IE4 install]
// If a signature is not present in HKCU/Software/Microsoft/Windows/Internet Settings/Cache,
//      jump to [over IE3 install]
// Determine if the content cache is per-user or not.

// [over IE3 install]
// For history and cookies, the containers will be located in the profiles directory
// Examine HKLM/Software/Microsoft/Windows/Internet Settings/Cache/Paths
// If not present, go to [clean install]
// If the cache path is located in a user's profiles directory, ignore and [clean install]
// Otherwise, adopt the values and [carry on]

// [clean install]
// Set up history/cookies to be per user.
// Set up the content cache to be shared.
// Write in default values.

// PROFILES NOT ENABLED --------------------------

// * If profiles are _not_ enabled, we'll look in HKLM/Software/Microsoft/Windows/Internet Settings/5.0/Cache
//      for a signature.
// If a signature is present, go ahead and gather information for the paths

// [carry on]
// Get info from the registry, and create the container


// -- DiscoverAnyIE5Settings
// We're going to call this function if we haven't any IE4 settings to upgrade,
// but _before_ we check for IE3,
BOOL CConMgr::DiscoverAnyIE5Settings(IE5_REGISTRYSET* pie5rs)
{
    // Let's consider the following scenario:
    // User A logs on to the machine with IE4 installed; installs IE5, and then shuts down
    // the machine. User B comes along, but IE5 hasn't been installed yet. If User B has 
    // admin privileges, install will continue, BUT still not have any IE4/5 settings.
    // Which resulted in skipping DiscoverIE4Settings. However, we don't want to look
    // at IE3's settings.

    // If we're installing over IE4/2/5, but we don't have any settings for this user, 
    // we must avoid an IE3 upgrade. Instead, short circuit to use last-minute info-gathering
    // For IE3, use a shared cache
    DWORD dwVer = GetIEVersion();
    
    // We're going to use a shared cache for IE3 and Win9x users.
    // Upgrading over IE4 and 5 -- for users who have logged in before,
    // their signatures shoudl be in place already. In those cases, we shouldn't
    // be in this function anyway. For other users, we'll use the shared cache.
    // This is the first time for the machine.
    if ((dwVer==3) && pie5rs->IsFirstTimeForMachine())
    {
        return FALSE;
    }

    pie5rs->AttemptToUseSharedCache(NULL, 0);
    return TRUE;
}


VOID CConMgr::DiscoverRegistrySettings(IE5_REGISTRYSET* pie5rs)
{
    LOG_UPGRADE_DATA("Attempting to discover IE4 settings...\n");

    if (DiscoverIE4Settings(pie5rs))
    {
        goto exit;
    }


#ifndef UNIX
    if (GlobalPlatformType == PLATFORM_TYPE_WINNT)
#else
    if (GlobalPlatformType == PLATFORM_TYPE_UNIX)
#endif /* UNIX */
    {
        LOG_UPGRADE_DATA("This is NT. Fuhgedabout IE3 et al settings...\n");

        // This will override NT's default behaviour to use per-user containers.
        pie5rs->SetWorkingContainer(CONTENT);
        if (!pie5rs->GetPerUserStatus())
        {
            pie5rs->AttemptToUseSharedCache(NULL, 0);
        }

        // Suppose this is an install over NT. Each user should get a per-user, non-roaming
        // path by default. The values we'd pick up from SHFolderGetPath will be okay; but, we need to make
        // sure that we treat this as a per-user container.

        // Suppose we upgraded from some previous version of Win9x to NT5. There are eight scenarios:
        // nothing                  : in which case, we do as above
        // IE3                      : same; need to delete old cache
        // IE4 -- single-user machine:same as fresh install; need to delete old cache.
        //     -- shared cache      : same as fresh install
        //     -- per user cache    : preserve path
        //     -- moved cache       : preserve path
        // IE5 -- single-user machine:same as fresh install; need to delete old cache.
        //     -- shared cache      : preserve shared path
        //     -- per user cache    : preserve path
        //     -- moved cache       : preserve path

        // If an admin wants to use a shared cache under NT5, s/he will have to set
        // HKCU/Shell Folders and User Shell Folders to point to the common path
        // AND {HKCU|HKLM}/blah/PerUserItem to 0 (or delete the HKCU value).
        if ((GetIEVersion()==3) && pie5rs->IsFirstTimeForMachine())
        {
            IE3_REGISTRYSET ie3rs;
            TCHAR szTemp[MAX_PATH];
            DWORD cbLimit;
            if ((ie3rs.InitialiseKeys()==ERROR_SUCCESS)
                &&
                (ie3rs.GetContentDetails(szTemp, cbLimit)))
            {
                DeleteCachedFilesInDir(szTemp);
            }
        }
        goto exit;
    }

    LOG_UPGRADE_DATA("Attempting to discover any IE5 settings...\n");
    if (DiscoverAnyIE5Settings(pie5rs))
    {
        goto exit;
    }

    LOG_UPGRADE_DATA("Attempting to discover any IE3 settings...\n");
    DiscoverIE3Settings(pie5rs);

exit:
    LOG_UPGRADE_DATA("Flushing shell folders cache...\n");
    pie5rs->SetIfFirstTime();
    FlushShellFolderCache();
}

#endif


// -- CleanPath
// Given a path, strip away any trailing content.ie5's, and if necessary, add a trailing brand mark,
// i.e. "Temporary Internet Files" or localised version.

VOID CleanPath(PTSTR pszPath)
{
    DWORD ccPath = strlen(pszPath);
    PTSTR pszLastSep = pszPath + ccPath;

    // Now we're at the null terminator, but if the last character is also a separator, we want
    // to skip that too.
    if (*(pszLastSep-1)==DIR_SEPARATOR_CHAR)
    {
        pszLastSep--;
    }
    BOOL fSlash;
    // Strip away any "content.ie5"'s from the path
    for (;(fSlash = ScanToLastSeparator(pszPath, &pszLastSep));)
    {
        if (StrCmpNI((pszLastSep+1), TEXT("content.ie"), ARRAY_ELEMENTS(TEXT("content.ie"))-1))
        {
            break;
        }
        *pszLastSep = '\0';
    }

    // Load temp int files
    TCHAR szBrand[MAX_PATH];
    DWORD ccBrand = 0;

#if 0
    ccBrand = LoadString(GlobalDllHandle, g_dwCachePathResourceID[CONTENT], szBrand, ARRAY_ELEMENTS(szBrand));
#endif
    memcpy(szBrand, g_dwCachePathResourceID[CONTENT], 
            strlen(g_dwCachePathResourceID[CONTENT]) + 1);

    // The following fragment should never happen, but just in case...
    if (!ccBrand)
    {
        ccBrand = sizeof(TEXT("Temporary Internet Files"));
        memcpy(szBrand, TEXT("Temporary Internet Files"), ccBrand);
        ccBrand /= sizeof(TCHAR);
        ccBrand--;
    }
    
    // If "Temporary Internet Files" doesn't trail the path, add it.
    if (!fSlash)
    {
        *pszLastSep++ = DIR_SEPARATOR_CHAR;
        *pszLastSep = '\0';
    }
    else
    {
        pszLastSep++;
    }
    if (StrCmpNI((pszLastSep), szBrand, ccBrand))
    {
        while (*pszLastSep && *pszLastSep!=DIR_SEPARATOR_CHAR)
        {
            pszLastSep++;
        }
        if (!*pszLastSep && (*(pszLastSep-1)!=DIR_SEPARATOR_CHAR))
        {
            *pszLastSep = DIR_SEPARATOR_CHAR;
            pszLastSep++;
        }
        else if (*pszLastSep)
        {
            pszLastSep++;
        }
        memcpy(pszLastSep, szBrand, ccBrand*sizeof(TCHAR));
    }
    *(pszLastSep+ccBrand)='\0';
}

/*
DWORD GetIEVersion()
{
    DWORD dwVer = 0;

    REGISTRY_OBJ roVersion(HKEY_LOCAL_MACHINE, OLD_VERSION_KEY);
    TCHAR szKey[MAX_PATH];
    DWORD cb = ARRAY_ELEMENTS(szKey);

    if ((roVersion.GetStatus()!=ERROR_SUCCESS)
        ||
        (roVersion.GetValue(OLD_VERSION_VALUE, (LPBYTE)szKey, &cb)!=ERROR_SUCCESS))
    {
        // This should never happen during a proper setup.
        // In case it does, however, we'll just use construct IE5's default settings.
        return 0;
    }

    PTSTR psz = szKey;
    PTSTR pszFirst = szKey;
    // Get the major version number
    while (*psz!='.')
    {
        psz++;
    }
    *psz = '\0';
    dwVer = (DWORD)StrToInt(pszFirst);

    if (dwVer==4)
    {
        psz++;
        // Skip the second number
        while (*psz!='.')
        {
            psz++;
        }
        pszFirst = psz;
        psz++;
        while (*psz!='.')
        {
            psz++;
        }
        *psz = '\0';
        dwVer = ((DWORD)StrToInt(pszFirst))==0 ? 3 : 4;
    }

    return dwVer;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\urlcache\debug.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    debug.c

Abstract:

    Contains debug functions.

Author:

    Madan Appiah (madana) 15-Nov-1994

Environment:

    User Mode - Win32

Revision History:

--*/


#if DBG


#include <windows.h>
#include <winnt.h>

#include <stdlib.h>
#include <stdio.h>
#include <debug.h>



VOID
InternetDebugPrintValist(
    IN LPSTR Format,
    va_list list
    );

extern BOOL UrlcacheDebugEnabled;

VOID
TcpsvcsDbgPrintRoutine(
    IN DWORD DebugFlag,
    IN LPSTR Format,
    ...
    )

{
    va_list arglist;

#if 0
    if (!UrlcacheDebugEnabled) {

        return;

    }
#endif //0

    va_start(arglist, Format);

    InternetDebugPrintValist(Format, arglist);

    va_end(arglist);
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\urlcache\cookies.cxx ===
/*-----------------------------------------------------------------------------
Copyright (c) 1996  Microsoft Corporation

Module Name:  cookies.cxx

Abstract:

  Cookie upgrade object implementation

  Upgrades cookies to new format by parsing existing cookies
  files and adding them to the newly created cookie cache index.

  Currently upgrades v3.2 to v4.0.


Author:
    Adriaan Canter (adriaanc) 01-Nov-1996.

Modification history:
    Ahsan Kabir (akabir) 25-Sep-1997 made a few minor alterations.
-------------------------------------------------------------------------------*/
#include <wininetp.h>
#include <cache.hxx>

/*-----------------------------------------------------------------------------
    CCookieLoader::GetHKLMCookiesDirectory

  ----------------------------------------------------------------------------*/
DWORD CCookieLoader::GetHKLMCookiesDirectory(CHAR *szCookiesDirectory)
{
    DWORD dwError;
    REGISTRY_OBJ roCookiePath(HKEY_LOCAL_MACHINE, IE3_COOKIES_PATH_KEY);
    DWORD cbKeyLen = MAX_PATH;

    if ((dwError=roCookiePath.GetStatus())==ERROR_SUCCESS)
    {
        dwError = roCookiePath.GetValue(CACHE_DIRECTORY_VALUE, (LPBYTE)szCookiesDirectory,  &cbKeyLen);
    }

    return dwError;

}
/*-----------------------------------------------------------------------------
    CCookieLoader::ParseNextCookie

    Upgrades cookies from Cache Version 3.2 to Cache Version 4.0
  ----------------------------------------------------------------------------*/
CHAR* CCookieLoader::ParseNextCookie(CHAR* ptr, CHAR** ppszHash,
    FILETIME* pftExpire, FILETIME* pftLast)
{
    CHAR *pszName, *pszValue, *pszFlags,
         *pszExpireTimeLow, *pszExpireTimeHigh,
         *pszLastTimeHigh,  *pszLastTimeLow,
         *pszDelimiter, *pszNextCookie;

    __try
    {
        // Get the first token (cookie name).
        pszName           = StrTokExA(&ptr, "\n");
        if (!pszName)                               // Cookie name.
        {
            // Normal termination of the parse.
            pszNextCookie = 0;
            goto exit;
        }

        // Parse the rest of the cookie
        pszValue          = StrTokExA(&ptr, "\n");      // Cookie value.
        *ppszHash         = StrTokExA(&ptr, "\n");      // Combo of domain and path.
        pszFlags          = StrTokExA(&ptr, "\n");      // Cookie flags.
        pszExpireTimeLow  = StrTokExA(&ptr, "\n");      // Expire time.
        pszExpireTimeHigh = StrTokExA(&ptr, "\n");
        pszLastTimeLow    = StrTokExA(&ptr, "\n");      // Last Modified time.
        pszLastTimeHigh   = StrTokExA(&ptr, "\n");
        pszDelimiter      = StrTokExA(&ptr, "\n");      // Delimiter should be "*"


        // Abnormal termination of parse.
        if (!pszDelimiter || pszDelimiter[0] != '*')
        {
            TcpsvcsDbgAssert(FALSE);
            pszNextCookie = 0;
            goto exit;
        }

        // Set the times.
        pftExpire->dwLowDateTime  = atoi(pszExpireTimeLow);
        pftExpire->dwHighDateTime = atoi(pszExpireTimeHigh);
        pftLast->dwLowDateTime    = atoi(pszLastTimeLow);
        pftLast->dwHighDateTime   = atoi(pszLastTimeHigh);

        pszNextCookie = pszDelimiter+2;
    }

    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        TcpsvcsDbgAssert(FALSE);
        pszNextCookie = 0;
        goto exit;
    }
    ENDEXCEPT

exit:
    return pszNextCookie;

}


/*-----------------------------------------------------------------------------
    CCookieLoader::LoadCookies
  ----------------------------------------------------------------------------*/
DWORD CCookieLoader::LoadCookies(URL_CONTAINER *UrlContainer)
{
    HANDLE             hFind = INVALID_HANDLE_VALUE;
    HANDLE             hFile = INVALID_HANDLE_VALUE;

    FILETIME           ftExpire, ftLast;
    CHAR               szCookieFileName        [MAX_PATH],
                       szCookieFileNamePattern [MAX_PATH],
                       szOldMemMapFilePath     [MAX_PATH],
                       szHKLMCookiesPath       [MAX_PATH],
                       szCookieName            [MAX_PATH],
                       szHKLMCookieFileName    [MAX_PATH],
                       szHKCUCookieFileName    [MAX_PATH];

    CHAR               *pszHash, *ptr,
                       *pszCurrentCookie, *szBuffer;

    WIN32_FIND_DATA    FindData;
    BOOL               bReturn;
    DWORD              cbRead = 0, dwError = ERROR_SUCCESS;

    // Data for a single cookie should fit in 2 pages.
    BYTE bCacheEntryInfoBuffer[2 * PAGE_SIZE];
    LPCACHE_ENTRY_INFO pCacheEntryInfo;
    DWORD cbCacheEntryInfoBuffer;
    DWORD dwDIR_SEP_STRING = strlen(DIR_SEPARATOR_STRING);
    DWORD dwLen;
    REGISTRY_OBJ roCachePath(HKEY_CURRENT_USER, OLD_CACHE_KEY);
    DWORD cbKeyLen = MAX_PATH;

    szBuffer = 0;

    __try
    {

        if (!UrlContainer)
        {
            dwError = ERROR_INVALID_PARAMETER;
            goto exit;
        }

        TCHAR szSigKey[MAX_PATH];
        
        // Check to see if we are upgrading cookies
        // from local machine to per user.
        // If IE4's signature isn't present, then we'll guess that IE3 might have been.
        if (UrlContainer->IsPerUserItem()
            &&
            ((roCachePath.GetStatus()!=ERROR_SUCCESS)
             ||  
             (roCachePath.GetValue(CACHE_SIGNATURE_VALUE, (LPBYTE) szSigKey, &cbKeyLen)!=ERROR_SUCCESS)))
        {
            DWORD cb = MAX_PATH;
            CHAR szUserName[MAX_PATH];

            // We are converting cookies from HKLM to HKCU.
            // This is done by enumerating the user's cookies
            // files and copying them to the per-user diretory.
            // Once this is accomplished, cookie converting will
            // proceed normally.

            // Get the cookies directory as specified by HKLM.
            GetHKLMCookiesDirectory(szHKLMCookiesPath);

            // Get the current user name.
            GetUserName(szUserName, &cb);

            // szCookieFileNamePattern will look like c:\winnt\cookies\joeuser@*.txt
            dwLen = strlen(szHKLMCookiesPath) +
                    strlen(szUserName) +
                    dwDIR_SEP_STRING   +
                    7;        // strlen("@*.txt" + '\0';

            if( dwLen > MAX_PATH )
            {
                dwError =  ERROR_INSUFFICIENT_BUFFER;
                goto exit;
            }

            strcpy(szCookieFileNamePattern, szHKLMCookiesPath);
            strcat(szCookieFileNamePattern, DIR_SEPARATOR_STRING);
            strcat(szCookieFileNamePattern, szUserName);
            strcat(szCookieFileNamePattern, "@*.txt");

            // Enumerate the users cache files
            hFind = FindFirstFile(szCookieFileNamePattern, &FindData);
            if (hFind != INVALID_HANDLE_VALUE)
            {
                // One or more cookie files exist.
                do
                {
                    // Construct absolute path from HKLM to cookies file.
                    dwLen = strlen(szHKLMCookiesPath) +
                            strlen(FindData.cFileName) +
                            dwDIR_SEP_STRING +
                            1;
                    if( dwLen > MAX_PATH )
                    {
                        dwError =  ERROR_INSUFFICIENT_BUFFER;
                        goto exit;
                    }
                    strcpy(szHKLMCookieFileName, szHKLMCookiesPath);
                    strcat(szHKLMCookieFileName, DIR_SEPARATOR_STRING);
                    strcat(szHKLMCookieFileName, FindData.cFileName);

                    // Construct absolute path from HKCU to cookies file.
                    dwLen = strlen(UrlContainer->GetCachePath()) +
                            strlen(FindData.cFileName) +
                            1;
    
                    // We should rescue as many cookies as we can.
                    if( dwLen <= MAX_PATH )
                    {
                        strcpy(szHKCUCookieFileName, UrlContainer->GetCachePath());
                        strcat(szHKCUCookieFileName, FindData.cFileName);
                        // Move the file to the per-user directory.
                        CopyFile(szHKLMCookieFileName, szHKCUCookieFileName, TRUE);
                    }
                } while (FindNextFile(hFind, &FindData));

                // Close the Find handle.
                if (hFind != INVALID_HANDLE_VALUE)
                {
                    FindClose(hFind);
                    hFind = INVALID_HANDLE_VALUE;
                }
            } // Per-user upgrade.
        }

        // No per-user upgrade. szCookieFileNamePattern will look like
        // c:\winnt\cookies\*@*.txt or c:\winnt\profiles\joeuser\cookies\*@*.txt.
        dwLen = strlen(UrlContainer->GetCachePath()) + 8;        // strlen("*@*.txt" + '\0';

        if( dwLen > MAX_PATH )
        {
            dwError =  ERROR_INSUFFICIENT_BUFFER;
            goto exit;
        }
        strcpy(szCookieFileNamePattern, UrlContainer->GetCachePath());
        strcat(szCookieFileNamePattern, "*@*.txt");

        // Enumerate the cache files.
        hFind = FindFirstFile(szCookieFileNamePattern, &FindData);
        if (hFind == INVALID_HANDLE_VALUE)
        {
            // OK, No cookies files to upgrade.
            // BUGBUG - should we verify this?
            dwError = ERROR_SUCCESS;
            goto exit;
        }

        // One or more cookie files exist.
        do
        {
            // Construct absolute path to cookie file.
            dwLen = strlen(UrlContainer->GetCachePath()) +
                    strlen(FindData.cFileName) +
                    1;
            if( dwLen > MAX_PATH )
            {
                continue;
            }

            strcpy(szCookieFileName, UrlContainer->GetCachePath());
            strcat(szCookieFileName, FindData.cFileName);

            // Get the WIN32_FILE_ATTRIBUTE for the call to AddUrl
            // This wrapper works for Win95 and WinNT.

            // Open the cookie file.
            hFile = CreateFile(
                    szCookieFileName,       // Absolute path to cookies file.
                    GENERIC_READ,           // Read only.
                    FILE_SHARE_READ,        // Share.
                    0,                      // Security Attribute (ignored in W95).
                    OPEN_EXISTING,          // Fail if doesn't exist.
                    FILE_ATTRIBUTE_NORMAL,  // No special attributes.
                    0                       // Attribute template.
                    );

            // File handle must be valid.
            TcpsvcsDbgAssert(hFile != INVALID_HANDLE_VALUE);
            if (hFile != INVALID_HANDLE_VALUE)
            {
                // Allocate memory for cookie file contents.
                // BUGBUG - put an upper limit on this? ->
                // 300 cookies * 4k/cookie = 1200k plus sundry.
                szBuffer = new CHAR[FindData.nFileSizeLow + 1];
                if (!szBuffer)
                {
                    dwError = ERROR_NOT_ENOUGH_MEMORY;
                    goto exit;
                }

                // Read the file into memory.
                bReturn = ReadFile(hFile, szBuffer, FindData.nFileSizeLow, &cbRead, NULL);

                // ReadFile must be successful.
                TcpsvcsDbgAssert(bReturn);
                if (bReturn)
                {
                    // Null terminate buffer.
                    szBuffer[cbRead] = '\0';

                    // Parse each cookie out of the buffer.
                    pszCurrentCookie = szBuffer;
                    while (pszCurrentCookie = ParseNextCookie(pszCurrentCookie,
                        &pszHash, &ftExpire, &ftLast))
                    {
                        // Construct the cookie name from the following strings:
                        // FindData.cFileName is like "user@foobar.txt"
                        // pszHash is like "foobar.com/"
                        // szCookieName should then be "Cookie:user@foobar.com/"
                        strcpy(szCookieName, COOKIE_PREFIX);
                        strcat(szCookieName, FindData.cFileName);

                        ptr = strstr(szCookieName, "@");

                        // Downcase the username portion of the file.
                        CHAR* tptr = ptr;
                        while (*--tptr != ':')
                            *tptr = tolower(*tptr);

                        strcpy(ptr+1, pszHash);

                        // Check to see if an earlier version of this cookie
                        // has already been added to the cache index file.
                        BOOL fAddToCache = TRUE;
                        pCacheEntryInfo = (LPCACHE_ENTRY_INFO) bCacheEntryInfoBuffer;
                        cbCacheEntryInfoBuffer = sizeof(bCacheEntryInfoBuffer);

                        dwError = UrlContainer->GetUrlInfo(szCookieName, &pCacheEntryInfo,
                            &cbCacheEntryInfoBuffer, 0, 0, 0);

#ifndef UNIX
                        if (dwError == ERROR_SUCCESS
                            && CompareFileTime(pCacheEntryInfo->LastModifiedTime, ftLast) > 0)
#else
                        /* There is a problem with multiple cookies in a single
                         * cookie file. When adding the second cookie, we will
                         * try to delete the existing cookie (the first one that
                         * was added), and thus try to delete the cookie file
                         * itself. But, deletion of the cookie file will fail on
                         * Win32 because the file is already open above for
                         * parsing. On Unix, the deletion will succeed.
                         * So, the work-around is to not add the second cookie
                         * which is from the same site. The entry will remain
                         * in the cookie file anyway.
                         */
                        if (dwError == ERROR_SUCCESS)
#endif /* UNIX */
                            fAddToCache = FALSE;

                        if (fAddToCache)
                        {
                            // Either this cookie was not found in the index file or
                            // it was found and the last modified time on it is
                            // less than the currently parsed cookie. Proceed
                            // to add this cookie to the index file.

                            // Add it to the cookie container.
                            // BUGBUG - besides assert, what to do if this fails?

                            AddUrlArg Args;
                            memset(&Args, 0, sizeof(Args));
                            Args.pszUrl      = szCookieName;  // user@foobar.com
                            Args.pszFilePath = szCookieFileName; // c:\winnt\cookies\user@foobar.txt
                            Args.qwExpires   = FT2LL(ftExpire); // Expire time.
                            Args.qwLastMod   = FT2LL(ftLast); // Last modified time.
                            Args.dwEntryType |= COOKIE_CACHE_ENTRY;
                            dwError = UrlContainer->AddUrl(&Args);

                            TcpsvcsDbgAssert(dwError == ERROR_SUCCESS);
                        }

                    } // Successful next cookie field.

                } // Successful read.

                // Done with this cookie file. Delete the buffer.
                delete [] szBuffer;

                // And close the file
                CloseHandle(hFile);
                hFile = INVALID_HANDLE_VALUE;

            } // File handle is valid.

        } while (FindNextFile(hFind, &FindData));


        // No more cookie files or an error occured.
        if ((dwError = GetLastError()) != ERROR_NO_MORE_FILES)
            goto exit;

        // Normal termination.
        dwError = ERROR_SUCCESS;

    exit:

        // Close the file handle.
        if (hFile != INVALID_HANDLE_VALUE)
            CloseHandle(hFile);

        // Close the Find handle.
        if (hFind != INVALID_HANDLE_VALUE)
            FindClose(hFind);


    } // try

    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        // Cleanup.
        delete [] szBuffer;

        if (hFind != INVALID_HANDLE_VALUE)
            FindClose(hFind);
        if (hFile != INVALID_HANDLE_VALUE)
            CloseHandle(hFile);

        TcpsvcsDbgAssert(FALSE);
        dwError = ERROR_EXCEPTION_IN_SERVICE;
        return dwError;
    }

    ENDEXCEPT
                
    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\urlcache\contain.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    contain.cxx

Abstract:

    Abstract-for-module.

    Contents:

Author:

     16-Nov-1995

[Environment:]

    optional-environment-info (e.g. kernel mode only...)

[Notes:]

    optional-notes

Revision History:

    16-Nov-1995
        Created

    Shishir Pardikar (shishirp) added: (as of 7/6/96)

    1) Container allows any size file. The file is cleanedup at scavneging time
    2) Free 100% uses cleanupallurls, reinitializes memorymappedfile and cleansup
       all directories
    3) CurrentCacheSIze and Cache Limit in the memorymapped file itself
    4) FileCreation time and lastcheckedtime added
    5) friendly naming scheme

    25-Sep-1997

    Ahsan Kabir (akabir) made minor alterations to GetFileSizeAndTimeByName.

--*/

/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    contain.cxx

Abstract:

    Contains code that implements CONTAINER classes defined in
    contain.hxx.

Author:

    Madan Appiah (madana)  28-Dec-1994

Environment:

    User Mode - Win32

Revision History:

--*/

#include <wininetp.h>
#include <cache.hxx>

// Beta logging
#ifdef BETA_LOGGING
#define BETA_LOG(stat) \
    {DWORD dw; INET_ASSERT (IsContentContainer()); \
    IncrementHeaderData (CACHE_HEADER_DATA_##stat, &dw);}
#else
#define BETA_LOG(stat) do { } while(0)
#endif

// Typedef for GetFileAttributeEx function
typedef BOOL (WINAPI *PFNGETFILEATTREX)(LPCTSTR, GET_FILEEX_INFO_LEVELS, LPVOID);
extern PFNGETFILEATTREX gpfnGetFileAttributesEx;


// private functions
DWORD GetFileSizeAndTimeByName(
    LPCTSTR FileName,
    WIN32_FILE_ATTRIBUTE_DATA *lpFileAttrData
    )
/*++

Routine Description:

    Get the size and creation time and file attributes of the specified file.

Arguments:

    FileName : full path name of the file whose size is asked for.

    lpFindData : pointer to a WIN32_FIND_DATA structure where the size and time value is
        returned. On WinNT, only the size and time fields are valid.

Return Value:

    Windows Error Code.

--*/
{
    INET_ASSERT(lpFileAttrData != NULL);

    if (gpfnGetFileAttributesEx)
    {
        if(!gpfnGetFileAttributesEx(FileName, GetFileExInfoStandard, (LPVOID)lpFileAttrData))
            return( GetLastError() );
    }
    else
    {
        HANDLE hHandle;
        WIN32_FIND_DATA FindData;

        hHandle = FindFirstFile(FileName, &FindData);
        if( hHandle == INVALID_HANDLE_VALUE ) {
            return( GetLastError() );
        }
        memset(lpFileAttrData, 0, sizeof(WIN32_FILE_ATTRIBUTE_DATA));
        lpFileAttrData->dwFileAttributes = FindData.dwFileAttributes;
        lpFileAttrData->nFileSizeLow = FindData.nFileSizeLow;
        lpFileAttrData->nFileSizeHigh = FindData.nFileSizeHigh;
        lpFileAttrData->ftCreationTime = FindData.ftCreationTime;

        FindClose(hHandle);
    }

    return(ERROR_SUCCESS);
}

DWORD
GetFileSizeByName(
    LPCTSTR pszFileName,
    DWORD *pdwFileSize
    )
/*++

Routine Description:

    Get the size of the specified file.

Arguments:

    FileName : full path name of the file whose size is asked for.

    FileSize : pointer to a longlong location where the size value is
        returned.

Return Value:

    Windows Error Code.

--*/
{
    DWORD dwError = ERROR_SUCCESS;

    // get the size of the file being cached.
    //  since we do not handle 4+gb files, we can safely ignore the high dword

    INET_ASSERT(pdwFileSize!=NULL);

    if (gpfnGetFileAttributesEx)
    {
        WIN32_FILE_ATTRIBUTE_DATA FileAttrData;
        if(!gpfnGetFileAttributesEx(pszFileName, GetFileExInfoStandard, &FileAttrData))
            return( GetLastError() );

        *pdwFileSize = FileAttrData.nFileSizeLow;
    }
    else
    {
        HANDLE hfFileHandle = CreateFile(
                        pszFileName,
                        GENERIC_READ,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL );

        if( hfFileHandle == INVALID_HANDLE_VALUE )
            return(GetLastError());

        *pdwFileSize = GetFileSize( hfFileHandle, NULL);
        if(*pdwFileSize == 0xFFFFFFFF)
            dwError = GetLastError();

        CloseHandle( hfFileHandle );
    }
    return dwError;
}

// -------------------------------URL_CONTAINER----------------------------------- //

/*-----------------------------------------------------------------------------
URL_CONTAINER::URL_CONTAINER Sets path, prefix and limit.
-----------------------------------------------------------------------------*/
URL_CONTAINER::URL_CONTAINER(LPTSTR CacheName, LPTSTR CachePath,
                             LPTSTR CachePrefix, LONGLONG CacheStartUpLimit,
                             DWORD dwOptions)
{
    _fIsInitialized = FALSE;
    _fPerUserItem = TRUE;
    _dwLastReference = GetTickCountWrap();
    _fDeleted = FALSE;
    _fMarked = FALSE;
    _fDeletePending = FALSE;
    _fMustLaunchScavenger = FALSE;
//#ifdef CHECKLOCK_NORMAL
    _dwTaken = 0;
//#endif
    _dwRefCount = 0;
    _dwOptions = dwOptions;
    _dwBytesDownloaded = _dwItemsDownloaded = 0;
    _CacheEntryType = 0;
    _CacheName = NULL;
    _CachePath = NULL;
    _CachePrefix = NULL;


    if (!CachePath || !*CachePath || !CachePrefix || !CacheStartUpLimit)
    {
        _Status = ERROR_INVALID_PARAMETER;
        return;
    }

    _CacheName = NewString(CacheName == NULL ? TEXT(""):CacheName);

    _CachePathLen = strlen(CachePath);

    if (CachePath[_CachePathLen-1] != DIR_SEPARATOR_CHAR)
    {
        _CachePath = CatString(CachePath, DIR_SEPARATOR_STRING);
        _CachePathLen++;
    }
    else
        _CachePath = NewString(CachePath);

    _CachePrefix = NewString(CachePrefix);

    if (!_CachePath || !_CachePrefix || !_CacheName)
    {
        _Status = ERROR_NOT_ENOUGH_MEMORY;
        return;
    }

    _CachePrefixLen = strlen(_CachePrefix);

    _CacheStartUpLimit = CacheStartUpLimit;

    _UrlObjStorage = NULL;
    _FileManager = NULL;

    if (!memcmp(_CachePrefix, CONTENT_PREFIX, sizeof(CONTENT_PREFIX)))
        _CacheEntryType = NORMAL_CACHE_ENTRY;
    else if (!memcmp(_CachePrefix, COOKIE_PREFIX, sizeof(COOKIE_PREFIX)))
        _CacheEntryType = COOKIE_CACHE_ENTRY;
    else if (!memcmp(_CachePrefix, HISTORY_PREFIX, sizeof(HISTORY_PREFIX)))
        _CacheEntryType = URLHISTORY_CACHE_ENTRY;

    _Status = ERROR_SUCCESS;
}


#ifdef CHECKLOCK_PARANOID
void URL_CONTAINER::CheckNoLocks(DWORD dwThreadId)
{
    INET_ASSERT(_dwTaken == 0 || _dwThreadLocked != dwThreadId);
}
#endif

/*-----------------------------------------------------------------------------
URL_CONTAINER::Init
-----------------------------------------------------------------------------*/
DWORD URL_CONTAINER::Init()
{
    _Status = ERROR_SUCCESS;
    _FileMapEntrySize = NORMAL_ENTRY_SIZE;
    MemMapStatus eMMStatus;
    BOOL fMustUnlock = FALSE;
    DWORDLONG dlSize;

    // Generate the mutex name based on the cache path.
    DWORD i;
    LPSTR szPrefix;
    CHAR MutexName[MAX_PATH + 1];
    LPTSTR pCachePath, pMutexName;

    i = 0;
    pCachePath = _CachePath,
    pMutexName = (LPSTR) MutexName;
    while( *pCachePath != '\0'  && (i++ < MAX_PATH))
    {
        if( *pCachePath == DIR_SEPARATOR_CHAR )
            *pMutexName = '!';
        else
            *pMutexName = tolower(*pCachePath);

        pMutexName++;
        pCachePath++;
    }
    *pMutexName = '\0';

    // Open the existing mutex, or if first process, create a new one.
    BOOL fFirstProcess = FALSE;

    _MutexHandle = OpenMutex(SYNCHRONIZE, FALSE, (LPTSTR)MutexName);
    if (_MutexHandle == NULL && (GetLastError() == ERROR_FILE_NOT_FOUND || GetLastError() == ERROR_INVALID_NAME))
    {
        _MutexHandle = CreateMutex(CreateAllAccessSecurityAttributes(NULL, NULL, NULL), FALSE, (LPTSTR)MutexName );
        if (_MutexHandle != NULL)
            fFirstProcess = TRUE;
    }

    if (_MutexHandle == NULL)
    {
        _Status = GetLastError();
        goto Cleanup;
    }

    // Lock the container.
    if (!LockContainer(&fMustUnlock))
    {
        if (fMustUnlock) ReleaseMutex(_MutexHandle);
        fMustUnlock = FALSE;
        _Status = GetLastError();
        if (_MutexHandle)
        {
            CloseHandle(_MutexHandle);
            _MutexHandle = NULL;
        }
        goto Cleanup;
    }
    if ((_CachePathLen > 1) && (_CachePath[_CachePathLen-1] != PATH_CONNECT_CHAR))
    {
        lstrcat( _CachePath, PATH_CONNECT_STRING );
        _CachePathLen++;
    }

    // Initialize _ClusterSizeMinusOne and _ClusterSizeMask
    if (!GetDiskInfo(_CachePath, &_ClusterSizeMinusOne, &dlSize, NULL))
    {
        _Status = GetLastError();
        goto Cleanup;
    }
    _ClusterSizeMinusOne--;
    _ClusterSizeMask = ~_ClusterSizeMinusOne;

    // Construct and initialize the memory mapped file object.
    _UrlObjStorage = new MEMMAP_FILE;
    if( _UrlObjStorage == NULL )
    {
        _Status = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }
    eMMStatus = _UrlObjStorage->Init(_CachePath, _FileMapEntrySize);

    if((_Status = _UrlObjStorage->GetStatus()) != ERROR_SUCCESS )
        goto Cleanup;

    // for first process attach, we need to clean up the notification
    // hwnd, msg, gid and filter
    if( fFirstProcess && (_CacheEntryType == NORMAL_CACHE_ENTRY ))
    {
        RegisterCacheNotify(0, 0, 0, 0);
    }

    _UrlObjStorage->SetCacheLimit(_CacheStartUpLimit);

    // Construct and initialize the file manager.
    // Cookies and history don't use random subdirs.
    // BUGBUG - move this off to container manager.
    szPrefix = GetCachePrefix();

    if (!strcmp(szPrefix, COOKIE_PREFIX)
        || !strcmp(szPrefix, HISTORY_PREFIX)
        || (_dwOptions & INTERNET_CACHE_CONTAINER_NOSUBDIRS))
    {
        // Insecure cache -no random cache subdirs.
        _FileManager = new CFileMgr(_UrlObjStorage, GetOptions());
        if (!_FileManager)
        {
            _Status = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
    }
    else
    {
        // Secure cache - random cache subdirs.
        _FileManager = new CSecFileMgr(_UrlObjStorage, GetOptions());
        if (!_FileManager)
        {
            _Status = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
    }

    // If first process to attach, unlock any locked entries.
    if (fFirstProcess)
        UnlockAllItems();

    // If the memory mapped file was reinitialized
    // cleanup old files.
    if (eMMStatus == MEMMAP_STATUS_REINITIALIZED)
        _FileManager->Cleanup();
    else
        eMMStatus = MEMMAP_STATUS_OPENED_EXISTING;

    _fIsInitialized = TRUE;
    if (dlSize <= (DWORDLONG)(4*1024*1024))
    {
        // Yeah, this hurts start-up perf. We also have little room to maneuvre in, so we're going to try anyway.
        CleanupUrls(DEFAULT_CLEANUP_FACTOR, 0);
    }

Cleanup:

    if( _Status != ERROR_SUCCESS)
    {
        INET_ASSERT(FALSE);
        TcpsvcsDbgPrint(( DEBUG_ERRORS,
            "URL_CONTAINER::URL_CONTAINER() failed, %ld\n", _Status ));
        SetLastError(_Status);
    }
    if (fMustUnlock) UnlockContainer();

    if (_Status == ERROR_SUCCESS)
        return (eMMStatus == MEMMAP_STATUS_OPENED_EXISTING ? ERROR_ALREADY_EXISTS : ERROR_SUCCESS);

    return _Status;
}

void URL_CONTAINER::CloseContainerFile()
{

    // Cleanup.
    // _Filemanager holds a pointer to _UrlObjStorage and
    // must be deleted before _UrlObjStorage.
    delete _FileManager;
    delete _UrlObjStorage;

    _FileManager = NULL;
    _UrlObjStorage = NULL;

    if (!_fDeleted)
    {
        // Keep fixed container files from being deleted.
        if (!(_CacheEntryType & (NORMAL_CACHE_ENTRY | COOKIE_CACHE_ENTRY | URLHISTORY_CACHE_ENTRY)))
        {
            _fDeleted = GlobalUrlContainers->DeleteFileIfNotRegistered(this);
            if (_fDeleted) _fDeletePending = FALSE;
        }
    }
}

URL_CONTAINER::~URL_CONTAINER(
    VOID
    )
/*++

Routine Description:

    URL_CONTAINER destructor

Arguments:

    None.

Return Value:

    None.

--*/
{
    BOOL fMustUnlock;

    // If not initialized, only delete path and prefix.
    if (!IsInitialized())
    {
        //  Free pending deleted container, even if someone has
        //  a enum handle open on it.  This is our last chance as we handle process
        //  detach

        LOCK_CACHE();
        TryToUnmap(0xFFFFFFFF);
        UNLOCK_CACHE();

        if(_CacheName) delete _CacheName;
        if(_CachePath) delete _CachePath;
        if(_CachePrefix) delete _CachePrefix;
        return;
    }

    LockContainer(&fMustUnlock);

    // Otherwise, do a full destruct.
    CloseContainerFile();

    if (fMustUnlock) UnlockContainer();

    // Delete mutex.
    if( _MutexHandle != NULL )
        CloseHandle( _MutexHandle );

    if(_CacheName) delete _CacheName;
    if(_CachePath) delete _CachePath;
    if(_CachePrefix) delete _CachePrefix;
}

DWORD URL_CONTAINER::GetOptions()
{
    return _dwOptions;
}

DWORD URL_CONTAINER::GetLastReference()
{
    return _dwLastReference;
}

BOOL URL_CONTAINER::IsVisible()
{
    return !(_fDeletePending || _fDeleted);
}

void URL_CONTAINER::Mark(BOOL fMarked)
{
    _fMarked = fMarked;
}

BOOL URL_CONTAINER::GetMarked()
{
    return _fMarked;
}

BOOL URL_CONTAINER::GetDeleted()
{
    return _fDeleted;
}

void URL_CONTAINER::SetDeleted(BOOL fDeleted)
{
    if (!_fIsInitialized) _fDeleted = fDeleted;
}

BOOL URL_CONTAINER::GetDeletePending()
{
    return _fDeletePending;
}

void URL_CONTAINER::SetDeletePending(BOOL fDeletePending)
{
    _fDeletePending = fDeletePending;
}

void URL_CONTAINER::AddRef()
// THIS FUNCTION MUST BE CALLED WITH THE CACHE CRIT SEC.
{
    _dwRefCount++;
}

void URL_CONTAINER::TryToUnmap(DWORD dwAcceptableRefCount)
// THIS FUNCTION MUST BE CALLED WITH THE CACHE CRIT SEC.
{
    BOOL fMustUnlock;

    if (_dwRefCount <= dwAcceptableRefCount)
    {
        if (_fIsInitialized)
        {
            LockContainer(&fMustUnlock);

            CloseContainerFile();

            if (fMustUnlock) UnlockContainer();

            // Delete mutex.
            if( _MutexHandle != NULL )
            {
                CloseHandle( _MutexHandle );
                _MutexHandle = NULL;
            }
            _fIsInitialized = FALSE;
        }
        else
        {
            if (!_fDeleted)
            {
                //  Never CONTENT, COOKIES or HISTORY container.
                if (!(_CacheEntryType & (NORMAL_CACHE_ENTRY | COOKIE_CACHE_ENTRY | URLHISTORY_CACHE_ENTRY)))
                {
                    if(GlobalUrlContainers)
                    {
                        _fDeleted = GlobalUrlContainers->DeleteFileIfNotRegistered(this);
                        if (_fDeleted) _fDeletePending = FALSE;
                    }
                }
            }
        }
    }
}

DWORD URL_CONTAINER::Release(BOOL fTryToUnmap)
// THIS FUNCTION MUST BE CALLED WITH THE CACHE CRIT SEC.
{
    DWORD dwRefCount = 0;

    INET_ASSERT(_dwRefCount);
    if (_dwRefCount)
    {
        dwRefCount = --_dwRefCount;
        if (fTryToUnmap && _dwRefCount == 0)
        {
            //  Never CONTENT, COOKIES or HISTORY container.
            if (!(_CacheEntryType & (NORMAL_CACHE_ENTRY | COOKIE_CACHE_ENTRY | URLHISTORY_CACHE_ENTRY)))
            {
                if (_fDeletePending)
                {
                    TryToUnmap(0);
                }
            }
        }
    }
    return dwRefCount;
}


BOOL URL_CONTAINER::LockContainer(BOOL *fMustUnlock)
/*++

Routine Description:

    This function waits for the container to be free.

Arguments:

    NONE.

Return Value:

    NONE.

--*/
{
    _dwLastReference = GetTickCountWrap();

    *fMustUnlock = FALSE;

    if( _MutexHandle == NULL )
    {
        // Bad mutex handle.
        TcpsvcsDbgPrint(( DEBUG_ERRORS, "Container Mutex Handle is NULL.\n" ));
        return FALSE;
    }

    //TcpsvcsDbgPrint((DEBUG_ERRORS, "LockContainer called by thread %x\n", GetCurrentThreadId()));

    //
    // Wait the for the mutex to be signalled.
    //

    DWORD Result;

    #if DBG
        DWORD MutexTimeoutCount;
        MutexTimeoutCount = 0;

    Waitagain:

    #endif

    // Check the mutex.
    #if DBG
        Result = WaitForSingleObject(_MutexHandle, MUTEX_DBG_TIMEOUT);
    #else
        Result = WaitForSingleObject(_MutexHandle, INFINITE);
    #endif

    switch ( Result )
    {
        case WAIT_OBJECT_0:

            // Mutex is signalled (normal result). We now have ownership of the mutex.
            // Do a CheckSizeGrowAndRemapAddress.
            _dwTaken++;
#ifdef CHECKLOCK_NORMAL
            _dwThreadLocked = GetCurrentThreadId();
#endif
            *fMustUnlock = TRUE;
            if (_UrlObjStorage)
            {
                if (_UrlObjStorage->CheckSizeGrowAndRemapAddress() != ERROR_SUCCESS)
                {
                    return (FALSE);
                }
            }
            return TRUE;

    #if DBG
        case WAIT_TIMEOUT:

            // Exceeded debug timeout count. Try again.
            MutexTimeoutCount++;
            TcpsvcsDbgPrint(( DEBUG_ERRORS, "Mutex wait time-out (count = %ld).\n", MutexTimeoutCount ));
            goto Waitagain;
    #endif

        case WAIT_ABANDONED :

            // The thread owning the mutex failed to release it before it terminated.
            // We still get ownership of the mutex.
            _dwTaken++;
#ifdef CHECKLOCK_NORMAL
            _dwThreadLocked = GetCurrentThreadId();
#endif
            *fMustUnlock = TRUE;

            TcpsvcsDbgPrint(( DEBUG_ERRORS, "Mutex ABANDONED.\n" ));
            if (_UrlObjStorage)
            {
                if (_UrlObjStorage->CheckSizeGrowAndRemapAddress() != ERROR_SUCCESS)
                    return (FALSE);
            }

            return TRUE;

        case WAIT_FAILED :

            // Failed to obtain mutex.
            TcpsvcsDbgPrint(( DEBUG_ERRORS, "Mutex wait failed (%ld).\n", GetLastError() ));
            return FALSE;

    }

    INET_ASSERT( FALSE );
    return FALSE;
}


VOID URL_CONTAINER::UnlockContainer(VOID)
/*++

Routine Description:

    This function frees the container to be used by someone else.

Arguments:

    NONE.

Return Value:

    NONE.

--*/
{
    BOOL fMustLaunchScavenger = FALSE;

    //TcpsvcsDbgPrint((DEBUG_ERRORS, "UnlockContainer called by thread %x\n", GetCurrentThreadId()));
    _dwLastReference = GetTickCountWrap();

    _dwTaken--;

#ifdef CHECKLOCK_NORMAL
    if( _MutexHandle)
    {
        INET_ASSERT(_dwThreadLocked == GetCurrentThreadId());

        if (_dwTaken == 0)
            _dwThreadLocked = 0;
#endif
        if (_dwTaken == 0)
        {
            fMustLaunchScavenger = _fMustLaunchScavenger;
            _fMustLaunchScavenger = FALSE;
        }
        if (ReleaseMutex( _MutexHandle ) == FALSE )
        {
            TcpsvcsDbgPrint(( DEBUG_ERRORS, "ReleaseMutex failed (%ld).\n", GetLastError() ));
        }
/* KV
        if (fMustLaunchScavenger)
            LaunchScavenger();
 */
#ifdef CHECKLOCK_NORMAL
    }
#endif
    return;
}

BOOL URL_CONTAINER::UpdateOfflineRedirect
(
    DWORD dwUrlItemOffset, // offset to hash table item of URL entry
    LPCSTR pszUrl,         // URL string
    DWORD cbUrl,           // URL length
    LPCSTR pszRedir        // redirect string
)
/*++
Routine Description:
    Marks a hash table item as allowing a redirect to add trailing slash,
    or creates a new redirect hash table item and memory mapped file entry.

    Addendum: We keep track of redirects in the cache and simulate them when
    offline. Often the redirected URL is the same as the original URL plus
    trailing slash.

WARNING: this function has multiple calls which can grow and remap the
memory map file, invalidating any pointers into the file.  Be careful.

Return Value: TRUE if redirect was cached

--*/

{
    DWORD cbRedir = strlen (pszRedir);
    DWORD dwUrlHash;
    DWORD dwRedirItemOffset;

    // Ignore the redirect URL if same as original URL.
    if (cbRedir == cbUrl && !memcmp(pszUrl, pszRedir, cbRedir))
        return FALSE;

    { // limit scope of pUrlItem

        HASH_ITEM* pUrlItem = (HASH_ITEM*)
            (*_UrlObjStorage->GetHeapStart() + dwUrlItemOffset);

        // Special case trailing slash redirect.
        if (   cbRedir + 1 == cbUrl
            && pszUrl [cbRedir] == '/'
            && !memcmp (pszUrl, pszRedir, cbRedir)
           )
        {
            pUrlItem->SetSlash();
            return TRUE;
        }

        // Record high bits of target URL hash value.
        dwUrlHash = pUrlItem->GetValue();
    }

    //
    // BUGBUG: we do not handle the case of redirect that once added a
    // trailing slash to redirect to another URL altogether.  We should
    // scan the entire hash table slot and unset the trailing slash bit
    // if we find a match.
    //

    REDIR_FILEMAP_ENTRY* pEntry;

    { // limit scope of pRedirItem

        HASH_ITEM* pRedirItem = NULL;

        if (HashFindItem (pszRedir, LOOKUP_REDIR_CREATE, &pRedirItem))
        {
            // Found existing redirect entry; update it.
            pEntry = (REDIR_FILEMAP_ENTRY*) HashGetEntry (pRedirItem);
            INET_ASSERT (pEntry->dwSig == SIG_REDIR);
            pEntry->dwHashValue = dwUrlHash;
            pEntry->dwItemOffset = dwUrlItemOffset;
            INET_ASSERT (!lstrcmp (pEntry->szUrl, pszRedir));
            return TRUE;
        }

        if (!pRedirItem)
            return FALSE;

        dwRedirItemOffset = (DWORD) ((LPBYTE) pRedirItem - *_UrlObjStorage->GetHeapStart()); // 64BIT
    }

    // Created new hash table item so allocate a redir entry.
    DWORD cbEntry = sizeof(*pEntry) + cbRedir;
    pEntry = (REDIR_FILEMAP_ENTRY *) _UrlObjStorage->AllocateEntry (cbEntry);

    // Associate entry with hash table item.
    HASH_ITEM *pRedirItem =
        (HASH_ITEM*) (*_UrlObjStorage->GetHeapStart() + dwRedirItemOffset);
    if (!pEntry)
    {
        pRedirItem->MarkFree();
        return FALSE;
    }
    HashSetEntry (pRedirItem, (LPBYTE) pEntry);
    pRedirItem->SetRedir();

    // Initialize the redirect entry.
    pEntry->dwSig        = SIG_REDIR;
    pEntry->dwHashValue  = dwUrlHash;
    pEntry->dwItemOffset = dwUrlItemOffset;
    memcpy (pEntry->szUrl, pszRedir, cbRedir + 1);

    return TRUE;
}

LPSTR URL_CONTAINER::GetPrefixMap()
{
    return TEXT("");
}

LPSTR URL_CONTAINER::GetVolumeLabel()
{
    return TEXT("");
}

LPSTR URL_CONTAINER::GetVolumeTitle()
{
    return TEXT("");
}

DWORD URL_CONTAINER::AddIdentityUrl (AddUrlArg* pArgs)
{
    DWORD dwError = ERROR_SUCCESS;
    pArgs->dwEntryType |= IDENTITY_CACHE_ENTRY;

    // Lookup or create a hash item for the 0-URL entry.
    HASH_ITEM *pItem;
    BOOL fUpdate = HashFindItem (pArgs->pszUrl, LOOKUP_URL_DONT_FOLLOW, &pItem);

    if (fUpdate)
    {
        URL_FILEMAP_ENTRY* pOld = HashGetEntry (pItem);
        if (pOld && !IsPerUserEntry(pOld))
        {
            DeleteUrlEntry(pOld, pItem, SIG_DELETE);
            fUpdate = FALSE;
        }
    }
    if (!fUpdate)
    {
        DWORD dwIdentity = pArgs->dwIdentity;
        PTSTR pszFilePath = (PTSTR)pArgs->pszFilePath;
        pArgs->pszFilePath = NULL;
        pArgs->dwIdentity = 0;
        
//////////////////////////////////////////////////////////////////////////////
// WARNING: LOOKUP_URL_CREATE set,thus the file might be grown and remapped //
// so all pointers into the file must be recalculated from their offsets!   //
//////////////////////////////////////////////////////////////////////////////

// SUPERWARNING !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// Calling AddUrl recursively may be hazardous to your health
// SUPERWARNING !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

        dwError = AddUrl(pArgs);
        pArgs->dwIdentity = dwIdentity;            
        pArgs->pszFilePath = pszFilePath;
    }
    else
    {            
        DWORD dwItemOffset = (DWORD) ((LPBYTE) pItem - *_UrlObjStorage->GetHeapStart()); // 64BIT
        DWORD dwUrlNameSize = lstrlen(pArgs->pszUrl) + 1;

        UpdateOfflineRedirect
            (dwItemOffset, pArgs->pszUrl, dwUrlNameSize - 1, pArgs->pszRedirect);
    }
    
    return dwError;
}


DWORD URL_CONTAINER::AddUrl (AddUrlArg* pArgs)

/*++

Routine Description:

    This member functions adds an URL to the container and moves the
    cache file to cache path.

Arguments:

    UrlName : pointer to an URL string.

    lpszNewFileName : pointer to a cache file (full) name.

    ExpireTime : expire time of the file.

    LastModifiedTime : Last modified time of this file. if this value is
        zero, current time is set as the last modified time.

    dwCacheEntryType : type of this new entry.

    HeaderInfo : if this pointer is non-NULL, it stores the HeaderInfo
        data as part of the URL entry in the memory mapped file, otherwise
        the app may store it else where. The size of the header info is
        specified by the HeaderSize parameter.

    dwHeaderSize : size of the header info associated with this URL, this
        can be non-zero even if the HeaderInfo specified above is NULL.

    FileExtension : file extension used to create this file.

Return Value:

    Windows Error Code.

--*/
{
    DWORD dwReturn;
    BOOL fMustUnlock;
    DWORD dwCurrentOffset;
    DWORD dwUrlNameSize;
    LPTSTR FileName;
    DWORD dwFileNameSize;
    DWORD dwUrlFileExtSize;
    DWORD dwEntrySize;
    FILETIME ftCreate;
    DWORD dwFileSize;
    LONGLONG CacheSize, CacheLimit;
    DWORD dwItemOffset;
    BOOL fUpdate;
    LPURL_FILEMAP_ENTRY NewEntry;
    HASH_ITEM *pItem;
    GROUP_ENTRY* pGroupEntry;
    GroupMgr    gm;
    DWORD dwFileMapEntrySizeAligned;
    BOOL fPlaceAnyRedirect = TRUE;

    if (!LockContainer(&fMustUnlock))
    {
        dwReturn = GetLastError();
        goto exit;
    }

    // If this is an identity-specific entry, we need to setup an identity-0
    // referrer
    if (pArgs->dwIdentity)
    {
        dwReturn = AddIdentityUrl(pArgs);
        if (dwReturn!=ERROR_SUCCESS)
        {
            goto exit;
        }
        fPlaceAnyRedirect = FALSE;
    }
    
    // Calculate dwUrlNameSize.
    dwUrlNameSize = lstrlen(pArgs->pszUrl) + 1;

    // FileName points to the filename sans cachepath.  Calculate dwFileNameSize.
    if(pArgs->pszFilePath)
    {

        // Is this an absolute path (edited)?
        if (!(pArgs->dwEntryType & EDITED_CACHE_ENTRY))
        // No, so find the last slash in the file name path.
        // This delimits the file name.

        {
            CHAR  *pSlash = NULL,
                  *ptr = (LPSTR) pArgs->pszFilePath;
            while (*ptr)
            {
                if (*ptr == DIR_SEPARATOR_CHAR)
                    pSlash = ptr;

                ptr=CharNext(ptr);
            }
            FileName = pSlash  + 1;
            dwFileNameSize = (DWORD) (ptr - FileName + 1); // 64BIT
        }
        // Have an absolute path so use the full path
        else
        {
            FileName = (char *)pArgs->pszFilePath;
            dwFileNameSize = lstrlen(FileName)+1;
        }
    }
    else
    {
        FileName = NULL;
        dwFileNameSize = 0;
    }

    // Calculate dwUrlFileExtSize
    if (FileName)
    {
        dwUrlFileExtSize =
            (pArgs->pszFileExt? (lstrlen(pArgs->pszFileExt) + 1) : sizeof("txt"));

    }
    else
    {
        dwUrlFileExtSize = 0;
    }

    // Get the file size.
    if (!pArgs->pszFilePath)
        dwFileSize = 0;
    else
    {
        if (!pArgs->dwFileSize)
        {
            WIN32_FILE_ATTRIBUTE_DATA FileAttrData;

            dwReturn = GetFileSizeAndTimeByName(pArgs->pszFilePath, &FileAttrData);
            // If not succeed, return a uniform error.
            if ((ERROR_SUCCESS!=dwReturn) || FileAttrData.nFileSizeHigh) // Accept 0 length files too ...
            {
                // Reject files of length 0 or larger than 4 GB.
                dwReturn = ERROR_INVALID_DATA;
                goto exit;
            }
            dwFileSize = FileAttrData.nFileSizeLow;
            ftCreate = FileAttrData.ftCreationTime;
        }
        else
        {
            dwFileSize = pArgs->dwFileSize;
            ftCreate = pArgs->ftCreate;
        }
    }

    dwReturn = ERROR_SUCCESS;

    { // Open a new block to limit the scope of pointer variables.

        HASH_ITEM *pItem;

        // Lookup or create a hash item for the URL entry.

        fUpdate = HashFindItem (pArgs->pszUrl, LOOKUP_URL_CREATE, &pItem);

//////////////////////////////////////////////////////////////////////////////
// WARNING: LOOKUP_URL_CREATE set,thus the file might be grown and remapped //
// so all pointers into the file must be recalculated from their offsets!   //
//////////////////////////////////////////////////////////////////////////////

        if (fUpdate)
        {
            // Check existing entry for refcount.
            URL_FILEMAP_ENTRY* pOld = HashGetEntry (pItem);
            if (pOld->NumReferences)
            {
                dwReturn = ERROR_SHARING_VIOLATION;
                goto exit;
            }

            // Validate the size of data to be copied from existing entry.
            // If the entry version is IE5, the value could be random, so
            // force it to the correct value.  If the value is otherwise
            // bogus, also set it to the IE5 size for safety.
            if (    pOld->bVerCreate == ENTRY_VERSION_IE5
                ||  pOld->CopySize > pOld->nBlocks * NORMAL_ENTRY_SIZE
                ||  pOld->CopySize & 3 // should be dword aligned
               )
            {
                pOld->CopySize = ENTRY_COPYSIZE_IE5;
            }

            dwFileMapEntrySizeAligned = pOld->CopySize;
        }
        else if (!pItem)
        {
            // Item was not found but could not allocate another hash table.
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }
        else // brand new entry
        {
           dwFileMapEntrySizeAligned = ENTRY_COPYSIZE_CURRENT;
        }

        // Save offsets in case the memmap file must be grown and remapped.
        dwItemOffset = (DWORD) ((LPBYTE) pItem - *_UrlObjStorage->GetHeapStart()); // 64BIT
    }

//////////////////////////////////////////////////////////////////
// BEGIN WARNING: The file might be grown and remapped, so all  //
// pointers into the file before this point may be invalidated. //
//////////////////////////////////////////////////////////////////

    // Create/update offline redirect as necessary.
    if (pArgs->pszRedirect && fPlaceAnyRedirect)
    {
        UpdateOfflineRedirect
            (dwItemOffset, pArgs->pszUrl, dwUrlNameSize - 1, pArgs->pszRedirect);
    }

    DWORD dwUrlNameSizeAligned;
    DWORD dwFileNameSizeAligned;
    DWORD dwHeaderSizeAligned;
    DWORD dwUrlFileExtSizeAligned;

    // Calculate the total size of the entry, rounding up for alignment.
    dwUrlNameSizeAligned        = ROUNDUPDWORD(dwUrlNameSize);
    dwFileNameSizeAligned       = ROUNDUPDWORD(dwFileNameSize);
    dwHeaderSizeAligned         = (pArgs->pbHeaders) ? ROUNDUPDWORD(pArgs->cbHeaders) : 0;
    dwUrlFileExtSizeAligned     = ROUNDUPDWORD(dwUrlFileExtSize);

    INET_ASSERT (dwFileMapEntrySizeAligned % sizeof(DWORD) == 0);
    INET_ASSERT (sizeof(FILEMAP_ENTRY) % sizeof(DWORD) == 0);
    dwFileMapEntrySizeAligned += sizeof(FILEMAP_ENTRY);

    dwEntrySize =         dwFileMapEntrySizeAligned
                        + dwUrlNameSizeAligned
                        + dwFileNameSizeAligned
                        + dwHeaderSizeAligned
                        + dwUrlFileExtSizeAligned;

    NewEntry = (LPURL_FILEMAP_ENTRY) _UrlObjStorage->AllocateEntry(dwEntrySize);

//////////////////////////////////////////////////////////////////
// END WARNING: The file might have grown and remapped, so all  //
// pointers into the file after this point must be recalculated //
// from offsets.                                                //
//////////////////////////////////////////////////////////////////

    // Restore pointer to hash table item.
    pItem = (HASH_ITEM*) (*_UrlObjStorage->GetHeapStart() + dwItemOffset);

    if (!NewEntry)
    {
        if (!fUpdate)
            pItem->MarkFree();
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }


/*
    Handle any differences between cache entry versions.

    IE5 inits bVerUpdate to 0 when creating an entry, but incorrectly preserves 
    the value when updating instead of forcing it to 0.  Fortunately IE6 does 
    not care since IE5 will not be able to find an identity-specific entry in 
    order to update it.

    However, we should have a safety hatch for IE7+ to realize that a downlevel 
    urlcache updated its entry and just copied over the opaque data.  Of course 
    the solution will be a total ugly hack.  One possibility is for the uplevel 
    urlcache to set dwUrlNameOffset to be dwCopySizeAligned + 4.  This will 
    leave an uninitialized dword "hole" between the fixed fields and the 4 
    variable size fields.  Once this hack is used, by IE7 for example, it 
    should correctly set bVerUpdate2 so that IE8+ can detect both IE5-6 and IE7 
    updates without creating further holes.
*/

    if (fUpdate)
    {
        URL_FILEMAP_ENTRY* pOld = HashGetEntry (pItem);

        if ((pOld->dwSig != SIG_URL)
            || (pOld->CopySize > PAGE_SIZE))
        {
            INET_ASSERT(FALSE);
            pItem->MarkFree();
            _UrlObjStorage->FreeEntry(NewEntry);
            dwReturn = ERROR_WINHTTP_INTERNAL_ERROR;
            goto exit;
        }
        
        CopyMemory (((LPBYTE) NewEntry) + sizeof(FILEMAP_ENTRY),
                    ((LPBYTE) pOld) + sizeof(FILEMAP_ENTRY),
                    pOld->CopySize);
        INET_ASSERT (NewEntry->CopySize == pOld->CopySize);
        if (NewEntry->CopySize == ENTRY_COPYSIZE_IE5)
            NewEntry->bVerCreate = ENTRY_VERSION_IE5;
        INET_ASSERT (NewEntry->bVerCreate == pOld->bVerCreate);
    }
    else
    {
        NewEntry->CopySize   = ENTRY_COPYSIZE_CURRENT;
        NewEntry->bVerCreate = ENTRY_VERSION_CURRENT;
        NewEntry->bVerUpdate = ENTRY_VERSION_CURRENT;
    }

    // Invalidate the signature during the update.
    NewEntry->dwSig = 0;

    // We must set entry type, file size, and exempt delta before
    // calling SetExemptDelta.  We leave the sticky bit out of the
    // entry type in case we have no more room for sticky items.
    NewEntry->CacheEntryType = _CacheEntryType
                                | (pArgs->dwEntryType & ~STICKY_CACHE_ENTRY);

    NewEntry->dwFileSize = dwFileSize;

    if (!fUpdate)
    {
        // This is a brand new entry.
        NewEntry->dwGroupOffset = 0;
        NewEntry->NumAccessed   = 1;

        if (pArgs->fImage)
        {
            NewEntry->bSyncState = SYNCSTATE_IMAGE;
            BETA_LOG (SYNCSTATE_IMAGE);
        }
        else
        {
            NewEntry->bSyncState = SYNCSTATE_VOLATILE;
            if (IsContentContainer())
                BETA_LOG (SYNCSTATE_VOLATILE);
        }

        NewEntry->dwExemptDelta = 0;
        if (pArgs->dwEntryType & STICKY_CACHE_ENTRY)
            SetExemptDelta (NewEntry, 24 * 60 * 60, dwItemOffset); // one day
    }
    else // if (fUpdate)
    {
        URL_FILEMAP_ENTRY* ExistingEntry = HashGetEntry (pItem);

        // This is an update of an existing entry.
        INET_ASSERT (NewEntry->dwGroupOffset == ExistingEntry->dwGroupOffset);

        NewEntry->NumAccessed++;  // BUGBUG: blowing off wraparound

        if (ExistingEntry->bSyncState == SYNCSTATE_STATIC)
            BETA_LOG (SYNCSTATE_STATIC_VOLATILE);

        NewEntry->bSyncState = SYNCSTATE_VOLATILE;


        if (ExistingEntry->dwExemptDelta ||
            ExistingEntry->CacheEntryType & STICKY_CACHE_ENTRY )
        {
            // If item was previously sticky, it is preserved upon update.
            NewEntry->dwExemptDelta = ExistingEntry->dwExemptDelta;
            INET_ASSERT (ExistingEntry->CacheEntryType | STICKY_CACHE_ENTRY);
            NewEntry->CacheEntryType |= STICKY_CACHE_ENTRY;
        }
        else
        {
            // If the item wasn't previously sticky, it might be made so.
            NewEntry->dwExemptDelta = 0;
            if (pArgs->dwEntryType & STICKY_CACHE_ENTRY)
                SetExemptDelta (NewEntry, 24 * 60 * 60 * 1000, dwItemOffset); // one day
        }

        // if belongs to a group, adjust the group usage
        if( ExistingEntry->dwGroupOffset &&
            ExistingEntry->dwFileSize != NewEntry->dwFileSize )
        {
            LONGLONG llDelta = RealFileSize(NewEntry->dwFileSize) -
                               RealFileSize(ExistingEntry->dwFileSize);
            if( pItem->HasMultiGroup() )
            {
                // multiple group
                if( gm.Init(this) )
                {
                    // dwGroupOffset is now offset to head of group list
                    gm.AdjustUsageOnList(ExistingEntry->dwGroupOffset, llDelta);
                }
            }
            else
            {
                // single group
                pGroupEntry = _UrlObjStorage->ValidateGroupOffset(
                    ExistingEntry->dwGroupOffset, pItem);

                // WARNING: quota can be reached by usage increase
                if( pGroupEntry )
                {
                    AdjustGroupUsage(pGroupEntry, llDelta);
                }
            }
        }

        // Delete the old entry if it's not an installed entry or an EDITED_CACHE_ENTRY
        // (Unless the new entry replacing it is also an EDITED_CACHE_ENTRY),
        // either way the hash table item is preserved. We also check the filesize if
        // we've determined the old entry was ECE but the new one is not, just in case
        // the client deletes the file but doesn't get around to deleting from the
        // cache index. The logic is optimized for the most likely case (want to del).
        if ((ExistingEntry->DirIndex != INSTALLED_DIRECTORY_KEY)
            && (!(ExistingEntry->CacheEntryType & EDITED_CACHE_ENTRY)))
        {
            // IDK=0 ECE=0 NECE=? FS=?
            DeleteUrlEntry (ExistingEntry, NULL, SIG_UPDATE);
        }
        else if (ExistingEntry->DirIndex != INSTALLED_DIRECTORY_KEY)
        {
            // IDK=0 ECE=1 NECE=? FS=?
            if (NewEntry->CacheEntryType & EDITED_CACHE_ENTRY)
            {
                // IDK=0 ECE=1 NECE=1 FS=?
                DeleteUrlEntry (ExistingEntry, NULL, SIG_UPDATE);
            }
            else
            {
                // IDK=0 ECE=1 NECE=0 FS=?
                // Only want to go out to the FS to get filesize if absolutely necessary

                WIN32_FILE_ATTRIBUTE_DATA FileAttrData;

                FileAttrData.nFileSizeLow = 0;
                dwReturn = GetFileSizeAndTimeByName(
                    (LPTSTR) OFFSET_TO_POINTER (ExistingEntry, ExistingEntry->InternalFileNameOffset),
                    &FileAttrData);
                if (!FileAttrData.nFileSizeLow)
                {
                    // IDK=0 ECE=1 NECE=0 FS=0 or not-exist
                    // if filesize is zero, might as well trounce it
                    DeleteUrlEntry (ExistingEntry, NULL, SIG_UPDATE);
                }
                else if (dwReturn == ERROR_SUCCESS)
                {
                    // IDK=0 ECE=1 NECE=0 FS>0
                    // found a non-zero length file
                    _UrlObjStorage->FreeEntry(NewEntry);
                    pItem->MarkFree();
                    dwReturn = ERROR_SHARING_VIOLATION;
                    goto exit;
                }
            }
        }
        else
        {
            // IDK=1 ECE=? NECE=? FS=?
            // Installed directory item
            _UrlObjStorage->FreeEntry(NewEntry);
            pItem->MarkFree();
            dwReturn = ERROR_SHARING_VIOLATION;
            goto exit;
        }

    } // end else if (fUpdate)

    // Record the new offset in the hash table item.
    HashSetEntry (pItem, (LPBYTE) NewEntry);

    // Initialize NewEntry fields.
    NewEntry->dwRedirHashItemOffset = 0;
    NewEntry->NumReferences        = 0;
    NewEntry->HeaderInfoSize       = pArgs->cbHeaders;
    NewEntry->LastModifiedTime     = pArgs->qwLastMod;
    GetCurrentGmtTime ((FILETIME*) &NewEntry->LastAccessedTime);

    FileTime2DosTime(
        *LONGLONG_TO_FILETIME( &(pArgs->qwExpires) ),
        &(NewEntry->dostExpireTime)   );

    FileTime2DosTime(
        *LONGLONG_TO_FILETIME( &(pArgs->qwPostCheck) ),
        &(NewEntry->dostPostCheckTime)   );

    // GetDirIndex will fail if the entry is stored at an absolute path outside
    // the cache dir, This is valid for EDITED_CACHE_ENTRYs such as offline
    // Office9 docs. Even tho the call fails in this case, NewEntry->DirIndex
    // will be set to NOT_A_CACHE_SUBDIRECTORY

    DWORD dwIndex;
    if ((!_FileManager->GetDirIndex((LPSTR) pArgs->pszFilePath, &dwIndex))
        && !((pArgs->dwEntryType & EDITED_CACHE_ENTRY)
             || ((pArgs->dwEntryType & IDENTITY_CACHE_ENTRY) && !pArgs->dwIdentity)))
    {
        _UrlObjStorage->FreeEntry(NewEntry);
        pItem->MarkFree();
        dwReturn = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    NewEntry->DirIndex = (BYTE) dwIndex;

    // If this entry points to the store directory, set
    // the INSTALLED_CACHE_ENTRY bit so that retrieval
    // from cache will not result in requests to the wire
    // from wininet except for refresh requests.

    if ((NewEntry->DirIndex == INSTALLED_DIRECTORY_KEY) ||
        (pArgs->dwEntryType & EDITED_CACHE_ENTRY))
    {
        NewEntry->CacheEntryType |= INSTALLED_CACHE_ENTRY;
    }

    FileTimeToDosDateTime( (FILETIME *)&(NewEntry->LastAccessedTime),
                           (LPWORD)&(NewEntry->dostLastSyncTime),
                           ((LPWORD)&(NewEntry->dostLastSyncTime)+1));

    // Specify identity.
    NewEntry->dwIdentity = pArgs->dwIdentity;
    if (pArgs->dwIdentity)
    {
        NewEntry->CacheEntryType |= IDENTITY_CACHE_ENTRY;
    }
    
    // The URL_FILEMAP_ENTRY will point to
    //
    // [URL_FILEMAP_ENTRY][UrlName][FileName][HeaderInfo][FileExtension]
    //                    ^        ^         ^           ^
    //                    |        |         |           FileExtensionOffset
    //                    |        |         |
    //                    |        |         HeaderInfoOffset
    //                    |        |
    //                    |        FileNameOffset
    //                    |
    //                    UrlNameOffset
    //


    dwCurrentOffset = dwFileMapEntrySizeAligned;
    NewEntry->UrlNameOffset = dwCurrentOffset;

    // Copy UrlName into NewEntry
    memcpy((LPSTR) OFFSET_TO_POINTER(NewEntry, NewEntry->UrlNameOffset),
        pArgs->pszUrl, dwUrlNameSize);

    dwCurrentOffset += dwUrlNameSizeAligned;

    // Copy FileName into NewEntry
    if(FileName)
    {
        NewEntry->InternalFileNameOffset = dwCurrentOffset;
        memcpy((LPTSTR) OFFSET_TO_POINTER (NewEntry,
            NewEntry->InternalFileNameOffset), FileName, dwFileNameSize);

        // Get file creation time of cache file.
        if (!pArgs->pszFilePath)
            NewEntry->dostFileCreationTime = 0;
        else
        {
            FileTimeToDosDateTime (&ftCreate,
                (LPWORD)&(NewEntry->dostFileCreationTime),
                ((LPWORD)&(NewEntry->dostFileCreationTime)+1));
        }

        dwCurrentOffset += dwFileNameSizeAligned;
    }
    else
    {
        NewEntry->InternalFileNameOffset = 0;
        NewEntry->dostFileCreationTime = 0;
    }

    // Copy HeaderInfo into NewEntry
    if(pArgs->pbHeaders)
    {
        NewEntry->HeaderInfoOffset = dwCurrentOffset;
        memcpy((LPBYTE)NewEntry + NewEntry->HeaderInfoOffset,
            pArgs->pbHeaders, pArgs->cbHeaders);
        dwCurrentOffset += dwHeaderSizeAligned;
    }
    else
    {
        NewEntry->HeaderInfoOffset = 0;
    }

    // Copy FileExtension into NewEntry
    if(pArgs->pszFileExt)
    {
        NewEntry->FileExtensionOffset = dwCurrentOffset;
        memcpy ((LPTSTR) ((LPBYTE)NewEntry + NewEntry->FileExtensionOffset),
            pArgs->pszFileExt, dwUrlFileExtSize);
        dwCurrentOffset += dwUrlFileExtSizeAligned;
    }
    else
    {
        NewEntry->FileExtensionOffset = 0;
    }

    // Restore the signature.
    NewEntry->dwSig = SIG_URL;

    // Increment the FileManager's count
    if (FileName)
    {
        // This is a no-op for the COOKIES and HISTORY containers.
        _FileManager->NotifyCommit(NewEntry->DirIndex);

        // Adjust CacheSize if not an installed entry or stored outside of cache dir.
        // If disk quota is exceeded, initiate cleanup.
        // NOTE: this attempts to take the critical section, so we must defer it
        // until we have released the container mutex to avoid potential deadlock
        if ((NewEntry->DirIndex != INSTALLED_DIRECTORY_KEY) && (!(NewEntry->CacheEntryType & EDITED_CACHE_ENTRY)))
        {
            _dwBytesDownloaded += (DWORD)RealFileSize(dwFileSize);
            _dwItemsDownloaded++;

            _UrlObjStorage->AdjustCacheSize(RealFileSize(dwFileSize));
            CacheSize = _UrlObjStorage->GetCacheSize();
            CacheLimit = _UrlObjStorage->GetCacheLimit();
            if (CacheSize > CacheLimit)
                _fMustLaunchScavenger = TRUE;

            // We also want to scavenge if, even though there's plenty of space available in the
            // cache, the amount of total disk space available falls below a certain threshold.
            // We'll arbitrarily set the threshold to be 4MB (below which, things are likely to get
            // painful.

            if (!_fMustLaunchScavenger && ((_dwBytesDownloaded>(1024*1024)) || (_dwItemsDownloaded>100)))
            {
                DWORDLONG dlSize = 0;

                _dwBytesDownloaded = _dwItemsDownloaded = 0;
                if (GetDiskInfo(_CachePath, NULL, &dlSize, NULL))
                {
                    _fMustLaunchScavenger = (BOOL)(dlSize <= (DWORDLONG)GlobalDiskUsageLowerBound);
                }
            }
        }
    }

    // Flush index if this is an edited document or Cookie to mitigate the risk of dirty shutdown losing changes a client
    // like Office9 might have made (they store edited docs in our cache).

    if (pArgs->dwEntryType & EDITED_CACHE_ENTRY )
    {
        FlushViewOfFile((LPCVOID)NewEntry, dwCurrentOffset);
    }

    if( pArgs->dwEntryType & COOKIE_CACHE_ENTRY )
    {
        FlushViewOfFile( (void*)(*_UrlObjStorage->GetHeapStart()), 0 );
    }


    // Notification
    // If item was previously sticky, it is preserved upon update.
    // only need to report non sticky -> sticky
    if( !fUpdate )
    {
        NotifyCacheChange(CACHE_NOTIFY_ADD_URL, dwItemOffset);
    }
    else
    {
        NotifyCacheChange(CACHE_NOTIFY_UPDATE_URL, dwItemOffset);
    }

exit:

    if (fMustUnlock) UnlockContainer();
    return dwReturn;
}



DWORD URL_CONTAINER::AddLeakFile (LPCSTR pszFilePath)
{
    DWORD dwReturn;

    BOOL fUnlock;
    if (!LockContainer(&fUnlock))
    {
        if(fUnlock)
            ReleaseMutex(_MutexHandle);

        return GetLastError();
    }

    //
    // Calculate the size of the filename, after the last slash.
    //

    LPSTR pszSlash = NULL;
    LPSTR pszScan = (LPSTR) pszFilePath;
    while (*pszScan)
    {
        if (*pszScan == DIR_SEPARATOR_CHAR)
            pszSlash = pszScan;

        pszScan = CharNext(pszScan);
    }
    LPSTR pszFileName = pszSlash + 1;
    DWORD cbFileName = (DWORD) (pszScan - pszFileName + 1); // 64BIT

    //
    // Determine the directory bucket.
    //

    DWORD nDirIndex;
    if (!_FileManager->GetDirIndex((LPSTR) pszFilePath, &nDirIndex))
    {
        dwReturn = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    //
    // Get the file size and create time.
    //

    WIN32_FILE_ATTRIBUTE_DATA FileAttrData;
    dwReturn = GetFileSizeAndTimeByName (pszFilePath, &FileAttrData);
    if (!FileAttrData.nFileSizeLow || FileAttrData.nFileSizeHigh)
    {
        // Reject files of length 0 or larger than 4 GB.
        dwReturn = ERROR_INVALID_DATA;
        goto exit;
    }

    //
    // Allocate a leaked file entry.
    //

//////////////////////////////////////////////////////////////////
// BEGIN WARNING: The file might be grown and remapped, so all  //
// pointers into the file before this point may be invalidated. //
//////////////////////////////////////////////////////////////////


    URL_FILEMAP_ENTRY* NewEntry;
    NewEntry = (URL_FILEMAP_ENTRY*) _UrlObjStorage->AllocateEntry
        (sizeof(URL_FILEMAP_ENTRY) + cbFileName);
    if (!NewEntry)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

//////////////////////////////////////////////////////////////////
// END WARNING: The file might have grown and remapped, so all  //
// pointers into the file after this point must be recalculated //
// from offsets.                                                //
//////////////////////////////////////////////////////////////////


    //
    // Fill only the fields important to WalkLeakList method.
    //

    NewEntry->dwSig = SIG_LEAK;
    NewEntry->dwFileSize = FileAttrData.nFileSizeLow;
    NewEntry->InternalFileNameOffset = sizeof(URL_FILEMAP_ENTRY);
    memcpy ((LPBYTE) (NewEntry + 1), pszFileName, cbFileName);
    NewEntry->DirIndex = (BYTE) nDirIndex;
    FileTimeToDosDateTime( &FileAttrData.ftCreationTime,
                           (LPWORD)&(NewEntry->dostFileCreationTime),
                           ((LPWORD)&(NewEntry->dostFileCreationTime)+1));
    NewEntry->NumReferences = 0;

    //
    // Add this entry on to the head of the scavenger leak list.
    //
    _UrlObjStorage->GetHeaderData
        (CACHE_HEADER_DATA_ROOT_LEAK_OFFSET, &NewEntry->dwNextLeak);
    _UrlObjStorage->SetHeaderData
        (CACHE_HEADER_DATA_ROOT_LEAK_OFFSET,
         OffsetFromPointer (NewEntry));

    //
    // Update the cache usage and directory count.
    //

    _UrlObjStorage->AdjustCacheSize(RealFileSize(NewEntry->dwFileSize));
    _FileManager->NotifyCommit(NewEntry->DirIndex);

    //
    // We could check here if usage exceeds quota then launch scavenger,
    // but it will probably happen soon enough anyway upon AddUrl.
    //

    dwReturn = ERROR_SUCCESS;

exit:
    if (fUnlock)
        UnlockContainer();

    return dwReturn;
}

DWORD URL_CONTAINER::RetrieveUrl
(
    LPCSTR UrlName,
    LPCACHE_ENTRY_INFO* ppInfo,
    LPDWORD pcbInfo,
    DWORD dwLookupFlags, // e.g. redirect
    DWORD dwRetrievalFlags
)

/*++

Routine Description:

    This member function retrives an url from the cache. The url is marked
    as referenced, so that caller should call UnlockUrl when he is done
    using it.

Arguments:

    UrlName : pointer to the url name.

    ppInfo :  ptr to ptr to an entry info buffer, where the url entry info
        is returned.

    pcbInfo : pointer to a DWORD location containing the size of the
        above buffer, on return it has the size of the buffer consumed or
        size of the buffer required for successful retrieval.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    LPURL_FILEMAP_ENTRY UrlEntry;
    BOOL fMustUnlock;

    if (!LockContainer(&fMustUnlock))
    {
        Error = GetLastError();
        goto exit;
    }

    // Find the item.
    HASH_ITEM *pItem;

    if (!HashFindItem (UrlName, dwLookupFlags, &pItem))
    {
        Error = ERROR_FILE_NOT_FOUND;
        goto exit;
    }

    // Get the hash entry.
    UrlEntry = HashGetEntry (pItem);
    if (UrlEntry->InternalFileNameOffset == 0)
    {
        Error = ERROR_INVALID_DATA;
        goto exit;
    }
    
    // For content container, check that username matches.
    if (IsContentContainer())
    {
        LPSTR pszHeaders = ((LPSTR) UrlEntry) + UrlEntry->HeaderInfoOffset;
        TcpsvcsDbgPrint((DEBUG_CONTAINER,
            "RetrieveUrl (contain.cxx): IsContentContainer() = TRUE; IsCorrectUser() = %s \r\n",
            (IsCorrectUser(pszHeaders, UrlEntry->HeaderInfoSize))? "TRUE" : "FALSE"
            ));

        if (!IsCorrectUser(pszHeaders, UrlEntry->HeaderInfoSize))
        {
            Error = ERROR_FILE_NOT_FOUND;
            goto exit;
        }
    }
    else
    {
        TcpsvcsDbgPrint((DEBUG_CONTAINER,
            "RetrieveUrl (contain.cxx): IsContentContainer() = FALSE\r\n"));
    }
    // Hide sparse cache entries from non-wininet clients.

    if (UrlEntry->CacheEntryType & SPARSE_CACHE_ENTRY
            && !(dwLookupFlags & LOOKUP_BIT_SPARSE))
    {
        Error = ERROR_FILE_NOT_FOUND;
        goto exit;
    }

    // Found the entry. Copy URL info in the return buffer first.
    Error = CopyUrlInfoGuard( UrlEntry, ppInfo, pcbInfo, dwRetrievalFlags );
    if( Error != ERROR_SUCCESS )
        goto Cleanup;

    if ((*ppInfo)->CacheEntryType & SPARSE_CACHE_ENTRY)
    {
        // Delete the item and entry but not the file.
        UrlEntry->InternalFileNameOffset = 0;
        DeleteUrlEntry (UrlEntry, pItem, SIG_DELETE);
        Error = ERROR_SUCCESS;
        goto Cleanup;
    }

    // Verify the file size is what it is supposed to be.
    if (dwRetrievalFlags & RETRIEVE_WITH_CHECKS)
    {
        DWORD dwFileSize;
        Error = GetFileSizeByName
            ((LPCSTR)((*ppInfo)->lpszLocalFileName), &dwFileSize);
        if (Error != ERROR_SUCCESS)
        {
            Error = ERROR_INVALID_DATA;
            goto Cleanup;
        }

        if (dwFileSize != UrlEntry->dwFileSize)
        {
            Error = ERROR_INVALID_DATA;
            goto Cleanup;
        }
    }

    // Hack to keep track of if any entries have locks.
    GlobalRetrieveUrlCacheEntryFileCount++;

    // Increment the reference count before returning.
    if (UrlEntry->NumReferences)
    {
        if( !pItem->IsLocked() )
        {
            //
            // corrupted index file
            // entry says it's locked, hash table say it's not
            // believe the hash table by fixing up the entry
            //
            INET_ASSERT (FALSE);
            UrlEntry->NumReferences = 0;
        }
    }
    else
        pItem->SetLocked();

    UrlEntry->NumReferences++;

    // Update last accessed time.
    GetCurrentGmtTime ((FILETIME*) &UrlEntry->LastAccessedTime);
 
    // And the number of times this was accessed
    UrlEntry->NumAccessed++;

Cleanup:

    if (Error != ERROR_SUCCESS)
    {
        TcpsvcsDbgPrint(( DEBUG_ERRORS, "RetrieveUrl call failed, %ld.\n",
            Error ));
        SetLastError(Error);
    }
exit:
    if (fMustUnlock) UnlockContainer();
    return Error;
}


DWORD URL_CONTAINER::DeleteUrl(LPCSTR  UrlName)
/*++

Routine Description:

    This member function deletes the specified url from the cache.

Arguments:

    UrlName : pointer to the url name.

Return Value:

    Windows Error Code.

--*/
{
    BOOL fMustUnlock;
    DWORD Error;
    URL_FILEMAP_ENTRY *pEntry;
    HASH_ITEM *pItem;

    if (!LockContainer(&fMustUnlock))
    {
        Error = GetLastError();
        goto exit;
    }

    // Find (and validate) the entry.
    if (!HashFindItem (UrlName, LOOKUP_URL_NOCREATE, &pItem))
    {
        Error = ERROR_FILE_NOT_FOUND;
        goto exit;
    }

    pEntry = HashGetEntry(pItem);

    // Delete the hash table item and entry from the index.
    Error = DeleteUrlEntry (pEntry, pItem, SIG_DELETE);

    TcpsvcsDbgPrint((DEBUG_CONTAINER,
        "DeleteUrl: RefCount=%d, DeletePending=%d \r\n",
        pEntry->NumReferences,
        (pEntry->CacheEntryType & PENDING_DELETE_CACHE_ENTRY)? 1 : 0
        ));

    // Notify
    NotifyCacheChange(
        CACHE_NOTIFY_DELETE_URL,
        (DWORD)( ((LPBYTE) pItem) - *_UrlObjStorage->GetHeapStart())
    );

exit:
    if (fMustUnlock) UnlockContainer();
    return Error;
}


/*++
Routine Description:
    This member functions deletes an URL from the container and also
    deletes the cache file from cache path.

    dwSig - if we must put an uplevel entry on the async fixup list,
       this param distinguishes between updates and deletions.

Return Value:
    Windows Error Code.
--*/

DWORD URL_CONTAINER::DeleteUrlEntry
    (URL_FILEMAP_ENTRY* pEntry, HASH_ITEM *pItem, DWORD dwSig)
{
    INET_ASSERT (pItem? dwSig == SIG_DELETE : dwSig == SIG_UPDATE);

    if (pEntry->dwSig != SIG_URL)
    {
        INET_ASSERT(FALSE);
        return ERROR_INVALID_PARAMETER;
    }

    DWORD Error;
    GROUP_ENTRY* pGroupEntry = NULL;
    GroupMgr     gm;

    // Check for locked entry.
    if (pEntry->NumReferences)
    {
        // Mark the entry for pending delete.
        pEntry->CacheEntryType |= PENDING_DELETE_CACHE_ENTRY;
        Error = ERROR_SHARING_VIOLATION;
        goto Cleanup;
    }

    // If the entry version is beyond our understanding...
    if (pEntry->bVerCreate & ENTRY_VERSION_NONCOMPAT_MASK)
    {
        INET_ASSERT (!(pEntry->bVerCreate & ENTRY_VERSION_NONCOMPAT_MASK));

        pEntry->dwSig = dwSig; // mark as either updated or deleted

        // Add entry to head of fixup list.
        _UrlObjStorage->GetHeaderData
            (CACHE_HEADER_DATA_ROOT_FIXUP_OFFSET, &pEntry->dwNextLeak);
        _UrlObjStorage->SetHeaderData
            (CACHE_HEADER_DATA_ROOT_FIXUP_OFFSET,
             OffsetFromPointer (pEntry));

        // Increment count of items on fixup list, maybe trigger fixup.
        DWORD dwCount, dwTrigger;
        _UrlObjStorage->GetHeaderData
            (CACHE_HEADER_DATA_ROOT_FIXUP_COUNT, &dwCount);
        _UrlObjStorage->GetHeaderData
            (CACHE_HEADER_DATA_ROOT_FIXUP_TRIGGER, &dwTrigger);
        if (++dwCount > dwTrigger)
            _fMustLaunchScavenger = TRUE;
        _UrlObjStorage->SetHeaderData
            (CACHE_HEADER_DATA_ROOT_FIXUP_COUNT, dwCount);

        goto delete_hash_item;
    }

    // If group associated, Adjust Group's disk Usage
    // if pItem == NULL, we should perserve all the group info
    if( pEntry->dwGroupOffset && pItem )
    {
        if( pItem->HasMultiGroup() )
        {
            // multiple group
            if( gm.Init(this) )
            {
                // dwGroupOffset now offset to head of group list
                gm.AdjustUsageOnList(
                    pEntry->dwGroupOffset, -RealFileSize(pEntry->dwFileSize) );
            }
        }
        else
        {
            // single group
            pGroupEntry = _UrlObjStorage->ValidateGroupOffset(
                pEntry->dwGroupOffset, pItem);

            if( pGroupEntry )
            {
                AdjustGroupUsage(pGroupEntry, -RealFileSize(pEntry->dwFileSize) );
            }
        }
    }

    // Delete any associated file.
    if (pEntry->InternalFileNameOffset
        && (pEntry->DirIndex != INSTALLED_DIRECTORY_KEY)
        && (!(pEntry->CacheEntryType & EDITED_CACHE_ENTRY)))
    {
        // Reduce the exempt usage for sticky item (could be an update)
        if ( pEntry->dwExemptDelta ||
             (pEntry->CacheEntryType & STICKY_CACHE_ENTRY) )
            _UrlObjStorage->AdjustExemptUsage(-RealFileSize(pEntry->dwFileSize));

        // Get the absolute path to the file.
        DWORD cb;
        TCHAR szFile[MAX_PATH];
        if (_FileManager->GetFilePathFromEntry(pEntry, szFile, &(cb = MAX_PATH))
            && _FileManager->DeleteOneCachedFile
            (szFile, pEntry->dostFileCreationTime, pEntry->DirIndex))
        {
            // Adjust cache usage.
            _UrlObjStorage->AdjustCacheSize(-RealFileSize(pEntry->dwFileSize));
            _UrlObjStorage->FreeEntry(pEntry);
        }
        else
        {
            // Link the entry at the head of leaked files list.
            INET_ASSERT(pEntry->NumReferences==0);

            pEntry->dwSig = SIG_LEAK;
            _UrlObjStorage->GetHeaderData
                (CACHE_HEADER_DATA_ROOT_LEAK_OFFSET, &pEntry->dwNextLeak);
            _UrlObjStorage->SetHeaderData
                (CACHE_HEADER_DATA_ROOT_LEAK_OFFSET,
                 OffsetFromPointer (pEntry));
        }
    }
    else
    {
        // NOTE: In the case that the entry is in a store (INSTALLED_DIRECTORY_KEY)
        // we do allow the cache entry to be deleted, but we do NOT allow the associated
        // file to be deleted. This at least allows us to delete these entries from
        // the cache without affecting their (permanent) backing store files.

        _UrlObjStorage->FreeEntry(pEntry);
    }

delete_hash_item:

    // Delete this item from the hash table.
    if (pItem)
        pItem->MarkFree();

    Error = ERROR_SUCCESS;

Cleanup:

    TcpsvcsDbgPrint ((DEBUG_ERRORS,
        "URL_CONTAINER::DeleteUrlEntry() returning %ld\n", Error));
    return Error;
}


DWORD URL_CONTAINER::UnlockUrl(LPCSTR UrlName)
/*++

Routine Description:

    This member function unreferences the url entry, so that it can be
    freed up when used no one.

Arguments:

    Url : pointer to an URL name.

Return Value:

    Windows Error Code.

--*/
 {
    DWORD Error;
    BOOL fMustUnlock;

    if (!LockContainer(&fMustUnlock))
    {
        Error = GetLastError();
        goto exit;
    }

    HASH_ITEM* pItem;
    URL_FILEMAP_ENTRY* pEntry;

    // Look up the entry.
    if (HashFindItem (UrlName, LOOKUP_URL_NOCREATE, &pItem))
        pEntry = HashGetEntry (pItem);
    else
    {
        Error = ERROR_FILE_NOT_FOUND;
        goto exit;
    }

    TcpsvcsDbgPrint((DEBUG_CONTAINER,
        "RefCount=%d, DeletePending=%d \r\n",
        pEntry->NumReferences,
        (pEntry->CacheEntryType & PENDING_DELETE_CACHE_ENTRY)? 1 : 0
        ));

    UnlockItem (pEntry, pItem);

    // Hack to keep track of if any entries have locks.
    GlobalRetrieveUrlCacheEntryFileCount--;
    Error = ERROR_SUCCESS;

exit:
    if (fMustUnlock) UnlockContainer();
    return Error;
}

DWORD URL_CONTAINER::GetUrlInfo
(
    LPCSTR UrlName,
    LPCACHE_ENTRY_INFO* ppUrlInfo,
    LPDWORD UrlInfoLength,
    DWORD dwLookupFlags,
    DWORD dwEntryFlags,
    DWORD dwRetrievalFlags
)
/*++

Routine Description:

    This member function retrieves the url info.

Arguments:

    UrlName : name of the url file (unused now).

    ppUrlInfo : pointer to the pointer to the url info structure that receives the url
        info.

    UrlInfoLength : pointer to a location where length of
        the above buffer is passed in. On return, this contains the length
        of the above buffer that is fulled in.

    dwLookupFlags: flags, e.g. translate through redirects

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    BOOL fMustUnlock;
    LPURL_FILEMAP_ENTRY UrlEntry;

    if (!LockContainer(&fMustUnlock))
    {
        Error = GetLastError();
        goto exit;
    }

    // Look up the entry.
    UrlEntry = HashFindEntry (UrlName, dwLookupFlags);
    if (!UrlEntry)
    {
        Error = ERROR_FILE_NOT_FOUND;
        goto exit;
    }

    // For content container, check that username matches.
    if (IsContentContainer())
    {
        LPSTR pszHeaders = ((LPSTR) UrlEntry) + UrlEntry->HeaderInfoOffset;
        if (!IsCorrectUser(pszHeaders, UrlEntry->HeaderInfoSize))
        {
            Error = ERROR_FILE_NOT_FOUND;
            goto exit;
        }
    }

    // Hide sparse cache entries from non-wininet clients.
    if (UrlEntry->CacheEntryType & SPARSE_CACHE_ENTRY
        && !(dwLookupFlags & LOOKUP_BIT_SPARSE))
    {
        Error = ERROR_FILE_NOT_FOUND;
        goto exit;
    }

    // Find only installed entry types.
    if ((dwEntryFlags & INTERNET_CACHE_FLAG_INSTALLED_ENTRY)
        && (!(UrlEntry->CacheEntryType & INSTALLED_CACHE_ENTRY)))
    {
        Error = ERROR_FILE_NOT_FOUND;
        goto exit;
    }

    if (UrlInfoLength)
    {
        if (!ppUrlInfo || !*ppUrlInfo)
            *UrlInfoLength = 0;

       Error = CopyUrlInfoGuard( UrlEntry, ppUrlInfo, UrlInfoLength,
                            (dwEntryFlags & INTERNET_CACHE_FLAG_ADD_FILENAME_ONLY ?
                                RETRIEVE_ONLY_FILENAME : 0) |
                            (dwEntryFlags & INTERNET_CACHE_FLAG_GET_STRUCT_ONLY ? 
                                RETRIEVE_ONLY_STRUCT_INFO : 0) |
                            dwRetrievalFlags);
    }
    else
       Error = ERROR_SUCCESS;

exit:
   if (fMustUnlock) UnlockContainer();
   return( Error );
}


DWORD URL_CONTAINER::SetExemptDelta
    (URL_FILEMAP_ENTRY* UrlEntry, DWORD dwExemptDelta, DWORD dwItemOffset)
{
    // Expanded history calls with STICKY_CACHE_ENTRY for no good reason.
    // INET_ASSERT (UrlEntry->FileSize);

    DWORD dwError = ERROR_SUCCESS;

    if (dwExemptDelta)
    {
        if (!UrlEntry->dwExemptDelta)
        {
            // Entry is changing from non-exempt to exempt.
            // (exempt limit check should be done at UpdateStickness
            dwError = UpdateStickness(UrlEntry, URLCACHE_OP_SET_STICKY, dwItemOffset);
            if( dwError != ERROR_SUCCESS )
                goto End;
        }
    }
    else // if (!dwExemptDelta)
    {
        if (UrlEntry->dwExemptDelta)
        {
            // Entry is changing from exempt to non-exempt.
            dwError = UpdateStickness(UrlEntry, URLCACHE_OP_UNSET_STICKY, dwItemOffset);
            if( dwError != ERROR_SUCCESS )
                goto End;
        }
    }

    UrlEntry->dwExemptDelta = dwExemptDelta;
End:
    return dwError;
}



DWORD URL_CONTAINER::SetUrlInfo(LPCSTR UrlName,
                                LPCACHE_ENTRY_INFO UrlInfo, DWORD FieldControl)
/*++

Routine Description:

Arguments:

    UrlName : name of the url file (unused now).

    UrlInfo : pointer to the url info structure that has the url info to
        be set.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    LPURL_FILEMAP_ENTRY UrlEntry;
    BOOL fMustUnlock;
    HASH_ITEM *pItem;

    if (!LockContainer(&fMustUnlock))
    {
        Error = GetLastError();
        goto Cleanup;
    }

    // Look up the entry.
    if (HashFindItem (UrlName, 0, &pItem))
    {
        UrlEntry = HashGetEntry (pItem);
    }
    else
    {
        UrlEntry = NULL;
    }

    if (!UrlEntry)
    {
        Error = ERROR_FILE_NOT_FOUND;
        goto Cleanup;
    }

    // Set cache entry ATTRIBUTE.
    if(FieldControl & CACHE_ENTRY_ATTRIBUTE_FC)
    {
        // We must preserve IDENTITY_CACHE_ENTRY bits, if they set
        UrlEntry->CacheEntryType = UrlInfo->CacheEntryType 
                                   | (UrlEntry->CacheEntryType & IDENTITY_CACHE_ENTRY);
    }
    
    // Reset cache entry HITRATE.
    if(FieldControl & CACHE_ENTRY_HITRATE_FC)
        UrlEntry->NumAccessed = UrlInfo->dwHitRate;

    // Set last modified time.
    if(FieldControl & CACHE_ENTRY_MODTIME_FC)
         UrlEntry->LastModifiedTime = FT2LL(UrlInfo->LastModifiedTime);

    // Set expire time.
    if( FieldControl & CACHE_ENTRY_EXPTIME_FC)
    {
        FileTime2DosTime(UrlInfo->ExpireTime, &(UrlEntry->dostExpireTime) );
    }

    // Set last access time.
    if(FieldControl & CACHE_ENTRY_ACCTIME_FC)
        UrlEntry->LastAccessedTime = FT2LL(UrlInfo->LastAccessTime);

    // Set last sync time.
    if(FieldControl & CACHE_ENTRY_SYNCTIME_FC)
    {
        FileTimeToDosDateTime( &(UrlInfo->LastSyncTime),
                                (LPWORD)&(UrlEntry->dostLastSyncTime),
                               ((LPWORD)&(UrlEntry->dostLastSyncTime)+1));

        if (   UrlEntry->bSyncState != SYNCSTATE_VOLATILE
            && UrlEntry->bSyncState < SYNCSTATE_STATIC)
        {
            // See if we should transition to SYNCSTATE_STATIC.
            if (UrlEntry->bSyncState == SYNCSTATE_IMAGE)
            {
                // We have not had the image long enough to
                // conclude it is static.  See if it is older
                // than MIN_AGESYNC.

                LONGLONG qwCreate;
                INET_ASSERT (UrlEntry->dostFileCreationTime);
                DosDateTimeToFileTime(
                    * (LPWORD)&(UrlEntry->dostFileCreationTime),
                    *((LPWORD)&(UrlEntry->dostFileCreationTime)+1),
                    (FILETIME*) &qwCreate);

                if (FT2LL(UrlInfo->LastSyncTime) > qwCreate + MIN_AGESYNC)
                {
                    UrlEntry->bSyncState++;
                }
            }
            else
            {
                if (++UrlEntry->bSyncState == SYNCSTATE_STATIC)
                    BETA_LOG (SYNCSTATE_IMAGE_STATIC);
            }

        }
    }

    if (FieldControl & CACHE_ENTRY_TYPE_FC)
    {
        UrlEntry->CacheEntryType = UrlInfo->CacheEntryType;
    }
    
    // Set exemption delta.
    if (FieldControl & CACHE_ENTRY_EXEMPT_DELTA_FC)
    {
        Error = SetExemptDelta (
            UrlEntry,
            UrlInfo->dwExemptDelta,
            (DWORD)( ((LPBYTE) pItem) - *_UrlObjStorage->GetHeapStart())
        );

        if (Error != ERROR_SUCCESS)
            goto Cleanup;
    }

    Error = ERROR_SUCCESS;

    NotifyCacheChange(CACHE_NOTIFY_UPDATE_URL,
            (DWORD)( ((LPBYTE) pItem) - *_UrlObjStorage->GetHeapStart())
        );

Cleanup:
    if (fMustUnlock) UnlockContainer();
    return Error;
}

/*++
Adds or removes a URL from a group.  If adding, may set exemption time.
--*/
DWORD URL_CONTAINER::SetUrlGroup (LPCSTR lpszUrl, DWORD dwFlags, GROUPID GroupId)
{
    DWORD Error;
    BOOL fMustUnlock;
    LPURL_FILEMAP_ENTRY pEntry;
    GROUP_ENTRY* pGroupEntry = NULL;
    GROUP_ENTRY* pOldGroupEntry = NULL;
    GROUPID      gid = 0;
    HASH_ITEM    *pItem = NULL;
    GroupMgr gm;

    if (dwFlags & INTERNET_CACHE_GROUP_NONE)
        return ERROR_SUCCESS;

    if (!GroupId)
        return ERROR_INVALID_PARAMETER;

    if (!LockContainer(&fMustUnlock))
    {
        Error = GetLastError();
        goto exit;
    }

    //
    // HashFindEntry will do the same thing, however, we need pItem
    // here so that we can set/clear the group bit
    //
    if (HashFindItem (lpszUrl, 0, &pItem))
    {
        pEntry = HashGetEntry (pItem);
    }
    else
    {
        pEntry = NULL;
    }

    if (!pEntry)
    {
        Error = ERROR_FILE_NOT_FOUND;
        goto exit;
    }

    if( !gm.Init(this) )
    {
        Error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto exit;
    }

    if (dwFlags & INTERNET_CACHE_GROUP_REMOVE)
    {
        // offset to GROUP_ENTRY*
        DWORD dwGEOffset = 0;

        // find the group via GroupOffset
        if( !pEntry->dwGroupOffset )
        {
            Error = ERROR_FILE_NOT_FOUND;
            goto exit;
        }

        // Get GroupEntry Offset
        if( pItem->HasMultiGroup() )
        {
            // multiple group, get from list
            Error = gm.GetOffsetFromList(
                pEntry->dwGroupOffset, GroupId, &dwGEOffset);
            if( Error != ERROR_SUCCESS )
                goto exit;
        }
        else
        {
            dwGEOffset = pEntry->dwGroupOffset;
        }

        // get group entry from the offset
        pGroupEntry = _UrlObjStorage->ValidateGroupOffset(dwGEOffset, pItem);

        if( !pGroupEntry )
        {
            Error = ERROR_FILE_NOT_FOUND;
            goto exit;
        }

        // Remove the group from list
        if( pItem->HasMultiGroup() )
        {
            // remove it from list
            DWORD dwNewHeaderOffset = pEntry->dwGroupOffset;

            Error = gm.RemoveFromGroupList(
                pEntry->dwGroupOffset, dwGEOffset, &dwNewHeaderOffset );

            if( Error != ERROR_SUCCESS )
            {
                goto exit;
            }

            //
            // header may have been changed (if head is the one we want)
            // newHeaderOffset = 0 means last group has been removed
            //
            // NOTE: even we may have one item left on the list, we
            //       are not changing the multiGroup flag on this
            //       entry, so the dwGroupOffset are still points to
            //       the list
            pEntry->dwGroupOffset = dwNewHeaderOffset;

        }
        else
        {
            // set offset to 0 (single group)
            pEntry->dwGroupOffset = 0;

        }

        // if dwExamptDelta is set, we should leave the stick bit
        if(!pEntry->dwExemptDelta)
        {
            //
            // if the unassociated group is sticky, we are remove
            // the sticky bit of this url
            //
            // For multiple groups, we will have to make sure all
            // the remaining groups are non-sticky
            //

            if( IsStickyGroup(pGroupEntry->gid ) &&
                ( !pItem->HasMultiGroup()  ||
                  gm.NoMoreStickyEntryOnList(pEntry->dwGroupOffset) )
            )
            {
                Error = UpdateStickness(
                    pEntry,
                    URLCACHE_OP_UNSET_STICKY,
                    (DWORD)( ((LPBYTE) pItem) - *_UrlObjStorage->GetHeapStart())
                );
                if( Error != ERROR_SUCCESS )
                    goto exit;
            }
        }

        // update the usage
        if( pItem->HasMultiGroup() )
        {
            // dwGroupOffset now offset to head of group list
            gm.AdjustUsageOnList(
                    pEntry->dwGroupOffset, -RealFileSize(pEntry->dwFileSize) );
        }
        else
        {
            AdjustGroupUsage(pGroupEntry, -RealFileSize(pEntry->dwFileSize));
        }

        //
        // update hash bit indicating no group associate with this url
        // we won't clear the multiple group flag even if there is single
        // group left on the group list.
        //
        if( !pEntry->dwGroupOffset )
        {
            pItem->ClearGroup();
            pItem->ClearMultGroup();
        }

    }
    else
    {

        // Find Group via gid
        Error = gm.FindEntry(GroupId, &pGroupEntry, FALSE);
        if( Error != ERROR_SUCCESS )
        {
            goto exit;
        }

        if( pItem->HasGroup() )
        {
            // multiple group

            LPBYTE  lpBase;
            DWORD dwGroupEntryOffset = 0;

            lpBase = *_UrlObjStorage->GetHeapStart();
            dwGroupEntryOffset = PtrDiff32(pGroupEntry, lpBase);

            DWORD dwListEntryOffset = 0;
            DWORD dwEntryOffset = 0;
            DWORD dwItemOffset = 0;
            DWORD dwOldGroupEntryOffset = 0;

            if( !pItem->HasMultiGroup() )
            {
                //
                // switch from a single group to multiple
                // group, need to
                //  1) create a new group list
                //  2) add the existing single group to the newly created list
                //


//////////////////////////////////////////////////////////////////
// BEGIN WARNING: The file might be grown and remapped, so all  //
// pointers into the file before this point may be invalidated. //
//////////////////////////////////////////////////////////////////

                // save offset
                dwEntryOffset = PtrDiff32(pEntry, lpBase);
                dwItemOffset = PtrDiff32(pItem, lpBase);
                if( pOldGroupEntry )
                {
                    dwOldGroupEntryOffset = PtrDiff32(pOldGroupEntry, lpBase);
                }

                //
                // get a new List (memfile may grown)
                //
                Error = gm.CreateNewGroupList(&dwListEntryOffset);
                if( Error != ERROR_SUCCESS )
                {
                    goto exit;
                }

                // restore pointers based on (possible) new base addr
                lpBase = *_UrlObjStorage->GetHeapStart();

                pEntry =  (URL_FILEMAP_ENTRY*)(lpBase + dwEntryOffset);
                pGroupEntry = (GROUP_ENTRY*)(lpBase + dwGroupEntryOffset);
                pItem = (HASH_ITEM*) (lpBase + dwItemOffset);
                if( pOldGroupEntry )
                {
                    pOldGroupEntry
                        = (GROUP_ENTRY*) (lpBase + dwOldGroupEntryOffset);
                }

//////////////////////////////////////////////////////////////////
// END WARNING: The file might have grown and remapped, so all  //
// pointers into the file after this point must be recalculated //
// from offsets.                                                //
//////////////////////////////////////////////////////////////////

                //
                // add the original group (whose offset is indicated
                // with dwGroupOffset of the url entry)
                // to the newly created list
                //
//////////////////////////////////////////////////////////////////
// BEGIN WARNING: The file might be grown and remapped, so all  //
// pointers into the file before this point may be invalidated. //
//////////////////////////////////////////////////////////////////

                // save offset
                lpBase = *_UrlObjStorage->GetHeapStart();
                dwEntryOffset = PtrDiff32(pEntry, lpBase);
                dwItemOffset = PtrDiff32(pItem, lpBase);
                dwGroupEntryOffset = PtrDiff32(pGroupEntry, lpBase);
                if( pOldGroupEntry )
                {
                    dwOldGroupEntryOffset = PtrDiff32(pOldGroupEntry, lpBase);
                }

                Error = gm.AddToGroupList(
                        dwListEntryOffset, pEntry->dwGroupOffset);

                // restore offset
                lpBase = *_UrlObjStorage->GetHeapStart();
                pEntry =  (URL_FILEMAP_ENTRY*)(lpBase + dwEntryOffset);
                pGroupEntry = (GROUP_ENTRY*)(lpBase + dwGroupEntryOffset);
                pItem = (HASH_ITEM*) (lpBase + dwItemOffset);
                if( pOldGroupEntry )
                {
                    pOldGroupEntry
                        = (GROUP_ENTRY*) (lpBase + dwOldGroupEntryOffset);
                }


                
//////////////////////////////////////////////////////////////////
// END WARNING: The file might have grown and remapped, so all  //
// pointers into the file after this point must be recalculated //
// from offsets.                                                //
//////////////////////////////////////////////////////////////////
                if( Error != ERROR_SUCCESS )
                {
                    goto exit;
                }

                //
                // the dwGroupOffset of the url entry now
                // points the the head of a group list
                //
                pEntry->dwGroupOffset = dwListEntryOffset;
                pItem->MarkMultGroup();

            }

            //
            // Multiple group, just add the new group to the list
            //
//////////////////////////////////////////////////////////////////
// BEGIN WARNING: The file might be grown and remapped, so all  //
// pointers into the file before this point may be invalidated. //
//////////////////////////////////////////////////////////////////
            // save offset
            lpBase = *_UrlObjStorage->GetHeapStart();
            dwEntryOffset = PtrDiff32(pEntry, lpBase);
            dwItemOffset = PtrDiff32(pItem, lpBase);
            dwGroupEntryOffset = PtrDiff32(pGroupEntry, lpBase);

            Error = gm.AddToGroupList(
                pEntry->dwGroupOffset, dwGroupEntryOffset);


            if( Error != ERROR_SUCCESS )
            {
                goto exit;
            }

            // remap since multiple group may cause memfile grow
            lpBase = *_UrlObjStorage->GetHeapStart();
            pEntry =  (URL_FILEMAP_ENTRY*)(lpBase + dwEntryOffset);
            pGroupEntry = (GROUP_ENTRY*)(lpBase + dwGroupEntryOffset);
            pItem = (HASH_ITEM*) (lpBase + dwItemOffset);

//////////////////////////////////////////////////////////////////
// END WARNING: The file might have grown and remapped, so all  //
// pointers into the file after this point must be recalculated //
// from offsets.                                                //
//////////////////////////////////////////////////////////////////
        }
        else
        {
            // single group, dwGroupOffset points the real group
            pEntry->dwGroupOffset = PtrDiff32(pGroupEntry, *_UrlObjStorage->GetHeapStart());
        }



        // update hash bit indicating group associate with this url
        pItem->MarkGroup();

        // if group is sticky, mark the entry to sticky as well
        if( IsStickyGroup(pGroupEntry->gid) )
        {
            Error = UpdateStickness(
                pEntry,
                URLCACHE_OP_SET_STICKY,
                (DWORD)( ((LPBYTE) pItem) - *_UrlObjStorage->GetHeapStart())
            );
            if( Error != ERROR_SUCCESS )
                goto exit;
        }

        // update the usage
        if( pItem->HasMultiGroup() )
        {
            // dwGroupOffset now offset to head of group list
            gm.AdjustUsageOnList(
                    pEntry->dwGroupOffset, RealFileSize(pEntry->dwFileSize) );
        }
        else
        {
            AdjustGroupUsage(pGroupEntry, RealFileSize(pEntry->dwFileSize) );
        }

        //
        // track the usage and quota
        // NOTE: we still allow this url to be added to the group
        //       even if usage > quota, DISK_FULL error will be
        //       returned, so the client is responsible to take
        //       futher action
        //
        if( pGroupEntry->llDiskUsage > (pGroupEntry->dwDiskQuota * 1024) )
        {
            Error = ERROR_NOT_ENOUGH_QUOTA;
            goto  exit;
        }
    }

    Error = ERROR_SUCCESS;

    NotifyCacheChange(CACHE_NOTIFY_UPDATE_URL,
            (DWORD)( ((LPBYTE) pItem) - *_UrlObjStorage->GetHeapStart())
        );

exit:
    if (fMustUnlock) UnlockContainer();
    return Error;
}

/*++
Gets group ID and exemption time for a particular URL.
--*/
DWORD URL_CONTAINER::GetUrlInGroup
    (LPCSTR lpszUrl, GROUPID* pGroupId, LPDWORD pdwExemptDelta)
{
    DWORD dwError;
    BOOL fMustUnlock;
    URL_FILEMAP_ENTRY* pEntry;
    GROUP_ENTRY*       pGroupEntry = NULL;
    HASH_ITEM*          pItem = NULL;

    if (!LockContainer(&fMustUnlock))
    {
        dwError = GetLastError();
        goto exit;
    }


    // Look up the entry.
    if (HashFindItem (lpszUrl, 0, &pItem))
    {
        pEntry = HashGetEntry (pItem);
    }
    else
    {
        pEntry = NULL;
    }

    if (!pEntry)
        dwError = ERROR_FILE_NOT_FOUND;
    else
    {
        if( pEntry->dwGroupOffset )
        {
            pGroupEntry = _UrlObjStorage->ValidateGroupOffset(
                pEntry->dwGroupOffset, pItem);
            if( pGroupEntry )
            {

                INET_ASSERT(pGroupEntry->gid);
                *((LONGLONG*) pGroupId) = pGroupEntry->gid;
            }
            else
            {
                dwError = ERROR_FILE_NOT_FOUND;
            }
        }
        else
        {
            *((LONGLONG*) pGroupId) = 0;
        }

        *pdwExemptDelta = pEntry->dwExemptDelta;
        dwError = ERROR_SUCCESS;
    }

exit:
    if (fMustUnlock) UnlockContainer();
    return dwError;
}


DWORD URL_CONTAINER::CreateUniqueFile(LPCSTR UrlName, DWORD ExpectedSize,
                                   LPCSTR lpszFileExtension, LPTSTR FileName,
                                   HANDLE *phfHandle, BOOL fCreatePerUser)
/*++

Routine Description:

    This function creates a temperary file in the cache storage. This call
    is called by the application when it receives a url file from a
    server. When the receive is completed it caches this file to url cache
    management, which will move the file to permanent cache file. The idea
    is the cache file is written only once directly into the cache store.

Arguments:

    UrlName : name of the url file (unused now).

    ExpectedSize : expected size of the incoming file. If it is unknown
        this value should be set to 0.

    lpszFileExtension: extension for the filename created

    FileName : pointer to a buffer that receives the full path name of the
        the temp file.

    phfHandle : pointer to a handle that receives the handle of the file
        being create; pass null if we don't care (the file will be closed).

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    BOOL fMustUnlock;

    // BUGBUG - adding LockContainer here.
    if (!LockContainer(&fMustUnlock))
    {
        Error = (GetLastError());
        goto exit;
    }

    Error = _FileManager->CreateUniqueFile((LPSTR) UrlName, (DWORD) ExpectedSize, (LPSTR) FileName,
        (LPSTR) lpszFileExtension, (HANDLE*) phfHandle, (BOOL)fCreatePerUser);

exit:
    if (fMustUnlock) UnlockContainer();
    return( Error );
}



DWORD URL_CONTAINER::FindNextEntry
    (LPDWORD lpdwEnum, LPCACHE_ENTRY_INFO *ppCEI, LPDWORD lpdwCEI, DWORD dwFilter, GROUPID GroupId, DWORD dwFlags, DWORD dwRetrievalFlags)
{

    DWORD Error;
    URL_FILEMAP_ENTRY* pEntry;
    DWORD dwEnumSave;
    BOOL fMustUnlock;
    DWORD dwCopyFlags;

    if (!LockContainer(&fMustUnlock))
    {
        Error = GetLastError();
        goto Cleanup;
    }

    BOOL fCheckUser;
    fCheckUser = IsContentContainer() && !(dwFilter & OTHER_USER_CACHE_ENTRY);
    dwCopyFlags = 0;
    if (dwFlags & FIND_FLAGS_RETRIEVE_ONLY_STRUCT_INFO)
    {
        dwCopyFlags = RETRIEVE_ONLY_STRUCT_INFO;
    }
    else if (dwFlags & FIND_FLAGS_RETRIEVE_ONLY_FIXED_AND_FILENAME)
    {
        dwCopyFlags = RETRIEVE_ONLY_FILENAME;
    }
    dwCopyFlags |= dwRetrievalFlags;
    while (1)
    {
        dwEnumSave = *lpdwEnum;
        pEntry = (URL_FILEMAP_ENTRY*) _UrlObjStorage->FindNextEntry(lpdwEnum, dwFilter, GroupId);

        if(!pEntry)
        {
            Error = ERROR_NO_MORE_ITEMS;
            goto Cleanup;
        }

        // For content container, skip items marked for another user.
        if (fCheckUser)
        {
            LPSTR pszHeaders = ((LPSTR) pEntry) + pEntry->HeaderInfoOffset;
            if (!IsCorrectUser(pszHeaders, pEntry->HeaderInfoSize))
                continue;
        }

        // Copy the data
        Error = CopyUrlInfoGuard(pEntry, ppCEI, lpdwCEI, dwCopyFlags);
        switch (Error)
        {
            case ERROR_INSUFFICIENT_BUFFER:
                // Restore current enum position.
                *lpdwEnum = dwEnumSave;
                goto Cleanup;

            case ERROR_FILE_NOT_FOUND:
                continue;

            default:
                INET_ASSERT (FALSE);
            // intentional fall through
            case ERROR_SUCCESS:
                goto Cleanup;
        }
    } // end while(1)

Cleanup:
    if (fMustUnlock) UnlockContainer();
    return Error;
}



/*------------------------------------------------------------------------------
    CopyUrlInfo

Routine Description:

    Copy URL info data from an URL_FILEMAP_ENTRY in the memory mapped file
    to CACHE_ENTRY_INFO output buffer. If the buffer given is sufficient,
    it returns ERROR_INSUFFICIENT_BUFFER, and pcbInfo will contain
    buffer size required.

Arguments:

    pEntry     : pointer to the source of the URL info.

    ppInfo   : ptr to ptr to an entry info buffer, where the url entry info
               is returned.

    pcbInfo : pointer to a DWORD location containing the size of the
               above buffer, on return it has the size of the buffer consumed or
               size of the buffer required for successful retrieval.

Return Value:

    Windows Error Code.

------------------------------------------------------------------------------*/
DWORD URL_CONTAINER::CopyUrlInfo(LPURL_FILEMAP_ENTRY   pEntry,
                                 LPCACHE_ENTRY_INFO*   ppInfo,
                                 LPDWORD               pcbInfo,
                                 DWORD                 dwFlags)
{
    DWORD cbRequired;
    DWORD dwError = ERROR_SUCCESS;
    DWORD cbSourceUrlName;
    DWORD cbLocalFileName;
    DWORD cbHeaderInfo;
    DWORD cbFileExt;

    INET_ASSERT(!((dwFlags & RETRIEVE_WITH_ALLOCATION) &&
                  (dwFlags & RETRIEVE_ONLY_FILENAME
                    || dwFlags & RETRIEVE_ONLY_STRUCT_INFO)));
    // Check signature
    if (pEntry->dwSig != SIG_URL)
    {
        INET_ASSERT(FALSE);
        dwError = ERROR_FILE_NOT_FOUND;
        goto exit;
    }

    // Verify url string exists.
    if (!pEntry->UrlNameOffset)
    {
        INET_ASSERT(FALSE);
        dwError = ERROR_FILE_NOT_FOUND;
        goto exit;
    }

    // Hate using goto's but, don't want to clutter anymore than I have to.
    // We assume that anything functions that pass these flags will have allocated
    // enough memory before hand.
    if ((dwFlags & RETRIEVE_ONLY_FILENAME) || (dwFlags & RETRIEVE_ONLY_STRUCT_INFO))
    {
        if (ppInfo && *ppInfo)
        {
            memset(*ppInfo, 0, sizeof(INTERNET_CACHE_ENTRY_INFO));
        }
        goto ShortCircuit;
    }

    // -----------------  Calculate embedded data sizes ------------------------
    // All byte counts are sizes.

    // SourceUrlName length;
    cbSourceUrlName = strlen((LPSTR) OFFSET_TO_POINTER(pEntry, pEntry->UrlNameOffset)) + 1;

    // LocalFileName length.
    if(pEntry->InternalFileNameOffset)
    {
        cbLocalFileName =
            _FileManager->GetDirLen(pEntry->DirIndex)
            + strlen((LPSTR) OFFSET_TO_POINTER(pEntry, pEntry->InternalFileNameOffset))
            + 1;
    }
    else
        cbLocalFileName = 0;

    // HeaderInfo length.
    cbHeaderInfo = (pEntry->HeaderInfoOffset) ? pEntry->HeaderInfoSize + 1 : 0;

    // File extension length.
    if (pEntry->FileExtensionOffset)
    {
        cbFileExt =
              strlen((LPSTR) OFFSET_TO_POINTER(pEntry, pEntry->FileExtensionOffset)) + 1;
    }
    else
        cbFileExt = 0;

    // Alignment - these quantities are already aligned in
    // URL_FILEMAP_ENTRY and should be reflected in its size.
    cbSourceUrlName  = ROUNDUPDWORD(cbSourceUrlName);
    cbLocalFileName  = ROUNDUPDWORD(cbLocalFileName);
    cbHeaderInfo     = ROUNDUPDWORD(cbHeaderInfo);
    cbFileExt        = ROUNDUPDWORD(cbFileExt);

    cbRequired = *pcbInfo;
    *pcbInfo = sizeof(CACHE_ENTRY_INFO)
                   + cbSourceUrlName
                   + cbLocalFileName
                   + cbHeaderInfo
                   + cbFileExt;

    if (dwFlags & RETRIEVE_WITH_ALLOCATION)
    {
        // If we are allocating entry info, use the ex version.
        *pcbInfo += sizeof(CACHE_ENTRY_INFOEX) - sizeof(CACHE_ENTRY_INFO);
        *ppInfo = (LPCACHE_ENTRY_INFO)ALLOCATE_FIXED_MEMORY(*pcbInfo);
        if (!*ppInfo)
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }
    }
    else
    {
        // Second check for required buffer size.
        if (cbRequired < *pcbInfo )
        {
            dwError = ERROR_INSUFFICIENT_BUFFER;
            goto exit;
        }
    }

    // ----------------------  Copy embedded data --------------------------------

    // A Typical CACHE_ENTRY_INFO will look like
    //
    // [CACHE_ENTRY_INFO][UrlName][FileName][Headers][FileExtension]
    //
    //                   ^        ^         ^        ^
    //                   |        |         |        |
    //                   |        |         |        lpszFileExtension
    //                   |        |         |
    //                   |        |         lpHeaderInfo
    //                   |        |
    //                   |        lpszLocalFileName
    //                   |
    //                   lpszSourceUrlName
    //

    // Pointer walks through CACHE_ENTRY_INFO appended data.
    LPBYTE pCur;
    pCur = (LPBYTE) *ppInfo + sizeof(CACHE_ENTRY_INFO);
    if (dwFlags & RETRIEVE_WITH_ALLOCATION)
    {
        // If we are creating the -ex version, skip over those fields.
        pCur += sizeof(CACHE_ENTRY_INFOEX) - sizeof(CACHE_ENTRY_INFO);
    }

    // UrlName.
    memcpy(pCur, OFFSET_TO_POINTER(pEntry, pEntry->UrlNameOffset), cbSourceUrlName);
    (*ppInfo)->lpszSourceUrlName = (LPSTR) pCur;
    pCur += cbSourceUrlName;

    // FileName
    if (cbLocalFileName)
    {
        DWORD cb;
        if (!_FileManager->GetFilePathFromEntry(pEntry, (LPSTR) pCur, &(cb = MAX_PATH)))
        {
            dwError = ERROR_FILE_NOT_FOUND;
            goto exit;
        }
        
        (*ppInfo)->lpszLocalFileName = (LPTSTR) pCur;
        pCur += cbLocalFileName;
    }
    else
        (*ppInfo)->lpszLocalFileName = NULL;


    // HeaderInfo
    if (cbHeaderInfo)
    {
        memcpy (pCur, OFFSET_TO_POINTER(pEntry, pEntry->HeaderInfoOffset),
            pEntry->HeaderInfoSize);
        pCur[pEntry->HeaderInfoSize] = 0;
        (*ppInfo)->lpHeaderInfo = (LPTSTR)pCur;
        pCur += cbHeaderInfo;
    }
    else
        (*ppInfo)->lpHeaderInfo = NULL;


    // FileExt
    if (cbFileExt)
    {
        memcpy(pCur, OFFSET_TO_POINTER(pEntry, pEntry->FileExtensionOffset), cbFileExt);
        (*ppInfo)->lpszFileExtension = (LPTSTR) pCur;
        pCur += cbFileExt;
    }
    else
        (*ppInfo)->lpszFileExtension = NULL;


    // ------------  Set remaining CACHE_ENTRY_INFO members -------------
ShortCircuit:
    // Struct size, entry type, use count and hit rate.
    (*ppInfo)->dwStructSize = URL_CACHE_VERSION_NUM;
    (*ppInfo)->CacheEntryType = pEntry->CacheEntryType & ~IDENTITY_CACHE_ENTRY;
    if (pEntry->bSyncState == SYNCSTATE_STATIC)
        (*ppInfo)->CacheEntryType |= STATIC_CACHE_ENTRY;
    (*ppInfo)->dwUseCount     = pEntry->NumReferences;
    (*ppInfo)->dwHitRate      = pEntry->NumAccessed;

    // File size.
    (*ppInfo)->dwSizeLow      = pEntry->dwFileSize;
    (*ppInfo)->dwSizeHigh     = 0;

    // Last modified, expire, last access and last sync times, maybe download time.
    (*ppInfo)->LastModifiedTime   = *LONGLONG_TO_FILETIME(&pEntry->LastModifiedTime);

    // expire time may be 0

    DosTime2FileTime(pEntry->dostExpireTime, &((*ppInfo)->ExpireTime));

    (*ppInfo)->LastAccessTime     = *LONGLONG_TO_FILETIME(&pEntry->LastAccessedTime);
    if (dwFlags & RETRIEVE_WITH_ALLOCATION)
    {
        CACHE_ENTRY_INFOEX* pCEI = (CACHE_ENTRY_INFOEX*) *ppInfo;
        DosDateTimeToFileTime(*(LPWORD)&(pEntry->dostFileCreationTime),
                             *((LPWORD)&(pEntry->dostFileCreationTime)+1),
                             &pCEI->ftDownload);

        DosTime2FileTime(pEntry->dostPostCheckTime, &pCEI->ftPostCheck);

    }

    DosDateTimeToFileTime(*(LPWORD)&(pEntry->dostLastSyncTime),
                          *((LPWORD)&(pEntry->dostLastSyncTime)+1),
                          &((*ppInfo)->LastSyncTime));


    // Header info size and exempt delta.
    (*ppInfo)->dwHeaderInfoSize   = pEntry->HeaderInfoSize;
    (*ppInfo)->dwExemptDelta      = pEntry->dwExemptDelta;

    // If we want only struct info and filename, we'll assume that we've preallocated
    // enough memory.
    if (dwFlags & RETRIEVE_ONLY_FILENAME)
    {
        DWORD cb;
        if (!_FileManager->GetFilePathFromEntry(pEntry, (LPSTR) (*ppInfo) + sizeof(INTERNET_CACHE_ENTRY_INFO),
            &(cb = MAX_PATH)))
        {
            dwError = ERROR_FILE_NOT_FOUND;
            goto exit;
        }
        (*ppInfo)->lpszLocalFileName = (LPTSTR) (*ppInfo) + sizeof(INTERNET_CACHE_ENTRY_INFO);
    }

exit:
    return dwError;
}


// CopyUrlInfoGuard puts an exception handler around CopyUrlInfo
// for those case when we don't get a chance to flush the memory-mapped
// file, thus corrupting the cache.

// We put the try in this function, rather than in CopyUrlInfo, to
// avoid affecting the perf characteristics.
DWORD URL_CONTAINER::CopyUrlInfoGuard(LPURL_FILEMAP_ENTRY   pEntry,
                                 LPCACHE_ENTRY_INFO*   ppInfo,
                                 LPDWORD               pcbInfo,
                                 DWORD                 dwFlags)
{
    DWORD dwError;
    
    __try
    {
        dwError = CopyUrlInfo(pEntry, ppInfo, pcbInfo, dwFlags);
    } // __try
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        INET_ASSERT(FALSE);
        dwError = ERROR_FILE_NOT_FOUND;
    }
    ENDEXCEPT
    return dwError;
}


void URL_CONTAINER::UnlockItem (URL_FILEMAP_ENTRY* pEntry, HASH_ITEM* pItem)
{
    // Possibly a bogus assert due to using lazy-write mappings?
    //INET_ASSERT (pEntry->NumReferences);


    if (pEntry->NumReferences)
    {
        if (--pEntry->NumReferences)
        {
            if( !pItem->IsLocked() )
            {
                // corrupted index file, we have to believe the hash table
                // to fixup the cache entry
                INET_ASSERT (FALSE);
                pEntry->NumReferences = 0;
            }
        }
        else
        {
            pItem->ClearLocked();

            // If the item is marked for pending delete, do it now.
            if (pEntry->CacheEntryType & PENDING_DELETE_CACHE_ENTRY)
                DeleteUrlEntry (pEntry, pItem, SIG_DELETE);
        }
    }
}


void URL_CONTAINER::UnlockAllItems (void)
{
    DWORD dwEnum = *(_UrlObjStorage->GetPtrToHashTableOffset());

    // Enumerate hash table items.
    while (dwEnum)
    {
        HASH_ITEM *pItem = HashGetNextItem
            (_UrlObjStorage, *(_UrlObjStorage->GetHeapStart()), &dwEnum, 0);

        if (pItem && (pItem->IsLocked()))
        {
            // Validate and unlock the entry.
            URL_FILEMAP_ENTRY *pEntry =
                _UrlObjStorage->ValidateUrlOffset (pItem->dwOffset);
            if (!pEntry)
                pItem->MarkFree(); // invalid item
            else
            {
                // Clear the lockcount.
                pEntry->NumReferences = 1;
                UnlockItem (pEntry, pItem);
            }
        }
    }
}


DWORD URL_CONTAINER::RegisterCacheNotify( HWND      hWnd,
                                          UINT      uMsg,
                                          GROUPID   gid,
                                          DWORD     dwFilter)
{
    BOOL fUnlock;
    LockContainer(&fUnlock);

    _UrlObjStorage->SetHeaderData(
            CACHE_HEADER_DATA_NOTIFICATION_HWND,    GuardedCast((DWORD_PTR)hWnd));
    _UrlObjStorage->SetHeaderData(
            CACHE_HEADER_DATA_NOTIFICATION_MESG,    (DWORD)uMsg);
    _UrlObjStorage->SetHeaderData(
            CACHE_HEADER_DATA_NOTIFICATION_FILTER,  (DWORD)dwFilter);

    if (fUnlock) UnlockContainer();

    return ERROR_SUCCESS;
}


// update stickness will do:
//      1. flip the bit
//      2. update the exempt usage
//      3. send notification
DWORD URL_CONTAINER::UpdateStickness( URL_FILEMAP_ENTRY* pEntry,
                                      DWORD              dwOp,
                                      DWORD              dwItemOffset)
{
    DWORD dwError = ERROR_SUCCESS;

    if( dwOp == URLCACHE_OP_SET_STICKY )
    {
        if( !( pEntry->CacheEntryType & STICKY_CACHE_ENTRY ) )
        {
            // Ensure that exempt items do not crowd the cache.
            LONGLONG FileUsage = RealFileSize(pEntry->dwFileSize);
            LONGLONG ExemptUsage = _UrlObjStorage->GetExemptUsage();
            LONGLONG CacheLimit  = _UrlObjStorage->GetCacheLimit();
            LONGLONG MaxExempt = (CacheLimit * MAX_EXEMPT_PERCENTAGE) / 100;
            if (ExemptUsage + FileUsage > MaxExempt)
                return ERROR_DISK_FULL;

            pEntry->CacheEntryType |= STICKY_CACHE_ENTRY;
            _UrlObjStorage->AdjustExemptUsage(RealFileSize(pEntry->dwFileSize));
            NotifyCacheChange(CACHE_NOTIFY_URL_SET_STICKY, dwItemOffset);
        }
    }

    else
    if( dwOp == URLCACHE_OP_UNSET_STICKY )
    {
        if( pEntry->CacheEntryType & STICKY_CACHE_ENTRY )
        {
            pEntry->CacheEntryType &= ~STICKY_CACHE_ENTRY;
            _UrlObjStorage->AdjustExemptUsage(-RealFileSize(pEntry->dwFileSize));
            NotifyCacheChange(CACHE_NOTIFY_URL_UNSET_STICKY, dwItemOffset);
        }
    }
    else
    {
        dwError = ERROR_INVALID_PARAMETER;
    }

    return dwError;
}

VOID FileTime2DosTime(FILETIME ft, DWORD* pdt)
{
    INET_ASSERT(pdt);

    *pdt = 0;
    if( FT2LL(ft) != LONGLONG_ZERO )
    {
        if( FT2LL(ft) == MAX_FILETIME)
        {
            *pdt = MAX_DOSTIME;
        }
        else
        {
            FileTimeToDosDateTime(
                &ft,
                ((LPWORD)(pdt)    ),
                ((LPWORD)(pdt) + 1)
            );
        }
    }
}

VOID DosTime2FileTime(DWORD dt, FILETIME* pft)
{
    INET_ASSERT(pft);

    LONGLONG llZero = LONGLONG_ZERO;
    LONGLONG llMax = MAX_FILETIME;
    if( dt )
    {
        if( dt == MAX_DOSTIME )
        {
            *pft = *LONGLONG_TO_FILETIME(&llMax);
        }
        else
        {
            DosDateTimeToFileTime(
                *((LPWORD)&(dt)    ),
                *((LPWORD)&(dt) + 1),
                pft
            );
        }
    }
    else
    {
        *pft = *LONGLONG_TO_FILETIME(&llZero);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\urlcache\debug.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    debug.h

Abstract:

    Contains data definitions for debug code.

Author:

    Madan Appiah (madana) 15-Nov-1994

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _DEBUG_
#define _DEBUG_

#ifdef __cplusplus
extern "C" {
#endif

// Event tracking macros...
#define EVENTWRAP(API, h) {\
    BOOL ret = API(h);\
    if (ret) \
        TcpsvcsDbgPrint((DEBUG_APIS, #API "(" #h "=%d)\n", h)); \
    else { \
        TcpsvcsDbgPrint((DEBUG_APIS, #API "(" #h "=%d) failed err=%d\n",\
            h, GetLastError())); \
        TcpsvcsDbgAssert( FALSE ); \
    } \
}\

#define   SETEVENT(h)  EVENTWRAP(SetEvent,    h)
#define RESETEVENT(h)  EVENTWRAP(ResetEvent,  h)
#define CLOSEHANDLE(h) EVENTWRAP(CloseHandle, h)

//
// LOW WORD bit mask (0x0000FFFF) for low frequency debug output.
//
#define DEBUG_ERRORS            0x00000001  // hard errors.
#define DEBUG_REGISTRY          0x00000002  // debug registry calls
#define DEBUG_MISC              0x00000004  // misc info.
#define DEBUG_SCAVENGER         0x00000008  // scavenger debug info.

#define DEBUG_SORT              0x00000010  // debug B-TREE functions
#define DEBUG_CONTAINER         0x00000020  // debug container
#define DEBUG_APIS              0x00000040  // debug tcpsvcs apis
#define DEBUG_FILE_VALIDATE     0x00000080 // validate file map file
#define DEBUG_SVCLOC_MESSAGE    0x00000100  // discovery messages



//
// HIGH WORD bit mask (0x0000FFFF) for high frequency debug output.
// ie more verbose.
//

#define DEBUG_TIMESTAMP         0x00010000  // print time stamps
#define DEBUG_MEM_ALLOC         0x00020000 // memory alloc
#define DEBUG_STARTUP_BRK       0x40000000  // breakin debugger during startup.

#define ENTER_CACHE_API(paramlist) \
{ DEBUG_ONLY(LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();) \
  DEBUG_ENTER_API(paramlist); \
}

#define LEAVE_CACHE_API() \
Cleanup:                         \
    if (Error != ERROR_SUCCESS)  \
    {                            \
        SetLastError( Error );   \
        DEBUG_ERROR(INET, Error); \
    }                            \
    DEBUG_LEAVE_API (Error==ERROR_SUCCESS);      \
    return (Error==ERROR_SUCCESS);                 \

#if DBG

///#define DEBUG_PRINT OutputDebugString

//
// debug functions.
//

#define TcpsvcsDbgPrint(_x_) TcpsvcsDbgPrintRoutine _x_

VOID
TcpsvcsDbgPrintRoutine(
    IN DWORD DebugFlag,
    IN LPSTR Format,
    ...
    );

#define TcpsvcsDbgAssert(Predicate) INET_ASSERT(Predicate)

#else

///#define IF_DEBUG(flag) if (FALSE)

#define TcpsvcsDbgPrint(_x_)
#define TcpsvcsDbgAssert(_x_)

#endif // DBG

#if DBG
#define INLINE
#else
#define INLINE      inline
#endif

#ifdef __cplusplus
}
#endif

#endif  // _DEBUG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\urlcache\filemgr.cxx ===
/*++
Copyright (c) 1997  Microsoft Corporation

Module Name:  filemgr.cxx

Abstract:

    Manages cache file & directory creation/deletion.

Author:
    Adriaan Canter (adriaanc) 04-02-97

Modifications:
    Ahsan Kabir (akabir) 25-Sept-97 made minor alterations.
    
--*/

#include <wininetp.h>
#include <cache.hxx>
#define WWW_DOT "www."

#define MAP_KEY_TO_PATH    0
#define MAP_PATH_TO_KEY    1


//
//==================== CFileMgr Public Functions =============================
//


/*-----------------------------------------------------------------------------
CFileMgr::CFileMgr
----------------------------------------------------------------------------*/
CFileMgr::CFileMgr(MEMMAP_FILE* mmFile, DWORD dwOptions) : _mmFile(mmFile), _dwOptions(dwOptions)
{
    INET_ASSERT(_mmFile);

    // GetFullPathNameLen includes trailing backslash.
    _cbBasePathLen = _mmFile->GetFullPathNameLen();
}


/*-----------------------------------------------------------------------------
CFileMgr::~CFileMgr
----------------------------------------------------------------------------*/
CFileMgr::~CFileMgr()
{}


/*-----------------------------------------------------------------------------
virtual CFileMgr::Init
----------------------------------------------------------------------------*/
BOOL CFileMgr::Init()
{
    return TRUE;
}


/*-----------------------------------------------------------------------------
virtual GetDirLen
Returns length of cache dir path.
----------------------------------------------------------------------------*/
DWORD CFileMgr::GetDirLen(DWORD nKey)
{
    return _cbBasePathLen;
}


/*-----------------------------------------------------------------------------
virtual CFileMgr::CreateUniqueFile
Generates cache files.
----------------------------------------------------------------------------*/
DWORD CFileMgr::CreateUniqueFile(LPCSTR szUrl, DWORD dwExpectedLength, LPTSTR szFileName,
                                LPTSTR szFileExtension, HANDLE *phfHandle, BOOL fCreatePerUser)
{
    return CreateUniqueFile((LPCSTR) szUrl, (DWORD) dwExpectedLength, (LPTSTR) _mmFile->GetFullPathName(),
        (LPTSTR) szFileName, (LPTSTR) szFileExtension, (HANDLE*) phfHandle, fCreatePerUser);
}


/*-----------------------------------------------------------------------------
virtual CFileMgr::NotifyCommit
No-op.
----------------------------------------------------------------------------*/
BOOL CFileMgr::NotifyCommit(DWORD nDirIndex)
{
    return TRUE;
}


/*-----------------------------------------------------------------------------
CFileMgr::DeleteCache
----------------------------------------------------------------------------*/
BOOL CFileMgr::DeleteCache(LPSTR szRoot)
{
    BOOL fHasCacheVu = IsValidCacheSubDir(szRoot);

    if ( fHasCacheVu)
        DisableCacheVu(szRoot);
        
    if (DeleteCachedFilesInDir(szRoot) == ERROR_SUCCESS)
    {
        SetFileAttributes(szRoot, FILE_ATTRIBUTE_DIRECTORY);
        RemoveDirectory(szRoot);
    }

    if( fHasCacheVu)
        EnableCacheVu( szRoot);
    
    return TRUE;
}

/*-----------------------------------------------------------------------------
CFileMgr::Cleanup
----------------------------------------------------------------------------*/
BOOL CFileMgr::Cleanup()
{
    return TRUE;
}

/*-----------------------------------------------------------------------------
virtual CFileMgr::GetDirIndex
----------------------------------------------------------------------------*/
BOOL CFileMgr::GetDirIndex(LPSTR szFilePath, LPDWORD pnIndex)
{
    *pnIndex = NOT_A_CACHE_SUBDIRECTORY;
    return TRUE;
}


/*-----------------------------------------------------------------------------
virtual CFileMgr::GetFilePathFromEntry

Retrieves the full path to the cache subdirectory for a cache entry.
Maps the directory index from the URL_FILEMAP_ENTRY pointer passed in
to a string containing the full path.
----------------------------------------------------------------------------*/
BOOL CFileMgr::GetFilePathFromEntry(URL_FILEMAP_ENTRY *pEntry,
                                    LPSTR szSubDirPath, LPDWORD pcb)
{
    INET_ASSERT(pEntry && szSubDirPath && pcb && *pcb);

    // "anyuser@msn.txt"
    LPTSTR szFile = (LPTSTR) OFFSET_TO_POINTER(pEntry, pEntry->InternalFileNameOffset);

    // Lengths of path and file.
    DWORD cbFile = strlen(szFile);
    DWORD cbPath = _mmFile->GetFullPathNameLen();

    // Don't overflow output buffer.
    DWORD cbSubDirPath = cbPath + cbFile;
    if (cbSubDirPath + 1 > *pcb)
    {
        INET_ASSERT(FALSE);
        return FALSE;
    }

    // "C:\Windows\Profiles\anyuser\Cookies\"
    memcpy(szSubDirPath, _mmFile->GetFullPathName(), cbPath);

    // "C:\Windows\Profiles\anyuser\Cookies\anyuser@msn.txt"
    memcpy(szSubDirPath + cbPath, szFile, cbFile + 1);

    *pcb = cbSubDirPath;

    return TRUE;
}


/*-----------------------------------------------------------------------------
virtual CFileMgr::DeleteOneCachedFile
Deletes a single cache file given the absolute path.
----------------------------------------------------------------------------*/
BOOL CFileMgr::DeleteOneCachedFile(LPSTR lpszFileName,
                                   DWORD dostEntry, DWORD nIndex)
{
    return ::DeleteOneCachedFile(lpszFileName, dostEntry);
}


/*-----------------------------------------------------------------------------
    virtual BOOL  CreateDirWithSecureName( LPSTR);

Creates a cache directory with a given name to allow existing directories
to be copied into another cache file.  Just the eight letters of the new
directory are given.
----------------------------------------------------------------------------*/
BOOL CFileMgr::CreateDirWithSecureName( LPSTR szDirName)
{
    return _mmFile->CreateDirWithSecureName( szDirName);
}


//
//================== CFileMgr Protected Functions =============================
//

/*-----------------------------------------------------------------------------
CFileMgr::GetStoreDirectory
    Returns "%windir%\web\" - ie "C:\Windows\Web\" and length. There
    is currently only ONE store directory and this is it.
----------------------------------------------------------------------------*/
BOOL CFileMgr::GetStoreDirectory(LPSTR szPath, LPDWORD pcbPath)
{
    DWORD cb;

    // Hardwired to "%windir%\Web\"
    if ((cb = GetWindowsDirectory(szPath, MAX_PATH)) && cb<=MAX_PATH)
    {
        AppendSlashIfNecessary(szPath, &cb);
        memcpy(szPath + cb, WEBDIR_STRING, sizeof(WEBDIR_STRING));
        cb += sizeof(WEBDIR_STRING) - 1;
        *pcbPath = cb;
        return TRUE;
    }
    INET_ASSERT(FALSE);
    return FALSE;
}

/*-----------------------------------------------------------------------------
CFileMgr::MapStoreKey
    Maps path to storage directory key (stored in the FILEMAP_ENTRY::DirIndex)
    or storage directory key to path (ie C:\Windows\Web\). There is currently
    only one key and it is INSTALLED_DIRECTORY_KEY. Mapping depends on dwFlag.
----------------------------------------------------------------------------*/
BOOL CFileMgr::MapStoreKey(LPSTR szPath, LPDWORD pcbPath, 
                           LPDWORD dwKey, DWORD dwFlag)
{
    DWORD cb;
    BOOL fReturn = FALSE;
    CHAR szStoreDir[MAX_PATH];

    // Must be able to get store dir in any case.
    if (GetStoreDirectory(szStoreDir, &cb))
    {
        // Mapping a path to a key requested.
        if (dwFlag == MAP_PATH_TO_KEY)
        {
            // Path matches?
            if ((*pcbPath == cb) 
                && !strnicmp(szStoreDir, szPath, cb))
            {
                // We only map one directory for now.
                *dwKey = INSTALLED_DIRECTORY_KEY;
                fReturn = TRUE;
            }
        }

        // Mapping a key to a path requested.    
        else if (dwFlag == MAP_KEY_TO_PATH)
        {
            if (*dwKey == INSTALLED_DIRECTORY_KEY)
            {
                memcpy(szPath, szStoreDir, cb+1);
                *pcbPath = cb;
                fReturn = TRUE;
            }
        }
    }
    //INET_ASSERT(fReturn);
    return fReturn;
}

/*-----------------------------------------------------------------------------
SetFileSize

Routine Description:  Set the expected file size of a newly created file

Arguments:

    hfHandle: pointer to the file handle

    dwExpectedLength: size of the file

Return Value:

----------------------------------------------------------------------------*/
VOID CFileMgr::SetFileSize(HANDLE hfHandle, DWORD dwExpectedLength) 
{
    DWORD dwFilePointer = 0;

    // Set the expected size of the file if necessary
    if (dwExpectedLength != 0) 
    {
        dwFilePointer = SetFilePointer(hfHandle, dwExpectedLength, NULL, FILE_BEGIN );
        if( dwFilePointer != INVALID_SET_FILE_POINTER )
        {
            SetEndOfFile( hfHandle );

            // reset the file pointer to the beginning of the file
            dwFilePointer = SetFilePointer(hfHandle, 0, NULL, FILE_BEGIN );
            INET_ASSERT (INVALID_SET_FILE_POINTER != dwFilePointer);
        }
    }
    return;
}
    

/*-----------------------------------------------------------------------------
CreateUniqueFile

Routine Description:

Arguments:

    UrlName : pointer to url name.

    Path : pointer to cache path.

    FileName : pointer to a buffer that receives the full path name of the
        newly created file.

    Extension : if specified the extension is used to make random file.

Return Value:

    Windows Error Code.
----------------------------------------------------------------------------*/
DWORD CFileMgr::CreateUniqueFile(LPCSTR UrlName, DWORD ExpectedLength,
								 LPTSTR Path, LPTSTR FileName, LPTSTR Extension, 
                                 HANDLE *phfHandle, BOOL fCreatePerUser)
{
    DWORD cbPath, cbName, cbFull;
    cbPath = strlen(Path);

    DWORD Error, len, lenExt=0;

    TCHAR RandomFileName[MAX_PATH];

    TCHAR FullFileName[MAX_PATH];

    HANDLE FileHandle;

    DWORD dwCollision = 0, dwTotalCollissionCount;
    char szHost[MAX_PATH], szUrl[INTERNET_MAX_PATH_LENGTH], szExtraInfo[MAX_PATH];
    URL_COMPONENTS sUrl;

    LPTSTR FileNamePtr = FileName, lpT;
    
    BOOL fUseFileName = FALSE, fPrettyName = FALSE;

    DWORD cbFileName;
    CHAR szExt[MAX_PATH];
    *szExt = '\0';  

    if (phfHandle)
        *phfHandle = INVALID_HANDLE_VALUE;
    
    // If a filename has been passed in attempt to use it.
    if (FileName[0] != '\0')
    {
        // Various checks to determine validity of name.

        // First strip any trailing whitespace.
        cbFileName = strlen(FileName);
        StripTrailingWhiteSpace(FileName, &cbFileName);

        // Check length.
        if (cbFileName < MAX_PATH)
        {            

            // '.' and '..' are illegal.
            if (memcmp(FileName, ".", sizeof("."))
                && memcmp(FileName, "..", sizeof("..")))
            {
                // slashes and backslashes are illegal.
                LPTSTR ptr = FileName;
                while (*ptr != '\0')
                {
                    if (IsDBCSLeadByte(*ptr))
                        ++ptr;
                    else
                    if (*ptr == '\\' || *ptr == '/')
                        break;
                    ptr++;
                }
                

                // Filename has no slashes in it.
                if (!*ptr)
                {
                    // Preliminary judgment. Creating
                    // this file could possibly fail,
                    // depending on further tests.
                    fUseFileName = TRUE;
                }
            }
        }
    }

    // Preliminary checks indicate valid filename.
    if (fUseFileName)
    {
        // Attempt to parse a file extension.

        CHAR* pExt = StrChr(FileName, '.');

        // Found a file extension delimiter.
        if (pExt)
        {
            // '.' but no extension (eg "foo.")
            if (*(pExt + 1) == '\0')
            {
                *pExt = '\0';
                len = cbFileName - 1;
            }

            // '.' at beginning (eg ".foo") Valid file, no extension.
            else if (pExt == FileName)
            {
                len = cbFileName;
            }

            // Common case (eg foo.bar)
            else
            {
                // Separate out the file extension w/o '.'
                lenExt = (DWORD) (cbFileName - (pExt - FileName) - 1);  // 64BIT
                memcpy(szExt, pExt+1, lenExt + 1);

                // Filename without extension.
                *pExt = '\0';
                len = (DWORD) (pExt - FileName);     // 64BIT
            }
        }     

        // No file extension found
        else
        {
            len = cbFileName;
        }
        fPrettyName = TRUE;
        goto have_file_name;
    }

    // No or bad filename passed in.
    else
    {
        // Copy over any extension passed in,
        // limiting the length as necessary.
        if (Extension)
        {
            lenExt = strlen(Extension);
            if (lenExt >= MAX_PATH)
            {
                lenExt = MAX_PATH - 1;
            }
            memcpy(szExt, Extension, lenExt);
            szExt[lenExt] = '\0';
        }
        else
        {
            *szExt = '\0';
            lenExt = 3;
        }
    }

    memset(&sUrl, 0, sizeof(sUrl));

    sUrl.dwStructSize = sizeof(sUrl);

    sUrl.lpszHostName = szHost;
    sUrl.dwHostNameLength = sizeof(szHost);

    sUrl.lpszUrlPath = szUrl;
    sUrl.dwUrlPathLength = sizeof(szUrl);


    sUrl.lpszExtraInfo = szExtraInfo;
    sUrl.dwExtraInfoLength = sizeof(szExtraInfo);

    // changed from InternetCrackUrl to WinHttpCrackUrlA
    if (WinHttpCrackUrlA(UrlName, lstrlen(UrlName), 0, &sUrl)) {
        fPrettyName = TRUE;

        if ((sUrl.dwUrlPathLength == 1) && (szUrl[0] == '/')) {

            FileNamePtr = szHost;
            len = sUrl.dwHostNameLength;

            // strip out www., this info is redundant

            if (!strnicmp(FileNamePtr, WWW_DOT, sizeof(WWW_DOT)-1)) {

                len -= (sizeof(WWW_DOT)-1);

                // copy the NULL terminator too

                memmove(FileNamePtr, FileNamePtr+sizeof(WWW_DOT)-1,len+1);

            }
        }
        else {

            FileNamePtr = szUrl;
            len = sUrl.dwUrlPathLength;

            // if there is a terminating slash let us fix it.
            // len-1 wont' break because we know the url is more than 1 char
            // Above assumption not valid.
            if (len && (FileNamePtr[len-1] == '/')) 
            {
                FileNamePtr[len-1] = 0;
                --len;
            }

            // get the tail
            if (lpT=StrRChrA(FileNamePtr, FileNamePtr+len-1, '/'))
            {
                ++lpT;

                len = len - (DWORD)PtrDifference(lpT, FileNamePtr);

                //
                // truncate the FileNamePtr if it is too long -
                //   the "fudge-factor" number is to allow room for stuff like "[%d]"
                //    in the URL -- this number doesn't have to be accurate since
                //    the worst-case scenario is us using a random (ugly) filename.
                //
                unsigned int newlen = MAX_PATH - (cbPath + lenExt + 2 + /*fudge-factor*/5);

                if ((newlen > 2) && (newlen < len))
                {
                    // For UTF-8, we don't want to chop in the middle of a %XX
                    if (lpT[newlen - 2] == '%')
                        newlen -= 2;
                    else if (lpT[newlen - 1] == '%')
                        newlen -= 1;

                    len      = newlen;
                    lpT[len] = '\0';
                }

                // copy the NULL terminator as well
                memmove(FileNamePtr, lpT, len+1);
            }
		
            // Special hack for cookies: Ensure that the username is
            // prepended on to the filename. The preceding filename
            // generation code does not generate this for cookies
            // which specify paths in addition to domains.   
            if (!memcmp(UrlName, COOKIE_PREFIX, sizeof(COOKIE_PREFIX) - 1))
            {                
                // This is a cookie url of the form Cookie:username@domain/path
                if (GetWininetUserName())
                {
                    DWORD cb = vdwCurrentUserLen;
                    if (len + cb + 1 < MAX_PATH)
                    {
                        if (memcmp(FileNamePtr, vszCurrentUser, cb) 
                            || FileNamePtr[cb] != '@'
                            || FileNamePtr[cb+1] == '\0')
                        {
                            memmove(FileNamePtr + cb + 1, FileNamePtr, len+1);
                            FileNamePtr[cb] = '@';
                            memcpy(FileNamePtr, vszCurrentUser, cb);
                            len += cb + 1;
                        }
                    }
                }
            }
        
        }

        
        if (lpT=StrRChrA(FileNamePtr, FileNamePtr+len-1, '.'))
        {
            *lpT = 0;
            len = (DWORD) PtrDifference(lpT, FileNamePtr);
        }

        // convert all invalid char (including '%') to '_'
        for(lpT = FileNamePtr; *lpT; ++lpT) 
        {
            if (IsDBCSLeadByte(*lpT))
                ++lpT;
            else if ((strchr(vszInvalidFilenameChars, *lpT))) 
                *lpT = '_';
        }

        if ((cbPath+len+lenExt+2) > MAX_PATH) {

            fPrettyName = FALSE;

        }
    }
    else {

        fPrettyName = FALSE;
    }


have_file_name:


    for(dwTotalCollissionCount = 0;
        dwTotalCollissionCount < MAX_COLLISSION_ATTEMPTS;
        dwTotalCollissionCount++) {


        //
        // make a random file name.
        //
        if (!fPrettyName) 
        {
            // If fUseFileName is TRUE, it means we've attempted to create
            // a file using the filename passed in and failed. We still want 
            // to create a cache file, but since the extension parsed from the
            // filename is also suspect, we want to create a cache filename
            // without any passed in extension, or NULL.
            if (fUseFileName)
            {
                if (Extension)
                {
                    lenExt = strlen(Extension);
                    memcpy(szExt, Extension, lenExt+1);
                }
                else
                {
                    lenExt = 0;
                    *szExt = '\0';
                }
            }

            Error = MakeRandomFileName(UrlName, RandomFileName, szExt);

        }
        else {

            DWORD digit;
            DWORD cb = strlen(FileNamePtr);
            memcpy(RandomFileName, FileNamePtr, cb+1);

            lpT = RandomFileName+len;

            // Always decorate the cache file name with [1-99]
            // We use square brackets instead of parens because
            // NT cmd shell barfs on parens.
            
            if (++dwCollision > 99)
            {
                fPrettyName = FALSE;
                continue;
            }

#ifndef UNIX
            if (fCreatePerUser && GlobalIdentity)
            {
                lpT += wsprintf (lpT, "[%d][%d]", GlobalIdentity, dwCollision);
            }
            else
            {
                lpT += wsprintf (lpT, "[%d]", dwCollision);
            }
#else
            /* Square brackets cause problems on UNIX */
            lpT += wsprintf (lpT, "(%d)", dwCollision);
#endif /* UNIX */
                
            if (*szExt)
            {
                *lpT++ = '.';
                memcpy(lpT, szExt, lenExt + 1);
            }
            
            Error = ERROR_SUCCESS;

        }

        if (Error != ERROR_SUCCESS) {
            INET_ASSERT(FALSE);
            return (Error);

        }

        cbName = strlen(RandomFileName);
        cbFull = cbPath + cbName + 1;

        if (cbFull > MAX_PATH)
        {
            INET_ASSERT(FALSE);
            return(ERROR_FILENAME_EXCED_RANGE);
        }
#ifndef UNIX
        // Hack for special DOS filenames:
        // aux.*, com[0-9].*, con.*, lpt[0-9].*, 
        // nul.* and prn.* on non-NT platforms.
        if (!IsPlatformWinNT())
        {
            DWORD cbMajor = cbName - lenExt;
            if (cbMajor == 4 || cbMajor == 5)
            {
                switch(tolower(*RandomFileName))
                {
                    // Test for aux.*
                    case 'a':
                    if (!strnicmp(RandomFileName + 1, "ux.", 3))
                    {
                        continue;
                    }
                    break;

                    // Test for com[0-9].* and con.*
                    case 'c':
                    if (tolower(RandomFileName[1]) == 'o')
                    {
                        CHAR c = tolower(RandomFileName[2]);
                        if (c == 'm')
                        {
                            if (isdigit(RandomFileName[3])
                                && RandomFileName[4] == '.')
                            {
                                continue;
                            }
                        }
                        else if (c == 'n')
                        {
                            if (RandomFileName[3] == '.')
                            {
                                continue;
                            }
                        }
                    }
                    break;
    
                    // Test for lpt[0-9].*
                    case 'l':
                    {
                        if (!strnicmp(RandomFileName + 1, "pt", 2)
                            && isdigit(RandomFileName[3])
                            && RandomFileName[4] == '.')
                        {
                            continue;
                        }
                        break;
                    }

                    // Test for nul.*
                    case 'n':
                    {
                        if (!strnicmp(RandomFileName + 1, "ul.", 3))
                        {
                            continue;
                        }
                        break;
                    }

                    // Test for prn.*
                    case 'p':
                    {
                        if (!strnicmp(RandomFileName + 1, "rn.", 3))
                        {
                            continue;
                        }
                        break;
                    }
                }
            }
        }
#endif /* !UNIX */

        // Make full path name.
        memcpy(FullFileName, Path, cbPath);
        memcpy(FullFileName + cbPath, RandomFileName, cbName + 1);

        // Check if this file exists.
        if (GetFileAttributes(FullFileName)!=0xffffffff) 
        {
            // A file or dir by this name exists.
            // This will also take care of special DOS filenames
            // on NT, which return !0xffffffff.
            continue;
        }



        FileHandle = CreateFile(
                        FullFileName,
                        GENERIC_WRITE,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        CREATE_NEW,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL );

        if( FileHandle != INVALID_HANDLE_VALUE ) 
        {
            SetFileSize(FileHandle, ExpectedLength); 

            // successfully create a new file either return handle or close it and return.
            if ( phfHandle )
                *phfHandle = FileHandle;
            else
                CloseHandle( FileHandle );

            break;
        }
        else
        {
            // Couldn't create the file. This is possibly due to the file
            // already existing or to the fact that the directory was deleted.

            // Check for the existance of the directory:
            if (GetFileAttributes(Path) == 0xffffffff)
            {
                // Directory was deleted. Create one and then
                // create the file.
                if (CreateDirectory(Path, NULL))
                {
                    // Set system attribute.
                    SetFileAttributes(Path, FILE_ATTRIBUTE_SYSTEM);

                    // Enable cachevu in this directory
                    if (!(GetOptions() & INTERNET_CACHE_CONTAINER_NODESKTOPINIT))
                        EnableCacheVu(Path);

                    FileHandle = CreateFile(
                            FullFileName,
                            GENERIC_WRITE,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL,
                            CREATE_NEW,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL );

                    // We just created the directory and the
                    // child file, so the file handle should
                    // be valid.
                    if( FileHandle != INVALID_HANDLE_VALUE ) 
                    {
                        SetFileSize(FileHandle, ExpectedLength);

                        // successfully create a new file either return handle or close it and return.
                        if ( phfHandle )
                            *phfHandle = FileHandle;
                        else
                            CloseHandle( FileHandle );

                        break;
                    }
                }
            }
        }

        Error = GetLastError();

        if( Error != ERROR_FILE_EXISTS )
        {
            if (!fPrettyName)
            {
                INET_ASSERT(FALSE);
                return( Error );
            }
            else
            {
                fPrettyName = FALSE;
                Error = ERROR_SUCCESS;
            }
        }
        else {

            // We found that the file exists
            // if it is zero size, let us just use it.
            // this in itself is an unlikely occurrence
            // but we any way try to work around the IBM virus software

            // ACHTUNG!!! this is a special hack for IBM antivirus software

            FileHandle = CreateFile(
                            FullFileName,
                            GENERIC_WRITE,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL );

            if (FileHandle != INVALID_HANDLE_VALUE) {

                // this looks usable
                if (GetFileSize(FileHandle, NULL) == 0)
                {
                    if (phfHandle)
                        *phfHandle = FileHandle;
                    else
                        CloseHandle( FileHandle );
                    break;
                }
                    
                CloseHandle( FileHandle );
                INET_ASSERT(FALSE);
            }
            return (ERROR_DISK_FULL);
        }

        //
        // try another random file.
        //
    } // end of the for loop

    if (dwTotalCollissionCount < MAX_COLLISSION_ATTEMPTS) {

        memcpy(FileName, FullFileName, cbFull);
        return( ERROR_SUCCESS );

    }
    else {
        INET_ASSERT(FALSE);
        return (ERROR_DISK_OPERATION_FAILED);

    }
}

/*-----------------------------------------------------------------------------
MakeRandomFileName

  Routine Description:

    Creates a random 8.3 file name. The format of the name will be as
    below:

        ca(0-99999).(0-999)

    Ex ca19200.340
    Ex ca19354.tmp - if an extension (tmp) is specified.

Arguments:

    UrlName : pointer to an URL string

    FileName : pointer to a string buffer where the random file name is
        returned. The buffer length must be atleast 8+3+1+1= 13 wchars.

    Extension : pointer to an extension string. if this is non-NULL, then
        the specified extension is used otherwise random extension as
        explained above is used.

Return Value:

    none.
----------------------------------------------------------------------------*/
DWORD CFileMgr::MakeRandomFileName(LPCSTR UrlName,
                                      LPTSTR FileName, LPTSTR Extension)
{
    DWORD RandNum;
    LPTSTR FileNamePtr = FileName;
    static Counter;
    DWORD i;
    DWORD cbExtension = 0;

    if (Extension)
        cbExtension = lstrlen(Extension) + 1;

    if (cbExtension > (MAX_PATH-(8+1)))
    {
        return(ERROR_FILENAME_EXCED_RANGE);
    }

    // Additional special hack for cookie urls.

    if (!memcmp(UrlName, COOKIE_PREFIX, sizeof(COOKIE_PREFIX) - 1))
    {                
        // This is a cookie url of the form Cookie:username@domain/path
        if (GetWininetUserName())
        {
          DWORD cb = vdwCurrentUserLen;
          
          if (cb + 8 + cbExtension + 1 < MAX_PATH)
          {
              memcpy(FileName, vszCurrentUser, cb);
              FileName[cb] = '@';
              FileNamePtr += (cb + 1);
          }
        }
    }

    
    // Check that the total name doesn't exceed MAX_PATH
    // Our total name is 8 chars basename + a dot + the extension + 0


    *FileNamePtr++ = L'C';
    *FileNamePtr++ = L'A';

    //
    // generate a six digits random string;
    //

    //
    // We can't use rand() alone to generate a random number because it will
    // repeat the same sequence for each new thread that comes in.  We can't
    // use the TickCount alone because it is a little too predicable.  But
    // the two combined should be nice.  Adding in Counter will take care of
    // the case of two brand-new threads coming in at the same time.
    //


    for ( i = 0; i < 6; i++) {
        UINT digit;

        RandNum = (GetTickCount() * rand()) + Counter++;

        digit = RandNum % 36; // 10 digits + 26 letters

        *FileNamePtr++  = ( digit < 10 ) ? (CHAR)('0' + digit) : (CHAR)('A' + (digit - 10));
    }

    *FileNamePtr++ = L'.';
  
    
    //
    // if an extension is specified, use it.
    //
    if( Extension != NULL )
    {
        // if a 0 extension if provided, we will create a
        // file with no extension
        memcpy(FileNamePtr, Extension, cbExtension);
        return ERROR_SUCCESS;
    }

    // Append default file extension.
    memcpy(FileNamePtr, DEFAULT_FILE_EXTENSION, sizeof(DEFAULT_FILE_EXTENSION));
    return ERROR_SUCCESS;
}






//
//===================== CSecFileMgr Public Functions ==========================
//


/*-----------------------------------------------------------------------------
CSecFileMgr::CSecFileMgr
----------------------------------------------------------------------------*/
CSecFileMgr::CSecFileMgr(MEMMAP_FILE* mmFile, DWORD dwOptions) : CFileMgr(mmFile, dwOptions)
{
    INET_ASSERT(_mmFile);

    // BUGBUG - have to guard against getting out of sync with dirs.
    if (_mmFile->GetDirCount() == 0)
        Init();
}


/*-----------------------------------------------------------------------------
CSecFileMgr::~CSecFileMgr
----------------------------------------------------------------------------*/
CSecFileMgr::~CSecFileMgr()
{}


/*-----------------------------------------------------------------------------
CSecFileMgr::Init
----------------------------------------------------------------------------*/
BOOL CSecFileMgr::Init()
{
    if (!(GetOptions() & INTERNET_CACHE_CONTAINER_NODESKTOPINIT))
        EnableCacheVu(_mmFile->GetFullPathName());

    return CreateAdditionalSubDirectories(DEFAULT_DIR_TABLE_GROW_SIZE);
}


/*-----------------------------------------------------------------------------
GetDirLen()
Returns cache dir path length.
----------------------------------------------------------------------------*/
DWORD CSecFileMgr::GetDirLen(DWORD nKey)
{
    DWORD cb = 0;

    if (nKey < DEFAULT_MAX_DIRS)
    {    
        // + 1 to account for trailing backslash.
        cb = _cbBasePathLen + DIR_NAME_SIZE + 1;
    }
    else
    {
        CHAR szStoreDir[MAX_PATH];
        GetStoreDirectory(szStoreDir, &cb);
    }
    INET_ASSERT(cb);
    return cb;
}

/*-----------------------------------------------------------------------------
CSecFileMgr::CreateUniqueFile
Creates a cache file.
----------------------------------------------------------------------------*/
DWORD CSecFileMgr::CreateUniqueFile(LPCSTR szUrl, DWORD dwExpectedLength, LPTSTR szFileName,
                                   LPTSTR szFileExtension, HANDLE *phfHandle, BOOL fCreatePerUser)
{
    DWORD nDir, nFiles;
    DWORD nDirCount = _mmFile->GetDirCount();

    INET_ASSERT(nDirCount <= DEFAULT_MAX_DIRS);

    FindMinFilesSubDir(nDir, nFiles);

    if (nFiles >= MAX_FILES_PER_CACHE_DIRECTORY
        && nDirCount < DEFAULT_MAX_DIRS)
    {
        if (CreateAdditionalSubDirectories(DEFAULT_DIR_TABLE_GROW_SIZE))
            nDir++;
    }

    // Get the cache path and subdirectory
    // from the memory mapped file
    CHAR szSubDirPath[MAX_PATH];

    DWORD cb = _mmFile->GetFullPathNameLen();
    memcpy(szSubDirPath, _mmFile->GetFullPathName(), cb);

    _mmFile->GetDirName(nDir, szSubDirPath + cb);
    memcpy(szSubDirPath + cb + DIR_NAME_SIZE, DIR_SEPARATOR_STRING, sizeof(DIR_SEPARATOR_STRING));
    return CFileMgr::CreateUniqueFile((LPCSTR) szUrl, dwExpectedLength, (LPTSTR) szSubDirPath,
                                      (LPTSTR) szFileName, (LPTSTR) szFileExtension,
                                      (HANDLE*) phfHandle, fCreatePerUser);
}


/*-----------------------------------------------------------------------------
CSecFileMgr::NotifyCommit
Tracks committed cache file counts.
----------------------------------------------------------------------------*/
BOOL CSecFileMgr::NotifyCommit(DWORD nDirIndex)
{
    INET_ASSERT(_mmFile->GetDirCount() <= DEFAULT_MAX_DIRS);

    // Regular random subdir
    if (nDirIndex < _mmFile->GetDirCount())
    {
        _mmFile->IncrementFileCount(nDirIndex);
        return TRUE;
    }
    // Not a directory.
    else if (nDirIndex == NOT_A_CACHE_SUBDIRECTORY)
    {
        //INET_ASSERT(FALSE);
        //return FALSE;
        // May be an absolute path EDITED_CACHE_ENTRY so pass
        return TRUE;
    }

    // Otherwise this had better be an installed directory.
    INET_ASSERT(nDirIndex == INSTALLED_DIRECTORY_KEY);
    return TRUE;
}


/*-----------------------------------------------------------------------------
CSecFileMgr::Cleanup
----------------------------------------------------------------------------*/
BOOL CSecFileMgr::Cleanup()
{

    CHAR szPath[MAX_PATH];

    DWORD cb = _mmFile->GetFullPathNameLen();
    memcpy(szPath, _mmFile->GetFullPathName(), cb+1);

    if (!AppendSlashIfNecessary(szPath, &cb))
        return FALSE;

    memcpy(szPath + cb, "*.*", sizeof("*.*"));

    WIN32_FIND_DATA fd;

    HANDLE handle = FindFirstFile(szPath, &fd);

    if (handle == INVALID_HANDLE_VALUE)
        return FALSE;

    do
    {
        if ((fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            && (strcmp(fd.cFileName, ".") && strcmp(fd.cFileName, "..")))
        {
            memcpy(szPath + cb, fd.cFileName, strlen(fd.cFileName) + 1);

            // Only delete directory if it is a valid subdirectory.
            if (IsValidCacheSubDir(szPath))
            {
                if (_mmFile->GetDirIndex(szPath) == NOT_A_CACHE_SUBDIRECTORY)
                {
                    DisableCacheVu(szPath);
                    if (DeleteCachedFilesInDir(szPath) == ERROR_SUCCESS)
                    {
                        SetFileAttributes(szPath, FILE_ATTRIBUTE_DIRECTORY);
                        RemoveDirectory(szPath);
                    }
                }
            }
        }
    } while (FindNextFile(handle, &fd));


    FindClose(handle);

  return TRUE;
}


/*-----------------------------------------------------------------------------
CSecFileMgr::GetDirIndex
Returns index of random cache subdirectory from an absolute file path.
----------------------------------------------------------------------------*/
BOOL CSecFileMgr::GetDirIndex(LPSTR szAbsPath, LPDWORD pnIndex)
{
    BOOL fReturn = FALSE;
    DWORD idx;

    INET_ASSERT(pnIndex);

    if (szAbsPath && *szAbsPath)
    {
        // First look in mem map file for regular dir.
        idx = _mmFile->GetDirIndex(szAbsPath);

        // If didn't find it in the mem map file,
        // check if it is the storage directory.
        if (idx == NOT_A_CACHE_SUBDIRECTORY)
        {
            // First we need to find the path to the file sans \filename.ext
            DWORD cbAbsPath = strlen(szAbsPath);
            LPSTR ptr = StrRChr(szAbsPath, szAbsPath + cbAbsPath, DIR_SEPARATOR_CHAR);
            if (ptr)
            {
                // Separate path from filename and attempt to map.
                // Note - trailing slash is included in path mapped.
                DWORD cbPath = (DWORD) (ptr - szAbsPath + 1);   // 64BIT
                if (MapStoreKey(szAbsPath, &cbPath, &idx, MAP_PATH_TO_KEY))
                {
                    *pnIndex = idx;
                    fReturn = TRUE;
                }
                // Must be an EDITED_CACHE_ENTRY set at an absolute path so just update the idx and fail
                else
                {
                    *pnIndex = NOT_A_CACHE_SUBDIRECTORY;
                }
            }
        }

        // Otherwise, this should be a valid cache subdirectory.
        else
        {
            *pnIndex = idx;
            fReturn = TRUE;
        }
    }
    else
    {
        *pnIndex = NOT_A_CACHE_SUBDIRECTORY;
    }
    
    return fReturn;
}



/*-----------------------------------------------------------------------------
CSecFileMgr::GetFilePathFromEntry

Retrieves the full path to the cache subdirectory for a cache entry.
Maps the directory index from the URL_FILEMAP_ENTRY pointer passed in
to a string containing the full path.
----------------------------------------------------------------------------*/
BOOL CSecFileMgr::GetFilePathFromEntry(URL_FILEMAP_ENTRY *pEntry,
                                       LPSTR szAbsPath, LPDWORD pcb)
{
    DWORD cbSubDirPath, cbFile;

    INET_ASSERT(pEntry && szAbsPath && pcb && *pcb);
    
    // Get file name and length - eg "default.html"
    LPTSTR szFile = (LPTSTR) OFFSET_TO_POINTER(pEntry, pEntry->InternalFileNameOffset);
    cbFile = strlen(szFile);
    
    // Make real time check?
    if (cbFile && (cbFile < MAX_PATH))
    {
        // Does entry reside in on of the random subdirs?
        if (pEntry->DirIndex != NOT_A_CACHE_SUBDIRECTORY 
            && pEntry->DirIndex < DEFAULT_MAX_DIRS)
        {
            // Path length.
            DWORD cbFull = _mmFile->GetFullPathNameLen();

            // Don't overflow output buffer.
            cbSubDirPath =
                  cbFull
                + DIR_NAME_SIZE
                + sizeof(DIR_SEPARATOR_STRING) - 1
                + cbFile;

            if (cbSubDirPath + 1 > *pcb)
            {
                // INET_ASSERT(FALSE);
                return FALSE;
            }

            // "C:\Windows\Profiles\anyuser\Temporary Internet Files\"
            memcpy(szAbsPath, _mmFile->GetFullPathName(), cbFull);

            // "C:\Windows\Profiles\anyuser\Temporary Internet Files\XAQRTLY7"
            _mmFile->GetDirName(pEntry->DirIndex, szAbsPath + cbFull);

            // "C:\Windows\Profiles\anyuser\Temporary Internet Files\XAQRTLY7\"
            memcpy(szAbsPath + cbFull + DIR_NAME_SIZE, DIR_SEPARATOR_STRING, sizeof (DIR_SEPARATOR_STRING));

            // "C:\Windows\Profiles\anyuser\Temporary Internet Files\XAQRTLY7\default.htm"
            memcpy(szAbsPath + cbFull + DIR_NAME_SIZE + sizeof(DIR_SEPARATOR_STRING) - 1, szFile, cbFile + 1);
        }
     
        // There is no cache subdirectory which has been can be mapped
        // from the index. See if there is an existing store mapping.
        else
        {

            if (pEntry->DirIndex == NOT_A_CACHE_SUBDIRECTORY) 
            // Assume an ECE absolute path item as AddURL only writes NACS entries with ECE set
            {
                cbSubDirPath = cbFile + 1;  // Add terminator to size
                if (cbSubDirPath > *pcb)
                {
                    INET_ASSERT(FALSE);
                    return FALSE;
                }
                memcpy(szAbsPath, szFile, cbSubDirPath);
            }
            else
            {

                INET_ASSERT(pEntry->DirIndex == INSTALLED_DIRECTORY_KEY);
        
                DWORD cbPath = 0;
                DWORD dwIndex = INSTALLED_DIRECTORY_KEY;
                if (MapStoreKey(szAbsPath, &cbPath, &dwIndex, MAP_KEY_TO_PATH))
                {
                    // "C:\Winnt\Web\"
                    cbSubDirPath = cbPath + cbFile;
                    if (cbSubDirPath + 1 > *pcb)
                    {
                        INET_ASSERT(FALSE);                
                        return FALSE;
                    }
                    // "C:\Winnt\Web\default.html"
                    memcpy(szAbsPath + cbPath, szFile, cbFile + 1);
                }
                else
                {
                    INET_ASSERT(FALSE);
                    return FALSE;
                }
            }            
            
        }

        // Hand out the absolute path to the file.
        *pcb = cbSubDirPath;
        
        return TRUE;
    }

    INET_ASSERT(FALSE);
    return FALSE;
}


/*-----------------------------------------------------------------------------
CSecFileMgr::DeleteOneCachedFile
Deletes one cache file and decrements the file count.
----------------------------------------------------------------------------*/
BOOL CSecFileMgr::DeleteOneCachedFile(LPSTR lpszFileName,
                         DWORD dostEntry, DWORD nDirIndex)
{
    if (!::DeleteOneCachedFile(lpszFileName, dostEntry))
        return FALSE;

    INET_ASSERT(nDirIndex != NOT_A_CACHE_SUBDIRECTORY);
    _mmFile->DecrementFileCount(nDirIndex);

    return TRUE;
}



//
//==================== CSecFileMgr Protected Functions =======================
//



/*-----------------------------------------------------------------------------
CSecFileMgr::CreateRandomDirName
Creates a random subdirectory name under the root container path.
----------------------------------------------------------------------------*/
BOOL CSecFileMgr::CreateRandomDirName(LPSTR szDirName)
{
    DWORD RandNum;
    LPSTR ptr = szDirName;
    static Counter;

    INET_ASSERT(szDirName);

    // Stolen from MakeRandomFileName.
    for (DWORD i = 0; i < DIR_NAME_SIZE; i++)
    {
        UINT digit;
        RandNum = (GetTickCount() * rand()) + Counter++;

        // 10 digits + 26 letters
        digit = RandNum % 36;
        *ptr++  = ( digit < 10 ) ? (CHAR)('0' + digit) : (CHAR)('A' + (digit - 10));
    }

    *ptr = '\0';

    return TRUE;
}


/*-----------------------------------------------------------------------------
CSecFileMgr::CreateAdditionalSubDirectories
Creates nAdditionalDirs random subdirectories, up to DEFAULT_MAX_DIRS.
----------------------------------------------------------------------------*/
BOOL CSecFileMgr::CreateAdditionalSubDirectories(DWORD nAdditionalDirs)
{
    DWORD nTotalDirs;
    DWORD nDirCount = _mmFile->GetDirCount();
    BOOL bSuccess = TRUE;

    INET_ASSERT(nDirCount <= DEFAULT_MAX_DIRS);

    // Don't create more than the max allowed dirs.
    nTotalDirs = nAdditionalDirs + nDirCount;
    INET_ASSERT(nTotalDirs <= DEFAULT_MAX_DIRS);

    // Create the dir and set the file count to 0.
    DWORD i = nDirCount;
    DWORD nTotalTries = 0;
    do
    {
        if (CreateSubDirectory(i))
        {
            _mmFile->SetFileCount(i, 0);
            _mmFile->IncrementDirCount();
            i++;
        }
        else
        {
            INET_ASSERT(FALSE);
            bSuccess = FALSE;
        }

        if (nTotalTries++ > 100)
        {
            bSuccess = FALSE;
            break;
        }

    } while (i < nTotalDirs);

    return bSuccess;
}


/*-----------------------------------------------------------------------------
CSecFileMgr::CreateSubDirectory(DWORD nIdx)
Actual creation of subdirectory.
----------------------------------------------------------------------------*/
BOOL CSecFileMgr::CreateSubDirectory(DWORD nIdx)
{
    CHAR szCacheDir[MAX_PATH];
    CHAR szSubDir[DIR_NAME_SIZE + 1];

    // Generate full path to random dir.
    CreateRandomDirName(szSubDir);
    DWORD cb = _mmFile->GetFullPathNameLen();

    memcpy(szCacheDir, _mmFile->GetFullPathName(), cb);
    memcpy(szCacheDir + cb, szSubDir, DIR_NAME_SIZE + 1);

    // Create the directory and add it to
    // the list of directories in the index.
    if (CreateDirectory(szCacheDir, NULL))
    {
        _mmFile->SetDirName(nIdx, szSubDir);

        // For cachevu must be hidden and system.
        // BUGBUG - sure it must be hidden?
        SetFileAttributes(szCacheDir, FILE_ATTRIBUTE_SYSTEM);

        if (!(GetOptions() & INTERNET_CACHE_CONTAINER_NODESKTOPINIT))
           EnableCacheVu(szCacheDir);

    }
    else
    {
        // Couldn't create the directory.
        INET_ASSERT(FALSE);
        return FALSE;
    }
    return TRUE;
}


/*-----------------------------------------------------------------------------
CSecFileMgr::FindMinFilesSubDir
Determines the cache subdirectory with the minimum file count for load balancing.
----------------------------------------------------------------------------*/
BOOL CSecFileMgr::FindMinFilesSubDir(DWORD& nMinFileDir, DWORD& nFiles)
{
    DWORD nDirCount = _mmFile->GetDirCount();

    if (nDirCount == 0 || nDirCount > DEFAULT_MAX_DIRS)
    {
        INET_ASSERT(FALSE);
        _mmFile->SetDirCount(0);
        CreateAdditionalSubDirectories(DEFAULT_DIR_TABLE_GROW_SIZE);
        nDirCount = _mmFile->GetDirCount();
    }

    nMinFileDir = 0;
    DWORD nMinFiles = _mmFile->GetFileCount(0);

    for (DWORD i = 1; i < nDirCount; i++)
    {
        if (_mmFile->GetFileCount(i) < nMinFiles)
        {
            nMinFiles = _mmFile->GetFileCount(i);
            nMinFileDir = i;
        }

    }
    nFiles = _mmFile->GetFileCount(nMinFileDir);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\urlcache\flock.cxx ===
#include "flock.hxx"
// #include <resource.h>
#include <cache.hxx>

#undef inet_ntoa
#undef inet_addr
#undef gethostname
#undef gethostbyname
#undef gethostbyaddr

#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <fcntl.h>

#ifdef sunos5
extern "C" int gethostname(char*,int);
#endif

extern HANDLE MwOpenProcess(pid_t, BOOL);
extern "C" MwAtExit(void (*f)(void));

//locally used functions
int lock_reg(int fd, int cmd, int type, off_t offset, int whence, off_t len);
off_t lock_test(int fd, int type, off_t *offset, int whence, off_t *len);

#define REG_READONLYCACHE TEXT("Software\\Microsoft\\Internet Explorer\\Unix\\ReadOnlyCacheWarning")
#define REG_READONLYCACHEKEY TEXT("ShowCacheWarning")
#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))
#define SECONDSINDAY 86400

#define REG_READONLYCACHE TEXT("Software\\Microsoft\\Internet Explorer\\Unix\\ReadOnlyCacheWarning")
#define REG_READONLYCACHEKEY TEXT("ShowCacheWarning")
#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))
#define SECONDSINDAY 86400


// lock region relative to whence starting at offset upto len bytes
int lock_reg(int fd, int cmd, int type, off_t offset, int whence, off_t len) {

  struct flock lock;

  lock.l_type = type;       //F_RDLCK, F_WRLCK, F_UNLCK     
  lock.l_start = offset;    //byte offset, relative to l_whence
  lock.l_whence = whence;   //SEEK_SET, SEEK_CUR, SEEK_END  
  lock.l_len = len;     //#bytes (0 means to EOF)

  return( fcntl(fd, cmd, &lock) );
}

// test region for locks relative to whence starting at offset for len bytes
off_t lock_test(int fd, int type, off_t *offset, int whence, off_t *len) {

  struct flock lock;

  lock.l_type = type;       //F_RDLCK, F_WRLCK, F_UNLCK 
  lock.l_start = *offset;   //byte offset, relative to l_whence     
  lock.l_whence = whence;   //SEEK_SET, SEEK_CUR, SEEK_END  
  lock.l_len = *len;        // #bytes (0 means to EOF)      

  if (fcntl(fd, F_GETLK, &lock) < 0)
    return(-1);

  if (lock.l_type == F_UNLCK)
    return(0);          // nobody has lock in this region
  else if (lock.l_type == F_RDLCK) {
    *offset = lock.l_start;
    *len = lock.l_len;
    return(lock.l_start);   // byte offset of host with read lock
  } else {          // dont support extended semantics of
    return(-1);         // write lock yet
  }
}


extern "C" void unixCleanupWininetCacheLockFile()
{
//    if(!g_ReadOnlyCaches)
        //unlink(szLockDBName);
}

BOOL CreateAtomicCacheLockFile(BOOL *pfReadOnlyCaches, char **pszLockingHost)
{
    int fdlockdbf, fdlock, envLen, hostbynameerr;
    off_t IPOffset=0, IPLen=0, ownIPOffset, ownIPLen;
    char *hostname, hostbynamebuf[512];
    char szLockFileName[MAX_PATH+1], szLockDBName[MAX_PATH+1];
    struct hostent hostbynameresult;
#ifdef ux10
    struct hostent_data hostentdata;
#endif

    char *pEnv = getenv("MWUSER_DIRECTORY");

    /* Don't process the ielock file for Mainwin Lite programs */
    if (MwIsInitLite())
       goto Cleanup;

    if (pEnv == 0)
    return FALSE;

    envLen = strlen(pEnv);
    if (envLen > MAX_PATH-256)
        return FALSE;

    strcpy(szLockFileName, pEnv);
    if (szLockFileName[envLen-1] != '/') {
      szLockFileName[envLen] = '/';
      szLockFileName[envLen+1] = 0x00;
    }
    strcpy(szLockDBName, pEnv);
    if (szLockDBName[envLen-1] != '/') {
      szLockDBName[envLen] = '/';
      szLockDBName[envLen+1] = 0x00;
    }
    strcat(szLockFileName, LF);
    strcat(szLockDBName, LOCKDBF);

    hostname = (char *)malloc(256*sizeof(char));
    if ((hostname == NULL) || (gethostname(hostname, 256) == -1)) {
      *pfReadOnlyCaches = TRUE;
      return FALSE;
    }

#ifdef sunos5
    if (!(gethostbyname_r(hostname, &hostbynameresult, hostbynamebuf,
                 sizeof(hostbynamebuf), &hostbynameerr))) {
      *pfReadOnlyCaches = TRUE;
      return FALSE;
    }
#endif
#ifdef ux10
    if (gethostbyname_r(hostname, &hostbynameresult, &hostentdata) < 0) {
      *pfReadOnlyCaches = TRUE;
      return FALSE;
    }
#endif
    struct in_addr *ptr = (struct in_addr *)*hostbynameresult.h_addr_list;
    ownIPOffset = inet_netof(*ptr);
    ownIPLen = inet_lnaof(*ptr);

    if ((fdlock = open(szLockFileName, O_WRONLY|O_CREAT|O_EXCL, FILE_MODE)) < 0) {
      if (errno == EEXIST) {
        if ((fdlock = open(szLockFileName, O_WRONLY)) < 0) {
          *pfReadOnlyCaches = TRUE;
          return FALSE;
        }
      } else {
        *pfReadOnlyCaches = TRUE;
        return FALSE;
      }
    }

    if (writew_lock(fdlock, 0, SEEK_SET, 0) < 0) {
      *pfReadOnlyCaches = TRUE;
      return FALSE;
    }

    /*under this lock, now do all the examination of szLockDBName*/
    if ((fdlockdbf = open(szLockDBName, O_RDWR|O_CREAT|O_EXCL, FILE_MODE)) < 0) {
      if (errno == EEXIST) {
        if ((fdlockdbf = open(szLockDBName, O_RDWR)) < 0) {
          *pfReadOnlyCaches = TRUE;
          un_lock(fdlock, 0, SEEK_SET, 0);
          return FALSE;
        }
      } else {
        *pfReadOnlyCaches = TRUE;
        un_lock(fdlock, 0, SEEK_SET, 0);
        return FALSE;
      }
    }

    /* check entire file for locking */
    if ((can_writelock(fdlockdbf, &IPOffset, SEEK_SET, &IPLen)) >= 0) {
      if ((IPOffset == 0) || ((IPOffset == ownIPOffset) && (IPLen == ownIPLen))){
    // either no IE writing to cache or IE on own host writing to cache
    // (IP address is identical)..either way we have write access
    *pfReadOnlyCaches = FALSE;
    *pszLockingHost = hostname;
    //lock at "network part" position for "host part" bytes
    read_lock(fdlockdbf, ownIPOffset, SEEK_SET, ownIPLen);
    un_lock(fdlock, 0, SEEK_SET, 0);
    return TRUE;
      } else {
    //some other host writing to cache
        *pfReadOnlyCaches = TRUE;
        u_long addr = inet_addr(inet_ntoa(inet_makeaddr(IPOffset, IPLen)));
        struct hostent * hp = gethostbyaddr((char *)&addr, sizeof(addr), AF_INET);
        if (!hp)
          ;       //cant find hostname from offset & length of locked bytes..
        else
          *pszLockingHost = hp->h_name;
        un_lock(fdlock, 0, SEEK_SET, 0);
        return TRUE;
      }
    } else {
      //can_writelock returned -1 with some fcntl error
      *pfReadOnlyCaches = TRUE;
      un_lock(fdlock, 0, SEEK_SET, 0);
      return FALSE;
    }

Cleanup:
    return TRUE;
}

BOOL DeleteAtomicCacheLockFile()
{
    /* Don't process for MainWin Lite programs */
    /* Right now, the code below does not make sense because all
     * we do is return TRUE. So, commenting out this code for now.
     */
#if 0
    if (MwIsInitLite())
       goto Cleanup;

Cleanup:
#endif /* 0 */
    //unlink(szLockDBName);
    return TRUE;
}

#if 0 // Back out till we get a consensus on this

BOOL CALLBACK ReadOnlyCache_DlgProc(HWND   hDlg,
                                    UINT   uMsg,
                                    WPARAM wParam,
                                    LPARAM lParam) {
     switch (uMsg) {
            case WM_INITDIALOG:
            {
                 LPTSTR lpszMessageStr = (LPTSTR)lParam;
                 TCHAR  pszText[MAX_PATH];
                 TCHAR  pszFormattedText[MAX_PATH];

                 if (lpszMessageStr)
                 {
                    if (LoadString(GlobalDllHandle,
                                   IDS_READONLYCACHE,
                                   pszText,
                                   ARRAYSIZE(pszText))) {
                       wsprintf(pszFormattedText,pszText, lpszMessageStr);
                       SetDlgItemText(hDlg, IDC_READONLYCACHE, pszFormattedText);
                    }
                 }

                 SetFocus(GetDlgItem(hDlg, IDOK));
            }
            break;

            case WM_COMMAND:
                 switch (LOWORD(wParam))
                 {
                        case IDOK:
                        {
                             if (IsDlgButtonChecked(hDlg, IDC_DONT_WANT_WARNING))
                                EndDialog(hDlg, 1);
                             else
                                EndDialog(hDlg, 0);
                             break;
                        }

                        default:
                             return FALSE;
                 }
                 return TRUE;
            case WM_CLOSE:
            {
                 if (IsDlgButtonChecked(hDlg, IDC_DONT_WANT_WARNING))
                    EndDialog(hDlg, 1);
                 else
                    EndDialog(hDlg, 0);
            }
            return TRUE;
     }

     return FALSE;
}

void ShowReadOnlyCacheDialog(char* pszHostName) {
     DWORD dwError = E_FAIL;
     HKEY  hKey = NULL;
     DWORD dwValue = 0;
     DWORD dwValueType;
     DWORD dwValueSize = sizeof(DWORD);

     if ((dwError = REGOPENKEYEX(HKEY_CURRENT_USER,
                            REG_READONLYCACHE,
                            0,
                            KEY_READ|KEY_WRITE,
                            &hKey)) != ERROR_SUCCESS)
     {
        goto Cleanup;
     }

     if ((dwError = RegQueryValueEx(hKey,
                               REG_READONLYCACHEKEY,
                               0,
                               &dwValueType,
                               (LPBYTE)&dwValue,
                               &dwValueSize)) != ERROR_SUCCESS)
     {
        goto Cleanup;
     }

     if (dwValue)
     {
        int fRet = 0;

        if ((fRet = DialogBoxParam(GlobalDllHandle,
                              MAKEINTRESOURCE(IDD_READONLYCACHE),
                              NULL,
                              ReadOnlyCache_DlgProc,
                              (LPARAM)pszHostName)) < 0)
        {
           goto Cleanup;
        }

        /*
         * we are here, because the registry told us to show this dialog.
         * now, we check if fRet == TRUE, in which case we don't show this
     * dialog in the future. And, we update the registry.
         */

        if (fRet == 1) {
           /* ShowCacheWarning will be set to False in the registry */
           dwValue = 0;

           /*
            * we don't check for the error here, because we close the key next
            * and if we did not save successfully, we will show this dialog again
            */

           RegSetValueEx(hKey,
                         REG_READONLYCACHEKEY,
                         0,
                         dwValueType,
                         (LPBYTE)&dwValue,
                         dwValueSize);
        }
     }

Cleanup:

     if (hKey)
        REGCLOSEKEY(hKey);

     return;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\urlcache\filemap.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    filemap.cxx

Abstract:

    contains implementation of MEMMAP_FILE class.

Author:

    Madan Appiah (madana)  28-April-1995

Environment:

    User Mode - Win32

Revision History:

    Shishir Pardikar (shishirp) added: (as of (7/6/96)

    1) Fix crossproces problems on win95 in checksizegrowandremap
    2) Exception handling to deal with badsector being memorymapped
    3) More robust validation at init time
    4) Reinitialization code to really clear the cache
    5) Bug fixes in GrowMap while growing partially filled dword

--*/

#include <wininetp.h>
#include <cache.hxx>


#define FILE_SIZE_MAX_DIGITS 16


DWORD
ValidateAndCreatePath(
    LPTSTR PathName
    )
{
    DWORD Error, len;
    DWORD FileAttribute;
    LPTSTR PathDelimit;

    //
    // check to see the path specified is there.
    //

    FileAttribute = GetFileAttributes( PathName );

    if( FileAttribute != 0xFFFFFFFF ) {

        //
        // check to see the attribute says it is a dir.
        //

        if( !(FileAttribute & FILE_ATTRIBUTE_DIRECTORY) ) {
            
            return( ERROR_INVALID_PARAMETER );
        }

        // We found the file and it is a dir.
        // Set the system attribute just in case
        // it has been unset.
        SetFileAttributes(PathName, FILE_ATTRIBUTE_SYSTEM);
        return( ERROR_SUCCESS );
    }

    Error = GetLastError();

    if( (Error != ERROR_FILE_NOT_FOUND) &&
        (Error != ERROR_PATH_NOT_FOUND) ) {

        return( Error );
    }

    //
    // we did not find the path, so create it.
    //

    if( CreateDirectory( PathName, NULL ) ) {

        //
        // done.
        //
        SetFileAttributes(PathName, FILE_ATTRIBUTE_SYSTEM);
        return( ERROR_SUCCESS );
    }

    Error = GetLastError();

    if( Error != ERROR_PATH_NOT_FOUND ) {

        return( Error );
    }

    //
    // sub-path is not found, create it first.
    //

    len = lstrlen( PathName );

    if (len < 5) {

        SetLastError(ERROR_INVALID_NAME);

        return (ERROR_INVALID_NAME);
    }

    PathDelimit = PathName + len -1 ;

    // step back from the trailing backslash

    if( *PathDelimit == PATH_CONNECT_CHAR ) {
        PathDelimit--;
    }

    //
    // find the last path delimiter.
    //

    while( PathDelimit >  PathName ) {
        if( *PathDelimit == PATH_CONNECT_CHAR ) {
            break;
        }

        PathDelimit--;
    }

    if( PathDelimit == PathName ) {
        return( ERROR_INVALID_PARAMETER );
    }

    *PathDelimit = TEXT('\0');

    //
    // validate sub-path now.
    //

    Error = ValidateAndCreatePath( PathName ) ;

    //
    // replace the connect char anyway.
    //

    *PathDelimit = PATH_CONNECT_CHAR;

    if( Error != ERROR_SUCCESS ) {

        return( Error );
    }

    //
    // try to create one more time.
    //

    if( CreateDirectory( PathName, NULL ) ) {

        //
        // done.
        //

        return( ERROR_SUCCESS );
    }

    Error = GetLastError();
    return( Error );
}


DWORD
MEMMAP_FILE::CheckSizeGrowAndRemapAddress(
    VOID
    )
{
    DWORD dwNewFileSize;

#ifdef WIN95_BUG
    if( _FileSize == (dwNewFileSize = _HeaderInfo->FileSize )) {
        return( ERROR_SUCCESS );
    }
#endif //WIN95_BUG

    // ideally we would have liked to do as in the above two lines
    // this works right on NT but doesn't on win95.

    // This is because the filesize is a part of the mapname
    // In the initial state the index file size is 8192. So the
    // memorymap name is c:_windows_temporaray internet files_8192.
    // Both the processes have this map in their address space.
    // Process B starts pumping in the data, and at some point the index
    // file needs to be grown. Process B, increases the index file to 16384,
    // updates the filesize in the header "while it is still mapped in the
    // map corresponding to the old filesize" and then remaps to the new map
    // with the name c:_windows_temporaray internet files_16384.
    // Any subsequent growth is now recorded in this map.
    // The old map c:_windows_temporaray internet files_8192 still has only
    // the first transition.


    // the work around is to actually get the filesize from the filesystem
    // This works correctly on win95 and NT both. Optimally, we would
    // check for a transition and then get the real size, but we will do that
    // after IE30 ships.



    //NB!!!!!!! The check below is the basis of our cross process
    // cache. All APIs finally make this call before touching the memory
    // mapped file. If there is a chneg, they remap it to the new size
    // with the sizename as part of the mapping, so they get the latest
    // stuff.
    // When anyone gets here, they are protected by a crossprocess mutex


    if( _FileSize == (dwNewFileSize = GetFileSize(_FileHandle, NULL))) {
        return( ERROR_SUCCESS );
    }

    //
    // so other user of the memmap file has increased the file size,
    // let's remap our address space so that the new portion is
    // visible to us too.
    //

    DWORD Error;
    DWORD OldFileSize;
    DWORD OldNumBitMapDWords;

   //
   // set our internal file size and num bit map entries.
   //

    OldFileSize = _FileSize;
    OldNumBitMapDWords = _NumBitMapDWords;


    _FileSize = dwNewFileSize;

    Error = RemapAddress();

    if( Error != ERROR_SUCCESS ) {

        //
        // reset the file size.
        //

        _FileSize = OldFileSize;
        _NumBitMapDWords = OldNumBitMapDWords;
    }
    else {

#if INET_DEBUG
        if ((GetFileSize(_FileHandle, NULL)) != (_HeaderInfo->FileSize)) {

            TcpsvcsDbgPrint(( DEBUG_FILE_VALIDATE,
                "GetFileSize!= (_FileSize)\n" ));

            TcpsvcsDbgAssert(FALSE);

        }
#endif //INET_DEBG

        _NumBitMapDWords =
            (_HeaderInfo->NumUrlInternalEntries + (NUM_BITS_IN_DWORD - 1)) /
                NUM_BITS_IN_DWORD; // cell
    }

    return( Error );
}

BOOL
MEMMAP_FILE::ValidateCache(
    VOID
    )
/*++

    This private member function validates the cache file content.

Arguments:

    NONE.

Return Value:

    TRUE - if the cache is valid.
     FALSE - otherwise.

--*/
{
    BOOL ReturnCode = FALSE;
    int i, k;
    DWORD BitPosition, TotalAlloced, MaxAllocedPosition, RunningCounter;


    __try {

        // validate signatue.
        if( memcmp(
                _HeaderInfo->FileSignature,
                CACHE_SIGNATURE,
                MAX_SIG_SIZE * sizeof(TCHAR) ) != 0 ) {

            TcpsvcsDbgPrint(( DEBUG_FILE_VALIDATE,
                "File signature does not match.\n" ));
            goto Cleanup;
        }

        // Also check the index does not contain entries with a higher
        // version than the current machine can handle.  This can happen
        // due to Windows kludgy concept of roaming, which replicates 
        // parts of the file system and registry hkcu.
        
        LPSTR pszHighVer = (LPSTR) (_HeaderInfo->dwHeaderData
            + CACHE_HEADER_DATA_HIGH_VERSION_STRING);
        if (pszHighVer[0] != 'V' || pszHighVer[3] != 0)
            memset (pszHighVer, 0, sizeof(DWORD));
        else if (!g_szFixup[0] || strcmp (g_szFixup, pszHighVer) < 0)
        {
            TcpsvcsDbgPrint(( DEBUG_FILE_VALIDATE,
                "Cannot handle uplevel index file.\n" ));
            goto Cleanup;
        }

        // check the hash table root offset is valid
        if( _HeaderInfo->dwHashTableOffset != 0 ) {

            if( _HeaderInfo->dwHashTableOffset > _FileSize ) {
                TcpsvcsDbgPrint(( DEBUG_FILE_VALIDATE,
                    "invalid b-tree root offset.\n" ));
                goto Cleanup;
            }
        }

        // check file size.
        if( _HeaderInfo->FileSize != _FileSize ) {
            TcpsvcsDbgPrint(( DEBUG_FILE_VALIDATE,
                "invalid file size.\n" ));
            goto Cleanup;
        }

        // one more file size check.
        DWORD ExpectedFileSize;
        ExpectedFileSize =
            HEADER_ENTRY_SIZE +
                _HeaderInfo->NumUrlInternalEntries * _EntrySize;

        // cell the size to GlobalMapFileGrowSize.
        if( ExpectedFileSize % GlobalMapFileGrowSize ) {
                ExpectedFileSize =
                ((ExpectedFileSize /  GlobalMapFileGrowSize) + 1) *
                        GlobalMapFileGrowSize;
        }

        if( _FileSize != ExpectedFileSize ) {

            // it is ok if the file size is one block bigger.
            TcpsvcsDbgPrint(( DEBUG_FILE_VALIDATE,
                "Invalid file size.\n" ));
            goto Cleanup;
        }


        if(_HeaderInfo->NumUrlInternalEntries < _HeaderInfo->NumUrlEntriesAlloced) {
            TcpsvcsDbgPrint(( DEBUG_FILE_VALIDATE,
                "Invalid alloc entires.\n" ));
            goto Cleanup;
        }


        TotalAlloced = 0;
        MaxAllocedPosition = 0;
        RunningCounter = 0;

        // scan the enire bitmap and do some consistency check for allocated bits
        for(i=0; i<BIT_MAP_ARRAY_SIZE; ++i) {
            // k goes from 0 to 31
            // BitPosition goes from 0x00000001 to 0x80000000

            for(BitPosition=1, k=0; k<NUM_BITS_IN_DWORD; ++k, BitPosition <<=1) {

                ++RunningCounter;
                if(_HeaderInfo->AllocationBitMap[i] & BitPosition) {

                    ++TotalAlloced;

                    MaxAllocedPosition = RunningCounter;

                }

            }
        }

        // if the max allocated bit is greter than the number of
        // possible entries for this filesize,
        // or the total allocated bits are greater (the above condition subsumes
        // this one, but it is OK to be paranoid)
        // or totalbits alloced don't match the count
        // there this header is not OK

        if ((MaxAllocedPosition > _HeaderInfo->NumUrlInternalEntries)
            ||(TotalAlloced > _HeaderInfo->NumUrlInternalEntries)
            ||(TotalAlloced != _HeaderInfo->NumUrlEntriesAlloced)) {

            TcpsvcsDbgPrint(( DEBUG_FILE_VALIDATE,
                "Invalid alloc bitmap\n" ));
            goto Cleanup;

        }
        //
        // every thing is fine.
        //

        ReturnCode = TRUE;
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {

        ReturnCode = FALSE;

        _Status = ERROR_WRITE_FAULT;
    }
    ENDEXCEPT

Cleanup:

    if( ReturnCode == FALSE ) {
        TcpsvcsDbgPrint(( DEBUG_FILE_VALIDATE, "Invalid Cache, or bad disk\n" ));
    }

    return( ReturnCode );
}

void MEMMAP_FILE::CloseMapping (void)
{
    if (_BaseAddr) // view
    {
        UnmapViewOfFile(_BaseAddr);
        _BaseAddr = NULL;
    }
    if (_FileMappingHandle) // mapping
    {
        CloseHandle (_FileMappingHandle);
        _FileMappingHandle = NULL;
    }
    if (_FileHandle) // file
    {
        CloseHandle (_FileHandle);
        _FileHandle = NULL;
    }
}


DWORD
MEMMAP_FILE::RemapAddress(
    VOID
    )
/*++

    This private member function remaps the memory mapped file just after
    the file size has been modified.

    Container must be locked when this function is called.

Arguments:

    NONE.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error = ERROR_SUCCESS;
    PVOID OldBaseAddr;
    DWORD OldViewSize;
    PVOID VirtualBase;
    BOOL BoolError;
    LPTSTR MapName = NULL;

    CloseMapping();
    
    //
    // Create/Open memory mapped file.
    //

    _FileHandle =
        CreateFile(
            _FileName,
            GENERIC_READ | GENERIC_WRITE,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
                // share this file with others while it is being used.
            CreateAllAccessSecurityAttributes(NULL, NULL, NULL),
            OPEN_ALWAYS,
            FILE_FLAG_RANDOM_ACCESS,
            NULL );


    if( _FileHandle ==  INVALID_HANDLE_VALUE ) {

        Error = _Status = GetLastError();
        TcpsvcsDbgPrint(( DEBUG_ERRORS,
            "Reinitialize:File open failed, %ld.\n",_Status));

        TcpsvcsDbgAssert( FALSE );

        _FileHandle = NULL;
        goto Cleanup;
    }


#ifndef unix
    /*******
     * UNIX:
     *       Mainwin does not support MapName in CreateFileMapping API
     *       Let us leave the MapName as NULL till this functionality
     *       is available.
     */

    //
    // make a map name.
    //

    DWORD MapNameSize;

    MapNameSize =
        (lstrlen(_FullPathName) +
            lstrlen( _FileName) +
                1 +
                FILE_SIZE_MAX_DIGITS ) * sizeof(TCHAR) ;

    MapName = (LPTSTR) CacheHeap->Alloc( MapNameSize );

    if( MapName == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    memcpy(MapName, _FileName, _FullPathNameLen + sizeof(MEMMAP_FILE_NAME));
    memcpy(MapName + _FullPathNameLen + sizeof(MEMMAP_FILE_NAME) - 1, DIR_SEPARATOR_STRING, sizeof(DIR_SEPARATOR_STRING));
    wsprintf(MapName + lstrlen(MapName), "%u", _FileSize);

#ifndef unix
#define BACKSLASH_CHAR          TEXT('\\')
#else
#define BACKSLASH_CHAR          TEXT('/')
#endif /* unix */
#define UNDERSCORE_CHAR         TEXT('_')
#define TERMINATING_CHAR        TEXT('\0')

    LPTSTR ScanMapName;

    //
    // Replace '\' with '_'.
    //

    ScanMapName = MapName;

    while( *ScanMapName != TERMINATING_CHAR ) {

        if( *ScanMapName == BACKSLASH_CHAR ) {
            *ScanMapName = UNDERSCORE_CHAR;
        }

        ScanMapName++;
    }
#endif /* !unix */



    //
    // re-create memory mapping.
    //
    _FileMappingHandle = OpenFileMapping(FILE_MAP_WRITE, FALSE, MapName);

    if (_FileMappingHandle == NULL && (GetLastError() == ERROR_FILE_NOT_FOUND || GetLastError() == ERROR_INVALID_NAME))
    {
        _FileMappingHandle =
            CreateFileMapping(
                _FileHandle,
                CreateAllAccessSecurityAttributes(NULL, NULL, NULL),
                PAGE_READWRITE,
                0, // high dword of max memory mapped file size.
    #if defined(UNIX) && defined(ux10)
                1024 * 1024, // map entire file.
    #else
                0, // map entire file.
    #endif
                MapName);
    }

    if( _FileMappingHandle == NULL ) {
        Error = _Status = GetLastError();
        goto Cleanup;
    }

    //
    // remap view region.
    //

    _BaseAddr =
        MapViewOfFileEx(
            _FileMappingHandle,
            FILE_MAP_WRITE,
            0,
            0,
#if defined(UNIX) && defined(ux10)
            1024 * 1024,   // MAP entire file.
#else
            0,   // MAP entire file.
#endif
            NULL );

#if defined(UNIX) && defined(ux10)
    DWORD FilePointer = SetFilePointer(
                            _FileHandle,
                            _FileSize,
                            NULL,
                            FILE_BEGIN );
    if (FilePointer == 0xFFFFFFFF)
    {
        Error = _Status = GetLastError();
        goto Cleanup;
    }

    BoolError = SetEndOfFile( _FileHandle );

    if (BoolError == FALSE)
    {
        Error = _Status = GetLastError();
        goto Cleanup;
    }
#endif

    if( _BaseAddr == NULL ) 
    {
        Error = _Status = GetLastError();
        TcpsvcsDbgAssert( FALSE );

        TcpsvcsDbgPrint(( DEBUG_ERRORS,
            "MapViewOfFile failed to extend address space, %ld.\n",
                Error ));

       goto Cleanup;
    }

    //
    // reset other pointers.
    //

    _HeaderInfo = (LPMEMMAP_HEADER)_BaseAddr;
    _EntryArray = ((LPBYTE)_BaseAddr + HEADER_ENTRY_SIZE );

    _Status = Error = ERROR_SUCCESS;

Cleanup:


    if( MapName != NULL ) {
        CacheHeap->Free( MapName );
    }

        return( Error );
}

DWORD
MEMMAP_FILE::GrowMapFile(DWORD dwMapFileGrowSize)
/*++

    This private member function extends the memory mapped file and
    creates more free url store entries.

Arguments:

    NONE.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error, i;
    BOOL BoolError;
    DWORD FilePointer;
    DWORD OldNumUrlInternalEntries;
    char  buff[PAGE_SIZE];

    //
    // check to see that we have reached the limit.
    // we can hold only MAX_URL_ENTRIES url entries.
    // so the file size can grow more than
    //
    //  HEADER_ENTRY_SIZE + MAX_URL_ENTRIES * _EntrySize
    //

#if INET_DEBUG
    if (GetFileSize(_FileHandle, NULL) != (_FileSize)) {

        TcpsvcsDbgPrint(( DEBUG_FILE_VALIDATE,
                "GetFileSize!= (_FileSize)\n" ));

        TcpsvcsDbgAssert(FALSE);

    }
#endif //INET_DEBG

    //BUGBUG - need to fix this
    if( (_FileSize + dwMapFileGrowSize) >=
            (HEADER_ENTRY_SIZE +
                MAX_URL_ENTRIES * _EntrySize) ) {

        //
        // best matching error code.
        //

        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    FilePointer = SetFilePointer(
                            _FileHandle,
                            dwMapFileGrowSize,
                            NULL,
                            FILE_END );


    if (FilePointer != (_FileSize + dwMapFileGrowSize))
    {
        TcpsvcsDbgPrint(( DEBUG_FILE_VALIDATE,
                "FilePointer != (_FileSize + dwMapFileGrowSize)\n" ));

        TcpsvcsDbgAssert(FALSE);
        
        _Status = GetLastError();
        Error = _Status;

        goto Cleanup;
    }

    if( FilePointer == 0xFFFFFFFF ) {
        Error = GetLastError();
        TcpsvcsDbgAssert(FALSE);
        goto Cleanup;
    }

    BoolError = SetEndOfFile( _FileHandle );

    if( BoolError != TRUE ) {
        Error = GetLastError();
        TcpsvcsDbgAssert(FALSE);
        goto Cleanup;
    }

#if INET_DEBUG
    if (GetFileSize(_FileHandle, NULL) != (_FileSize + dwMapFileGrowSize)) {

        TcpsvcsDbgPrint(( DEBUG_FILE_VALIDATE,
                "GetFileSize!= (_FileSize + dwMapFileGrowSize)\n" ));

        TcpsvcsDbgAssert(FALSE);

    }
#endif

    //
    // adjust internal size parameters.
    //

    _FileSize += dwMapFileGrowSize;

    //
    // also set the new file size in the memory mapped file so that
    // other user will remap their address space and view the new portion.
    //

    _HeaderInfo->FileSize = _FileSize;

    OldNumUrlInternalEntries = _HeaderInfo->NumUrlInternalEntries;
    _HeaderInfo->NumUrlInternalEntries +=
        dwMapFileGrowSize / _EntrySize;

    _NumBitMapDWords =
        (_HeaderInfo->NumUrlInternalEntries + (NUM_BITS_IN_DWORD - 1)) /
            NUM_BITS_IN_DWORD; // cell

    //
    // remap
    //

    Error = RemapAddress();

    if( Error != ERROR_SUCCESS ) {

        goto Cleanup;
    }

    memset(
          (_EntryArray + _EntrySize * OldNumUrlInternalEntries),
           0,
          dwMapFileGrowSize );

    Error = ERROR_SUCCESS;


Cleanup:

    return( Error );
}

BOOL MEMMAP_FILE::CheckNextNBits(DWORD& nArrayIndex, DWORD &dwStartMask, 
                                DWORD nBitsRequired, DWORD& nBitsFound)
{
/*++
    Determines if the next N bits are unset.

Arguments:
    [IN/OUT]
    DWORD &nArrayIndex, DWORD &dwMask

    [IN]
    DWORD nBitsRequired

    [OUT]
    DWORD &nBitsFound

Return Value:

    TRUE if the next N bits were found unset.
    FALSE otherwise.

Notes:
    This function assumes that the range of bits to be checked lie
    within a valid area of the bit map. 
--*/
    DWORD i, j;
    DWORD nIdx = nArrayIndex;
    DWORD dwMask = dwStartMask;
    BOOL fFound = FALSE;
    LPDWORD BitMap = &_HeaderInfo->AllocationBitMap[nIdx];

    nBitsFound = 0;

    // Check if the next nBitsRequired bits are unset
    for (i = 0; i < nBitsRequired; i++)
    {
        // Is this bit unset?
        if ((*BitMap & dwMask) == 0)
        {
            // Have sufficient unset bits been found?
            if (++nBitsFound == nBitsRequired)
            {
                // Found sufficient bits. Success.
                fFound = TRUE;
                goto exit;
            }
        }

        // Ran into a set bit. Fail.
        else
        {
            // Indicate the array and bit index 
            // of the set bit encountered.
            nArrayIndex = nIdx;
            dwStartMask = dwMask;
            goto exit;
        }

        // Left rotate the bit mask.
        dwMask <<= 1;
        if (dwMask == 0x0)
        {
            dwMask = 0x1;
            BitMap = &_HeaderInfo->AllocationBitMap[++nIdx];
        }

    } // Loop nBitsRequired times.


exit:
    return fFound;
}
 

BOOL MEMMAP_FILE::SetNextNBits(DWORD nIdx, DWORD dwMask, 
                                DWORD nBitsRequired)
/*++
    Given an array index and bit mask, sets the next N bits.

Arguments:
    [IN]
    DWORD nIdx, DWORD dwMask, DWORD nBitsRequired

Return Value:

    TRUE if the next N bits were found unset, and successfully set.
    FALSE if unable to set all the required bits.

Notes:
    This function assumes that the range of bits to be set lie
    within a valid area of the bit map. If the function returns
    false, no bits are set.
 --*/
{
    DWORD i, j, nBitsSet = 0;
    LPDWORD BitMap = &_HeaderInfo->AllocationBitMap[nIdx];
    BitMap = &_HeaderInfo->AllocationBitMap[nIdx];

    for (i = 0; i < nBitsRequired; i++)
    {    
        // Check that this bit is not already set.
        if (*BitMap & dwMask)
        {
            INET_ASSERT(FALSE);

            // Fail. Unset the bits we just set and exit.
            for (j = nBitsSet; j > 0; j--)
            {
                INET_ASSERT((*BitMap & dwMask) == 0);

                // Right rotate the bit mask.
                dwMask >>= 1;
                if (dwMask == 0x0)
                {
                    dwMask = 0x80000000;
                    BitMap = &_HeaderInfo->AllocationBitMap[--nIdx];
                }                        
                *BitMap &= ~dwMask;
            }             
            return FALSE;
        }

        *BitMap |= dwMask;
        nBitsSet++;
    
        // Left rotate the bit mask.
        dwMask <<= 1;
        if (dwMask == 0x0)
        {
            dwMask = 0x1;
            BitMap = &_HeaderInfo->AllocationBitMap[++nIdx];
        }                        
    
    }

    // Success.
    return TRUE;
}


DWORD
MEMMAP_FILE::GetAndSetNextFreeEntry(
    DWORD nBitsRequired
    )
/*++
    This private member function computes the first available free entry
    index.

Arguments:

    DWORD nBitsRequired

Return Value:

    Next available free entry Index.
--*/
{
    DWORD i, nReturnBit = 0xFFFFFFFF;
    
    // Align if 4k or greater
    BOOL fAlign = (nBitsRequired >= NUM_BITS_IN_DWORD ? TRUE : FALSE);            
    
    // Scan DWORDS from the beginning of the byte array.
    DWORD nArrayIndex = 0;
    while (nArrayIndex < _NumBitMapDWords)
    {
        // Process starting from this DWORD if alignment is not required 
        // and there are free bits, or alignment is required and all bits
        // are free. 
        if (_HeaderInfo->AllocationBitMap[nArrayIndex] !=  0xFFFFFFFF
            && (!fAlign || (fAlign && _HeaderInfo->AllocationBitMap[nArrayIndex] == 0)))
        {
            DWORD nBitIndex = 0;
            DWORD dwMask = 0x1;
            LPDWORD BitMap = &_HeaderInfo->AllocationBitMap[nArrayIndex];

            // Find a candidate slot.
            while (nBitIndex < NUM_BITS_IN_DWORD)
            {
                // Found first bit of a candidate slot.
                if ((*BitMap & dwMask) == 0)
                {
                    // Calculate leading bit value.
                    DWORD nLeadingBit = NUM_BITS_IN_DWORD * nArrayIndex + nBitIndex;
          
                    // Don't exceed the number of internal entries.
                    if (nLeadingBit + nBitsRequired > _HeaderInfo->NumUrlInternalEntries)
                    {
                        // Overstepped last internal entry
                        goto exit;
                    }

                    // If we just need one bit, then we're done.
                    if (nBitsRequired == 1)
                    {
                        *BitMap |= dwMask;
                        nReturnBit = nLeadingBit;
                        _HeaderInfo->NumUrlEntriesAlloced += 1;
                        goto exit;
                    }

                    // Additional bits required.
                    DWORD nBitsFound;
                    DWORD nIdx = nArrayIndex;

                    // Check the next nBitsRequired bits. Set them if free.
                    if (CheckNextNBits(nIdx, dwMask, nBitsRequired, nBitsFound))
                    {
                        if (SetNextNBits(nIdx, dwMask, nBitsRequired))
                        {
                            // Return the offset of the leading bit.
                            _HeaderInfo->NumUrlEntriesAlloced += nBitsRequired;
                            nReturnBit = nLeadingBit;
                            goto exit;
                        }
                        // Bad news.
                        else
                        {
                            // The bits are free, but we couldn't set them. Fail.
                            goto exit;
                        }
                    }
                    else
                    {
                        // This slot has insufficient contiguous free bits. 
                        // Update the array index. We break back to looping
                        // over the bits in the DWORD where the interrupting
                        // bit was found.
                        nArrayIndex = nIdx;
                        nBitIndex = (nBitIndex + nBitsFound) % NUM_BITS_IN_DWORD;
                        break;
                    }

                } // Found a free leading bit.
                else                
                {
                    // Continue looking at bits in this DWORD.
                    nBitIndex++;
                    dwMask <<= 1;
                }

            } // Loop over bits in DWORD.

        } // If we found a candidate DWORD.

        nArrayIndex++;

    } // Loop through all DWORDS.
	exit:
    return nReturnBit;
}


MemMapStatus MEMMAP_FILE::Init(LPTSTR PathName, DWORD EntrySize)
/*++

    MEMMAP_FILE object constructor.

Arguments:

    PathName : full path name of the memory mapped file.

    EntrySize : size of the each entry in this container.

Return Value:

    NONE.

--*/
{
    DWORD cb;

    _EntrySize =  EntrySize;
    _FullPathName = NULL;
    _FileName = NULL;
    _FileSize = 0;
    _FileHandle = NULL;
    _FileMappingHandle = NULL;
    _BaseAddr = NULL;
    _HeaderInfo = NULL;
    _EntryArray = NULL;
    _NumBitMapDWords = 0;

    // Validate the path and create the path if it is not already there.
    _Status = ValidateAndCreatePath( PathName );
    if( _Status != ERROR_SUCCESS ) 
        goto Cleanup;

    // Path to memory mapped file.
    cb = strlen(PathName);
    _FullPathName = (LPTSTR)CacheHeap->Alloc(cb + sizeof(DIR_SEPARATOR_STRING));

    if( _FullPathName == NULL ) 
    {
        _Status = ERROR_NOT_ENOUGH_MEMORY;
        INET_ASSERT(FALSE);
        goto Cleanup;
    }

    memcpy(_FullPathName, PathName, cb + 1);
    AppendSlashIfNecessary(_FullPathName, &cb);
    
    _FullPathNameLen = cb;

    // Construct memory mapped file name.
    _FileName = (LPTSTR)CacheHeap->Alloc(cb + sizeof(MEMMAP_FILE_NAME));
    if (!_FileName)
    {
        _Status = ERROR_NOT_ENOUGH_MEMORY;
        INET_ASSERT(FALSE);
        goto Cleanup;
    }
    memcpy(_FileName, _FullPathName, cb);
    memcpy(_FileName + cb, 
        MEMMAP_FILE_NAME, sizeof(MEMMAP_FILE_NAME));
    
    // Create/Open memory mapped file.
    _FileHandle =
        CreateFile(
            _FileName,
            GENERIC_READ | GENERIC_WRITE,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            CreateAllAccessSecurityAttributes(NULL, NULL, NULL),
            OPEN_ALWAYS,
            FILE_FLAG_RANDOM_ACCESS,
            NULL );

    _Status = GetLastError();

    if( _FileHandle ==  INVALID_HANDLE_VALUE ) 
    {
        _FileHandle = NULL;
        TcpsvcsDbgAssert(FALSE);
        goto Cleanup;
    }
    else
    {
        SetFileTime(_FileHandle, NULL, NULL, (LPFILETIME)&dwdwSessionStartTime);
    }

    // Check to this file is new.
    if ( _Status == ERROR_ALREADY_EXISTS ) 
    {

        // Old file.

        _Status = ERROR_SUCCESS;
       _NewFile = FALSE;

       _FileSize = GetFileSize( _FileHandle, NULL );

       if( _FileSize == 0xFFFFFFFF ) 
       {
           _Status = GetLastError();
           TcpsvcsDbgAssert(FALSE);
           goto Cleanup;
       }

       if ((_FileSize < GlobalMapFileGrowSize) || ((_FileSize %GlobalMapFileGrowSize) != 0)) 
       {
            TcpsvcsDbgAssert(FALSE);
            if(!Reinitialize()) 
            {
                TcpsvcsDbgAssert(FALSE);
                SetLastError(_Status);
                goto Cleanup;
            }
            // Reinitialization results in new file.
            _NewFile = TRUE;
       }
    }
    else if( _Status == ERROR_SUCCESS) 
    {
        BOOL BoolError;
        DWORD FilePointer;

        // New file.
        _NewFile = TRUE;

        // Set initial file size.
        _FileSize = GlobalMapFileGrowSize;
        FilePointer = SetFilePointer( _FileHandle, _FileSize, NULL, FILE_BEGIN );

        if( FilePointer == 0xFFFFFFFF ) 
        {
            _Status = GetLastError();
            goto Cleanup;
        }

        if (FilePointer != _FileSize )
        {
            TcpsvcsDbgPrint(( DEBUG_FILE_VALIDATE,
                    "FilePointer != (_FileSize)\n" ));

            TcpsvcsDbgAssert(FALSE);
        }

        BoolError = SetEndOfFile( _FileHandle );

        if( BoolError != TRUE ) 
        {
            _Status = GetLastError();
            goto Cleanup;
        }
    }
    else 
    {
        // We should not reach here.
        TcpsvcsDbgAssert(FALSE);
    }
    _Status = RemapAddress();

    if( _Status != ERROR_SUCCESS ) 
    {
        TcpsvcsDbgAssert(FALSE);
        goto Cleanup;
    }

    TcpsvcsDbgPrint(( DEBUG_ERRORS,
                        "Header Size, %ld.\n",
                    HEADER_ENTRY_SIZE));

    TcpsvcsDbgPrint(( DEBUG_ERRORS,
                        "Size of elements, %ld.\n",
                        sizeof(MEMMAP_HEADER_SMALL)));


    TcpsvcsDbgPrint(( DEBUG_ERRORS,
                        "Bit Array size, %ld.\n",
                    BIT_MAP_ARRAY_SIZE));

    TcpsvcsDbgPrint(( DEBUG_ERRORS,
                        "Memmap Header Size, %ld.\n",
                    sizeof(MEMMAP_HEADER)));

    TcpsvcsDbgAssert( HEADER_ENTRY_SIZE >= sizeof(MEMMAP_HEADER) );

    // validate the file content if the file is not new.
    if( _NewFile != TRUE ) 
    {
        if( ValidateCache() == FALSE) 
        {
            if (!Reinitialize()) 
            {
                _Status = ERROR_WINHTTP_INTERNAL_ERROR;
                goto Cleanup;
            }

            // Succeeded in re-initializing the file, we 
            // treat this as if we created a new file.
            _NewFile = TRUE;
        }
    }
    else
    {
        // It is a brand new file. Initialize file header.
        if(!InitHeaderInfo()) 
        {
            // This can happen if there is an exception while
            // initializing headers
            _Status = ERROR_WINHTTP_INTERNAL_ERROR;
            goto Cleanup;

        }
    }

    // Compute number of bitmap DWORDs used.
    _NumBitMapDWords =
        (_HeaderInfo->NumUrlInternalEntries + (NUM_BITS_IN_DWORD - 1)) /
            NUM_BITS_IN_DWORD; //cell

    // We are done.
    _Status = ERROR_SUCCESS;

Cleanup:

    if( _Status != ERROR_SUCCESS ) 
    {
        INET_ASSERT(FALSE);
        TcpsvcsDbgPrint(( DEBUG_ERRORS,
            "MEMMAP_FILE::Initfailed, %ld\n", _Status ));
        
        SetLastError(_Status);
    }

    if (_NewFile)
        return MEMMAP_STATUS_REINITIALIZED;
    else
        return MEMMAP_STATUS_OPENED_EXISTING;
}

MEMMAP_FILE::~MEMMAP_FILE(
    VOID
    )
/*++

Routine Description:

    MEMMAP_FILE object destructor.

Arguments:

    None.

Return Value:

    None.

--*/
{
    CloseMapping();
    CacheHeap->Free( _FileName );
    CacheHeap->Free( _FullPathName );
}


BOOL MEMMAP_FILE::ReAllocateEntry(LPFILEMAP_ENTRY pEntry, DWORD cbBytes)
/*++

Routine Description:

    Attempts to reallocate an entry at the location given.

Arguments:

    LPFILEMAP_ENTRY pEntry: Pointer to location in file map.
    DWORD cbBytes : Number of bytes requested

Return Value:

    Original value of pEntry if successful. pEntry->nBlocks is set to the new
    value, but all other fields in the entry are unmodified. If insufficient contiguous 
    bits are found at the end of the original entry, NULL is returned, indicating failure.
    In this case the entry remains unmodified. 

Notes:
    
    The Map file should *not* be grown if insufficient additional bits are not found.

--*/
{
    // Validate cbBytes
    if (cbBytes > MAX_ENTRY_SIZE)
    {
        INET_ASSERT(FALSE);
        return FALSE;
    }

    // Validate pEntry.
    DWORD cbEntryOffset = (DWORD) PtrDifference(pEntry, _EntryArray);
    if (IsBadOffset(cbEntryOffset))
    {
        INET_ASSERT(FALSE);
        return FALSE;
    }

    // Calculate number of blocks required for this entry.
    DWORD nBlocksRequired = NUMBLOCKS(ROUNDUPBLOCKS(cbBytes));
    
    // Sufficient space in current slot?
    if (nBlocksRequired <= pEntry->nBlocks)
    {
        // We're done.
        return TRUE;
    }
    else
    {           
        // Determine if additional free bits are 
        // available at the end of this entry.
        // If not, return NULL.

        // Determine the array and bit indicese of the first
        // free bit immediately following the last set bit of
        // the entry.
        DWORD nTrailingIndex = cbEntryOffset / _EntrySize + pEntry->nBlocks;
        DWORD nArrayIndex = nTrailingIndex / NUM_BITS_IN_DWORD;
        DWORD nBitIndex = nTrailingIndex % NUM_BITS_IN_DWORD;
        DWORD dwMask = 0x1 << nBitIndex;
        DWORD nAdditionalBlocksRequired = nBlocksRequired - pEntry->nBlocks;
        DWORD nBlocksFound;

        // Don't exceed the number of internal entries.
        if (nTrailingIndex + nAdditionalBlocksRequired 
            > _HeaderInfo->NumUrlInternalEntries)
        {
            // Overstepped last internal entry. Here we should fail
            // by returning NULL. Note - DO NOT attempt to grow the 
            // map file at this point. The caller does not expect this.
            return FALSE;
        }

        if (CheckNextNBits(nArrayIndex, dwMask, 
            nAdditionalBlocksRequired, nBlocksFound))
        {
            // We were able to grow the entry.
            SetNextNBits(nArrayIndex, dwMask, nAdditionalBlocksRequired);
            pEntry->nBlocks = nBlocksRequired;
            _HeaderInfo->NumUrlEntriesAlloced += nAdditionalBlocksRequired;
            return TRUE;
        }
        else
            // Couldn't grow the entry.
            return FALSE;
    }
}

LPFILEMAP_ENTRY MEMMAP_FILE::AllocateEntry(DWORD cbBytes)
/*++

Routine Description:

    Member function that returns an free entry from the cache list. If
    none is available free, it grows the map file, makes more free
    entries.

Arguments:

    DWORD cbBytes : Number of bytes requested
    DWORD cbOffset: Offset from beginning of bit map where allocation is requested.

Return Value:

    If NULL, GetStatus() will return actual error code.

--*/
{
    LPFILEMAP_ENTRY NewEntry;

    // Validate cbBytes
    if (cbBytes > MAX_ENTRY_SIZE)
    {
        INET_ASSERT(FALSE);
        return 0;
    }

    // Find and mark off a set of contiguous bits
    // spanning the requested number of bytes.
    DWORD nBlocksRequired = NUMBLOCKS(ROUNDUPBLOCKS(cbBytes));
    DWORD FreeEntryIndex = GetAndSetNextFreeEntry(nBlocksRequired);

    // Failed to find space.
    if( FreeEntryIndex == 0xFFFFFFFF ) 
    {
        // Map file is full, grow it now.
        _Status = GrowMapFile(cbBytes <= GlobalMapFileGrowSize ?
            GlobalMapFileGrowSize : ROUNDUPTOPOWEROF2(cbBytes, ALLOC_PAGES * PAGE_SIZE) );

        // Failed to grow map file.
        if( _Status != ERROR_SUCCESS ) 
        {
            return NULL;
        }

        // Retry with enlarged map file.
        FreeEntryIndex = GetAndSetNextFreeEntry(nBlocksRequired);

        TcpsvcsDbgAssert( FreeEntryIndex != 0xFFFFFFFF );

        // Failed to allocate bytes after enlarging map file.
        if( FreeEntryIndex == 0xFFFFFFFF ) 
        {
            return NULL;
        }
    }

    INET_ASSERT(  (cbBytes < PAGE_SIZE) 
        || ( (cbBytes >= PAGE_SIZE) && !((_EntrySize * FreeEntryIndex) % PAGE_SIZE)) );
    
    // Cast the memory.
    NewEntry = (LPFILEMAP_ENTRY)
        (_EntryArray + _EntrySize * FreeEntryIndex);
    
    // Mark the allocated space.
    #ifdef DBG
        ResetEntryData(NewEntry, SIG_ALLOC, nBlocksRequired);
    #else
        NewEntry->dwSig = SIG_ALLOC;
    #endif // DBG

    // Set the number of blocks in the entry.
    NewEntry->nBlocks = nBlocksRequired;
        
    return NewEntry;
}


BOOL MEMMAP_FILE::FreeEntry(LPFILEMAP_ENTRY Entry)
/*++

    This public member function frees up a file cache entry.

Arguments:

    UrlEntry : pointer to the entry that being freed.

Return Value:

    TRUE - if the entry is successfully removed from the cache.
    FALSE - otherwise.

--*/
{
    DWORD nIndex, nArrayIndex, 
        nOffset, nBlocks, BitMask;

    LPDWORD BitMap;

    //
    // Validate the pointer passed in.
    //
    if( ((LPBYTE)Entry < _EntryArray) 
        || ((LPBYTE)Entry >=
           (_EntryArray + _EntrySize *
           _HeaderInfo->NumUrlInternalEntries) ) ) 
    {
        TcpsvcsDbgAssert(FALSE);
        return FALSE;
    }

    // Compute and check offset (number of bytes from start).
    nOffset = (DWORD) PtrDifference(Entry, _EntryArray);
    if( nOffset % _EntrySize ) 
    {
        // Pointer does not point to a valid entry.
        TcpsvcsDbgAssert(FALSE);
        return FALSE;
    }
    
    nBlocks = Entry->nBlocks;

    if (nBlocks > (MAX_ENTRY_SIZE / NORMAL_ENTRY_SIZE))
    {
        INET_ASSERT(FALSE);
        return FALSE;
    }

    // Compute indicese
    nIndex = nOffset / _EntrySize;
    nArrayIndex = nIndex / NUM_BITS_IN_DWORD;

    //
    // Unmark the index bits in the map.
    //

    BitMap = &_HeaderInfo->AllocationBitMap[nArrayIndex];
    BitMask = 0x1 << (nIndex % NUM_BITS_IN_DWORD);
    for (DWORD i = 0; i < nBlocks; i++)
    {
        // Check we don't free unset bits
        if (!(*BitMap & BitMask))
        {
            TcpsvcsDbgPrint(( DEBUG_ERRORS, "Attempted to free unset bits. Ignoring...\n"));
            return FALSE;
        }

        *BitMap &= ~BitMask;
        BitMask <<= 1;
        if (BitMask == 0x0)
        {
            BitMask = 0x1;
            BitMap = &_HeaderInfo->AllocationBitMap[++nArrayIndex];
        }
    }

    // Mark the freed space.
    ResetEntryData(Entry, SIG_FREE, nBlocks);

    // Reduce the count of allocated entries.
    TcpsvcsDbgAssert(_HeaderInfo->NumUrlEntriesAlloced  > 0);
    _HeaderInfo->NumUrlEntriesAlloced -= nBlocks;

return TRUE;
}


BOOL
MEMMAP_FILE::Reinitialize(void)
/*++

    This  member function reinitializes a cache index file

Arguments:



Return Value:

    Windows error code


--*/
{
    TcpsvcsDbgAssert( _FileHandle != NULL );

    // Close view, mapping, and file.
    CloseMapping();
    
    BOOL BoolError, fReinited = FALSE;
    DWORD FilePointer;

    // If we're re-initialising, that means we're losing all our cached data. 
    // Time to delete all the old stuff

    // But wait -- we only want to do this for the content cache, since we can regen
    // the index from the cookies, and history stores all its info in index file
    // We'll check for "content.ie5" in the path

    if (StrStrI(_FullPathName, "content.ie5"))
    {
        DeleteCachedFilesInDir(_FullPathName);
    }

    // check for exclusive access, we do this by opening the
    // file in exclsive mode, if we succeed we are the only one
    _FileHandle = CreateFile
        (
            _FileName,
            GENERIC_WRITE,
            0,    // no read/write sharing
            CreateAllAccessSecurityAttributes(NULL, NULL, NULL),
            OPEN_ALWAYS,
            FILE_ATTRIBUTE_NORMAL,
            NULL
        );

    if (_FileHandle == INVALID_HANDLE_VALUE)
        _FileHandle = NULL;
    else
    {
        DWORD FilePointer = SetFilePointer
            ( _FileHandle, GlobalMapFileGrowSize, NULL, FILE_BEGIN);
    
        if( FilePointer != 0xFFFFFFFF)
        {
            if (SetEndOfFile (_FileHandle))
            {
                // Success!
                _FileSize = GlobalMapFileGrowSize;
                fReinited = TRUE;
            }
            else
            {
                TcpsvcsDbgPrint(( DEBUG_ERRORS, "SetEndOfFile failed: %u\n",
                    GetLastError()));
            }
        }            

        // Following will be done by RemapAddress calling CloseMapping
        // CloseHandle (_FileHandle);
        // _FileHandle = NULL
    }

    // Re-attach to the file.

    _Status = RemapAddress();

    if( _Status != ERROR_SUCCESS )
    {
        TcpsvcsDbgPrint(( DEBUG_ERRORS,
            "Reinitialize:Remap failed, %ld.\n",_Status));
        TcpsvcsDbgAssert( FALSE );
        goto Cleanup;
    }

    if (fReinited)
    {
        // if there is an exception due to bad sector, this will set
        // _status to something other than ERROR_SUCCESS
        if(!InitHeaderInfo()) 
            goto Cleanup;

        _NumBitMapDWords =
            (_HeaderInfo->NumUrlInternalEntries + (NUM_BITS_IN_DWORD - 1)) /
                NUM_BITS_IN_DWORD; // cell
    }

Cleanup:

    return fReinited;
}

BOOL
MEMMAP_FILE::InitHeaderInfo()
/*++

    This  member function intializes the memorymapped headerinfo
    structure

Arguments:



Return Value:

    None

--*/
{
    //
    // initialize file header.
    //
    BOOL fSuccess = TRUE;

    __try {
        TcpsvcsDbgAssert( _HeaderInfo != NULL );

        memcpy(_HeaderInfo->FileSignature, CACHE_SIGNATURE, sizeof(CACHE_SIGNATURE));

        _HeaderInfo->FileSize = _FileSize; // set file size in the memmap file.
        _HeaderInfo->dwHashTableOffset = 0;
        _HeaderInfo->CacheSize = (LONGLONG)0;
        _HeaderInfo->CacheLimit = (LONGLONG)0;
        _HeaderInfo->ExemptUsage = (LONGLONG)0;
        _HeaderInfo->nDirCount = 0;
        
        for (int i = 0; i < DEFAULT_MAX_DIRS; i++)
        {
            _HeaderInfo->DirArray[i].nFileCount = 0;
            _HeaderInfo->DirArray[i].sDirName[0] = '\0';
        }
        
        _HeaderInfo->NumUrlInternalEntries =
            ((_FileSize - HEADER_ENTRY_SIZE ) /
                _EntrySize );

        _HeaderInfo->NumUrlEntriesAlloced = 0;

        memset( _HeaderInfo->AllocationBitMap, 0,  sizeof(_HeaderInfo->AllocationBitMap) );
        memset( _EntryArray, 0, (_FileSize - HEADER_ENTRY_SIZE) );
        memset( _HeaderInfo->dwHeaderData, 0, sizeof(DWORD) * NUM_HEADER_DATA_DWORDS);

        _Status = ERROR_SUCCESS;
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {

        _Status = ERROR_WRITE_FAULT;
        fSuccess = FALSE;
    }
    ENDEXCEPT

    return (fSuccess);
}

LPFILEMAP_ENTRY MEMMAP_FILE::FindNextEntry (DWORD* pdwEnum, DWORD dwFilter, GROUPID GroupId, DWORD dwMatch)
{
    while (1)
    {
        // Get the next item in the hash table.
        HASH_ITEM *pItem = HashGetNextItem (this, (LPBYTE)_BaseAddr, pdwEnum, 0);
        if (!pItem)
            return NULL;

        // continue if search entry within group but hash bit says no group 
        // (may avoid unnecessary page hit by pulling non-relevent pEntry)
        if( GroupId && !pItem->HasGroup() )
            continue;

            
        // Get the entry from the item.
        URL_FILEMAP_ENTRY* pEntry = ValidateUrlOffset (pItem->dwOffset);
        if (!pEntry)
        {
            pItem->MarkFree();
            continue;
        }
        
        // No filter - continue enum until ERROR_NO_MORE_ITEMS.
        if (!dwFilter)
            continue;

        // IDENTITY_CACHE_ENTRY is an identity-specific entry.
        // We don't want these to be shown inappropriately to a client.
        // We may want to be able to display all of these for debug, though.
        if ((pEntry->CacheEntryType & IDENTITY_CACHE_ENTRY)
            && ((pEntry->dwIdentity != dwMatch)
                || (!pEntry->dwIdentity)))
            continue;

        DWORD cet = pEntry->CacheEntryType & ~IDENTITY_CACHE_ENTRY;
        
        // Temporary hack to always show 1.1 entries 
        // until we have a better way of dealing with them.
        dwFilter |= INCLUDE_BY_DEFAULT_CACHE_ENTRY;

        // Continue enum if no match on cache entry type.
        if ((dwFilter & cet) != cet)
            continue;

        // Continue enum if no match on group.
        if (GroupId ) 
        {
            if( pItem->HasMultiGroup() )
            {
                // need to search the list
                LIST_GROUP_ENTRY*   pListGroup = NULL;
                pListGroup = ValidateListGroupOffset(pEntry->dwGroupOffset);
                if( !pListGroup )
                    continue;

                BOOL fFoundOnList = FALSE;
                while( pListGroup && pListGroup->dwGroupOffset )
                {
                    GROUP_ENTRY* pGroup = NULL;
                    pGroup = ValidateGroupOffset( 
                                pListGroup->dwGroupOffset, pItem); 
                    if( !pGroup )
                    {
                        break;
                    }

                    if( GroupId ==  pGroup->gid )
                    {
                        fFoundOnList = TRUE;
                        break;
                    }

                    if( !pListGroup->dwNext )
                    {
                        break;
                    }

                    // next group on list
                    pListGroup = ValidateListGroupOffset(pListGroup->dwNext);
                }
               
                if( !fFoundOnList )
                    continue; 

            }
            else if( GroupId != 
                        ((GROUP_ENTRY*)( (LPBYTE)_BaseAddr + 
                                 pEntry->dwGroupOffset))->gid ) 
            { 
                continue;
            }

        }

        return (LPFILEMAP_ENTRY) (((LPBYTE)_BaseAddr) + pItem->dwOffset);
    }
}

BOOL MEMMAP_FILE::IsBadOffset (DWORD dwOffset)
{

    ASSERT_ISPOWEROF2 (_EntrySize);
    return (dwOffset == 0
        || (dwOffset & (_EntrySize-1))
        || (dwOffset >= _FileSize));

    return FALSE;

}


BOOL MEMMAP_FILE::IsBadGroupOffset (DWORD dwOffset)
{
    return (dwOffset == 0 || (dwOffset >= _FileSize));
    return FALSE;
}


GROUP_ENTRY* MEMMAP_FILE::ValidateGroupOffset (DWORD dwOffset, HASH_ITEM* hItem)
{
    GROUP_ENTRY *pEntry = NULL;

    // if hash item is available, check the group bit first.
    if( hItem && !hItem->HasGroup())
    {
        return NULL;
    }

    // check the offset 
    if (IsBadGroupOffset (dwOffset))
    {
        INET_ASSERT (FALSE);
        return NULL;
    }

    //
    // Validate page signature.
    // since we know all the allocated page are aligned with
    // 4K boundary, so from the offset, we can get the 
    // the offset of this page by:
    //   pageOffset = Offset - Offset(mod)4K
    //

    DWORD dwOffsetInPage = dwOffset & 0x00000FFF;
    FILEMAP_ENTRY* pFM = (FILEMAP_ENTRY*) 
        ( (LPBYTE)_BaseAddr + dwOffset - dwOffsetInPage );
    
    // Get the Group.
    if( pFM->dwSig == SIG_ALLOC && pFM->nBlocks )
    {
        pEntry = (GROUP_ENTRY *) ((LPBYTE) _BaseAddr + dwOffset);
    }
    
    return pEntry;
}



URL_FILEMAP_ENTRY* MEMMAP_FILE::ValidateUrlOffset (DWORD dwOffset)
{
    // Validate offset.
    if (IsBadOffset (dwOffset))
    {
        INET_ASSERT (FALSE);
        return NULL;
    }

    // Validate signature.
    URL_FILEMAP_ENTRY *pEntry =
        (URL_FILEMAP_ENTRY *) ((LPBYTE) _BaseAddr + dwOffset);
    if (pEntry->dwSig != SIG_URL)
    {
        INET_ASSERT (FALSE);
        return NULL;
    }
    
    // TODO: validate entry offsets, string terminations etc.
    return pEntry;
}


LIST_GROUP_ENTRY* MEMMAP_FILE::ValidateListGroupOffset (DWORD dwOffset)
{
    LIST_GROUP_ENTRY *pEntry = NULL;

    // Validate offset.
    if (IsBadGroupOffset (dwOffset))
    {
        INET_ASSERT (FALSE);
        return NULL ;
    }

    //
    // Validate page signature.
    // since we know all the allocated page are aligned with
    // 4K boundary, so from the offset, we can get the 
    // the offset of this page by:
    //   pageOffset = Offset - Offset(mod)4K
    //

    DWORD dwOffsetInPage = dwOffset & 0x00000FFF;
    FILEMAP_ENTRY* pFM = (FILEMAP_ENTRY*) 
        ( (LPBYTE)_BaseAddr + dwOffset - dwOffsetInPage );
    

    if( pFM->dwSig == SIG_ALLOC && pFM->nBlocks )
    {
        pEntry = (LIST_GROUP_ENTRY*) ((LPBYTE) _BaseAddr + dwOffset);
    }
    
    return pEntry;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\urlcache\downsize.cxx ===
/*++
Copyright (c) 1997  Microsoft Corp.

Module Name: downsize.cxx

Abstract:

    Implementation of heuristic pruning and wholesale purge of cache index.

Author:

    Rajeev Dujari (rajeevd) 15-Apr-97

    RajeevD rewrote scoring and pruning algo, Aug-98.

--*/

#include <wininetp.h>
#include <cache.hxx>

#ifdef BETA_LOGGING
#define SCAVENGER_TRACE
#define TRACE_FACTOR 99
#endif


BOOL // whether memory mapped index file was deleted
URL_CONTAINER::DeleteIndex (void)
{                                        
    BOOL fRetVal = FALSE;
    BOOL fMustUnlock;

    // Get the full path name of the cache directory.
    if (!LockContainer(&fMustUnlock))
        goto exit;

    CHAR szFullPath[MAX_PATH];
    memcpy(szFullPath, _UrlObjStorage->GetFullPathName(),
        _UrlObjStorage->GetFullPathNameLen() + 1);

    if (fMustUnlock)
    {
        UnlockContainer();
        fMustUnlock = FALSE;
    }

    // Delete the cache files not in use (index.dat is open by us)
    CFileMgr::DeleteCache (szFullPath);

    if (!(GetOptions() & INTERNET_CACHE_CONTAINER_NODESKTOPINIT))
        EnableCacheVu(szFullPath);


    if (!LockContainer(&fMustUnlock))
        goto exit;

#ifdef NUKE_CACHE_INDEX_FILE

    // If no handles are actively in use by this process,
    // attempt to shrink the index file.
    if (!AnyFindsInProgress(0) && !GlobalRetrieveUrlCacheEntryFileCount)
    {

        LONGLONG qwLimit = _UrlObjStorage->GetCacheLimit();
        fRetVal = _UrlObjStorage->Reinitialize();
        if (fRetVal)
        {
            _UrlObjStorage->SetCacheLimit (qwLimit);
            _FileManager->Init();
            // BUGBUG: call SetCacheSize with total not deleted by DeleteCache.

        }
    }

#endif

exit:
    if (fMustUnlock)
        UnlockContainer();
    return fRetVal;
}

// Weightings of various score components...
#define IDLETIME_WEIGHT     (60000)
#define EXPIRY_WEIGHT       ( 3000)
#define NUMACCESS_WEIGHT    ( 3000)

/*=======================================================================
ScoreEntry computes the score for the given url entry.

    The lower the score the more likely is an entry to be
    removed from the cache. Entries with higher scores are
    considered more useful.  Only the relative values matter.

    The components that contribute to the score are as follows...
        idle time since last access
        number of times accessed
        expiry, last-modified, and other sync factors
    They are weighted so that idle time predominates if the
    item has been accessed recently while older items are
    more easily influenced by the other factors.

    IDLE TIME is measured as number of days since last access,
    not rounded to an integer but including a fraction.  Then
    the score decays as 1/(days+1).  To illustrate:

        Elapsed Time    Rel. Score
        ============    ==========
        0                   60
        12 hours            40
        1 day               30
        1.5 days            24
        2 days              20
        5 days              10
        9 days               6
        29 days              2
        30-59 days           1
        60+ days             0

    NUMBER OF TIMES ACCESSED is a predictor of both the likelihood
    the item will ever be accessed again and the frequency of future
    access.  This subscore is scaled by (1 - 1/num).  For example:

        Num         Rel. Score
        ===         ==========
         1               0
         2              10
         4              15
        10              18
        20+             20

    EXPIRY in the future is worth full credit because we need
    not issue if-modified-since requests (except upon refresh.)

    Similarly, an item which is approaching SYNCSTATE_VOLATILE
    gets checked rarely and gets nearly full credit.  Items on
    the way to approaching this state get pro-rated credit.

    An expiry in the past is treated same has no expiry at all.

    An item gets half credit if last-modified-time is set.
    Otherwise any net hit would download  new content so the
    cache entry is of limited value.

    To summarize:

        Expiry  LastMod SyncState   Rel. Score
        ======  ======= =========   ==========
        future  n/a     n/a             14
        other   present static          13
        other   present image            8
        other   present volatile         7
        other   none    n/a              0

    We are agnostic about file size.  Pruning a larger file means
    we reclaim a lot of disk space, but it takes longer to download.
    Small files often waste a lot of disk space on a FAT partition,
    but incur the same fixed cost as downloading a large file.

Arguments:
    pEntry :  pointer to the Url entry.
    CurrentGmtTime : Current GMT time.

Return Value: DWORD score.
=======================================================================*/
DWORD ScoreEntry
(
    URL_FILEMAP_ENTRY* pEntry,
    LONGLONG CurrentGmtTime
)
{
    INET_ASSERT(pEntry->dwSig == SIG_URL);

    // Compute scored based on days since last access.

    // We're adding 15 minutes to the CurrentGmtTime to account for the continual 
    // readjustments to the pc's internal clock; this will handle occasional blips
    // (cases when the gmt is suddenly earlier than the LastAccessedTime, for example)
    CurrentGmtTime += (15*60*FILETIME_SEC);

    LONGLONG IdleTime = CurrentGmtTime - pEntry->LastAccessedTime;

    // In case the Last Accessed Time is later than the GMT, we want to protect against
    // a negative time
    if (IdleTime < 0)
    {
        IdleTime = 0;
    }

    DWORD dwScore = (DWORD) (((LONGLONG) IDLETIME_WEIGHT * FILETIME_DAY)
        / (IdleTime + FILETIME_DAY));

#ifdef UNIX
    {
       /* We don't want to delete items that were just created.
        * On Win32, because the InternetLockRequestFile will hold onto
        * the entries. This will not work on Unix because they use
        * InternetLockRequestFile uses CreateFile, which does not really
        * lock the file on unix, because of the lack of file handles.
        * 
        * So, just like in IE4, we will give a grace period for the cache
        * item.
        */
       #define UNIX_STICKY_SCORE 0L
       if (IdleTime < (1 * 60 * (LONGLONG)10000000))
          return UNIX_STICKY_SCORE;
    }
#endif /* UNIX */

    // Add to score based on number of times accessed.
    DWORD dwAccess = pEntry->NumAccessed;
    if (!dwAccess)
    {
        INET_ASSERT (pEntry->NumAccessed);
        dwAccess = 1;
    }
    dwScore += NUMACCESS_WEIGHT - NUMACCESS_WEIGHT/dwAccess;

    // Add to score based on expiry and syncstate.
    FILETIME ftExpireTime;
    DosTime2FileTime(pEntry->dostExpireTime, &ftExpireTime);
    if (FT2LL(ftExpireTime) > CurrentGmtTime)
        dwScore += EXPIRY_WEIGHT;
    else if (pEntry->LastModifiedTime)
    {
        // Add a bonus for having a last-modified time.
        dwScore += EXPIRY_WEIGHT / 2;

        // Add more as the item approaches auto sync mode.
        INET_ASSERT (pEntry->bSyncState <= SYNCSTATE_STATIC);
        dwScore += (EXPIRY_WEIGHT * pEntry->bSyncState)
            / (2 * (SYNCSTATE_STATIC + 1));
    }

    INET_ASSERT (dwScore <=
        IDLETIME_WEIGHT + EXPIRY_WEIGHT + NUMACCESS_WEIGHT);
    return dwScore;
}


/*=======================================================================
WalkLeakList attempts to delete files that we couldn't delete earlier.
========================================================================*/
BOOL URL_CONTAINER::WalkLeakList (void)
{
    BOOL fMustUnlock;
    LockContainer(&fMustUnlock);

    // Set loop variables to head of list.
    DWORD dwPrevOffset = OffsetFromPointer(_UrlObjStorage->GetPtrToLeakListOffset());
    DWORD dwCurrOffset, dwFirstItemOffset;
    _UrlObjStorage->GetHeaderData(CACHE_HEADER_DATA_ROOT_LEAK_OFFSET,
                                  &dwCurrOffset);

    // Validate offset and block signature.
    URL_FILEMAP_ENTRY* pEntry = (URL_FILEMAP_ENTRY*) PointerFromOffset (dwCurrOffset);
    if (_UrlObjStorage->IsBadOffset (dwCurrOffset)
        || pEntry->dwSig != SIG_LEAK)
    {
        INET_ASSERT(dwCurrOffset==0);
        
        // Replace the bad link with a terminator.
        _UrlObjStorage->SetHeaderData(CACHE_HEADER_DATA_ROOT_LEAK_OFFSET, 
                                      0);
        return fMustUnlock;
    }
    dwFirstItemOffset = dwCurrOffset;
    
    while (1)
    {
        // Extract full path of the file.
        // and attempt to delete the file.
        DWORD cb;
        TCHAR szFile[MAX_PATH];

        if (_FileManager->GetFilePathFromEntry(pEntry, szFile, &(cb = MAX_PATH))
            &&
            (!pEntry->NumReferences)
            &&
            (_FileManager->DeleteOneCachedFile
                (szFile, pEntry->dostFileCreationTime, pEntry->DirIndex)))
        {
            // Adjust cache usage.
            _UrlObjStorage->AdjustCacheSize(-RealFileSize(pEntry->dwFileSize));

            // Remove this item from the list.
            LPDWORD pdwPrev = (LPDWORD) PointerFromOffset (dwPrevOffset);
            *pdwPrev = pEntry->dwNextLeak;

            if (dwFirstItemOffset==dwCurrOffset)
            {
                _UrlObjStorage->SetHeaderData(CACHE_HEADER_DATA_ROOT_LEAK_OFFSET,
                                  pEntry->dwNextLeak);
            }
            if( dwCurrOffset != pEntry->dwNextLeak )
            {
                dwCurrOffset = pEntry->dwNextLeak;
            }
            else
            {
                // we have a circular list, break now
                // Replace the bad link with a terminator.
                dwCurrOffset = 0;
                LPDWORD pdwPrev = (LPDWORD) PointerFromOffset (dwPrevOffset);
                *pdwPrev = 0;
            }

            _UrlObjStorage->FreeEntry(pEntry);
        }
        else
        {
            // We don't have permission to delete this entry
            dwPrevOffset = OffsetFromPointer (&pEntry->dwNextLeak);
            if( dwCurrOffset != pEntry->dwNextLeak )
            {
                dwCurrOffset = pEntry->dwNextLeak;
            }
            else
            {
                // we have a circular list, break now
                // Replace the bad link with a terminator.
                dwCurrOffset = 0;
                LPDWORD pdwPrev = (LPDWORD) PointerFromOffset (dwPrevOffset);
                *pdwPrev = 0;
            }
        }
    
        // If the shutdown event signalled, call it quits.
        // Also, if we've reached the end of the list, quit
        if (GlobalPleaseQuitWhatYouAreDoing || (dwCurrOffset==0))
            break;

        pEntry = (URL_FILEMAP_ENTRY*) PointerFromOffset (dwCurrOffset);
        if (_UrlObjStorage->IsBadOffset (dwCurrOffset)
            || pEntry->dwSig != SIG_LEAK)
        {
            // Replace the bad link with a terminator.
            INET_ASSERT (FALSE);
            LPDWORD pdwPrev = (LPDWORD) PointerFromOffset (dwPrevOffset);
            *pdwPrev = 0;
            break;
        }
        pEntry->NumReferences++;

        // Relinquish the lock and time slice so other threads don't get starved.
        if (fMustUnlock)
        {
            UnlockContainer();
            fMustUnlock = FALSE;
        }

        SuspendCAP();
        Sleep (0);
        ResumeCAP();

        LockContainer(&fMustUnlock);
        _UrlObjStorage->GetHeaderData(CACHE_HEADER_DATA_ROOT_LEAK_OFFSET,
                                  &dwFirstItemOffset);
        pEntry = (URL_FILEMAP_ENTRY*) PointerFromOffset (dwCurrOffset);
        pEntry->NumReferences--;
    }

    return fMustUnlock;
}

/*=======================================================================
IsUrlEntryExemptFromScavenging filters out items exempt from scavenging.

Returns BOOL: TRUE indicating the item should not be scavenged.
========================================================================*/
BOOL URL_CONTAINER::IsUrlEntryExemptFromScavenging
(
    HASH_ITEM* pItem,
    URL_FILEMAP_ENTRY* pEntry,
    DWORD dwFilter,
    LONGLONG qwGmtTime,
    GroupMgr* pgm
)
{
    // If entry points to a store directory, ignore it.
    if ((pEntry->DirIndex == INSTALLED_DIRECTORY_KEY)
    || (pEntry->CacheEntryType & EDITED_CACHE_ENTRY))
    {
        return TRUE;
    }

    // If filter==0, trash everything, son.
    if (dwFilter==0)
    {
        return FALSE;
    }
    
    // If entry type excluded by filter, ignore it.
    if (pEntry->CacheEntryType & dwFilter)
        return TRUE;

    // If not deleting all entries, check for exemption from scavenging.
    if( pEntry->CacheEntryType & STICKY_CACHE_ENTRY)
    {
        // sticky + exemptDelta == 0 means sticky forever
        // because item must belong to non-purgeable group
        // or the cache entry type would not have sticky bit.
        if( !(pEntry->dwExemptDelta) )
            return TRUE;

        // sticky group == sticky forever! no exempt delta
        // needs to be looked.

        if( pEntry->dwGroupOffset )
        {
            if( pItem->HasMultiGroup() )
            {
                // multiple group
                // if there are other sticky groups attached to
                // this url entry, leave this entry alone
                if(!pgm->NoMoreStickyEntryOnList(pEntry->dwGroupOffset))
                    return TRUE;
            }
            else
            {
                // single group
                // if the group attached to this url entry is
                // sticky, leave this entry alone
                GROUP_ENTRY* pGroupEntry = NULL;
                pGroupEntry = _UrlObjStorage->ValidateGroupOffset
                    (pEntry->dwGroupOffset, pItem);
                if(pGroupEntry && IsStickyGroup(pGroupEntry->gid) )
                    return TRUE;
            }
        }

        // Skip over the item if it's within its exemption period.
        // FILETIME units are 100-ns ticks, exempt delta in seconds.

        LONGLONG qwExemptDelta = FILETIME_SEC * pEntry->dwExemptDelta;
        if (qwGmtTime < pEntry->LastAccessedTime + qwExemptDelta)
            return TRUE;
    }

    return FALSE;
}

/*=======================================================================
ScavengeItem deletes a cache entry and yields with the lock unowned.

Returns BOOL: FALSE if dll shutdown has been signalled.
========================================================================*/
BOOL URL_CONTAINER::ScavengeItem (HASH_ITEM* pItem, BOOL* pfMustUnlock)
{
    DeleteUrlEntry (HashGetEntry (pItem), pItem, SIG_DELETE);

    // If the shutdown event signalled, call it quits.
    if (GlobalPleaseQuitWhatYouAreDoing)
        return FALSE;

    // Relinquish the lock and time slice so other threads don't get starved.
    if (*pfMustUnlock)
    {
        UnlockContainer();
        *pfMustUnlock = FALSE;
    }

    SuspendCAP();
    Sleep (0);
    ResumeCAP();

    LockContainer(pfMustUnlock);
    return TRUE;
}


#define NUM_SCORE_ITEMS 100

//=======================================================================
#define FIND_MIN 1
#define FIND_MAX 0

PRIVATE SCORE_ITEM* FindMinOrMaxScoreItem
    (SCORE_ITEM* pScore, DWORD cScore, DWORD MinOrMax)
{
    INET_ASSERT (cScore);
    INET_ASSERT (MinOrMax == FIND_MIN || MinOrMax == FIND_MAX);

    SCORE_ITEM* pRet = pScore;
    DWORD dwScore = pScore->dwScore;

    for (DWORD iScore=1; iScore<cScore; iScore++)
    {
        pScore++;
        if ((dwScore < pScore->dwScore ? TRUE : FALSE) ^ MinOrMax)
        {
            pRet = pScore;
            dwScore = pScore->dwScore;
        }
    }

    return pRet;
}

//=======================================================================
PRIVATE void SwapScoreItems (SCORE_ITEM *p1, SCORE_ITEM *p2)
{
    SCORE_ITEM t;
    memcpy (&t, p1, sizeof(SCORE_ITEM));
    memcpy (p1, p2, sizeof(SCORE_ITEM));
    memcpy (p2, &t, sizeof(SCORE_ITEM));
}

//=======================================================================
PRIVATE void SortScoreItems (SCORE_ITEM* pScore, DWORD cScore)
{

    while (cScore > 1)
    {
        SCORE_ITEM *pMax =
            FindMinOrMaxScoreItem (pScore, cScore--, FIND_MAX);
        SwapScoreItems (pScore + cScore, pMax);
    }
}

//=======================================================================
void URL_CONTAINER::ScavengerDebugSpew
    (SCORE_ITEM* pScoreItem, LONGLONG* pqwDeleted)
{
    HASH_ITEM* pItem = (HASH_ITEM*)
        (*_UrlObjStorage->GetHeapStart() + pScoreItem->dwItemOffset);
    if (pScoreItem->dwHashValue == pItem->GetValue()
        && pScoreItem->dwHashOffset == pItem->dwOffset)
    {
        URL_FILEMAP_ENTRY* pEntry = HashGetEntry (pItem);
        char szBuf[1024];
        LPSTR pszOp;

        if (!pqwDeleted)
            pszOp = "IGNORE";
        else
        {
            pszOp = "DELETE";
            *pqwDeleted += RealFileSize (pEntry->dwFileSize);
        }

        wsprintf (szBuf, "%s %05d ", pszOp, pScoreItem->dwScore);
        OutputDebugString (szBuf);
        if (pqwDeleted)
        {
            wsprintf (szBuf, "%02d%% ", (*pqwDeleted * 100) / GetCacheLimit());
            OutputDebugString (szBuf);
        }
        PrintFileTimeInInternetFormat ((FILETIME*)
            &pEntry->LastAccessedTime , szBuf, sizeof(szBuf));
        OutputDebugString (szBuf);
        wsprintf (szBuf, " %s\n", ((LPSTR) pEntry) + pEntry->UrlNameOffset);
        OutputDebugString (szBuf);
    }
}


#ifndef SCAVENGER_TRACE
#define ScavengerTrace(x,y,z) { }
#else
#define ScavengerTrace(dwFactor, pScoreItem, pdwDel) \
    if (dwFactor==TRACE_FACTOR) {ScavengerDebugSpew(pScoreItem, pdwDel);}
#endif

/*========================================================================*/
DWORD URL_CONTAINER::FixupHandler (DWORD dwFactor, DWORD dwFilter)
{
    LOCK_CACHE();
    
    if (!g_pfnFixup)
    {
        // This is the first time we needed the handler; initialize.
        char szDll[MAX_PATH + 80];
        DWORD cbDll = sizeof(szDll);
        
        // Look up the fixup handler for the highest cache version installed.
        REGISTRY_OBJ roCache (HKEY_LOCAL_MACHINE, OLD_CACHE_KEY);
        if (ERROR_SUCCESS != roCache.GetStatus())
            goto err;
        if (ERROR_SUCCESS != roCache.GetValue (g_szFixup, (LPBYTE) szDll, &cbDll))
            goto err;
            
        LPSTR pszEntryPoint;

        // The dll name and entry point are delimited by a comma; tokenize.
        pszEntryPoint = StrChr (szDll, TEXT(','));
        if (!pszEntryPoint)
            goto err;
        *pszEntryPoint++ = 0;
        
        g_hFixup = LoadLibrary (szDll);
        if (!g_hFixup)
            goto err;
                
        g_pfnFixup = (PFN_FIXUP) GetProcAddress (g_hFixup, pszEntryPoint);
        if (!g_pfnFixup)
        {
            FreeLibrary (g_hFixup);
            goto err;
        }
    }

    UNLOCK_CACHE();
    
    return (*g_pfnFixup)
        (ENTRY_VERSION_CURRENT, _CachePath, _CachePrefix, 
        &GlobalPleaseQuitWhatYouAreDoing, dwFactor, dwFilter, NULL);

err:
    // We couldn't locate async fixup handler; fail gracefully.
    g_szFixup[0] = 0;
    UNLOCK_CACHE();
    return ERROR_WINHTTP_INTERNAL_ERROR;
}


/*=======================================================================
Routine Description:

Arguments:
    Factor : amount of free space to make. Factor of 25 means delete
        sufficient files to make CacheSize <= .75 * CacheLimit.

The index does not maintain a list of items sorted by score because the cost
of scavenging would be amortized across update operations, which are
performed on a foreground thread.  Such a list would be doubly linked because
updating an item would change its score and probably change its rank.  If the
items were directly linked together, this would likely result in touching two
other random pages on update.  A lookaside list would be a better approach
but would still require hitting another page on update or increasing the size
of the lookup hash table.  Furthermore, the ranking would need to be strictly
LRU, or else we would have to a 16-bit score in the entry and an updated item
might not go to the head of the list and require some traversal.

The scavenger thread scores items on the fly.  It attempts to avoid a full
enumeration of the cache and sorting of the scores.  Instead, it attempts to
track items that fall below a cutoff score and delete the lowest-scoring
among this set, possibly before completing the enumeration.  Specifically, it
starts by enumerating 100 items and sorting them.  Since the rank of the
items is uniformly distributed, by definition, the score of the 10th lowest
item is an estimate of the 10th percentile.  Of course, deleting 10% of the
items in the cache is no guarantee 10% of disk usage will be reclaimed.
However hitting the low-water mark of 90% of cache quota is not a strict goal
and will probably get the cache under the quota.  Even if not, the scavenger
will be invoked again on the next update and establish a higher cutoff.

If this cutoff score proves to be too low, then it's possible the scavenger
will enumerate the entire cache without bringing it below quota, in which
case it will be restarted by the next cache update, probably with a higher
threshhold.  On the other hand, if the cutoff score is too high, then we
might end the enumeration early and delete some items in the 20th or even
30th percentiles.  The latter outcome seems better since we never promised to
be perfect anyway, so we bias the algorithm by picking the 20th lowest
item for the threshhold score.

Once the cutoff score is established, the enumeration continues.  The list is
not kept sorted.  If all of the items in the 100-item list are below the
cutoff, then the lowest-scoring one is deleted.  Otherwise the highest-scoring
item is merely removed from the list and forgotten.  The the next item in the
enumeration is added to the list.  If the enumeration completes without
reaching the target usage, then the lowest-scoring item is deleted until the
list is empty, even those items that fall above the cutoff, which after all was
too low.

After each file deletion, the scavenger thread yields without holding the
container lock.  Otherwise another thread wanting to acquire the lock would
block, wake up the scavenger thread, and switch back after the scavenger
unlocked.

Return Value: ERROR_SUCCESS
========================================================================*/
DWORD URL_CONTAINER::CleanupUrls(DWORD dwFactor, DWORD dwFilter)
{
    DWORD Error = ERROR_SUCCESS;

    // dwFactor must be between 1 and 100 inclusive.
    INET_ASSERT (dwFactor >= 1 && dwFactor <= 100);

    // If an uplevel fixup handler is installed, delegate.

    if (g_szFixup[0])
        return FixupHandler (dwFactor, dwFilter);
    
    // Special case purging entire container.
    BOOL fPurge = (dwFactor == 100 && dwFilter == 0);
    if (fPurge && DeleteIndex())
        return ERROR_SUCCESS;

    // First loop through the leaked files and try to delete them.
    BOOL fMustUnlock = WalkLeakList();

    // before index get nuked, we need to send out last notification
    // about the whole cache gets deleted
    DWORD dwHWnd = 0;
    DWORD dwUMsg = 0;
    DWORD dwNotifFilter = 0;

    GroupMgr gm;
    if( !gm.Init(this) )
    {
        INET_ASSERT(FALSE);
    }

    BOOL fLowDiskSpace = FALSE;
    
    _UrlObjStorage->GetHeaderData(
            CACHE_HEADER_DATA_NOTIFICATION_FILTER, &dwNotifFilter);
    if( dwNotifFilter & CACHE_NOTIFY_DELETE_ALL)
    {
        _UrlObjStorage->GetHeaderData( CACHE_HEADER_DATA_NOTIFICATION_HWND, &dwHWnd);
        _UrlObjStorage->GetHeaderData( CACHE_HEADER_DATA_NOTIFICATION_MESG, &dwUMsg);
    }

    // Calculate usage goal.
    LONGLONG qwQuota = _UrlObjStorage->GetCacheLimit();
    LONGLONG qwGoal = (qwQuota * (100 - dwFactor)) / 100;
    LONGLONG qwGmtTime;
    GetCurrentGmtTime ((FILETIME*) &qwGmtTime);

    DWORDLONG dlAvail = 0;
    if (GetDiskInfo(_CachePath, NULL, &dlAvail, NULL)
        &&
        (BOOL)(dlAvail <= (DWORDLONG)GlobalDiskUsageLowerBound))
    {
        fLowDiskSpace = TRUE;
        // We'll set the goal even lower, if the disk space falls below the 4 GIG threshold
        // qwResult contains how much disk space would be available with the current goal
        LONGLONG qwResult = dlAvail + (_UrlObjStorage->GetCacheSize() - qwGoal);
        if (qwResult < (LONGLONG)GlobalDiskUsageLowerBound)
        {
            qwGoal = _UrlObjStorage->GetCacheSize() - ((LONGLONG)(GlobalDiskUsageLowerBound - dlAvail));

            // At the very least, we'll preserve 128K (about three pages)
            if (qwGoal<(LONGLONG)(128*1024))
            {
                qwGoal = (LONGLONG)(128*1024);
            }
        }
    }

#ifdef SCAVENGER_TRACE

    // If we are simulating a scavenging, we accumulate the number
    // of bytes, adjusted for cluster slop, that would be reclaimed
    // if this were for real.  By setting the usage target to 0, we
    // also stress the scavenger to see how well it selects items
    // in edge cases where we just can't seem to delete enough.

    LONGLONG qwDeleted = 0;
    if (dwFactor == TRACE_FACTOR)
        qwGoal = 0;

#endif

    SCORE_ITEM ScoreList[NUM_SCORE_ITEMS];
    DWORD cScore = 0;  // number of valid entries in score list

    DWORD dwCutoffScore = 0;

    DWORD dwEnum = GetInitialFindHandle();

    // The loop code below is organized in two parts.
    // Part 1 - enum the cache to add another item to the list.
    // Part 2 - remove an item from a list, by throwing out a
    //   a high-scoring item or deleting a low-scoring item.

    // The looping occurs in 3 phases.
    // A. Do part 1 only until there are 100 items or enum is complete.
    // B. Do part 1 and part 2 until the enum is complete.
    // C. Do part 2 only until the list is empty.
    // Note that it's possible to skip directly from phase A to C.

    while (1) // until goal is met or score list is empty
    {

        // PART 1 OF LOOP: Enumerate another item from the cache.

        HASH_ITEM* pItem = HashGetNextItem
            (_UrlObjStorage, *_UrlObjStorage->GetHeapStart(), &dwEnum, fPurge);

        if (pItem)
        {
            // Validate offset.
            if (_UrlObjStorage->IsBadOffset (pItem->dwOffset))
            {
                pItem->MarkFree();
                continue;
            }

            // Get the signature.
            FILEMAP_ENTRY* pBlock = (FILEMAP_ENTRY*)
                (((LPBYTE) *_UrlObjStorage->GetHeapStart()) + pItem->dwOffset);

            if (pBlock->dwSig != SIG_URL)
            {
                if (fPurge && (pBlock->dwSig == SIG_REDIR))
                    _UrlObjStorage->FreeEntry (pBlock);
                else
                    INET_ASSERT (pBlock->dwSig == SIG_LEAK );

                pItem->MarkFree();
                continue;
            }

            // Filter out items exempt from scavenging.
            URL_FILEMAP_ENTRY* pEntry = (URL_FILEMAP_ENTRY*) pBlock;

            // The entry should not be from an uplevel cache, or
            // we ought to be deferring to its scavenger.
            INET_ASSERT (!(pEntry->bVerCreate & ENTRY_VERSION_NONCOMPAT_MASK));
            
            if (IsUrlEntryExemptFromScavenging
                (pItem, pEntry, dwFilter, qwGmtTime, &gm))
            {
#ifdef SCAVENGER_TRACE
                if (dwFactor == TRACE_FACTOR)
                {
                    char szBuf[1024];
                    wsprintf (szBuf, "EXEMPT %s\n",
                        ((LPSTR) pEntry) + pEntry->UrlNameOffset);
                    OutputDebugString (szBuf);
                }
#endif
                continue;
            }

            // If we are deleting all items, no need to score.
            if (dwFactor==100)
            {
                if (ScavengeItem (pItem, &fMustUnlock))
                    continue;
                else
                    goto done;
            }

            // If we've fallen below the 4MB threshold, we won't exempt anything from 
            // scavenging.

            // Otherwise, we look at the size of the item. If its size is greater than
            // whatever 90% of the cache quota is (arbitrary), then we won't scavenge it
            // for this session. 

            // For all other instances, we won't scavenge items we've seen in the past
            // ten minutes.

            if (!fLowDiskSpace)
            {
                if (((LONGLONG)pEntry->dwFileSize > (LONGLONG)((LONGLONG)(qwQuota * (LONGLONG)9)/(LONGLONG)10))
                    && (dwdwSessionStartTime < pEntry->LastAccessedTime))
                    continue;
                
                if (qwGmtTime < (pEntry->LastAccessedTime + (LONGLONG)(GlobalScavengeFileLifeTime*FILETIME_SEC)))
                    continue;
            }
            
            // Otherwise score the entry.
            SCORE_ITEM* pScoreItem = ScoreList + cScore;

            pScoreItem->dwScore = ScoreEntry (pEntry, qwGmtTime);

#ifdef UNIX
            if (!pScoreItem->dwScore)
               continue;
#endif /* UNIX */

            // Add to the list.
            pScoreItem->dwItemOffset =          // 64BIT
                (DWORD) ((LPBYTE) pItem - *_UrlObjStorage->GetHeapStart());
            pScoreItem->dwHashValue  = pItem->GetValue();
            pScoreItem->dwHashOffset = pItem->dwOffset;

             // Check if list is full.
            if (++cScore != NUM_SCORE_ITEMS)
                continue;

            if (!dwCutoffScore)
            {
                // Establish a cutoff score.
                SortScoreItems (ScoreList, cScore);
                DWORD nIndex; // of item used as cutoff

                switch (dwFactor)
                {
                    case DEFAULT_CLEANUP_FACTOR:
#ifdef SCAVENGER_TRACE
                    case TRACE_FACTOR:
#endif
                        nIndex = NUM_SCORE_ITEMS / 5;
                        break;

                    default:
                        nIndex = (NUM_SCORE_ITEMS * dwFactor) / 100;
                        break;
                }

                dwCutoffScore = ScoreList[nIndex].dwScore;
            }
        } // end if (pItem)

        // PART 2 OF LOOP: remove an item from the list

        // If enumeration complete and list is empty, then
        // break out of the infinite loop.
        if (!cScore)
            break;

        SCORE_ITEM *pScoreItem;

        // Is the score list full?
        if (cScore == NUM_SCORE_ITEMS)
        {
            // Find the highest scoring item.
            pScoreItem = FindMinOrMaxScoreItem
                (ScoreList, NUM_SCORE_ITEMS, FIND_MAX);
            if (pScoreItem->dwScore > dwCutoffScore)
            {
                ScavengerTrace (dwFactor, pScoreItem, NULL);

                // Some of the items are above the cutoff score.
                // Remove the highest-scoring item from the list
                // by swapping it to the end and reducing count.
                cScore--;
                SwapScoreItems (pScoreItem, ScoreList + cScore);
                continue;
            }
        }

        // Either the score list isn't full or all of the items
        // are below the cutoff score.  Delete lowest scoring item.
        pScoreItem = FindMinOrMaxScoreItem (ScoreList, cScore, FIND_MIN);

        // We yield the lock between deletes, so do some sanity
        // checking before attemptint to delete the item.
        pItem = (HASH_ITEM*)
            (*_UrlObjStorage->GetHeapStart() + pScoreItem->dwItemOffset);
        if (pScoreItem->dwHashValue == pItem->GetValue()
            && pScoreItem->dwHashOffset == pItem->dwOffset)
        {
            ScavengerTrace (dwFactor, pScoreItem, &qwDeleted);

            if (!ScavengeItem (pItem, &fMustUnlock))
                goto done;

            // If we met our goal, call it quits.
            if (dwFactor != 100 && _UrlObjStorage->GetCacheSize() < qwGoal)
                break;
        }

        // Remove the lowest-scoring item from the list.
        cScore--;
        SwapScoreItems (pScoreItem, ScoreList + cScore);

    } // end while (1)

    if( dwHWnd && dwUMsg && IsWindow((HWND)DWORD_PTR(dwHWnd)) )
    {
        PostMessage(
            (HWND)DWORD_PTR(dwHWnd),
            (UINT)dwUMsg,
            (WPARAM)CACHE_NOTIFY_DELETE_ALL,
            (LPARAM)0
        );
    }

done:
    if (fMustUnlock)
        UnlockContainer();
    return ERROR_SUCCESS;
}

VOID CacheScavenger(LPVOID Parameter)
/*++

Routine Description:

    This function is the main  function for the cache management scavenger
    thread. This function performs verious time critical operations.

Arguments:

    NONE.

Return Value:

    NONE

--*/
{
    DWORD Error;
    DWORD WaitStatus;

    //StartCAP();

    // Set a global to indicate the thread is no longer suspended.
    LOCK_CACHE();
    if (!GlobalPleaseQuitWhatYouAreDoing)
    {
        UNLOCK_CACHE();

        // Why aren't we locking in this case?
        
        // Attempt to reduce the cache usage below the quota.
        GlobalUrlContainers->CleanupUrls (NULL, DEFAULT_CLEANUP_FACTOR, 0);

        // Clear a global to indicate the scavenger thread has exited.
        InterlockedDecrement(&GlobalScavengerRunning);

        LOCK_CACHE();
    }
    UNLOCK_CACHE();

    //StopCAP();
}


void LaunchScavenger (void)
{
#ifdef unix
    INET_ASSERT(!g_ReadOnlyCaches);
#endif /* unix */

    LOCK_CACHE(); 

    // only if scavenger is not already running.
    if (!InterlockedIncrement(&GlobalScavengerRunning))
    {
        // don't fire off new thread. Just queue scavenger as work item for
        // thread pool
        SHQueueUserWorkItem((LPTHREAD_START_ROUTINE)CacheScavenger,
                            NULL,
                            0,
                            (DWORD_PTR)0,
                            (DWORD_PTR *)NULL,
                            NULL,
                            0
                            );
    }
    else
    {
        InterlockedDecrement(&GlobalScavengerRunning);
    }
    
    UNLOCK_CACHE();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\urlcache\hndlmgr.cxx ===
#include <wininetp.h>
#include <cache.hxx>

#ifdef TEST

#include <stdlib.h>
#include <stdio.h>
#include <windows.h>
#include "hndlmgr.hxx"

#define ALLOCATE_FIXED_MEMORY(size) malloc(size)
#define REALLOCATE_MEMORY(ptr, size, flags) realloc(ptr, size)
#define FREE_MEMORY(ptr) free(ptr)

int main ()
{
    HNDLMGR HandleMgr;
    HANDLE h[10];
    HANDLE hBad = (HANDLE) 5150;

    // Test alloc and realloc of handle heap.
    for (int i=9; i>=0; i--)
    {
        h[i] = HandleMgr.Alloc (54);
        printf ("Alloc h[%d] = %d\n", i, (DWORD) h[i]);
    }

    // Test invalid, valid, and double free.
    printf ("Free(%d) returns %d\n", NULL, HandleMgr.Free(NULL));
    printf ("Free(%d) returns %d\n", hBad, HandleMgr.Free(hBad));
    printf ("Free(%d) returns %d\n", h[3], HandleMgr.Free(h[3]));
    printf ("Free(%d) returns %d\n", h[3], HandleMgr.Free(h[3]));
    printf ("Free(%d) returns %d\n", h[9], HandleMgr.Free(h[9]));

    // Test mapping of invalid, free, and valid handles.
    printf ("Map(%d) = %d\n", NULL, HandleMgr.Map(NULL));
    printf ("Map(%d) = %d\n", hBad, HandleMgr.Map(hBad));
    printf ("Map(%d) = %d\n", h[3], HandleMgr.Map(h[3]));
    printf ("Map(%d) = %d\n", h[5], HandleMgr.Map(h[5]));

    // Test recycling of handles from free list.
    i = 3;
    h[i] = HandleMgr.Alloc (42);
    printf ("Alloc h[%d] = %d\n", i, (DWORD) h[i]);
    i = 9;
    h[i] = HandleMgr.Alloc (42);
    printf ("Alloc h[%d] = %d\n", i, (DWORD) h[i]);

    return 1;
}

#endif // TEST

#define INC_GROW 8

//=========================================================================
void HNDLMGR::Destroy (void)
{
    if (pHeap)
    {
        for (DWORD iHandle=0; iHandle < pHeap->dwNumHandles; iHandle++)
        {
            if ((DWORD_PTR) pHeap->pvHandles[iHandle] >= pHeap->dwMaxHandles)
                FREE_MEMORY (pHeap->pvHandles[iHandle]);
        }
        FREE_MEMORY (pHeap);
    }        
}

//=========================================================================
BOOL HNDLMGR::IsValidOffset (DWORD_PTR dwp)
{
    return (pHeap && (dwp < pHeap->dwNumHandles) && 
        ((DWORD_PTR) pHeap->pvHandles[dwp]) >= pHeap->dwMaxHandles);
}

//=========================================================================
HANDLE HNDLMGR::Alloc (DWORD cbAlloc)
{
    PVOID pTemp;

    if (!pHeap)
    {
        // Allocate the heap.
        pHeap = (HNDLHEAP*) ALLOCATE_FIXED_MEMORY
            (sizeof(HNDLHEAP) + INC_GROW * sizeof(LPVOID));
        if (!pHeap)
            return NULL;

        // Initialize the heap.
        pHeap->dwNumHandles = 0;
        pHeap->dwNumInUse = 0;
        pHeap->dwMaxHandles = 0xFFFFFFFF;
        pHeap->dwFirstFree = 0;
        for (DWORD iHandle = 0; iHandle < INC_GROW; iHandle++)
        {
            pHeap->pvHandles[pHeap->dwNumHandles] =
                (HANDLE) (pHeap->dwNumHandles + 1);
            pHeap->dwNumHandles++;
        }
    }

    else if (pHeap->dwFirstFree == pHeap->dwNumHandles)
    {
        // Reallocate the heap.
        if (pHeap->dwNumHandles + INC_GROW >= pHeap->dwMaxHandles)
        {
            // Uh oh, heap is hit the lower bound set by the allocator.
            return NULL; 
        }
        pTemp = REALLOCATE_MEMORY (pHeap, sizeof(HNDLHEAP)
            + (pHeap->dwNumHandles + INC_GROW) * sizeof(LPVOID), LMEM_MOVEABLE);
        if (!pTemp)
            return NULL;
        pHeap = (HNDLHEAP*) pTemp;

        // Extend the free list.
        for (DWORD iHandle = 0; iHandle < INC_GROW; iHandle++)
        {
            pHeap->pvHandles[pHeap->dwNumHandles] =
                (HANDLE) (pHeap->dwNumHandles + 1);
            pHeap->dwNumHandles++;
        }
    }

    // Allocate a handle.
    pTemp = ALLOCATE_FIXED_MEMORY (cbAlloc);
    if (!pTemp)
        return NULL;
    if ((DWORD_PTR) pTemp < pHeap->dwNumHandles)
    {
        // Uh oh, allocator returned a low value!
        FREE_MEMORY (pTemp);
        return NULL;
    }
    if (pHeap->dwMaxHandles >= ((DWORD_PTR) pTemp))
        pHeap->dwMaxHandles = ((DWORD_PTR) pTemp);

    INET_ASSERT(pHeap->dwFirstFree < pHeap->dwNumHandles);
    // Pop the handle off the top of the free list.
    DWORD_PTR dwOffset = pHeap->dwFirstFree;
    pHeap->dwFirstFree = (DWORD_PTR) pHeap->pvHandles[pHeap->dwFirstFree];
    pHeap->pvHandles[dwOffset] = pTemp;
    pHeap->dwNumInUse++;
    return (HANDLE) (dwOffset + 1);
}

//=========================================================================
LPVOID HNDLMGR::Map (HANDLE h)
{
    // Subtract one from handle to get offset.
    DWORD_PTR dwOffset = (DWORD_PTR)h - 1;
    if (!IsValidOffset (dwOffset) || (((DWORD_PTR) pHeap->pvHandles[dwOffset]) == -1))
    {
        return NULL;
    }
    else
        return pHeap->pvHandles[dwOffset];
}

//=========================================================================
BOOL HNDLMGR::Free (HANDLE h)
{
    // Subtract one from handle to get offset.
    DWORD_PTR dwOffset = (DWORD_PTR)h - 1;

    if (!IsValidOffset (dwOffset))
        return FALSE;

    if (((DWORD_PTR) pHeap->pvHandles[dwOffset]) != -1)
    {
        // Push the handle on the top of the free list.
        FREE_MEMORY (pHeap->pvHandles[dwOffset]);
    }

    INET_ASSERT(pHeap->dwFirstFree <= pHeap->dwNumHandles);
    pHeap->pvHandles[dwOffset] = (LPVOID) pHeap->dwFirstFree;
    pHeap->dwFirstFree = dwOffset;
    pHeap->dwNumInUse--;
    return TRUE;
}

//=========================================================================
VOID HNDLMGR::InvalidateAll()
{
    // We're in the process of switching identities; all cache handles
    // should be invalidated so that they can no longer be used.
    
    if (pHeap)
    {
        for (DWORD iHandle=0; iHandle < pHeap->dwNumHandles; iHandle++)
        {
            if (((DWORD_PTR) pHeap->pvHandles[iHandle] > pHeap->dwNumHandles)
                && ((DWORD_PTR) pHeap->pvHandles[iHandle] != -1))
            {
                FREE_MEMORY (pHeap->pvHandles[iHandle]);
                pHeap->pvHandles[iHandle] = (HANDLE)-1;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\urlcache\group.cxx ===
/*++
Copyright (c) 1998  Microsoft Corporation

Module Name:  group.hxx

Abstract:

    Manages cache group.
    
Author:
    Danpo Zhang (DanpoZ) 02-08-98
--*/

#include <wininetp.h>
#include <cache.hxx>

GroupMgr::GroupMgr()
{
    _pContainer = NULL;
}

GroupMgr::~GroupMgr()
{
    if( _pContainer )
    {
        _pContainer->Release(FALSE);
    }
}

BOOL
GroupMgr::Init(URL_CONTAINER* pCont)
{
    BOOL fRet = TRUE;

    if( pCont )
    {
        _pContainer = pCont;
        _pContainer->AddRef();
    }
    else
    {
        SetLastError(ERROR_WINHTTP_INTERNAL_ERROR);
        fRet = FALSE;
    }

    return fRet;
}

DWORD
GroupMgr::CreateGroup(DWORD dwFlags, GROUPID* pGID)
{
    INET_ASSERT(_pContainer);
    INET_ASSERT(pGID);

    BOOL            fMustUnlock;
    DWORD           dwError;
    GROUP_ENTRY*    pGroupEntry = NULL;

    *pGID = 0;

    if( !_pContainer->LockContainer(&fMustUnlock) )
    {
        dwError = ERROR_WINHTTP_INTERNAL_ERROR;
        goto exit;    
    }

    if( dwFlags & CACHEGROUP_FLAG_GIDONLY )
    {
        // only needs to return GID, no group needs to be created
        *pGID = ObtainNewGID();
        if( *pGID )
            dwError = ERROR_SUCCESS;
        else
            dwError = ERROR_WINHTTP_INTERNAL_ERROR;
            

        goto exit;
    }

    //
    // find the first available entry by using FindEntry()
    // passing gid = 0 means looking for empty entry 
    // passing TRUE means create new page if no entry available
    //
    dwError = FindEntry(0, &pGroupEntry, TRUE );
    if( dwError != ERROR_SUCCESS )
    {
        goto exit;
    }

    // get a new gid
    *pGID = ObtainNewGID();

    if( *pGID )
    {
        // insert gid into the first available entry
        
        // set the sticky bit for non purgable group
        if( dwFlags & CACHEGROUP_FLAG_NONPURGEABLE )
        {
            *pGID = SetStickyBit(*pGID);
        }

        pGroupEntry->gid = *pGID;
        pGroupEntry->dwGroupFlags = dwFlags;
        dwError = ERROR_SUCCESS;
    } 
   
exit: 
    if( fMustUnlock )
    {
        _pContainer->UnlockContainer();
    }

    return dwError;
}


DWORD
GroupMgr::CreateDefaultGroups()
{
    
    INET_ASSERT(_pContainer);

    BOOL            fMustUnlock;
    DWORD           dwError;
    GROUP_ENTRY*    pGroupEntry = NULL;
    DWORD           dwOffsetHead = 0;

    if( !_pContainer->LockContainer(&fMustUnlock) )
    {
        dwError = ERROR_WINHTTP_INTERNAL_ERROR;
        goto exit;    
    }

    if(    GetHeaderData( CACHE_HEADER_DATA_ROOTGROUP_OFFSET, &dwOffsetHead)
        && dwOffsetHead )
    {
        BOOL fBadHead = FALSE;

        // dwOffsetHead may point to a page which has not actually mapped in
        if( _pContainer->_UrlObjStorage->IsBadGroupOffset(dwOffsetHead) ) 
        {
            fBadHead = TRUE;
        }
        else
        {
            
            // if offset is too big, invalid
            FILEMAP_ENTRY* pFM = NULL;

            pFM = (FILEMAP_ENTRY*) 
                    (*_pContainer->_UrlObjStorage->GetHeapStart() + 
                    dwOffsetHead - sizeof(FILEMAP_ENTRY) );                                   
            if(pFM->dwSig != SIG_ALLOC || !pFM->nBlocks )
            {
                fBadHead = TRUE;
            }
        }
            
        if( fBadHead )
        {
            // dwOffsetHead is invalid, reset!
            SetHeaderData(CACHE_HEADER_DATA_ROOTGROUP_OFFSET, 0);
        }
    }

    // if already created, just return success
    dwError = FindEntry(CACHEGROUP_ID_BUILTIN_STICKY, &pGroupEntry, FALSE);
    if( dwError == ERROR_SUCCESS )
    {
        goto exit;
    }

    //
    // not found, need to create new default groups
    //
    // find the first available entry by using FindEntry()
    // passing gid = 0 means looking for empty entry 
    // passing TRUE means create new page if no entry available
    //
    dwError = FindEntry(0, &pGroupEntry, TRUE );
    if( dwError != ERROR_SUCCESS )
    {
        goto exit;
    }

    // set the sticky bit for non purgable group
    pGroupEntry->gid = CACHEGROUP_ID_BUILTIN_STICKY;
    pGroupEntry->dwGroupFlags = CACHEGROUP_FLAG_NONPURGEABLE;
    dwError = ERROR_SUCCESS;
   
exit: 
    if( fMustUnlock )
    {
        _pContainer->UnlockContainer();
    }

    return dwError;
}


DWORD
GroupMgr::DeleteGroup(GROUPID gid, DWORD dwFlags)
{
    INET_ASSERT(_pContainer);
    INET_ASSERT(gid);

    BOOL                fMustUnlock;
    DWORD               dwError;
    GROUP_ENTRY*        pGroupEntry = NULL;
    GROUP_DATA_ENTRY*   pData = NULL;
    DWORD               hUrlFindHandle = 0;
    URL_FILEMAP_ENTRY*  pUrlEntry = 0;
    DWORD               dwFindFilter;
    HASH_ITEM*          pItem = NULL; 


    if( !_pContainer->LockContainer(&fMustUnlock) )
    {
        dwError = ERROR_WINHTTP_INTERNAL_ERROR;
        goto exit;    
    }


    // find the first available entry
    dwError = FindEntry(gid, &pGroupEntry, FALSE);
    if( dwError != ERROR_SUCCESS )
    {
        goto exit;
    }
     

    // Look for all the url associated with this group
    // mark the groupid to 0
    hUrlFindHandle = _pContainer->GetInitialFindHandle();       

    // set up find filter (do not care about cookie/history)
    dwFindFilter = URLCACHE_FIND_DEFAULT_FILTER 
                    & ~COOKIE_CACHE_ENTRY 
                    & ~URLHISTORY_CACHE_ENTRY;
    
    //
    // loop find all url belongs to this group
    // WARNING: this can be slow!
    //
    do 
    {
        // next url in this group
        pUrlEntry = (URL_FILEMAP_ENTRY*)
                        _pContainer->_UrlObjStorage->FindNextEntry( 
                                &hUrlFindHandle, dwFindFilter, gid); 

        if( pUrlEntry )
        {
            INET_ASSERT(hUrlFindHandle);
            pItem = (HASH_ITEM*)(
                    (LPBYTE) *_pContainer->_UrlObjStorage->GetHeapStart() +
                    hUrlFindHandle );

            if( pItem->HasMultiGroup() )
            {
                //
                // examing the group list and remove this group
                // from the list
                //
                DWORD       dwNewHeaderOffset       = pUrlEntry->dwGroupOffset;
                DWORD       dwGroupEntryOffset      = PtrDiff32(pGroupEntry, *_pContainer->_UrlObjStorage->GetHeapStart());

                //
                // find the to be deleted group entry in the list
                // of groups associated with this url, we need to
                // fix this by removing the to be dead group from 
                // the list
                //
                DWORD Error = RemoveFromGroupList(
                    pUrlEntry->dwGroupOffset, 
                    dwGroupEntryOffset,
                    &dwNewHeaderOffset 
                );
                    
            
                //
                // found the entry and head offset has been changed
                //
                if( Error == ERROR_SUCCESS && 
                    dwNewHeaderOffset != pUrlEntry->dwGroupOffset )
                {
                    pUrlEntry->dwGroupOffset = dwNewHeaderOffset;
               
                    // 
                    // no more group associated with this url 
                    // let's update the hash flags 
                    //
                    if( !dwNewHeaderOffset )
                    {
                        pItem->ClearMultGroup();
                        pItem->ClearGroup();
                    }
                }

                // sticky bit
                if(!pUrlEntry->dwExemptDelta && IsStickyGroup(gid) )
                {
                    //
                    // unset sticky bit for this url IFF 
                    // 1) we are about to delete the last group of this url
                    // 2) there is no more sticky group associated with this
                    //    url other than the to be deleted group
                    //
                    if( !pUrlEntry->dwGroupOffset ||
                        (  pUrlEntry->dwGroupOffset &&
                           NoMoreStickyEntryOnList(pUrlEntry->dwGroupOffset)))
                    {
                    
                        _pContainer->UpdateStickness(
                            pUrlEntry,
                            URLCACHE_OP_UNSET_STICKY,
                            hUrlFindHandle        
                        );
                    }
                }
            }
            else
            {
                //
                // do not move the url entry now, so we just
                // need to reset the GroupOffset and re-exam the
                // stick bit
                //
                pUrlEntry->dwGroupOffset = 0;

                // sticky bit
                if(!pUrlEntry->dwExemptDelta && IsStickyGroup(gid) )
                {

                    _pContainer->UpdateStickness(
                        pUrlEntry,
                        URLCACHE_OP_UNSET_STICKY,
                        hUrlFindHandle        
                    );
                }

            }


            if( dwFlags & CACHEGROUP_FLAG_FLUSHURL_ONDELETE)
            {
                //
                // Container's DeleteUrlEntry method takes two 
                // param, the url entry and hash item.
                // The hUrlFindHandle actually contains the
                // offset of the Hash Item, so we can get 
                // the hash item from there. 
                //

                // if this url belongs to other groups, 
                // do not delete it
                if( !pItem->HasMultiGroup() )
                {
                    _pContainer->DeleteUrlEntry(pUrlEntry, pItem, SIG_DELETE);
                }
            }

        } // find next url
    } while( pUrlEntry);
                    
    // if data entry exists, we should free them as well 
    if( pGroupEntry->dwGroupNameOffset )
    {
        dwError = FindDataEntry(pGroupEntry, &pData, FALSE); 
        if( dwError == ERROR_SUCCESS )
        {
            FreeDataEntry(pData);
        }
    }

    memset(pGroupEntry, 0, sizeof(GROUP_ENTRY) );
    dwError = ERROR_SUCCESS;

exit: 
    if( fMustUnlock )
    {
        _pContainer->UnlockContainer();
    }

    return dwError;
}



DWORD
GroupMgr::GetGroup(
    GROUPID                             gid, 
    DWORD                               dwAttrib, 
    INTERNET_CACHE_GROUP_INFOA*         pOutGroupInfo, 
    DWORD*                              pdwOutGroupInfoSize
)
{
    INET_ASSERT(_pContainer);
    INET_ASSERT(gid && pOutGroupInfo && pdwOutGroupInfoSize);

    BOOL            fMustUnlock;
    DWORD           dwError;
    GROUP_ENTRY*    pGroupEntry = NULL;

    if( !_pContainer->LockContainer(&fMustUnlock) )
    {
        dwError = ERROR_WINHTTP_INTERNAL_ERROR; 
        goto exit;    
    }

    
    *pdwOutGroupInfoSize = 0;

    // find the entry
    dwError = FindEntry(gid, &pGroupEntry, FALSE); 
    if( dwError != ERROR_SUCCESS )
    {
        goto exit;
    }

    // init out param
    memset(pOutGroupInfo, 0, sizeof(INTERNET_CACHE_GROUP_INFOA) );

    // copy over GROUP_ENTRY -> GROUP_INFO
    Translate(
            dwAttrib,
            pOutGroupInfo, 
            pGroupEntry, 
            GROUP_ENTRY_TO_INFO, 
            pdwOutGroupInfoSize 
    ); 
    dwError = ERROR_SUCCESS; 

exit: 
    if( fMustUnlock )
    {
        _pContainer->UnlockContainer();
    }

    return dwError;
}


DWORD
GroupMgr::SetGroup(
    GROUPID                             gid, 
    DWORD                               dwAttrib, 
    INTERNET_CACHE_GROUP_INFOA*         pGroupInfo 
)
{
    INET_ASSERT(_pContainer);
    INET_ASSERT(pGroupInfo && gid);

    BOOL  fMustUnlock;
    DWORD dwError;
    GROUP_ENTRY* pGroupEntry;

    if( !_pContainer->LockContainer(&fMustUnlock) )
    {
        dwError = GetLastError();
        goto Cleanup;    
    }

    pGroupEntry = NULL;

    INET_ASSERT(pGroupInfo);

    if( dwAttrib & ~(CACHEGROUP_READWRITE_MASK) ) 
    {
        //
        // read only fields are being requested
        //
        dwError = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    if( (dwAttrib & CACHEGROUP_ATTRIBUTE_GROUPNAME) &&
        (strlen(pGroupInfo->szGroupName) >= GROUPNAME_MAX_LENGTH ) ) 
    {
        //
        // name too long, exceed the buffer limit 
        //
        dwError = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    // find the entry
    dwError = FindEntry(gid, &pGroupEntry, FALSE);
    if( dwError != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    // copy over GROUP_INFO -> GROUP_ENTRY
    Translate(
            dwAttrib,
            pGroupInfo, 
            pGroupEntry, 
            GROUP_INFO_TO_ENTRY, 
            0 
    ); 
    dwError = ERROR_SUCCESS;
    
Cleanup:
    if( fMustUnlock )
    {
        _pContainer->UnlockContainer();
    }

    return dwError; 
}


DWORD
GroupMgr::GetNextGroup(
    DWORD*                          pdwLastItemOffset, 
    GROUPID*                        pOutGroupId
)
{
    INET_ASSERT(_pContainer);
    INET_ASSERT(pOutGroupId);

    BOOL            fMustUnlock;
    BOOL            fEndOfGroups;
    GROUP_ENTRY*    pGroupEntry;
    DWORD           dwNewOffset;
    DWORD           dwError;

    if( !_pContainer->LockContainer(&fMustUnlock) )
    {
        dwError = ERROR_WINHTTP_INTERNAL_ERROR;
        fEndOfGroups = TRUE;
        goto Cleanup;    
    }

    pGroupEntry = NULL;
    dwNewOffset = 0;
    fEndOfGroups = FALSE;

    if( *pdwLastItemOffset == 0 )
    {
        // get root
        dwError = FindRootEntry(&pGroupEntry, FALSE );
        if( dwError != ERROR_SUCCESS )
        {
            //
            // new find and we can not get the root entry
            // this means there are no group at all. 
            //
            fEndOfGroups = TRUE;
            goto Cleanup;
        }
    } // IF: no previous offset, this is a new Find 

    else if( *pdwLastItemOffset == OFFSET_NO_MORE_GROUP )
    {
        // this group of search has completed already
        fEndOfGroups = TRUE;
        dwError = ERROR_FILE_NOT_FOUND;
        goto Cleanup;

    } // ELSE IF: previous FindNext has already reached the end of the groups 

    else
    {
        //
        // use the offset to jump to the last returned item's entry  
        //
        pGroupEntry = (GROUP_ENTRY*) 
            (*_pContainer->_UrlObjStorage->GetHeapStart() + *pdwLastItemOffset);                                   
        //
        // one step forward 
        //
        INET_ASSERT(pGroupEntry);                      // can't be null
        INET_ASSERT( !IsIndexToNewPage(pGroupEntry) ); // can't be index item
        pGroupEntry++;

    } // ELSE: walk to the item which has been returned by previous FindNext()


    // loop for next entry 
    while(pGroupEntry)
    {
        //
        // if this entry is the last one of the page
        // it contains offset pointing to the next page
        //
        if( IsIndexToNewPage(pGroupEntry) )
        {
            //
            // BUGBUG
            // we currently use dwFlags to indicating if
            // this is pointing to the next offset
            //
            if( pGroupEntry->dwGroupFlags )
            {
                //
                // walk to next page
                //
                pGroupEntry = (GROUP_ENTRY*)
                        (   *_pContainer->_UrlObjStorage->GetHeapStart() 
                          + pGroupEntry->dwGroupFlags );                                   
            } // IF: index entry point to next page

            else
            {
                //
                // we are done 
                //
                fEndOfGroups = TRUE;
                dwError = ERROR_FILE_NOT_FOUND;
                break; 

            } // ELSE: index page contains nothing (this is the last page)

        } // special case: current entry is the index(point to next page)


        // 
        // using gid to test if the entry is empty, if not, 
        // walk to the next entry  
        //
        if( !pGroupEntry->gid )
        {
            pGroupEntry++;
        } 
        else
        {
            break;    
        }

    } // while(pGroupEntry)
    

Cleanup:
    // update LastItemOffset
    if (!fEndOfGroups
        && pGroupEntry)
    {
        LPBYTE      lpbBase = *_pContainer->_UrlObjStorage->GetHeapStart(); 
        dwNewOffset = PtrDiff32(pGroupEntry, lpbBase);
        *pdwLastItemOffset = dwNewOffset;

        // copy over GROUP_ENTRY -> GROUP_INFO
        *pOutGroupId = pGroupEntry->gid;
        dwError = ERROR_SUCCESS;

    } // IF:  find the item

    else
    {
        *pdwLastItemOffset = OFFSET_NO_MORE_GROUP;
        dwError = ERROR_FILE_NOT_FOUND;
    } // ELSE: not find 

    if( fMustUnlock )
    {
        _pContainer->UnlockContainer();
    }

    return dwError;
}


DWORD
GroupMgr::FindRootEntry(
    GROUP_ENTRY** ppOut,        // OUT: first empty entry
    BOOL fCreate                // allocate new page if needed
)
{
    INET_ASSERT(ppOut);
    *ppOut = NULL;
    
    GROUPS_ALLOC_FILEMAP_ENTRY* pPage = NULL;
    DWORD                       dwError;
    DWORD                       dwOffsetToRootEntry = 0;

    // get base offset 
    if( GetHeaderData( CACHE_HEADER_DATA_ROOTGROUP_OFFSET, &dwOffsetToRootEntry))
    {
        if( !dwOffsetToRootEntry && fCreate )
        {
            dwError = CreateNewPage(&dwOffsetToRootEntry, TRUE);

            if( dwError != ERROR_SUCCESS)
            {
                goto Cleanup;
            }
        } 
        else if( !dwOffsetToRootEntry && !fCreate )
        {
            //
            // there is no offset infomation on the mem file 
            // however, the flag says do not create a new page
            // failure is the only option here
            //
            dwError = ERROR_FILE_NOT_FOUND;
            goto Cleanup;
        } 

    } // IF: retrieve base offset

    else
    {
        dwError = ERROR_WINHTTP_INTERNAL_ERROR;
        goto Cleanup; 

    } // ELSE: failed to get base offset
    

    // 
    // At this point, we should either:
    //  1. retrieved valid dwOffsetToRootEntry or 
    //  2. get the new dwOffsetToRootEntry via CreateNewPage() call  
    //
    INET_ASSERT( dwOffsetToRootEntry );
    *ppOut =  (GROUP_ENTRY*) 
        ( *_pContainer->_UrlObjStorage->GetHeapStart() + dwOffsetToRootEntry);                                   
    dwError = ERROR_SUCCESS;

Cleanup:
    return dwError; 
}



DWORD
GroupMgr::FindEntry(
    GROUPID         gid,          // gid, 0 means find first empty seat
    GROUP_ENTRY**   ppOut,        // OUT: entry with gid specified
    BOOL            fCreate       // allocate new page if needed 
                                  // (applied for searching empty seat only)
)
{
    INET_ASSERT(ppOut);

    // fCreate can only be associated with gid == 0
    INET_ASSERT( (fCreate && !gid ) || (!fCreate && gid ) );

    GROUP_ENTRY*    pGroupEntry = NULL;
    DWORD           dwError;

    // get Root Entry
    dwError = FindRootEntry(&pGroupEntry, fCreate);
    if( dwError != ERROR_SUCCESS )
    {
        dwError = ERROR_WINHTTP_INTERNAL_ERROR;
        goto Cleanup;
    } // failed to get the root entry


    INET_ASSERT(pGroupEntry); // pGroupEntry should be available now

    while(1)
    {
        // special case for end of this page
        if( IsIndexToNewPage(pGroupEntry) )
        {
            //
            // BUGBUG
            // we currently use the dwFlags to indicating
            // if this is pointing to the next offset
            //
            if( pGroupEntry->dwGroupFlags )
            {
                // walk to next page
                pGroupEntry = (GROUP_ENTRY*)
                        (   *_pContainer->_UrlObjStorage->GetHeapStart()
                           + pGroupEntry->dwGroupFlags );

            } // IF: index entry points to next page
    
            else if( fCreate)
            {
//////////////////////////////////////////////////////////////////
// BEGIN WARNING: The file might be grown and remapped, so all  //
// pointers into the file before this point may be invalidated. //
//////////////////////////////////////////////////////////////////

                DWORD dwOffsetToFirstEntry = 0;
                LPBYTE  lpbBase = NULL;

                // remember the old offset for pGroupEntry
                DWORD_PTR dwpEntryOffset = PtrDifference(pGroupEntry, *_pContainer->_UrlObjStorage->GetHeapStart());

                // create new page!
                dwError = CreateNewPage(&dwOffsetToFirstEntry, FALSE);
                if( dwError != ERROR_SUCCESS )
                {
                    goto Cleanup;
                }

                // recalculate pGroupEntry using the offset remembered 
                lpbBase = *_pContainer->_UrlObjStorage->GetHeapStart(); 
                pGroupEntry = (GROUP_ENTRY*)(lpbBase + dwpEntryOffset);

//////////////////////////////////////////////////////////////////
// END WARNING: The file might be grown and remapped, so all    //
// pointers into the file before this point may be invalidated. //
//////////////////////////////////////////////////////////////////

                //
                // pGroupEntry currently is the index item, insert 
                // the offset of the first item to the newly created page
                //
                pGroupEntry->dwGroupFlags = dwOffsetToFirstEntry;

                // walk to the new page 
                pGroupEntry = (GROUP_ENTRY*)(lpbBase + dwOffsetToFirstEntry);


            } // ELSE IF: index entry not point to new page, fCreate is
              //          set, a new page is being created  

            else
            {
                // this is the end of all groups, item still not found, 
                dwError = ERROR_FILE_NOT_FOUND;
                break;

            } // ELSE: index entry not point to new page, fCreate not set

        } // IF: this entry is an index entry


        //
        // now pGroupEntry must point to a normal group entry 
        //
        INET_ASSERT( !IsIndexToNewPage(pGroupEntry) );

        if( pGroupEntry->gid != gid )
        {
            // not found, walk to next entry
            pGroupEntry++;
        } 
        else
        {
            // found entry
            dwError = ERROR_SUCCESS;
            break;    
        }

    } // WHILE: (loop over all page)

    
Cleanup:
    if( dwError == ERROR_SUCCESS )
    {
        *ppOut = pGroupEntry;
    }
    else
    {
        *ppOut = NULL;
    }

    return dwError;
}

DWORD
GroupMgr::CreateNewPage(DWORD* dwOffsetToFirstEntry, BOOL fIsFirstPage)
{
    DWORD                           dwError;
    GROUPS_ALLOC_FILEMAP_ENTRY*     pPage = NULL;
    DWORD cbSize = sizeof(GROUPS_ALLOC_FILEMAP_ENTRY);

    pPage = (GROUPS_ALLOC_FILEMAP_ENTRY*)
            _pContainer->_UrlObjStorage->AllocateEntry(cbSize);


    if( pPage )
    {
        // clean up allocated page
        cbSize = PAGE_SIZE_FOR_GROUPS;    
        memset(pPage->pGroupBlock, 0, cbSize );

        // calculate the group base offset 
        LPBYTE lpbBase = *_pContainer->_UrlObjStorage->GetHeapStart(); 

        *dwOffsetToFirstEntry = PtrDiff32(pPage->pGroupBlock, lpbBase);

        //
        // mark the last entry as index to next page
        // (gid == GID_INDEX_TO_NEXT_PAGE) is the mark, 
        // the actual offset is stored at dwGroupFlags field
        //
        GROUP_ENTRY*    pEnd = (GROUP_ENTRY*) pPage->pGroupBlock;
        pEnd = pEnd + (GROUPS_PER_PAGE - 1);
        pEnd->gid = GID_INDEX_TO_NEXT_PAGE;

        if( fIsFirstPage )
        {
            //
            // for first page, we would have to set the offset 
            // back to the CacheHeader 
            //
            if( !SetHeaderData( 
                    CACHE_HEADER_DATA_ROOTGROUP_OFFSET, *dwOffsetToFirstEntry))
            {
                // free allocated page
                _pContainer->_UrlObjStorage->FreeEntry(pPage);
        
                // set error and go
                *dwOffsetToFirstEntry = 0;
                dwError = ERROR_WINHTTP_INTERNAL_ERROR;
                goto Cleanup;

            } // IF: failed to set the offset 
        }

        // return the offset to the first entry of the new page
        dwError = ERROR_SUCCESS;

    } // IF: Allocate new page succeed

    else
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
    } // ELSE: failed to allocate new page

Cleanup:
    return dwError;
}



GROUPID
GroupMgr::ObtainNewGID()
{
    SYSTEMTIME  st;
    DWORD   dwC[2] = {0, 0};
    GROUPID gid = 0;

    // get counter from index file
    if( GetHeaderData(CACHE_HEADER_DATA_GID_LOW,  &dwC[0]) &&
        GetHeaderData(CACHE_HEADER_DATA_GID_HIGH, &dwC[1]) )
    {
        if( !dwC[0] && !dwC[1] )
        {
            // need to get the current system time
            GetSystemTime( &st );
            SystemTimeToFileTime(&st, (FILETIME*)dwC);

        } // IF: counter not initialized 

        else
        {
            // increment
            if( dwC[0] != 0xffffffff )
            {
                dwC[0] ++;
            }
            else
            {
                dwC[0] = 0;
                dwC[1] ++;
            }
        } // ELSE: counter initialized

        // send data back to cache
        if( SetHeaderData(CACHE_HEADER_DATA_GID_LOW,  dwC[0] ) &&
            SetHeaderData(CACHE_HEADER_DATA_GID_HIGH, dwC[1] ) ) 
        {
            //memcpy(&gid, dwC, sizeof(GROUPID) );
            gid = *((GROUPID *)dwC); 
        } 
    } 
    
    // apply the mask to newly created gid
    // the first 4 bits are reserved (one bit is used for stickness)  
    return (gid & GID_MASK); 
}


BOOL
GroupMgr::Translate(
    DWORD                           dwAttrib,
    INTERNET_CACHE_GROUP_INFOA*     pGroupInfo,
    GROUP_ENTRY*                    pGroupEntry, 
    DWORD                           dwFlag,
    DWORD*                          pdwSize                           
) 
{
    INET_ASSERT(pGroupInfo && pGroupEntry);
    BOOL fRet = TRUE;
    GROUP_DATA_ENTRY*   pData = NULL;
    DWORD               dwError;

    if( dwFlag == GROUP_ENTRY_TO_INFO )
    {
        INET_ASSERT(pdwSize);

        // clear
        memset(pGroupInfo, 0, sizeof(INTERNET_CACHE_GROUP_INFOA) );
        *pdwSize = 0;

        // basic entries 
        if( dwAttrib & CACHEGROUP_ATTRIBUTE_BASIC )
        {
            pGroupInfo->dwGroupSize  = sizeof(INTERNET_CACHE_GROUP_INFOA);
            pGroupInfo->dwGroupFlags = pGroupEntry->dwGroupFlags;
            pGroupInfo->dwGroupType  = pGroupEntry->dwGroupType;
            pGroupInfo->dwDiskUsage  = (DWORD)(pGroupEntry->llDiskUsage / 1024);
            pGroupInfo->dwDiskQuota  = pGroupEntry->dwDiskQuota;
        }
        
        // user friendly name
        if( ( (dwAttrib & CACHEGROUP_ATTRIBUTE_GROUPNAME) | 
              (dwAttrib & CACHEGROUP_ATTRIBUTE_STORAGE  )  ) &&
              pGroupEntry->dwGroupNameOffset ) 
        {
            dwError = FindDataEntry(pGroupEntry, &pData, FALSE);
            if( dwError != ERROR_SUCCESS )
            {
                fRet = FALSE;
            } 
            else
            {
                DWORD dwLen = strlen(pData->szName) + 1;
                INET_ASSERT( dwLen > GROUPNAME_MAX_LENGTH );

                memcpy( pGroupInfo->szGroupName, 
                        pData->szName, 
                        dwLen );

                memcpy( pGroupInfo->dwOwnerStorage,
                        pData->dwOwnerStorage, 
                        sizeof(DWORD) * GROUP_OWNER_STORAGE_SIZE );
            }
        }

        // set size
        *pdwSize = sizeof(INTERNET_CACHE_GROUP_INFOA);
    }

    else 
    if( dwFlag == GROUP_INFO_TO_ENTRY )
    {
        // copy
        if( dwAttrib & CACHEGROUP_ATTRIBUTE_FLAG )
        {
            pGroupEntry->dwGroupFlags = pGroupInfo->dwGroupFlags;
        }

        if( dwAttrib & CACHEGROUP_ATTRIBUTE_TYPE )
        {
            pGroupEntry->dwGroupType = pGroupInfo->dwGroupType;
        }

        if( dwAttrib & CACHEGROUP_ATTRIBUTE_QUOTA )
        {
            pGroupEntry->dwDiskQuota = pGroupInfo->dwDiskQuota;
        }

        if( (dwAttrib & CACHEGROUP_ATTRIBUTE_GROUPNAME) | 
            (dwAttrib & CACHEGROUP_ATTRIBUTE_STORAGE  )  )
        {

            dwError = FindDataEntry(pGroupEntry, &pData, TRUE);
            if( dwError != ERROR_SUCCESS )
            {
                fRet = FALSE;
            } 
            else
            {
                
                if( dwAttrib & CACHEGROUP_ATTRIBUTE_GROUPNAME )  
                {
                    DWORD dwLen = strlen(pGroupInfo->szGroupName) + 1;
                    INET_ASSERT(dwLen > GROUPNAME_MAX_LENGTH);

                    memcpy( pData->szName, 
                            pGroupInfo->szGroupName, 
                            dwLen );
                }

                if( dwAttrib & CACHEGROUP_ATTRIBUTE_STORAGE ) 
                {
                    memcpy( pData->dwOwnerStorage, 
                            pGroupInfo->dwOwnerStorage,
                            sizeof(DWORD) * GROUP_OWNER_STORAGE_SIZE );
                }


                // BUGBUG
                // if both fields are set to be empty, we should free
                // the allocated data itam 
            }
        }
    }

    else
    {
        fRet = FALSE;
    }
    
    return fRet;
}

BOOL
GroupMgr::IsPageEmpty(GROUP_ENTRY* pHead)
{
    BOOL fRet = FALSE;

    GROUP_ENTRY* pGroupEntry = pHead;
    for( int i = 0; i < (GROUPS_PER_PAGE - 1); i ++)
    {
        if( pGroupEntry->gid )
        {
            break;
        }
        else
        {
            pGroupEntry++;
        }
    }

    // there is no item found on this page
    if( !pGroupEntry->gid && i == GROUPS_PER_PAGE - 1 )
    {
        fRet = TRUE; 
    }


    return fRet;
}

BOOL
GroupMgr::IsLastPage(GROUP_ENTRY* pHead)
{
    BOOL fRet = FALSE;

    GROUP_ENTRY*    pEnd = NULL;

    // jump to last item
    pEnd = pHead + GROUPS_PER_PAGE;

    //
    // the gid has to be marked as GID_INDEX_TO_NEXT_PAGE 
    // for index entry, and if the dwGroupFlags is 0, 
    // that means we are not pointing to any
    // other page, this is the last page indeed.
    //
    if( pEnd->gid == GID_INDEX_TO_NEXT_PAGE && !pEnd->dwGroupFlags )
    {
        fRet = TRUE;
    }

    return fRet;
}


BOOL
GroupMgr::FreeEmptyPages(DWORD dwFlags)
{
    INET_ASSERT(_pContainer);
    BOOL            fMustUnlock;

    BOOL            fRet = TRUE;
    GROUP_ENTRY*    pHead = NULL;
    GROUP_ENTRY*    pPrevHead = NULL;
    GROUP_ENTRY*    pEnd  = NULL;
    GROUP_ENTRY*    pTobeDeleted = NULL;
    BOOL            fFirstPage = TRUE;

    if( !_pContainer->LockContainer(&fMustUnlock) )
    {
        fRet = FALSE;
        goto Cleanup;    
    }

    // BUGBUG FindRootEntry changed the return code, check for dwError
    if( FindRootEntry(&pHead, FALSE ) )
    {
        pPrevHead = pHead; 
        while(pHead)
        {
            pTobeDeleted = NULL;

            if( IsPageEmpty(pHead) )
            {
                pTobeDeleted = pHead;

                //
                // find the offset of the next page
                // 0 which means the current page is the last one
                //
                DWORD dwOffsetNextPage = 0;
                pEnd = pHead + GROUPS_PER_PAGE;
                dwOffsetNextPage = pEnd->dwGroupFlags;

                //     
                // if the first page is to be deleted, we have to 
                // update the offset which points to the next page
                //
                if( fFirstPage)
                {
                    if( !SetHeaderData(
                        CACHE_HEADER_DATA_ROOTGROUP_OFFSET, dwOffsetNextPage))
                    {
                        fRet = FALSE;
                        goto Cleanup;
                    }
                } 
                else
                {
                
                    // 
                    // Link Prev page to Next page
                    //
                    GROUP_ENTRY* pPrevEnd = pPrevHead + GROUPS_PER_PAGE;
                    pPrevEnd->dwGroupFlags = dwOffsetNextPage;  
                }
            } 
        

            //
            // update pHead make it point to the next page 
            //
            if( !IsLastPage(pHead) )
            {
                // remember pPrev
                pPrevHead = pHead;

                // walk to next page
                pEnd = pHead + GROUPS_PER_PAGE;
                pHead = (GROUP_ENTRY*)
                        (   *_pContainer->_UrlObjStorage->GetHeapStart()
                          + pEnd->dwGroupFlags );

                // not first page anymore
                fFirstPage = FALSE;
            }
            else
            {
                // this is the last page
                pHead = NULL;
            }

            // 
            // free the tobe deleted page
            //
            if( pTobeDeleted )
            {
                GROUPS_ALLOC_FILEMAP_ENTRY*     pPage = NULL;
                pPage = (GROUPS_ALLOC_FILEMAP_ENTRY*) ((LPBYTE)pTobeDeleted - sizeof(FILEMAP_ENTRY));

                _pContainer->_UrlObjStorage->FreeEntry(pPage);
            }
        }
    }

    
Cleanup:
    if( fMustUnlock )
    {
        _pContainer->UnlockContainer();
    }
    return fRet;
}


DWORD
GroupMgr::FindDataEntry(
    GROUP_ENTRY*        pGroupEntry, 
    GROUP_DATA_ENTRY**  pOutData,
    BOOL                fCreate
)
{
    INET_ASSERT(_pContainer);
    INET_ASSERT(pGroupEntry && pOutData );
    *pOutData = NULL;

    BOOL            fMustUnlock;
    DWORD           dwError;
    LPBYTE          lpbBase = NULL;

    if( !_pContainer->LockContainer(&fMustUnlock) )
    {
        dwError = ERROR_WINHTTP_INTERNAL_ERROR; 
        goto exit;    
    }

    if( pGroupEntry->dwGroupNameOffset )
    {
        lpbBase = *_pContainer->_UrlObjStorage->GetHeapStart();
        *pOutData = (GROUP_DATA_ENTRY*) (lpbBase + pGroupEntry->dwGroupNameOffset);
        dwError = ERROR_SUCCESS;
    }

    else if( fCreate)
    {
//////////////////////////////////////////////////////////////////
// BEGIN WARNING: The file might be grown and remapped, so all  //
// pointers into the file before this point may be invalidated. //
//////////////////////////////////////////////////////////////////
        // remember the old offset for pGroupEntry
        DWORD_PTR   dwpEntryOffset = PtrDifference(pGroupEntry, *_pContainer->_UrlObjStorage->GetHeapStart());

        // create new data entry
        *pOutData = GetHeadDataEntry(TRUE);
        if( *pOutData )
        {
            //
            // re-calc pGroupEntry
            //
            lpbBase = (LPBYTE) *_pContainer->_UrlObjStorage->GetHeapStart();
            pGroupEntry = (GROUP_ENTRY*)(lpbBase + dwpEntryOffset);

            //
            // set entry's filename offset field 
            //
            pGroupEntry->dwGroupNameOffset = PtrDiff32(*pOutData, lpbBase);

            // succeed
            dwError = ERROR_SUCCESS;
            
        }
        else
        {
            dwError = ERROR_WINHTTP_INTERNAL_ERROR;
        }
//////////////////////////////////////////////////////////////////
// END WARNING: The file might be grown and remapped, so all    //
// pointers into the file before this point may be invalidated. //
//////////////////////////////////////////////////////////////////
    }

    else
    {
        dwError = ERROR_FILE_NOT_FOUND;
    }

exit: 
    if( fMustUnlock )
    {
        _pContainer->UnlockContainer();
    }

    if( fCreate && (dwError == ERROR_SUCCESS) )
    {
        // for new item, it's nice to mark the next link to 0
        (*pOutData)->dwOffsetNext = 0;
    }
    return dwError;
}


VOID
GroupMgr::FreeDataEntry(GROUP_DATA_ENTRY* pDataEntry)
{
    // get the head entry 
    GROUP_ENTRY*    pGroupEntry = NULL;
    DWORD dwError = FindRootEntry(&pGroupEntry, FALSE );
    if( dwError != ERROR_SUCCESS )
    {
        return;
    }

    //
    // walk to the index item whose dwGroupNameOffset 
    // contains offset the the head of free list
    //
    pGroupEntry += (GROUPS_PER_PAGE - 1);
    INET_ASSERT( pGroupEntry->gid == GID_INDEX_TO_NEXT_PAGE);

    // memset the freed data entry
    memset(pDataEntry, 0, sizeof(GROUP_DATA_ENTRY) );

    // make data item's next link points to current head
    pDataEntry->dwOffsetNext = pGroupEntry->dwGroupNameOffset;

    // make the current head to be the just freed item's offset 
    LPBYTE lpbBase = *_pContainer->_UrlObjStorage->GetHeapStart();
    pGroupEntry->dwGroupNameOffset = PtrDiff32(pDataEntry, lpbBase);
}


LPGROUP_DATA_ENTRY
GroupMgr::GetHeadDataEntry(BOOL fCreate)
{
    GROUP_DATA_ENTRY*   pDataEntry = NULL;
    GROUP_ENTRY*        pGroupEntry = NULL;         
    LPBYTE              lpbBase = NULL;

    // get the head entry 
    DWORD dwError = FindRootEntry(&pGroupEntry, FALSE );
    if( dwError != ERROR_SUCCESS )
    {
        goto exit;
    }

    // walk to the index item
    pGroupEntry += (GROUPS_PER_PAGE - 1);
    INET_ASSERT( pGroupEntry->gid == GID_INDEX_TO_NEXT_PAGE);

    // the dwGroupNameOffset contains offset the the head of free list
    if( pGroupEntry->dwGroupNameOffset)
    {
        // get the head
        lpbBase = (LPBYTE) *_pContainer->_UrlObjStorage->GetHeapStart();
        pDataEntry = (GROUP_DATA_ENTRY*) (lpbBase + pGroupEntry->dwGroupNameOffset);

        // reset head to next one
        pGroupEntry->dwGroupNameOffset = pDataEntry->dwOffsetNext;
    }   

    else if( fCreate )
    {
//////////////////////////////////////////////////////////////////
// BEGIN WARNING: The file might be grown and remapped, so all  //
// pointers into the file before this point may be invalidated. //
//////////////////////////////////////////////////////////////////

        // remember the old offset for pGroupEntry
        DWORD_PTR dwpEntryOffset = PtrDifference(pGroupEntry, *_pContainer->_UrlObjStorage->GetHeapStart());

        // create a new page
        GROUPS_ALLOC_FILEMAP_ENTRY*     pPage = NULL;
        DWORD cbSize = sizeof(GROUPS_ALLOC_FILEMAP_ENTRY);

        pPage = (GROUPS_ALLOC_FILEMAP_ENTRY*)
                _pContainer->_UrlObjStorage->AllocateEntry(cbSize);

        if( !pPage )
        {
            goto exit;
        }
    
        // memset
        memset(pPage->pGroupBlock, 0, PAGE_SIZE_FOR_GROUPS);

        lpbBase = (LPBYTE) *_pContainer->_UrlObjStorage->GetHeapStart(); 
        GROUP_DATA_ENTRY*   pHead = (GROUP_DATA_ENTRY*)pPage->pGroupBlock;
        pDataEntry = pHead;

        // init list on the newly created page
        for(int i = 0; i < GROUPS_DATA_PER_PAGE - 1; i++)
        {
            // point to next offset 
            GROUP_DATA_ENTRY* pNext = pHead + 1;
            pHead->dwOffsetNext =  PtrDiff32(pNext, lpbBase);
            pHead = pNext;
        }

        //
        // pGroupEntry needs to be re-calc! 
        //
        pGroupEntry = (GROUP_ENTRY*)(lpbBase + dwpEntryOffset);

        // 
        // pGroupEntry currently is the index entry of the first 
        // page, it's dwGroupNameOffset field points the head of 
        // the list of a free group data entry
        //
        pGroupEntry->dwGroupNameOffset = pDataEntry->dwOffsetNext;

//////////////////////////////////////////////////////////////////
// END WARNING: The file might be grown and remapped, so all    //
// pointers into the file before this point may be invalidated. //
//////////////////////////////////////////////////////////////////
    }

    else
    {
        goto exit;
    }
    
exit:
    return pDataEntry;
}

DWORD
GroupMgr::GetOffsetFromList(DWORD dwHeadOffset, GROUPID gid, DWORD* pdwOffset)
{
    DWORD dwError;
    LIST_GROUP_ENTRY*   pListGroup = NULL;
    GROUP_ENTRY*        pGroupEntry = NULL;
    
    *pdwOffset = 0;

    pListGroup = 
        _pContainer->_UrlObjStorage->ValidateListGroupOffset(dwHeadOffset); 
    if( !pListGroup )
    {
        dwError = ERROR_FILE_NOT_FOUND;
        goto Cleanup;
    }   

    while(1)
    {
        
        if(!_pContainer->_UrlObjStorage->IsBadGroupOffset(pListGroup->dwGroupOffset))
        {
            pGroupEntry = (GROUP_ENTRY*)
                        (   *_pContainer->_UrlObjStorage->GetHeapStart()
                           + pListGroup->dwGroupOffset );
        }
        else
        {
            dwError = ERROR_WINHTTP_INTERNAL_ERROR;
            goto Cleanup;
        }

        if( pGroupEntry && pGroupEntry->gid == gid )
        {
            *pdwOffset = pListGroup->dwGroupOffset;
            break;
        }     

        // end of list, not found 
        if( !pListGroup->dwNext )
        {
            dwError = ERROR_FILE_NOT_FOUND;
            break;
        }

        // walk to next
        pListGroup = 
            _pContainer->_UrlObjStorage->ValidateListGroupOffset(
                pListGroup->dwNext); 

        if( !pListGroup )
        {
            dwError = ERROR_FILE_NOT_FOUND;
            goto Cleanup;
        }   
    } 

    if( *pdwOffset )    
    {
        dwError = ERROR_SUCCESS;
    }
    else
    {
        dwError = ERROR_FILE_NOT_FOUND;
    }

Cleanup:
    return dwError;
}


DWORD   
GroupMgr::CreateNewGroupList(DWORD* pdwHeadOffset)
{
    DWORD               dwError;
    
    // Find empty slot
    *pdwHeadOffset = 0;
    dwError = FindEmptySlotInListPage(pdwHeadOffset);
    if( ERROR_SUCCESS != dwError )
    {
        goto Cleanup;
    }

Cleanup:
    return dwError;
}

DWORD
GroupMgr::AddToGroupList(DWORD dwHeadOffset, DWORD dwOffset)
{
    DWORD               dwError;
    DWORD               dwEmptySlot;
    LIST_GROUP_ENTRY*   pListGroup = NULL;
    LIST_GROUP_ENTRY*   pListGroupEmpty = NULL;

    // if the item already on the list, return success
    if( IsGroupOnList(dwHeadOffset, dwOffset) )
    {
        dwError = ERROR_SUCCESS;
        goto Cleanup;
    }

    pListGroup = 
        _pContainer->_UrlObjStorage->ValidateListGroupOffset(dwHeadOffset); 
    if( !pListGroup )
    {
        dwError = ERROR_WINHTTP_INTERNAL_ERROR;
        goto Cleanup;
    }

    if( !pListGroup->dwGroupOffset )
    {
        // list is empty, just need to fill up the Head
        pListGroup->dwGroupOffset = dwOffset;
    }
    else
    {
        // List is not empty, we have to walk to end of the list
        // also need to get another empty slot

//////////////////////////////////////////////////////////////////
// BEGIN WARNING: The file might be grown and remapped, so all  //
// pointers into the file before this point may be invalidated. //
//////////////////////////////////////////////////////////////////
        // remember the old offset for pListGroup
        DWORD_PTR dwpListGroupOffset = PtrDifference(pListGroup, *_pContainer->_UrlObjStorage->GetHeapStart());

        // find empty slot
        dwError = FindEmptySlotInListPage(&dwEmptySlot);
        if( ERROR_SUCCESS != dwError )
        {
            goto Cleanup;
        }


        // recalculate pListGroup using the offset remembered 
        LPBYTE      lpbBase = *_pContainer->_UrlObjStorage->GetHeapStart(); 
        pListGroup = (LIST_GROUP_ENTRY*)(lpbBase + dwpListGroupOffset);

//////////////////////////////////////////////////////////////////
// END WARNING:   The file might be grown and remapped, so all  //
// pointers into the file before this point may be invalidated. //
//////////////////////////////////////////////////////////////////
        
        // walk to end of list
        while( pListGroup->dwNext )
        {
            pListGroup = 
                _pContainer->_UrlObjStorage->ValidateListGroupOffset(
                    pListGroup->dwNext); 
            if( !pListGroup )
            {
                dwError = ERROR_WINHTTP_INTERNAL_ERROR;
                goto Cleanup;
            }
        }

        // Get ListGroupEmpty Object from the empty slot
        pListGroupEmpty = 
            _pContainer->_UrlObjStorage->ValidateListGroupOffset(dwEmptySlot); 
        if( !pListGroupEmpty )
        {
            dwError = ERROR_WINHTTP_INTERNAL_ERROR;
            goto Cleanup;
        }

        // assign the new offset
        pListGroupEmpty->dwGroupOffset = dwOffset;

        // append empty slot at the end of the list
        // this need to be done at last to prevent some invalid
        // object get on the list
        pListGroup->dwNext = dwEmptySlot;
    }


    dwError = ERROR_SUCCESS;

Cleanup:
    return dwError;
}

DWORD   
GroupMgr::RemoveFromGroupList(
    DWORD      dwHeadOffset, 
    DWORD      dwOffset, 
    LPDWORD    pdwNewHeadOffset
)
{
    DWORD dwError = ERROR_SUCCESS;
    LIST_GROUP_ENTRY*   pListGroup = NULL;
    LIST_GROUP_ENTRY*   pListGroupPrev = NULL;
    LPBYTE              lpbBase = NULL;

    pListGroup = 
        _pContainer->_UrlObjStorage->ValidateListGroupOffset(dwHeadOffset); 
    if( !pListGroup )
    {
        dwError = ERROR_FILE_NOT_FOUND;
        goto Cleanup;
    }   

    lpbBase = (LPBYTE) *_pContainer->_UrlObjStorage->GetHeapStart(); 

    // header is the one we need, we will have to assign new header
    if( pListGroup->dwGroupOffset == dwOffset )
    {
        // new head
        *pdwNewHeadOffset = pListGroup->dwNext;

        // empty removed head and added to free list
        pListGroup->dwGroupOffset = 0;
        pListGroup->dwNext= 0;
        AddToFreeList(pListGroup);

        // done
        dwError = ERROR_SUCCESS;
        goto Cleanup;
    }

    if( !pListGroup->dwNext )
    {
        dwError = ERROR_FILE_NOT_FOUND;
        goto Cleanup;
    }   

    pListGroupPrev = pListGroup;
    pListGroup = 
        _pContainer->_UrlObjStorage->ValidateListGroupOffset(pListGroup->dwNext); 
    if( !pListGroup)
    {
        dwError = ERROR_FILE_NOT_FOUND;
        goto Cleanup;
    }   

      
    while( pListGroup )
    {
        INET_ASSERT(pListGroup->dwGroupOffset);

        if( pListGroup->dwGroupOffset == dwOffset )
        {
            pListGroupPrev->dwNext = pListGroup->dwNext;

            // empty removed item and added it to free list
            pListGroup->dwGroupOffset = 0;
            pListGroup->dwNext= 0;
            AddToFreeList(pListGroup);

            dwError = ERROR_SUCCESS;
            break;
        }

        if( pListGroup->dwNext )
        {
            pListGroupPrev = pListGroup;
            pListGroup =  
                _pContainer->_UrlObjStorage->ValidateListGroupOffset(pListGroup->dwNext); 
        }
        else
        {
            dwError = ERROR_FILE_NOT_FOUND;
            break;

        }
    }

Cleanup:
    return dwError;
}

DWORD
GroupMgr::FindEmptySlotInListPage(DWORD* pdwOffsetToSlot)
{

    DWORD   dwError;
    DWORD   dwOffsetRoot = 0;
    LPBYTE  lpbBase = NULL;
    LIST_GROUP_ENTRY*   pListGroupFreeHead = NULL;
    LIST_GROUP_ENTRY*   pListGroupEmpty = NULL;

    if( !GetHeaderData( CACHE_HEADER_DATA_ROOT_GROUPLIST_OFFSET, &dwOffsetRoot))
    {
        dwError = ERROR_WINHTTP_INTERNAL_ERROR;
        goto Cleanup; 
    } 

    if( !dwOffsetRoot)
    {
        // new page needs to be created
        dwError = CreateNewListPage(&dwOffsetRoot, TRUE);

        if( dwError != ERROR_SUCCESS)
            goto Cleanup;
    } 

    // 
    // At this point, we've got the root entry 
    //  1. retrieved valid dwOffsetToRootEntry or 
    //  2. get the new dwOffsetToRootEntry via CreateNewPage() call  
    //
    INET_ASSERT( dwOffsetRoot);

    lpbBase = (LPBYTE) *_pContainer->_UrlObjStorage->GetHeapStart();
    pListGroupFreeHead =  (LIST_GROUP_ENTRY*) (lpbBase + dwOffsetRoot);                                   
    if( !pListGroupFreeHead )
    {
        dwError = ERROR_WINHTTP_INTERNAL_ERROR;
        goto Cleanup; 
    }

//////////////////////////////////////////////////////////////////
// BEGIN WARNING: The file might be grown and remapped, so all  //
// pointers into the file before this point may be invalidated. //
//////////////////////////////////////////////////////////////////
    // get the next free item from the list
    if( !pListGroupFreeHead->dwNext )
    {
        // no free slot left!, let's create a new page!

        // remember the old offset free list head entry
        DWORD_PTR dwpFreeHeadOffset = PtrDifference(pListGroupFreeHead, lpbBase);

        // create a new page
        DWORD  dwNewList;
        dwError = CreateNewListPage(&dwNewList, FALSE);

        if( dwError != ERROR_SUCCESS)
            goto Cleanup;

        // restore
        lpbBase = (LPBYTE) *_pContainer->_UrlObjStorage->GetHeapStart();
        pListGroupFreeHead =  (LIST_GROUP_ENTRY*) (lpbBase + dwpFreeHeadOffset);                                   
        //
        // add the newly created page contains a list of empty
        // slot (already chained together), now update the head 
        // of free list pointing to the head of the newly created
        // list
        //
        pListGroupFreeHead->dwNext = dwNewList;
    }
//////////////////////////////////////////////////////////////////
// END WARNING:   The file might be grown and remapped, so all  //
// pointers into the file before this point may be invalidated. //
//////////////////////////////////////////////////////////////////

     
    // get the empty slot offset
    *pdwOffsetToSlot = pListGroupFreeHead->dwNext;

    // update the free list to point to the next slot
    pListGroupEmpty = (LIST_GROUP_ENTRY*)(lpbBase + pListGroupFreeHead->dwNext);
    pListGroupFreeHead->dwNext = pListGroupEmpty->dwNext;
    
    memset(pListGroupEmpty, 0, sizeof(LIST_GROUP_ENTRY) );
    
    dwError = ERROR_SUCCESS;

Cleanup:
    return dwError;
}


DWORD
GroupMgr::CreateNewListPage(DWORD* pdwOffsetToFirstEntry, BOOL fIsFirstPage)
{
    DWORD                           dwError;
    GROUPS_ALLOC_FILEMAP_ENTRY*     pPage = NULL;
    DWORD cbSize = sizeof(GROUPS_ALLOC_FILEMAP_ENTRY);

    pPage = (GROUPS_ALLOC_FILEMAP_ENTRY*)
            _pContainer->_UrlObjStorage->AllocateEntry(cbSize);


    if( pPage )
    {
        // clean up allocated page
        cbSize = PAGE_SIZE_FOR_GROUPS;    
        memset(pPage->pGroupBlock, 0, cbSize );

        // calculate the group base offset 
        LPBYTE lpbBase = (LPBYTE) *_pContainer->_UrlObjStorage->GetHeapStart(); 

        *pdwOffsetToFirstEntry = PtrDiff32(pPage->pGroupBlock, lpbBase);

        //
        // chain all items together  
        // (Last item will have dwNext == 0 since we have alredy memset 
        //  the whole page ) 
        //
        LIST_GROUP_ENTRY*    pList = (LIST_GROUP_ENTRY*) pPage->pGroupBlock;

        for( DWORD dwi = 0; dwi < (LIST_GROUPS_PER_PAGE -1); dwi++)
        {
            pList->dwNext = PtrDiff32(pList+1, lpbBase);
            pList++ ;
        }


        if( fIsFirstPage )
        {
            //
            // for first page, we would have to set the offset 
            // back to the CacheHeader 
            //
            if( !SetHeaderData( 
                    CACHE_HEADER_DATA_ROOT_GROUPLIST_OFFSET, 
                    *pdwOffsetToFirstEntry))
            {
                // free allocated page
                _pContainer->_UrlObjStorage->FreeEntry(pPage);
        
                // set error and go
                *pdwOffsetToFirstEntry = 0;
                dwError = ERROR_WINHTTP_INTERNAL_ERROR;
                goto Cleanup;

            } // IF: failed to set the offset 
        }
        
        // return the offset to the first entry of the new page
        dwError = ERROR_SUCCESS;

    } // IF: Allocate new page succeed

    else
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
    } // ELSE: failed to allocate new page

Cleanup:
    return dwError;
}



BOOL    
GroupMgr::IsGroupOnList(DWORD dwHeadOffset, DWORD dwGrpOffset)
{
    BOOL    fRet = FALSE;
    LIST_GROUP_ENTRY*   pListGroup = NULL;

    LIST_GROUP_ENTRY   *pMilestone  = NULL; // used for detecting cycles
    unsigned long       dwNodeCount = 1;

    pListGroup = 
        _pContainer->_UrlObjStorage->ValidateListGroupOffset(dwHeadOffset); 
    if( !pListGroup )
    {
        goto Cleanup;
    }

    while( pListGroup )
    {
        //INET_ASSERT(pListGroup->dwGroupOffset);

        if( pListGroup->dwGroupOffset == dwGrpOffset )
        {
            fRet = TRUE;
            break;
        }

        if( pListGroup->dwNext )
        {
            LIST_GROUP_ENTRY*   plgTemp =  
                _pContainer->_UrlObjStorage->ValidateListGroupOffset(
                    pListGroup->dwNext); 

            // Sometimes the list is corrupted and contains a cycle
            // This is detected by comparing against the saved pointer
            // (Revisiting an earlier milestone indicates a cycle)
            if (plgTemp==pMilestone)
                break;

            // Also check (and fix) simple self-loops
            if (plgTemp==pListGroup) 
            {
                pListGroup->dwNext = 0;
                break;
            }

            // Advance to next node
            pListGroup = plgTemp;

            // Choose new milestone when node count is power of 2
            dwNodeCount++;

            if ((dwNodeCount & (dwNodeCount-1)) == 0)
                pMilestone = pListGroup;
        }
        else
        {
            break;
        }
    }

Cleanup:
    return fRet;
}


BOOL    
GroupMgr::NoMoreStickyEntryOnList(DWORD dwHeadOffset)
{
    BOOL                fRet = FALSE;
    LIST_GROUP_ENTRY*   pListGroup = NULL;
    GROUP_ENTRY*        pGroupEntry = NULL;

    pListGroup = 
        _pContainer->_UrlObjStorage->ValidateListGroupOffset(dwHeadOffset); 
    if( !pListGroup )
    {
        goto Cleanup;
    }

    while( pListGroup )
    {
        //INET_ASSERT(pListGroup->dwGroupOffset);

        // get the GroupEntry structure
        if( !_pContainer->_UrlObjStorage->IsBadGroupOffset(
                    pListGroup->dwGroupOffset) )
        {
            pGroupEntry = (GROUP_ENTRY*)
                ( *_pContainer->_UrlObjStorage->GetHeapStart() + 
                pListGroup->dwGroupOffset );

            // IsSticky?
            if( IsStickyGroup(pGroupEntry->gid) )
            {
                goto Cleanup;
            }
        } 


        // end of list
        if( !pListGroup->dwNext )
        {
            break;
        }

        // next item on list
        pListGroup =  _pContainer->_UrlObjStorage->ValidateListGroupOffset(
            pListGroup->dwNext); 
    }

    //
    // reach here means we are at end of the list and can not find
    // any sticky group, return TRUE
    //
    fRet = TRUE;

Cleanup:
    return fRet;


}


void
GroupMgr::AdjustUsageOnList(DWORD dwHeadOffset, LONGLONG llDelta)
{
    LIST_GROUP_ENTRY*   pListGroup = NULL;
    GROUP_ENTRY*        pGroupEntry = NULL;

    pListGroup = 
        _pContainer->_UrlObjStorage->ValidateListGroupOffset(dwHeadOffset); 
    if( !pListGroup )
    {
        goto Cleanup;
    }

    while( pListGroup )
    {
        // INET_ASSERT(pListGroup->dwGroupOffset);

        // get the GroupEntry structure
        if( !_pContainer->_UrlObjStorage->IsBadGroupOffset(
                    pListGroup->dwGroupOffset) )
        {
            pGroupEntry = (GROUP_ENTRY*)
                ( *_pContainer->_UrlObjStorage->GetHeapStart() + 
                pListGroup->dwGroupOffset );

            // AdjustUsage
            _pContainer->AdjustGroupUsage(pGroupEntry, llDelta);
        } 


        // end of list
        if( !pListGroup->dwNext )
        {
            goto Cleanup;
        }

        // next item on list
        pListGroup =  _pContainer->_UrlObjStorage->ValidateListGroupOffset(
            pListGroup->dwNext); 
    }

Cleanup:
    return;

}

void
GroupMgr::AddToFreeList(LIST_GROUP_ENTRY* pFreeListGroup)
{
    DWORD dwOffsetRoot  = 0;
    LIST_GROUP_ENTRY*   pFreeListHead = NULL;
    
    if( GetHeaderData( CACHE_HEADER_DATA_ROOT_GROUPLIST_OFFSET, &dwOffsetRoot))
    {

        pFreeListHead = 
            _pContainer->_UrlObjStorage->ValidateListGroupOffset(dwOffsetRoot); 
   
        if( pFreeListHead && pFreeListGroup )
        {
            pFreeListGroup->dwNext = pFreeListHead->dwNext;

            pFreeListHead->dwNext = PtrDiff32(pFreeListGroup,
                                              *_pContainer->_UrlObjStorage->GetHeapStart());
        } 
    } 
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\urlcache\makefile.inc ===
..\inc\urlcache.h: urlcache.w
    wcshdr < urlcache.w > $@

!IF "$(PROCESSOR_ARCHITECTURE)" == "x86"

urlcache.sym: urlcache.map
    ..\win32s\tools\mapsympe -o urlcache.sym urlcache.map
    binplace urlcache.map
    binplace urlcache.sym

!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\urlcache\proto.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    proto.h

Abstract:

    Contains proto type definitions of several functions.

Author:

    Madan Appiah (madana) 15-Nov-1994

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _PROTO_
#define _PROTO_

extern "C"
{
    VOID CacheScavenger(LPVOID Parameter);
}

LONGLONG GetGmtTime(VOID);

DWORD GetFileSizeAndTimeByName(
    LPCTSTR FileName,
    WIN32_FILE_ATTRIBUTE_DATA *lpFileAttrData
    );

DWORD
GetFileSizeByName(
    LPCTSTR pszFileName,
    DWORD *pdwFileSize
    );

BOOL InitGlobals (void);

void LaunchScavenger (void);

DWORD
CreateUniqueFile(
    LPCSTR UrlName,
    LPTSTR Path,
    LPTSTR FileName,
    LPTSTR Extension,
    HANDLE *phfHandle
    );

#endif  // _PROTO_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\urlcache\hashutil.cxx ===
/*++
Copyright (c) 1996  Microsoft Corp.

Module Name: hashutil.cxx

Abstract:

    Implementation of linked list of hash tables for cache index lookup.

Author:
    Rajeev Dujari (rajeevd) 22-Oct-96

--*/

#include <wininetp.h>
#include <cache.hxx>

#define SIG_HASH ('H'|('A'<<8)|('S'<<16)|('H'<<24))

typedef LIST_FILEMAP_ENTRY HASH_FILEMAP_ENTRY;

// hash table parameters
#define BYTES_PER_PAGE 4096

#define ITEMS_PER_BUCKET ((BYTES_PER_PAGE - sizeof(HASH_FILEMAP_ENTRY))\
    / (SLOT_COUNT * sizeof(HASH_ITEM)))
#define BYTES_PER_TABLE (sizeof(HASH_FILEMAP_ENTRY) \
    + SLOT_COUNT * ITEMS_PER_BUCKET * sizeof(HASH_ITEM))


//
// Hash Function: Pearson's method
//

PRIVATE DWORD HashKey (LPCSTR lpsz, DWORD dwAddedHash)
{
    union
    {
        DWORD dw;
        BYTE c[4];
    }
    Hash, Hash2;
        
    const static BYTE bTranslate[256] =
    {
        1, 14,110, 25, 97,174,132,119,138,170,125,118, 27,233,140, 51,
        87,197,177,107,234,169, 56, 68, 30,  7,173, 73,188, 40, 36, 65,
        49,213,104,190, 57,211,148,223, 48,115, 15,  2, 67,186,210, 28,
        12,181,103, 70, 22, 58, 75, 78,183,167,238,157,124,147,172,144,
        176,161,141, 86, 60, 66,128, 83,156,241, 79, 46,168,198, 41,254,
        178, 85,253,237,250,154,133, 88, 35,206, 95,116,252,192, 54,221,
        102,218,255,240, 82,106,158,201, 61,  3, 89,  9, 42,155,159, 93,
        166, 80, 50, 34,175,195,100, 99, 26,150, 16,145,  4, 33,  8,189,
        121, 64, 77, 72,208,245,130,122,143, 55,105,134, 29,164,185,194,
        193,239,101,242,  5,171,126, 11, 74, 59,137,228,108,191,232,139,
        6, 24, 81, 20,127, 17, 91, 92,251,151,225,207, 21, 98,113,112,
        84,226, 18,214,199,187, 13, 32, 94,220,224,212,247,204,196, 43,
        249,236, 45,244,111,182,153,136,129, 90,217,202, 19,165,231, 71,
        230,142, 96,227, 62,179,246,114,162, 53,160,215,205,180, 47,109,
        44, 38, 31,149,135,  0,216, 52, 63, 23, 37, 69, 39,117,146,184,
        163,200,222,235,248,243,219, 10,152,131,123,229,203, 76,120,209
    };

    // Seed the hash values based on the first character.
    Hash.c[0] = bTranslate[ *lpsz];
    Hash.c[1] = bTranslate[(*lpsz+1) & 255];
    Hash.c[2] = bTranslate[(*lpsz+2) & 255];
    Hash.c[3] = bTranslate[(*lpsz+3) & 255];
    Hash.dw += dwAddedHash;
    
    while (*++lpsz)
    {
        // Allow URLs differing only by trailing slash to collide.
        if (lpsz[0] == '/' && lpsz[1] == 0)
            break;

        Hash2.c[0] = Hash.c[0] ^ *lpsz;
        Hash2.c[1] = Hash.c[1] ^ *lpsz;
        Hash2.c[2] = Hash.c[2] ^ *lpsz;
        Hash2.c[3] = Hash.c[3] ^ *lpsz;
            
        Hash.c[0] = bTranslate[Hash2.c[0]];
        Hash.c[1] = bTranslate[Hash2.c[1]];
        Hash.c[2] = bTranslate[Hash2.c[2]];
        Hash.c[3] = bTranslate[Hash2.c[3]];
    }

    return Hash.dw;
}
    
//
// HashLookupItem support functions specific to urlcache:
//      AllocTable
//      IsMatch
//


PRIVATE HASH_FILEMAP_ENTRY* AllocTable
    (LPVOID pAllocObj, LPBYTE* ppBase, LPDWORD* ppdwOffset)
{
    // Save the offset to the table offset.
    DWORD_PTR dpOffsetToTableOffset = (LPBYTE)*ppdwOffset - *ppBase;  // 64BIT
    
    // Ask for BYTES_PER_PAGE instead of BYTES_PER_TABLE
    // so the allocator knows to align on a page boundary.
    INET_ASSERT (BYTES_PER_PAGE >= BYTES_PER_TABLE);
    MEMMAP_FILE* pmmf = (MEMMAP_FILE*) pAllocObj;
    HASH_FILEMAP_ENTRY* pTable =
        (HASH_FILEMAP_ENTRY *) pmmf->AllocateEntry (BYTES_PER_PAGE);
    if (!pTable)
        return NULL;  
    INET_ASSERT (! (((LPBYTE) pTable - *pmmf->GetHeapStart()) & (BYTES_PER_PAGE-1)) );

    // Chain new table to previous table.
    *ppBase = *pmmf->GetHeapStart();
    *ppdwOffset = (DWORD*) (*ppBase + dpOffsetToTableOffset);
    **ppdwOffset = (DWORD) ((LPBYTE)pTable - *ppBase);             // 64BIT
    
    // Initialize the header.
    pTable->dwSig = SIG_HASH;
    pTable->dwNext = 0;
    
    // Fill the rest of the entry with HASH_END
    DWORD* pdw = (DWORD *) (pTable + 1);
    DWORD cdw = SLOT_COUNT * ITEMS_PER_BUCKET * (sizeof(HASH_ITEM)/sizeof(DWORD));
    INET_ASSERT (!(sizeof(HASH_ITEM) % sizeof(DWORD)));
    while (cdw--)
        *pdw++ = HASH_END;

    // Return the new table.
    return pTable;
}

//
// IsMatch: determine if hash table item with a matching 32-bit hash value
// is an actual match or return NULL if a collision.
//

PRIVATE HASH_ITEM* URL_CONTAINER::IsMatch
    (HASH_ITEM *pItem, LPCSTR pszKey, DWORD dwFlags)
{
    MEMMAP_FILE* pmmf = _UrlObjStorage;

    dwFlags &= (LOOKUP_BIT_REDIR | LOOKUP_BIT_CREATE);

    if (pmmf->IsBadOffset (pItem->dwOffset))
    {
        // Fix up a bad hash table item.  This could happen if a thread
        // died between allocating a hash table item and setting the offset.
        pItem->MarkFree();
        return NULL;
    }

    FILEMAP_ENTRY* pEntry = (FILEMAP_ENTRY*)
        (*pmmf->GetHeapStart() + pItem->dwOffset);

    switch (pEntry->dwSig)
    {
        case SIG_URL:
        {        
            // Fail if lookup flags are inconsistent with url entry type.
            INET_ASSERT (!(pItem->dwHash & HASH_BIT_NOTURL));

            // Get pointer to URL.
            URL_FILEMAP_ENTRY *pUrlEntry = (URL_FILEMAP_ENTRY *) pEntry;
            LPSTR pszUrl = ((LPSTR) pUrlEntry) + pUrlEntry->UrlNameOffset;
            LPCSTR pszKey2 = pszKey, pszUrl2 = pszUrl;
            
            while ( *pszKey2 && *pszUrl2 && *pszKey2 == *pszUrl2 )
            {
                pszKey2++;
                pszUrl2++;
            }

            if (!*pszKey2 && ! *pszUrl2)
            {
                // Found exact match.

                if (dwFlags == LOOKUP_REDIR_CREATE)
                {
                    // We are have a cache entry for a URL which is now
                    // redirecting.  Delete the cache entry.
                    DeleteUrlEntry (pUrlEntry, pItem, SIG_DELETE);
                    return NULL;
                }

                return pItem;
            }

            // If redirects allowed, check for trailing slash match.
            if ((dwFlags == LOOKUP_URL_TRANSLATE)
                && (pItem->dwHash & HASH_BIT_REDIR))
            {
                DWORD cbUrl = strlen (pszUrl);
                DWORD cbKey = strlen (pszKey);
                INET_ASSERT (cbUrl && pszUrl[cbUrl - 1] == '/');
                if (cbUrl == (cbKey + 1) && !memcmp (pszUrl, pszKey, cbKey))
                    return pItem;
            }
                
            return NULL;
        }
        
        case SIG_REDIR:
        {
            // When online, filter out offline redirect entries.
            if (dwFlags == LOOKUP_URL_NOCREATE)
                return NULL;

            // Check that redirect URL matches exactly.
            REDIR_FILEMAP_ENTRY* pRedir = (REDIR_FILEMAP_ENTRY *) pEntry;
            if (lstrcmp (pszKey, pRedir->szUrl))
                return NULL;

            switch (dwFlags)
            {
                case LOOKUP_URL_CREATE:

                    // We are creating a new entry for a URL that once
                    // redirected.  Delete the stale redirect entry.
                    pmmf->FreeEntry (pRedir);
                    pItem->MarkFree();
                    return NULL;

                case LOOKUP_REDIR_CREATE:
                
                    // Return the redirect item if we're looking for it.
                    return pItem;

                case LOOKUP_URL_TRANSLATE:

                    // Otherwise, translate through the redirect item.
                    pItem = (HASH_ITEM *)
                        (*pmmf->GetHeapStart() + pRedir->dwItemOffset);

                    // Perform some consistency checks.
                    if (pItem->dwHash & HASH_BIT_NOTURL)
                        return NULL; // not an URL entry
                    if ((pItem->dwHash & ~SLOT_MASK) != pRedir->dwHashValue)
                        return NULL; // not a matching URL entry
                    return pItem;

                default:
                    INET_ASSERT (FALSE);                
            }
        }
        
        default:
        {
            // Fix up a bad hash table entry.  This can happen if a thread
            // died between allocating a hash table item and setting the offset.
            pItem->MarkFree();
            return NULL;
        }            
    }
}


//
// HashFindItem: finds a matching entry or else the first free slot
//

BOOL URL_CONTAINER::HashFindItem
    (LPCSTR pszKey, DWORD dwFlags, HASH_ITEM** ppItem)
{    
    INET_ASSERT(!((dwFlags & LOOKUP_URL_DONT_FOLLOW) && (dwFlags & LOOKUP_BIT_CREATE)));
    DWORD dwFind = 0;
    BOOL fLookAgain = !(dwFlags & LOOKUP_URL_DONT_FOLLOW) && GlobalIdentity;
again:
    LPVOID pAllocObj = (LPVOID) _UrlObjStorage;
    LPBYTE pBase = *_UrlObjStorage->GetHeapStart();
    LPDWORD pdwTableOffset = _UrlObjStorage->GetPtrToHashTableOffset();
    
    // Scan flags.
    BOOL fCreate = dwFlags & LOOKUP_BIT_CREATE;

    HASH_ITEM* pFree = NULL;
    DWORD nBlock = 0;
    
    // Hash the URL and calculate the slot.
    DWORD dwHash = HashKey(pszKey, dwFind);
    DWORD iSlot = dwHash & SLOT_MASK;
    dwHash &= ~SLOT_MASK;

    // Walk through the list of hash tables.
    while (*pdwTableOffset && !_UrlObjStorage->IsBadOffset(*pdwTableOffset))
    {
        // Calculate offset to next hash table and validate signature.
        HASH_FILEMAP_ENTRY* pTable =
            (HASH_FILEMAP_ENTRY*) (pBase + *pdwTableOffset);
        if (pTable->dwSig != SIG_HASH || pTable->nBlock != nBlock++)
            break;

        // Calculate offset to bucket in this table.
        HASH_ITEM* pItem = ((HASH_ITEM*) (pTable + 1)) + iSlot * ITEMS_PER_BUCKET;

        // Scan the bucket.
        for (DWORD iSeat=0; iSeat<ITEMS_PER_BUCKET; iSeat++, pItem++)
        {
            // No reserved bits should ever be set on an item.
            INET_ASSERT (!(pItem->dwHash & HASH_BIT_RESERVED));

            switch (pItem->dwHash)
            {
                case HASH_FREE: // free item but more items might follow
                {
                    INET_ASSERT (!(pItem->dwHash & ~SLOT_MASK)); 
                    // If caller wants a free item, record the first one we find.
                    if (!pFree && fCreate)
                        pFree = pItem;
                }                        
                    continue;

                case HASH_END: // first previously unused free item; no more to follow
                {
                    INET_ASSERT (!(pItem->dwHash & ~SLOT_MASK)); 
                    if (!fCreate)
                        *ppItem = NULL;
                    else
                    {
                        // Hand out the first free slot.
                        if (pFree)
                        {
                            // Invalidate offset in case caller neglects to set it.
                            pFree->dwOffset = HASH_END;
                            *ppItem = pFree;
                        }
                        else
                        {
                            // The first free slot has never been used before.
                            INET_ASSERT (pItem->dwOffset == HASH_END);
                            *ppItem = pItem;
                        }
                        (*ppItem)->dwHash = dwHash;
                    }
                }
                    return FALSE;

                default:
                {
                    // Check if the key matches.
                    if (dwHash == (pItem->dwHash & ~SLOT_MASK))
                    {
                        if (dwFlags & INTERNET_CACHE_FLAG_ALLOW_COLLISIONS)
                        {
                            *ppItem = pItem;
                            return TRUE;
                        }
                        
                        HASH_ITEM* pItem2 = IsMatch(pItem, pszKey, dwFlags);
                        if (pItem2)
                        {
                            LPURL_FILEMAP_ENTRY pEntry = 
                                (URL_FILEMAP_ENTRY*)(*(((MEMMAP_FILE*)_UrlObjStorage)->GetHeapStart())
                                                + pItem2->dwOffset);

                            // This will check for a ~U: header or IDENTITY_CACHE_ENTRY
                            // We use the first for compatibility with Wininet5
                            // We use IDENTITY_CACHE_ENTRY for entries we wish to hide from Wininet5
                            if ((pEntry->dwSig==SIG_URL)
                                && (!(dwFlags & LOOKUP_URL_DONT_FOLLOW) 
                                   && ((pEntry->CacheEntryType & IDENTITY_CACHE_ENTRY) 
                                       || IsPerUserEntry(pEntry))))
                            {
                                // We'll search again for an entry corresponding to GlobalIdentity
                                if (fLookAgain)
                                {
                                    fLookAgain = FALSE;
                                    dwFind = GlobalIdentity;
                                    goto again;
                                }

                                // Guarantee that this is what we want
                                if (pEntry->GetIdentity()!=GlobalIdentity)
                                {
                                    continue;
                                }
                                // If we're looking for an identity-0 cache entry
                                // and there is no filename, we need to do the following:
                                // 1. if we're trying to create an entry, then return this
                                // 2. otherwise, say No, the entry is not present
                                if (!pEntry->InternalFileNameOffset && !fCreate)
                                {
                                    *ppItem = NULL;
                                    return FALSE;
                                }
                            }
                            *ppItem = pItem2;
                            return TRUE;
                        }
                    }                    
                }
                    continue;
                    
            } // end switch
          
        } // end for loop to scan seats in bucket
        
        // Follow the link to the next table.
        pdwTableOffset = &pTable->dwNext;

    } // end while (*pdwTableOffset)

    // If we've encountered a corrupt table, we'll have to recover
    if (*pdwTableOffset)
    {
        INET_ASSERT(FALSE);
        *pdwTableOffset = 0;
    }
   
    // We are out a buckets, so an item hasn't been found.

    if (fCreate && !pFree)
    {
        // Caller wanted a free item but we didn't find one.
       
        HASH_FILEMAP_ENTRY* pTable = AllocTable
            (pAllocObj, &pBase, &pdwTableOffset);

//////////////////////////////////////////////////////////////////////
// WARNING: the file might have grown and remapped, so any pointers //
// hereafter must be recalculated by offsets from the new base.     //
//////////////////////////////////////////////////////////////////////

        if (pTable)
        {
            pTable->nBlock = nBlock;
            // Calculate next free slot.
            pFree = ((HASH_ITEM*) (pTable + 1)) + iSlot * ITEMS_PER_BUCKET;
            INET_ASSERT (pFree->dwHash   == HASH_END);
            INET_ASSERT (pFree->dwOffset == HASH_END);
        }
    }

    // Return free item if desired and indicate no item found.
    if (pFree)
    {
        INET_ASSERT (fCreate);
        pFree->dwHash   = dwHash;
        pFree->dwOffset = HASH_END; // invalid in case caller neglects to set it
    }
    *ppItem = pFree;
    return FALSE;
}

//
// HashFindNextItem: scans the table for the next valid URL item
//

PUBLIC
HASH_ITEM*
HashGetNextItem
(
    IN     LPVOID       pAllocObj,      // allocator object
    IN     LPBYTE       pBase,          // base for all offsets
    IN OUT LPDWORD      pdwItemOffset,  // current item offset
    IN     DWORD        dwFlags         // include redirects?
)
{
    INET_ASSERT (!(dwFlags & ~LOOKUP_BIT_REDIR));
    
    // Check if there if the hash table is empty (or we are at the end already.)
    if (!*pdwItemOffset)
        return NULL;

    HASH_ITEM* pItem = (HASH_ITEM*) (pBase + *pdwItemOffset);

    // Calculate current table offset, assuming it's the previous page boundary.
    INET_ASSERT (BYTES_PER_TABLE <= BYTES_PER_PAGE);
    HASH_FILEMAP_ENTRY* pTable =
        (HASH_FILEMAP_ENTRY*) (((DWORD_PTR)pItem) & ~(BYTES_PER_PAGE - 1));

    // Advance item pointer to next location.
    if (pItem == (HASH_ITEM*) pTable)
        pItem = (HASH_ITEM*) (pTable + 1); // first location in table
    else
        pItem++; // next location in table

    do // Scan the list of tables.
    {
        if (pTable->dwSig != SIG_HASH)
            break;
            
        // Scan the current table.
        for (; (LPBYTE) pItem < ((LPBYTE) pTable) + BYTES_PER_TABLE; pItem++)
        {
            // No reserved bits should be set.
            INET_ASSERT (!(pItem->dwHash & HASH_BIT_RESERVED));
            
            if (!(pItem->dwHash & HASH_BIT_NOTURL)
                ||      (dwFlags /* & LOOKUP_BIT_REDIR */)
                    &&  ((pItem->dwHash & HASH_FLAG_MASK) == HASH_REDIR))
            {
                // Found a valid entry.
                *pdwItemOffset = (DWORD) ((LPBYTE)pItem - pBase);  // 64BIT
                return pItem;
            }
        }

        // Follow the link to the next table.
        if (!pTable->dwNext)
            pTable = NULL;
        else
        {
            // Validate the table signature and sequence number.
            DWORD nBlock = pTable->nBlock;
            pTable = (HASH_FILEMAP_ENTRY*) (pBase + pTable->dwNext);
            if (pTable->dwSig != SIG_HASH || pTable->nBlock != nBlock + 1)
                pTable = NULL;

            // Set pointer to first location in table.
            pItem = (HASH_ITEM*) (pTable + 1);
        }
    }
        while (pTable);

    // We reached the end of the last table.
    *pdwItemOffset = 0;
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\urlcache\oldnames.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    oldnames.h

Abstract:

    contains old names of cache structures, etc.

Author:

    Richard L Firth (rfirth) 09-May-1996

Revision History:

    09-May-1996 rfirth
        Created

--*/

#define CACHE_ENTRY_INFO            INTERNET_CACHE_ENTRY_INFO
#define LPCACHE_ENTRY_INFO          LPINTERNET_CACHE_ENTRY_INFO

#define CACHE_ENTRY_INFOA           INTERNET_CACHE_ENTRY_INFOA
#define LPCACHE_ENTRY_INFOA         LPINTERNET_CACHE_ENTRY_INFOA

#define CACHE_ENTRY_INFOW           INTERNET_CACHE_ENTRY_INFOW
#define LPCACHE_ENTRY_INFOW         LPINTERNET_CACHE_ENTRY_INFOW

#define CACHE_CONFIG_PATH_ENTRY     INTERNET_CACHE_CONFIG_PATH_ENTRY
#define LPCACHE_CONFIG_PATH_ENTRY   LPINTERNET_CACHE_CONFIG_PATH_ENTRY

#define CACHE_CONFIG_PATH_ENTRYA    INTERNET_CACHE_CONFIG_PATH_ENTRYA
#define LPCACHE_CONFIG_PATH_ENTRYA  LPINTERNET_CACHE_CONFIG_PATH_ENTRYA

#define CACHE_CONFIG_PATH_ENTRYW    INTERNET_CACHE_CONFIG_PATH_ENTRYW
#define LPCACHE_CONFIG_PATH_ENTRYW  LPINTERNET_CACHE_CONFIG_PATH_ENTRYW

#define CACHE_CONFIG_INFO           INTERNET_CACHE_CONFIG_INFO
#define LPCACHE_CONFIG_INFO         LPINTERNET_CACHE_CONFIG_INFO

#define CACHE_CONFIG_INFOA          INTERNET_CACHE_CONFIG_INFOA
#define LPCACHE_CONFIG_INFOA        LPINTERNET_CACHE_CONFIG_INFOA

#define CACHE_CONFIG_INFOW          INTERNET_CACHE_CONFIG_INFOW
#define LPCACHE_CONFIG_INFOW        LPINTERNET_CACHE_CONFIG_INFOW
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\urlcache\ids.cxx ===
/*++

Copyright (c) 1994-2000  Microsoft Corporation

Module Name:

    ids.cxx

Abstract:

    Contains functions responsible for managing identities in wininet
    
    Contents:

Author:

    July - September 1999. akabir

Environment:

    Win32 user-mode DLL

Revision History:


--*/

#include <wininetp.h>
#include <cache.hxx>

#undef SHGetFolderPath
HRESULT SHGetFolderPath(HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, LPSTR pszPath);


#if 0

#include <hlink.h>
#include <urlmon.h>
#include <shlobj.h>
#define HMONITOR_DECLARED    1
#include <shlobjp.h>


typedef HRESULT (*PFNSHGETDESKTOPFOLDER)(IShellFolder**);

HRESULT _SHGetDesktopFolder(IShellFolder **psfDesktop)
{
    HMODULE h = LoadLibrary("shell32.dll");
    HRESULT hr = E_POINTER;
    if (h) 
    {
        PFNSHGETDESKTOPFOLDER pfn = (PFNSHGETDESKTOPFOLDER)GetProcAddress(h, "SHGetDesktopFolder");
        if (pfn)
        {
            hr = pfn(psfDesktop);
        }
        FreeLibrary(h);
    }
    return hr;
}

typedef VOID (*PFNILFREE)(LPITEMIDLIST);

VOID _ILFree(LPITEMIDLIST pidl)
{
    HMODULE h = LoadLibrary("shell32.dll");
    if (h) 
    {
        PFNILFREE pfn = (PFNILFREE)GetProcAddress(h, "ILFree");
        if (pfn)
        {
            pfn(pidl);
        }
        FreeLibrary(h);
    }
}


const GUID  DefaultGuid = { 0x00000000L, 0x0000, 0x0000, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
const GUID  IID_IHistSFPrivate = { 0x62e1261L, 0xa60e, 0x11d0, 0x82, 0xc2, 0x0, 0xc0, 0x4f, 0xd5, 0xae, 0x38 };
#endif // 0


// -- Utility functions --------------------------------------------------------------------------------------

// Create an ansi representation of a guid.
VOID GuidToAnsiStr(GUID* pGuid, PSTR psz, DWORD dwSize)
{
    WCHAR   wszUid[MAX_PATH];
    StringFromGUID2(*pGuid, wszUid, ARRAY_ELEMENTS(wszUid));
    SHUnicodeToAnsi(wszUid, psz, dwSize);
}


REGISTRY_OBJ* CreateExtensiRegObjFor(HKEY hKey, GUID* pguid)
{
    REGISTRY_OBJ *pro = NULL;

    CHAR sz[MAX_PATH];    
    GuidToAnsiStr(pguid, sz, ARRAY_ELEMENTS(sz));

    CHAR szBranches[MAX_PATH];
    if (wnsprintf(szBranches, ARRAY_ELEMENTS(szBranches), 
                              "%s\\%s\\%s", 
                              IDENTITIES_KEY, 
                              sz, 
                              EXTENSIBLE_CACHE_PATH_KEY) >= 0)
    {
        pro = new REGISTRY_OBJ(hKey, szBranches, CREATE_KEY_IF_NOT_EXISTS);
    }

    return pro;
}

#ifdef WININET6
DWORD IDRegDwordCore(LPCTSTR psz, PDWORD pdw, BOOL fSet)
{
    INET_ASSERT(GlobalIdentity);
    
    CHAR sz[MAX_PATH];    
    GuidToAnsiStr(&GlobalIdentityGuid, sz, ARRAY_ELEMENTS(sz));

    CHAR szBranches[MAX_PATH];
    DWORD dwError = ERROR_INVALID_PARAMETER;
    if (wnsprintf(szBranches, ARRAY_ELEMENTS(szBranches), 
                              "%s\\%s", 
                              IDENTITIES_KEY, 
                              sz) >= 0)
    {
        REGISTRY_OBJ ro(GlobalCacheHKey, szBranches);
        dwError = ro.GetStatus();
        if (dwError==ERROR_SUCCESS)
        {
            dwError = fSet ? ro.SetValue((LPTSTR)psz, pdw)
                           : ro.GetValue((LPTSTR)psz, pdw);
        }
    }
    return dwError;
}

DWORD ReadIDRegDword(LPCTSTR psz, PDWORD pdw)
{
    return IDRegDwordCore(psz, pdw, FALSE);
}

DWORD WriteIDRegDword(LPCTSTR psz, DWORD dw)
{
    return IDRegDwordCore(psz, &dw, TRUE);
}
#endif

// Disable the funny business of altering identities for now. It can be
// enabled once we have a better understanding of how this can fit
// into WinHttp
#if 0

VOID CreateCurrentHistory()
{
    INTERNET_CACHE_CONFIG_INFO icci;
    icci.dwStructSize = sizeof(icci);
    if (GlobalUrlContainers->GetUrlCacheConfigInfo(&icci, NULL, CACHE_CONFIG_HISTORY_PATHS_FC)
        && SUCCEEDED(CoInitialize(NULL)))
    {
        // We want to ensure that the history is valid for this user.
        IShellFolder *psfDesktop;
        if (SUCCEEDED(_SHGetDesktopFolder(&psfDesktop)))
        {
            WCHAR wszPath[MAX_PATH];
            LPITEMIDLIST pidlHistory;
            IShellFolder *psfHistory;
            MultiByteToWideChar(CP_ACP, 0, icci.CachePath, -1, wszPath, ARRAY_ELEMENTS(wszPath));
            PathRemoveFileSpecW(wszPath);  // get the trailing slash
            PathRemoveFileSpecW(wszPath);  // get the trailing slash
            PathRemoveFileSpecW(wszPath);  // trim the "content.ie5" junk
            if (SUCCEEDED(psfDesktop->ParseDisplayName(NULL, NULL, wszPath, NULL, &pidlHistory, NULL)))
            {
                if (SUCCEEDED(psfDesktop->BindToObject(pidlHistory, NULL, IID_IShellFolder, (VOID**)&psfHistory)))
                {
                    IHistSFPrivate *phsf;
                    if (SUCCEEDED(psfHistory->QueryInterface(IID_IHistSFPrivate, (void**)&phsf)))
                    {
                        FILETIME ftBogus = { 0 };
                        // This forces the validation in shdocvw
                        phsf->WriteHistory(L"", ftBogus, ftBogus, NULL);
                        phsf->Release();
                    }
                    psfHistory->Release();
                }
                _ILFree(pidlHistory);
            }
            psfDesktop->Release();
        }
        CoUninitialize();
    }
}


CONST TCHAR c_szIdentityOrdinal[] = "Identity Ordinal";

DWORD MapGuidToOrdinal(GUID* lpGUID)
{
    DWORD dwOrdinal = 0;
    HKEY    hSourceSubKey;

    if (!memcmp(lpGUID, &DefaultGuid, sizeof(DefaultGuid)))
    {
        return 0;
    }

    if (RegCreateKey(HKEY_CURRENT_USER, IDENTITIES_KEY, &hSourceSubKey) == ERROR_SUCCESS)
    {        
        CHAR    szUid[MAX_PATH];
        GuidToAnsiStr(lpGUID, szUid, ARRAY_ELEMENTS(szUid));

        DWORD   dwSize, dwType;
        DWORD   dwIdentityOrdinal = 1;

        dwSize = sizeof(dwIdentityOrdinal);
        RegQueryValueEx(hSourceSubKey, c_szIdentityOrdinal, NULL, &dwType, (LPBYTE)&dwIdentityOrdinal, &dwSize);

        HKEY    hkUserKey;
        if (RegCreateKey(hSourceSubKey, szUid, &hkUserKey) == ERROR_SUCCESS)
        {
            if (RegQueryValueEx(hkUserKey, c_szIdentityOrdinal, NULL, &dwType, (LPBYTE)&dwOrdinal, &dwSize)!=ERROR_SUCCESS)
            {
                if (RegSetValueEx(hkUserKey, c_szIdentityOrdinal, NULL, REG_DWORD, (LPBYTE)&dwIdentityOrdinal, dwSize)==ERROR_SUCCESS)
                {
                    dwOrdinal = dwIdentityOrdinal++;
                    RegSetValueEx(hSourceSubKey, c_szIdentityOrdinal, 0, REG_DWORD, (LPBYTE)&dwIdentityOrdinal, dwSize);
                }
            }            
            RegCloseKey(hkUserKey); 
        }
        RegCloseKey(hSourceSubKey);
    }

    INET_ASSERT(dwOrdinal);
    return dwOrdinal;
}

DWORD AlterIdentity(DWORD dwFlags)
{
    if (!GlobalIdentity)
    {
        return ERROR_INVALID_PARAMETER;
    }
    switch (dwFlags)
    {
    case INTERNET_IDENTITY_FLAG_PRIVATE_CACHE:
    case INTERNET_IDENTITY_FLAG_SHARED_CACHE:
    case INTERNET_IDENTITY_FLAG_CLEAR_DATA:
    case INTERNET_IDENTITY_FLAG_CLEAR_COOKIES:
    case INTERNET_IDENTITY_FLAG_CLEAR_HISTORY:
    case INTERNET_IDENTITY_FLAG_CLEAR_CONTENT:
        break;
    }    
    return ERROR_CALL_NOT_IMPLEMENTED;
}

DWORD RemoveIdentity(GUID* pguidIdentity)
{
    if (!pguidIdentity 
        || !memcmp(pguidIdentity, &DefaultGuid, sizeof(DefaultGuid)))
    {
        return ERROR_INVALID_PARAMETER;
    }

    CHAR    szUid[MAX_PATH];
    GuidToAnsiStr(pguidIdentity, szUid, ARRAY_ELEMENTS(szUid));
    DWORD dwIdentity = MapGuidToOrdinal(pguidIdentity);
    if (dwIdentity==GlobalIdentity)
    {
        DWORD dwErr = SwitchIdentity(NULL);
        if (dwErr!=ERROR_SUCCESS)
            return dwErr;
    }

    DWORD dwErr = ERROR_INVALID_PARAMETER;
    REGISTRY_OBJ roIds(HKEY_CURRENT_USER, IDENTITIES_KEY);
    if (roIds.GetStatus()==ERROR_SUCCESS)
    {        
        // We want to delete the containers before we delete the reg keys.
        // First the extensible containers
        REGISTRY_OBJ* pro = CreateExtensiRegObjFor(HKEY_CURRENT_USER, pguidIdentity);
        if (pro && (pro->GetStatus()==ERROR_SUCCESS))
        {
            CHAR szVendorKey[MAX_PATH];
            while (pro->FindNextKey(szVendorKey, MAX_PATH) == ERROR_SUCCESS)
            {
                REGISTRY_OBJ roVendor(pro, szVendorKey);
                if (roVendor.GetStatus()==ERROR_SUCCESS)
                {
                    TCHAR szPath[MAX_PATH];
                    DWORD ccKeyLen = ARRAY_ELEMENTS(szPath);
                    if (roVendor.GetValue(CACHE_PATH_VALUE, (LPBYTE) szPath, &ccKeyLen)==ERROR_SUCCESS)
                    {
                        TCHAR szScratch[MAX_PATH+1];
                        ExpandEnvironmentStrings(szPath, szScratch, ARRAY_ELEMENTS(szScratch)-1); // don't count the NULL
                        DeleteCachedFilesInDir(szScratch);
                        RemoveDirectory(szScratch);
                    }
                }
            }
        }
        if (pro)
        {
            delete pro;
        }
        TCHAR szPath[MAX_PATH];
        if ((S_OK==SHGetFolderPath(NULL, CSIDL_COOKIES | CSIDL_FLAG_CREATE, NULL, 0, szPath))
            && (*szPath!='\0'))
        {
            if (GenerateStringWithOrdinal(NULL, dwIdentity, szPath, ARRAY_ELEMENTS(szPath)))
            {
                DeleteCachedFilesInDir(szPath);
                RemoveDirectory(szPath);
            }
        }
        if ((S_OK==SHGetFolderPath(NULL, CSIDL_HISTORY | CSIDL_FLAG_CREATE, NULL, 0, szPath))
            && (*szPath!='\0'))
        {
            StrCatBuff(szPath, "\\History.IE5", ARRAY_ELEMENTS(szPath));
            if (GenerateStringWithOrdinal(NULL, dwIdentity, szPath, ARRAY_ELEMENTS(szPath)))
            {
                DeleteCachedFilesInDir(szPath);
                RemoveDirectory(szPath);
            }
        }

        // We'll leave the content; it'll be scavenged anyway.        
        if (roIds.DeleteKey(szUid)==ERROR_SUCCESS)
        {
            dwErr = ERROR_SUCCESS;
        }
    }
    return dwErr;
}


DWORD SwitchIdentity(GUID* pguidIdentity)
{
    DWORD dwIdentity = pguidIdentity ? MapGuidToOrdinal(pguidIdentity) : 0;
    if (dwIdentity==GlobalIdentity)
        return ERROR_SUCCESS;

    DWORD dwErr = ERROR_SUCCESS;
    
    LOCK_CACHE();
    INET_ASSERT(dwIdentity!=GlobalIdentity);

    CloseTheCookieJar();

    DWORD dwTemp = GlobalIdentity;
    GUID guidTemp;
    GlobalIdentity = dwIdentity;
    GlobalCacheInitialized = FALSE;
    memcpy(&guidTemp, &GlobalIdentityGuid, sizeof(GlobalIdentityGuid));
    if (dwIdentity==0)
    {
        memset(&GlobalIdentityGuid, 0, sizeof(GlobalIdentityGuid));
    }
    else
    {
        memcpy(&GlobalIdentityGuid, pguidIdentity, sizeof(*pguidIdentity));
    }

    CConMgr* NewGUC = new CConMgr();

    if (!NewGUC 
        || (NewGUC->GetStatus()!=ERROR_SUCCESS)
        || (!InternetSetOption(NULL, INTERNET_OPTION_END_BROWSER_SESSION, NULL, 0)))
    {
        INET_ASSERT(FALSE);
        if (NewGUC)
            delete NewGUC;
        
        dwErr = ERROR_WINHTTP_INTERNAL_ERROR;
        GlobalCacheInitialized = TRUE;
        GlobalIdentity = dwTemp;
        memcpy(&GlobalIdentityGuid, &guidTemp, sizeof(GlobalIdentityGuid));
        goto exit;
    }

    // We need to stop the scavenger
    GlobalPleaseQuitWhatYouAreDoing = TRUE;
    while (GlobalScavengerRunning!=-1)
    {
        Sleep(0);
    }
    
    delete GlobalUrlContainers;
    GlobalUrlContainers = NewGUC;
    GlobalCacheInitialized = TRUE;

    // It's safe now, you can scavenge
    GlobalPleaseQuitWhatYouAreDoing = FALSE;

    if (AnyFindsInProgress(0))
    {
        HandleMgr.InvalidateAll();
    }

    CreateCurrentHistory();
    
    // Note to ASK: check what this call does, if it affects identities
    if ((dwErr = GlobalUrlContainers->CreateDefaultGroups())!=ERROR_SUCCESS)
        goto exit;
        
    if (!OpenTheCookieJar()) 
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

#ifdef WININET6
    // Set warnings appropriately.
    GlobalWarnOnPost = FALSE;
    GlobalWarnAlways = FALSE;
    GlobalWarnOnZoneCrossing = TRUE;
    GlobalWarnOnBadCertSending = FALSE;
    GlobalWarnOnBadCertRecving = TRUE;
    GlobalWarnOnPostRedirect = TRUE;
    GlobalDataReadWarningUIFlags();
#endif

exit:
    UNLOCK_CACHE();
    INET_ASSERT((dwErr==ERROR_SUCCESS));
    return dwErr;
}

#endif


// CreateExtensiRegObj ----------------
// Create an identity-appropriate registry object
// for extensible cache containers.

REGISTRY_OBJ* CreateExtensiRegObj(HKEY hKey)
{
    REGISTRY_OBJ *pro = NULL;
    
    if (GlobalIdentity)
    {
        pro = CreateExtensiRegObjFor(hKey, &GlobalIdentityGuid);
    }
    else
    {
        REGISTRY_OBJ roCache(hKey, CACHE5_KEY);
        if (roCache.GetStatus()==ERROR_SUCCESS)
        {
            pro = new REGISTRY_OBJ(&roCache, EXTENSIBLE_CACHE_PATH_KEY, CREATE_KEY_IF_NOT_EXISTS);
        }
    }

    if (pro && pro->GetStatus()!=ERROR_SUCCESS)
    {
        delete pro;
        pro = NULL;
    }

    return pro;
}


// GenerateStringWithOrdinal ------------
// We want to append the identity ordinal to a string
// If psz is null, then pszBuffer better contain a 0-terminated string that we can
//      append the ordinal to.
// Otherwise, we copy psz to pszBuffer and append to that.
BOOL GenerateStringWithOrdinal(PCTSTR psz, DWORD dwOrdinal, PTSTR pszBuffer, DWORD dwMax)
{
    DWORD cc = psz ? lstrlen(psz) : lstrlen(pszBuffer);

    if (cc>dwMax)
        return FALSE;

    if (psz)
    {
        memcpy(pszBuffer, psz, cc*sizeof(*pszBuffer));
    }
    
    if (dwOrdinal)
    {
        if (!AppendSlashIfNecessary(pszBuffer, &cc))
            return FALSE;   

        if (wnsprintf(pszBuffer+cc, dwMax-cc,
                                "%d", 
                                dwOrdinal) < 0)
            return FALSE;
    }
    else
    {
        pszBuffer[cc] = TEXT('\0');
    }
    
    return TRUE;
}

// IsPerUserEntry
// Examine the headers of a cache entry to determine whether or 
// not it is user-specific

BOOL IsPerUserEntry(LPURL_FILEMAP_ENTRY pfe)
{
    INET_ASSERT(pfe);
    
    BOOL fRet = FALSE;
    PTSTR lpszHeaderInfo = (PTSTR)pfe + pfe->HeaderInfoOffset;
    DWORD dwHeaderSize = pfe->HeaderInfoSize;

    if (!lpszHeaderInfo || !dwHeaderSize)
    {
        return FALSE;
    }
    
    LPSTR lpTemp = lpszHeaderInfo+dwHeaderSize-1;
    LPSTR lpTemp2;

    // start searching backwards

    while (lpTemp >= lpszHeaderInfo) 
    {
        if (*lpTemp ==':') 
        {
                   // compare with "~U:"
            fRet = (!strnicmp(lpTemp-2, vszUserNameHeader, sizeof(vszUserNameHeader)-1))
                   // guarantee that this is the beginning of a header
                   && (((lpTemp-2)==lpszHeaderInfo)
                       || isspace(*(lpTemp-3)));
            break;
        }
        --lpTemp;
    }
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\urlcache\reg.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    reg.cxx

Abstract:

    Contains code that implements REGISTRY_OBJ class defined in reg.hxx.

Author:

    Madan Appiah (madana)  19-Dec-1994

Environment:

    User Mode - Win32

Revision History:

--*/

#include <wininetp.h>
#include <cache.hxx>

REGISTRY_OBJ::REGISTRY_OBJ(
    HKEY Handle,
    DWORD Error
    )
/*++

Routine Description:

    This function is a inline function that initialize the registry
    object with given handle and status.

Arguments:

    Handle : registry object handle value.

    Error : registry object status value.

Return Value:

    None.

--*/
{
    _RegHandle = Handle;
    _Status = Error;
    _Index = 0;
    _ValIndex = 0;
    _dwAccess = DEFAULT_KEY_ACCESS;
    return;
};


DWORD REGISTRY_OBJ::WorkWith(
    HKEY ParentHandle,
    LPTSTR KeyName,
    DWORD dwFlags,
    DWORD dwAccess
    )
/*++

Routine Description:

    Initializes the registry object from its parent's registry key
    handle and this object's keyname.

Arguments:

    ParentHandle : registry handle of the parent key.

    Keyname : key name of the new registry object being created.

Return Value:

    None.

--*/
{
    if (_RegHandle)
    {
        REGCLOSEKEY(_RegHandle);
    }
    _Index = 0;
    _ValIndex = 0;
    _dwAccess = dwAccess;
    
    _Status = REGOPENKEYEX(
                ParentHandle,
                KeyName,
                0,
                _dwAccess,
                &_RegHandle );

    if (_Status == ERROR_FILE_NOT_FOUND  && dwFlags == CREATE_KEY_IF_NOT_EXISTS)
    {
        REGISTRY_OBJ roTemp(ParentHandle, (LPSTR)NULL);
        _Status = roTemp.GetStatus();
        if (_Status==ERROR_SUCCESS)
        {
            _Status = roTemp.Create(KeyName, &_RegHandle);
        }
    }

    if( _Status != ERROR_SUCCESS )
    {
        _RegHandle = NULL;
    }

    return _Status;
}

DWORD REGISTRY_OBJ::WorkWith(
    REGISTRY_OBJ *ParentObj,
    LPTSTR KeyName,
    DWORD dwFlags
    )
/*++

Routine Description:

    Initializes the registry object from its parent's registry object
    and this object's keyname.

Arguments:

    ParentObj : registry object of the parent.

    Keyname : key name of the new registry object being created.

Return Value:

    None.

--*/
{
    if (_RegHandle)
    {
        REGCLOSEKEY(_RegHandle);
    }
    _Index = 0;
    _ValIndex = 0;
    _dwAccess = ParentObj->GetAccessFlags();
    _Status = REGOPENKEYEX(
                ParentObj->_RegHandle,
                KeyName,
                0,
                _dwAccess,
                &_RegHandle );

    if (_Status == ERROR_FILE_NOT_FOUND  && dwFlags == CREATE_KEY_IF_NOT_EXISTS)
    {
        _Status = ParentObj->Create(KeyName, &_RegHandle);
    }

    if( _Status != ERROR_SUCCESS )
    {
        _RegHandle = NULL;
    }

    return _Status;
}

DWORD
REGISTRY_OBJ::Create(
    LPTSTR ChildName,
    HKEY* pChildHandle
    )
/*++

Routine Description:

    Creates a new subkey under this key.

Arguments:

    ChildName : name of the subkey being created.

Return Value:

    Windows Error Code.

--*/
{
    HKEY ChildHandle;
    DWORD KeyDisposition;

    _Status = REGCREATEKEYEX(
               _RegHandle,
               ChildName,
               0,
               DEFAULT_CLASS,
               REG_OPTION_NON_VOLATILE,
               DEFAULT_KEY_ACCESS,
               NULL,
               (pChildHandle) ? pChildHandle : &ChildHandle,
               &KeyDisposition );

    if( _Status != ERROR_SUCCESS )
    {
        return( _Status );
    }

    if( KeyDisposition == REG_CREATED_NEW_KEY ) {
#ifndef unix
        TcpsvcsDbgPrint(( DEBUG_REGISTRY,
           "Registry key (%ws) is created.\n", ChildName ));
#else
        TcpsvcsDbgPrint(( DEBUG_REGISTRY,
           "Registry key (%s) is created.\n", ChildName ));
#endif /* unix */
    }

    //
    // close the child handle before return.
    //

    if (!pChildHandle)
    {
        REGCLOSEKEY( ChildHandle );
    }

    return( ERROR_SUCCESS );
}


DWORD
REGISTRY_OBJ::Create(
    LPTSTR ChildName,
    REGISTRY_OBJ **ChildObj
    )
/*++

Routine Description:

    Creates a new subney and a new subney registry object.

Arguments:

    ChildName : name of the subkey being created.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    HKEY ChildHandle;
    DWORD KeyDisposition;

    Error = REGCREATEKEYEX(
                _RegHandle,
                ChildName,
                0,
                DEFAULT_CLASS,
                REG_OPTION_NON_VOLATILE,
                DEFAULT_KEY_ACCESS,
                NULL,
                &ChildHandle,
                &KeyDisposition );


    if( Error != ERROR_SUCCESS ) {
        *ChildObj = new REGISTRY_OBJ( NULL, Error );
    }
    else {

        if( KeyDisposition == REG_CREATED_NEW_KEY ) {
#ifndef unix
            TcpsvcsDbgPrint(( DEBUG_REGISTRY,
               "Registry key (%ws) is created.\n", ChildName ));
#else
            TcpsvcsDbgPrint(( DEBUG_REGISTRY,
               "Registry key (%s) is created.\n", ChildName ));
#endif /* unix */
        }

        *ChildObj = new REGISTRY_OBJ( ChildHandle, (DWORD)ERROR_SUCCESS );
    }

    return( Error );
}

DWORD
REGISTRY_OBJ::Create(
    LPTSTR ChildName,
    REGISTRY_OBJ **ChildObj,
    DWORD *KeyDisposition
    )
/*++

Routine Description:

    Creates a new subney and a new subney registry object.

Arguments:

    ChildName : name of the subkey being created.

    ChildObj : pointer to a location where the child registry object
        pointer is returned.

    KeyDisposition : pointer to a location where the child KeyDisposition
        value is returned.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    HKEY ChildHandle;

    Error = REGCREATEKEYEX(
                _RegHandle,
                ChildName,
                0,
                DEFAULT_CLASS,
                REG_OPTION_NON_VOLATILE,
                DEFAULT_KEY_ACCESS,
                NULL,
                &ChildHandle,
                KeyDisposition );


    if( Error != ERROR_SUCCESS ) {
        *ChildObj = new REGISTRY_OBJ( NULL, Error );
    }
    else {

        if( *KeyDisposition == REG_CREATED_NEW_KEY ) {
#ifndef unix
            TcpsvcsDbgPrint(( DEBUG_REGISTRY,
               "Registry key (%ws) is created.\n", ChildName ));
#else
            TcpsvcsDbgPrint(( DEBUG_REGISTRY,
               "Registry key (%s) is created.\n", ChildName ));
#endif /* unix */
        }

        *ChildObj = new REGISTRY_OBJ( ChildHandle, (DWORD)ERROR_SUCCESS );
    }

    return( Error );
}

DWORD
REGISTRY_OBJ::GetValue(
    LPTSTR ValueName,
    DWORD *Data
    )
/*++

Routine Description:

    Gets a REG_DWORD value.

Arguments:

    ValueName : name of the value being retrived.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    DWORD ValueType;
    DWORD ValueSize = sizeof(DWORD);

    Error = RegQueryValueEx(
                _RegHandle,
                ValueName,
                0,
                &ValueType,
                (LPBYTE)Data,
                &ValueSize );

//    TcpsvcsDbgAssert( ValueSize == sizeof( DWORD ) );
//    TcpsvcsDbgAssert( ValueType == REG_DWORD );

    return( Error );
}

DWORD
REGISTRY_OBJ::GetValue(
    LPTSTR ValueName,
    LPTSTR *Data,
    DWORD *NumStrings
    )
/*++

Routine Description:

    Gets a REG_SZ or REG_EXPAND_SZ or REG_MULTI_SZ value.

Arguments:

    ValueName : name of the value being retrived.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    DWORD ValueType;
    DWORD ValueSize;
    LPBYTE StringData = NULL;

    Error = GetValueSizeAndType( ValueName, &ValueSize, &ValueType );

    if( Error != ERROR_SUCCESS ) {
        return( Error );
    }

    TcpsvcsDbgAssert(
        (ValueType == REG_SZ) ||
        (ValueType == REG_EXPAND_SZ) ||
        (ValueType == REG_MULTI_SZ) );

    StringData = (LPBYTE)CacheHeap->Alloc( ValueSize );

    if( StringData == NULL ) {
        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    Error = RegQueryValueEx(
                _RegHandle,
                ValueName,
                0,
                &ValueType,
                StringData,
                &ValueSize );

    if( Error != ERROR_SUCCESS ) {
        CacheHeap->Free( StringData );
        return( Error );
    }

#ifdef unix
    if (Error == ERROR_SUCCESS) {
       CHAR szExpand[MAX_PATH+1];
        DWORD Length = ExpandEnvironmentStrings((LPTSTR)StringData,
                                                (LPTSTR)szExpand,
                                                MAX_PATH);
       if (Length == 0 || Length > MAX_PATH) {
           Error = GetLastError();
           CacheHeap->Free(StringData);
           return (Error);
        }

        CacheHeap->Free(StringData);
        StringData = (LPBYTE)CacheHeap->Alloc( Length );
        if(StringData == NULL){
            return( ERROR_NOT_ENOUGH_MEMORY );
        }
        memcpy(StringData,szExpand,Length+1);
    }
#endif /* unix */

    *Data = (LPTSTR)StringData;

    if( (ValueType == REG_SZ) || (ValueType == REG_EXPAND_SZ) ) {
        *NumStrings = 1;
    }
    else {

        DWORD Strings = 0;
        LPTSTR StrPtr = (LPTSTR)StringData;
        DWORD Len;

        while( (Len = lstrlen(StrPtr)) != 0 ) {
            Strings++;
            StrPtr = StrPtr + Len + 1;
        }

        *NumStrings = Strings;
    }

    return( ERROR_SUCCESS );
}

DWORD
REGISTRY_OBJ::GetValue(
    LPTSTR ValueName,
    LPBYTE *Data,
    DWORD *DataLen
    )
/*++

Routine Description:

    Gets a REG_BINARY value.

Arguments:

    ValueName : name of the value being retrived.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    DWORD ValueType;
    DWORD ValueSize;
    LPBYTE BinaryData = NULL;

    Error = GetValueSizeAndType( ValueName, &ValueSize, &ValueType );

    if( Error != ERROR_SUCCESS ) {
        return( Error );
    }

    TcpsvcsDbgAssert( ValueType == REG_BINARY );

    BinaryData = (LPBYTE)CacheHeap->Alloc( ValueSize );

    if( BinaryData == NULL ) {
        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    Error = RegQueryValueEx(
                _RegHandle,
                ValueName,
                0,
                &ValueType,
                BinaryData,
                &ValueSize );

    if( Error != ERROR_SUCCESS ) {
        CacheHeap->Free( BinaryData );
        return( Error );
    }

    *Data = BinaryData;
    *DataLen = ValueSize;
    return( ERROR_SUCCESS );
}

DWORD
REGISTRY_OBJ::GetValue(
    LPTSTR ValueName,
    LPBYTE Data,
    DWORD *DataLen
    )
/*++

Routine Description:

    Gets a REG_BINARY value.

Arguments:

    ValueName : name of the value being retrived.

    Data : pointer to a buffer where the data will be read.

    Datalen : pointer to location where length of the above buffer is
        passed. On return this location will have the length of the
        data read.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    DWORD ValueType;

    Error = RegQueryValueEx(
                _RegHandle,
                ValueName,
                0,
                &ValueType,
                Data,
                DataLen );

#ifdef unix
    {
    CHAR szExpand[MAX_PATH+1];
        DWORD Length = ExpandEnvironmentStrings((LPTSTR)Data,
                                                (LPTSTR)szExpand,
                                                MAX_PATH);
       if (Length == 0 || Length > MAX_PATH) {
           Error = GetLastError();
           return (Error);
        }
        memcpy(Data,szExpand,Length+1);
    }
#endif /* unix */
    return( Error );
}

DWORD
REGISTRY_OBJ::SetValue(
    LPTSTR ValueName,
    LPDWORD Data
    )
/*++

Routine Description:

    Sets a REG_DWORD value.

Arguments:

    ValueName : name of the value being set.

    Date : pointer to a DWORD data.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;

    Error = RegSetValueEx(
                _RegHandle,
                ValueName,
                0,
                REG_DWORD,
                (LPBYTE)Data,
                sizeof(DWORD) );

    return( Error );
}

DWORD
REGISTRY_OBJ::SetValue(
    LPTSTR ValueName,
    LPTSTR Data,
    DWORD StringType
    )
/*++

Routine Description:

    Sets a REG_SZ or REG_EXPAND_SZ or REG_MULTI_SZ value.

    Data : pointer to STRING(s) data.

    StringType : type of string data in the above buffer, it should be
        either of the following types :
            REG_SZ or REG_EXPAND_SZ or REG_MULTI_SZ

Arguments:

    ValueName : name of the value being set.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;

    UNIX_NORMALIZE_IF_CACHE_PATH((LPTSTR)Data,TEXT("%USERPROFILE%"),ValueName);

    Error = RegSetValueEx(
                _RegHandle,
                ValueName,
                0,
                StringType,
                (LPBYTE)Data,
                sizeof(TCHAR) * (lstrlen(Data) + 1) );

    return( Error );
}

DWORD
REGISTRY_OBJ::SetValue(
    LPSTR ValueName,
    LPSTR Data,
    DWORD DataLen,
    DWORD StringType
    )
/*++

Routine Description:

    Sets a REG_SZ or REG_EXPAND_SZ or REG_MULTI_SZ value.

    Data : pointer to STRING(s) data.

    DataLen : data length

    StringType : type of string data in the above buffer, it should be
        either of the following types :
            REG_SZ or REG_EXPAND_SZ or REG_MULTI_SZ

Arguments:

    ValueName : name of the value being set.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;

    Error = RegSetValueEx(
                _RegHandle,
                ValueName,
                0,
                StringType,
                (LPBYTE)Data,
                DataLen );

    return( Error );
}

DWORD
REGISTRY_OBJ::SetValue(
    LPTSTR ValueName,
    LPBYTE Data,
    DWORD DataLen
    )
/*++

Routine Description:

    Sets a REG_BINARY value.

Arguments:

    ValueName : name of the value being set.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;

    Error = RegSetValueEx(
                _RegHandle,
                ValueName,
                0,
                REG_BINARY,
                Data,
                DataLen );

    return( Error );
}

DWORD
REGISTRY_OBJ::FindNextKey(
    LPTSTR Key,
    DWORD KeySize
    )
/*++

Routine Description:

    Retrieves the Next subkey name of this key.

Arguments:

    Key - pointer to a buffer that receives the subkey name.

    KeySize - size of the above buffer in CHARS.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    DWORD KeyLength;
    FILETIME KeyLastWrite;

    KeyLength = KeySize * sizeof(TCHAR);
    Error = RegEnumKeyEx(
                _RegHandle,
                _Index,
                Key,
                &KeyLength,
                0,                  // reserved.
                NULL,               // class string not required.
                0,                  // class string buffer size.
                &KeyLastWrite );

    if( Error != ERROR_SUCCESS ) {
        return( Error );
    }

    TcpsvcsDbgAssert( KeyLength <= KeySize );

    //
    // increament the index to point to the next key.
    //

    _Index++;
    return( ERROR_SUCCESS );
}

DWORD
REGISTRY_OBJ::DeleteKey(
    LPTSTR ChildKeyName
    )
/*++

Routine Description:

    Deletes a subkey node.

Arguments:

    ChildKeyName : name of the subkey to be deleted.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    LPTSTR GChildKeyName[MAX_KEY_SIZE];
    REGISTRY_OBJ ChildObj( _RegHandle, ChildKeyName );

    Error = ChildObj.GetStatus();

    if( Error != ERROR_SUCCESS ) {
        return( Error );
    }

    //
    // delete all its subkeys.
    //

    Error = ChildObj.FindFirstKey(
                (LPTSTR)GChildKeyName,
                MAX_KEY_SIZE );

    while( Error == ERROR_SUCCESS ) {

        Error = ChildObj.DeleteKey( (LPTSTR)GChildKeyName );

        if( Error != ERROR_SUCCESS ) {
            return( Error );
        }

        Error = ChildObj.FindFirstKey(
                    (LPTSTR)GChildKeyName,
                    MAX_KEY_SIZE );
    }

    if( Error != ERROR_NO_MORE_ITEMS ) {
        return( Error );
    }

    //
    // delete this key.
    //

    Error = RegDeleteKey( _RegHandle, (LPTSTR)ChildKeyName );
    return( Error );
}

DWORD
REGISTRY_OBJ::DeleteValue(
    LPTSTR ValueName
    )
{
    DWORD Error;
    Error = RegDeleteValue(
                _RegHandle,
                ValueName
                );


    return( Error );
}


DWORD
REGISTRY_OBJ::FindNextValue(
    LPSTR ValueName,
    DWORD ValueSize,
    LPBYTE Data,
    DWORD *DataLen
    )
/*++

Routine Description:

    Retrieves the Next value name of this key.

Arguments:

    ValueName - pointer to a buffer that receives the Value name.

    ValueSize - size of the above buffer in CHARS.
    Data - pointer to a buffer that receives the Value data.
    DataLen - pointer to a buffer that receives data size.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    DWORD ValueLength;
    DWORD ValueType;

    ValueLength = ValueSize * sizeof(CHAR);

    Error = RegEnumValue(
                _RegHandle,
                _ValIndex,
                ValueName,
                &ValueLength,
                NULL,                  // reserved.
                &ValueType,
                Data,
                DataLen );

    if( Error != ERROR_SUCCESS ) {
        return( Error );
    }

    TcpsvcsDbgAssert( ValueLength <= ValueSize );

    //
    // increment the value index to point to the next value.
    //

    _ValIndex++;
    return( ERROR_SUCCESS );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\urlcache\urlcache.cxx ===
/*++

Copyright (c) 1997  Microsoft Corp.

Module Name: urlcache.cxx

Abstract:

    Urlcache API enhanced and optimized for internal use by wininet.

Author:
    Rajeev Dujari (rajeevd) 10-Apr-97

--*/

#include <wininetp.h>
#include <cache.hxx>

DWORD
UrlCacheRetrieve
(
        IN  LPSTR                pszUrl,
        IN  BOOL                 fOffline,
        OUT HANDLE*              phStream,
        OUT CACHE_ENTRY_INFOEX** ppCEI
)
{
    BOOL fLocked = FALSE;
    HANDLE hStream = NULL;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD dwErr;

    if (!InitGlobals())
    {
        INET_ASSERT(FALSE);
        return ERROR_WINHTTP_INTERNAL_ERROR;
    }

    DWORD dwLookupFlags = fOffline? LOOKUP_URL_TRANSLATE
        : (LOOKUP_BIT_SPARSE | LOOKUP_URL_NOCREATE);

    DWORD cbCEI;
    
    // Find the container and search the index.
    dwErr = GlobalUrlContainers->RetrieveUrl(
                    pszUrl, 
                    (CACHE_ENTRY_INFO **) ppCEI, 
                    &cbCEI, 
                    dwLookupFlags, 
                    RETRIEVE_WITHOUT_CHECKS | RETRIEVE_WITH_ALLOCATION);

    if (dwErr != ERROR_SUCCESS)
        goto Cleanup;

    fLocked = TRUE;
    if ((*ppCEI)->CacheEntryType & SPARSE_CACHE_ENTRY)
    {    
        *phStream = NULL;    
    }
    else
    {
        // Allocate a stream handle.
        CACHE_STREAM_CONTEXT_HANDLE* pStream;
        LOCK_CACHE();
        hStream = HandleMgr.Alloc (sizeof(CACHE_STREAM_CONTEXT_HANDLE));
        if (hStream)
        {
            pStream = (CACHE_STREAM_CONTEXT_HANDLE*) HandleMgr.Map (hStream);
            INET_ASSERT (pStream);
        }
        UNLOCK_CACHE();
        if (!hStream)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        // Open the file.
        hFile = CreateFile
        (
            (*ppCEI)->lpszLocalFileName,
            GENERIC_READ,
            FILE_SHARE_READ,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
            NULL
        );
        if( hFile == INVALID_HANDLE_VALUE )
        {
            dwErr = GetLastError();
            goto Cleanup;
        }

        DWORD dwFileSize = GetFileSize(hFile, NULL);

        if (dwFileSize != (*ppCEI)->dwSizeLow) 
        {
            dwErr = (dwFileSize==0xFFFFFFFF) ? GetLastError() : ERROR_INVALID_DATA;
            goto Cleanup;
        }

        pStream->FileHandle = hFile;

        // Copy URL name storage.
        pStream->SourceUrlName = NewString(pszUrl);
        if( !pStream->SourceUrlName)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        *phStream = hStream;
    }
    
    dwErr = ERROR_SUCCESS;

Cleanup:

    if( dwErr != ERROR_SUCCESS )
    {
        if (*ppCEI)
        {
            FREE_MEMORY (*ppCEI);
            *ppCEI = NULL;
        }
        if (hStream)
            HandleMgr.Free (hStream);
        if (hFile)
            CloseHandle (hFile);
        if (fLocked)
            GlobalUrlContainers->UnlockUrl(pszUrl);
    }
    return dwErr;
}


void UrlCacheFlush (void)
{
    DWORD fPersist;
    
    REGISTRY_OBJ regCache (HKEY_CURRENT_USER, OLD_CACHE_KEY);
    
    if (    ERROR_SUCCESS == regCache.GetStatus()
        &&  ERROR_SUCCESS == regCache.GetValue (CACHE_PERSISTENT, &fPersist)
        &&  !fPersist
       )
    {
        FreeUrlCacheSpace (NULL, 100, STICKY_CACHE_ENTRY);
    }
}

DWORD UrlCacheCreateFile(LPCSTR szUrl, LPTSTR szExt, LPTSTR szFile, HANDLE *phfHandle, BOOL fCreatePerUser, DWORD dwExpectedLength)
{
    if (!InitGlobals())
        return ERROR_WINHTTP_INTERNAL_ERROR;
    else
        return GlobalUrlContainers->CreateUniqueFile(szUrl, dwExpectedLength, szExt, szFile, phfHandle, fCreatePerUser);
}

DWORD UrlCacheCommitFile(AddUrlArg* pArgs)
{
    if (!InitGlobals())
        return ERROR_WINHTTP_INTERNAL_ERROR;
    else        
        return GlobalUrlContainers->AddUrl(pArgs);
}

DWORD UrlCacheSendNotification(DWORD   dwOp)
{
    DWORD Error;

    // Initialize globals.
    if (!InitGlobals())
    {
        Error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto Cleanup;
    }
        
    Error = GlobalUrlContainers->SendCacheNotification(dwOp);

Cleanup:
    return Error;
}

DWORD UrlCacheAddLeakFile (IN LPCSTR pszFile)
{
    if (!InitGlobals())
        return ERROR_WINHTTP_INTERNAL_ERROR;
    else
        return GlobalUrlContainers->AddLeakFile (pszFile);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\urlcache\util.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    util.cxx

Abstract:

    Contains the class implementation of UTILITY classes.

Author:

    Madan Appiah (madana)  16-Nov-1994

Environment:

    User Mode - Win32

Revision History:

    Ahsan Kabir (akabir)    24-Nov-1997

--*/

#include <wininetp.h>
#include <cache.hxx>

typedef BOOL (WINAPI *PFNGETFILEATTREX)(LPCTSTR, GET_FILEEX_INFO_LEVELS, LPVOID);

static char vszDot[] = ".";
static char vszDotDot[] = "..";
#ifdef UNIX
static char vszIndexFile[] = "index.dat";
#endif /* UNIX */

static char vszSHClassInfo[]=".ShellClassInfo";

static char vszCLSIDKey[]="CLSID";
static char vszCLSID[]="{FF393560-C2A7-11CF-BFF4-444553540000}";

static char vszUICLSIDKey[]="UICLSID";
static char vszUICLSID[]="{7BD29E00-76C1-11CF-9DD0-00A0C9034933}";

typedef HRESULT (*PFNSHFLUSHCACHE)(VOID);

#ifdef UNIX
extern void UnixGetValidParentPath(LPTSTR szDevice);
#endif /* UNIX */

/*-----------------------------------------------------------------------------
DeleteOneCachedFile

    Deletes a file belonging to the cache.

Arguments:

    lpszFileName: Fully qualified filename

Return Value:

    TRUE if successful. If FALSE, GetLastError() returns the error code.

Comments:

  ---------------------------------------------------------------------------*/
BOOL
DeleteOneCachedFile(
    LPSTR   lpszFileName,
    DWORD   dostEntry)
{

    if (dostEntry)
    {
        DWORD dostCreate = 0;
        LPWORD pwCreate = (LPWORD) &dostCreate;
        WIN32_FILE_ATTRIBUTE_DATA FileAttrData;

        switch (GetFileSizeAndTimeByName(lpszFileName, &FileAttrData))
        {
            case ERROR_SUCCESS:
                break;
            case ERROR_FILE_NOT_FOUND:
            case ERROR_PATH_NOT_FOUND:
                return TRUE;
            default:
                return FALSE;
        }                    
    
        FileTimeToDosDateTime(&FileAttrData.ftCreationTime, pwCreate, pwCreate+1);

        if (dostCreate != dostEntry)
           return TRUE; // not our file, so consider it done!
    }


    if(!DeleteFile(lpszFileName))
    {
        TcpsvcsDbgPrint (( DEBUG_ERRORS, "DeleteFile failed on %s, Error=%ld\n",
            lpszFileName, GetLastError()));

        switch (GetLastError())
        {
            case ERROR_FILE_NOT_FOUND:
            case ERROR_PATH_NOT_FOUND:
                return TRUE;
            default:
                return FALSE;
        }
    }
    else
    {
        TcpsvcsDbgPrint(( DEBUG_ERRORS, "Deleted %s\n", lpszFileName ));
        return TRUE;
    }
}


/*-----------------------------------------------------------------------------
DeleteCachedFilesInDir
  ---------------------------------------------------------------------------*/
DWORD DeleteCachedFilesInDir(
    LPSTR   lpszPath,
    DWORD   dwLevel
    )
{
    TCHAR PathFiles[MAX_PATH+1];
    TCHAR FullFileName[MAX_PATH+1];
    LPTSTR FullFileNamePtr;
    WIN32_FIND_DATA FindData;

    HANDLE FindHandle = INVALID_HANDLE_VALUE;

    // Since this has become a recursive call, we don't want to go more than 6 levels.
    if (dwLevel>5)
    {
        INET_ASSERT(FALSE);
        return ERROR_INVALID_PARAMETER;
    }
    
    DWORD Error, len, cbUsed;
    BOOL fFindSuccess;

    DWORD cb = strlen(lpszPath);
    memcpy(PathFiles, lpszPath, cb + 1);

    if(!AppendSlashIfNecessary(PathFiles, &cb)) 
    {
        Error = ERROR_INVALID_NAME;
        goto Cleanup;
    }

    memcpy(FullFileName, PathFiles, cb + 1);
    memcpy(PathFiles + cb, ALLFILES_WILDCARD_STRING, sizeof(ALLFILES_WILDCARD_STRING));

    FullFileNamePtr = FullFileName + lstrlen( (LPTSTR)FullFileName );

    if ( IsValidCacheSubDir( lpszPath))
        DisableCacheVu( lpszPath);

    FindHandle = FindFirstFile( (LPTSTR)PathFiles, &FindData );

    if( FindHandle == INVALID_HANDLE_VALUE ) 
    {
        Error = GetLastError();
        goto Cleanup;
    }

    cbUsed = (unsigned int)(FullFileNamePtr-FullFileName);
    FullFileName[MAX_PATH] = '\0';
    do
    {
        cb = strlen(FindData.cFileName);
        if (cb+cbUsed+1 > MAX_PATH)
        {
            // Subtracting 1 extra so that the null terminator doesn't get overwritten
            cb = MAX_PATH - cbUsed - 2;
        }
        memcpy(FullFileNamePtr, FindData.cFileName, cb+1);

#ifndef UNIX
        if (!(!strnicmp(FindData.cFileName, vszDot, sizeof(vszDot)-1) ||
            !strnicmp(FindData.cFileName, vszDotDot, sizeof(vszDotDot)-1))) 
#else
        if (!(!strnicmp(FindData.cFileName, vszDot, sizeof(vszDot)-1) ||
            !strnicmp(FindData.cFileName, vszIndexFile, sizeof(vszIndexFile)-1) || 
            !strnicmp(FindData.cFileName, vszDotDot, sizeof(vszDotDot)-1))) 
#endif /* UNIX */
        {
            if (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            {
                Error = DeleteCachedFilesInDir(FullFileName, dwLevel + 1);
                if (Error!=ERROR_SUCCESS)
                {
                    goto Cleanup;
                }
                SetFileAttributes(FullFileName, FILE_ATTRIBUTE_DIRECTORY);
                RemoveDirectory(FullFileName);
            }
            else
            {
                DeleteOneCachedFile( (LPTSTR)FullFileName, 0);
            }
        }

        //
        // find next file.
        //

    } while (FindNextFile( FindHandle, &FindData ));

    Error = GetLastError();
    if( Error == ERROR_NO_MORE_FILES) 
    {
        Error = ERROR_SUCCESS;
    }

Cleanup:

    if( FindHandle != INVALID_HANDLE_VALUE ) 
    {
        FindClose( FindHandle );
    }

    if( Error != ERROR_SUCCESS ) 
    {
        TcpsvcsDbgPrint(( DEBUG_ERRORS,
            "DeleteCachedFilesInDir failed, %ld.\n",
                Error ));
    }

    return( Error );
}


/*-----------------------------------------------------------------------------
AppendSlashIfNecessary
  ---------------------------------------------------------------------------*/
BOOL AppendSlashIfNecessary(LPSTR szPath, DWORD* pcbPath)
{
    if (*pcbPath > (MAX_PATH-2)) 
        return FALSE;
    if (szPath[*pcbPath-1] != DIR_SEPARATOR_CHAR)
    {
        szPath[*pcbPath] = DIR_SEPARATOR_CHAR;
        (*pcbPath)++;
        szPath[*pcbPath] = '\0';
    }
    return TRUE;
}


/*-----------------------------------------------------------------------------
EnableCachevu
  ---------------------------------------------------------------------------*/
BOOL EnableCacheVu(LPSTR szPath, DWORD dwContainer)
{       
    DWORD cbPath = strlen(szPath);
    CHAR szDesktopIni[MAX_PATH];
    DWORD dwFileAttributes;

    HMODULE hInstShell32 = 0;
    PFNSHFLUSHCACHE pfnShFlushCache = NULL;

#define DESIRED_ATTR (FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM)

    // Calls with non-existant directory allowed and return false.
    dwFileAttributes = GetFileAttributes(szPath);
    if (dwFileAttributes == 0xFFFFFFFF)
        return FALSE;
    
    // Always be set to enable cachevu.
    SetFileAttributes(szPath, FILE_ATTRIBUTE_SYSTEM);
    
    // Path to DESKTOP_INI_FILENAME
    memcpy(szDesktopIni, szPath, cbPath + 1);           
    AppendSlashIfNecessary(szDesktopIni, &cbPath);
            
    // Correct location for desktop.ini.
    memcpy(szDesktopIni + cbPath, DESKTOPINI_FILE_NAME, sizeof(DESKTOPINI_FILE_NAME));

    // Check for existing desktop.ini
    dwFileAttributes = GetFileAttributes(szDesktopIni);

    if (dwFileAttributes == 0xFFFFFFFF)
    {
        dwFileAttributes = 0;

        // Always write out the UICLSID
        WritePrivateProfileString(vszSHClassInfo,  vszUICLSIDKey,  vszUICLSID,  szDesktopIni);    

        // HISTORY requires an additional CLSID.
        if (dwContainer == HISTORY)
            WritePrivateProfileString(vszSHClassInfo,  vszCLSIDKey,  vszCLSID,  szDesktopIni);    

        // Flush buffer - problems on Win95 if you don't.
        WritePrivateProfileString(NULL, NULL, NULL,  szDesktopIni);
    }

    if ((dwFileAttributes & DESIRED_ATTR) != DESIRED_ATTR)
    {
        // Should be hidden, read-only and system for cachevu to work correctly.
        SetFileAttributes(szDesktopIni, DESIRED_ATTR);
    }
/*
    BUGBUG - taking this code out for raid # 45710.
    // We now need to notify the shell that a new desktop.ini has been created.
    hInstShell32 = GetModuleHandle("shell32.dll");
    if (hInstShell32)
    {    
        pfnShFlushCache = (PFNSHFLUSHCACHE) GetProcAddress(hInstShell32, (LPSTR) 526);
        if (pfnShFlushCache)
        {
            __try
            {
                (*pfnShFlushCache)();
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
            }
            ENDEXCEPT
        }
    }
*/
    return TRUE;

}

/*-----------------------------------------------------------------------------
IsValidCacheSubDir
  ---------------------------------------------------------------------------*/
BOOL IsValidCacheSubDir(LPSTR szPath)
{
    DWORD dwFileAttributes, cb, cbPath;
    CHAR szDesktopIni[MAX_PATH];
    CHAR szCLSID     [MAX_PATH];
    CHAR szWindowsDir[MAX_PATH];
    CHAR szSystemDir [MAX_PATH];

    cbPath = strlen(szPath);
            
    // Root, Windows or System directories
    // are decidedly not cache subdirectories.
    cb = GetWindowsDirectory(szWindowsDir, MAX_PATH);
    if (!cb || cb>MAX_PATH)
    {
        INET_ASSERT(FALSE);
        return FALSE;
    }
    AppendSlashIfNecessary(szWindowsDir, &cb);

    cb = GetSystemDirectory(szSystemDir, MAX_PATH);
    AppendSlashIfNecessary(szSystemDir, &cb);

    if (cbPath < 4 
        || !strnicmp(szPath, szWindowsDir, cbPath)
        || !strnicmp(szPath, szSystemDir, cbPath))
    {
        INET_ASSERT(FALSE);
        return FALSE;
    }

    // Path to DESKTOP_INI_FILENAME
    memcpy(szDesktopIni, szPath, cbPath + 1);           
    AppendSlashIfNecessary(szDesktopIni, &cbPath);
    
    // Correct location for desktop.ini.
    memcpy(szDesktopIni + cbPath, DESKTOPINI_FILE_NAME, sizeof(DESKTOPINI_FILE_NAME));

    // Check for existing desktop.ini
    dwFileAttributes = GetFileAttributes(szDesktopIni);

    // No desktop.ini found or system attribute not set.
    if (dwFileAttributes == 0xFFFFFFFF)
    {
        return FALSE;
    }

    // Found UICLSID (CONTENT cachevu) ?
    if (GetPrivateProfileString(vszSHClassInfo,  vszUICLSIDKey,  
                                "", szCLSID, MAX_PATH, szDesktopIni)
        && !strcmp(szCLSID, vszUICLSID)) 
    {
        return TRUE;
    }

    return FALSE;
}


/*-----------------------------------------------------------------------------
DisableCachevu
  ---------------------------------------------------------------------------*/
BOOL DisableCacheVu(LPSTR szPath)
{
    DWORD cbPath = strlen(szPath);
    CHAR szDesktopIni[MAX_PATH];

    // Path to DESKTOP_INI_FILENAME
    memcpy(szDesktopIni, szPath, cbPath + 1);           
    AppendSlashIfNecessary(szDesktopIni, &cbPath);
            
    // Correct location for desktop.ini.
    memcpy(szDesktopIni + cbPath, DESKTOPINI_FILE_NAME, sizeof(DESKTOPINI_FILE_NAME));
    SetFileAttributes(szDesktopIni, FILE_ATTRIBUTE_NORMAL);
    DeleteFile(szDesktopIni);
    return TRUE;
}

/*-----------------------------------------------------------------------------
StripTrailingWhiteSpace
  ---------------------------------------------------------------------------*/
VOID StripTrailingWhiteSpace(LPSTR szString, LPDWORD pcb)
{
    INET_ASSERT(szString);

    if (*pcb == 0)
        return;

    CHAR* ptr = szString + *pcb - 1;

    while (*ptr == ' ')
    {
        ptr--;
        if (--(*pcb) == 0)
            break;
    }
    *(ptr+1) = '\0';
}


/* PerformOperationOverUrlCache-----------------------

The purpose of this function is to iterate through the content cache and perform the same action (here, called
an operation) on each entry in the cache.

This function takes all the parameters that FindFirstUrlCacheEntryEx accepts, 
plus two more:

op              -- This is of type CACHE_OPERATOR, discussed below
pOperatorData   -- a pointer to an array of data that the calling process and op use to collect/maintain info
 */

/* CACHE_OPERATOR
    is a pointer to function, that takes three arguments(pointer to a cache entry, cache entry size, and a pointer to 
    state data.

    The operator can perform whatever operation (move/copy/data collection) it wishes on the supplied cache entry.
    It must return TRUE if the operation has succeeded and PerformOperationOverUrlCache can continue to iterate through
    the cache, FALSE otherwise.

    pOpData can be null, or a cast pointer to whatever structure the operator will use to maintain state information.
        
    PerformOperationOverUrlCache guarantees that each cache entry will have sufficient space for its information.
*/ 

typedef BOOL (*CACHE_OPERATOR)(INTERNET_CACHE_ENTRY_INFO* pcei, PDWORD pcbcei, PVOID pOpData);


// hAdjustMemory is a helper function
// that ensures that the buffer used by PerformOperationOverUrlCache
// is large enough to hold all of a cache entry's info

BOOL hAdjustMemory(PBYTE pbSrc, PDWORD pcbAvail, LPINTERNET_CACHE_ENTRY_INFO* pbNew, PDWORD pcbNeeded)
{
    if ((PBYTE)*pbNew!=pbSrc)
    {
        FREE_MEMORY(*pbNew);
    }
    do
    {
        *pcbAvail += 1024;
    } 
    while (*pcbAvail < *pcbNeeded);
    *pcbNeeded = *pcbAvail;
    *pbNew = (LPINTERNET_CACHE_ENTRY_INFO)ALLOCATE_FIXED_MEMORY(*pcbAvail);
    return (*pbNew!=NULL);
}


// PerformOperationOverUrlCache
// described above
// uses FindFirstUrlCacheEntryEx and FindNext as any other wininet client would.
// and passes a complete cache entry to the operator for processing

BOOL PerformOperationOverUrlCacheA(
    IN     PCSTR     pszUrlSearchPattern,
    IN     DWORD     dwFlags,
    IN     DWORD     dwFilter,
    IN     GROUPID   GroupId,
    OUT    PVOID     pReserved1,
    IN OUT PDWORD    pdwReserved2,
    IN     PVOID     pReserved3,
    IN       CACHE_OPERATOR op, 
    IN OUT PVOID     pOperatorData
    )
{
    BOOL fResult = FALSE;

    BYTE buffer[sizeof(INTERNET_CACHE_ENTRY_INFO) + 1024];
    DWORD cbAvail = sizeof(buffer);
    DWORD cbCEI = cbAvail;
    LPINTERNET_CACHE_ENTRY_INFO pCEI = (LPINTERNET_CACHE_ENTRY_INFO)buffer;
    HANDLE hFind = NULL;
    
    hFind = FindFirstUrlCacheEntryEx(pszUrlSearchPattern, 
                                    dwFlags,
                                    dwFilter,
                                    GroupId,
                                    pCEI, 
                                    &cbCEI,
                                    pReserved1,
                                    pdwReserved2,
                                    pReserved3);
    if (!hFind && (GetLastError()!=ERROR_INSUFFICIENT_BUFFER) && hAdjustMemory(buffer, &cbAvail, &pCEI, &cbCEI))
    {
        hFind = FindFirstUrlCacheEntryEx(pszUrlSearchPattern, 
                                    dwFlags,
                                    dwFilter,
                                    GroupId,
                                    pCEI, 
                                    &cbCEI,
                                    pReserved1,
                                    pdwReserved2,
                                    pReserved3);
    }

    if (hFind!=NULL)
    {
        do
        {
            fResult = op(pCEI, &cbCEI, pOperatorData);
            if (fResult)
            {
                cbCEI = cbAvail;
                fResult = FindNextUrlCacheEntryEx(hFind, pCEI, &cbCEI, NULL, NULL, NULL);
                if (!fResult && (GetLastError()==ERROR_INSUFFICIENT_BUFFER) && hAdjustMemory(buffer, &cbAvail, &pCEI, &cbCEI))
                {
                    fResult = FindNextUrlCacheEntryEx(hFind, pCEI, &cbCEI, NULL, NULL, NULL);
                }
            } 
        }
        while (fResult);
        FindCloseUrlCache(hFind);

        if (GetLastError()==ERROR_NO_MORE_ITEMS)
        {
            fResult = TRUE;
        } 
    }

    if (pCEI!=(LPINTERNET_CACHE_ENTRY_INFO)buffer)
    {
        FREE_MEMORY(pCEI);
    }
    return fResult;
}

// ------ MoveCachedFiles ---------------------------------------------------------------------------------------
// Purpose: Moves as many files as possible from the current Temporary Internet Files to the new location


// State information required for the move operation
struct MOVE_OP_STATE
{
    TCHAR szNewPath[MAX_PATH];
    TCHAR szOldPath[MAX_PATH];
    DWORD ccNewPath;
    DWORD ccOldPath;
    DWORDLONG dlCacheSize;
    DWORD dwClusterSizeMinusOne;
    DWORD dwClusterSizeMask;
};

// Helper function that, 
// given a string pointer, 
// returns the next occurrence of DIR_SEPARATOR_CHAR ('/' || '\\')
PTSTR hScanPastSeparator(PTSTR pszPath)
{
    while (*pszPath && *pszPath!=DIR_SEPARATOR_CHAR)
    {
        pszPath++;
    }
    if (*pszPath)
    {
        return pszPath+1;
    }
    return NULL;
}

// Helper function that,
// given a path,
// ensures that all the directories in the path exist
BOOL hConstructSubDirs(PTSTR pszBase)
{
    PTSTR pszLast = hScanPastSeparator(pszBase);

    if (NULL == pszLast)
        return TRUE;    // returning TRUE on purpose

    PTSTR pszNext = pszLast;
    while ((pszNext=hScanPastSeparator(pszNext))!=NULL)
    {
        *(pszNext-1) = '\0';
        CreateDirectory(pszBase, NULL);
        *(pszNext-1) = DIR_SEPARATOR_CHAR;
        pszLast = pszNext;
    }
    return TRUE;
}

// MoveOperation
// actually moves a cached file to the new location

BOOL MoveOperation(LPINTERNET_CACHE_ENTRY_INFO pCEI, PDWORD pcbCEI, PVOID pOpData)
{
    MOVE_OP_STATE* pmos = (MOVE_OP_STATE*)pOpData;
    BOOL fResult = TRUE;

    if (pCEI->lpszLocalFileName)
    {
        if (!strnicmp(pCEI->lpszLocalFileName, pmos->szOldPath, pmos->ccOldPath))
        {
            // Copy the file
            lstrcpy(pmos->szNewPath + pmos->ccNewPath, pCEI->lpszLocalFileName + pmos->ccOldPath);        
            fResult = CopyFile(pCEI->lpszLocalFileName, pmos->szNewPath, FALSE);
            if (!fResult && GetLastError()==ERROR_PATH_NOT_FOUND)
            {
                if (hConstructSubDirs(pmos->szNewPath))
                {
                    fResult = CopyFile(pCEI->lpszLocalFileName, pmos->szNewPath, FALSE);
                }
            }
            // If the move was successful, we need to adjust the size of the new cache
            if (fResult)
            {
                fResult = FALSE;
                
                HANDLE h1 = CreateFile(pCEI->lpszLocalFileName, 
                                      GENERIC_READ,
                                      0,
                                      NULL,
                                      OPEN_EXISTING,
                                      FILE_ATTRIBUTE_NORMAL,
                                      NULL);

                // If we can't open the original file, then the new file will never
                // get scavenged because we'll never be able to match creation times
                if (h1!=INVALID_HANDLE_VALUE)
                {
                    HANDLE h2 = CreateFile(pmos->szNewPath, 
                                      GENERIC_WRITE,
                                      0,
                                      NULL,
                                      OPEN_EXISTING,
                                      FILE_ATTRIBUTE_NORMAL,
                                      NULL);
                    if (h2!=INVALID_HANDLE_VALUE)
                    {
                        FILETIME ft;
                        if (GetFileTime(h1, &ft, NULL, NULL))
                        {
                            fResult = SetFileTime(h2, &ft, NULL, NULL);
                        }
                        CloseHandle(h2);
                    }
                    CloseHandle(h1);
                }
            }

            // If we haven't been able to set the create time, then we've got a problem
            // we'd sooner not deal with.
            if (!fResult)
            {
                DeleteUrlCacheEntry(pCEI->lpszSourceUrlName);
                DeleteFile(pmos->szNewPath);
            }
            else
            {
                pmos->dlCacheSize += ((LONGLONG) (pCEI->dwSizeLow + pmos->dwClusterSizeMinusOne) 
                                        & pmos->dwClusterSizeMask);
            }

            // Delete the old one
            DeleteFile(pCEI->lpszLocalFileName);
        }
    }
    return TRUE;
}


DWORD
MoveCachedFiles(
    LPSTR     pszOldPath,
    LPSTR     pszNewPath
)
{
    MOVE_OP_STATE mos;
    INET_ASSERT(pszOldPath && pszNewPath);

    mos.ccNewPath = lstrlen(pszNewPath);
    memcpy(mos.szNewPath, pszNewPath, mos.ccNewPath*sizeof(TCHAR));
    AppendSlashIfNecessary(mos.szNewPath, &mos.ccNewPath);
    memcpy(mos.szNewPath + mos.ccNewPath, CONTENT_VERSION_SUBDIR, sizeof(CONTENT_VERSION_SUBDIR)*sizeof(TCHAR));
    mos.ccNewPath += sizeof(CONTENT_VERSION_SUBDIR)-1;
    AppendSlashIfNecessary(mos.szNewPath, &mos.ccNewPath);

    mos.ccOldPath = lstrlen(pszOldPath);
    memcpy(mos.szOldPath, pszOldPath, mos.ccOldPath*sizeof(TCHAR));
    AppendSlashIfNecessary(mos.szOldPath, &mos.ccOldPath);

    mos.dlCacheSize = 0;
    GetDiskInfo(mos.szNewPath, &mos.dwClusterSizeMinusOne, NULL, NULL);
    mos.dwClusterSizeMinusOne--;
    mos.dwClusterSizeMask = ~mos.dwClusterSizeMinusOne;
    
    GlobalUrlContainers->WalkLeakList(CONTENT);

    // We don't need to get all the information about each and every entry.
    PerformOperationOverUrlCacheA(
        NULL, 
        FIND_FLAGS_RETRIEVE_ONLY_FIXED_AND_FILENAME,
        NORMAL_CACHE_ENTRY | STICKY_CACHE_ENTRY | SPARSE_CACHE_ENTRY,
        NULL,
        NULL,
        NULL,
        NULL,
        MoveOperation, 
        (PVOID)&mos);

    GlobalUrlContainers->SetCacheSize(CONTENT, mos.dlCacheSize);
    
    // Copy desktop.ini and index.dat, since these aren't cached
    TCHAR szFile[MAX_PATH];
    DWORD ccOldPath = lstrlen(pszOldPath);
    memcpy(szFile, pszOldPath, ccOldPath);
    AppendSlashIfNecessary(szFile, &ccOldPath);
    memcpy(szFile + ccOldPath, MEMMAP_FILE_NAME, sizeof(MEMMAP_FILE_NAME));
    memcpy(mos.szNewPath + mos.ccNewPath, MEMMAP_FILE_NAME, sizeof(MEMMAP_FILE_NAME));
    CopyFile(szFile, mos.szNewPath, FALSE);

    memcpy(szFile + ccOldPath, DESKTOPINI_FILE_NAME, sizeof(DESKTOPINI_FILE_NAME));
    memcpy(mos.szNewPath + mos.ccNewPath, DESKTOPINI_FILE_NAME, sizeof(DESKTOPINI_FILE_NAME));
    CopyFile(szFile, mos.szNewPath, FALSE);

    return ERROR_SUCCESS;
}


/*-----------------------------------------------------------------------------
IsCorrectUser

Routine Description:

    checks to see from the headers whether there is any username in there and
    whether it matches the currently logged on user. If no one is logged on a
    default username string is used

Arguments:

    lpszHeaderInfo: headers to check

    dwheaderSize:   size of the headers buffer

Return Value:

    BOOL


---------------------------------------------------------------------------*/
BOOL
IsCorrectUserPrivate(
    IN LPSTR lpszHeaderInfo,
    IN DWORD dwHeaderSize
    )
{
    LPSTR lpTemp, lpTemp2;

    INET_ASSERT (lpszHeaderInfo);

    lpTemp = lpszHeaderInfo+dwHeaderSize-1;

    // start searching backwards

    while (lpTemp >= lpszHeaderInfo) {

        if (*lpTemp ==':') {
            // If this is less than the expected header:
            // then we know that there is no such usernameheader 
            // <MH> i.e. it's not a peruseritem so allow access</MH>

            if ((DWORD)PtrDifference((lpTemp+1), lpszHeaderInfo) < (sizeof(vszUserNameHeader)-1)) {
                TcpsvcsDbgPrint((DEBUG_CONTAINER,
                    "IsCorrectUser (Util.cxx): Didn't find header <lpTemp = 0x%x %s> <lpszHeaderInfo = 0x%x %s> <vszCurrentUser = %s> <PtrDifference = %d> <sizeof(vszUserNameHeader)-1) = %d>\r\n",
                    lpTemp,
                    lpTemp,
                    lpszHeaderInfo,
                    lpszHeaderInfo,
                    vszCurrentUser,
                    PtrDifference(lpTemp, lpszHeaderInfo),
                    (sizeof(vszUserNameHeader)-1)
                    ));
                return (TRUE); // No such header. just ay it is OK
            }

            // point this puppy to the expected header start
            lpTemp2 = lpTemp - (sizeof(vszUserNameHeader)-2);

            // if the earlier char is not a white space [0x9-0xd or 0x20]
            // then this is not the beginning of the header
            // <MH> Also need to check for the first header which would not 
            // have whitespace preceding it. Want to first check lpTemp2 ==
            // lpszheaderInfo to prevent underflowing when dereferencing.</MH>

            if (((lpTemp2) == lpszHeaderInfo) || isspace(*(lpTemp2-1))) {

                // we have the beginning of a header
                if (!strnicmp(lpTemp2
                                , vszUserNameHeader
                                , sizeof(vszUserNameHeader)-1)) {

                    // right header, let us see whether this is the right person
                    if(!strnicmp(lpTemp+1, vszCurrentUser, vdwCurrentUserLen)) {
                        TcpsvcsDbgPrint((DEBUG_CONTAINER,
                            "IsCorrectUser (Util.cxx): Match!! %s header == %s current user.\r\n",
                            lpTemp+1,
                            vszCurrentUser
                            ));
                    
                        return (TRUE); // right guy
                    }
                    else {
                        TcpsvcsDbgPrint((DEBUG_CONTAINER,
                            "IsCorrectUser (Util.cxx): No match!! %s header != %s current user.\r\n",
                            lpTemp+1,
                            vszCurrentUser
                            ));

                    }

                    return(FALSE); // wrong guy
                }
            }
        }
        --lpTemp;
    }

    return (TRUE); // there was no UserName header, just say it is OK
}


BOOL
IsCorrectUser(
    IN LPSTR lpszHeaderInfo,
    IN DWORD dwHeaderSize
    )
{
    BOOL fRet = FALSE;
    
    __try
    {
        fRet = IsCorrectUserPrivate(lpszHeaderInfo, dwHeaderSize);
    } // __try
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        INET_ASSERT(FALSE);
        fRet = FALSE;
    }
    ENDEXCEPT
    return fRet;
}



#ifndef UNICODE
#define SZ_GETDISKFREESPACEEX   "GetDiskFreeSpaceExA"
#define SZ_WNETUSECONNECTION    "WNetUseConnectionA"
#define SZ_WNETCANCELCONNECTION "WNetCancelConnectionA"
#else
#define SZ_GETDISKFREESPACEEX   "GetDiskFreeSpaceExW"
#define SZ_WNETUSECONNECTION    "WNetUseConnectionW"
#define SZ_WNETCANCELCONNECTION "WNetCancelConnectionW"
#endif

typedef BOOL (WINAPI *PFNGETDISKFREESPACEEX)(LPCTSTR, PULARGE_INTEGER, PULARGE_INTEGER, PULARGE_INTEGER);
typedef BOOL (WINAPI *PFNWNETUSECONNECTION)(HWND, LPNETRESOURCE, PSTR, PSTR, DWORD, PSTR, PDWORD, PDWORD);
typedef BOOL (WINAPI *PFNWNETCANCELCONNECTION)(LPCTSTR, BOOL);

BOOL EstablishFunction(PTSTR pszModule, PTSTR pszFunction, PFN* pfn)
{
    if (*pfn==(PFN)-1)
    {
        *pfn = NULL;
        HMODULE ModuleHandle = GetModuleHandle(pszModule);
        if (ModuleHandle)
        {
            *pfn = (PFN)GetProcAddress(ModuleHandle, pszFunction);
        }
    }        

    return (*pfn!=NULL);
}


// GetPartitionClusterSize

// GetDiskFreeSpace has the annoying habit of lying about the layout
// of the drive; thus we've been ending up with bogus sizes for the cluster size.
// You can't imagine how annoying it is to think you've a 200 MB cache, but it
// starts scavenging at 20MB.

// This function will, if given reason to doubt the veracity of GDFS, go straight 
// to the hardware and get the information for itself, otherwise return the passed-in
// value.

// The code that follows is heavily doctored from msdn sample code. Copyright violation? I think not.

static PFNGETDISKFREESPACEEX pfnGetDiskFreeSpaceEx = (PFNGETDISKFREESPACEEX)-1;
#define VWIN32_DIOC_DOS_DRIVEINFO   6

typedef struct _DIOC_REGISTERS 
{
    DWORD reg_EBX;
    DWORD reg_EDX;
    DWORD reg_ECX;
    DWORD reg_EAX;
    DWORD reg_EDI;
    DWORD reg_ESI;
    DWORD reg_Flags;
} 
DIOC_REGISTERS, *PDIOC_REGISTERS;

// Important: All MS_DOS data structures must be packed on a 
// one-byte boundary. 

#pragma pack(1) 

typedef struct 
_DPB {
    BYTE    dpb_drive;          // Drive number (1-indexed)
    BYTE    dpb_unit;           // Unit number
    WORD    dpb_sector_size;    // Size of sector in bytes
    BYTE    dpb_cluster_mask;   // Number of sectors per cluster, minus 1
    BYTE    dpb_cluster_shift;  // The stuff after this, we don't really care about. 
    WORD    dpb_first_fat;
    BYTE    dpb_fat_count;
    WORD    dpb_root_entries;
    WORD    dpb_first_sector;
    WORD    dpb_max_cluster;
    WORD    dpb_fat_size;
    WORD    dpb_dir_sector;
    DWORD   dpb_reserved2;
    BYTE    dpb_media;
    BYTE    dpb_first_access;
    DWORD   dpb_reserved3;
    WORD    dpb_next_free;
    WORD    dpb_free_cnt;
    WORD    extdpb_free_cnt_hi;
    WORD    extdpb_flags;
    WORD    extdpb_FSInfoSec;
    WORD    extdpb_BkUpBootSec;
    DWORD   extdpb_first_sector;
    DWORD   extdpb_max_cluster;
    DWORD   extdpb_fat_size;
    DWORD   extdpb_root_clus;
    DWORD   extdpb_next_free;
} 
DPB, *PDPB;

#pragma pack()

DWORD GetPartitionClusterSize(PTSTR szDevice, DWORD dwClusterSize)
{
    switch (GlobalPlatformType)
    {
    case PLATFORM_TYPE_WIN95:
        // If GetDiskFreeSpaceEx is present _and_ we're running Win9x, this implies
        // that we must be doing OSR2 or later. We can trust earlier versions 
        // of the GDFS (we think; this assumption may be invalid.)

        // Since Win95 can't read NTFS drives, we'll freely assume we're reading a FAT drive.
        // Basically, we're performing an MSDOS INT21 call to get the drive partition record. Joy.
        
        if (pfnGetDiskFreeSpaceEx)
        {
            HANDLE hDevice;
            DIOC_REGISTERS reg;
            BYTE buffer[sizeof(WORD)+sizeof(DPB)];
            PDPB pdpb = (PDPB)(buffer + sizeof(WORD));
    
            BOOL fResult;
            DWORD cb;

            // We must always have a drive letter in this case
            int nDrive = *szDevice - TEXT('A') + 1;  // Drive number, 1-indexed

            hDevice = CreateFile("\\\\.\\vwin32", 0, 0, NULL, 0, FILE_FLAG_DELETE_ON_CLOSE, NULL);

            if (hDevice!=INVALID_HANDLE_VALUE)
            {
                reg.reg_EDI = PtrToUlong(buffer);
                reg.reg_EAX = 0x7302;        
                reg.reg_ECX = sizeof(buffer);
                reg.reg_EDX = (DWORD) nDrive; // drive number (1-based) 
                reg.reg_Flags = 0x0001;     // assume error (carry flag is set) 

                fResult = DeviceIoControl(hDevice, 
                                          VWIN32_DIOC_DOS_DRIVEINFO,
                                          &reg, sizeof(reg), 
                                          &reg, sizeof(reg), 
                                          &cb, 0);

                if (fResult && !(reg.reg_Flags & 0x0001))
                {
                    // no error if carry flag is clear
                    dwClusterSize = DWORD((pdpb->dpb_cluster_mask+1)*pdpb->dpb_sector_size);
                }
                CloseHandle(hDevice);
            }
        }
        break;

    default:
        // Do nothing. Trust the value we've been passed.
        // UNIX guys will have to treat this separately.

        // For NT, however, this might be another issue. We can't use the DOS INT21.
        // Questions:
        // NT5 (but not NT4) supports FAT32; will we get honest answers? Apparently, yes.
        // NT4/5: NTFS drives and other FAT drives -- do we still get honest answers? Investigation
        // so far says, Yes. 
        break;
    }
    
    return dwClusterSize;
}


/* GetDiskInfo
    A nice way to get volume information
*/
BOOL GetDiskInfoA(PTSTR pszPath, PDWORD pdwClusterSize, PDWORDLONG pdlAvail, PDWORDLONG pdlTotal)
{
    static PFNWNETUSECONNECTION pfnWNetUseConnection = (PFNWNETUSECONNECTION)-1;
    static PFNWNETCANCELCONNECTION pfnWNetCancelConnection = (PFNWNETCANCELCONNECTION)-1;

    if (!pszPath)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    INET_ASSERT(pdwClusterSize || pdlAvail || pdlTotal);
    // If GetDiskFreeSpaceExA is available, we can be confident we're running W95OSR2+ || NT4
    EstablishFunction(TEXT("KERNEL32"), SZ_GETDISKFREESPACEEX, (PFN*)&pfnGetDiskFreeSpaceEx);
  
    BOOL fRet = FALSE;
    TCHAR szDevice[MAX_PATH];
    PTSTR pszGDFSEX = NULL;
   
    if (*pszPath==DIR_SEPARATOR_CHAR)
    {
        // If we're dealing with a cache that's actually located on a network share, 
        // that's fine so long as we have GetDiskFreeSpaceEx at our disposal.
        // _However_, if we need the cluster size on Win9x, we'll need to use
        // INT21 stuff (see above), even if we have GDFSEX available, so we need to map
        // the share to a local drive.
        
        if (pfnGetDiskFreeSpaceEx 
            && !((GlobalPlatformType==PLATFORM_TYPE_WIN95) && pdwClusterSize))
        {
            DWORD cbPath = lstrlen(pszPath);
            cbPath -= ((pszPath[cbPath-1]==DIR_SEPARATOR_CHAR) ? 1 : 0);
            if (cbPath>MAX_PATH-2)
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return FALSE;
            }
            memcpy(szDevice, pszPath, cbPath);
            szDevice[cbPath] = DIR_SEPARATOR_CHAR;
            cbPath++;
            szDevice[cbPath] = '\0';
            pszGDFSEX = szDevice;
        }
        else
        {
            if (!(EstablishFunction(TEXT("MPR"), SZ_WNETUSECONNECTION, (PFN*)&pfnWNetUseConnection)
                &&
               EstablishFunction(TEXT("MPR"), SZ_WNETCANCELCONNECTION, (PFN*)&pfnWNetCancelConnection)))
            {
                return FALSE;
            }

           // If it's a UNC, map it to a local drive for backwards compatibility
            NETRESOURCE nr = { 0, RESOURCETYPE_DISK, 0, 0, szDevice, pszPath, NULL, NULL };
            DWORD cbLD = sizeof(szDevice);
            DWORD dwNull;
            if (pfnWNetUseConnection(NULL, 
                          &nr, 
                          NULL, 
                          NULL, 
                          CONNECT_INTERACTIVE | CONNECT_REDIRECT, 
                          szDevice,
                          &cbLD,
                          &dwNull)!=ERROR_SUCCESS)
            {
                SetLastError(ERROR_NO_MORE_DEVICES);        
                return FALSE;
            }
        }
    }
    else
    {
        memcpy(szDevice, pszPath, sizeof(TEXT("?:\\")));
        szDevice[3] = '\0';
        pszGDFSEX = pszPath;
    }
    if (*szDevice!=DIR_SEPARATOR_CHAR)
    {
        *szDevice = (TCHAR)CharUpper((LPTSTR)*szDevice);
    }

#ifdef UNIX
    /* On Unix, GetDiskFreeSpace and GetDiskFreeSpaceEx will work successfully
     * only if the path exists. So, let us pass a path that exists
     */
    UnixGetValidParentPath(szDevice);
#endif /* UNIX */

    // I hate goto's, and this is a way to avoid them...
    for (;;)
    {
        DWORDLONG cbFree = 0, cbTotal = 0;
    
        if (pfnGetDiskFreeSpaceEx && (pdlTotal || pdlAvail))
        {
            ULARGE_INTEGER ulFree, ulTotal;

            // BUG BUG BUG Is the following problematic? Also, we'll need to add checks to make sure that 
            // the  cKBlimit fits a DWORD (in the obscene if unlikely case drive spaces grow that large)
            // For instance, if this is a per user system with a non-shared cache, we might want to change
            // the ratios.
            INET_ASSERT(pszGDFSEX);
            fRet = pfnGetDiskFreeSpaceEx(pszGDFSEX, &ulFree, &ulTotal, NULL);

            // HACK Some versions of GetDiskFreeSpaceEx don't accept the whole directory; they
            // take only the drive letter. Pfft.
            if (!fRet)
            {
                fRet = pfnGetDiskFreeSpaceEx(szDevice, &ulFree, &ulTotal, NULL);
            }

            if (fRet)
            {
                cbFree = ulFree.QuadPart;
                cbTotal = ulTotal.QuadPart;
            }
        }

        if ((!fRet) || pdwClusterSize)
        {
            DWORD dwSectorsPerCluster, dwBytesPerSector, dwFreeClusters, dwClusters, dwClusterSize;
            if (!GetDiskFreeSpace(szDevice, &dwSectorsPerCluster, &dwBytesPerSector, &dwFreeClusters, &dwClusters))
            {
                fRet = FALSE;
                break;
            }
            
            dwClusterSize = dwBytesPerSector * dwSectorsPerCluster;

            if (!fRet)
            {
                cbFree = (DWORDLONG)dwClusterSize * (DWORDLONG)dwFreeClusters;
                cbTotal = (DWORDLONG)dwClusterSize * (DWORDLONG)dwClusters;
            }
            
            if (pdwClusterSize)
            {
                *pdwClusterSize = GetPartitionClusterSize(szDevice, dwClusterSize);
            }
        }

        if (pdlTotal)
        {
             *pdlTotal = cbTotal;
        }
        if (pdlAvail)
        {
             *pdlAvail = cbFree;
        }
        fRet = TRUE;
        break;
    };
    
    // We've got the characteristics. Now delete local device connection, if any.
    if (*pszPath==DIR_SEPARATOR_CHAR && !pfnGetDiskFreeSpaceEx)
    {
        pfnWNetCancelConnection(szDevice, FALSE);
    }

    return fRet;
}


// -- ScanToLastSeparator
// Given a path, and a pointer within the path, discover where the path separator prior to the path
// is located and return the pointer to it. If there is none, return NULL.

BOOL ScanToLastSeparator(PTSTR pszPath, PTSTR* ppszCurrent)
{
    PTSTR pszActual = *ppszCurrent;
    pszActual--;
    while ((pszActual>(pszPath+1)) && (*pszActual!=DIR_SEPARATOR_CHAR))
    {
        pszActual--;
    }
    if ((*pszActual==DIR_SEPARATOR_CHAR) && (pszActual!=*ppszCurrent))
    {
        *ppszCurrent = pszActual;
        return TRUE;
    }

    return FALSE;
}

// -- Centralised method of tracking mutexes
// class MUTEX_HOLDER

MUTEX_HOLDER::MUTEX_HOLDER()
{
    _hHandle = NULL;
    _dwState = WAIT_FAILED;
}

MUTEX_HOLDER::~MUTEX_HOLDER()
{
    if (_hHandle)
    {
        INET_ASSERT(FALSE);
        TcpsvcsDbgPrint((DEBUG_CONTAINER,
            "ERROR: Releasing ownership of mutex %d\r\n",
            _hHandle));
        ReleaseMutex(_hHandle);
    }
}

VOID MUTEX_HOLDER::Grab(HANDLE hHandle, DWORD dwTime)
{
    INET_ASSERT(hHandle);
    _hHandle = hHandle;
    _dwState = WaitForSingleObject(_hHandle, dwTime);
    if (_dwState==WAIT_ABANDONED)
    {
        TcpsvcsDbgPrint((DEBUG_CONTAINER,
            "Gained ownership of abandoned mutex %d\r\n",
            hHandle));
    }
    else if (_dwState==WAIT_OBJECT_0)
    {
        TcpsvcsDbgPrint((DEBUG_CONTAINER,
            "Gained ownership of mutex %d\r\n",
            hHandle));
    }
    else
    {
        INET_ASSERT(FALSE);
        TcpsvcsDbgPrint((DEBUG_CONTAINER,
            "Unable to gain ownership of mutex %d\r\n",
            hHandle));
    }
}

VOID MUTEX_HOLDER::Release()
{
    if (_hHandle)
    {
        if (_dwState==WAIT_ABANDONED || _dwState==WAIT_OBJECT_0)
        {
            ReleaseMutex(_hHandle);
            TcpsvcsDbgPrint((DEBUG_CONTAINER,
                "Released ownership of mutex %d\r\n",
                _hHandle));
        }
        else
        {
            TcpsvcsDbgPrint((DEBUG_CONTAINER,
                "Would release ownership of mutex %d, except we don't own it\r\n",
                _hHandle));
        }
    }
    _hHandle = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5.1\wininet.inc ===
!IF 0

Copyright (c) 1994  Microsoft Corporation

Module Name:

    wininet.inc

Abstract:

    Common makefile contents for wininet project

Author:

    Richard L Firth (rfirth) 10-Feb-1996

Revision History:

    10-Feb-1996 rfirth
        Created

!ENDIF

!IFNDEF SDKINC
SDKINC=$(SDK_INC_PATH)
!ENDIF

!IFDEF LIBDIR
!ERROR LIBDIR already defined - choose new name
!ENDIF

LIBDIR=..\lib\$(_OBJ_DIR)

#
# if TARGETPATH is not defined (in the paths that build libraries) then this
# is the default target path
#

!IFNDEF TARGETPATH
TARGETPATH=$(LIBDIR)
TARGETTYPE=LIBRARY
!ENDIF

#
# what it is that we're building
#

MAJORCOMP=winhttpx

USE_NOLIBS=1
USE_MSVCRT=1
NO_NTDLL=1


#
# compiler definitions
#

C_DEFINES=$(C_DEFINES) -D_WINHTTP_INTERNAL_  -DCOMPILING_ROCKALL_LIBRARY -DFD_SETSIZE=256

# Get same version from NT or IE builds.
C_DEFINES=$(C_DEFINES)

!IFDEF USE_ICECAP
C_DEFINES=$(C_DEFINES) -DICECAP
!ENDIF

#
# Set debugging level
#

!IF "$(NTDEBUG)" != "" && "$(NTDEBUG)" != "retail" && "$(NTDEBUG)" != "ntsdnodbg"

C_DEFINES=$(C_DEFINES) -DENABLE_DEBUG

#
# remove maximal diagnostics for customer debug version based on environment
# variable
#

!IF "$(FULL_DEBUG)" != ""
C_DEFINES=$(C_DEFINES) -DUSE_DEBUG_MEMORY
!ELSE
C_DEFINES=$(C_DEFINES) -DRETAIL_LOGGING
!IF "$(BUILD_PRODUCT)" != "NT"
C_DEFINES=$(C_DEFINES) -DDISABLE_ASSERTS
!ENDIF
!ENDIF

!ELSE IF "$(ALMOSTRETAIL)" != ""
C_DEFINES=$(C_DEFINES) -DENABLE_DEBUG
!ENDIF

!IF "$(WIN64)" == "0" && "$(FULL_DEBUG)"==""
C_DEFINES=$(C_DEFINES) -DUSE_ROCKALL
!ENDIF

!if "$(WINHTTP_BROWSER_INFO)" == "1"
BROWSER_INFO = 1;
NO_BROWSER_FILE = 1;
USER_ENV_BROWSER_INFO=1
!endif


#
# performance diagnostics
#

!IF "$(PERF_BUILD)" != ""
C_DEFINES=$(C_DEFINES) -DUSE_PERF_DIAG
!ENDIF

!if !defined(CLEANINF_FLAGS)
# Cleaninf flags
CLEANINF_FLAGS  = -w
!endif

#
# Linker flags
#

!if "$(BUILD_PRODUCT)" == "IE"
USE_WIN98OPT=1
!endif

# Cleaninf utility
CLEANINF        = cleaninf.exe $(CLEANINF_FLAGS)

#
# Do this to assure that we run on NT 4.0 and Win95, even with
# NT5/Memphis headers.
#

WIN32_WINNT_VERSION=0x0400
WIN32_WIN95_VERSION=0x0400

#
# compiler warning flags
#

MSC_WARNING_LEVEL=/W3 /WX

#
# precompiled header options
#

!IFNDEF WININET_PCH

PRECOMPILED_OPTION=/Fp..\inc\$(_OBJ_DIR)\*\wininetp.pch /Yuwininetp.h
PRECOMPILED_CXX=1

!ENDIF

CONDITIONAL_INCLUDES = \
        winwlm.h \
        macwin32.h \
        ia64inst.h \
        pshpck16.h \
        rpcerr.h \
        rpcmac.h \
        macname1.h \
        macpub.h \
        macapi.h \
        macname2.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\urlcache\unxcache.cxx ===
#include <cache.hxx>
#include <conmgr.hxx>
#include <time.h>

#include <sys/types.h>
#include <sys/stat.h>
#include <dirent.h>
#include <fcntl.h>
#include <unistd.h>

#include <errno.h>


extern int errno;

/* Code swiped from cachecfg.cxx */
static BOOL _NormalisePath(LPCTSTR pszPath, LPCTSTR pszEnvVar,
                           LPTSTR pszResult, UINT cbResult)
{
     TCHAR szEnvVar[MAX_PATH];

     // don't count the NULL
     ExpandEnvironmentStrings(pszEnvVar, szEnvVar, sizeof(szEnvVar)-1);
     DWORD dwEnvVar = lstrlen(szEnvVar);

     if (CompareString(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, szEnvVar,
                       dwEnvVar, pszPath, dwEnvVar) == 2)
     {
        if (lstrlen(pszPath) + dwEnvVar < cbResult)
        {
           strncpy(pszResult, pszEnvVar, MAX_PATH);
           strncat(pszResult, pszPath + dwEnvVar, MAX_PATH);
           return TRUE;
         }
     }

     return FALSE;
}

void UnixNormalisePath(LPTSTR pszOrigPath, LPCTSTR pszEnvVar)
{
     TCHAR szScratch[MAX_PATH];
    
     if (_NormalisePath(pszOrigPath,pszEnvVar,szScratch,sizeof(szScratch)))
        strncpy(pszOrigPath,szScratch,MAX_PATH);
}

void UnixNormaliseIfCachePath(LPTSTR pszOrigPath, LPCTSTR pszEnvVar,
                              LPCTSTR pszKeyName)
{
     if (!strncmp(pszKeyName,CACHE_PATH_VALUE,lstrlen(CACHE_PATH_VALUE)))
        UnixNormalisePath(pszOrigPath,pszEnvVar);
}

int UnixPathExists(LPCTSTR pszPath)
{
     struct stat statbuf;

     if (stat(pszPath, &statbuf) < 0)
     {
        /* If path does not exist */
        if (errno == ENOENT)
           return 0;
        else
           return -1;
     }
     
     /* TODO */
     /* Make sure path points to a directory */

     return 1;
}

void UnixGetValidParentPath(LPTSTR szDevice)
{
     TCHAR szDeviceExists[MAX_PATH];
     PTSTR pszDeviceExists = NULL;
     PTSTR pszEnd          = NULL;
 
     if (!szDevice)
        return;

     lstrcpy(szDeviceExists, szDevice);
 
     pszDeviceExists = szDeviceExists;
     pszEnd          = szDeviceExists + lstrlen(szDeviceExists);
 
     for(;;)
     {
        int   fPathExists;
 
        if (pszEnd == pszDeviceExists)
           break;
 
        fPathExists = UnixPathExists(pszDeviceExists);
        if (fPathExists == -1)
        {
           /* Error */
           break;
        }
        else
        if (fPathExists == 0)
        {
           /* Path does not exist */
           while (*pszEnd != DIR_SEPARATOR_CHAR &&
                  pszEnd != pszDeviceExists)
                 pszEnd--;
 
           *pszEnd = '\0';

           continue;
        }
        else
        {
           /* Path exists */
           lstrcpy(szDevice, pszDeviceExists);
           break;
        }
    }
}

/* CopyDir */

static int DoCopy();

static int UnixCopyCacheFile(const char* file_src,
                         const char* file_dest,
                         mode_t fmode);

static int UnixCreateCacheFolder( const char* dir_dest, mode_t fmode);

#ifndef BUFSIZ
#define BUFSIZ 4096
#endif /* BUFSIZ */

#define CUR_DIR  "."
#define PREV_DIR ".."

static char* pathdir1 = NULL;
static char* pathdir2 = NULL;

int CopyDir(const char* dirname1, const char* dirname2)
{
    int Error = 0;
    struct stat statdir1, statdir2;

    if (!dirname1 || !dirname2)
    {
       goto Cleanup;
    }

    /* We are assuming that dirname1 and dirname2 are absolute paths */
    if (stat(dirname1, &statdir1) < 0)
    {
       Error = errno;
       goto Cleanup;
    }
    else
    if (!S_ISDIR(statdir1.st_mode))
    {
       Error = -1; /* source is not directory */
       goto Cleanup;
    }

    if (stat(dirname2, &statdir2) < 0)
    {
       if (errno != ENOENT)
       {
          Error = errno;
          goto Cleanup;
       }
       /* It is fine if the destination dir does not exist
        * provided all directories above the leaf dir exist
        */
    }
    else
    if (!S_ISDIR(statdir2.st_mode))
    {
       Error = -1; /* destination is not directory */
       goto Cleanup; 
    }

    pathdir1 = (char*)malloc((MAX_PATH+1)*sizeof(char));
    pathdir2 = (char*)malloc((MAX_PATH+1)*sizeof(char));

    lstrcpy(pathdir1, dirname1);
    lstrcpy(pathdir2, dirname2);

    Error = DoCopy();

Cleanup:

    if (pathdir1)
       free(pathdir1);

    if (pathdir2)
       free(pathdir2);

    pathdir1 = pathdir2 = NULL;

    return Error;
}

int DoCopy()
{
    struct stat statbuf;
    struct dirent *dirp;
    DIR           *dp;
    int           Error;
    char          *ptr1, *ptr2;

    if (stat(pathdir1, &statbuf) < 0)
    {
       Error = errno;
       goto Cleanup;
    }

    /* Check if this is a regular file */
    if ((statbuf.st_mode & S_IFMT) == S_IFREG)
    {
       Error = UnixCopyCacheFile(pathdir1, pathdir2, statbuf.st_mode);
       goto Cleanup;
    }

    /* Now, we are dealing with a directory */
    if ((Error = UnixCreateCacheFolder(pathdir2, statbuf.st_mode)))
       goto Cleanup;

    ptr1 = pathdir1 + lstrlen(pathdir1);
    *ptr1++ = '/';
    *ptr1   = 0;

    ptr2 = pathdir2 + lstrlen(pathdir2);
    *ptr2++ = '/';
    *ptr2 = 0;

    if ((dp = opendir(pathdir1)) == NULL)
    {
       Error = errno;
       goto Cleanup;
    }

    while ((dirp = readdir(dp)) != NULL)
    {
          if (!lstrcmp(dirp->d_name, CUR_DIR) ||
              !lstrcmp(dirp->d_name, PREV_DIR))
             continue;

          lstrcpy(ptr1, dirp->d_name);
          lstrcpy(ptr2, dirp->d_name);

          if ((Error = DoCopy()))
             break;
    }
    ptr1[-1] = 0;
    ptr2[-1] = 0;

    /* If this fails, ignore this error */
    closedir(dp);

Cleanup:

    return Error;
}

static int UnixCreateCacheFolder( const char* path_dest, mode_t mode_src)
{
    int Error = 0;
    struct stat statbuf2;

    if (stat(path_dest, &statbuf2) < 0)
    {
       if (errno == ENOENT)
       {
          if (mkdir(path_dest, mode_src) < 0)
          {
             Error = errno;
             goto Cleanup;
          }
       }
       else
       {
          Error = errno;
          goto Cleanup;
       }
    }
    else
    if (!S_ISDIR(statbuf2.st_mode))
       Error = -1; /* we are expecting a directory */

Cleanup:
    return Error;
}

int UnixCopyCacheFile(const char* file_src, const char* file_dest, mode_t fmode)
{
    int Error = 0;
    int fd1, fd2;
    char buf[BUFSIZ];
    int  nread, nwrite;

    if ((fd1 = open(file_src, O_RDONLY)) < 0)
    {
       Error = errno;
       goto Cleanup;
    }

    if ((fd2 = open(file_dest, O_CREAT|O_TRUNC|O_WRONLY, fmode)) < 0)
    {
       Error = errno;
       goto Cleanup;
    }

    while((nread = read(fd1, buf, BUFSIZ)) > 0)
    {
         if ((nwrite = write(fd2, buf, nread)) != nread)
         {
            Error = errno;
            goto Cleanup;
         }
    }

    Error = 0;

Cleanup:

    if (fd1 > 0)
       close(fd1);

    if (fd2 > 0)
       close(fd2);

    return Error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\urlcache\urlcache.h ===
#ifndef URLCACHE_H

#define URLCACHE_H

/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    urlcache.h

Abstract:

    Urlcache API enhanced and optimized for internal use by wininet.

Author:

    Rajeev Dujari (rajeevd) 10-Apr-1997

Revision History:

    10-Apr-97 rajeevd
        Created

--*/


DWORD
UrlCacheRetrieve
(
    IN  LPSTR                pszUrl,
    IN  BOOL                 fRedir,
    OUT HANDLE*              phStream,
    OUT CACHE_ENTRY_INFOEX** ppCEI
);

void UrlCacheFlush (void); // check registry to flush cache

DWORD 
UrlCacheCreateFile
(
    IN LPCSTR szUrl, 
    IN OUT LPTSTR szFile, 
    IN LPTSTR szExt,
    IN HANDLE* phfHandle,
    IN BOOL fCreatePerUser = FALSE,
    IN DWORD dwExpectedLength = 0
);

struct AddUrlArg
{
    LPCSTR   pszUrl;
    LPCSTR   pszRedirect;
    LPCTSTR  pszFilePath;
    DWORD    dwFileSize;
    LONGLONG qwExpires;
    LONGLONG qwLastMod;
    LONGLONG qwPostCheck;
    FILETIME ftCreate;
    DWORD    dwEntryType;
    LPCSTR   pbHeaders;
    DWORD    cbHeaders;
    LPCSTR   pszFileExt;
    BOOL     fImage;
    DWORD    dwIdentity;
};


DWORD UrlCacheCommitFile (IN AddUrlArg* pArgs);

DWORD UrlCacheAddLeakFile (IN LPCSTR pszFile);

DWORD UrlCacheSendNotification (IN DWORD dwOp);

BOOL IsExpired
(
    CACHE_ENTRY_INFOEX* pInfo, 
    DWORD dwCacheFlags, 
    BOOL* pfLaxyUpdate
);

extern const char vszUserNameHeader[4];

#ifdef UNIX
extern "C"
#endif /* UNIX */

BOOL GetIE5ContentPath( LPSTR szPath);

#if 0
DWORD SwitchIdentity(GUID* guidIdentity);
DWORD RemoveIdentity(GUID* guidIdentity);
DWORD AlterIdentity(DWORD dwControl);
#endif

#ifdef WININET6
DWORD ReadIDRegDword(LPCTSTR psz, PDWORD pdw);
DWORD WriteIDRegDword(LPCTSTR psz, DWORD dw);
#endif

#endif //URLCACHE.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5.1\api\autodial.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    autodial.cxx

Abstract:

    Contains the implementation of autodial

    Contents:

Author:

    Darren Mitchell (darrenmi) 22-Apr-1997

Environment:

    Win32(s) user-mode DLL

Revision History:

    14-Jan-2002 ssulzer
        Ported small subset to WinHttp

    22-Apr-1997 darrenmi
        Created


--*/

#include "wininetp.h"
#include "autodial.h"
#include "rashelp.h"
#include <winsvc.h>
#include <iphlpapi.h>

// Globals.

DWORD   g_dwLastTickCount = 0;

// serialize access to RAS
HANDLE g_hRasMutex = INVALID_HANDLE_VALUE;

// don't check RNA state more than once every 10 seconds
#define MIN_RNA_BUSY_CHECK_INTERVAL 10000

//
// Current ras connections - used so we don't poll ras every time we're
// interested - only poll every 10 seconds (const. above)
//
RasEnumConnHelp * g_RasCon;

DWORD       g_dwConnections = 0;
BOOL        g_fRasInstalled = FALSE;
DWORD       g_dwLastDialupTicks = 0;

//
// Control of autodial initialization
//
BOOL        g_fAutodialInitialized = FALSE;


///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
//
//                         RAS dynaload code
//
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

static HINSTANCE g_hRasLib = NULL;

static _RASENUMENTRIESW          pfnRasEnumEntriesW = NULL;
static _RASGETCONNECTSTATUSW     pfnRasGetConnectStatusW = NULL;
static _RASENUMCONNECTIONSW      pfnRasEnumConnectionsW = NULL;
static _RASGETENTRYPROPERTIESW   pfnRasGetEntryPropertiesW = NULL;


typedef struct _tagAPIMAPENTRY {
    FARPROC* pfn;
    LPSTR pszProc;
} APIMAPENTRY;

APIMAPENTRY rgRasApiMapW[] = {
    { (FARPROC*) &pfnRasEnumEntriesW,            "RasEnumEntriesW" },
    { (FARPROC*) &pfnRasGetConnectStatusW,       "RasGetConnectStatusW" },
    { (FARPROC*) &pfnRasEnumConnectionsW,        "RasEnumConnectionsW" },
    { (FARPROC*) &pfnRasGetEntryPropertiesW,     "RasGetEntryPropertiesW"},
    { NULL, NULL },
};

#define RASFCN(_fn, _part, _par, _dbge, _dbgl)     \
DWORD _##_fn _part                          \
{                                           \
    DEBUG_ENTER(_dbge);                     \
                                            \
    DWORD dwRet;                            \
    if(NULL == pfn##_fn)                    \
    {                                       \
        _dbgl(ERROR_INVALID_FUNCTION);      \
        return ERROR_INVALID_FUNCTION;      \
    }                                       \
                                            \
    dwRet = (* pfn##_fn) _par;              \
                                            \
    _dbgl(dwRet);                           \
    return dwRet;                           \
}


RASFCN(RasEnumEntriesW,
    (LPWSTR lpszReserved, LPWSTR lpszPhonebook, LPRASENTRYNAMEW lprasentryname,
    LPDWORD lpcb, LPDWORD lpcEntries),
    (lpszReserved, lpszPhonebook, lprasentryname, lpcb, lpcEntries),
    (DBG_DIALUP, Dword, "RasEnumEntriesW", "%#x (%Q), %#x (%Q), %#x, %#x %#x", lpszReserved, lpszReserved, lpszPhonebook, lpszPhonebook, lprasentryname, lpcb, lpcEntries),
    DEBUG_LEAVE
    );

RASFCN(RasGetConnectStatusW,
    (HRASCONN hrasconn, LPRASCONNSTATUSW lprasconnstatus),
    (hrasconn, lprasconnstatus),
    (DBG_DIALUP, Dword, "RasGetConnectStatusW", "%#x, %#x", hrasconn, lprasconnstatus),
    DEBUG_LEAVE
    );

RASFCN(RasGetEntryPropertiesW,
    (LPWSTR lpszPhonebook, LPWSTR lpszEntry, LPRASENTRYW lpRasEntry, LPDWORD lpdwEntryInfoSize, LPBYTE lpbDeviceInfo, LPDWORD lpdwDeviceInfoSize),
    (lpszPhonebook, lpszEntry, lpRasEntry, lpdwEntryInfoSize, lpbDeviceInfo, lpdwDeviceInfoSize),
    (DBG_DIALUP, Dword, "RasGetEntryPropertiesW", "%#x (%Q), %#x (%Q), %#x, %#x, %#x %#x", lpszPhonebook, lpszPhonebook, lpszEntry, lpszEntry, lpRasEntry, lpdwEntryInfoSize, lpbDeviceInfo, lpdwDeviceInfoSize),
    DEBUG_LEAVE
    );

RASFCN(RasEnumConnectionsW,
    (LPRASCONNW lpRasConn, LPDWORD lpdwSize, LPDWORD lpdwConn),
    (lpRasConn, lpdwSize, lpdwConn),
    (DBG_DIALUP, Dword, "RasEnumConnectionsW", "%#x, %#x, %#x", lpRasConn, lpdwSize, lpdwConn),
    DEBUG_LEAVE
    );

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

BOOL
EnsureRasLoaded(
    VOID
    )

/*++

Routine Description:

    Dynaload ras apis

Arguments:

    pfInstalled - return installed state of ras

Return Value:

    BOOL
        TRUE    - Ras loaded
        FALSE   - Ras not loaded

--*/

{
    DEBUG_ENTER((DBG_DIALUP,
                 Bool,
                 "EnsureRasLoaded",
                 NULL
                 ));

    //
    // Looks like RAS is installed - try and load it up!
    //
    if(NULL == g_hRasLib)
    {
        g_hRasLib = LoadLibrary("RASAPI32.DLL");

        if(NULL == g_hRasLib)
        {
            DEBUG_LEAVE(FALSE);
            return FALSE;
        }

        APIMAPENTRY *prgRasApiMap = rgRasApiMapW;

        int nIndex = 0;
        while ((prgRasApiMap+nIndex)->pszProc != NULL)
        {
            // Some functions are only present on some platforms.  Don't
            // assume this succeeds for all functions.
            *(prgRasApiMap+nIndex)->pfn =
                    GetProcAddress(g_hRasLib, (prgRasApiMap+nIndex)->pszProc);
            nIndex++;
        }
    }

    if(g_hRasLib)
    {
        DEBUG_LEAVE(TRUE);
        return TRUE;
    }

    DEBUG_LEAVE(FALSE);
    return FALSE;
}


BOOL
IsRasInstalled(
    VOID
    )

/*++

Routine Description:

    Determines whether ras is installed on this machine

Arguments:

    none

Return Value:

    BOOL
        TRUE    - Ras is installed

        FALSE   - Ras is not installed

--*/

{
    DEBUG_ENTER_API((DBG_DIALUP,
                 Bool,
                 "IsRasInstalled",
                 NULL
                 ));

    static fChecked = FALSE;

    //
    // If RAS is already loaded, don't bother doing any work.
    //
    if(g_hRasLib)
    {
        DEBUG_LEAVE_API(TRUE);
        return TRUE;
    }

    //
    // if we've already done the check, don't do it again
    //
    if(fChecked)
    {
        DEBUG_LEAVE_API(g_fRasInstalled);
        return g_fRasInstalled;
    }

    OSVERSIONINFO osvi;

    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&osvi);

    if (osvi.dwMajorVersion < 5)
    {
        // WinHttp does not support the use of RAS on NT4
        g_fRasInstalled = FALSE;
    }
    else
    {
        // NT5 and presumably beyond, ras is always installed
        g_fRasInstalled = TRUE;
    }

    fChecked = TRUE;

    DEBUG_LEAVE_API(g_fRasInstalled);
    return g_fRasInstalled;
}


BOOL
DoConnectoidsExist(
    VOID
    )

/*++

Routine Description:

    Determines whether any ras connectoids exist

Arguments:

    none

Return Value:

    BOOL
        TRUE    - Connectoids exist

        FALSE   - No connectoids exist

--*/

{
    DEBUG_ENTER_API((DBG_DIALUP,
                 Bool,
                 "DoConnectoidsExist",
                 NULL
                 ));

    static BOOL fExist = FALSE;

    //
    // If we found connectoids before, don't bother looking again
    //
    if(fExist)
    {
        DEBUG_LEAVE_API(TRUE);
        return TRUE;
    }

    //
    // If RAS is already loaded, ask it
    //
    if(g_hRasLib)
    {
        DWORD dwRet, dwEntries;

        RasEnumHelp *pRasEnum = new RasEnumHelp;

        if (pRasEnum)
        {
            dwRet = pRasEnum->GetError();
            dwEntries = pRasEnum->GetEntryCount();
            delete pRasEnum;
        }
        else
        {
            dwRet = ERROR_NOT_ENOUGH_MEMORY;
            dwEntries = 0;
        }

        // If ras tells us there are none, return none
        if(ERROR_SUCCESS == dwRet && 0 == dwEntries)
        {
            DEBUG_LEAVE_API(FALSE);
            return FALSE;
        }
        // couldn't determine that there aren't any so assume there are.
        fExist = TRUE;
        DEBUG_LEAVE_API(TRUE);
        return TRUE;
    }

    //
    // if ras isn't installed, say no connectoids
    //
    if(FALSE == IsRasInstalled())
    {
        DEBUG_LEAVE_API(FALSE);
        return FALSE;
    }

    OSVERSIONINFO osvi;

    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&osvi);

    // assume connectoids exist
    fExist = TRUE;

    if (osvi.dwMajorVersion < 5)
    {
        fExist = FALSE;
    }

    DEBUG_LEAVE_API(fExist);
    return fExist;
}



///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
//
//                           Initialization
//
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

BOOL
InitAutodialModule()

/*++

Routine Description:

    Initialize autodial code

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_DIALUP,
                 Bool,
                 "InitAutodialModule",
                 NULL
                 ));

    // Assert that WinHttp's global data has already been initialized
    INET_ASSERT(GlobalDataInitialized);

    // only do this once...
    if(g_fAutodialInitialized)
    {
        DEBUG_LEAVE(g_fAutodialInitialized);
        return g_fAutodialInitialized;
    }

    if (GlobalDataInitCritSec.Lock())
    {
        if (!g_fAutodialInitialized)
        {
            // create mutex to serialize access to RAS (per process)
            g_hRasMutex = CreateMutex(NULL, FALSE, NULL);

            if (g_hRasMutex != INVALID_HANDLE_VALUE)
            {
                g_RasCon = new RasEnumConnHelp();

                if (g_RasCon != NULL)
                {
                    g_fAutodialInitialized = TRUE;
                }
                else
                {
                    CloseHandle(g_hRasMutex);
                    g_hRasMutex = INVALID_HANDLE_VALUE;
                }
            }
        }

        GlobalDataInitCritSec.Unlock();
    }

    DEBUG_LEAVE(g_fAutodialInitialized);

    return g_fAutodialInitialized;
}


VOID
ExitAutodialModule(
    VOID
    )

/*++

Routine Description:

    Clean up autodial code

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_DIALUP,
                 None,
                 "ExitAutodialModule",
                 NULL
                 ));

    // don't do anything if not initialized
    if(FALSE == g_fAutodialInitialized)
    {
        DEBUG_LEAVE(0);
        return;
    }

    if (g_RasCon)
    {
        delete g_RasCon;
        g_RasCon = NULL;
    }

    if(INVALID_HANDLE_VALUE != g_hRasMutex)
    {
        CloseHandle(g_hRasMutex);
        g_hRasMutex = INVALID_HANDLE_VALUE;
    }

    if (g_hRasLib)
    {
        FreeLibrary(g_hRasLib);
        g_hRasLib = NULL;
    }

    g_fAutodialInitialized = FALSE;

    DEBUG_LEAVE(0);
}



///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
//
//                     Connection management code
//
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////




LPSTR
GetActiveConnectionName()

/*++

Routine Description:

    Figure out the current connection and fix proxy settings for it.
    Basically a cheap, return-no-info version of GetConnectedStateEx used
    by the winsock callback.

Arguments:

    none

Return Value:

    BOOL
        TRUE        - connected
        FALSE       - not connected

--*/

{
    DEBUG_ENTER((DBG_DIALUP,
                 String,
                 "GetActiveConnectionName",
                 NULL
                 ));

    static BOOL     fRasLoaded = FALSE;
    DWORD           dwNewTickCount, dwElapsed;
    DWORD           dwConnection = 0;
    LPSTR           lpstrConnection = NULL;

    //
    // Make sure everything's initialized
    //
    if (!InitAutodialModule())
        goto quit;

    //
    // serialize
    //
    WaitForSingleObject(g_hRasMutex, INFINITE);

    //
    // Check out how recently we polled ras
    //
    dwNewTickCount = GetTickCountWrap();
    dwElapsed = dwNewTickCount - g_dwLastDialupTicks;

    //
    // Only refresh if more than MIN... ticks has passed
    //
    if(dwElapsed >= MIN_RNA_BUSY_CHECK_INTERVAL)
    {
        g_dwLastDialupTicks = dwNewTickCount;
        if(DoConnectoidsExist())
        {
            if(FALSE == fRasLoaded)
                fRasLoaded = EnsureRasLoaded();

            if(fRasLoaded)
            {
                g_RasCon->Enum();
                if(g_RasCon->GetError() == 0)
                    g_dwConnections = g_RasCon->GetConnectionsCount();
                else
                    g_dwConnections = 0;
            }
        }
        else
        {
            g_dwConnections = 0;
        }
    }

    DEBUG_PRINT(DIALUP, INFO, ("Found %d connections\n", g_dwConnections));

    if(g_dwConnections > 1)
    {
        //
        // We have more than one connection and caller wants to know which one
        // is the interesting one.  Try to find a VPN connectoid.
        //
        RasEntryPropHelp *pRasProp = new RasEntryPropHelp;

        if (pRasProp)
        {
            for(DWORD dwConNum = 0; dwConNum < g_dwConnections; dwConNum++)
            {
                if(0 == pRasProp->GetW(g_RasCon->GetEntryW(dwConNum)))
                {
                    if(0 == lstrcmpiA(pRasProp->GetDeviceTypeA(), RASDT_Vpn))
                    {
                        DEBUG_PRINT(DIALUP, INFO, ("Found VPN entry: %ws\n",
                            g_RasCon->GetEntryW(dwConNum)));
                        dwConnection = dwConNum;
                        break;
                    }
                }
            }
            delete pRasProp;
        }
    }

    //
    // verify status of connection we're interested in is RASCS_Connected.
    //
    if(g_dwConnections != 0)
    {
        RasGetConnectStatusHelp RasGetConnectStatus(g_RasCon->GetHandle(dwConnection));
        DWORD dwRes = RasGetConnectStatus.GetError();
        if (!dwRes && (RasGetConnectStatus.ConnState() == RASCS_Connected))
        {
            WideCharToAscii_UsingGlobalAlloc(g_RasCon->GetEntryW(dwConnection),
                    &lpstrConnection);
        }

        DEBUG_PRINT(DIALUP, INFO, ("Connect Status: dwRet=%x, connstate=%x\n", dwRes, RasGetConnectStatus.ConnState()));
    }

    ReleaseMutex(g_hRasMutex);

quit:
    DEBUG_LEAVE(lpstrConnection);
    return lpstrConnection;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5\urlcache\test\testurlcache.cxx ===
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright 1996 Microsoft Corporation.  All Rights Reserved.
// ===========================================================================
// 
// Test driver for the persistant URL Cache component
//

// This define is a hack
#define __CACHE_INCLUDE__

#include <windows.h>
#include <winhttp.h>
#include "..\cache.hxx"
#include <conio.h>
#include <stdio.h>
#include <crtdbg.h>
#include <stdlib.h>
#include <time.h>

// support for Unicode
#include <tchar.h>

// file I/O include
#include <fstream.h>

#define CACHE_ENTRY_BUFFER_SIZE (1024 * 5)
#define DEFAULT_BUFFER_SIZE 1024
#define MAX_URL_LENGTH (1024 * 5)

// URL string constants
#define URL_1 "t-eddieng"
#define URL_2 "http://www.microsoft.com"

// global variables
BYTE GlobalCacheEntryInfoBuffer[CACHE_ENTRY_BUFFER_SIZE];

// General Utility Functions
// =======================================================================
LPTSTR
ConvertGmtTimeToString(
    FILETIME Time,
    LPTSTR OutputBuffer
    )
{
    SYSTEMTIME SystemTime;
    FILETIME LocalTime;

    static FILETIME ftNone = {0, 0};
    
    if (!memcmp (&Time, &ftNone, sizeof(FILETIME)))
        _stprintf (OutputBuffer, _T( "<none>" ));
    else
    {
        FileTimeToLocalFileTime( &Time , &LocalTime );
        FileTimeToSystemTime( &LocalTime, &SystemTime );

        _stprintf( OutputBuffer,
                    _T( "%02u/%02u/%04u %02u:%02u:%02u " ),
                    SystemTime.wMonth,
                    SystemTime.wDay,
                    SystemTime.wYear,
                    SystemTime.wHour,
                    SystemTime.wMinute,
                    SystemTime.wSecond );
    }
    
    return( OutputBuffer );
}

DWORD TestCommitCacheEntryWithoutInet(VOID) {
	DWORD dwExpectedSize = 0;	                
	TCHAR lpFileExtension[] = "html";
	TCHAR lpszFileName[MAX_PATH];
    TCHAR szBuffer[] = "<HTML><TITLE>Test</TITLE><BODY>Testgadfasing</BODY></HTML>";
    HANDLE hWrite;
    DWORD dwWritten;

    // Prepare cache entry by calling CreateUrlCacheEntry
    if( !CreateUrlCacheEntryA(
                URL_1,
                dwExpectedSize,
                lpFileExtension,
                lpszFileName,
                0 )  ) {
        printf ("CreateUrlCacheEntry failed: %x\n", GetLastError());
        return( GetLastError() );
    }

    _tprintf(_T( "URL = %s\n" ), lpszFileName);

    // Now monkey around with the local file (lpszFileName)
    hWrite = CreateFile(lpszFileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hWrite == INVALID_HANDLE_VALUE) {
        printf ("CreateFile failed: %x\n", GetLastError());
        return GetLastError();
    }

    WriteFile(hWrite, &szBuffer, sizeof(szBuffer), &dwWritten, NULL);
    if (sizeof(szBuffer) != dwWritten) {
        printf ("WriteFile failed: %x\n", GetLastError());
        return GetLastError();
    }

    CloseHandle(hWrite);

    FILETIME unknownTime1;
    unknownTime1.dwLowDateTime = 0;
    unknownTime1.dwHighDateTime = 0;
    
    FILETIME unknownTime2;
    unknownTime2.dwLowDateTime = 0;
    unknownTime2.dwHighDateTime = 0;

    // Commit cache entry by calling CommitUrlCacheEntry
    if ( !CommitUrlCacheEntryA(URL_1, 
                               lpszFileName, 
                               unknownTime1, /* unknown expire time */
                               unknownTime2, /* unknown last modified time */
                               NORMAL_CACHE_ENTRY,
                               NULL,
                               0,
                               NULL,
                               NULL)) {
        printf ("CommitUrlCacheEntry failed: %x\n", GetLastError());
        return GetLastError();
    }
    
    return TRUE;
}

/* +++

    FPTestEnumerateCache Function pointers

--- */
// =======================================================================

DWORD TestCommitCacheEntryFromInet(LPINTERNET_CACHE_ENTRY_INFO lpCacheEntryInfo) {
    TCHAR TimeBuffer[DEFAULT_BUFFER_SIZE];
    LPTSTR Tab = _T( "" );

	TCHAR *lpFileExtension = NULL;
	LPSTR lpszUrlName = lpCacheEntryInfo->lpszSourceUrlName;
    LPSTR lpszFileName = lpCacheEntryInfo->lpszLocalFileName;

    TCHAR szBuffer[] = "<HTML><TITLE>Test</TITLE><BODY>Testing</BODY></HTML>";
    HANDLE hWrite;
    DWORD dwWritten;
    DWORD dwExpectedSize;

    printf ("%s\n", lpszFileName);

    
    // Now monkey around with the local file (lpszFileName)
    hWrite = CreateFile(lpszFileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hWrite == INVALID_HANDLE_VALUE) {
        printf ("CreateFile failed: %x\n", GetLastError());
        return GetLastError();
    }

    WriteFile(hWrite, &szBuffer, sizeof(szBuffer), &dwWritten, NULL);
    if (sizeof(szBuffer) != dwWritten) {
        printf ("WriteFile failed: %x\n", GetLastError());
        return GetLastError();
    }

	dwExpectedSize = GetFileSize(hWrite, NULL); 

    CloseHandle(hWrite);

    // Commit cache entry by calling CommitUrlCacheEntry
    if ( !CommitUrlCacheEntryA(lpszUrlName, 
                               lpszFileName, 
                               lpCacheEntryInfo->ExpireTime,  /* expire time */
                               lpCacheEntryInfo->LastModifiedTime, /* last modified time */
                               NORMAL_CACHE_ENTRY,
                               NULL,
                               0,
                               NULL,
                               NULL)) {
        printf ("CommitUrlCacheEntry failed: %x\n", GetLastError());
        return GetLastError();
    }
    
    return ERROR_SUCCESS;
}

// getting the content of the a cache entry into memory (i.e. don't need to write to disk)
DWORD TestRetrieveCacheEntryToMemory(LPINTERNET_CACHE_ENTRY_INFO lpCacheEntryInfo) {
    DWORD dwLen;
    DWORD szFileSize = lpCacheEntryInfo->dwSizeLow;
    DWORD dwCurLocation = 0;
    TCHAR lpszUrlName[MAX_URL_LENGTH];
    HANDLE hCacheEntryStream;
    LPSTR pszBuffer;
    DWORD dwEntryBufferSize = CACHE_ENTRY_BUFFER_SIZE;
    
    strncpy(lpszUrlName, lpCacheEntryInfo->lpszSourceUrlName, MAX_URL_LENGTH); 

    if ((hCacheEntryStream = RetrieveUrlCacheEntryStreamA(lpszUrlName, lpCacheEntryInfo, 
                                &dwEntryBufferSize, TRUE, 0)) == NULL) 
    {
        return GetLastError();
    }

    // srand( (unsigned)time(NULL));

    //while (TRUE) {
        dwLen = szFileSize;
        pszBuffer = new char[dwLen+1];
        ZeroMemory(pszBuffer, dwLen+1);

        if (ReadUrlCacheEntryStream(hCacheEntryStream, dwCurLocation, (LPVOID)pszBuffer, &dwLen, 0)) {
            printf ("%s\n\n", pszBuffer);
            delete pszBuffer;
        }
        else
        {
            delete pszBuffer;
            dwCurLocation += dwLen;
            if (dwCurLocation == szFileSize)
                return GetLastError();

            _ASSERT(0);
        }
            
    //}

    // close the cache entry stream handle
    UnlockUrlCacheEntryStream(hCacheEntryStream, 0);
    return ERROR_SUCCESS;
    
}    
DWORD TestGetUrlCacheEntryInfo(LPINTERNET_CACHE_ENTRY_INFO lpCacheEntryInfo) {
    TCHAR TimeBuffer[DEFAULT_BUFFER_SIZE];
    LPTSTR Tab = _T( "" );

    if (!(lpCacheEntryInfo->CacheEntryType & COOKIE_CACHE_ENTRY) && 
       !(lpCacheEntryInfo->CacheEntryType & URLHISTORY_CACHE_ENTRY)) {
        printf("\n\n------------------------------------------------------------------\n");
        _tprintf( _T( "%sUrlName = %s\n" ), Tab, lpCacheEntryInfo->lpszSourceUrlName );
#if UNICODE
        _tprintf( _T( "%sLocalFileName = %ws\n" ), Tab, lpCacheEntryInfo->lpszLocalFileName );
#else
        _tprintf( _T( "%sLocalFileName = %s\n" ), Tab, lpCacheEntryInfo->lpszLocalFileName );
#endif
        _tprintf( _T( "%sdwStructSize = %lx\n" ), Tab, lpCacheEntryInfo->dwStructSize );
        _tprintf( _T( "%sCacheEntryType = %lx\n" ), Tab, lpCacheEntryInfo->CacheEntryType );
        _tprintf( _T( "%sUseCount = %ld\n" ), Tab, lpCacheEntryInfo->dwUseCount );

        _tprintf( _T( "%sHitRate = %ld\n" ), Tab, lpCacheEntryInfo->dwHitRate );
        _tprintf( _T( "%sSize = %ld:%ld\n" ), Tab, lpCacheEntryInfo->dwSizeLow, lpCacheEntryInfo->dwSizeHigh );
        _tprintf( _T( "%sLastModifiedTime = %s\n" ), Tab, ConvertGmtTimeToString( lpCacheEntryInfo->LastModifiedTime, TimeBuffer) );
        _tprintf( _T( "%sExpireTime = %s\n" ), Tab, ConvertGmtTimeToString( lpCacheEntryInfo->ExpireTime, TimeBuffer) );
        _tprintf( _T( "%sLastAccessTime = %s\n" ), Tab, ConvertGmtTimeToString( lpCacheEntryInfo->LastAccessTime, TimeBuffer) );
        _tprintf( _T( "%sLastSyncTime = %s\n" ), Tab, ConvertGmtTimeToString( lpCacheEntryInfo->LastSyncTime, TimeBuffer) );
#if 1
        _tprintf( _T( "%sHeaderInfo = \n%s\n" ), Tab, lpCacheEntryInfo->lpHeaderInfo );
#endif
        _tprintf( _T( "%sHeaderInfoSize = %ld\n" ), Tab, lpCacheEntryInfo->dwHeaderInfoSize );
#if UNICODE
        _tprintf( _T( "%sFileExtension = %ws\n" ), Tab, lpCacheEntryInfo->lpszFileExtension );
#else
        _tprintf( _T( "%sFileExtension = %s\n" ), Tab, lpCacheEntryInfo->lpszFileExtension );
#endif

    }
    return ERROR_SUCCESS;

}

// =============================================================================
typedef DWORD (*FPTestEnumerateCache)(LPINTERNET_CACHE_ENTRY_INFO);
    
/* +++

    TestEnumerateCache

    Purpose:
    Enumerate the persistent URL cache entry in the system.
    
    Parameters:
        [in] count  -    number of iterations to enumerate.  If set to 0 than enumerate all
        ptrfunc     -   a the function pointer to call for each cache entry.  If set to NULL then
                        no functions are called

    Return Value:
        ERROR_SUCCESS if call succeeds.  Otherwise return GetLastError()

--- */

DWORD TestEnumerateCache(DWORD dwCount, FPTestEnumerateCache pfTestEnumerateCache) {

    LPINTERNET_CACHE_ENTRY_INFO lpCacheEntryInfo;
    DWORD CacheEntryInfoBufferSize;
    
    DWORD dwBufferSize;
    HANDLE EnumHandle;
    DWORD dwIndex = 0;
    TCHAR UrlName[1024];
    DWORD dwError = ERROR_SUCCESS;

    do
    {
        memset(GlobalCacheEntryInfoBuffer, 0, CACHE_ENTRY_BUFFER_SIZE);
        dwBufferSize = CACHE_ENTRY_BUFFER_SIZE;
        if( dwIndex++ == 0)
        {
            EnumHandle = FindFirstUrlCacheEntryEx (
                NULL,                   // search pattern
                0,                      // flags
                0xffffffff,             // filter
                0,                      // groupid
                (LPINTERNET_CACHE_ENTRY_INFO)GlobalCacheEntryInfoBuffer,
                &dwBufferSize,
                NULL,
                NULL,
                NULL
            );

            if( EnumHandle == NULL ) {
                return( GetLastError() );
            }
        } else {
            if( !FindNextUrlCacheEntryEx(
                    EnumHandle,
                    (LPINTERNET_CACHE_ENTRY_INFO)GlobalCacheEntryInfoBuffer,
                    &dwBufferSize, NULL, NULL, NULL))
            {
                dwError = GetLastError();
                if( dwError != ERROR_NO_MORE_ITEMS ) 
                    return( dwError );                   
                break;
            }
        }

        // now we've got the URL entry, do something about it
        strcpy(UrlName, ((LPINTERNET_CACHE_ENTRY_INFO)GlobalCacheEntryInfoBuffer)->lpszSourceUrlName);

        lpCacheEntryInfo = (LPINTERNET_CACHE_ENTRY_INFO)GlobalCacheEntryInfoBuffer;
        CacheEntryInfoBufferSize = CACHE_ENTRY_BUFFER_SIZE;

        // clean up the block of memory
        memset(GlobalCacheEntryInfoBuffer, 0, CACHE_ENTRY_BUFFER_SIZE);

        _ASSERT(UrlName);

        // put cache entry info into lpCacheEntryInfo
        if (GetUrlCacheEntryInfoA(UrlName,
                                 lpCacheEntryInfo,
                                 &CacheEntryInfoBufferSize ))
        {
            if (pfTestEnumerateCache(lpCacheEntryInfo) != ERROR_SUCCESS)
                printf ("Function pointer call failed\n");
        }
    }
    while (dwCount == 0 || (dwCount != 0 && dwIndex < dwCount));

    FindCloseUrlCache(EnumHandle);
	return TRUE;
}

// =============================================================================
/* +++

    Sets of test cases to execute directly from main()
    
---*/
   
void TestCase1() {
	(void) TestEnumerateCache(0, (FPTestEnumerateCache)TestGetUrlCacheEntryInfo);
	//(void) TestEnumerateCache(1, (FPTestEnumerateCache)TestCommitCacheEntryFromInet);
}

void TestCase2() {
    (void) TestCommitCacheEntryWithoutInet();
}

// test retrieving the cache entry to memory (i.e. don't need a file) incrementally using the Wininet API
void TestCase3() {
    (void) TestEnumerateCache(4, (FPTestEnumerateCache)TestRetrieveCacheEntryToMemory);
}

void TestCase4() {
    (void) TestEnumerateCache(1, (FPTestEnumerateCache)TestCommitCacheEntryFromInet);
}

void __cdecl main() {
	// HACK: At the time being, DLLUrlCacheEntry has to be called explicitly during initialization and termination, 
	// since the urlcache component is not attached to WinHttp's DLL hooks yet.
	// We'll remove this constraint when the cache component becomes part of WinHTTP
	DLLUrlCacheEntry(DLL_PROCESS_ATTACH);    

    TestCase1();

	DLLUrlCacheEntry(DLL_PROCESS_DETACH);    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5.1\api\cliauth.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    cliauth.cxx

Abstract:

    Contains Schannel/SSPI specific code for handling Client Authenication
    multiplexed between several asynchronous requests using fibers

    Contents:
        CERT_CONTEXT_ARRAY::CERT_CONTEXT_ARRAY
        CERT_CONTEXT_ARRAY::Reset
        CERT_CONTEXT_ARRAY::~CERT_CONTEXT_ARRAY
        CliAuthSelectCredential

Author:

    Arthur L Bierer (arthurbi) 13-Jun-1996

Environment:

    Win32 user-mode DLL

Revision History:

    13-Jun-1996 arthurbi
        Created, based on orginal code from a-petesk.

--*/

#include <wininetp.h>


extern "C" {

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntsecapi.h>

}


CERT_FREE_CERTIFICATE_CONTEXT_FN       g_pfnCertFreeCertificateContext = NULL;


CERT_CONTEXT_ARRAY::CERT_CONTEXT_ARRAY(BOOL fNoRevert)
{
    _error           = ERROR_SUCCESS;
    _iSelected  = -1;
    _ppCertContexts    = (PCCERT_CONTEXT *)
                        ALLOCATE_MEMORY(sizeof(PCERT_CONTEXT)* CERT_CONTEXT_ARRAY_ALLOC_UNIT);

    if ( _ppCertContexts == NULL ) {
        _error = GetLastError();
    }

    _cAlloced  = CERT_CONTEXT_ARRAY_ALLOC_UNIT;
    _cCertContexts     = 0;

    ClearCreds(_hCreds);
    _cs.Init();

    _fNoRevert = fNoRevert;
}

void CERT_CONTEXT_ARRAY::Reset(void)
{
    if ( _ppCertContexts )
    {
        for ( DWORD i = 0; i < _cCertContexts; i++ )
        {
            INET_ASSERT(_ppCertContexts[i]);
            WRAP_REVERT_USER_VOID((*g_pfnCertFreeCertificateContext), _fNoRevert, (_ppCertContexts[i]));
        }
    }
    _cCertContexts = 0;
    
    // It is important that this Free is guarded by a try except.
    // These objects get freed up at dll unload time and there is a circular
    // dependency between winient and schannel which can cause schannel to 
    // get unloaded. If that is the case we could fault here.
    if (!IsCredClear(_hCreds))
    {
        SAFE_WRAP_REVERT_USER_VOID(g_FreeCredentialsHandle, _fNoRevert, (&_hCreds));
    }
}


CERT_CONTEXT_ARRAY::~CERT_CONTEXT_ARRAY()
{
    Reset();

    FREE_MEMORY(_ppCertContexts);
}

DWORD
CliAuthSelectCredential(
    IN PCtxtHandle        phContext,
    IN LPTSTR             pszPackageName,
    IN CERT_CONTEXT_ARRAY*  pCertContextArray,
    OUT PCredHandle       phCredential,
    IN LPDWORD            pdwStatus,
    IN DWORD              dwSecureProtocols,
    IN BOOL               fNoRevert)

/*++

Routine Description:

    Uses a selected Certificate Chain to produce a Credential handle.

    The credential handle will be used by SCHANNEL to produce a valid Client
    Auth session with a server.

Arguments:

    phContext       - SSPI Context Handle

    pszPackageName  - Name of the SSPI package we're using.

    pSelectedCert   - Cert that User wishes us to use for Client Auth with this server.
                       (BUGBUG who should free this? )

    phCredential    - Outgoing SSPI Credential handle that we may generate
                    IMPORTANT: Do not free the credential handle returned by this function.
                    These have to be cached for the lifetime of the process so the user 
                    doesn't get prompted forthe password over and over. Unfortunately there is
                    no ref-counting mechanism on CredHandle's so callers of this function need to 
                    make sure they don't free the handle.

    pdwStatus       - Secure error status flag that's filled in if an error occurs.
                    Pointer is assumed to be valid.

    dwSecureProtocols - Enabled secure protocols (SSL2, SSL3, and/or TLS1) when acquiring
                        this credential.

    fNoRevert         - Determines if any impersonation should be reverted for SSL handling.

Return Value:

    DWORD
        Success - ERROR_SUCCESS
                        Caller should return ERROR_WINHTTP_CLIENT_AUTH_CERT_NEEDED,
                        to its caller.  The appropriate Cert chain was generated,
                        and the User needs to select it using UI.

        Failure -
                  ERROR_NOT_ENOUGH_MEMORY -
                        Out of Memory

                  ERROR_WINHTTP_SECURE_FAILURE -
                        Call Down to SSPI or WinTrust failed.

--*/

{

     SCHANNEL_CRED CredData = {SCHANNEL_CRED_VERSION,
                                     0,
                                     NULL,
                                     0,
                                     0,
                                     NULL,
                                     0,
                                     NULL,
                                     DEFAULT_SECURE_PROTOCOLS,
                                     0,
                                     0,
                                     0,
                                     SCH_CRED_MANUAL_CRED_VALIDATION |
                                     SCH_CRED_NO_DEFAULT_CREDS
                                     };
    SECURITY_STATUS scRet;


    DWORD           error = ERROR_SUCCESS;
    PCCERT_CONTEXT  pCert;

    UNREFERENCED_PARAMETER(phContext);

    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "CliAuthSelectCredential",
                 "%#x, %s, %x, %x",
                 phContext,
                 pszPackageName,
                 pCertContextArray,
                 phCredential
                 ));


    INET_ASSERT(phContext);
    INET_ASSERT(pCertContextArray);
    INET_ASSERT(pszPackageName);


    if (!pCertContextArray->LockCredHandle( ))
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    if ( pCertContextArray->GetArraySize() == 0 )
    {
        goto cleanup;
    }
    else
    {
        // First check and see if the Cert context already has a CredHandle associated with it.
        CredHandle hCreds = pCertContextArray->GetCredHandle( );

        if (!IsCredClear(hCreds))
        {
            *phCredential = hCreds;
            error = ERROR_SUCCESS;
            goto cleanup;
        }
    }

    pCert =         pCertContextArray->GetSelectedCertContext();


    //
    // Setup strucutres for AcquireCredentialsHandle call.
    //

    if ( pCert )
    {

        CredData.cCreds = 1;
        CredData.paCred = &pCert;
    }
    
    CredData.grbitEnabledProtocols = dwSecureProtocols;

    WRAP_REVERT_USER(g_AcquireCredentialsHandle,
                     fNoRevert,
                     (NULL,
                      pszPackageName,
                      SECPKG_CRED_OUTBOUND,
                      NULL,
                      &CredData,
                      NULL,
                      NULL,
                      phCredential,
                      NULL),
                     scRet);

    error = MapInternetError((DWORD)scRet, pdwStatus);
    if (error == ERROR_SUCCESS)
    {
        pCertContextArray->SetCredHandle(*phCredential);
    }

cleanup:
    pCertContextArray->UnlockCredHandle();
    
quit:
    DEBUG_LEAVE(error);

    return error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5.1\api\inetapiu.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    inetapiu.cxx

Abstract:

    Contains WinInet API utility & sub-API functions

    Contents:
        wInternetQueryDataAvailable

Author:

    Richard L Firth (rfirth) 16-Feb-1996

Environment:

    Win32 user-level

Revision History:

    16-Feb-1996 rfirth
        Created

--*/

#include <wininetp.h>

//
// functions
//


BOOL
wInternetQueryDataAvailable(
    IN LPVOID hFileMapped,
    OUT LPDWORD lpdwNumberOfBytesAvailable,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    Part 2 of InternetQueryDataAvailabe. This function is called by the async
    worker thread in order to resume InternetQueryDataAvailable(), and by the
    app as the worker part of the API, post validation

    We can query available data for handle types that return data, either from
    a socket, or from a cache file:

        - HTTP request
        - FTP file
        - FTP find
        - FTP find HTML
        - gopher file
        - gopher find
        - gopher find HTML

Arguments:

    hFileMapped                 - the mapped HINTERNET

    lpdwNumberOfBytesAvailable  - where the number of bytes is returned

    dwFlags                     - flags controlling operation

    dwContext                   - context value for callbacks

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    UNREFERENCED_PARAMETER(dwFlags);
    UNREFERENCED_PARAMETER(dwContext);
    DEBUG_ENTER((DBG_INET,
                Bool,
                "wInternetQueryDataAvailable",
                "%#x, %#x, %#x, %#x",
                hFileMapped,
                lpdwNumberOfBytesAvailable,
                dwFlags,
                dwContext
                ));

    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
    DWORD error;
    DWORD bytesAvailable = 0;


    INET_ASSERT(hFileMapped);

    //
    // as usual, grab the per-thread info block
    //

    if (lpThreadInfo == NULL) {

        //informational INET_ASSERT(FALSE);

        error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto quit;
    }

    //
    // if this is the async worker thread then set the handle, and
    // last-error info in the per-thread data block before we go any further
    // (we already did this on the sync path)
    //

    if (lpThreadInfo->IsAsyncWorkerThread) {
        _InternetSetObjectHandle(lpThreadInfo,
                                 ((HANDLE_OBJECT *)hFileMapped)->GetPseudoHandle(),
                                 hFileMapped
                                 );
        _InternetClearLastError(lpThreadInfo);

        //
        // we should only be here in async mode if there was no data immediately
        // available
        //

        INET_ASSERT(!((INTERNET_HANDLE_OBJECT *)hFileMapped)->IsDataAvailable());

    }

    //
    // we copy the number of bytes available to a local variable first, and
    // only update the caller's variable if we succeed
    //
    //
    // get the current data available
    //

    error = ((HTTP_REQUEST_HANDLE_OBJECT *)hFileMapped)
                ->QueryDataAvailable(&bytesAvailable);

quit:

    BOOL success;

    if (error == ERROR_SUCCESS) {
        ((INTERNET_HANDLE_OBJECT *)hFileMapped)->SetAvailableDataLength(bytesAvailable);
        *lpdwNumberOfBytesAvailable = bytesAvailable;
        success = TRUE;

        DEBUG_PRINT(INET,
                    INFO,
                    ("%d bytes available\n",
                    bytesAvailable
                    ));

        DEBUG_PRINT_API(API,
                        INFO,
                        ("*lpdwNumberOfBytesAvailable (%#x) = %d\n",
                        lpdwNumberOfBytesAvailable,
                        bytesAvailable
                        ));

    } else {
        success = FALSE;

        DEBUG_ERROR(INET, error);

    }

    SetLastError(error);

    DEBUG_LEAVE(success);

    return success;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5.1\api\certcach.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    certcach.cxx

Abstract:

    Contains class implementation for certificate cache object.
    This object will hold various Certificate entries.

    Contents:
        SECURITY_CACHE_LIST_ENTRY::SECURITY_CACHE_LIST_ENTRY
        SECURITY_CACHE_LIST_ENTRY::~SECURITY_CACHE_LIST_ENTRY
        SECURITY_CACHE_LIST_ENTRY::AddRef
        SECURITY_CACHE_LIST_ENTRY::Release
        SECURITY_CACHE_LIST_ENTRY::Clear
        SECURITY_CACHE_LIST::Find
        SECURITY_CACHE_LIST::Add
        SECURITY_CACHE_LIST::ClearList
        SECURITY_CACHE_LIST::Initialize
        SECURITY_CACHE_LIST::Terminate

    TODO:  Add Cert validation.  What if Cert is given but different?

Author:

    Arthur L Bierer (arthurbi) 20-Apr-1996

Revision History:

    20-Apr-1996 arthurbi
        Created

--*/
#include <wininetp.h>

//
//
//  List of encryption packages:  PCT, SSL, etc
//

//
// BUGBUG [arthurbi] The SSL and PCT package names
//  are hard coded into the stucture below.  We need
//  to be more flexible in case someone write a FOO security
//  package.
//

// BUGBUG:  Don't change the order of the packages below.  some old SSL2 sites deny the UNISP
// provider, and if we walk down the list to PCT1 or SSL3, things hang.
const SEC_PROVIDER g_cSecProviders[MAX_SEC_PROVIDERS] =
{
    UNISP_NAME, INVALID_CRED_VALUE , ENC_CAPS_SSL | ENC_CAPS_SCHANNEL_CREDS, FALSE, SP_PROT_CLIENTS, NULL,
    UNISP_NAME, INVALID_CRED_VALUE , ENC_CAPS_SSL | ENC_CAPS_SCHANNEL_CREDS, FALSE, SP_PROT_SSL2_CLIENT, NULL,
//    PCT1SP_NAME, INVALID_CRED_VALUE , ENC_CAPS_PCT| ENC_CAPS_SCHANNEL_CREDS, FALSE, SP_PROT_PCT1_CLIENT, NULL,
//    SSL3SP_NAME, INVALID_CRED_VALUE , ENC_CAPS_SSL| ENC_CAPS_SCHANNEL_CREDS, FALSE, SP_PROT_SSL3_CLIENT, NULL,
    NULL,        INVALID_CRED_VALUE , FALSE,        FALSE, 0
};


//
// private manifests
//

#define MAX_CERT_CACHE_CERTS    16

//
// private types
//

//
// SECURITY_CACHE_LIST_ENTRY member functions
//


SECURITY_CACHE_LIST_ENTRY::SECURITY_CACHE_LIST_ENTRY(
    IN BOOL fNoRevert,
    IN LPSTR lpszHostName
    )

/*++

Routine Description:

    SECURITY_CACHE_LIST_ENTRY constructor. Create object; don't add it to list

Arguments:

    fNoRevert       - Revert any impersonation on SSL handling?

    lpszHostName    - name of host for which this cache entry created

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "SECURITY_CACHE_LIST_ENTRY::SECURITY_CACHE_LIST_ENTRY",
                 "%q",
                 lpszHostName
                 ));

#if INET_DEBUG
    _List.Flink = _List.Blink = NULL;
#endif
    _cRef = 1;
    _fInCache = FALSE;
    _ServerName = lpszHostName;
    ZeroMemory(&_CertInfo, sizeof(_CertInfo));
    _dwSecurityFlags = 0;
    _dwStatusFlags = 0;
    _pCertContextArray = NULL;
    _fNoRevert = fNoRevert;

#if INET_DEBUG
    m_Signature = 0x454c4353;   // 'SCLE'
#endif

    DEBUG_LEAVE(0);
}


SECURITY_CACHE_LIST_ENTRY::~SECURITY_CACHE_LIST_ENTRY()

/*++

Routine Description:

    SECURITY_CACHE_LIST_ENTRY destructor.

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "~SECURITY_CACHE_LIST_ENTRY",
                 "{%#x [%q]}",
                 this,
                 _ServerName.StringAddress()
                 ));

    INET_ASSERT((_List.Flink == NULL) && (_List.Blink == NULL));

    Clear();

    DEBUG_LEAVE(0);
}


LONG
SECURITY_CACHE_LIST_ENTRY::AddRef(
    VOID
    )

/*++

Routine Description:

    Increment reference count of SECURITY_CACHE_LIST_ENTRY

Arguments:

    None.

Return Value:

    LONG    - reference count after increment

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 Int,
                 "SECURITY_CACHE_LIST_ENTRY::AddRef",
                 "{%#x [%q, %d]}",
                 this,
                 _ServerName.StringAddress(),
                 _cRef
                 ));

    InterlockedIncrement(&_cRef);

    DEBUG_LEAVE(_cRef);

    return _cRef;
}


LONG
SECURITY_CACHE_LIST_ENTRY::Release(
    VOID
    )

/*++

Routine Description:

    Decrement reference count and destroy object if (<=) zero

Arguments:

    None.

Return Value:

    LONG    - reference count after decrement

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 Int,
                 "SECURITY_CACHE_LIST_ENTRY::Release",
                 "{%q [%d]}",
                 _ServerName.StringAddress(),
                 _cRef
                 ));

    LONG cRet;

    if (0 >= (cRet = InterlockedDecrement(&_cRef))) {
        delete this;
    }

    DEBUG_LEAVE(cRet);

    return cRet;
}


VOID
SECURITY_CACHE_LIST_ENTRY::Clear()

/*++

Routine Description:

    Clear out SECURITY_CACHE_LIST_ENTRY

Arguments:

    Clear   -

Return Value:

    None.

--*/

{
    if (_CertInfo.pCertificate != NULL)
    {
        SAFE_WRAP_REVERT_USER_VOID((*g_pfnCertFreeCertificateContext), _fNoRevert, (_CertInfo.pCertificate));
        _CertInfo.pCertificate = NULL;
    }

    ZeroMemory(&_CertInfo, sizeof(_CertInfo));
    _CertInfo.dwSize = sizeof(_CertInfo);

    _dwSecurityFlags = 0;
    _dwStatusFlags = 0;
    _ServerName = NULL;
    if( _pCertContextArray )
    {
        delete _pCertContextArray;
        _pCertContextArray = NULL;
    }
}

//
// SECURITY_CACHE_LIST member functions
//


VOID
SECURITY_CACHE_LIST::ClearList(
    VOID
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "SECURITY_CACHE_LIST::ClearList",
                 NULL
                 ));

    if (!LockSerializedList(&_List))
    {
        DEBUG_PRINT(OBJECTS,
                    ERROR,
                    ("Failed to obtain lock -- SECURITY_CACHE_LIST potentially leaked\n"
                    ));
        goto quit;
    }

    while (!IsSerializedListEmpty(&_List)) {

        SECURITY_CACHE_LIST_ENTRY * CacheEntry;

        //
        // remove the PROXY_SERVER_LIST_ENTRY at the head of the serialized
        // list
        //

        LPVOID entry = SlDequeueHead(&_List);

        //
        // entry should not be NULL - IsSerializedListEmpty() told us we
        // could expect something
        //

        INET_ASSERT(entry != NULL);

        //
        // get the address of the object (should be the same as entry) and
        // delete it
        //

        CacheEntry = CONTAINING_RECORD(entry, SECURITY_CACHE_LIST_ENTRY, _List);

        DEBUG_PRINT(OBJECTS,
                    INFO,
                    ("releasing %q (%d)\n",
                    CacheEntry->_ServerName.StringAddress(),
                    CacheEntry->_cRef
                    ));

        CacheEntry->Release();
    }

    UnlockSerializedList(&_List);

quit:
    DEBUG_LEAVE(0);
}


DWORD
SECURITY_CACHE_LIST::Add(
    IN SECURITY_CACHE_LIST_ENTRY * entry
    )

/*++

Routine Description:

    Adds a CertInfo Structure to the list front of the list.

Arguments:

    lpszHost    - Hostname to add.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "SECURITY_CACHE_LIST::Add",
                 "%#x [%q, %d]",
                 entry,
                 entry ? entry->_ServerName.StringAddress() : "",
                 entry ? entry->_cRef : 0
                 ));

    DWORD error = ERROR_SUCCESS;

    INET_ASSERT(entry != NULL);

    if (entry != NULL) {
        if (LockSerializedList(&_List))
        {

            //
            // If we've grown too much, nuke the oldest one.
            //

            if (ElementsOnSerializedList(&_List) >= MAX_CERT_CACHE_CERTS) {

                SECURITY_CACHE_LIST_ENTRY *pOld;
                LPVOID old_entry = SlDequeueTail(&_List);

                INET_ASSERT(old_entry != NULL);

                pOld = CONTAINING_RECORD(old_entry, SECURITY_CACHE_LIST_ENTRY, _List);

                //
                // entry should not be NULL - IsSerializedListEmpty() told us we
                // could expect something
                //

                pOld->_fInCache = FALSE;

                //
                // Clean Our old object, and reinstatiate with a new name.
                //

                pOld->Release();
            }
            if (InsertAtHeadOfSerializedList(&_List, &entry->_List)) {
                entry->AddRef();
                entry->_fInCache = TRUE;
            }
            UnlockSerializedList(&_List);
        }
        else
            error = ERROR_NOT_ENOUGH_MEMORY;
    }

    DEBUG_LEAVE(error);

    return error;
}


SECURITY_CACHE_LIST_ENTRY *
SECURITY_CACHE_LIST::Find(
    IN LPSTR lpszHost
    )

/*++

Routine Description:

    Searches the linked list for the Cert, and returns
    the found entry, or NULL if not found.

Arguments:

    lpszHost    - Hostname to search on.

Return Value:

    CERT_CACHE_LIST_ENTRY *
        Success - Pointer to found entry.

        Failure - NULL, not found.

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Pointer,
                 "SECURITY_CACHE_LIST::Find",
                 "%q",
                 lpszHost
                 ));

    SECURITY_CACHE_LIST_ENTRY * info = NULL;

    //
    // BUGBUG need to validate against Server Certifcate on every
    //  connection, this Find only validates by Hostname.
    //  What about DNS spoofing?  Won't we be hosed?
    //

    //
    // TODO if found, need to push to front of list.
    //

    if (LockSerializedList(&_List))
    {
        for (PLIST_ENTRY entry = HeadOfSerializedList(&_List);
            entry != (PLIST_ENTRY)SlSelf(&_List);
            entry = entry->Flink)
        {
            info = CONTAINING_RECORD(entry, SECURITY_CACHE_LIST_ENTRY, _List);

            //
            // check to see if they match.
            //

            if (info->_ServerName.Stricmp(lpszHost) == 0) {
                info->AddRef();
                break; // match.
            }
            info = NULL;
        }
        UnlockSerializedList(&_List);
    }

    DEBUG_LEAVE(info);

    return info;
}


BOOL SECURITY_CACHE_LIST::Initialize(
    VOID
    )
{
    if (!InitializeSerializedList(&_List))
        return FALSE;

#if INET_DEBUG
    m_Signature = 0x4c436553;   // "SeCL"
#endif

    // Fill in default starting values, will enumerate and acquire handles
    // during the first SSL handshake for the session.
    CopyMemory((LPVOID)_SecProviders,
           (CONST VOID *)g_cSecProviders,
           sizeof(SEC_PROVIDER) * MAX_SEC_PROVIDERS);

    _dwEncFlags = 0;
    _dwSecureProtocols = DEFAULT_SECURE_PROTOCOLS;

    return TRUE;
}


VOID SECURITY_CACHE_LIST::Terminate(
    VOID
    )
{

    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "SECURITY_CACHE_LIST::Terminate",
                 "{%#x}",
                 this
                 ));

    ClearList();

    //
    //  free all security pkg credential handles
    //
    for (DWORD i = 0; _SecProviders[i].pszName != NULL ; i++)
    {
        if (_SecProviders[i].fEnabled)
        {
            if (_SecProviders[i].pCertCtxt == NULL && !IsCredClear(_SecProviders[i].hCreds))
            {
                // Beta1 Hack. Because of some circular dependency between dlls
                // both crypt32 and schannel's PROCESS_DETACH gets called before wininet.
                // This is catastrophic if we have a cert context attached to the credentials
                // handle. In this case we will just leak the handle since the process is dying
                // anyway. We really need to fix this.
                WRAP_REVERT_USER_VOID(g_FreeCredentialsHandle,
                                      IsImpersonationEnabled(),
                                      (&_SecProviders[i].hCreds));
            }
        }
#if 0 // See comments above.
        if (_SecProviders[i].pCertCtxt != NULL)
        {
            (*g_pfnCertFreeCertificateContext)(_SecProviders[i].pCertCtxt);
            _SecProviders[i].pCertCtxt = NULL;
        }
#endif
    }

    TerminateSerializedList(&_List);

    DEBUG_LEAVE(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5.1\api\globals.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    globals.cxx

Abstract:

    Contains global data items for WININET.DLL and initialization function

    Contents:
        GlobalDllInitialize
        GlobalDllTerminate
        GlobalDataInitialize
        GlobalDataTerminate
        IsHttp1_1
        SetOfflineUserState
        GetWininetUserName
        ChangeGlobalSettings

Author:

    Richard L Firth (rfirth) 15-Jul-1995

Revision History:

    15-Jul-1995 rfirth
        Created

    07-Oct-1998 joshco
        updated minor version number 1->2

--*/

#include <wininetp.h>
#include <ntverp.h>
#include <schnlsp.h>
#include <persist.h>
#include "autodial.h"

#ifdef INCLUDE_CACHE
#include "..\urlcache\cache.hxx"
#endif

//
// WinHttpX major & minor versions - allow to be defined externally
//

#if !defined(WINHTTPX_MAJOR_VERSION)
#define WINHTTPX_MAJOR_VERSION   5
#endif
#if !defined(WINHTTPX_MINOR_VERSION)
#define WINHTTPX_MINOR_VERSION   1
#endif

//
// external functions
//

#if INET_DEBUG

VOID
InitDebugSock(
    VOID
    );

#endif


//
// global DLL state data
//

GLOBAL HINSTANCE GlobalDllHandle = NULL;
GLOBAL DWORD GlobalPlatformType;
GLOBAL DWORD GlobalPlatformVersion5;
GLOBAL DWORD GlobalPlatformMillennium = FALSE;
GLOBAL DWORD GlobalPlatformWhistler = FALSE;
GLOBAL BOOL GlobalDataInitialized = FALSE;

GLOBAL BOOL GlobalIsProcessNtService = FALSE;

GLOBAL HANDLE g_hCompletionPort = NULL;
GLOBAL LPOVERLAPPED g_lpCustomOverlapped = NULL;
GLOBAL DWORD g_cNumIOCPThreads = 0;

#if INET_DEBUG
LONG g_cWSACompletions = 0;
LONG g_cCustomCompletions = 0;
#endif

#if defined (INCLUDE_CACHE)
GLOBAL LPOVERLAPPED g_lpCustomUserOverlapped = NULL;
#if INET_DEBUG
LONG g_cCustomUserCompletions = 0;
LONG g_cCacheFileCompletions = 0;
#endif
#endif

//
// WinInet DLL version information (mainly for diagnostics)
//

#if !defined(VER_PRODUCTBUILD)
#define VER_PRODUCTBUILD    0
#endif

GLOBAL DWORD InternetBuildNumber = VER_PRODUCTBUILD;

//
// transport-based time-outs, etc.
//

#ifndef unix
GLOBAL const DWORD GlobalConnectTimeout = DEFAULT_CONNECT_TIMEOUT;
#else
GLOBAL const DWORD GlobalConnectTimeout = 1 * 60 * 1000;
#endif /* unix */
GLOBAL const DWORD GlobalResolveTimeout = DEFAULT_RESOLVE_TIMEOUT;
GLOBAL const DWORD GlobalConnectRetries = DEFAULT_CONNECT_RETRIES;
GLOBAL const DWORD GlobalSendTimeout = DEFAULT_SEND_TIMEOUT;
GLOBAL const DWORD GlobalReceiveTimeout = DEFAULT_RECEIVE_TIMEOUT;
GLOBAL const DWORD GlobalTransportPacketLength = DEFAULT_TRANSPORT_PACKET_LENGTH;
GLOBAL const DWORD GlobalKeepAliveSocketTimeout = DEFAULT_KEEP_ALIVE_TIMEOUT;
GLOBAL const DWORD GlobalSocketSendBufferLength = DEFAULT_SOCKET_SEND_BUFFER_LENGTH;
GLOBAL const DWORD GlobalSocketReceiveBufferLength = DEFAULT_SOCKET_RECEIVE_BUFFER_LENGTH;
GLOBAL const DWORD GlobalMaxHttpRedirects = DEFAULT_MAX_HTTP_REDIRECTS;
GLOBAL const DWORD GlobalConnectionInactiveTimeout = DEFAULT_CONNECTION_INACTIVE_TIMEOUT;
GLOBAL const DWORD GlobalServerInfoTimeout = DEFAULT_SERVER_INFO_TIMEOUT;
GLOBAL const DWORD GlobalMaxSizeStatusLineResultText = 1024;

//
// switches
//

GLOBAL BOOL InDllCleanup = FALSE;
GLOBAL BOOL GlobalDynaUnload = FALSE;

//
// AutoDetect Proxy Globals
//

GLOBAL LONG GlobalInternetOpenHandleCount = -1;
GLOBAL DWORD GlobalProxyVersionCount = 0;
GLOBAL BOOL GlobalAutoProxyInInit = FALSE;
GLOBAL BOOL GlobalAutoProxyCacheEnable = TRUE;
GLOBAL BOOL GlobalDisplayScriptDownloadFailureUI = FALSE;

//
//  Workaround for Novell's Client32
//

GLOBAL const BOOL fDontUseDNSLoadBalancing = FALSE;

//
// lists
//

GLOBAL SERIALIZED_LIST GlobalObjectList;

GLOBAL BOOL GlobalDisableNTLMPreAuth = FALSE;

//
// critical sections
//

GLOBAL CCritSec MlangCritSec;
GLOBAL CCritSec GlobalDataInitCritSec;
GLOBAL CCritSec GlobalSSPIInitCritSec;


// Mlang related data and functions.
PRIVATE HINSTANCE hInstMlang;
PRIVATE PFNINETMULTIBYTETOUNICODE pfnInetMultiByteToUnicode;
PRIVATE BOOL bFailedMlangLoad;  // So we don't try repeatedly if we fail once.
BOOL LoadMlang( );
BOOL UnloadMlang( );
#define MLANGDLLNAME    "mlang.dll"


//
// novell client32 (hack) "support"
//

GLOBAL BOOL GlobalRunningNovellClient32 = FALSE;
GLOBAL const BOOL GlobalNonBlockingClient32 = FALSE;

//
// proxy info
//

GLOBAL PROXY_INFO_GLOBAL * g_pGlobalProxyInfo;

//
// DLL version info
//

GLOBAL INTERNET_VERSION_INFO InternetVersionInfo = {
    WINHTTPX_MAJOR_VERSION,
    WINHTTPX_MINOR_VERSION
};

//
// HTTP version info - default 1.1
//

GLOBAL HTTP_VERSION_INFO HttpVersionInfo = {1, 1};


GLOBAL BOOL fCdromDialogActive = FALSE; // this needs to go

//
// The following globals are literal strings passed to winsock.
// Do NOT make them const, otherwise they end up in .text section,
// and web release of winsock2 has a bug where it locks and dirties
// send buffers, confusing the win95 vmm and resulting in code
// getting corrupted when it is paged back in.  -RajeevD
//

GLOBAL char gszAt[]   = "@";
GLOBAL char gszBang[] = "!";
GLOBAL char gszCRLF[] = "\r\n";

GLOBAL LONG g_cSessionCount=0;
GLOBAL CAsyncCount* g_pAsyncCount = NULL;

// implemented in ihttprequest\httprequest.cxx:
extern void CleanupWinHttpRequestGlobals();


//
// functions
//

#if 0 
/*
BOOL AddEventSource(void)
{
    HKEY hKey; 
    DWORD dwData; 
    CHAR szBuf[80];
    DWORD dwDispo;
    // Add your source name as a subkey under the Application 
    // key in the EventLog registry key. 
 
    if (RegCreateKeyExA(HKEY_LOCAL_MACHINE, 
                        "SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\WinHttp",
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_READ | KEY_WRITE,
                        NULL,
                        &hKey,
                        &dwDispo) != ERROR_SUCCESS)
    {
        return FALSE;
    }

    if (dwDispo == REG_OPENED_EXISTING_KEY)
    {
        RegCloseKey(hKey); 
        return TRUE;
    }
 
    // Set the name of the message file. 
 
    strcpy(szBuf, "%SystemRoot%\\System32\\WinHttp.dll"); 
 
    // Add the name to the EventMessageFile subkey. 
 
    if (RegSetValueEx(hKey,             // subkey handle 
            "EventMessageFile",       // value name 
            0,                        // must be zero 
            REG_EXPAND_SZ,            // value type 
            (LPBYTE) szBuf,           // pointer to value data 
            strlen(szBuf) + 1) != ERROR_SUCCESS)       // length of value data
    {
        RegCloseKey(hKey); 
        return FALSE;
    }
 
    // Set the supported event types in the TypesSupported subkey. 
 
    dwData = EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE | 
        EVENTLOG_INFORMATION_TYPE; 
 
    if (RegSetValueEx(hKey,      // subkey handle 
            "TypesSupported",  // value name 
            0,                 // must be zero 
            REG_DWORD,         // value type 
            (LPBYTE) &dwData,  // pointer to value data 
            sizeof(DWORD)) != ERROR_SUCCESS)    // length of value data 
    {
        RegCloseKey(hKey); 
        return FALSE;
    }

    RegCloseKey(hKey);
    return TRUE;
} 

HANDLE g_hEventLog = 0;

BOOL InitializeEventLog(void)
{
    if (AddEventSource() == FALSE)
    {
        return FALSE;
    }

    g_hEventLog = ::RegisterEventSourceA(NULL, "WinHttp");

    return g_hEventLog != NULL;
}

void TerminateEventLog(void)
{
    if (g_hEventLog)
    {
        ::DeregisterEventSource(g_hEventLog);
        g_hEventLog = NULL;
    }
}
*/
#endif


#ifdef UNIX
extern "C"
#endif /* UNIX */
BOOL
GlobalDllInitialize(
    VOID
    )

/*++

Routine Description:

    The set of initializations - critical sections, etc. - that must be done at
    DLL_PROCESS_ATTACH

Arguments:

    None.

Return Value:

    TRUE, only FALSE when not enough memory to initialize globals

--*/

{
    BOOL fResult = FALSE;
    
    DEBUG_ENTER((DBG_GLOBAL,
                 Bool,
                 "GlobalDllInitialize",
                 NULL
                 ));

    CLEAR_DEBUG_CRIT(szDebugBlankBuffer);

    if (MlangCritSec.Init() &&
        InitializeSerializedList(&GlobalObjectList) &&
        AuthOpen() &&
        IwinsockInitialize() &&
        SecurityInitialize() &&
        GlobalDataInitCritSec.Init() &&
        GlobalSSPIInitCritSec.Init()
#ifdef INCLUDE_CACHE
        &&
        DLLUrlCacheEntry(DLL_PROCESS_ATTACH)
#endif
        )
    {
        fResult = TRUE;
    }

    DEBUG_LEAVE(fResult);
    return fResult;
}


#ifdef UNIX
extern "C"
#endif /* UNIX */
VOID
GlobalDllTerminate(
    VOID
    )

/*++

Routine Description:

    Undoes the initializations of GlobalDllInitialize

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_GLOBAL,
                 None,
                 "GlobalDllTerminate",
                 NULL
                 ));

    //
    // only perform resource clean-up if this DLL is being unloaded due to a
    // FreeLibrary() call. Otherwise, we take the lazy way out and let the
    // system clean up after us
    //

    if (GlobalDynaUnload) {
        TerminateAsyncSupport(TRUE);
        IwinsockTerminate();
        HandleTerminate();
    }

    CHECK_SOCKETS();

    AuthClose();

    CTracer::s_CritSectionTraceInit.FreeLock();

    //
    //BUGBUG: we can't Terminate the list here because
    //        of a race condition from IE3
    //        (someone still holds the handle)
    //        but we don't want to leak the CritSec
    //        TerminateSerlizedList == DeleteCritSec + some Asserts
    //
    //TerminateSerializedList(&GlobalObjectList);
    GlobalObjectList.Lock.FreeLock();


    MlangCritSec.FreeLock();

    GlobalDataInitCritSec.FreeLock();
    GlobalSSPIInitCritSec.FreeLock();
    
    SecurityTerminate();

#ifdef INCLUDE_CACHE
    DLLUrlCacheEntry(DLL_PROCESS_DETACH);
#endif

    //Close this here because keepalive sync sockets may depend on it.
    if (g_hCompletionPort)
    {
        CloseHandle(g_hCompletionPort);
        g_hCompletionPort = NULL;
    }

    if (g_lpCustomOverlapped)
    {
        delete g_lpCustomOverlapped;
        g_lpCustomOverlapped = NULL;
    }

#if defined (INCLUDE_CACHE)
    if (g_lpCustomUserOverlapped)
    {
        delete g_lpCustomUserOverlapped;
        g_lpCustomUserOverlapped = NULL;
    }
#endif

    DEBUG_LEAVE(0);
}


DWORD
GlobalDataInitialize(
    VOID
    )

/*++

Routine Description:

    Loads any global data items from the registry

Arguments:

    None.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DEBUG_ENTER((DBG_GLOBAL,
                 Dword,
                 "GlobalDataInitialize",
                 NULL
                 ));

    static BOOL Initializing = FALSE;
    static BOOL Initialized = FALSE;
    static DWORD error = ERROR_SUCCESS;
    
    //
    // only one thread initializes
    //

    if (!GlobalDataInitCritSec.Lock())
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto done;
    }

    if (Initializing) 
    {
        //if re-entered on same thread, fail.
        error = ERROR_WINHTTP_NOT_INITIALIZED;
        goto leave;
    }
    else if (GlobalDataInitialized)
    {
        //else some other thread succeeded, and we can fall out.
        error = ERROR_SUCCESS;
        goto leave;
    }
    else if (Initialized)
    {
        //else if we've failed initialization for non-entrancy reasons, don't reattempt
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto leave;
    }

    Initializing = TRUE;

    //Ensure that the GlobalDataInitCritSec function is never abandoned.
    __try
    {
        //
        // create the global proxy lists
        //

        INET_ASSERT(g_pGlobalProxyInfo==NULL);
        g_pGlobalProxyInfo = New PROXY_INFO_GLOBAL();

        if (!g_pGlobalProxyInfo)
        {
            error = ERROR_NOT_ENOUGH_MEMORY;
            goto quit;
        }

        g_pGlobalProxyInfo->InitializeProxySettings();

        //
        // Load proxy config settings from registry...
        //
        error = LoadProxySettings();

        if (error != ERROR_SUCCESS)
            goto quit;

        //
        // perform module/package-specific initialization
        //

        error = HandleInitialize();
        if (error != ERROR_SUCCESS) {
            goto quit;
        }

        g_pGlobalServerInfoPool = New CGlobalServerInfoPool();

        if (!g_pGlobalServerInfoPool
            || !g_pGlobalServerInfoPool->Initialize())
        {
            error = ERROR_NOT_ENOUGH_MEMORY;
        }

        char buf[MAX_PATH + 1];

        if (GetModuleFileName(NULL, buf, sizeof(buf)))
        {
            LPSTR p = strrchr(buf, DIR_SEPARATOR_CHAR);
            p = p ? ++p : buf;

            DEBUG_PRINT(GLOBAL, INFO, ("process is %q\n", p));

            if (!lstrcmpi(p, "SVCHOST.EXE") || !lstrcmpi(p, "SERVICES.EXE"))
            {
                GlobalIsProcessNtService = TRUE;
            }
        }
        else
        {
            DEBUG_PRINT(GLOBAL,
                        INFO,
                        ("GetModuleFileName() returns %d\n",
                        GetLastError()
                        ));
        }

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto leave_change_state;
    }
    ENDEXCEPT
    
quit:

    if (error == ERROR_SUCCESS) {
        GlobalDataInitialized = TRUE;
    }
    
leave_change_state:


    //
    // irrespective of success or failure, we have attempted global data
    // initialization. If we failed then we assume its something fundamental
    // and fatal: we don't try again
    //

    Initialized = TRUE;
    Initializing = FALSE;

//jump here if you grabbed GlobalDataInitCritSec but don't want to affect Init*
leave:

    GlobalDataInitCritSec.Unlock();

//jump here IFF you didn't grab GlobalDataInitCritSec
done:

    DEBUG_LEAVE(error);

    return error;
}



VOID
GlobalDataTerminate(
    VOID
    )

/*++

Routine Description:

    Undoes work of GlobalDataInitialize()

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_GLOBAL,
                 None,
                 "GlobalDataTerminate",
                 NULL
                 ));

    RIP(g_cSessionCount == 0);
#ifndef WININET_SERVER_CORE
    //
    // Release background task manager
    //
    UnloadBackgroundTaskMgr();
#endif

    AuthUnload();

    //
    // terminate the global proxy lists
    //

    if (g_pGlobalProxyInfo)
    {
        g_pGlobalProxyInfo->TerminateProxySettings();
        delete g_pGlobalProxyInfo;
        g_pGlobalProxyInfo = NULL;
    }

    if (g_pGlobalServerInfoPool)
    {
        g_pGlobalServerInfoPool->Terminate();
        delete g_pGlobalServerInfoPool;
        g_pGlobalServerInfoPool = NULL;
    }

    UnloadMlang();
    UnloadSecurity();
    UnloadAutoProxy();

    ExitAutodialModule();

    CleanupWinHttpRequestGlobals();

    GlobalDataInitialized = FALSE;

    DEBUG_LEAVE(0);
}


BOOL
IsHttp1_1(
    VOID
    )

/*++

Routine Description:

    Determine if we are using HTTP 1.1 or greater

Arguments:

    None.

Return Value:

    BOOL

--*/

{
    return (HttpVersionInfo.dwMajorVersion > 1)
            ? TRUE
            : (((HttpVersionInfo.dwMajorVersion == 1)
                && (HttpVersionInfo.dwMajorVersion >= 1))
                ? TRUE
                : FALSE);
}



VOID
ChangeGlobalSettings(
    VOID
    )

/*++

Routine Description:

    Changes global settings

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_GLOBAL,
                 None,
                 "ChangeGlobalSettings",
                 NULL
                 ));

    DEBUG_LEAVE(0);
}



// Loads Mlang.dll and get the entry point we are interested in.

BOOL LoadMlang( )
{
    if (!MlangCritSec.Lock())
        goto quit;

    if (hInstMlang == NULL && !bFailedMlangLoad)
    {
        INET_ASSERT(pfnInetMultiByteToUnicode == NULL);
        hInstMlang = LoadLibrary(MLANGDLLNAME);

        if (hInstMlang != NULL)
        {
            pfnInetMultiByteToUnicode = (PFNINETMULTIBYTETOUNICODE)GetProcAddress
                                            (hInstMlang,"ConvertINetMultiByteToUnicode");
            if (pfnInetMultiByteToUnicode == NULL)
            {
                INET_ASSERT(FALSE);
                FreeLibrary(hInstMlang);
                hInstMlang = NULL;
            }
        }
        else
        {
            INET_ASSERT(FALSE); // bad news if we can't load mlang.dll
        }

        if (pfnInetMultiByteToUnicode == NULL)
            bFailedMlangLoad = TRUE;
    }

    MlangCritSec.Unlock();

quit:
    return (pfnInetMultiByteToUnicode != NULL);
}

BOOL UnloadMlang( )
{
    if (!MlangCritSec.Lock())
        return FALSE;

    if (hInstMlang)
        FreeLibrary(hInstMlang);

    hInstMlang = NULL;
    pfnInetMultiByteToUnicode = NULL;
    bFailedMlangLoad = FALSE;

    MlangCritSec.Unlock();

    return TRUE;
}

PFNINETMULTIBYTETOUNICODE GetInetMultiByteToUnicode( )
{
    // We are checking for pfnInetMultiByteToUnicode without getting a crit section.
    // This works only because UnloadMlang is called at the Dll unload time.

    if (pfnInetMultiByteToUnicode == NULL)
    {
        LoadMlang( );
    }

    return pfnInetMultiByteToUnicode;
}


#if 0
/*
int cdecl _sprintf(char* buffer, char* format, va_list args);

void LOG_EVENT(DWORD dwEventType, char* format, ...)
{
    if (g_hEventLog == NULL)
    {
        return;
    }

    va_list args;
    int n;
    char *pBuffer = (char *) ALLOCATE_FIXED_MEMORY(1024);

    if (pBuffer == NULL)
        return;

    va_start(args, format);
    n = _sprintf(pBuffer, format, args);
    va_end(args);
    
    LPCSTR pszMessages[1];
    pszMessages[0] = &pBuffer[0];

    ::ReportEvent(g_hEventLog, 
                  (WORD)dwEventType,
                  0,
                  dwEventType,
                  NULL,
                  1,
                  0,
                  &pszMessages[0],
                  NULL);

    FREE_MEMORY(pBuffer);
}
*/
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5.1\api\autoprox.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    autoprox.cxx


Author:

    Stephen A Sulzer (ssulzer) 26-August-2001

--*/

#include <wininetp.h>
#include "apdetect.h"
#include <cscpsite.h>
#include "..\http\httpp.h"

//
// definitions
//

#define MAX_RELOAD_DELAY 45000 // in mins
#define DEFAULT_SCRIPT_BUFFER_SIZE 4000 // bytes.
#define ONE_HOUR_DELTA  (60 * 60 * (LONGLONG)10000000)

GLOBAL LONGLONG dwdwHttpDefaultExpiryDelta = 12 * 60 * 60 * (LONGLONG)10000000;  // 12 hours in 100ns units



//
// private vars
//

// Return TRUE if the WinHttp Autoproxy Service is available on
// the current platform.
BOOL IsAutoProxyServiceAvailable()
{
    // Eventually on .NET Server and other platforms,
    // this will return TRUE.
    return FALSE;
}

//
// functions
//
INTERNETAPI
BOOL
WinHttpDetectAutoProxyConfigUrl(DWORD dwAutoDetectFlags, LPWSTR * ppwstrAutoConfigUrl)
{
    DWORD   error = ERROR_SUCCESS;
    char *  pszUrl;

    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "WinHttpDetectAutoProxyConfigUrl",
                     "%#x, %#x",
                     dwAutoDetectFlags,
                     ppwstrAutoConfigUrl
                     ));

    if (((dwAutoDetectFlags &
            ~(WINHTTP_AUTO_DETECT_TYPE_DHCP | WINHTTP_AUTO_DETECT_TYPE_DNS_A)) != 0)
        || (ppwstrAutoConfigUrl == NULL)
        || IsBadWritePtr(ppwstrAutoConfigUrl, sizeof(char *)))
    {
        error = ERROR_INVALID_PARAMETER;
        goto quit;
    }

    if (!(dwAutoDetectFlags & 
            (WINHTTP_AUTO_DETECT_TYPE_DHCP | WINHTTP_AUTO_DETECT_TYPE_DNS_A)))
    {
        error = ERROR_INVALID_PARAMETER;
        goto quit;
    }

    if (!GlobalDataInitialized) 
    {
        error = GlobalDataInitialize();
        if (error != ERROR_SUCCESS) 
        {
            goto quit;
        }
    }

    error = ::DetectAutoProxyUrl(dwAutoDetectFlags, &pszUrl);

    if (error == ERROR_SUCCESS)
    {
        error = AsciiToWideChar_UsingGlobalAlloc(pszUrl, ppwstrAutoConfigUrl);
        FREE_MEMORY(pszUrl);
    }

quit:
    if (error != ERROR_SUCCESS)
    {
        *ppwstrAutoConfigUrl = NULL;
        SetLastError(error);
    }

    DEBUG_LEAVE_API(error == ERROR_SUCCESS);
    return (error == ERROR_SUCCESS);    
}


INTERNETAPI
BOOL
WinHttpGetProxyForUrl(
    IN  HINTERNET                   hSession,
    IN  LPCWSTR                     lpcwszUrl,
    IN  WINHTTP_AUTOPROXY_OPTIONS * pAutoProxyOptions,
    OUT WINHTTP_PROXY_INFO *        pProxyInfo  
    )
{
    DWORD   error;

    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "WinHttpGetProxyForUrl",
                     "%#x, %wq, %#x, %#x",
                     hSession,
                     lpcwszUrl,
                     pAutoProxyOptions,
                     pProxyInfo
                     ));

    //
    // Validate the WinHttp session handle
    //
    if ((hSession == NULL) || IsBadReadPtr((void *)hSession, sizeof(void *)))
    {
        error = ERROR_INVALID_HANDLE;
        goto quit;
    }

    //
    // Validate the target URL, and AUTOPROXY_OPTIONS and PROXY_INFO structs.
    //
    if ((lpcwszUrl == NULL)  || IsBadStringPtrW(lpcwszUrl, (UINT_PTR)-1)
        || (pAutoProxyOptions == NULL)
        || IsBadReadPtr(pAutoProxyOptions, sizeof(WINHTTP_AUTOPROXY_OPTIONS))
	|| (pProxyInfo == NULL)
        || IsBadWritePtr(pProxyInfo, sizeof(WINHTTP_PROXY_INFO)))
    {
        goto ErrorInvalidParameter;
    }

    //
    // Validate that the caller specified one of the
    // AUTO_DETECT, CONFIG_URL or RUN_INPROCESS flags.
    //
    if (!(pAutoProxyOptions->dwFlags &
             (WINHTTP_AUTOPROXY_AUTO_DETECT |
              WINHTTP_AUTOPROXY_CONFIG_URL  |
              WINHTTP_AUTOPROXY_RUN_INPROCESS)))
    {
        goto ErrorInvalidParameter;
    }

    //
    // Validate that the caller did not set any flags other than
    // AUTO_DETECT, CONFIG_URL or RUN_INPROCESS.
    //
    if (pAutoProxyOptions->dwFlags &
             ~(WINHTTP_AUTOPROXY_AUTO_DETECT |
               WINHTTP_AUTOPROXY_CONFIG_URL  |
               WINHTTP_AUTOPROXY_RUN_INPROCESS))
    {
        goto ErrorInvalidParameter;
    }

    //
    // Validate the detection flags if the application
    // requests autodetection.
    //
    if (pAutoProxyOptions->dwFlags & WINHTTP_AUTOPROXY_AUTO_DETECT)
    {
        if ((pAutoProxyOptions->dwAutoDetectFlags &
                    ~(WINHTTP_AUTO_DETECT_TYPE_DHCP | WINHTTP_AUTO_DETECT_TYPE_DNS_A)) != 0)
        {
            goto ErrorInvalidParameter;
        }
        if (!(pAutoProxyOptions->dwAutoDetectFlags & 
                (WINHTTP_AUTO_DETECT_TYPE_DHCP | WINHTTP_AUTO_DETECT_TYPE_DNS_A)))
        {
            goto ErrorInvalidParameter;
        }
    }

    //
    // Validate if lpszAutoConfigUrl string if the application 
    // specifies the CONFIG_URL option.
    //
    if ((pAutoProxyOptions->dwFlags & WINHTTP_AUTOPROXY_CONFIG_URL) &&
            (!pAutoProxyOptions->lpszAutoConfigUrl  ||
            IsBadStringPtrW(pAutoProxyOptions->lpszAutoConfigUrl, (UINT_PTR)-1L) ||
            (*(pAutoProxyOptions->lpszAutoConfigUrl) == '\0')))
    {
        goto ErrorInvalidParameter;
    }

    if (!GlobalDataInitialized) 
    {
        error = ERROR_WINHTTP_NOT_INITIALIZED;
        goto quit;
    }

    error = ERROR_SUCCESS;

    if ((pAutoProxyOptions->dwFlags & WINHTTP_AUTOPROXY_RUN_INPROCESS) ||
        !IsAutoProxyServiceAvailable())
    {
        CAutoProxy *                pAutoProxy;
        INTERNET_HANDLE_OBJECT *    hSessionMapped = NULL;
        HINTERNET_HANDLE_TYPE       handleType = (HINTERNET_HANDLE_TYPE)0;

        error = MapHandleToAddress(hSession, (LPVOID *)&hSessionMapped, FALSE);

        if ((error != ERROR_SUCCESS) && (hSessionMapped == NULL))
        {
            goto quit;
        }

        error = RGetHandleType(hSessionMapped, &handleType);

        if (error == ERROR_SUCCESS && handleType == TypeInternetHandle)
        {
            pAutoProxy = hSessionMapped->GetAutoProxy();

            if (pAutoProxy)
            {
                error = pAutoProxy->GetProxyForURL(lpcwszUrl, pAutoProxyOptions, pProxyInfo);
            }
            else
            {
                error = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
        else
        {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }

        DereferenceObject(hSessionMapped);

        if (error != ERROR_SUCCESS)
            goto quit;
    }

quit:


    if (error != ERROR_SUCCESS)
    {
        SetLastError(error);
    }

    DEBUG_LEAVE_API(error == ERROR_SUCCESS);

    return (error == ERROR_SUCCESS);

ErrorInvalidParameter:
    error = ERROR_INVALID_PARAMETER;
    goto quit;
}


BOOL
CAutoProxy::Initialize()
{
    _pszAutoConfigUrl          = NULL;
    _pdwDetectedInterfaceIp    = NULL;
    _cDetectedInterfaceIpCount = 0;
    memset(&_ftLastDetectionTime, 0, sizeof(_ftLastDetectionTime));

    _pszConfigScript = NULL;

    memset(&_ftExpiryTime, 0, sizeof(_ftExpiryTime));
    memset(&_ftLastModifiedTime, 0, sizeof(_ftLastModifiedTime));
    memset(&_ftLastSyncTime, 0, sizeof(_ftLastSyncTime));

    _fHasExpiry      = FALSE;
    _fHasLastModifiedTime = FALSE;
    _fMustRevalidate = FALSE;

    _ScriptResLock.Initialize();

    return (_ScriptResLock.IsInitialized() && _CritSec.Init());
}


CAutoProxy::~CAutoProxy()
{
    if (_pszAutoConfigUrl)
        FREE_MEMORY(_pszAutoConfigUrl);

    if (_pdwDetectedInterfaceIp)
        FREE_MEMORY(_pdwDetectedInterfaceIp);

    if (_pszConfigScript)
        FREE_MEMORY(_pszConfigScript);
}


DWORD
CAutoProxy::GetProxyForURL(
    LPCWSTR                     lpcwszUrl,
    WINHTTP_AUTOPROXY_OPTIONS * pAutoProxyOptions,
    WINHTTP_PROXY_INFO *        pProxyInfo  
)
{
    DWORD       error = ERROR_SUCCESS;
    char *      pszAutoConfigUrl = NULL;
    char *      pszConfigScript = NULL;
    char *      pszUrl = NULL;
    char *      pszQueryResults = NULL;
    bool        bReleaseScriptLock = false;

    //
    // If the application requests auto-detect, then attempt to detect
    // the autonconfig URL and download the autoproxy script.
    //
    if (pAutoProxyOptions->dwFlags & WINHTTP_AUTOPROXY_AUTO_DETECT)
    {
        error = DetectAutoProxyUrl(pAutoProxyOptions->dwAutoDetectFlags,
                        &pszAutoConfigUrl);

        if (error == ERROR_SUCCESS)
        {
            INET_ASSERT(pszAutoConfigUrl);

            error = DownloadAutoConfigUrl(pszAutoConfigUrl, pAutoProxyOptions, &pszConfigScript);

            if (error != ERROR_SUCCESS)
            {
                FREE_MEMORY(pszAutoConfigUrl);
                pszAutoConfigUrl = NULL;
            }
            else
            {
                bReleaseScriptLock = true;
                INET_ASSERT(pszConfigScript != NULL);
            }
        }
        else
        {
            INET_ASSERT(pszAutoConfigUrl == NULL);
        }
    }

    //
    // If autodetection or downloading the autoproxy script fails,
    // or if autodetection is not requested, then fall back to an
    // (optional) autoconfig URL supplied by the application.
    //
    if ((error != ERROR_SUCCESS || pszAutoConfigUrl == NULL)
        && (pAutoProxyOptions->dwFlags & WINHTTP_AUTOPROXY_CONFIG_URL))
    {
        INET_ASSERT(pAutoProxyOptions->lpszAutoConfigUrl);

        error = WideCharToAscii(pAutoProxyOptions->lpszAutoConfigUrl,
                        &pszAutoConfigUrl);
       
        if (error != ERROR_SUCCESS)
            goto quit;

        error = DownloadAutoConfigUrl(pszAutoConfigUrl, pAutoProxyOptions, &pszConfigScript);

        if (error == ERROR_SUCCESS)
        {
            bReleaseScriptLock = true;
        }
    }


    //
    // Could not obtain the autoproxy script, bail out.
    //
    if (error != ERROR_SUCCESS)
        goto quit;

    // Need the app's target URL in ANSI
    error = WideCharToAscii(lpcwszUrl, &pszUrl);

    if (error != ERROR_SUCCESS)
        goto quit;

    //
    // Execute the proxy script.
    //
    error = RunProxyScript(pszUrl, pszConfigScript, &pszQueryResults);

    if (error != ERROR_SUCCESS)
        goto quit;

    //
    // Parse the output from the autoproxy script and
    // convert it into a WINHTTP_PROXY_INFO struct for
    // the application.
    //
    error = ParseProxyQueryResults(pszQueryResults, pProxyInfo);

quit:
    if (bReleaseScriptLock)
    {
        _ScriptResLock.Release();
    }

    if (pszUrl)
    {
        FREE_MEMORY(pszUrl);
    }

    if (pszAutoConfigUrl)
    {
        FREE_MEMORY(pszAutoConfigUrl);
    }

    if (pszQueryResults)
    {
        GlobalFree(pszQueryResults);
    }

    return error;
}


DWORD
CAutoProxy::DetectAutoProxyUrl(DWORD dwAutoDetectFlags, LPSTR * ppszAutoConfigUrl)
{
    char *  pszAutoConfigUrl = NULL;
    BOOL    fDetectionNeeded;
    DWORD   error            = ERROR_SUCCESS;

    fDetectionNeeded = IsDetectionNeeded();  // avoid holding a critsec across this

    if (_CritSec.Lock())
    {
        if (_pszAutoConfigUrl == NULL)
        {
            fDetectionNeeded = TRUE;
        }
        else if (!fDetectionNeeded)
        {
            pszAutoConfigUrl = NewString(_pszAutoConfigUrl);
        }

        _CritSec.Unlock();
    }

    // We should have either the AutoConfigUrl string or
    // fDetectionNeeded should be TRUE; otherwise raise
    // an out-of-memory error.
    if (!(pszAutoConfigUrl || fDetectionNeeded))
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }


    // check detection cache; also check for network changes or if
    // this machine's IP address have changed

    if (fDetectionNeeded)
    {
        int      cInterfaces      = 0;
        DWORD *  pdwInterfaceIp   = NULL;
        FILETIME ftDetectionTime;

        //
        // Save out the Host IP addresses, before we start the detection,
        //  after the detection is complete, we confirm that we're still
        //  on the same set of Host IPs, in case the user switched connections.
        //

        error = GetHostAddresses(&cInterfaces, &pdwInterfaceIp);

        if (error != ERROR_SUCCESS)
        {
            goto quit;
        }

        // Important: cannot hold the _CritSec lock across the autodetection
        // call, as it can take several seconds, which could cause
        // waiting EnterCriticalSection() calls to raise POSSIBLE_DEADLOCK
        // exceptions.
        error = ::DetectAutoProxyUrl(dwAutoDetectFlags, &pszAutoConfigUrl);

        if (error != ERROR_SUCCESS)
        {
            goto quit;
        }

        GetCurrentGmtTime(&ftDetectionTime); // mark when detection was run.

        if (_CritSec.Lock())
        {
            // 
            // Clear out any cached autoconfig script
            //
            if (_pszConfigScript)
            {
                FREE_MEMORY(_pszConfigScript);
                _pszConfigScript = NULL;
            }

            //
            // Cache new AutoConfigUrl string and detection time
            //
            if (_pszAutoConfigUrl)
            {
                FREE_MEMORY(_pszAutoConfigUrl);
            }

            _pszAutoConfigUrl = pszAutoConfigUrl;

            _ftLastDetectionTime = ftDetectionTime;

            //
            // Cache IP address of host machine at time of detection
            //
            if (_pdwDetectedInterfaceIp)
            {
                FREE_MEMORY(_pdwDetectedInterfaceIp);
            }

            _pdwDetectedInterfaceIp = pdwInterfaceIp;
            _cDetectedInterfaceIpCount = cInterfaces;

            //
            // Prepare return string for caller
            //
            *ppszAutoConfigUrl = NewString(pszAutoConfigUrl);

            if (*ppszAutoConfigUrl == NULL)
            {
                error = ERROR_NOT_ENOUGH_MEMORY;
            }

            // Exit lock
            _CritSec.Unlock();
        }
        else
        {
            error = ERROR_NOT_ENOUGH_MEMORY;
        }
    }
    else
    {
        INET_ASSERT(pszAutoConfigUrl);
        *ppszAutoConfigUrl = pszAutoConfigUrl;
    }

quit:
    return error;
}


DWORD
CAutoProxy::DownloadAutoConfigUrl(
    LPSTR                       lpszAutoConfigUrl,
    WINHTTP_AUTOPROXY_OPTIONS * pAutoProxyOptions,
    LPSTR *                     ppszConfigScript
)
{
    HINTERNET   hInternet = NULL;
    HINTERNET   hConnect  = NULL;
    HINTERNET   hRequest  = NULL;
    
    LPSTR   pszHostName = NULL;
    
    BOOL    fSuccess;
    DWORD   error = ERROR_SUCCESS;

    CHAR    szContentType[MAX_PATH+1];

    LPSTR   lpszScriptBuffer = NULL;
    DWORD   dwScriptBufferSize;

    DWORD   dwStatusCode = ERROR_SUCCESS;
    DWORD   cbSize = sizeof(DWORD);

    bool    bCloseInternetHandle  = false;
    bool    bValidateCachedScript = false;
    bool    bAcquiredScriptLock    = false;

    static const char * AcceptTypes[] = { "*/*", NULL };
    URL_COMPONENTSA     Url;


    INET_ASSERT(lpszAutoConfigUrl);

    if (!_CritSec.Lock())
        return ERROR_NOT_ENOUGH_MEMORY;

    //
    // Does the given AutoConfig URL match the last one that
    // was downloaded? If so, the autoconfig script may
    // already be cached.
    //
    if (_pszAutoConfigUrl &&
            StrCmpIA(_pszAutoConfigUrl, lpszAutoConfigUrl) == 0)
    {
        //
        // If we have a cached script and it has not expired,
        // then we're done.
        //
        if (_pszConfigScript)
        {
            if (!IsCachedProxyScriptExpired())
            {
                lpszScriptBuffer = _pszConfigScript;
                
                // Acquire non-exclusive read lock
                if (_ScriptResLock.Acquire())
                {
                    error = ERROR_SUCCESS;
                    bAcquiredScriptLock = true;
                }
                else
                {
                    error = ERROR_NOT_ENOUGH_MEMORY;
                }
                goto quit;
            }
            else
            {
                bValidateCachedScript = true;
            }
        }
    }
    else if (_pszAutoConfigUrl)
    {
        FREE_MEMORY(_pszAutoConfigUrl);
        _pszAutoConfigUrl = NULL;
    }


    //
    // Acquire exclusive write lock - this will wait for all the 
    // outstanding reader locks to release.
    //
    if (!_ScriptResLock.AcquireExclusive())
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    bAcquiredScriptLock = true;


    //
    // Prepare to GET the auto proxy script.
    //

    ZeroMemory(&Url, sizeof(Url));
    Url.dwStructSize = sizeof(URL_COMPONENTSA);
    Url.dwHostNameLength  = 1L;
    Url.dwUrlPathLength   = 1L;
    Url.dwExtraInfoLength = 1L;

    if (!WinHttpCrackUrlA(lpszAutoConfigUrl, 0, 0, &Url))
    {
        goto quitWithLastError;
    }

    // Check for non-http schemes
    if (Url.nScheme != INTERNET_SCHEME_HTTP && Url.nScheme != INTERNET_SCHEME_HTTPS)
    {
        error = ERROR_WINHTTP_UNRECOGNIZED_SCHEME;
        goto quit;
    }

    if (Url.dwHostNameLength == 0)
    {
        error = ERROR_WINHTTP_INVALID_URL;
        goto quit;
    }

    // If the client does not specify a resource path,
    // then add the "/".
    if (Url.dwUrlPathLength == 0)
    {
        INET_ASSERT(Url.dwExtraInfoLength == 1);

        Url.lpszUrlPath = "/";
        Url.dwUrlPathLength = 1;
    }

    pszHostName = NewString(Url.lpszHostName, Url.dwHostNameLength);

    if (!pszHostName)
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    //
    // Fire up a mini WinHttp Session to download a
    //  config file found on some internal server.
    //

    if (_hSession->IsAsyncHandle())
    {
        hInternet = InternetOpenA(
                        NULL,
                        WINHTTP_ACCESS_TYPE_NO_PROXY,
                        NULL,
                        NULL,
                        0);
        if (!hInternet)
        {
            goto quitWithLastError;
        }
        bCloseInternetHandle = true;
    }
    else
    {
        hInternet = _hSession;
    }


    hConnect = InternetConnectA(hInternet, pszHostName, Url.nPort, 0, NULL);

    if (!hConnect)
    {
        goto quitWithLastError;
    }

    hRequest = HttpOpenRequestA(hConnect, NULL, // "GET"
                        Url.lpszUrlPath ? Url.lpszUrlPath : "/",
                        NULL,   // Version
                        NULL,   // Referrer:
                        AcceptTypes,
                        (Url.nScheme == INTERNET_SCHEME_HTTPS) ?
                            WINHTTP_FLAG_SECURE
                          : 0,  // Flags
                        NULL);  // Context

    if (!hRequest)
    {
        goto quitWithLastError;
    }

    //
    // Initialize the Request object
    //

    WINHTTP_PROXY_INFO ProxyInfo;

    ProxyInfo.dwAccessType    = WINHTTP_ACCESS_TYPE_NO_PROXY;
    ProxyInfo.lpszProxy       = NULL;
    ProxyInfo.lpszProxyBypass = NULL;

    fSuccess = WinHttpSetOption(hRequest, WINHTTP_OPTION_PROXY,
                        (void *) &ProxyInfo,
                        sizeof(ProxyInfo));
    if (!fSuccess)
    {
        goto quitWithLastError;
    }

    if (pAutoProxyOptions->fAutoLogonIfChallenged)
    {
        DWORD   dwAutoLogonPolicy = WINHTTP_AUTOLOGON_SECURITY_LEVEL_LOW;

        fSuccess = WinHttpSetOption(hRequest, WINHTTP_OPTION_AUTOLOGON_POLICY,
                            (void *) &dwAutoLogonPolicy,
                            sizeof(dwAutoLogonPolicy));
        if (!fSuccess)
        {
            goto quitWithLastError;
        }
    }

   
    //
    // We have an expired cached script; add If-Modified-Since request
    // header if possible to check if the cached script is still valid.
    //
    if (bValidateCachedScript)
    {
        AddIfModifiedSinceHeaders(hRequest);
    }


    //
    // Send the request syncrhonously
    //

    if (!WinHttpSendRequest(hRequest, NULL, 0, NULL, 0, 0, NULL))
    {
        error = ERROR_WINHTTP_UNABLE_TO_DOWNLOAD_SCRIPT;
        goto quit;
    }

    if (!WinHttpReceiveResponse(hRequest, NULL))
    {
        error = ERROR_WINHTTP_UNABLE_TO_DOWNLOAD_SCRIPT;
        goto quit;
    }


    //
    // Update LastSyncTime
    //
    GetCurrentGmtTime(&_ftLastSyncTime);


    //
    // Check status code
    //
    cbSize = sizeof(dwStatusCode);

    if (HttpQueryInfoA(hRequest, HTTP_QUERY_STATUS_CODE | HTTP_QUERY_FLAG_NUMBER,
            NULL,
            (LPVOID) &dwStatusCode,
            &cbSize,
            NULL))
    {
        if (dwStatusCode == HTTP_STATUS_DENIED)
        {
            error = ERROR_WINHTTP_LOGIN_FAILURE;
            goto quit;
        }
        else if (dwStatusCode >= HTTP_STATUS_NOT_FOUND)
        {
            error = ERROR_WINHTTP_UNABLE_TO_DOWNLOAD_SCRIPT;
            goto quit;
        }
        else if (dwStatusCode == HTTP_STATUS_NOT_MODIFIED)
        {
            INET_ASSERT(bValidateCachedScript);
            INET_ASSERT(_pszConfigScript);

            error = ERROR_SUCCESS;

            lpszScriptBuffer = _pszConfigScript;

            //
            // Release exclusive write lock and take read lock.
            // This is atomic because we also have the general
            // autoproxy critical section.
            //
            _ScriptResLock.Release(); // Release exclusive write lock.
            _ScriptResLock.Acquire(); // Acquire non-exclusive read lock.
            
            goto quit;
        }
    }


    //
    // Clear existing cache config script if any before
    // downloading the new script code.
    //
    if (_pszConfigScript)
    {
        FREE_MEMORY(_pszConfigScript);
        _pszConfigScript = NULL;
    }

    DWORD dwIndex;
    DWORD dwTempSize;

    dwIndex = 0;
    dwTempSize = sizeof(dwScriptBufferSize);

    dwScriptBufferSize = 0;
    
    if (! HttpQueryInfoA(hRequest, (HTTP_QUERY_CONTENT_LENGTH | HTTP_QUERY_FLAG_NUMBER),
           NULL,
           (LPVOID) &dwScriptBufferSize,
           &dwTempSize,
           &dwIndex))
    {
        // failure, just defaults 
        dwScriptBufferSize = DEFAULT_SCRIPT_BUFFER_SIZE;
    }
   
    lpszScriptBuffer = (LPSTR)
                        ALLOCATE_MEMORY(((dwScriptBufferSize + 2) * sizeof(CHAR)));
    if (lpszScriptBuffer == NULL) 
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }


    //
    // read script data
    //

    DWORD   dwBytes     = 0;
    DWORD   dwBytesRead = 0;
    DWORD   dwBytesLeft = dwScriptBufferSize;
    LPSTR   lpszDest    = lpszScriptBuffer;

    do
    {
        fSuccess = WinHttpReadData(hRequest, lpszDest, dwBytesLeft, &dwBytes);

        if (!fSuccess)
        {
            error = GetLastError();
            goto quit;
        }

        if (dwBytes > 0)
        {
            dwBytesRead += dwBytes;
            dwBytesLeft -= dwBytes;

            if (dwBytesLeft == 0)
            {
                dwScriptBufferSize += DEFAULT_SCRIPT_BUFFER_SIZE;
                lpszScriptBuffer = (LPSTR)
                                    REALLOCATE_MEMORY(lpszScriptBuffer,
                                            (dwScriptBufferSize + 2) * sizeof(CHAR));
                if (lpszScriptBuffer == NULL)
                {
                    error = ERROR_NOT_ENOUGH_MEMORY;
                    goto quit;
                }
                dwBytesLeft = DEFAULT_SCRIPT_BUFFER_SIZE;
            }

            lpszDest = lpszScriptBuffer + dwBytesRead;
        }
    } while (dwBytes != 0);

    lpszScriptBuffer[dwBytesRead] = '\0';


    //
    // Figure out what kind of file we're dealing with.
    //  ONLY allow files with the correct extension or the correct MIME type.
    //

    szContentType[0] = '\0';
    dwBytes = ARRAY_ELEMENTS(szContentType)-1;

    fSuccess = HttpQueryInfoA(hRequest, HTTP_QUERY_CONTENT_TYPE, NULL,
                     szContentType,
                     &dwBytes,
                     NULL);

    if (fSuccess && !IsSupportedMimeType(szContentType))
    {
        if (!IsSupportedFileExtension(lpszAutoConfigUrl))
        {
            error = ERROR_WINHTTP_BAD_AUTO_PROXY_SCRIPT;
            goto quit;
        }
    }

    //
    // The script has been downloaded successfully, so now process
    // any Cache-Control and/or Expires headers.
    //
    CalculateTimeStampsForCache(hRequest);

    if (!_pszAutoConfigUrl)
    {
        _pszAutoConfigUrl = NewString(lpszAutoConfigUrl);
        // ok to ignore OOM
    }

    //
    // Cache script
    //
    _pszConfigScript = lpszScriptBuffer;

    //
    // Release exclusive write lock and take read lock.
    // This is atomic because we also have the general
    // autoproxy critical section.
    //
    _ScriptResLock.Release(); // Release exclusive write lock.
    _ScriptResLock.Acquire(); // Acquire non-exclusive read lock.

quit:
    _CritSec.Unlock();

    if (error == ERROR_SUCCESS)
    {
        *ppszConfigScript = lpszScriptBuffer;

        INET_ASSERT(bAcquiredScriptLock);
    }
    else
    {
        if (bAcquiredScriptLock)
        {
            _ScriptResLock.Release();
        }

        if (lpszScriptBuffer)
        {
            FREE_MEMORY(lpszScriptBuffer);
        }
    }

    if (hRequest)
    {
        WinHttpCloseHandle(hRequest);
    }

    if (hConnect)
    {
        WinHttpCloseHandle(hConnect);
    }

    if (bCloseInternetHandle)
    {
        WinHttpCloseHandle(hInternet);
    }

    if (pszHostName)
    {
        FREE_MEMORY(pszHostName);
    }

    return error;


quitWithLastError:
    error = GetLastError();
    INET_ASSERT(error != ERROR_SUCCESS);
    goto quit;
}


BOOL
CAutoProxy::IsSupportedMimeType(char * szType)
{
    return StrCmpIA(szType, "application/x-ns-proxy-autoconfig") == 0;
}

BOOL
CAutoProxy::IsSupportedFileExtension(LPCSTR lpszUrl)
{
    LPCSTR lpszExtension;
    LPCSTR lpszQuestion;

    static const char * rgszExtensionList[] = { ".dat", ".js", ".pac", ".jvs", NULL };

    BOOL    fMatch = FALSE;

    //
    // We need to be careful about checking for a period on the end of an URL
    //   Example: if we have: "http://auto-proxy-srv/fooboo.exe?autogenator.com.ex" ?
    //

    lpszQuestion = strchr(lpszUrl, '?');

    lpszUrl = (lpszQuestion) ? lpszQuestion : lpszUrl;

    lpszExtension = strrchr(lpszUrl, '.');


    if (lpszExtension)
    {
        for (int i = 0; rgszExtensionList[i] != NULL; i++)
        {
            if (StrCmpIA(lpszExtension, rgszExtensionList[i]) == 0)
            {
                fMatch = TRUE;
                break;
            }
        }
    }

    return fMatch;
}


BOOL
CAutoProxy::IsCachedProxyScriptExpired()
/*++

Routine Description:

    Determines whether the cached proxy config script is expired.  If it's 
    expired then we need to synchronize (i.e. do a i-m-s request)

Parameters:

    NONE

Return Value: 

    BOOL
    
--*/

{
    DEBUG_ENTER((DBG_PROXY,
                 Bool,
                 "CAutoProxy::IsCachedProxyScriptExpired",
                 NULL
                 ));

    BOOL        fExpired = FALSE;
    FILETIME    ftCurrentTime;
    
    GetCurrentGmtTime(&ftCurrentTime);

    // Always strictly honor expire time from the server.
    if (_fHasExpiry)
    {
        fExpired = FT2LL(_ftExpiryTime) <= FT2LL(ftCurrentTime);
    }
    else
    {
        // We'll assume the data could change within 12 hours of the last time
        // we sync'ed.
        fExpired = (FT2LL(ftCurrentTime) >= (FT2LL(_ftLastSyncTime) + dwdwHttpDefaultExpiryDelta));
    }
    

    DEBUG_LEAVE(fExpired);
    return fExpired;
}


VOID
CAutoProxy::CalculateTimeStampsForCache(HINTERNET hRequest)
/*++

Routine Description:

    extracts timestamps from the http response. If the timestamps don't exist,
    does the default thing. has additional goodies like checking for expiry etc.

Side Effects:  

    The calculated time stamps values are saved as private members 
    _ftLastModifiedTime, _ftExpiryTime, _fHasExpiry,
    _fHasLastModifiedTime, and _fMustRevalidate.

Return Value: 

    NONE

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                 None,
                 "CAutoProxy::CalculateTimeStampsForCache",
                 NULL
                 ));

    TCHAR   buf[256];
    BOOL    fRet = FALSE;
    DWORD   dwLen, index = 0;

    // reset the private variables
    _fHasLastModifiedTime = FALSE;
    _fHasExpiry = FALSE;
    _fMustRevalidate = FALSE;

    // Determine if a Cache-Control: max-age header exists. If so, calculate expires
    // time from current time + max-age minus any delta indicated by Age:

    CHAR  *ptr, *pToken;

    BOOL fResult;
    DWORD dwError;
    
    while (1)
    {
        // Scan headers for Cache-Control: max-age header.
        dwLen = sizeof(buf);
        fResult = HttpQueryInfoA(hRequest, 
                                WINHTTP_QUERY_CACHE_CONTROL,
                                NULL,
                                buf,
                                &dwLen,
                                &index);

        if (fResult == TRUE) 
            dwError = ERROR_SUCCESS;
        else
            dwError = GetLastError();

        switch (dwError)
        {
        case ERROR_SUCCESS:      
            buf[dwLen] = '\0';
            pToken = ptr = buf;

            // Parse a token from the string; test for sub headers.
            while (NULL != (pToken = StrTokEx(&ptr, ",")))  // <<-- Really test this out, used StrTokEx before
            {
                SKIPWS(pToken);

                if (strnicmp(MAX_AGE_SZ, pToken, MAX_AGE_LEN) == 0)
                {
                    // Found max-age. Convert to integer form.
                    // Parse out time in seconds, text and convert.
                    pToken += MAX_AGE_LEN;

                    SKIPWS(pToken);

                    if (*pToken != '=')
                        break;

                    pToken++;

                    SKIPWS(pToken);

                    INT nDeltaSecs = atoi(pToken);
                    INT nAge;

                    // See if an Age: header exists.

		            // Using a local index variable:
                    DWORD indexAge = 0;
                    dwLen = sizeof(INT)+1;

                    if (HttpQueryInfoA(hRequest,
                                      HTTP_QUERY_AGE | HTTP_QUERY_FLAG_NUMBER,
                                      NULL,
                                      &nAge,
                                      &dwLen,
                                      &indexAge))

                    {
                        // Found Age header. Convert and subtact from max-age.
                        // If less or = 0, attempt to get expires header.
                        nAge = ((nAge < 0) ? 0 : nAge);

                        nDeltaSecs -= nAge;
                        if (nDeltaSecs <= 0)
                        {
                            // The server (or some caching intermediary) possibly sent an incorrectly
				            // calculated header. Use "Expires", if no "max-age" directives at higher indexes.
                            continue;
                        }
                    }

                    // Calculate expires time from max age.
                    GetCurrentGmtTime(&_ftExpiryTime);
                    AddLongLongToFT(&_ftExpiryTime, (nDeltaSecs * (LONGLONG) 10000000));
                    fRet = TRUE;
                }
                else if (strnicmp(MUST_REVALIDATE_SZ, pToken, MUST_REVALIDATE_LEN) == 0)
                {
                    pToken += MUST_REVALIDATE_LEN;
                    SKIPWS(pToken);
                    if (*pToken == 0 || *pToken == ',')
                        _fMustRevalidate = TRUE;
            
                }
            }

            // If an expires time has been found, break switch.
            if (fRet)
                break;
		            
            // Need to bump up index to prevent possibility of never-ending outer while(1) loop.
            // Otherwise, on exit from inner while, we could be stuck here reading the 
            // Cache-Control at the same index.
            // HttpQueryInfoA(WINHTTP_QUERY_CACHE_CONTROL, ...) will return either the next index,
            // or an error, and we'll be good to go:
            index++;
            continue;

        case ERROR_INSUFFICIENT_BUFFER:
            index++;
            continue;

        default:
            break; // no more Cache-Control headers.
        }

        break; // no more Cache-Control headers.
    }

    // If no expires time is calculated from max-age, check for expires header.
    if (!fRet)
    {
        dwLen = sizeof(buf) - 1;
        index = 0;
        if (HttpQueryInfoA(hRequest, HTTP_QUERY_EXPIRES, NULL, buf, &dwLen, &index))
        {
            fRet = FParseHttpDate(&_ftExpiryTime, buf);

            //
            // as per HTTP spec, if the expiry time is incorrect, then the page is
            // considered to have expired
            //

            if (!fRet)
            {
                GetCurrentGmtTime(&_ftExpiryTime);
                AddLongLongToFT(&_ftExpiryTime, (-1)*ONE_HOUR_DELTA); // subtract 1 hour
                fRet = TRUE;
            }
        }
    }

    // We found or calculated a valid expiry time, let us check it against the
    // server date if possible
    FILETIME ft;
    dwLen = sizeof(buf) - 1;
    index = 0;

    if (HttpQueryInfoA(hRequest, HTTP_QUERY_DATE, NULL, buf, &dwLen, &index)
        && FParseHttpDate(&ft, buf))
    {

        // we found a valid Date: header

        // if the expires: date is less than or equal to the Date: header
        // then we put an expired timestamp on this item.
        // Otherwise we let it be the same as was returned by the server.
        // This may cause problems due to mismatched clocks between
        // the client and the server, but this is the best that can be done.

        // Calulating an expires offset from server date causes pages
        // coming from proxy cache to expire later, because proxies
        // do not change the date: field even if the reponse has been
        // sitting the proxy cache for days.

        // This behaviour is as-per the HTTP spec.


        if (FT2LL(_ftExpiryTime) <= FT2LL(ft))
        {
            GetCurrentGmtTime(&_ftExpiryTime);
            AddLongLongToFT(&_ftExpiryTime, (-1)*ONE_HOUR_DELTA); // subtract 1 hour
        }
    }

    _fHasExpiry = fRet;

    if (!fRet)
    {
        _ftExpiryTime.dwLowDateTime = 0;
        _ftExpiryTime.dwHighDateTime = 0;
    }

    fRet = FALSE;
    dwLen = sizeof(buf) - 1;
    index = 0;

    if (HttpQueryInfoA(hRequest, HTTP_QUERY_LAST_MODIFIED, NULL, buf, &dwLen, &index))
    {
        DEBUG_PRINT(PROXY,
                    INFO,
                    ("Last Modified date is: %q\n",
                    buf
                    ));

        fRet = FParseHttpDate(&_ftLastModifiedTime, buf);

        if (!fRet)
        {
            DEBUG_PRINT(PROXY,
                        ERROR,
                        ("FParseHttpDate() returns FALSE\n"
                        ));
        }
    }

    _fHasLastModifiedTime = fRet;

    if (!fRet)
    {
        _ftLastModifiedTime.dwLowDateTime = 0;
        _ftLastModifiedTime.dwHighDateTime = 0;
    }

    DEBUG_LEAVE(0);
}


VOID
CAutoProxy::AddIfModifiedSinceHeaders(HINTERNET hRequest)
/*++

Routine Description:

    Add the necessary IMS request headers to validate whether a cache
    entry can still be used to satisfy the GET request.

Return Value: 

    BOOL
    
--*/

{
    DEBUG_ENTER((DBG_PROXY,
                 None,
                 "CAutoProxy::AddIfModifiedSinceHeaders",
                 NULL
                 ));

    // add if-modified-since only if there is last modified time
    // sent back by the site. This way you never get into trouble
    // where the site doesn't send you an last modified time and you
    // send if-modified-since based on a clock which might be ahead
    // of the site. So the site might say nothing is modified even though
    // something might be. www.microsoft.com is one such example
    if (_fHasLastModifiedTime)
    {
        #define HTTP_IF_MODIFIED_SINCE_SZ   "If-Modified-Since:"
        #define HTTP_IF_MODIFIED_SINCE_LEN  (sizeof(HTTP_IF_MODIFIED_SINCE_SZ) - 1)

        TCHAR szBuf[80];
        TCHAR szHeader[HTTP_IF_MODIFIED_SINCE_LEN + 80];
        DWORD dwLen;

        INET_ASSERT (FT2LL(_ftLastModifiedTime));

        dwLen = sizeof(szBuf);

        if (FFileTimetoHttpDateTime(&_ftLastModifiedTime, szBuf, &dwLen))
        {
            dwLen = wsprintf(szHeader, "%s %s", HTTP_IF_MODIFIED_SINCE_SZ, szBuf); 
            
            HttpAddRequestHeadersA(hRequest, 
                     szHeader, 
                     dwLen,
                     WINHTTP_ADDREQ_FLAG_ADD);
        }
    }
 
    DEBUG_LEAVE(0);
}



DWORD
CAutoProxy::RunProxyScript(
    LPCSTR      lpszUrl,
    LPCSTR      pszProxyScript,
    LPSTR *     ppszQueryResults
)
{
    CScriptSite *           pScriptSite     = NULL;
    AUTO_PROXY_HELPER_APIS  AutoProxyFuncs;

    URL_COMPONENTSA Url;
    char *          pszHostName = NULL;
    DWORD           error = ERROR_SUCCESS;
    HRESULT         hrCoInit = E_FAIL;
    HRESULT         hr = NOERROR;

    if(!DelayLoad( &g_moduleOle32))
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    //
    // Must initialize COM in order to host the JScript engine.
    //
    hrCoInit = DL(CoInitializeEx)(NULL, COINIT_MULTITHREADED);

    pScriptSite = new CScriptSite();

    if (!pScriptSite)
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    ZeroMemory(&Url, sizeof(Url));
    Url.dwStructSize = sizeof(URL_COMPONENTSA);
    Url.dwHostNameLength  = 1L;
    Url.dwUrlPathLength   = 1L;

    if (!WinHttpCrackUrlA(lpszUrl, 0, 0, &Url))
    {
        error = ::GetLastError();
        goto quit;
    }

    pszHostName = NewString(Url.lpszHostName, Url.dwHostNameLength);

    if (!pszHostName)
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    //
    // Make the call into the external DLL,
    //  and let it run, possibly initilization and doing a bunch
    //  of stuff.
    //

    hr = pScriptSite->Init(&AutoProxyFuncs, pszProxyScript);

    if (FAILED(hr))
    {
        goto quit;
    }

    __try
    {
        hr = pScriptSite->RunScript(lpszUrl, pszHostName, ppszQueryResults);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_UNEXPECTED;
    }

quit:
    if (FAILED(hr))
    {
        error = ERROR_WINHTTP_BAD_AUTO_PROXY_SCRIPT;
    }

    if (pScriptSite)
    {
        pScriptSite->DeInit();
        delete pScriptSite;
    }

    if (SUCCEEDED(hrCoInit))
    {
        DL(CoUninitialize)();
    }
    return error;
}

DWORD
CAutoProxy::ParseProxyQueryResults(
    LPSTR                   pszQueryResults,
    WINHTTP_PROXY_INFO *    pProxyInfo
)
{
    LPSTR   pszProxy  = NULL;
    LPSTR   psz;
    size_t  len;
    DWORD   error;
    BOOL    fReadProxy = FALSE;

    memset(pProxyInfo, 0, sizeof(WINHTTP_PROXY_INFO));

    pProxyInfo->dwAccessType = WINHTTP_ACCESS_TYPE_NO_PROXY;

    for (;;)
    {
        // Skip any white space
        while (*pszQueryResults == ' ')
            pszQueryResults++;

        //
        // Skip to the end of the current token
        //
        psz = pszQueryResults;
        while (*psz != '\0' && *psz != ' ' && *psz != ';' && *psz != ',')
            psz++;

        len = psz - pszQueryResults;

        if (len == 0)
            break;

        if (!fReadProxy)
        {
            if (StrCmpNIA(pszQueryResults, "DIRECT", len) == 0)
            {
                break;
            }
            else if (StrCmpNIA(pszQueryResults, "PROXY", len) == 0)
            {
                fReadProxy = TRUE;
            }
            else // error
            {
                break;
            }
        }
        else
        {
            if (!pszProxy)
            {
                pszProxy = new char[lstrlen(pszQueryResults)+1];

                if (!pszProxy)
                    goto ErrorOutOfMemory;

                *pszProxy = '\0';
            }
            else
            {
                StrCatA(pszProxy, ";");
            }

            StrNCatA(pszProxy, pszQueryResults, len+1);

            fReadProxy = FALSE;
        }

        //
        // Are we at the end of the query-results string?
        // If not, advance to the next character.
        //
        if (*psz == '\0')
            break;
        else
            pszQueryResults = psz + 1;
    }

    if (pszProxy)
    {
        error = AsciiToWideChar_UsingGlobalAlloc(pszProxy, &pProxyInfo->lpszProxy);

        delete [] pszProxy;

        if (error)
            goto ErrorOutOfMemory;

        pProxyInfo->dwAccessType = WINHTTP_ACCESS_TYPE_NAMED_PROXY;
    }

    return ERROR_SUCCESS;

ErrorOutOfMemory:
    error = ERROR_NOT_ENOUGH_MEMORY;
    goto Error;

Error:
    return error;
}


BOOL
CAutoProxy::IsDetectionNeeded()

/*++

Routine Description:

  Detects whether we need to actually run a detection on the network,
    or whether we can resuse current results from previous runs

Arguments:

    lpProxySettings - structure to fill

Return Value:

    DWORD
        ERROR_SUCCESS    - success

        Win32 Error code - failure

--*/

{
    int         addressCount;
    LPHOSTENT   lpHostent;
    BOOL        fDetectionNeeded = FALSE;

    if (_pdwDetectedInterfaceIp == NULL)
    {
        // no saved IP address, so detection required
        fDetectionNeeded = TRUE;
    }
    else
    {
        //
        // Check for IP addresses that no longer match, indicating a network change
        //
        __try
        {
            lpHostent = _I_gethostbyname(NULL);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            lpHostent = NULL;
        }

        if (lpHostent != NULL && _CritSec.Lock())
        {
            for (addressCount = 0;
                 lpHostent->h_addr_list[addressCount] != NULL;
                 addressCount++ );  // gather count

            if (addressCount != _cDetectedInterfaceIpCount)
            {
                fDetectionNeeded = TRUE; // detect needed, the IP count is different
            }
            else
            {
                for (int i = 0; i < addressCount; i++)
                {
                    if (*((DWORD *)(lpHostent->h_addr_list[i])) != _pdwDetectedInterfaceIp[i] )
                    {
                        fDetectionNeeded = TRUE; // detect needed, mismatched values
                        break;
                    }
                }
            }

            _CritSec.Unlock();
        }
    }

    return fDetectionNeeded; // default, do not need to redetect
}


DWORD 
CAutoProxy::GetHostAddresses(int * pcInterfaces, DWORD ** ppdwInterfaceIp)
{
    int         addressCount = 0;
    LPHOSTENT   lpHostent;
    DWORD       error;
    DWORD *     pdwInterfaceIp  = NULL;

    error = LoadWinsock();

    if ( error != ERROR_SUCCESS )
    {
        goto quit;
    }

    
    //
    // Gather IP addresses and start copying them over
    //

    __try
    {
        lpHostent = _I_gethostbyname(NULL);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        lpHostent = NULL;
    }

    if (lpHostent == NULL )
    {
        goto quit;
    }

    for (addressCount = 0;
         lpHostent->h_addr_list[addressCount] != NULL;
         addressCount++ );  // gather count

    pdwInterfaceIp = (DWORD *) ALLOCATE_FIXED_MEMORY(addressCount * sizeof(DWORD));

    if (pdwInterfaceIp != NULL)
    {
        for (int i = 0; i < addressCount; i++)
        {
            (pdwInterfaceIp)[i] = *((DWORD *)(lpHostent->h_addr_list[i]));
        }
    }
    else
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
    }

quit:

    if (pdwInterfaceIp)
    {
        *ppdwInterfaceIp = pdwInterfaceIp;
        *pcInterfaces    = addressCount;
    }

    return error;
}



AUTO_PROXY_ASYNC_MSG::AUTO_PROXY_ASYNC_MSG(
    IN INTERNET_SCHEME isUrlScheme,
    IN LPSTR lpszUrl,
    IN LPSTR lpszUrlHostName,
    IN DWORD dwUrlHostNameLength
    )
{
    URL_COMPONENTSA urlComponents;

    Initalize();

    if ( lpszUrl )
    {
        _lpszUrl      = lpszUrl;
        _dwUrlLength  = lstrlen(lpszUrl);
        _tUrlProtocol = isUrlScheme;
        _pmProxyQuery = PROXY_MSG_GET_PROXY_INFO;
        _pmaAllocMode = MSG_ALLOC_STACK_ONLY;

        memset(&urlComponents, 0, sizeof(urlComponents));
        urlComponents.dwStructSize = sizeof(urlComponents);
        urlComponents.lpszHostName = lpszUrlHostName;
        urlComponents.dwHostNameLength = dwUrlHostNameLength;

        //
        // parse out the host name and port. The host name will be decoded; the
        // original URL will not be modified
        //

        if (WinHttpCrackUrlA(lpszUrl, 0, ICU_DECODE, &urlComponents))
        {
           _nUrlPort            = urlComponents.nPort;
           _lpszUrlHostName     = urlComponents.lpszHostName;
           _dwUrlHostNameLength = urlComponents.dwHostNameLength;

           if ( _tUrlProtocol == INTERNET_SCHEME_UNKNOWN )
           {
               _tUrlProtocol = urlComponents.nScheme;
           }

        }
        else
        {
            _Error = GetLastError();
        }
    }
    else
    {
        _Error = ERROR_NOT_ENOUGH_MEMORY;
    }
}

AUTO_PROXY_ASYNC_MSG::AUTO_PROXY_ASYNC_MSG(
    IN INTERNET_SCHEME isUrlScheme,
    IN LPSTR lpszUrlHostName,
    IN DWORD dwUrlHostNameLength
    )
{

    Initalize();

    _tUrlProtocol = isUrlScheme;
    _pmProxyQuery = PROXY_MSG_GET_PROXY_INFO;
    _pmaAllocMode = MSG_ALLOC_STACK_ONLY;
    _lpszUrlHostName     = lpszUrlHostName;
    _dwUrlHostNameLength = dwUrlHostNameLength;
}

AUTO_PROXY_ASYNC_MSG::AUTO_PROXY_ASYNC_MSG(
    IN INTERNET_SCHEME isUrlScheme,
    IN LPSTR lpszUrl,
    IN DWORD dwUrlLength,
    IN LPSTR lpszUrlHostName,
    IN DWORD dwUrlHostNameLength,
    IN INTERNET_PORT nUrlPort
    )
{
    Initalize();

    _tUrlProtocol        = isUrlScheme;
    _pmProxyQuery        = PROXY_MSG_GET_PROXY_INFO;
    _pmaAllocMode        = MSG_ALLOC_STACK_ONLY;
    _nUrlPort            = nUrlPort;
    _lpszUrlHostName     = lpszUrlHostName;
    _dwUrlHostNameLength = dwUrlHostNameLength;
    _lpszUrl             = lpszUrl;
    _dwUrlLength         = dwUrlLength;

}

VOID
AUTO_PROXY_ASYNC_MSG::SetProxyMsg(
    IN INTERNET_SCHEME isUrlScheme,
    IN LPSTR lpszUrl,
    IN DWORD dwUrlLength,
    IN LPSTR lpszUrlHostName,
    IN DWORD dwUrlHostNameLength,
    IN INTERNET_PORT nUrlPort
    )
{
    _tUrlProtocol        = isUrlScheme;
    _pmProxyQuery        = PROXY_MSG_GET_PROXY_INFO;
    _pmaAllocMode        = MSG_ALLOC_STACK_ONLY;
    _nUrlPort            = nUrlPort;
    _lpszUrlHostName     = lpszUrlHostName;
    _dwUrlHostNameLength = dwUrlHostNameLength;
    _lpszUrl             = lpszUrl;
    _dwUrlLength         = dwUrlLength;
}


AUTO_PROXY_ASYNC_MSG::AUTO_PROXY_ASYNC_MSG(
    IN PROXY_MESSAGE_TYPE pmProxyQuery
    )
{
    Initalize();

    _pmaAllocMode = MSG_ALLOC_HEAP_MSG_OBJ_OWNS;
    _pmProxyQuery = pmProxyQuery;
}

AUTO_PROXY_ASYNC_MSG::AUTO_PROXY_ASYNC_MSG(
    IN AUTO_PROXY_ASYNC_MSG *pStaticAutoProxy
    )
{
    Initalize();

    _tUrlProtocol          = pStaticAutoProxy->_tUrlProtocol;
    _lpszUrl               = (pStaticAutoProxy->_lpszUrl) ? NewString(pStaticAutoProxy->_lpszUrl) : NULL;
    _dwUrlLength           = pStaticAutoProxy->_dwUrlLength;
    _lpszUrlHostName       =
                (pStaticAutoProxy->_lpszUrlHostName ) ?
                NewString(pStaticAutoProxy->_lpszUrlHostName, pStaticAutoProxy->_dwUrlHostNameLength) :
                NULL;
    _dwUrlHostNameLength   = pStaticAutoProxy->_dwUrlHostNameLength;
    _nUrlPort              = pStaticAutoProxy->_nUrlPort;
    _tProxyScheme          = pStaticAutoProxy->_tProxyScheme;

    //
    // ProxyHostName is something that is generated by the request,
    //   therefore it should not be copied OR freed.
    //

    INET_ASSERT( pStaticAutoProxy->_lpszProxyHostName == NULL );
    //_lpszProxyHostName     = (pStaticAutoProxy->_lpszProxyHostName ) ? NewString(pStaticAutoProxy->_lpszProxyHostName) : NULL;


    _dwProxyHostNameLength = pStaticAutoProxy->_dwProxyHostNameLength;
    _nProxyHostPort        = pStaticAutoProxy->_nProxyHostPort;
    _pmProxyQuery          = pStaticAutoProxy->_pmProxyQuery;
    _pmaAllocMode          = MSG_ALLOC_HEAP_MSG_OBJ_OWNS;
    _pProxyState           = pStaticAutoProxy->_pProxyState;

    INET_ASSERT(_pProxyState == NULL);

    _dwQueryResult         = pStaticAutoProxy->_dwQueryResult;
    _Error                 = pStaticAutoProxy->_Error;
    _MessageFlags.Dword    = pStaticAutoProxy->_MessageFlags.Dword;
    _dwProxyVersion        = pStaticAutoProxy->_dwProxyVersion;
}

AUTO_PROXY_ASYNC_MSG::~AUTO_PROXY_ASYNC_MSG(
    VOID
    )
{
    DEBUG_ENTER((DBG_OBJECTS,
                None,
                "~AUTO_PROXY_ASYNC_MSG",
                NULL
                ));

    if ( IsAlloced() )
    {
        DEBUG_PRINT(OBJECTS,
                    INFO,
                    ("Freeing Allocated MSG ptr=%x\n",
                    this
                    ));


        if ( _lpszUrl )
        {
            //DEBUG_PRINT(OBJECTS,
            //            INFO,
            //            ("Url ptr=%x, %q\n",
            //            _lpszUrl,
            //            _lpszUrl
            //            ));

            FREE_MEMORY(_lpszUrl);
        }

        if ( _lpszUrlHostName )
        {
            FREE_MEMORY(_lpszUrlHostName);
        }


        if ( _pProxyState )
        {
            delete _pProxyState;
        }
    }
    if (_bFreeProxyHostName && (_lpszProxyHostName != NULL)) {
        FREE_MEMORY(_lpszProxyHostName);
    }

    DEBUG_LEAVE(0);
}



DWORD
AUTO_PROXY_HELPER_APIS::ResolveHostName(
    IN LPSTR lpszHostName,
    IN OUT LPSTR   lpszIPAddress,
    IN OUT LPDWORD lpdwIPAddressSize
    )
 
/*++
 
Routine Description:
 
    Resolves a HostName to an IP address by using Winsock DNS.
 
Arguments:
 
    lpszHostName   - the host name that should be used.
 
    lpszIPAddress  - the output IP address as a string.
 
    lpdwIPAddressSize - the size of the outputed IP address string.
 
Return Value:
 
    DWORD
        Win32 error code.
 
--*/
 
{
    // Figure out if we're being asked to resolve a name or an address literal.
    // If getaddrinfo() with the AI_NUMERICHOST flag succeeds then we were
    // given a string respresentation of an IPv6 or IPv4 address. Otherwise
    // we expect getaddrinfo to return EAI_NONAME.
    //

    DWORD dwIPAddressSize;
    BOOL bResolved = FALSE;
    ADDRINFO Hints;
    LPADDRINFO lpAddrInfo;
    DWORD error;

    memset(&Hints, 0, sizeof(struct addrinfo));
    Hints.ai_flags = AI_NUMERICHOST;  // Only check for address literals.
    Hints.ai_family = PF_UNSPEC;      // Accept any protocol family.
    Hints.ai_socktype = SOCK_STREAM;  // Constrain results to stream socket.
    Hints.ai_protocol = IPPROTO_TCP;  // Constrain results to TCP.

    error = _I_getaddrinfo(lpszHostName, NULL, &Hints, &lpAddrInfo);
    if (error != EAI_NONAME) {
        if (error != 0) {
            if (error == EAI_MEMORY)
                error = ERROR_NOT_ENOUGH_MEMORY;
            else
                error = ERROR_WINHTTP_NAME_NOT_RESOLVED;
            goto quit;
        }

        //
        // An IP address (either v4 or v6) was passed in.
        // This is precisely what we want, so if we have the room,
        // just copy it back out.
        //

        _I_freeaddrinfo(lpAddrInfo);

        dwIPAddressSize = lstrlen(lpszHostName);
 
        if ( *lpdwIPAddressSize < dwIPAddressSize ||
              lpszIPAddress == NULL )
        {
            *lpdwIPAddressSize = dwIPAddressSize+1;
            error = ERROR_INSUFFICIENT_BUFFER;
            goto quit;
        }
 
        lstrcpy(lpszIPAddress, lpszHostName);
        goto quit;
    }
  
    DEBUG_PRINT(SOCKETS,
                INFO,
                ("resolving %q\n",
                lpszHostName
                ));

    error = _I_getaddrinfo(lpszHostName, NULL, &Hints, &lpAddrInfo);

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("%q %sresolved\n",
                lpszHostName,
                (error == 0) ? "" : "NOT "
                ));
 
    if (error == 0) {
        bResolved = TRUE;
    } else {
        if (error == EAI_MEMORY)
            error = ERROR_NOT_ENOUGH_MEMORY;
        else
            error = ERROR_WINHTTP_NAME_NOT_RESOLVED;
        goto quit;
    }

    INET_ASSERT(lpAddrInfo != NULL);

    //
    // We have an addrinfo struct for lpszHostName.
    // Convert its IP address into a string.
    //

    //
    // BUGBUG: Until our caller can deal with IPv6 addresses, we'll only
    // return IPv4 addresses here, regardless of what may be in the cache.
    // Step through chain until we find an IPv4 address.
    //

    LPADDRINFO IPv4Only;

    IPv4Only = lpAddrInfo;
    while (IPv4Only->ai_family != AF_INET) {

        IPv4Only = IPv4Only->ai_next;
        if (IPv4Only == NULL) {
            error = ERROR_WINHTTP_NAME_NOT_RESOLVED;
            goto quit;
        }
    }

    error = _I_getnameinfo(IPv4Only->ai_addr, IPv4Only->ai_addrlen,
                           lpszIPAddress, *lpdwIPAddressSize, NULL, 0,
                           NI_NUMERICHOST);

    if (error != 0) {
        error = ERROR_WINHTTP_NAME_NOT_RESOLVED;
    }

quit:
    if (bResolved)
    {
        _I_freeaddrinfo(lpAddrInfo);
    }

    return error;
}

BOOL
AUTO_PROXY_HELPER_APIS::IsResolvable(
    IN LPSTR lpszHost
    )
 
/*++
 
Routine Description:
 
    Determines wheter a HostName can be resolved.  Performs a Winsock DNS query,
      and if it succeeds returns TRUE.
 
Arguments:
 
    lpszHost   - the host name that should be used.
 
Return Value:
 
    BOOL
        TRUE - the host is resolved.
 
        FALSE - could not resolve.
 
--*/
 
{
 
    DWORD dwDummySize;
    DWORD error;
 
    error = ResolveHostName(
                lpszHost,
                NULL,
                &dwDummySize
                );
 
    if ( error == ERROR_INSUFFICIENT_BUFFER )
    {
        return TRUE;
    }
    else
    {
        INET_ASSERT(error != ERROR_SUCCESS );
        return FALSE;
    }
 
}
DWORD
AUTO_PROXY_HELPER_APIS::GetIPAddress(
    IN OUT LPSTR   lpszIPAddress,
    IN OUT LPDWORD lpdwIPAddressSize
    )
 
/*++
 
Routine Description:
 
    Acquires the IP address string of this client machine WINHTTP is running on.
 
Arguments:
 
    lpszIPAddress   - the IP address of the machine, returned.
 
    lpdwIPAddressSize - size of the IP address string.
 
Return Value:
 
    DWORD
        Win32 Error.
 
--*/
 
{
 
    CHAR szHostBuffer[255];
    int serr;
 
    serr = _I_gethostname(
                szHostBuffer,
                255-1 
                );
 
    if ( serr != 0)
    {
        return ERROR_WINHTTP_INTERNAL_ERROR;
    }
 
    return ResolveHostName(
                szHostBuffer,
                lpszIPAddress,
                lpdwIPAddressSize
                );
 
}

BOOL
AUTO_PROXY_HELPER_APIS::IsInNet(
    IN LPSTR   lpszIPAddress,
    IN LPSTR   lpszDest,
    IN LPSTR   lpszMask
    )
 
/*++
 
Routine Description:
 
    Determines whether a given IP address is in a given dest/mask IP address.
 
Arguments:
 
    lpszIPAddress   - the host name that should be used.
 
    lpszDest        - the IP address dest to check against.
 
    lpszMask        - the IP mask string
 
Return Value:
 
    BOOL
        TRUE - the IP address is in the given dest/mask
 
        FALSE - the IP address is NOT in the given dest/mask
 
--*/
 
{
    DWORD dwDest, dwIpAddr, dwMask;
 
    INET_ASSERT(lpszIPAddress);
    INET_ASSERT(lpszDest);
    INET_ASSERT(lpszMask);
 
    dwIpAddr = _I_inet_addr(lpszIPAddress);
    dwDest   = _I_inet_addr(lpszDest);
    dwMask   = _I_inet_addr(lpszMask);
 
    if ( dwDest   == INADDR_NONE ||
         dwIpAddr == INADDR_NONE  )
 
    {
        INET_ASSERT(FALSE);
        return FALSE;
    }
 
    if ( (dwIpAddr & dwMask) != dwDest)
    {
        return FALSE;
    }
 
    //
    // Pass, its Matches.
    //
 
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5.1\api\creds.cxx ===
/*++

Copyright (c) 1994-2000  Microsoft Corporation

Module Name:

    Creds.cxx

Abstract:

    Contains the Creds APIs

    Contents:
        WinHttpSetCredentialsA
        WinHttpSetCredentials
        WinHttpQueryAuthSchemes
        
Author:

    Biao Wang (biaow) 27-June-2000

Environment:

    Win32 user-mode DLL

Revision History:

    27-June-2000 biaow
        Created

--*/

#include <wininetp.h>

/*
BOOLAPI WinHttpQueryAuthParams(
    IN  HINTERNET   hRequest,        // HINTERNET handle returned by WinHttpOpenRequest   
    IN  DWORD       AuthScheme,
    OUT LPVOID*     pAuthParams      // Scheme-specific Advanced auth parameters
    )
{
    //BUG-BUG Verify parameters
    
    // biaow: to implement this fully
    *pAuthParams = 0;

    return TRUE;
}
*/

BOOLAPI WinHttpQueryAuthSchemes(
    
    IN  HINTERNET   hRequest,       // HINTERNET handle returned by HttpOpenRequest.   
    OUT LPDWORD     lpdwSupportedSchemes,// a bitmap of available Authentication Schemes
    OUT LPDWORD     lpdwPreferredScheme,  // WinHttp's preferred Authentication Method 
    OUT LPDWORD      pdwAuthTarget  
    )
{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "WinHttpQueryAuthSchemes",
                     "%#x, %#x, %#x",
                     hRequest,
                     lpdwSupportedSchemes,
                     lpdwPreferredScheme
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    HINTERNET hRequestMapped = NULL;
    BOOL fResult = FALSE;
    HINTERNET_HANDLE_TYPE HandleType;    

    dwErr = ::MapHandleToAddress(hRequest, (LPVOID *)&hRequestMapped, FALSE);
    
    if ((dwErr != ERROR_SUCCESS) || (hRequestMapped == NULL)) 
    {
        dwErr = ERROR_INVALID_HANDLE;
        goto cleanup;
    }

    HTTP_REQUEST_HANDLE_OBJECT * pRequest;

    if ((::RGetHandleType(hRequestMapped, &HandleType) != ERROR_SUCCESS) 
        || (HandleType != TypeHttpRequestHandle))
    {
        dwErr = ERROR_INVALID_HANDLE;
        goto cleanup;
    }
    
    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)hRequestMapped;

    if (::IsBadWritePtr(lpdwSupportedSchemes, sizeof(DWORD)) 
        || ::IsBadWritePtr(lpdwPreferredScheme, sizeof(DWORD)) 
        || ::IsBadWritePtr(pdwAuthTarget, sizeof(DWORD)))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    if (!pRequest->_KnowSupportedSchemes)
    {
        dwErr = ERROR_INVALID_OPERATION;
        goto cleanup;
    }

    *lpdwSupportedSchemes = pRequest->_SupportedSchemes;
    *lpdwPreferredScheme = pRequest->_PreferredScheme;
    *pdwAuthTarget = pRequest->_AuthTarget;
    
    fResult = TRUE;

    DEBUG_PRINT(API,
                INFO,
                ("Supported Scheme = %x; Preferred Scheme = %x; Auth Target = %x\n",
                *lpdwSupportedSchemes,
                *lpdwPreferredScheme,
                *pdwAuthTarget
                ));

cleanup:

    if (hRequestMapped)
    {
        DereferenceObject(hRequestMapped);
    }

    if (dwErr!= ERROR_SUCCESS) 
    { 
        ::SetLastError(dwErr); 
        DEBUG_ERROR(HTTP, dwErr);
    }
    
    DEBUG_LEAVE_API(fResult);
    return fResult;
}

BOOL WinHttpSetCredentialsA (
    
    IN HINTERNET   hRequest,        // HINTERNET handle returned by HttpOpenRequest.   
    
    
    IN DWORD       AuthTargets,      // Only WINHTTP_AUTH_TARGET_SERVER and 
                                    // WINHTTP_AUTH_TARGET_PROXY are supported
                                    // in this version and they are mutually 
                                    // exclusive 
    
    IN DWORD       AuthScheme,      // must be one of the supported Auth Schemes 
                                    // returned from HttpQueryAuthSchemes(), Apps 
                                    // should use the Preferred Scheme returned
    
    IN LPCSTR     pszUserName,     // 1) NULL if default creds is to be used, in 
                                    // which case pszPassword will be ignored
    
    IN LPCSTR     pszPassword,     // 1) "" == Blank Passowrd; 2)Parameter ignored 
                                    // if pszUserName is NULL; 3) Invalid to pass in 
                                    // NULL if pszUserName is not NULL
    IN LPVOID     pAuthParams
   
    )
{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "WinHttpSetCredentialsA",
                     "%#x, %#x, %#x, %q, %q, %q",
                     hRequest,
                     AuthTargets,
                     AuthScheme,
                     pAuthParams,
                     pszUserName,
                     pszPassword
                     ));
    
    // Note: we assume WinHttp will explose an Unicode only API, so this function
    // will not be called directly by Apps. If this assumption is no longer true 
    // in future revisions, we need to add more elaborate parameter validation here.

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;
    HINTERNET hRequestMapped = NULL;
    HTTP_REQUEST_HANDLE_OBJECT* pRequest;
    HINTERNET_HANDLE_TYPE HandleType;
    PSTR pszRealm = NULL;

    // validate API symantics

    if (pszUserName != NULL)
    {
        // in any case, it doesn't make sense (and therefore invalid) to pass 
        // in a blank("") User Name
        if (pszUserName[0] == '\0')
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
        else if (pszPassword == NULL)
        {
            // in any case, if an app passes in a UserName, it is invalid to
            // then pass in a NULL password (should use "" for blank passowrd)
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
    }

    switch (AuthScheme)
    {
        case WINHTTP_AUTH_SCHEME_BASIC:
        case WINHTTP_AUTH_SCHEME_NTLM:
        case WINHTTP_AUTH_SCHEME_PASSPORT:
        case WINHTTP_AUTH_SCHEME_DIGEST:
        case WINHTTP_AUTH_SCHEME_NEGOTIATE:
            break;
        default:
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
    }

    // if an app picks BASIC auth, it must also supply an UserName and password
    if ((AuthScheme == WINHTTP_AUTH_SCHEME_BASIC) && (pszUserName == NULL))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    // default credentials (UserName/Password == NULL/NULL) are allowed only for 
    // NTLM/NEGOTIATE/PASSPORT auth
    if (pszUserName == NULL)
    {
        if ((AuthScheme != WINHTTP_AUTH_SCHEME_NTLM) 
            && (AuthScheme != WINHTTP_AUTH_SCHEME_NEGOTIATE)
            && (AuthScheme != WINHTTP_AUTH_SCHEME_PASSPORT))
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
    }

    dwErr = ::MapHandleToAddress(hRequest, (LPVOID *)&hRequestMapped, FALSE);
    
    if ((dwErr != ERROR_SUCCESS) || (hRequestMapped == NULL)) {
        
        dwErr = ERROR_INVALID_HANDLE;
        goto cleanup;
    }

    if ((::RGetHandleType(hRequestMapped, &HandleType) != ERROR_SUCCESS) 
        || (HandleType != TypeHttpRequestHandle))
    {
        dwErr = ERROR_INVALID_HANDLE;
        goto cleanup;
    }

    pRequest = 
        reinterpret_cast<HTTP_REQUEST_HANDLE_OBJECT*>(hRequestMapped);

    if (AuthScheme == WINHTTP_AUTH_SCHEME_DIGEST)
    {
        if (pAuthParams)
        {
            pszRealm = NewString((PCSTR)pAuthParams);
        }
        else
        {
            pszRealm = pRequest->_pszRealm;
        }

        if (pszRealm == NULL)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
    }

    if (AuthTargets == WINHTTP_AUTH_TARGET_PROXY)
    {
        delete pRequest->_pProxyCreds;
        pRequest->_pProxyCreds = New WINHTTP_REQUEST_CREDENTIALS(AuthScheme, 
                                                              pszRealm, pszUserName, pszPassword);
        if (pRequest->_pProxyCreds == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
    }
    else 
    {
        delete pRequest->_pServerCreds;
        pRequest->_pServerCreds = New WINHTTP_REQUEST_CREDENTIALS(AuthScheme, 
                                                                  pszRealm, pszUserName, pszPassword);
        if (pRequest->_pServerCreds == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
    }

    pRequest->_KnowSupportedSchemes = FALSE;
    pRequest->_PreferredScheme = 0x00000000;
    pRequest->_SupportedSchemes = 0x00000000;
    pRequest->_AuthTarget = 0x00000000;
    if (pRequest->_pszRealm)
    {
        FREE_MEMORY(pRequest->_pszRealm);
        pRequest->_pszRealm = NULL;
    }

    fResult = TRUE;

cleanup:

    if (hRequestMapped)
    {
        DereferenceObject(hRequestMapped);
    }

    if (dwErr!=ERROR_SUCCESS) 
    { 
        ::SetLastError(dwErr); 
        DEBUG_ERROR(HTTP, dwErr);
    }
    
    DEBUG_LEAVE_API(fResult);
    return fResult;
}

BOOLAPI 
WinHttpSetCredentials(
    
    IN HINTERNET   hRequest,        // HINTERNET handle returned by HttpOpenRequest.   
    
    
    IN DWORD       AuthTargets,      // Only WINHTTP_AUTH_TARGET_SERVER and 
                                    // WINHTTP_AUTH_TARGET_PROXY are supported
                                    // in this version and they are mutually 
                                    // exclusive 
    
    IN DWORD       AuthScheme,      // must be one of the supported Auth Schemes 
                                    // returned from HttpQueryAuthSchemes(), Apps 
                                    // should use the Preferred Scheme returned
    
    IN LPCWSTR     pwszUserName,     // 1) NULL if default creds is to be used, in 
                                    // which case pszPassword will be ignored
    
    IN LPCWSTR     pwszPassword,     // 1) "" == Blank Passowrd; 2)Parameter ignored 
                                    // if pszUserName is NULL; 3) Invalid to pass in 
                                    // NULL if pszUserName is not NULL
    IN LPVOID      pAuthParams
   
    )
{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "WinHttpSetCredentials",
                     "%#x, %#x, %#x, %wq, %wq, %wq",
                     hRequest,
                     AuthTargets,
                     AuthScheme,
                     pAuthParams,
                     !pwszUserName 
                        || ::IsBadStringPtrW(pwszUserName, INTERNET_MAX_USER_NAME_LENGTH)? L"": pwszUserName,
                     !pwszPassword 
                        || ::IsBadStringPtrW(pwszPassword, INTERNET_MAX_PASSWORD_LENGTH)? L"": pwszPassword
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;
    LPCWSTR pwszRealm = NULL;
    MEMORYPACKET mpRealm, mpUserName, mpPassword;

    if (!hRequest)
    {
        dwErr = ERROR_INVALID_HANDLE;
        goto cleanup;
    }

    // make sure only one bit in AuthScheme is set
    if ((AuthScheme & (AuthScheme - 1)) != 0x00000000)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    // make sure the input strings are valid
    if (pwszUserName 
        && ::IsBadStringPtrW(pwszUserName, INTERNET_MAX_USER_NAME_LENGTH))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    if (pwszPassword 
        && ::IsBadStringPtrW(pwszPassword, INTERNET_MAX_PASSWORD_LENGTH))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    
    if ((AuthScheme == WINHTTP_AUTH_SCHEME_DIGEST) && pAuthParams)
    {
        pwszRealm = (LPCWSTR)pAuthParams;
    }
    if (pwszRealm 
        && ::IsBadStringPtrW(pwszRealm, INTERNET_MAX_REALM_LENGTH))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    // make sure AuthTargets are either Server or Proxy (not both)
    if ((AuthTargets != WINHTTP_AUTH_TARGET_SERVER) 
        && (AuthTargets != WINHTTP_AUTH_TARGET_PROXY))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    // convert Unicode strings to Ansi
    
    if (pwszUserName)
    {
        ALLOC_MB(pwszUserName, 0, mpUserName);
        if (!mpUserName.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(pwszUserName, mpUserName);
    }
    if (pwszPassword)
    {
        ALLOC_MB(pwszPassword, 0, mpPassword);
        if (!mpPassword.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(pwszPassword, mpPassword);
    }
    if (pwszRealm)
    {
        ALLOC_MB(pwszRealm, 0, mpRealm);
        if (!mpRealm.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(pwszRealm, mpRealm);
    }

    fResult = ::WinHttpSetCredentialsA(hRequest, AuthTargets,
                                       AuthScheme, mpUserName.psStr, mpPassword.psStr, mpRealm.psStr);

cleanup:
    ZERO_MEMORY_ALLOC(mpUserName);
    ZERO_MEMORY_ALLOC(mpPassword);
    
    if (dwErr!=ERROR_SUCCESS) 
    { 
        ::SetLastError(dwErr); 
        DEBUG_ERROR(HTTP, dwErr);
    }
    
    DEBUG_LEAVE_API(fResult);
    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5.1\api\inetapia.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    inetapia.cxx

Abstract:

    Contains the ANSI and character-mode-independent Internet APIs

    Contents:
        WinHttpCloseHandle
        WinHttpReadData
        WinHttpWriteData
        WinHttpQueryDataAvailable
        
    
        WinHttpCrackUrlA
        WinHttpCreateUrlA
        InternetCanonicalizeUrlA
        InternetCombineUrlA
        InternetOpenA
        _InternetCloseHandle
        _InternetCloseHandleNoContext
        InternetConnectA
        InternetOpenUrlA
        ReadFile_End
        InternetQueryOptionA
        InternetSetOptionA
        InternetGetLastResponseInfoA
        (wInternetCloseConnectA)
        (CreateDeleteSocket)

Author:

    Richard L Firth (rfirth) 02-Mar-1995

Environment:

    Win32 user-mode DLL

Revision History:

    02-Mar-1995 rfirth
        Created

    07-Mar-1995 madana


--*/


#include <wininetp.h>
#include <perfdiag.hxx>

//  because wininet doesnt know IStream
#define NO_SHLWAPI_STREAM
#include <shlwapi.h>
#include <shlwapip.h>


//
// private manifests
//

//
// private prototypes
//

PRIVATE
DWORD
ReadFile_Fsm(
    IN CFsm_ReadFile * Fsm
    );

PRIVATE
DWORD
ReadFileEx_Fsm(
    IN CFsm_ReadFileEx * Fsm
    );

PRIVATE
VOID
ReadFile_End(
    IN BOOL bDeref,
    IN BOOL bSuccess,
    IN HINTERNET hFileMapped,
    IN DWORD dwBytesRead,
    IN LPVOID lpBuffer OPTIONAL,
    IN DWORD dwNumberOfBytesToRead,
    OUT LPDWORD lpdwNumberOfBytesRead OPTIONAL
    );

PRIVATE
DWORD
QueryAvailable_Fsm(
    IN CFsm_QueryAvailable * Fsm
    );


PRIVATE
DWORD
wInternetCloseConnectA(
    IN HINTERNET lpConnectHandle,
    IN DWORD ServiceType
    );

PRIVATE
BOOL
InternetParseCommon(
    IN LPCTSTR lpszBaseUrl,
    IN LPCTSTR lpszRelativeUrl,
    OUT LPTSTR lpszBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN DWORD dwFlags
    );


//
// functions
//


INTERNETAPI
BOOL
WINAPI
WinHttpCrackUrlA(
    IN LPCSTR lpszUrl,
    IN DWORD dwUrlLength,
    IN DWORD dwFlags,
    IN LPURL_COMPONENTSA lpUrlComponents
    )

/*++

Routine Description:

    Cracks an URL into its constituent parts. Optionally escapes the url-path.
    We assume that the user has supplied large enough buffers for the various
    URL parts

Arguments:

    lpszUrl         - pointer to URL to crack

    dwUrlLength     - 0 if lpszUrl is ASCIIZ string, else length of lpszUrl

    dwFlags         - flags controlling operation

    lpUrlComponents - pointer to URL_COMPONENTS

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError() for more info

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "WinHttpCrackUrlA",
                     "%q, %#x, %#x, %#x",
                     lpszUrl,
                     dwUrlLength,
                     dwFlags,
                     lpUrlComponents
                     ));

    DWORD error;

    //
    // validate parameters
    //
    if (!dwUrlLength)
        dwUrlLength = lstrlen(lpszUrl);

    //
    // get the individual components to return. If they reference a buffer then
    // check it for writeability
    //

    LPSTR lpUrl;
    LPSTR urlCopy;
    INTERNET_SCHEME schemeType;
    LPSTR schemeName;
    DWORD schemeNameLength;
    LPSTR hostName;
    DWORD hostNameLength;
    INTERNET_PORT nPort;
    LPSTR userName;
    DWORD userNameLength;
    LPSTR password;
    DWORD passwordLength;
    LPSTR urlPath;
    DWORD urlPathLength;
    LPSTR extraInfo;
    DWORD extraInfoLength;
    BOOL copyComponent;
    BOOL havePort;

    copyComponent = FALSE;

    schemeName = lpUrlComponents->lpszScheme;
    schemeNameLength = lpUrlComponents->dwSchemeLength;
    if ((schemeName != NULL) && (schemeNameLength != 0)) 
    {
        *schemeName = '\0';
        copyComponent = TRUE;
    }

    hostName = lpUrlComponents->lpszHostName;
    hostNameLength = lpUrlComponents->dwHostNameLength;
    if ((hostName != NULL) && (hostNameLength != 0)) 
    {
        *hostName = '\0';
        copyComponent = TRUE;
    }

    userName = lpUrlComponents->lpszUserName;
    userNameLength = lpUrlComponents->dwUserNameLength;
    if ((userName != NULL) && (userNameLength != 0)) 
    {
        *userName = '\0';
        copyComponent = TRUE;
    }

    password = lpUrlComponents->lpszPassword;
    passwordLength = lpUrlComponents->dwPasswordLength;
    if ((password != NULL) && (passwordLength != 0)) 
    {
        *password = '\0';
        copyComponent = TRUE;
    }

    urlPath = lpUrlComponents->lpszUrlPath;
    urlPathLength = lpUrlComponents->dwUrlPathLength;
    if ((urlPath != NULL) && (urlPathLength != 0)) 
    {
        *urlPath = '\0';
        copyComponent = TRUE;
    }

    extraInfo = lpUrlComponents->lpszExtraInfo;
    extraInfoLength = lpUrlComponents->dwExtraInfoLength;
    if ((extraInfo != NULL) && (extraInfoLength != 0)) 
    {
        *extraInfo = '\0';
        copyComponent = TRUE;
    }

    //
    // we can only escape or decode the URL if the caller has provided us with
    // buffers to write the escaped strings into
    //

    if (dwFlags & (ICU_ESCAPE | ICU_DECODE)) {
        if (!copyComponent) {
            error = ERROR_INVALID_PARAMETER;
            goto quit;
        }

        //
        // create a copy of the URL. CrackUrl() will modify this in situ. We
        // need to copy the results back to the user's buffer(s)
        //

        urlCopy = NewString((LPSTR)lpszUrl, dwUrlLength);
        if (urlCopy == NULL) {
            error = ERROR_NOT_ENOUGH_MEMORY;
            goto quit;
        }
        lpUrl = urlCopy;
    } else {
        lpUrl = (LPSTR)lpszUrl;
        urlCopy = NULL;
    }

    //
    // crack the URL into its constituent parts
    //

    error = CrackUrl(lpUrl,
                     dwUrlLength,
                     (dwFlags & ICU_ESCAPE) ? TRUE : FALSE,
                     &schemeType,
                     &schemeName,
                     &schemeNameLength,
                     &hostName,
                     &hostNameLength,
                     TRUE,
                     &nPort,
                     &userName,
                     &userNameLength,
                     &password,
                     &passwordLength,
                     &urlPath,
                     &urlPathLength,
                     extraInfoLength ? &extraInfo : NULL,
                     extraInfoLength ? &extraInfoLength : 0,
                     &havePort
                     );
    if (error != ERROR_SUCCESS) {
        goto crack_error;
    }

    BOOL copyFailure;

    copyFailure = FALSE;

    //
    // update the URL_COMPONENTS structure based on the results, and what was
    // asked for
    //

    if (lpUrlComponents->lpszScheme != NULL) {
        if (lpUrlComponents->dwSchemeLength > schemeNameLength) {
            memcpy((LPVOID)lpUrlComponents->lpszScheme,
                   (LPVOID)schemeName,
                   schemeNameLength
                   );
            lpUrlComponents->lpszScheme[schemeNameLength] = '\0';
            if (dwFlags & ICU_DECODE) {
                UrlUnescapeInPlace(lpUrlComponents->lpszScheme, 0);
            }
        } else {
            ++schemeNameLength;
            copyFailure = TRUE;
        }
        lpUrlComponents->dwSchemeLength = schemeNameLength;
    } else if (lpUrlComponents->dwSchemeLength != 0) {
        lpUrlComponents->lpszScheme = schemeName;
        lpUrlComponents->dwSchemeLength = schemeNameLength;
    }

    if (lpUrlComponents->lpszHostName != NULL) {
        if (lpUrlComponents->dwHostNameLength > hostNameLength) {
            memcpy((LPVOID)lpUrlComponents->lpszHostName,
                   (LPVOID)hostName,
                   hostNameLength
                   );
            lpUrlComponents->lpszHostName[hostNameLength] = '\0';
            if (dwFlags & ICU_DECODE) {
                UrlUnescapeInPlace(lpUrlComponents->lpszHostName, 0);
            }
        } else {
            ++hostNameLength;
            copyFailure = TRUE;
        }
        lpUrlComponents->dwHostNameLength = hostNameLength;
    } else if (lpUrlComponents->dwHostNameLength != 0) {
        lpUrlComponents->lpszHostName = hostName;
        lpUrlComponents->dwHostNameLength = hostNameLength;
    }

    if (lpUrlComponents->lpszUserName != NULL) {
        if (lpUrlComponents->dwUserNameLength > userNameLength) {
            memcpy((LPVOID)lpUrlComponents->lpszUserName,
                   (LPVOID)userName,
                   userNameLength
                   );
            lpUrlComponents->lpszUserName[userNameLength] = '\0';
            if (dwFlags & ICU_DECODE) {
                UrlUnescapeInPlace(lpUrlComponents->lpszUserName, 0);
            }
        } else {
            ++userNameLength;
            copyFailure = TRUE;
        }
        lpUrlComponents->dwUserNameLength = userNameLength;
    } else if (lpUrlComponents->dwUserNameLength != 0) {
        lpUrlComponents->lpszUserName = userName;
        lpUrlComponents->dwUserNameLength = userNameLength;
    }

    if (lpUrlComponents->lpszPassword != NULL) {
        if (lpUrlComponents->dwPasswordLength > passwordLength) {
            memcpy((LPVOID)lpUrlComponents->lpszPassword,
                   (LPVOID)password,
                   passwordLength
                   );
            lpUrlComponents->lpszPassword[passwordLength] = '\0';
            if (dwFlags & ICU_DECODE) {
                UrlUnescapeInPlace(lpUrlComponents->lpszPassword, 0);
            }
        } else {
            ++passwordLength;
            copyFailure = TRUE;
        }
        lpUrlComponents->dwPasswordLength = passwordLength;
    } else if (lpUrlComponents->dwPasswordLength != 0) {
        lpUrlComponents->lpszPassword = password;
        lpUrlComponents->dwPasswordLength = passwordLength;
    }

    if (lpUrlComponents->lpszUrlPath != NULL) {
        if (lpUrlComponents->dwUrlPathLength > urlPathLength) {
            memcpy((LPVOID)lpUrlComponents->lpszUrlPath,
                   (LPVOID)urlPath,
                   urlPathLength
                   );
            lpUrlComponents->lpszUrlPath[urlPathLength] = '\0';
            if (dwFlags & ICU_DECODE) {
                UrlUnescapeInPlace(lpUrlComponents->lpszUrlPath, 0);
            }
            lpUrlComponents->dwUrlPathLength = urlPathLength;
        } else {
            ++urlPathLength;
            copyFailure = TRUE;
            lpUrlComponents->dwUrlPathLength = urlPathLength;
        }
    } else if (lpUrlComponents->dwUrlPathLength != 0) {
        lpUrlComponents->lpszUrlPath = urlPath;
        lpUrlComponents->dwUrlPathLength = urlPathLength;
    }

    if (lpUrlComponents->lpszExtraInfo != NULL) {
        if (lpUrlComponents->dwExtraInfoLength > extraInfoLength) {
            memcpy((LPVOID)lpUrlComponents->lpszExtraInfo,
                   (LPVOID)extraInfo,
                   extraInfoLength
                   );
            lpUrlComponents->lpszExtraInfo[extraInfoLength] = '\0';
            if (dwFlags & ICU_DECODE) {
                UrlUnescapeInPlace(lpUrlComponents->lpszExtraInfo, 0);
            }
        } else {
            ++extraInfoLength;
            copyFailure = TRUE;
        }
        lpUrlComponents->dwExtraInfoLength = extraInfoLength;
    } else if (lpUrlComponents->dwExtraInfoLength != 0) {
        lpUrlComponents->lpszExtraInfo = extraInfo;
        lpUrlComponents->dwExtraInfoLength = extraInfoLength;
    }

    //
    // we may have failed to copy one or more components because we didn't have
    // enough buffer space.
    //
    // N.B. Don't change error below here. If need be, move this test lower
    //

    if (copyFailure) {
        error = ERROR_INSUFFICIENT_BUFFER;
    }

    //
    // copy the scheme type
    //

    lpUrlComponents->nScheme = schemeType;

    //
    // convert 0 port (not in URL) to default value for scheme
    //

    if (nPort == INTERNET_INVALID_PORT_NUMBER && !havePort) {
        switch (schemeType) {
        case INTERNET_SCHEME_HTTP:
            nPort = INTERNET_DEFAULT_HTTP_PORT;
            break;

        case INTERNET_SCHEME_HTTPS:
            nPort = INTERNET_DEFAULT_HTTPS_PORT;
            break;
        }
    }
    lpUrlComponents->nPort = nPort;

crack_error:

    if (urlCopy != NULL) {
        DEL_STRING(urlCopy);
    }

quit:
    BOOL success = (error==ERROR_SUCCESS);

    if (!success) {
        DEBUG_ERROR(API, error);
        SetLastError(error);
    }

    DEBUG_LEAVE_API(success);
    return success;
}


INTERNETAPI
BOOL
WINAPI
WinHttpCreateUrlA(
    IN LPURL_COMPONENTSA lpUrlComponents,
    IN DWORD dwFlags,
    OUT LPSTR lpszUrl OPTIONAL,
    IN OUT LPDWORD lpdwUrlLength
    )

/*++

Routine Description:

    Creates an URL from its constituent parts

Arguments:

    lpUrlComponents - pointer to URL_COMPONENTS structure containing pointers
                      and lengths of components of interest

    dwFlags         - flags controlling function:

                        ICU_ESCAPE  - the components contain characters that
                                      must be escaped in the output URL

    lpszUrl         - pointer to buffer where output URL will be written

    lpdwUrlLength   - IN: number of bytes in lpszUrl buffer
                      OUT: if success, number of characters in lpszUrl, else
                           number of bytes required for buffer

Return Value:

    BOOL
        Success - URL written to lpszUrl

        Failure - call GetLastError() for more info

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "WinHttpCreateUrlA",
                     "%#x, %#x, %#x, %#x",
                     lpUrlComponents,
                     dwFlags,
                     lpszUrl,
                     lpdwUrlLength
                     ));

#if INET_DEBUG

    LPSTR lpszUrlOriginal = lpszUrl;

#endif

    DWORD error = ERROR_SUCCESS;
    LPSTR encodedUrlPath = NULL;
    LPSTR encodedExtraInfo = NULL;

    //
    // validate parameters
    //

    if (!ARGUMENT_PRESENT(lpszUrl)) {
        *lpdwUrlLength = 0;
    }

    //
    // allocate large buffers from heap
    //

    encodedUrlPath = (LPSTR)ALLOCATE_MEMORY(INTERNET_MAX_URL_LENGTH + 1);
    encodedExtraInfo = (LPSTR)ALLOCATE_MEMORY(INTERNET_MAX_URL_LENGTH + 1);
    if ((encodedUrlPath == NULL) || (encodedExtraInfo == NULL)) {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    //
    // if we get an exception, we return ERROR_INVALID_PARAMETER
    //
    
    __try {

        //
        // get the individual components to copy
        //

        LPSTR schemeName;
        DWORD schemeNameLength;
        DWORD schemeFlags;
        LPSTR hostName;
        DWORD hostNameLength;
        INTERNET_PORT nPort = 0;
        DWORD portLength;
        LPSTR userName;
        DWORD userNameLength;
        LPSTR password;
        DWORD passwordLength;
        LPSTR urlPath;
        DWORD urlPathLength;
        DWORD extraLength;
        DWORD encodedUrlPathLength;
        LPSTR extraInfo = NULL;
        DWORD extraInfoLength = 0;
        DWORD encodedExtraInfoLength;
        LPSTR schemeSep;
        DWORD schemeSepLength;
        INTERNET_SCHEME schemeType;
        INTERNET_PORT defaultPort;

        //
        // if the scheme name is absent then we use the default
        //

        schemeName = lpUrlComponents->lpszScheme;
        schemeType = lpUrlComponents->nScheme;

        if (schemeName == NULL) {
            if (schemeType == INTERNET_SCHEME_DEFAULT){
                schemeName = DEFAULT_URL_SCHEME_NAME;
                schemeNameLength = sizeof(DEFAULT_URL_SCHEME_NAME) - 1;
            }
            else {
                schemeName = MapUrlScheme(schemeType, &schemeNameLength);
            }
        } else {
            schemeNameLength = lpUrlComponents->dwSchemeLength;
            if (schemeNameLength == 0) {
                schemeNameLength = lstrlen(schemeName);
            }
        }

        if (schemeNameLength == 0)
        {
            error = ERROR_INVALID_PARAMETER;
            goto quit;
        }
        

        //
        // doesn't have to be a host name
        //

        hostName = lpUrlComponents->lpszHostName;
        portLength = 0;
        if (hostName != NULL) {
            hostNameLength = lpUrlComponents->dwHostNameLength;
            if (hostNameLength == 0) {
                hostNameLength = lstrlen(hostName);
            }

        //
        // if the port is default then we don't add it to the URL, else we need to
        // copy it as a string
        //
        // there won't be a port unless there's host.

            schemeType = MapUrlSchemeName(schemeName, schemeNameLength ? schemeNameLength : -1);
            switch (schemeType) {
            case INTERNET_SCHEME_HTTP:
                defaultPort = INTERNET_DEFAULT_HTTP_PORT;
                break;

            case INTERNET_SCHEME_HTTPS:
                defaultPort = INTERNET_DEFAULT_HTTPS_PORT;
                break;

            default:
                defaultPort = INTERNET_INVALID_PORT_NUMBER;
                break;
            }

            if (lpUrlComponents->nPort != defaultPort) {

                INTERNET_PORT divisor;

                nPort = lpUrlComponents->nPort;
                if (nPort) {
                    divisor = 10000;
                    portLength = 6; // max is 5 characters, plus 1 for ':'
                    while ((nPort / divisor) == 0) {
                        --portLength;
                        divisor /= 10;
                    }
                } else {
                    portLength = 2;         // port is ":0"
                }
            }
        } else {
            hostNameLength = 0;
        }


        //
        // doesn't have to be a user name
        //

        userName = lpUrlComponents->lpszUserName;
        if (userName != NULL) {
            userNameLength = lpUrlComponents->dwUserNameLength;
            if (userNameLength == 0) {
                userNameLength = lstrlen(userName);
            }
        } else {

            userNameLength = 0;
        }

        //
        // doesn't have to be a password
        //

        password = lpUrlComponents->lpszPassword;
        if (password != NULL) {
            passwordLength = lpUrlComponents->dwPasswordLength;
            if (passwordLength == 0) {
                passwordLength = lstrlen(password);
            }
        } else {

            passwordLength = 0;
        }

        //
        // but if there's a password without a user name, then its an error
        //

        if (password && !userName) {
            error = ERROR_INVALID_PARAMETER;
        } else {

            //
            // determine the scheme type for possible uses below
            //

            schemeFlags = 0;
            if (strnicmp(schemeName, "http", schemeNameLength) == 0) {
                schemeFlags = SCHEME_HTTP;
            } else if (strnicmp(schemeName, "ftp", schemeNameLength) == 0) {
                schemeFlags = SCHEME_FTP;
            } else if (strnicmp(schemeName, "gopher", schemeNameLength) == 0) {
                schemeFlags = SCHEME_GOPHER;
            }

            //
            // doesn't have to be an URL-path. Empty string is default
            //

            urlPath = lpUrlComponents->lpszUrlPath;
            if (urlPath != NULL) {
                urlPathLength = lpUrlComponents->dwUrlPathLength;
                if (urlPathLength == 0) {
                    urlPathLength = lstrlen(urlPath);
                }
                if ((*urlPath != '/') && (*urlPath != '\\')) {
                    extraLength = 1;
                } else {
                    extraLength = 0;
                }

                //
                // if requested, we will encode the URL-path
                //

                if (dwFlags & ICU_ESCAPE) {

                    //
                    // only encode the URL-path if it's a recognized scheme
                    //

                    if (schemeFlags != 0) {
                        encodedUrlPathLength = INTERNET_MAX_URL_LENGTH + 1;
                        error = EncodeUrlPath(NO_ENCODE_PATH_SEP,
                                              schemeFlags,
                                              urlPath,
                                              urlPathLength,
                                              &encodedUrlPath,
                                              &encodedUrlPathLength
                                              );
                        if (error == ERROR_SUCCESS) {
                            urlPath = encodedUrlPath;
                            urlPathLength = encodedUrlPathLength;
                        }
                    }
                }
            } else {
                urlPathLength = 0;
                extraLength = 0;
            }

            //
            // handle extra info if present
            //

            if (error == ERROR_SUCCESS) {
                extraInfo = lpUrlComponents->lpszExtraInfo;
                if (extraInfo != NULL) {
                    extraInfoLength = lpUrlComponents->dwExtraInfoLength;
                    if (extraInfoLength == 0) {
                        extraInfoLength = lstrlen(extraInfo);
                    }

                    //
                    // if requested, we will encode the extra info
                    //

                    if (dwFlags & ICU_ESCAPE) {

                        //
                        // only encode the extra info if it's a recognized scheme
                        //

                        if (schemeFlags != 0) {
                            encodedExtraInfoLength = INTERNET_MAX_URL_LENGTH + 1;
                            error = EncodeUrlPath(0,
                                                  schemeFlags,
                                                  extraInfo,
                                                  extraInfoLength,
                                                  &encodedExtraInfo,
                                                  &encodedExtraInfoLength
                                                  );
                            if (error == ERROR_SUCCESS) {
                                extraInfo = encodedExtraInfo;
                                extraInfoLength = encodedExtraInfoLength;
                            }
                        }
                    }
                } else {
                    extraInfoLength = 0;
                }
            }

            DWORD requiredSize = 0;

            if (error == ERROR_SUCCESS) {

                //
                // Determine if we have a protocol scheme that requires slashes
                //

                if (DoesSchemeRequireSlashes(schemeName, schemeNameLength, (hostName != NULL))) {
                    schemeSep = "://";
                    schemeSepLength = sizeof("://") - 1;
                } else {
                    schemeSep = ":";
                    schemeSepLength = sizeof(":") - 1;
                }

                //
                // ensure we have enough buffer space
                //

                requiredSize = schemeNameLength
                             + schemeSepLength
                             + hostNameLength
                             + portLength
                             + (userName ? userNameLength + 1 : 0) // +1 for '@'
                             + (password ? passwordLength + 1 : 0) // +1 for ':'
                             + urlPathLength
                             + extraLength
                             + extraInfoLength
                             + 1                                // +1 for '\0'
                             ;

                //
                // if there is enough buffer, copy the URL
                //

                if (*lpdwUrlLength >= requiredSize) {
                    memcpy((LPVOID)lpszUrl, (LPVOID)schemeName, schemeNameLength);
                    lpszUrl += schemeNameLength;
                    memcpy((LPVOID)lpszUrl, (LPVOID)schemeSep, schemeSepLength);
                    lpszUrl += schemeSepLength;
                    if (userName) {
                        memcpy((LPVOID)lpszUrl, (LPVOID)userName, userNameLength);
                        lpszUrl += userNameLength;
                        if (password) {
                            *lpszUrl++ = ':';
                            memcpy((LPVOID)lpszUrl, (LPVOID)password, passwordLength);
                            lpszUrl += passwordLength;
                        }
                        *lpszUrl++ = '@';
                    }
                    if (hostName) {
                        memcpy((LPVOID)lpszUrl, (LPVOID)hostName, hostNameLength);
                        lpszUrl += hostNameLength;

                        // We won't attach a port unless there's a host to go with it.
                        if (portLength) {
                            lpszUrl += wsprintf(lpszUrl, ":%d", nPort & 0xffff);
                        }

                    }
                    if (urlPath) {

                        //
                        // Only do extraLength if we've actually copied something
                        // after the scheme.
                        //

                        if (extraLength != 0 && (userName || hostName || portLength)) {
                            *lpszUrl++ = '/';
                        } else if (extraLength != 0) {
                            --requiredSize;
                        }
                        memcpy((LPVOID)lpszUrl, (LPVOID)urlPath, urlPathLength);
                        lpszUrl += urlPathLength;
                    } else if (extraLength != 0) {
                        --requiredSize;
                    }
                    if (extraInfo) {
                        memcpy((LPVOID)lpszUrl, (LPVOID)extraInfo, extraInfoLength);
                        lpszUrl += extraInfoLength;
                    }

                    //
                    // terminate string
                    //

                    *lpszUrl = '\0';

                    //
                    // -1 for terminating '\0'
                    //

                    --requiredSize;
                } else {

                    //
                    // not enough buffer space - just return the required buffer length
                    //

                    error = ERROR_INSUFFICIENT_BUFFER;
                }
            }

            //
            // update returned parameters
            //

            *lpdwUrlLength = requiredSize;
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        error = ERROR_INVALID_PARAMETER;
    }
    ENDEXCEPT
quit:

    //
    // clear up the buffers we allocated
    //


    if (encodedUrlPath != NULL) {
        FREE_MEMORY(encodedUrlPath);
    }
    if (encodedExtraInfo != NULL) {
        FREE_MEMORY(encodedExtraInfo);
    }

    BOOL success = (error==ERROR_SUCCESS);

    if (success) {

        DEBUG_PRINT_API(API,
                        INFO,
                        ("URL = %q\n",
                        lpszUrlOriginal
                        ));
    } else {

        DEBUG_ERROR(API, error);
        SetLastError(error);
    }

    DEBUG_LEAVE_API(success);
    return success;
}

//
//  ICUHrToWin32Error() is specifically for converting the return codes for
//  Url* APIs in shlwapi into win32 errors.
//  WARNING:  it should not be used for any other purpose.
//
DWORD
ICUHrToWin32Error(HRESULT hr)
{
    DWORD err = ERROR_INVALID_PARAMETER;
    switch(hr)
    {
    case E_OUTOFMEMORY:
        err = ERROR_NOT_ENOUGH_MEMORY;
        break;

    case E_POINTER:
        err = ERROR_INSUFFICIENT_BUFFER;
        break;

    case S_OK:
        err = ERROR_SUCCESS;
        break;

    default:
        break;
    }
    return err;
}


INTERNETAPI
BOOL
WINAPI
InternetCanonicalizeUrlA(
    IN LPCSTR lpszUrl,
    OUT LPSTR lpszBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Combines a relative URL with a base URL to form a new full URL.

Arguments:

    lpszUrl             - pointer to URL to be canonicalize
    lpszBuffer          - pointer to buffer where new URL is written
    lpdwBufferLength    - size of buffer on entry, length of new URL on exit
    dwFlags             - flags controlling operation

Return Value:

    BOOL                - TRUE if successful, FALSE if not

--*/

{
    DEBUG_ENTER((DBG_API,
                     Bool,
                     "InternetCanonicalizeUrlA",
                     "%q, %#x, %#x [%d], %#x",
                     lpszUrl,
                     lpszBuffer,
                     lpdwBufferLength,
                     lpdwBufferLength ? *lpdwBufferLength : 0,
                     dwFlags
                     ));

    HRESULT hr ;
    BOOL bRet = TRUE;;

    INET_ASSERT(lpszUrl);
    INET_ASSERT(lpszBuffer);
    INET_ASSERT(lpdwBufferLength && (*lpdwBufferLength > 0));

    //
    //  the flags for the Url* APIs in shlwapi should be the same
    //  except that NO_ENCODE is on by default.  so we need to flip it
    //
    dwFlags ^= ICU_NO_ENCODE;

    // Check for invalid parameters

    if (!lpszUrl || !lpszBuffer || !lpdwBufferLength || *lpdwBufferLength == 0 || IsBadWritePtr(lpszBuffer, *lpdwBufferLength*sizeof(CHAR)))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = UrlCanonicalizeA(lpszUrl, lpszBuffer,
                    lpdwBufferLength, dwFlags | URL_WININET_COMPATIBILITY);
    }

    if(FAILED(hr))
    {
        DWORD dw = ICUHrToWin32Error(hr);

        bRet = FALSE;

        DEBUG_ERROR(API, dw);

        SetLastError(dw);
    }

    DEBUG_LEAVE(bRet);

    return bRet;
}


INTERNETAPI
BOOL
WINAPI
InternetCombineUrlA(
    IN LPCSTR lpszBaseUrl,
    IN LPCSTR lpszRelativeUrl,
    OUT LPSTR lpszBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Combines a relative URL with a base URL to form a new full URL.

Arguments:

    lpszBaseUrl         - pointer to base URL
    lpszRelativeUrl     - pointer to relative URL
    lpszBuffer          - pointer to buffer where new URL is written
    lpdwBufferLength    - size of buffer on entry, length of new URL on exit
    dwFlags             - flags controlling operation

Return Value:

    BOOL                - TRUE if successful, FALSE if not

--*/

{
    DEBUG_ENTER((DBG_API,
                     Bool,
                     "InternetCombineUrlA",
                     "%q, %q, %#x, %#x [%d], %#x",
                     lpszBaseUrl,
                     lpszRelativeUrl,
                     lpszBuffer,
                     lpdwBufferLength,
                     lpdwBufferLength ? *lpdwBufferLength : 0,
                     dwFlags
                     ));

    HRESULT hr ;
    BOOL bRet;

    INET_ASSERT(lpszBaseUrl);
    INET_ASSERT(lpszRelativeUrl);
    INET_ASSERT(lpdwBufferLength);

    //
    //  the flags for the Url* APIs in shlwapi should be the same
    //  except that NO_ENCODE is on by default.  so we need to flip it
    //
    dwFlags ^= ICU_NO_ENCODE;

    // Check for invalid parameters

    if (!lpszBaseUrl || !lpszRelativeUrl || !lpdwBufferLength || (lpszBuffer && IsBadWritePtr(lpszBuffer, *lpdwBufferLength*sizeof(CHAR))))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = UrlCombineA(lpszBaseUrl, lpszRelativeUrl, lpszBuffer,
                    lpdwBufferLength, dwFlags | URL_WININET_COMPATIBILITY);
    }

    if(FAILED(hr))
    {
        DWORD dw = ICUHrToWin32Error(hr);

        bRet = FALSE;

        DEBUG_ERROR(API, dw);

        SetLastError(dw);
    }
    else
        bRet = TRUE;

    IF_DEBUG_CODE() {
        if (bRet) {
            DEBUG_PRINT_API(API,
                            INFO,
                            ("URL = %q\n",
                            lpszBuffer
                            ));
        }
    }

    DEBUG_LEAVE(bRet);

    return bRet;
}


INTERNETAPI
HINTERNET
WINAPI
InternetOpenA(
    IN LPCSTR lpszAgent,
    IN DWORD dwAccessType,
    IN LPCSTR lpszProxy OPTIONAL,
    IN LPCSTR lpszProxyBypass OPTIONAL,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Opens a root Internet handle from which all HINTERNET objects are derived

Arguments:

    lpszAgent       - name of the application making the request (arbitrary
                      identifying string). Used in "User-Agent" header when
                      communicating with HTTP servers, if the application does
                      not add a User-Agent header of its own

    dwAccessType    - type of access required. Can be

                        WINHTTP_ACCESS_TYPE_DEFAULT_PROXY
                            - Gets the configuration from the registry

                        WINHTTP_ACCESS_TYPE_NO_PROXY
                            - Requests are made directly to the nominated server

                        WINHTTP_ACCESS_TYPE_NAMED_PROXY
                            - Requests are made via the nominated proxy


    lpszProxy       - if INTERNET_OPEN_TYPE_PROXY, a list of proxy servers to
                      use

    lpszProxyBypass - if INTERNET_OPEN_TYPE_PROXY, a list of servers which we
                      will communicate with directly

    dwFlags         - flags to control the operation of this API or potentially
                      all APIs called on the handle generated by this API.
                      Currently supported are:

                        WINHTTP_FLAG_ASYNC - Not supported in WinHttpX v6.


Return Value:

    HINTERNET
        Success - handle of Internet object

        Failure - NULL. For more information, call GetLastError()

--*/

{
    PERF_INIT();

    DEBUG_ENTER((DBG_API,
                     Handle,
                     "InternetOpenA",
                     "%q, %s (%d), %q, %q, %#x",
                     lpszAgent,
                     InternetMapOpenType(dwAccessType),
                     dwAccessType,
                     lpszProxy,
                     lpszProxyBypass,
                     dwFlags
                     ));

    DWORD error;
    HINTERNET hInternet = NULL;

    if (!GlobalDataInitialized) {
        error = GlobalDataInitialize();
        if (error != ERROR_SUCCESS) {
            goto quit;
        }
    }

    //
    // validate parameters
    //

    if (!(   (dwAccessType == WINHTTP_ACCESS_TYPE_DEFAULT_PROXY)
          || (dwAccessType == WINHTTP_ACCESS_TYPE_NO_PROXY)
          || (   (dwAccessType == WINHTTP_ACCESS_TYPE_NAMED_PROXY)
              && (ARGUMENT_PRESENT(lpszProxy))
              && (*lpszProxy != '\0'))))
    {
        error = ERROR_INVALID_PARAMETER;
        goto quit;
    }

    if( 0 != (dwFlags & ~WINHTTP_OPEN_FLAGS_MASK))
    {
        error = ERROR_INVALID_PARAMETER;
        goto quit;
    }


    INTERNET_HANDLE_OBJECT * lpInternet;

    lpInternet = New INTERNET_HANDLE_OBJECT(lpszAgent,
                                            dwAccessType,
                                            (LPSTR)lpszProxy,
                                            (LPSTR)lpszProxyBypass,
                                            dwFlags
                                            );
    if (lpInternet == NULL) {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }
    error = lpInternet->GetStatus();
    if (error == ERROR_SUCCESS) {
        hInternet = (HINTERNET)lpInternet;

        //
        // success - don't return the object address, return the pseudo-handle
        // value we generated
        //

        hInternet = ((HANDLE_OBJECT *)hInternet)->GetPseudoHandle();
        
    } else {

        //
        // hack fix to stop InternetIndicateStatus (called from the handle
        // object destructor) blowing up if there is no handle object in the
        // thread info block. We can't call back anyway
        //

        LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();

        if (lpThreadInfo) {

            //
            // BUGBUG - incorrect handle value
            //

            _InternetSetObjectHandle(lpThreadInfo, lpInternet, lpInternet);
        }

        //
        // we failed during initialization. Kill the handle using Dereference()
        // (in order to stop the debug version complaining about the reference
        // count not being 0. Invalidate for same reason)
        //

        lpInternet->Invalidate();
        lpInternet->Dereference();

        INET_ASSERT(hInternet == NULL);

    }

quit:

    if (error != ERROR_SUCCESS) {

        DEBUG_ERROR(API, error);

        SetLastError(error);
    }

    DEBUG_LEAVE(hInternet);

    return hInternet;
}


INTERNETAPI
BOOL
WINAPI
WinHttpCloseHandle(
    IN HINTERNET hInternet
    )

/*++

Routine Description:

    Closes any open internet handle object

Arguments:

    hInternet   - handle of internet object to close

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. For more information call GetLastError()

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "WinHttpCloseHandle",
                     "%#x",
                     hInternet
                     ));

    PERF_ENTER(InternetCloseHandle);

    DWORD error;
    BOOL success = FALSE;
    HINTERNET hInternetMapped = NULL;

    if (!GlobalDataInitialized) {
        error = GlobalDataInitialize();
        if (error != ERROR_SUCCESS) {
            goto quit;
        }
    }

    //
    // map the handle. Don't invalidate it (_InternetCloseHandle() does this)
    //

    error = MapHandleToAddress(hInternet, (LPVOID *)&hInternetMapped, FALSE);
    if (error != ERROR_SUCCESS) {
        if (hInternetMapped == NULL) {

            //
            // the handle never existed or has been completely destroyed
            //

            DEBUG_PRINT(API,
                        ERROR,
                        ("Handle %#x is invalid\n",
                        hInternet
                        ));

            //
            // catch invalid handles - may help caller
            //

            DEBUG_BREAK(INVALID_HANDLES);

        } else {

            //
            // this handle is already being closed (it's invalidated). We only
            // need one InternetCloseHandle() operation to invalidate the handle.
            // All other threads will simply dereference the handle, and
            // eventually it will be destroyed
            //

            DereferenceObject((LPVOID)hInternetMapped);
        }
        goto quit;
    }

    //
    // the handle is not invalidated
    //

    HANDLE_OBJECT * pHandle;

    pHandle = (HANDLE_OBJECT *)hInternetMapped;

    DEBUG_PRINT(INET,
                INFO,
                ("handle %#x == %#x == %s\n",
                hInternet,
                hInternetMapped,
                InternetMapHandleType(pHandle->GetHandleType())
                ));

    //
    // clear the handle object last error variables
    //

    InternetClearLastError();

    //
    // decrement session count here rather than in destructor, since 
    // the session is ref-counted and there may still be outstanding
    // references from request/connect handles on async fsms.
    //
    if (pHandle->GetHandleType() == TypeInternetHandle)
    {
        InterlockedDecrement(&g_cSessionCount);
    }

    //
    // remove the reference added by MapHandleToAddress(), or the handle won't
    // be destroyed by _InternetCloseHandle()
    //

    DereferenceObject((LPVOID)hInternetMapped);

    //
    // use _InternetCloseHandle() to do the work
    //

    success = _InternetCloseHandle(hInternet);

quit:

    // SetLastError must be called after PERF_LEAVE !!!
    PERF_LEAVE(InternetCloseHandle);

    if (error != ERROR_SUCCESS) {
        DEBUG_ERROR(API, error);
        SetLastError(error);
    }

    DEBUG_LEAVE_API(success);

    return success;
}


BOOL
_InternetCloseHandle(
    IN HINTERNET hInternet
    )

/*++

Routine Description:

    Same as InternetCloseHandle() except does not clear out the last error text.
    Mainly for FTP

Arguments:

    hInternet   - handle of internet object to close

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. For more information call GetLastError()

--*/

{
    DEBUG_ENTER((DBG_INET,
                 Bool,
                 "_InternetCloseHandle",
                 "%#x",
                 hInternet
                 ));

    DWORD error;
    BOOL success;
    HINTERNET hInternetMapped = NULL;
    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();

    if (lpThreadInfo == NULL) {
        if (InDllCleanup) {
            error = ERROR_WINHTTP_SHUTDOWN;
        } else {

            INET_ASSERT(FALSE);

            error = ERROR_WINHTTP_INTERNAL_ERROR;
        }
        goto quit;
    }

    //
    // map the handle and invalidate it. This will cause any new requests with
    // the handle as a parameter to fail
    //

    error = MapHandleToAddress(hInternet, (LPVOID *)&hInternetMapped, TRUE);
    if (error != ERROR_SUCCESS) {
        if (hInternetMapped != NULL) {

            //
            // the handle is already being closed, or is already deleted
            //

            DereferenceObject((LPVOID)hInternetMapped);
        }

        //
        // since this is the only function that can invalidate a handle, if we
        // are here then the handle is just waiting for its refcount to go to
        // zero. We already removed the refcount we added above, so we're in
        // the clear
        //

        goto quit;
    }

    //
    // there may be an active socket operation. We close the socket to abort the
    // operation
    //

    ((INTERNET_HANDLE_OBJECT *)hInternetMapped)->AbortSocket();

    //
    // we need the parent handle - we will set this as the handle object being
    // processed by this thread. This is required for async worker threads (see
    // below)
    //

    HINTERNET hParent = NULL;
    HINTERNET hParentMapped;
    DWORD_PTR dwParentContext;

    hParentMapped = ((HANDLE_OBJECT *)hInternetMapped)->GetParent();
    if (hParentMapped != NULL) {
        hParent = ((HANDLE_OBJECT *)hParentMapped)->GetPseudoHandle();
        dwParentContext = ((HANDLE_OBJECT *)hParentMapped)->GetContext();
    }

    //
    // set the object handle in the per-thread data structure
    //

    _InternetSetObjectHandle(lpThreadInfo, hInternet, hInternetMapped);

    //
    // at this point, there should *always* be at least 2 references on the
    // handle - one added when the object was created, and one added by
    // MapHandleToAddress() above. If the object is still alive after the 2
    // dereferences, then it will be destroyed when the current owning thread
    // dereferences it
    //

    (void)DereferenceObject((LPVOID)hInternetMapped);
    error = DereferenceObject((LPVOID)hInternetMapped);

    //
    // now set the object to be the parent. This is necessary for e.g.
    // FtpGetFile() and async requests (where the async worker thread will make
    // an extra callback to deliver the results of the async request)
    //

    if (hParentMapped != NULL) {
        _InternetSetObjectHandle(lpThreadInfo, hParent, hParentMapped);
    }

    //
    // if the handle was still alive after dereferencing it then we will inform
    // the app that the close is pending
    //

quit:

    success = (error==ERROR_SUCCESS);
    if (!success) {
        SetLastError(error);
        DEBUG_ERROR(INET, error);
    }
    DEBUG_LEAVE(success);
    return success;
}


DWORD
_InternetCloseHandleNoContext(
    IN HINTERNET hInternet
    )

/*++

Routine Description:

    Same as _InternetCloseHandle() except does not change the per-thread info
    structure handle/context values

    BUGBUG - This should be handled via a parameter to _InternetCloseHandle(),
             but its close to shipping...

Arguments:

    hInternet   - handle of internet object to close

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_HANDLE

--*/

{
    DEBUG_ENTER((DBG_INET,
                 Bool,
                 "_InternetCloseHandleNoContext",
                 "%#x",
                 hInternet
                 ));

    DWORD error;
    HINTERNET hInternetMapped = NULL;

    //
    // map the handle and invalidate it. This will cause any new requests with
    // the handle as a parameter to fail
    //

    error = MapHandleToAddress(hInternet, (LPVOID *)&hInternetMapped, TRUE);
    if (error != ERROR_SUCCESS) {
        if (hInternetMapped != NULL) {

            //
            // the handle is already being closed, or is already deleted
            //

            DereferenceObject((LPVOID)hInternetMapped);
        }

        //
        // since this is the only function that can invalidate a handle, if we
        // are here then the handle is just waiting for its refcount to go to
        // zero. We already removed the refcount we added above, so we're in
        // the clear
        //

        goto quit;
    }

    //
    // there may be an active socket operation. We close the socket to abort the
    // operation
    //

    ((INTERNET_HANDLE_OBJECT *)hInternetMapped)->AbortSocket();

    //
    // at this point, there should *always* be at least 2 references on the
    // handle - one added when the object was created, and one added by
    // MapHandleToAddress() above. If the object is still alive after the 2
    // dereferences, then it will be destroyed when the current owning thread
    // dereferences it
    //

    (void)DereferenceObject((LPVOID)hInternetMapped);
    error = DereferenceObject((LPVOID)hInternetMapped);

quit:

    DEBUG_LEAVE(error);

    return error;
}



INTERNETAPI
HINTERNET
WINAPI
InternetConnectA(
    IN HINTERNET hInternet,
    IN LPCSTR lpszServerName,
    IN INTERNET_PORT nServerPort,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    Opens a connection with a server, logging-on the user in the process.

Arguments:

    hInternet       - Internet handle, returned by InternetOpen()

    lpszServerName  - name of server with which to connect

    nServerPort     - port at which server listens

    dwFlags         - protocol-specific flags. The following are defined:
                        - INTERNET_FLAG_KEEP_CONNECTION (HTTP)
                        - WINHTTP_FLAG_SECURE (HTTP)

    dwContext       - application-supplied value used to identify this
                      request in callbacks
                    - ignored in WinHttp

Return Value:

    HINTERNET
        Success - address of a new handle object

        Failure - NULL. Call GetLastError() for more info

--*/

{
    DEBUG_ENTER((DBG_API,
                     Handle,
                     "InternetConnectA",
                     "%#x, %q, %d, %#08x, %#x",
                     hInternet,
                     lpszServerName,
                     nServerPort,
                     dwFlags,
                     dwContext
                     ));

    HINTERNET connectHandle = NULL;
    HINTERNET hInternetMapped = NULL;

    LPINTERNET_THREAD_INFO lpThreadInfo;

    INTERNET_CONNECT_HANDLE_OBJECT * pConnect = NULL;

    BOOL bIsWorker = FALSE;
    BOOL bNonNestedAsync = FALSE;
    BOOL isAsync;

    DWORD error = ERROR_SUCCESS;

    UNREFERENCED_PARAMETER(dwContext);

    if (!GlobalDataInitialized) {
        error = ERROR_WINHTTP_NOT_INITIALIZED;
        goto done;
    }

    //
    // get the per-thread info block
    //

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto done;
    }

    _InternetIncNestingCount();
    bIsWorker = lpThreadInfo->IsAsyncWorkerThread;
    bNonNestedAsync = bIsWorker && (lpThreadInfo->NestedRequests == 1);

    //
    // handle/refcount munging:
    //
    //  sync:
    //      map hInternet on input (+1 ref)
    //      generate connect handle (1 ref)
    //      if failure && !connect handle
    //          close connect handle (0 refs: delete)
    //      if success
    //          deref hInternet (-1 ref)
    //      else if going async
    //          ref connect handle (2 refs)
    //
    //  async:
    //      hInternet is mapped connect handle (2 refs)
    //      get real hInternet from connect handle parent (2 refs (e.g.))
    //      deref connect handle (1 ref)
    //      if failure
    //          close connect handle (0 refs: delete)
    //      deref open handle (-1 ref)
    //
    // N.B. the final deref of the *indicated* handle on async callback will
    // happen in the async code
    //

    if (bNonNestedAsync) {
        connectHandle = hInternet;
        hInternetMapped = ((HANDLE_OBJECT *)connectHandle)->GetParent();
        hInternet = ((HANDLE_OBJECT *)hInternetMapped)->GetPseudoHandle();
    } else {
        error = MapHandleToAddress(hInternet, (LPVOID *)&hInternetMapped, FALSE);
        if ((error != ERROR_SUCCESS) && (hInternetMapped == NULL)) {
            goto quit;
        }

        //
        // set the info and clear the last error info
        //

        _InternetSetObjectHandle(lpThreadInfo, hInternet, hInternetMapped);
        _InternetClearLastError(lpThreadInfo);

        //
        // quit now if the handle object is invalidated
        //

        if (error != ERROR_SUCCESS) {
            goto quit;
        }

        //
        // validate the handle & discover sync/async
        //

        error = RIsHandleLocal(hInternetMapped,
                               NULL,
                               &isAsync,
                               TypeInternetHandle
                               );
        if (error != ERROR_SUCCESS) {
            goto quit;
        }

        //
        // we allow all valid flags to be passed in
        //

        if ((dwFlags & ~WINHTTP_CONNECT_FLAGS_MASK)
            || (lpszServerName == NULL)
            || (*lpszServerName == '\0')) 
        {
            error = ERROR_INVALID_PARAMETER;
            goto quit;
        }
    }

    //
    // validate arguments if we're not in the async thread context, in which
    // case we did this when the original request was made
    //

    if (bNonNestedAsync)
    {
        pConnect = (INTERNET_CONNECT_HANDLE_OBJECT *)connectHandle;
    }
    else
    {
        //
        // app thread or in async worker thread but being called from another
        // async API, such as InternetOpenUrl()
        //

        INET_ASSERT(connectHandle == NULL);
        INET_ASSERT(error == ERROR_SUCCESS);
           
        error = RMakeInternetConnectObjectHandle(
                    hInternetMapped,
                    &connectHandle,
                    (LPSTR) lpszServerName,
                    nServerPort,
                    dwFlags
                    );
        if (error != ERROR_SUCCESS) {
            goto quit;
        }

        //
        // this new handle will be used in callbacks
        //

        _InternetSetObjectHandle(lpThreadInfo,
                                 ((HANDLE_OBJECT *)connectHandle)->GetPseudoHandle(),
                                 connectHandle
                                 );

        //
        // based on whether we have been asked to perform async I/O AND we are not
        // in an async worker thread context AND the request is to connect with an
        // FTP service (currently only FTP because this request performs network
        // I/O - gopher and HTTP just allocate & fill in memory) AND there is a
        // valid context value, we will queue the async request, or execute the
        // request synchronously
        //

        pConnect = (INTERNET_CONNECT_HANDLE_OBJECT *)connectHandle;
    }
    

    INET_ASSERT(error == ERROR_SUCCESS);

quit:

    _InternetDecNestingCount(1);


done:

    if (error == ERROR_SUCCESS) {

        //
        // success - return generated pseudo-handle
        //

        connectHandle = ((HANDLE_OBJECT *)connectHandle)->GetPseudoHandle();

    } else {
        if (bNonNestedAsync
            && (/*((HANDLE_OBJECT *)connectHandle)->Dereference()
                ||*/ ((HANDLE_OBJECT *)connectHandle)->IsInvalidated())) {
            error = ERROR_WINHTTP_OPERATION_CANCELLED;
        }

        //
        // if we are not pending an async request but we created a handle object
        // then close it
        //

        if ((error != ERROR_IO_PENDING) && (connectHandle != NULL)) {

            //
            // use _InternetCloseHandle() to close the handle: it doesn't clear
            // out the last error text, so that an app can find out what the
            // server sent us in the event of an FTP login failure
            //


            if (bNonNestedAsync) {

                //
                // this handle deref'd at async completion
                //

                hInternetMapped = NULL;
            }
            else
            {
                _InternetCloseHandle(((HANDLE_OBJECT *)connectHandle)->GetPseudoHandle());
            }
        }
        connectHandle = NULL;
    }
    if (hInternetMapped != NULL) {
        DereferenceObject((LPVOID)hInternetMapped);
    }
    if (error != ERROR_SUCCESS) {
        DEBUG_ERROR(API, error);
        SetLastError(error);
    }
    DEBUG_LEAVE(connectHandle);
    return connectHandle;
}



INTERNETAPI
HINTERNET
WINAPI
InternetOpenUrlA(
    IN HINTERNET hInternet,
    IN LPCSTR lpszUrl,
    IN LPCSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )
{
    // this is dead code
    UNREFERENCED_PARAMETER(hInternet);
    UNREFERENCED_PARAMETER(lpszUrl);
    UNREFERENCED_PARAMETER(lpszHeaders);
    UNREFERENCED_PARAMETER(dwHeadersLength);
    UNREFERENCED_PARAMETER(dwFlags);
    UNREFERENCED_PARAMETER(dwContext);

    return FALSE;
}



INTERNETAPI
BOOL
WINAPI
WinHttpReadData(
    IN HINTERNET hFile,
    IN LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToRead,
    OUT LPDWORD lpdwNumberOfBytesRead
    )

/*++

Routine Description:

    This functions reads the next block of data from the file object.

Arguments:

    hFile                   - handle returned from Open function

    lpBuffer                - pointer to caller's buffer

    dwNumberOfBytesToRead   - size of lpBuffer in BYTEs

    lpdwNumberOfBytesRead   - returned number of bytes read into lpBuffer

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError() for more info

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "WinHttpReadData",
                     "%#x, %#x, %d, %#x",
                     hFile,
                     lpBuffer,
                     dwNumberOfBytesToRead,
                     lpdwNumberOfBytesRead
                     ));

    LPINTERNET_THREAD_INFO lpThreadInfo;
    DWORD nestingLevel = 0;
    DWORD error;
    BOOL success = FALSE;
    HINTERNET hFileMapped = NULL;
    DWORD bytesRead = 0;
    BOOL bEndRead = TRUE;
    BOOL b2ndDeref = FALSE;
    BOOL isAsync = FALSE;

    if (!GlobalDataInitialized)
    {
        error = ERROR_WINHTTP_NOT_INITIALIZED;
        goto done;
    }

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL)
    {
        INET_ASSERT(FALSE);
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto done;
    }

    //INET_ASSERT(lpThreadInfo->Fsm == NULL);

    _InternetIncNestingCount();
    nestingLevel = 1;

    error = MapHandleToAddress(hFile, (LPVOID *)&hFileMapped, FALSE);
    if ((error != ERROR_SUCCESS) && (hFileMapped == NULL))
    {
        goto quit;
    }

    // set the handle, and last-error info in the per-thread data block
    // before we go any further. This allows us to return a status in the async
    // case, even if the handle has been closed

    if (!lpThreadInfo->IsAsyncWorkerThread)
    {
        PERF_LOG(PE_CLIENT_REQUEST_START,
                 AR_INTERNET_READ_FILE,
                 lpThreadInfo->ThreadId,
                 hFile
                 );
    }

    _InternetSetObjectHandle(lpThreadInfo, hFile, hFileMapped);
    _InternetClearLastError(lpThreadInfo);

    // if MapHandleToAddress() returned a non-NULL object address, but also an
    // error status, then the handle is being closed - quit
    if (error != ERROR_SUCCESS)
    {
        goto quit;
    }

    error = RIsHandleLocal(hFileMapped, NULL, &isAsync, TypeHttpRequestHandle);
    if (error != ERROR_SUCCESS)
    {
        INET_ASSERT(FALSE);
        goto quit;
    }

    // validate parameters
    if (!lpThreadInfo->IsAsyncWorkerThread)
    {
        if (lpdwNumberOfBytesRead)
        {
            error = ProbeAndSetDword(lpdwNumberOfBytesRead, 0);
            if (error != ERROR_SUCCESS)
            {
                goto quit;
            }
        }
        error = ProbeWriteBuffer(lpBuffer, dwNumberOfBytesToRead);
        if (error != ERROR_SUCCESS)
        {
            goto quit;
        }

        // *lpdwNumberOfBytesRead = 0;

    } // end if (!lpThreadInfo->IsAsyncWorkerThread)


    INET_ASSERT(error == ERROR_SUCCESS);

    // just call the underlying API: return whatever it returns, and let it
    // handle setting the last error

    CFsm_ReadFile *pFsm;

    pFsm = New CFsm_ReadFile(lpBuffer,
                             dwNumberOfBytesToRead,
                             /*lpdwNumberOfBytesRead*/ NULL
                             );

    HTTP_REQUEST_HANDLE_OBJECT *pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)hFileMapped;
    if (pFsm != NULL)
    {
        if (isAsync)
        {
            pRequest->Reference();
            b2ndDeref = TRUE;
        }

        error = StartFsmChain(pFsm, pRequest, FALSE, isAsync);

        //if error == ERROR_IO_PENDING, DO NOT TOUCH this fsm or any pRequest contents.
        //another async thread could be operating on this fsm.
    }
    else
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
    }

    bEndRead = FALSE;

    if (error == ERROR_SUCCESS)
    {
        bytesRead = pRequest->GetBytesRead();

        success = TRUE;
        goto sync_success;
    }
    else
    {
        success = FALSE;
    }
    
quit:

    _InternetDecNestingCount(nestingLevel);

    if (bEndRead)
    {
        //
        // if handleType is not HttpRequest or File then we are making this
        // request in the context of an uninterruptable async worker thread.
        // HTTP and file requests use the normal mechanism. In the case of non-
        // HTTP and file requests, we need to treat the request as if it were
        // sync and deref the handle
        //

        ReadFile_End(!lpThreadInfo->IsAsyncWorkerThread,
                     success,
                     hFileMapped,
                     bytesRead,
                     lpBuffer,
                     dwNumberOfBytesToRead,
                     lpdwNumberOfBytesRead
                     );
    }

    if (lpThreadInfo && !lpThreadInfo->IsAsyncWorkerThread)
    {
        PERF_LOG(PE_CLIENT_REQUEST_END,
                 AR_INTERNET_READ_FILE,
                 bytesRead,
                 lpThreadInfo->ThreadId,
                 hFile
                 );

    }

done:

    if (b2ndDeref)
    {
        // So that we have a refcount on the object going into the callback.
        INET_ASSERT (isAsync);
        DereferenceObject((LPVOID)hFileMapped);
    }
    
    // if error is not ERROR_SUCCESS then this function returning the error,
    // otherwise the error has already been set by the API we called,
    // irrespective of the value of success
    if (error != ERROR_SUCCESS)
    {
        if (error == ERROR_IO_PENDING)
        {
            SetLastError(ERROR_SUCCESS);
            success = TRUE;
        }
        else
        {
            DEBUG_ERROR(API, error);

            SetLastError(error);
            success = FALSE;
        }
    }

    DEBUG_LEAVE_API(success);
    return success;
    
sync_success:

    if (isAsync)
    {
        InternetIndicateStatus(WINHTTP_CALLBACK_STATUS_READ_COMPLETE,
                               lpBuffer,
                               bytesRead
                               );
    }

    if (lpdwNumberOfBytesRead)
    {
        *lpdwNumberOfBytesRead = bytesRead;
    }
    
    goto quit;
}


PRIVATE
VOID
ReadFile_End(
    IN BOOL bDeref,
    IN BOOL bSuccess,
    IN HINTERNET hFileMapped,
    IN DWORD dwBytesRead,
    IN LPVOID lpBuffer OPTIONAL,
    IN DWORD dwNumberOfBytesToRead,
    OUT LPDWORD lpdwNumberOfBytesRead OPTIONAL
    )

/*++

Routine Description:

    Common end-of-read processing:

        - update bytes read parameter
        - dump data if logging & API data requested
        - dereference handle if not async request

Arguments:

    bDeref                  - TRUE if handle should be dereferenced (should be
                              FALSE for async request)

    bSuccess                - TRUE if Read completed successfully

    hFileMapped             - mapped file handle

    dwBytesRead             - number of bytes read

    lpBuffer                - into this buffer

    dwNumberOfBytesToRead   - originally requested bytes to read

    lpdwNumberOfBytesRead   - where bytes read is stored

Return Value:

    None.

--*/

{
    UNREFERENCED_PARAMETER(lpBuffer);
    DEBUG_ENTER((DBG_INET,
                 None,
                 "ReadFile_End",
                 "%B, %B, %#x, %d, %#x, %d, %#x",
                 bDeref,
                 bSuccess,
                 hFileMapped,
                 dwBytesRead,
                 lpBuffer,
                 dwNumberOfBytesToRead,
                 lpdwNumberOfBytesRead
                 ));

    if (bSuccess) {

        //
        // update the amount of immediate data available only if we succeeded
        //

        ((INTERNET_HANDLE_OBJECT *)hFileMapped)->ReduceAvailableDataLength(dwBytesRead);

        if (lpdwNumberOfBytesRead != NULL) {
            *lpdwNumberOfBytesRead = dwBytesRead;

            DEBUG_PRINT(API,
                        INFO,
                        ("*lpdwNumberOfBytesRead = %d\n",
                        *lpdwNumberOfBytesRead
                        ));

            //
            // dump API data only if requested
            //

            IF_DEBUG_CONTROL(DUMP_API_DATA) {
                DEBUG_DUMP_API(API,
                               "Received data:\n",
                               lpBuffer,
                               *lpdwNumberOfBytesRead
                               );
            }

            /* Likely redundant:
            TRACE_DUMP_API_IF_REQUEST(API,
                           "Received data:\n",
                           lpBuffer,
                           *lpdwNumberOfBytesRead,
                            (HANDLE_OBJECT *)(hFileMapped)
                           );
           */

        }
        if (dwBytesRead < dwNumberOfBytesToRead) {

            DEBUG_PRINT(API,
                        INFO,
                        ("(!) bytes read (%d) < bytes requested (%d)\n",
                        dwBytesRead,
                        dwNumberOfBytesToRead
                        ));

        }
    }

    //
    // if async request, handle will be deref'd after REQUEST_COMPLETE callback
    // is delivered
    //

    if (bDeref && (hFileMapped != NULL)) {
        DereferenceObject((LPVOID)hFileMapped);
    }

    PERF_LOG(PE_CLIENT_REQUEST_END,
             AR_INTERNET_READ_FILE,
             dwBytesRead,
             0,
             (!bDeref && hFileMapped) ? ((INTERNET_HANDLE_OBJECT *)hFileMapped)->GetPseudoHandle() : NULL
             );

    DEBUG_LEAVE(0);
}




DWORD
CFsm_ReadFile::RunSM(
    IN CFsm * Fsm
    )
{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "CFsm_ReadFile::RunSM",
                 "%#x",
                 Fsm
                 ));

    DWORD error;
    CFsm_ReadFile * stateMachine = (CFsm_ReadFile *)Fsm;

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = ReadFile_Fsm(stateMachine);
        break;

    case FSM_STATE_ERROR:
        error = Fsm->GetError();
        INET_ASSERT (error == ERROR_WINHTTP_OPERATION_CANCELLED);
        Fsm->SetDone();
        break;

    default:
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_WINHTTP_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


PRIVATE
DWORD
ReadFile_Fsm(
    IN CFsm_ReadFile * Fsm
    )
{
    DEBUG_ENTER((DBG_INET,
                 Dword,
                 "ReadFile_Fsm",
                 "%#x",
                 Fsm
                 ));

    CFsm_ReadFile & fsm = *Fsm;
    DWORD error = fsm.GetError();

    if ((error == ERROR_SUCCESS) && (fsm.GetState() == FSM_STATE_INIT)) {
        error = HttpReadData(fsm.GetMappedHandle(),
                             fsm.m_lpBuffer,
                             fsm.m_dwNumberOfBytesToRead,
                             &fsm.m_dwBytesRead,
                             0
                             );
        if (error == ERROR_IO_PENDING) {
            goto quit;
        }

    // the operation has gone sync, let's store the Bytes read in the request handle, otherwise we will
    // lose it as the fsm will be deleted before returning to the API call.
    HTTP_REQUEST_HANDLE_OBJECT* pRequest =
        (HTTP_REQUEST_HANDLE_OBJECT*) fsm.GetMappedHandle();

    pRequest->SetBytesRead(fsm.m_dwBytesRead);
    }
    ReadFile_End(!fsm.GetThreadInfo()->IsAsyncWorkerThread,
                 (error == ERROR_SUCCESS) ? TRUE : FALSE,
                 fsm.GetMappedHandle(),
                 fsm.m_dwBytesRead,
                 fsm.m_lpBuffer,
                 fsm.m_dwNumberOfBytesToRead,
                 fsm.m_lpdwNumberOfBytesRead
                 );
    fsm.SetDone();

quit:

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_ReadFileEx::RunSM(
    IN CFsm * Fsm
    )
{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "CFsm_ReadFileEx::RunSM",
                 "%#x",
                 Fsm
                 ));

    DWORD error;
    CFsm_ReadFileEx * stateMachine = (CFsm_ReadFileEx *)Fsm;

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = ReadFileEx_Fsm(stateMachine);
        break;

    case FSM_STATE_ERROR:
        error = Fsm->GetError();
        INET_ASSERT (error == ERROR_WINHTTP_OPERATION_CANCELLED);
        Fsm->SetDone();
        break;

    default:
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_WINHTTP_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


PRIVATE
DWORD
ReadFileEx_Fsm(
    IN CFsm_ReadFileEx * Fsm
    )
{
    DEBUG_ENTER((DBG_INET,
                 Dword,
                 "ReadFileEx_Fsm",
                 "%#x",
                 Fsm
                 ));

    CFsm_ReadFileEx & fsm = *Fsm;
    DWORD error = fsm.GetError();

    if ((error == ERROR_SUCCESS) && (fsm.GetState() == FSM_STATE_INIT)) {
        fsm.m_dwNumberOfBytesToRead = fsm.m_lpBuffersOut->dwBufferLength;
        error = HttpReadData(fsm.GetMappedHandle(),
                             fsm.m_lpBuffersOut->lpvBuffer,
                             fsm.m_dwNumberOfBytesToRead,
                             &fsm.m_dwBytesRead,
                             (fsm.m_dwFlags & IRF_NO_WAIT)
                               ? SF_NO_WAIT
                               : 0
                             );
        if (error == ERROR_IO_PENDING) {
            goto quit;
        }
    }

    //
    // if we are asynchronously completing a no-wait read then we don't update
    // any app parameters - we simply return the indication that we completed.
    // The app will then make another no-wait read to get the data
    //

    BOOL bNoOutput;

    bNoOutput = ((fsm.m_dwFlags & IRF_NO_WAIT)
                && fsm.GetThreadInfo()->IsAsyncWorkerThread)
                    ? TRUE
                    : FALSE;

    ReadFile_End(!fsm.GetThreadInfo()->IsAsyncWorkerThread,
                 (error == ERROR_SUCCESS) ? TRUE : FALSE,
                 fsm.GetMappedHandle(),
                 bNoOutput ? 0    : fsm.m_dwBytesRead,
                 bNoOutput ? NULL : fsm.m_lpBuffersOut->lpvBuffer,
                 bNoOutput ? 0    : fsm.m_dwNumberOfBytesToRead,
                 bNoOutput ? NULL : &fsm.m_lpBuffersOut->dwBufferLength
                 );
    fsm.SetDone();

quit:

    DEBUG_LEAVE(error);

    return error;
}



INTERNETAPI
BOOL
WINAPI
WinHttpWriteData(
    IN HINTERNET hFile,
    IN LPCVOID lpBuffer,
    IN DWORD dwNumberOfBytesToWrite,
    OUT LPDWORD lpdwNumberOfBytesWritten
    )

/*++

Routine Description:

    This function write next block of data to the internet file. Currently it
    supports the following protocol data:

        HttpWriteFile

Arguments:

    hFile                       - handle that was obtained by OpenFile Call

    lpBuffer                    - pointer to the data buffer

    dwNumberOfBytesToWrite      - number of bytes in the above buffer

    lpdwNumberOfBytesWritten    -  pointer to a DWORD where the number of bytes
                                   of data actually written is returned

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError() for more info

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "WinHttpWriteData",
                     "%#x, %#x, %d, %#x",
                     hFile,
                     lpBuffer,
                     dwNumberOfBytesToWrite,
                     lpdwNumberOfBytesWritten
                     ));

    LPINTERNET_THREAD_INFO lpThreadInfo;
    DWORD nestingLevel = 0;
    DWORD error;
    BOOL success = FALSE;
    BOOL fNeedDeref = TRUE;
    HINTERNET hFileMapped = NULL;

    if (!GlobalDataInitialized)
    {
        error = ERROR_WINHTTP_NOT_INITIALIZED;
        goto done;
    }

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL)
    {

        //informational INET_ASSERT(FALSE);

        error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto done;
    }

    _InternetIncNestingCount();
    nestingLevel = 1;

    error = MapHandleToAddress(hFile, (LPVOID *)&hFileMapped, FALSE);
    if ((error != ERROR_SUCCESS) && (hFileMapped == NULL))
    {
        goto quit;
    }

    //
    // set the handle, and last-error info in the per-thread data block
    // before we go any further. This allows us to return a status in the async
    // case, even if the handle has been closed
    //

    _InternetSetObjectHandle(lpThreadInfo, hFile, hFileMapped);
    _InternetClearLastError(lpThreadInfo);

    //
    // if MapHandleToAddress() returned a non-NULL object address, but also an
    // error status, then the handle is being closed - quit
    //

    if (error != ERROR_SUCCESS)
    {
        goto quit;
    }

    // validate handle and its type
    BOOL isAsync;
    error = RIsHandleLocal(hFileMapped, NULL, &isAsync, TypeHttpRequestHandle);
    if (error != ERROR_SUCCESS)
    {
        INET_ASSERT(FALSE);
        goto quit;
    }

    //
    // validate parameters - write length cannot be 0
    //

    if (!lpThreadInfo->IsAsyncWorkerThread)
    {
        if (dwNumberOfBytesToWrite != 0)
        {
            error = ProbeReadBuffer((LPVOID)lpBuffer, dwNumberOfBytesToWrite);
            if (error == ERROR_SUCCESS)
            {
                if (lpdwNumberOfBytesWritten)
                {
                    error = ProbeAndSetDword(lpdwNumberOfBytesWritten, 0);
                }
            }
        }
        else
        {
            error = ERROR_INVALID_PARAMETER;
        }         

        if (error != ERROR_SUCCESS)
        {
            goto quit;
        }
    }


    // # 62953
    // If the authentication state of the handle is Negotiate,
    // don't submit data to the server but return success.
    // ** Added test for NTLM or Negotiate - Adriaanc.
    //
    
    HTTP_REQUEST_HANDLE_OBJECT *pRequest;
    pRequest = (HTTP_REQUEST_HANDLE_OBJECT*) hFileMapped;

    DWORD dwBytesWritten = 0;
    if (pRequest->GetAuthState() == AUTHSTATE_NEGOTIATE)
    {
        dwBytesWritten = dwNumberOfBytesToWrite;
        error = ERROR_SUCCESS;
        success = TRUE;
        goto sync_success;
    }
        

    INET_ASSERT(error == ERROR_SUCCESS);

    CFsm_HttpWriteData *pFsm = New CFsm_HttpWriteData((LPVOID)lpBuffer,
                                                      dwNumberOfBytesToWrite,
                                                      NULL/*lpdwNumberOfBytesWritten*/,
                                                      0,
                                                      pRequest
                                                      );

    if (pFsm != NULL)
    {
        HTTP_REQUEST_HANDLE_OBJECT *pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)hFileMapped;

        error = StartFsmChain(pFsm, pRequest, FALSE, isAsync);

        //if error == ERROR_IO_PENDING, DO NOT TOUCH this fsm or any pRequest contents.
        //another async thread could be operating on this fsm/request.
    }
    else
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Don't Derefrence if we're going pending cause the FSM will do
    //  it for us.
    //

    if ( error == ERROR_IO_PENDING )
    {
        fNeedDeref = FALSE;
    }

    if (error == ERROR_SUCCESS)
    {
        dwBytesWritten = pRequest->GetBytesWritten();
        success = TRUE;
        goto sync_success;
    }
    else
    {
        success = FALSE;
    }
    
quit:

    if (hFileMapped != NULL && fNeedDeref)
    {
        DereferenceObject((LPVOID)hFileMapped);
    }

    _InternetDecNestingCount(nestingLevel);;

done:

    if (error != ERROR_SUCCESS)
    {
        if (error == ERROR_IO_PENDING)
        {
            SetLastError(ERROR_SUCCESS);
            success = TRUE;
        }
        else
        {
            DEBUG_ERROR(API, error);
        
            SetLastError(error);
        }
    }

    DEBUG_LEAVE_API(success);

    return success;

sync_success:

    if (isAsync)
    {
        DWORD dwResult = dwBytesWritten;
        InternetIndicateStatus(WINHTTP_CALLBACK_STATUS_WRITE_COMPLETE,
                               &dwResult,
                               sizeof (DWORD)
                               );
    }

    if (lpdwNumberOfBytesWritten)
    {
        *lpdwNumberOfBytesWritten = dwBytesWritten;
    }
    
    goto quit;
}



INTERNETAPI
BOOL
WINAPI
WinHttpQueryDataAvailable(
    IN HINTERNET hFile,
    OUT LPDWORD lpdwNumberOfBytesAvailable
    )

/*++

Routine Description:

    Determines the amount of data currently available to be read on the handle

Arguments:

    hFile                       - handle of internet object

    lpdwNumberOfBytesAvailable  - pointer to returned bytes available

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError() for more info

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "WinHttpQueryDataAvailable",
                     "%#x, %#x, %#x",
                     hFile,
                     lpdwNumberOfBytesAvailable
                     ));

    BOOL success;
    DWORD error;
    LPINTERNET_THREAD_INFO lpThreadInfo = NULL;
    HINTERNET hFileMapped = NULL;
    BOOL bDeref = TRUE;
    DWORD dwNumBytes = (DWORD)-1;

    if (!GlobalDataInitialized)
    {
        error = ERROR_WINHTTP_NOT_INITIALIZED;
        bDeref = FALSE;
        goto quit;
    }

    //
    // get the per-thread info block
    //

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL)
    {

        //informational INET_ASSERT(FALSE);

        error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto quit;
    }

    //INET_ASSERT(lpThreadInfo->Fsm == NULL);

    PERF_LOG(PE_CLIENT_REQUEST_START,
             AR_INTERNET_QUERY_DATA_AVAILABLE,
             lpThreadInfo->ThreadId,
             hFile
             );

    //
    // validate parameters
    //

    error = MapHandleToAddress(hFile, &hFileMapped, FALSE);
    if ((error != ERROR_SUCCESS) && (hFileMapped == NULL))
    {
        goto quit;
    }

    INET_ASSERT(hFileMapped);

    //
    // set the handle values in the per-thread info block (this API
    // can't return extended error info, so we don't care about it)
    //

    _InternetSetObjectHandle(lpThreadInfo, hFile, hFileMapped);

    //
    // if the handle is invalid, quit now
    //

    if (error != ERROR_SUCCESS)
    {
        goto quit;
    }

    //
    // validate rest of parameters
    //

    if (lpdwNumberOfBytesAvailable)
    {
        error = ProbeAndSetDword(lpdwNumberOfBytesAvailable, 0);
        if (error != ERROR_SUCCESS)
        {
            goto quit;
        }
    }

    BOOL isAsync;
    error = RIsHandleLocal(hFileMapped, NULL, &isAsync, TypeHttpRequestHandle);
    if (error != ERROR_SUCCESS)
    {
        goto quit;
    }

    //
    // since the async worker thread doesn't come back through this API, the
    // following test is sufficient. Note that we only go async if there is
    // no data currently available on the handle
    //

    BOOL dataAvailable;
    dataAvailable = ((INTERNET_HANDLE_OBJECT *)hFileMapped)->IsDataAvailable();

    BOOL eof;
    eof = ((INTERNET_HANDLE_OBJECT *)hFileMapped)->IsEndOfFile();

    DWORD available;

    if (dataAvailable || eof)
    {
        available = ((INTERNET_HANDLE_OBJECT *)hFileMapped)->AvailableDataLength();

        DEBUG_PRINT(API,
                    INFO,
                    ("%d bytes are immediately available\n",
                    available
                    ));

        // *lpdwNumberOfBytesAvailable = available;
        success = TRUE;
        goto sync_success;
    }

    INET_ASSERT(hFileMapped);

    //
    // sync path. wInternetQueryDataAvailable will set the last error code
    // if it fails
    //

    CFsm_QueryAvailable *pFsm;

    pFsm = New CFsm_QueryAvailable(NULL/*lpdwNumberOfBytesAvailable*/,
                                   0,
                                   NULL
                                   );

    HTTP_REQUEST_HANDLE_OBJECT *pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)hFileMapped;

    if (pFsm != NULL)
    {
        error = StartFsmChain(pFsm, pRequest, FALSE, isAsync);
    }
    else
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
    }

    if (error == ERROR_SUCCESS)
    {
        available = pRequest->AvailableDataLength();
        success = TRUE;
        goto sync_success;
    }
    else
    {
        if (error == ERROR_IO_PENDING)
        {
            bDeref = FALSE;
        }
        goto quit;
    }

finish:

    DEBUG_PRINT_API(API,
                    INFO,
                    ("*lpdwNumberOfBytesAvailable (%#x) = %d\n",
                    lpdwNumberOfBytesAvailable,
                    dwNumBytes
                    ));

    if (bDeref && (hFileMapped != NULL))
    {
        DereferenceObject((LPVOID)hFileMapped);
    }

    if (lpThreadInfo)
    {

        PERF_LOG(PE_CLIENT_REQUEST_END,
                 AR_INTERNET_QUERY_DATA_AVAILABLE,
                 dwNumBytes,
                 lpThreadInfo->ThreadId,
                 hFile
                 );

    }

    if (error == ERROR_IO_PENDING)
    {
        SetLastError(ERROR_SUCCESS);
        success = TRUE;
    }
    
    DEBUG_LEAVE_API(success);
    return success;

quit:

    if (error != ERROR_IO_PENDING)
    {
        DEBUG_ERROR(API, error);
    }

    SetLastError(error);
    success = FALSE;

    goto finish;

sync_success:

    dwNumBytes = available;
    
    if (isAsync)
    {
        DWORD dwResult = available;
        InternetIndicateStatus(WINHTTP_CALLBACK_STATUS_DATA_AVAILABLE,
                               &dwResult,
                               sizeof (DWORD)
                               );
    }

    if (lpdwNumberOfBytesAvailable)
    {
        *lpdwNumberOfBytesAvailable = available;
    }
    
    goto finish;
}


DWORD
CFsm_QueryAvailable::RunSM(
    IN CFsm * Fsm
    )
{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "CFsm_QueryAvailable::RunSM",
                 "%#x",
                 Fsm
                 ));

    DWORD error;
    CFsm_QueryAvailable * stateMachine = (CFsm_QueryAvailable *)Fsm;

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = QueryAvailable_Fsm(stateMachine);
        break;

    case FSM_STATE_ERROR:
        error = Fsm->GetError();
        INET_ASSERT (error == ERROR_WINHTTP_OPERATION_CANCELLED);
        Fsm->SetDone();
        break;

    default:
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_WINHTTP_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


PRIVATE
DWORD
QueryAvailable_Fsm(
    IN CFsm_QueryAvailable * Fsm
    )
{
    DEBUG_ENTER((DBG_INET,
                 Dword,
                 "QueryAvailable_Fsm",
                 "%#x",
                 Fsm
                 ));

    CFsm_QueryAvailable & fsm = *Fsm;
    DWORD error = fsm.GetError();

    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    HTTP_REQUEST_HANDLE_OBJECT * pRequest;

    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)fsm.GetMappedHandle();

    if (fsm.GetState() == FSM_STATE_INIT) {
        error = pRequest->QueryDataAvailable(fsm.m_lpdwNumberOfBytesAvailable);
    }
    if (error == ERROR_SUCCESS) {
        pRequest->SetAvailableDataLength(*fsm.m_lpdwNumberOfBytesAvailable);

        DEBUG_PRINT(INET,
                    INFO,
                    ("%d bytes available\n",
                    *fsm.m_lpdwNumberOfBytesAvailable
                    ));

        fsm.SetApiData(*fsm.m_lpdwNumberOfBytesAvailable);
    }

quit:

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone();
    }

    DEBUG_LEAVE(error);

    return error;
}



INTERNETAPI
BOOL
WINAPI
InternetGetLastResponseInfoA(
    OUT LPDWORD lpdwErrorCategory,
    IN LPSTR lpszBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    This function returns the per-thread last internet error description text
    or server response.

    If this function is successful, *lpdwBufferLength contains the string length
    of lpszBuffer.

    If this function returns a failure indication, *lpdwBufferLength contains
    the number of BYTEs required to hold the response text

Arguments:

    lpdwErrorCategory   - pointer to DWORD location where the error catagory is
                          returned

    lpszBuffer          - pointer to buffer where the error text is returned

    lpdwBufferLength    - IN: length of lpszBuffer
                          OUT: number of characters in lpszBuffer if successful
                          else size of buffer required to hold response text

Return Value:

    BOOL
        Success - TRUE
                    lpszBuffer contains the error text. The caller must check
                    *lpdwBufferLength: if 0 then there was no text to return

        Failure - FALSE
                    Call GetLastError() for more information

--*/

{
    DEBUG_ENTER((DBG_API,
                     Bool,
                     "InternetGetLastResponseInfoA",
                     "%#x, %#x, %#x [%d]",
                     lpdwErrorCategory,
                     lpszBuffer,
                     lpdwBufferLength,
                     lpdwBufferLength ? *lpdwBufferLength : 0
                     ));

    DWORD error;
    BOOL success;
    DWORD textLength;
    LPINTERNET_THREAD_INFO lpThreadInfo;

    //
    // validate parameters
    //

    if (IsBadWritePtr(lpdwErrorCategory, sizeof(*lpdwErrorCategory))
    || IsBadWritePtr(lpdwBufferLength, sizeof(*lpdwBufferLength))
    || (ARGUMENT_PRESENT(lpszBuffer)
        ? IsBadWritePtr(lpszBuffer, *lpdwBufferLength)
        : FALSE)) {
        error = ERROR_INVALID_PARAMETER;
        goto quit;
    }

    //
    // if the buffer pointer is NULL then its the same as a zero-length buffer
    //

    if (!ARGUMENT_PRESENT(lpszBuffer)) {
        *lpdwBufferLength = 0;
    } else if (*lpdwBufferLength != 0) {
        *lpszBuffer = '\0';
    }

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL) {

        DEBUG_PRINT(INET,
                    ERROR,
                    ("failed to get INTERNET_THREAD_INFO\n"
                    ));

        //informational INET_ASSERT(FALSE);

        error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto quit;
    }

    //
    // there may not be any error text for this thread - either no server
    // error/response has been received, or the error text has been cleared by
    // an intervening API
    //

    if (lpThreadInfo->hErrorText != NULL) {

        //
        // copy as much as we can fit in the user supplied buffer
        //

        textLength = lpThreadInfo->ErrorTextLength;
        if (*lpdwBufferLength) {

            LPBYTE errorText;

            errorText = (LPBYTE)LOCK_MEMORY(lpThreadInfo->hErrorText);
            if (errorText != NULL) {
                textLength = min(textLength, *lpdwBufferLength) - 1;
                memcpy(lpszBuffer, errorText, textLength);

                //
                // the error text should always be zero terminated, so the
                // calling app can treat it as a string
                //

                lpszBuffer[textLength] = '\0';

                UNLOCK_MEMORY(lpThreadInfo->hErrorText);

                if (textLength == lpThreadInfo->ErrorTextLength - 1) {
                    error = ERROR_SUCCESS;
                } else {

                    //
                    // returned length is amount of buffer required
                    //

                    textLength = lpThreadInfo->ErrorTextLength;
                    error = ERROR_INSUFFICIENT_BUFFER;
                }
            } else {

                DEBUG_PRINT(INET,
                            ERROR,
                            ("failed to lock hErrorText (%#x): %d\n",
                            lpThreadInfo->hErrorText,
                            GetLastError()
                            ));

                error = ERROR_WINHTTP_INTERNAL_ERROR;
            }
        } else {

            //
            // user's buffer is not large enough to hold the info. We'll
            // let them know the required length
            //

            error = ERROR_INSUFFICIENT_BUFFER;
        }
    } else {

        INET_ASSERT(lpThreadInfo->ErrorTextLength == 0);

        textLength = 0;
        error = ERROR_SUCCESS;
    }

    *lpdwErrorCategory = lpThreadInfo->ErrorNumber;
    *lpdwBufferLength = textLength;

    IF_DEBUG(ANY) {
        if ((error == ERROR_SUCCESS)
        || ((textLength != 0) && (lpszBuffer != NULL))) {

            DEBUG_DUMP_API(API,
                           "Last Response Info:\n",
                           lpszBuffer,
                           textLength
                           );

        }
    }

    if ((error == ERROR_SUCCESS)
    || ((textLength != 0) && (lpszBuffer != NULL))) {

        TRACE_DUMP_API_IF_REQUEST(API,
                       "Last Response Info:\n",
                       lpszBuffer,
                       textLength,
                       (HANDLE_OBJECT *) (lpThreadInfo->hObjectMapped)
                       );

    }

quit:
    success = (error == ERROR_SUCCESS);
    if (!success) {
        DEBUG_ERROR(API, error);
        SetLastError(error);
    }

    DEBUG_LEAVE(success);

    return success;
}


BOOL
internalWinHttpGetDefaultProxyConfigurationA( IN OUT WINHTTP_PROXY_INFOA * pProxyInfo)
/*++

Routine Description:

    Reads the settings for WinHTTP's default proxy mode.
    
Arguments:

    pProxyInfo  - Pointer to structure to receive proxy settings

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError() for more info

--*/
{
    DWORD dwError;
    
    INTERNET_PROXY_INFO_EX proxyInfoEx;
    memset( &proxyInfoEx, 0, sizeof( proxyInfoEx));
    proxyInfoEx.dwStructSize = sizeof( proxyInfoEx);

    dwError = ReadProxySettings( &proxyInfoEx);

    if( dwError == ERROR_SUCCESS)
    {
        //  reset access type result to one of two known..
        pProxyInfo->dwAccessType = WINHTTP_ACCESS_TYPE_NO_PROXY;
        if( proxyInfoEx.dwFlags == WINHTTP_ACCESS_TYPE_NAMED_PROXY)
            pProxyInfo->dwAccessType = WINHTTP_ACCESS_TYPE_NAMED_PROXY;
        
        pProxyInfo->lpszProxy = (LPSTR)proxyInfoEx.lpszProxy;  // allocated by GlobalAlloc()
        pProxyInfo->lpszProxyBypass = (LPSTR)proxyInfoEx.lpszProxyBypass;  // allocated by GlobalAlloc()
    }

    if( dwError != ERROR_SUCCESS)
        SetLastError( dwError);

    return dwError == ERROR_SUCCESS ? TRUE : FALSE;
}


BOOL
internalWinHttpSetDefaultProxyConfigurationA( IN WINHTTP_PROXY_INFOA * pProxyInfo)
/*++

Routine Description:

    Writes settings for WinHTTP's default proxy mode.
    
Arguments:

    pProxyInfo  - Pointer to structure describing proxy settings

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError() for more info

--*/
{
    BOOL blReturnValue = FALSE;

    //
    //  Parameter validation
    //

    //  If AccessType is NO_PROXY, make sure no proxy information is given.
    if( pProxyInfo->dwAccessType == WINHTTP_ACCESS_TYPE_NO_PROXY)
    {
        if( pProxyInfo->lpszProxy != NULL
            || pProxyInfo->lpszProxyBypass != NULL)
        {
            SetLastError( ERROR_INVALID_PARAMETER);
            goto done;
        }
    }
    //  If AccessType is NAMED_PROXY, make sure a proxy is given.  ProxyBypass list is optional.
    else if( pProxyInfo->dwAccessType == WINHTTP_ACCESS_TYPE_NAMED_PROXY)
    {
        if( pProxyInfo->lpszProxy == NULL)
        {
            SetLastError( ERROR_INVALID_PARAMETER);
            goto done;
        }
    }
    else
    {
        //  AccessType is not NAMED_PROXY or NO_PROXY
        SetLastError( ERROR_INVALID_PARAMETER);
        goto done;
    }

    //  verify validity of proxy server list
    if( pProxyInfo->lpszProxy != NULL)
    {
        //  verify validity of proxy server list
        PROXY_SERVER_LIST proxyServerList( pProxyInfo->lpszProxy);

        if( ERROR_SUCCESS != proxyServerList.GetError())
        {
            SetLastError( ERROR_INVALID_PARAMETER);
            goto done;
        }
    }
    
    //  verify validity of proxy server bypass list
    if( pProxyInfo->lpszProxyBypass != NULL)
    {
        PROXY_BYPASS_LIST proxyBypassList( pProxyInfo->lpszProxyBypass);
        if( ERROR_SUCCESS != proxyBypassList.GetError())
        {
            SetLastError( ERROR_INVALID_PARAMETER);
            goto done;
        }
    }

    INTERNET_PROXY_INFO_EX proxyInfoEx;
    memset( &proxyInfoEx, 0, sizeof( proxyInfoEx));
    proxyInfoEx.dwStructSize = sizeof( proxyInfoEx);
    proxyInfoEx.dwFlags = pProxyInfo->dwAccessType;
    proxyInfoEx.lpszProxy = pProxyInfo->lpszProxy;
    proxyInfoEx.lpszProxyBypass = pProxyInfo->lpszProxyBypass;

    DWORD dwError;
    dwError = WriteProxySettings( &proxyInfoEx);
    if( ERROR_SUCCESS != dwError)
    {
        SetLastError( dwError);
        goto done;
    }
    
    blReturnValue = TRUE;

done:
    return blReturnValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5.1\api\inetapiw.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    inetapiw.cxx

Abstract:

    Contains the wide-character Internet APIs

    Contents:
        WinHttpCrackUrl
        WinHttpCreateUrl
        WinHttpOpen
        WinHttpConnect
        WinHttpSetStatusCallback

Author:

    Richard L Firth (rfirth) 02-Mar-1995

Environment:

    Win32(s) user-mode DLL

Revision History:

    02-Mar-1995 rfirth
        Created

--*/

#include <wininetp.h>

//  because wininet doesnt know about IStream
#define NO_SHLWAPI_STREAM
#include <shlwapi.h>
#include <shlwapip.h>
#include "autodial.h"

// -- FixStrings ------

//  Used in WinHttpCrackUrlW only.
//  Either
//  (a) If we have an ansi string, AND a unicode buffer, convert from ansi to unicode
//  (b) If we have an ansi string, but NO unicode buffer, determine where the ansi string
//         occurs in the unicode URL, and point the component there.

VOID
FixStrings(    
    LPSTR& pszA, 
    DWORD cbA, 
    LPWSTR& pszW, 
    DWORD& ccW, 
    LPSTR pszUrlA, 
    LPCWSTR pszUrlW)
{
    if (!pszA)
        return;

    if (pszW) 
    {
        ccW = MultiByteToWideChar(CP_ACP, 0, pszA, cbA+1, pszW, ccW) - 1; 
    } 
    else 
    { 
        pszW = (LPWSTR)(pszUrlW + MultiByteToWideChar(CP_ACP, 0, 
                pszUrlA, (int) (pszA-pszUrlA), NULL, 0)); 
        ccW = MultiByteToWideChar(CP_ACP, 0, pszA, cbA, NULL, 0); 
    } 
}

//
// functions
//


INTERNETAPI
BOOL
WINAPI
WinHttpCrackUrl(
    IN LPCWSTR pszUrlW,
    IN DWORD dwUrlLengthW,
    IN DWORD dwFlags,
    IN OUT LPURL_COMPONENTS pUCW
    )

/*++

Routine Description:

    Cracks an URL into its constituent parts. Optionally escapes the url-path.
    We assume that the user has supplied large enough buffers for the various
    URL parts

Arguments:

    pszUrl         - pointer to URL to crack

    dwUrlLength     - 0 if pszUrl is ASCIIZ string, else length of pszUrl

    dwFlags         - flags controlling operation

    lpUrlComponents - pointer to URL_COMPONENTS

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError() for more info

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "WinHttpCrackUrl",
                     "%wq, %#x, %#x, %#x",
                     pszUrlW,
                     dwUrlLengthW,
                     dwFlags,
                     pUCW
                     ));

    INET_ASSERT(pszUrlW);
    INET_ASSERT(pUCW);

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;
    DWORD c;
    MEMORYPACKET mpUrlA, mpHostName, mpUserName, mpScheme, mpPassword, mpUrlPath, mpExtraInfo;
    URL_COMPONENTSA UCA;

    if (!pszUrlW
        || (dwUrlLengthW
            ? IsBadStringPtrW(pszUrlW,dwUrlLengthW)
            : IsBadStringPtrW(pszUrlW,(UINT_PTR)-1))
        || !pUCW
        || IsBadWritePtr(pUCW, sizeof(*pUCW))
        || (pUCW->dwStructSize != sizeof(*pUCW)) 
        || (dwFlags & ~(ICU_ESCAPE | ICU_DECODE)))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    
    UCA.dwStructSize = sizeof(URL_COMPONENTSA); 
    ALLOC_MB(pszUrlW, dwUrlLengthW, mpUrlA);
    if (!mpUrlA.psStr) {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
    }
    UNICODE_TO_ANSI(pszUrlW, mpUrlA);

    for (c=0; c<=5; c++) {
        LPWSTR pszWorker = NULL;
        DWORD ccLen = 0;
        MEMORYPACKET* pmpWorker = NULL;
        
        switch(c)
        {
        case 0:
            pszWorker = pUCW->lpszScheme;
            ccLen = pUCW->dwSchemeLength;
            pmpWorker = &mpScheme;
            break;

        case 1:
            pszWorker = pUCW->lpszHostName;
            ccLen = pUCW->dwHostNameLength;
            pmpWorker = &mpHostName;
            break;

        case 2:
            pszWorker = pUCW->lpszUserName;
            ccLen = pUCW->dwUserNameLength;
            pmpWorker = &mpUserName;
            break;

        case 3:
            pszWorker = pUCW->lpszPassword;
            ccLen = pUCW->dwPasswordLength;
            pmpWorker = &mpPassword;
            break;

        case 4:
            pszWorker = pUCW->lpszUrlPath;
            ccLen = pUCW->dwUrlPathLength;
            pmpWorker = &mpUrlPath;
            break;

        case 5:
            pszWorker = pUCW->lpszExtraInfo;
            ccLen = pUCW->dwExtraInfoLength;
            pmpWorker = &mpExtraInfo;
            break;
        }

        if (pszWorker) 
        {
            if (pszWorker 
                && ccLen 
                && (ProbeWriteBuffer(pszWorker,ccLen) != ERROR_SUCCESS) )
            {
                dwErr = ERROR_INVALID_PARAMETER;
                goto cleanup;
            }
            ALLOC_MB(pszWorker,ccLen,(*pmpWorker)); 
            if (!pmpWorker->psStr) 
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                goto cleanup;
            }
        } 
        else 
        { 
            pmpWorker->dwAlloc = ccLen; 
        }
    };

    REASSIGN_ALLOC(mpScheme,UCA.lpszScheme,UCA.dwSchemeLength);
    REASSIGN_ALLOC(mpHostName, UCA.lpszHostName,UCA.dwHostNameLength);
    REASSIGN_ALLOC(mpUserName, UCA.lpszUserName,UCA.dwUserNameLength);
    REASSIGN_ALLOC(mpPassword,UCA.lpszPassword,UCA.dwPasswordLength);
    REASSIGN_ALLOC(mpUrlPath,UCA.lpszUrlPath,UCA.dwUrlPathLength);
    REASSIGN_ALLOC(mpExtraInfo,UCA.lpszExtraInfo,UCA.dwExtraInfoLength);
                
    fResult = WinHttpCrackUrlA(mpUrlA.psStr, mpUrlA.dwSize, dwFlags, &UCA);
    if (fResult) {
        FixStrings(UCA.lpszScheme, UCA.dwSchemeLength, pUCW->lpszScheme, 
                    pUCW->dwSchemeLength, mpUrlA.psStr, pszUrlW);
        FixStrings(UCA.lpszHostName, UCA.dwHostNameLength, pUCW->lpszHostName, 
                    pUCW->dwHostNameLength, mpUrlA.psStr, pszUrlW);
        FixStrings(UCA.lpszUserName, UCA.dwUserNameLength, pUCW->lpszUserName, 
                    pUCW->dwUserNameLength, mpUrlA.psStr, pszUrlW);
        FixStrings(UCA.lpszPassword, UCA.dwPasswordLength, pUCW->lpszPassword, 
                    pUCW->dwPasswordLength, mpUrlA.psStr, pszUrlW);
        FixStrings(UCA.lpszUrlPath, UCA.dwUrlPathLength, pUCW->lpszUrlPath, 
                    pUCW->dwUrlPathLength, mpUrlA.psStr, pszUrlW);
        FixStrings(UCA.lpszExtraInfo, UCA.dwExtraInfoLength, pUCW->lpszExtraInfo, 
                    pUCW->dwExtraInfoLength, mpUrlA.psStr, pszUrlW);
        pUCW->nScheme = UCA.nScheme;
        pUCW->nPort = UCA.nPort;
        pUCW->dwStructSize = sizeof(URL_COMPONENTSW);
    }

cleanup:        
    if (dwErr!=ERROR_SUCCESS) { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}


INTERNETAPI
BOOL
WINAPI
WinHttpCreateUrl(
    IN LPURL_COMPONENTS pUCW,
    IN DWORD dwFlags,
    OUT LPWSTR pszUrlW,
    IN OUT LPDWORD pdwUrlLengthW
    )

/*++

Routine Description:

    Creates an URL from its constituent parts

Arguments:

Return Value:

    BOOL
        Success - URL written to pszUrl

        Failure - call GetLastError() for more info

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "WinHttpCreateUrl",
                     "%#x, %#x, %#x, %#x",
                     pUCW,
                     dwFlags,
                     pszUrlW,
                     pdwUrlLengthW
                     ));

    INET_ASSERT(pszUrlW);
    INET_ASSERT(pUCW);

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;
    MEMORYPACKET mpUrlA, mpHostName, mpUserName, mpScheme, mpPassword, mpUrlPath, mpExtraInfo;
    URL_COMPONENTSA UCA;

    if (!pdwUrlLengthW 
        || (pUCW==NULL)
        || IsBadWritePtr(pUCW, sizeof(*pUCW))
        || (pUCW->dwStructSize != sizeof(*pUCW))
        || (pszUrlW && IsBadWritePtr(pszUrlW, *pdwUrlLengthW*sizeof(WCHAR)))
        || (dwFlags & ~(ICU_ESCAPE)))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    if (pszUrlW)
    {
        ALLOC_MB(pszUrlW, *pdwUrlLengthW, mpUrlA);
        if (!mpUrlA.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
    }
    mpUrlA.dwSize = mpUrlA.dwAlloc;
    UCA.dwStructSize = sizeof(URL_COMPONENTSA);

    UCA.nScheme = pUCW->nScheme;
    UCA.nPort = pUCW->nPort;
    if (pUCW->lpszScheme)
    {
        if (pUCW->dwSchemeLength
            ? IsBadReadPtr(pUCW->lpszScheme, pUCW->dwSchemeLength)
            : IsBadStringPtrW(pUCW->lpszScheme, (UINT_PTR)-1))
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
        ALLOC_MB(pUCW->lpszScheme, pUCW->dwSchemeLength, mpScheme);
        if (!mpScheme.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(pUCW->lpszScheme, mpScheme);
    }
    REASSIGN_SIZE(mpScheme, UCA.lpszScheme, UCA.dwSchemeLength);
    if (pUCW->lpszHostName)
    {
        if (pUCW->dwHostNameLength
            ? IsBadReadPtr(pUCW->lpszHostName, pUCW->dwHostNameLength)
            : IsBadStringPtrW(pUCW->lpszHostName, (UINT_PTR)-1))
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
        ALLOC_MB(pUCW->lpszHostName, pUCW->dwHostNameLength, mpHostName);
        if (!mpHostName.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(pUCW->lpszHostName, mpHostName);
    }
    REASSIGN_SIZE(mpHostName, UCA.lpszHostName, UCA.dwHostNameLength);
    if (pUCW->lpszUserName)
    {
        if (pUCW->dwUserNameLength
            ? IsBadReadPtr(pUCW->lpszUserName, pUCW->dwUserNameLength)
            : IsBadStringPtrW(pUCW->lpszUserName, (UINT_PTR)-1))
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
        ALLOC_MB(pUCW->lpszUserName, pUCW->dwUserNameLength, mpUserName);
        if (!mpUserName.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(pUCW->lpszUserName, mpUserName);
    }
    REASSIGN_SIZE(mpUserName, UCA.lpszUserName, UCA.dwUserNameLength);
    if (pUCW->lpszPassword)
    {
        if (pUCW->dwPasswordLength
            ? IsBadReadPtr(pUCW->lpszPassword, pUCW->dwPasswordLength)
            : IsBadStringPtrW(pUCW->lpszPassword, (UINT_PTR)-1))
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
        ALLOC_MB(pUCW->lpszPassword, pUCW->dwPasswordLength, mpPassword);
        if (!mpPassword.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(pUCW->lpszPassword, mpPassword);
    }
    REASSIGN_SIZE(mpPassword, UCA.lpszPassword, UCA.dwPasswordLength);
    if (pUCW->lpszUrlPath)
    {
        if (pUCW->dwUrlPathLength
            ? IsBadReadPtr(pUCW->lpszUrlPath, pUCW->dwUrlPathLength)
            : IsBadStringPtrW(pUCW->lpszUrlPath, (UINT_PTR)-1))
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
        ALLOC_MB(pUCW->lpszUrlPath, pUCW->dwUrlPathLength, mpUrlPath); 
        if (!mpUrlPath.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(pUCW->lpszUrlPath, mpUrlPath);
    }
    REASSIGN_SIZE(mpUrlPath, UCA.lpszUrlPath, UCA.dwUrlPathLength);
    if (pUCW->lpszExtraInfo)
    {
        if (pUCW->dwExtraInfoLength
            ? IsBadReadPtr(pUCW->lpszExtraInfo, pUCW->dwExtraInfoLength)
            : IsBadStringPtrW(pUCW->lpszExtraInfo, (UINT_PTR)-1))
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
        ALLOC_MB(pUCW->lpszExtraInfo, pUCW->dwExtraInfoLength, mpExtraInfo);
        if (!mpExtraInfo.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(pUCW->lpszExtraInfo, mpExtraInfo);
    }
    REASSIGN_SIZE(mpExtraInfo, UCA.lpszExtraInfo, UCA.dwExtraInfoLength);
    fResult = WinHttpCreateUrlA(&UCA, dwFlags, mpUrlA.psStr, &mpUrlA.dwSize);
    if (fResult)
    {
        DWORD dwRet;

        fResult = FALSE;
        
        if (pszUrlW && *pdwUrlLengthW)
        {
            //On success, reduce length of terminating NULL widechar.
            dwRet = MultiByteToWideChar(CP_ACP, 0, mpUrlA.psStr, mpUrlA.dwSize+1, pszUrlW, *pdwUrlLengthW);
            
            if (dwRet)
            {
                *pdwUrlLengthW = dwRet-1;
                fResult = TRUE;
            }
        }
        
        //If no url or no length or failure in prev. call, use MBtoWC to calculate required length of buffer.
        //If a value is returned, then set ERROR_INSUFFICIENT_BUFFER as last error
        if (!fResult)
        {
            dwRet = MultiByteToWideChar(CP_ACP, 0, mpUrlA.psStr, mpUrlA.dwSize+1, pszUrlW, 0);
            
            if (dwRet)
            {
                dwErr = ERROR_INSUFFICIENT_BUFFER;
                *pdwUrlLengthW = dwRet;
                
            }
            else
            {
                dwErr = GetLastError();
                //Morph the error since we don't know what to initialize pdwUrlLengthW to
                if (dwErr == ERROR_INSUFFICIENT_BUFFER)
                {
                    dwErr = ERROR_INVALID_PARAMETER;
                }
            }
        }
    }
    else
    {
        *pdwUrlLengthW = mpUrlA.dwSize;
    }

cleanup:        
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }

    DEBUG_LEAVE_API(fResult);
    return fResult;
}


// implemented in inetapia.cxx
DWORD ICUHrToWin32Error(HRESULT);


INTERNETAPI
HINTERNET
WINAPI
WinHttpOpen(
    IN LPCWSTR pszAgentW,
    IN DWORD dwAccessType,
    IN LPCWSTR pszProxyW OPTIONAL,
    IN LPCWSTR pszProxyBypassW OPTIONAL,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    pszAgent       -

    dwAccessType    -

    pszProxy       -

    pszProxyBypass -

    dwFlags         -

Return Value:

    HINTERNET

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Handle,
                     "WinHttpOpen",
                     "%wq, %s (%d), %wq, %wq, %#x",
                     pszAgentW,
                     InternetMapOpenType(dwAccessType),
                     dwAccessType,
                     pszProxyW,
                     pszProxyBypassW,
                     dwFlags
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    HINTERNET hInternet = NULL;
    MEMORYPACKET mpAgentA, mpProxyA, mpProxyBypassA;

    if (dwFlags &~ (WINHTTP_OPEN_FLAGS_MASK))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    
    if (pszAgentW)
    {
        if (IsBadStringPtrW(pszAgentW, (UINT_PTR)-1))
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
        ALLOC_MB(pszAgentW,0,mpAgentA);
        if (!mpAgentA.psStr)
        {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                goto cleanup;
        }
        UNICODE_TO_ANSI(pszAgentW,mpAgentA);
    }

    if (dwAccessType == WINHTTP_ACCESS_TYPE_NAMED_PROXY)
    {
        if (pszProxyW)
        {
            if (IsBadStringPtrW(pszProxyW, (UINT_PTR)-1) 
                || (*pszProxyW == L'\0'))
            {
                dwErr = ERROR_INVALID_PARAMETER;
                goto cleanup;
            }
            ALLOC_MB(pszProxyW,0,mpProxyA);
            if (!mpProxyA.psStr)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                goto cleanup;
            }
            UNICODE_TO_ANSI(pszProxyW,mpProxyA);
        }
        if (pszProxyBypassW)
        {
            if (IsBadStringPtrW(pszProxyBypassW, (UINT_PTR)-1))
            {
                dwErr = ERROR_INVALID_PARAMETER;
                goto cleanup;
            }
            ALLOC_MB(pszProxyBypassW,0,mpProxyBypassA);
            if (!mpProxyBypassA.psStr)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                goto cleanup;
            }
            UNICODE_TO_ANSI(pszProxyBypassW,mpProxyBypassA);
        }
    }

    hInternet = InternetOpenA(mpAgentA.psStr, dwAccessType, mpProxyA.psStr, 
                                        mpProxyBypassA.psStr, dwFlags);

                                        
cleanup:        
    if (dwErr!=ERROR_SUCCESS) { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }

    DEBUG_LEAVE_API(hInternet);
    return hInternet;
}


INTERNETAPI
HINTERNET
WINAPI
WinHttpConnect(
    IN HINTERNET hInternetSession,
    IN LPCWSTR pszServerNameW,
    IN INTERNET_PORT nServerPort,
    IN DWORD dwReserved
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    hInternetSession    -
    pszServerName      -
    nServerPort         -
    pszUserName        -
    pszPassword        -
    dwService           -
    dwReserved             -

Return Value:

    HINTERNET

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Handle,
                     "WinHttpConnect",
                     "%#x, %wq, %d, %#x",
                     hInternetSession,
                     pszServerNameW,
                     nServerPort,
                     dwReserved
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    MEMORYPACKET mpServerNameA;
    HINTERNET hInternet = NULL;

    if (dwReserved)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    
    if (pszServerNameW)
    {
        if (IsBadStringPtrW(pszServerNameW,(UINT_PTR)-1))
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
        dwErr = ConvertUnicodeToMultiByte(pszServerNameW, 0/*CODEPAGE not used here*/, &mpServerNameA, 
                    WINHTTP_FLAG_VALID_HOSTNAME); 
        if (dwErr != ERROR_SUCCESS)
        {
            goto cleanup;
        }
    }
    else
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    hInternet = InternetConnectA
        (hInternetSession, mpServerNameA.psStr, nServerPort, dwReserved, NULL);

cleanup:        
    if (dwErr!=ERROR_SUCCESS) { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }

    DEBUG_LEAVE_API(hInternet);
    return hInternet;
}


INTERNETAPI
WINHTTP_STATUS_CALLBACK
WINAPI
WinHttpSetStatusCallback(
    IN HINTERNET hInternet,
    IN WINHTTP_STATUS_CALLBACK lpfnInternetCallback,
    IN DWORD dwNotificationFlags,
    IN DWORD_PTR dwReserved
    )

/*++

Routine Description:

    Sets the status callback function for the DLL or the handle object

Arguments:

    hInternet               - handle of the object for which we wish to set the
                              status callback

    lpfnInternetCallback    - pointer to caller-supplied status function

Return Value:

    FARPROC
        Success - previous status callback function address

        Failure - INTERNET_INVALID_STATUS_CALLBACK. Call GetLastErrorInfo() for
                  more information:

                    ERROR_INVALID_PARAMETER
                        The callback function is invalid

                    ERROR_WINHTTP_INCORRECT_HANDLE_TYPE
                        Cannot set the callback on the supplied handle (probably
                        a NULL handle - per-process callbacks no longer
                        supported)

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Pointer,
                     "WinHttpSetStatusCallback",
                     "%#x, %#x, %#x",
                     hInternet,
                     lpfnInternetCallback,
                     dwNotificationFlags
                     ));
                 
    DWORD dwErr = ERROR_SUCCESS;
    BOOL fIsUnicode = TRUE; //vestigial UNICODE indicator
    
    WINHTTP_STATUS_CALLBACK previousCallback = WINHTTP_INVALID_STATUS_CALLBACK;
    HINTERNET hObjectMapped = NULL;

    if (!GlobalDataInitialized) 
    {
        dwErr = GlobalDataInitialize();
        if (dwErr != ERROR_SUCCESS) 
        {
            goto cleanup;
        }
    }

    if (((lpfnInternetCallback != NULL) && IsBadCodePtr((FARPROC)lpfnInternetCallback))
        || (dwNotificationFlags == 0) || (dwReserved != 0))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    
    if (!hInternet)
    {
        dwErr = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        goto cleanup;
    }

    // map the handle
    dwErr = MapHandleToAddress(hInternet, (LPVOID *)&hObjectMapped, FALSE);
    if (dwErr != ERROR_SUCCESS)
    {
        goto cleanup;
    }
    
    // swap the new and previous handle object status callbacks, ONLY
    // if there are no pending requests on this handle
    previousCallback = lpfnInternetCallback;
    dwErr = RExchangeStatusCallback(hObjectMapped, &previousCallback, fIsUnicode, dwNotificationFlags);
    
cleanup:

    if (hObjectMapped != NULL) 
    {
        DereferenceObject((LPVOID)hObjectMapped);
    }

    if (dwErr!=ERROR_SUCCESS)
    {
        SetLastError(dwErr);
        DEBUG_ERROR(API, dwErr);
    }
    
    DEBUG_LEAVE_API(previousCallback);
    return previousCallback;
}


// WinHttpPlatformCheck() API routines //////////////////////////////////////

static void ConvertVersionString(LPCSTR pszVersion, WORD rwVer[], CHAR ch)
{
    LPCSTR pszEnd;
    LPCSTR pszTemp;
    int    i; 

    for (i = 0; i < 4; i++)
        rwVer[i] = 0;

    pszEnd = pszVersion + lstrlen(pszVersion);
    pszTemp = pszVersion;

    for (i = 0; i < 4 && pszTemp < pszEnd; i++)
    {
        while (pszTemp < pszEnd && *pszTemp != ch)
        {
            rwVer[i] = rwVer[i] * 10 + (*pszTemp - '0');
            pszTemp++;
        }

        pszTemp++;
    }
}


const char c_gszRegActiveSetup[]        = "Software\\Microsoft\\Active Setup\\Installed Components\\";
const char c_gszInternetExplorerCLSID[] = "{89820200-ECBD-11cf-8B85-00AA005B4383}";

static void GetInstalledComponentVersion(LPCSTR szCLSID, DWORD *pdwMSVer, DWORD *pdwLSVer)
{
    HKEY    hKey;
    char    szKey[MAX_PATH];
    WORD    rgwVersion[4];
    DWORD   dwSize;
    
    *pdwMSVer = 0;
    *pdwLSVer = 0;

    // Build the registry path.
    lstrcpy(szKey, c_gszRegActiveSetup);
    lstrcat(szKey, szCLSID);
    
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, szKey, 0, KEY_QUERY_VALUE, &hKey) == ERROR_SUCCESS)
    {
        dwSize = sizeof(szKey);

        if ((RegQueryValueEx(hKey, "Version", NULL, NULL, (BYTE *)szKey, &dwSize) == ERROR_SUCCESS) &&
            (dwSize > 0))
        {
            ConvertVersionString(szKey, rgwVersion, ',');

            *pdwMSVer = (DWORD)rgwVersion[0] << 16;    // Make hi word of MS version
            *pdwMSVer += (DWORD)rgwVersion[1];         // Make lo word of MS version
            *pdwLSVer = (DWORD)rgwVersion[2] << 16;    // Make hi word of LS version
            *pdwLSVer += (DWORD)rgwVersion[3];         // Make lo word of LS version
        }

        RegCloseKey(hKey);
    }
}

static BOOL Is_IE_501_OrLaterInstalled()
{
    DWORD   dwMSVer;
    DWORD   dwLSVer;

    //
    // Find the IE version number. IE 5.01 has version number 5.00.2919.6300.
    // This will be returned from GetInstalledComponentVersion as two DWORDs,
    // like so:
    //      5.00   ->  0x00050000
    //   2919.6300 ->  0x0B67189C
    //

    GetInstalledComponentVersion(c_gszInternetExplorerCLSID, &dwMSVer, &dwLSVer);

    if (dwMSVer > 0x00050000)
        return TRUE;
    else if ((dwMSVer == 0x00050000) && (dwLSVer >= 0x0B67189C))
        return TRUE;

    return FALSE;
}

#if 0

#define REGSTR_CCS_CONTROL_WINDOWS  TEXT("SYSTEM\\CurrentControlSet\\Control\\WINDOWS")
#define CSDVERSION                  TEXT("CSDVersion")
#define SP6_VERSION                 0x0600

static BOOL Is_SP6_OrLater()
{
    BOOL    fSP6OrLater = FALSE;
    HKEY    hKey;
    DWORD   dwCSDVersion;
    DWORD   dwSize;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_CCS_CONTROL_WINDOWS, 0, KEY_QUERY_VALUE, &hKey) == ERROR_SUCCESS)
    {
        dwSize = sizeof(dwCSDVersion);

        if (RegQueryValueEx(hKey, CSDVERSION, NULL, NULL, (BYTE *)&dwCSDVersion, &dwSize) == ERROR_SUCCESS)
        {
            fSP6OrLater = (LOWORD(dwCSDVersion) >= SP6_VERSION);
        }
        RegCloseKey(hKey);
    }

    return fSP6OrLater;
}
#endif


INTERNETAPI
BOOL
WINAPI
WinHttpCheckPlatform(void)
{
    static BOOL _fCheckedPlatform = FALSE;
    static BOOL _fPlatformOk;


    if (!_fCheckedPlatform)
    {
        OSVERSIONINFO   osvi;
        BOOL            fPlatformOk = FALSE;

        osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        
        if (GetVersionEx(&osvi))
        {
            // Allow only Win2K or NT-based platforms.
            if (osvi.dwPlatformId == VER_PLATFORM_WIN32_NT)
            {
                if (osvi.dwMajorVersion >= 5)
                {
                    // Ok on Win2K or later.
                    fPlatformOk = TRUE;
                }
                else if (osvi.dwMajorVersion == 4)
                {
                    // On NT4, we require IE 5.01 (or later).
                    fPlatformOk = Is_IE_501_OrLaterInstalled();
                }
            }
        }

        _fPlatformOk = fPlatformOk;

        InterlockedExchange((long *)&_fCheckedPlatform, TRUE);
    }

    return _fPlatformOk;
}


// WinHttpGet/SetDefaultProxyConfiguration APIs /////////////////////////////

WINHTTPAPI
BOOL
WINAPI
WinHttpGetDefaultProxyConfiguration( IN OUT WINHTTP_PROXY_INFOW * pProxyInfo)
/*++

Routine Description:

    Reads the settings for WinHTTP's default proxy mode.
    
Arguments:

    pProxyInfo  - Pointer to structure to receive proxy settings

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError() for more info

--*/
{
    BOOL blReturnValue = FALSE;
    DWORD dwError;
    
    LPWSTR lpszProxy = NULL, lpszProxyBypass = NULL;

    WINHTTP_PROXY_INFOA ansiProxyInfo;
    memset( &ansiProxyInfo, 0, sizeof( ansiProxyInfo));

    if( IsBadWritePtr( pProxyInfo, sizeof( *pProxyInfo)))
    {
        SetLastError( ERROR_INVALID_PARAMETER);
        goto done;
    }

    //
    //  Get results and make available in Unicode format
    //
    if( FALSE == internalWinHttpGetDefaultProxyConfigurationA( &ansiProxyInfo))
    {
        //  SetLastError() performed by Ansi version of WinHttpGetDefaultProxyConfiguration
        goto done;
    }

    if( ansiProxyInfo.lpszProxy != NULL)
    {
        dwError = AsciiToWideChar_UsingGlobalAlloc( ansiProxyInfo.lpszProxy, &(lpszProxy));
        if( dwError != ERROR_SUCCESS)
        {
            SetLastError( dwError);
            goto done;
        }
    }

    if( ansiProxyInfo.lpszProxyBypass != NULL)
    {
        dwError = AsciiToWideChar_UsingGlobalAlloc( ansiProxyInfo.lpszProxyBypass, &(lpszProxyBypass));
        if( dwError != ERROR_SUCCESS)
        {
            SetLastError( dwError);
            goto done;
        }
    }

    //
    //  Return results
    //
    pProxyInfo->dwAccessType = ansiProxyInfo.dwAccessType;
    pProxyInfo->lpszProxy = lpszProxy;
    lpszProxy = NULL;
    pProxyInfo->lpszProxyBypass = lpszProxyBypass;
    lpszProxyBypass = NULL;

    blReturnValue = TRUE;

done:
    if( NULL != lpszProxy)
        GlobalFree( lpszProxy);
    
    if( NULL != lpszProxyBypass)
        GlobalFree( lpszProxyBypass);

    if( NULL != ansiProxyInfo.lpszProxy)
        GlobalFree( ansiProxyInfo.lpszProxy);
    
    if( NULL != ansiProxyInfo.lpszProxyBypass)
        GlobalFree( ansiProxyInfo.lpszProxyBypass);
    
    return blReturnValue;
}


WINHTTPAPI
BOOL
WINAPI
WinHttpSetDefaultProxyConfiguration( IN WINHTTP_PROXY_INFOW * pProxyInfo)
/*++

Routine Description:

    Writes settings for WinHTTP's default proxy mode.
    
Arguments:

    pProxyInfo  - Pointer to structure describing proxy settings

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError() for more info

--*/
{
    BOOL blReturnValue = FALSE;
    DWORD dwError;

    WINHTTP_PROXY_INFOA ansiProxyInfo;
    memset( &ansiProxyInfo, 0, sizeof( ansiProxyInfo));

    //
    //  Validate parameters
    //    (Ansi WinHttpSetDEfaultProxyConfiguration does deeper verification)
    if( IsBadReadPtr( pProxyInfo, sizeof( *pProxyInfo))
        || ((NULL != pProxyInfo->lpszProxy) && IsBadStringPtrW( pProxyInfo->lpszProxy, 2048))
        || ((NULL != pProxyInfo->lpszProxyBypass) && IsBadStringPtrW( pProxyInfo->lpszProxyBypass, 2048)))
    {
        SetLastError( ERROR_INVALID_PARAMETER);
        goto done;
    }

    //
    //  Convert WINHTTP_PROXY_INFOW to WINHTTP_PROXY_INFOA
    //
    ansiProxyInfo.dwAccessType = pProxyInfo->dwAccessType;

    if( pProxyInfo->lpszProxy != NULL)
    {
        dwError = WideCharToAscii( pProxyInfo->lpszProxy, &(ansiProxyInfo.lpszProxy));
        if( ERROR_SUCCESS != dwError)
        {
            SetLastError( dwError);
            goto done;
        }
    }

    if( pProxyInfo->lpszProxyBypass != NULL)
    {
        dwError = WideCharToAscii( pProxyInfo->lpszProxyBypass, &(ansiProxyInfo.lpszProxyBypass));
        if( ERROR_SUCCESS != dwError)
        {
            SetLastError( dwError);
            goto done;
        }
    }

    //
    //  call Ansi version
    //
    blReturnValue = internalWinHttpSetDefaultProxyConfigurationA( &ansiProxyInfo);

done:
    if( ansiProxyInfo.lpszProxy != NULL)
        delete[] ansiProxyInfo.lpszProxy;
    
    if( ansiProxyInfo.lpszProxyBypass != NULL)
        delete[] ansiProxyInfo.lpszProxyBypass;

    return blReturnValue;
}



INTERNETAPI
BOOL
WINAPI
WinHttpGetIEProxyConfigForCurrentUser
(
    WINHTTP_CURRENT_USER_IE_PROXY_CONFIG * pProxyConfig
)
{
    WININET_PROXY_INFO_EX   WinInetProxyInfo;
    DWORD                   error = ERROR_SUCCESS;

    if (pProxyConfig == NULL ||
        IsBadWritePtr(pProxyConfig, sizeof(WINHTTP_CURRENT_USER_IE_PROXY_CONFIG)))
    {
        error = ERROR_INVALID_PARAMETER;
        goto quit;
    }

    if (!GlobalDataInitialized)
    {
        error = GlobalDataInitialize();

        if (error != ERROR_SUCCESS)
            goto quit;
    }

    memset(pProxyConfig, 0, sizeof(WINHTTP_CURRENT_USER_IE_PROXY_CONFIG));
    memset(&WinInetProxyInfo, 0, sizeof(WinInetProxyInfo));

    WinInetProxyInfo.dwStructSize = sizeof(WinInetProxyInfo);

    // GetActiveConnectionName will use RAS APIs to determine if
    // there are any active VPN or dial-up connections, and then return
    // the name of one of them. If no active VPN/dial-up connections
    // are found, then the function returns NULL, in which we'll
    // default to LAN Settings.
    WinInetProxyInfo.lpszConnectionName = GetActiveConnectionName();

    error = ReadWinInetProxySettings(&WinInetProxyInfo);

    if (error == ERROR_SUCCESS)
    {
        DWORD dwFlags = WinInetProxyInfo.dwFlags;

        if (dwFlags & PROXY_TYPE_AUTO_DETECT)
        {
            pProxyConfig->fAutoDetect = TRUE;
        }

        if ((dwFlags & PROXY_TYPE_AUTO_PROXY_URL) && WinInetProxyInfo.lpszAutoconfigUrl)
        {
            AsciiToWideChar_UsingGlobalAlloc(WinInetProxyInfo.lpszAutoconfigUrl,
                    &pProxyConfig->lpszAutoConfigUrl);
        }

        if ((dwFlags & PROXY_TYPE_PROXY) && WinInetProxyInfo.lpszProxy)
        {
            if (ERROR_SUCCESS == AsciiToWideChar_UsingGlobalAlloc(
                        WinInetProxyInfo.lpszProxy,
                        &pProxyConfig->lpszProxy)
                )
            {
                if (WinInetProxyInfo.lpszProxyBypass)
                {
                    AsciiToWideChar_UsingGlobalAlloc(WinInetProxyInfo.lpszProxyBypass,
                            &pProxyConfig->lpszProxyBypass);
                }
            }
        }
    }

    CleanWinInetProxyStruct(&WinInetProxyInfo);

quit:
    if (error != ERROR_SUCCESS)
    {
        SetLastError(error);
    }

    return (error == ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5.1\auth\auth.h ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    auth.h

Abstract:

    Private include file for 

Author:

    Rajeev Dujari (rajeevd) 28-Jul-97
    
Revision History:

--*/

//
// manifests
//
 
#define HTTP_AUTHORIZATION_SZ           "Authorization:"
#define HTTP_AUTHORIZATION_LEN          (sizeof(HTTP_AUTHORIZATION_SZ)-1)

#define HTTP_PROXY_AUTHORIZATION_SZ     "Proxy-Authorization:"
#define HTTP_PROXY_AUTHORIZATION_LEN    (sizeof(HTTP_PROXY_AUTHORIZATION_SZ)-1)


//
// prototypes - versions of spluginx.hxx for basic auth
//


void UrlZonesDetach (void);

//#ifdef __cplusplus
//extern "C" {
//#endif

extern DWORD g_cSspiContexts; // refcount of sspi contexts

DWORD SSPI_Unload();

DWORD_PTR SSPI_InitScheme (LPCSTR pszScheme);

//#ifdef __cplusplus
//} // end extern "C" {
//#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5.1\api\parseurl.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    parseurl.cxx

Abstract:

    Contains functions to parse the basic URLs - FTP, Gopher, HTTP.

    An URL parser simply acts as a macro: it must break out the protocol-specific
    information from the URL and initiate opening the identified resource: all
    this can be accomplished by calling the relevant Internet protocol APIs.

    Code in this module is based on RFC1738

    Contents:
        IsValidUrl
        DoesSchemeRequireSlashes
        ParseUrl
        CrackUrl
        EncodeUrlPath
        (HexCharToNumber)
        (NumberToHexChar)
        DecodeUrl
        DecodeUrlInSitu
        DecodeUrlStringInSitu
        GetUrlAddressInfo
        GetUrlAddress
        MapUrlSchemeName
        MapUrlScheme
        MapUrlSchemeToName

Author:

    Richard L Firth (rfirth) 26-Apr-1995

Environment:

    Win32(s) user-mode DLL

Revision History:

    26-Apr-1995
        Created

--*/

#include <wininetp.h>

//
// private manifests
//

#define RESERVED    SAFE

//
// private macros
//

//#define HEX_CHAR_TO_NUMBER(ch) \
//    ((ch <= '9') \
//        ? (ch - '0') \
//        : ((ch >= 'a') \
//            ? ((ch - 'a') + 10) \
//            : ((ch - 'A') + 10)))

#define NUMBER_TO_HEX_CHAR(n) \
    (((n) <= 9) ? ((char)(n) + '0') : (((char)(n) - 10) + 'A'))

#define IS_UNSAFE_URL_CHARACTER(Char, Scheme) \
    (((UCHAR)(Char) <= 0x20) || ((UCHAR)(Char) >= 0x7f) \
    || (SafetyList[(Char) - 0x21] & (UNSAFE | Scheme)))

#define IS_UNSAFE_URL_WIDECHARACTER(wChar, Scheme) \
    (((WCHAR)(wChar) <= 0x0020) || ((WCHAR)(wChar) >= 0x007f) \
    || (SafetyList[(wChar) - 0x0021] & (UNSAFE | Scheme)))

//
// private types
//

//
// private prototypes
//

PRIVATE
char
HexCharToNumber(
    IN char ch
    );

PRIVATE
char
NumberToHexChar(
    IN int Number
    );


//
// private data
//

//
// SafetyList - the list of characters above 0x20 and below 0x7f that are
// classified as safe, unsafe or scheme-specific. Safe characters do not need
// to be escaped for any URL scheme. Unsafe characters must be escaped for all
// URL schemes. Scheme-specific characters need only be escaped for the relevant
// scheme(s)
//

const
PRIVATE
UCHAR
SafetyList[] = {

    //
    // UNSAFE: 0x00..0x20
    //

    SAFE | HOSTNAME,                        // 0x21 (!)
    UNSAFE,                                 // 0x22 (")
    UNSAFE,                                 // 0x23 (#)
    SAFE | HOSTNAME,                        // 0x24 ($)
    UNSAFE,                                 // 0x25 (%)
    RESERVED | HOSTNAME,                    // 0x26 (&)
    SAFE | HOSTNAME,                        // 0x27 (')
    SAFE | HOSTNAME,                        // 0x28 (()
    SAFE | HOSTNAME,                        // 0x29 ())
    SAFE | HOSTNAME,                        // 0x2A (*)
    SCHEME_GOPHER | HOSTNAME,               // 0x2B (+)
    SAFE | HOSTNAME,                        // 0x2C (,)
    SAFE,                                   // 0x2D (-)
    SAFE,                                   // 0x2E (.)
    RESERVED | HOSTNAME,                    // 0x2F (/)
    SAFE,                                   // 0x30 (0)
    SAFE,                                   // 0x31 (1)
    SAFE,                                   // 0x32 (2)
    SAFE,                                   // 0x33 (3)
    SAFE,                                   // 0x34 (4)
    SAFE,                                   // 0x35 (5)
    SAFE,                                   // 0x36 (6)
    SAFE,                                   // 0x37 (7)
    SAFE,                                   // 0x38 (8)
    SAFE,                                   // 0x39 (9)
    RESERVED | HOSTNAME,                    // 0x3A (:)
    RESERVED | HOSTNAME,                    // 0x3B (;)
    UNSAFE,                                 // 0x3C (<)
    RESERVED | HOSTNAME,                    // 0x3D (=)
    UNSAFE,                                 // 0x3E (>)
    RESERVED | SCHEME_GOPHER | HOSTNAME,    // 0x3F (?)
    RESERVED | HOSTNAME,                    // 0x40 (@)
    SAFE,                                   // 0x41 (A)
    SAFE,                                   // 0x42 (B)
    SAFE,                                   // 0x43 (C)
    SAFE,                                   // 0x44 (D)
    SAFE,                                   // 0x45 (E)
    SAFE,                                   // 0x46 (F)
    SAFE,                                   // 0x47 (G)
    SAFE,                                   // 0x48 (H)
    SAFE,                                   // 0x49 (I)
    SAFE,                                   // 0x4A (J)
    SAFE,                                   // 0x4B (K)
    SAFE,                                   // 0x4C (L)
    SAFE,                                   // 0x4D (M)
    SAFE,                                   // 0x4E (N)
    SAFE,                                   // 0x4F (O)
    SAFE,                                   // 0x50 (P)
    SAFE,                                   // 0x51 (Q)
    SAFE,                                   // 0x42 (R)
    SAFE,                                   // 0x43 (S)
    SAFE,                                   // 0x44 (T)
    SAFE,                                   // 0x45 (U)
    SAFE,                                   // 0x46 (V)
    SAFE,                                   // 0x47 (W)
    SAFE,                                   // 0x48 (X)
    SAFE,                                   // 0x49 (Y)
    SAFE,                                   // 0x5A (Z)
    UNSAFE,                                 // 0x5B ([)
    UNSAFE,                                 // 0x5C (\)
    UNSAFE,                                 // 0x5D (])
    UNSAFE,                                 // 0x5E (^)
    SAFE,                                   // 0x5F (_)
    UNSAFE,                                 // 0x60 (`)
    SAFE,                                   // 0x61 (a)
    SAFE,                                   // 0x62 (b)
    SAFE,                                   // 0x63 (c)
    SAFE,                                   // 0x64 (d)
    SAFE,                                   // 0x65 (e)
    SAFE,                                   // 0x66 (f)
    SAFE,                                   // 0x67 (g)
    SAFE,                                   // 0x68 (h)
    SAFE,                                   // 0x69 (i)
    SAFE,                                   // 0x6A (j)
    SAFE,                                   // 0x6B (k)
    SAFE,                                   // 0x6C (l)
    SAFE,                                   // 0x6D (m)
    SAFE,                                   // 0x6E (n)
    SAFE,                                   // 0x6F (o)
    SAFE,                                   // 0x70 (p)
    SAFE,                                   // 0x71 (q)
    SAFE,                                   // 0x72 (r)
    SAFE,                                   // 0x73 (s)
    SAFE,                                   // 0x74 (t)
    SAFE,                                   // 0x75 (u)
    SAFE,                                   // 0x76 (v)
    SAFE,                                   // 0x77 (w)
    SAFE,                                   // 0x78 (x)
    SAFE,                                   // 0x79 (y)
    SAFE,                                   // 0x7A (z)
    UNSAFE,                                 // 0x7B ({)
    UNSAFE,                                 // 0x7C (|)
    UNSAFE,                                 // 0x7D (})
    UNSAFE                                  // 0x7E (~)

    //
    // UNSAFE: 0x7F..0xFF
    //

};

//
// UrlSchemeList - the list of schemes that we support
//

typedef struct {
    LPSTR SchemeName;
    DWORD SchemeLength;
    INTERNET_SCHEME SchemeType;
    DWORD SchemeFlags;
    BOOL NeedSlashes;
    DWORD OpenFlags;
} URL_SCHEME_INFO;


const
PRIVATE
URL_SCHEME_INFO
UrlSchemeList[] = {
    NULL,           0,  INTERNET_SCHEME_DEFAULT,    0,              FALSE,  0,
    "http",         4,  INTERNET_SCHEME_HTTP,       SCHEME_HTTP,    TRUE,   0,
    "https",        5,  INTERNET_SCHEME_HTTPS,      SCHEME_HTTP,    TRUE,   WINHTTP_FLAG_SECURE,
};

#define NUMBER_OF_URL_SCHEMES   ARRAY_ELEMENTS(UrlSchemeList)

BOOL ScanSchemes(LPTSTR pszToCheck, DWORD ccStr, PDWORD pwResult)
{
    for (DWORD i=0; i<NUMBER_OF_URL_SCHEMES; i++)
    {
        if ((UrlSchemeList[i].SchemeLength == ccStr)
            && (strnicmp(UrlSchemeList[i].SchemeName, pszToCheck, ccStr)==0))
        {
            *pwResult = i;
            return TRUE;
        }
    }
    return FALSE;
}

//
// functions
//


BOOL
IsValidUrl(
    IN LPCSTR lpszUrl
    )

/*++

Routine Description:

    Determines whether an URL has a valid format

Arguments:

    lpszUrl - pointer to URL to check.

    Assumes:    1. lpszUrl is non-NULL, non-empty string

Return Value:

    BOOL

--*/

{
    INET_ASSERT(lpszUrl != NULL);
    INET_ASSERT(*lpszUrl != '\0');

    while (*lpszUrl != '\0') {
        if (IS_UNSAFE_URL_CHARACTER(*lpszUrl, SCHEME_ANY)) {
            return FALSE;
        }
        ++lpszUrl;
    }
    return TRUE;
}

BOOL
IsValidHostName(
    IN LPCSTR lpszHostName
    )

/*++

Routine Description:

    Determines whether an URL has a valid format

Arguments:

    lpszHostName - pointer to URL to check.

    Assumes:    1. lpszHostName is non-NULL, non-empty string

Return Value:

    BOOL

--*/

{
    INET_ASSERT(lpszHostName != NULL);
    INET_ASSERT(*lpszHostName != '\0');

    while (*lpszHostName != '\0') {
        if (IS_UNSAFE_URL_CHARACTER(*lpszHostName, HOSTNAME)) {
            return FALSE;
        }
        ++lpszHostName;
    }
    return TRUE;
}



BOOL
DoesSchemeRequireSlashes(
    IN LPSTR lpszScheme,
    IN DWORD dwSchemeLength,
    IN BOOL bHasHostName
    )

/*++

Routine Description:

    Determines whether a protocol scheme requires slashes

Arguments:

    lpszScheme      - pointer to protocol scheme in question
                      (does not include ':' or slashes, just scheme name)

    dwUrlLength     - if not 0, string length of lpszScheme

Return Value:

    BOOL

--*/

{
    DWORD i;

    //
    // if dwSchemeLength is 0 then lpszUrl is ASCIIZ. Find its length
    //

    if (dwSchemeLength == 0) {
        dwSchemeLength = strlen(lpszScheme);
    }

    if (ScanSchemes(lpszScheme, dwSchemeLength, &i))
    {
        return UrlSchemeList[i].NeedSlashes;
    }
    return bHasHostName;
}


DWORD
CrackUrl(
    IN OUT LPSTR lpszUrl,
    IN DWORD dwUrlLength,
    IN BOOL bEscape,
    OUT LPINTERNET_SCHEME lpSchemeType OPTIONAL,
    OUT LPSTR* lpszSchemeName OPTIONAL,
    OUT LPDWORD lpdwSchemeNameLength OPTIONAL,
    OUT LPSTR* lpszHostName OPTIONAL,
    OUT LPDWORD lpdwHostNameLength OPTIONAL,
    IN  BOOL fUnescapeHostName,
    OUT LPINTERNET_PORT lpServerPort OPTIONAL,
    OUT LPSTR* lpszUserName OPTIONAL,
    OUT LPDWORD lpdwUserNameLength OPTIONAL,
    OUT LPSTR* lpszPassword OPTIONAL,
    OUT LPDWORD lpdwPasswordLength OPTIONAL,
    OUT LPSTR* lpszUrlPath OPTIONAL,
    OUT LPDWORD lpdwUrlPathLength OPTIONAL,
    OUT LPSTR* lpszExtraInfo OPTIONAL,
    OUT LPDWORD lpdwExtraInfoLength OPTIONAL,
    OUT LPBOOL pHavePort
    )

/*++

Routine Description:

    Cracks an URL into its constituent parts

    Assumes: 1. If one of the optional lpsz fields is present (e.g. lpszUserName)
                then the accompanying lpdw field must also be supplied

Arguments:

    lpszUrl                 - pointer to URL to crack. This buffer WILL BE
                              OVERWRITTEN if it contains escape sequences that
                              we will convert back to ANSI characters

    dwUrlLength             - if not 0, string length of lpszUrl

    bEscape                 - TRUE if we are to escape the url-path

    lpSchemeType            - returned scheme type - e.g. INTERNET_SCHEME_HTTP

    lpszSchemeName          - returned scheme name

    lpdwSchemeNameLength    - length of scheme name

    lpszHostName            - returned host name

    lpdwHostNameLength      - length of host name buffer

    lpServerPort            - returned server port if present in the URL, else 0

    lpszUserName            - returned user name if present

    lpdwUserNameLength      - length of user name buffer

    lpszPassword            - returned password if present

    lpdwPasswordLength      - length of password buffer

    lpszUrlPath             - returned, canonicalized URL path

    lpdwUrlPathLength       - length of url-path buffer

    lpszExtraInfo           - returned search string or intra-page link if present

    lpdwExtraInfoLength     - length of extra info buffer

    pHavePort               - returned boolean indicating whether port was specified

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_WINHTTP_UNRECOGNIZED_SCHEME

--*/

{
    DWORD error;
    DWORD schemeLength;
    INTERNET_SCHEME schemeType;

    //
    // if dwUrlLength is 0 then lpszUrl is ASCIIZ. Find its length
    //

    if (dwUrlLength == 0) {
        dwUrlLength = strlen(lpszUrl);
    }

    //
    // get parser based on the protocol name
    //

    for (schemeLength = 0; lpszUrl[schemeLength] != ':'; ++schemeLength) {
        if ((dwUrlLength == 0) || (lpszUrl[schemeLength] == '\0')) {

            //
            // no ':' in URL? Bogus (dude)
            //

            error = ERROR_WINHTTP_UNRECOGNIZED_SCHEME;
            goto quit;
        }
        --dwUrlLength;
    }

    DWORD i;
    int skip;
    BOOL isGeneric;
    BOOL needSlashes;
    BOOL haveSlashes;

    isGeneric = FALSE;
    needSlashes = FALSE;
    haveSlashes = FALSE;

    schemeType = INTERNET_SCHEME_UNKNOWN;

    if (ScanSchemes(lpszUrl, schemeLength, &i))
    {
        schemeType = UrlSchemeList[i].SchemeType;
        needSlashes = UrlSchemeList[i].NeedSlashes;
    }
    else
    {
        error = ERROR_WINHTTP_UNRECOGNIZED_SCHEME;
        goto quit;
    }

    skip = 1;       // skip ':'

    if ((dwUrlLength > 3) && (memcmp(&lpszUrl[schemeLength], "://", 3) == 0)) {
        skip = 3;   // skip "://"
        haveSlashes = TRUE;
    }

    //
    // If we don't have slashes, make sure we don't need them.
    // If we have slashes, make sure they are required.
    //

    if ((!haveSlashes && !needSlashes) || (haveSlashes && needSlashes)) {
        if (ARGUMENT_PRESENT(lpSchemeType)) {
            *lpSchemeType = schemeType;
        }
        if (ARGUMENT_PRESENT(lpszSchemeName)) {
            *lpszSchemeName = lpszUrl;
            *lpdwSchemeNameLength = schemeLength;
        }
        lpszUrl += schemeLength + skip;
        dwUrlLength -= skip;

        if (isGeneric) {
            if (ARGUMENT_PRESENT(lpszUserName)) {
                *lpszUserName = NULL;
                *lpdwUserNameLength = 0;
            }
            if (ARGUMENT_PRESENT(lpszPassword)) {
                *lpszPassword = NULL;
                *lpdwPasswordLength = 0;
            }
            if (ARGUMENT_PRESENT(lpszHostName)) {
                *lpszHostName = NULL;
                *lpdwHostNameLength = 0;
            }
            if (ARGUMENT_PRESENT(lpServerPort)) {
                *lpServerPort = 0;
            }
            error = ERROR_SUCCESS;
        } else {
            error = GetUrlAddress(&lpszUrl,
                                  &dwUrlLength,
                                  lpszUserName,
                                  lpdwUserNameLength,
                                  lpszPassword,
                                  lpdwPasswordLength,
                                  lpszHostName,
                                  lpdwHostNameLength,
                                  fUnescapeHostName,
                                  lpServerPort,
                                  pHavePort
                                  );
        }
        if (bEscape && (error == ERROR_SUCCESS)) {
            error = DecodeUrlInSitu(lpszUrl, &dwUrlLength);
        }
        if ((error == ERROR_SUCCESS) && ARGUMENT_PRESENT(lpszExtraInfo)) {
            *lpdwExtraInfoLength = 0;
            for (i = 0; i < (int)dwUrlLength; i++) {
                if (lpszUrl[i] == '?' || lpszUrl[i] == '#') {
                    *lpszExtraInfo = &lpszUrl[i];
                    *lpdwExtraInfoLength = dwUrlLength - i;
                    dwUrlLength -= *lpdwExtraInfoLength;
                }
            }
        }
        if ((error == ERROR_SUCCESS) && ARGUMENT_PRESENT(lpszUrlPath)) {
            *lpszUrlPath = lpszUrl;
            *lpdwUrlPathLength = dwUrlLength;
        }
    } else {
        error = ERROR_WINHTTP_UNRECOGNIZED_SCHEME;
    }

quit:

    return error;
}

#define DEFAULT_REALLOC_SIZE 1024

DWORD
EncodeUrlPath(
    IN DWORD Flags,
    IN DWORD SchemeFlags,
    IN LPSTR UrlPath,
    IN DWORD UrlPathLength,
    OUT LPSTR* pEncodedUrlPath,
    IN OUT LPDWORD EncodedUrlPathLength
    )

/*++

Routine Description:

    Encodes an URL-path. That is, escapes the string. Creates a new URL-path in
    which all the 'unsafe' and reserved characters for this scheme have been
    converted to escape sequences

Arguments:

    Flags                   - controlling expansion

    SchemeFlags             - which scheme we are encoding for -
                              SCHEME_HTTP, etc.

    UrlPath                 - pointer to the unescaped string

    UrlPathLength           - length of Url

    EncodedUrlPath          - pointer to buffer where encoded URL will be
                              written

    EncodedUrlPathLength    - IN: size of EncodedUrlPath
                              OUT: number of bytes written to EncodedUrlPath

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INSUFFICIENT_BUFFER
                    UrlPathLength not large enough to store encoded URL path

--*/

{
    DWORD error;
    DWORD len;

    len = *EncodedUrlPathLength;
    LPSTR EncodedUrlPath = *pEncodedUrlPath;
    UCHAR ch;

    UNREFERENCED_PARAMETER(UrlPathLength);

    while(0 != (ch = (UCHAR)*UrlPath++))
    {
        //
        // check whether this character is safe. For now, we encode all unsafe
        // and scheme-specific characters the same way (i.e. irrespective of
        // scheme)
        //
        // We are allowing '/' to be copied unmodified
        //

        if (len < 3) 
        {
            LPSTR pStr = (LPSTR)REALLOCATE_MEMORY(*pEncodedUrlPath, *EncodedUrlPathLength+DEFAULT_REALLOC_SIZE);

            if (pStr)
            {
                EncodedUrlPath = pStr+*EncodedUrlPathLength-len;
                *pEncodedUrlPath = pStr;
                len += DEFAULT_REALLOC_SIZE;
                *EncodedUrlPathLength += DEFAULT_REALLOC_SIZE;
            }
            else
            {                
                goto error;
            }
        }
        
        if (IS_UNSAFE_URL_CHARACTER(ch, SchemeFlags)
        && !((ch == '/') && (Flags & NO_ENCODE_PATH_SEP))) 
        {
            *EncodedUrlPath++ = '%';
            //*EncodedUrlPath++ = NumberToHexChar((int)ch / 16);
            *EncodedUrlPath++ = (CHAR)NUMBER_TO_HEX_CHAR((int)ch / 16);
            //*EncodedUrlPath++ = NumberToHexChar((int)ch % 16);
            *EncodedUrlPath++ = (CHAR)NUMBER_TO_HEX_CHAR((int)ch % 16);
            len -= 2; // extra --len below
        } 
        else 
        {
            *EncodedUrlPath++ = (signed char)ch;
        }
        --len;
    }
    
    *EncodedUrlPath = '\0';
    *EncodedUrlPathLength -= len;
    error = ERROR_SUCCESS;

quit:
    return error;

error:
    error = ERROR_INSUFFICIENT_BUFFER;
    goto quit;
}


PRIVATE
char
HexCharToNumber(
    IN char ch
    )

/*++

Routine Description:

    Converts an ANSI character in the range '0'..'9' 'A'..'F' 'a'..'f' to its
    corresponding hexadecimal value (0..f)

Arguments:

    ch  - character to convert

Return Value:

    char
        hexadecimal value of ch, as an 8-bit (signed) character value

--*/

{
    return (CHAR)((ch <= '9') ? (ch - '0')
                       : ((ch >= 'a') ? ((ch - 'a') + 10) : ((ch - 'A') + 10)));
}


PRIVATE
char
NumberToHexChar(
    IN int Number
    )

/*++

Routine Description:

    Converts a number in the range 0..15 to its ASCII character hex representation
    ('0'..'F')

Arguments:

    Number  - to convert

Return Value:

    char
        character in above range

--*/

{
    return (Number <= 9) ? (char)('0' + Number) : (char)('A' + (Number - 10));
}


DWORD
DecodeUrl(
    IN LPSTR Url,
    IN DWORD UrlLength,
    OUT LPSTR DecodedString,
    IN OUT LPDWORD DecodedLength
    )

/*++

Routine Description:

    Converts an URL string with embedded escape sequences (%xx) to a counted
    string

    It is safe to pass the same pointer for the string to convert, and the
    buffer for the converted results: if the current character is not escaped,
    it just gets overwritten, else the input pointer is moved ahead 2 characters
    further than the output pointer, which is benign

Arguments:

    Url             - pointer to URL string to convert

    UrlLength       - number of characters in UrlString

    DecodedString   - pointer to buffer that receives converted string

    DecodedLength   - IN: number of characters in buffer
                      OUT: number of characters converted

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_WINHTTP_INVALID_URL
                    UrlString couldn't be converted

                  ERROR_INSUFFICIENT_BUFFER
                    ConvertedString isn't large enough to hold all the converted
                    UrlString

--*/

{
    DWORD bufferRemaining;

    bufferRemaining = *DecodedLength;
    while (UrlLength && bufferRemaining) {

        char ch;

        if (*Url == '%') {

            //
            // BUGBUG - would %00 ever appear in an URL?
            //

            ++Url;
            if (isxdigit(*Url)) {
                ch = HexCharToNumber(*Url++) << 4;
                if (isxdigit(*Url)) {
                    ch |= HexCharToNumber(*Url++);
                } else {
                    return ERROR_WINHTTP_INVALID_URL;
                }
            } else {
                return ERROR_WINHTTP_INVALID_URL;
            }
            UrlLength -= 3;
        } else {
            ch = *Url++;
            --UrlLength;
        }
        *DecodedString++ = ch;
        --bufferRemaining;
    }
    if (UrlLength == 0) {
        *DecodedLength -= bufferRemaining;
        return ERROR_SUCCESS;
    } else {
        return ERROR_INSUFFICIENT_BUFFER;
    }
}


DWORD
DecodeUrlInSitu(
    IN LPSTR BufferAddress,
    IN OUT LPDWORD BufferLength
    )

/*++

Routine Description:

    Decodes an URL string, if it contains escape sequences. The conversion is
    done in place, since we know that a string containing escapes is longer than
    the string with escape sequences (3 bytes) converted to characters (1 byte)

Arguments:

    BufferAddress   - pointer to the string to convert

    BufferLength    - IN: number of characters to convert
                      OUT: length of converted string

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_WINHTTP_INVALID_URL
                  ERROR_INSUFFICIENT_BUFFER

--*/

{
    DWORD stringLength;

    stringLength = *BufferLength;
    if (memchr(BufferAddress, '%', stringLength)) {
        return DecodeUrl(BufferAddress,
                         stringLength,
                         BufferAddress,
                         BufferLength
                         );
    } else {

        //
        // no escape character in the string, just return success
        //

        return ERROR_SUCCESS;
    }
}


DWORD
DecodeUrlStringInSitu(
    IN LPSTR BufferAddress,
    IN OUT LPDWORD BufferLength
    )

/*++

Routine Description:

    Performs DecodeUrlInSitu() on a string and zero terminates it

    Assumes: 1. Even if no decoding is performed, *BufferLength is large enough
                to fit an extra '\0' character

Arguments:

    BufferAddress   - pointer to the string to convert

    BufferLength    - IN: number of characters to convert
                      OUT: length of converted string, excluding '\0'

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_WINHTTP_INVALID_URL
                  ERROR_INSUFFICIENT_BUFFER

--*/

{
    DWORD error;

    error = DecodeUrlInSitu(BufferAddress, BufferLength);
    if (error == ERROR_SUCCESS) {
        BufferAddress[*BufferLength] = '\0';
    }
    return error;
}


DWORD
GetUrlAddressInfo(
    IN OUT LPSTR* Url,
    IN OUT LPDWORD UrlLength,
    OUT LPSTR* PartOne,
    OUT LPDWORD PartOneLength,
    OUT LPBOOL PartOneEscape,
    OUT LPSTR* PartTwo,
    OUT LPDWORD PartTwoLength,
    OUT LPBOOL PartTwoEscape
    )

/*++

Routine Description:

    Given a string of the form foo:bar, splits them into 2 counted strings about
    the ':' character. The address string may or may not contain a ':'.

    This function is intended to split into substrings the host:port and
    username:password strings commonly used in Internet address specifications
    and by association, in URLs

Arguments:

    Url             - pointer to pointer to string containing URL. On output
                      this is advanced past the address parts

    UrlLength       - pointer to length of URL in UrlString. On output this is
                      reduced by the number of characters parsed

    PartOne         - pointer which will receive first part of address string

    PartOneLength   - pointer which will receive length of first part of address
                      string

    PartOneEscape   - TRUE on output if PartOne contains escape sequences

    PartTwo         - pointer which will receive second part of address string

    PartTwoLength   - pointer which will receive length of second part of address
                      string

    PartOneEscape   - TRUE on output if PartTwo contains escape sequences

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_WINHTTP_INVALID_URL

--*/

{
    LPSTR pString;
    LPSTR pColon;
    DWORD partLength;
    LPBOOL partEscape;
    DWORD length;

    //
    // parse out <host>[:<port>] or <name>[:<password>] (i.e. <part1>[:<part2>]
    //

    pString = *Url;
    pColon = NULL;
    partLength = 0;
    *PartOne = pString;
    *PartOneLength = 0;
    *PartOneEscape = FALSE;
    *PartTwoEscape = FALSE;
    partEscape = PartOneEscape;
    length = *UrlLength;
    while ((*pString != '/') && (*pString != '\0') && (length != 0)) {
        if (*pString == '%') {

            //
            // if there is a % in the string then it *must* (RFC 1738) be the
            // start of an escape sequence. This function just reports the
            // address of the substrings and their lengths; calling functions
            // must handle the escape sequences (i.e. it is their responsibility
            // to decide where to put the results)
            //

            *partEscape = TRUE;
        }
        if (*pString == ':') {
            if (pColon != NULL) {

                //
                // we don't expect more than 1 ':'
                //

                return ERROR_WINHTTP_INVALID_URL;
            }
            pColon = pString;
            *PartOneLength = partLength;
            if (partLength == 0) {
                *PartOne = NULL;
            }
            partLength = 0;
            partEscape = PartTwoEscape;
        } else {
            ++partLength;
        }
        ++pString;
        --length;
    }

    //
    // we either ended on the host (or user) name or the port number (or
    // password), one of which we don't know the length of
    //

    if (pColon == NULL) {
        *PartOneLength = partLength;
        *PartTwo = NULL;
        *PartTwoLength = 0;
        *PartTwoEscape = FALSE;
    } else {
        *PartTwoLength = partLength;
        *PartTwo = pColon + 1;

        //
        // in both the <user>:<password> and <host>:<port> cases, we cannot have
        // the second part without the first, although both parts being zero
        // length is OK (host name will be sorted out elsewhere, but (for now,
        // at least) I am allowing <>:<> for username:password, since I don't
        // see it expressly disallowed in the RFC. I may be revisiting this code
        // later...)
        //
        // N.B.: ftp://ftp.microsoft.com uses http://:0/-http-gw-internal-/menu.gif

//      if ((*PartOneLength == 0) && (partLength != 0)) {
//          return ERROR_WINHTTP_INVALID_URL;
//      }
    }

    //
    // update the URL pointer and length remaining
    //

    *Url = pString;
    *UrlLength = length;

    return ERROR_SUCCESS;
}


DWORD
GetUrlAddress(
    IN OUT LPSTR* lpszUrl,
    OUT LPDWORD lpdwUrlLength,
    OUT LPSTR* lpszUserName OPTIONAL,
    OUT LPDWORD lpdwUserNameLength OPTIONAL,
    OUT LPSTR* lpszPassword OPTIONAL,
    OUT LPDWORD lpdwPasswordLength OPTIONAL,
    OUT LPSTR* lpszHostName OPTIONAL,
    OUT LPDWORD lpdwHostNameLength OPTIONAL,
    IN  BOOL fUnescapeHostName,
    OUT LPINTERNET_PORT lpPort OPTIONAL,
    OUT LPBOOL pHavePort
    )

/*++

Routine Description:

    This function extracts any and all parts of the address information for a
    generic URL. If any of the address parts contain escaped characters (%nn)
    then they are converted in situ

    The generic addressing format (RFC 1738) is:

        <user>:<password>@<host>:<port>

    The addressing information cannot contain a password without a user name,
    or a port without a host name
    NB: ftp://ftp.microsoft.com uses URL's that have a port without a host name!
    (e.g. http://:0/-http-gw-internal-/menu.gif)

    Although only the lpszUrl and lpdwUrlLength fields are required, the address
    parts will be checked for presence and completeness

    Assumes: 1. If one of the optional lpsz fields is present (e.g. lpszUserName)
                then the accompanying lpdw field must also be supplied

Arguments:

    lpszUrl             - IN: pointer to the URL to parse
                          OUT: URL remaining after address information

                          N.B. The url-path is NOT canonicalized (unescaped)
                          because it may contain protocol-specific information
                          which must be parsed out by the protocol-specific
                          parser

    lpdwUrlLength       - returned length of the remainder of the URL after the
                          address information

    lpszUserName        - returned pointer to the user name
                          This parameter can be omitted by those protocol parsers
                          that do not require or expect user names in the URL

    lpdwUserNameLength  - returned length of the user name part
                          This parameter can be omitted by those protocol parsers
                          that do not require or expect user names in the URL

    lpszPassword        - returned pointer to the password
                          This parameter can be omitted by those protocol parsers
                          that do not require or expect user passwords in the URL

    lpdwPasswordLength  - returned length of the password
                          This parameter can be omitted by those protocol parsers
                          that do not require or expect user passwords in the URL

    lpszHostName        - returned pointer to the host name
                          This parameter can be omitted by those protocol parsers
                          that do not require the host name info

    lpdwHostNameLength  - returned length of the host name
                          This parameter can be omitted by those protocol parsers
                          that do not require the host name info

    lpPort              - returned value of the port field
                          This parameter can be omitted by those protocol parsers
                          that do not require or expect user port number

    pHavePort           - returned boolean indicating whether a port was specified
                          in the URL or not.  This value is not returned if the
                          lpPort parameter is omitted.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_WINHTTP_INVALID_URL
                    We could not parse some part of the address info, or we
                    found address info where the protocol parser didn't expect
                    any

                  ERROR_INSUFFICIENT_BUFFER
                    We could not convert an escaped string

--*/

{
    LPSTR pAt;
    DWORD urlLength;
    LPSTR pUrl;
    BOOL part1Escape;
    BOOL part2Escape;
    char portNumber[INTERNET_MAX_PORT_NUMBER_LENGTH + 1];
    DWORD portNumberLength;
    LPSTR pPortNumber;
    DWORD error;
    LPSTR hostName;
    DWORD hostNameLength;

    pUrl = *lpszUrl;
    urlLength = strlen(pUrl);

    //
    // check to see if there is an '@' separating user name & password. If we
    // see a '/' or get to the end of the string before we see the '@' then
    // there is no username:password part
    //

    pAt = NULL;
    for (DWORD i = 0; i < urlLength; ++i) {
        if (pUrl[i] == '/') {
            break;
        } else if (pUrl[i] == '@') {
            pAt = &pUrl[i];
            break;
        }
    }

    if (pAt != NULL) {

        DWORD addressPartLength;
        LPSTR userName;
        DWORD userNameLength;
        LPSTR password;
        DWORD passwordLength;

        addressPartLength = (DWORD) (pAt - pUrl);
        urlLength -= addressPartLength;
        error = GetUrlAddressInfo(&pUrl,
                                  &addressPartLength,
                                  &userName,
                                  &userNameLength,
                                  &part1Escape,
                                  &password,
                                  &passwordLength,
                                  &part2Escape
                                  );
        if (error != ERROR_SUCCESS) {
            return error;
        }

        //
        // ensure there is no address information unparsed before the '@'
        //

        INET_ASSERT(addressPartLength == 0);
        INET_ASSERT(pUrl == pAt);

        if (ARGUMENT_PRESENT(lpszUserName)) {

            INET_ASSERT(ARGUMENT_PRESENT(lpdwUserNameLength));

            //
            // convert the user name in situ
            //

            if (part1Escape) {

                INET_ASSERT(userName != NULL);
                INET_ASSERT(userNameLength != 0);

                error = DecodeUrlInSitu(userName, &userNameLength);
                if (error != ERROR_SUCCESS) {
                    return error;
                }
            }
            *lpszUserName = userName;
            *lpdwUserNameLength = userNameLength;
        }

        if (ARGUMENT_PRESENT(lpszPassword)) {

            //
            // convert the password in situ
            //

            if (part2Escape) {

                INET_ASSERT(userName != NULL);
                INET_ASSERT(userNameLength != 0);
                INET_ASSERT(password != NULL);
                INET_ASSERT(passwordLength != 0);

                error = DecodeUrlInSitu(password, &passwordLength);
                if (error != ERROR_SUCCESS) {
                    return error;
                }
            }
            *lpszPassword = password;
            *lpdwPasswordLength = passwordLength;
        }

        //
        // the URL pointer now points at the host:port fields (remember that
        // ExtractAddressParts() must have bumped pUrl up to the end of the
        // password field (if present) which ends at pAt)
        //

        ++pUrl;

        //
        // similarly, bump urlLength to account for the '@'
        //

        --urlLength;
    } else {

        //
        // no '@' therefore no username or password
        //

        if (ARGUMENT_PRESENT(lpszUserName)) {

            INET_ASSERT(ARGUMENT_PRESENT(lpdwUserNameLength));

            *lpszUserName = NULL;
            *lpdwUserNameLength = 0;
        }
        if (ARGUMENT_PRESENT(lpszPassword)) {

            INET_ASSERT(ARGUMENT_PRESENT(lpdwPasswordLength));

            *lpszPassword = NULL;
            *lpdwPasswordLength = 0;
        }
    }

    //
    // now get the host name and the optional port
    //

    pPortNumber = portNumber;
    portNumberLength = sizeof(portNumber);
    error = GetUrlAddressInfo(&pUrl,
                              &urlLength,
                              &hostName,
                              &hostNameLength,
                              &part1Escape,
                              &pPortNumber,
                              &portNumberLength,
                              &part2Escape
                              );
    if (error != ERROR_SUCCESS) {
        return error;
    }

    //
    // the URL address information MUST contain the host name
    //

//  if ((hostName == NULL) || (hostNameLength == 0)) {
//      return ERROR_WINHTTP_INVALID_URL;
//  }

    if (ARGUMENT_PRESENT(lpszHostName)) {

        INET_ASSERT(ARGUMENT_PRESENT(lpdwHostNameLength));

        //
        // if the host name contains escaped characters, convert them in situ
        //

        if (part1Escape && fUnescapeHostName) {
            error = DecodeUrlInSitu(hostName, &hostNameLength);
            if (error != ERROR_SUCCESS) {
                return error;
            }
        }
        *lpszHostName = hostName;
        *lpdwHostNameLength = hostNameLength;
    }

    //
    // if there is a port field, convert it if there are escaped characters,
    // check it for valid numeric characters, and convert it to a number
    //

    if (ARGUMENT_PRESENT(lpPort)) {
        if (portNumberLength != 0) {

            DWORD i;
            DWORD port;

            INET_ASSERT(pPortNumber != NULL);

            if (part2Escape) {
                error = DecodeUrlInSitu(pPortNumber, &portNumberLength);
                if (error != ERROR_SUCCESS) {
                    return error;
                }
            }

            //
            // ensure all characters in the port number buffer are numeric, and
            // calculate the port number at the same time
            //

            for (i = 0, port = 0; i < portNumberLength; ++i) {
                if (!isdigit(*pPortNumber)) {
                    return ERROR_WINHTTP_INVALID_URL;
                }
                port = port * 10 + (int)(*pPortNumber++ - '0');
                // We won't allow ports larger than 65535 ((2^16)-1)
                // We have to check this every time to make sure that someone
                // doesn't try to overflow a DWORD.
                if (port > 65535)
                {
                    return ERROR_WINHTTP_INVALID_URL;
                }
            }
            *lpPort = (INTERNET_PORT)port;
            if (ARGUMENT_PRESENT(pHavePort)) {
                *pHavePort = TRUE;
            }
        } else {
            *lpPort = INTERNET_INVALID_PORT_NUMBER;
            if (ARGUMENT_PRESENT(pHavePort)) {
                *pHavePort = FALSE;
            }
        }
    }

    //
    // update the URL pointer and the length of the url-path
    //

    *lpszUrl = pUrl;
    *lpdwUrlLength = urlLength;

    return ERROR_SUCCESS;
}


INTERNET_SCHEME
MapUrlSchemeName(
    IN LPSTR lpszSchemeName,
    IN DWORD dwSchemeNameLength
    )

/*++

Routine Description:

    Maps a scheme name/length to a scheme name type

Arguments:

    lpszSchemeName      - pointer to name of scheme to map

    dwSchemeNameLength  - length of scheme (if -1, lpszSchemeName is ASCIZ)

Return Value:

    INTERNET_SCHEME

--*/

{
    if (dwSchemeNameLength == (DWORD)-1) {
        dwSchemeNameLength = (DWORD)lstrlen(lpszSchemeName);
    }

    DWORD i;
    if (ScanSchemes(lpszSchemeName, dwSchemeNameLength, &i))
    {
        return UrlSchemeList[i].SchemeType;
    }
    return INTERNET_SCHEME_UNKNOWN;
}


LPSTR
MapUrlScheme(
    IN INTERNET_SCHEME Scheme,
    OUT LPDWORD lpdwSchemeNameLength
    )

/*++

Routine Description:

    Maps the enumerated scheme name type to the name

Arguments:

    Scheme                  - enumerated scheme type to map

    lpdwSchemeNameLength    - pointer to returned length of scheme name

Return Value:

    LPSTR   - pointer to scheme name or NULL

--*/

{
    if ((Scheme >= INTERNET_SCHEME_FIRST)
    && (Scheme <= INTERNET_SCHEME_LAST)) 
    {
        *lpdwSchemeNameLength = UrlSchemeList[Scheme].SchemeLength;
        return UrlSchemeList[Scheme].SchemeName;
    }
    *lpdwSchemeNameLength = 0;
    return NULL;
}


LPSTR
MapUrlSchemeToName(
    IN INTERNET_SCHEME Scheme
    )

/*++

Routine Description:

    Maps the enumerated scheme name type to the name

Arguments:

    Scheme  - enumerated scheme type to map

Return Value:

    LPSTR   - pointer to scheme name or NULL

--*/

{
    if ((Scheme >= INTERNET_SCHEME_FIRST)
    && (Scheme <= INTERNET_SCHEME_LAST)) {
        return UrlSchemeList[Scheme].SchemeName;
    }
    return NULL;
}




//
//
// UnsafeInPathAndQueryFlags   flag in table set to 1 if symbol is unsafe for path or query
//                             question mark treated as safe
//                             this table is fater then SafetyList because it requires no substraction and no masking
//                             and only one bound checking to access it
//
//
const
PRIVATE
BYTE
UnsafeInPathAndQueryFlags[128] = {
//  00  01  02  03  04  05  06  07  08  09  0a  0b  0c  0d  0e  0f
//  xx  xx  xx  xx  xx  xx  xx  xx  xx  xx  xx  xx  xx  xx  xx  xx
    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,

//  10  11  12  13  14  15  16  17  18  19  1a  1b  1c  1d  1e  1f
//  xx  xx  xx  xx  xx  xx  xx  xx  xx  xx  xx  xx  xx  xx  xx  xx
    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,

//  20  21  22  23  24  25  26  27  28  29  2a  2b  2c  2d  2e  2f
//      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
    1,  0,  1,  1,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,

//  30  31  32  33  34  35  36  37  38  39  3a  3b  3c  3d  3e  3f
//  0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  1,  0,

//  40  41  42  43  44  45  46  47  48  49  4a  4b  4c  4d  4e  4f
//  @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,

//  50  51  52  53  54  55  56  57  58  59  5a  5b  5c  5d  5e  5f
//  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  1,  1,  0,

//  60  61  62  63  64  65  66  67  68  69  6a  6b  6c  6d  6e  6f
//  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
    1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,

//  70  71  72  73  74  75  76  77  78  79  7a  7b  7c  7d  7e  7f
//  p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~   xx
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  1,  0,  1
};





//
//
// ADD_HEX_TO_STRING   adds ch in "%hh" format to a given string and increases string ptr
//                     for use inside ConvertUnicodeToMultiByte only
//
//
#define ADD_HEX_TO_STRING(pStr, ch) \
{ UCHAR c = (UCHAR)(ch);\
  *pStr++ = '%'; \
  *pStr++ = hexArray[c>>4]; \
  *pStr++ = hexArray[c & 0x0f]; \
}
//#define ADD_HEX_TO_STRING(pStr, ch) \
//    { UCHAR c = (UCHAR)ch; *(DWORD*)pStr = (DWORD)'%' + ((DWORD)(hexArray[c>>4]) << 8) + ((DWORD)(hexArray[c & 0x0f]) << 16); \
//    pStr += 3; }



/*
 * ConvertUnicodeToMultiByte:
 *

dwFlags: 

    WINHTTP_FLAG_VALID_HOSTNAME         only for server name; fast conversion is performed, no escaping
    WINHTTP_FLAG_NULL_CODEPAGE          assumes string contains only ASCII chars, fast conversion is performed
    WINHTTP_FLAG_ESCAPE_PERCENT         if escaping enabled, escape percent as well
    WINHTTP_FLAG_ESCAPE_DISABLE         disable escaping (if WINHTTP_FLAG_VALID_HOSTNAME not set)
    WINHTTP_FLAG_ESCAPE_DISABLE_QUERY   if escaping enabled escape path part, but do not escape query

 */

DWORD
ConvertUnicodeToMultiByte(
    LPCWSTR lpszObjectName, 
    DWORD dwCodePage, 
    MEMORYPACKET* pmp, 
    DWORD dwFlags)
{
    static CHAR* hexArray = "0123456789ABCDEF";

    DWORD dwError = ERROR_SUCCESS;
    BOOL bPureAscii = TRUE;
    BOOL bTreatPercentAsSafe = (dwFlags & WINHTTP_FLAG_ESCAPE_PERCENT) ? FALSE : TRUE;
    BOOL bNeedEscaping = (dwFlags & WINHTTP_FLAG_ESCAPE_DISABLE) ? FALSE : TRUE;
    BOOL bEscapeQuery = (dwFlags & WINHTTP_FLAG_ESCAPE_DISABLE_QUERY) ? FALSE : TRUE;

//determine size of string and/or safe characters
    DWORD dwUnsafeChars = 0; 
    DWORD dwUnicodeUrlSize;

    if (dwFlags & WINHTTP_FLAG_VALID_HOSTNAME)
    {
        bNeedEscaping = FALSE;

        for (PCWSTR pwStr = lpszObjectName; *pwStr; ++pwStr)
        {
            UINT16 wc = *pwStr;
            if (IS_UNSAFE_URL_WIDECHARACTER(wc, HOSTNAME))
            {
                dwError = ERROR_WINHTTP_INVALID_URL;
                goto done;
            }
        }
        dwUnicodeUrlSize = (DWORD)(pwStr-lpszObjectName+1);
    }
    else if ((dwFlags & WINHTTP_FLAG_NULL_CODEPAGE) && !bNeedEscaping)
    {
        //if no escaping needed there is no need to calcaulate num of unsafe char
        dwUnicodeUrlSize = lstrlenW(lpszObjectName)+1;
    }
    else 
    {
        // optimization to check for unsafe characters, and optimize the common case.
        // calculate the length, and while parsing the string, check if there are unsafeChars
        PCWSTR pwStr;

        if (bTreatPercentAsSafe)
            for(pwStr = lpszObjectName; *pwStr; ++pwStr)
            {
                UINT16 wc = *pwStr;
                if (wc <= 0x7f)
                {
                    if (UnsafeInPathAndQueryFlags[wc] && (wc != L'%'))
                        ++dwUnsafeChars;                
                }
                else
                {
                    bPureAscii = FALSE;
                    ++dwUnsafeChars;
                }
            }
        else
            for(pwStr = lpszObjectName; *pwStr; ++pwStr)
            {
                UINT16 wc = *pwStr;
                if (wc <= 0x7f)
                {
                    if (UnsafeInPathAndQueryFlags[wc])
                        ++dwUnsafeChars;                
                }
                else
                {
                    bPureAscii = FALSE;
                    ++dwUnsafeChars;
                }
            }

        dwUnicodeUrlSize = (DWORD)(pwStr-lpszObjectName+1);
    }

//convert to MBCS
    if (bPureAscii)
    {
        pmp->dwAlloc = dwUnicodeUrlSize;
        if (bNeedEscaping)
            pmp->dwAlloc += 2 * dwUnsafeChars;

        pmp->psStr = (LPSTR)ALLOCATE_FIXED_MEMORY(pmp->dwAlloc);

        if (!pmp->psStr)
        {
            pmp->dwAlloc = 0;
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto done;
        }

        PSTR pStr = pmp->psStr;
        if (bNeedEscaping)
        {
            UCHAR chPercent = bTreatPercentAsSafe ? (UCHAR)'%' : (UCHAR)0;

            if (bEscapeQuery)
                for (; *lpszObjectName; ++lpszObjectName)
                {
                    UCHAR ch = (UCHAR)*lpszObjectName;
                    if (!UnsafeInPathAndQueryFlags[ch] || (ch == chPercent))
                        *pStr++ = ch;
                    else
                    {
                        ADD_HEX_TO_STRING (pStr, ch)
                    }
                }
            else
                for (; *lpszObjectName && (*lpszObjectName != L'?'); ++lpszObjectName)
                {
                    UCHAR ch = (UCHAR)*lpszObjectName;
                    if (!UnsafeInPathAndQueryFlags[ch] || ch == chPercent)
                        *pStr++ = ch;
                    else
                    {
                        ADD_HEX_TO_STRING (pStr, ch)
                    }
                }
        }

        for (; *lpszObjectName; ++lpszObjectName)
            *pStr++ = (CHAR)*lpszObjectName;
        *pStr = '\0';

        pmp->dwSize = (DWORD)(pStr - pmp->psStr);
    }
    else if (dwCodePage == CP_UTF8)
    {
        //converts to UTF8 and performs escaping at same time
        pmp->dwAlloc = dwUnicodeUrlSize + (bNeedEscaping ? 8 : 2) * dwUnsafeChars; //yep, some extra allocation possible

        pmp->psStr = (LPSTR)ALLOCATE_FIXED_MEMORY(pmp->dwAlloc);

        if (!pmp->psStr)
        {
            pmp->dwAlloc = 0;
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto done;
        }

        PSTR pStr = pmp->psStr;

        if (bNeedEscaping)
        {
            WCHAR wcPercent = bTreatPercentAsSafe ? L'%' : (WCHAR)0;
            WCHAR wcQMark = bEscapeQuery ? (WCHAR)0 : L'?';

            for (; *lpszObjectName && (*lpszObjectName != wcQMark); ++lpszObjectName)
            {
                UINT16 wc = *lpszObjectName;
                if (wc <= 0x007f) // encode to one byte
                {
                    if (!UnsafeInPathAndQueryFlags[wc] || wc == wcPercent)
                        *pStr++ = (CHAR)wc;
                    else
                    {
                        ADD_HEX_TO_STRING (pStr, wc)
                    }
                }
                else if (wc <= 0x07FF) //encode to two bytes
                {
                    ADD_HEX_TO_STRING (pStr, 0xC0 | (wc >> 6))
                    ADD_HEX_TO_STRING (pStr, 0x80 | (wc & 0x3F))
                }
                else //encode to three bytes
                {
                    ADD_HEX_TO_STRING (pStr, 0xe0 | (wc >> 12))
                    ADD_HEX_TO_STRING (pStr, 0x80 | ((wc >> 6) & 0x3F))
                    ADD_HEX_TO_STRING (pStr, 0x80 | (wc & 0x3F))
                }
            }
        }

        for (; *lpszObjectName; ++lpszObjectName)
        {
            UINT16 wc = *lpszObjectName;
            if (wc <= 0x007f) // encode to one byte
            {
                *pStr++ = (CHAR)wc;
            }
            else if (wc <= 0x07FF) //encode to two bytes
            {
                *pStr++ = (CHAR)(0xC0 | (wc >> 6));
                *pStr++ = (CHAR)(0x80 | (wc & 0x3F));
                //*(WORD*)pStr = (WORD)0x80C0 | (wc >> 6) | ((wc & 0x3F) << 8);
                pStr += 2;
            }
            else //encode to three bytes
            {
                *pStr++ = (CHAR)(0xe0 | (wc >> 12));
                *pStr++ = (CHAR)(0x80 | ((wc >> 6) & 0x3F));
                *pStr++ = (CHAR)(0x80 | (wc & 0x3F));
                //DWORD tmp = 0x8080e0 | (wc >> 12) | ((wc << 2) & 0x3f00) | (((DWORD)wc << 16) & 0x3f0000);
                //*(DWORD*)pStr = tmp;
                //pStr += 3;
            }
        }

        *pStr = '\0';

        pmp->dwSize = (DWORD)(pStr - pmp->psStr);
    }
    else
    {
        //last and final, so not to loose perf don't set dwCodePage to values other then CP_UTF8 :)
        // convert with WideCharToMultiByte()

        pmp->dwAlloc = WideCharToMultiByte(dwCodePage, 0, lpszObjectName, dwUnicodeUrlSize, NULL, 0, NULL, NULL);
        if (!pmp->dwAlloc)
        {
            dwError = GetLastError();
            goto done;
        }

        pmp->psStr = (LPSTR)ALLOCATE_FIXED_MEMORY(pmp->dwAlloc);

        if (!pmp->psStr)
        {
            pmp->dwAlloc = 0;
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto done;
        }

        //find out if query is present
        PCHAR pchQMInConverted = NULL;
        DWORD dwQuerySize;
        if (bNeedEscaping)
        {
            WCHAR* pQM = wcschr(lpszObjectName, L'?');
            if (pQM)
            {
                DWORD dwPathSize = 0;
                if (pQM != lpszObjectName)
                {
                    dwPathSize = WideCharToMultiByte(dwCodePage, 0, lpszObjectName, (DWORD)(pQM - lpszObjectName), pmp->psStr, pmp->dwAlloc, NULL, NULL);
                    
                    if (!dwPathSize)
                    {
                        dwError = GetLastError();
                        goto done;
                    }
                }

                dwQuerySize = WideCharToMultiByte(dwCodePage, 0, pQM,  dwUnicodeUrlSize - (DWORD)(pQM - lpszObjectName), pmp->psStr + dwPathSize, pmp->dwAlloc - dwPathSize, NULL, NULL);

                if (!dwQuerySize)
                {
                    dwError = GetLastError();
                    goto done;
                }

                --dwQuerySize;

                pmp->dwSize = dwPathSize + dwQuerySize;
                pchQMInConverted = pmp->psStr + dwPathSize;
            }
        }

        if (!pchQMInConverted)
        {
            pmp->dwSize = WideCharToMultiByte(dwCodePage, 0, lpszObjectName, dwUnicodeUrlSize, pmp->psStr, pmp->dwAlloc, NULL, NULL);

            if (!pmp->dwSize)
            {
                dwError = GetLastError();
                goto done;
            }
            else
                --(pmp->dwSize); 
        }

        if (bNeedEscaping)
        {
            //collect information about code page
            DWORD dwCharSize = 1;

            if (dwCodePage != CP_UTF7)
            {
                CPINFO CPInfo;
                if (!GetCPInfo(dwCodePage, &CPInfo))
                {
                    dwError = GetLastError();
                    goto done;
                }
                dwCharSize = CPInfo.MaxCharSize;
            }

            UCHAR chPercent = bTreatPercentAsSafe ? '%' : (UCHAR)0;

            if (dwCharSize == 1)
            {
                DWORD dwUnsafeChars = 0;

                //calculate number of unsafe chars
                PSTR pStop = pchQMInConverted ? pchQMInConverted : (pmp->psStr + pmp->dwSize);

                PSTR pStr = pmp->psStr;
                //this loop counts unsafe chars in path, count '?' as well
                for(; pStr != pStop; ++pStr)
                {
                    UCHAR ch = *pStr;
                    if ((ch > 0x7F) || (UnsafeInPathAndQueryFlags[ch] && (ch != chPercent)) || (ch == '?'))
                        ++dwUnsafeChars;
                }
                //this loop counts unsafe chars in query, do not count '?'
                for(; *pStr; ++pStr)
                {
                    UCHAR ch = *pStr;
                    if ((ch > 0x7F) || (UnsafeInPathAndQueryFlags[ch] && (ch != chPercent)))
                        ++dwUnsafeChars;
                }

                if (dwUnsafeChars == 0)
                    goto done;

                //make new allocation
                DWORD dwNewAlloc = pmp->dwAlloc + dwUnsafeChars*2;
                LPSTR pDest, pNewStr;
                pNewStr = pDest = (LPSTR)ALLOCATE_FIXED_MEMORY(dwNewAlloc);
                if (!pDest)
                {
                    dwError = ERROR_NOT_ENOUGH_MEMORY;
                    goto done;
                }

                //escaping

                //escape path part
                pStr = pmp->psStr;
                for(; pStr != pStop; ++pStr)
                {
                    UCHAR ch = *pStr;
                    if ((ch <= 0x7F) && ((!UnsafeInPathAndQueryFlags[ch] && (ch != '?')) || (ch == chPercent)))
                        *pDest++ = ch;
                    else
                    {
                        ADD_HEX_TO_STRING (pDest, ch)
                    }
                }
                //escape query part
                for(; *pStr; ++pStr)
                {
                    UCHAR ch = *pStr;
                    if ((ch <= 0x7F) && (!UnsafeInPathAndQueryFlags[ch] || (ch == chPercent)))
                        *pDest++ = ch;
                    else
                    {
                        ADD_HEX_TO_STRING (pDest, ch)
                    }
                }
                *pDest = '\0';

                FREE_FIXED_MEMORY(pmp->psStr);
                pmp->psStr = pNewStr;
                pmp->dwSize = (DWORD)(pDest-pNewStr);
                pmp->dwAlloc = dwNewAlloc;
            }
            else
            {
                //well, string is mbcs

                DWORD dwUnsafeChars = 0;

                //calculate number of unsafe chars
                PSTR pStop = pchQMInConverted ? pchQMInConverted : (pmp->psStr + pmp->dwSize);

                PSTR pStr = pmp->psStr;

                //this loop counts unsafe chars in path, count '?' as well
                while (pStr != pStop)
                {
                    UCHAR ch = *pStr;
                    if (IsDBCSLeadByteEx(dwCodePage, ch))
                    {
                        //do not allow percent here
                        if ((ch > 0x7F) || UnsafeInPathAndQueryFlags[ch] || (ch == '?'))
                            ++dwUnsafeChars;
                        ++pStr;
                        ch = *pStr;
                        if ((ch > 0x7F) || UnsafeInPathAndQueryFlags[ch] || (ch == '?'))
                            ++dwUnsafeChars;
                        ++pStr;
                    }
                    else
                    {
                        if ((ch > 0x7F) || (UnsafeInPathAndQueryFlags[ch] && (ch != chPercent)) || (ch == '?'))
                            ++dwUnsafeChars;
                        ++pStr;
                    }
                }
                //this loop counts unsafe chars in query, do not count '?'
                while(*pStr)
                {
                    UCHAR ch = *pStr;
                    if (IsDBCSLeadByteEx(dwCodePage, ch))
                    {
                        //do not allow percent here
                        if ((ch > 0x7F) || UnsafeInPathAndQueryFlags[ch])
                            ++dwUnsafeChars;
                        ++pStr;
                        ch = *pStr;
                        if ((ch > 0x7F) || UnsafeInPathAndQueryFlags[ch])
                            ++dwUnsafeChars;
                        ++pStr;
                    }
                    else
                    {
                        if ((ch > 0x7F) || (UnsafeInPathAndQueryFlags[ch] && (ch != chPercent)))
                            ++dwUnsafeChars;
                        ++pStr;
                    }
                }

                if (dwUnsafeChars == 0)
                    goto done;

                //make new allocation
                DWORD dwNewAlloc = pmp->dwAlloc + dwUnsafeChars*2;
                LPSTR pDest, pNewStr;
                pNewStr = pDest = (LPSTR)ALLOCATE_FIXED_MEMORY(dwNewAlloc);
                if (!pDest)
                {
                    dwError = ERROR_NOT_ENOUGH_MEMORY;
                    goto done;
                }

                //escaping

                //escape path part
                pStr = pmp->psStr;
                while (pStr != pStop)
                {
                    UCHAR ch = *pStr;
                    if (IsDBCSLeadByteEx(dwCodePage, ch))
                    {
                        //do not allow percent here
                        if ((ch <= 0x7F) && !UnsafeInPathAndQueryFlags[ch] && (ch != '?'))
                            *pDest++ = ch;
                        else
                        {
                            ADD_HEX_TO_STRING (pDest, ch)
                        }
                        ++pStr;
                        ch = *pStr;
                        if ((ch <= 0x7F) && !UnsafeInPathAndQueryFlags[ch] && (ch != '?'))
                            *pDest++ = ch;
                        else
                        {
                            ADD_HEX_TO_STRING (pDest, ch)
                        }
                        ++pStr;
                    }
                    else
                    {
                        if ((ch <= 0x7F) && ((!UnsafeInPathAndQueryFlags[ch] && (ch != '?')) || (ch == chPercent)))
                            *pDest++ = ch;
                        else
                        {
                            ADD_HEX_TO_STRING (pDest, ch)
                        }
                        ++pStr;
                    }
                }

                //escape query part
                while (*pStr)
                {
                    UCHAR ch = *pStr;
                    if (IsDBCSLeadByteEx(dwCodePage, ch))
                    {
                        //do not allow percent here
                        if ((ch <= 0x7F) && !UnsafeInPathAndQueryFlags[ch])
                            *pDest++ = ch;
                        else
                        {
                            ADD_HEX_TO_STRING (pDest, ch)
                        }
                        ++pStr;
                        ch = *pStr;
                        if ((ch <= 0x7F) && !UnsafeInPathAndQueryFlags[ch])
                            *pDest++ = ch;
                        else
                        {
                            ADD_HEX_TO_STRING (pDest, ch)
                        }
                        ++pStr;
                    }
                    else
                    {
                        if ((ch <= 0x7F) && (!UnsafeInPathAndQueryFlags[ch] || (ch == chPercent)))
                            *pDest++ = ch;
                        else
                        {
                            ADD_HEX_TO_STRING (pDest, ch)
                        }
                        ++pStr;
                    }
                }

                *pDest = '\0';

                FREE_FIXED_MEMORY(pmp->psStr);
                pmp->psStr = pNewStr;
                pmp->dwSize = (DWORD)(pDest-pNewStr);
                pmp->dwAlloc = dwNewAlloc;
            }
        }
    }
     
done:
    if (pmp->psStr)
        pmp->dwAlloc = (pmp->dwAlloc > MP_MAX_STACK_USE) ? pmp->dwAlloc : MP_MAX_STACK_USE+1;// to force FREE in ~MEMORYPACKET
        
    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5.1\api\proxreg.cxx ===
#include "wininetp.h"

static const CHAR szRegPathConnections[] = REGSTR_PATH_INTERNET_SETTINGS "\\Connections";




// some winsock stacks fault if we do a gethostbyname(NULL).  If we come
// accross one of these, don't do any more autodetecting.
BOOL g_fGetHostByNameNULLFails = FALSE;

//
// IsConnectionMatch - a worker function to simply some logic elsewhere,
//  it just handles Connection Name Matching.
//

BOOL 
IsConnectionMatch(
    LPCSTR lpszConnection1,
    LPCSTR lpszConnection2)
{
    if ( lpszConnection1 == NULL && 
         lpszConnection2 == NULL) 
    {
        return TRUE;
    }

    if ( lpszConnection1 && lpszConnection2 &&
         stricmp(lpszConnection1, lpszConnection2) == 0 )
    {
        return TRUE;
    }

    return FALSE;
}

///////////////////////////////////////////////////////////////////////////
//
// CRegBlob implementation
//
///////////////////////////////////////////////////////////////////////////

CRegBlob::CRegBlob(
    BOOL fWrite
    )
{
    // initialize members
    _fWrite = fWrite;
    _fCommit = TRUE;
    _dwOffset = 0;
    _pBuffer = NULL;
    _dwBufferLimit = 0;
    _hkey = NULL;
}


CRegBlob::~CRegBlob(
    )
{
    Commit();

    if(_hkey)
        REGCLOSEKEY(_hkey);

    if(_pBuffer)
        FREE_FIXED_MEMORY(_pBuffer);

    // caller owns _pszValue pointer
}


DWORD
CRegBlob::Init(
    HKEY hBaseKey,
    LPCSTR pszSubKey,
    LPCSTR pszValue
    )
{
    long lRes;
    REGSAM  regsam = KEY_QUERY_VALUE;
    DWORD dwDisposition;

    // If we're writing, save reg value name and set access
    if(_fWrite)
    {
        _pszValue = pszValue;
        regsam = KEY_SET_VALUE;

        lRes = REGCREATEKEYEX(hBaseKey, pszSubKey, 0, "", 0,
                    regsam, NULL, &_hkey, &dwDisposition);
    }
    else
    {
        // If not writing, then use RegOpenKeyEx so we don't need
        // registry write permissions.
        lRes = REGOPENKEYEX(hBaseKey, pszSubKey, 0, regsam, &_hkey);
    }

    if(lRes != ERROR_SUCCESS)
    {
        return lRes;
    }

    // figure out buffer size
    _dwBufferLimit = BLOB_BUFF_GRANULARITY;
    if(FALSE == _fWrite)
    {
        // get size of registry blob
        lRes = RegQueryValueEx(_hkey, pszValue, NULL, NULL, NULL, &_dwBufferLimit);
        if(lRes != ERROR_SUCCESS)
        {
            // nothing there - make zero size buffer
            _dwBufferLimit = 0;
        }
    }

    // allocate buffer if necessary
    if(_dwBufferLimit)
    {
        _pBuffer = (BYTE *)ALLOCATE_FIXED_MEMORY(_dwBufferLimit);
        if(NULL == _pBuffer)
            return GetLastError();
    }

    // if we're reading, fill in buffer
    if(FALSE == _fWrite && _dwBufferLimit)
    {
        // read reg key
        DWORD dwSize = _dwBufferLimit;
        lRes = RegQueryValueEx(_hkey, pszValue, NULL, NULL, _pBuffer, &dwSize);
        if(lRes != ERROR_SUCCESS)
        {
            return lRes;
        }
    }

    // reset pointer to beginning of blob
    _dwOffset = 0;

    return 0;
}

DWORD
CRegBlob::Abandon(
    VOID
    )
{
    // don't commit changes when the time comes
    _fCommit = FALSE;

    return 0;
}

DWORD
CRegBlob::Commit(
    )
{
    long lres = 0;

    if(_fCommit && _fWrite && _pszValue && _pBuffer)
    {
        // save blob to reg key
        lres = RegSetValueEx(_hkey, _pszValue, 0, REG_BINARY, _pBuffer, _dwOffset);
    }

    return lres;
}


DWORD
CRegBlob::WriteString(
    LPCSTR pszString
    )
{
    DWORD dwBytes, dwLen = 0;

    if(pszString)
    {
        dwLen = lstrlen(pszString);
    }

    dwBytes = WriteBytes(&dwLen, sizeof(DWORD));
    if(dwLen && dwBytes == sizeof(DWORD))
        dwBytes = WriteBytes(pszString, dwLen);

    return dwBytes;
}



DWORD
CRegBlob::ReadString(
    LPCSTR * ppszString
    )
{
    DWORD dwLen, dwBytes = 0;
    LPSTR lpszTemp = NULL;

    dwBytes = ReadBytes(&dwLen, sizeof(DWORD));
    if(dwBytes == sizeof(DWORD))
    {
        if(dwLen)
        {
            lpszTemp = (LPSTR)GlobalAlloc(GPTR, dwLen + 1);
            if(lpszTemp)
            {
                dwBytes = ReadBytes(lpszTemp, dwLen);
                lpszTemp[dwBytes] = 0;
            }
        }
    }

    *ppszString = lpszTemp;
    return dwBytes;
}


DWORD
CRegBlob::WriteBytes(
    LPCVOID pBytes,
    DWORD dwByteCount
    )
{
    BYTE * pNewBuffer;

    // can only do this on write blob
    if(FALSE == _fWrite)
        return 0;

    // grow buffer if necessary
    if(_dwBufferLimit - _dwOffset < dwByteCount)
    {
        DWORD dw = _dwBufferLimit + ((dwByteCount / BLOB_BUFF_GRANULARITY)+1)*BLOB_BUFF_GRANULARITY;
        pNewBuffer = (BYTE *)ALLOCATE_FIXED_MEMORY(dw);
        if(NULL == pNewBuffer)
        {
            // failed to get more memory
            return 0;
        }

        memset(pNewBuffer, 0, dw);
        memcpy(pNewBuffer, _pBuffer, _dwBufferLimit);
        FREE_FIXED_MEMORY(_pBuffer);
        _pBuffer = pNewBuffer;
        _dwBufferLimit = dw;
    }

    // copy callers data to buffer
    memcpy(_pBuffer + _dwOffset, pBytes, dwByteCount);
    _dwOffset += dwByteCount;

    // tell caller how much we wrote
    return dwByteCount;
}



DWORD
CRegBlob::ReadBytes(
    LPVOID pBytes,
    DWORD dwByteCount
    )
{
    DWORD   dwActual = _dwBufferLimit - _dwOffset;

    // can only do this on read blob
    if(_fWrite)
        return 0;

    // don't read past end of blob
    if(dwByteCount < dwActual)
        dwActual = dwByteCount;

    // copy bytes and increment offset
    if(dwActual > 0)
    {
        memcpy(pBytes, _pBuffer + _dwOffset, dwActual);
        _dwOffset += dwActual;
    }

    // tell caller how much we actually read
    return dwActual;
}


//
// Function Declarations
//


DWORD
LoadProxySettings()
/*
** Load global proxy info from registry.
** 
*/
{
    DWORD error;

    //
    // Get proxy struct for proxy object
    //
    INTERNET_PROXY_INFO_EX info;

    memset(&info, 0, sizeof(info));

    info.dwStructSize = sizeof(info);
    info.lpszConnectionName = NULL;

    //
    // Read LAN proxy settings and stuff them into the GlobalProxyInfo object.
    //
    error = ReadProxySettings(&info);

    if (error == ERROR_SUCCESS)
    {
        error = g_pGlobalProxyInfo->SetProxySettings(&info, FALSE);

        info.lpszConnectionName = NULL; // we don't allocate this field
        CleanProxyStruct(&info);
    }

    return error;
}



#define INTERNET_SETTINGS_KEY       "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings"

HKEY
FindBaseProxyKey(
    VOID
    )
/*
** Determine whether proxy settings live in HKLM or HKCU
**
** WinHttpX is hard-coded to always use HKEY_LOCAL_MACHINE
** 
*/

{
    return HKEY_LOCAL_MACHINE;
}


DWORD
ReadProxySettings(
    LPINTERNET_PROXY_INFO_EX pInfo
    )

{
    CRegBlob r(FALSE);
    LPCSTR  pszConnectionName;
    LPCSTR  pszSavedConnectionName;
    DWORD   error = ERROR_SUCCESS;
    long    lRes;
    HKEY    hBaseKey;

    DEBUG_ENTER((DBG_PROXY,
                 Dword,
                 "ReadProxySettings",
                 "%#x",
                 pInfo
                 ));

    // verify pInfo
    if(NULL == pInfo || pInfo->dwStructSize != sizeof(INTERNET_PROXY_INFO_EX))
    {
        DEBUG_LEAVE(ERROR_INVALID_PARAMETER);
        return ERROR_INVALID_PARAMETER;
    }

    // figure out connection name  (NULL == 'network')
    pszConnectionName = pInfo->lpszConnectionName;
    pszSavedConnectionName = pInfo->lpszConnectionName;
    if(NULL == pszConnectionName || 0 == *pszConnectionName)
    {
        pszConnectionName = "WinHttpSettings";
    }

    // figure out base key
    hBaseKey = FindBaseProxyKey();

    // initialize structure
    memset(pInfo, 0, sizeof(*pInfo));
    pInfo->dwStructSize = sizeof(*pInfo);
    pInfo->lpszConnectionName = pszSavedConnectionName;
    pInfo->dwFlags = PROXY_TYPE_DIRECT;

    // init blob
    lRes = r.Init(hBaseKey, szRegPathConnections, pszConnectionName);
    if(lRes)
    {
        error = (lRes == ERROR_FILE_NOT_FOUND) ? ERROR_SUCCESS : lRes;
        goto quit;
    }

    // read fields from blob
    if(0 == r.ReadBytes(&pInfo->dwStructSize, sizeof(DWORD)) ||
         (pInfo->dwStructSize < sizeof(*pInfo)))
    {
        // blob didn't exist or in correct format - set default values
        pInfo->dwStructSize = sizeof(*pInfo);
    }
    else
    {
        // read the rest of the blob
        r.ReadBytes(&pInfo->dwCurrentSettingsVersion, sizeof(DWORD));
        r.ReadBytes(&pInfo->dwFlags, sizeof(DWORD));
        r.ReadString(&pInfo->lpszProxy);
        r.ReadString(&pInfo->lpszProxyBypass);
    }

    //
    // WinHttpX does not support proxy autodection or autoconfig URL's,
    // so make sure those PROXY_TYPE flags are turned off.
    //
    pInfo->dwFlags &= ~(PROXY_TYPE_AUTO_DETECT | PROXY_TYPE_AUTO_PROXY_URL);


    DEBUG_PRINT(PROXY, INFO, ("conn=%s, vers=%u, flag=%X, prox=%s, by=%s\n", 
                    pszConnectionName,
                    pInfo->dwCurrentSettingsVersion,
                    pInfo->dwFlags,
                    (pInfo->lpszProxy ? pInfo->lpszProxy : "<none>"),
                    (pInfo->lpszProxyBypass ? pInfo->lpszProxyBypass : "<none>")
                    ));

quit:
    DEBUG_LEAVE(error);
    return error;
}


void
CleanProxyStruct(
    LPINTERNET_PROXY_INFO_EX pInfo
    )

{
    if(pInfo->lpszConnectionName)             GlobalFree((LPSTR) pInfo->lpszConnectionName);
    if(pInfo->lpszProxy)                      GlobalFree((LPSTR) pInfo->lpszProxy);
    if(pInfo->lpszProxyBypass)                GlobalFree((LPSTR) pInfo->lpszProxyBypass);
    memset(pInfo, 0, sizeof(INTERNET_PROXY_INFO_EX));
    pInfo->dwFlags = PROXY_TYPE_DIRECT;
}


DWORD WriteProxySettings(INTERNET_PROXY_INFO_EX * pInfo)
{
    CRegBlob    r(TRUE);
    DWORD       error = ERROR_SUCCESS;
    long        lRes;

    // verify pInfo
    if(NULL == pInfo || pInfo->dwStructSize != sizeof(INTERNET_PROXY_INFO_EX))
    {
        return ERROR_INVALID_PARAMETER;
    }

    // init blob
    lRes = r.Init(HKEY_LOCAL_MACHINE, szRegPathConnections, "WinHttpSettings");
    if (lRes)
    {
        error = lRes;
        goto quit;
    }

    if (r.WriteBytes(&pInfo->dwStructSize, sizeof(DWORD)) == 0
        || r.WriteBytes(&pInfo->dwCurrentSettingsVersion, sizeof(DWORD)) == 0
        || r.WriteBytes(&pInfo->dwFlags, sizeof(DWORD)) == 0
        || r.WriteString(pInfo->lpszProxy) == 0
        || r.WriteString(pInfo->lpszProxyBypass) == 0)
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        r.Abandon();
        goto quit;
    }

    lRes = r.Commit();
    if (lRes)
    {
        error = lRes;
        goto quit;
    }

quit:
    return error;
}


//
// support routines for WinHttpGetIEProxyConfigForCurrentUser API ///////////
//

//
//
// Maximum size of TOKEN_USER information.
//

#define SIZE_OF_TOKEN_INFORMATION                   \
    sizeof( TOKEN_USER )                            \
    + sizeof( SID )                                 \
    + sizeof( ULONG ) * SID_MAX_SUB_AUTHORITIES

#define MAX_SID_STRING 256


// type for RtlConvertSidToUnicodeString, exported from ntdll.dll
typedef NTSTATUS (* PCONVERTSID)(
    PUNICODE_STRING UnicodeString,
    PSID Sid,
    BOOLEAN AllocateDestinationString
    );


//
// Function Declarations
//

BOOL
InitClientUserString (
    LPWSTR pString
    )

/*++

Routine Description:

Arguments:

    pString - output string of current user

Return Value:

    TRUE = success,
    FALSE = fail

    Returns in pString a ansi string if the impersonated client's
    SID can be expanded successfully into  Unicode string. If the conversion
    was unsuccessful, returns FALSE.

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                 Bool,
                 "InitClientUserString",
                 "%#x",
                 pString
                 ));

    HANDLE      TokenHandle;
    UCHAR       TokenInformation[ SIZE_OF_TOKEN_INFORMATION ];
    ULONG       ReturnLength;
    BOOL        Status;
    DWORD       dwLastError;
    UNICODE_STRING UnicodeString;
    HMODULE     hNtDll;
    PCONVERTSID pRtlConvertSid;

    //
    // get RtlConvertSideToUnicodeString entry point in NTDLL
    //
    hNtDll = LoadLibrary("ntdll.dll");
    if(NULL == hNtDll)
    {
        return FALSE;
    }

    pRtlConvertSid = (PCONVERTSID)GetProcAddress(hNtDll, "RtlConvertSidToUnicodeString");
    if(NULL == pRtlConvertSid)
    {
        FreeLibrary(hNtDll);
        DEBUG_LEAVE(FALSE);
        return FALSE;
    }

    //
    // We can use OpenThreadToken because this server thread
    // is impersonating a client
    //
    Status = OpenThreadToken(
                GetCurrentThread(),
                TOKEN_READ,
                TRUE,                // Open as self
                &TokenHandle
                );
    dwLastError = GetLastError();

    if( Status == FALSE )
    {
        DEBUG_PRINT(PROXY, INFO, ("OpenThreadToken() failed: Error=%d\n",
                    dwLastError
                    ));

        Status = OpenProcessToken(
                    GetCurrentProcess(),
                    TOKEN_READ,
                    &TokenHandle
                    );
        dwLastError = GetLastError();

        if( Status == FALSE )
        {
            DEBUG_LEAVE(FALSE);
            return FALSE ;
        }
    }

    //
    // Notice that we've allocated enough space for the
    // TokenInformation structure. so if we fail, we
    // return a NULL pointer indicating failure
    //
    Status = GetTokenInformation( TokenHandle,
                                  TokenUser,
                                  TokenInformation,
                                  sizeof( TokenInformation ),
                                  &ReturnLength
                                   );
    dwLastError = GetLastError();
    CloseHandle( TokenHandle );

    if ( Status == FALSE ) {
        DEBUG_PRINT(PROXY, INFO, ("GetTokenInformation failed: Error=%d\n",
                    dwLastError
                    ));
        DEBUG_LEAVE(FALSE);
        return FALSE;
    }

    //
    // Convert the Sid (pointed to by pSid) to its
    // equivalent Unicode string representation.
    //

    UnicodeString.Length = 0;
    UnicodeString.MaximumLength = MAX_SID_STRING;
    UnicodeString.Buffer = pString;

    Status = (*pRtlConvertSid)(
                 &UnicodeString,
                 ((PTOKEN_USER)TokenInformation)->User.Sid,
                 FALSE );
    FreeLibrary(hNtDll);

    if( !NT_SUCCESS( Status )){
        DEBUG_PRINT(PROXY, INFO, ("RtlConvertSidToUnicodeString failed: Error=%d\n",
                    Status
                    ));
        DEBUG_LEAVE(FALSE);
        return FALSE;
    }
    
    DEBUG_PRINT(PROXY, INFO, ("User SID = %ws\n",
                pString
                ));

    DEBUG_LEAVE(TRUE);
    return TRUE;
}


HKEY
GetClientUserHandle(
    IN REGSAM samDesired
    )

/*++

Routine Description:

Arguments:

Returns:

---*/

{
    DEBUG_ENTER((DBG_PROXY,
                 Dword,
                 "GetClientUserHandle",
                 "%#x",
                 samDesired
                 ));

    HKEY   hKeyClient;
    WCHAR  String[MAX_SID_STRING];
    LONG   ReturnValue;

    if (!InitClientUserString(String)) {
        DEBUG_LEAVE(0);
        return NULL ;
    }

    //
    // We now have the Unicode string representation of the
    // local client's Sid we'll use this string to open a handle
    // to the client's key in  the registry.

    ReturnValue = RegOpenKeyExW( HKEY_USERS,
                                 String,
                                 0,
                                 samDesired,
                                 &hKeyClient );

    //
    // If we couldn't get a handle to the local key
    // for some reason, return a NULL handle indicating
    // failure to obtain a handle to the key
    //

    if ( ReturnValue != ERROR_SUCCESS )
    {
        DEBUG_PRINT(PROXY, INFO, ("RegOpenKeyW failed: Error=%d\n",
                    ReturnValue
                    ));

        DEBUG_ERROR(PROXY, ReturnValue);
        SetLastError( ReturnValue );

        DEBUG_LEAVE(0);
        return NULL;
    }

    DEBUG_LEAVE(hKeyClient);
    return( hKeyClient );
}


HKEY
FindWinInetBaseProxyKey(
    VOID
    )

/*
** Determine whether proxy settings live in HKLM or HKCU
**
** Returns HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE
**
** Checks \HKLM\SW\MS\Win\CV\Internet Settings\ProxySettingsPerUser.  If
** exists and is zero, use HKLM otherwise use HKCU.
*/

{
    HKEY hkeyBase = NULL;

    DWORD   dwType, dwValue, dwSize = sizeof(DWORD);

    if (ERROR_SUCCESS ==
            SHGetValue(HKEY_LOCAL_MACHINE, INTERNET_POLICY_KEY,
                TEXT("ProxySettingsPerUser"), &dwType, &dwValue, &dwSize) &&
                0 == dwValue)
    {
        hkeyBase = HKEY_LOCAL_MACHINE;
     }
    else
    {
        //
        // Find an HKCU equivalent for this process
        //
        hkeyBase = GetClientUserHandle(KEY_QUERY_VALUE | KEY_SET_VALUE);

        if (!hkeyBase)
        {
            BOOL fLocalSystem = FALSE;

            if (GlobalIsProcessNtService)
            {
                char    szUserName[32];
                DWORD   cbUserNameSize = sizeof(szUserName);
                
                if (GetUserName(szUserName, &cbUserNameSize))
                {
                    if (0 == lstrcmpi(szUserName, "SYSTEM") ||
                        0 == lstrcmpi(szUserName, "LOCAL SERVICE") || 
                        0 == lstrcmpi(szUserName, "NETWORK SERVICE"))
                    {
                        fLocalSystem = TRUE;
                    }
                }
            }
            
            if (hkeyBase == NULL && !fLocalSystem)
            {
                hkeyBase = HKEY_CURRENT_USER;
            }
        }
    }

    return hkeyBase;
}


DWORD
ReadWinInetProxySettings(
    LPWININET_PROXY_INFO_EX pInfo
    )

{
    CRegBlob r(FALSE);
    LPCSTR  pszConnectionName;
    LPCSTR  pszSavedConnectionName;
    DWORD   error = ERROR_SUCCESS;
    long    lRes;
    BOOL    fLanConnection = FALSE;
    HKEY    hBaseKey = NULL;
    DWORD   dwStructVersion = 0;

    DEBUG_ENTER((DBG_PROXY,
                 Dword,
                 "ReadWinInetProxySettings",
                 "%#x",
                 pInfo
                 ));

    // verify pInfo
    if (NULL == pInfo || pInfo->dwStructSize != sizeof(WININET_PROXY_INFO_EX))
    {
        return ERROR_INVALID_PARAMETER;
    }

    // figure out connection name  (NULL == 'network')
    pszConnectionName = pInfo->lpszConnectionName;
    pszSavedConnectionName = pInfo->lpszConnectionName;
    if(NULL == pszConnectionName || 0 == *pszConnectionName)
    {
        fLanConnection = TRUE;
        pszConnectionName = "DefaultConnectionSettings";
    }

    // figure out base key
    hBaseKey = FindWinInetBaseProxyKey();
    if (hBaseKey == NULL)
    {
        error = ERROR_FILE_NOT_FOUND;
        goto quit;
    }

    // initialize structure
    memset(pInfo, 0, sizeof(*pInfo));
    pInfo->dwStructSize = sizeof(*pInfo);
    pInfo->lpszConnectionName = pszSavedConnectionName;
    pInfo->dwFlags = PROXY_TYPE_DIRECT;

    // init blob
    lRes = r.Init(hBaseKey, szRegPathConnections, pszConnectionName);
    if(lRes)
    {
        error = lRes;
        goto quit;
    }

    // read fields from blob
    if(0 == r.ReadBytes(&dwStructVersion, sizeof(DWORD)) ||
         (dwStructVersion < WININET_PROXY_INFO_EX_VERSION))
    {
        // blob didn't exist or in correct format - set default values

        //
        // All lan connections and overridden dial-ups get autodetect
        //
        if(fLanConnection)
        {
            pInfo->dwFlags |= PROXY_TYPE_AUTO_DETECT;
        }
    }
    else
    {
        // read the rest of the blob
        r.ReadBytes(&pInfo->dwCurrentSettingsVersion, sizeof(DWORD));
        r.ReadBytes(&pInfo->dwFlags, sizeof(DWORD));
        r.ReadString(&pInfo->lpszProxy);
        r.ReadString(&pInfo->lpszProxyBypass);
        r.ReadString(&pInfo->lpszAutoconfigUrl);
        r.ReadBytes(&pInfo->dwAutoDiscoveryFlags, sizeof(DWORD));
        r.ReadString(&pInfo->lpszLastKnownGoodAutoConfigUrl);

#if 0 // WinHttp does not need the rest of the WinInet proxy config data.
    /*
        r.ReadBytes(&pInfo->ftLastKnownDetectTime, sizeof(FILETIME));

        // read interface ips
        r.ReadBytes(&pInfo->dwDetectedInterfaceIpCount, sizeof(DWORD));
        if(pInfo->dwDetectedInterfaceIpCount)
        {
            pInfo->pdwDetectedInterfaceIp = (DWORD *)GlobalAlloc(GPTR, sizeof(DWORD) * pInfo->dwDetectedInterfaceIpCount);
            if(pInfo->pdwDetectedInterfaceIp)
            {
                for(i=0; i<pInfo->dwDetectedInterfaceIpCount; i++)
                {
                    r.ReadBytes(&pInfo->pdwDetectedInterfaceIp[i], sizeof(DWORD));
                }
            }
        }

        r.ReadString(&pInfo->lpszAutoconfigSecondaryUrl);
        r.ReadBytes(&pInfo->dwAutoconfigReloadDelayMins, sizeof(DWORD));
    */
#endif
    }

    DEBUG_PRINT(PROXY, INFO, ("conn=%s, vers=%u, flag=%X, prox=%s, by=%s, acu=%s\n", 
                    pszConnectionName,
                    pInfo->dwCurrentSettingsVersion,
                    pInfo->dwFlags,
                    (pInfo->lpszProxy ? pInfo->lpszProxy : "<none>"),
                    (pInfo->lpszProxyBypass ? pInfo->lpszProxyBypass : "<none>"),
                    (pInfo->lpszAutoconfigUrl ? pInfo->lpszAutoconfigUrl : "<none>")
                    ));

quit:
    if (hBaseKey != NULL &&
        hBaseKey != INVALID_HANDLE_VALUE &&
        hBaseKey != HKEY_LOCAL_MACHINE &&
        hBaseKey != HKEY_CURRENT_USER)
    {
        RegCloseKey(hBaseKey);
    }

    DEBUG_LEAVE(error);
    return error;
}


void
CleanWinInetProxyStruct(
    LPWININET_PROXY_INFO_EX pInfo
    )

{
    if(pInfo->lpszConnectionName)             GlobalFree((LPSTR) pInfo->lpszConnectionName);
    if(pInfo->lpszProxy)                      GlobalFree((LPSTR) pInfo->lpszProxy);
    if(pInfo->lpszProxyBypass)                GlobalFree((LPSTR) pInfo->lpszProxyBypass);
    if(pInfo->lpszAutoconfigUrl)              GlobalFree((LPSTR) pInfo->lpszAutoconfigUrl);
    if(pInfo->lpszLastKnownGoodAutoConfigUrl) GlobalFree((LPSTR) pInfo->lpszLastKnownGoodAutoConfigUrl);
    if(pInfo->pdwDetectedInterfaceIp)         GlobalFree(pInfo->pdwDetectedInterfaceIp);
    memset(pInfo, 0, sizeof(WININET_PROXY_INFO_EX));
    pInfo->dwFlags = PROXY_TYPE_DIRECT;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5.1\api\rashelp.cxx ===
/////////////////////////////////////////////////////////////////////////////
//
// RAS API wrappers for wide/ansi
//
// Works on all NT platforms correctly, maintaining unicode
// whenever possible.
//
/////////////////////////////////////////////////////////////////////////////

#include "wininetp.h"
#include "rashelp.h"
#include "autodial.h"

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
ENUM_TYPE GetOSVersion::_EnumType = ENUM_NONE;

GetOSVersion::GetOSVersion()
{
    if(_EnumType == ENUM_NONE)
    {
        if(0 == GlobalPlatformType)
            GlobalPlatformType = PlatformType(&GlobalPlatformVersion5);

        INET_ASSERT(PLATFORM_TYPE_WINNT == GlobalPlatformType);

        if(TRUE == GlobalPlatformVersion5)
            _EnumType = ENUM_WIN2K;
        else
            _EnumType = ENUM_UNICODE;
    }
}

GetOSVersion::~GetOSVersion()
{
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
RasEnumHelp::RasEnumHelp()
{
    DWORD           dwBufSize, dwStructSize = 0;

    // init
    _dwEntries = 0;
    _dwLastError = 0;

    switch(_EnumType)
    {
    case ENUM_UNICODE:
        dwStructSize = sizeof(RASENTRYNAMEW);
        break;
    case ENUM_WIN2K:
        dwStructSize = sizeof(W2KRASENTRYNAMEW);
        break;
    }

    // allocate space for 16 entries
    dwBufSize = 16 * dwStructSize;
    _preList = (LPRASENTRYNAMEA)LocalAlloc(LPTR, dwBufSize);
    if(_preList)
    {
        do
        {
            // set up list
            _preList[0].dwSize = dwStructSize;

            // call ras to enumerate
            _dwLastError = ERROR_UNKNOWN;
            _dwLastError = _RasEnumEntriesW(
                            NULL,
                            NULL,
                            (LPRASENTRYNAMEW)_preList,
                            &dwBufSize,
                            &_dwEntries
                            );

            // reallocate buffer if necessary
            if(ERROR_BUFFER_TOO_SMALL == _dwLastError)
            {
                LocalFree(_preList);
                _preList = (LPRASENTRYNAMEA)LocalAlloc(LPTR, dwBufSize);
                if(NULL == _preList)
                {
                    _dwLastError = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }
            }
            else
            {
                break;
            }

        } while(TRUE);
    }
    else
    {
        _dwLastError = ERROR_NOT_ENOUGH_MEMORY;
    }

    if(_preList && (ERROR_SUCCESS != _dwLastError))
    {
        LocalFree(_preList);
        _preList = NULL;
        _dwEntries = 0;
    }

    return;
}

RasEnumHelp::~RasEnumHelp()
{
    if(_preList)
    {
        LocalFree(_preList);
    }
}

DWORD
RasEnumHelp::GetError()
{
    return _dwLastError;
}

DWORD
RasEnumHelp::GetEntryCount()
{
    return _dwEntries;
}

LPWSTR
RasEnumHelp::GetEntryW(DWORD dwConnectionNum)
{
    LPWSTR  pwszName = NULL;

    if(dwConnectionNum >= _dwEntries)
    {
        return NULL;
    }

    switch(_EnumType)
    {
    case ENUM_UNICODE:
        {
        LPRASENTRYNAMEW lpTemp = (LPRASENTRYNAMEW)_preList;
        if(*lpTemp[dwConnectionNum].szEntryName)
            pwszName = lpTemp[dwConnectionNum].szEntryName;
        break;
        }
    case ENUM_WIN2K:
        {
        LPW2KRASENTRYNAMEW lpTemp = (LPW2KRASENTRYNAMEW)_preList;
        if(*lpTemp[dwConnectionNum].szEntryName)
            pwszName = lpTemp[dwConnectionNum].szEntryName;
        break;
        }
    }

    return pwszName;
}

LPSTR
RasEnumHelp::GetEntryA(DWORD dwConnectionNum)
{
    LPSTR  pszName = NULL;

    if(dwConnectionNum >= _dwEntries)
    {
        return NULL;
    }

    switch(_EnumType)
    {
    case ENUM_UNICODE:
        {
        LPRASENTRYNAMEW lpTemp = (LPRASENTRYNAMEW)_preList;
        if(*lpTemp[dwConnectionNum].szEntryName)
        {
            WideCharToMultiByte(CP_ACP, 0, lpTemp[dwConnectionNum].szEntryName, -1,
                _szCurrentEntryA, RAS_MaxEntryName + 1, NULL, NULL);
            pszName = _szCurrentEntryA;
        }
        break;
        }
    case ENUM_WIN2K:
        {
        LPW2KRASENTRYNAMEW lpTemp = (LPW2KRASENTRYNAMEW)_preList;
        if(*lpTemp[dwConnectionNum].szEntryName)
        {
            WideCharToMultiByte(CP_ACP, 0, lpTemp[dwConnectionNum].szEntryName, -1,
                _szCurrentEntryA, RAS_MaxEntryName + 1, NULL, NULL);
            pszName = _szCurrentEntryA;
        }
        break;
        }
    }

    return pszName;
}

/////////////////////////////////////////////////////////////////////////////
//
// RasEnumConnHelp
//
/////////////////////////////////////////////////////////////////////////////
RasEnumConnHelp::RasEnumConnHelp()
{
    DWORD           dwBufSize;

    // init
    _dwConnections = 0;
    _dwLastError = 0;

    switch(_EnumType)
    {
    case ENUM_UNICODE:
        _dwStructSize = sizeof(RASCONNW);
        break;
    case ENUM_WIN2K:
        _dwStructSize = sizeof(W2KRASCONNW);
        break;
    }

    // allocate space for MAX_CONNECTION entries
    dwBufSize = MAX_CONNECTION * _dwStructSize;
    _pRasCon = (LPRASCONNA)LocalAlloc(LPTR, dwBufSize);
    if(_pRasCon == NULL)
    {
        _dwLastError = ERROR_NOT_ENOUGH_MEMORY;
    }

    return;
}

RasEnumConnHelp::~RasEnumConnHelp()
{
    if(_pRasCon)
    {
        LocalFree(_pRasCon);
        _pRasCon = NULL;
    }
}

DWORD RasEnumConnHelp::Enum()
{
    DWORD           dwBufSize;

    _dwLastError = 0;

    if(_pRasCon)
    {
        dwBufSize = MAX_CONNECTION * _dwStructSize;
        do
        {
            // set up list
            _pRasCon[0].dwSize = _dwStructSize;

            // call ras to enumerate
            _dwLastError = ERROR_UNKNOWN;
            switch(_EnumType)
            {
                case ENUM_UNICODE:
                case ENUM_WIN2K:
                    _dwLastError = _RasEnumConnectionsW((LPRASCONNW)_pRasCon, &dwBufSize, &_dwConnections);
                    break;
            }

            // reallocate buffer if necessary
            if(ERROR_BUFFER_TOO_SMALL == _dwLastError)
            {
                LocalFree(_pRasCon);
                _pRasCon = (LPRASCONNA)LocalAlloc(LPTR, dwBufSize);
                if(NULL == _pRasCon)
                {
                    _dwLastError = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }
            }
            else
            {
                break;
            }

        } while(TRUE);
    }
    else
    {
        _dwLastError = ERROR_NOT_ENOUGH_MEMORY;
    }

    return _dwLastError;
}

DWORD
RasEnumConnHelp::GetError()
{
    return _dwLastError;
}

DWORD
RasEnumConnHelp::GetConnectionsCount()
{
    return _dwConnections;
}

LPWSTR
RasEnumConnHelp::GetEntryW(DWORD dwConnectionNum)
{
    LPWSTR  pwszName = NULL;

    if((_pRasCon == NULL) || (dwConnectionNum >= _dwConnections))
    {
        return NULL;
    }

    switch(_EnumType)
    {
    case ENUM_UNICODE:
        {
        LPRASCONNW lpTemp = (LPRASCONNW)_pRasCon;
        if(*lpTemp[dwConnectionNum].szEntryName)
            pwszName = lpTemp[dwConnectionNum].szEntryName;
        break;
        }
    case ENUM_WIN2K:
        {
        LPW2KRASCONNW lpTemp = (LPW2KRASCONNW)_pRasCon;
        if(*lpTemp[dwConnectionNum].szEntryName)
            pwszName = lpTemp[dwConnectionNum].szEntryName;
        break;
        }
    }

    return pwszName;
}

LPSTR
RasEnumConnHelp::GetEntryA(DWORD dwConnectionNum)
{
    LPSTR  pszName = NULL;

    if((_pRasCon == NULL) || (dwConnectionNum >= _dwConnections))
    {
        return NULL;
    }

    switch(_EnumType)
    {
    case ENUM_UNICODE:
        {
        LPRASCONNW lpTemp = (LPRASCONNW)_pRasCon;
        if(*lpTemp[dwConnectionNum].szEntryName)
        {
            WideCharToMultiByte(CP_ACP, 0, lpTemp[dwConnectionNum].szEntryName, -1, _szEntryNameA, RAS_MaxEntryName + 1, NULL, NULL);
            pszName = _szEntryNameA;
        }
        break;
        }
    case ENUM_WIN2K:
        {
        LPW2KRASCONNW lpTemp = (LPW2KRASCONNW )_pRasCon;
        if(*lpTemp[dwConnectionNum].szEntryName)
        {
            WideCharToMultiByte(CP_ACP, 0, lpTemp[dwConnectionNum].szEntryName, -1, _szEntryNameA, RAS_MaxEntryName + 1, NULL, NULL);
            pszName = _szEntryNameA;
        }
        break;
        }
    }

    return pszName;
}

LPWSTR
RasEnumConnHelp::GetLastEntryW(DWORD dwConnectionNum)
{
    UNREFERENCED_PARAMETER(dwConnectionNum);

    if(_pRasCon == NULL)
        return NULL;

    return _szEntryNameW;
}

LPSTR
RasEnumConnHelp::GetLastEntryA(DWORD dwConnectionNum)
{
    UNREFERENCED_PARAMETER(dwConnectionNum);

    if(_pRasCon == NULL)
        return NULL;

    return _szEntryNameA;
}

HRASCONN
RasEnumConnHelp::GetHandle(DWORD dwConnectionNum)
{
    HRASCONN hTemp = NULL;

    if((_pRasCon == NULL) || (dwConnectionNum >= _dwConnections))
    {
        return NULL;
    }

    switch(_EnumType)
    {
    case ENUM_UNICODE:
        {
        LPRASCONNW lpTemp = (LPRASCONNW)_pRasCon;
        hTemp = lpTemp[dwConnectionNum].hrasconn;
        break;
        }
    case ENUM_WIN2K:
        {
        LPW2KRASCONNW lpTemp = (LPW2KRASCONNW)_pRasCon;
        hTemp = lpTemp[dwConnectionNum].hrasconn;
        break;
        }
    }

    return hTemp;
}

/////////////////////////////////////////////////////////////////////////////
//
// RasEntryPropHelp
//
/////////////////////////////////////////////////////////////////////////////
RasEntryPropHelp::RasEntryPropHelp()
{
    // init
    _dwLastError = 0;

    switch(_EnumType)
    {
    case ENUM_UNICODE:
        _dwStructSize = sizeof(RASENTRYW);
        break;
    case ENUM_WIN2K:
        _dwStructSize = sizeof(W2KRASENTRYW);
        break;
    }

    _pRasEntry = (LPRASENTRYA)LocalAlloc(LPTR, _dwStructSize * 2);
    if(_pRasEntry)
    {
        _pRasEntry->dwSize = _dwStructSize;
    }
    else
    {
        _dwLastError = ERROR_NOT_ENOUGH_MEMORY;
    }

    if(_pRasEntry && (ERROR_SUCCESS != _dwLastError))
    {
        LocalFree(_pRasEntry);
        _pRasEntry = NULL;
    }
    return;
}

RasEntryPropHelp::~RasEntryPropHelp()
{
    if(_pRasEntry)
    {
        LocalFree(_pRasEntry);
        _pRasEntry = NULL;
    }
}

DWORD RasEntryPropHelp::GetError()
{
    return _dwLastError;
}

DWORD RasEntryPropHelp::GetA(LPSTR lpszEntryName)
{
    DWORD dwSize = _dwStructSize * 2;

    switch(_EnumType)
    {
    case ENUM_UNICODE:
        {
        LPRASENTRYW lpTemp = (LPRASENTRYW)_pRasEntry;
        MultiByteToWideChar(CP_ACP, 0, lpszEntryName, -1, _szEntryNameW, RAS_MaxEntryName + 1 );
        _dwLastError = _RasGetEntryPropertiesW(NULL, _szEntryNameW, (LPRASENTRYW)lpTemp, &dwSize, NULL, NULL);
        break;
        }
    case ENUM_WIN2K:
        {
        LPW2KRASENTRYW lpTemp = (LPW2KRASENTRYW)_pRasEntry;
        MultiByteToWideChar(CP_ACP, 0, lpszEntryName, -1, _szEntryNameW, RAS_MaxEntryName + 1);
        _dwLastError = _RasGetEntryPropertiesW(NULL, _szEntryNameW, (LPRASENTRYW)lpTemp, &dwSize, NULL, NULL);
        break;
        }
    }

    return(_dwLastError);
}

DWORD RasEntryPropHelp::GetW(LPWSTR lpszEntryName)
{
    DWORD dwSize = _dwStructSize * 2;

    switch(_EnumType)
    {
    case ENUM_UNICODE:
        {
        LPRASENTRYW lpTemp = (LPRASENTRYW)_pRasEntry;
        _dwLastError = _RasGetEntryPropertiesW(NULL, lpszEntryName, (LPRASENTRYW)lpTemp, &dwSize, NULL, NULL);
        break;
        }
    case ENUM_WIN2K:
        {
        LPW2KRASENTRYW lpTemp = (LPW2KRASENTRYW)_pRasEntry;
        _dwLastError = _RasGetEntryPropertiesW(NULL, lpszEntryName, (LPRASENTRYW)lpTemp, &dwSize, NULL, NULL);
        break;
        }
    }

    return(_dwLastError);
}

LPWSTR RasEntryPropHelp::GetDeviceTypeW(VOID)
{
    LPWSTR lpwstr = NULL;

    if(_pRasEntry)
    {
        switch(_EnumType)
        {
        case ENUM_UNICODE:
            {
            LPRASENTRYW lpTemp = (LPRASENTRYW)_pRasEntry;
            if(*lpTemp->szDeviceType)
                lpwstr = lpTemp->szDeviceType;
            break;
            }
        case ENUM_WIN2K:
            {
            LPW2KRASENTRYW lpTemp = (LPW2KRASENTRYW)_pRasEntry;
            if(*lpTemp->szDeviceType)
                lpwstr = lpTemp->szDeviceType;
            break;
            }
        }
    }

    return lpwstr;
}

LPSTR RasEntryPropHelp::GetDeviceTypeA(VOID)
{
    LPSTR lpstr = NULL;

    if(_pRasEntry)
    {
        switch(_EnumType)
        {
        case ENUM_UNICODE:
            {
            LPRASENTRYW lpTemp = (LPRASENTRYW)_pRasEntry;
            if(*lpTemp->szDeviceType)
            {
                WideCharToMultiByte(CP_ACP, 0, lpTemp->szDeviceType, -1, _szDeviceTypeA, RAS_MaxDeviceType + 1, NULL, NULL);
                lpstr = _szDeviceTypeA;
            }
            break;
            }
        case ENUM_WIN2K:
            {
            LPW2KRASENTRYW lpTemp = (LPW2KRASENTRYW)_pRasEntry;
            if(*lpTemp->szDeviceType)
            {
                WideCharToMultiByte(CP_ACP, 0, lpTemp->szDeviceType, -1, _szDeviceTypeA, RAS_MaxDeviceType + 1, NULL, NULL);
                lpstr = _szDeviceTypeA;
            }
            break;
            }
        }
    }

    return lpstr;
}

LPWSTR RasEntryPropHelp::GetAutodiallDllW()
{
    LPWSTR lpwstr = NULL;

    if(_pRasEntry)
    {
        switch(_EnumType)
        {
        case ENUM_UNICODE:
            {
            LPRASENTRYW lpTemp = (LPRASENTRYW)_pRasEntry;
            if(*lpTemp->szAutodialDll)
                lpwstr = lpTemp->szAutodialDll;
            break;
            }
        case ENUM_WIN2K:
            {
            LPW2KRASENTRYW lpTemp = (LPW2KRASENTRYW)_pRasEntry;
            if(*lpTemp->szAutodialDll)
                lpwstr = lpTemp->szAutodialDll;
            break;
            }
        }
    }

    return lpwstr;
}

LPSTR RasEntryPropHelp::GetAutodiallDllA()
{
    LPSTR lpstr = NULL;

    if(_pRasEntry)
    {
        switch(_EnumType)
        {
        case ENUM_UNICODE:
            {
            LPRASENTRYW lpTemp = (LPRASENTRYW)_pRasEntry;
            if(*lpTemp->szAutodialDll)
            {
                WideCharToMultiByte(CP_ACP, 0, lpTemp->szAutodialDll, -1, _szAutodialDllA, MAX_PATH, NULL, NULL);
                lpstr = _szAutodialDllA;
            }
            break;
            }
        case ENUM_WIN2K:
            {
            LPW2KRASENTRYW lpTemp = (LPW2KRASENTRYW)_pRasEntry;
            if(*lpTemp->szAutodialDll)
            {
                WideCharToMultiByte(CP_ACP, 0, lpTemp->szAutodialDll, -1, _szAutodialDllA, MAX_PATH, NULL, NULL);
                lpstr = _szAutodialDllA;
            }
            break;
            }
        }
    }

    return lpstr;
}

LPWSTR RasEntryPropHelp::GetAutodialFuncW()
{
    LPWSTR lpwstr = NULL;

    if(_pRasEntry)
    {
        switch(_EnumType)
        {
        case ENUM_UNICODE:
            {
            LPRASENTRYW lpTemp = (LPRASENTRYW)_pRasEntry;
            if(*lpTemp->szAutodialFunc)
                lpwstr = lpTemp->szAutodialFunc;
            break;
            }
        case ENUM_WIN2K:
            {
            LPW2KRASENTRYW lpTemp = (LPW2KRASENTRYW)_pRasEntry;
            if(*lpTemp->szAutodialFunc)
                lpwstr = lpTemp->szAutodialFunc;
            break;
            }
        }
    }

    return lpwstr;
}

LPSTR RasEntryPropHelp::GetAutodialFuncA()
{
    LPSTR lpstr = NULL;

    if(_pRasEntry)
    {
        switch(_EnumType)
        {
        case ENUM_UNICODE:
            {
            LPRASENTRYW lpTemp = (LPRASENTRYW)_pRasEntry;
            if(*lpTemp->szAutodialFunc)
            {
                WideCharToMultiByte(CP_ACP, 0, lpTemp->szAutodialFunc, -1, _szAutodialFuncA, RAS_MaxDeviceType + 1, NULL, NULL);
                lpstr = _szAutodialFuncA;
            }
            break;
            }
        case ENUM_WIN2K:
            {
            LPW2KRASENTRYW lpTemp = (LPW2KRASENTRYW)_pRasEntry;
            if(*lpTemp->szAutodialFunc)
            {
                WideCharToMultiByte(CP_ACP, 0, lpTemp->szAutodialFunc, -1, _szAutodialFuncA, RAS_MaxDeviceType + 1, NULL, NULL);
                lpstr = _szAutodialFuncA;
            }
            break;
            }
        }
    }

    return lpstr;
}

LPWSTR RasEntryPropHelp::GetCustomDialDllW()
{
    LPWSTR lpwstr = NULL;

    if(_pRasEntry)
    {
        switch(_EnumType)
        {
        case ENUM_UNICODE:      // Not is NT4
            break;
        case ENUM_WIN2K:
            {
            LPW2KRASENTRYW lpTemp = (LPW2KRASENTRYW)_pRasEntry  ;
            if(*lpTemp->szCustomDialDll)
                lpwstr = lpTemp->szCustomDialDll;
            break;
            }
        }
    }

    return lpwstr;
}

LPWSTR RasEntryPropHelp::GetPhoneNumberW()
{
    LPWSTR lpwstr = NULL;

    if(_pRasEntry)
    {
        switch(_EnumType)
        {
        case ENUM_UNICODE:
            {
            LPRASENTRYW lpTemp = (LPRASENTRYW)_pRasEntry;
            if(*lpTemp->szLocalPhoneNumber)
                lpwstr = lpTemp->szLocalPhoneNumber;
            break;
            }
        case ENUM_WIN2K:
            {
            LPW2KRASENTRYW lpTemp = (LPW2KRASENTRYW)_pRasEntry;
            if(*lpTemp->szLocalPhoneNumber)
                lpwstr = lpTemp->szLocalPhoneNumber;
            break;
            }
        }
    }

    return lpwstr;
}


DWORD RasEntryPropHelp::GetCountryCode()
{
    DWORD dwCode = 0;

    if(_pRasEntry)
    {
        // country code is at the same place for all versions of the struct,
        // so take the shortcut
        dwCode = _pRasEntry->dwCountryCode;
    }

    return dwCode;
}

DWORD RasEntryPropHelp::GetOptions()
{
    DWORD dwOptions = 0;

    if(_pRasEntry)
    {
        // dwfOptions is at the same place for all versions of the struct,
        // so take the shortcut
        dwOptions = _pRasEntry->dwfOptions;
    }

    return dwOptions;
}

LPWSTR RasEntryPropHelp::GetAreaCodeW()
{
    LPWSTR lpwstr = NULL;

    if(_pRasEntry)
    {
        switch(_EnumType)
        {
        case ENUM_UNICODE:
            {
            LPRASENTRYW lpTemp = (LPRASENTRYW)_pRasEntry;
            if(*lpTemp->szAreaCode)
                lpwstr = lpTemp->szAreaCode;
            break;
            }
        case ENUM_WIN2K:
            {
            LPW2KRASENTRYW lpTemp = (LPW2KRASENTRYW)_pRasEntry;
            if(*lpTemp->szAreaCode)
                lpwstr = lpTemp->szAreaCode;
            break;
            }
        }
    }

    return lpwstr;
}



/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
RasGetConnectStatusHelp::RasGetConnectStatusHelp(HRASCONN hrasconn)
{
    // init
    _dwLastError = 0;

    switch(_EnumType)
    {
    case ENUM_UNICODE:
    case ENUM_WIN2K:
        _dwStructSize = sizeof(RASCONNSTATUSW);
        break;
    }

    _pRasConnStatus = (LPRASCONNSTATUSA)LocalAlloc(LPTR, _dwStructSize);
    if(_pRasConnStatus)
    {
        _pRasConnStatus->dwSize = _dwStructSize;

        _dwLastError = _RasGetConnectStatusW(hrasconn, (LPRASCONNSTATUSW)_pRasConnStatus);

        if(_pRasConnStatus && (ERROR_SUCCESS != _dwLastError))
        {
            LocalFree(_pRasConnStatus);
            _pRasConnStatus = NULL;
        }
    }
    else
    {
        _dwLastError = ERROR_NOT_ENOUGH_MEMORY;
    }

    return;
}

RasGetConnectStatusHelp::~RasGetConnectStatusHelp()
{
    _dwLastError = 0;
    if(_pRasConnStatus)
    {
        LocalFree(_pRasConnStatus);
        _pRasConnStatus = NULL;
    }
}

DWORD RasGetConnectStatusHelp::GetError()
{
    return _dwLastError;
}

RASCONNSTATE RasGetConnectStatusHelp::ConnState()
{
    RASCONNSTATE hConnState = (RASCONNSTATE)NULL;

    if(_pRasConnStatus)
    {
        LPRASCONNSTATUSW lpTemp = (LPRASCONNSTATUSW)_pRasConnStatus;
        hConnState = lpTemp->rasconnstate;
    }

    return hConnState;
}



/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5.1\auth\basic.cxx ===
#include <wininetp.h>
#include <splugin.hxx>
#include "htuu.h"

/*---------------------------------------------------------------------------
BASIC_CTX
---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------
    Constructor
---------------------------------------------------------------------------*/
BASIC_CTX::BASIC_CTX(HTTP_REQUEST_HANDLE_OBJECT *pRequest, BOOL fIsProxy, 
                    SPMData* pSPM, AUTH_CREDS* pCreds)
    : AUTHCTX(pSPM, pCreds)
{
    _fIsProxy = fIsProxy;
    _pRequest = pRequest;
}


/*---------------------------------------------------------------------------
    Destructor
---------------------------------------------------------------------------*/
BASIC_CTX::~BASIC_CTX()
{}


/*---------------------------------------------------------------------------
    PreAuthUser
---------------------------------------------------------------------------*/
DWORD BASIC_CTX::PreAuthUser(IN LPSTR pBuf, IN OUT LPDWORD pcbBuf)
{
    if (!_pCreds->lpszUser || !_pCreds->lpszPass)
        return ERROR_INVALID_PARAMETER;
            
    // Prefix the header value with the auth type.
    const static BYTE szBasic[] = "Basic ";

    #define BASIC_LEN sizeof(szBasic)-1

    memcpy (pBuf, szBasic, BASIC_LEN);
    pBuf += BASIC_LEN;

    DWORD cbUserLen = _pCreds->lpszUser ? strlen(_pCreds->lpszUser) : 0;
    DWORD cbPassLen = _pCreds->lpszPass ? strlen(_pCreds->lpszPass) : 0;
    
    // Generate rest of header value by uuencoding user:pass.
    DWORD cbMaxUserPathLen = cbUserLen + 1 + cbPassLen + 1 
        + 2;    // HTUU_encode() parse the buffer 3 bytes at a time; 
                // In the worst case we will be two bytes short, so add 2 here. 
                // longer buffer doesn't matter, HTUU_encode will adjust appropreiately.
    
    LPSTR pszUserPass = New CHAR[cbMaxUserPathLen];
    if (pszUserPass)
    {
        DWORD cbUserPass;
    
        cbUserPass = wsprintf(pszUserPass, "%s:%s", _pCreds->lpszUser, _pCreds->lpszPass);
        
        INET_ASSERT (cbUserPass < cbMaxUserPathLen);
    
        HTUU_encode ((PBYTE) pszUserPass, cbUserPass,
            pBuf, *pcbBuf);
    
        delete [] pszUserPass;
    
        *pcbBuf = BASIC_LEN + lstrlen (pBuf);
        
        _pvContext = (LPVOID) 1;
        return ERROR_SUCCESS;
    }
    else
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
}

/*---------------------------------------------------------------------------
    UpdateFromHeaders
---------------------------------------------------------------------------*/
DWORD BASIC_CTX::UpdateFromHeaders(HTTP_REQUEST_HANDLE_OBJECT *pRequest, BOOL fIsProxy)
{
    DWORD dwAuthIdx, cbRealm, dwError;
    LPSTR szRealm = NULL;
    
    // Get the associated header.
    if ((dwError = FindHdrIdxFromScheme(&dwAuthIdx)) != ERROR_SUCCESS)
        goto exit;

    // Get any realm.
    dwError = GetAuthHeaderData(pRequest, fIsProxy, "Realm", 
        &szRealm, &cbRealm, ALLOCATE_BUFFER, dwAuthIdx);

    // No realm is OK.
    if (dwError != ERROR_SUCCESS)
        szRealm = NULL;

    // If we already have a Creds, ensure that the realm matches. If not,
    // find or create a new one and set it in the auth context.
    if (_pCreds)
    {
        INET_ASSERT(_pCreds->lpszRealm);
        if (/*_pCreds->lpszRealm && */szRealm && lstrcmp(_pCreds->lpszRealm, szRealm))
        {
            // Realms don't match - create a new Creds entry, release the old.
            delete _pCreds;
            _pCreds = CreateCreds(pRequest, fIsProxy, _pSPMData, szRealm);
            INET_ASSERT(_pCreds->pSPM == _pSPMData);
        }
    }
    // If no password cache is set in the auth context,
    // find or create one and set it in the auth context.
    else
    {            
        // Find or create a password cache entry.
        _pCreds = CreateCreds(pRequest, fIsProxy, _pSPMData, szRealm);
        if (!_pCreds)
        {
            dwError = ERROR_WINHTTP_INTERNAL_ERROR;
            goto exit;
        }
        INET_ASSERT(_pCreds->pSPM == _pSPMData);
        // _pCreds->nLockCount++;
    }

    if (!_pCreds)
    {
        INET_ASSERT(FALSE);
        dwError = ERROR_WINHTTP_INTERNAL_ERROR;
        goto exit;
    }

    dwError = ERROR_SUCCESS;
        
    exit:

    if (szRealm)
        delete []szRealm;

    return dwError;
}


/*---------------------------------------------------------------------------
    PostAuthUser
---------------------------------------------------------------------------*/
DWORD BASIC_CTX::PostAuthUser()
{
    DWORD dwRet;

    if (! _pvContext && !_pRequest->GetCreds() 
        && _pCreds->lpszUser && _pCreds->lpszPass)
        dwRet = ERROR_WINHTTP_FORCE_RETRY;
    else
        dwRet = ERROR_WINHTTP_INCORRECT_PASSWORD;

    _pRequest->SetCreds(NULL);
    _pvContext = (LPVOID) 1;
    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5.1\api\registry.cxx ===
/*++


Copyright (c) 1994  Microsoft Corporation

Module Name:

    registry.cxx

Abstract:

    Functions to read/write registry parameters

    Contents:
        OpenInternetSettingsKey
        CloseInternetSettingsKey
        InternetGetComputerName
        InternetDeleteRegistryValue
        InternetReadRegistryDword
        InternetWriteRegistryDword
        InternetReadRegistryString
        InternetWriteRegistryString
        InternetReadRegistryBinary
        (InternetReadRegistryDwordKey)
        (InternetReadRegistryStringKey)
        (InternetReadRegistryBinaryKey)
        (InternetGetPrivateProfileString)
        (ReadRegistryOemString)
        (WriteRegistryDword)
        ReadRegistryDword

Author:

    Richard L Firth (rfirth) 20-Mar-1995

Environment:

    Win32(s) user-level DLL

Revision History:

    20-Mar-1995 rfirth
        Created

--*/

#include <wininetp.h>

char vszDelimiters[] = ";, ";

//
// manifests
//

#define INTERNET_CLIENT_KEY         "Internet Settings"
#define SYSTEM_INI_FILE_NAME        "SYSTEM.INI"
#define NETWORK_SECTION_NAME        "Network"
#define COMPUTER_NAME_VALUE         "ComputerName"
#define PROFILE_INT_BUFFER_LENGTH   128

#define MIME_TO_FILE_EXTENSION_KEY  "MIME\\Database\\Content Type\\"
#define EXTENSION_VALUE             "Extension"

//
// macros
//

#define INTERNET_SETTINGS_KEY       "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings"
#define INTERNET_CACHE_SETTINGS_KEY "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\5.0\\Cache"

//
// private prototypes
//

PRIVATE
DWORD
InternetReadRegistryDwordKey(
    IN HKEY ParameterKey,
    IN LPCSTR ParameterName,
    OUT LPDWORD ParameterValue,
    IN LPCSTR keyToReadFrom
    );

PRIVATE
DWORD
InternetReadRegistryStringKey(
    IN HKEY ParameterKey,
    IN LPCSTR ParameterName,
    OUT LPSTR ParameterValue,
    IN OUT LPDWORD ParameterLength,
    IN LPCSTR keyToReadFrom
    );

//PRIVATE
//DWORD
//InternetReadRegistryBinaryKey(
//    IN HKEY ParameterKey,
//    IN LPCSTR ParameterName,
//    OUT LPBYTE ParameterValue,
//    IN OUT LPDWORD ParameterLength
//    );
//
//PRIVATE
//DWORD
//InternetGetPrivateProfileString(
//    IN LPSTR IniFileName,
//    IN LPSTR SectionName,
//    IN LPCSTR ParameterName,
//    OUT LPSTR ParameterValue,
//    IN OUT LPDWORD ParameterLength
//    );

PRIVATE
DWORD
ReadRegistryOemString(
    IN HKEY Key,
    IN LPCSTR ParameterName,
    OUT LPSTR String,
    IN OUT LPDWORD Length
    );




PRIVATE
DWORD
WriteRegistryDword(
    IN HKEY Key,
    IN LPCSTR ParameterName,
    IN DWORD ParameterValue
    );

//
// private data
//

PRIVATE HKEY hKeyInternetSettings = NULL;

//
// functions
//


DWORD
OpenInternetSettingsKey(
    VOID
    )

/*++

Routine Description:

    Opens registry key for Internet Settings branch

Arguments:

    None.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "OpenInternetSettingsKey",
                 NULL
                 ));

    DWORD error = ERROR_SUCCESS;

    if (!GeneralInitCritSec.Lock())
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    if (hKeyInternetSettings == NULL) {

        DWORD dwDisposition;

        REGCREATEKEYEX(HKEY_LOCAL_MACHINE,
                       INTERNET_SETTINGS_KEY,
                       0,     // reserved
                       NULL,  // class
                       0,     // options
                       KEY_READ | KEY_WRITE,
                       NULL,  // security attributes
                       &hKeyInternetSettings,
                       &dwDisposition
                       );
    }

    GeneralInitCritSec.Unlock();

quit:
    DEBUG_LEAVE(error);

    return error;
}


DWORD
CloseInternetSettingsKey(
    VOID
    )

/*++

Routine Description:

    Closes Internet Settings registry key

Arguments:

    None.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "CloseInternetSettingsKey",
                 NULL
                 ));

    DWORD error = ERROR_SUCCESS;

    if (hKeyInternetSettings != NULL) {
        error = REGCLOSEKEY(hKeyInternetSettings);
        hKeyInternetSettings = NULL;
    }

    DEBUG_LEAVE(error);

    return error;
}


PUBLIC
DWORD
InternetDeleteRegistryValue(
    IN LPSTR ParameterName
    )

/*++

Routine Description:

    Delets an entry from a the Internet Client registry key if the platform
    is NT/Win95.

Arguments:

    ParameterName   - name of the parameter to retrieve (e.g. AccessType)

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND

--*/

{
    DWORD error;

    DEBUG_ENTER((DBG_REGISTRY,
                Dword,
                "InternetDeleteRegistryValue",
                "%q",
                ParameterName
                ));


    HKEY clientKey;

    //
    // open the registry key containing the Internet client values (this is
    // in the same place on NT and Win95)
    //

    error = REGOPENKEYEX(HKEY_CURRENT_USER,
                         INTERNET_SETTINGS_KEY,
                         0, // reserved
                         KEY_ALL_ACCESS,
                         &clientKey
                         );


    if (error == ERROR_SUCCESS) {

        error = RegDeleteValue(clientKey,
                               ParameterName
                               );

        REGCLOSEKEY(clientKey);
    }


    DEBUG_LEAVE(error);

    return error;
}




DWORD
InternetReadRegistryDword(
    IN LPCSTR ParameterName,
    OUT LPDWORD ParameterValue
    )

/*++

Routine Description:

    Reads a single DWORD from a the Internet Client registry key if the platform
    is NT/Win95, else reads the value from SYSTEM.INI if we are running on Win32s

Arguments:

    ParameterName   - name of the parameter to retrieve (e.g. AccessType)

    ParameterValue  - pointer to place to store retrieved value

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "InternetReadRegistryDword",
                 "%q, %x",
                 ParameterName,
                 ParameterValue
                 ));

    DWORD error = InternetReadRegistryDwordKey(HKEY_LOCAL_MACHINE,
                                               ParameterName,
                                               ParameterValue
                                               );

    DEBUG_LEAVE(error);

    return error;
}

#ifdef WININET6

DWORD
InternetIDEWriteRegistryDword(
    IN LPCSTR ParameterName,
    IN DWORD ParameterValue
    )

/*++

Routine Description:

    Writes a single DWORD from to the Internet Client registry key if the platform
    is NT/Win95, otherwise it fails.

Arguments:

    ParameterName   - name of the parameter to retrieve (e.g. AccessType)

    ParameterValue  - value to store in registry.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "InternetIDEWriteRegistryDword",
                 "%q, %x",
                 ParameterName,
                 ParameterValue
                 ));

    DWORD error = GlobalIdentity 
                ? WriteIDRegDword(ParameterName, ParameterValue)
                : InternetWriteRegistryDword(ParameterName, ParameterValue);

    DEBUG_LEAVE(error);

    return error;
}



DWORD
InternetIDEReadRegistryDword(
    IN LPCSTR ParameterName,
    OUT LPDWORD ParameterValue
    )

/*++

Routine Description:

    If we're in an identity-mode, we'll read from the special location.
    Otherwise, read from the old location.

Arguments:

    ParameterName   - name of the parameter to retrieve (e.g. AccessType)

    ParameterValue  - pointer to place to store retrieved value

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "InternetIDEReadRegistryDword",
                 "%q, %x",
                 ParameterName,
                 ParameterValue
                 ));

    DWORD error = GlobalIdentity
                ? ReadIDRegDword(ParameterName, ParameterValue)
                : InternetReadRegistryDwordKey(HKEY_CURRENT_USER, ParameterName, ParameterValue);

    DEBUG_LEAVE(error);

    return error;
}
#endif


DWORD
InternetCacheReadRegistryDword(
    IN LPCSTR ParameterName,
    OUT LPDWORD ParameterValue
    )

/*++

Routine Description:

    Reads a single DWORD from a the Internet Client registry key if the platform
    is NT/Win95, else reads the value from SYSTEM.INI if we are running on Win32s

Arguments:

    ParameterName   - name of the parameter to retrieve (e.g. AccessType)

    ParameterValue  - pointer to place to store retrieved value

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "InternetCacheReadRegistryDword",
                 "%q, %x",
                 ParameterName,
                 ParameterValue
                 ));

    DWORD error = ERROR_SUCCESS;
    HKEY clientKey;

    error = REGOPENKEYEX(HKEY_CURRENT_USER,
                         INTERNET_CACHE_SETTINGS_KEY,
                         0, // reserved
                         KEY_QUERY_VALUE,
                         &clientKey
                         );

    if (error == ERROR_SUCCESS) {
        error = ReadRegistryDword(clientKey,
                                  ParameterName,
                                  ParameterValue
                                  );
        REGCLOSEKEY(clientKey);
    }

    DEBUG_LEAVE(error);

    return error;
}



DWORD
InternetWriteRegistryDword(
    IN LPCSTR ParameterName,
    IN DWORD ParameterValue
    )

/*++

Routine Description:

    Writes a single DWORD from to the Internet Client registry key if the platform
    is NT/Win95, otherwise it fails.

Arguments:

    ParameterName   - name of the parameter to retrieve (e.g. AccessType)

    ParameterValue  - value to store in registry.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "InternetWriteRegistryDword",
                 "%q, %x",
                 ParameterName,
                 ParameterValue
                 ));

    DWORD error;

    if (hKeyInternetSettings != NULL) {
        error = WriteRegistryDword(hKeyInternetSettings,
                                   ParameterName,
                                   ParameterValue
                                   );
    } else {
        error = ERROR_SUCCESS;
    }

    DEBUG_PRINT(REGISTRY,
                INFO,
                ("InternetWriteRegistryDword(%q): value = %d (%#x)\n",
                ParameterName,
                ParameterValue,
                ParameterValue
                ));

    DEBUG_LEAVE(error);

    return error;
}



DWORD
InternetReadRegistryString(
    IN LPCSTR ParameterName,
    OUT LPSTR ParameterValue,
    IN OUT LPDWORD ParameterLength
    )

/*++

Routine Description:

    Reads a string from the Internet Client registry key on NT/Win95, or reads
    the corresponding value from SYSTEM.INI on a Win32s platform

Arguments:

    ParameterName   - name of value parameter within key (e.g. EmailName)

    ParameterValue  - pointer to string buffer for returned string

    ParameterLength - IN: number of bytes in ParameterValue
                      OUT: number of bytes in string (excluding trailing '\0')

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "InternetReadRegistryString",
                 "%q, %x, %x [%d]",
                 ParameterName,
                 ParameterValue,
                 ParameterLength,
                 *ParameterLength
                 ));

    DWORD error = InternetReadRegistryStringKey(HKEY_CURRENT_USER,
                                                ParameterName,
                                                ParameterValue,
                                                ParameterLength
                                                );

    DEBUG_LEAVE(error);

    return error;
}

//
//DWORD
//InternetWriteRegistryString(
//    IN LPCSTR ParameterName,
//    IN LPSTR ParameterValue
//    )
//
///*++
//
//Routine Description:
//
//    Writes a string to the Internet Client registry key on NT/Win95, or writes
//    the corresponding value to SYSTEM.INI on Win32s platform
//
//Arguments:
//
//    ParameterName   - name of value parameter within key (e.g. EmailName)
//
//    ParameterValue  - pointer to string to write
//
//Return Value:
//
//    DWORD
//        Success - ERROR_SUCCESS
//
//        Failure -
//
//--*/
//
//{
//    DEBUG_ENTER((DBG_REGISTRY,
//                 Dword,
//                 "InternetWriteRegistryString",
//                 "%.40q, %.80q",
//                 ParameterName,
//                 ParameterValue
//                 ));
//
//    DWORD error;
//
//    if (IsPlatformWin32s()) {
//
//        BOOL ok;
//
//        ok = WritePrivateProfileString(INTERNET_CLIENT_KEY,
//                                       ParameterName,
//                                       ParameterValue,
//                                       SYSTEM_INI_FILE_NAME
//                                       );
//        error = ok ? ERROR_SUCCESS : GetLastError();
//    } else {
//
//        //
//        // BUGBUG - currently, nothing needs to write to registry if NT or Win95
//        //
//
//        INET_ASSERT(FALSE);
//
//    }
//
//    DEBUG_LEAVE(error);
//
//    return error;
//}
//
//
//DWORD
//InternetReadRegistryBinary(
//    IN LPCSTR ParameterName,
//    OUT LPBYTE ParameterValue,
//    IN OUT LPDWORD ParameterLength
//    )
//
///*++
//
//Routine Description:
//
//    Reads a binary value from the Internet Client registry key on NT/Win95, or
//    reads the corresponding value from SYSTEM.INI on a Win32s platform
//
//Arguments:
//
//    ParameterName   - name of value parameter within key (e.g. EmailName)
//
//    ParameterValue  - pointer to buffer for returned data
//
//    ParameterLength - IN: number of bytes in ParameterValue
//                      OUT: number of bytes in buffer, or required size
//
//Return Value:
//
//    DWORD
//        Success - ERROR_SUCCESS
//
//        Failure - ERROR_PATH_NOT_FOUND
//                    The parameter wasn't found
//
//                  ERROR_MORE_DATA
//                    The buffer isn't large enough
//
//--*/
//
//{
//    DEBUG_ENTER((DBG_REGISTRY,
//                 Dword,
//                 "InternetReadRegistryBinary",
//                 "%q, %#x, %#x [%d]",
//                 ParameterName,
//                 ParameterValue,
//                 ParameterLength,
//                 *ParameterLength
//                 ));
//
//    DWORD error;
//
//    error = InternetReadRegistryBinaryKey(HKEY_CURRENT_USER,
//                                          ParameterName,
//                                          ParameterValue,
//                                          ParameterLength
//                                          );
//
//    DEBUG_LEAVE(error);
//
//    return error;
//}

//
// private functions
//


PUBLIC
DWORD
InternetReadRegistryDwordKey(
    IN HKEY ParameterKey,
    IN LPCSTR ParameterName,
    OUT LPDWORD ParameterValue,
    IN LPCSTR keyToReadFrom
    )

/*++

Routine Description:

    Reads a single DWORD from a the Internet Client registry key if the platform
    is NT/Win95, else reads the value from SYSTEM.INI if we are running on Win32s.

    Does not modify the *ParameterValue if the registry variable cannot be read

Arguments:

    ParameterKey    - root registry key (e.g. HKEY_CURRENT_USER)

    ParameterName   - name of the parameter to retrieve (e.g. AccessType)

    ParameterValue  - pointer to place to store retrieved value

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "InternetReadRegistryDwordKey",
                 "%s, %q, %x",
                 (ParameterKey == HKEY_LOCAL_MACHINE)
                    ? "HKEY_LOCAL_MACHINE"
                    : (ParameterKey == HKEY_CURRENT_USER)
                        ? "HKEY_CURRENT_USER"
                        : "???",
                 ParameterName,
                 ParameterValue
                 ));

    DWORD error = ERROR_SUCCESS;
    HKEY clientKey = hKeyInternetSettings;

    if (ParameterKey != HKEY_CURRENT_USER) {
        error = REGOPENKEYEX(ParameterKey,
                             keyToReadFrom,
                             0, // reserved
                             KEY_QUERY_VALUE,
                             &clientKey
                             );
    } else if (clientKey == NULL) {
        error = ERROR_PATH_NOT_FOUND;
    }

    if (error == ERROR_SUCCESS) {
        error = ReadRegistryDword(clientKey,
                                  ParameterName,
                                  ParameterValue
                                  );
        if (clientKey != hKeyInternetSettings) {
            REGCLOSEKEY(clientKey);
        }
    }

    DEBUG_PRINT(REGISTRY,
                INFO,
                ("InternetReadRegistryDwordKey(%q): value = %d (%#x)\n",
                ParameterName,
                *ParameterValue,
                *ParameterValue
                ));

    DEBUG_LEAVE(error);

    return error;
}


PRIVATE
DWORD
InternetReadRegistryStringKey(
    IN HKEY ParameterKey,
    IN LPCSTR ParameterName,
    OUT LPSTR ParameterValue,
    IN OUT LPDWORD ParameterLength,
    IN LPCSTR keyToReadFrom
    )

/*++

Routine Description:

    Reads a string from the Internet Client registry key on NT/Win95, or reads
    the corresponding value from SYSTEM.INI on a Win32s platform

Arguments:

    ParameterKey    - root registry key (e.g. HKEY_LOCAL_MACHINE)

    ParameterName   - name of value parameter within key (e.g. EmailName)

    ParameterValue  - pointer to string buffer for returned string

    ParameterLength - IN: number of bytes in ParameterValue
                      OUT: number of bytes in string (excluding trailing '\0')

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "InternetReadRegistryStringKey",
                 "%s (%x), %q, %x, %x [%d]",
                 (ParameterKey == HKEY_LOCAL_MACHINE)
                    ? "HKEY_LOCAL_MACHINE"
                    : (ParameterKey == HKEY_CURRENT_USER)
                        ? "HKEY_CURRENT_USER"
                        : "???",
                 ParameterKey,
                 ParameterName,
                 ParameterValue,
                 ParameterLength,
                 *ParameterLength
                 ));

    //
    // zero-terminate the string
    //

    if (*ParameterLength > 0) {
        *ParameterValue = '\0';
    }

    DWORD error = ERROR_SUCCESS;
    HKEY clientKey = hKeyInternetSettings;

    if (ParameterKey != HKEY_CURRENT_USER) {
        error = REGOPENKEYEX(ParameterKey,
                             keyToReadFrom,
                             0, // reserved
                             KEY_QUERY_VALUE,
                             &clientKey
                             );
    } else if (clientKey == NULL) {
        error = ERROR_PATH_NOT_FOUND;
    }

    if (error == ERROR_SUCCESS) {
        error = ReadRegistryOemString(clientKey,
                                      ParameterName,
                                      ParameterValue,
                                      ParameterLength
                                      );
        if (clientKey != hKeyInternetSettings) {
            REGCLOSEKEY(clientKey);
        }
    }

    DEBUG_PRINT(REGISTRY,
                INFO,
                ("InternetReadRegistryStringKey(%q): value = %q\n",
                ParameterName,
                ParameterValue
                ));

    DEBUG_LEAVE(error);

    return error;
}

//
//PRIVATE
//DWORD
//InternetReadRegistryBinaryKey(
//    IN HKEY ParameterKey,
//    IN LPCSTR ParameterName,
//    OUT LPBYTE ParameterValue,
//    IN OUT LPDWORD ParameterLength
//    )
//
///*++
//
//Routine Description:
//
//    Reads a binary value from the Internet Client registry key on NT/Win95, or
//    reads the corresponding value from SYSTEM.INI on a Win32s platform
//
//Arguments:
//
//    ParameterKey    - root registry key (e.g. HKEY_LOCAL_MACHINE)
//
//    ParameterName   - name of value parameter within key (e.g. EmailName)
//
//    ParameterValue  - pointer to buffer for returned data
//
//    ParameterLength - IN: number of bytes in ParameterValue
//                      OUT: number of bytes in buffer, or required size
//
//Return Value:
//
//    DWORD
//        Success - ERROR_SUCCESS
//
//        Failure - ERROR_PATH_NOT_FOUND
//                    The parameter wasn't found
//
//                  ERROR_MORE_DATA
//                    The buffer isn't large enough
//
//--*/
//
//{
//    DEBUG_ENTER((DBG_REGISTRY,
//                 Dword,
//                 "InternetReadRegistryBinaryKey",
//                 "%s (%x), %q, %#x, %#x [%d]",
//                 (ParameterKey == HKEY_LOCAL_MACHINE)
//                    ? "HKEY_LOCAL_MACHINE"
//                    : (ParameterKey == HKEY_CURRENT_USER)
//                        ? "HKEY_CURRENT_USER"
//                        : "???",
//                 ParameterKey,
//                 ParameterName,
//                 ParameterValue,
//                 ParameterLength,
//                 *ParameterLength
//                 ));
//
//    DWORD error;
//    HKEY clientKey;
//
//    //
//    // open the registry key containing the Internet client values (this is
//    // in the same place on NT and Win95)
//    //
//
//    error = REGOPENKEYEX(ParameterKey,
//                         INTERNET_SETTINGS_KEY,
//                         0, // reserved
//                         KEY_QUERY_VALUE,
//                         &clientKey
//                         );
//
//    if (error == ERROR_SUCCESS) {
//
//        DWORD valueType;
//
//        error = RegQueryValueEx(clientKey,
//                                ParameterName,
//                                NULL,   // reserved
//                                &valueType,
//                                ParameterValue,
//                                ParameterLength
//                                );
//        REGCLOSEKEY(clientKey);
//    }
//
//    DEBUG_PRINT(REGISTRY,
//                INFO,
//                ("InternetReadRegistryBinaryKey(%q): length = %d\n",
//                ParameterName,
//                *ParameterLength
//                ));
//
//    DEBUG_LEAVE(error);
//
//    return error;
//}
//
//
//PRIVATE
//DWORD
//InternetGetPrivateProfileString(
//    IN LPSTR IniFileName,
//    IN LPSTR SectionName,
//    IN LPCSTR ParameterName,
//    OUT LPSTR ParameterValue,
//    IN OUT LPDWORD ParameterLength
//    )
//
///*++
//
//Routine Description:
//
//    Reads an string out of an INI file. Mainly just for Win32s
//
//Arguments:
//
//    IniFileName     - name of INI file to read
//
//    SectionName     - name of section in INI file to read
//
//    ParameterName   - name of entry in section to read
//
//    ParameterValue  - returned string
//
//    ParameterLength - IN: Length of ParameterValue
//                      OUT: Number of characters in ParameterValue, excluding
//                           terminating NUL
//
//Return Value:
//
//    DWORD
//        Success - ERROR_SUCCESS
//
//        Failure - ERROR_PATH_NOT_FOUND
//                  ERROR_FILE_NOT_FOUND
//
//--*/
//
//{
//    DWORD error;
//    DWORD nChars;
//
//    nChars = GetPrivateProfileString(SectionName,
//                                     ParameterName,
//                                     "",                // lpszDefault
//                                     ParameterValue,
//                                     *ParameterLength,
//                                     IniFileName
//                                     );
//    if (nChars > 0) {
//        *ParameterLength = nChars;
//        error = ERROR_SUCCESS;
//    } else {
//        error = ERROR_PATH_NOT_FOUND;
//    }
//    return error;
//}


PRIVATE
DWORD
ReadRegistryOemString(
    IN HKEY Key,
    IN LPCSTR ParameterName,
    OUT LPSTR String,
    IN OUT LPDWORD Length
    )

/*++

Routine Description:

    Reads a string out of the registry as an OEM string

Arguments:

    Key             - open registry key where to read value from

    ParameterName   - name of registry value to read

    String          - place to put it

    Length          - IN: length of String buffer in characters
                      OUT: length of String in characters, as if returned from
                      strlen()

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_FILE_NOT_FOUND
                    Couldn't find the parameter

                  ERROR_PATH_NOT_FOUND
                    Couldn't find the parameter
--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "ReadRegistryOemString",
                 "%#x, %q, %#x, %#x [%d]",
                 Key,
                 ParameterName,
                 String,
                 Length,
                 *Length
                 ));

    LONG error;
    DWORD valueType;
    DWORD valueLength;

    //
    // first, get the length of the string
    //

    valueLength = *Length;
    error = RegQueryValueEx(Key,
                            ParameterName,
                            NULL, // reserved
                            &valueType,
                            (LPBYTE)String,
                            &valueLength
                            );
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // we only support REG_SZ (single string) values in this function
    //

    if (valueType != REG_SZ) {
        error = ERROR_PATH_NOT_FOUND;
        goto quit;
    }

    //
    // if 1 or 0 chars returned then the string is empty
    //

    if (valueLength <= sizeof(char)) {
        error = ERROR_PATH_NOT_FOUND;
        goto quit;
    }

    //
    // convert the ANSI string to OEM character set in place. According to Win
    // help, this always succeeds
    //

    CharToOem(String, String);

    //
    // return the length as if returned from strlen() (i.e. drop the '\0')
    //

    *Length = valueLength - sizeof(char);

    DEBUG_PRINT(REGISTRY,
                INFO,
                ("ReadRegistryOemString(%q) returning %q (%d chars)\n",
                ParameterName,
                String,
                *Length
                ));

quit:

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ReadRegistryDword(
    IN HKEY Key,
    IN LPCSTR ParameterName,
    OUT LPDWORD ParameterValue
    )

/*++

Routine Description:

    Reads a DWORD parameter from the registry

    Won't modify *ParameterValue unless a valid value is read from the registry

Arguments:

    Key             - handle of open registry key where parameter resides

    ParameterName   - name of DWORD parameter to read

    ParameterValue  - returned DWORD parameter read from registry

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND
                    One of the following occurred:
                        - the parameter is not in the specified registry key
                        - the parameter is the wrong type
                        - the parameter is the wrong size

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "ReadRegistryDword",
                 "%x, %q, %x",
                 Key,
                 ParameterName,
                 ParameterValue
                 ));

    DWORD error;
    DWORD valueLength;
    DWORD valueType;
    DWORD value;

    valueLength = sizeof(*ParameterValue);
    error = (DWORD)RegQueryValueEx(Key,
                                   ParameterName,
                                   NULL, // reserved
                                   &valueType,
                                   (LPBYTE)&value,
                                   &valueLength
                                   );

    //
    // if the size or type aren't correct then return an error, else only if
    // success was returned do we modify *ParameterValue
    //

    if (error == ERROR_SUCCESS) {
        if (((valueType != REG_DWORD)
        && (valueType != REG_BINARY))
        || (valueLength != sizeof(DWORD))) {

            DEBUG_PRINT(REGISTRY,
                        ERROR,
                        ("valueType = %d, valueLength = %d\n",
                        valueType,
                        valueLength
                        ));

            error = ERROR_PATH_NOT_FOUND;
        } else {
            *ParameterValue = value;
        }
    }

    DEBUG_LEAVE(error);

    return error;
}


PRIVATE
DWORD
WriteRegistryDword(
    IN HKEY Key,
    IN LPCSTR ParameterName,
    IN DWORD ParameterValue
    )

/*++

Routine Description:

    Writes a DWORD parameter from the registry

    Will write ParameterValue to the key.

Arguments:

    Key             - handle of open registry key where parameter resides

    ParameterName   - name of DWORD parameter to write

    ParameterValue  - DWORD parameter to write from registry

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND
                    One of the following occurred:
                        - the parameter is not in the specified registry key
                        - the parameter is the wrong type
                        - the parameter is the wrong size

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "WriteRegistryDword",
                 "%x, %q, %x",
                 Key,
                 ParameterName,
                 ParameterValue
                 ));

    DWORD error;
    DWORD valueLength;
    DWORD valueType;
    DWORD value;

    valueLength = sizeof(ParameterValue);
    valueType   = REG_DWORD;
    value       = ParameterValue;

    error = (DWORD)RegSetValueEx(Key,
                                 ParameterName,
                                 NULL, // reserved
                                 valueType,
                                 (LPBYTE)&value,
                                 valueLength
                                 );

    DEBUG_PRINT(REGISTRY,
                INFO,
                ("added: valueType = %d, valueLength = %d\n",
                valueType,
                valueLength
                ));

    DEBUG_LEAVE(error);

    return error;
}

#if INET_DEBUG

typedef struct {
    LIST_ENTRY entry;
    HKEY hkey;
    char * file;
    int line;
    char name[1];
} DBGREGKEYINFO;

SERIALIZED_LIST DbgRegKeyList;

VOID DbgRegKey_Init(VOID) {
    InitializeSerializedList(&DbgRegKeyList);
}

VOID DbgRegKey_Terminate(VOID) {
    TerminateSerializedList(&DbgRegKeyList);
}

void regkey_add(const char * name, HKEY hkey, char * file, int line) {

    if (!name) {
        name = "";
    }

    int len = lstrlen(name);
    DBGREGKEYINFO * p = (DBGREGKEYINFO *)ALLOCATE_FIXED_MEMORY(sizeof(DBGREGKEYINFO) + len);

    if (p) {
//dprintf("Wininet.DbgRegKey: adding %q\n", name);
        memcpy(p->name, name, len + 1);
        p->line = line;
        p->file = file;
        p->hkey = hkey;
        InsertAtHeadOfSerializedList(&DbgRegKeyList, &p->entry);
    }
}

void regkey_remove(HKEY hkey) {
    if (LockSerializedList(&DbgRegKeyList))
    {

        DBGREGKEYINFO * p = (DBGREGKEYINFO *)HeadOfSerializedList(&DbgRegKeyList);

        while (p != (DBGREGKEYINFO *)SlSelf(&DbgRegKeyList)) {
            if (p->hkey == hkey) {
                RemoveFromSerializedList(&DbgRegKeyList, (PLIST_ENTRY)p);
//dprintf("Wininet.DbgRegKey: removing %q\n", p->name);
                FREE_MEMORY(p);
                break;
            }
            p = (DBGREGKEYINFO *)p->entry.Flink;
        }
        UnlockSerializedList(&DbgRegKeyList);
    }
}

char * regkey_name(HKEY hkey, const char * subname) {
    switch ((INT_PTR)hkey) {
    case (INT_PTR)HKEY_CLASSES_ROOT:
        return NEW_STRING("HKEY_CLASSES_ROOT");

    case (INT_PTR)HKEY_CURRENT_USER:
        return NEW_STRING("HKEY_CURRENT_USER");

    case (INT_PTR)HKEY_LOCAL_MACHINE:
        return NEW_STRING("HKEY_LOCAL_MACHINE");

    case (INT_PTR)HKEY_USERS:
        return NEW_STRING("HKEY_USERS");

    case (INT_PTR)HKEY_PERFORMANCE_DATA:
        return NEW_STRING("HKEY_PERFORMANCE_DATA");

    case (INT_PTR)HKEY_CURRENT_CONFIG:
        return NEW_STRING("HKEY_CURRENT_CONFIG");

    case (INT_PTR)HKEY_DYN_DATA:
        return NEW_STRING("HKEY_DYN_DATA");
    }

    char * name = NULL;

    if (LockSerializedList(&DbgRegKeyList))
    {
        DBGREGKEYINFO * p = (DBGREGKEYINFO *)HeadOfSerializedList(&DbgRegKeyList);

        while (p != (DBGREGKEYINFO *)SlSelf(&DbgRegKeyList)) {
            if (p->hkey == hkey) {

                int len = lstrlen(p->name);
                int slen = lstrlen(subname);

                name = (char *)ALLOCATE_FIXED_MEMORY(len + 1 + slen + 1);
                if (name) {
                    memcpy(name, p->name, len);
                    name[len] = '\\';
                    memcpy(name + len + 1, subname, slen + 1);
                }
                break;
            }
            p = (DBGREGKEYINFO *)p->entry.Flink;
        }
        UnlockSerializedList(&DbgRegKeyList);
    }

    return name;
}

void regkey_freename(char * name) {
    if (name) {
        FREE_MEMORY(name);
    }
}

LONG
DbgRegOpenKey(
    IN HKEY hKey,
    IN LPCTSTR lpszSubKey,
    OUT PHKEY phkResult,
    char * file,
    int line
    )
{
    char * keyname = regkey_name(hKey, lpszSubKey);
    LONG rc = RegOpenKey(hKey, lpszSubKey, phkResult);

    if (rc == 0) {
        regkey_add(keyname, *phkResult, file, line);
    }
    regkey_freename(keyname);
    return rc;
}

LONG
DbgRegOpenKeyEx(
    IN HKEY hKey,
    IN LPCSTR lpSubKey,
    IN DWORD ulOptions,
    IN REGSAM samDesired,
    OUT PHKEY phkResult,
    char * file,
    int line
    )
{
    char * keyname = regkey_name(hKey, lpSubKey);
    LONG rc = RegOpenKeyEx(hKey, lpSubKey, ulOptions, samDesired, phkResult);

    if (rc == 0) {
        regkey_add(keyname, *phkResult, file, line);
    }
    regkey_freename(keyname);
    return rc;
}

LONG
DbgRegCreateKeyEx(
    IN HKEY hKey,
    IN LPCSTR lpSubKey,
    IN DWORD Reserved,
    IN LPSTR lpClass,
    IN DWORD dwOptions,
    IN REGSAM samDesired,
    IN LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    OUT PHKEY phkResult,
    OUT LPDWORD lpdwDisposition,
    char * file,
    int line
    )
{
    char * keyname = regkey_name(hKey, lpSubKey);
    LONG rc = RegCreateKeyEx(hKey, lpSubKey, Reserved, lpClass, dwOptions, samDesired, lpSecurityAttributes, phkResult, lpdwDisposition);

    if (rc == 0) {
        regkey_add(keyname, *phkResult, file, line);
    }
    regkey_freename(keyname);
    return rc;
}

LONG
DbgRegCloseKey(
    IN HKEY hKey
    )
{
    LONG rc = RegCloseKey(hKey);

    if (rc == 0) {
        regkey_remove(hKey);
    }
    return rc;
}

#endif // INET_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5.1\api\options.cxx ===
/*++

Copyright (c) 1994-98  Microsoft Corporation

Module Name:

    options.cxx

Abstract:

    Contains the Internet*Option APIs

    Contents:
        InternetQueryOptionA
        InternetSetOptionA
        WinHttpQueryOption
        WinHttpSetOption
        (FValidCacheHandleType)

Author:

    Richard L Firth (rfirth) 02-Mar-1995

Environment:

    Win32 user-mode DLL

Revision History:

    02-Mar-1995 rfirth
        Created

    07-Mar-1995 madana

    07-Jul-1998 Forked by akabir

--*/

#include <wininetp.h>
#include <perfdiag.hxx>
#include "msident.h"

//
// private macros
//

//
// IS_PER_THREAD_OPTION - options applicable to the thread (HINTERNET is NULL).
// Subset of IS_VALID_OPTION()
//

#define IS_PER_THREAD_OPTION(option) ((                     \
       ((option) == WINHTTP_OPTION_EXTENDED_ERROR)         \
    ) ? TRUE : FALSE)

//
// IS_PER_PROCESS_OPTION - options applicable to the process (HINTERNET is NULL).
// Subset of IS_VALID_OPTION()
//

#define IS_PER_PROCESS_OPTION(option)                       \
    (( ((option) == WINHTTP_OPTION_GET_DEBUG_INFO)         \
    || ((option) == WINHTTP_OPTION_SET_DEBUG_INFO)         \
    || ((option) == WINHTTP_OPTION_GET_HANDLE_COUNT)       \
    || ((option) == WINHTTP_OPTION_PROXY)                  \
    || ((option) == WINHTTP_OPTION_VERSION)                \
    || ((option) == WINHTTP_OPTION_HTTP_VERSION)           \
    || ((option) == WINHTTP_OPTION_WORKER_THREAD_COUNT) \
    ) ? TRUE : FALSE)

//
// IS_DEBUG_OPTION - the set of debug-specific options
//

#define IS_DEBUG_OPTION(option)                     \
    (( ((option) >= INTERNET_FIRST_DEBUG_OPTION)    \
    && ((option) <= INTERNET_LAST_DEBUG_OPTION)     \
    ) ? TRUE : FALSE)

//
// IS_VALID_OPTION - the set of known option values, for a HINTERNET, thread, or
// process. In the retail version, debug options are invalid
//

#if INET_DEBUG

#define IS_VALID_OPTION(option)             \
    (((((option) >= WINHTTP_FIRST_OPTION)  \
    && ((option) <= WINHTTP_LAST_OPTION_INTERNAL))  \
    || IS_DEBUG_OPTION(option)              \
    ) ? TRUE : FALSE)

#else

#define IS_VALID_OPTION(option)             \
    (((((option) >= WINHTTP_FIRST_OPTION)  \
    && ((option) <= WINHTTP_LAST_OPTION_INTERNAL))  \
    ) ? TRUE : FALSE)

#endif // INET_DEBUG

//
// private prototypes
//
PRIVATE
BOOL
FValidCacheHandleType(
    HINTERNET_HANDLE_TYPE   hType
    );

PRIVATE
VOID
InitIPCOList(LPINTERNET_PER_CONN_OPTION_LISTW plistW, LPINTERNET_PER_CONN_OPTION_LISTA plistA)
{
    plistA->dwSize = sizeof(INTERNET_PER_CONN_OPTION_LISTA);
    plistA->dwOptionCount = plistW->dwOptionCount;
    if (plistW->pszConnection && *plistW->pszConnection)
    {
        SHUnicodeToAnsi(plistW->pszConnection, plistA->pszConnection, RAS_MaxEntryName + 1);
    }
    else
    {
        plistA->pszConnection = NULL;
    }
}

//
// functions
//


INTERNETAPI
BOOL
WINAPI
InternetQueryOptionA(
    IN HINTERNET hInternet OPTIONAL,
    IN DWORD dwOption,
    OUT LPVOID lpBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    Returns information about various handle-specific variables

Arguments:

    hInternet           - handle of object for which information will be
                          returned

    dwOption            - the handle-specific WINHTTP_OPTION to query

    lpBuffer            - pointer to a buffer which will receive results

    lpdwBufferLength    - IN: number of bytes available in lpBuffer
                          OUT: number of bytes returned in lpBuffer

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError() for more info:
                    ERROR_INVALID_HANDLE
                        hInternet does not identify a valid Internet handle
                        object

                    ERROR_WINHTTP_INTERNAL_ERROR
                        Shouldn't see this?

                    ERROR_INVALID_PARAMETER
                        One of the parameters was bad

                    ERROR_INSUFFICIENT_BUFFER
                        lpBuffer is not large enough to hold the requested
                        information; *lpdwBufferLength contains the number of
                        bytes needed

                    ERROR_WINHTTP_INCORRECT_HANDLE_TYPE
                        The handle is the wrong type for the requested option

                    ERROR_WINHTTP_INVALID_OPTION
                        The option is unrecognized

--*/

{
    DEBUG_ENTER((DBG_API,
                     Bool,
                     "InternetQueryOptionA",
                     "%#x, %s (%d), %#x, %#x [%d]",
                     hInternet,
                     InternetMapOption(dwOption),
                     dwOption,
                     lpBuffer,
                     lpdwBufferLength,
                     lpdwBufferLength
                        ? (!IsBadReadPtr(lpdwBufferLength, sizeof(DWORD))
                            ? *lpdwBufferLength
                            : 0)
                        : 0
                     ));

    DWORD error;
    BOOL success;
    HINTERNET_HANDLE_TYPE handleType = (HINTERNET_HANDLE_TYPE)0;
    LPINTERNET_THREAD_INFO lpThreadInfo;
    DWORD requiredSize = 0;
    LPVOID lpSource = NULL;
    DWORD dwValue;
    DWORD_PTR dwPtrValue;
    HINTERNET hObjectMapped = NULL;
    BOOL isString = FALSE;
    // INTERNET_DIAGNOSTIC_SOCKET_INFO socketInfo;

    if (!GlobalDataInitialized) {
        error = GlobalDataInitialize();
        if (error != ERROR_SUCCESS) {
            goto done;
        }
    }

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL) {
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto done;
    }

    //
    // validate parameters
    //

    INET_ASSERT(lpdwBufferLength);

    if (!ARGUMENT_PRESENT(lpBuffer)) {
        *lpdwBufferLength = 0;
    }

    //
    // validate the handle and get its type
    //

    HINTERNET hOriginal;

    hOriginal = hInternet;
    if (ARGUMENT_PRESENT(hInternet)) {

        //
        // map the handle
        //

        error = MapHandleToAddress(hInternet, (LPVOID *)&hObjectMapped, FALSE);
        if (error == ERROR_SUCCESS) {
            hInternet = hObjectMapped;
            error = RGetHandleType(hInternet, &handleType);
        }
    } else if (IS_PER_THREAD_OPTION(dwOption)) {

        //
        // this option updates the per-thread information block, so this is a
        // good point at which to get it
        //

        if (lpThreadInfo != NULL) {
            error = ERROR_SUCCESS;
        } else {

            DEBUG_PRINT(INET,
                        ERROR,
                        ("InternetGetThreadInfo() returns NULL\n"
                        ));

            //
            // we never expect this - ERROR_WINHTTP_SPANISH_INQUISITION
            //

            INET_ASSERT(FALSE);

            error = ERROR_WINHTTP_INTERNAL_ERROR;
        }
    } else if (IS_PER_PROCESS_OPTION(dwOption)) {
        error = ERROR_SUCCESS;
    } else {

        //
        // catch any invalid options for the NULL handle. If the option is valid
        // then it is incorrect for this handle type, otherwise its an invalid
        // option, period
        //

        error = IS_VALID_OPTION(dwOption)
                    ? ERROR_WINHTTP_INCORRECT_HANDLE_TYPE
                    : ERROR_WINHTTP_INVALID_OPTION
                    ;
    }

    //
    // if the option and handle combination is valid then query the option value
    //

    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    HTTP_REQUEST_HANDLE_OBJECT* pReq;
    switch(handleType)
    {
        case TypeHttpRequestHandle:
            pReq = (HTTP_REQUEST_HANDLE_OBJECT*) hInternet;
            break;
        default:
            pReq = NULL;
            break;
    }
        
    // New fast path for request handle options.

    if (dwOption > WINHTTP_OPTION_MASK)
    {
        dwOption &= WINHTTP_OPTION_MASK;
        if (dwOption > MAX_INTERNET_STRING_OPTION)
            error = ERROR_INVALID_PARAMETER;
        else if (!pReq)
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        else
        {
            lpSource = pReq->GetProp (dwOption);
            isString = TRUE;
            error = ERROR_SUCCESS;
            goto copy;
        }
        goto quit;
    }

    switch (dwOption) {
    case WINHTTP_OPTION_CALLBACK:
        requiredSize = sizeof(WINHTTP_STATUS_CALLBACK);
        if (hInternet != NULL) {
            error = RGetStatusCallback(hInternet,
                                       (LPWINHTTP_STATUS_CALLBACK)&dwValue
                                       );
            lpSource = (LPVOID)&dwValue;
        } else {
            error = ERROR_INVALID_HANDLE;
        }
        break;

    case WINHTTP_OPTION_RESOLVE_TIMEOUT:
    case WINHTTP_OPTION_CONNECT_TIMEOUT:
    case WINHTTP_OPTION_CONNECT_RETRIES:
    case WINHTTP_OPTION_SEND_TIMEOUT:
    case WINHTTP_OPTION_RECEIVE_TIMEOUT:
        requiredSize = sizeof(DWORD);

        //
        // remember hInternet in the INTERNET_THREAD_INFO then call
        // GetTimeoutValue(). If hInternet refers to a valid Internet
        // object handle, then the relevant timeout value will be
        // returned from that, else we will return the global value
        // corresponding to the requested option
        //

        InternetSetObjectHandle(hOriginal, hInternet);
        dwValue = GetTimeoutValue(dwOption);
        lpSource = (LPVOID)&dwValue;
        break;

    case WINHTTP_OPTION_REDIRECT_POLICY:

        // For WinHttp, these options are per-handle, not per-process.
        if (hInternet == NULL) 
        {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
            break;
        }

        switch (handleType) 
        {
        case TypeInternetHandle:

            //only error possible is in allocing memory for OPTIONAL_PARAMS struct
            if (! ((INTERNET_HANDLE_OBJECT*)hObjectMapped)->GetDwordOption(dwOption, &dwValue) )
            {    
                error = ERROR_NOT_ENOUGH_MEMORY;
            }
            else
            {
                requiredSize = sizeof(DWORD);
                lpSource = (LPVOID)&dwValue;
            }
            break;
            
        case TypeHttpRequestHandle:

            // no errors possible here
            dwValue = ((HTTP_REQUEST_HANDLE_OBJECT*)hObjectMapped)->GetDwordOption(dwOption);
            requiredSize = sizeof(DWORD);
            lpSource = (LPVOID)&dwValue;
            break;

        default:

            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
            break;
        }
        break;

    case WINHTTP_OPTION_HANDLE_TYPE:

        requiredSize = sizeof(dwValue);
        switch (handleType)
        {
        case TypeInternetHandle:
            dwValue = WINHTTP_HANDLE_TYPE_SESSION;
            break;

        case TypeHttpConnectHandle:
            dwValue = WINHTTP_HANDLE_TYPE_CONNECT;
            break;

        case TypeHttpRequestHandle:
            dwValue = WINHTTP_HANDLE_TYPE_REQUEST;
            break;

        default:
            error = ERROR_WINHTTP_INTERNAL_ERROR;
            break;
        }
        lpSource = (LPVOID)&dwValue;
        break;

    case WINHTTP_OPTION_CONTEXT_VALUE:
        requiredSize = sizeof(DWORD_PTR);
        error = RGetContext(hInternet, &dwPtrValue);
        lpSource = (LPVOID)&dwPtrValue;
        break;

    case WINHTTP_OPTION_READ_BUFFER_SIZE:
    case WINHTTP_OPTION_WRITE_BUFFER_SIZE:
    
        if (pReq)
        {
            requiredSize = sizeof(DWORD);
            error = ERROR_SUCCESS;
            dwValue = pReq->GetBufferSize(dwOption);
            lpSource = (LPVOID)&dwValue;
        }
        else
        {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        break;

    case WINHTTP_OPTION_PARENT_HANDLE:
        hInternet = ((HANDLE_OBJECT *)hInternet)->GetParent();
        if (hInternet != NULL) {
            hInternet = ((HANDLE_OBJECT *)hInternet)->GetPseudoHandle();
        }
        requiredSize = sizeof(hInternet);
        lpSource = (LPVOID)&hInternet;
        break;

    case WINHTTP_OPTION_EXTENDED_ERROR:
        requiredSize = sizeof(lpThreadInfo->dwMappedErrorCode);
        lpSource = (LPVOID)&lpThreadInfo->dwMappedErrorCode;
        break;
    
    case WINHTTP_OPTION_SECURITY_FLAGS:

        if (handleType != TypeHttpRequestHandle)
        {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        else
        {
            HTTP_REQUEST_HANDLE_OBJECT *lphHttpRqst;

            requiredSize = sizeof(dwValue);
            dwValue = 0;
            lpSource = (LPVOID)&dwValue;

            lphHttpRqst = (HTTP_REQUEST_HANDLE_OBJECT *) hInternet;

            dwValue = lphHttpRqst->GetSecureFlags();

            DEBUG_PRINT(INET,
                        INFO,
                        ("SECURITY_FLAGS: %X\n",
                        dwValue
                        ));


            error = ERROR_SUCCESS;
        }

        break;

   
    case WINHTTP_OPTION_URL:

        //
        // return the URL associated with the request handle. This may be
        // different from the original URL due to redirections
        //

        if (pReq)
        {

            //
            // only these handle types (retrieved object handles) can have
            // associated URLs
            //

            lpSource = pReq->GetURL();
            isString = TRUE;

            INET_ASSERT(error == ERROR_SUCCESS);

        }
        else
        {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        break;


    case WINHTTP_OPTION_SECURITY_CONNECTION_INFO:
        //
        // Caller is expected to pass in an INTERNET_SECURITY_CONNECTION_INFO structure.

        if (handleType != TypeHttpRequestHandle) {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        } else if (*lpdwBufferLength < (DWORD)sizeof(INTERNET_SECURITY_CONNECTION_INFO)) {
            requiredSize = sizeof(INTERNET_SECURITY_CONNECTION_INFO);
            *lpdwBufferLength = requiredSize;
            error = ERROR_INSUFFICIENT_BUFFER;
        } else {
            HTTP_REQUEST_HANDLE_OBJECT *lphHttpRqst;
            LPINTERNET_SECURITY_CONNECTION_INFO lpSecConnInfo;
            INTERNET_SECURITY_INFO ciInfo;

            lphHttpRqst = (HTTP_REQUEST_HANDLE_OBJECT *)hInternet;
            lpSecConnInfo = (LPINTERNET_SECURITY_CONNECTION_INFO)lpBuffer;
            requiredSize = sizeof(INTERNET_SECURITY_CONNECTION_INFO);

            if ((error = lphHttpRqst->GetSecurityInfo(&ciInfo)) == ERROR_SUCCESS) {
                // Set up that data members in the structure passed in.
                lpSecConnInfo->fSecure = TRUE;

                lpSecConnInfo->dwProtocol = ciInfo.dwProtocol;
                lpSecConnInfo->aiCipher = ciInfo.aiCipher;
                lpSecConnInfo->dwCipherStrength = ciInfo.dwCipherStrength;
                lpSecConnInfo->aiHash = ciInfo.aiHash;
                lpSecConnInfo->dwHashStrength = ciInfo.dwHashStrength;
                lpSecConnInfo->aiExch = ciInfo.aiExch;
                lpSecConnInfo->dwExchStrength = ciInfo.dwExchStrength;

                if (ciInfo.pCertificate)
                {
                    WRAP_REVERT_USER_VOID((*g_pfnCertFreeCertificateContext),
                                          GetRootHandle(lphHttpRqst)->GetSslSessionCache()->IsImpersonationEnabled(),
                                          (ciInfo.pCertificate));
                }

            } else if (error == ERROR_WINHTTP_INTERNAL_ERROR)  {
                // This implies we are not secure.
                error = ERROR_SUCCESS;
                lpSecConnInfo->fSecure = FALSE;
            }

            lpSecConnInfo->dwSize = requiredSize;
            *lpdwBufferLength = requiredSize;
        }

        goto quit;


    case WINHTTP_OPTION_SECURITY_CERTIFICATE_STRUCT:

        //
        // Allocates memory that caller is expected to free.
        //

        if (handleType != TypeHttpRequestHandle) {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        } else if (*lpdwBufferLength < (DWORD)sizeof(INTERNET_CERTIFICATE_INFO)) {
            requiredSize = sizeof(INTERNET_CERTIFICATE_INFO);
            *lpdwBufferLength = requiredSize;
            error = ERROR_INSUFFICIENT_BUFFER;
        } else {
            HTTP_REQUEST_HANDLE_OBJECT *lphHttpRqst;
            INTERNET_SECURITY_INFO cInfo;
            lphHttpRqst = (HTTP_REQUEST_HANDLE_OBJECT *) hInternet;
            requiredSize = sizeof(INTERNET_CERTIFICATE_INFO);

            if (ERROR_SUCCESS == lphHttpRqst->GetSecurityInfo(&cInfo))
            {
                error = ConvertSecurityInfoIntoCertInfoStruct(&cInfo, (LPINTERNET_CERTIFICATE_INFO)lpBuffer, lpdwBufferLength);
                if(cInfo.pCertificate)
                {
                    WRAP_REVERT_USER_VOID((*g_pfnCertFreeCertificateContext),
                                          GetRootHandle(lphHttpRqst)->GetSslSessionCache()->IsImpersonationEnabled(),
                                          (cInfo.pCertificate));
                }
                goto quit;
            }
            else
            {
                error = ERROR_INVALID_OPERATION;
            }
        }
        break;

    case WINHTTP_OPTION_SERVER_CERT_CONTEXT:
        if (handleType != TypeHttpRequestHandle)
        {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        else if (*lpdwBufferLength < (DWORD)sizeof(PCCERT_CONTEXT))
        {
            requiredSize = sizeof(PCCERT_CONTEXT);
            *lpdwBufferLength = requiredSize;
            error = ERROR_INSUFFICIENT_BUFFER;
        }
        else
        {
            HTTP_REQUEST_HANDLE_OBJECT *lphHttpRqst;
            INTERNET_SECURITY_INFO cInfo;
            lphHttpRqst = (HTTP_REQUEST_HANDLE_OBJECT *) hInternet;
            requiredSize = sizeof(PCERT_CONTEXT);

            if (lpBuffer)
            {
                if (ERROR_SUCCESS == lphHttpRqst->GetSecurityInfo(&cInfo))
                {
                    // GetSecurityInfo calls CertDuplicateCertificateContext, so
                    // the client app should call CertFreeCertificateContext when
                    // finished in order to maintain the proper ref count.
                    *((PCCERT_CONTEXT *) lpBuffer) = cInfo.pCertificate;  
                }
                else
                {
                    error = ERROR_INVALID_OPERATION;
                }
            }
        }
        goto quit;
        
    case WINHTTP_OPTION_SECURITY_KEY_BITNESS:

        if (handleType != TypeHttpRequestHandle)
        {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        else
        {
            HTTP_REQUEST_HANDLE_OBJECT *lphHttpRqst;
            INTERNET_SECURITY_INFO secInfo;

            requiredSize = sizeof(dwValue);
            dwValue = 0;
            lpSource = (LPVOID)&dwValue;

            lphHttpRqst = (HTTP_REQUEST_HANDLE_OBJECT *) hInternet;
            if (ERROR_SUCCESS != lphHttpRqst->GetSecurityInfo(&secInfo)) {
                error = ERROR_INVALID_OPERATION;
            } else {
                dwValue = secInfo.dwCipherStrength;
                WRAP_REVERT_USER_VOID((*g_pfnCertFreeCertificateContext),
                                      GetRootHandle(lphHttpRqst)->GetSslSessionCache()->IsImpersonationEnabled(),
                                      (secInfo.pCertificate));

                INET_ASSERT (error == ERROR_SUCCESS);

                DEBUG_PRINT(INET,
                            INFO,
                            ("SECURITY_KEY_BITNESS: %X\n",
                            dwValue
                            ));

            }
        }

        break;


    case WINHTTP_OPTION_PROXY:
        if (!ARGUMENT_PRESENT(hInternet)) {

            error = g_pGlobalProxyInfo->GetProxyStringInfo(lpBuffer, lpdwBufferLength);
            requiredSize = *lpdwBufferLength;
            goto quit;

        } else if ((handleType == TypeInternetHandle) || (handleType == TypeHttpRequestHandle)) {

            //
            // GetProxyInfo() will return the data, or calculate the buffer
            // length required
            //

            error = ((INTERNET_HANDLE_BASE *)hInternet)->GetProxyStringInfo(
                lpBuffer,
                lpdwBufferLength
                );
            requiredSize = *lpdwBufferLength;
            goto quit;
        } else {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        break;

    case WINHTTP_OPTION_VERSION:
        requiredSize = sizeof(InternetVersionInfo);
        lpSource = (LPVOID)&InternetVersionInfo;
        break;

    case WINHTTP_OPTION_USER_AGENT:
        if (handleType == TypeInternetHandle) {
            lpSource = ((INTERNET_HANDLE_OBJECT *)hInternet)->GetUserAgent();
            isString = TRUE;
        } else {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        break;

    case WINHTTP_OPTION_PASSPORT_COBRANDING_TEXT:
        if (handleType == TypeHttpRequestHandle) {
            AUTHCTX* pAuthCtx = ((HTTP_REQUEST_HANDLE_OBJECT *)hInternet)->GetAuthCtx();
            if (pAuthCtx && (pAuthCtx->GetSchemeType() == WINHTTP_AUTH_SCHEME_PASSPORT))
            {
                lpSource = ((PASSPORT_CTX*)pAuthCtx)->m_pszCbTxt;
                isString = TRUE;
            }
            else
            {
                lpSource = NULL;
            }

            if (lpSource == NULL)
            {
                error = ERROR_WINHTTP_HEADER_NOT_FOUND;
            }
        } else {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        break;

    case WINHTTP_OPTION_PASSPORT_COBRANDING_URL:
        if (handleType == TypeHttpRequestHandle) {
            AUTHCTX* pAuthCtx = ((HTTP_REQUEST_HANDLE_OBJECT *)hInternet)->GetAuthCtx();
            if (pAuthCtx && (pAuthCtx->GetSchemeType() == WINHTTP_AUTH_SCHEME_PASSPORT))
            {
                lpSource = ((PASSPORT_CTX*)pAuthCtx)->m_pszCbUrl;
                isString = TRUE;
            }
            else
            {
                lpSource = NULL;
            }

            if (lpSource == NULL)
            {
                error = ERROR_WINHTTP_HEADER_NOT_FOUND;
            }
        } else {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        break;

    case WINHTTP_OPTION_PASSPORT_RETURN_URL:
        if (handleType == TypeHttpRequestHandle) {
            if (((HTTP_REQUEST_HANDLE_OBJECT *)hInternet)->m_lpszRetUrl)
            {
                lpSource = ((HTTP_REQUEST_HANDLE_OBJECT *)hInternet)->m_lpszRetUrl;
                UrlUnescapeA((LPSTR)lpSource, NULL, NULL, URL_UNESCAPE_INPLACE);
                isString = TRUE;
            }
            else
            {
                lpSource = NULL;
            }

            if (lpSource == NULL)
            {
                error = ERROR_WINHTTP_HEADER_NOT_FOUND;
            }
        } else {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        break;

    case WINHTTP_OPTION_REQUEST_PRIORITY:
        if (handleType == TypeHttpRequestHandle) {
            requiredSize = sizeof(dwValue);
            dwValue = ((HTTP_REQUEST_HANDLE_OBJECT *)hInternet)->GetPriority();
            lpSource = (LPVOID)&dwValue;
        } else {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        break;

    case WINHTTP_OPTION_HTTP_VERSION:
        requiredSize = sizeof(HttpVersionInfo);
        lpSource = (LPVOID)&HttpVersionInfo;
        break;

    //case WINHTTP_OPTION_DIAGNOSTIC_SOCKET_INFO:

    //    //
    //    // internal option
    //    //

    //    if (pReq) {
    //        requiredSize = sizeof(socketInfo);
    //        lpSource = (LPVOID)&socketInfo;

    //        socketInfo.Socket = pReq->GetSocket();
    //        socketInfo.SourcePort = pReq->GetSourcePort();
    //        socketInfo.DestPort = pReq->GetDestPort();
    //        socketInfo.Flags = (pReq->IsSocketFromGlobalKeepAlivePool()
    //                                ? IDSI_FLAG_KEEP_ALIVE : 0)
    //                            | (pReq->IsSecure()
    //                                ? IDSI_FLAG_SECURE : 0)
    //                            | (pReq->IsRequestUsingProxy()
    //                                ? IDSI_FLAG_PROXY : 0)
    //                            | (pReq->IsTunnel()
    //                                ? IDSI_FLAG_TUNNEL : 0)
    //                            | (pReq->IsSocketAuthenticated()
    //                                ? IDSI_FLAG_AUTHENTICATED : 0);
    //    } else {
    //        error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
    //    }
    //    break;

    case WINHTTP_OPTION_MAX_CONNS_PER_SERVER:
    case WINHTTP_OPTION_MAX_CONNS_PER_1_0_SERVER:
        if (hInternet)
        {
            if (handleType == TypeInternetHandle)
            {
                requiredSize = sizeof(dwValue);
                dwValue = 0;
                lpSource = (LPVOID)&dwValue;
                dwValue = ((INTERNET_HANDLE_OBJECT *)hInternet)->GetMaxConnectionsPerServer(dwOption);
            }
            else
                error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        else
            error = ERROR_INVALID_OPERATION;
        break;

    case WINHTTP_OPTION_WORKER_THREAD_COUNT:
        
        requiredSize = sizeof(DWORD);
        dwValue = g_cNumIOCPThreads;
        lpSource = (LPVOID)&dwValue;
        break;
        
#if INET_DEBUG

    case WINHTTP_OPTION_GET_DEBUG_INFO:
        error = InternetGetDebugInfo((LPINTERNET_DEBUG_INFO)lpBuffer,
                                     lpdwBufferLength
                                     );

        //
        // everything updated, so quit without going through common buffer
        // processing
        //

        goto quit;
        break;

    case WINHTTP_OPTION_GET_HANDLE_COUNT:
        requiredSize = sizeof(DWORD);
        dwValue = InternetHandleCount();
        lpSource = (LPVOID)&dwValue;
        break;

#endif // INET_DEBUG

    default:
        requiredSize = 0;
        error = ERROR_INVALID_PARAMETER;
        break;
    }

    //
    // if we have a buffer and enough space, then copy the data
    //

copy:
    if (error == ERROR_SUCCESS) {

        //
        // if we are returning a string, calculate the amount of space
        // required to hold it
        //

        if (isString) {
            if (lpSource != NULL) {
                requiredSize = lstrlen((LPCSTR)lpSource) + 1;
            } else {

                //
                // option string is NULL: return an empty string
                //

                lpSource = "";
                requiredSize = 1;
            }
        }

        INET_ASSERT(lpSource != NULL);

        if ((*lpdwBufferLength >= requiredSize)
        && ARGUMENT_PRESENT(lpBuffer)) {
            memcpy(lpBuffer, lpSource, requiredSize);
            if (isString) {

                //
                // string copied successfully. Returned length is string
                // length, not buffer length, i.e. drop 1 for '\0'
                //

                --requiredSize;
            }
        } else {
            error = ERROR_INSUFFICIENT_BUFFER;
        }
    }

quit:

    //
    // return the amount the app needs to supply, or the amount of data in the
    // buffer, depending on success/failure status
    //

    *lpdwBufferLength = requiredSize;

    if (hObjectMapped != NULL) {
        DereferenceObject((LPVOID)hObjectMapped);
    }

done:

    if (error == ERROR_SUCCESS) {
        success = TRUE;

        IF_DEBUG(API) {

            if (isString) {

                DEBUG_PRINT_API(API,
                                INFO,
                                ("returning %q (%d chars)\n",
                                lpBuffer,
                                requiredSize
                                ));

            } else {

                DEBUG_DUMP_API(API,
                               "option data:\n",
                               lpBuffer,
                               requiredSize
                               );

            }
        }
    } else {

        DEBUG_ERROR(API, error);

        IF_DEBUG(API) {

            if (error == ERROR_INSUFFICIENT_BUFFER) {

                DEBUG_PRINT_API(API,
                                INFO,
                                ("*lpdwBufferLength (%#x)= %d\n",
                                lpdwBufferLength,
                                *lpdwBufferLength
                                ));

            }
        }

        SetLastError(error);
        success = FALSE;
    }

    DEBUG_LEAVE(success);

    return success;
}


INTERNETAPI
BOOL
WINAPI
WinHttpQueryOption(
    IN HINTERNET hInternet OPTIONAL,
    IN DWORD dwOption,
    OUT LPVOID lpBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    hInternet           -

    dwOption            -

    lpBuffer            -

    lpdwBufferLength    -

Return Value:

    BOOL

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "WinHttpQueryOption",
                     "%#x, %s (%d), %#x, %#x [%d]",
                     hInternet,
                     InternetMapOption(dwOption),
                     dwOption,
                     lpBuffer,
                     lpdwBufferLength,
                     lpdwBufferLength
                        ? (!IsBadReadPtr(lpdwBufferLength, sizeof(DWORD))
                            ? *lpdwBufferLength
                            : 0)
                        : 0
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;
    MEMORYPACKET mpBuffer;

    if (!lpdwBufferLength
        || IsBadWritePtr(lpdwBufferLength, sizeof(*lpdwBufferLength))
        || (lpBuffer && *lpdwBufferLength && IsBadWritePtr(lpBuffer, *lpdwBufferLength)) )
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    
    switch (dwOption)
    {
    case WINHTTP_OPTION_USERNAME:
    case WINHTTP_OPTION_PASSWORD:
    case WINHTTP_OPTION_URL:
    case WINHTTP_OPTION_USER_AGENT:
    case WINHTTP_OPTION_PROXY_USERNAME:
    case WINHTTP_OPTION_PROXY_PASSWORD:
    case WINHTTP_OPTION_PASSPORT_COBRANDING_TEXT:
    case WINHTTP_OPTION_PASSPORT_COBRANDING_URL:
    case WINHTTP_OPTION_PASSPORT_RETURN_URL:
        if (lpBuffer)
        {
            mpBuffer.dwAlloc = mpBuffer.dwSize = *lpdwBufferLength;
            mpBuffer.psStr = (LPSTR)ALLOC_BYTES(mpBuffer.dwAlloc*sizeof(CHAR));
            if (!mpBuffer.psStr)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }
        }
        fResult = InternetQueryOptionA(hInternet,
                                  dwOption,
                                  (LPVOID)mpBuffer.psStr,
                                  &mpBuffer.dwSize
                                 );
        if (fResult)
        {
            *lpdwBufferLength = sizeof(WCHAR) *
                MultiByteToWideChar(CP_ACP, 0, mpBuffer.psStr, mpBuffer.dwSize + 1, NULL, 0);
                
            if (*lpdwBufferLength <= mpBuffer.dwAlloc && lpBuffer)
            {
                MultiByteToWideChar(CP_ACP, 0, mpBuffer.psStr, mpBuffer.dwSize+1,
                        (LPWSTR)lpBuffer, *lpdwBufferLength);
                (*lpdwBufferLength)-=sizeof(WCHAR);
            }
            else
            {
                fResult = FALSE;
                dwErr = ERROR_INSUFFICIENT_BUFFER;
            }
        }
        else
        {
            if (GetLastError()==ERROR_INSUFFICIENT_BUFFER)
            {
                *lpdwBufferLength = mpBuffer.dwSize*sizeof(WCHAR);
            }
        }

        switch(dwOption)
        {
        case WINHTTP_OPTION_USERNAME:
        case WINHTTP_OPTION_PASSWORD:
        case WINHTTP_OPTION_PROXY_USERNAME:
        case WINHTTP_OPTION_PROXY_PASSWORD:
            ZERO_MEMORY_ALLOC(mpBuffer);
        }
        break;

    case WINHTTP_OPTION_PROXY:
        {
            WINHTTP_PROXY_INFOW * pInfo = (WINHTTP_PROXY_INFOW *) lpBuffer;
            
            union
            {
                WINHTTP_PROXY_INFOA InfoA;
                char                Buffer[1024];
            };

            char *  pBuffer = NULL;
            DWORD   dwBufferLen = sizeof(Buffer);
            bool    fFreeBuffer = false;

            if (IsBadWritePtr(pInfo, sizeof(WINHTTP_PROXY_INFOW)) ||
                (*lpdwBufferLength < sizeof(WINHTTP_PROXY_INFOW)))
            {
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }

            fResult = InternetQueryOptionA(hInternet, WINHTTP_OPTION_PROXY,
                            (void *) &Buffer,
                            &dwBufferLen);
            
            if (!fResult && (GetLastError() == ERROR_INSUFFICIENT_BUFFER))
            {
                pBuffer = New char[dwBufferLen];

                if (pBuffer)
                {
                    fFreeBuffer = true;

                    fResult = InternetQueryOptionA(hInternet, WINHTTP_OPTION_PROXY,
                                    (void *) pBuffer,
                                    &dwBufferLen);
                }
                else
                    dwErr = ERROR_NOT_ENOUGH_MEMORY;
            }

            if (fResult)
            {
                pInfo->dwAccessType = InfoA.dwAccessType;
            
                dwErr = AsciiToWideChar_UsingGlobalAlloc(InfoA.lpszProxy,
                                &(pInfo->lpszProxy));

                if (dwErr == ERROR_SUCCESS)
                {
                    dwErr = AsciiToWideChar_UsingGlobalAlloc(InfoA.lpszProxyBypass,
                                    &(pInfo->lpszProxyBypass));

                    if ((dwErr != ERROR_SUCCESS) && (pInfo->lpszProxy != NULL))
                    {
                        GlobalFree(pInfo->lpszProxy);
                        pInfo->lpszProxy = NULL;
                    }
                }

                fResult = (dwErr == ERROR_SUCCESS);
            }

            if (fFreeBuffer)
            {
                delete [] pBuffer;
            }
        }
        break;

    case WINHTTP_OPTION_ENABLETRACING:
        {
            if(hInternet)
            {
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }

            BOOL *pInfo = (BOOL *)lpBuffer;
            if (IsBadWritePtr(pInfo, sizeof(BOOL)) ||
                (*lpdwBufferLength < sizeof(BOOL)))
            {
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }

            *pInfo = CTracer::IsTracingEnabled();
            fResult = TRUE;
        }
        break;

    default:
        fResult = InternetQueryOptionA(hInternet,
                                  dwOption,
                                  lpBuffer,
                                  lpdwBufferLength
                                 );
    }

cleanup:
    if (dwErr!=ERROR_SUCCESS)
    {
        SetLastError(dwErr);
        DEBUG_ERROR(INET, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}


INTERNETAPI
BOOL
WINAPI
InternetSetOptionA(
    IN HINTERNET hInternet OPTIONAL,
    IN DWORD dwOption,
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength
    )

/*++

Routine Description:

    Sets a handle-specific variable, or a per-thread variable

Arguments:

    hInternet           - handle of object for which information will be set,
                          or NULL if the option defines a per-thread variable

    dwOption            - the handle-specific WINHTTP_OPTION to set

    lpBuffer            - pointer to a buffer containing value to set

    dwBufferLength      - size of lpBuffer

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError() for more info:
                    ERROR_INVALID_HANDLE
                        hInternet does not identify a valid Internet handle
                        object

                    ERROR_WINHTTP_INTERNAL_ERROR
                        Shouldn't see this?

                    ERROR_INVALID_PARAMETER
                        One of the parameters was bad

                    ERROR_WINHTTP_INVALID_OPTION
                        The requested option cannot be set

                    ERROR_WINHTTP_OPTION_NOT_SETTABLE
                        Can't set this option, only query it

                    ERROR_INSUFFICIENT_BUFFER
                        The dwBufferLength parameter is incorrect for the
                        expected type of the option

--*/

{
    DEBUG_ENTER((DBG_API,
                     Bool,
                     "InternetSetOptionA",
                     "%#x, %s (%d), %#x [%#x], %d",
                     hInternet,
                     InternetMapOption(dwOption),
                     dwOption,
                     lpBuffer,
                     lpBuffer
                        ? (!IsBadReadPtr(lpBuffer, sizeof(DWORD))
                            ? *(LPDWORD)lpBuffer
                            : 0)
                        : 0,
                     dwBufferLength
                     ));

    DWORD error;
    BOOL success = TRUE;
    HINTERNET_HANDLE_TYPE handleType = (HINTERNET_HANDLE_TYPE)0;
    LPINTERNET_THREAD_INFO lpThreadInfo;
    DWORD requiredSize;
    HINTERNET hObjectMapped = NULL;

    INET_ASSERT(dwBufferLength != 0);

    if (!GlobalDataInitialized) {
        error = GlobalDataInitialize();
        if (error != ERROR_SUCCESS) {
            goto done;
        }
    }

    //
    // validate the handle and get its type
    //

    if (ARGUMENT_PRESENT(hInternet)) {

        //
        // map the handle
        //

        error = MapHandleToAddress(hInternet, (LPVOID *)&hObjectMapped, FALSE);
        if (error == ERROR_SUCCESS) {
            hInternet = hObjectMapped;
            error = RGetHandleType(hInternet, &handleType);
        }
    } else if (IS_PER_THREAD_OPTION(dwOption)) {

        //
        // this option updates the per-thread information block, so this is a
        // good point at which to get it
        //

        lpThreadInfo = InternetGetThreadInfo();
        if (lpThreadInfo != NULL) {
            error = ERROR_SUCCESS;
        } else {

            DEBUG_PRINT(INET,
                        ERROR,
                        ("InternetGetThreadInfo() returns NULL\n"
                        ));

            //
            // we never expect this - ERROR_WINHTTP_SPANISH_INQUISITION
            //

            INET_ASSERT(FALSE);

            error = ERROR_WINHTTP_INTERNAL_ERROR;
        }
    } else if (IS_PER_PROCESS_OPTION(dwOption)) {
        error = ERROR_SUCCESS;
    } else {

        //
        // catch any invalid options for the NULL handle. If the option is valid
        // then it is incorrect for this handle type, otherwise its an invalid
        // option, period
        //

        error = IS_VALID_OPTION(dwOption)
                    ? ERROR_WINHTTP_INCORRECT_HANDLE_TYPE
                    : ERROR_WINHTTP_INVALID_OPTION
                    ;
    }

    if (error != ERROR_SUCCESS) {
        goto quit;
    }
    
    HTTP_REQUEST_HANDLE_OBJECT *pReq;

    switch (handleType)
    {
        case TypeHttpRequestHandle:
            pReq = (HTTP_REQUEST_HANDLE_OBJECT*) hInternet; 
            break;
        default:
            pReq = NULL;
            break;
    }

    // New fast path for request handle options.

    if (dwOption > WINHTTP_OPTION_MASK)
    {
        dwOption &= WINHTTP_OPTION_MASK;
        if (dwOption > MAX_INTERNET_STRING_OPTION)
            error = ERROR_INVALID_PARAMETER;
        else if (!pReq)
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        else if (pReq->SetProp (dwOption, (LPSTR) lpBuffer))
            error = ERROR_SUCCESS;
        else
            error = ERROR_WINHTTP_INTERNAL_ERROR;

        goto quit;
    }

    //
    // if the option and handle combination is valid then set the option value
    //

    switch (dwOption) {
    case WINHTTP_OPTION_CALLBACK:
    case WINHTTP_OPTION_HANDLE_TYPE:
    
        // these options cannot be set by this function
        error = ERROR_WINHTTP_OPTION_NOT_SETTABLE;
        break;
        
    case WINHTTP_OPTION_RESOLVE_TIMEOUT:
    case WINHTTP_OPTION_CONNECT_TIMEOUT:
    case WINHTTP_OPTION_CONNECT_RETRIES:
    case WINHTTP_OPTION_SEND_TIMEOUT:
    case WINHTTP_OPTION_RECEIVE_TIMEOUT:
    case WINHTTP_OPTION_REDIRECT_POLICY:
        requiredSize = sizeof(DWORD);
        if (dwBufferLength != requiredSize) 
        {
            error = ERROR_INSUFFICIENT_BUFFER;
            break;
        }

        // For WinHttp, these options are per-handle, not per-process.
        if (hInternet == NULL) 
        {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
            break;
        }

        //
        //  Do per-option parameter validation where applicable
        //
        if (dwOption == WINHTTP_OPTION_REDIRECT_POLICY
            && WINHTTP_OPTION_REDIRECT_POLICY_LAST < (*(LPDWORD)lpBuffer))
        {
            error = ERROR_INVALID_PARAMETER;
            break;
        }

        // we have a non-NULL context handle: the app wants to set specific
        // protocol timeouts
        switch (handleType) 
        {
        case TypeInternetHandle:

            //only error possible is in allocing memory for OPTIONAL_PARAMS struct
            if (! ((INTERNET_HANDLE_OBJECT*)hObjectMapped)->SetDwordOption(dwOption, *(LPDWORD)lpBuffer) )
            {    
                error = ERROR_NOT_ENOUGH_MEMORY;
            }
            break;
            
        case TypeHttpRequestHandle:

            // no errors possible here
            ((HTTP_REQUEST_HANDLE_OBJECT*)hObjectMapped)->SetDwordOption(dwOption, *(LPDWORD)lpBuffer);
            break;

        default:

            // any other handle type (?) cannot have timeouts set for it
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
            break;
        }
        break;

    case WINHTTP_OPTION_CONTEXT_VALUE:

        //
        // BUGBUG - can't change context if async operation is pending
        //

        if (dwBufferLength == sizeof(LPVOID)) {
            error = RSetContext(hInternet, *((DWORD_PTR *) lpBuffer));
        } else {
            error = ERROR_INSUFFICIENT_BUFFER;
        }
        break;

    case WINHTTP_OPTION_READ_BUFFER_SIZE:
    case WINHTTP_OPTION_WRITE_BUFFER_SIZE:
        if (pReq)
        {
            if (dwBufferLength == sizeof(DWORD))
            {
                DWORD bufferSize;

                bufferSize = *(LPDWORD)lpBuffer;
                if (bufferSize > 0)
                {
                    pReq->SetBufferSize(dwOption, bufferSize);
                    error = ERROR_SUCCESS;
                }
                else  // the read/write buffer size cannot be set to 0
                {
                    error = ERROR_INVALID_PARAMETER;
                }
            }
            else
            {
                error = ERROR_INSUFFICIENT_BUFFER;
            }
        }
        else
        {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        break;

    case WINHTTP_OPTION_CLIENT_CERT_CONTEXT:

        if (handleType != TypeHttpRequestHandle)
        {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        else if (dwBufferLength < sizeof(CERT_CONTEXT))
        {
            error = ERROR_INSUFFICIENT_BUFFER;
        }
        else
        {
            HTTP_REQUEST_HANDLE_OBJECT *pRequest =
                (HTTP_REQUEST_HANDLE_OBJECT *) hInternet;
            CERT_CONTEXT_ARRAY* pArray = pRequest->GetCertContextArray();
            if (!pArray)
            {
                pArray = New CERT_CONTEXT_ARRAY(GetRootHandle(pRequest)->
                                                GetSslSessionCache()->
                                                IsImpersonationEnabled());
                pRequest->SetCertContextArray(pArray);
            }

            if (!pArray)
                error = ERROR_NOT_ENOUGH_MEMORY;
            else
            {
                pArray->Reset();
                pArray->AddCertContext((PCCERT_CONTEXT) lpBuffer);
                pArray->SelectCertContext(0);
                error = ERROR_SUCCESS;
            }
        }
        break;

    case WINHTTP_OPTION_SECURITY_FLAGS:

        if (handleType != TypeHttpRequestHandle)
        {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        else if (dwBufferLength < sizeof(DWORD))
        {
            error = ERROR_INSUFFICIENT_BUFFER;
        }
        else
        {
            HTTP_REQUEST_HANDLE_OBJECT *lphHttpRqst;

            lphHttpRqst = (HTTP_REQUEST_HANDLE_OBJECT *) hInternet;

            lphHttpRqst->SetSecureFlags(*(LPDWORD)lpBuffer);

            error = ERROR_SUCCESS;
        }

        break;

    case WINHTTP_OPTION_CONFIGURE_PASSPORT_AUTH:
        if (handleType != TypeInternetHandle)
        {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        else
        {
            DWORD dwFlags = *(LPDWORD)lpBuffer;

            if (dwFlags == WINHTTP_DISABLE_PASSPORT_AUTH)
            {
                ((INTERNET_HANDLE_OBJECT *)hInternet)->DisableTweener();
            }
            else
            {
                if (dwFlags & WINHTTP_ENABLE_PASSPORT_AUTH)
                {
                    ((INTERNET_HANDLE_OBJECT *)hInternet)->EnableTweener();
                }

                if (dwFlags & WINHTTP_DISABLE_PASSPORT_KEYRING)
                {
                    ((INTERNET_HANDLE_OBJECT *)hInternet)->DisableKeyring();
                }

                if (dwFlags & WINHTTP_ENABLE_PASSPORT_KEYRING)
                {
                    ((INTERNET_HANDLE_OBJECT *)hInternet)->EnableKeyring();
                }
            }

            error = ERROR_SUCCESS;
        }
                    
        break;

    case WINHTTP_OPTION_SECURE_PROTOCOLS:

        if (handleType != TypeInternetHandle)
        {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        else if (dwBufferLength < sizeof(DWORD))
        {
            error = ERROR_INSUFFICIENT_BUFFER;
        }
        else if (*(LPDWORD)lpBuffer & ~(WINHTTP_FLAG_SECURE_PROTOCOL_ALL))
        {
            error = ERROR_INVALID_PARAMETER;
        }
        else
        {
            ((INTERNET_HANDLE_OBJECT *)hInternet)->SetSecureProtocols(
                *(LPDWORD)lpBuffer);

            error = ERROR_SUCCESS;
        }

        break;

    case WINHTTP_OPTION_PROXY:
        if ((handleType == TypeInternetHandle) || (handleType == TypeHttpRequestHandle))
        {
            WINHTTP_PROXY_INFOA * lpInfo = (WINHTTP_PROXY_INFOA *) lpBuffer;

            //
            // validate parameters
            //

            if (dwBufferLength != sizeof(*lpInfo))
            {
                error = ERROR_INSUFFICIENT_BUFFER;
            }
            else if (!((lpInfo->dwAccessType == WINHTTP_ACCESS_TYPE_DEFAULT_PROXY)
                    || (lpInfo->dwAccessType == WINHTTP_ACCESS_TYPE_NO_PROXY)
                    || (lpInfo->dwAccessType == WINHTTP_ACCESS_TYPE_NAMED_PROXY))
            || ((lpInfo->dwAccessType == WINHTTP_ACCESS_TYPE_NAMED_PROXY)
                && ((lpInfo->lpszProxy == NULL) || (*lpInfo->lpszProxy == '\0'))))
            {
                error = ERROR_INVALID_PARAMETER;
            }
            else
            {
                error = ((INTERNET_HANDLE_BASE *)hInternet)->SetProxyInfo(
                            lpInfo->dwAccessType,
                            lpInfo->lpszProxy,
                            lpInfo->lpszProxyBypass
                            );
            }
        }
        else
        {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        break;

    case WINHTTP_OPTION_USER_AGENT:
        if (*(LPSTR)lpBuffer == '\0') {
            error = ERROR_INSUFFICIENT_BUFFER;
        } else {
            if ((handleType == TypeInternetHandle) || (handleType == TypeHttpRequestHandle))
            {
                ((INTERNET_HANDLE_BASE *)hInternet)->SetUserAgent((LPSTR)lpBuffer);
            } else {
                error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
            }
        }
        break;

    case WINHTTP_OPTION_PASSPORT_SIGN_OUT:
        if (*(LPSTR)lpBuffer == '\0') {
            error = ERROR_INSUFFICIENT_BUFFER;
        } else {
            if (handleType == TypeInternetHandle)
            {
                INTERNET_HANDLE_OBJECT* pInternet = ((INTERNET_HANDLE_OBJECT*)hInternet); 
                PP_CONTEXT hPP = pInternet->GetPPContext();
                
                pInternet->ClearPassportCookies((LPSTR)lpBuffer);

                if (hPP != NULL)
                {
                    ::PP_Logout(hPP, 0);
                }
            } else {
                error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
            }
        }
        break;
        
    case WINHTTP_OPTION_REQUEST_PRIORITY:
        if (handleType == TypeHttpRequestHandle) {
            if (dwBufferLength == sizeof(LONG)) {
                ((HTTP_REQUEST_HANDLE_OBJECT *)hInternet)->
                    SetPriority(*(LPLONG)lpBuffer);
            } else {
                error = ERROR_INSUFFICIENT_BUFFER;
            }
        } else {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        break;

    case WINHTTP_OPTION_HTTP_VERSION:
        if (dwBufferLength == sizeof(HTTP_VERSION_INFO))
        {
            HTTP_VERSION_INFO* pVersionInfo = (LPHTTP_VERSION_INFO)lpBuffer;
            if (pVersionInfo->dwMajorVersion != 1
                || (pVersionInfo->dwMinorVersion != 0
                    && pVersionInfo->dwMajorVersion != 1))
            {
                error = ERROR_INVALID_PARAMETER;
            }
            else
            {
                HttpVersionInfo = *(LPHTTP_VERSION_INFO)lpBuffer;
            }
        } else {
            error = ERROR_INSUFFICIENT_BUFFER;
        }
        break;

    case WINHTTP_OPTION_DISABLE_FEATURE:

        if (handleType == TypeHttpRequestHandle)
        {
            HTTP_REQUEST_HANDLE_OBJECT *pRequest =
                (HTTP_REQUEST_HANDLE_OBJECT *) hInternet;
            
            DWORD dwDisable = *((LPDWORD) lpBuffer);
            
            if (dwDisable & WINHTTP_DISABLE_KEEP_ALIVE)
            {
                DWORD dwFlags = pRequest->GetOpenFlags();
                dwFlags &= ~INTERNET_FLAG_KEEP_CONNECTION;
                pRequest->SetOpenFlags (dwFlags);                
            }
            if (dwDisable & WINHTTP_DISABLE_REDIRECTS)
            {
                pRequest->SetDwordOption( WINHTTP_OPTION_REDIRECT_POLICY, WINHTTP_OPTION_REDIRECT_POLICY_NEVER);
            }
            if (dwDisable & WINHTTP_DISABLE_COOKIES)
            {
                DWORD dwFlags = pRequest->GetOpenFlags();
                dwFlags |= INTERNET_FLAG_NO_COOKIES;
                pRequest->SetOpenFlags (dwFlags);                
            }
            if (dwDisable & WINHTTP_DISABLE_AUTHENTICATION)
            {
                DWORD dwFlags = pRequest->GetOpenFlags();
                dwFlags |= INTERNET_FLAG_NO_AUTH;
                pRequest->SetOpenFlags (dwFlags);                
            }

            error = ERROR_SUCCESS;
        }
        else if (dwBufferLength < sizeof(DWORD))
        {
            error = ERROR_INVALID_PARAMETER;
        }
        else
        {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        break;
            
  
    case WINHTTP_OPTION_ENABLE_FEATURE:

        if (dwBufferLength < sizeof(DWORD))
        {
            error = ERROR_INVALID_PARAMETER;
        }
        else if (handleType == TypeHttpRequestHandle)
        {
            HTTP_REQUEST_HANDLE_OBJECT *pRequest =
                (HTTP_REQUEST_HANDLE_OBJECT *) hInternet;
            DWORD dwEnable = *((LPDWORD) lpBuffer);

            // This one feature is only allowed to be set on the
            // session handle
            if (dwEnable & WINHTTP_ENABLE_SSL_REVERT_IMPERSONATION)
            {
                error = ERROR_INVALID_PARAMETER;
            }
            else
            {
                pRequest->SetEnableFlags(*((LPDWORD) lpBuffer));
                error = ERROR_SUCCESS;
            }
        }
        else if (handleType == TypeInternetHandle)
        {
            INTERNET_HANDLE_OBJECT *pInternet =
                (INTERNET_HANDLE_OBJECT *) hInternet;
            DWORD dwEnable = *((LPDWORD) lpBuffer);

            // Consider the call invalid if anything else is being
            // set on the session handle.
            if (dwEnable & ~WINHTTP_ENABLE_SSL_REVERT_IMPERSONATION)
            {
                error = ERROR_INVALID_PARAMETER;
            }
            else
            {
                // Error code could indicate that a request handle
                // has already been created, resulting in this call failing.
                error = pInternet->SetSslImpersonationLevel(
                    (*((LPDWORD) lpBuffer) & WINHTTP_ENABLE_SSL_REVERT_IMPERSONATION) ? FALSE : TRUE);
            }
        }
        else
        {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        break;
            
  
    case WINHTTP_OPTION_CODEPAGE:
        if ((hInternet == NULL) || (handleType == TypeHttpRequestHandle))
        {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        else
        {
            if (dwBufferLength == sizeof(DWORD)) 
            {
                ((INTERNET_HANDLE_BASE *)hInternet)->SetCodePage(*(LPDWORD)lpBuffer);
            } 
            else 
            {
                error = ERROR_INSUFFICIENT_BUFFER;
            }
        } 
        break;

    case WINHTTP_OPTION_MAX_CONNS_PER_SERVER:
    case WINHTTP_OPTION_MAX_CONNS_PER_1_0_SERVER:
        if (handleType == TypeInternetHandle)
        {
            if (dwBufferLength == sizeof(DWORD))
            {
                ((INTERNET_HANDLE_OBJECT *)hInternet)->SetMaxConnectionsPerServer(dwOption, *(DWORD *)lpBuffer);
            }
            else
                error = ERROR_INSUFFICIENT_BUFFER;
        }
        else
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        break;

    case WINHTTP_OPTION_AUTOLOGON_POLICY:

        if (handleType != TypeHttpRequestHandle)
        {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        else if (dwBufferLength < sizeof(DWORD))
        {
            error = ERROR_INSUFFICIENT_BUFFER;
        }
        else
        {
            HTTP_REQUEST_HANDLE_OBJECT *lphHttpRqst;

            lphHttpRqst = (HTTP_REQUEST_HANDLE_OBJECT *) hInternet;

            lphHttpRqst->SetSecurityLevel(*(LPDWORD)lpBuffer);

            error = ERROR_SUCCESS;
        }

        break;

    case WINHTTP_OPTION_WORKER_THREAD_COUNT:
        
        if (dwBufferLength < sizeof(DWORD))
        {
            error = ERROR_INSUFFICIENT_BUFFER;
        }
        else
        {
            if (!g_cNumIOCPThreads)
            {
                g_cNumIOCPThreads = *(LPDWORD)lpBuffer;
                error = ERROR_SUCCESS;
            }
            else
            {
                error = ERROR_WINHTTP_OPTION_NOT_SETTABLE;
            }
        }
        break;
        
#if INET_DEBUG
    case WINHTTP_OPTION_SET_DEBUG_INFO:
        error = InternetSetDebugInfo((LPINTERNET_DEBUG_INFO)lpBuffer,
                                     dwBufferLength
                                     );
        break;

#endif // INET_DEBUG

    default:

        //
        // this option is not recognized
        //

        error = ERROR_WINHTTP_INVALID_OPTION;
    }

quit:

    if (hObjectMapped != NULL) {
        DereferenceObject((LPVOID)hObjectMapped);
    }

done:

    if (error != ERROR_SUCCESS) {

        DEBUG_ERROR(API, error);

        SetLastError(error);
        success = FALSE;
    }

    DEBUG_LEAVE(success);

    return success;
}

#define CHECK_MODIFY_TIMEOUT(nTimeout) \
{ \
    if (nTimeout <= 0) \
    { \
        if (nTimeout == 0) \
        { \
            nTimeout = (int)INFINITE; \
        } \
        else if (nTimeout < -1) \
        { \
            dwError = ERROR_INVALID_PARAMETER; \
            goto quit; \
        } \
    } \
}

INTERNETAPI
BOOL
WINAPI 
WinHttpSetTimeouts(    
    IN HINTERNET    hInternet,           // Session/Request handle.
    IN int        nResolveTimeout,
    IN int        nConnectTimeout,
    IN int        nSendTimeout,
    IN int        nReceiveTimeout
    )
{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "WinHttpSetTimeouts",
                     "%#x, %d, %d, %d, %d",
                     hInternet,
                     nResolveTimeout,
                     nConnectTimeout,
                     nSendTimeout,
                     nReceiveTimeout
                     ));

    DWORD dwError = ERROR_SUCCESS;
    BOOL bRetval = FALSE;
    HINTERNET_HANDLE_TYPE handleType;
    HINTERNET hObjectMapped = NULL;

    if (!hInternet)
    {
        dwError = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        goto quit;
    }

    CHECK_MODIFY_TIMEOUT(nResolveTimeout);
    CHECK_MODIFY_TIMEOUT(nConnectTimeout);
    CHECK_MODIFY_TIMEOUT(nSendTimeout);
    CHECK_MODIFY_TIMEOUT(nReceiveTimeout);
    
    dwError = MapHandleToAddress(hInternet, (LPVOID *)&hObjectMapped, FALSE);

    if (dwError != ERROR_SUCCESS)
    {
        goto quit;
    }
    
    dwError = RGetHandleType(hObjectMapped, &handleType);

    if (dwError != ERROR_SUCCESS)
    {
        goto quit;
    }

    switch(handleType)
    {
        case TypeInternetHandle:

            //only error possible is in allocing memory for OPTIONAL_PARAMS struct
            bRetval = ((INTERNET_HANDLE_OBJECT*)hObjectMapped)->SetTimeouts(
                nResolveTimeout, nConnectTimeout, nSendTimeout, nReceiveTimeout);
            if (!bRetval)
            {    
                dwError = ERROR_NOT_ENOUGH_MEMORY;
                goto quit;
            }
            break;
            
        case TypeHttpRequestHandle:

            // no errors possible here
            bRetval = ((HTTP_REQUEST_HANDLE_OBJECT*)hObjectMapped)->SetTimeouts( 
                nResolveTimeout, nConnectTimeout, nSendTimeout, nReceiveTimeout);
            INET_ASSERT(bRetval);
            break;

        default:

            // any other handle type cannot have timeouts set for it
            dwError = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
            break;
    }
    
quit:

    if (hObjectMapped) 
    {
        DereferenceObject((LPVOID)hObjectMapped);
    }

    if (dwError != ERROR_SUCCESS) 
    { 
        ::SetLastError(dwError); 
        INET_ASSERT(!bRetval);
    }
    
    DEBUG_LEAVE_API(bRetval);
    return bRetval;
}


INTERNETAPI
BOOL
WINAPI
WinHttpSetOption(
    IN HINTERNET hInternet OPTIONAL,
    IN DWORD dwOption,
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    hInternet       -

    dwOption        -

    lpBuffer        -

    dwBufferLength  -

Return Value:

    BOOL

--*/

{
    DEBUG_ENTER2_API((DBG_API,
                     Bool,
                     "WinHttpSetOption",
                     "%#x, %s (%d), %#x [%#x], %d",
                     hInternet,
                     InternetMapOption(dwOption),
                     dwOption,
                     lpBuffer,
                     lpBuffer
                        ? (!IsBadReadPtr(lpBuffer, sizeof(DWORD))
                            ? *(LPDWORD)lpBuffer
                            : 0)
                        : 0,
                     dwBufferLength
                     ));

    TRACE_ENTER2_API((DBG_API,
                     Bool,
                     "WinHttpSetOption",
                     hInternet,
                     "%#x, %s (%d), %#x [%#x], %d",
                     hInternet,
                     InternetMapOption(dwOption),
                     dwOption,
                     lpBuffer,
                     lpBuffer
                        ? (!IsBadReadPtr(lpBuffer, sizeof(DWORD))
                            ? *(LPDWORD)lpBuffer
                            : 0)
                        : 0,
                     dwBufferLength
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    MEMORYPACKET mpBuffer;
    BOOL fResult = FALSE;

    //
    // validate parameters
    //

    if ((dwBufferLength == 0) || IsBadReadPtr(lpBuffer, dwBufferLength)) 
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    
    switch (dwOption)
    {
    case WINHTTP_OPTION_USERNAME:
    case WINHTTP_OPTION_PASSWORD:
    case WINHTTP_OPTION_URL:
    case WINHTTP_OPTION_USER_AGENT:
    case WINHTTP_OPTION_PROXY_USERNAME:
    case WINHTTP_OPTION_PROXY_PASSWORD:
    case WINHTTP_OPTION_PASSPORT_SIGN_OUT:
        ALLOC_MB((LPWSTR)lpBuffer, dwBufferLength, mpBuffer);
        if (!mpBuffer.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI((LPWSTR)lpBuffer, mpBuffer);
        fResult = InternetSetOptionA(hInternet,
                                  dwOption,
                                  mpBuffer.psStr,
                                  mpBuffer.dwSize
                                 );

        switch(dwOption)       
        {
        case WINHTTP_OPTION_USERNAME:
        case WINHTTP_OPTION_PASSWORD:
        case WINHTTP_OPTION_PROXY_USERNAME:
        case WINHTTP_OPTION_PROXY_PASSWORD:
            ZERO_MEMORY_ALLOC(mpBuffer);
        }
        break;

    case WINHTTP_OPTION_PROXY:
        {
            WINHTTP_PROXY_INFOW * pInfo = (WINHTTP_PROXY_INFOW *) lpBuffer;
            WINHTTP_PROXY_INFOA   InfoA;

            if (IsBadReadPtr(pInfo, sizeof(WINHTTP_PROXY_INFOW)) || (dwBufferLength < sizeof(WINHTTP_PROXY_INFOW)))
            {
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }

            InfoA.dwAccessType = pInfo->dwAccessType;

            dwErr = WideCharToAscii(pInfo->lpszProxy, &InfoA.lpszProxy);

            if (dwErr == ERROR_SUCCESS)
            {
                dwErr = WideCharToAscii(pInfo->lpszProxyBypass, &InfoA.lpszProxyBypass);

                if (dwErr == ERROR_SUCCESS)
                {
                    fResult = InternetSetOptionA(hInternet, WINHTTP_OPTION_PROXY, &InfoA, sizeof(InfoA));

                    if (InfoA.lpszProxyBypass)
                    {
                        delete [] InfoA.lpszProxyBypass;
                    }
                }

                if (InfoA.lpszProxy)
                {
                    delete [] InfoA.lpszProxy;
                }
            }
        }
        break;

    case WINHTTP_OPTION_ENABLETRACING:
        {
            if(hInternet)
            {
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }

            BOOL *pInfo = (BOOL *)lpBuffer;
            if (IsBadReadPtr(pInfo, sizeof(BOOL)) ||
                (dwBufferLength < sizeof(BOOL)))
            {
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }

            if( *pInfo)
            {
                fResult = CTracer::GlobalTraceInit( TRUE);
                if( fResult != FALSE)
                    CTracer::EnableTracing();
            }
            else
            {
                CTracer::DisableTracing();
                fResult = TRUE;
            }
        }
        break;

    default:
        fResult = InternetSetOptionA(hInternet,
                                  dwOption,
                                  lpBuffer,
                                  dwBufferLength
                                 );
    }

cleanup:

    if (dwErr!=ERROR_SUCCESS)
    {
        SetLastError(dwErr);
        DEBUG_ERROR(INET, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}



PRIVATE
BOOL
FValidCacheHandleType(
    HINTERNET_HANDLE_TYPE   hType
    )
{
    return ((hType != TypeInternetHandle)   &&
            (hType != TypeHttpConnectHandle));
}

#ifdef ENABLE_DEBUG

#define CASE_OF(constant)   case constant: return # constant

LPSTR
InternetMapOption(
    IN DWORD Option
    )

/*++

Routine Description:

    Convert WINHTTP_OPTION_ value to symbolic name

Arguments:

    Option  - to map

Return Value:

    LPSTR - pointer to symbolic name, or "?" if unknown

--*/

{
    switch (Option) {
    CASE_OF(WINHTTP_OPTION_CALLBACK);
    CASE_OF(WINHTTP_OPTION_RESOLVE_TIMEOUT);
    CASE_OF(WINHTTP_OPTION_CONNECT_TIMEOUT);
    CASE_OF(WINHTTP_OPTION_CONNECT_RETRIES);
    CASE_OF(WINHTTP_OPTION_SEND_TIMEOUT);
    CASE_OF(WINHTTP_OPTION_RECEIVE_TIMEOUT);
    CASE_OF(WINHTTP_OPTION_HANDLE_TYPE);
    CASE_OF(WINHTTP_OPTION_READ_BUFFER_SIZE);
    CASE_OF(WINHTTP_OPTION_WRITE_BUFFER_SIZE);
    CASE_OF(WINHTTP_OPTION_PARENT_HANDLE);
    CASE_OF(WINHTTP_OPTION_EXTENDED_ERROR);
    CASE_OF(WINHTTP_OPTION_USERNAME);
    CASE_OF(WINHTTP_OPTION_PASSWORD);
    CASE_OF(WINHTTP_OPTION_SECURITY_FLAGS);
    CASE_OF(WINHTTP_OPTION_SECURITY_CERTIFICATE_STRUCT);
    CASE_OF(WINHTTP_OPTION_URL);
    CASE_OF(WINHTTP_OPTION_SECURITY_KEY_BITNESS);
    CASE_OF(WINHTTP_OPTION_PROXY);
    CASE_OF(WINHTTP_OPTION_VERSION);
    CASE_OF(WINHTTP_OPTION_USER_AGENT);
    CASE_OF(WINHTTP_OPTION_PROXY_USERNAME);
    CASE_OF(WINHTTP_OPTION_PROXY_PASSWORD);
    CASE_OF(WINHTTP_OPTION_CONTEXT_VALUE);
    CASE_OF(WINHTTP_OPTION_CLIENT_CERT_CONTEXT);
    CASE_OF(WINHTTP_OPTION_REQUEST_PRIORITY);
    CASE_OF(WINHTTP_OPTION_HTTP_VERSION);
    CASE_OF(WINHTTP_OPTION_SECURITY_CONNECTION_INFO);
    // CASE_OF(WINHTTP_OPTION_DIAGNOSTIC_SOCKET_INFO);
    CASE_OF(WINHTTP_OPTION_SERVER_CERT_CONTEXT);
    }
    return "?";
}

#endif // ENABLE_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5.1\auth\htuu.h ===
/*
   This file was derived from the libwww code, version 2.15, from CERN.
   A number of modifications have been made by Spyglass.

   eric@spyglass.com
 */

/*                              ENCODING TO PRINTABLE CHARACTERS

   File module provides functions HTUU_encode() and HTUU_decode() which convert a buffer
   of bytes to/from RFC 1113 printable encoding format. This technique is similar to the
   familiar Unix uuencode format in that it maps 6 binary bits to one ASCII character (or
   more aptly, 3 binary bytes to 4 ASCII characters).  However, RFC 1113 does not use the
   same mapping to printable characters as uuencode.

	Ported to WinINet Plug In DLL by arthurbi Dec-23-1995

 */

#ifndef HTUU_H
#define HTUU_H

#ifdef __cplusplus
extern "C" {
#endif

int HTUU_encode(unsigned char *bufin,
				unsigned int nbytes,
				char *bufcoded,
                long outbufmax);

int HTUU_decode(char *bufcoded,
				unsigned char *bufplain,
				int outbufsize);

#ifdef __cplusplus
} // end extern "C"
#endif

#endif
/*

   End of file.  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5.1\api\thrdinfo.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    thrdinfo.cxx

Abstract:

    Functions to manipulate an INTERNET_THREAD_INFO

    Contents:
        InternetCreateThreadInfo
        InternetDestroyThreadInfo
        InternetTerminateThreadInfo
        InternetGetThreadInfo
        InternetSetThreadInfo
        InternetIndicateStatusAddress
        InternetIndicateStatusString
        InternetIndicateStatusNewHandle
        InternetIndicateStatus
        InternetSetLastError
        _InternetSetLastError
        InternetLockErrorText
        InternetUnlockErrorText
        InternetSetObjectHandle
        InternetGetObjectHandle
        InternetFreeThreadInfo

Author:

    Richard L Firth (rfirth) 16-Feb-1995

Environment:

    Win32 user-level DLL

Revision History:

    16-Feb-1995 rfirth
        Created

--*/

#include <wininetp.h>
#include <perfdiag.hxx>

//
// manifests
//

#define BAD_TLS_INDEX   0xffffffff  // according to online win32 SDK documentation
#ifdef SPX_SUPPORT
#define GENERIC_SPX_NAME   "SPX Server"
#endif //SPX_SUPPORT
//
// macros
//

#ifdef ENABLE_DEBUG

#define InitializeInternetThreadInfo(lpThreadInfo) \
    InitializeListHead(&lpThreadInfo->List); \
    lpThreadInfo->Signature = INTERNET_THREAD_INFO_SIGNATURE; \
    lpThreadInfo->ThreadId = GetCurrentThreadId();

#else

#define InitializeInternetThreadInfo(threadInfo) \
    InitializeListHead(&lpThreadInfo->List); \
    lpThreadInfo->ThreadId = GetCurrentThreadId();

#endif // ENABLE_DEBUG

//
// private data
//

PRIVATE DWORD InternetTlsIndex = BAD_TLS_INDEX;
PRIVATE SERIALIZED_LIST ThreadInfoList;



LPINTERNET_THREAD_INFO
InternetCreateThreadInfo(
    IN BOOL SetTls
    )

/*++

Routine Description:

    Creates, initializes an INTERNET_THREAD_INFO. Optionally (allocates and)
    sets this thread's Internet TLS

    Assumes: 1. The first time this function is called is in the context of the
                process attach library call, so we allocate the TLS index once

Arguments:

    SetTls  - TRUE if we are to set the INTERNET_THREAD_INFO TLS for this thread

Return Value:

    LPINTERNET_THREAD_INFO
        Success - pointer to allocated INTERNET_THREAD_INFO structure which has
                  been set as this threads value in its InternetTlsIndex slot

        Failure - NULL

--*/

{
    LPINTERNET_THREAD_INFO lpThreadInfo = NULL;
    BOOL ok = FALSE;

    if (InDllCleanup)
    {
        goto quit;
    }

    if (InternetTlsIndex == BAD_TLS_INDEX)
    {

        //
        // first time through, initialize serialized list
        //

        InitializeSerializedList(&ThreadInfoList);

        //
        // we assume that if we are allocating the TLS index, then this is the
        // one and only thread in this process that can call into this DLL
        // right now - i.e. this thread is loading the DLL
        //

        InternetTlsIndex = TlsAlloc();
    }

    if (InternetTlsIndex != BAD_TLS_INDEX)
    {
        lpThreadInfo = NEW(INTERNET_THREAD_INFO);
        if (lpThreadInfo != NULL)
        {
            InitializeInternetThreadInfo(lpThreadInfo);
            if (SetTls)
            {
                ok = TlsSetValue(InternetTlsIndex, (LPVOID)lpThreadInfo);
                if (!ok) 
                {
                    DEBUG_PUT(("InternetCreateThreadInfo(): TlsSetValue(%d, %#x) returns %d\n",
                             InternetTlsIndex,
                             lpThreadInfo,
                             GetLastError()
                             ));

                    DEBUG_BREAK(THRDINFO);
                }
            }
            else 
            {
                ok = TRUE;
            }
        }
        else 
        {
            DEBUG_PUT(("InternetCreateThreadInfo(): NEW(INTERNET_THREAD_INFO) returned NULL\n"));

            DEBUG_BREAK(THRDINFO);
        }
    }
    else 
    {
        DEBUG_PUT(("InternetCreateThreadInfo(): TlsAlloc() returns %#x, error %d\n",
                 BAD_TLS_INDEX,
                 GetLastError()
                 ));

        DEBUG_BREAK(THRDINFO);
    }

    if (ok)
    {
        if (!InsertAtHeadOfSerializedList(&ThreadInfoList, &lpThreadInfo->List))
        {
            DEL(lpThreadInfo);
            lpThreadInfo = NULL;
        }
    }
    else
    {
        if (lpThreadInfo != NULL)
        {
            DEL(lpThreadInfo);
            lpThreadInfo = NULL;
        }
    }

quit:
    return lpThreadInfo;
}


VOID
InternetDestroyThreadInfo(
    VOID
    )

/*++

Routine Description:

    Cleans up the INTERNET_THREAD_INFO - deletes any memory it owns and deletes
    it

Arguments:

    None.

Return Value:

    None.

--*/

{
    LPINTERNET_THREAD_INFO lpThreadInfo;

    IF_DEBUG(NOTHING)
    {
        DEBUG_PUT(("InternetDestroyThreadInfo(): Thread %#x: Deleting INTERNET_THREAD_INFO\n",
                    GetCurrentThreadId()
                    ));
    }

    //
    // don't call InternetGetThreadInfo() - we don't need to create the
    // INTERNET_THREAD_INFO if it doesn't exist in this case
    //

    lpThreadInfo = (LPINTERNET_THREAD_INFO)TlsGetValue(InternetTlsIndex);
    if (lpThreadInfo != NULL)
    {
#if INET_DEBUG

        //
        // there shouldn't be anything in the debug record stack. On Win95, we
        // ignore this check if this is the async scheduler (nee worker) thread
        // AND there are entries in the debug record stack. The async thread
        // gets killed off before it has chance to DEBUG_LEAVE, then comes here,
        // causing this assert to be over-active
        //

        if (IsPlatformWin95() && lpThreadInfo->IsAsyncWorkerThread)
        {
            if (lpThreadInfo->CallDepth != 0)
            {
                DEBUG_PUT(("InternetDestroyThreadInfo(): "
                            "Thread %#x: "
                            "%d records in debug stack\n",
                            lpThreadInfo->CallDepth
                            ));
            }
        }
        else
        {
            INET_ASSERT(lpThreadInfo->Stack == NULL);

        }

#endif // INET_DEBUG

        InternetFreeThreadInfo(lpThreadInfo);

        INET_ASSERT(InternetTlsIndex != BAD_TLS_INDEX);

        TlsSetValue(InternetTlsIndex, NULL);
    }
    else
    {
        DEBUG_PUT(("InternetDestroyThreadInfo(): Thread %#x: no INTERNET_THREAD_INFO\n",
                    GetCurrentThreadId()
                    ));
    }
}


VOID
InternetFreeThreadInfo(
    IN LPINTERNET_THREAD_INFO lpThreadInfo
    )

/*++

Routine Description:

    Removes the INTERNET_THREAD_INFO from the list and frees all allocated
    blocks

Arguments:

    lpThreadInfo    - pointer to INTERNET_THREAD_INFO to remove and free

Return Value:

    None.

--*/

{
    if (RemoveFromSerializedList(&ThreadInfoList, &lpThreadInfo->List))
    {
        if (lpThreadInfo->hErrorText != NULL)
        {
            FREE_MEMORY(lpThreadInfo->hErrorText);
        }

        //if (lpThreadInfo->lpResolverInfo != NULL) {
        //    if (lpThreadInfo->lpResolverInfo->DnrSocketHandle != NULL) {
        //        lpThreadInfo->lpResolverInfo->DnrSocketHandle->Dereference();
        //    }
        //    DEL(lpThreadInfo->lpResolverInfo);
        //}

        DEL(lpThreadInfo);
    }
}


VOID
InternetTerminateThreadInfo(
    VOID
    )

/*++

Routine Description:

    Destroy all INTERNET_THREAD_INFO structures and terminate the serialized
    list. This funciton called at process detach time.

    At DLL_PROCESS_DETACH time, there may be other threads in the process for
    which we created an INTERNET_THREAD_INFO that aren't going to get the chance
    to delete the structure, so we do it here.

    Code in this module assumes that it is impossible for a new thread to enter
    this DLL while we are terminating in DLL_PROCESS_DETACH

Arguments:

    None.

Return Value:

    None.

--*/

{
    //
    // get rid of this thread's info structure. No more debug output after this!
    //

    InternetDestroyThreadInfo();

    //
    // get rid of the thread info structures left by other threads
    //

    if (LockSerializedList(&ThreadInfoList))
    {
        LPINTERNET_THREAD_INFO lpThreadInfo;

        while (NULL != (lpThreadInfo = (LPINTERNET_THREAD_INFO)SlDequeueHead(&ThreadInfoList)))
        {
            //
            // already dequeued, no need to call InternetFreeThreadInfo()
            //

            FREE_MEMORY(lpThreadInfo);
        }

        UnlockSerializedList(&ThreadInfoList);
    }

    //
    // no more need for list
    //

    TerminateSerializedList(&ThreadInfoList);

    //
    // or TLS index
    //

    TlsFree(InternetTlsIndex);
    InternetTlsIndex = BAD_TLS_INDEX;
}


LPINTERNET_THREAD_INFO
InternetGetThreadInfo(
    VOID
    )

/*++

Routine Description:

    Gets the pointer to the INTERNET_THREAD_INFO for this thread and checks
    that it still looks good.

    If this thread does not have an INTERNET_THREAD_INFO then we create one,
    presuming that this is a new thread

Arguments:

    None.

Return Value:

    LPINTERNET_THREAD_INFO
        Success - pointer to INTERNET_THREAD_INFO block

        Failure - NULL

--*/

{
    LPINTERNET_THREAD_INFO lpThreadInfo = NULL;
    DWORD lastError;

    //
    // this is pretty bad - TlsGetValue() can destroy the per-thread last error
    // variable if it returns NULL (to indicate that NULL was actually set, and
    // that NULL does not indicate an error). So we have to read it before it is
    // potentially destroyed, and reset it before we quit.
    //
    // We do this here because typically, other functions will be completely
    // unsuspecting of this behaviour, and it is better to fix it once here,
    // than in several dozen other places, even though it is slightly
    // inefficient
    //

    lastError = GetLastError();

    if (InternetTlsIndex != BAD_TLS_INDEX)
    {
        lpThreadInfo = (LPINTERNET_THREAD_INFO)TlsGetValue(InternetTlsIndex);
    }

    //
    // we may be in the process of creating the INTERNET_THREAD_INFO, in
    // which case its okay for this to be NULL. According to online SDK
    // documentation, a threads TLS value will be initialized to NULL
    //

    if (lpThreadInfo == NULL)
    {
        //
        // we presume this is a new thread. Create an INTERNET_THREAD_INFO
        //

        IF_DEBUG(NOTHING) {
            DEBUG_PUT(("InternetGetThreadInfo(): Thread %#x: Creating INTERNET_THREAD_INFO\n",
                      GetCurrentThreadId()
                      ));
        }

        lpThreadInfo = InternetCreateThreadInfo(TRUE);
    }
    if (lpThreadInfo != NULL)
    {
        INET_ASSERT(lpThreadInfo->Signature == INTERNET_THREAD_INFO_SIGNATURE);
        INET_ASSERT(lpThreadInfo->ThreadId == GetCurrentThreadId());
    }
    else
    {
        DEBUG_PUT(("InternetGetThreadInfo(): Failed to get/create INTERNET_THREAD_INFO\n"));
    }

    //
    // as above - reset the last error variable in case TlsGetValue() trashed it
    //

    SetLastError(lastError);

    //
    // actual success/failure indicated by non-NULL/NULL pointer resp.
    //

    return lpThreadInfo;
}


VOID
InternetSetThreadInfo(
    IN LPINTERNET_THREAD_INFO lpThreadInfo
    )

/*++

Routine Description:

    Sets lpThreadInfo as the current thread's INTERNET_THREAD_INFO. Used within
    fibers

Arguments:

    lpThreadInfo    - new INTERNET_THREAD_INFO to set

Return Value:

    None.

--*/

{
    if (InternetTlsIndex != BAD_TLS_INDEX)
    {
        if (!TlsSetValue(InternetTlsIndex, (LPVOID)lpThreadInfo))
        {
            DEBUG_PUT(("InternetSetThreadInfo(): TlsSetValue(%d, %#x) returns %d\n",
                     InternetTlsIndex,
                     lpThreadInfo,
                     GetLastError()
                     ));

            INET_ASSERT(FALSE);
        }
    }
    else
    {

        DEBUG_PUT(("InternetSetThreadInfo(): InternetTlsIndex = %d\n",
                 InternetTlsIndex
                 ));

        INET_ASSERT(FALSE);
    }
}


DWORD
InternetIndicateStatusAddress(
    IN DWORD dwInternetStatus,
    IN LPSOCKADDR lpSockAddr,
    IN DWORD dwSockAddrLength
    )

/*++

Routine Description:

    Make a status callback to the app. The data is a network address that we
    need to convert to a string

Arguments:

    dwInternetStatus    - WINHTTP_CALLBACK_STATUS_ value

    lpSockAddr          - pointer to full socket address

    dwSockAddrLength    - length of lpSockAddr in bytes

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_WINHTTP_OPERATION_CANCELLED
                    The app closed the object handle during the callback

--*/

{
    LPSTR lpAddress;

    UNREFERENCED_PARAMETER(dwSockAddrLength);

    INET_ASSERT(lpSockAddr != NULL);

    switch (lpSockAddr->sa_family) 
    {
    case AF_INET:
        lpAddress = _I_inet_ntoa(
                        ((struct sockaddr_in*)lpSockAddr)->sin_addr
                        );
        break;

    case AF_IPX:

        //
        // BUGBUG - this should be a call to WSAAddressToString, but that's not implemented yet
        //
#ifdef SPX_SUPPORT
        lpAddress = GENERIC_SPX_NAME;
#else
        lpAddress = NULL;
#endif //SPX_SUPPORT
        break;

    default:
        lpAddress = NULL;
        break;
    }
    // we don't want a client to mess around with a winsock-internal buffer
    return InternetIndicateStatusString(dwInternetStatus, lpAddress, TRUE/*bCopyBuffer*/);
}


DWORD
InternetIndicateStatusString(
    IN DWORD dwInternetStatus,
    IN LPSTR lpszStatusInfo OPTIONAL,
    IN BOOL  bCopyBuffer,
    IN BOOL  bConvertToUnicode
    )

/*++

Routine Description:

    Make a status callback to the app. The data is a string

Arguments:

    dwInternetStatus    - WINHTTP_CALLBACK_STATUS_ value

    lpszStatusInfo      - string status data

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_WINHTTP_OPERATION_CANCELLED
                    The app closed the object handle during the callback

--*/

{
    DEBUG_ENTER((DBG_THRDINFO,
                Dword,
                "InternetIndicateStatusString",
                "%d, %q",
                dwInternetStatus,
                lpszStatusInfo
                ));

    DWORD length;

    if (ARGUMENT_PRESENT(lpszStatusInfo)) 
    {
        length = strlen(lpszStatusInfo) + 1;
    } 
    else 
    {
        length = 0;
    }

    DWORD error;

    error = InternetIndicateStatus(dwInternetStatus, lpszStatusInfo, length, bCopyBuffer, bConvertToUnicode);

    DEBUG_LEAVE(error);

    return error;
}


DWORD
InternetIndicateStatusNewHandle(
    IN LPVOID hInternetMapped
    )

/*++

Routine Description:

    Indicates to the app a new handle

Arguments:

    hInternetMapped - mapped address of new handle being indicated

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_WINHTTP_OPERATION_CANCELLED
                    The app closed the either the new object handle or the
                    parent object handle during the callback

--*/

{
    DEBUG_ENTER((DBG_THRDINFO,
                Dword,
                "InternetIndicateStatusNewHandle",
                "%#x",
                hInternetMapped
                ));

    HANDLE_OBJECT * hObject = (HANDLE_OBJECT *)hInternetMapped;

    //
    // reference the new request handle, in case the app closes it in the
    // callback. The new handle now has a reference count of 2
    //

    hObject->Reference();

    INET_ASSERT(hObject->ReferenceCount() == 2);

    //
    // we indicate the pseudo handle to the app
    //

    HINTERNET hInternet = hObject->GetPseudoHandle();

    DWORD error = InternetIndicateStatus(WINHTTP_CALLBACK_STATUS_HANDLE_CREATED,
                                         (LPVOID)&hInternet,
                                         sizeof(hInternet)
                                         );

    //
    // dereference the new request handle. If this returns TRUE then the new
    // handle has been deleted (the app called InternetCloseHandle() against
    // it which dereferenced it to 1, and now we've dereferenced it to zero)
    //

    if (hObject->Dereference()) 
    {
        error = ERROR_WINHTTP_OPERATION_CANCELLED;
    } 
    else if (error == ERROR_WINHTTP_OPERATION_CANCELLED) 
    {

        //
        // the parent handle was deleted. Kill off the new handle too
        //

        BOOL ok;

        ok = hObject->Dereference();

        INET_ASSERT(ok);

    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
InternetIndicateStatus(
    IN DWORD dwStatus,
    IN LPVOID lpBuffer,
    IN DWORD dwLength,
    IN BOOL bCopyBuffer,
    IN BOOL bConvertToUnicode
    )

/*++

Routine Description:

    If the app has registered a callback function for the object that this
    thread is operating on, call it with the arguments supplied

Arguments:

    dwStatus    - WINHTTP_CALLBACK_STATUS_ value

    lpBuffer    - pointer to variable data buffer

    dwLength    - length of *lpBuffer in bytes

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_WINHTTP_OPERATION_CANCELLED
                    The app closed the object handle during the callback

--*/

{
    DEBUG_ENTER((DBG_THRDINFO,
                Dword,
                "InternetIndicateStatus",
                "%s, %#x, %d",
                InternetMapStatus(dwStatus),
                lpBuffer,
                dwLength
                ));

    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
    DWORD error = ERROR_SUCCESS;

    //
    // the app can affect callback operation by specifying a zero context value
    // meaning no callbacks will be generated for this API
    //

    if (lpThreadInfo != NULL) 
    {

        INET_ASSERT(lpThreadInfo->hObject != NULL);
        INET_ASSERT(lpThreadInfo->hObjectMapped != NULL);

        //
        // if the context value in the thread info block is 0 then we use the
        // context from the handle object
        //

        DWORD_PTR context;

        context = ((INTERNET_HANDLE_BASE *)lpThreadInfo->hObjectMapped)->GetContext();

        WINHTTP_STATUS_CALLBACK appCallback;

        appCallback = ((INTERNET_HANDLE_BASE *)lpThreadInfo->hObjectMapped)->GetStatusCallback();

        IF_DEBUG(THRDINFO) 
        {
            switch (dwStatus) 
            {
                case WINHTTP_CALLBACK_STATUS_SENDREQUEST_COMPLETE:
                case WINHTTP_CALLBACK_STATUS_HEADERS_AVAILABLE:
                    DEBUG_PRINT(THRDINFO,
                                INFO,
                                ("%s\n",
                                InternetMapStatus(dwStatus)
                                ));
                    break;
                case WINHTTP_CALLBACK_STATUS_WRITE_COMPLETE:
                case WINHTTP_CALLBACK_STATUS_DATA_AVAILABLE:
                    DEBUG_PRINT(THRDINFO,
                                INFO,
                                ("%s: #bytes = %d [%#x]\n",
                                InternetMapStatus(dwStatus),
                                *((DWORD*)lpBuffer),
                                *((DWORD*)lpBuffer)
                                ));
                    break;
                case WINHTTP_CALLBACK_STATUS_READ_COMPLETE:
                    DEBUG_PRINT(THRDINFO,
                                INFO,
                                ("%s: Buffer = %#x, Number of bytes = %d\n",
                                InternetMapStatus(dwStatus),
                                lpBuffer,
                                dwLength
                                ));
                    break;
                case WINHTTP_CALLBACK_STATUS_REQUEST_ERROR:
                    DEBUG_PRINT(THRDINFO,
                                INFO,
                                ("%s: failure api = %d, Number of bytes = %d [%#x, %#s] \n",
                                InternetMapStatus(dwStatus),
                                ((LPWINHTTP_ASYNC_RESULT)lpBuffer)->dwResult,
                                ((LPWINHTTP_ASYNC_RESULT)lpBuffer)->dwError,
                                ((LPWINHTTP_ASYNC_RESULT)lpBuffer)->dwError,
                                InternetMapError(((LPWINHTTP_ASYNC_RESULT)lpBuffer)->dwError)
                                ));
            }

        }


        if( dwStatus == WINHTTP_CALLBACK_STATUS_REQUEST_ERROR)
        {
            TRACE_PRINT_API(THRDINFO,
                        INFO,
                        ("%s: Failure API = %s, Error = %s\n",
                        InternetMapStatus(dwStatus),
                        InternetMapRequestError( (DWORD) ((LPWINHTTP_ASYNC_RESULT)lpBuffer)->dwResult),
                        InternetMapError(((LPWINHTTP_ASYNC_RESULT)lpBuffer)->dwError)
                        ));
        }

        if ((appCallback != NULL) &&
            (((INTERNET_HANDLE_BASE *)lpThreadInfo->hObjectMapped)->IsNotificationEnabled(dwStatus)) )
        {
            LPVOID pInfo; //reported thru callback
            DWORD infoLength; //reported thru callback
            BOOL isAsyncWorkerThread;
            BYTE buffer[256];

            //
            // we make a copy of the info to remove the app's opportunity to
            // change it. E.g. if we were about to resolve host name "foo" and
            // passed the pointer to our buffer containing "foo", the app could
            // change the name to "bar", changing the intended server
            //

            if (lpBuffer != NULL) 
            {
                if (bConvertToUnicode)
                {
                    INET_ASSERT( ((INTERNET_HANDLE_BASE *)lpThreadInfo->hObjectMapped)->IsUnicodeStatusCallback() );

                    INET_ASSERT(    
                        (dwStatus == WINHTTP_CALLBACK_STATUS_RESOLVING_NAME)        || 
                        (dwStatus == WINHTTP_CALLBACK_STATUS_NAME_RESOLVED)         ||
                        (dwStatus == WINHTTP_CALLBACK_STATUS_REDIRECT)              ||
                        (dwStatus == WINHTTP_CALLBACK_STATUS_CONNECTING_TO_SERVER)  ||
                        (dwStatus == WINHTTP_CALLBACK_STATUS_CONNECTED_TO_SERVER)
                        );
                        
                    infoLength = MultiByteToWideChar(CP_ACP, 0, (LPSTR)lpBuffer,
                                                                dwLength, NULL, 0);
                    if (infoLength == 0)
                    {
                        pInfo = NULL;
                                
                        DEBUG_PRINT(THRDINFO,
                                    ERROR,
                                    ("MultiByteToWideChar returned 0 for a %d-length MBCS string\n",
                                    dwLength
                                    ));
                    }
                    else if (infoLength <= sizeof(buffer)/sizeof(WCHAR))
                    {
                        pInfo = buffer;
                    }
                    else
                    {
                        pInfo = (LPVOID)ALLOCATE_FIXED_MEMORY(infoLength * sizeof(WCHAR));
                    }
                    
                    if (pInfo)
                    {
                        infoLength = MultiByteToWideChar(CP_ACP, 0, (LPSTR)lpBuffer, 
                                                                dwLength, (LPWSTR)pInfo, infoLength);
                        if (infoLength == 0)
                        {
                            //MBtoWC failed
                            if (pInfo != buffer)
                                FREE_FIXED_MEMORY(pInfo);
                            pInfo = NULL;
                                
                            DEBUG_PRINT(THRDINFO,
                                        ERROR,
                                        ("MultiByteToWideChar returned 0 for a %d-length MBCS string\n",
                                        dwLength
                                        ));
                        }
                    } //pInfo
                    else
                    {
                        infoLength = 0;

                        DEBUG_PRINT(THRDINFO,
                                    ERROR,
                                    ("MultiByteToWideChar() error OR Failed to allocate %d bytes for info\n",
                                    dwLength
                                    ));

                    } //pInfo == NULL
                } //bConvertToUnicode
                else if (bCopyBuffer)
                {
                    if (dwLength <= sizeof(buffer))
                        pInfo = buffer;
                    else
                        pInfo = (LPVOID)ALLOCATE_FIXED_MEMORY(dwLength);

                    if (pInfo)
                    {
                        memcpy(pInfo, lpBuffer, dwLength);
                        infoLength = dwLength;
                    }
                    else 
                    {
                        infoLength = 0;

                        DEBUG_PRINT(THRDINFO,
                                    ERROR,
                                    ("Failed to allocate %d bytes for info\n",
                                    dwLength
                                    ));

                    }
                } //bCopyBuffer
                else
                {
                    pInfo = lpBuffer;
                    infoLength = dwLength;

                    INET_ASSERT(dwLength
                                || (WINHTTP_CALLBACK_STATUS_READ_COMPLETE == dwStatus));
                } //!bCopyBuffer && !bConvertToUnicode
            } //lpBuffer != NULL
            else 
            {
                pInfo = NULL;
                infoLength = 0;
            }

            //
            // we're about to call into the app. We may be in the context of an
            // async worker thread, and if the callback submits an async request
            // then we'll execute it synchronously. To avoid this, we will reset
            // the async worker thread indicator in the INTERNET_THREAD_INFO and
            // restore it when the app returns control to us. This way, if the
            // app makes an API request during the callback, on a handle that
            // has async I/O semantics, then we will simply queue it, and not
            // try to execute it synchronously
            //

            isAsyncWorkerThread = lpThreadInfo->IsAsyncWorkerThread;
            lpThreadInfo->IsAsyncWorkerThread = FALSE;

            BOOL bInCallback = lpThreadInfo->InCallback;

            lpThreadInfo->InCallback = TRUE;

            INET_ASSERT(!IsBadCodePtr((FARPROC)appCallback));

            DEBUG_ENTER((DBG_THRDINFO,
                         None,
                         "(*callback)",
                         "%#x, %#x, %s (%d), %#x [%#x], %d",
                         lpThreadInfo->hObject,
                         context,
                         InternetMapStatus(dwStatus),
                         dwStatus,
                         pInfo,
                         ((dwStatus == WINHTTP_CALLBACK_STATUS_HANDLE_CREATED)
                         || (dwStatus == WINHTTP_CALLBACK_STATUS_HANDLE_CLOSING))
                            ? (DWORD_PTR)*(LPHINTERNET)pInfo
                            : (((dwStatus == WINHTTP_CALLBACK_STATUS_REQUEST_SENT)
                            || (dwStatus == WINHTTP_CALLBACK_STATUS_RESPONSE_RECEIVED)
                            || (dwStatus == WINHTTP_CALLBACK_STATUS_INTERMEDIATE_RESPONSE))
                                ? *(LPDWORD)pInfo
                                : 0),
                         infoLength
                         ));

            PERF_LOG(PE_APP_CALLBACK_START,
                     dwStatus,
                     lpThreadInfo->ThreadId,
                     lpThreadInfo->hObject
                     );

            HINTERNET hObject = lpThreadInfo->hObject;
            LPVOID hObjectMapped = lpThreadInfo->hObjectMapped;

            appCallback(lpThreadInfo->hObject,
                        context,
                        dwStatus,
                        pInfo,
                        infoLength
                        );

            lpThreadInfo->hObject = hObject;
            lpThreadInfo->hObjectMapped = hObjectMapped;

            PERF_LOG(PE_APP_CALLBACK_END,
                     dwStatus,
                     lpThreadInfo->ThreadId,
                     lpThreadInfo->hObject
                     );

            DEBUG_LEAVE(0);

            lpThreadInfo->InCallback = bInCallback;
            lpThreadInfo->IsAsyncWorkerThread = isAsyncWorkerThread;

            //
            // free the buffer
            //

            // We should free the memory only if we have done an ALLOCATE_FIXED_MEMORY in this function:
            if (pInfo != NULL && pInfo != lpBuffer && pInfo != buffer) {
                FREE_FIXED_MEMORY(pInfo);
            }
        } else {

            DEBUG_PRINT(THRDINFO,
                        ERROR,
                        ("%#x: callback = %#x, context = %#x\n",
                        lpThreadInfo->hObject,
                        appCallback,
                        context
                        ));

            //
            // if we're completing a request then we shouldn't be here - it
            // means we lost the context or callback address somewhere along the
            // way
            //

            // don't need the ASSERTS below.
            // It could also mean something as benign as the notification not being enabled:
            /*
            INET_ASSERT(
                    dwStatus != WINHTTP_CALLBACK_STATUS_HEADERS_AVAILABLE
                &&  dwStatus != WINHTTP_CALLBACK_STATUS_WRITE_COMPLETE
                &&  dwStatus != WINHTTP_CALLBACK_STATUS_REQUEST_ERROR
                &&  dwStatus != WINHTTP_CALLBACK_STATUS_DATA_AVAILABLE
                &&  dwStatus != WINHTTP_CALLBACK_STATUS_READ_COMPLETE
                );
            */

#ifdef DEBUG
            if ( 
                    dwStatus == WINHTTP_CALLBACK_STATUS_HEADERS_AVAILABLE
                ||  dwStatus == WINHTTP_CALLBACK_STATUS_WRITE_COMPLETE
                ||  dwStatus == WINHTTP_CALLBACK_STATUS_REQUEST_ERROR
                ||  dwStatus == WINHTTP_CALLBACK_STATUS_DATA_AVAILABLE
                ||  dwStatus == WINHTTP_CALLBACK_STATUS_READ_COMPLETE
            )
            {
                INET_ASSERT(appCallback != NULL);
                /*
                    These are not valid asserts in winhttp.
                    Contexts don't control whether callbacks are made or not.
                 */
                //INET_ASSERT(context != NULL);
                //INET_ASSERT(_InternetGetContext(lpThreadInfo) != NULL);
            }
#endif


        }
        
        //
        // if the object is now invalid then the app closed the handle in
        // the callback, or from an external thread and the entire operation is cancelled
        // propagate this error back to calling code.
        //
        if (((HANDLE_OBJECT *)lpThreadInfo->hObjectMapped)->IsInvalidated()) 
        {
            error = ERROR_WINHTTP_OPERATION_CANCELLED;
        }
    } else {

        //
        // this is catastrophic if the indication was async request completion
        //

        DEBUG_PUT(("InternetIndicateStatus(): no INTERNET_THREAD_INFO?\n"));

    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
InternetSetLastError(
    IN DWORD ErrorNumber,
    IN LPSTR ErrorText,
    IN DWORD ErrorTextLength,
    IN DWORD Flags
    )

/*++

Routine Description:

    Copies the error text to the per-thread error buffer (moveable memory)

Arguments:

    ErrorNumber     - protocol-specific error code

    ErrorText       - protocol-specific error text (from server). The buffer is
                      NOT zero-terminated

    ErrorTextLength - number of characters in ErrorText

    Flags           - Flags that control how this function operates:

                        SLE_APPEND          TRUE if ErrorText is to be appended
                                            to the text already in the buffer

                        SLE_ZERO_TERMINATE  TRUE if ErrorText must have a '\0'
                                            appended to it

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - Win32 error

--*/

{
    DEBUG_ENTER((DBG_THRDINFO,
                Dword,
                "InternetSetLastError",
                "%d, %.80q, %d, %#x",
                ErrorNumber,
                ErrorText,
                ErrorTextLength,
                Flags
                ));

    DWORD error;
    LPINTERNET_THREAD_INFO lpThreadInfo;

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo != NULL) {
        error = _InternetSetLastError(lpThreadInfo,
                                      ErrorNumber,
                                      ErrorText,
                                      ErrorTextLength,
                                      Flags
                                      );
    } else {

        DEBUG_PUT(("InternetSetLastError(): no INTERNET_THREAD_INFO\n"));

        error = ERROR_WINHTTP_INTERNAL_ERROR;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
_InternetSetLastError(
    IN LPINTERNET_THREAD_INFO lpThreadInfo,
    IN DWORD ErrorNumber,
    IN LPSTR ErrorText,
    IN DWORD ErrorTextLength,
    IN DWORD Flags
    )

/*++

Routine Description:

    Sets or resets the last error text in an INTERNET_THREAD_INFO block

Arguments:

    lpThreadInfo    - pointer to INTERNET_THREAD_INFO

    ErrorNumber     - protocol-specific error code

    ErrorText       - protocol-specific error text (from server). The buffer is
                      NOT zero-terminated

    ErrorTextLength - number of characters in ErrorText

    Flags           - Flags that control how this function operates:

                        SLE_APPEND          TRUE if ErrorText is to be appended
                                            to the text already in the buffer

                        SLE_ZERO_TERMINATE  TRUE if ErrorText must have a '\0'
                                            appended to it

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - Win32 error

--*/

{
    DEBUG_ENTER((DBG_THRDINFO,
                Dword,
                "_InternetSetLastError",
                "%#x, %d, %.80q, %d, %#x",
                lpThreadInfo,
                ErrorNumber,
                ErrorText,
                ErrorTextLength,
                Flags
                ));

    DWORD currentLength = 0;
    DWORD newTextLength;
    DWORD error;

    newTextLength = ErrorTextLength;

    //
    // if we are appending text, then account for the '\0' currently at the end
    // of the buffer (if it exists)
    //

    if (Flags & SLE_APPEND) {
        currentLength = lpThreadInfo->ErrorTextLength;
        if (currentLength != 0) {
            --currentLength;
        }
        newTextLength += currentLength;
    }

    if (Flags & SLE_ZERO_TERMINATE) {
        ++newTextLength;
    }

    //
    // expect success (and why not?)
    //

    error = ERROR_SUCCESS;

    //
    // allocate, grow or shrink the buffer to fit. The buffer is moveable. If
    // the buffer is being shrunk to zero size then NULL will be returned as
    // the buffer handle from ResizeBuffer()
    //

    lpThreadInfo->hErrorText = ResizeBuffer(lpThreadInfo->hErrorText,
                                            newTextLength,
                                            FALSE
                                            );
    if (lpThreadInfo->hErrorText != NULL) {

        LPSTR lpErrorText;

        lpErrorText = (LPSTR)LOCK_MEMORY(lpThreadInfo->hErrorText);

        INET_ASSERT(lpErrorText != NULL);

        if (lpErrorText != NULL) {
            if (Flags & SLE_APPEND) {
                lpErrorText += currentLength;
            }
            memcpy(lpErrorText, ErrorText, ErrorTextLength);
            if (Flags & SLE_ZERO_TERMINATE) {
                lpErrorText[ErrorTextLength++] = '\0';
            }

            //
            // the text should always be zero-terminated. We expect this in
            // InternetGetLastResponseInfo()
            //

            INET_ASSERT(lpErrorText[ErrorTextLength - 1] == '\0');

            UNLOCK_MEMORY(lpThreadInfo->hErrorText);

        } else {

            //
            // real error occurred - failed to lock memory?
            //

            error = GetLastError();
        }
    } else {

        INET_ASSERT(newTextLength == 0);

        newTextLength = 0;
    }

    //
    // set the error code and text length
    //

    lpThreadInfo->ErrorTextLength = newTextLength;
    lpThreadInfo->ErrorNumber = ErrorNumber;

    DEBUG_LEAVE(error);

    return error;
}


LPSTR
InternetLockErrorText(
    VOID
    )

/*++

Routine Description:

    Returns a pointer to the locked per-thread error text buffer

Arguments:

    None.

Return Value:

    LPSTR
        Success - pointer to locked buffer

        Failure - NULL

--*/

{
    LPINTERNET_THREAD_INFO lpThreadInfo;

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo != NULL) {

        HLOCAL lpErrorText;

        lpErrorText = lpThreadInfo->hErrorText;
        if (lpErrorText != (HLOCAL)NULL) {
            return (LPSTR)LOCK_MEMORY(lpErrorText);
        }
    }
    return NULL;
}

//
//VOID
//InternetUnlockErrorText(
//    VOID
//    )
//
///*++
//
//Routine Description:
//
//    Unlocks the per-thread error text buffer locked by InternetLockErrorText()
//
//Arguments:
//
//    None.
//
//Return Value:
//
//    None.
//
//--*/
//
//{
//    LPINTERNET_THREAD_INFO lpThreadInfo;
//
//    lpThreadInfo = InternetGetThreadInfo();
//
//    //
//    // assume that if we locked the error text, there must be an
//    // INTERNET_THREAD_INFO when we come to unlock it
//    //
//
//    INET_ASSERT(lpThreadInfo != NULL);
//
//    if (lpThreadInfo != NULL) {
//
//        HLOCAL hErrorText;
//
//        hErrorText = lpThreadInfo->hErrorText;
//
//        //
//        // similarly, there must be a handle to the error text buffer
//        //
//
//        INET_ASSERT(hErrorText != NULL);
//
//        if (hErrorText != (HLOCAL)NULL) {
//            UNLOCK_MEMORY(hErrorText);
//        }
//    }
//}


VOID
InternetSetObjectHandle(
    IN HINTERNET hInternet,
    IN HINTERNET hInternetMapped
    )

/*++

Routine Description:

    Sets the hObject field in the INTERNET_THREAD_INFO structure so we can get
    at the handle contents, even when we're in a function that does not take
    the hInternet as a parameter

Arguments:

    hInternet       - handle of object we may need info from

    hInternetMapped - mapped handle of object we may need info from

Return Value:

    None.

--*/

{
    LPINTERNET_THREAD_INFO lpThreadInfo;

    lpThreadInfo = InternetGetThreadInfo();

    if (lpThreadInfo != NULL) {
        _InternetSetObjectHandle(lpThreadInfo, hInternet, hInternetMapped);
    }
}


HINTERNET
InternetGetObjectHandle(
    VOID
    )

/*++

Routine Description:

    Just returns the hObject value stored in our INTERNET_THREAD_INFO

Arguments:

    None.

Return Value:

    HINTERNET
        Success - non-NULL handle value

        Failure - NULL object handle (may not have been set)

--*/

{
    LPINTERNET_THREAD_INFO lpThreadInfo;
    HINTERNET hInternet;

    lpThreadInfo = InternetGetThreadInfo();

    if (lpThreadInfo != NULL) {
        hInternet = lpThreadInfo->hObject;
    } else {
        hInternet = NULL;
    }
    return hInternet;
}


HINTERNET
InternetGetMappedObjectHandle(
    VOID
    )

/*++

Routine Description:

    Just returns the hObjectMapped value stored in our INTERNET_THREAD_INFO

Arguments:

    None.

Return Value:

    HINTERNET
        Success - non-NULL handle value

        Failure - NULL object handle (may not have been set)

--*/

{
    LPINTERNET_THREAD_INFO lpThreadInfo;
    HINTERNET hInternet;

    lpThreadInfo = InternetGetThreadInfo();

    if (lpThreadInfo != NULL) {
        hInternet = lpThreadInfo->hObjectMapped;
    } else {
        hInternet = NULL;
    }
    return hInternet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5.1\api\sendapi.cxx ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    sendapi.cxx

Abstract:

    This file contains the implementation of the HttpSendRequestA API.

    Contents:
        WinHttpSendRequest
        HttpSendRequestA
        WinHttpReceiveResponse
        HttpWrapSendRequest

Author:

    Keith Moore (keithmo) 16-Nov-1994

Revision History:

      29-Apr-97 rfirth
        Conversion to FSM

--*/

#include <wininetp.h>
#include <perfdiag.hxx>

//
// private prototypes
//

PRIVATE
BOOL
HttpWrapSendRequest(
    IN HINTERNET hRequest,
    IN LPCSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN LPVOID lpOptional OPTIONAL,
    IN DWORD dwOptionalLength,
    IN DWORD dwOptionalLengthTotal,
    IN AR_TYPE arRequest,
    OUT HTTP_REQUEST_HANDLE_OBJECT** pHandleToDeref,
    IN DWORD_PTR dwContext=NULL
    );

//
// functions
//

INTERNETAPI
BOOL
WINAPI
HttpSendRequestA(
    IN HINTERNET hRequest,
    IN LPCSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN LPVOID lpOptional OPTIONAL,
    IN DWORD dwOptionalLength
    )

/*++

Routine Description:

    Sends the specified request to the HTTP server.

Arguments:

    hRequest                - An open HTTP request handle returned by
                              HttpOpenRequest()

    lpszHeaders             - Additional headers to be appended to the request.
                              This may be NULL if there are no additional
                              headers to append

    dwHeadersLength         - The length (in characters) of the additional
                              headers. If this is -1L and lpszAdditional is
                              non-NULL, then lpszAdditional is assumed to be
                              zero terminated (ASCIIZ)

    lpOptionalData          - Any optional data to send immediately after the
                              request headers. This is typically used for POST
                              operations. This may be NULL if there is no
                              optional data to send

    dwOptionalDataLength    - The length (in BYTEs) of the optional data. This
                              may be zero if there is no optional data to send

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. For more information call GetLastError(). If the
                  request was async, then GetLastError() will return
                  ERROR_IO_PENDING which means that the operation initially
                  succeeded, and that the caller should wait for the status
                  callback to discover the final success/failure status

--*/

{
    DEBUG_ENTER((DBG_API,
                Bool,
                "HttpSendRequestA",
                "%#x, %.80q, %d, %#x, %d",
                hRequest,
                lpszHeaders,
                dwHeadersLength,
                lpOptional,
                dwOptionalLength
                ));


    BOOL fRet= HttpWrapSendRequest(
                hRequest,
                lpszHeaders,
                dwHeadersLength,
                lpOptional,
                dwOptionalLength,
                0,
                AR_HTTP_SEND_REQUEST,
                NULL
                );


    DEBUG_LEAVE(fRet);

    return fRet;
}

INTERNETAPI
BOOL
WINAPI
WinHttpSendRequest(
    IN HINTERNET hRequest,
    IN LPCWSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN LPVOID lpOptional OPTIONAL,
    IN DWORD dwOptionalLength,
    IN DWORD dwTotalLength,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    Sends the specified request to the HTTP server.

Arguments:

    hRequest                - An open HTTP request handle returned by
                              HttpOpenRequest()

    lpszHeaders             - Additional headers to be appended to the request.
                              This may be NULL if there are no additional
                              headers to append

    dwHeadersLength         - The length (in characters) of the additional
                              headers. If this is -1L and lpszAdditional is
                              non-NULL, then lpszAdditional is assumed to be
                              zero terminated (ASCIIZ)

    lpOptionalData          - Any optional data to send immediately after the
                              request headers. This is typically used for POST
                              operations. This may be NULL if there is no
                              optional data to send

    dwOptionalDataLength    - The length (in BYTEs) of the optional data. This
                              may be zero if there is no optional data to send

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. For more information call GetLastError(). If the
                  request was async, then GetLastError() will return
                  ERROR_IO_PENDING which means that the operation initially
                  succeeded, and that the caller should wait for the status
                  callback to discover the final success/failure status

--*/

{
    DEBUG_ENTER2_API((DBG_API,
                Bool,
                "WinHttpSendRequest",
                "%#x, %.80wq, %d, %#x, %d, %d, %x",
                hRequest,
                lpszHeaders,
                dwHeadersLength,
                lpOptional,
                dwOptionalLength,
                dwTotalLength,
                dwContext
                ));

    TRACE_ENTER2_API((DBG_API,
                Bool,
                "WinHttpSendRequest",
                hRequest,
                "%#x, %.80wq, %d, %#x, %d, %d, %x",
                hRequest,
                !lpszHeaders || IsBadReadPtr(lpszHeaders, 1)? L"": lpszHeaders,
                dwHeadersLength,
                lpOptional,
                dwOptionalLength,
                dwTotalLength,
                dwContext
                ));

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;
    MEMORYPACKET mpHeaders;

    if (!hRequest)
    {
        dwErr = ERROR_INVALID_HANDLE;
        goto cleanup;
    }

    if (lpszHeaders && IsBadReadPtr(lpszHeaders, 1))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    if (dwHeadersLength == -1L)
    {
        dwHeadersLength = lpszHeaders ? lstrlenW(lpszHeaders) : 0;
    }

    if (lpszHeaders)
    {
        if ((dwHeadersLength == -1)
            ? IsBadStringPtrW(lpszHeaders, (UINT_PTR)-1)
            : IsBadReadPtr(lpszHeaders, dwHeadersLength))
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
        ALLOC_MB(lpszHeaders, dwHeadersLength, mpHeaders);
        if (!mpHeaders.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(lpszHeaders, mpHeaders);
    }
    if (lpOptional 
        && dwOptionalLength
        && IsBadReadPtr(lpOptional, dwOptionalLength) )
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
            
    AR_TYPE ar;
    
    // Always require a WinHttpReceiveResponse to initiate
    // FSM_STATE_4 onwards in HTTP_REQUEST_HANDLE_OBJECT::HttpSendRequest_Start:
    if (dwOptionalLength <= dwTotalLength)
    {
        ar = AR_HTTP_BEGIN_SEND_REQUEST;
    }
    else
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    HTTP_REQUEST_HANDLE_OBJECT* pRequest = NULL;
    
    fResult = HttpWrapSendRequest(hRequest, mpHeaders.psStr, mpHeaders.dwSize,
                lpOptional, dwOptionalLength, dwTotalLength, ar, &pRequest, dwContext);
    // This calls SetLastError if fResult is FALSE.

    if (fResult)
    {
        if (pRequest)
        {
            InternetIndicateStatus(WINHTTP_CALLBACK_STATUS_SENDREQUEST_COMPLETE,
                                   NULL,
                                   NULL
                                   );

            // So that we have a refcount on the object going into the callback.
            DereferenceObject((LPVOID)pRequest);
        }
    }
    else if ((dwErr = GetLastError()) == ERROR_IO_PENDING)
    {
        SetLastError(dwErr = ERROR_SUCCESS);
        fResult = TRUE;
    }
    
cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        DEBUG_ERROR(HTTP, dwErr);
        SetLastError(dwErr); 
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}


INTERNETAPI
BOOL
WINAPI
WinHttpReceiveResponse(
    IN HINTERNET hRequest,
    IN LPVOID lpBuffersOut OPTIONAL
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    hRequest        -
    lpBuffersOut    -
    dwFlags         -
    dwContext       -

Return Value:

    BOOL

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "WinHttpReceiveResponse",
                     "%#x, %#x",
                     hRequest,
                     lpBuffersOut
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;

    if (!hRequest)
    {
        dwErr = ERROR_INVALID_HANDLE;
    }
    else if (lpBuffersOut)
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        HTTP_REQUEST_HANDLE_OBJECT* pRequest = NULL;
        fResult = HttpWrapSendRequest(hRequest, NULL, 0, NULL, 0, 0, AR_HTTP_END_SEND_REQUEST, &pRequest);
        
        if (fResult)
        {
            if (pRequest)
            {
                InternetIndicateStatus(WINHTTP_CALLBACK_STATUS_HEADERS_AVAILABLE,
                                       NULL,
                                       NULL
                                       );

                // So that we have a refcount on the object going into the callback.
                DereferenceObject((LPVOID)pRequest);
            }
        }
        else if ((dwErr = GetLastError()) == ERROR_IO_PENDING)
        {
            SetLastError(dwErr = ERROR_SUCCESS);
            fResult = TRUE;
        }
    }
    
    if (dwErr!=ERROR_SUCCESS) 
    { 
        DEBUG_ERROR(HTTP, dwErr);
        SetLastError(dwErr); 
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}


PRIVATE
BOOL
HttpWrapSendRequest(
    IN HINTERNET hRequest,
    IN LPCSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN LPVOID lpOptional OPTIONAL,
    IN DWORD dwOptionalLength,
    IN DWORD dwOptionalLengthTotal,
    IN AR_TYPE arRequest,
    OUT HTTP_REQUEST_HANDLE_OBJECT** pHandleToDeref,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    Sends the specified request to the HTTP server.

Arguments:

    hRequest                - An open HTTP request handle returned by
                              HttpOpenRequest()

    lpszHeaders             - Additional headers to be appended to the request.
                              This may be NULL if there are no additional
                              headers to append

    dwHeadersLength         - The length (in characters) of the additional
                              headers. If this is -1L and lpszAdditional is
                              non-NULL, then lpszAdditional is assumed to be
                              zero terminated (ASCIIZ)

    lpOptionalData          - Any optional data to send immediately after the
                              request headers. This is typically used for POST
                              operations. This may be NULL if there is no
                              optional data to send

    dwOptionalDataLength    - The length (in BYTEs) of the optional data. This
                              may be zero if there is no optional data to send

    dwOptionalLengthTotal   - Total length need to be sent for File Upload.

    arRequest               - Which API the caller is making,
                                assumed to be HttpEndRequestA, HttpSendRequestExA, or
                                HttpSendRequestA

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. For more information call GetLastError(). If the
                  request was async, then GetLastError() will return
                  ERROR_IO_PENDING which means that the operation initially
                  succeeded, and that the caller should wait for the status
                  callback to discover the final success/failure status

Comments:

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Bool,
                 "HttpWrapSendRequest",
                 "%#x, %.80q, %d, %#x, %d, %d, %x",
                 hRequest,
                 lpszHeaders,
                 dwHeadersLength,
                 lpOptional,
                 dwOptionalLength,
                 dwOptionalLengthTotal,
                 dwContext
                 ));

    PERF_ENTER(HttpWrapSendRequest);

    DWORD error = ERROR_SUCCESS;
    HINTERNET hRequestMapped = NULL;
    BOOL bDeref = TRUE;

    BOOL isLocal;
    BOOL isAsync = FALSE;

    if (!GlobalDataInitialized) {
        error = ERROR_WINHTTP_NOT_INITIALIZED;
        goto done;
    }

    //
    // we will need the thread info for several items
    //

    LPINTERNET_THREAD_INFO lpThreadInfo;

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL) {
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto done;
    }

    //
    // the only FSMs that can come before this one are InternetOpenUrl() or
    // HttpSendRequest() when we are performing nested send for https://
    // tunnelling through proxy
    //

    INET_ASSERT((lpThreadInfo->Fsm == NULL)
                || (lpThreadInfo->Fsm->GetType() == FSM_TYPE_PARSE_HTTP_URL)
                || (lpThreadInfo->Fsm->GetType() == FSM_TYPE_OPEN_PROXY_TUNNEL)
                );

    INET_ASSERT( arRequest == AR_HTTP_SEND_REQUEST ||
                 arRequest == AR_HTTP_BEGIN_SEND_REQUEST ||
                 arRequest == AR_HTTP_END_SEND_REQUEST );


    //
    // map the handle
    //
    error = MapHandleToAddress(hRequest, (LPVOID *)&hRequestMapped, FALSE);


    if ((error != ERROR_SUCCESS) && (hRequestMapped == NULL)) {
        goto quit;
    }

    //
    // Cast it to the object that we know. We are going to do caching
    // semantics with this
    //

    HTTP_REQUEST_HANDLE_OBJECT * pRequest;

    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)hRequestMapped;

    //
    // set the context and handle info & reset the error variables,
    // but only if not for a ReceiveResponse call.
    //
    if (arRequest != AR_HTTP_END_SEND_REQUEST)
    {
        if (dwContext)
            pRequest->SetContext(dwContext);
        
        // We need this information to special-case for Redirects and Auth because of RR FSM changes:
        pRequest->SetWriteRequired(dwOptionalLength < dwOptionalLengthTotal);
    }
    _InternetSetObjectHandle(lpThreadInfo, hRequest, hRequestMapped);
    _InternetClearLastError(lpThreadInfo);

    //
    // quit now if the handle was invalid
    //

    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // use RIsHandleLocal() to discover 4 things:
    //
    //  1. Handle is valid
    //  2. Handle is of expected type (HTTP Request in this case)
    //  3. Handle is local or remote
    //  4. Handle supports async I/O
    //

    error = RIsHandleLocal(hRequestMapped,
                           &isLocal,
                           &isAsync,
                           TypeHttpRequestHandle
                           );

    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    if (isAsync)
    {
        error = InitializeAsyncSupport();
        if (error != ERROR_SUCCESS)
        {
            goto quit;
        }
    }
    //
    // For SEND_REQUEST, and BEGIN_SEND_REQUEST, we need
    //  to do some basic initalization
    //

    if ( arRequest == AR_HTTP_SEND_REQUEST ||
         arRequest == AR_HTTP_BEGIN_SEND_REQUEST)
    {
        error = pRequest->InitBeginSendRequest(lpszHeaders,
                                       dwHeadersLength,
                                       &lpOptional,
                                       &dwOptionalLength,
                                       dwOptionalLengthTotal
                                       );

        if ( error != ERROR_SUCCESS)
        {
            goto quit;
        }

        // (Re)set flag to indicate WinHttpReceiveResponse needs to be called.
        pRequest->SetReceiveResponseState(FALSE);

        // RENO 35599: If sending a new request, ensure the OptionalSaved member
        // variables are cleared out.
        pRequest->ClearSavedOptionalData();
    }
    else if (arRequest == AR_HTTP_END_SEND_REQUEST)
    {
        pRequest->SetReceiveResponseState(TRUE);
    }


    //
    // send the request to the server. This may involve redirections and user
    // authentication
    //

    //error = DoFsm(New CFsm_HttpSendRequest(lpOptional, dwOptionalLength, pRequest, arRequest));
    //if (error == ERROR_IO_PENDING) {
    //    bDeref = FALSE;
    //}
    CFsm_HttpSendRequest * pFsm;

    pFsm = New CFsm_HttpSendRequest(lpOptional, dwOptionalLength, pRequest, arRequest);

    if (pFsm != NULL)
    {
        if (isAsync && !lpThreadInfo->IsAsyncWorkerThread)
        {
            error = StartFsmChain(pFsm, pRequest, TRUE, TRUE);

            if ((error == ERROR_SUCCESS)
                && pHandleToDeref)
            {
                // Deref in the outer api call for sync success in async case.
                *pHandleToDeref = pRequest;
                bDeref = FALSE;
            }
        }
        else
        {
            error = StartFsmChain(pFsm, pRequest, FALSE, FALSE);
        }
        if (error == ERROR_IO_PENDING)
        {
            bDeref = FALSE;
        }
    }
    else
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
    }

quit:

    //
    // if we went async don't deref the handle
    //

    if (bDeref && (hRequestMapped != NULL)) {
        DereferenceObject((LPVOID)hRequestMapped);
    }

done:

    BOOL success = TRUE;

    // SetLastError must be called after PERF_LEAVE !!!
    PERF_LEAVE(HttpWrapSendRequest);

    if (error != ERROR_SUCCESS) 
    {
        DEBUG_ERROR(HTTP, error);
        SetLastError(error);
        success = FALSE;
    }

    DEBUG_LEAVE(success);
    return success;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5.1\auth\sspspm.h ===
//#----------------------------------------------------------------------------
//
//  File:           sspspm.h
//
//      Synopsis:   Definitions specific to SSPI SPM DLL.
//
//      Copyright (C) 1995  Microsoft Corporation.  All Rights Reserved.
//
//  Authors:        LucyC       Created                         25 Sept 1995
//
//-----------------------------------------------------------------------------
#ifndef _SSPSPM_H_
#define _SSPSPM_H_

#include <platform.h>

#ifdef __cplusplus
extern "C" {
#endif

//
//  Names of secruity DLL
//
#define SSP_SPM_NT_DLL      "security.dll"
#define SSP_SPM_WIN95_DLL   "secur32.dll"


#define SSP_SPM_DLL_NAME_SIZE   16          // max. length of security DLL names

#define MAX_SSPI_PKG        32              // Max. no. of SSPI supported

#define SSPPKG_ERROR        ((UCHAR) 0xff)
#define SSPPKG_NO_PKG       SSPPKG_ERROR
#define MAX_AUTH_MSG_SIZE   10000
#define TCP_PRINT   fprintf
#define DBG_CONTEXT stderr

#define MAX_BLOB_SIZE       13000

//
//  Server host list definition.

//  The following defines an entry in the server host list.
//
typedef struct _ssp_host_list
{
    struct _ssp_host_list   *pNext;

    unsigned char           *pHostname; // name of server host
    unsigned char           pkgID;      // the package being used for this host

} SspHosts, *PSspHosts;

//
//  List of SSPI packages installed on this machine.
//  The following defines an entry of the SSPI package list.
//
typedef struct _ssp_auth_pkg
{
    LPTSTR       pName;         // package name
    DWORD        Capabilities ; // Interesting capabilities bit
    ULONG        cbMaxToken;    // max size of security token
} SSPAuthPkg, *PSSPAuthPkg;

#define SSPAUTHPKG_SUPPORT_NTLM_CREDS   0x00000001

//
//  The following defines the global data structure which the SPM DLL keeps
//  in the HTSPM structure.
//
typedef struct _ssp_htspm
{
    PSecurityFunctionTable pFuncTbl;

    SSPAuthPkg      **PkgList;          // array of pointers to auth packages
    UCHAR           PkgCnt;



    BOOLEAN         bKeepList;          // whether to keep a list of servers
    
    PSspHosts       pHostlist;

} SspData, *PSspData;

#define SPM_STATUS_OK                   0
#define SPM_ERROR                       1
#define SPM_STATUS_WOULD_BLOCK          2
#define SPM_STATUS_INSUFFICIENT_BUFFER  3

/////////////////////////////////////////////////////////////////////////////
//
//  Function headers from sspcalls.c
//
/////////////////////////////////////////////////////////////////////////////

DWORD
GetSecAuthMsg (
    PSspData        pData,
    PCredHandle     pCredential,
    DWORD           pkgID,              // the package index into package list
    PCtxtHandle     pInContext,
    PCtxtHandle     pOutContext,
    ULONG           fContextReq,        // Request Flags
    VOID            *pBuffIn,
    DWORD           cbBuffIn,
    char            *pFinalBuff,
    DWORD           *pcbBuffOut,
    SEC_CHAR        *pszTarget,         // Server Host Name
    BOOL            fTargetTrusted,
    UINT            bNonBlock,
    LPSTR           pszScheme,
	SECURITY_STATUS *pssResult
    );

INT
GetPkgId(LPTSTR  lpszPkgName);

DWORD
GetPkgCapabilities(
    INT Package
    );
ULONG
GetPkgMaxToken(
    INT Package
    );

/////////////////////////////////////////////////////////////////////////////
//
//  Function headers from buffspm.c
//
/////////////////////////////////////////////////////////////////////////////

PSspHosts
SspSpmNewHost (
    PSspData pData,
    UCHAR    *pHost,       // name of server host to be added
    UCHAR    Package
    );

VOID
SspSpmDeleteHost(
    SspData     *pData,
    PSspHosts   pDelHost
    );

VOID
SspSpmTrashHostList(
    SspData     *pData
    );

PSspHosts
SspSpmGetHost(
    PSspData pData,
    UCHAR *pHost
    );

#ifdef __cplusplus
} // end extern "C" {
#endif

#endif  /* _SSPSPM_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5.1\auth\digest.cxx ===
#include <wininetp.h>
#include <splugin.hxx>
#include <security.h>
#include "auth.h"

#define SSP_SPM_NT_DLL      "security.dll"

#define MAX_SILENT_RETRIES  3
#define OUTPUT_BUFFER_LEN   10000

#define HEADER_IDX          0
#define REALM_IDX           1
#define HOST_IDX            2
#define URL_IDX             3
#define METHOD_IDX          4
#define USER_IDX            5
#define PASS_IDX            6
#define NONCE_IDX           7
#define NC_IDX              8
#define HWND_IDX            9
#define NUM_BUFF            10

#define ISC_MODE_AUTH        0
#define ISC_MODE_PREAUTH     1
#define ISC_MODE_UI          2

struct DIGEST_PKG_DATA
{
    LPSTR szAppCtx;
    LPSTR szUserCtx;
};

/*-----------------------------------------------------------------------------
    DIGEST_CTX
-----------------------------------------------------------------------------*/

// Globals
PSecurityFunctionTable DIGEST_CTX::g_pFuncTbl = NULL;
CredHandle DIGEST_CTX::g_hCred;


/*---------------------------------------------------------------------------
DIGEST_CTX::GetFuncTbl
---------------------------------------------------------------------------*/
VOID DIGEST_CTX::GetFuncTbl()
{
    HINSTANCE hSecLib = NULL;
    INIT_SECURITY_INTERFACE addrProcISI = NULL;
    OSVERSIONINFO   VerInfo;

    VerInfo.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);

    GetVersionEx (&VerInfo);

    if (VerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
    {
        hSecLib = LoadLibrary (SSP_SPM_NT_DLL);
    }
        
    addrProcISI = (INIT_SECURITY_INTERFACE) GetProcAddress(hSecLib, 
                    SECURITY_ENTRYPOINT_ANSI);       
        
    g_pFuncTbl = (*addrProcISI)();
}

/*---------------------------------------------------------------------------
DIGEST_CTX::GetRequestUri
---------------------------------------------------------------------------*/
LPSTR DIGEST_CTX::GetRequestUri()
{
    LPSTR szUrl;
    DWORD cbUrl;

    URL_COMPONENTSA sUrl;        

    memset(&sUrl, 0, sizeof(sUrl));
    sUrl.dwStructSize = sizeof(sUrl);
    sUrl.dwHostNameLength = (DWORD)-1; 
    sUrl.dwUrlPathLength = (DWORD)-1; 
    sUrl.dwExtraInfoLength = (DWORD)-1; 

    szUrl = _pRequest->GetURL();

    // Generate request-uri
    if (WinHttpCrackUrlA(szUrl, strlen(szUrl), 0, &sUrl))
    {
        cbUrl = sUrl.dwUrlPathLength;
        szUrl = New CHAR[cbUrl+1];

        if (!szUrl)
        {
            // Alloc failure. Return NULL. We will
            // use _pRequest->GetURL instead.
            return NULL;
        }
    
        memcpy(szUrl, sUrl.lpszUrlPath, cbUrl);
        szUrl[cbUrl] = '\0';
    }
    else
    {
        // ICU failed. Return NULL which
        // will cause _pRequest->GetURL
        // to be used.
        return NULL;
    }

    return szUrl;
}


/*---------------------------------------------------------------------------
DIGEST_CTX::InitSecurityBuffers
---------------------------------------------------------------------------*/
VOID DIGEST_CTX::InitSecurityBuffers(LPSTR szOutBuf, DWORD cbOutBuf,
    LPDWORD pdwSecFlags, DWORD dwISCMode)
{
    // Input Buffer.    
    _SecBuffInDesc.cBuffers = NUM_BUFF;
    _SecBuffInDesc.pBuffers = _SecBuffIn;

    // Set Header
    _SecBuffIn[HEADER_IDX].pvBuffer     = _szData;
    _SecBuffIn[HEADER_IDX].cbBuffer     = _cbData;
    _SecBuffIn[HEADER_IDX].BufferType   = SECBUFFER_TOKEN;
    
    // If credentials are supplied will be set to
    // ISC_REQ_USE_SUPPLIED_CREDS.
    // If prompting for auth dialog will be set to
    // ISC_REQ_PROMPT_FOR_CREDS.
    *pdwSecFlags = 0;
    
    // Set realm if no header, otherwise NULL.
    if (_SecBuffIn[HEADER_IDX].pvBuffer)
    {
        _SecBuffIn[REALM_IDX].pvBuffer  = NULL;
        _SecBuffIn[REALM_IDX].cbBuffer  = 0;
    }
    else
    {
        // We are preauthenticating using the realm
        _SecBuffIn[REALM_IDX].pvBuffer = _pCreds->lpszRealm;
        _SecBuffIn[REALM_IDX].cbBuffer = strlen(_pCreds->lpszRealm);
    }
    
    // Host.
    _SecBuffIn[HOST_IDX].pvBuffer     = _pCreds->lpszHost;
    _SecBuffIn[HOST_IDX].cbBuffer     = strlen(_pCreds->lpszHost);
    _SecBuffIn[HOST_IDX].BufferType   = SECBUFFER_TOKEN;

    
    // Request URI.    
    if (!_szRequestUri)
    {
        _szRequestUri = GetRequestUri();
        if (_szRequestUri)
            _SecBuffIn[URL_IDX].pvBuffer     = _szRequestUri;
        else
            _SecBuffIn[URL_IDX].pvBuffer = _pRequest->GetURL();
    }

    _SecBuffIn[URL_IDX].cbBuffer     = strlen((LPSTR) _SecBuffIn[URL_IDX].pvBuffer);
    _SecBuffIn[URL_IDX].BufferType   = SECBUFFER_TOKEN;


    LPSTR lpszVerb;
    DWORD dwVerbLength;
    lpszVerb = _pRequest->_RequestHeaders.GetVerb(&dwVerbLength);
    if(NULL != _pszVerb)
        delete[] _pszVerb;
    _pszVerb = new CHAR[dwVerbLength+1];
    if (_pszVerb)
    {
        memcpy(_pszVerb, lpszVerb, dwVerbLength);
        _pszVerb[dwVerbLength] = 0;
    }

    // HTTP method.
    _SecBuffIn[METHOD_IDX].pvBuffer = _pszVerb;
    _SecBuffIn[METHOD_IDX].cbBuffer = dwVerbLength;
        // MapHttpMethodType(_pRequest->GetMethodType(), (LPCSTR*) &_SecBuffIn[METHOD_IDX].pvBuffer);
    _SecBuffIn[METHOD_IDX].BufferType   = SECBUFFER_TOKEN;

    // User and pass might be provided from Creds entry. Use only if
    // we have a challenge header (we don't pre-auth using supplied creds).
    if (dwISCMode == ISC_MODE_AUTH && _pCreds->lpszUser && *_pCreds->lpszUser 
        && _pCreds->lpszPass && *_pCreds->lpszPass)
    {
        // User.
        _SecBuffIn[USER_IDX].pvBuffer     = _pCreds->lpszUser;
        _SecBuffIn[USER_IDX].cbBuffer     = strlen(_pCreds->lpszUser);
        _SecBuffIn[USER_IDX].BufferType   = SECBUFFER_TOKEN;

        // Pass.
        _SecBuffIn[PASS_IDX].pvBuffer     = _pCreds->lpszPass;
        _SecBuffIn[PASS_IDX].cbBuffer     = strlen(_pCreds->lpszPass);
        _SecBuffIn[PASS_IDX].BufferType   = SECBUFFER_TOKEN;
        *pdwSecFlags = ISC_REQ_USE_SUPPLIED_CREDS;
    }
    else
    {
        // User.
        _SecBuffIn[USER_IDX].pvBuffer     = NULL;  
        _SecBuffIn[USER_IDX].cbBuffer     = 0;
        _SecBuffIn[USER_IDX].BufferType   = SECBUFFER_TOKEN;

        // Pass.
        _SecBuffIn[PASS_IDX].pvBuffer     = NULL;
        _SecBuffIn[PASS_IDX].cbBuffer     = 0;
        _SecBuffIn[PASS_IDX].BufferType   = SECBUFFER_TOKEN;
    }

    if (dwISCMode == ISC_MODE_UI)
        *pdwSecFlags = ISC_REQ_PROMPT_FOR_CREDS;
        
    // Out Buffer.
    _SecBuffOutDesc.cBuffers    = 1;
    _SecBuffOutDesc.pBuffers    = _SecBuffOut;
    _SecBuffOut[0].pvBuffer     = szOutBuf;
    _SecBuffOut[0].cbBuffer     = cbOutBuf;
    _SecBuffOut[0].BufferType   = SECBUFFER_TOKEN;
}


/*---------------------------------------------------------------------------
    Constructor
---------------------------------------------------------------------------*/
DIGEST_CTX::DIGEST_CTX(HTTP_REQUEST_HANDLE_OBJECT *pRequest, BOOL fIsProxy,
                 SPMData *pSPM, AUTH_CREDS* pCreds)
    : AUTHCTX(pSPM, pCreds)
{
    SECURITY_STATUS ssResult;
    _fIsProxy = fIsProxy;
    _pRequest = pRequest;

    _szAlloc      = NULL;
    _szData       = NULL;
    _pvContext    = NULL;
    _szRequestUri = NULL;
    _cbData       = 0;
    _cbContext    = 0;
    _nRetries     = 0;

    _pszVerb = NULL;
    
    
    // Zero out the security buffers and request context.
    memset(&_SecBuffInDesc,  0, sizeof(_SecBuffInDesc));
    memset(&_SecBuffOutDesc, 0, sizeof(_SecBuffInDesc));
    memset(_SecBuffIn,       0, sizeof(_SecBuffIn));
    memset(_SecBuffOut,      0, sizeof(_SecBuffOut));
    memset(&_hCtxt,          0, sizeof(_hCtxt));
        
    // Is this the first time that the digest SSPI package
    // is being called for this process.
    if (!g_pFuncTbl)
    {
        // Get the global SSPI dispatch table.
        GetFuncTbl();

        DIGEST_PKG_DATA             PkgData;
        SEC_WINNT_AUTH_IDENTITY_EXA SecIdExA;

        sprintf(_szUserCtx, "%p", pRequest);

        // Logon with szAppCtx = szUserCtx = NULL.
        PkgData.szAppCtx = PkgData.szUserCtx = _szUserCtx;
        memset(&SecIdExA, 0, sizeof(SEC_WINNT_AUTH_IDENTITY_EXA));

        SecIdExA.Version = sizeof(SEC_WINNT_AUTH_IDENTITY_EXA);
        SecIdExA.User = (unsigned char*) &PkgData;
        SecIdExA.UserLength = sizeof(DIGEST_PKG_DATA);
        
        // Get the global credentials handle.
        ssResult = (*(g_pFuncTbl->AcquireCredentialsHandleA))
            (NULL, "Digest", SECPKG_CRED_OUTBOUND, NULL, &SecIdExA, NULL, 0, &g_hCred, NULL);
    }
}


/*---------------------------------------------------------------------------
DIGEST_CTX::PromptForCreds
---------------------------------------------------------------------------*/
DWORD DIGEST_CTX::PromptForCreds(HWND hWnd)
{
    SECURITY_STATUS ssResult;
        
    // Prompt for the credentials.
    INET_ASSERT(_pvContext);
    _cbContext = OUTPUT_BUFFER_LEN;

    DWORD sf;
    InitSecurityBuffers((LPSTR) _pvContext, _cbContext, &sf, ISC_MODE_UI);

    _SecBuffIn[HWND_IDX].pvBuffer = &hWnd;
    _SecBuffIn[HWND_IDX].cbBuffer = sizeof(HWND);

    ssResult = (*(g_pFuncTbl->InitializeSecurityContextA))(&g_hCred, &_hCtxt, NULL, sf, 
        0, 0, &_SecBuffInDesc, 0, &_hCtxt, &_SecBuffOutDesc, NULL, NULL);

    _cbContext = _SecBuffOutDesc.pBuffers[0].cbBuffer;    

    if (ssResult == SEC_E_NO_CREDENTIALS)
        return ERROR_CANCELLED;

    return (DWORD) ssResult;
}


/*---------------------------------------------------------------------------
    Destructor
---------------------------------------------------------------------------*/
DIGEST_CTX::~DIGEST_CTX()
{
    if (_szAlloc)
        delete _szAlloc;

    if (_pvContext)
        delete _pvContext;

    if (_szRequestUri)
        delete _szRequestUri;

    Logoff();
    g_pFuncTbl = NULL;

    if (_pszVerb)
        delete [] _pszVerb;
}


/*---------------------------------------------------------------------------
    PreAuthUser
---------------------------------------------------------------------------*/
DWORD DIGEST_CTX::PreAuthUser(OUT LPSTR pBuff, IN OUT LPDWORD pcbBuff)
{
    SECURITY_STATUS ssResult = SEC_E_OK;
    INET_ASSERT(_pSPMData == _pCreds->pSPM);

    if (AuthLock())
    {
        // If a response has been generated copy into output buffer.
        if (_cbContext)
        {
            memcpy(pBuff, _pvContext, _cbContext);
            *pcbBuff = _cbContext;
        }
        // Otherwise attempt to preauthenticate.
        else
        {
            // Call into the SSPI package.
            DWORD sf;
            InitSecurityBuffers(pBuff, *pcbBuff, &sf, ISC_MODE_PREAUTH);

            ssResult = (*(g_pFuncTbl->InitializeSecurityContext))(&g_hCred, NULL, NULL, sf, 
                0, 0, &_SecBuffInDesc, 0, &_hCtxt, &_SecBuffOutDesc, NULL, NULL);

            *pcbBuff = _SecBuffOut[0].cbBuffer;
        }

        AuthUnlock();
    }
            
    return (DWORD) ssResult;
}

/*---------------------------------------------------------------------------
    UpdateFromHeaders
---------------------------------------------------------------------------*/
DWORD DIGEST_CTX::UpdateFromHeaders(HTTP_REQUEST_HANDLE_OBJECT *pRequest, BOOL fIsProxy)
{
    if (!AuthLock())
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    DWORD dwError, dwAuthIdx;
    LPSTR szRealm; 
    DWORD cbRealm;
    
    // Get the associated header.
    if ((dwError = FindHdrIdxFromScheme(&dwAuthIdx)) != ERROR_SUCCESS)
        goto exit;

    // If this auth ctx does not have Creds then it has been
    // just been constructed in response to a 401.
    if (!_pCreds)
    {
        // Get any realm.
        dwError = GetAuthHeaderData(pRequest, fIsProxy, "Realm", 
            &szRealm, &cbRealm, ALLOCATE_BUFFER, dwAuthIdx);

        _pCreds = CreateCreds(pRequest, fIsProxy, _pSPMData, szRealm);
        
        if (pRequest->_pszRealm)
        {
            FREE_MEMORY(pRequest->_pszRealm);
        }
        pRequest->_pszRealm = szRealm;
        szRealm = NULL;

        if (_pCreds)
        {
            INET_ASSERT(_pCreds->pSPM == _pSPMData);
        }
        else
        {
            dwError = ERROR_WINHTTP_INTERNAL_ERROR;
            goto exit;
        }
    }

    // Updating the buffer - delete old one if necessary.
    if (_szAlloc)
    {
        delete _szAlloc;
        _szAlloc = _szData = NULL;
        _cbData = 0;
    }

    // Get the entire authentication header.
    dwError = GetAuthHeaderData(pRequest, fIsProxy, NULL,
        &_szAlloc, &_cbData, ALLOCATE_BUFFER, dwAuthIdx);
    
    if (dwError != ERROR_SUCCESS)
    {
        goto exit;
    }

    // Point just past scheme
    _szData = _szAlloc;
    while (*_szData != ' ')
    {
        _szData++;
        _cbData--;
    }

    // The request will be retried.
    dwError = ERROR_SUCCESS;

exit:
    AuthUnlock();
    return dwError;
}



/*---------------------------------------------------------------------------
    PostAuthUser
---------------------------------------------------------------------------*/
DWORD DIGEST_CTX::PostAuthUser()
{
    if (!AuthLock())
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    INET_ASSERT(_pSPMData == _pCreds->pSPM);

    DWORD dwError;
    SECURITY_STATUS ssResult;

    // Allocate an output buffer if not done so already.
    if (!_pvContext)
    {
        _pvContext = New CHAR[OUTPUT_BUFFER_LEN];
        if (!_pvContext)
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }
    }

    _cbContext = OUTPUT_BUFFER_LEN;


    if (_nRetries++ < MAX_SILENT_RETRIES)
    {
        // If we pre-authenticated, treat as second
        // or subsequent attempt. We depend on the
        // server correctly sending stale=FALSE (or no stale)
        // if the credentials sent during pre-auth were bad.
        // In this case the digest pkg will return SEC_E_NO_CREDENTIALS
        // and we will prompt for credentials.
        // BUGBUG - Use ApplyControlToken
        if (_nRetries == 1 && _pRequest->GetCreds())
        {
            // Increment num of retries to 2
            _nRetries++;

            // The dwLower member has to have the correct value
            // so that secur32.dll can route to correct provider.
            _hCtxt.dwLower = g_hCred.dwLower;
        }

        // Call into the SSPI package.

        DWORD sf;
        InitSecurityBuffers((LPSTR) _pvContext, _cbContext, &sf, ISC_MODE_AUTH);
        ssResult = (*(g_pFuncTbl->InitializeSecurityContext))
            (&g_hCred, (_nRetries == 1 ? NULL : &_hCtxt), NULL, sf, 
            0, 0, &_SecBuffInDesc, 0, &_hCtxt, &_SecBuffOutDesc, NULL, NULL);
        _cbContext = _SecBuffOutDesc.pBuffers[0].cbBuffer;
        
        switch(ssResult)
        {
            case SEC_E_OK:
            {
                dwError = ERROR_WINHTTP_FORCE_RETRY;
                break;
            }
            case SEC_E_NO_CREDENTIALS:
            {
                dwError = ERROR_WINHTTP_INCORRECT_PASSWORD;
                break;
            }
            default:
                dwError = ERROR_WINHTTP_LOGIN_FAILURE;
        }
    }
    else
    {
        _cbContext = 0;
        _nRetries = 0;
        dwError = ERROR_WINHTTP_INCORRECT_PASSWORD;
    }

exit:
    _pRequest->SetCreds(NULL);
    AuthUnlock();
    return dwError;
}

/*---------------------------------------------------------------------------
    Flush creds
---------------------------------------------------------------------------*/
VOID DIGEST_CTX::FlushCreds()
{
    DWORD ssResult;
    if (g_pFuncTbl)
    {
        DWORD sf = ISC_REQ_NULL_SESSION;
        ssResult = (*(g_pFuncTbl->InitializeSecurityContext))(&g_hCred, NULL, NULL, sf, 
            0, 0, NULL, 0, NULL, NULL, NULL, NULL);
    }
}

/*---------------------------------------------------------------------------
    Logoff
---------------------------------------------------------------------------*/
VOID DIGEST_CTX::Logoff()
{
    DWORD ssResult;
    if (g_pFuncTbl)
    {
        ssResult = (*(g_pFuncTbl->FreeCredentialsHandle))(&g_hCred);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5.1\auth\uudec.c ===
#include <stdio.h>
#include "htuu.h"

int main (int argc, char **argv)
{
    char outbuf[500];
    char *pOut = outbuf;
    int cbOut = (strlen(argv[1]) * 3) / 4;

    if (argc != 2)
    {
        fprintf (stderr, "usage: uudec <base64-string>\n");
        exit (1);
    }
    
    HTUU_decode (argv[1], pOut, sizeof(outbuf));

    while (cbOut--)
    {
        printf ("%02x %c\n", (unsigned char) *pOut, *pOut);
        pOut++;
    }
        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5.1\auth\passport.cxx ===
#include <wininetp.h>
#include <urlmon.h>
#include <splugin.hxx>
#include "htuu.h"

/*---------------------------------------------------------------------------
PASSPORT_CTX
---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------
    Constructor
---------------------------------------------------------------------------*/
PASSPORT_CTX::PASSPORT_CTX(HTTP_REQUEST_HANDLE_OBJECT *pRequest, BOOL fIsProxy, 
                    SPMData* pSPM, AUTH_CREDS* pCreds)
    : AUTHCTX(pSPM, pCreds)
{
    _fIsProxy = fIsProxy;

    _pRequest = pRequest;
    
    m_hLogon = NULL;

    m_pNewThreadInfo = NULL;
    m_pwszPartnerInfo = NULL;
    m_lpszRetUrl = NULL;

    m_wRealm[0] = '\0';
    m_pszFromPP = NULL;

    m_fPreauthFailed = FALSE;
    m_fAnonymous = TRUE;

    m_AuthComplete = FALSE;

    m_pszCbUrl = NULL;
    m_pszCbTxt = NULL;

    ::MultiByteToWideChar(CP_ACP, 0, _pRequest->GetServerName(), -1, m_wTarget, MAX_AUTH_TARGET_LEN);
}

BOOL PASSPORT_CTX::Init(void)
{
    m_pNewThreadInfo = ::InternetCreateThreadInfo(FALSE);
    if (m_pNewThreadInfo == NULL)
    {
        return FALSE;
    }

    LPINTERNET_THREAD_INFO pCurrentThreadInfo = ::InternetGetThreadInfo();
    m_pNewThreadInfo->ThreadId = ::GetCurrentThreadId();
    ::InternetSetThreadInfo(m_pNewThreadInfo);
    
    m_pInternet = GetRootHandle (_pRequest);
    
    if (!m_pInternet->GetPPContext())
    {
        PWSTR pProxyUser = NULL;
        PWSTR pProxyPass = NULL;

        if (_pRequest->_pTweenerProxyCreds)
        {
            if (_pRequest->_pTweenerProxyCreds->lpszUser)
            {
                DWORD dwProxyUserLength = strlen(_pRequest->_pTweenerProxyCreds->lpszUser);
                pProxyUser = new WCHAR[dwProxyUserLength+1];
                if (pProxyUser)
                {
                    ::MultiByteToWideChar(CP_ACP, 0, _pRequest->_pTweenerProxyCreds->lpszUser, -1, pProxyUser, dwProxyUserLength+1); 
                }
            }

            if (_pRequest->_pTweenerProxyCreds->lpszPass)
            {
                DWORD dwProxyPassLength = strlen(_pRequest->_pTweenerProxyCreds->lpszPass);
                pProxyPass = new WCHAR[dwProxyPassLength+1];
                if (pProxyPass)
                {
                    ::MultiByteToWideChar(CP_ACP, 0, _pRequest->_pTweenerProxyCreds->lpszPass, -1, pProxyPass, dwProxyPassLength+1); 
                }
            }
        }

        PP_CONTEXT hPP = ::PP_InitContext(L"WinHttp.Dll", m_pInternet->GetPseudoHandle(), pProxyUser, pProxyPass);
        m_pInternet->SetPPContext(hPP);
        hPP = NULL;
        
        pProxyUser = NULL;
        pProxyPass = NULL;

    }
    
    ::InternetSetThreadInfo(pCurrentThreadInfo);

    if (!m_pInternet->GetPPContext())
    {
        return FALSE;
    }
    
    return TRUE;
}
/*---------------------------------------------------------------------------
    Destructor
---------------------------------------------------------------------------*/
PASSPORT_CTX::~PASSPORT_CTX()
{
    LPINTERNET_THREAD_INFO pCurrentThreadInfo = ::InternetGetThreadInfo();
    
    m_pNewThreadInfo->ThreadId = ::GetCurrentThreadId();
    ::InternetSetThreadInfo(m_pNewThreadInfo);
    
    if (m_hLogon)
    {
        ::PP_FreeLogonContext(m_hLogon);
        m_hLogon = NULL;
    }

    ::InternetSetThreadInfo(pCurrentThreadInfo);

    if (m_pNewThreadInfo)
    {
        ::InternetFreeThreadInfo(m_pNewThreadInfo);
    }

    if (m_pwszPartnerInfo)
    {
        delete [] m_pwszPartnerInfo;
    }

    if (m_lpszRetUrl)
    {
        delete [] m_lpszRetUrl;
    }

    if (m_pszFromPP)
    {
        delete [] m_pszFromPP;
    }

    if (m_pszCbUrl != NULL)
    {
        delete [] m_pszCbUrl;
    }

    if (m_pszCbTxt != NULL)
    {
        delete [] m_pszCbTxt;
    }
}

BOOL PASSPORT_CTX::CallbackRegistered(void)
{
    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo)
    {
        WINHTTP_STATUS_CALLBACK appCallback = 
            ((INTERNET_HANDLE_BASE *)lpThreadInfo->hObjectMapped)->GetStatusCallback();

        if (appCallback != NULL) 
        {
            return TRUE;
        }
    }

    return FALSE;
}


DWORD PASSPORT_CTX::HandleSuccessfulLogon(
    LPWSTR*  ppwszFromPP,
    PDWORD   pdwFromPP,
    BOOL     fPreAuth
    )
{
    // biaow-todo: I am betting the RU DWORD UrlLength = 1024;
    LPWSTR pwszUrl = (LPWSTR) ALLOCATE_FIXED_MEMORY(1024 * sizeof(WCHAR));
    DWORD dwwUrlLength = 1024;//             won't be too long, but I could be wrong 
    LPSTR pszUrl = (LPSTR) ALLOCATE_FIXED_MEMORY(dwwUrlLength * sizeof(CHAR));
    BOOL fRetrySameUrl;
    DWORD dwRet = ERROR_SUCCESS;

    if (pwszUrl == NULL || pszUrl == NULL)
    {
        dwRet = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    *pdwFromPP = 0;

    if (::PP_GetAuthorizationInfo(m_hLogon,
                                  NULL, 
                                  pdwFromPP,
                                  &fRetrySameUrl,
                                  pwszUrl,
                                  &dwwUrlLength
                                  ) == FALSE)
    {
        *ppwszFromPP = new WCHAR[*pdwFromPP];
        if (*ppwszFromPP == NULL)
        {
            dwRet = ERROR_WINHTTP_LOGIN_FAILURE;
            goto exit;
        }
    }
    else
    {
        INET_ASSERT(TRUE); // this shouldn't happen
    }

    if (::PP_GetAuthorizationInfo(m_hLogon,
                                  *ppwszFromPP, 
                                  pdwFromPP,
                                  &fRetrySameUrl,
                                  pwszUrl,
                                  &dwwUrlLength
                                  ) == FALSE)
    {
        INET_ASSERT(TRUE); // this shouldn't happen
        dwRet = ERROR_WINHTTP_LOGIN_FAILURE;
        goto exit;
    }

    // save the DA Host name for Logout security check
    /*
    WCHAR wszDAHost[256];
    DWORD dwHostLen = ARRAY_ELEMENTS(wszDAHost);
    if (::PP_GetLogonHost(m_hLogon, wszDAHost, &dwHostLen) == TRUE)
    {
        ::WideCharToMultiByte(CP_ACP, 0, wszDAHost, -1, g_szPassportDAHost, 256, NULL, NULL);
    }
    */

    if (!fRetrySameUrl)
    {
        if (_pRequest->GetMethodType() == HTTP_METHOD_TYPE_GET)
        {
            // DA wanted us to GET to a new Url
            ::WideCharToMultiByte(CP_ACP, 0, pwszUrl, -1, pszUrl, 1024, NULL, NULL);
        }
        else
        {
            fRetrySameUrl = TRUE; // *** WinHttp currently supports retry custom verb to same URL only ***
        }
    }
    
    if (fPreAuth)
    {
        // We are sending, in the context of AuthOnRequest.

        if (fRetrySameUrl)
        {
            // DA told us to keep Verb & Url, so there is nothing more needs to be done
            goto exit;
        }
        
        // Regardless whether we are asked to handle redirect, we'll need to fake
        // that a 302 just came in. 
        
        // biaow-todo: this is causing problem for QueryHeaders(StatusCode). I don't know why yet...
        /*
        _pRequest->AddInternalResponseHeader(HTTP_QUERY_STATUS_TEXT, // use non-standard index, since we never query this normally
                                  "HTTP/1.0 302 Object Moved",
                                  strlen("HTTP/1.0 302 Object Moved")
                                  );
        _pRequest->AddInternalResponseHeader(HTTP_QUERY_LOCATION, 
                                             pszUrl, 
                                             strlen(pszUrl));
        */


        //
        //  todo:  if REDIRECT_POLICY is POLICY_DISALLOW_HTTPS_TO_HTTP, do not allow
        //the passport server to redirect to an HTTP site if the original request
        //was to an HTTPS site
        //
        if (_pRequest->GetDwordOption(WINHTTP_OPTION_REDIRECT_POLICY) == WINHTTP_OPTION_REDIRECT_POLICY_NEVER)
        {
            if (!CallbackRegistered())
            {
                _pRequest->SetPPAbort(TRUE);
                dwRet = ERROR_WINHTTP_LOGIN_FAILURE;
                goto exit;
            }
        }
        
        ::InternetIndicateStatusString(WINHTTP_CALLBACK_STATUS_REDIRECT, pszUrl);
    }
    else
    {
        // We are receiving a 302, in the context of AuthOnResponse.
        
        // Here we need to re-play the request to lpszRetUrl. One way to 
        // achieve this is returning ERROR_INTERNET_FORCE_RETRY. But before
        // that, we'll need to remember the lpszRetUrl.

        // *NOTE* This is in effective an 401. To prevent the send path from
        // following the 302 Location: header, caller must set the status code
        // to 401.

        if (!fRetrySameUrl)
        {
            //
            //  todo:  if REDIRECT_POLICY is POLICY_DISALLOW_HTTPS_TO_HTTP, do not allow
            //the passport server to redirect to an HTTP site if the original request
            //was to an HTTPS site
            //
            if (_pRequest->GetDwordOption(WINHTTP_OPTION_REDIRECT_POLICY) == WINHTTP_OPTION_REDIRECT_POLICY_NEVER)
            {
                if (!CallbackRegistered())
                {
                    dwRet = ERROR_WINHTTP_LOGIN_FAILURE;
                    goto exit;
                }

                ::InternetIndicateStatusString(WINHTTP_CALLBACK_STATUS_REDIRECT, pszUrl);
            }
        }
        
        dwRet = ERROR_WINHTTP_RESEND_REQUEST;
    }

    PCSTR lpszRetUrl = NULL;

    if (fRetrySameUrl)
    {
        lpszRetUrl = _pRequest->GetURL();
    }
    else
    {
        lpszRetUrl = pszUrl;
    }

    if (m_lpszRetUrl)
    {
        delete [] m_lpszRetUrl;
    }

    m_lpszRetUrl = new CHAR[strlen(lpszRetUrl) + 1];
    if (m_lpszRetUrl)
    {
        strcpy(m_lpszRetUrl, lpszRetUrl);
    }

exit:

    if (pwszUrl)
    {
        FREE_MEMORY(pwszUrl);
    }
    if (pszUrl)
    {
        FREE_MEMORY(pszUrl);
    }
    
    return dwRet;
}

DWORD PASSPORT_CTX::SetCreds(BOOL* pfCredSet)
{
    DWORD dwError = ERROR_SUCCESS;
    BOOL fUseDefaultCreds;
    LPWSTR pwszUser = NULL;
    LPWSTR pwszPass = NULL;
    
    if (_pCreds->lpszUser && _pCreds->lpszPass) // both User and Pass are specified
    {
        fUseDefaultCreds = FALSE;
    }
    else if (!_pCreds->lpszUser && !_pCreds->lpszPass) // both User and Pass are NULL
    {
        fUseDefaultCreds = TRUE;
    }
    else
    {
        INET_ASSERT(TRUE); // this case should not happen
        fUseDefaultCreds = TRUE;
    }

    PSYSTEMTIME pCredTimestamp = NULL;
    SYSTEMTIME TimeCredsEntered;

    if (!fUseDefaultCreds)
    {
        pwszUser = (LPWSTR) ALLOCATE_FIXED_MEMORY((strlen(_pCreds->lpszUser) + 1) * sizeof(WCHAR));
        pwszPass = (LPWSTR) ALLOCATE_FIXED_MEMORY((strlen(_pCreds->lpszPass) + 1) * sizeof(WCHAR));

        if (pwszUser && pwszPass)
        {
            if( (0 == ::MultiByteToWideChar(CP_ACP, 0, _pCreds->lpszUser, -1, pwszUser, strlen(_pCreds->lpszUser) + 1))
                || (0 ==::MultiByteToWideChar(CP_ACP, 0, _pCreds->lpszPass, -1, pwszPass, strlen(_pCreds->lpszPass) + 1)))
            {
                pwszUser[0] = L'\0';
                pwszPass[0] = L'\0';
                dwError=GetLastError();
            }
        }
        else
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
        }

        pCredTimestamp = &TimeCredsEntered;
        ::GetSystemTime(pCredTimestamp); // time-stamp the creds
    }

    if (dwError == ERROR_SUCCESS)
    {
        if (pwszUser == NULL && pwszPass == NULL && m_pInternet->KeyringDisabled())
        {
            *pfCredSet = FALSE;
        }
        else
        {
            *pfCredSet = ::PP_SetCredentials(m_hLogon, m_wRealm, m_wTarget, pwszUser, pwszPass, pCredTimestamp);
        }
    }

    if (pwszUser)
    {
        memset( pwszUser, 0, sizeof(pwszUser[0])*wcslen(pwszUser));
        FREE_MEMORY(pwszUser);
    }
    if (pwszPass)
    {
        memset( pwszPass, 0, sizeof(pwszPass[0])*wcslen(pwszPass));
        FREE_MEMORY(pwszPass);
    }
    
    return dwError;
}

DWORD PASSPORT_CTX::ModifyRequestBasedOnRU(void)
{
    DWORD dwError = ERROR_SUCCESS;
    
    INTERNET_SCHEME schemeType;
    INTERNET_SCHEME currentSchemeType;
    INTERNET_PORT currentHostPort;
    LPSTR currentHostName;
    DWORD currentHostNameLength;

    INTERNET_PORT port = 0;
    LPSTR pszHostName;
    DWORD dwHostNameLength = 0;
    LPSTR pszUrlPath;
    DWORD dwUrlPathLength = 0;
    LPSTR extra;
    DWORD extraLength;

    dwError = CrackUrl(m_lpszRetUrl,
             0,
             FALSE, // don't escape URL-path
             &schemeType,
             NULL,  // scheme name, don't care
             NULL,
             &pszHostName,
             &dwHostNameLength,
             TRUE,
             &port,
             NULL,  // UserName, don't care
             NULL,  
             NULL,  // Password, don't care
             NULL,
             &pszUrlPath,
             &dwUrlPathLength,
             &extra,
             &extraLength,
             NULL);

    if (dwError != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    //
    // if there is an intra-page link on the redirected URL then get rid of it:
    // we don't send it to the server, and we have already indicated it to the
    // app
    //

    if (extraLength != 0) {

        INET_ASSERT(extra != NULL);
        INET_ASSERT(!IsBadWritePtr(extra, 1));

        if (*extra == '#') {
            *extra = '\0';
            // newUrlLength -= extraLength;
        } else {
            dwUrlPathLength += extraLength;
        }
    }

    if (port == INTERNET_INVALID_PORT_NUMBER) {
        port = (INTERNET_PORT)((schemeType == INTERNET_SCHEME_HTTPS)
            ? INTERNET_DEFAULT_HTTPS_PORT
            : INTERNET_DEFAULT_HTTP_PORT);
    }

    currentHostPort = _pRequest->GetHostPort();
    currentHostName = _pRequest->GetHostName(&currentHostNameLength);

    if (port != currentHostPort) {
        _pRequest->SetHostPort(port);
    }
    if ((dwHostNameLength != currentHostNameLength)
    || (strnicmp(pszHostName, currentHostName, dwHostNameLength) != 0)) {

        char hostValue[INTERNET_MAX_HOST_NAME_LENGTH + sizeof(":4294967295")];
        LPSTR hostValueStr;
        DWORD hostValueSize; 

        CHAR chBkChar = pszHostName[dwHostNameLength]; // save off char

        pszHostName[dwHostNameLength] = '\0';
        _pRequest->SetHostName(pszHostName);

        hostValueSize = dwHostNameLength;
        hostValueStr = pszHostName;            

        if ((port != INTERNET_DEFAULT_HTTP_PORT)
        &&  (port != INTERNET_DEFAULT_HTTPS_PORT)) {
            if (hostValueSize > INTERNET_MAX_HOST_NAME_LENGTH)
            {
                pszHostName[dwHostNameLength] = chBkChar; // put back char
                dwError = ERROR_INVALID_PARAMETER;
                goto cleanup;
            }
            hostValueSize = wsprintf(hostValue, "%s:%d", pszHostName, (port & 0xffff));
            hostValueStr = hostValue;
        }

        pszHostName[dwHostNameLength] = chBkChar; // put back char

        //
        // replace the "Host:" header
        //

        _pRequest->ReplaceRequestHeader(HTTP_QUERY_HOST,
                             hostValueStr,
                             hostValueSize,
                             0, // dwIndex
                             ADD_HEADER
                             );

        //
        // and get the corresponding server info, resolving the name if
        // required
        //

        // _pRequest->SetServerInfo(FALSE);

        //
        // Since we are redirecting to a different host, force an update of the origin
        // server.  Otherwise, we will still pick up the proxy info of the first server.
        //
        
        // todo:
        // _pRequest->SetOriginServer(TRUE);
    }

    currentSchemeType = ((WINHTTP_FLAG_SECURE & _pRequest->GetOpenFlags()) ?
                            INTERNET_SCHEME_HTTPS :
                            INTERNET_SCHEME_HTTP);

    if ( currentSchemeType != schemeType )
    {
        DWORD OpenFlags = _pRequest->GetOpenFlags();

        // Switched From HTTPS to HTTP
        if ( currentSchemeType == INTERNET_SCHEME_HTTPS )
        {
            INET_ASSERT(schemeType != INTERNET_SCHEME_HTTPS );

            OpenFlags &= ~(WINHTTP_FLAG_SECURE);
        }

        // Switched From HTTP to HTTPS
        else if ( schemeType == INTERNET_SCHEME_HTTPS )
        {
            INET_ASSERT(currentSchemeType == INTERNET_SCHEME_HTTP );

            OpenFlags |= (WINHTTP_FLAG_SECURE);
        }

        _pRequest->SetOpenFlags(OpenFlags);
        _pRequest->SetSchemeType(schemeType);

    }

    _pRequest->SetURL(m_lpszRetUrl);

    if (_pRequest->IsRequestUsingProxy())
    {
        _pRequest->ModifyRequest(_pRequest->GetMethodType(),
                                 m_lpszRetUrl,
                                 strlen(m_lpszRetUrl),
                                 NULL,
                                 0);
    }
    else
    {
        _pRequest->ModifyRequest(_pRequest->GetMethodType(),
                                 pszUrlPath, // m_lpszRetUrl,
                                 strlen(pszUrlPath),//strlen(m_lpszRetUrl),
                                 NULL,
                                 0);
    }

cleanup:

    return dwError;
}


/*---------------------------------------------------------------------------
    PreAuthUser
---------------------------------------------------------------------------*/
DWORD PASSPORT_CTX::PreAuthUser(IN LPSTR pBuf, IN OUT LPDWORD pcbBuf)
{
    DEBUG_ENTER ((
		DBG_HTTP,
        Dword,
        "PASSPORT_CTX::PreAuthUser",
        "this=%#x pBuf=%#x pcbBuf=%#x {%d}",
        this,
        pBuf,
        pcbBuf,
        *pcbBuf
        ));

    DWORD dwError = ERROR_SUCCESS;
    LPWSTR pwszFromPP = NULL;

    // Prefix the header value with the auth type.
    const static BYTE szPassport[] = "Passport1.4 ";
    #define PASSPORT_LEN sizeof(szPassport)-1
    
    if (m_pszFromPP == NULL) 
    {
        if (m_hLogon == NULL)
        {
            dwError = ERROR_WINHTTP_INTERNAL_ERROR;
            goto cleanup;
        }

        DWORD dwFromPPLen = 0;
        BOOL fCredSet;
        dwError = SetCreds(&fCredSet);
        if (dwError != ERROR_SUCCESS)
        {
            goto cleanup;
        }

        LPINTERNET_THREAD_INFO pCurrentThreadInfo = ::InternetGetThreadInfo();

        m_pNewThreadInfo->ThreadId = ::GetCurrentThreadId();
        ::InternetSetThreadInfo(m_pNewThreadInfo);


        DWORD dwLogonStatus = ::PP_Logon(m_hLogon,
                                         FALSE,
                                         0,
                                         NULL,
                                         0);

        ::InternetSetThreadInfo(pCurrentThreadInfo);

        if (dwLogonStatus != PP_LOGON_SUCCESS)
        {
            if (dwLogonStatus == PP_LOGON_FAILED)
            {
                m_fPreauthFailed = TRUE;
            }
            
            dwError = ERROR_WINHTTP_INTERNAL_ERROR; // need to double check this return error
            goto cleanup;
        }

        dwError = HandleSuccessfulLogon(&pwszFromPP, &dwFromPPLen, TRUE);

        if (dwError == ERROR_WINHTTP_LOGIN_FAILURE)
        {
            goto cleanup;
        }
        
        m_pszFromPP = new CHAR [dwFromPPLen];
        if (m_pszFromPP == NULL)
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        
        ::WideCharToMultiByte(CP_ACP, 0, pwszFromPP, -1, m_pszFromPP, dwFromPPLen, NULL, NULL);
    }

    // check to see if we need to update url

    if (m_lpszRetUrl)
    {
        dwError = ModifyRequestBasedOnRU();

        if (dwError != ERROR_SUCCESS)
        {
            // delete [] m_lpszRetUrl;
            // m_lpszRetUrl = NULL;
            
            goto cleanup;
        }

        // delete [] m_lpszRetUrl;
        // m_lpszRetUrl = NULL;
    }

    // Ticket and profile is already present
    
    // put in the header
    memcpy (pBuf, szPassport, PASSPORT_LEN);
    pBuf += PASSPORT_LEN;
    
    // append the ticket
    strcpy(pBuf, m_pszFromPP);
    *pcbBuf = (DWORD)(PASSPORT_LEN + strlen(m_pszFromPP));

    m_AuthComplete = TRUE;

cleanup:
    if (pwszFromPP)
        delete [] pwszFromPP;

    DEBUG_LEAVE(dwError);
    return dwError;
}

/*---------------------------------------------------------------------------
    UpdateFromHeaders
---------------------------------------------------------------------------*/
DWORD PASSPORT_CTX::UpdateFromHeaders(HTTP_REQUEST_HANDLE_OBJECT *pRequest, BOOL fIsProxy)
{
    DEBUG_ENTER ((
		DBG_HTTP,
        Dword,
        "PASSPORT_CTX::UpdateFromHeaders", 
        "this=%#x request=%#x isproxy=%B",
        this,
        pRequest,
        fIsProxy
        ));

    DWORD dwAuthIdx, cbChallenge, dwError;
    LPSTR szChallenge = NULL;

    // Get the associated header.
    if ((dwError = FindHdrIdxFromScheme(&dwAuthIdx)) != ERROR_SUCCESS)
        goto exit;

    if (m_AuthComplete)
    {
        _pRequest->SetStatusCode(401);  // this is needed to prevent send code from tracing Location: header
        dwError = ERROR_WINHTTP_LOGIN_FAILURE;
        goto exit;
    }

    // Get the complete auth header.
    dwError = GetAuthHeaderData(pRequest, fIsProxy, NULL, 
        &szChallenge, &cbChallenge, ALLOCATE_BUFFER, dwAuthIdx);

    if (dwError != ERROR_SUCCESS)
    {
        szChallenge = NULL;
        goto exit;
    }

    if (!_pCreds)
    {
        _pCreds = CreateCreds(pRequest, fIsProxy, _pSPMData, NULL);
        if (!_pCreds)
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }
    }
    
    if (m_pwszPartnerInfo)
    {
        delete [] m_pwszPartnerInfo;
    }

    {
        LPSTR lpszVerb;
        DWORD dwVerbLength;
        lpszVerb = _pRequest->_RequestHeaders.GetVerb(&dwVerbLength);
        #define MAX_VERB_LENGTH 16
        CHAR szOrgVerb[MAX_VERB_LENGTH] = {0};
        if (dwVerbLength > MAX_VERB_LENGTH - 1)
        {
            goto exit;
        }
        strncpy(szOrgVerb, lpszVerb, dwVerbLength+1);
        PCSTR pszOrgUrl = _pRequest->GetURL();

        const LPWSTR pwszOrgVerbAttr = L",OrgVerb=";
        const LPWSTR pwszOrgUrlAttr =  L",OrgUrl=";

        DWORD dwPartnerInfoLength = cbChallenge 
                                    +::wcslen(pwszOrgVerbAttr)
                                    +::strlen(szOrgVerb)
                                    +::wcslen(pwszOrgUrlAttr)
                                    +::strlen(pszOrgUrl)
                                    + 1; // NULL terminator
        
        DWORD dwSize = 0;
        PWSTR pwszPartnerInfo = NULL;

        m_pwszPartnerInfo = new WCHAR[dwPartnerInfoLength];
        if (m_pwszPartnerInfo == NULL)
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }

        pwszPartnerInfo = m_pwszPartnerInfo;

        dwSize = ::MultiByteToWideChar(CP_ACP, 0, szChallenge, -1, pwszPartnerInfo, dwPartnerInfoLength) - 1;
        ::wcscat(pwszPartnerInfo, pwszOrgVerbAttr);
        pwszPartnerInfo += (dwSize + wcslen(pwszOrgVerbAttr));
        dwPartnerInfoLength -= (dwSize + wcslen(pwszOrgVerbAttr));
        dwSize = ::MultiByteToWideChar(CP_ACP, 0, szOrgVerb, -1, pwszPartnerInfo, dwPartnerInfoLength) - 1;
        ::wcscat(pwszPartnerInfo, pwszOrgUrlAttr);
        pwszPartnerInfo += (dwSize + wcslen(pwszOrgUrlAttr));
        dwPartnerInfoLength -= (dwSize + wcslen(pwszOrgUrlAttr));
        dwSize = ::MultiByteToWideChar(CP_ACP, 0, pszOrgUrl, -1, pwszPartnerInfo, dwPartnerInfoLength) - 1;

        dwError = ERROR_SUCCESS;
    }

exit:

    if (szChallenge)
        delete []szChallenge;

    DEBUG_LEAVE(dwError);
    return dwError;
}

BOOL PASSPORT_CTX::InitLogonContext(void)
{
    // set up the thread context before calling the Passport auth library
    
    LPINTERNET_THREAD_INFO pCurrentThreadInfo = ::InternetGetThreadInfo();
    m_pNewThreadInfo->ThreadId = ::GetCurrentThreadId();
    ::InternetSetThreadInfo(m_pNewThreadInfo);

    if (!m_hLogon)
    {
        INET_ASSERT(m_pInternet->GetPPContext()); // must have been initialized in the Init() call

        m_hLogon = ::PP_InitLogonContext(
                                        m_pInternet->GetPPContext(),
                                        m_pwszPartnerInfo,
                                        (_pRequest->GetOpenFlags() & INTERNET_FLAG_NO_COOKIES),
                                        NULL,
                                        NULL
                                        );
    }

    // restore the WinHttp thread context
    ::InternetSetThreadInfo(pCurrentThreadInfo);

    PCWSTR pwszRealm = ::wcsstr(m_pwszPartnerInfo, L"srealm");
    if (pwszRealm)
    {
        pwszRealm += ::wcslen(L"srealm");
        if (*pwszRealm == L'=')
        {
            pwszRealm++;
            DWORD i = 0;
            while (*pwszRealm != 0 && *pwszRealm != L',' && i < MAX_AUTH_REALM_LEN-1)
            {
                m_wRealm[i++] = *pwszRealm++;
            }

            m_wRealm[i] = 0; // null-terminate it
        }
    }

    if (!m_wRealm[0])
    {
        DWORD dwRealmLen = MAX_AUTH_REALM_LEN;
        PP_GetRealm(m_pInternet->GetPPContext(), m_wRealm, &dwRealmLen);
    }
    
    return m_hLogon != NULL;
}

/*---------------------------------------------------------------------------
    PostAuthUser
---------------------------------------------------------------------------*/
DWORD PASSPORT_CTX::PostAuthUser()
{
    DEBUG_ENTER ((
                 DBG_HTTP,
                 Dword,
                 "PASSPORT_CTX::PostAuthUser",
                 "this=%#x",
                 this
                 ));

    DWORD dwRet = ERROR_SUCCESS;

    if (InitLogonContext() == FALSE)
    {
        dwRet = ERROR_WINHTTP_LOGIN_FAILURE;
        goto exit;
    }

    BOOL fCredSet;
    dwRet = SetCreds(&fCredSet);
    if (dwRet != ERROR_SUCCESS)
    {
        goto exit;
    }
        
    // Ok, Let's give it a try

    LPINTERNET_THREAD_INFO pCurrentThreadInfo = ::InternetGetThreadInfo();
    m_pNewThreadInfo->ThreadId = ::GetCurrentThreadId();
    ::InternetSetThreadInfo(m_pNewThreadInfo);
    
    DWORD dwLogonStatus = ::PP_Logon(m_hLogon, 
                                     m_fAnonymous,                             
                                     0, 
                                     NULL, 
                                     0);

    // restore the WinHttp thread context
    ::InternetSetThreadInfo(pCurrentThreadInfo);

    if (dwLogonStatus == PP_LOGON_REQUIRED)
    {
        // no creds specified, we are required to sign on.
        
        // change from 302 to 401
        _pRequest->ReplaceResponseHeader(HTTP_QUERY_STATUS_CODE,
                                        "401", strlen("401"),
                                        0, HTTP_ADDREQ_FLAG_REPLACE);

        // biaow-todo: 1) nice to replace the status text as well; weird to have "HTTP/1.1 401 object moved"
        // for example 2) remove the Location: header

        BOOL fPrompt;
        DWORD dwCbUrlSize = 0;
        DWORD dwCbTxtSize = 0;
        ::PP_GetChallengeInfo(m_hLogon, 
                              &fPrompt, NULL, &dwCbUrlSize, NULL, &dwCbTxtSize, m_wRealm, MAX_AUTH_REALM_LEN);

        PWSTR pwszCbUrl = NULL;
        PWSTR pwszCbTxt = NULL;

        if (dwCbUrlSize)
        {
            pwszCbUrl = new WCHAR[dwCbUrlSize];    
        }

        if (dwCbTxtSize)
        {
            pwszCbTxt = new WCHAR[dwCbTxtSize];    
        }

        ::PP_GetChallengeInfo(m_hLogon, 
                              NULL, pwszCbUrl, &dwCbUrlSize, pwszCbTxt, &dwCbTxtSize, NULL, 0);

        if (pwszCbUrl)
        {
            m_pszCbUrl = new CHAR[wcslen(pwszCbUrl)+1];
            
            if (m_pszCbUrl)
            {
                ::WideCharToMultiByte(CP_ACP, 0, pwszCbUrl, -1, m_pszCbUrl, wcslen(pwszCbUrl)+1, NULL, NULL);
                UrlUnescapeA(m_pszCbUrl, NULL, NULL, URL_UNESCAPE_INPLACE);
            }
        }

        if (pwszCbTxt)
        {
            m_pszCbTxt = new CHAR[wcslen(pwszCbTxt)+1];
            if (m_pszCbTxt)
            {
                ::WideCharToMultiByte(CP_ACP, 0, pwszCbTxt, -1, m_pszCbTxt, wcslen(pwszCbTxt)+1, NULL, NULL);
                UrlUnescapeA(m_pszCbTxt, NULL, NULL, URL_UNESCAPE_INPLACE);
            }
        }

        delete [] pwszCbUrl;
        delete [] pwszCbTxt;

        if (fPrompt)
        {
            dwRet = ERROR_WINHTTP_INCORRECT_PASSWORD;
        }
        else
        {

            if (m_fAnonymous)
            {
                if (fCredSet)
                {
                    dwRet = ERROR_WINHTTP_RESEND_REQUEST;
                }
                else
                {
                    dwRet = ERROR_WINHTTP_INCORRECT_PASSWORD;
                }

                m_fAnonymous = FALSE;
            }
            else
            {
                dwRet = ERROR_WINHTTP_INCORRECT_PASSWORD;
            }
        }

        if (dwRet == ERROR_WINHTTP_INCORRECT_PASSWORD)
        {
            Transfer401ContentFromPP();
        }

        /*
        if (RetryLogon() == TRUE)
        {
            dwRet = ERROR_WINHTTP_RESEND_REQUEST;
        }
        else
        {
            dwRet = ERROR_WINHTTP_INCORRECT_PASSWORD;
        }
        */
    }
    else if (dwLogonStatus == PP_LOGON_SUCCESS)
    {
        // wow! we got in!!!

        DWORD dwFromPPLen = 0;
        LPWSTR pwszFromPP = NULL;

        dwRet = HandleSuccessfulLogon(&pwszFromPP, &dwFromPPLen, FALSE);
        if (dwRet != ERROR_WINHTTP_LOGIN_FAILURE)
        {
            if (m_pszFromPP)
            {
                delete [] m_pszFromPP;
            }

            m_pszFromPP = new CHAR [dwFromPPLen];
            if (m_pszFromPP)
            {
                ::WideCharToMultiByte(CP_ACP, 0, pwszFromPP, -1, m_pszFromPP, dwFromPPLen, NULL, NULL);
            }
        }
        if (pwszFromPP)
        {
            delete [] pwszFromPP;
        }

        m_fAnonymous = FALSE;
    }
    else
    {
        Transfer401ContentFromPP();

        dwRet = ERROR_WINHTTP_LOGIN_FAILURE;
    }


exit:
    _pRequest->SetStatusCode(401);  // this is needed to prevent send code from tracing Location: header

    DEBUG_LEAVE(dwRet);
    return dwRet;
}

BOOL PASSPORT_CTX::Transfer401ContentFromPP(void)
{
    DWORD ContentLength = 0;
    ::PP_GetChallengeContent(m_hLogon, 
                             NULL,
                             &ContentLength);
    if (ContentLength > 0)
    {
        LPBYTE pContent = (LPBYTE)ALLOCATE_FIXED_MEMORY(ContentLength);
        if (pContent == NULL)
        {
            return FALSE;
        }

        if (::PP_GetChallengeContent(m_hLogon, 
                             pContent,
                             &ContentLength) == TRUE)
        {
            BOOL fDrained;
            
            // play with socket mode to force DrainResponse to return synchronously

            ICSocket* pSocket = _pRequest->_Socket;
            if (pSocket)
            {
			    BOOL fSocketModeSet = FALSE;
                if (pSocket->IsNonBlocking())
                {
                    pSocket->SetNonBlockingMode(FALSE);
                    fSocketModeSet = TRUE;
                }

                INET_ASSERT(pSocket->IsNonBlocking() == FALSE);
                
                _pRequest->DrainResponse(&fDrained);

                if (fSocketModeSet)
                {
                    pSocket->SetNonBlockingMode(TRUE);
                }
            }

            _pRequest->_ResponseHeaders.FreeHeaders();
            _pRequest->FreeResponseBuffer();
            _pRequest->ResetResponseVariables();
            _pRequest->_ResponseHeaders.Initialize();

            // _pRequest->_dwCurrentStreamPosition = 0;

            _pRequest->CloneResponseBuffer(pContent, ContentLength);
        }
        FREE_MEMORY(pContent);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5.1\auth\htuu.c ===
/*
   This file was derived from the libwww code, version 2.15, from CERN.
   A number of modifications have been made by Spyglass.

   eric@spyglass.com

   This file was removed from LibWWW and placed into the
   Security Protocol Module.

   jeff@spyglass.com
 */

/* MODULE                           HTUU.c
   **           UUENCODE AND UUDECODE
   **
   ** ACKNOWLEDGEMENT:
   **   This code is taken from rpem distribution, and was originally
   **   written by Mark Riordan.
   **
   ** AUTHORS:
   **   MR  Mark Riordan    riordanmr@clvax1.cl.msu.edu
   **   AL  Ari Luotonen    luotonen@dxcern.cern.ch
   **
   ** HISTORY:
   **   Added as part of the WWW library and edited to conform
   **   with the WWW project coding standards by:   AL  5 Aug 1993
   **   Originally written by:              MR 12 Aug 1990
   **   Original header text:
   ** -------------------------------------------------------------
   **  File containing routines to convert a buffer
   **  of bytes to/from RFC 1113 printable encoding format.
   **
   **  This technique is similar to the familiar Unix uuencode
   **  format in that it maps 6 binary bits to one ASCII
   **  character (or more aptly, 3 binary bytes to 4 ASCII
   **  characters).  However, RFC 1113 does not use the same
   **  mapping to printable characters as uuencode.
   **
   **  Mark Riordan   12 August 1990 and 17 Feb 1991.
   **  This code is hereby placed in the public domain.
   ** -------------------------------------------------------------
   **
   ** BUGS:
   **
   **
 */


const static char six2pr[64] =
{
	'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
	'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
	'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
	'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
	'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'
};

static unsigned char pr2six[256];


/*--- function HTUU_encode -----------------------------------------------
 *
 *   Encode a single line of binary data to a standard format that
 *   uses only printing ASCII characters (but takes up 33% more bytes).
 *
 *    Entry    bufin    points to a buffer of bytes.  If nbytes is not
 *                      a multiple of three, then the byte just beyond
 *                      the last byte in the buffer must be 0.
 *             nbytes   is the number of bytes in that buffer.
 *                      This cannot be more than 48.
 *             bufcoded points to an output buffer.  Be sure that this
 *                      can hold at least 1 + (4*nbytes)/3 characters.
 *             outbufmax maximum size of the buffer bufcoded.
 *
 *    Exit     bufcoded contains the coded line.  The first 4*nbytes/3 bytes
 *                      contain printing ASCII characters representing
 *                      those binary bytes. This may include one or
 *                      two '=' characters used as padding at the end.
 *                      The last byte is a zero byte.
 *             Returns the number of ASCII characters in "bufcoded".
 */
int HTUU_encode(unsigned char *bufin, unsigned int nbytes, char *bufcoded,
                long outbufmax)
{
/* ENC is the basic 1 character encoding function to make a char printing */
#define ENC(c) six2pr[c]

	register char *outptr = bufcoded;
	unsigned int i;

	for (i = 0; i < nbytes; i += 3)
	{
        if ( (outptr - bufcoded + 4) > outbufmax )
            return (-1);

		*(outptr++) = ENC(*bufin >> 2);		/* c1 */
		*(outptr++) = ENC(((*bufin << 4) & 060) | ((bufin[1] >> 4) & 017));		/*c2 */
		*(outptr++) = ENC(((bufin[1] << 2) & 074) | ((bufin[2] >> 6) & 03));	/*c3 */
		*(outptr++) = ENC(bufin[2] & 077);	/* c4 */

		bufin += 3;
	}

	/* If nbytes was not a multiple of 3, then we have encoded too
	 * many characters.  Adjust appropriately.
	 */
	if (i == nbytes + 1)
	{
		/* There were only 2 bytes in that last group */
		outptr[-1] = '=';
	}
	else if (i == nbytes + 2)
	{
		/* There was only 1 byte in that last group */
		outptr[-1] = '=';
		outptr[-2] = '=';
	}

    if ( (outptr - bufcoded) + 1 < outbufmax )
    	*outptr = '\0';

	return ((int)(outptr - bufcoded));
}


/*--- function HTUU_decode ------------------------------------------------
 *
 *  Decode an ASCII-encoded buffer back to its original binary form.
 *
 *    Entry    bufcoded    points to a uuencoded string.  It is 
 *                         terminated by any character not in
 *                         the printable character table six2pr, but
 *                         leading whitespace is stripped.
 *             bufplain    points to the output buffer; must be big
 *                         enough to hold the decoded string (generally
 *                         shorter than the encoded string) plus
 *                         as many as two extra bytes used during
 *                         the decoding process.
 *             outbufsize  is the maximum number of bytes that
 *                         can fit in bufplain.
 *
 *    Exit     Returns the number of binary bytes decoded.
 *             bufplain    contains these bytes.
 */
int HTUU_decode(char *bufcoded, unsigned char *bufplain, int outbufsize)
{
/* single character decode */
#define DEC(c) pr2six[(int)c]
#define MAXVAL 63

	static int first = 1;

	int nbytesdecoded, j;
	register char *bufin = bufcoded;
	register unsigned char *bufout = bufplain;
	register int nprbytes;

	/* If this is the first call, initialize the mapping table.
	 * This code should work even on non-ASCII machines.
	 */
	if (first)
	{
		first = 0;
		for (j = 0; j < 256; j++)
			pr2six[j] = MAXVAL + 1;

		for (j = 0; j < 64; j++)
			pr2six[(int) six2pr[j]] = (unsigned char) j;
#if 0
		pr2six['A'] = 0;
		pr2six['B'] = 1;
		pr2six['C'] = 2;
		pr2six['D'] = 3;
		pr2six['E'] = 4;
		pr2six['F'] = 5;
		pr2six['G'] = 6;
		pr2six['H'] = 7;
		pr2six['I'] = 8;
		pr2six['J'] = 9;
		pr2six['K'] = 10;
		pr2six['L'] = 11;
		pr2six['M'] = 12;
		pr2six['N'] = 13;
		pr2six['O'] = 14;
		pr2six['P'] = 15;
		pr2six['Q'] = 16;
		pr2six['R'] = 17;
		pr2six['S'] = 18;
		pr2six['T'] = 19;
		pr2six['U'] = 20;
		pr2six['V'] = 21;
		pr2six['W'] = 22;
		pr2six['X'] = 23;
		pr2six['Y'] = 24;
		pr2six['Z'] = 25;
		pr2six['a'] = 26;
		pr2six['b'] = 27;
		pr2six['c'] = 28;
		pr2six['d'] = 29;
		pr2six['e'] = 30;
		pr2six['f'] = 31;
		pr2six['g'] = 32;
		pr2six['h'] = 33;
		pr2six['i'] = 34;
		pr2six['j'] = 35;
		pr2six['k'] = 36;
		pr2six['l'] = 37;
		pr2six['m'] = 38;
		pr2six['n'] = 39;
		pr2six['o'] = 40;
		pr2six['p'] = 41;
		pr2six['q'] = 42;
		pr2six['r'] = 43;
		pr2six['s'] = 44;
		pr2six['t'] = 45;
		pr2six['u'] = 46;
		pr2six['v'] = 47;
		pr2six['w'] = 48;
		pr2six['x'] = 49;
		pr2six['y'] = 50;
		pr2six['z'] = 51;
		pr2six['0'] = 52;
		pr2six['1'] = 53;
		pr2six['2'] = 54;
		pr2six['3'] = 55;
		pr2six['4'] = 56;
		pr2six['5'] = 57;
		pr2six['6'] = 58;
		pr2six['7'] = 59;
		pr2six['8'] = 60;
		pr2six['9'] = 61;
		pr2six['+'] = 62;
		pr2six['/'] = 63;
#endif
	}

	/* Strip leading whitespace. */

	while (*bufcoded == ' ' || *bufcoded == '\t')
		bufcoded++;

	/* Figure out how many characters are in the input buffer.
	 * If this would decode into more bytes than would fit into
	 * the output buffer, adjust the number of input bytes downwards.
	 */
	bufin = bufcoded;
	while (pr2six[(int) *(bufin++)] <= MAXVAL) ;
	nprbytes = (int)(bufin - bufcoded) - 1;
	nbytesdecoded = ((nprbytes + 3) / 4) * 3;
	if (nbytesdecoded > outbufsize)
	{
		nprbytes = (outbufsize * 4) / 3;
	}

	bufin = bufcoded;

	while (nprbytes > 0)
	{
		*(bufout++) = (unsigned char) (DEC(*bufin) << 2 | DEC(bufin[1]) >> 4);
		*(bufout++) = (unsigned char) (DEC(bufin[1]) << 4 | DEC(bufin[2]) >> 2);
		*(bufout++) = (unsigned char) (DEC(bufin[2]) << 6 | DEC(bufin[3]));
		bufin += 4;
		nprbytes -= 4;
	}

	if (nprbytes & 03)
	{
		if (pr2six[(int) bufin[-2]] > MAXVAL)
		{
			nbytesdecoded -= 2;
		}
		else
		{
			nbytesdecoded -= 1;
		}
	}

	return (nbytesdecoded);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5.1\auth\winctxt.h ===
#ifndef _WIN_SIC_CTXT_H_
#define _WIN_SIC_CTXT_H_

#define DEFAULT_SERVER_NAME_LEN		128

typedef struct _WINCONTEXT	{

    //
    //  Buffer for storing exchange blob returned by SSPI before 
    //  PreAuthenticateUser is called
    //
    char        *szOutBuffer;
    DWORD       cbOutBuffer;        // bytes associated with allocated szOutBuffer
	DWORD		dwOutBufferLength;

    char        *szInBuffer;
    DWORD       cbInBuffer;         // bytes associated with allocated szInBuffer
    PCHAR       pInBuffer;
	DWORD		dwInBufferLength;

	DWORD		dwCallId;

	DWORD		pkgId;

    CredHandle  Credential;     // SSPI credential handle for this connection
    PCredHandle pCredential;

	//
	// The SSPI Context Handle is stored here
	//
	CtxtHandle	SspContextHandle;
	PCtxtHandle	pSspContextHandle;  // before any ctxt is created, this is NULL

	LPSTR		lpszServerName;

	char		szServerName[DEFAULT_SERVER_NAME_LEN];

} WINCONTEXT, *PWINCONTEXT;

#endif  // _WIN_SIC_CTXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5.1\auth\sspi.cxx ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    sspi.c

Abstract:

    This file contains the implementation for SSPI Authentication 

    The following functions are exported by this module:

    UnloadAuthenticateUser
    AuthenticateUser
    PreAuthenticateUser
    AuthenticateUserUI

Author:

    Sudheer Koneru    (SudK)    Created    2/17/96

Revision History:


--*/

#include <wininetp.h>
#include "htuu.h"
//#include "msnspmh.h"
#ifdef DEBUG_WINSSPI
#include <stdio.h>
#endif

#include "auth.h"
//LPSTR StrChrA(LPCSTR lpStart, WORD wMatch); // from shlwapi.h

#include "sspspm.h"
#include "winctxt.h"

extern SspData  *g_pSspData;
LPVOID SSPI_InitGlobals(void);


DWORD g_cSspiContexts;

#define NAME_SEPERATOR  0x5c    // this is a backslash character which 
                                // seperates the domain name from user name

VOID
WINAPI
UnloadAuthenticateUser(LPVOID *lppvContext,
                       LPSTR lpszScheme,
                       LPSTR lpszHost)
{

    PWINCONTEXT        pWinContext = (PWINCONTEXT) (*lppvContext);

    UNREFERENCED_PARAMETER(lpszScheme);
    UNREFERENCED_PARAMETER(lpszHost);

    if (!SSPI_InitGlobals())
        return;

    if (*lppvContext == NULL)    {
        return;
    }

    if (pWinContext->pInBuffer != NULL && 
        pWinContext->pInBuffer != pWinContext->szInBuffer)
    {
        LocalFree (pWinContext->pInBuffer);
    }
    pWinContext->pInBuffer = NULL;
    pWinContext->dwInBufferLength = 0;

    // Free SSPI security context
    //
    if (pWinContext->pSspContextHandle != NULL)
        (*(g_pSspData->pFuncTbl->DeleteSecurityContext))(pWinContext->pSspContextHandle);

    //  Free SSPI credential handle
    //
    if (pWinContext->pCredential)
        (*(g_pSspData->pFuncTbl->FreeCredentialHandle))(pWinContext->pCredential);
    pWinContext->pCredential = NULL;
    pWinContext->pSspContextHandle = NULL;
 
    if ( (pWinContext->lpszServerName != NULL) &&
         (pWinContext->lpszServerName != pWinContext->szServerName) )
    {
        LocalFree(pWinContext->lpszServerName);
    }

    LocalFree(pWinContext);

    *lppvContext = NULL;

    AuthLock();
    g_cSspiContexts--;
    AuthUnlock();

    return;
}


//+---------------------------------------------------------------------------
//
//  Function:   SaveServerName
//
//  Synopsis:   This function saves the destination server name in this
//              connection context for AuthenticateUserUI
//
//  Arguments:  [lpszServerName] - points to the target server name
//              [pWinContext] - points to the connection context
//
//  Returns:    TRUE if server name is successfully saved in connection context.
//              Otherwise, FALSE is returned.
//
//----------------------------------------------------------------------------
BOOL
SaveServerName (
    LPSTR             lpszServerName,
    PWINCONTEXT        pWinContext
    )
{
    DWORD dwLen = lstrlen(lpszServerName);

    if (dwLen < DEFAULT_SERVER_NAME_LEN)
    {
        lstrcpy(pWinContext->szServerName, lpszServerName);
        pWinContext->lpszServerName = pWinContext->szServerName;
    }
    else
    {   //
        //  Server name is longer, need to allocate memory for the name
        //

        //  Free already allocated memory if any
        if (pWinContext->lpszServerName && 
            pWinContext->lpszServerName != pWinContext->szServerName)
        {
            LocalFree (pWinContext->lpszServerName);
        }

        pWinContext->lpszServerName = (char *) LocalAlloc(0, dwLen+1);

        if (pWinContext->lpszServerName == NULL)
            return FALSE;

        lstrcpy(pWinContext->lpszServerName, lpszServerName);
    }

    return TRUE;
}


//  Function bHasExtendedChars
//  Check if an ANSI string contains extended characters
BOOL bHasExtendedChars(char const *str)
{
    signed char const *p;

    for (p = (signed char const *)str; *p; p++)
        if ( *p < 0)
            return TRUE;

    return FALSE;
}


//+---------------------------------------------------------------------------
//
//  Function:   BuildNTLMauthData
//
//  Synopsis:   This function builds SEC_WINNT_AUTH_IDENTITY structure 
//              from the user name and password specified.  If domain name 
//              is not specified in the user name, the Domain field in 
//              the structure is set to NULL.  NOTE: This structure is 
//              specific to the NTLM SSPI package.
//              This function allocates a chunck of memory big enough for 
//              storing user name, domain, and password. Then setup 
//              pointers in pAuthData to use sections of this memory.
//
//  Arguments:  [pAuthData] - points to the SEC_WINNT_AUTH_IDENTITY structure
//              [lpszUserName] - points to the user name, which may also 
//                               include user's domain name.
//              [lpszPassword] - points to user's password
//
//  Returns:    TRUE if SEC_WINNT_AUTH_IDENTITY structure is successfully 
//              initialized and built.  Otherwise, FALSE is returned.
//
//----------------------------------------------------------------------------
BOOL
BuildNTLMauthData (
    PSEC_WINNT_AUTH_IDENTITY pAuthData, 
    LPTSTR       lpszUserName,
    LPTSTR       lpszPassword
    )
{
    DWORD  dwUserLen, dwDomainLen, dwPwdLen;
    LPTSTR pName;
    LPTSTR pDomain = NULL;
    BOOL bUnicodeAuth = FALSE;

    if ( bHasExtendedChars(lpszUserName) || bHasExtendedChars(lpszPassword))
        bUnicodeAuth = TRUE;

    pAuthData->Flags = bUnicodeAuth ? SEC_WINNT_AUTH_IDENTITY_UNICODE : SEC_WINNT_AUTH_IDENTITY_ANSI;

    //
    //  Check to see if domain name is specified in lpszUserName
    //
    pName = StrChrA (lpszUserName, NAME_SEPERATOR);

    if (pName)  // Domain name specified
    {
        // Make sure that we don't change the original string in lpszUserName 
        // because that it would be reused for other connections

        // Calculate no. of bytes in domain name
        dwDomainLen = (int)(pName - lpszUserName);

        // Convert to no. of characters
        pAuthData->DomainLength = dwDomainLen / sizeof(TCHAR);

        pDomain = lpszUserName;
        pName++;
    }
    else        // No domain specified
    {
        pName = lpszUserName;
        pAuthData->Domain = NULL;
        pDomain = NULL;
        dwDomainLen = pAuthData->DomainLength = 0;
    }

    dwUserLen = pAuthData->UserLength = lstrlen (pName);
    dwPwdLen = pAuthData->PasswordLength = lstrlen (lpszPassword);

    //
    //  Allocate memory for all: name, domain, and password
    //  The memory block is big enough for Unicode. Some bytes will be wasted in the ANSI case
    //
    pAuthData->User = (unsigned char*)LocalAlloc(LMEM_ZEROINIT, (dwUserLen + dwDomainLen + dwPwdLen + 3)*sizeof(WCHAR));
    //  Since the buffer is zero-initialized, strings don't need their '\0' copied over.

    if (pAuthData->User == NULL)
        return (FALSE);

    if (bUnicodeAuth)
    {
        // Convert the user name into Unicode and store in pAuthData->User
        if (0 == MultiByteToWideChar(CP_ACP, 0, pName, -1, (LPWSTR)(pAuthData->User), dwUserLen+1))
            return FALSE;
    }
    else
        CopyMemory (pAuthData->User, pName, dwUserLen);

    //  Setup memory pointer for password
    //
    pAuthData->Password = pAuthData->User + (dwUserLen + 1) * sizeof(WCHAR);

    if (bUnicodeAuth)
    {
        if (0 == MultiByteToWideChar(CP_ACP, 0, lpszPassword, -1, (LPWSTR)(pAuthData->Password), dwPwdLen+1))
            return FALSE;
    }
    else
        CopyMemory (pAuthData->Password, lpszPassword, dwPwdLen);

    if (pAuthData->DomainLength > 0)
    {
        //  Setup memory pointer for domain
        //
        pAuthData->Domain = pAuthData->Password + (dwPwdLen + 1) * sizeof(WCHAR);
        if (bUnicodeAuth)
        {
            // pDomain is not null terminated, so provide the length
            if (0 == MultiByteToWideChar(CP_ACP, 0, pDomain, dwDomainLen, (LPWSTR)(pAuthData->Domain), dwDomainLen+1))
                return FALSE;
        }
        else
            CopyMemory (pAuthData->Domain, pDomain, dwDomainLen);
    }
    else
    {
       pAuthData->Domain = NULL;
    }

    return (TRUE);
}

//+---------------------------------------------------------------------------
//
//  Function:   FreeNTLMauthData
//
//  Synopsis:   This function frees memory allocated for the 
//              SEC_WINNT_AUTH_IDENTITY structure
//
//  Arguments:  [pAuthData] - points to the SEC_WINNT_AUTH_IDENTITY structure
//
//  Returns:    void.
//
//----------------------------------------------------------------------------
VOID
FreeNTLMauthData (
    PSEC_WINNT_AUTH_IDENTITY pAuthData
    )
{
    //
    //  Free User which points to memory for all domain, name, and password
    //
    if (pAuthData->User)
    {
        int iCharacterSize = 0;
        if (pAuthData->Flags & SEC_WINNT_AUTH_IDENTITY_ANSI)
            iCharacterSize = sizeof(char);
        else if (pAuthData->Flags & SEC_WINNT_AUTH_IDENTITY_UNICODE)
            iCharacterSize = sizeof(WCHAR);
        
        memset(pAuthData->User, 0, iCharacterSize * pAuthData->UserLength);
        memset(pAuthData->Password, 0, iCharacterSize * pAuthData->PasswordLength);
        LocalFree (pAuthData->User);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   NewWinContext
//
//  Synopsis:   This function creates a new context and a new credential 
//              handle for this connection.  If a user name/password is 
//              specified, the credential handle is created for the 
//              specified user.  Otherwise, the credential handle is created 
//              for the local logon user.
//
//  Arguments:  [pkgId] - the package ID (index into SSPI package list)
//              [lpszScheme] - the name of the current authentication scheme,
//                             which is also the SSPI package name
//              [ppCtxt] - this returns the pointer of the created context 
//                         to the caller.
//              [lpszUserName] - the name of a specific user to be used 
//                               for authentication. If this is NULL, the 
//                               credential of the currently logon user is 
//                               used for authentication.
//              [lpszPassword] - the password of the specified user, if any.
//
//  Returns:    ERROR_SUCCESS - if the new context is created successfully
//              ERROR_NOT_ENOUGH_MEMORY - if memory allocation failed
//              ERROR_INVALID_PARAMETER - the SSPI call for creating the 
//                              security credential handle failed
//
//----------------------------------------------------------------------------
DWORD
NewWinContext (
    INT         pkgId, 
    LPSTR       lpszScheme,
    PWINCONTEXT *ppCtxt,
    BOOL        fCanUseLogon,
    LPSTR       lpszUserName,
    LPSTR       lpszPassword
    )
{
    SECURITY_STATUS ss;
    TimeStamp   Lifetime;
    PWINCONTEXT pWinContext;
    SEC_WINNT_AUTH_IDENTITY  AuthData;
    PSEC_WINNT_AUTH_IDENTITY pAuthData;
    DWORD Capabilities ;

    DWORD SecurityBlobSize;

    //
    // need space for maxtoken size for in+out, + base64 encoding overhead for each.
    // really 1.34 overhead, but just round up to 1.5
    //
    SecurityBlobSize = GetPkgMaxToken(pkgId);
    SecurityBlobSize += (SecurityBlobSize/2);

    //
    // note: for compatibility sake, make the buffer size the MAX_BLOB_SIZE at the minimum
    // consider removing this once we're convinced all packages return good cbMaxToken values.
    //

    if( SecurityBlobSize < MAX_BLOB_SIZE )
    {
        SecurityBlobSize = MAX_BLOB_SIZE;
    }


    pWinContext = (PWINCONTEXT) LocalAlloc(
                        0,
                        sizeof(WINCONTEXT) +
                        (SecurityBlobSize*2)
                        );
    if (pWinContext == NULL)
        return (ERROR_NOT_ENOUGH_MEMORY);
        
    //  Initialize context
    //
    ZeroMemory( pWinContext, sizeof(WINCONTEXT) );
    pWinContext->pkgId = (DWORD)pkgId;
    
    pWinContext->szOutBuffer = (char*)(pWinContext+1);
    pWinContext->cbOutBuffer = SecurityBlobSize;

    pWinContext->szInBuffer = pWinContext->szOutBuffer + pWinContext->cbOutBuffer;
    pWinContext->cbInBuffer = SecurityBlobSize;

    //
    // Get bitmask representing the package capabilities
    //

    Capabilities = GetPkgCapabilities( pkgId );

    if ( ( Capabilities & SSPAUTHPKG_SUPPORT_NTLM_CREDS ) == 0 )
    {
        pAuthData = NULL;
    }
    else if (lpszUserName && lpszPassword)
    {
        //  Build AuthData from the specified user name/password
        if (!BuildNTLMauthData (&AuthData, lpszUserName, lpszPassword))
        {
            LocalFree (pWinContext);
            return (ERROR_NOT_ENOUGH_MEMORY);
        }

        pAuthData = &AuthData;
    }
    else if (fCanUseLogon)
    {
        // The zone policy allows silent use of the logon credential.
        pAuthData = NULL;
    }
    else
    {
        LocalFree (pWinContext);
        // We must prompt the user for credentials.
        return ERROR_WINHTTP_INCORRECT_PASSWORD;
    }

    //
    //  Call SSPI function acquire security credential for this package
    //
    ss = (*(g_pSspData->pFuncTbl->AcquireCredentialsHandle))(
                       NULL,                // New principal
                       lpszScheme,          // SSPI Package Name
                       SECPKG_CRED_OUTBOUND,// Credential Use
                       NULL,                // Logon ID
                       pAuthData,           // Auth Data
                       NULL,                // Get key func
                       NULL,                // Get key arg
                       &pWinContext->Credential,    // Credential Handle
                       &Lifetime );

    if (pAuthData)
        FreeNTLMauthData (pAuthData);

    if (ss != STATUS_SUCCESS)
    {
        LocalFree (pWinContext);
        return (ERROR_INVALID_PARAMETER);
    }

    pWinContext->pCredential = &pWinContext->Credential;

    *ppCtxt = pWinContext;

    AuthLock();
    g_cSspiContexts++;
    AuthUnlock();

    return (ERROR_SUCCESS);
}

//+---------------------------------------------------------------------------
//
//  Function:   RedoNTLMAuth4User
//
//  Synopsis:   This function recreates a NTLM credential handle for the 
//              specified user and generate a NEGOTIATE message in 
//              the provided buffer with the new credential handle.
//
//  Arguments:  [pWinContext] - points to the connection context
//              [pkgId] - specifies the SSPI pkg to be used for authentication
//              [lpszUserName] - the name of the specific user to be used 
//                               for authentication. 
//              [lpszPassword] - the password of the specified user,
//              [lpszServerName] - the target server name
//              [lpszScheme] - the name of the current authentication scheme,
//                             which is also the SSPI package name
//              [lpOutBuffer] - points to the buffer for the new authorization 
//                              header including the UUENCODED NEGOTIATE msg
//              [lpdwOutBufferLength] - returns the length of the generated 
//                                      authorization header.
//
//  Returns:    ERROR_SUCCESS - if the new authorization header is successfully 
//                              created for the new user name/password
//              ERROR_NOT_ENOUGH_MEMORY - if memory allocation failed
//              ERROR_INVALID_HANDLE - the SSPI call for generating the 
//                              new NEGOTIATE msg failed
//
//----------------------------------------------------------------------------
DWORD
RedoNTLMAuth4User (
    PWINCONTEXT    pWinContext, 
    INT         pkgId, 
    LPSTR       lpszUserName,
    LPSTR       lpszPassword, 
    LPSTR       lpszServerName,
    LPSTR       lpszScheme,
    IN BOOL     fCanUseLogon,
    LPSTR       lpOutBuffer,
    LPDWORD     lpdwOutBufferLength,
    SECURITY_STATUS *pssResult
    )
{
    SECURITY_STATUS         ss;
    DWORD                   dwStatus;
    TimeStamp               Lifetime;
    SEC_WINNT_AUTH_IDENTITY AuthData;
    ULONG                   fContextReq = ISC_REQ_DELEGATE;
    DWORD                   dwMaxLen;

       if (pWinContext->pSspContextHandle)
       {
        (*(g_pSspData->pFuncTbl->DeleteSecurityContext))(pWinContext->pSspContextHandle);
           pWinContext->pSspContextHandle = NULL;
    }

    //  Free existing credential handle
    //
    if (pWinContext->pCredential)
    {
        (*(g_pSspData->pFuncTbl->FreeCredentialHandle))(pWinContext->pCredential);
        pWinContext->pCredential = NULL;
    }
    //
    //  Build the NTLM SSPI AuthData from the specified user name/password
    //
    if (!BuildNTLMauthData (&AuthData, lpszUserName, lpszPassword))
        return (ERROR_NOT_ENOUGH_MEMORY);

    //
    //  Call SSPI function acquire security credential for this user
    //
    ss = (*(g_pSspData->pFuncTbl->AcquireCredentialsHandle))(
                       NULL,                // New principal
                       lpszScheme,          // SSPI Package Name
                       SECPKG_CRED_OUTBOUND,// Credential Use
                       NULL,                // Logon ID
                       &AuthData,           // Auth Data
                       NULL,                // Get key func
                       NULL,                // Get key arg
                       &pWinContext->Credential,    // Credential Handle
                       &Lifetime );

    FreeNTLMauthData (&AuthData);   // don't need it any more

    if (ss != STATUS_SUCCESS)
    {
        return (ERROR_INVALID_HANDLE);
    }

    pWinContext->pCredential = &pWinContext->Credential;

    dwMaxLen = *lpdwOutBufferLength;

    //
    //  Generate NEGOTIATE message in the provided buffer for this user 
    //
    dwStatus =  GetSecAuthMsg( g_pSspData,
                                pWinContext->pCredential,
                                pkgId,
                                NULL, 
                                &(pWinContext->SspContextHandle),
                                fContextReq,
                                NULL,
                                0,
                                lpOutBuffer,
                                lpdwOutBufferLength,
                                lpszServerName,
                                fCanUseLogon,
                                TRUE,
                                lpszScheme,
                                pssResult);
    
    if (dwStatus != SPM_STATUS_OK)
    {
        *lpdwOutBufferLength = 0; // no exchange blob generated
        return(ERROR_INVALID_HANDLE);
    }

    pWinContext->pSspContextHandle = &(pWinContext->SspContextHandle);

    //
    //  If we are not in the initial state, continue to a RESPONSE message
    //
    if (pWinContext->pInBuffer != NULL && pWinContext->dwInBufferLength > 0)
    {
        *lpdwOutBufferLength = dwMaxLen;
        ZeroMemory( lpOutBuffer, dwMaxLen );

        dwStatus = GetSecAuthMsg( g_pSspData,
                                pWinContext->pCredential,
                                pWinContext->pkgId,
                                pWinContext->pSspContextHandle,
                                (PCtxtHandle) &(pWinContext->SspContextHandle),
                                fContextReq,
                                pWinContext->pInBuffer, 
                                pWinContext->dwInBufferLength, 
                                lpOutBuffer,
                                lpdwOutBufferLength,
                                pWinContext->lpszServerName,
                                fCanUseLogon,
                                TRUE,
                                lpszScheme,
                                pssResult);

        //  Clear out the input exchange blob
        //
        if (pWinContext->pInBuffer != NULL)
        {
            if (pWinContext->pInBuffer != pWinContext->szInBuffer)
                LocalFree (pWinContext->pInBuffer);
            pWinContext->pInBuffer = NULL;
            pWinContext->dwInBufferLength = 0;
        }

        if (dwStatus != SPM_STATUS_OK)
        {
            *lpdwOutBufferLength = 0; // no exchange blob generated
            return(ERROR_INVALID_HANDLE);
        }
    }

    return (ERROR_SUCCESS);
}


//
// functions
//

/*++

Routine Description:

    Generates a Basic User Authentication string for WinINet or 
    other callers can use

Arguments:

    lpContext               - if the package accepts the request & authentication
                    requires multiple transactions, the package will supply
                    a context value which will be used in subsequent calls,
                    Currently this contains a pointer to a pointer of a 
                    User defined Void Pointer.  Can be Assume to be NULL
                    if this is the first instance of a Realm - Host Combo

    lpszServerName  - the name of the server we are performing 
                    authentication for. We may want to supply the full URL
                    
    lpszScheme              - the name of the authentication scheme we are seeking, in case the package supports multiple schemes

    dwFlags                 - on input, flags modifying how the package should behave,
                    e.g. "only authenticate if you don't have to get user 
                    information"  On output contains flags relevant to
                    future HTTP requests, e.g. "don't cache any data from 
                    this connection". Note, this information should not be 
                    specific to HTTP - we may want to use the same flags 
                    for FTP, etc.
    
    lpszInBuffer              - pointer to the string containing the response from
                    the server (if any)

    dwInBufferLength - number of bytes in lpszInBuffer. No CR-LF sequence, no terminating NUL

    lpOutBuffer -   pointer to a buffer where the challenge response will be written by the 
                    package if it can handle the request

    lpdwOutBufferLength - on input, contains the size of lpOutBuffer. On output, contains the
                          number of bytes to return to the server in the next GET request 
                          (or whatever). If lpOutBuffer is too small, the package should 
                          return ERROR_INSUFFICIENT_BUFFER and set *lpdwOutBufferLength to be
                          the required length

    We will keep a list of the authentication packages and the schemes they support, 
    along with the entry point name (should be the same for all packages) in the registry. 

    Wininet should keep enough information such that it can make a reasonable guess as to
    whether we need to authenticate a connection attempt, or whether we can use previously 
    authenticated information


Return Value:

    DWORD
    Success - non-zero 
    Failure - 0. Error status is available by calling GetLastError()

--*/
DWORD
WINAPI
AuthenticateUser(
    IN OUT LPVOID *lppvContext,
    IN LPSTR lpszServerName,
    IN LPSTR lpszScheme,
    IN BOOL  fCanUseLogon,
    IN LPSTR lpszInBuffer,
    IN DWORD dwInBufferLength,
    IN LPSTR lpszUserName,
    IN LPSTR lpszPassword,
    OUT SECURITY_STATUS *pssResult
    )
{
    PWINCONTEXT        pWinContext;
    LPSTR           pServerBlob = NULL;
    int                pkgId;
    DWORD           SPMStatus;
    ULONG           fContextReq = ISC_REQ_DELEGATE;
    BOOL            bNonBlock = TRUE;

    if (!SSPI_InitGlobals())
        return ERROR_INVALID_PARAMETER;

    
    pkgId = GetPkgId(lpszScheme);

    if (pkgId == -1) 
        return (ERROR_INVALID_PARAMETER);

    if (*lppvContext == NULL)   // a new connection
    {
        DWORD dwStatus;

        //
        // First time we are getting called here, there should be no input blob
        //
        if (dwInBufferLength != 0)
            return (ERROR_INVALID_PARAMETER);

        dwStatus = NewWinContext (pkgId, lpszScheme, &pWinContext,
            fCanUseLogon, lpszUserName, lpszPassword);
        if (dwStatus != ERROR_SUCCESS)
            return (dwStatus);

        (*lppvContext) = (LPVOID) pWinContext;
#ifdef DEBUG_WINSSPI
        (void)wsprintf (msg, "AuthenticateUser> Scheme= %s  Server= '%s'\n", 
                       lpszScheme, lpszServerName);
        OutputDebugString(msg);
#endif
    }
    else
    {
        pWinContext = (PWINCONTEXT) (*lppvContext);

        //
        // The package Id better be the same. Cant just switch packageId 
        // arbitrarily
        //
        if (pWinContext->pkgId != (DWORD)pkgId)
            return (ERROR_INVALID_PARAMETER);
        
        pServerBlob = lpszInBuffer;

        //++(pWinContext->dwCallId);        // Increment Call Id

        //
        // BUGBUG: Hack for now to know when auth failed
        // The only time we get lpszInBuffer to be empty is when 
        // Web server failed the authentication request
        //
        if (dwInBufferLength == 0)
        {
            //
            // This means auth has failed as far as NTLM are concerned.
            // Will result in UI being done again for new passwd
            //

            // Make sure we should have the same server name as before
            //
            if ( pWinContext->lpszServerName != NULL &&  
                 lstrcmp (pWinContext->lpszServerName, lpszServerName) != 0 )
            {
                return(ERROR_INVALID_PARAMETER);
            }

            if (!SaveServerName (lpszServerName, pWinContext))
                return (ERROR_NOT_ENOUGH_MEMORY);

            //
            //    Delete the original SSPI context handle and 
            //    let UI recreate one.
            //
            if (pWinContext->pSspContextHandle)
            {
                (*(g_pSspData->pFuncTbl->DeleteSecurityContext))(pWinContext->pSspContextHandle);
                pWinContext->pSspContextHandle = NULL;
            }

            if (pWinContext->pInBuffer != NULL && 
                pWinContext->pInBuffer != pWinContext->szInBuffer)
            {
                LocalFree (pWinContext->pInBuffer);
            }

            pWinContext->pInBuffer = NULL;
            pWinContext->dwInBufferLength = 0;

            //
            //  clear buffer length for the exchange blob
            //
            pWinContext->dwOutBufferLength = 0;

            return (ERROR_WINHTTP_INCORRECT_PASSWORD);
        }
    }

    //
    //  Setup dwOutBufferLength to represent max. memory in szOutBuffer
    //
    pWinContext->dwOutBufferLength = pWinContext->cbOutBuffer;
    ZeroMemory (pWinContext->szOutBuffer, pWinContext->cbOutBuffer);

    //
    // This will generate an authorization header with UUEncoded blob from SSPI.
    // BUGBUG: Better make sure outbuf buffer is big enough for this.
    //
    SPMStatus =  GetSecAuthMsg( g_pSspData,
                                pWinContext->pCredential,
                                pkgId,
                                pWinContext->pSspContextHandle,
                                &(pWinContext->SspContextHandle),
                                fContextReq,
                                pServerBlob, 
                                   dwInBufferLength,
                                pWinContext->szOutBuffer,
                                &pWinContext->dwOutBufferLength,
                                lpszServerName,
                                fCanUseLogon,
                                bNonBlock,
                                lpszScheme,
                                pssResult);

    if (SPMStatus != SPM_STATUS_OK)             // Fail to generate blob
    {
        pWinContext->dwOutBufferLength = 0;     // no exchange blob generated

        //
        //  if SSPI is requesting an opportunity to prompt for user credential
        //
        if (SPMStatus == SPM_STATUS_WOULD_BLOCK)
        {
            if (!SaveServerName (lpszServerName, pWinContext))
                return (ERROR_NOT_ENOUGH_MEMORY);

            //  If there is a exchange blob, this is not the first call
            //
            if (pServerBlob && dwInBufferLength > 0)
            {
                //  Save the exchange blob in the connection context
                //  so we can call SSPI again with the exchange blob
                if (dwInBufferLength > MAX_BLOB_SIZE)
                {
                    pWinContext->pInBuffer = (PCHAR) LocalAlloc(0, 
                                                    dwInBufferLength);
                    if (pWinContext->pInBuffer == NULL)
                        return (ERROR_NOT_ENOUGH_MEMORY);
                }
                else
                    pWinContext->pInBuffer = pWinContext->szInBuffer;

                CopyMemory( pWinContext->szInBuffer, pServerBlob, 
                            dwInBufferLength );
                pWinContext->dwInBufferLength = dwInBufferLength;
            }
            else
            {
                //
                //    Delete the original SSPI context handle and 
                //    let UI recreate one.
                //
                if (pWinContext->pSspContextHandle)
                {
                    (*(g_pSspData->pFuncTbl->DeleteSecurityContext))(pWinContext->pSspContextHandle);
                    pWinContext->pSspContextHandle = NULL;
                }

                //
                //  clear buffer length for the exchange blob
                //
                if (pWinContext->pInBuffer != NULL && 
                    pWinContext->pInBuffer != pWinContext->szInBuffer)
                {
                    LocalFree (pWinContext->pInBuffer);
                }

                pWinContext->pInBuffer = NULL;
                pWinContext->dwInBufferLength = 0;
            }
            pWinContext->dwOutBufferLength = 0;

            return(ERROR_WINHTTP_INCORRECT_PASSWORD);
        }

        return (ERROR_WINHTTP_LOGIN_FAILURE);
    }
    else if (pWinContext->pSspContextHandle == NULL)
    {   
        //  This means that we've just created a security context
        //
        pWinContext->pSspContextHandle = &(pWinContext->SspContextHandle);
    }

    return ERROR_WINHTTP_RESEND_REQUEST;
}


DWORD
WINAPI
PreAuthenticateUser(
    IN OUT LPVOID *lppvContext,
    IN LPSTR lpszServerName,
    IN LPSTR lpszScheme,
    IN BOOL  fCanUseLogon,
    IN DWORD dwFlags,
    OUT LPSTR lpOutBuffer,
    IN OUT LPDWORD lpdwOutBufferLength,
    IN LPSTR lpszUserName,
    IN LPSTR lpszPassword,
    SECURITY_STATUS *pssResult
    )
{
    INT             pkgId;
    DWORD           dwStatus;
    PWINCONTEXT        pWinContext;
    BOOL            bNonBlock = TRUE;
    ULONG           fContextReq = ISC_REQ_DELEGATE;
    DWORD Capabilities ;

    UNREFERENCED_PARAMETER(dwFlags);

    if (!SSPI_InitGlobals())
        return ERROR_INVALID_PARAMETER;

    if (lpszServerName == NULL || *lpszServerName == '\0')
        return(ERROR_INVALID_PARAMETER);

    pkgId = GetPkgId(lpszScheme);

    if (pkgId == -1)    {
        return(ERROR_INVALID_PARAMETER);
    }

    Capabilities = GetPkgCapabilities( pkgId );

    //
    //  If this is for an existing connection
    //
    if (*lppvContext != NULL)
    {
        pWinContext = (PWINCONTEXT) (*lppvContext);

        if ((DWORD)pkgId != pWinContext->pkgId)
            return(ERROR_INVALID_PARAMETER);

        //
        //  For package that does not handle its own UI, if there is no 
        //  generated blob, it means that we have just collected 
        //  user name/password.
        //
        if ( ( pWinContext->dwOutBufferLength == 0 ) &&
                ( Capabilities & SSPAUTHPKG_SUPPORT_NTLM_CREDS ) )
        {
            if (lpszUserName == NULL || lpszPassword == NULL)
            {
                return(ERROR_INVALID_PARAMETER);
            }

            //
            // Need to recreate a credential handle and 
            // generate a new NEGOTIATE message in lpOutBuffer
            //
            dwStatus = RedoNTLMAuth4User (pWinContext, 
                                         pkgId,
                                         lpszUserName,
                                         lpszPassword, 
                                         lpszServerName ,
                                         lpszScheme,
                                         fCanUseLogon,
                                         lpOutBuffer,
                                         lpdwOutBufferLength,
                                         pssResult);

            if (dwStatus != ERROR_SUCCESS)
                return (dwStatus);

            return(ERROR_SUCCESS);
        }
        else if (pWinContext->dwOutBufferLength == 0)
        //
        //  For other packages, If there is no generated blob, 
        //  something is wrong 
        //
            return(ERROR_INVALID_PARAMETER);

    }
    // If not NTLM, don't pre-auth.
    else if ( (Capabilities & SSPAUTHPKG_SUPPORT_NTLM_CREDS ) == 0 )
    {
        return (ERROR_INVALID_HANDLE);
    }
    else
    {
        // probably sending 1st request on a new connection for the same URL
        //  Create a new context and SSPI credential handle for this connection
        //
        // Set fCanUseLogon to TRUE : we would not be pre-authing
        // unless we have a valid pwc which means we already checked
        // zone policy for silent logon.
        dwStatus = NewWinContext (pkgId, lpszScheme, &pWinContext, 
                                  fCanUseLogon, lpszUserName, lpszPassword);
        if (dwStatus != ERROR_SUCCESS)
            return (dwStatus);
        
#ifdef DEBUG_WINSSPI
        (void)wsprintf (msg, 
            "PreAuthenticateUser> New Context for Scheme= %s  Server= '%s'\n", 
            lpszScheme, lpszServerName);
        OutputDebugString(msg);
#endif
        pWinContext->dwOutBufferLength = pWinContext->cbOutBuffer;
        ZeroMemory (pWinContext->szOutBuffer, pWinContext->cbOutBuffer);
    
        //
        // This will generate an authorization header with the 
        // UUEncoded blob from SSPI. 
        // BUGBUG: Better make sure outbuf buffer is big enough for this.
        //
        dwStatus =  GetSecAuthMsg( g_pSspData,
                                    pWinContext->pCredential,
                                    pkgId,
                                    NULL, 
                                    &(pWinContext->SspContextHandle),
                                    fContextReq,
                                    NULL,
                                    0,
                                    pWinContext->szOutBuffer,
                                    &pWinContext->dwOutBufferLength,
                                    lpszServerName,
                                    fCanUseLogon,
                                    bNonBlock,
                                    lpszScheme,
                                    pssResult);
    
        if (dwStatus != SPM_STATUS_OK)
        {
            //  This is a rare case
            //
            pWinContext->dwOutBufferLength = 0; // no exchange blob generated
            return(ERROR_INVALID_HANDLE);
        }

        (*lppvContext) = (LPVOID) pWinContext;

        //  Save the pointer of the created security ctxt
        //
        pWinContext->pSspContextHandle = &(pWinContext->SspContextHandle);
    }

    //
    //  Copy exchange blob to the output buffer
    //    Make sure output buffer provided is big enough
    //
    if (*lpdwOutBufferLength < pWinContext->dwOutBufferLength)
    {
        *lpdwOutBufferLength = pWinContext->dwOutBufferLength + 1;
        return(ERROR_INSUFFICIENT_BUFFER);
    }

    CopyMemory (lpOutBuffer, pWinContext->szOutBuffer, 
                pWinContext->dwOutBufferLength);
    if (*lpdwOutBufferLength > pWinContext->dwOutBufferLength)
        lpOutBuffer[pWinContext->dwOutBufferLength] = '\0';

    *lpdwOutBufferLength = pWinContext->dwOutBufferLength;

    //
    //  The exchange blob has being copied to request header, so clear its len
    //

    pWinContext->dwOutBufferLength = 0;

    return(ERROR_SUCCESS);
}

BOOL g_fUUEncodeData = TRUE;

typedef enum _COMPUTER_NAME_FORMAT {
    ComputerNameNetBIOS,
    ComputerNameDnsHostname,
    ComputerNameDnsDomain,
    ComputerNameDnsFullyQualified,
    ComputerNamePhysicalNetBIOS,
    ComputerNamePhysicalDnsHostname,
    ComputerNamePhysicalDnsDomain,
    ComputerNamePhysicalDnsFullyQualified,
    ComputerNameMax
} COMPUTER_NAME_FORMAT ;

typedef 
BOOL
(WINAPI * PFN_GET_COMPUTER_NAME_EX)(
    IN COMPUTER_NAME_FORMAT NameType,
    OUT LPSTR lpBuffer,
    IN OUT LPDWORD nSize
    );

PFN_GET_COMPUTER_NAME_EX g_pfnGetComputerNameExA = NULL;


/*-----------------------------------------------------------------------------
**
**  Function:   GetSecAuthMsg
**
**  Synopsis:   This function generates a SSPI NEGOTIATE or RESPONSE 
**                authorization string for the specified SSPI package.
**                The authorization string generated by this function 
**                follows the format: 
**                    "<Package Name> <Package Specific Auth. Data>"
**                If global uuencoding is turned on, this functions will 
**                uuencode the message before building it into an  
**                authorization string; by default, the uuencoding flag is 
**                always on.  
**                This functions calls InitializeSecurityContext() to 
**                generate the NEGOTIATE/RESPONSE message for the authori-
**                zation string. If the SSPI function returns NO_CREDENTIAL, 
**                and if the PROMPT_CREDS flag is not turned on when blocking
**                is permitted, this function will call the SSPI function 
**                again with the PROMPT_CREDS flag set; if SSPI returns 
**                NO_CREDENTIAL again, this SSPI will return ERROR to the 
**                caller.
**
**
**  Arguments:
**
**        pData - pointer to SspData containing the SSPI function table 
**                and the SSPI package list. 
**        pkgID - the package index of the SSPI package to use.
**        pInContext - pointer to a context handle. If NULL is specified, 
**                     this function will use a temporary space for the context
**                     handle and delete the handle before returning to the 
**                     caller. If non-NULL address is specified, the context 
**                     handle created by the SSPI is returned to the caller. 
**                     And the caller will have to delete the handle when it's
**                     done with it.
**        fContextReq - the SSPI request flag to pass to InitializeSecurityContext
**        pBuffIn - pointer to the uudecoded CHALLENGE message if any. 
**                  For generating NEGOTIATE message, this pointer should be NULL.
**        cbBuffIn - length of the CHALLENGE message. This should be zero when  
**                   when pBuffIn is NULL.
**        pFinalBuff - pointer to a buffer for the final authorization string.
**        pszTarget - Server Host Name
**        bNonBlock - a flag which is set if blocking is not permitted.
**
**  Return Value:
**
**        SPM_STATUS_OK    - if an authorization string is generated successfully
**      SPM_STATUS_WOULD_BLOCK - if generating an authorization string would 
**                    cause blocking when blocking is not permitted. 
**        SPM_ERROR - if any problem/error is encountered in generating an 
**                    authorization string, including user hitting cancel on 
**                    the SSPI dialog prompt for name/password.
**
**---------------------------------------------------------------------------*/
DWORD
GetSecAuthMsg (
    PSspData        pData,              
    PCredHandle     pCredential, 
    DWORD           pkgID,              // the package index into package list
    PCtxtHandle     pInContext,
    PCtxtHandle        pOutContext,
    ULONG           fContextReq,        // Request Flags
    VOID            *pBuffIn, 
    DWORD           cbBuffIn, 
    char            *pFinalBuff, 
    DWORD           *pcbBuffOut,
    SEC_CHAR        *pszTarget,         // Server Host Name
    BOOL            fTargetTrusted,
    UINT            bNonBlock,
    LPSTR           pszScheme,
    SECURITY_STATUS *pssResult
    )
{
    char                  *SlowDecodedBuf = NULL;

    int                   retsize;
    SECURITY_STATUS       SecStat;
    TimeStamp             Lifetime;
    SecBufferDesc         OutBuffDesc;
    SecBuffer             OutSecBuff;
    SecBufferDesc         InBuffDesc;
    SecBuffer             InSecBuff;
    ULONG                 ContextAttributes;

    char                  *SlowOutBufPlain = NULL;

    char                  *pOutMsg = NULL;
    DWORD                 RetStatus;
    long                  maxbufsize;
    CHAR                  szDecoratedTarget[MAX_PATH + 6];
    DWORD                 cbTarget;

    ULONG                 cbMaxToken;


    //
    // BUGBUG: Deal with output buffer not being long enough


    if (pFinalBuff == NULL) {
        return(SPM_ERROR);
    }

    //
    //  Prepare our output buffer.  We use a temporary buffer because
    //  the real output buffer will most likely need to be uuencoded
    //
    OutBuffDesc.ulVersion = 0;
    OutBuffDesc.cBuffers  = 1;
    OutBuffDesc.pBuffers  = &OutSecBuff;

    OutSecBuff.cbBuffer   = MAX_AUTH_MSG_SIZE;
    OutSecBuff.BufferType = SECBUFFER_TOKEN;


    // Dynamically allocate since being in a service doesn't
    // give us the guaranteed luxury of 10+KB stack allocations.

    cbMaxToken = GetPkgMaxToken(pkgID);

    SlowOutBufPlain = (char *) ALLOCATE_FIXED_MEMORY(cbMaxToken);

    if( SlowOutBufPlain == NULL )
    {
        RetStatus = SPM_STATUS_INSUFFICIENT_BUFFER;
        goto Cleanup;
    }
    OutSecBuff.pvBuffer = SlowOutBufPlain;
    OutSecBuff.cbBuffer = cbMaxToken;

    //
    //  Prepare our Input buffer if a CHALLENGE message is passed in.
    //
    if ( pBuffIn )
    {
        InBuffDesc.ulVersion = 0;
        InBuffDesc.cBuffers  = 1;
        InBuffDesc.pBuffers  = &InSecBuff;

        InSecBuff.BufferType = SECBUFFER_TOKEN;

        //
        // If this is UUENCODED, decode it first
        //
        if ( g_fUUEncodeData)
        {
            DWORD cbDecodedBuf;

            cbDecodedBuf = cbBuffIn;
            SlowDecodedBuf = (char*) ALLOCATE_FIXED_MEMORY(cbDecodedBuf);
            if( SlowDecodedBuf == NULL )
            {
                RetStatus = SPM_STATUS_INSUFFICIENT_BUFFER;
                goto Cleanup;
            }

            InSecBuff.cbBuffer   = HTUU_decode ((char*)pBuffIn, (UCHAR*)SlowDecodedBuf,
                                                cbDecodedBuf);
            InSecBuff.pvBuffer   = SlowDecodedBuf;
        }
        else
        {
            InSecBuff.cbBuffer   = cbBuffIn;
            InSecBuff.pvBuffer   = pBuffIn;
        }
    }

    // If scheme is Negotiate, set ISC_REQ_MUTUAL_AUTH and decorate
    // the server name indicated by pszTarget
    if (pszScheme && !(lstrcmpi(pszScheme, "Negotiate")))
    {
        fContextReq |= ISC_REQ_MUTUAL_AUTH;
        cbTarget = (pszTarget ? strlen(pszTarget) : 0);
        if (cbTarget && (cbTarget <= MAX_PATH - sizeof( "HTTP/" )))
        {
            memcpy(szDecoratedTarget, "HTTP/", sizeof( "HTTP/" ) - 1 );
            memcpy(szDecoratedTarget + sizeof( "HTTP/" ) - 1, pszTarget, cbTarget + 1);
            pszTarget = szDecoratedTarget;

            OutputDebugStringA(pszTarget);
        }
    }


    //
    //    Call SSPI function generate the NEGOTIATE/RESPONSE message
    //

    if (fContextReq & ISC_REQ_DELEGATE)
    {
        // we should only request delegation when calling InitializeSecurityContext if 
        // the site is in the intranet or trusted sites zone. Otherwise you will be giving 
        // the user's TGT to any web server that is trusted for delegation.

        if (fTargetTrusted)
        {
            fContextReq &= ~ISC_REQ_DELEGATE;
        }
    }

SspiRetry:

//
// BUGBUG: Same credential handle could be used by multiple threads at the
// same time.
//
    SecStat = (*(pData->pFuncTbl->InitializeSecurityContext))(
                                pCredential, 
                                pInContext,
                                pszTarget,
                                fContextReq,
                                0,
                                SECURITY_NATIVE_DREP,
                                (pBuffIn) ? &InBuffDesc : NULL, 
                                0,
                                pOutContext, 
                                &OutBuffDesc,
                                &ContextAttributes,
                                &Lifetime );
    *pssResult = SecStat;
    
    //
    //    If SSPI function fails 
    //
    if ( !NT_SUCCESS( SecStat ) )
    {
        RetStatus = SPM_ERROR;

        //
        //    If SSPI do not have user name/password for the secified package,
        //
        if (SecStat == SEC_E_NO_CREDENTIALS)
        {
            //
            //  If we have prompted the user and still get back "No Credential"
            //  error, it means the user does not have valid credential; the 
            //    user hit <CANCEL> on the UI box. If we have supplied a valid 
            //    credential, but get back a "No Credential" error, then something
            //    has gone wrong; we definitely should return to caller with ERROR
            //
            if ((fContextReq & ISC_REQ_PROMPT_FOR_CREDS) ||
                (fContextReq & ISC_REQ_USE_SUPPLIED_CREDS))
            {
                RetStatus = SPM_ERROR;    // return ERROR to caller
            }
            else if (bNonBlock)
            {
                //
                //    Blocking is not permitted, return WOULD_BLOCK to caller
                //
                RetStatus = SPM_STATUS_WOULD_BLOCK;
            }
            else
            {
                //    Blocking is permitted and we have not asked the SSPI to
                //  prompt the user for proper credential, we should call  
                //  the SSPI again with PROMPT_CREDS flag set.
                //
                fContextReq = fContextReq | ISC_REQ_PROMPT_FOR_CREDS;
                goto SspiRetry;
            }
        }
        SetLastError( SecStat );

        goto Cleanup;
    }

    RetStatus = SPM_STATUS_OK;

    //
    //  Only return the SSPI blob if a output buffer is specified
    //
    if (pFinalBuff)
    {
        //
        //    Initialize the final buffer to hold the package name followed by 
        //    a space. And setup the pOutMsg pointer to points to the character 
        //    following the space so that the final NEGOTIATE/RESPONSE can be 
        //    copied into the pFinalBuff starting at the character pointed to 
        //    by pOutMsg. 
        //
        wsprintf (pFinalBuff, "%s ", pData->PkgList[pkgID]->pName);
        pOutMsg = pFinalBuff + lstrlen(pFinalBuff);

        if ( g_fUUEncodeData)
        {
            maxbufsize = *pcbBuffOut - 
                         lstrlen(pData->PkgList[pkgID]->pName) - 1;
            //
            //  uuencode it, but make sure that it fits in the given buffer
            //
            retsize = HTUU_encode ((BYTE *) OutSecBuff.pvBuffer,
                                   OutSecBuff.cbBuffer,
                                   (CHAR *) pOutMsg, maxbufsize);
            if (retsize > 0)
                *pcbBuffOut = retsize + lstrlen(pData->PkgList[pkgID]->pName)+1;
            else
                RetStatus = SPM_STATUS_INSUFFICIENT_BUFFER;
        }
        else if ( *pcbBuffOut >= lstrlen(pData->PkgList[pkgID]->pName) + 
                                 OutSecBuff.cbBuffer + 1 )
        {
            CopyMemory( (CHAR *) pOutMsg, 
                        OutSecBuff.pvBuffer,
                        OutSecBuff.cbBuffer );
            *pcbBuffOut = lstrlen(pData->PkgList[pkgID]->pName) + 1 +
                          OutSecBuff.cbBuffer;
        }
        else
        {
            *pcbBuffOut = lstrlen(pData->PkgList[pkgID]->pName) + 
                          OutSecBuff.cbBuffer + 1;
            RetStatus = SPM_STATUS_INSUFFICIENT_BUFFER;
        }
    }

Cleanup:

    if( SlowOutBufPlain != NULL )
    {
        FREE_MEMORY( SlowOutBufPlain );
    }

    if( SlowDecodedBuf != NULL )
    {
        FREE_MEMORY( SlowDecodedBuf );
    }

    return (RetStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5.1\auth\sspspm.cxx ===
/*#----------------------------------------------------------------------------
**
**  File:           sspspm.c
**
**  Synopsis:   Security Protocol Module for SSPI Authentication providers.
**                  
**      This module contains major funtions of the SEC_SSPI.DLL which 
**      allows the Internet Explorer to use SSPI providers for authentication.
**      The function exported to the Internet Explorer is Ssp_Load() which 
**      passes the address of the Ssp__DownCall() function to the Explorer.
**      Then the Explorer will call Ssp__DownCall() when it needs service from 
**      this SPM DLL.  The two major functions called by Ssp__DownCall() to 
**      service Explorer's request are Ssp__PreProcessRequest() and 
**      Ssp__ProcessResponse().  In brief, Ssp__PreProcessRequest() is 
**      called before the Explorer sends out a request which does not have 
**      any 'Authorization' header yet.  And Ssp__ProcessResponse() is called 
**      whenever the Explorer receives an 401 'Unauthorized' response from the 
**      server.  This SPM DLL supports all SSPI packages which are installed 
**      on the machine.
**
**      This SPM DLL is called by the Internet Explorer only for its
**      The Internet Explorer only calls this SPM DLL when it needs 
**      authentication data in its request/response. In other words, the 
**      Explorer never calls this SPM DLL when an authentication succeeded; 
**      it never calls this DLL when it decide to give up on a connection 
**      because of server response timeout.  Because of this fact, this SPM 
**      DLL never has sufficient information on the state of each server 
**      connection; it only know its state based on the content of the last 
**      request and the content of the current response. For this reason, this 
**      SPM DLL does not keep state information for each host it has visited 
**      unless the information is essential. 
**      The security context handle returned from the first call of  
**      InitializeSecurityContext() for NEGOTIATE message generation is 
**      always the identical for a SSPI package when the same server host is 
**      passed.  Since the server host name is always in the request/response
**      header, the only information essential in generating a NEGOTIATE or 
**      RESPONSE is already available in the header. So unlike most SSPI 
**      application, this DLL will not keep the security context handle which 
**      it received from the SSPI function calls. Whenever it needs to call 
**      the SSPI function for generating a RESPONSE, it will first call the 
**      SSPI function without the CHALLENGE to get a security context handle.
**      Then it calls the SSPI function again with the CHALLENGE to generate 
**      a RESPONSE.
**
**
**      Copyright (C) 1995  Microsoft Corporation.  All Rights Reserved.
**
**  Authors:        LucyC       Created                         25 Sept. 1995
**
**---------------------------------------------------------------------------*/
#include <wininetp.h>
#include <ntlmsp.h>
#include "sspspm.h"

//
// Global variable where all the SSPI Pkgs data is collected
//

SspData  *g_pSspData;


HINSTANCE g_hSecLib;

/*-----------------------------------------------------------------------------
**
**  Function:   SpmAddSSPIPkg
**
**  Synopsis:   This function adds a SSPI package to the SPM's package list.
**
**  Arguments:  pData - Points to the private SPM data structure containing 
**                      the package list and the package info.
**              pPkgName - package name
**              cbMaxToken - max size of security token
**
**  Returns:    The index in the package list where this new package is added.
**              If failed to add the new package, SSPPKG_ERROR is returned.
**
**  History:    LucyC       Created                             21 Oct. 1995
**
**---------------------------------------------------------------------------*/
static UCHAR
SpmAddSSPIPkg (
    SspData *pData, 
    LPTSTR   pPkgName,
    ULONG    cbMaxToken
    )
{
    if ( (pData->PkgList[pData->PkgCnt] =
                        (SSPAuthPkg *)LocalAlloc(0, sizeof(SSPAuthPkg))) == NULL)
    {
        return SSPPKG_ERROR;
    }

    if ( (pData->PkgList[pData->PkgCnt]->pName = 
                        (LPSTR)LocalAlloc(0, lstrlen(pPkgName)+1)) == NULL)
    {
        LocalFree(pData->PkgList[pData->PkgCnt]);
        pData->PkgList[pData->PkgCnt] = NULL;
        return SSPPKG_ERROR;
    }

    lstrcpy (pData->PkgList[pData->PkgCnt]->pName, pPkgName);
    pData->PkgList[ pData->PkgCnt ]->Capabilities = 0 ;

    pData->PkgList[ pData->PkgCnt ]->cbMaxToken = cbMaxToken;

    //
    // Determine if this package supports anything of interest to
    // us.
    //

    if ( lstrcmpi( pPkgName, NTLMSP_NAME_A ) == 0 )
    {
        //
        // NTLM supports the standard credential structure
        //

        pData->PkgList[ pData->PkgCnt ]->Capabilities |= SSPAUTHPKG_SUPPORT_NTLM_CREDS ;
    }
    else if ( lstrcmpi( pPkgName, "Negotiate" ) == 0 )
    {
        //
        // Negotiate supports that cred structure too
        //

        pData->PkgList[ pData->PkgCnt ]->Capabilities |= SSPAUTHPKG_SUPPORT_NTLM_CREDS ;

    }
    else
    {
        //
        // Add more comparisons here, eventually.
        //

        ;
    }

    pData->PkgCnt++;
    return (pData->PkgCnt - 1);
}

/*-----------------------------------------------------------------------------
**
**  Function:   SpmFreePkgList
**
**  Synopsis:   This function frees memory allocated for the package list. 
**
**  Arguments:  pData - Points to the private SPM data structure containing 
**                      the package list and the package info.
**
**  Returns:    void.
**
**  History:    LucyC       Created                             21 Oct. 1995
**
**---------------------------------------------------------------------------*/
static VOID
SpmFreePkgList (
    SspData *pData
    )
{
    int ii;

    for (ii = 0; ii < pData->PkgCnt; ii++)
    {
        LocalFree(pData->PkgList[ii]->pName);

        LocalFree(pData->PkgList[ii]);
    }

    LocalFree(pData->PkgList);
}


/*-----------------------------------------------------------------------------
**
**  Function:   Ssp__Unload
**
**  Synopsis:   This function is called by the Internet Explorer before 
**              the SPM DLL is unloaded from the memory.
**
**  Arguments:  fpUI - From Explorer for making all UI_SERVICE call
**              pvOpaqueOS - From Explorer for making all UI_SERVICE call
**              htspm - the SPM structure which contains the global data 
**                      storage for this SPM DLL.
**
**  Returns:    always returns SPM_STATUS_OK, which means successful.
**
**  History:    LucyC       Created                             25 Sept. 1995
**
**---------------------------------------------------------------------------*/
DWORD SSPI_Unload()
{
    if (!AuthLock())
    {
        return SPM_STATUS_INSUFFICIENT_BUFFER;
    }

    if (g_pSspData != NULL)
    {
        SpmFreePkgList(g_pSspData);
        LocalFree(g_pSspData);
        g_pSspData = NULL;
    }

    if (g_hSecLib)
    {
        FreeLibrary (g_hSecLib);
        g_hSecLib = NULL;
    }

    AuthUnlock();
        
    return SPM_STATUS_OK;
}

/*-----------------------------------------------------------------------------
**
**  Function:   SspSPM_InitData
**
**  Synopsis:   This function allocates and initializes global data structure 
**              of the SPM DLL.
**
**  Arguments:  
**
**  Returns:    Pointer to the allocated global data structure.
**
**  History:    LucyC       Created                             25 Sept. 1995
**
**---------------------------------------------------------------------------*/
LPVOID SSPI_InitGlobals(void)
{
    SspData *pData = NULL;
    OSVERSIONINFO   VerInfo;
    INIT_SECURITY_INTERFACE    addrProcISI = NULL;

    SECURITY_STATUS sstat;
    ULONG           ii, cntPkg;
    PSecPkgInfo     pPkgInfo = NULL;
    PSecurityFunctionTable    pFuncTbl = NULL;

    if (g_pSspData)
        return g_pSspData;

    static BOOL Initializing = FALSE;
    static BOOL Initialized = FALSE;

    if (!GlobalSSPIInitCritSec.Lock())
    {
        goto done;
    }

    if (Initializing) 
    {
        //if re-entered on same thread, fail.
        goto leave;
    }
    else if (g_pSspData)
    {
        //else some other thread succeeded, and we can fall out.
        goto leave;
    }
    else if (Initialized)
    {
        //else if we've failed initialization for non-entrancy reasons, don't reattempt
        goto leave;
    }

    Initializing = TRUE;

    //Ensure that the GlobalSSPIInitCritSec function is never abandoned.
    __try
    {
        //
        // Initialize SSP SPM Global Data
        //

        VerInfo.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);
        if (!GetVersionEx (&VerInfo))   // If this fails, something has gone wrong
        {
            goto quit;
        }

        if (VerInfo.dwPlatformId != VER_PLATFORM_WIN32_NT)
        {
            goto quit;
        }

        if ((pData = (SspData *) LocalAlloc(0, sizeof(SspData))) == NULL)    {
            
            goto quit;

        }

        //
        //  Keep these information in global SPM
        //
        ZeroMemory (pData, sizeof(SspData));

        //
        //  Load Security DLL
        //
        g_hSecLib = LoadLibrary (SSP_SPM_NT_DLL);
        if (g_hSecLib == NULL)
        {
            // This should never happen.
            LocalFree(pData);
            pData = NULL;
            goto Cleanup;
        }

        addrProcISI = (INIT_SECURITY_INTERFACE) GetProcAddress( g_hSecLib, 
                        SECURITY_ENTRYPOINT);       
        if (addrProcISI == NULL)
        {
            LocalFree(pData);
            pData = NULL;
            goto Cleanup;
        }

        //
        // Get the SSPI function table
        //
        pFuncTbl = (*addrProcISI)();

        //
        //  Get list of packages supported
        //
        sstat = (*(pFuncTbl->EnumerateSecurityPackages))(&cntPkg, &pPkgInfo);
        if (sstat != SEC_E_OK || pPkgInfo == NULL)
        {
            //
            // ??? Should we give up here ???
            // EnumerateSecurityPackage() failed
            //
            goto Cleanup;
        }

        if (cntPkg)
        {
            //
            //  Create the package list
            //
            if ((pData->PkgList = (PSSPAuthPkg *)LocalAlloc(0, 
                                                cntPkg*sizeof(PSSPAuthPkg))) == NULL)
            {
                goto Cleanup;
            }
        }

        for (ii = 0; ii < cntPkg; ii++)
        {
            //DebugTrace(SSPSPMID, "Found %s SSPI package\n", 
            //                     pPkgInfo[ii].Name);

            if (SpmAddSSPIPkg (pData, 
                               pPkgInfo[ii].Name,
                               pPkgInfo[ii].cbMaxToken
                               ) == SSPPKG_ERROR)
            {
                goto Cleanup;
            }
        }

        pData->pFuncTbl = pFuncTbl;
        pData->bKeepList = TRUE;

        if (pData->PkgCnt == 0)
        {
            goto Cleanup;
        }

        g_pSspData = pData;
        pData = NULL;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        goto Cleanup;
    }
    ENDEXCEPT

Cleanup:


    if( pPkgInfo != NULL )
    {
        //
        // Free buffer returned by the enumerate security package function
        //

        (*(pFuncTbl->FreeContextBuffer))(pPkgInfo);
    }

    if( pData != NULL )
    {
        SpmFreePkgList (pData);
    }

    /*
    if (g_hSecLib)
    {
        FreeLibrary (g_hSecLib);
        g_hSecLib = NULL;
    }
    */


quit: 
    Initialized = TRUE;
    Initializing = FALSE;

//jump here if you grabbed GlobalSSPIInitCritSec but don't want to affect Init*
leave:
    GlobalSSPIInitCritSec.Unlock();

//jump here IFF you didn't grab GlobalSSPIInitCritSec
done:
    return (g_pSspData);
}

INT
GetPkgId(LPTSTR  lpszPkgName)
{
    int ii;

    if ( g_pSspData == NULL )
    {
        return -1;
    }
    
    if (!AuthLock())
    {
        return -1;
    }
    
    for (ii = 0; ii < g_pSspData->PkgCnt; ii++)
    {
        if (!lstrcmp(g_pSspData->PkgList[ii]->pName, lpszPkgName))
        {
            AuthUnlock();
            return(ii);
        }
    }

    AuthUnlock();
    return(-1);
}

DWORD
GetPkgCapabilities(
    INT Package
    )
{
    if (!AuthLock())
    {
        return 0;
    }
    
    DWORD dwCaps;
    if ( Package < g_pSspData->PkgCnt )
    {
        dwCaps = g_pSspData->PkgList[ Package ]->Capabilities ;
    }
    else
        dwCaps = 0 ;

    AuthUnlock();
    return dwCaps;
}

ULONG
GetPkgMaxToken(
    INT Package
    )
{
    if (!AuthLock())
    {
        return MAX_AUTH_MSG_SIZE;
    }
    
    ULONG dwMaxToken;

    if ( Package < g_pSspData->PkgCnt )
    {
        dwMaxToken = g_pSspData->PkgList[ Package ]->cbMaxToken;
    }
    else {
        // be compatible with old static buffer size
        dwMaxToken = MAX_AUTH_MSG_SIZE;
    }

    AuthUnlock();
    return dwMaxToken;
}

//
//  Calls to this function are serialized
//

DWORD_PTR SSPI_InitScheme (LPCSTR lpszScheme)
{
    int ii;

       if (!SSPI_InitGlobals())
           return 0;
           
       if (!AuthLock())
       {
           return 0;
       }
    //  Once initialized, check to see if this scheme is installed 
    for (ii = 0; ii < g_pSspData->PkgCnt && 
        lstrcmp (g_pSspData->PkgList[ii]->pName, lpszScheme); ii++);

    if (ii >= g_pSspData->PkgCnt)
    {
        // This scheme is not installed on this machine
        AuthUnlock();
        return (0);
    }
    
    AuthUnlock();
    return ((DWORD_PTR)g_pSspData);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5.1\auth\plug.cxx ===
#include <wininetp.h>
#include <splugin.hxx>
#include "auth.h"
#include "sspspm.h"
#include "winctxt.h"

extern SspData  *g_pSspData;
/*-----------------------------------------------------------------------------
    PLUG_CTX
-----------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
    Load
---------------------------------------------------------------------------*/
DWORD PLUG_CTX::Load()
{
    INET_ASSERT(_pSPMData == _pCreds->pSPM);

    DWORD_PTR dwAuthCode = 0;

    dwAuthCode = SSPI_InitScheme (GetScheme());

    if (!dwAuthCode)
    {
        _pSPMData->eState = STATE_ERROR;
        return ERROR_WINHTTP_INTERNAL_ERROR;
    }

    _pSPMData->eState = STATE_LOADED;
    return ERROR_SUCCESS;
}


/*---------------------------------------------------------------------------
    ClearAuthUser
---------------------------------------------------------------------------*/
DWORD PLUG_CTX::ClearAuthUser(LPVOID *ppvContext, LPSTR szServer)
{
    if (GetState() == AUTHCTX::STATE_LOADED)
    {
        __try
        {
            UnloadAuthenticateUser(ppvContext, szServer, GetScheme());
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            DEBUG_PRINT(HTTP, ERROR,
                ("UnloadAuthenticateUser call down faulted\n"));
        }
        ENDEXCEPT
    }
    *ppvContext = 0;
    return ERROR_SUCCESS;
}

/*-----------------------------------------------------------------------------
    wQueryHeadersAlloc

Routine Description:

    Allocates a HTTP Header String, and queries the HTTP handle for it.

Arguments:

    hRequestMapped          - An open HTTP request handle
                               where headers can be quiered
    dwQuery                 - The Query Type to pass to HttpQueryHeaders
    lpdwQueryIndex          - The Index of the header to pass to HttpQueryHeaders,
                              make sure to inialize to 0.
    lppszOutStr             - On success, a pointer to Allocated string with header string,
    lpdwSize                - size of the string returned in lppszOutStr

Return Value:

    DWORD
    Success - ERROR_SUCCESS

    Failure - One of Several Error codes defined in winerror.h or wininet.w

Comments:

    On Error, lppszOutStr may still contain an allocated string that will need to be
    freed.
-----------------------------------------------------------------------------*/
DWORD PLUG_CTX::wQueryHeadersAlloc
(
    IN HINTERNET hRequestMapped,
    IN DWORD dwQuery,
    OUT LPDWORD lpdwQueryIndex,
    OUT LPSTR *lppszOutStr,
    OUT LPDWORD lpdwSize
)
{
    LPSTR lpszRawHeaderBuf = NULL;
    DWORD dwcbRawHeaderBuf = 0;
    DWORD error;
    DWORD length;
    HTTP_REQUEST_HANDLE_OBJECT * pHttpRequest;

    INET_ASSERT(lppszOutStr);
    INET_ASSERT(hRequestMapped);
    INET_ASSERT(lpdwSize);
    INET_ASSERT((dwQuery & HTTP_QUERY_HEADER_MASK) != HTTP_QUERY_CUSTOM);

    *lppszOutStr = NULL;
    error = ERROR_SUCCESS;
    pHttpRequest = (HTTP_REQUEST_HANDLE_OBJECT *) hRequestMapped;

    // Attempt to determine whether our header is there.
    length = 0;
    if (pHttpRequest->QueryInfo(dwQuery, NULL, NULL, &length, lpdwQueryIndex)
          != ERROR_INSUFFICIENT_BUFFER)
    {
        // no authentication happening, we're done
        error = ERROR_HTTP_HEADER_NOT_FOUND;
        goto quit;
    }

    // Allocate a Fixed Size Buffer
    lpszRawHeaderBuf = (LPSTR) ALLOCATE_ZERO_MEMORY(length);
    dwcbRawHeaderBuf = length;

    if ( lpszRawHeaderBuf == NULL )
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    error = pHttpRequest->QueryInfo
        (dwQuery, NULL, lpszRawHeaderBuf, &dwcbRawHeaderBuf, lpdwQueryIndex);

    INET_ASSERT(error != ERROR_INSUFFICIENT_BUFFER );
    INET_ASSERT(error != ERROR_HTTP_HEADER_NOT_FOUND );

quit:

    if ( error != ERROR_SUCCESS  )
    {
        dwcbRawHeaderBuf = 0;

        if ( lpszRawHeaderBuf )
            *lpszRawHeaderBuf = '\0';
    }

    *lppszOutStr = lpszRawHeaderBuf;
    *lpdwSize = dwcbRawHeaderBuf;

    return error;
}

/*-----------------------------------------------------------------------------
    CrackAuthenticationHeader

Routine Description:

    Attempts to decode a HTTP 1.1 Authentication header into its
    components.

Arguments:

    hRequestMapped           - Mapped Request handle
    fIsProxy                 - Whether proxy or server auth
    lpdwAuthenticationIndex  - Index of current HTTP header. ( initally called with 0 )
    lppszAuthHeader          - allocated pointer which should be freed by client
    lppszAuthScheme          - Pointer to Authentication scheme string.
    lppszRealm               - Pointer to Realm string,
    lpExtra                  - Pointer to any Extra String data in the header that is not
                                   part of the Realm
    lpdwExtra                - Pointer to Size of Extra data.
    lppszAuthScheme

  Return Value:

    DWORD
    Success - ERROR_SUCCESS

    Failure - ERROR_NOT_ENOUGH_MEMORY,
              ERROR_HTTP_HEADER_NOT_FOUND

Comments:
-----------------------------------------------------------------------------*/
DWORD PLUG_CTX::CrackAuthenticationHeader
(
    IN HINTERNET hRequestMapped,
    IN BOOL      fIsProxy,
    IN     DWORD dwAuthenticationIndex,
    IN OUT LPSTR *lppszAuthHeader,
    IN OUT LPSTR *lppszExtra,
    IN OUT DWORD *lpdwExtra,
       OUT LPSTR *lppszAuthScheme
    )
{
    DWORD error = ERROR_SUCCESS;

    LPSTR lpszAuthHeader = NULL;
    DWORD cbAuthHeader = 0;
    LPSTR lpszExtra = NULL;
    LPSTR lpszAuthScheme = NULL;

    LPDWORD lpdwAuthenticationIndex = &dwAuthenticationIndex;
    INET_ASSERT(lpdwExtra);
    INET_ASSERT(lppszExtra);
    INET_ASSERT(lpdwAuthenticationIndex);

    DWORD dwQuery = fIsProxy?
        HTTP_QUERY_PROXY_AUTHENTICATE : HTTP_QUERY_WWW_AUTHENTICATE;

    error = wQueryHeadersAlloc (hRequestMapped, dwQuery,
        lpdwAuthenticationIndex, &lpszAuthHeader, &cbAuthHeader);

    if ( error != ERROR_SUCCESS )
    {
        INET_ASSERT(*lpdwAuthenticationIndex
            || error == ERROR_HTTP_HEADER_NOT_FOUND );
        goto quit;
    }


    //
    // Parse Header for Scheme type
    //
    lpszAuthScheme = lpszAuthHeader;

    while ( *lpszAuthScheme == ' ' )  // strip spaces
        lpszAuthScheme++;

    lpszExtra = strchr(lpszAuthScheme, ' ');

    if (lpszExtra)
        *lpszExtra++ = '\0';

    if (lstrcmpi(GetScheme(), lpszAuthScheme))
    {
        DEBUG_PRINT(HTTP, ERROR,
               ("Authentication: HTTP Scheme has changed!: Scheme=%q\n",
                lpszAuthScheme));
        goto quit;

    }


    DEBUG_PRINT (HTTP, INFO,
        ("Authentication: found in headers: Scheme=%q, Extra=%q\n",
        lpszAuthScheme, lpszExtra));

quit:
    *lppszExtra  = lpszExtra;
    *lpdwExtra   = lpszExtra ? lstrlen(lpszExtra) : 0;
    *lppszAuthHeader = lpszAuthHeader;
    *lppszAuthScheme = lpszAuthScheme;
    return error;
}


/*---------------------------------------------------------------------------
    ResolveProtocol
---------------------------------------------------------------------------*/
VOID PLUG_CTX::ResolveProtocol()
{
    SECURITY_STATUS ssResult;
    PWINCONTEXT pWinContext;
    SecPkgContext_NegotiationInfo SecPkgCtxtInfo;

    INET_ASSERT(GetSchemeType() == WINHTTP_AUTH_SCHEME_NEGOTIATE);
    
    SecPkgCtxtInfo.PackageInfo = NULL;

    // Call QueryContextAttributes on the context handle.
    pWinContext = (PWINCONTEXT) (_pvContext);
    ssResult = (*(g_pSspData->pFuncTbl->QueryContextAttributes))
        (pWinContext->pSspContextHandle, SECPKG_ATTR_NEGOTIATION_INFO, &SecPkgCtxtInfo);

    if (ssResult == SEC_E_OK 
        && (SecPkgCtxtInfo.NegotiationState == SECPKG_NEGOTIATION_COMPLETE
            || (SecPkgCtxtInfo.NegotiationState == SECPKG_NEGOTIATION_OPTIMISTIC)))
    {
        // Resolve actual auth protocol from package name.
        // update both the auth context and Creds entry.
        if (!lstrcmpi(SecPkgCtxtInfo.PackageInfo->Name, "NTLM"))
        {
            _eSubScheme = WINHTTP_AUTH_SCHEME_NTLM;
            _dwSubFlags = PLUGIN_AUTH_FLAGS_NO_REALM;
        }
        else if (!lstrcmpi(SecPkgCtxtInfo.PackageInfo->Name, "Kerberos"))
        {
            _eSubScheme = WINHTTP_AUTH_SCHEME_KERBEROS;            
            _dwSubFlags = PLUGIN_AUTH_FLAGS_KEEP_ALIVE_NOT_REQUIRED | PLUGIN_AUTH_FLAGS_NO_REALM;
        }

// BUGBUG - This faults.
//        

    }

    if (SecPkgCtxtInfo.PackageInfo)
    {
        (*(g_pSspData->pFuncTbl->FreeContextBuffer))(SecPkgCtxtInfo.PackageInfo);
    }
}


/*---------------------------------------------------------------------------
    Constructor
---------------------------------------------------------------------------*/
PLUG_CTX::PLUG_CTX(HTTP_REQUEST_HANDLE_OBJECT *pRequest, BOOL fIsProxy,
                 SPMData *pSPM, AUTH_CREDS* pCreds)
    : AUTHCTX(pSPM, pCreds)
{
    _fIsProxy = fIsProxy;
    _pRequest = pRequest;
    _szAlloc = NULL;
    _szData = NULL;
    _cbData = 0;
    _pRequest->SetAuthState(AUTHSTATE_NONE);
    _fNTLMProxyAuth = _fIsProxy && (GetSchemeType() == WINHTTP_AUTH_SCHEME_NTLM);

    _pszFQDN = NULL;

    _fChallengeSeen = FALSE;
}

/*---------------------------------------------------------------------------
    Destructor
---------------------------------------------------------------------------*/
PLUG_CTX::~PLUG_CTX()
{
    if (GetState() == AUTHCTX::STATE_LOADED)
    {
        if (_pCreds)
        {
            if (_CtxCriSec.Lock())
            {
                ClearAuthUser(&_pvContext, _pCreds->lpszHost);

                _CtxCriSec.Unlock();
            }
        }
    }
    if (_pRequest)
    {
        _pRequest->SetAuthState(AUTHSTATE_NONE);
    }

    if (_pszFQDN)
    {
        FREE_MEMORY(_pszFQDN);
    }
}


/*---------------------------------------------------------------------------
    PreAuthUser
---------------------------------------------------------------------------*/
DWORD PLUG_CTX::PreAuthUser(OUT LPSTR pBuf, IN OUT LPDWORD pcbBuf)
{
    if (!_CtxCriSec.Lock())
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    INET_ASSERT(_pSPMData == _pCreds->pSPM);

    DWORD dwError;
    SECURITY_STATUS ssResult;

    //  Make sure the auth provider is loaded.
    if (GetState() != AUTHCTX::STATE_LOADED)
    {
        if (GetState() != AUTHCTX::STATE_ERROR )
            Load();
        if (GetState() != AUTHCTX::STATE_LOADED)
        {
            dwError = ERROR_WINHTTP_INTERNAL_ERROR;
            goto exit;
        }
    }

    BOOL fCanUseLogon = _fIsProxy 
        || _pRequest->SilentLogonOK(_pCreds->lpszHost);

    LPSTR lpszFQDN = GetFQDN(_pCreds->lpszHost);
    LPSTR lpszHostName =  lpszFQDN ? lpszFQDN : _pCreds->lpszHost;

    __try
    {
        ssResult = SEC_E_INTERNAL_ERROR;
        dwError = PreAuthenticateUser(&_pvContext,
                               lpszHostName,
                               GetScheme(),
                               fCanUseLogon,
                               0, // dwFlags
                               pBuf,
                               pcbBuf,
                               _pCreds->lpszUser,
                               _pCreds->lpszPass,
                               &ssResult);


        // Transit to the correct auth state.
        if (ssResult == SEC_E_OK || ssResult == SEC_I_CONTINUE_NEEDED)
        {
            if (GetSchemeType() == WINHTTP_AUTH_SCHEME_NEGOTIATE)
                ResolveProtocol();

            // Kerberos + SEC_E_OK or SEC_I_CONTINUE_NEEDED transits to challenge.
            // Negotiate does not transit to challenge.
            // Any other protocol + SEC_E_OK only transits to challenge.
            if ((GetSchemeType() == WINHTTP_AUTH_SCHEME_KERBEROS
                && (ssResult == SEC_E_OK || ssResult == SEC_I_CONTINUE_NEEDED))
                || (GetSchemeType() != WINHTTP_AUTH_SCHEME_NEGOTIATE && ssResult == SEC_E_OK))
            {
                _pRequest->SetAuthState(AUTHSTATE_CHALLENGE);
            }        
        }
    }

    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        DEBUG_PRINT (HTTP, ERROR, ("preAuthenticateUser call down faulted\n"));
        _pSPMData->eState = STATE_ERROR;
        dwError = ERROR_WINHTTP_INTERNAL_ERROR;
    }

    ENDEXCEPT

exit:
    _CtxCriSec.Unlock();
    return dwError;
}


/*---------------------------------------------------------------------------
    UpdateFromHeaders
---------------------------------------------------------------------------*/
DWORD PLUG_CTX::UpdateFromHeaders(HTTP_REQUEST_HANDLE_OBJECT *pRequest, BOOL fIsProxy)
{
    DWORD dwError, cbExtra = 0, dwAuthIdx;
    LPSTR szAuthHeader = NULL, szExtra = NULL, szScheme;

    // Get the auth header index corresponding to the scheme of this ctx.
    if ((dwError = FindHdrIdxFromScheme(&dwAuthIdx)) != ERROR_SUCCESS)
        goto quit;

    // Get the scheme and any extra data.
    if ((dwError = CrackAuthenticationHeader(pRequest, fIsProxy, dwAuthIdx,
        &szAuthHeader, &szExtra, &cbExtra, &szScheme)) != ERROR_SUCCESS)
        goto quit;
    
    if (!cbExtra)
    {
        if (_fChallengeSeen)
        {
            dwError = ERROR_HTTP_HEADER_NOT_FOUND;
            goto quit;
        }

        _pRequest->SetAuthState(AUTHSTATE_NEGOTIATE);
    }

    // Check if auth scheme requires keep-alive.
    if (!(GetFlags() & PLUGIN_AUTH_FLAGS_KEEP_ALIVE_NOT_REQUIRED))
    {
        // if in negotiate phase check if we are going via proxy.
        if (pRequest->GetAuthState() == AUTHSTATE_NEGOTIATE)
        {
            // BUGBUG: if via proxy, we are not going to get keep-alive
            // connection to the server.  It would be nice if we knew
            // a priori the whether proxy would allow us to tunnel to
            // http port on the server.  Otherwise if we try and fail,
            // we look bad vs. other browsers who are ignorant of ntlm
            // and fall back to basic.
            CHAR szBuffer[64];
            DWORD dwBufferLength = sizeof(szBuffer);
            DWORD dwIndex = 0;
            BOOL fSessionBasedAuth = FALSE;
            if (pRequest->QueryResponseHeader(HTTP_QUERY_PROXY_SUPPORT, 
                                          szBuffer, &dwBufferLength, 
                                          0, &dwIndex) == ERROR_SUCCESS)
            {
                if (!_stricmp(szBuffer, "Session-Based-Authentication"))
                {
                    fSessionBasedAuth = TRUE;
                }
            }
            if (!fIsProxy && pRequest->IsRequestUsingProxy()
                && !pRequest->IsTalkingToSecureServerViaProxy() && !fSessionBasedAuth)
            {
                // Ignore NTLM via proxy since we won't get k-a to server.
                dwError = ERROR_HTTP_HEADER_NOT_FOUND;
                goto quit;
            }
        }

        // Else if in challenge phase, we require a persistent connection.
        else
        {
            // If we don't have a keep-alive connection ...
            if (!(pRequest->IsPersistentConnection (fIsProxy)))
            {
                dwError = ERROR_HTTP_HEADER_NOT_FOUND;
                goto quit;
            }
        }

    } // end if keep-alive required

    _fChallengeSeen = TRUE;

    quit:

    if (dwError == ERROR_SUCCESS)
    {
        // If no password cache is set in the auth context,
        // find or create one and set it in the handle.
        if (!_pCreds)
        {
            _pCreds = CreateCreds(pRequest, fIsProxy, _pSPMData, NULL);

            if (!_pCreds)
            {
                INET_ASSERT(FALSE);
                dwError = ERROR_WINHTTP_INTERNAL_ERROR;
            }
            else
            {
                INET_ASSERT(_pCreds->pSPM == _pSPMData);
            }
        }
    }

    if (dwError == ERROR_SUCCESS)
    {
        // Point to allocated data.
        _szAlloc = szAuthHeader;
        _szData = szExtra;
        _cbData = cbExtra;
    }
    else
    {
        // Free allocated data.
        if (_szAlloc)
            delete _szAlloc;
        _szAlloc = NULL;
        _szData = NULL;
        _cbData = 0;
    }

    // Return of non-success will cancel auth session.
    return dwError;
}



/*---------------------------------------------------------------------------
    PostAuthUser
---------------------------------------------------------------------------*/
DWORD PLUG_CTX::PostAuthUser()
{
    if (!_CtxCriSec.Lock())
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    INET_ASSERT(_pSPMData == _pCreds->pSPM);
    DWORD dwError;

    //  Make sure the auth provider is loaded.
    if (GetState() != AUTHCTX::STATE_LOADED)
    {
        if (GetState() != AUTHCTX::STATE_ERROR )
            Load();
        if (GetState() != AUTHCTX::STATE_LOADED)
        {
            dwError = ERROR_WINHTTP_INTERNAL_ERROR;
            goto exit;
        }
    }

    BOOL fCanUseLogon = _fIsProxy 
        || _pRequest->SilentLogonOK(_pCreds->lpszHost);

    if (_fDisableAutoLogon)
    {
        fCanUseLogon = FALSE;
    }

    LPSTR lpszFQDN = GetFQDN(_pCreds->lpszHost);
    LPSTR lpszHostName = lpszFQDN ? lpszFQDN : _pCreds->lpszHost;

    SECURITY_STATUS ssResult;
    __try
    {
        ssResult = SEC_E_INTERNAL_ERROR;
        dwError = AuthenticateUser(&_pvContext,
                                   lpszHostName,
                                   GetScheme(),
                                   fCanUseLogon,
                                   _szData,
                                   _cbData,
                                   _pCreds->lpszUser,
                                   _pCreds->lpszPass,
                                   &ssResult);



        // Kerberos package can get into a bad state.
        if (GetSchemeType() == WINHTTP_AUTH_SCHEME_KERBEROS && ssResult == SEC_E_WRONG_PRINCIPAL)
            dwError = ERROR_WINHTTP_INCORRECT_PASSWORD;
            
        // Transit to the correct auth state.
        if (ssResult == SEC_E_OK || ssResult == SEC_I_CONTINUE_NEEDED)
        {
            if (GetSchemeType() == WINHTTP_AUTH_SCHEME_NEGOTIATE)
                ResolveProtocol();

            // Kerberos + SEC_E_OK or SEC_I_CONTINUE_NEEDED transits to challenge.
            // Negotiate does not transit to challenge.
            // Any other protocol + SEC_E_OK only transits to challenge.
            if ((GetSchemeType() == WINHTTP_AUTH_SCHEME_KERBEROS
                && (ssResult == SEC_E_OK || ssResult == SEC_I_CONTINUE_NEEDED))
                || (GetSchemeType() != WINHTTP_AUTH_SCHEME_NEGOTIATE && ssResult == SEC_E_OK))
            {
                _pRequest->SetAuthState(AUTHSTATE_CHALLENGE);
            }        
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        DEBUG_PRINT (HTTP, ERROR, ("AuthenticateUser faulted!\n"));
        dwError = ERROR_BAD_FORMAT;
        _pSPMData->eState = STATE_ERROR;
    }
    ENDEXCEPT

    if (_szAlloc)
    {
        delete _szAlloc;
        _szAlloc = NULL;
        _szData = NULL;
    }

    _cbData = 0;

exit:
    _CtxCriSec.Unlock();
    return dwError;
}

LPSTR PLUG_CTX::GetFQDN(LPSTR lpszHostName)
{
    if (lstrcmpi(GetScheme(), "Negotiate")) // only need to get FQDN for Kerberos
    {
        return NULL;
    }

    if (_pszFQDN)
    {
        return _pszFQDN;
    }

    SERIALIZED_LIST* pResolverCache = GetRootHandle(_pRequest)->GetResolverCache()->GetResolverCacheList();
    LPADDRINFO lpAddrInfo;
    DWORD TTL;
    LPRESOLVER_CACHE_ENTRY lpResolverCacheEntry;
    if ((lpResolverCacheEntry=QueryResolverCache(pResolverCache,
                                            (LPSTR)lpszHostName, 
                                            NULL, 
                                            &lpAddrInfo, 
                                            &TTL)) != NULL) 
    {
        _pszFQDN = (lpAddrInfo->ai_canonname ? NewString(lpAddrInfo->ai_canonname) : NULL);
        ReleaseResolverCacheEntry(pResolverCache, lpResolverCacheEntry);
        return _pszFQDN;
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5.1\auth\splugin.cxx ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    splugin.cxx

Abstract:

    This file contains the implementation for Plug In Authentication

    The following functions are exported by this module:

    AuthOnRequest
    AuthOnResponse
    AuthCtxClose
    AuthInDialog
    AuthNotify
    AuthUnload

Author:

    Arthur Bierer (arthurbi) 25-Dec-1995

Revision History:
 
    Rajeev Dujari (rajeevd)  01-Oct-1996 overhauled

    Adriaan Canter (adriaanc) 01-03-1998 :
    AUTHCTX now a virtual base class, from which derived classes
    inherit to implement the different authentication protocols:

    BASIC_CTX  (Basic auth),
    PLUG_CTX   (NTLM, Negotiate)
    DIGEST_CTX (Digest auth, new)


--*/

#include <wininetp.h>
#include <splugin.hxx>
#include "auth.h"
#include "sspspm.h"

//
// constants
//

#define WILDCARD 0x05 // don't use '*' since it can appear in an URL
#define AssertHaveLock() INET_ASSERT(g_dwOwnerId == GetCurrentThreadId())

#define MAX_AUTH_HDR_SIZE (MAX_BLOB_SIZE + HTTP_PROXY_AUTHORIZATION_LEN + 2)

//
//  globals
//

// Global authentication providers list and state.
AUTHCTX::SPMState  AUTHCTX::g_eState;
AUTHCTX::SPMData  *AUTHCTX::g_pSPMList = NULL;


// Global auth crit sect.
CCritSec g_crstAuth;

#ifdef DBG
DWORD g_dwOwnerId = 0;
LONG g_nLockCount = 0;
#endif

//
// private prototypes
//

//-----------------------------------------------------------------------------
//
//  AUTH_CREDS class definition.
//
//
PRIVATE AUTH_CREDS *Creds_Create
(
    LPSTR lpszHost,
    LPSTR lpszRealm,
    AUTHCTX::SPMData* pSPM
);

void  Creds_Free (AUTH_CREDS *Creds);



//-----------------------------------------------------------------------------
//
//  Utilities
//
//

PRIVATE VOID SspiFlush (LPSTR pszDll);
PRIVATE BOOL TemplateMatch(LPSTR lpszTemplate, LPSTR lpszFilename);
PRIVATE LPSTR MakeTemplate (LPSTR docname);
PRIVATE LPSTR GetProxyName (HTTP_REQUEST_HANDLE_OBJECT *pRequest);

PRIVATE BOOL ReadRegKey(
    BYTE * pbRegValue,
    DWORD * pdwNumBytes,
    LPSTR  pszRegKey,
    LPSTR  pszRegValueName,
    DWORD  dwRegTypeExpected);



//-----------------------------------------------------------------------------
//
//
//      AUTH_CREDS functions
//
//          Creds_CREATE
//          Creds_FREE
//          SetUser
//          SetPass
//          FlushCredsList
//

PRIVATE AUTH_CREDS *Creds_Create // AUTH_CREDS constructor
(
    LPSTR lpszHost,     // Host Name to place in structure.
    LPSTR lpszRealm,    // Realm string to add.
    AUTHCTX::SPMData * pSPM
)
{
    AUTH_CREDS* Creds = (AUTH_CREDS *) ALLOCATE_ZERO_MEMORY(sizeof(*Creds));
    if (!Creds)
        return NULL;

    INET_ASSERT (!Creds->lpszHost);
    Creds->lpszHost    = lpszHost ?  NewString(lpszHost)   : NULL;
    
    INET_ASSERT (!Creds->lpszRealm);
    Creds->lpszRealm   = lpszRealm ? NewString(lpszRealm)  : NULL;
    Creds->pSPM         = pSPM;

    if (  (!Creds->lpszHost  && lpszHost)
       || (!Creds->lpszRealm && lpszRealm)
       )
    {
        Creds_Free(Creds);
        return NULL;
    }

    return Creds;
}

PRIVATE VOID Creds_Free(AUTH_CREDS *Creds) // AUTH_CREDS destructor
{
    if ( Creds )
    {
        if (Creds->lpszHost)
            FREE_MEMORY(Creds->lpszHost);
        if ( Creds->lpszUser )
        {
            memset(Creds->lpszUser, 0, strlen(Creds->lpszUser));
            FREE_MEMORY(Creds->lpszUser);
        }
        if ( Creds->lpszPass )
        {
            memset(Creds->lpszPass, 0, strlen(Creds->lpszPass));
            FREE_MEMORY(Creds->lpszPass);
        }
        if ( Creds->lpszRealm )
            FREE_MEMORY(Creds->lpszRealm);
        FREE_MEMORY(Creds);
    }
}

PUBLIC DWORD AUTH_CREDS::SetUser (LPSTR lpszInput)
{
    //AssertHaveLock();
    if (!lpszInput)
    {
        if (lpszUser)
        {
            memset(lpszUser, 0, strlen(lpszUser));
            FREE_MEMORY (lpszUser);
        }
        lpszUser = NULL;
        return ERROR_SUCCESS;
    }
    if (lpszUser && !lstrcmp (lpszUser, lpszInput))
        return ERROR_SUCCESS; // didn't change
    LPSTR lpszTemp = NewString(lpszInput);
    if (!lpszTemp)
        return ERROR_NOT_ENOUGH_MEMORY;
    if (lpszUser)
        FREE_MEMORY (lpszUser);
    lpszUser = lpszTemp;
    return ERROR_SUCCESS;
}

PUBLIC DWORD AUTH_CREDS::SetPass (LPSTR lpszInput)
{
    //AssertHaveLock();
    if (!lpszInput)
    {
        if (lpszPass)
        {
            memset(lpszPass, 0, strlen(lpszPass));
            FREE_MEMORY (lpszPass);
        }
        lpszPass = NULL;
        return ERROR_SUCCESS;
    }
    if (lpszPass && !lstrcmp (lpszPass, lpszInput))
        return ERROR_SUCCESS; // didn't change
    LPSTR lpszTemp = NewString(lpszInput);
    if (!lpszTemp)
        return ERROR_NOT_ENOUGH_MEMORY;
    if (lpszPass)
        FREE_MEMORY (lpszPass);
    lpszPass = lpszTemp;
    return ERROR_SUCCESS;
}


/*++
Delete some entries from a singly linked list.
--*/
/*
PRIVATE void FlushCredsList (AUTH_CREDS **ppList)
{
    AssertHaveLock();

    AUTH_CREDS *Creds = *ppList;
    while (Creds)
    {
        AUTH_CREDS *CredsNext = Creds->pNext;

        if (!Creds->nLockCount)
            Creds_Free (Creds);
        else
        {
            *ppList = Creds;
            ppList = &(Creds->pNext);
        }

        Creds = CredsNext;
    }
    *ppList = NULL;
}
*/


//-----------------------------------------------------------------------------
//
//
//      Auth* functions
//
//          AuthOpen
//          AuthClose
//          AuthLock
//          AuthUnlock
//          AuthInDialog
//          AuthNotify
//          AuthFlush
//
//

BOOL AuthOpen (void)
{
    INET_ASSERT (!g_dwOwnerId && !g_nLockCount);
    return g_crstAuth.Init();
}

void AuthClose (void)
{
    g_crstAuth.FreeLock();
    INET_ASSERT (!g_dwOwnerId && !g_nLockCount);
}

BOOL AuthLock (void)
{
    INET_ASSERT(g_crstAuth.IsInitialized() == TRUE);
    if (!g_crstAuth.Lock())
    {
        INET_ASSERT(FALSE);
        return FALSE;
    }
    DEBUG_ONLY (if (!g_nLockCount++) g_dwOwnerId = GetCurrentThreadId();)
    return TRUE;
}

void AuthUnlock (void)
{
    INET_ASSERT(g_crstAuth.IsInitialized() == TRUE);
    INET_ASSERT (g_nLockCount > 0);
    DEBUG_ONLY (if (!--g_nLockCount) g_dwOwnerId = 0;)
    g_crstAuth.Unlock();
}

/*++
Flush any server and proxy password cache entries not in use.
--*/
PUBLIC void AuthFlush (void)
{
    // Serialize access to globals.
    if (AuthLock())
    {
        if (!g_cSspiContexts)
            AUTHCTX::UnloadAll();

        DIGEST_CTX::FlushCreds();

        AuthUnlock();
    }
}


PUBLIC void AuthUnload (void)
/*++
Routine Description:
    Frees all Cached URLs, and unloads any loaded DLL authentication modeles.

--*/
{
    if (g_crstAuth.IsInitialized())
    {
        AuthFlush();
        if (AuthLock())
        {
            AUTHCTX::UnloadAll();
            AuthUnlock();
        }
    }
}


//-----------------------------------------------------------------------------
//
//
//      Utility Functions:
//
//          SspiFlush
//          TemplateMatch
//          MakeTemplate
//          GetProxyName
//          ReadRegKey
//          TrimQuotes
//          TrimWhiteSpace
//          GetDelimitedToken
//          GetKeyValuePair
//
//


typedef BOOL (WINAPI * SSPI_FLUSH) (VOID) ;

void SspiFlush (LPSTR pszDll)
{
    __try
    {
        HINSTANCE hinst = GetModuleHandle (pszDll);

        if (hinst)
        {
            SSPI_FLUSH pfnFlush = (SSPI_FLUSH)
                GetProcAddress (hinst, "CleanupCredentialCache");

            if (pfnFlush)
            {
                (*pfnFlush) ();
            }
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        INET_ASSERT (FALSE);
    }
    ENDEXCEPT
}



PRIVATE BOOL TemplateMatch(LPSTR lpszTemplate, LPSTR lpszFilename)

/*++

Routine Description:

    Attempts to match a template URL string with a URL ( FileName )

Arguments:

    lpszTemplate             - Template to match against.
    lpszFilename             - URL to match with the template

Return Value:

    BOOL
    Success - TRUE - match
    Failure - FALSE - no match

Comments:

    Note: This Legacy code from the SpyGlass IE 1.0 browser

--*/

{
    /* code for this routine cloned from HTAA_templateMatch() */

    CHAR *p = lpszTemplate;
    CHAR *q = lpszFilename;
    int m;

    if (!lpszTemplate || !lpszFilename)
        return 0;

    for (; *p && *q && *p == *q; p++, q++)  /* Find first mismatch */
        ;                                                                       /* do nothing else */

    if (!*p && !*q)
        return 1;                                                       /* Equally long equal strings */
    else if (WILDCARD == *p)
    {                                                                               /* Wildcard */
        p++;                                                            /* Skip wildcard character */
        m = strlen(q) - strlen(p);                      /* Amount to match to wildcard */
        if (m < 0)
            return 0;                                               /* No match, filename too short */
        else
        {                                                                       /* Skip the matched characters and compare */
        if (lstrcmp(p, q + m))
                return 0;                                       /* Tail mismatch */
            else
                return 1;                                       /* Tail match */
        }
    }                                                                               /* if wildcard */
    else
        return 0;                                                       /* Length or character mismatch */
}


PRIVATE LPSTR MakeTemplate (LPSTR docname)

/*++
Routine Description:
    Makes a Template String (from a URL) that can later be used to match a range of URLs.

Arguments:
    ppszTemplate             - pointer to pointer of where Template can be stored
    docname                  - URL to create a template with.

Return Value: BOOL
    Success - TRUE - created
    Failure - FALSE - error

Comments:
    Note: This Legacy code from the SpyGlass IE 1.0 browser
--*/

{
    CHAR *pszTemplate = NULL;
    unsigned long k;
    k = 0;

    if (docname)
    {
        CHAR *slash;
        CHAR *first_slash;

        //
        // Ignore everything after first reserved character.
        //

        BYTE chSave = 0;
        LPSTR lpszScan = docname;
        while (*lpszScan)
        {
            if (*lpszScan == '?' || *lpszScan == ';')
            {
                chSave = *lpszScan;
                *lpszScan = 0;
                break;
            }
            lpszScan++;
        }

        slash = strrchr(docname, '/');

        //
        // If there is a "//" and no other slashes,
        //  then make sure not to chop the hostname off
        //  the URL. ex: http://www.netscape.com
        //  should be //www.netscape.com* not //*
        //

        if (slash)
        {
            first_slash = strchr(docname, '/' );
            if ((first_slash+1) == slash)
                k = lstrlen(docname);
            else
                k = (unsigned long)(slash-docname)+1;
        }

        // Restore any reserved character (or rewrite terminating null)
        *lpszScan = chSave;
    }

    pszTemplate = (CHAR *) ALLOCATE_FIXED_MEMORY(k+2);
    if (!pszTemplate)
        return 0;

    memcpy(pszTemplate, docname, k);
    pszTemplate[k]= WILDCARD;
    pszTemplate[k+1]=0;

    DEBUG_PRINT(HTTP, INFO, ("MakeTemplate: made template [%s] from [%s]\n",
        pszTemplate, docname ));

    return pszTemplate;
}

LPSTR GetProxyName (HTTP_REQUEST_HANDLE_OBJECT *pRequest)
{
    // Get the proxy name.
    LPSTR lpszProxy;
    DWORD cbProxy;
    INTERNET_PORT port;

   pRequest->GetProxyName(
                &lpszProxy,
                &cbProxy,
                &port);

   return lpszProxy;
}


//++------------------------------------------------------------------------
//
//   Function: ReadRegKey
//
//   Synopsis: This function reads a registry key.
//
//   Arguments:
//
//   Returns:   TRUE     no error
//                 FALSE    a fatal error happened
//
//   History:      AshishS    Created     5/22/96
//------------------------------------------------------------------------

BOOL ReadRegKey(
    BYTE * pbRegValue, // The value of the reg key will be
                 // stored here
    DWORD * pdwNumBytes, // Pointer to DWORD conataining
     // the number of bytes in the above buffer - will be
     // set to actual bytes stored.
    LPSTR  pszRegKey, // Reg Key to be opened
    LPSTR  pszRegValueName, // Reg Value to query
    DWORD  dwRegTypeExpected) // Expected type of Value
{
    HKEY   hRegKey;
    DWORD  dwRegType;
    LONG lResult;

     //read registry to find out name of the file
    if ( (lResult = REGOPENKEYEX(HKEY_LOCAL_MACHINE,
                                 pszRegKey, // address of subkey name
                                 0,          // reserved
                                 KEY_READ,   // samDesired
                                 &hRegKey
                                  // address of handle of open key
        )) != ERROR_SUCCESS )
    {
        goto cleanup;
    }


    if ( (lResult =RegQueryValueEx( hRegKey,
                                    pszRegValueName,
                                    0,           // reserved
                                    &dwRegType,// address of buffer
                                     // for value type
                                    pbRegValue,
                                    pdwNumBytes)) != ERROR_SUCCESS )
    {
        REGCLOSEKEY(hRegKey);
        goto cleanup;
    }

    REGCLOSEKEY(hRegKey);

    if ( dwRegType != dwRegTypeExpected )
    {
        goto cleanup;
    }

    return TRUE;

cleanup:

    return FALSE;

}


/*-----------------------------------------------------------------------------
Inplace trim of one leading and one trailing quote.
-----------------------------------------------------------------------------*/
VOID TrimQuotes(LPSTR *psz, LPDWORD pcb)
{
    if (*pcb && (**psz == '"'))
    {
        (*psz)++;
        (*pcb)--;
    }
    if (*pcb && (*(*psz + *pcb - 1) == '"'))
        (*pcb)--;
}

/*-----------------------------------------------------------------------------
Inplace trim of leading and trailing whitespace.
-----------------------------------------------------------------------------*/
VOID TrimWhiteSpace(LPSTR *psz, LPDWORD pcb)
{
    DWORD cb = *pcb;
    CHAR* beg = *psz;
    CHAR* end = beg + cb - 1;

    while ((cb != 0) && ((*beg == ' ') || (*beg == '\t')))
    {
        beg++;
        cb--;
    }

    while ((cb != 0) && ((*end == ' ') || (*end == '\t')))
    {
        end--;
        cb--;
    }

    *psz = beg;
    *pcb = cb;
}

/*-----------------------------------------------------------------------------
Inplace strtok based on one delimiter. Ignores delimiter scoped by quotes.
-----------------------------------------------------------------------------*/
BOOL GetDelimitedToken(LPSTR* pszBuf,   LPDWORD pcbBuf,
                       LPSTR* pszTok,   LPDWORD pcbTok,
                       CHAR   cDelim)
{
    CHAR *pEnd;
    BOOL fQuote = FALSE,
         fRet   = FALSE;

    *pcbTok = 0;
    *pszTok = *pszBuf;
    pEnd = *pszBuf + *pcbBuf - 1;

    while (*pcbBuf)
    {
        if ( ((**pszBuf == cDelim) && !fQuote)
            || (*pszBuf == pEnd)
            || (**pszBuf =='\r')
            || (**pszBuf =='\n'))
        {
            fRet = TRUE;
            break;
        }

        if (**pszBuf == '"')
            fQuote = !fQuote;

        (*pszBuf)++;
        (*pcbBuf)--;
    }

    if (fRet)
    {
        *pcbBuf = (DWORD) (pEnd - *pszBuf);
        if (**pszBuf == cDelim)
        {
            *pcbTok = (DWORD)(*pszBuf - *pszTok);
            (*pszBuf)++;
        }
        else
            *pcbTok = (DWORD) (*pszBuf - *pszTok) + 1;
    }

    return fRet;
}


/*-----------------------------------------------------------------------------
Inplace retrieval of key and value from a buffer of form key = <">value<">
-----------------------------------------------------------------------------*/
BOOL GetKeyValuePair(LPSTR  szB,    DWORD cbB,
                     LPSTR* pszK,   LPDWORD pcbK,
                     LPSTR* pszV,   LPDWORD pcbV)
{
    if (GetDelimitedToken(&szB, &cbB, pszK, pcbK, '='))
    {
        TrimWhiteSpace(pszK, pcbK);

        if (cbB)
        {
            *pszV = szB;
            *pcbV = cbB;
            TrimWhiteSpace(pszV, pcbV);
        }
        else
        {
            *pszV = NULL;
            *pcbV = 0;
        }
        return TRUE;
    }

    else
    {
        *pszK  = *pszV  = NULL;
        *pcbK  = *pcbV = 0;
    }
    return FALSE;
}


//-----------------------------------------------------------------------------
//
//
//      Main authentication functions:
//
//          AddAuthorizationHeader
//          AuthOnRequest
//          ProcessResponseHeader
//          AuthOnRequest
//
//



/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/
PRIVATE void AddAuthorizationHeader
(
    HTTP_REQUEST_HANDLE_OBJECT *pRequest,
    AUTHCTX* pAuthCtx
)
{
    if (!pAuthCtx)
        return;

    INET_ASSERT(pAuthCtx->_pSPMData);

    // AssertHaveLock();

    // Call the auth package.
    // CHAR *szHeader;
    // DWORD dwFastHeaderSize = MAX_BLOB_SIZE + HTTP_PROXY_AUTHORIZATION_LEN + 2;
    // CHAR* pszFastHeader = NULL;
    CHAR *szSlowHeader = NULL;
    // ULONG cbHeader;
    LPSTR pBuf;
    DWORD cbBuf;
    DWORD dwPlugInError;
    // CHAR *pszHeader;

    /*
    pszFastHeader = (CHAR*)ALLOCATE_FIXED_MEMORY(dwFastHeaderSize);
    if (!pszFastHeader)
    {
        // Don't worry about reporting an error.
        // Since this is a low mem condition, the only failure resulting
        // from this is that the header won't be added, and this won't
        // directly cause any more harm than unexpectedly failing to
        // authenticate, which isn't bad, given the low mem state.
        return;
    }
    */


    INT PackageId;
    ULONG cbMaxToken;

    //
    // GetPkgMaxToken() will return 10000 if invalid pkg.
    //

    if( (pAuthCtx->_pSPMData) &&
        (pAuthCtx->_pSPMData->szScheme) &&
        ((PackageId = GetPkgId( pAuthCtx->_pSPMData->szScheme )) != -1)
        )
    {
        cbMaxToken = GetPkgMaxToken( PackageId );
    } else {
        cbMaxToken = MAX_AUTH_MSG_SIZE;
    }

    //
    // add space for base64 overhead (33%, but round up)
    //

    cbMaxToken += (cbMaxToken/2);
    
    // Prefix with the appropriate header.

    /*
    if( cbMaxToken < dwFastHeaderSize )
    {
        cbHeader = dwFastHeaderSize;
        szHeader = pszFastHeader;
    } else {
        cbHeader = cbMaxToken;
        */
        szSlowHeader = (CHAR*)ALLOCATE_FIXED_MEMORY(cbMaxToken);

        if( szSlowHeader == NULL )
        {
            //
            // no clean way to report an error here.  just try with the stack
            // buffer.
            //
            /*
            cbHeader = dwFastHeaderSize;
            szHeader = pszFastHeader;
        } else {
            szHeader = szSlowHeader;  */
            return;
        }
    //}

    if (pAuthCtx->_fIsProxy)
    {
        memcpy (szSlowHeader, HTTP_PROXY_AUTHORIZATION_SZ, HTTP_PROXY_AUTHORIZATION_LEN);
        pBuf = szSlowHeader + HTTP_PROXY_AUTHORIZATION_LEN;

        // Don't reuse this keep-alive socket after a password cache flush.
        pRequest->SetAuthorized();
    }
    else
    {
        memcpy (szSlowHeader, HTTP_AUTHORIZATION_SZ, HTTP_AUTHORIZATION_LEN);
        pBuf = szSlowHeader + HTTP_AUTHORIZATION_LEN;

        // Don't reuse a keep-alive socket after a password cache flush.
        pRequest->SetAuthorized();
    }

    *pBuf++ = ' ';
    cbBuf = cbMaxToken - HTTP_PROXY_AUTHORIZATION_LEN - 2;
    INET_ASSERT (HTTP_PROXY_AUTHORIZATION_LEN >= HTTP_AUTHORIZATION_LEN);


    dwPlugInError =
        pAuthCtx->PreAuthUser(pBuf, &cbBuf);

    //  If the plug in did not fail, add its header to the outgoing header list
    if (dwPlugInError == ERROR_SUCCESS && pAuthCtx->GetState() != AUTHCTX::STATE_ERROR)
    {
        // Append CR-LF.
        pBuf += cbBuf;
        *pBuf++ = '\r';
        *pBuf++ = '\n';
        *pBuf = 0;
        cbBuf = (DWORD) (pBuf - szSlowHeader);

        // Add or replace the (proxy-)authorization header.
        wHttpAddRequestHeaders (pRequest, szSlowHeader, cbBuf,
            HTTP_ADDREQ_FLAG_ADD | HTTP_ADDREQ_FLAG_REPLACE);

    }

    // delete [] pszHeader;
    if( szSlowHeader )
    {
        FREE_MEMORY( szSlowHeader );
    }

    /*
    if (pszFastHeader)
    {
        FREE_MEMORY( pszFastHeader );
    }
    */

    //DEBUG_LEAVE(0);
}

// biaow: move this to a better place

PSTR DwordSchemeToString(DWORD dwScheme)
{
    switch (dwScheme)
    {
    case WINHTTP_AUTH_SCHEME_BASIC:
        return "Basic";
    case WINHTTP_AUTH_SCHEME_NTLM:
        return "NTLM";
    case WINHTTP_AUTH_SCHEME_PASSPORT:
        return "Passport1.4";
    case WINHTTP_AUTH_SCHEME_DIGEST:
        return "Digest";
    case WINHTTP_AUTH_SCHEME_NEGOTIATE:
        return "Negotiate";
    default:
        return "";
    }
}

DWORD DwordSchemeToFlags(DWORD dwScheme)
{
    switch (dwScheme)
    {
    case WINHTTP_AUTH_SCHEME_BASIC:
        return PLUGIN_AUTH_FLAGS_KEEP_ALIVE_NOT_REQUIRED;
    case WINHTTP_AUTH_SCHEME_NTLM:
        return PLUGIN_AUTH_FLAGS_NO_REALM;
    case WINHTTP_AUTH_SCHEME_PASSPORT:
        return PLUGIN_AUTH_FLAGS_KEEP_ALIVE_NOT_REQUIRED;
    case WINHTTP_AUTH_SCHEME_DIGEST:
        return PLUGIN_AUTH_FLAGS_KEEP_ALIVE_NOT_REQUIRED | PLUGIN_AUTH_FLAGS_CAN_HANDLE_UI;
    case WINHTTP_AUTH_SCHEME_NEGOTIATE:
        return PLUGIN_AUTH_FLAGS_KEEP_ALIVE_NOT_REQUIRED | PLUGIN_AUTH_FLAGS_NO_REALM;
    default:
        return 0;
    }
}

/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/
PUBLIC DWORD AuthOnRequest (IN HINTERNET hRequestMapped)
{
    DEBUG_ENTER ((DBG_HTTP, Dword, "AuthOnRequest", "%#x", hRequestMapped));

    DWORD dwError = ERROR_SUCCESS;
    LPSTR lpszUser, lpszPass;
    
    // Get username, password, url, and auth context from request handle.
    HTTP_REQUEST_HANDLE_OBJECT *pRequest =
        (HTTP_REQUEST_HANDLE_OBJECT *) hRequestMapped;


    AUTHCTX *pAuthCtx = pRequest->GetAuthCtx();
    BOOL fCredsChanged = FALSE;
    
    // PROXY AUTHENTICATION
    //
    // CERN proxies should remove proxy-authorization headers before forwarding
    // requests to servers.  Otherwise, don't add proxy authorization headers
    // that would be seen by servers on a direct connect or via SSL tunneling.

    if  (pRequest->IsRequestUsingProxy()
      && !pRequest->IsTalkingToSecureServerViaProxy())
    {
        // if an app sets proxy creds, we want to make sure that the specified
        // auth scheme is the same as the auth scheme in progress. Otherwise, we
        // will delete the current auth context and build a new one based on the
        // new scheme.
        if (pRequest->_pProxyCreds 
            && (pAuthCtx && pAuthCtx->_fIsProxy)
            && (pAuthCtx->GetRawSchemeType() != pRequest->_pProxyCreds->_AuthScheme))
        {
            delete pAuthCtx;
            pAuthCtx = NULL;
            pRequest->SetAuthCtx(NULL);
        }

        if (pAuthCtx && pAuthCtx->_fIsProxy)
        {
            // We have a proxy authentication in progress.
            // If a user/pass set on handle, transfer to AUTH_CREDS.

            // First check for proxy credentials and fallback to server
            // for legacy wininet apps. This will invalidate the credentials
            // on the handle they were found for any subsequent calls to
            // GetUserAndPass.
            
                // Serialize access to globals.
            if (AuthLock())
            {
                if (pRequest->_pProxyCreds)
                {
                    pAuthCtx->_pCreds->SetUser(pRequest->_pProxyCreds->_pszUserName);
                    pAuthCtx->_pCreds->SetPass(pRequest->_pProxyCreds->_pszPassword);
                }
                else if (pRequest->GetUserAndPass(IS_PROXY, &lpszUser, &lpszPass))
                {
                    pAuthCtx->_pCreds->SetUser(lpszUser);
                    pAuthCtx->_pCreds->SetPass(lpszPass);
                }

                AuthUnlock();

                // Add the authorization header.
                AddAuthorizationHeader (pRequest, pAuthCtx);
            }
        }

        // NO PROXY AUTHENTICATION CONTEXT -> SEE IF A AUTH_CREDS EXISTS.
        else  // See if we have a cached proxy user/pass.
        {
            if (pRequest->_pProxyCreds)
            {
                AUTHCTX::SPMData* pSPMData = AUTHCTX::SPMLookup(DwordSchemeToString(pRequest->_pProxyCreds->_AuthScheme));

                    /*
                    reinterpret_cast<AUTHCTX::SPMData*>(New AUTHCTX::SPMData(
                        DwordSchemeToString(pRequest->_pProxyCreds->_AuthScheme), 
                        DwordSchemeToFlags(pRequest->_pProxyCreds->_AuthScheme)));
                    */

                if (pSPMData)
                {
                    AUTH_CREDS *pCreds = AUTHCTX::CreateCreds(pRequest, TRUE,
                                                      pSPMData, pRequest->_pProxyCreds->_pszRealm);
                    if (pCreds)
                    {
                        pCreds->SetUser(pRequest->_pProxyCreds->_pszUserName);
                        pCreds->SetPass(pRequest->_pProxyCreds->_pszPassword);

                        pAuthCtx = AUTHCTX::CreateAuthCtx(pRequest, IS_PROXY, pCreds);
                        if (pAuthCtx && pAuthCtx->GetSchemeType() == WINHTTP_AUTH_SCHEME_BASIC)
                        {
                            AddAuthorizationHeader (pRequest, pAuthCtx);
                        }
                        delete pAuthCtx;
                        pAuthCtx = NULL;
                    }
                }
            }
        }
    }

    // SERVER AUTHENTICATION
    //
    // Don't send server authorization when initiating SSL tunneling with proxy.
    if (!pRequest->IsTunnel())
    {
        // if an app sets server creds, we want to make sure that the specified
        // auth scheme is the same as the auth scheme in progress. Otherwise, we
        // will delete the current auth context and build a new one based on the
        // new scheme.

        BOOL fNonePreferredSchemeUsed = FALSE;

        if (pRequest->_pServerCreds 
            && (pAuthCtx && !pAuthCtx->_fIsProxy)
            && (pAuthCtx->GetRawSchemeType() != pRequest->_pServerCreds->_AuthScheme))
        {
            delete pAuthCtx;
            pAuthCtx = NULL;
            pRequest->SetAuthCtx(NULL);

            fNonePreferredSchemeUsed = TRUE;
        }

        // See if we have a server authentication in progress
        if (pAuthCtx && !pAuthCtx->_fIsProxy)
        {
            // Server authentication in progress.

            // If a user/pass set on handle, transfer to AUTH_CREDS.
            // This will invalidate the credentials on the handle they
            // were found for any subsequent calls to GetUserAndPass.
            
            if (AuthLock())
            {
                if (pRequest->_pServerCreds)
                {
                    pAuthCtx->_pCreds->SetUser(pRequest->_pServerCreds->_pszUserName);
                    pAuthCtx->_pCreds->SetPass(pRequest->_pServerCreds->_pszPassword);
                }
                else if (pRequest->GetUserAndPass(IS_SERVER, &lpszUser, &lpszPass))
                {
                    pAuthCtx->_pCreds->SetUser(lpszUser);
                    pAuthCtx->_pCreds->SetPass(lpszPass);
                }

                AuthUnlock();

                // Add the authorization header.
                AddAuthorizationHeader (pRequest, pAuthCtx);
            }
        }
        else  // See if we have a cached server user/pass.
        {
            // NO PROXY AUTHENTICATION CONTEXT -> SEE IF A AUTH_CREDS EXISTS
                
            if (pRequest->_pServerCreds)
            {
                AUTHCTX *pNewAuthCtx = NULL;

                AUTHCTX::SPMData* pSPMData = AUTHCTX::SPMLookup(DwordSchemeToString(pRequest->_pServerCreds->_AuthScheme));

                    /*
                    reinterpret_cast<AUTHCTX::SPMData*>(New AUTHCTX::SPMData(
                        DwordSchemeToString(pRequest->_pServerCreds->_AuthScheme), 
                        DwordSchemeToFlags(pRequest->_pServerCreds->_AuthScheme)));
                    */
                
                INET_ASSERT(pSPMData);

                AUTH_CREDS *pCreds = AUTHCTX::CreateCreds(pRequest, FALSE,
                                                  pSPMData, pRequest->_pServerCreds->_pszRealm);
                if (pCreds)
                {
                    pCreds->SetUser(pRequest->_pServerCreds->_pszUserName);
                    pCreds->SetPass(pRequest->_pServerCreds->_pszPassword);

                    pNewAuthCtx = AUTHCTX::CreateAuthCtx(pRequest, IS_SERVER, pCreds);
                    
                    if(pNewAuthCtx)
                    {
                        if (pNewAuthCtx->GetSchemeType() == WINHTTP_AUTH_SCHEME_NTLM
                            || pNewAuthCtx->GetSchemeType() == WINHTTP_AUTH_SCHEME_NEGOTIATE)
                        {
                            // NTLM or Negotiate (in which case we don't really know the
                            // protocol yet) - create the auth context, set it in the handle
                            // and set state to AUTHSTATE_NEGOTIATE. Handle now has
                            // a valid auth context and is in the correct auth state
                            // for the remainder of the authorization sequence.

                            // It's possible that the Creds entry was created when no proxy
                            // was in use and the user set a proxy. Check that this is
                            // not the case.

                            if (!fNonePreferredSchemeUsed &&

                                (!pRequest->IsMethodBody() 
                                || (pNewAuthCtx->GetSchemeType() == WINHTTP_AUTH_SCHEME_NTLM
                                    && pRequest->IsDisableNTLMPreauth())
                                || (pRequest->IsRequestUsingProxy()
                                    && !pRequest->IsTalkingToSecureServerViaProxy())))
                            {
                                // NTLM preauth disabled or over proxy; no preauth.
                                delete pNewAuthCtx;
                                pNewAuthCtx = NULL;
                            }
                            else
                            {
                                // Set the auth context in the handle and
                                // add the auth header.
                                pRequest->SetAuthCtx(pNewAuthCtx);
                                pRequest->SetAuthState(AUTHSTATE_NEGOTIATE);
                                AddAuthorizationHeader (pRequest, pNewAuthCtx);
                            }
                        }
                        else
                        {
                            if ((pNewAuthCtx->GetSchemeType() == WINHTTP_AUTH_SCHEME_DIGEST && !fCredsChanged)
                                || (pNewAuthCtx->GetSchemeType() == WINHTTP_AUTH_SCHEME_BASIC))
                            {
                                pRequest->SetAuthCtx(pNewAuthCtx);
                                AddAuthorizationHeader (pRequest, pNewAuthCtx);
                                pRequest->SetCreds(pNewAuthCtx->_pCreds);
                            }

                            if (pNewAuthCtx->GetSchemeType() == WINHTTP_AUTH_SCHEME_PASSPORT)
                            {
                                pRequest->SetAuthCtx(pNewAuthCtx);
                                AddAuthorizationHeader (pRequest, pNewAuthCtx);
                            }
                        }
                    }
                }
            }
        }
    }

    DEBUG_LEAVE(dwError);
    return dwError;
}


/*-----------------------------------------------------------------------------
-----------------------------------------------------------------------------*/
DWORD ProcessResponseHeaders
(
    HINTERNET hRequestMapped,
    BOOL fIsProxy
)
{
    DEBUG_ENTER ((DBG_HTTP, Dword, "ProcessResponseHeaders", "%#x", hRequestMapped));

    DWORD dwError = ERROR_SUCCESS;

    // Get context from request handle.
    HTTP_REQUEST_HANDLE_OBJECT *pRequest
        = (HTTP_REQUEST_HANDLE_OBJECT *) hRequestMapped;
    AUTHCTX* pAuthCtx = pRequest->GetAuthCtx();
    BOOL fDoNotSetCreds = FALSE;

    if (pAuthCtx)
    {
        if ((dwError = pAuthCtx->UpdateFromHeaders(pRequest, fIsProxy))
            != ERROR_SUCCESS)
        {
            // Delete the auth context and fail auth 
            // immediately if any other error than
            // scheme has been changed.
            delete pAuthCtx;
            pRequest->SetAuthCtx(NULL);
            if (dwError != ERROR_HTTP_HEADER_NOT_FOUND)
            {
                goto cleanup;
            }

            fDoNotSetCreds = TRUE;

            if (fIsProxy)
            {
                if (pRequest->_pProxyCreds)
                {
                    delete pRequest->_pProxyCreds;
                    pRequest->_pProxyCreds = NULL;
                }
            }
            else
            {
                if (pRequest->_pServerCreds)
                {
                    delete pRequest->_pServerCreds;
                    pRequest->_pServerCreds = NULL;
                }
            }

            pRequest->ClearUserAndPass(fIsProxy);

            // Attempt to create a new auth context using
            // the challenge received from the server.
            // If this fails, we follow logic as commented
            // below.
            pAuthCtx = AUTHCTX::CreateAuthCtx(pRequest, fIsProxy);        
            if (!pAuthCtx)
            {
                dwError = ERROR_SUCCESS;
                goto cleanup;
            }

            pAuthCtx->DisableAutoLogon();
        }
    }
    else
    {
        // CreateAuthCtx returns NULL if auth scheme not
        // supported (fall through from HttpFiltOnResponse
        // in sendreq.cxx) or if scheme is NTLM and the
        // socket is not keep-alive or via proxy.
        // In these cases it is necessary to check for a NULL
        // return value. The correct return code for these cases is
        // ERROR_SUCCESS, which will be returned by AuthOnResponse.
        pAuthCtx = AUTHCTX::CreateAuthCtx(pRequest, fIsProxy);
        if (!pAuthCtx)
        {
            dwError = ERROR_SUCCESS;
            goto cleanup;
        }
    }

    LPSTR lpszUser, lpszPass;

    // First check for proxy credentials and fallback to server
    // for legacy wininet apps. This will invalidate the credentials
    // on the handle they were found for any subsequent calls to
    // GetUserAndPass.

    // I believe we should be putting the credentials in the
    // password cache at this time. The scenario is that a client
    // sets credentials on a handle, after a successful authentication
    // the Creds will have null credentials. Pre-auth will then pull up
    // credentials for the default user!!!!!!!!!!!
    
        // Serialize access to globals.
    if (AuthLock())
    {
        if (pRequest->_pServerCreds && !fIsProxy)
        {
            lpszUser = pRequest->_pServerCreds->_pszUserName;
            lpszPass = pRequest->_pServerCreds->_pszPassword;
        }
        else if (pRequest->_pProxyCreds && fIsProxy)
        {
            lpszUser = pRequest->_pProxyCreds->_pszUserName;
            lpszPass = pRequest->_pProxyCreds->_pszPassword;
        }
        else if ((!pRequest->GetUserAndPass(fIsProxy, &lpszUser, &lpszPass)) && fIsProxy)
        {
            pRequest->GetUserAndPass(IS_SERVER, &lpszUser, &lpszPass);
        }

        AuthUnlock();
    }
    else
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    // If we retrieved credentials from the handle set
    // them in the Creds.
    if (lpszUser && lpszPass && !fDoNotSetCreds)
    {
       pAuthCtx->_pCreds->SetUser(lpszUser);
       pAuthCtx->_pCreds->SetPass(lpszPass);
    }

    // Post authenticate user.
    dwError = pAuthCtx->PostAuthUser();

    // Map all unexpected error codes to login failure.
    if (dwError != ERROR_WINHTTP_FORCE_RETRY
        && dwError != ERROR_WINHTTP_INCORRECT_PASSWORD)
    {
        dwError = ERROR_WINHTTP_LOGIN_FAILURE;
    }

    pRequest->SetAuthCtx(pAuthCtx);

cleanup:

    DEBUG_LEAVE (dwError);
    return dwError;
}


BOOL IsSameDomain(LPCSTR pszTarget, LPCSTR pszResponse)
{
    LPCSTR pszTargetR = pszTarget + strlen(pszTarget);
    DWORD dwDotsSeen = 0;
    while (--pszTargetR > pszTarget)
    {
        if (*pszTargetR == '.')
        {
            if (++dwDotsSeen == 2)
            {
                break;
            }
        }
    }

    if (dwDotsSeen == 2)
    {
        ++pszTargetR;
        DWORD dwOffsetR = strlen(pszTargetR);
        if (strlen(pszResponse) < dwOffsetR)
        {
            return FALSE;
        }

        LPCSTR pszResponseR = pszResponse + strlen(pszResponse) - dwOffsetR;

        return !strcmp(pszTargetR, pszResponseR);
    }
    else
    {
        return FALSE;
    }
}

VOID CheckForTweenerLogout(HTTP_REQUEST_HANDLE_OBJECT *pRequest)
{
    DWORD dwIndex = 0;
    DWORD dwError;

    do
    {
        LPSTR szData;
        DWORD cbData;
        dwError = pRequest->FastQueryResponseHeader(HTTP_QUERY_AUTHENTICATION_INFO,
                                                    (LPVOID*) &szData,
                                                    &cbData,
                                                    dwIndex);
        if (dwError == ERROR_SUCCESS)
        {
            BOOL fLogout = FALSE;
            CHAR TempChar = szData[cbData];
            szData[cbData] = '\0';

            if (strstr(szData, "Passport1.4") && strstr(szData, "logout"))
            {
                fLogout = TRUE;
            }
            szData[cbData] = TempChar;

            if (fLogout)
            {
                PP_CONTEXT hPP = GetRootHandle(pRequest)->GetPPContext();
                if (hPP != NULL)
                {
                    WCHAR wszDAHost[256];
                    DWORD dwDAHostLen = 256;
                    CHAR szDAHost[256];
                    
                    ::PP_GetEffectiveDAHost(hPP, wszDAHost, &dwDAHostLen);
                    ::WideCharToMultiByte(CP_ACP, 0, wszDAHost, -1, szDAHost, 256, NULL, NULL);
                    
                    if (IsSameDomain(pRequest->GetServerName(), szDAHost))
                    {
                        ::PP_Logout(hPP, 0);
                    }
                }
                
                break;
            }
        }

        ++dwIndex;

    } while (dwError == ERROR_SUCCESS);
}


/*-----------------------------------------------------------------------------

Routine Description:

    Validates, and Caches Authentication Request headers if needed. If a URL matches a
    cached set of templates it is assumed to require specific authentication information.

Arguments:

    hRequest                - An open HTTP request handle
                              where headers will be added if needed.

Return Value:

    DWORD
    Success - ERROR_SUCCESS

    Failure - One of Several Error codes defined in winerror.h or wininet.w

Comments:

    Need to handle mutiple authentication pages.

-----------------------------------------------------------------------------*/
PUBLIC DWORD AuthOnResponse (HINTERNET hRequestMapped)
{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "AuthOnResponse",
                 "%#x [%#x]",
                 hRequestMapped,
                 ((INTERNET_HANDLE_OBJECT *)hRequestMapped)->GetPseudoHandle()
                 ));

    // Get URL and password cache entry from request handle.
    HTTP_REQUEST_HANDLE_OBJECT *pRequest =
        (HTTP_REQUEST_HANDLE_OBJECT *) hRequestMapped;

    AUTHCTX *pAuthCtx = pRequest->GetAuthCtx();
    DWORD dwStatus = pRequest->GetStatusCode();

    if (pAuthCtx)
    {
        if (pAuthCtx->_fIsProxy && dwStatus != HTTP_STATUS_PROXY_AUTH_REQ)
        {
            if (dwStatus == HTTP_STATUS_REDIRECT)   // we might need to do Tweener auth
            {
                pRequest->_pTweenerProxyCreds = pAuthCtx->_pCreds;
                pAuthCtx->_pCreds = NULL;
            }

            // We are done with proxy authentication.
            delete pAuthCtx;
            pRequest->SetAuthCtx (NULL);
            
            if (pRequest->_pProxyCreds)
            {
                delete pRequest->_pProxyCreds;
                pRequest->_pProxyCreds = NULL;
            }

            pRequest->ClearUserAndPass(IS_PROXY);
        }
        else if (!pAuthCtx->_fIsProxy && dwStatus != HTTP_STATUS_DENIED)
        {
			if ((pAuthCtx->GetSchemeType() != WINHTTP_AUTH_SCHEME_PASSPORT) || dwStatus != HTTP_STATUS_REDIRECT)
            {
                // We are done with server authentication.

                if (pAuthCtx->GetSchemeType() == WINHTTP_AUTH_SCHEME_PASSPORT)
                {
                    delete [] pRequest->m_lpszRetUrl;
                    pRequest->m_lpszRetUrl = ((PASSPORT_CTX*)pAuthCtx)->m_lpszRetUrl;
                    ((PASSPORT_CTX*)pAuthCtx)->m_lpszRetUrl = NULL;
                }

                delete pAuthCtx;
                pRequest->SetAuthCtx (NULL);

                if (pRequest->_pServerCreds)
                {
                    delete pRequest->_pServerCreds;
                    pRequest->_pServerCreds = NULL;
                }

                pRequest->ClearUserAndPass(IS_SERVER);
            }
			else
            {
                // in the case of Passport Auth, 302 is still not done yet, 
                // but this is quite strange since 302 came a second time
                // biaow-todo: we could be in a loop here
            }
        }
    }

    // Remove any stale authorization headers in case wHttpSendRequest
    // loops, for example, to handle a redirect.  To ignore trailing colon,
    // subtract 1 from header lengths passed to ReplaceRequestHeader.
    pRequest->ReplaceRequestHeader
        (HTTP_QUERY_AUTHORIZATION,
                    "", 0, 0, HTTP_ADDREQ_FLAG_REPLACE);
    pRequest->ReplaceRequestHeader
        (HTTP_QUERY_PROXY_AUTHORIZATION,
            "", 0, 0, HTTP_ADDREQ_FLAG_REPLACE);

    DWORD error;

//
// note: Negotiate MUTUAL_AUTH can return dwStatus = 200 with a final
// WWW-Authenticate blob to process.  logic below could be adjusted
// to ProcessResponseHeaders() in this situation, which allows MUTUAL_AUTH
// to be enforced.
//
    
    switch (dwStatus)
    {
        case HTTP_STATUS_PROXY_AUTH_REQ: // 407
            error = ProcessResponseHeaders(pRequest, IS_PROXY);
            break;

        case HTTP_STATUS_REDIRECT: // 302
            {
                INTERNET_HANDLE_OBJECT * pInternet = GetRootHandle((INTERNET_HANDLE_BASE*)pRequest);
                if (pInternet->TweenerDisabled())
                {
                    // biaow-todo: no passport support for down-levels yet

                    pRequest->SetAuthState(AUTHSTATE_NONE);
                    error = ERROR_SUCCESS;

                    break;
                }
            }
    
            // process the header to see whether this is a 302 passport1.4 challenge

        case HTTP_STATUS_DENIED: // 401

            error = ProcessResponseHeaders(pRequest, IS_SERVER);
            break;

        default:
            pRequest->SetAuthState(AUTHSTATE_NONE);
            error = ERROR_SUCCESS;
    }

    // creds set by WinHttpSetCredentials() is good for one "authentication attempt" only. 
    // Since we are done authentication here, we are deleting it.

    // biaow: detect the "final" failure so that we can delete the creds.
    
    if (pRequest->_pTweenerProxyCreds)
    {
        Creds_Free(pRequest->_pTweenerProxyCreds);
        pRequest->_pTweenerProxyCreds = NULL;
    }
    
    CheckForTweenerLogout(pRequest);
    
    DEBUG_LEAVE(error);
    return error;
}




//-----------------------------------------------------------------------------
//
//
//      AUTHCTX Base class definitions
//
//
//
//      static funcs:
//          Enumerate
//          UnloadAll
//          CreateAuthCtx
//          CreateAuthCtx (using Creds*)
//          GetSPMListState
//          SearchCredsList
//          FindOrCreateCreds
//          GetAuthHeaderData
//
//      base funcs:
//          FindHdrIdxFromScheme
//          GetScheme
//          GetSchemeType - returns enum
//          GetFlags      - returns SPM flags
//          GetState      - returns state of SPM provider
//
//
//      virtual overrides: defined in basic.cxx, plug.cxx and digest.cxx
//          UpdateFromHeaders
//          PreAuthUser
//          PostAuthUser
//
//
//


/*---------------------------------------------------------------------------
AUTHCTX::SPMData constructor
---------------------------------------------------------------------------*/
AUTHCTX::SPMData::SPMData(LPSTR _szScheme, DWORD _dwFlags)
{
    if (_szScheme)
    {
        szScheme = NewString(_szScheme);
        cbScheme = strlen(_szScheme);
    }
    else
    {
        szScheme = NULL;
        cbScheme = 0;
    }

    if (szScheme)
    {
        if (!lstrcmpi(szScheme, "Basic"))
            eScheme = WINHTTP_AUTH_SCHEME_BASIC;
        else if (!lstrcmpi(szScheme, "NTLM"))
            eScheme = WINHTTP_AUTH_SCHEME_NTLM;
        else if (!lstrcmpi(szScheme, "Digest"))
            eScheme = WINHTTP_AUTH_SCHEME_DIGEST;
        else if (!lstrcmpi(szScheme, "Negotiate"))
            eScheme = WINHTTP_AUTH_SCHEME_NEGOTIATE;
        else if (!lstrcmpi(szScheme, "Passport1.4"))
            eScheme = WINHTTP_AUTH_SCHEME_PASSPORT;
        else
            eScheme = 0;

        dwFlags    = _dwFlags;
        eState     = STATE_NOTLOADED;
    }
    else
    {
        dwFlags    = 0;
        eState     = STATE_ERROR;
    }
}

/*---------------------------------------------------------------------------
AUTHCTX::SPMData destructor
---------------------------------------------------------------------------*/
AUTHCTX::SPMData::~SPMData()
{ delete szScheme; }


/*---------------------------------------------------------------------------
AUTHCTX constructor
---------------------------------------------------------------------------*/
AUTHCTX::AUTHCTX(SPMData *pData, AUTH_CREDS *pCreds)
{
    _pSPMData = pData;
    _pCreds = pCreds;
    _pRequest = NULL;
    _fIsProxy = FALSE;
    _pvContext = NULL;
    _eSubScheme = 0;
    _dwSubFlags = 0;

    _fDisableAutoLogon = FALSE;

    _CtxCriSec.Init();
}


/*---------------------------------------------------------------------------
    Destructor
---------------------------------------------------------------------------*/
AUTHCTX::~AUTHCTX()
{
    if (AuthLock())
    {
        if (_pCreds)
            Creds_Free(_pCreds);
        AuthUnlock();
    }

    _CtxCriSec.FreeLock();
}


// ------------------------  Static Functions ---------------------------------


/*---------------------------------------------------------------------------
    Enumerate
---------------------------------------------------------------------------*/
VOID AUTHCTX::Enumerate()
{
    struct SchemeFlagsPair
    {
        LPSTR pszScheme;
        DWORD Flags;
    };

    SchemeFlagsPair SchemeFlags[] = {
                        {"NTLM", PLUGIN_AUTH_FLAGS_NO_REALM},
                        {"Basic", PLUGIN_AUTH_FLAGS_KEEP_ALIVE_NOT_REQUIRED},
                        {"Digest", PLUGIN_AUTH_FLAGS_KEEP_ALIVE_NOT_REQUIRED | PLUGIN_AUTH_FLAGS_CAN_HANDLE_UI},
                        {"Negotiate", PLUGIN_AUTH_FLAGS_KEEP_ALIVE_NOT_REQUIRED | PLUGIN_AUTH_FLAGS_NO_REALM},
                        {"Passport1.4",  PLUGIN_AUTH_FLAGS_KEEP_ALIVE_NOT_REQUIRED}
                        };
    
    SPMData   *pNew;
    g_pSPMList = NULL;
    g_eState = STATE_ERROR;

    AssertHaveLock();

    // Hard-wired Basic, NTLM and Digest
    for (DWORD dwIndex = 0; dwIndex < sizeof(SchemeFlags) / sizeof(SchemeFlagsPair); dwIndex++)
    {
        if (!GlobalPlatformVersion5 // we don't support Negotiate on NT4 or Win9x
            && !stricmp(SchemeFlags[dwIndex].pszScheme, "Negotiate"))
        {
            continue;
        }

        pNew = (AUTHCTX::SPMData*) New SPMData(SchemeFlags[dwIndex].pszScheme, SchemeFlags[dwIndex].Flags);
        if (!pNew)
            return;

        // Add to head of list.
        if (pNew->eState != STATE_ERROR)
        {
            pNew->pNext = g_pSPMList;
            g_pSPMList = pNew;
        }
    }

    // The list is now in the correct state.
    g_eState = STATE_LOADED;
}


VOID AUTHCTX::UnloadAll()
{
    // BUGBUG - AuthFlush is called when the last browser session
    // is closed. First the global Creds lists are destructed, and
    // then this func (UnloadAll) is called. However, the global
    // Creds lists are not necessarily flushed (they may have out-
    // standing ref counts) and may persist across browser sessions.
    // when we destruct the SPM list in this func, SPMs reference
    // by any surviving Creds entries are bogus and can be used
    // for subsequent authentication, resulting in a fault.
    //
    // The temporary hack here is to not destruct the SPM
    // list if any Creds list is not destructed. We leak the
    // SPM list on process detach but don't fault. Put the
    // SPM destruct code in DllProcessDetach.
    
    SPMData *pData = g_pSPMList;
    while (pData)
    {
        SPMData *pNext = pData->pNext;
        delete pData;
        pData = pNext;
    }

    SSPI_Unload();
    g_eState = STATE_NOTLOADED;
    g_pSPMList = NULL;
}

DWORD StringSchemeToDword(LPSTR szScheme)
{
    if (!stricmp(szScheme, "Basic"))
    {
        return WINHTTP_AUTH_SCHEME_BASIC;
    }
    else if (!stricmp(szScheme, "Digest"))
    {
        return WINHTTP_AUTH_SCHEME_DIGEST;
    }
    else if (!stricmp(szScheme, "Passport1.4"))
    {
        return WINHTTP_AUTH_SCHEME_PASSPORT;
    }
    else if (!stricmp(szScheme, "NTLM"))
    {
        return WINHTTP_AUTH_SCHEME_NTLM;
    }
    else if (!stricmp(szScheme, "Negotiate"))
    {
        return WINHTTP_AUTH_SCHEME_NEGOTIATE;
    }
    else
    {
        return 0;
    }
}

/*---------------------------------------------------------------------------
    CreateAuthCtx
    Create an AUTHCTX* from headers - initially the authentication context
    is created without a AUTH_CREDS entry. The AUTH_CREDS entry will be found or created
    and possibly updated in UpdateFromHeaders.
---------------------------------------------------------------------------*/
AUTHCTX* AUTHCTX::CreateAuthCtx(HTTP_REQUEST_HANDLE_OBJECT * pRequest, BOOL fIsProxy)
{
    LPSTR szScheme;
    DWORD cbScheme, dwError, dwAuthIdx;
    AUTHCTX *pAuthCtx = NULL;

    dwAuthIdx = 0;
    szScheme = NULL;


    // Get scheme. This is assumed to be the first
    // non-ws token in the auth header info.
    do
    {
        // It is necessary to hold on to the auth index
        // in this loop because we could have gone through
        // more than one scheme.
        dwError = GetAuthHeaderData(pRequest, fIsProxy, NULL,
            &szScheme, &cbScheme, ALLOCATE_BUFFER | GET_SCHEME, dwAuthIdx);

        if (dwError != ERROR_SUCCESS)
            goto quit;

        pRequest->_KnowSupportedSchemes = TRUE;
        pRequest->_SupportedSchemes |= StringSchemeToDword(szScheme);
        pRequest->_AuthTarget = fIsProxy ? WINHTTP_AUTH_TARGET_PROXY : WINHTTP_AUTH_TARGET_SERVER;
        
        DEBUG_PRINT(API,
                    INFO,
                    ("CreateAuthCtx(%x) : Auth Target = %x\n",
                    fIsProxy,
                    pRequest->_AuthTarget
                    ));

        // This will create the appropriate authentication context
        // with a NULL password cache. The password cache will be
        // created in the call to UpdateFromHeaders.
        
        if (pAuthCtx == NULL)
        {
            pAuthCtx = CreateAuthCtx(pRequest, fIsProxy, szScheme);

            // If creation of an auth context is successful, update
            // the context from any header info.
            if (pAuthCtx)
            {
                if (pAuthCtx->UpdateFromHeaders(pRequest, fIsProxy) != ERROR_SUCCESS)
                {
                    delete pAuthCtx;
                    pAuthCtx = NULL;
                }
                else
                {
                    pRequest->_PreferredScheme = StringSchemeToDword(szScheme);
                }
            }
        }
        
        dwAuthIdx++;

        delete szScheme;
        szScheme = NULL;

    } while (1);

quit:

    if (szScheme)
        delete szScheme;

    return pAuthCtx;
}

AUTHCTX::SPMData* AUTHCTX::SPMLookup(LPSTR szScheme)
{
    if (!AuthLock())
    {
        return NULL;
    }

    AUTHCTX::SPMData *pSPM = NULL;

    // If necessary, enumerate auth providers from registry.
    if (AUTHCTX::GetSPMListState() == AUTHCTX::STATE_NOTLOADED)
        AUTHCTX::Enumerate();

    if (AUTHCTX::GetSPMListState() != AUTHCTX::STATE_LOADED)
    {
        // not critical, just no authentication
        goto quit;
    }

    pSPM = g_pSPMList;

    // Find SPMData to create from scheme.
    while (pSPM)
    {
        if (!lstrcmpi(pSPM->szScheme, szScheme))
            break;

        pSPM = pSPM->pNext;
    }

quit:
    AuthUnlock();
    return pSPM;
}

/*---------------------------------------------------------------------------
    CreateAuthCtx
    Create an AUTHCTX without a AUTH_CREDS from scheme
---------------------------------------------------------------------------*/
AUTHCTX* AUTHCTX::CreateAuthCtx(HTTP_REQUEST_HANDLE_OBJECT *pRequest,
    BOOL fIsProxy, LPSTR szScheme)
{
    if (!AuthLock())
    {
        return NULL;
    }

    AUTHCTX *pNewAuthCtx = NULL;

    // we don't want to create a Passport1.4 context on 401 response (from DA)
    if (!lstrcmpi("Passport1.4", szScheme))
    {
        if (pRequest->GetStatusCode() == HTTP_STATUS_DENIED)
        {
            goto quit;
        }
    }

    // If necessary, enumerate auth providers from registry.
    if (AUTHCTX::GetSPMListState() == AUTHCTX::STATE_NOTLOADED)
        AUTHCTX::Enumerate();

    if (AUTHCTX::GetSPMListState() != AUTHCTX::STATE_LOADED)
    {
        // not critical, just no authentication
        goto quit;
    }

    SPMData *pSPM;
    pSPM = g_pSPMList;

    // Find SPMData to create from scheme.
    while (pSPM)
    {
        if (!lstrcmpi(pSPM->szScheme, szScheme))
            break;

        pSPM = pSPM->pNext;
    }

    if (!pSPM)
    {
        // No matching auth scheme found.
        // Not critical, just no auth.
        goto quit;
    }

    // Create an auth context without Creds
    switch(pSPM->eScheme)
    {
        // Create BASIC_CTX with NULL AUTH_CREDS.
        case WINHTTP_AUTH_SCHEME_BASIC:
            pNewAuthCtx = New BASIC_CTX(pRequest, fIsProxy, pSPM, NULL);
            break;

        // Create DIGEST_CTX with NULL AUTH_CREDS.
        case WINHTTP_AUTH_SCHEME_DIGEST:
            pNewAuthCtx = New DIGEST_CTX(pRequest, fIsProxy, pSPM, NULL);
            break;

        case WINHTTP_AUTH_SCHEME_PASSPORT:
            pNewAuthCtx = new PASSPORT_CTX(pRequest, fIsProxy, pSPM, NULL);
            if (pNewAuthCtx)
            {
                if (((PASSPORT_CTX*)pNewAuthCtx)->Init() == FALSE)
                {
                    delete pNewAuthCtx;
                    pNewAuthCtx = NULL;
                }
            }
            break;

        // Create PLUG_CTX with NULL AUTH_CREDS.
        case WINHTTP_AUTH_SCHEME_NTLM:
        case WINHTTP_AUTH_SCHEME_NEGOTIATE:

        default:
            pNewAuthCtx = New PLUG_CTX(pRequest, fIsProxy, pSPM, NULL);

    }


quit:
    AuthUnlock();
    return pNewAuthCtx;
}


/*---------------------------------------------------------------------------
    CreateAuthCtx
    Create an AUTHCTX from a AUTH_CREDS.
---------------------------------------------------------------------------*/
AUTHCTX* AUTHCTX::CreateAuthCtx(HTTP_REQUEST_HANDLE_OBJECT *pRequest,
                    BOOL fIsProxy, AUTH_CREDS* pCreds)
{
    if (!AuthLock())
    {
        return NULL;
    }
    
    AUTHCTX *pNewAuthCtx = NULL;

    // If necessary, enumerate auth providers from registry.
    if (AUTHCTX::GetSPMListState() == AUTHCTX::STATE_NOTLOADED)
        AUTHCTX::Enumerate();

    if (AUTHCTX::GetSPMListState() != AUTHCTX::STATE_LOADED)
    {
        // not critical, just no authentication
        goto quit;
    }

    // Handle tests (via proxy, is keep-alive)
    // will be done in UpdateFromHeaders. Here
    // we just construct the AUTHCTX.
    switch(pCreds->pSPM->eScheme)
    {
        // Create BASIC_CTX.
        case WINHTTP_AUTH_SCHEME_BASIC:

            pNewAuthCtx = New BASIC_CTX(pRequest, fIsProxy, pCreds->pSPM, pCreds);
            break;

        // Create DIGEST_CTX.
        case WINHTTP_AUTH_SCHEME_DIGEST:
            pNewAuthCtx = New DIGEST_CTX(pRequest, fIsProxy, pCreds->pSPM, pCreds);
            break;

        case WINHTTP_AUTH_SCHEME_PASSPORT:
            pNewAuthCtx = new PASSPORT_CTX(pRequest, fIsProxy, pCreds->pSPM, pCreds);
            if (pNewAuthCtx)
            {
                if (((PASSPORT_CTX*)pNewAuthCtx)->Init() == FALSE)
                {
                    delete pNewAuthCtx;
                    pNewAuthCtx = NULL;
                }
            }
            break;

        // Create PLUG_CTX.
        case WINHTTP_AUTH_SCHEME_NTLM:
        case WINHTTP_AUTH_SCHEME_NEGOTIATE:

        default:
            pNewAuthCtx = New PLUG_CTX(pRequest, fIsProxy, pCreds->pSPM, pCreds);

    }


quit:
    AuthUnlock();
    return pNewAuthCtx;
}

AUTHCTX::SPMState AUTHCTX::GetSPMListState()
    { return g_eState; }


/*-----------------------------------------------------------------------------
    SearchCredsList
-----------------------------------------------------------------------------*/
//AUTH_CREDS* AUTHCTX::SearchCredsList
//    (AUTH_CREDS* Creds, LPSTR lpszHost, LPSTR lpszUri, LPSTR lpszRealm, SPMData *pSPM)
/*++

Routine Description:
    Scans the Linked List Cache for URLs, Realms, and Servers.  Also allows
    filter fields, to narrow searches.

Arguments:
    Creds                   - Pointer to first item to search from.
    lpszHost              - Host, or Server name to search on.
    lpszUri               - URL to search on.
    lpszRealm             - Security Realm to search on
    lpszScheme            - Authentication scheme to search on.
Return Value:

    AUTH_CREDS *
    Success - Pointer to found item.

    Failure - NULL pointer.

Comments:
    Note: This Legacy code from the SpyGlass IE 1.0 browser

    The AUTH_CREDS lists are searched on every request.  Could optimize by keeping
    a hash value of the server/proxy name.

    If an exact match isn't found on a 401 response, the list is walked again
    to search for a realm match.  Could add a parameter to do both at once.
--*/

/*
{
    AssertHaveLock();

    while (Creds)
    {
        if (   (!pSPM || pSPM == Creds->pSPM)
            && (!lpszHost  || !lstrcmpi(Creds->lpszHost,lpszHost))
            && (!lpszRealm || !lstrcmpi(Creds->lpszRealm,lpszRealm))
            && (!lpszUri   || TemplateMatch (Creds->lpszUrl, lpszUri))
           )
        {

            DEBUG_PRINT(HTTP, INFO, ("Lookup: Found template match [%q]\n",
                Creds->lpszUser));
            return Creds;
        }
        else
        {
            Creds = Creds->pNext;
        }
    }

    return NULL;
}
*/



/*-----------------------------------------------------------------------------
    FindOrCreateCreds
-----------------------------------------------------------------------------*/
AUTH_CREDS* AUTHCTX::CreateCreds(
    HTTP_REQUEST_HANDLE_OBJECT *pRequest,
    BOOL     fIsProxy,
    SPMData *pSPM,
    LPSTR    lpszRealm
)
{
    //AssertHaveLock();

    // Create a AUTH_CREDS.
    AUTH_CREDS *Creds;
    Creds = NULL;

    if (!pSPM)
    {
        INET_ASSERT(FALSE);
        goto quit;
    }

    // Get host from request handle.
    LPSTR lpszHost;
    lpszHost = fIsProxy?
        GetProxyName(pRequest) : pRequest->GetServerName();

    // For NTLM, use the hostname analagously to basic realm.
    if (pSPM->eScheme == WINHTTP_AUTH_SCHEME_NTLM || pSPM->eScheme == WINHTTP_AUTH_SCHEME_NEGOTIATE)
    {
        INET_ASSERT (!lpszRealm);
        lpszRealm = lpszHost;
    }

    Creds = Creds_Create (lpszHost, lpszRealm, pSPM);
    
quit:
    
    return Creds;
}

/*-----------------------------------------------------------------------------
    GetAuthHeaderData
-----------------------------------------------------------------------------*/
DWORD AUTHCTX::GetAuthHeaderData(
    HTTP_REQUEST_HANDLE_OBJECT *pRequest,
    BOOL      fIsProxy,
    LPSTR     szItem,
    LPSTR    *pszData,
    LPDWORD   pcbData,
    DWORD     dwFlags,
    DWORD     dwIndex)
{
    LPSTR szData;
    DWORD cbData, cbItem, dwError = ERROR_SUCCESS;;
    CHAR *szTok, *szKey, *szValue;
    DWORD cbTok, cbKey, cbValue;

    szTok = szKey = szValue = NULL;
    cbTok = cbKey = cbValue = NULL;

    cbItem = szItem ? strlen(szItem) : 0;

    DWORD dwQuery = fIsProxy?
        HTTP_QUERY_PROXY_AUTHENTICATE : HTTP_QUERY_WWW_AUTHENTICATE;

    // NULL item passed in means get up to the first \r\n, or
    // possibly only the scheme is desired depending on dwFlags.
    if (!cbItem)
    {
        if ((dwError = pRequest->FastQueryResponseHeader(dwQuery,
            (LPVOID*) &szData,
            &cbData,
            dwIndex)) != ERROR_SUCCESS)
        {
            goto quit;
        }

        // Only the scheme is desired.
        if (dwFlags & GET_SCHEME)
        {
            CHAR* ptr;
            ptr = szValue = szData;
            cbValue = 0;
            while (!(*ptr == ' ' || *ptr == '\t' || *ptr == '\r' || *ptr == '\n'))
            {
                ptr++;
                cbValue++;
            }
        }
        else
        {
            // The entire header is desired.
            szValue = szData;
            cbValue = cbData;
        }

    }
    else
    {
        // An item was passed in - attempt to parse this
        // from the headers and return the corresponding
        // value.
        if ((dwError = pRequest->FastQueryResponseHeader(dwQuery,
                  (LPVOID*) &szData,
                  &cbData,
                  dwIndex)) != ERROR_SUCCESS)
        {
            goto quit;
        }

        // Successfully retrieved header. Parse for the desired item.

        // Point past scheme
        while (!(*szData == ' ' || *szData == '\t' || *szData == '\r' || *szData == '\n'))
        {
            szData++;
            cbData--;
        }

        // Attempt to parse an item of the format 'key = <">value<">'
        // from a comma delmited list of items.
        dwError = ERROR_HTTP_HEADER_NOT_FOUND;
        while (GetDelimitedToken(&szData, &cbData, &szTok, &cbTok, ','))
        {
            if (GetKeyValuePair(szTok, cbTok, &szKey, &cbKey, &szValue, &cbValue))
            {
                if ((cbItem == cbKey) && !strnicmp(szKey, szItem, cbItem))
                {
                    TrimQuotes(&szValue, &cbValue);
                    dwError = ERROR_SUCCESS;
                    break;
                }
            }
        }

    }

    if (dwError == ERROR_SUCCESS)
    {
        // Allocate buffer containing data
        // or return reference.
        if (dwFlags & ALLOCATE_BUFFER)
        {
            *pszData = New CHAR[cbValue+1];
            if (!*pszData)
            {
                dwError = ERROR_NOT_ENOUGH_MEMORY;
                goto quit;
            }
            memcpy(*pszData, szValue, cbValue);
            (*pszData)[cbValue] = '\0';
            *pcbData = cbValue;
        }
        else
        {
            *pszData = szValue;
            *pcbData = cbValue;
        }
    }

quit:

    if (dwError != ERROR_SUCCESS)
    {
        INET_ASSERT(dwIndex || dwError == ERROR_HTTP_HEADER_NOT_FOUND);
    }

    return dwError;
}


// ------------------------  Base class funcs---------------------------------




/*-----------------------------------------------------------------------------
FindHdrIdxFromScheme
-----------------------------------------------------------------------------*/
DWORD AUTHCTX::FindHdrIdxFromScheme(LPDWORD pdwIndex)
{
    LPSTR szHeader;
    DWORD cbHeader, dwQuery, dwError;

    dwQuery = _fIsProxy?
        HTTP_QUERY_PROXY_AUTHENTICATE : HTTP_QUERY_WWW_AUTHENTICATE;

    *pdwIndex = 0;

    while ((dwError = _pRequest->FastQueryResponseHeader(dwQuery,
            (LPVOID*) &szHeader,
            &cbHeader,
            *pdwIndex)) == ERROR_SUCCESS)
    {
        DWORD cb = 0;
        CHAR *ptr = szHeader;
        while (!(*ptr == ' ' || *ptr == '\t' || *ptr == '\r' || *ptr == '\n'))
        {
            ptr++;
            cb++;
        }

        if ((_pSPMData->cbScheme == cb)
            && (!strnicmp(_pSPMData->szScheme, szHeader, cb)))
        {
            break;
        }
        (*pdwIndex)++;
    }
    return dwError;
}

/*-----------------------------------------------------------------------------
    Get funcs.
-----------------------------------------------------------------------------*/
LPSTR AUTHCTX::GetScheme()
    { return _pSPMData->szScheme; }

DWORD AUTHCTX::GetSchemeType()
{
    if (_pSPMData->eScheme == WINHTTP_AUTH_SCHEME_NEGOTIATE)
    {
        if (_eSubScheme == WINHTTP_AUTH_SCHEME_NTLM || _eSubScheme == WINHTTP_AUTH_SCHEME_KERBEROS)
        {
            return _eSubScheme;
        }
    }
    return _pSPMData->eScheme;
}

DWORD AUTHCTX::GetRawSchemeType()
{
    return _pSPMData->eScheme;
}

DWORD AUTHCTX::GetFlags()
{
    if (_pSPMData->eScheme == WINHTTP_AUTH_SCHEME_NEGOTIATE)
    {
        if (_eSubScheme == WINHTTP_AUTH_SCHEME_NTLM || _eSubScheme == WINHTTP_AUTH_SCHEME_KERBEROS)
        {
            return _dwSubFlags;
        }
    }
    return _pSPMData->dwFlags;
}

AUTHCTX::SPMState AUTHCTX::GetState()
    { return _pSPMData->eState; }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5.1\autoproxy\aproxp.h ===
// precompiled header

//#include <wininetp.h>

//
// NT headers and our basterized versions of
//

#include <winsock.h>
#include <sockreg.h>
#include "vdhcpapi.h"
#include <wscntl.h>
#include <ntddtcp.h>
#include <tdistat.h>
#include <tdiinfo.h>
#include <llinfo.h>
#include <ipinfo.h>

#include <lmcons.h>
#include <optchg.h>


#include <dhcp.h>
#include <dhcplib.h>

//
//  Local header files
//

#include <dhcpdef.h>
#include <debug.h>
#include <dhcploc.h>
#include <dhcppro.h>

#include <options.h>
#include <optreg.h>
#include <stack.h>

#include <iphlpapi.h>
#include <apiappl.h>

#include "ipconfig.hxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5.1\autoproxy\apiappl.h ===
//================================================================================
//  Copyright (C) 1997 Microsoft Corporation
//  Author: RameshV
//  Description: these are the exported dhcp client api function definitions
//================================================================================

#ifndef APIAPPL_H_INCLUDED
#define APIAPPL_H_INCLUDED

#ifndef DHCPAPI_PARAMS_DEFINED
#define DHCPAPI_PARAMS_DEFINED
typedef struct _DHCPAPI_PARAMS {                  // use this structure to request params
    ULONG                          Flags;         // for future use
    ULONG                          OptionId;      // what option is this?
    BOOL                           IsVendor;      // is this vendor specific?
    LPBYTE                         Data;          // the actual data
    DWORD                          nBytesData;    // how many bytes of data are there in Data?
} DHCPAPI_PARAMS, *PDHCPAPI_PARAMS, *LPDHCPAPI_PARAMS;
#endif DHCPAPI_PARAMS_DEFINED

DWORD                                             // win32 status
DhcpAcquireParameters(                            // acquire/renew a lease
    IN      LPWSTR                 AdapterName    // adapter to acquire lease on
);

DWORD                                             // win32 status
DhcpReleaseParameters(                            // release an existing lease
    IN      LPWSTR                 AdapterName    // adpater to release lease for
);

DWORD                                             // win32 status
DhcpEnableDynamicConfic(                          // convert from static to dhcp
    IN      LPWSTR                 AdapterName    // convert for this adapter
);

DWORD                                             // win32 status
DhcpDisableDynamicConfig(                         // convert from dhcp to static
    IN      LPWSTR                 AdapterName    // convert this adapter
);

DWORD                                             // win32 status
DhcpStaticRefreshParams(                          // some registry parameters may have changed, refresh them
    IN      LPWSTR                 AdapterName
);

DWORD
APIENTRY // Request client for options.. and get the options.
DhcpRequestOptions(
    LPWSTR             AdapterName,
    BYTE              *pbRequestedOptions,
    DWORD              dwNumberOfOptions,
    BYTE             **ppOptionList,        // out param
    DWORD             *pdwOptionListSize,   // out param
    BYTE             **ppbReturnedOptions,  // out param
    DWORD             *pdwNumberOfAvailableOptions // out param
);

DWORD
APIENTRY // Register with the client to get Event for notification.
DhcpRegisterOptions(
    LPWSTR             AdapterName ,  // Null implies ALL adapters.
    LPBYTE             OptionList  ,  // The list of options to check.
    DWORD              OptionListSz,  // The size of the above list
    HANDLE             *pdwHandle     // the handle of an event to wait for.
);  // returns an event.


DWORD
APIENTRY // Deregister with the client..
DhcpDeRegisterOptions(
    HANDLE             Event          // This MUST be the one returned by above fn.
);

DWORD                                             // win32 status
APIENTRY
DhcpRequestParameters(                            // request parameters of client
    IN      LPWSTR                 AdapterName,   // adapter name to request for
    IN      LPBYTE                 ClassId,       // byte stream of class id to use
    IN      DWORD                  ClassIdLen,    // # of bytes of class id to use
    IN      PDHCPAPI_PARAMS        SendParams,    // parameters to send to server
    IN      DWORD                  nSendParams,   // size of above array
    IN      DWORD                  Flags,         // must be zero, reserved
    IN OUT  PDHCPAPI_PARAMS        RecdParams,    // fill this array with received params
    IN OUT  LPDWORD                pnRecdParamsBytes // i/p: size of above in BYTES, o/p required bytes or filled up # of elements
);  // returns ERROR_MORE_DATA if o/p buffer is of insufficient size, and fills in reqd size in # of bytes

DWORD                                             // win32 status
APIENTRY
DhcpRegisterParameterChangeNofitication(          // notify if a parameter has changed
    IN      LPWSTR                 AdapterName,   // adapter of interest
    IN      LPBYTE                 ClassId,       // byte stream of class id to use
    IN      DWORD                  ClassIdLen,    // # of bytes of class id
    IN      PDHCPAPI_PARAMS        Params,        // params of interest
    IN      DWORD                  nParams,       // # of elts in above array
    IN      DWORD                  Flags,         // must be zero, reserved
    IN OUT  PHANDLE                hEvent         // handle to event that will be SetEvent'ed in case of param change
);

DWORD
APIENTRY
DhcpDeRegisterParameterChangeNofitication(        // undo the registration
    IN      HANDLE                 Event          // handle to event returned by DhcpRegisterParameterChangeNotification, NULL ==> everything
);

DWORD                                             // win32 status
APIENTRY
DhcpPersistentRequestParams(                      // parameters to request persistently
    IN      LPWSTR                 AdapterName,   // adapter name to request for
    IN      LPBYTE                 ClassId,       // byte stream of class id to use
    IN      DWORD                  ClassIdLen,    // # of bytes of class id
    IN      PDHCPAPI_PARAMS        SendParams,    // persistent parameters
    IN      DWORD                  nSendParams,   // size of above array
    IN      DWORD                  Flags,         // must be zero, reserved
    IN      LPWSTR                 AppName        // the name of the app that is to be used for this instance
);

DWORD                                             // win32 status
APIENTRY
DhcpDelPersistentRequestParams(                   // undo the effect of a persistent request -- currently undo from registry
    IN      LPWSTR                 AdapterName,   // the name of the adpater to delete for
    IN      LPWSTR                 AppName        // the name used by the app
);

#endif APIAPPL_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5.1\autoproxy\debug.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    debug.h

Abstract:

    This file contains debugging macros for the DHCP server.

Author:

    Manny Weiser  (mannyw)  10-Oct-1992

Environment:

    User Mode - Win32

Revision History:

    Madan Appiah (madana)  21-Oct-1993

--*/

#if DBG

//
// Critical debug output flags.
//

#define DEBUG_ERRORS                0x00000001
#define DEBUG_PROTOCOL              0x00000002
#define DEBUG_LEASE                 0x00000004
#define DEBUG_MISC                  0x00000008
#define DEBUG_INIT                  0x00000010
#define DEBUG_TIMESTAMP             0x00000020
#define DEBUG_ASSERT                0x00001000
#define DEBUG_TRACK                 0x00002000
//
// more verbose debug output flags.
//

#define DEBUG_PROTOCOL_DUMP         0x00010000
#define DEBUG_STACK                 0x00020000
#define DEBUG_TCP_INFO              0x00040000
#define DEBUG_DNS                   0x00080000

#define DEBUG_BACKDOOR              0x01000000
#define DEBUG_ALLOC                 0x02000000
#define DEBUG_PERF                  0x04000000
#define DEBUG_TRACE                 0x08000000

#define DEBUG_API                   0x10000000
#define DEBUG_OPTIONS               0x20000000
#define DEBUG_BREAK_POINT           0x40000000
#define DEBUG_TRACE_CALLS           0x80000000

#endif DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5.1\autoproxy\apdetect.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    apdetect.cxx

Abstract:

    This is the overall generic wrappers and entry code to the 
      auto-proxy, auto-detection code, that sends DHCP informs,
      and mundges through DNS to find an URL for proxy configuration

Author:

    Arthur Bierer (arthurbi)  15-Jul-1998

Environment:

    User Mode - Win32

Revision History:

    Arthur Bierer (arthurbi)  15-Jul-1998
        Created

    Josh Cohen (joshco)     7-oct-1998
        added proxydetecttype

    Stephen Sulzer (ssulzer) 24-Feb-2001
        WinHttp 5 Autoproxy support
        
--*/

#include <wininetp.h>
#include "aproxp.h"
#include "apdetect.h"


DWORD
DetectAutoProxyUrl(
    IN  DWORD   dwDetectFlags,
    OUT LPSTR * ppszAutoProxyUrl
    )
{
    DWORD       error;
    bool        bDetected = false;

    DEBUG_ENTER((DBG_SOCKETS,
                 Bool,
                 "DetectAutoProxyUrl",
                 "%u, %x",
                 dwDetectFlags,
                 ppszAutoProxyUrl
                 ));

    INET_ASSERT(GlobalDataInitialized);

    error = LoadWinsock();

    if (error != ERROR_SUCCESS)
    {
        goto quit;
    }

    if (PROXY_AUTO_DETECT_TYPE_DHCP & dwDetectFlags)
    {
        CIpConfig Interfaces;

        if (Interfaces.DoInformsOnEachInterface(ppszAutoProxyUrl))
        {
            //printf("success on DHCP search: got %s\n", szAutoProxyUrl);
            bDetected = true;
        }
    }

    if (!bDetected && (PROXY_AUTO_DETECT_TYPE_DNS_A & dwDetectFlags))
    {
        if (QueryWellKnownDnsName(ppszAutoProxyUrl) == ERROR_SUCCESS)
        {
            //printf("success on well qualified name search: got %s\n", szAutoProxyUrl);
            bDetected = true;
        }
    }

    if (bDetected)
    {
        INET_ASSERT(*ppszAutoProxyUrl);
        error = ERROR_SUCCESS;
    }
    else
    {
        *ppszAutoProxyUrl = NULL;
        error = ERROR_WINHTTP_AUTODETECTION_FAILED;
    }

quit:

    DEBUG_LEAVE(error);

    return error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5.1\autoproxy\dhcp.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    dhcp.h

Abstract:

    This module defines the DHCP server service definitions and structures.

Author:

    Manny Weiser  (mannyw)  11-Aug-1992

Revision History:

    Madan Appiah (madana) 10-Oct-1993

--*/

#ifndef _DHCP_
#define _DHCP_

#define WS_VERSION_REQUIRED     MAKEWORD( 1, 1)

//
// update dhcpapi.h also if you modify the following three typedefs.
//

typedef DWORD DHCP_IP_ADDRESS, *PDHCP_IP_ADDRESS, *LPDHCP_IP_ADDRESS;
typedef DWORD DHCP_OPTION_ID;

typedef struct _DATE_TIME {
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
} DATE_TIME, *LPDATE_TIME;

#define DHCP_DATE_TIME_ZERO_HIGH        0
#define DHCP_DATE_TIME_ZERO_LOW         0

#define DHCP_DATE_TIME_INFINIT_HIGH     0x7FFFFFFF
#define DHCP_DATE_TIME_INFINIT_LOW      0xFFFFFFFF

#define DOT_IP_ADDR_SIZE                16          // XXX.XXX.XXX.XXX + '\0'
#define NO_DHCP_IP_ADDRESS              ((DHCP_IP_ADDRESS)-1)
#define DHCP_IP_KEY_LEN                 32          //arbitary size.

#define INFINIT_TIME                    0x7FFFFFFF  // time_t is int
#define INFINIT_LEASE                   0xFFFFFFFF  // in secs. (unsigned int.)
#define MDHCP_SERVER_IP_ADDRESS         0x0100efef // 239.239.0.1
//
// hardware types.
//
#define HARDWARE_TYPE_NONE              0 // used for non-hardware type client id
#define HARDWARE_TYPE_10MB_EITHERNET    1
#define HARDWARE_TYPE_IEEE_802          6
#define HARDWARE_ARCNET                 7
#define HARDWARE_PPP                    8
#define HARDWARE_IEEE1394               24

//
// Client-server protoocol reserved ports
//

#define DHCP_CLIENT_PORT    68
#define DHCP_SERVR_PORT     67

//
// DHCP BROADCAST flag.
//

#define DHCP_BROADCAST      0x8000
#define DHCP_NO_BROADCAST   0x0000

// MDHCP flag
#define DHCP_MBIT           0x4000
#define IS_MDHCP_MESSAGE( _msg ) ( _I_ntohs((_msg)->Reserved) & DHCP_MBIT ? TRUE : FALSE )
#define MDHCP_MESSAGE( _msg ) ( (_msg)->Reserved |= htons(DHCP_MBIT) )

#define CLASSD_NET_ADDR(a)  ( (a & 0xf0) == 0xe0)
#define CLASSD_HOST_ADDR(a)  ((a & 0xf0000000) == 0xe0000000)

#define DHCP_MESSAGE_SIZE       576
#define DHCP_SEND_MESSAGE_SIZE  548
#define BOOTP_MESSAGE_SIZE      300 // the options field for bootp is 64 bytes.

//
// The amount of time to wait for a DHCP response after a request
// has been sent.
//

#if !DBG
#define WAIT_FOR_RESPONSE_TIME          5
#else
#define WAIT_FOR_RESPONSE_TIME          10
#endif

//
// DHCP Operations
//

#define BOOT_REQUEST   1
#define BOOT_REPLY     2

//
// DHCP Standard Options.
//

#define OPTION_PAD                      0
#define OPTION_SUBNET_MASK              1
#define OPTION_TIME_OFFSET              2
#define OPTION_ROUTER_ADDRESS           3
#define OPTION_TIME_SERVERS             4
#define OPTION_IEN116_NAME_SERVERS      5
#define OPTION_DOMAIN_NAME_SERVERS      6
#define OPTION_LOG_SERVERS              7
#define OPTION_COOKIE_SERVERS           8
#define OPTION_LPR_SERVERS              9
#define OPTION_IMPRESS_SERVERS          10
#define OPTION_RLP_SERVERS              11
#define OPTION_HOST_NAME                12
#define OPTION_BOOT_FILE_SIZE           13
#define OPTION_MERIT_DUMP_FILE          14
#define OPTION_DOMAIN_NAME              15
#define OPTION_SWAP_SERVER              16
#define OPTION_ROOT_DISK                17
#define OPTION_EXTENSIONS_PATH          18

//
// IP layer parameters - per host
//

#define OPTION_BE_A_ROUTER              19
#define OPTION_NON_LOCAL_SOURCE_ROUTING 20
#define OPTION_POLICY_FILTER_FOR_NLSR   21
#define OPTION_MAX_REASSEMBLY_SIZE      22
#define OPTION_DEFAULT_TTL              23
#define OPTION_PMTU_AGING_TIMEOUT       24
#define OPTION_PMTU_PLATEAU_TABLE       25

//
// Link layer parameters - per interface.
//

#define OPTION_MTU                      26
#define OPTION_ALL_SUBNETS_MTU          27
#define OPTION_BROADCAST_ADDRESS        28
#define OPTION_PERFORM_MASK_DISCOVERY   29
#define OPTION_BE_A_MASK_SUPPLIER       30
#define OPTION_PERFORM_ROUTER_DISCOVERY 31
#define OPTION_ROUTER_SOLICITATION_ADDR 32
#define OPTION_STATIC_ROUTES            33
#define OPTION_TRAILERS                 34
#define OPTION_ARP_CACHE_TIMEOUT        35
#define OPTION_ETHERNET_ENCAPSULATION   36

//
// TCP Paramters - per host
//

#define OPTION_TTL                      37
#define OPTION_KEEP_ALIVE_INTERVAL      38
#define OPTION_KEEP_ALIVE_DATA_SIZE     39

//
// Application Layer Parameters
//

#define OPTION_NETWORK_INFO_SERVICE_DOM 40
#define OPTION_NETWORK_INFO_SERVERS     41
#define OPTION_NETWORK_TIME_SERVERS     42

//
// Vender specific information option
//

#define OPTION_VENDOR_SPEC_INFO         43

//
// NetBIOS over TCP/IP Name server option
//

#define OPTION_NETBIOS_NAME_SERVER      44
#define OPTION_NETBIOS_DATAGRAM_SERVER  45
#define OPTION_NETBIOS_NODE_TYPE        46
#define OPTION_NETBIOS_SCOPE_OPTION     47

//
// X Window System Options.
//

#define OPTION_XWINDOW_FONT_SERVER      48
#define OPTION_XWINDOW_DISPLAY_MANAGER  49

//
// Other extensions
//

#define OPTION_REQUESTED_ADDRESS        50
#define OPTION_LEASE_TIME               51
#define OPTION_OK_TO_OVERLAY            52
#define OPTION_MESSAGE_TYPE             53
#define OPTION_SERVER_IDENTIFIER        54
#define OPTION_PARAMETER_REQUEST_LIST   55
#define OPTION_MESSAGE                  56
#define OPTION_MESSAGE_LENGTH           57
#define OPTION_RENEWAL_TIME             58      // T1
#define OPTION_REBIND_TIME              59      // T2
#define OPTION_CLIENT_CLASS_INFO        60
#define OPTION_CLIENT_ID                61

#define OPTION_TFTP_SERVER_NAME         66
#define OPTION_BOOTFILE_NAME            67

//
//  user class id
//
#define OPTION_USER_CLASS               77

//
//  Dynamic DNS Stuff.  Tells if we should do both A+PTR updates?
//
#define OPTION_DYNDNS_BOTH              81

// Multicast options.
#define OPTION_MCAST_SCOPE_ID           101
#define OPTION_MCAST_LEASE_START        102
#define OPTION_MCAST_TTL                103
#define OPTION_CLIENT_PORT              105
#define OPTION_MCAST_SCOPE_LIST         107

// special option to extend options
#define     OPTION_LARGE_OPTION    127

#define OPTION_WPAD_URL                 252 

#define OPTION_END                      255

// default mcast_ttl value.
#define DEFAULT_MCAST_TTL               32

//
// Different option values for the DYNDNS_BOTH option ...
//

#define DYNDNS_REGISTER_AT_CLIENT       0     // Client will do both registrations
#define DYNDNS_REGISTER_AT_SERVER       1     // Server will do registrations
#define DYNDNS_DOWNLEVEL_CLIENT         3     // arbitraty # diff from above

//
// Microsoft-specific options
//
#define OPTION_MSFT_DSDOMAINNAME_REQ    94    // send me your DS Domain name
#define OPTION_MSFT_DSDOMAINNAME_RESP   95    // sending my DS Domain name
#define OPTION_MSFT_CONTINUED           250   // the previous option is being continued..

//
// DHCP Message types
//

#define DHCP_DISCOVER_MESSAGE  1
#define DHCP_OFFER_MESSAGE     2
#define DHCP_REQUEST_MESSAGE   3
#define DHCP_DECLINE_MESSAGE   4
#define DHCP_ACK_MESSAGE       5
#define DHCP_NACK_MESSAGE      6
#define DHCP_RELEASE_MESSAGE   7
#define DHCP_INFORM_MESSAGE    8

#define DHCP_MAGIC_COOKIE_BYTE1     99
#define DHCP_MAGIC_COOKIE_BYTE2     130
#define DHCP_MAGIC_COOKIE_BYTE3     83
#define DHCP_MAGIC_COOKIE_BYTE4     99

#define BOOT_FILE_SIZE          128
#define BOOT_SERVER_SIZE        64
#define BOOT_FILE_SIZE_W        ( BOOT_FILE_SIZE * sizeof( WCHAR ))
#define BOOT_SERVER_SIZE_W      ( BOOT_SERVER_SIZE * sizeof( WCHAR ))

//
// DHCP APP names - used to indentify to the eventlogger.
//

#define DHCP_EVENT_CLIENT     TEXT("Dhcp")
#define DHCP_EVENT_SERVER     TEXT("DhcpServer")


typedef struct _OPTION {
    BYTE OptionType;
    BYTE OptionLength;
    BYTE OptionValue[1];
} OPTION, *POPTION, *LPOPTION;

//
// A DHCP message buffer
//


#pragma pack(1)         /* Assume byte packing */
typedef struct _DHCP_MESSAGE {
    BYTE Operation;
    BYTE HardwareAddressType;
    BYTE HardwareAddressLength;
    BYTE HopCount;
    DWORD TransactionID;
    WORD SecondsSinceBoot;
    WORD Reserved;
    DHCP_IP_ADDRESS ClientIpAddress;
    DHCP_IP_ADDRESS YourIpAddress;
    DHCP_IP_ADDRESS BootstrapServerAddress;
    DHCP_IP_ADDRESS RelayAgentIpAddress;
    BYTE HardwareAddress[16];
    BYTE HostName[ BOOT_SERVER_SIZE ];
    BYTE BootFileName[BOOT_FILE_SIZE];
    OPTION Option;
} DHCP_MESSAGE, *PDHCP_MESSAGE, *LPDHCP_MESSAGE;
#pragma pack()

#define DHCP_MESSAGE_FIXED_PART_SIZE \
            (sizeof(DHCP_MESSAGE) - sizeof(OPTION))

#define DHCP_MIN_SEND_RECV_PK_SIZE \
            (DHCP_MESSAGE_FIXED_PART_SIZE + 64)

//
// JET - DHCP database constants.
//

#define DB_TABLE_SIZE       10      // table size in 4K pages.
#define DB_TABLE_DENSITY    80      // page density
#define DB_LANGID           0x0409  // language id
#define DB_CP               1252    // code page

#if DBG

//
// debug functions.
//

#ifdef CHICAGO // No Tracing available on CHICAGO
#define DhcpPrintTrace
#endif

//#define IF_DEBUG(flag) if (DhcpGlobalDebugFlag & (DEBUG_ ## flag))
#define DhcpPrint(_x_) DEBUG_PRINT(UTIL,INFO,_x_)
#define Trace          DhcpPrintTrace

#ifndef CHICAGO
VOID
DhcpPrintTrace(
    IN LPSTR Format,
    ...
    );

#endif

#if DBG

/*
VOID
//extern "C"
DhcpPrintRoutine(
    IN DWORD DebugFlag,
    IN LPSTR Format,
    ...
    )
{

#define MAX_PRINTF_LEN 1024        // Arbitrary.

    va_list arglist;
    char OutputBuffer[MAX_PRINTF_LEN];
    ULONG length = 0;

    //
    // Put a the information requested by the caller onto the line
    //

    va_start(arglist, Format);
    length += (ULONG) vsprintf(&OutputBuffer[length], Format, arglist);
    va_end(arglist);

    //DhcpAssert(length <= MAX_PRINTF_LEN);

    //
    // Output to the debug terminal,
    //

    printf( "%s", OutputBuffer);
}
*/
#endif // DBG


#else

//#define IF_DEBUG(flag) if (FALSE)
#define DhcpPrint(_x_)
#define Trace       (void)

#endif // DBG

#define OpenDriver     DhcpOpenDriver

#endif // _DHCP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5.1\autoproxy\cscpsite.cpp ===
#include <wininetp.h>
#include <cscpsite.h>
#include <objsafe.h>
#include "jsproxy.h"
#include "utils.h"


/*******************************************************************************
*    CScriptSite Functions
********************************************************************************/
CScriptSite::CScriptSite()
{
    m_refCount = 1;
    m_pios = NULL;
    m_pasp = NULL; 
    m_pScriptDispatch = NULL;
    m_Scriptdispid = -1;
    m_punkJSProxy = NULL;
    m_fInitialized = FALSE;

}
CScriptSite::~CScriptSite()
{
    if (m_fInitialized)
        DeInit();
}

STDMETHODIMP CScriptSite::QueryInterface(REFIID riid, PVOID *ppvObject)
{
    if (riid == IID_IUnknown)
    {            
        *ppvObject = (LPVOID)(LPUNKNOWN)static_cast<IActiveScriptSite *>(this);
    }
    else if (riid == IID_IActiveScriptSite)
    {
        *ppvObject = (LPVOID)static_cast<IActiveScriptSite *>(this);
    }
    else if (riid == IID_IServiceProvider)
    {
        *ppvObject = (LPVOID)static_cast<IServiceProvider *>(this);
    }
    else if (riid == IID_IInternetHostSecurityManager)
    {
        *ppvObject = (LPVOID)static_cast<IInternetHostSecurityManager *>(this);
    }
    else
    {
        *ppvObject = 0;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

STDMETHODIMP CScriptSite::Init(AUTO_PROXY_HELPER_APIS* pAPHA, LPCSTR szScript)
{
    CHAR szClassId[64];    
    CLSID clsid;
    HRESULT hr = S_OK;
    BSTR    bstrClsID = NULL;
    BSTR    bstrScriptText = NULL;
    BSTR    rgbstrNames[1] = {L"FindProxyForURL"};
    EXCEPINFO    exceptinfo;
    IObjectSafety * pIObjSafety = NULL;

    // pAPHA can be null - it is checked in the autoproxy object!
    if (!szScript)
        return E_POINTER;

    if (m_fInitialized)
        return hr;
    // CoCreateInstance the JScript engine.

    if(!DelayLoad(&g_moduleOle32)
       || !DelayLoad(&g_moduleOleAut32))
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Get the class id of the desired language engine
    hr = GetScriptEngineClassIDFromName(
        "JavaScript",
        szClassId,
        sizeof(szClassId)
        );
    if (FAILED(hr)) {
        return E_FAIL;
    }
    //convert CLSID string to clsid

    bstrClsID = BSTRFROMANSI(szClassId);
    if (!bstrClsID)
        goto exit;
    hr = DL(CLSIDFromString)(bstrClsID, &clsid);
    DL(SysFreeString)(bstrClsID);
    if (FAILED(hr))
        goto exit;

    // Instantiate the script engine
    hr = DL(CoCreateInstance)(clsid, NULL, CLSCTX_INPROC_SERVER, IID_IActiveScript, (void**)&m_pios);
    if (FAILED(hr))
        goto exit;

    // Get the IActiveScriptParse interface, if any
    hr = m_pios->QueryInterface(IID_IActiveScriptParse, (void**) &m_pasp);
    if (FAILED(hr))
        goto exit;

    hr = m_pasp->InitNew();
    if (FAILED(hr))
        goto exit;

    // SetScriptSite to this
    hr = m_pios->SetScriptSite((IActiveScriptSite *)this);
    if (FAILED(hr))
        goto exit;
    hr = m_pios->SetScriptState(SCRIPTSTATE_INITIALIZED);

    //
    // Inform the script engine that this host implements
    // the IInternetHostSecurityManager interface, which
    // is used to prevent the script code from using any
    // ActiveX objects.
    //
    hr = m_pios->QueryInterface(IID_IObjectSafety, (void **)&pIObjSafety);

    if (SUCCEEDED(hr) && (pIObjSafety != NULL))
    {
        pIObjSafety->SetInterfaceSafetyOptions(IID_NULL, 
                INTERFACE_USES_SECURITY_MANAGER,
                INTERFACE_USES_SECURITY_MANAGER);

        pIObjSafety->Release();
        pIObjSafety = NULL;
    }

    // AddNamedItem for pUnk and set m_punkJSProxy to pUnk.
    // If we added JSProxy to the name space the store away the JSProxy objects punk.
    m_punkJSProxy = new CJSProxy;
    if( !m_punkJSProxy )
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }
    m_punkJSProxy->Init(pAPHA);
    hr = m_pios->AddNamedItem(L"JSProxy",SCRIPTITEM_ISVISIBLE | SCRIPTITEM_GLOBALMEMBERS);
    if (FAILED(hr))
        goto exit;
    
    // Convert the ANSI script text to a bstr.
    bstrScriptText = BSTRFROMANSI(szScript);
    if (!bstrScriptText)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }
    // Add the script text to the parser
    hr = m_pasp->ParseScriptText(
             bstrScriptText,
             NULL,
             NULL,
             NULL,
             0,
             0,
             SCRIPTTEXT_ISEXPRESSION|SCRIPTTEXT_ISVISIBLE,
             NULL,
             &exceptinfo);
    
    DL(SysFreeString)(bstrScriptText);
    if (FAILED(hr))
        goto exit;

    hr = m_pios->SetScriptState(SCRIPTSTATE_STARTED);
    if (FAILED(hr))
        goto exit;
    // Now get the script dispatch and find the DISPID for the method just added.  since this is a single use dll
    // I can do this otherwise this would be bad.
    hr = m_pios->GetScriptDispatch(NULL,&m_pScriptDispatch);
    if (FAILED(hr))
        goto exit;
    hr = m_pScriptDispatch->GetIDsOfNames(IID_NULL,rgbstrNames,1,LOCALE_SYSTEM_DEFAULT,&m_Scriptdispid);
    if (FAILED(hr))
        goto exit;

    m_fInitialized = TRUE;

    return hr;

exit: // we come here if something fails  -  release everything and set to null.
    if (m_pasp)
        m_pasp->Release();
    if (m_pScriptDispatch)
        m_pScriptDispatch->Release();
    if (m_pios)
    {
        m_pios->Close();
        m_pios->Release();
    }
    if (m_punkJSProxy)
        m_punkJSProxy->Release();
    m_pios = NULL;
    m_pasp = NULL;
    m_pScriptDispatch = NULL;
    m_Scriptdispid = -1;
    m_punkJSProxy = NULL;
    
    return hr;
}

STDMETHODIMP CScriptSite::DeInit()
{
    HRESULT hr = S_OK;

    if (m_pasp)
        m_pasp->Release();

    if (m_pScriptDispatch)
        m_pScriptDispatch->Release();

    if (m_pios)
    {
        hr = m_pios->Close();
        m_pios->Release();
    }

    if (m_punkJSProxy)
        m_punkJSProxy->Release();

    m_pios = NULL;
    m_pasp = NULL;
    m_pScriptDispatch = NULL;
    m_Scriptdispid = -1;
    m_fInitialized = FALSE;

    return hr;
}

STDMETHODIMP CScriptSite::RunScript(LPCSTR szURL, LPCSTR szHost, LPSTR* result)
{
    HRESULT        hr = S_OK;
    UINT        puArgErr = 0;
    EXCEPINFO    excep;
    VARIANT        varresult;
    DISPPARAMS    dispparams;
    VARIANT        args[2]; // We always call with 2 args!

    
    if (!szURL || !szHost || !result)
        return E_POINTER;

    if (!m_fInitialized)
        return E_UNEXPECTED;
        
    DL(VariantInit)(&varresult);

    dispparams.cArgs = 2;
    DL(VariantInit)(&args[0]);
    DL(VariantInit)(&args[1]);

    args[0].vt = VT_BSTR;
    args[1].vt = VT_BSTR;

    args[0].bstrVal = BSTRFROMANSI(szHost);
    args[1].bstrVal = BSTRFROMANSI(szURL);

    dispparams.rgvarg = args;

    dispparams.cNamedArgs = 0;    
    dispparams.rgdispidNamedArgs = NULL; 

    // Call invoke on the stored dispid
    hr = m_pScriptDispatch->Invoke(m_Scriptdispid,
                    IID_NULL,LOCALE_SYSTEM_DEFAULT,
                    DISPATCH_METHOD,
                    &dispparams,
                    &varresult,
                    &excep,
                    &puArgErr);

    // convert result into bstr and return ansi version of the string!
    if (varresult.vt == VT_BSTR)
    {
        MAKE_ANSIPTR_FROMWIDE(rescpy, varresult.bstrVal);
        *result = (LPSTR) GlobalAlloc(GPTR|GMEM_ZEROINIT,lstrlen(rescpy)+1);
        if (!*result)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        lstrcpy(*result,rescpy);

    }
    else
    {
        VARIANT    resvar;

        DL(VariantInit)(&resvar);
        hr = DL(VariantChangeType)(&resvar,&varresult,NULL,VT_BSTR);
        if (SUCCEEDED(hr))
        {
            MAKE_ANSIPTR_FROMWIDE(rescpy, resvar.bstrVal);
            *result = (LPSTR) GlobalAlloc(GPTR|GMEM_ZEROINIT,lstrlen(rescpy)+1);
            if (!*result)
            {
                hr = E_OUTOFMEMORY;
                DL(VariantClear)(&resvar);
                goto Cleanup;
            }
            lstrcpy(*result,rescpy);
        }
        else
            *result = NULL;
        DL(VariantClear)(&resvar);
    }

Cleanup:
    DL(VariantClear)(&varresult);
    DL(VariantClear)(&args[0]);
    DL(VariantClear)(&args[1]);
    
    return hr;
}

STDMETHODIMP CScriptSite::GetLCID(LCID *plcid)
{
    UNREFERENCED_PARAMETER(plcid);
    return E_NOTIMPL;
}
STDMETHODIMP CScriptSite::GetItemInfo(LPCOLESTR pstrName, DWORD dwReturnMask, IUnknown **ppunkItem, ITypeInfo **ppTypeInfo)
{
    UNREFERENCED_PARAMETER(ppTypeInfo);
    if (!pstrName || !ppunkItem)
        return E_POINTER;

    if ((StrCmpW(L"JSProxy",pstrName) == 0) && (dwReturnMask == SCRIPTINFO_IUNKNOWN))
    {
        *ppunkItem = (LPUNKNOWN)(IDispatch*)(CJSProxy*)m_punkJSProxy;
        (*ppunkItem)->AddRef();
        return S_OK;
    }
    else
        return TYPE_E_ELEMENTNOTFOUND;
}
STDMETHODIMP CScriptSite::GetDocVersionString(BSTR *pstrVersionString)
{
    UNREFERENCED_PARAMETER(pstrVersionString);
    return E_NOTIMPL;
}

// I am not interested it the transitioning of state or the status of where we are in
// the executing of the script.
STDMETHODIMP CScriptSite::OnScriptTerminate(const VARIANT *pvarResult,const EXCEPINFO *pexcepinfo)
{
    UNREFERENCED_PARAMETER(pvarResult);
    UNREFERENCED_PARAMETER(pexcepinfo);
    return S_OK;
}
STDMETHODIMP CScriptSite::OnStateChange(SCRIPTSTATE ssScriptState)
{
     UNREFERENCED_PARAMETER(ssScriptState);
     return S_OK;
}
STDMETHODIMP CScriptSite::OnScriptError(IActiveScriptError *pase)
{
     UNREFERENCED_PARAMETER(pase);
     return S_OK;
}
STDMETHODIMP CScriptSite::OnEnterScript()
{
    return S_OK;
}
STDMETHODIMP CScriptSite::OnLeaveScript()
{
    return S_OK;
}

//
// IServiceProvider
//
//      Implemented to help wire up the script engine with our
//      IInternetHostSecurityManager interface.
//

STDMETHODIMP CScriptSite::QueryService(
    REFGUID guidService,
    REFIID  riid,
    void ** ppvObject)
{
    if (guidService == SID_SInternetHostSecurityManager)
    {
        return QueryInterface(riid, ppvObject);
    }
    else
    {
        return E_NOINTERFACE;
    }
}


//
// IInternetHostSecurityManager
// 
//      Implemented to prevent the script code from using ActiveX objects.
//

STDMETHODIMP CScriptSite::GetSecurityId( 
    BYTE *      pbSecurityId,
    DWORD *     pcbSecurityId,
    DWORD_PTR   dwReserved)
{
    UNREFERENCED_PARAMETER(pbSecurityId);
    UNREFERENCED_PARAMETER(pcbSecurityId);
    UNREFERENCED_PARAMETER(dwReserved);

    return E_NOTIMPL;
}


STDMETHODIMP CScriptSite::ProcessUrlAction( 
    DWORD   dwAction,
    BYTE *  pPolicy,
    DWORD   cbPolicy,
    BYTE *  pContext,
    DWORD   cbContext,
    DWORD   dwFlags,
    DWORD   dwReserved)
{
    UNREFERENCED_PARAMETER(dwAction);
    UNREFERENCED_PARAMETER(pContext);
    UNREFERENCED_PARAMETER(cbContext);
    UNREFERENCED_PARAMETER(dwFlags);
    UNREFERENCED_PARAMETER(dwReserved);

    //
    // Deny the script any capabilites. In particular, this
    // will disallow the script code from instantiating 
    // ActiveX objects.
    //

    if (cbPolicy == sizeof(DWORD))
    {
        *(DWORD *)pPolicy = URLPOLICY_DISALLOW;
    }

    return S_FALSE; // S_FALSE means the policy != URLPOLICY_ALLOW.
}


STDMETHODIMP CScriptSite::QueryCustomPolicy( 
    REFGUID guidKey,
    BYTE ** ppPolicy,
    DWORD * pcbPolicy,
    BYTE *  pContext,
    DWORD   cbContext,
    DWORD   dwReserved)
{
    UNREFERENCED_PARAMETER(guidKey);
    UNREFERENCED_PARAMETER(ppPolicy);
    UNREFERENCED_PARAMETER(pcbPolicy);
    UNREFERENCED_PARAMETER(pContext);
    UNREFERENCED_PARAMETER(cbContext);
    UNREFERENCED_PARAMETER(dwReserved);

    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5.1\autoproxy\dhcpdef.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    dhcpdef.h

Abstract:

    This module contains data type definitions for the DHCP client.

Author:

    Madan Appiah (madana) 31-Oct-1993

Environment:

    User Mode - Win32

Revision History:

--*/
//
// init.c will #include this file with GLOBAL_DATA_ALLOCATE defined.
// That will cause each of these variables to be allocated.
//

#ifndef _DHCPDEF_
#define _DHCPDEF_

#ifdef  GLOBAL_DATA_ALLOCATE
#define EXTERN
#else
#define EXTERN extern
#endif

//
// the registry key is of different type between NT and Memphis.
//
#ifdef VXD
typedef VMMHKEY   DHCPKEY;
#else  //  NT
typedef HKEY      DHCPKEY;
#endif


#ifndef VXD
#define RUNNING_IN_RAS_CONTEXT()     (!DhcpGlobalIsService)
#else
#define RUNNING_IN_RAS_CONTEXT()     FALSE
#endif


//
// The amount of time to wait for a retry if we have no IP address
//

#define ADDRESS_ALLOCATION_RETRY        300 //  5 minutes
#define EASYNET_ALLOCATION_RETRY        300 //  5 minutes

//
// The amount of time to wait for a retry if we have an IP address,
// but the renewal on startup failed.
//

#if !DBG
#define RENEWAL_RETRY                   600 // 10 minutes
#else
#define RENEWAL_RETRY                   60  // 1 minute
#endif

//
// The number of times to send a request before giving up waiting
// for a response.
//

#define DHCP_MAX_RETRIES                4
#define DHCP_ACCEPT_RETRIES             2
#define DHCP_MAX_RENEW_RETRIES          2


//
// amount of time required between consequtive send_informs..
//

#define DHCP_DEFAULT_INFORM_SEPARATION_INTERVAL   60 // one minute

//
// amount of time to wait after an address conflict is detected
//

#define ADDRESS_CONFLICT_RETRY          10 // 10 seconds

//
//
// Expoenential backoff delay.
//

#define DHCP_EXPO_DELAY                  4

//
// The maximum total amount of time to spend trying to obtain an
// initial address.
//
// This delay is computed as below:
//
// DHCP_MAX_RETRIES - n
// DHCP_EXPO_DELAY - m
// WAIT_FOR_RESPONSE_TIME - w
// MAX_STARTUP_DELAY - t
//
// Binary Exponential backup Algorithm.
//
// t > m * (n*(n+1)/2) + n + w*n
//     -------------------   ---
//        random wait      + response wait
//

#define MAX_STARTUP_DELAY \
    DHCP_EXPO_DELAY * \
        (( DHCP_MAX_RETRIES * (DHCP_MAX_RETRIES + 1)) / 2) + \
            DHCP_MAX_RETRIES + DHCP_MAX_RETRIES * WAIT_FOR_RESPONSE_TIME

#define MAX_RENEW_DELAY \
    DHCP_EXPO_DELAY * \
        (( DHCP_MAX_RENEW_RETRIES * (DHCP_MAX_RENEW_RETRIES + 1)) / 2) + \
            DHCP_MAX_RENEW_RETRIES + DHCP_MAX_RENEW_RETRIES * \
                WAIT_FOR_RESPONSE_TIME

//
// The maximum amount of time to wait between renewal retries, if the
// lease period is between T1 and T2.
//

#define MAX_RETRY_TIME                  3600    // 1 hour

//
// Minimum time to sleep between retries.
//

#if DBG
#define MIN_SLEEP_TIME                  1 * 60      // 1 min.
#else
#define MIN_SLEEP_TIME                  5 * 60      // 5 min.
#endif

//
// Minimum lease time.
//

#define DHCP_MINIMUM_LEASE              60*60   // 24 hours.

#ifdef __DHCP_DYNDNS_ENABLED__

#define DHCP_DNS_TTL                    0       // let the DNS api decide..

#endif


//
// IP Autoconfiguration defaults
//

#define DHCP_IPAUTOCONFIGURATION_DEFAULT_SUBNET  "169.254.0.0"
#define DHCP_IPAUTOCONFIGURATION_DEFAULT_MASK    "255.255.0.0"

// define the reserved range of autonet addresses..

#define DHCP_RESERVED_AUTOCFG_SUBNET             "169.254.255.0"
#define DHCP_RESERVED_AUTOCFG_MASK               "255.255.255.0"

// will dhcp pick any reserved autonet addr? NO!
#define DHCP_RESERVED_AUTOCFG_FLAG                (1)

// self default route (0,0,<self>) will have a metric of (3)
#define DHCP_SELF_DEFAULT_METRIC                  (3)

//
// General purpose macros
//

#define MIN(a,b)                        ((a) < (b) ? (a) : (b))
#define MAX(a,b)                        ((a) > (b) ? (a) : (b))

#if DBG
#define STATIC
#else
#define STATIC static
#endif

/*#define LOCK_RENEW_LIST()       EnterCriticalSection(&DhcpGlobalRenewListCritSect)
#define UNLOCK_RENEW_LIST()     LeaveCriticalSection(&DhcpGlobalRenewListCritSect)

#define LOCK_INTERFACE()        EnterCriticalSection(&DhcpGlobalSetInterfaceCritSect)
#define UNLOCK_INTERFACE()      LeaveCriticalSection(&DhcpGlobalSetInterfaceCritSect)

#define LOCK_OPTIONS_LIST()     EnterCriticalSection(&DhcpGlobalOptionsListCritSect)
#define UNLOCK_OPTIONS_LIST()   LeaveCriticalSection(&DhcpGlobalOptionsListCritSect)
*/
#define LOCK_RENEW_LIST()       
#define UNLOCK_RENEW_LIST()     

#define LOCK_INTERFACE()        
#define UNLOCK_INTERFACE()      

#define LOCK_OPTIONS_LIST()     
#define UNLOCK_OPTIONS_LIST()   


#define ZERO_TIME                       0x0         // in secs.

//
// length of the time string returned by ctime.
// actually it is 26.
//

#define TIME_STRING_LEN                 32

//
// String size when a long converted to printable string.
// 2^32 = 4294967295 (10 digits) + termination char.
//

#define LONG_STRING_SIZE                12

//
// A renewal function.
//

typedef
DWORD
(*PRENEWAL_FUNCTION) (
    IN PVOID Context,
    LPDWORD Sleep
    );

//
// DHCP Client-Identifier (option 61)
//
typedef struct _DHCP_CLIENT_IDENTIFIER
{
    BYTE  *pbID;
    DWORD  cbID;
    BYTE   bType;
    BOOL   fSpecified;
} DHCP_CLIENT_IDENTIFIER;


//
// state information for IP autoconfiguration
//

typedef struct _DHCP_IPAUTOCONFIGURATION_CONTEXT
{
    DHCP_IP_ADDRESS   Address;
    DHCP_IP_ADDRESS   Subnet;
    DHCP_IP_ADDRESS   Mask;
    DWORD             Seed;
} DHCP_IPAUTOCONFIGURATION_CONTEXT;

//
// A DHCP context block.  One block is maintained per NIC (network
// interface Card).
//

typedef struct _DHCP_CONTEXT {

        // list of adapters.
    //LIST_ENTRY NicListEntry;

        // hardware type.
    BYTE HardwareAddressType;
        // HW address, just follows this context structure.
    LPBYTE HardwareAddress;
        // Length of HW address.
    DWORD HardwareAddressLength;

        // Selected IpAddress, NetworkOrder.
    DHCP_IP_ADDRESS IpAddress;
        // Selected subnet mask. NetworkOrder.
    //DHCP_IP_ADDRESS SubnetMask;
        // Selected DHCP server address. Network Order.
    DHCP_IP_ADDRESS DhcpServerAddress;
        // Desired IpAddress the client request in next discover.
    //DHCP_IP_ADDRESS DesiredIpAddress;
        // The ip address that was used just before losing this..
    //DHCP_IP_ADDRESS LastKnownGoodAddress; // ONLY DNS uses this..
        // the domain name that was used with last registration..
    //WCHAR LastUsedDomainName[257]; // dns domain name is atmost 255 bytes.
        // current domain name for this adapter.
    //BYTE  DomainName[257];

        // IP Autoconfiguration state
    //DHCP_IPAUTOCONFIGURATION_CONTEXT IPAutoconfigurationContext;

    DHCP_CLIENT_IDENTIFIER ClientIdentifier;

        // Lease time in seconds.
    //DWORD Lease;
        // Time the lease was obtained.
    //time_t LeaseObtained;
        // Time the client should start renew its address.
    //time_t T1Time;
        // Time the client should start broadcast to renew address.
    time_t T2Time;
        // Time the lease expires. The clinet should stop using the
        // IpAddress.
        // LeaseObtained  < T1Time < T2Time < LeaseExpires
    //time_t LeaseExpires;
        // when was the last time an inform was sent?
    time_t LastInformSent;
        // how many seconds between consecutive informs?
    //DWORD  InformSeparationInterval;
        // # of gateways and the currently plumbed gateways are stored here
    //DWORD  nGateways;
    //DHCP_IP_ADDRESS *GatewayAddresses;

        // # of static routes and the actual static routes are stored here
    //DWORD  nStaticRoutes;
    //DHCP_IP_ADDRESS *StaticRouteAddresses;

        // to place in renewal list.
    //LIST_ENTRY RenewalListEntry;
        // Time for next renewal state.
    //time_t RunTime;

        // seconds passed since boot.
    DWORD SecondsSinceBoot;

        // should we ping the g/w or always assume g/w is NOT present?
    //BOOL  DontPingGatewayFlag;

        // can we use DHCP_INFORM packets or should we use DHCP_REQUEST instead?
    //BOOL  UseInformFlag;

    //WORD  ClientPort;

        // what to function at next renewal state.
    //PRENEWAL_FUNCTION RenewalFunction;

    	// A semaphore for synchronization to this structure
    //HANDLE RenewHandle;

        // the list of options to send and the list of options received
    LIST_ENTRY  SendOptionsList;
    LIST_ENTRY  RecdOptionsList;

        // the opened key to the adapter info storage location
    //DHCPKEY AdapterInfoKey;

        // the class this adapter belongs to
    LPBYTE ClassId;
    DWORD  ClassIdLength;

        // Message buffer to send and receive DHCP message.
    PDHCP_MESSAGE MessageBuffer;

        // state information for this interface. see below for manifests
    struct /* anonymous */ {
        unsigned Plumbed       : 1 ;    // is this interface plumbed
        unsigned ServerReached : 1 ;    // Did we reach the server ever
        unsigned AutonetEnabled: 1 ;    // Autonet enabled?
        unsigned HasBeenLooked : 1 ;    // Has this context been looked at?
        unsigned DhcpEnabled   : 1 ;    // Is this context dhcp enabled?
        unsigned AutoMode      : 1 ;    // Currently in autonet mode?
        unsigned MediaState    : 2 ;    // One of connected, disconnected, reconnected
        unsigned MDhcp         : 1 ;    // Is this context created for Mdhcp?
        unsigned PowerResumed  : 1 ;    // Was power just resumed on this interface?
        unsigned Broadcast     : 1 ;
    }   State;

	    // machine specific information
    //PVOID LocalInformation;
     
//    DWORD  IpInterfaceInstance;  // needed for BringUpInterface
    LPTSTR AdapterName;
//    LPWSTR DeviceName;
//    LPWSTR NetBTDeviceName;
//    LPWSTR RegistryKey;
    SOCKET Socket;
    DWORD  IpInterfaceContext;
//    BOOL DefaultGatewaysSet;

    CHAR szMessageBuffer[DHCP_MESSAGE_SIZE];
} DHCP_CONTEXT, *PDHCP_CONTEXT;

#define ADDRESS_PLUMBED(Ctxt)        ((Ctxt)->State.Plumbed = 1)
#define ADDRESS_UNPLUMBED(Ctxt)      ((Ctxt)->State.Plumbed = 0)
#define IS_ADDRESS_PLUMBED(Ctxt)     ((Ctxt)->State.Plumbed)
#define IS_ADDRESS_UNPLUMBED(Ctxt)   (!(Ctxt)->State.Plumbed)

#define CONNECTION_BROADCAST(Ctxt)        ((Ctxt)->State.Broadcast = 1)
#define CONNECTION_NO_BROADCAST(Ctxt)      ((Ctxt)->State.Broadcast = 0)
#define IS_CONNECTION_BROADCAST(Ctxt)     ((Ctxt)->State.Broadcast)
#define IS_CONNECTION_NOBROADCAST(Ctxt)   (!(Ctxt)->State.Broadcast)

#define SERVER_REACHED(Ctxt)         ((Ctxt)->State.ServerReached = 1)
#define SERVER_UNREACHED(Ctxt)       ((Ctxt)->State.ServerReached = 0)
#define IS_SERVER_REACHABLE(Ctxt)    ((Ctxt)->State.ServerReached)
#define IS_SERVER_UNREACHABLE(Ctxt)  (!(Ctxt)->State.ServerReached)

#define AUTONET_ENABLED(Ctxt)        ((Ctxt)->State.AutonetEnabled = 1)
#define AUTONET_DISABLED(Ctxt)       ((Ctxt)->State.AutonetEnabled = 0)
#define IS_AUTONET_ENABLED(Ctxt)     ((Ctxt)->State.AutonetEnabled)
#define IS_AUTONET_DISABLED(Ctxt)    (!(Ctxt)->State.AutonetEnabled)

#define CTXT_WAS_LOOKED(Ctxt)        ((Ctxt)->State.HasBeenLooked = 1)
#define CTXT_WAS_NOT_LOOKED(Ctxt)    ((Ctxt)->State.HasBeenLooked = 0)
#define WAS_CTXT_LOOKED(Ctxt)        ((Ctxt)->State.HasBeenLooked)
#define WAS_CTXT_NOT_LOOKED(Ctxt)    (!(Ctxt)->State.HasBeenLooked)

#define DHCP_ENABLED(Ctxt)           ((Ctxt)->State.DhcpEnabled = 1)
#define DHCP_DISABLED(Ctxt)          ((Ctxt)->State.DhcpEnabled = 0)
#define IS_DHCP_ENABLED(Ctxt)        ((Ctxt)->State.DhcpEnabled )
#define IS_DHCP_DISABLED(Ctxt)       (!(Ctxt)->State.DhcpEnabled )

#define ADDRESS_TYPE_AUTO            1
#define ADDRESS_TYPE_DHCP            0

#define ACQUIRED_DHCP_ADDRESS(Ctxt)  ((Ctxt)->State.AutoMode = 0 )
#define ACQUIRED_AUTO_ADDRESS(Ctxt)  ((Ctxt)->State.AutoMode = 1 )
#define IS_ADDRESS_DHCP(Ctxt)        (!(Ctxt)->State.AutoMode)
#define IS_ADDRESS_AUTO(Ctxt)        ((Ctxt)->State.AutoMode)

#define MEDIA_CONNECTED(Ctxt)        ((Ctxt)->State.MediaState = 0)
#define MEDIA_RECONNECTED(Ctxt)      ((Ctxt)->State.MediaState = 1)
#define MEDIA_DISCONNECTED(Ctxt)     ((Ctxt)->State.MediaState = 2)
#define IS_MEDIA_CONNECTED(Ctxt)     ((Ctxt)->State.MediaState == 0)
#define IS_MEDIA_RECONNECTED(Ctxt)   ((Ctxt)->State.MediaState == 1)
#define IS_MEDIA_DISCONNECTED(Ctxt)  ((Ctxt)->State.MediaState == 2)

#define _INIT_STATE1(Ctxt)           do{(Ctxt)->State.Plumbed = 0; (Ctxt)->State.AutonetEnabled=0;}while(0)
#define _INIT_STATE2(Ctxt)           do{(Ctxt)->State.HasBeenLooked = 0; (Ctxt)->State.DhcpEnabled=1;}while(0)
#define _INIT_STATE3(Ctxt)           do{(Ctxt)->State.AutoMode = 0; (Ctxt)->State.MediaState = 0;}while(0)
#define INIT_STATE(Ctxt)             do{_INIT_STATE1(Ctxt);_INIT_STATE2(Ctxt);_INIT_STATE3(Ctxt);}while(0)

#define MDHCP_CTX(Ctxt)           ((Ctxt)->State.MDhcp = 1)
#define NONMDHCP_CTX(Ctxt)          ((Ctxt)->State.MDhcp = 0)
#define IS_MDHCP_CTX(Ctxt)        ((Ctxt)->State.MDhcp )
#define SET_MDHCP_STATE( Ctxt ) { \
    ADDRESS_PLUMBED( Ctxt ), MDHCP_CTX( Ctxt ); \
}

#define POWER_RESUMED(Ctxt)           ((Ctxt)->State.PowerResumed = 1)
#define POWER_NOT_RESUMED(Ctxt)       ((Ctxt)->State.PowerResumed = 0)
#define IS_POWER_RESUMED(Ctxt)        ((Ctxt)->State.PowerResumed )


/*LPSTR _inline                        //  the string'ed version of state (same as Buffer)
ConvertStateToString(                //  convert from bits to string
    IN PDHCP_CONTEXT   Ctxt,         //  The context to print state for
    IN LPBYTE          Buffer        //  The input buffer to write state into
) {
    strcpy(Buffer, IS_DHCP_ENABLED(Ctxt)?"DhcpEnabled ":"DhcpDisabled ");
    strcat(Buffer, IS_AUTONET_ENABLED(Ctxt)?"AutonetEnabled ":"AutonetDisabled ");
    strcat(Buffer, IS_ADDRESS_DHCP(Ctxt)?"DhcpMode ":"AutoMode ");
    strcat(Buffer, IS_ADDRESS_PLUMBED(Ctxt)?"Plumbed ":"UnPlumbed ");
    strcat(Buffer, IS_SERVER_REACHABLE(Ctxt)?"(server-present) ":"(server-absent) ");
    strcat(Buffer, WAS_CTXT_LOOKED(Ctxt)? "(seen) ":"(not-seen) ");

    if(IS_MEDIA_CONNECTED(Ctxt) ) strcat(Buffer, "MediaConnected\n");
    else if(IS_MEDIA_RECONNECTED(Ctxt)) strcat(Buffer, "MediaReConnected\n");
    else if(IS_MEDIA_DISCONNECTED(Ctxt)) strcat(Buffer, "MediaDisConnected\n");
    else strcat(Buffer, "MediaUnknownState\n");

    strcat(Buffer, IS_MDHCP_CTX(Ctxt)? "(MDhcp) ":"");
    strcat(Buffer, IS_POWER_RESUMED(Ctxt)? "Pwr Resumed ":"");

    return Buffer;
}
*/

//
// The types of machines.. laptop would have aggressive EASYNET behaviour.
//

#define MACHINE_NONE   0
#define MACHINE_LAPTOP 1

//
//  Here is the set of expected options by the client -- If they are absent, not much can be done
//

typedef struct _DHCP_EXPECTED_OPTIONS {
    BYTE            UNALIGNED*     MessageType;
    DHCP_IP_ADDRESS UNALIGNED*     SubnetMask;
    DHCP_IP_ADDRESS UNALIGNED*     LeaseTime;
    DHCP_IP_ADDRESS UNALIGNED*     ServerIdentifier;
    BYTE            UNALIGNED*     DomainName;
    DWORD                          DomainNameSize;
    // Wpad Auto-Proxy Url
    BYTE            UNALIGNED*     WpadUrl;
    DWORD                          WpadUrlSize;
} DHCP_EXPECTED_OPTIONS, *PDHCP_EXPECTED_OPTIONS, *LPDHCP_EXPECTED_OPTIONS;

//
//  Here is the set of options understood by the client
//
typedef struct _DHCP_FULL_OPTIONS {
    BYTE            UNALIGNED*     MessageType;   // What kind of message is this?

    // Basic IP Parameters

    DHCP_IP_ADDRESS UNALIGNED*     SubnetMask;
    DHCP_IP_ADDRESS UNALIGNED*     LeaseTime;
    DHCP_IP_ADDRESS UNALIGNED*     T1Time;
    DHCP_IP_ADDRESS UNALIGNED*     T2Time;
    DHCP_IP_ADDRESS UNALIGNED*     GatewayAddresses;
    DWORD                          nGateways;
    DHCP_IP_ADDRESS UNALIGNED*     StaticRouteAddresses;
    DWORD                          nStaticRoutes;

    DHCP_IP_ADDRESS UNALIGNED*     ServerIdentifier;

    // DNS parameters

    BYTE            UNALIGNED*     DnsFlags;
    BYTE            UNALIGNED*     DnsRcode1;
    BYTE            UNALIGNED*     DnsRcode2;
    BYTE            UNALIGNED*     DomainName;
    DWORD                          DomainNameSize;
    DHCP_IP_ADDRESS UNALIGNED*     DnsServerList;
    DWORD                          nDnsServers;

    // Multicast options.
    DWORD           UNALIGNED*     MCastLeaseStartTime;
    BYTE            UNALIGNED     *MCastTTL;

    // Server message is something that the server may inform us of

    BYTE            UNALIGNED*     ServerMessage;
    DWORD                          ServerMessageLength;

    // Wpad Auto-Proxy Url
    BYTE            UNALIGNED*     WpadUrl;
    DWORD                          WpadUrlSize;

} DHCP_FULL_OPTIONS, *PDHCP_FULL_OPTIONS, *LPDHCP_FULL_OPTIONS;

typedef DHCP_FULL_OPTIONS DHCP_OPTIONS, *PDHCP_OPTIONS;

//
// structure for a list of messages
//

typedef struct _MSG_LIST {
    LIST_ENTRY     MessageListEntry;
    DWORD          ServerIdentifier;
    DWORD          MessageSize;
    DWORD          LeaseExpirationTime;
    DHCP_MESSAGE   Message;
} MSGLIST, *PMSGLIST, *LPMSGLIST;


//
// DHCP Global data.
//

extern BOOL DhcpGlobalServiceRunning;   // initialized global.

EXTERN LPSTR DhcpGlobalHostName;
EXTERN LPWSTR DhcpGlobalHostNameW;
EXTERN LPSTR DhcpGlobalHostComment;

//
// NIC List.
//

EXTERN LIST_ENTRY DhcpGlobalNICList;
EXTERN LIST_ENTRY DhcpGlobalRenewList;

//
// Synchronization variables.
//

EXTERN CRITICAL_SECTION DhcpGlobalRenewListCritSect;
EXTERN CRITICAL_SECTION DhcpGlobalSetInterfaceCritSect;
EXTERN CRITICAL_SECTION DhcpGlobalOptionsListCritSect;
EXTERN HANDLE DhcpGlobalRecomputeTimerEvent;
EXTERN HANDLE DhcpGlobalResumePowerEvent;

// waitable timer
EXTERN HANDLE DhcpGlobalWaitableTimerHandle;

//
// to display success message.
//

EXTERN BOOL DhcpGlobalProtocolFailed;

//
// This varible tells if we are going to provide the DynDns api support to external clients
// and if we are going to use the corresponding DnsApi.  The define below gives the default
// value.
//

EXTERN DWORD UseMHAsyncDns;
#define DEFAULT_USEMHASYNCDNS             1

//
// This flag tells if we need to use inform or request packets
//
EXTERN DWORD DhcpGlobalUseInformFlag;

//
// This flag tells if pinging the g/w is disabled. (in this case the g/w is always NOT present)
//
EXTERN DWORD DhcpGlobalDontPingGatewayFlag;

//
// The # of seconds before retrying according to AUTONET... default is EASYNET_ALLOCATION_RETRY
//

EXTERN DWORD AutonetRetriesSeconds;

//
// Not used on NT.  Just here for memphis.
//

EXTERN DWORD DhcpGlobalMachineType;

//
// Do we need to do a global refresh?
//

EXTERN ULONG DhcpGlobalDoRefresh;


//
// options related lists
//

EXTERN LIST_ENTRY DhcpGlobalClassesList;
EXTERN LIST_ENTRY DhcpGlobalOptionDefList;


//
// dhcpmsg.c.. list for doing parallel recv on..
//

EXTERN LIST_ENTRY DhcpGlobalRecvFromList;
EXTERN CRITICAL_SECTION DhcpGlobalRecvFromCritSect;

//
// the client vendor name ( "MSFT 5.0" or something like that )
//

EXTERN LPSTR   DhcpGlobalClientClassInfo;

//
// The following global keys are used to avoid re-opening each time
//
EXTERN DHCPKEY DhcpGlobalParametersKey;
EXTERN DHCPKEY DhcpGlobalTcpipParametersKey;
EXTERN DHCPKEY DhcpGlobalClientOptionKey;
EXTERN DHCPKEY DhcpGlobalServicesKey;

//
// debug variables.
//

#if DBG
EXTERN DWORD DhcpGlobalDebugFlag;
#endif

#endif // _DHCPDEF_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5.1\autoproxy\dhcplib.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    dhcplib.h

Abstract:

    This file contains proto type definitions for the dhcp lib
    functions.

Author:

    Madan Appiah  (madana)  12-Aug-1993

Environment:

    User Mode - Win32 - MIDL

Revision History:

--*/
#ifndef DHCPLIB_H_INCLUDED
#define DHCPLIB_H_INCLUDED


#define DhcpAllocateMemory(x) ALLOCATE_ZERO_MEMORY(x)
#define DhcpFreeMemory(x)     FREE_MEMORY(x)


//
// network.c
//

DHCP_IP_ADDRESS
DhcpDefaultSubnetMask(
    DHCP_IP_ADDRESS IpAddress
    );

//
// dhcp.c
//


/*PVOID
DhcpAllocateMemory(
    DWORD Size
    );

VOID
DhcpFreeMemory(
    PVOID Memory
    );*/


#if DBG

#ifndef DEBUG_ALLOC
#define DEBUG_ALLOC 0x02000000
#endif

/*
PVOID _inline
DhcpAllocateMemoryEx(
    DWORD Size,
    DWORD LineNo,
    LPSTR FileName
) {
    LPVOID Ptr = DhcpAllocateMemory(Size);

    DhcpPrint(("Allocate %010x %04x %04d %s\n", Ptr, Size, LineNo, FileName));
    return Ptr;
}

VOID _inline
DhcpFreeMemoryEx(
    LPVOID Ptr,
    DWORD  LineNo,
    LPSTR  FileName
) {
    DhcpFreeMemory(Ptr);
    DhcpPrint("Free %010x %04x %04d %s\n", Ptr, 0, LineNo, FileName));
} 
*/

//#define DhcpAllocateMemory(Sz)    DhcpAllocateMemoryEx(Sz, __LINE__, __FILE__)
//#define DhcpFreeMemory(Ptr)       DhcpFreeMemoryEx(Ptr, __LINE__, __FILE__)

#endif

LPOPTION
DhcpAppendOption(
    LPOPTION Option,
    BYTE OptionType,
    PVOID OptionValue,
    ULONG OptionLength,
    LPBYTE OptionEnd
    );

LPOPTION
DhcpAppendClientIDOption(
    LPOPTION Option,
    BYTE ClientHWType,
    LPBYTE ClientHWAddr,
    BYTE ClientHWAddrLength,
    LPBYTE OptionEnd

    );

LPBYTE
DhcpAppendMagicCookie(
    LPBYTE Option,
    LPBYTE OptionEnd

    );

LPOPTION
DhcpAppendEnterpriseName(
    LPOPTION Option,
    PCHAR    DSEnterpriseName,
    LPBYTE   OptionEnd
    );

DATE_TIME
DhcpCalculateTime(
    DWORD RelativeTime
    );

DATE_TIME
DhcpGetDateTime(
    VOID
    );

DWORD
DhcpReportEventW(
    LPWSTR Source,
    DWORD EventID,
    DWORD EventType,
    DWORD NumStrings,
    DWORD DataLength,
    LPWSTR *Strings,
    LPVOID Data
    );

DWORD
DhcpReportEventA(
    LPWSTR Source,
    DWORD EventID,
    DWORD EventType,
    DWORD NumStrings,
    DWORD DataLength,
    LPSTR *Strings,
    LPVOID Data
    );

DWORD
DhcpLogUnknownOption(
    LPWSTR Source,
    DWORD EventID,
    LPOPTION Option
    );

VOID
DhcpCancelWaitableTimer(
    HANDLE TimerHandle
    );

DWORD
DhcpStartWaitableTimer(
    HANDLE TimerHandle,
    DWORD SleepTime);


//
// convert.c
//

LPWSTR
DhcpOemToUnicodeN(
    IN      LPSTR   Ansi,
    IN OUT  LPWSTR  Unicode,
    IN      USHORT  cChars
    );

LPWSTR
DhcpOemToUnicode(
    IN LPSTR Ansi,
    IN OUT LPWSTR Unicode
    );

LPSTR
DhcpUnicodeToOem(
    IN LPWSTR Unicode,
    IN LPSTR Ansi
    );

#if 0

VOID
DhcpIpAddressToString(
    LPWSTR Buffer,
    DWORD HexNumber
    );

VOID
DhcpStringToIpAddress(
    LPSTR Buffer,
    LPDHCP_IP_ADDRESS IpAddress,
    BOOL NetOrder
    );

#endif

VOID
DhcpHexToString(
    LPWSTR Buffer,
    LPBYTE HexNumber,
    DWORD Length
    );

VOID
DhcpHexToAscii(
    LPSTR Buffer,
    LPBYTE HexNumber,
    DWORD Length
    );

VOID
DhcpDecimalToString(
    LPWSTR Buffer,
    BYTE Number
    );

DWORD
DhcpDottedStringToIpAddress(
    LPSTR String
    );

LPSTR
DhcpIpAddressToDottedString(
    DWORD IpAddress
    );

DWORD
DhcpStringToHwAddress(
    LPSTR AddressBuffer,
    LPSTR AddressString
    );

#if 0

DHCP_IP_ADDRESS
DhcpHostOrder(
    DHCP_IP_ADDRESS NetworkOrderAddress
    );

DHCP_IP_ADDRESS
DhcpNetworkOrder(
    DHCP_IP_ADDRESS NetworkOrderAddress
    );

#endif

LPWSTR
DhcpRegIpAddressToKey(
    DHCP_IP_ADDRESS IpAddress,
    LPWSTR KeyBuffer
    );

DWORD
DhcpRegKeyToIpAddress(
    LPWSTR Key
    );

LPWSTR
DhcpRegOptionIdToKey(
    DHCP_OPTION_ID OptionId,
    LPWSTR KeyBuffer
    );

DHCP_OPTION_ID
DhcpRegKeyToOptionId(
    LPWSTR Key
    );

#if 0 //DBG

VOID
DhcpDumpMessage(
    DWORD DhcpDebugFlag,
    LPDHCP_MESSAGE DhcpMessage
    );

VOID
DhcpAssertFailed(
    LPSTR FailedAssertion,
    LPSTR FileName,
    DWORD LineNumber,
    LPSTR Message
    );

#define DhcpAssert(Predicate) \
    { \
        if (!(Predicate)) \
            DhcpAssertFailed( #Predicate, __FILE__, __LINE__, NULL ); \
    }


#define DhcpVerify(Predicate) \
    { \
        if (!(Predicate)) \
            DhcpAssertFailed( #Predicate, __FILE__, __LINE__, NULL ); \
    }


#else

#define DhcpAssert(_x_)
#define DhcpDumpMessage(_x_, _y_)
#define DhcpVerify(_x_) (_x_)

#endif // not DBG

VOID
DhcpNTToNTPTime(
    LPDATE_TIME AbsNTTime,
    DWORD       Offset,
    PULONG      NTPTimeStamp
    );

VOID
DhcpNTPToNTTime(
    PULONG          NTPTimeStamp,
    DWORD           Offset,
    DATE_TIME       *NTTime
    );


#endif DHCPLIB_H_INCLUDED

//------------------------------------------------------------------------
// End of file
//------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5.1\autoproxy\dhcpcli.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    dhcpcli.h

Abstract:

    This file is the central include file for the DHCP client service.

Author:

    Manny Weiser  (mannyw)  20-Oct-1992

Environment:

    User Mode - Win32

Revision History:

    Madan Appiah (madana)  21-Oct-1993

--*/

#ifndef _DHCPCLI_H_
#define _DHCPCLI_H_

//
//  NT public header files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#ifdef VXD
#define WIN32_LEAN_AND_MEAN         // Don't include extraneous headers
#endif

#include <windows.h>                // (spec. winsock.h)
#include <winsock.h>

//
//  DHCP public header files
//

#include <dhcp.h>
#include <dhcplib.h>
#if !defined(VXD)
#include <dhcpcapi.h>
#endif

//
// C Runtime Lib.
//

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>

//
//  Local header files
//

#include <dhcpdef.h>
#include <debug.h>
#include <gmacros.h>

#ifdef VXD
#include <vxdmsg.h>
#else
#include <dhcpmsg.h>
#endif

#if     defined(_PNP_POWER_)
#include <ipexport.h>
#ifndef VXD
#include <ntddip.h>
#endif
#endif _PNP_POWER_

#include <proto.h>


#ifdef VXD
#include <vxdprocs.h>
#endif


//
// debug heap
//
#include <heapx.h>

#ifndef VXD
#ifdef DBG
#ifdef __DHCP_USE_DEBUG_HEAP__

#pragma message ( "*** DHCP Client will use debug heap ***" )

#define DhcpAllocateMemory(x) ALLOCATE_ZERO_MEMORY(x)
#define DhcpFreeMemory(x)     FREE_MEMORY(x)

#endif
#endif
#endif

#ifdef CHICAGO
#define _WINNT_
#include <vmm.h>
#endif  // CHICAGO
//
// Macros for pageable code.
//
#define CTEMakePageable( _Page, _Routine )  \
    alloc_text(_Page,_Routine)

#ifdef CHICAGO
#define ALLOC_PRAGMA
#undef  INIT
#define INIT _ITEXT
#undef  PAGE
#define PAGE _PTEXT
#define PAGEDHCP _PTEXT
#endif // CHICAGO

#if     defined(CHICAGO) && defined(DEBUG)
//
// This is asserts when the pageable code is called at inappropriate time.
// Since in reality all our pageable code is dynamically locked, there is no
// need for this.
//
//#define CTEPagedCode() _Debug_Flags_Service(DFS_TEST_REENTER+DFS_TEST_BLOCK)
#define CTEPagedCode()
#else
#define CTEPagedCode()
#endif

#include <options.h>
#include <optreg.h>
#include <stack.h>

#endif //_DHCPCLI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5.1\autoproxy\dhcploc.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    local.h

Abstract:

    This module contains various declarations for implementation
    specific "stuff".

Author:

    Manny Weiser (mannyw)  21-Oct-1992

Environment:

    User Mode - Win32

Revision History:

    Madan Appiah (madana)  21-Oct-1993

--*/

#ifndef _LOCAL_
#define _LOCAL_

//
// dhcp.c will #include this file with GLOBAL_DATA_ALLOCATE defined.
// That will cause each of these variables to be allocated.
//

#ifdef  GLOBAL_DATA_ALLOCATE
#define EXTERN
#else
#define EXTERN extern
#endif

#define DAY_LONG_SLEEP                          24*60*60    // in secs.
#define INVALID_INTERFACE_CONTEXT               0xFFFF

#define DHCP_NEW_IPADDRESS_EVENT_NAME   TEXT("DHCPNEWIPADDRESS"

//
// Registry keys and values we're interested in.
//

#define DHCP_SERVICES_KEY                       TEXT("System\\CurrentControlSet\\Services")

#define DHCP_ADAPTERS_KEY                       TEXT("System\\CurrentControlSet\\Services\\TCPIP\\Linkage")
#define DHCP_ADAPTERS_VALUE                     TEXT("Bind")
#define DHCP_ADAPTERS_VALUE_TYPE                REG_MULTI_SZ
#define DHCP_ADAPTERS_DEVICE_STRING             TEXT("\\Device\\")
#define DHCP_TCPIP_DEVICE_STRING                TEXT("\\Device\\TCPIP_")
#if     defined(_PNP_POWER_)
#define DHCP_NETBT_DEVICE_STRING                TEXT("NetBT_TCPIP_")
#else
#define DHCP_NETBT_DEVICE_STRING                TEXT("NetBT_")
#endif _PNP_POWER_

#define DHCP_CLIENT_ENABLE_DYNDNS_VALUE         TEXT("EnableDynDNS")
#define DHCP_CLIENT_ENABLE_DYNDNS_VALUE_TYPE    REG_DWORD

#ifdef DYNDNS_DNS_OVERRIDE_ENABLED

#define DHCP_CLIENT_DYNDNS_DNS_OVERRIDE_VALUE   TEXT("DynDNSServer")
#define DHCP_CLIENT_DYNDNS_DNS_OVERRIDE_VALUE_TYPE REG_DWORD

#endif

#define DHCP_CLIENT_PARAMETER_KEY               TEXT("System\\CurrentControlSet\\Services\\Dhcp\\Parameters")

#if DBG
#define DHCP_DEBUG_FLAG_VALUE                   TEXT("DebugFlag")
#define DHCP_DEBUG_FLAG_VALUE_TYPE              REG_DWORD
#endif

#define DHCP_CLIENT_OPTION_KEY                  TEXT("System\\CurrentControlSet\\Services\\Dhcp\\Parameters\\Options")

#define DHCP_CLIENT_GLOBAL_CLASSES_KEY          TEXT("System\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Classes")
#define DHCP_CLIENT_CLASS_VALUE                 TEXT("DhcpMachineClass")

#if     defined(_PNP_POWER_)
#define DHCP_ADAPTER_PARAMETERS_KEY             TEXT("\\TCPIP\\Parameters\\Interfaces")
#else
#define DHCP_ADAPTER_PARAMETERS_KEY             TEXT("\\Parameters\\TCPIP")
#endif _PNP_POWER_

#define DHCP_DEFAULT_GATEWAY_PARAMETER          TEXT("DefaultGateway")
#define DHCP_DONT_ADD_DEFAULT_GATEWAY_FLAG      TEXT("DontAddDefaultGateway")
#define DHCP_DONT_PING_GATEWAY_FLAG             TEXT("DontPingGateway")
#define DHCP_USE_MHASYNCDNS_FLAG                TEXT("UseMHAsyncDns")
#define DHCP_USE_INFORM_FLAG                    TEXT("UseInform")
#define DHCP_INFORM_SEPARATION_INTERVAL         TEXT("DhcpInformInterval")

#define DHCP_TCPIP_PARAMETERS_KEY               DHCP_SERVICES_KEY TEXT("\\TCPIP\\Parameters")
#define DHCP_TCPIP_ADAPTER_PARAMETERS_KEY       NULL
#define DHCP_NAME_SERVER_VALUE                  TEXT("NameServer")
#define DHCP_IPADDRESS_VALUE                    TEXT("IPAddress")
#define DHCP_HOSTNAME_VALUE                     TEXT("Hostname")
#define DHCP_DOMAINNAME_VALUE                   TEXT("Domain")
#define DHCP_STATIC_DOMAIN_VALUE_A              "Domain"

#ifdef __DHCP_CLIENT_OPTIONS_API_ENABLED__

#define DHCP_CLIENT_OPTION_SIZE                 TEXT("OptionSize")
#define DHCP_CLIENT_OPTION_SIZE_TYPE            REG_DWORD
#define DHCP_CLIENT_OPTION_VALUE                TEXT("OptionValue")
#define DHCP_CLIENT_OPTION_VALUE_TYPE           REG_BINARY

#endif

#define REGISTRY_CONNECT                        L'\\'
#define REGISTRY_CONNECT_STRING                 TEXT("\\")

#define DHCP_CLIENT_OPTION_REG_LOCATION         TEXT("RegLocation")
#define DHCP_CLIENT_OPTION_REG_LOCATION_TYPE    REG_SZ

#define DHCP_CLIENT_OPTION_REG_KEY_TYPE         TEXT("KeyType")
#define DHCP_CLIENT_OPTION_REG_KEY_TYPE_TYPE    REG_DWORD

#define DHCP_CLASS_LOCATION_VALUE               TEXT("DhcpClientClassLocation")
#define DHCP_CLASS_LOCATION_TYPE                REG_MULTI_SZ

#define DEFAULT_USER_CLASS_LOCATION             TEXT("Tcpip\\Parameters\\Interfaces\\?\\DhcpClassIdBin")
#define DEFAULT_USER_CLASS_LOC_FULL             DHCP_SERVICES_KEY REGISTRY_CONNECT_STRING DEFAULT_USER_CLASS_LOCATION

#define DEFAULT_USER_CLASS_UI_LOCATION          TEXT("Tcpip\\Parameters\\Interfaces\\?\\DhcpClassId")
#define DEFAULT_USER_CLASS_UI_LOC_FULL          DHCP_SERVICES_KEY REGISTRY_CONNECT_STRING DEFAULT_USER_CLASS_UI_LOCATION

// ******** Don;t chagne regloc for below.. it also affects DHCP_REGISTER_OPTION_LOC below
#define DEFAULT_REGISTER_OPT_LOC            TEXT("Tcpip\\Parameters\\Interfaces\\?\\DhcpRequestOptions")

#define DHCP_OPTION_LIST_VALUE                  TEXT("DhcpOptionLocationList")
#define DHCP_OPTION_LIST_TYPE                   REG_MULTI_SZ

#define NETBIOSLESS_OPT                         TEXT("DhcpNetbiosLessOption\0")
#define DEFAULT_DHCP_KEYS_LIST_VALUE            (L"1\0" L"15\0" L"3\0" L"44\0" L"46\0" L"47\0" L"6\0" NETBIOSLESS_OPT)

#define DHCP_OPTION_OPTIONID_VALUE              TEXT("OptionId")
#define DHCP_OPTION_OPTIONID_TYPE               REG_DWORD

#define DHCP_OPTION_ISVENDOR_VALUE              TEXT("VendorType")
#define DHCP_OPTION_ISVENDOR_TYPE               REG_DWORD

#define DHCP_OPTION_SAVE_TYPE_VALUE             TEXT("KeyType")
#define DHCP_OPTION_SAVE_TYPE_TYPE              REG_DWORD

#define DHCP_OPTION_CLASSID_VALUE               TEXT("ClassId")
#define DHCP_OPTION_CLASSID_TYPE                REG_BINARY

#define DHCP_OPTION_SAVE_LOCATION_VALUE         TEXT("RegLocation")
#define DHCP_OPTION_SAVE_LOCATION_TYPE          REG_MULTI_SZ

#define DHCP_OPTION_SEND_LOCATION_VALUE         TEXT("RegSendLocation")
#define DHCP_OPTION_SEND_LOCATION_TYPE          REG_MULTI_SZ



#define DHCP_ENABLE_STRING                      TEXT("EnableDhcp")
#define DHCP_ENABLE_STRING_TYPE                 REG_DWORD

#define DHCP_IP_ADDRESS_STRING                  TEXT("DhcpIPAddress")
#define DHCP_IP_ADDRESS_STRING_TYPE             REG_SZ

#define DHCP_SUBNET_MASK_STRING                 TEXT("DhcpSubnetMask")
#define DHCP_SUBNET_MASK_STRING_TYPE            REG_SZ

#define DHCP_SERVER                             TEXT("DhcpServer")
#define DHCP_SERVER_TYPE                        REG_SZ

#define DHCP_LEASE                              TEXT("Lease")
#define DHCP_LEASE_TYPE                         REG_DWORD

#define DHCP_LEASE_OBTAINED_TIME                TEXT("LeaseObtainedTime")
#define DHCP_LEASE_OBTAINED_TIME_TYPE           REG_DWORD

#define DHCP_LEASE_T1_TIME                      TEXT("T1")
#define DHCP_LEASE_T1_TIME_TYPE                 REG_DWORD

#define DHCP_LEASE_T2_TIME                      TEXT("T2")
#define DHCP_LEASE_T2_TIME_TYPE                 REG_DWORD

#define DHCP_LEASE_TERMINATED_TIME              TEXT("LeaseTerminatesTime")
#define DHCP_LEASE_TERMINATED_TIME_TYPE         REG_DWORD

#define DHCP_IP_INTERFACE_CONTEXT               TEXT("IpInterfaceContext")
#define DHCP_IP_INTERFACE_CONTEXT_TYPE          REG_DWORD

#define DHCP_IP_INTERFACE_CONTEXT_MAX           TEXT("IpInterfaceContextMax")
#define DHCP_IP_INTERFACE_CONTEXT_MAX_TYPE      REG_DWORD

#if     defined(_PNP_POWER_)
#define DHCP_NTE_CONTEXT_LIST                   TEXT("NTEContextList")
#define DHCP_NTE_CONTEXT_LIST_TYPE              REG_MULTI_SZ
#endif _PNP_POWER_

#define DHCP_CLIENT_IDENTIFIER_FORMAT           TEXT("DhcpClientIdentifierType")
#define DHCP_CLIENT_IDENTIFIER_FORMAT_TYPE      REG_DWORD

#define DHCP_CLIENT_IDENTIFIER_VALUE            TEXT("DhcpClientIdentifier")

#define DHCP_DYNDNS_UPDATE_REQUIRED             TEXT("DNSUpdateRequired")
#define DHCP_DYNDNS_UPDATE_REQUIRED_TYPE        REG_DWORD

#define DHCP_IPAUTOCONFIGURATION_ENABLED        TEXT("IPAutoconfigurationEnabled")
#define DHCP_IPAUTOCONFIGURATION_ENABLED_TYPE   REG_DWORD

#define DHCP_IPAUTOCONFIGURATION_ADDRESS        TEXT("IPAutoconfigurationAddress")
#define DHCP_IPAUTOCONFIGURATION_ADDRESS_TYPE   REG_SZ

#define DHCP_IPAUTOCONFIGURATION_SUBNET         TEXT("IPAutoconfigurationSubnet")
#define DHCP_IPAUTOCONFIGURATION_SUBNET_TYPE    REG_SZ

#define DHCP_IPAUTOCONFIGURATION_MASK           TEXT("IPAutoconfigurationMask")
#define DHCP_IPAUTOCONFIGURATION_MASK_TYPE      REG_SZ

#define DHCP_IPAUTOCONFIGURATION_SEED           TEXT("IPAutoconfigurationSeed")
#define DHCP_IPAUTOCONFIGURATION_SEED_TYPE      REG_DWORD

#define DHCP_OPTION_EXPIRATION_DATE             TEXT("ExpirationTime")
#define DHCP_OPTION_EXPIRATION_DATE_TYPE        REG_BINARY

#define DHCP_MACHINE_TYPE                       TEXT("MachineType")
#define DHCP_MACHINE_TYPE_TYPE                  REG_DWORD

#define DHCP_AUTONET_RETRIES_VALUE              TEXT("AutonetRetries")
#define DHCP_AUTONET_RETRIES_VALUE_TYPE         REG_DWORD

#define DHCP_ADDRESS_TYPE_VALUE                 TEXT("AddressType")
#define DHCP_ADDRESS_TYPE_TYPE                  REG_DWORD

#if DBG

#define DHCP_LEASE_OBTAINED_CTIME               TEXT("LeaseObtainedCTime"
#define DHCP_LEASE_OBTAINED_CTIME_TYPE          REG_SZ

#define DHCP_LEASE_T1_CTIME                     TEXT("T1CTime")
#define DHCP_LEASE_T1_CTIME_TYPE                REG_SZ

#define DHCP_LEASE_T2_CTIME                     TEXT("T2CTime")
#define DHCP_LEASE_T2_CTIME_TYPE                REG_SZ

#define DHCP_LEASE_TERMINATED_CTIME             TEXT("LeaseTerminatesCTime")
#define DHCP_LEASE_TERMINATED_CTIME_TYPE        REG_SZ

#define DHCP_OPTION_EXPIRATION_CDATE            TEXT("ExpirationCTime")
#define DHCP_OPTION_EXPIRATION_CDATE_TYPE       REG_SZ


#endif

// options api specials
#define DHCPAPI_VALID_VALUE                     TEXT("Valid")
#define DHCPAPI_VALID_VALUE_TYPE                REG_DWORD

#define DHCPAPI_AVAIL_VALUE                     TEXT("AvailableOptions")
#define DHCPAPI_AVAIL_VALUE_TYPE                REG_BINARY

#define DHCPAPI_REQUESTED_VALUE                 TEXT("RequestedOptions")
#define DHCPAPI_REQUESTED_VALUE_TYPE            REG_BINARY

#define DHCPAPI_RAW_OPTIONS_VALUE               TEXT("RawOptionsValue")
#define DHCPAPI_RAW_OPTIONS_VALUE_TYPE          REG_BINARY

#define DHCPAPI_RAW_LENGTH_VALUE                TEXT("RawOptionsLength")
#define DHCPAPI_RAW_LENGTH_VALUE_TYPE           REG_DWORD

#define DHCPAPI_GATEWAY_VALUE                   TEXT("LastGateWay")
#define DHCPAPI_GATEWAY_VALUE_TYPE              REG_DWORD

// this tag is used to locate dns updates requests on the renewal list
#define DHCP_DNS_UPDATE_CONTEXT_TAG             TEXT("DNSUpdateRetry")

// This semaphore cannot have backward slashes in it.
#define DHCP_REQUEST_OPTIONS_API_SEMAPHORE      TEXT("DhcpRequestOptionsAPI")

// the client vendor name (DhcpGlobalClientClassInfo) value is this..
#define DHCP_DEFAULT_CLIENT_CLASS_INFO          "MSFT 5.0"

// the location for storing options for DhcpRegisterOptions API.
// ****** Don't change the foll value -- it also changes DEFAULT_REGISTER_OPT_LOC above
//
#define DHCP_REGISTER_OPTIONS_LOC               DHCP_TCPIP_PARAMETERS_KEY L"\\Interfaces\\?\\DhcpRequestOptions"

//
// size of the largest adapter name in unicode.
//
#define ADAPTER_STRING_SIZE 512

//
// windows version info.
//

#define HOST_COMMENT_LENGTH                     128
#define WINDOWS_32S                             "Win32s on Windows 3.1"
#define WINDOWS_NT                              "Windows NT"

#define DHCP_NAMESERVER_BACKUP                  TEXT("Backup")
#define DHCP_NAMESERVER_BACKUP_LIST             TEXT("BackupList")

//
// Adapter Key - replacement character.
//
#define OPTION_REPLACE_CHAR                     L'\?'

//
// registry access key.
//

#define DHCP_CLIENT_KEY_ACCESS  (KEY_QUERY_VALUE |           \
                                    KEY_SET_VALUE |          \
                                    KEY_CREATE_SUB_KEY |     \
                                    KEY_ENUMERATE_SUB_KEYS)

//
// Dhcp registry class.
//

#define DHCP_CLASS                      TEXT("DhcpClientClass")
#define DHCP_CLASS_SIZE                 sizeof(DHCP_CLASS)


//
// Option ID key length.
//

#define DHCP_OPTION_KEY_LEN             32

//
// The name of the DHCP service DLL
//

#define DHCP_SERVICE_DLL                TEXT("dhcpcsvc.dll")

//
// command values for SetDefaultGateway function.

#define DEFAULT_GATEWAY_ADD             0
#define DEFAULT_GATEWAY_DELETE          1


//
// A block NT specific context information, appended the the DHCP work
// context block.
//

typedef struct _LOCAL_CONTEXT_INFO {
    DWORD  IpInterfaceContext;
    DWORD  IpInterfaceInstance;  // needed for BringUpInterface
    LPWSTR AdapterName;
#if     !defined(_PNP_POWER_)
    LPWSTR DeviceName;
#endif _PNP_POWER_
    LPWSTR NetBTDeviceName;
    LPWSTR RegistryKey;
    SOCKET Socket;
    BOOL DefaultGatewaysSet;
} LOCAL_CONTEXT_INFO, *PLOCAL_CONTEXT_INFO;

//
// Other service specific options info struct.
//

typedef struct _SERVICE_SPECIFIC_DHCP_OPTION {
    DHCP_OPTION_ID OptionId;
    LPWSTR RegKey;              // alloted memory.
    LPWSTR ValueName;           // embedded in the RegKey memory.
    DWORD ValueType;
    DWORD OptionLength;
#ifdef __DHCP_CLIENT_OPTIONS_API_ENABLED__
    time_t ExpirationDate; // this value is used to decide when to stop
                           // requested unneeded options.
#endif
    LPBYTE RawOptionValue;
} SERVICE_SPECIFIC_DHCP_OPTION, *LPSERVICE_SPECIFIC_DHCP_OPTION;


//
// Key query Info.
//

typedef struct _DHCP_KEY_QUERY_INFO {
    WCHAR Class[DHCP_CLASS_SIZE];
    DWORD ClassSize;
    DWORD NumSubKeys;
    DWORD MaxSubKeyLen;
    DWORD MaxClassLen;
    DWORD NumValues;
    DWORD MaxValueNameLen;
    DWORD MaxValueLen;
    DWORD SecurityDescriptorLen;
    FILETIME LastWriteTime;
} DHCP_KEY_QUERY_INFO, *LPDHCP_KEY_QUERY_INFO;

//
// Global variables.
//

//
// client specific option list.
//


EXTERN HINSTANCE DhcpGlobalMessageFileHandle;

EXTERN DWORD DhcpGlobalOptionCount;
EXTERN LPSERVICE_SPECIFIC_DHCP_OPTION DhcpGlobalOptionInfo;
EXTERN LPBYTE DhcpGlobalOptionList;

//
// Service variables
//

EXTERN SERVICE_STATUS DhcpGlobalServiceStatus;
EXTERN SERVICE_STATUS_HANDLE DhcpGlobalServiceStatusHandle;

//
// To signal to stop the service.
//

EXTERN HANDLE DhcpGlobalTerminateEvent;

//
// multi home flag.
//

EXTERN BOOL DhcpGlobalMultiHomedHost;

//
// Client APIs over name pipe variables.
//

EXTERN HANDLE DhcpGlobalClientApiPipe;
EXTERN HANDLE DhcpGlobalClientApiPipeEvent;
EXTERN OVERLAPPED DhcpGlobalClientApiOverLapBuffer;

//
// Message Popup Thread handle.
//

EXTERN HANDLE DhcpGlobalMsgPopupThreadHandle;
EXTERN BOOL DhcpGlobalDisplayPopup;
EXTERN CRITICAL_SECTION DhcpGlobalPopupCritSect;

#define LOCK_POPUP()   EnterCriticalSection(&DhcpGlobalPopupCritSect)
#define UNLOCK_POPUP() LeaveCriticalSection(&DhcpGlobalPopupCritSect)


//
// winsock variables.
//

EXTERN WSADATA DhcpGlobalWsaData;
EXTERN BOOL DhcpGlobalWinSockInitialized;

EXTERN BOOL DhcpGlobalGatewaysSet;

EXTERN BOOL DhcpGlobalIsService;

//
// a named event that notifies the ip address changes to
// external apps.
//

EXTERN HANDLE DhcpGlobalNewIpAddressNotifyEvent;
EXTERN UINT   DhcpGlobalIPEventSeqNo;


#endif // _LOCAL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5.1\autoproxy\dhcppro.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    lproto.h

Abstract:

    This file contains function proto types for the NT specific
    functions.

Author:

    Madan Appiah (madana)  Dec-7-1993

Environment:

    User Mode - Win32

Revision History:


--*/

//
// dhcpreg.c
//

DWORD
DhcpRegQueryInfoKey(
    HKEY KeyHandle,
    LPDHCP_KEY_QUERY_INFO QueryInfo
    );

DWORD
GetRegistryString(
    HKEY Key,
    LPVOID ValueStringName,
    LPTSTR *String,
    LPDWORD StringSize
    );

DWORD
DhcpRegReadParamString(
    LPWSTR     AdapterName,
    LPWSTR     RegKeyLocation,
    LPWSTR     ValueName,
    LPWSTR    *ReturnValue
);

DWORD
RegSetIpAddress(
    HKEY KeyHandle,
    LPWSTR ValueName,
    DWORD ValueType,
    DHCP_IP_ADDRESS IpAddress
    );

#if DBG
DWORD
RegSetTimeField(
    HKEY KeyHandle,
    LPWSTR ValueName,
    DWORD ValueType,
    time_t Time
    );
#endif

DWORD
DhcpGetRegistryValue(
    LPWSTR RegKey,
    LPWSTR ValueName,
    DWORD ValueType,
    PVOID *Data
    );

DWORD
DhcpSetDNSAddress(
    HKEY KeyHandle,
    LPWSTR ValueName,
    DWORD ValueType,
    DHCP_IP_ADDRESS UNALIGNED *Data,
    DWORD DataLength
    );

DWORD
SetDhcpOption(
    LPWSTR AdapterName,
    DHCP_OPTION_ID OptionId,
    LPBOOL DefaultGatewaysSet,
    BOOL LastKnownDefaultGateway
    );

DWORD
DhcpMakeNICList(
    VOID
    );

DWORD
DhcpAddNICtoList(
    LPWSTR AdapterName,
    LPWSTR DeviceName,
    PDHCP_CONTEXT *DhcpContext
    );

#if     defined(_PNP_POWER_)
DWORD
DhcpAddNICtoListEx(
    LPWSTR AdapterName,
    DWORD  ipInterfaceContext,
    PDHCP_CONTEXT *DhcpContext
    );

#endif _PNP_POWER_
BOOL
SetOverRideDefaultGateway(
    LPWSTR AdapterName
    );

BOOL
DhcpGetAddressOption(
    DHCP_IP_ADDRESS **ppDNSServerList,
    DWORD            *pNumberOfServers
    );


BOOL
DhcpRegReadUseMHAsyncDnsFlag(
    VOID
);

DWORD                                             // Win32 status
DhcpInitRegistry(                                 // Initialize registry based globals
    VOID
);

VOID
DhcpCleanupRegistry(                              // undo the effects of InitReg call
    VOID
);


DHCP_IP_ADDRESS                                   // the static ip address of the adapter
DhcpRegReadIpAddress(                             // get the first ip address
    LPWSTR    AdapterName,                        // the adaptor of interest
    LPWSTR    ValueName                           // the ip address value to read
);

DWORD                                             // status
DhcpRegReadIpAddresses(                           // read a set of ip addresses
    IN      DHCPKEY                RegKeyHandle,  // open key handle
    IN      LPWSTR                 ValueName,     // name of value to read frm
    IN      WCHAR                  Separation,    // a MULTI_SZ has L'\0', SZ has L' ' or L',' etc.
    OUT     PDHCP_IP_ADDRESS      *AddressArray,  // an array of addresses
    OUT     LPDWORD                AddressCount   // the output size of above array
);

VOID
DhcpRegInitializeClasses(                         // initialize the classes list
    IN OUT  PDHCP_CONTEXT          DhcpContext    // NULL or adpater context
);

DWORD                                             // status
DhcpGetRegistryValueWithKey(                      // see defn of GetRegistryValue
    IN      HKEY                   KeyHandle,     // keyhandle NOT location
    IN      LPTSTR                 ValueName,     // value to read from registry
    IN      DWORD                  ValueType,     // type of value
    OUT     LPVOID                 Data           // this will be filled in
);

DWORD                                             // status
DhcpRegExpandString(                              // replace '?' with AdapterName
    IN      LPWSTR                 InString,      // input string to expand
    IN      LPWSTR                 AdapterName,   // the adapter name
    OUT     LPWSTR                *OutString,     // the output ptr to store string
    IN OUT  LPWSTR                 Buffer         // the buffer to use if non NULL
);

DWORD                                             // status
DhcpRegReadFromLocation(                          // read from one location
    IN      LPWSTR                 OneLocation,   // value to read from
    IN      LPWSTR                 AdapterName,   // replace '?' with adapternames
    OUT     LPBYTE                *Value,         // output value
    OUT     DWORD                 *ValueType,     // data type of value
    OUT     DWORD                 *ValueSize      // the size in bytes
);

DWORD                                             // status
DhcpRegReadFromAnyLocation(                       // read from one of many locations
    IN      LPWSTR                 MzRegLocation, // multiple locations thru REG_MULTI_MZ
    IN      LPWSTR                 AdapterName,   // may have to replace '?' with AdapterName
    OUT     LPBYTE                *Value,         // data for the value read
    OUT     DWORD                 *ValueType,     // type of the data
    OUT     DWORD                 *ValueSize      // the size of data
);

DWORD                                             // win32 status
DhcpRegFillParams(                                // get the registry config for this adapter
    IN OUT  PDHCP_CONTEXT          DhcpContext,   // adapter context to fill in
    IN      BOOL                   ReadAllInfo    // read EVERYTHING or only some critical info?
);

VOID
DhcpRegReadClassId(                               // Read the class id stuff
    IN      PDHCP_CONTEXT          DhcpContext    // Input context to read for
);

//
// ioctl.c
//

DWORD
IPSetIPAddress(
    DWORD IpInterfaceContext,
    DHCP_IP_ADDRESS IpAddress,
    DHCP_IP_ADDRESS SubnetMask
    );

DWORD
IPAddIPAddress(
    LPWSTR AdapterName,
    DHCP_IP_ADDRESS Address,
    DHCP_IP_ADDRESS SubnetMask
    );

DWORD
IPResetIPAddress(
    DWORD           dwInterfaceContext,
    DHCP_IP_ADDRESS SubnetMask
    );


DWORD
SetIPAddressAndArp(
    PVOID         pvLocalInformation,
    DWORD         dwAddress,
    DWORD         dwSubnetMask
    );


DWORD
NetBTSetIPAddress(
    LPWSTR DeviceName,
    DHCP_IP_ADDRESS IpAddress,
    DHCP_IP_ADDRESS SubnetMask
    );

DWORD
NetBTResetIPAddress(
    LPWSTR DeviceName,
    DHCP_IP_ADDRESS SubnetMask
    );

DWORD
NetBTNotifyRegChanges(
    LPWSTR DeviceName
    );

DWORD
SetDefaultGateway(
    DWORD Command,
    DHCP_IP_ADDRESS GatewayAddress
    );

HANDLE
DhcpOpenGlobalEvent(
    void
    );

#if     defined(_PNP_POWER_) && !defined(VXD)
DWORD
IPGetIPEventRequest(
    HANDLE  handle,
    HANDLE  event,
    UINT    seqNo,
    PIP_GET_IP_EVENT_RESPONSE  responseBuffer,
    DWORD                responseBufferSize,
    PIO_STATUS_BLOCK     ioStatusBlock
    );

DWORD
IPCancelIPEventRequest(
    HANDLE  handle,
    PIO_STATUS_BLOCK     ioStatusBlock
    );

#endif _PNP_POWER_ && !VXD

//
// api.c
//

DWORD
DhcpApiInit(
    VOID
    );



VOID
DhcpApiCleanup(
    VOID
    );

DWORD
ProcessApiRequest(
    HANDLE PipeHandle,
    LPOVERLAPPED Overlap
    );

//
// util.c
//


PDHCP_CONTEXT
FindDhcpContextOnRenewalList(
    LPWSTR AdapterName,
    DWORD  InterfaceContext
    );

PDHCP_CONTEXT
FindDhcpContextOnNicList(
    LPWSTR AdapterName,
    DWORD  InterfaceContext
    );

BOOL
IsMultiHomeMachine(
    VOID
    );


//
// options.c
//


SERVICE_SPECIFIC_DHCP_OPTION *
FindDhcpOption(
    DHCP_OPTION_ID OptionID
    );


DWORD
ReadGlobalOptionList();

DWORD
LoseAllEnvSpecificOptions(
    PDHCP_CONTEXT   dhcpContext
);


//
// dhcp.c
//

DWORD
SetIpConfigurationForNIC(
    HKEY            KeyHandle,
    PDHCP_CONTEXT   DhcpContext,
    PDHCP_OPTIONS   DhcpOptions,
    DHCP_IP_ADDRESS ServerIpAddress,
    DWORD           dwLeaseTime,
    DWORD           dwT1Time,
    DWORD           dwT2Time,
    BOOL            ObtainedNewAddress
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5.1\autoproxy\gmacros.h ===
/*================================================================================
  File: gmacros.h
  Contains: Macros used in common by both the DHCP Server and the DHCP Client.
  	Most of them are inlines for sake of elegance and ease of usage.
  Author: RameshV
  Created: 04-Jun-97 00:01

================================================================================*/
//#include <align.h>

//  Some block macros; usage at end

#define _shorten(string)    ( strrchr(string, '\\')? strrchr(string, '\\') : (string) )

// print a message and the file and line # of whoever is printing this.
#define _TracePrintLine(Msg)  DhcpPrint((DEBUG_TRACE_CALLS, "%s:%d %s\n", _shorten(__FILE__), __LINE__, Msg))

#define BlockBegin(Name)    { BlockStart_ ## Name : _TracePrintLine( "Block -> " #Name );
#define BlockEnd(Name)      BlockEnd_ ## Name : _TracePrintLine( "Block <- " #Name ) ;}
#define BlockContinue(Name) do { _TracePrintLine( "Continue to " #Name); goto BlockStart_ ## Name; } while (0)
#define BlockBreak(Name)    do { _TracePrintLine( "Breaking out of " #Name); goto BlockEnd_ ## Name; } while (0)
#define RetFunc(F,Ret)      do {_TracePrintLine( "Quitting function " #F ); return Ret ; } while (0)

// The way to use the above set of simple block macros is as follows: (example usage)
#if     0
int
DummyFunction(VOID) {
    BlockBegin(DummyFunctionMain) {
        if(GlobalCount > 0 )
            BlockContinue(DummyFunctionMain);
        else GlobalCount ++;

        if(GlobalCount > GlobalCountMax)
            BlockBreak(DummyFunctionMain);
    } BlockEnd(DummyFunctionMain);

    RetFunc(DummyFunction, RetVal);
}
#endif

// now come some little more complicated functions..
// note that these can be freely mixed with the above set of simple functions.
#define BlockBeginEx(Name, String)    {BlockStart_ ## Name : _TracePrintLine( #String );
#define BlockEndEx(Name, String)      BlockEnd_## Name : _TracePrintLine( #String );}
#define BlockContinueEx(Name, String) do {_TracePrintLine( #String); goto BlockStart_ ## Name; } while (0)
#define BlockBreakEx(Name, String)    do {_TracePrintLine( #String); goto BlockEnd_ ## Name; } while(0)

#define RetFuncEx(Name,Ret,DebMsg)    do {_TracePrintLine( "QuittingFunction " #Name); DhcpPrint(DebMsg); return Ret;} while(0)

// usage example:

#if 0
int
DummyFunction(VOID) {
    BlockBeginEx(Main, "Entering Dummy Function" ) {
        if( GlobalCount > 0)
            BlockContinueEx(Main, GlobalCount > 0);
        else GlobalCount ++;

        if(GlobalCount > GlobalCountMax)
            BlockBreak(Main);
    } BlockEndEx(Main, "Done Dummy Function");

    RetFunc(DummyFunc, RetVal);
    // OR
    RetFuncEx(DummyFunc, RetVal, (DEBUG_ERRROS, "Function returning, gcount = %ld\n", GlobalCount));

}

#endif 0


#define NOTHING

// Now if a VOID function (procedure) returns, we can say RetFunc(VoidFunc, NOTHING) and things will work.


//================================================================================
//  Now some useful inlines.
//================================================================================

VOID _inline
FreeEx(LPVOID Ptr) {
    if(Ptr) DhcpFreeMemory(Ptr);
}

VOID _inline
FreeEx2(LPVOID Ptr1, LPVOID Ptr2) {
    FreeEx(Ptr1); FreeEx(Ptr2);
}

VOID _inline
FreeEx3(LPVOID Ptr1, LPVOID Ptr2, LPVOID Ptr3) {
    FreeEx(Ptr1); FreeEx(Ptr2); FreeEx(Ptr3);
}

VOID _inline
FreeEx4(LPVOID Ptr1, LPVOID Ptr2, LPVOID Ptr3, LPVOID Ptr4) {
    FreeEx2(Ptr1, Ptr2); FreeEx2(Ptr3, Ptr4);
}

//--------------------------------------------------------------------------------
//  All the alloc functions below, allocate in one shot a few pointers,
//  and initialize them.. aligning them correctly.
//--------------------------------------------------------------------------------
LPVOID _inline
AllocEx(LPVOID *Ptr1, DWORD Size1, LPVOID *Ptr2, DWORD Size2) {
    DWORD  Size = ROUND_UP_COUNT(Size1, ALIGN_WORST) + Size2;
    LPBYTE Ptr = DhcpAllocateMemory(Size);

    if(!Ptr) return NULL;
    (*Ptr1) = Ptr;
    (*Ptr2) = Ptr + ROUND_UP_COUNT(Size1, ALIGN_WORST);

    return Ptr;
}

LPVOID _inline
AllocEx2(LPVOID *Ptr1, DWORD Size1, LPVOID *Ptr2, DWORD Size2) {
    DWORD  Size = ROUND_UP_COUNT(Size1, ALIGN_WORST) + Size2;
    LPBYTE Ptr = DhcpAllocateMemory(Size);

    if(!Ptr) return NULL;
    (*Ptr1) = Ptr;
    (*Ptr2) = Ptr + ROUND_UP_COUNT(Size1, ALIGN_WORST);

    return Ptr;
}

LPVOID _inline
AllocEx3(LPVOID *Ptr1, DWORD Size1, LPVOID *Ptr2, DWORD Size2, LPVOID *Ptr3, DWORD Size3) {
    DWORD  Size = ROUND_UP_COUNT(Size1, ALIGN_WORST) + ROUND_UP_COUNT(Size2, ALIGN_WORST) + Size3;
    LPBYTE Ptr = DhcpAllocateMemory(Size);

    if(!Ptr) return NULL;
    (*Ptr1) = Ptr;
    (*Ptr2) = Ptr + ROUND_UP_COUNT(Size1, ALIGN_WORST);
    (*Ptr3) = Ptr + ROUND_UP_COUNT(Size1, ALIGN_WORST) + ROUND_UP_COUNT(Size2, ALIGN_WORST);
    return Ptr;
}

LPVOID _inline
AllocEx4(LPVOID *Ptr1, DWORD Size1, LPVOID *Ptr2, DWORD Size2,
         LPVOID *Ptr3, DWORD Size3, LPVOID *Ptr4, DWORD Size4) {
    DWORD  Size = ROUND_UP_COUNT(Size1, ALIGN_WORST) +
    	ROUND_UP_COUNT(Size2, ALIGN_WORST) + ROUND_UP_COUNT(Size3, ALIGN_WORST) + Size4;
    LPBYTE Ptr = DhcpAllocateMemory(Size);

    if(!Ptr) return NULL;
    (*Ptr1) = Ptr;
    (*Ptr2) = Ptr + ROUND_UP_COUNT(Size1, ALIGN_WORST);
    (*Ptr3) = Ptr + ROUND_UP_COUNT(Size1, ALIGN_WORST) + ROUND_UP_COUNT(Size2, ALIGN_WORST);
    (*Ptr4) = Ptr + ROUND_UP_COUNT(Size1, ALIGN_WORST) +
    	ROUND_UP_COUNT(Size2, ALIGN_WORST) + ROUND_UP_COUNT(Size3, ALIGN_WORST);
    return Ptr;
}

//--------------------------------------------------------------------------------
//  This function takes an input string and a static buffer and if the input
//  string is not nul terminated, copies it to the static buffer and then null
//  terminates it.  It also change the size to reflect the new size..
//--------------------------------------------------------------------------------
LPBYTE _inline
AsciiNulTerminate(LPBYTE Input, DWORD *Size, LPBYTE StaticBuf, DWORD BufSize) {
    if( 0 == *Size) return Input;   // nothing to copy
    if(!Input[(*Size)-1]) return Input; // Everything is fine.

    if(*Size >= BufSize) {
        // Nothing much can be done here.. this is an error.. insufficient buffer space.
        DhcpAssert(FALSE);

        *Size = BufSize - 1;
    }

    memcpy(StaticBuf, Input, (*Size));
    StaticBuf[*Size] = '\0';
    (*Size) ++;
    return StaticBuf;
}

#if DBG
#define INLINE
#else
#define INLINE _inline
#endif

#define BEGIN_EXPORT
#define END_EXPORT

#define AssertReturn(Condition, RetVal )    do { DhcpAssert(Condition); return RetVal ;} while(0)

//================================================================================
//  End of File.
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5.1\autoproxy\jsproxy.cpp ===
/********************************************************************************
/    This is the base file to the Microsoft JScript Proxy Configuration 
/    This file implements the code to provide the script site and the JSProxy psuedo
/    object for the script engine to call against.
/
/    Created        11/27/96    larrysu
/
/
/
/
/
/
/
/
/
*/
#include <wininetp.h>
#include "jsproxy.h"


/*******************************************************************************
*    JSProxy functions.
********************************************************************************/
CJSProxy::CJSProxy()
{
    m_refCount = 1;
    m_fDestroyable = FALSE;
    m_fInitialized = FALSE;
    m_pCallout = NULL;
}

CJSProxy::~CJSProxy()
{
    if(m_fInitialized)
        DeInit();
}

STDMETHODIMP CJSProxy::Init(AUTO_PROXY_HELPER_APIS* pAPHA)
{
    if(!DelayLoad(&g_moduleOleAut32))
        return FALSE;

    m_strings[0] = L"isPlainHostName";
    m_strings[1] = L"dnsDomainIs";
    m_strings[2] = L"localHostOrDomainIs";
    m_strings[3] = L"isResolvable";
    m_strings[4] = L"isInNet";
    m_strings[5] = L"dnsResolve";
    m_strings[6] = L"myIpAddress";
    m_strings[7] = L"dnsDomainLevels";
    m_strings[8] = L"shExpMatch";
    m_strings[9] = L"weekdayRange";
    m_strings[10] = L"dateRange";
    m_strings[11] = L"timeRange";
    m_strings[12] = L"alert";
    
    m_pCallout = pAPHA;
    m_fInitialized = TRUE;
    return S_OK;
}

STDMETHODIMP CJSProxy::DeInit()
{
    m_pCallout = NULL;
    m_fInitialized = FALSE;
    return S_OK;
}
//IDispatch functions for JSProxy.  I want these to be light and fast.
STDMETHODIMP CJSProxy::GetIDsOfNames(REFIID riid, OLECHAR** rgszNames,UINT cNames, LCID lcid, DISPID FAR* rgdispid)
{
    // Use addition of first 4 chars to make quick cheesy hash of which function wants to be called.
    // These are values are #defined in JSProxy.h
    HRESULT        hr = S_OK;
    long        strval = 0;
    unsigned long        nameindex = 0;
    OLECHAR*    currentName = NULL;

    UNREFERENCED_PARAMETER(riid);
    UNREFERENCED_PARAMETER(lcid);
    
    if (!*rgszNames)
        return E_POINTER;
    if (cNames < 1)
        return E_INVALIDARG;

    while (nameindex < cNames)
    {
        currentName = rgszNames[nameindex];
        if (currentName == NULL)
            break;
        
        strval = currentName[0]+currentName[1]+currentName[2]+currentName[3]+currentName[4];

        switch (strval)
        {

            case VAL_myIpAddress :
                    if (StrCmpW(m_strings[6],currentName) == 0)
                        rgdispid[nameindex] = DISPID_myIpAddress;
                    else
                    {
                        rgdispid[nameindex] = DISPID_UNKNOWN;
                        hr = DISP_E_UNKNOWNNAME;
                    }
                    break;

            case VAL_isInNet :
                    if (StrCmpW(m_strings[4],currentName) == 0)
                        rgdispid[nameindex] = DISPID_isInNet;
                    else 
                    {
                        rgdispid[nameindex] = DISPID_UNKNOWN;
                        hr = DISP_E_UNKNOWNNAME;
                    }
                    break;
            
            case VAL_dateRange :
                    if (StrCmpW(m_strings[10],currentName) == 0)
                        rgdispid[nameindex] = DISPID_dateRange;
                    else 
                    {
                        rgdispid[nameindex] = DISPID_UNKNOWN;
                        hr = DISP_E_UNKNOWNNAME;
                    }
                    break;
            
            case VAL_dnsDomainIs : // This is also VAL_dnsDomainLevels check for both strings.
                    if (StrCmpW(m_strings[7],currentName) == 0)
                        rgdispid[nameindex] = DISPID_dnsDomainLevels;
                    else 
                    {
                        if (StrCmpW(m_strings[1],currentName) == 0)
                            rgdispid[nameindex] = DISPID_dnsDomainIs;
                        else 
                        {
                            rgdispid[nameindex] = DISPID_UNKNOWN;
                            hr = DISP_E_UNKNOWNNAME;
                        }
                    }
                    break;
            
            case VAL_isPlainHostName :
                    if (StrCmpW(m_strings[0],currentName) == 0)
                        rgdispid[nameindex] = DISPID_isPlainHostName;
                    else 
                    {
                        rgdispid[nameindex] = DISPID_UNKNOWN;
                        hr = DISP_E_UNKNOWNNAME;
                    }
                    break;
            
            case VAL_dnsResolve :
                    if (StrCmpW(m_strings[5],currentName) == 0)
                        rgdispid[nameindex] = DISPID_dnsResolve;
                    else 
                    {
                        rgdispid[nameindex] = DISPID_UNKNOWN;
                        hr = DISP_E_UNKNOWNNAME;
                    }
                    break;
            
            case VAL_timeRange :
                    if (StrCmpW(m_strings[11],currentName) == 0)
                        rgdispid[nameindex] = DISPID_timeRange;
                    else 
                    {
                        rgdispid[nameindex] = DISPID_UNKNOWN;
                        hr = DISP_E_UNKNOWNNAME;
                    }
                    break;
            
            case VAL_isResolvable :
                    if (StrCmpW(m_strings[3],currentName) == 0)
                        rgdispid[nameindex] = DISPID_isResolvable;
                    else 
                    {
                        rgdispid[nameindex] = DISPID_UNKNOWN;
                        hr = DISP_E_UNKNOWNNAME;
                    }
                    break;
            
            case VAL_shExpMatch :
                    if (StrCmpW(m_strings[8],currentName) == 0)
                        rgdispid[nameindex] = DISPID_shExpMatch;
                    else 
                    {
                        rgdispid[nameindex] = DISPID_UNKNOWN;
                        hr = DISP_E_UNKNOWNNAME;
                    }
                    break;
            
            case VAL_localHostOrDomainIs :
                    if (StrCmpW(m_strings[2],currentName) == 0)
                        rgdispid[nameindex] = DISPID_localHostOrDomainIs;
                    else 
                    {
                        rgdispid[nameindex] = DISPID_UNKNOWN;
                        hr = DISP_E_UNKNOWNNAME;
                    }
                    break;
            
            case VAL_weekdayRange :
                    if (StrCmpW(m_strings[9],currentName) == 0)
                        rgdispid[nameindex] = DISPID_weekdayRange;
                    else 
                    {
                        rgdispid[nameindex] = DISPID_UNKNOWN;
                        hr = DISP_E_UNKNOWNNAME;
                    }
                    break;
            
            case VAL_alert :
                    if (StrCmpW(m_strings[12],currentName) == 0)
                        rgdispid[nameindex] = DISPID_alert;
                    else 
                    {
                        rgdispid[nameindex] = DISPID_UNKNOWN;
                        hr = DISP_E_UNKNOWNNAME;
                    }
                    break;
            
            default :
                    rgdispid[nameindex] = DISPID_UNKNOWN;
                    hr = DISP_E_UNKNOWNNAME;
                    break;

        }
        nameindex++;
    }
    return hr;
    
}

STDMETHODIMP CJSProxy::Invoke(
                DISPID dispidMember,
                REFIID riid,
                LCID lcid,
                WORD wFlags,
                DISPPARAMS* pdispparams,
                VARIANT* pvarResult,
                EXCEPINFO* pexcepinfo,
                UINT* puArgErr)
{
    HRESULT hr = S_OK;
    
    UNREFERENCED_PARAMETER(riid);
    UNREFERENCED_PARAMETER(lcid);
    UNREFERENCED_PARAMETER(pexcepinfo);
    UNREFERENCED_PARAMETER(puArgErr);
    
    if (dispidMember > 0x000d)
        return DISP_E_MEMBERNOTFOUND;

    if (!(wFlags & (DISPATCH_PROPERTYGET|DISPATCH_METHOD)))
    {
        return DISP_E_MEMBERNOTFOUND;
    }

    if(!m_fInitialized)
        return DISP_E_BADCALLEE;

    // The big switch based on DISPID!
    switch (dispidMember)
    {
/*****************************************************************************
    Calling isPlainHostName 
*****************************************************************************/
    case DISPID_isPlainHostName :
        {
            // look in the DISPARAMS to make sure the signiture is correct for this function.
            if (pdispparams->cArgs != 1)
                hr = DISP_E_BADPARAMCOUNT;
            if (pdispparams->cNamedArgs > 0)
                hr = DISP_E_NONAMEDARGS;

            if (FAILED(hr))
                break;
            
            VARIANT arg1;
            
            // check the type of the variant in the disparams and if it is a bstr use it
            if (pdispparams->rgvarg[0].vt == VT_BSTR)
                arg1 = pdispparams->rgvarg[0];
            // otherwise change it into one!  if this fails the return an error.
            else
            {
                hr = DL(VariantChangeType)(&arg1,&(pdispparams->rgvarg[0]),NULL,VT_BSTR);
                if (FAILED(hr))
                {
                    hr = DISP_E_TYPEMISMATCH;
                    break;
                }
            }
            // call isPlainHostName.
            hr = isPlainHostName(arg1.bstrVal,pvarResult);
            break;
        }
/*****************************************************************************
    Calling dnsDomainIs
*****************************************************************************/
    case DISPID_dnsDomainIs :
        {
            if (pdispparams->cArgs != 2)
            {
                hr = DISP_E_BADPARAMCOUNT;
                break;
            }
            if (pdispparams->cNamedArgs > 0)
            {
                hr = DISP_E_NONAMEDARGS;
                break;
            }

            VARIANT arg1;
            VARIANT arg2;
            
            // check the type of the variant in the disparams and if it is a bstr use it
            if (pdispparams->rgvarg[0].vt == VT_BSTR)
                arg2 = pdispparams->rgvarg[0];
            // otherwise change it into one!  if this fails the return an error.
            else
            {
                hr = DL(VariantChangeType)(&arg2,&(pdispparams->rgvarg[0]),NULL,VT_BSTR);
                if (FAILED(hr))
                {
                    hr = DISP_E_TYPEMISMATCH;
                    break;
                }
            }
            if (pdispparams->rgvarg[1].vt == VT_BSTR)
                arg1 = pdispparams->rgvarg[1];
            // otherwise change it into one!  if this fails the return an error.
            else
            {
                hr = DL(VariantChangeType)(&arg1,&(pdispparams->rgvarg[1]),NULL,VT_BSTR);
                if (FAILED(hr))
                {
                    hr = DISP_E_TYPEMISMATCH;
                    break;
                }
            }
            // call dnsDomainIs
            hr = dnsDomainIs(arg1.bstrVal,arg2.bstrVal,pvarResult);
            break;
        }
/*****************************************************************************
    Calling localHostOrDomainIs
*****************************************************************************/
    case DISPID_localHostOrDomainIs :
        {
            if (pdispparams->cArgs != 2)
            {
                hr = DISP_E_BADPARAMCOUNT;
                break;
            }
            if (pdispparams->cNamedArgs > 0)
            {
                hr = DISP_E_NONAMEDARGS;
                break;
            }
            
            VARIANT arg1;
            VARIANT arg2;
            
            // check the type of the variant in the disparams and if it is a bstr use it
            if (pdispparams->rgvarg[0].vt == VT_BSTR)
                arg2 = pdispparams->rgvarg[0];
            // otherwise change it into one!  if this fails the return an error.
            else
            {
                hr = DL(VariantChangeType)(&arg2,&(pdispparams->rgvarg[0]),NULL,VT_BSTR);
                if (FAILED(hr))
                {
                    hr = DISP_E_TYPEMISMATCH;
                    break;
                }
            }
            if (pdispparams->rgvarg[1].vt == VT_BSTR)
                arg1 = pdispparams->rgvarg[1];
            // otherwise change it into one!  if this fails the return an error.
            else
            {
                hr = DL(VariantChangeType)(&arg1,&(pdispparams->rgvarg[1]),NULL,VT_BSTR);
                if (FAILED(hr))
                {
                    hr = DISP_E_TYPEMISMATCH;
                    break;
                }
            }
            // call localHostOrDomainIs
            hr = localHostOrDomainIs(arg1.bstrVal,arg2.bstrVal,pvarResult);
            break;
        }
/*****************************************************************************
    Calling isResolvable
*****************************************************************************/
    case DISPID_isResolvable :
        {
            if (pdispparams->cArgs != 1)
            {
                hr = DISP_E_BADPARAMCOUNT;
                break;
            }
            if (pdispparams->cNamedArgs > 0)
            {
                hr = DISP_E_NONAMEDARGS;
                break;
            }
            
            VARIANT arg1;
            
            // check the type of the variant in the disparams and if it is a bstr use it
            if (pdispparams->rgvarg[0].vt == VT_BSTR)
                arg1 = pdispparams->rgvarg[0];
            // otherwise change it into one!  if this fails the return an error.
            else
            {
                hr = DL(VariantChangeType)(&arg1,&(pdispparams->rgvarg[0]),NULL,VT_BSTR);
                if (FAILED(hr))
                {
                    hr = DISP_E_TYPEMISMATCH;
                    break;
                }
            }
            // call isResolvable
            hr = isResolvable(arg1.bstrVal,pvarResult);
            break;
        }
/*****************************************************************************
    Calling isInNet
*****************************************************************************/
    case DISPID_isInNet :
        {
            int x;

            if (pdispparams->cArgs != 3)
            {
                hr = DISP_E_BADPARAMCOUNT;
                break;
            }
            if (pdispparams->cNamedArgs > 0)
            {
                hr = DISP_E_NONAMEDARGS;
                break;
            }
            
            VARIANT args[3];
            
            for (x=0;x<3;x++)
            {
                // check the type of the variant in the disparams and if it is a bstr use it
                if (pdispparams->rgvarg[x].vt == VT_BSTR)
                    args[x] = pdispparams->rgvarg[x];
                // otherwise change it into one!  if this fails the return an error.
                else
                {
                    hr = DL(VariantChangeType)(&args[x],&(pdispparams->rgvarg[x]),NULL,VT_BSTR);
                    if (FAILED(hr))
                    {
                        hr = DISP_E_TYPEMISMATCH;
                        break;
                    }
                }
            }
            if (FAILED(hr))
                break;
            // call isInNet.  Args need to be reversed
            hr = isInNet(args[2].bstrVal,args[1].bstrVal,args[0].bstrVal,pvarResult);
            break;
        }
/*****************************************************************************
    Calling dnsResolve
*****************************************************************************/
    case DISPID_dnsResolve :
        {
            if (pdispparams->cArgs != 1)
            {
                hr = DISP_E_BADPARAMCOUNT;
                break;
            }
            if (pdispparams->cNamedArgs > 0)
            {
                hr = DISP_E_NONAMEDARGS;
                break;
            }
            
            VARIANT arg1;
            
            // check the type of the variant in the disparams and if it is a bstr use it
            if (pdispparams->rgvarg[0].vt == VT_BSTR)
                arg1 = pdispparams->rgvarg[0];
            // otherwise change it into one!  if this fails the return an error.
            else
            {
                hr = DL(VariantChangeType)(&arg1,&(pdispparams->rgvarg[0]),NULL,VT_BSTR);
                if (FAILED(hr))
                {
                    hr = DISP_E_TYPEMISMATCH;
                    break;
                }
            }
            // call dnsResolve
            hr = dnsResolve(arg1.bstrVal,pvarResult);
            break;
        }
/*****************************************************************************
    Calling myIpAddress
*****************************************************************************/
    case DISPID_myIpAddress :
        // Should have no args and 1 named arg and the name should be DISPATCH_PROPERTYGET!
/*        if (pdispparams->cNamedArgs != 1)
        {
            hr = DISP_E_BADPARAMCOUNT;
            break;
        }
*/
        // call myIpAddress
        hr = myIpAddress(pvarResult);
        break;
/*****************************************************************************
    Calling dnsDomainLevels
*****************************************************************************/
    case DISPID_dnsDomainLevels :
        {
            if (pdispparams->cArgs != 1)
            {
                hr = DISP_E_BADPARAMCOUNT;
                break;
            }
            if (pdispparams->cNamedArgs > 0)
            {
                hr = DISP_E_NONAMEDARGS;
                break;
            }
            
            VARIANT arg1;
            
            // check the type of the variant in the disparams and if it is a bstr use it
            if (pdispparams->rgvarg[0].vt == VT_BSTR)
                arg1 = pdispparams->rgvarg[0];
            // otherwise change it into one!  if this fails the return an error.
            else
            {
                hr = DL(VariantChangeType)(&arg1,&(pdispparams->rgvarg[0]),NULL,VT_BSTR);
                if (FAILED(hr))
                {
                    hr = DISP_E_TYPEMISMATCH;
                    break;
                }
            }
            // call dnsDomainLevels
            hr = dnsDomainLevels(arg1.bstrVal,pvarResult);
            break;
        }
/*****************************************************************************
    Calling shExpMatch
*****************************************************************************/
    case DISPID_shExpMatch :
        {
            if (pdispparams->cArgs != 2)
            {
                hr = DISP_E_BADPARAMCOUNT;
                break;
            }
            if (pdispparams->cNamedArgs > 0)
            {
                hr = DISP_E_NONAMEDARGS;
                break;
            }
            
            VARIANT arg1;
            VARIANT arg2;
            
            // check the type of the variant in the disparams and if it is a bstr use it
            if (pdispparams->rgvarg[0].vt == VT_BSTR)
                arg2 = pdispparams->rgvarg[0];
            // otherwise change it into one!  if this fails the return an error.
            else
            {
                hr = DL(VariantChangeType)(&arg2,&(pdispparams->rgvarg[0]),NULL,VT_BSTR);
                if (FAILED(hr))
                {
                    hr = DISP_E_TYPEMISMATCH;
                    break;
                }
            }
            if (pdispparams->rgvarg[1].vt == VT_BSTR)
                arg1 = pdispparams->rgvarg[1];
            // otherwise change it into one!  if this fails the return an error.
            else
            {
                hr = DL(VariantChangeType)(&arg1,&(pdispparams->rgvarg[1]),NULL,VT_BSTR);
                if (FAILED(hr))
                {
                    hr = DISP_E_TYPEMISMATCH;
                    break;
                }
            }
            // call isPlainHostName.
            hr = shExpMatch(arg1.bstrVal,arg2.bstrVal,pvarResult);
            break;
        }
/*****************************************************************************
    Calling weekdayRange
*****************************************************************************/
    case DISPID_weekdayRange :
        {
            unsigned int x;

            if ((pdispparams->cArgs > 3) || (pdispparams->cArgs < 1))
            {
                hr = DISP_E_BADPARAMCOUNT;
                break;
            }
            if (pdispparams->cNamedArgs > 0)
            {
                hr = DISP_E_NONAMEDARGS;
                break;
            }
            
            VARIANT* args[3] = {NULL,NULL,NULL};
            
            for (x=0;x<pdispparams->cArgs;x++)
            {
                args[x] = new(VARIANT);
                if( !(args[x]) )
                {
                       hr = E_OUTOFMEMORY;
                       break;
                }

                // check the type of the variant in the disparams and if it is a bstr use it
                if (pdispparams->rgvarg[x].vt == VT_BSTR)
                    *args[x] = pdispparams->rgvarg[x];
                // otherwise change it into one!  if this fails the return an error.
                else
                {
                    hr = DL(VariantChangeType)(args[x],&(pdispparams->rgvarg[x]),NULL,VT_BSTR);
                    if (FAILED(hr))
                    {
                        hr = DISP_E_TYPEMISMATCH;
                        break;
                    }
                }
            }
            if (FAILED(hr))
                break;
            // call isInNet.  Args need to be reversed
            switch (pdispparams->cArgs)
            {
            case 1:
                hr = weekdayRange(args[0]->bstrVal,NULL,NULL,pvarResult);
                break;
            case 2:
                if ((args[0]->bstrVal[0] == 'G') || (args[0]->bstrVal[0] == 'g'))
                    hr = weekdayRange(args[1]->bstrVal,NULL,args[0]->bstrVal,pvarResult);
                else
                    hr = weekdayRange(args[1]->bstrVal,args[0]->bstrVal,NULL,pvarResult);
                break;
            case 3:
                hr = weekdayRange(args[2]->bstrVal,args[1]->bstrVal,args[0]->bstrVal,pvarResult);
                break;
            }
            break;
        }
/*****************************************************************************
    Calling dateRange
*****************************************************************************/
    case DISPID_dateRange :
        break;
/*****************************************************************************
    Calling timeRange
*****************************************************************************/
    case DISPID_timeRange :
        break;
/*****************************************************************************
    Calling alert 
*****************************************************************************/
    case DISPID_alert :
        {
            // look in the DISPARAMS to make sure the signiture is correct for this function.
            if (pdispparams->cArgs != 1)
                hr = DISP_E_BADPARAMCOUNT;
            if (pdispparams->cNamedArgs > 0)
                hr = DISP_E_NONAMEDARGS;

            if (FAILED(hr))
                break;
            
            VARIANT arg1;
            
            // check the type of the variant in the disparams and if it is a bstr use it
            if (pdispparams->rgvarg[0].vt == VT_BSTR)
                arg1 = pdispparams->rgvarg[0];
            // otherwise change it into one!  if this fails the return an error.
            else
            {
                hr = DL(VariantChangeType)(&arg1,&(pdispparams->rgvarg[0]),NULL,VT_BSTR);
                if (FAILED(hr))
                {
                    hr = DISP_E_TYPEMISMATCH;
                    break;
                }
            }
            // call alert.
            hr = alert(arg1.bstrVal,pvarResult);
            break;
        }
/*****************************************************************************
    Default returning error code
*****************************************************************************/
    default:
        hr = DISP_E_MEMBERNOTFOUND;
    }

    return hr;
}


//  JScript Auto-Proxy config functions.
STDMETHODIMP CJSProxy::isPlainHostName(BSTR host, VARIANT* retval)
{
    WCHAR    *currentch;
    BOOL    bfound = FALSE;

    if (!host || !retval)
        return E_POINTER;

    retval->vt = VT_BOOL;

    // check to detemine whether this is a plain host name!
    currentch = host;
    while ((*currentch != '\0') && !bfound)
    {
        if (*currentch == '.')
            bfound = TRUE;
        else
            currentch++;
    }

    if (bfound)
        retval->boolVal = VARIANT_FALSE;
    else
        retval->boolVal = VARIANT_TRUE;

    return S_OK;
}

STDMETHODIMP CJSProxy::dnsDomainIs(BSTR host,BSTR domain, VARIANT* retval)
{
    WCHAR *result = NULL;

    if (!host || !domain || !retval)
        return E_POINTER;
    
    result = StrStrW(host,domain);
    retval->vt = VT_BOOL;
    if (result)
        retval->boolVal = VARIANT_TRUE;
    else
        retval->boolVal = VARIANT_FALSE;

    return S_OK;
}

STDMETHODIMP CJSProxy::localHostOrDomainIs(BSTR host,BSTR hostdom, VARIANT* retval)
{
    HRESULT    hr = S_OK;

    if (!host || !hostdom || !retval)
        return E_POINTER;

    // check to see if it is a local host
    hr = isPlainHostName(host,retval);
    if (SUCCEEDED(hr))
    {
        if (retval->boolVal != VARIANT_TRUE)
        {
            //
            // this is a strange function, if its not a local hostname
            //  we do a strait compare against the passed in domain
            //  string.  If its not a direct match, then its FALSE,
            //  even if the root of the domain/hostname are the same.
            //  Blame Netscape for this, we are just following their
            //  behavior and docs.
            //

            if ( StrCmpIW(host, hostdom) == 0 )
            {
                retval->boolVal = VARIANT_TRUE;
            }
            else
            {
                retval->boolVal = VARIANT_FALSE;
            }

        }
    }

    return hr;
}

// Functions that need to call back on wininet.
STDMETHODIMP CJSProxy::isResolvable(BSTR host, VARIANT* retval)
{
    
    if (!host || !retval)
        return E_POINTER;
    // call into wininet provided functions!
    retval->vt = VT_BOOL;
    if (m_pCallout)
    {
        MAKE_ANSIPTR_FROMWIDE(szhost,host);
        if (m_pCallout->IsResolvable(szhost)) 
            retval->boolVal = VARIANT_TRUE;
        else
            retval->boolVal = VARIANT_FALSE;
    }
    else
        retval->boolVal = VARIANT_FALSE;

    return S_OK;
}

STDMETHODIMP CJSProxy::isInNet(BSTR host, BSTR pattern, BSTR mask, VARIANT* retval)
{
    VARIANT    myretval;
    HRESULT    hr = S_OK;

    //  Because isInNet() is only called from Invoke(), a non-debug
    //check on m_fInitialized has already been done.
    INET_ASSERT(m_fInitialized);  
    
    // call into wininet provided functions!
    if (!host || !pattern || !mask || !retval)
        return E_POINTER;
    // call into wininet provided functions!
    retval->vt = VT_BOOL;
    DL(VariantInit)(&myretval);

    if (m_pCallout)
    {
        hr = dnsResolve(host,&myretval);
        if (SUCCEEDED(hr))
        {
            if (myretval.vt != VT_BSTR)
            {    
                DL(VariantClear)(&myretval);
                retval->boolVal = VARIANT_FALSE;        
                return hr;
            }
        }
        else
        {
            DL(VariantClear)(&myretval);
            retval->boolVal = VARIANT_FALSE;
            return hr;    
        }

        // Fallthrough to code to check IP/pattern and mask!
    
        MAKE_ANSIPTR_FROMWIDE(szhost,myretval.bstrVal);
        MAKE_ANSIPTR_FROMWIDE(szpattern,pattern);
        MAKE_ANSIPTR_FROMWIDE(szmask,mask);

        //  Check to see if IP address from dnsResolve matches the pattern/mask!
        if ( m_pCallout->IsInNet(szhost, szpattern, szmask ) ) 
            retval->boolVal = VARIANT_TRUE;
        else
            retval->boolVal = VARIANT_FALSE;
    }
    else
        retval->boolVal = VARIANT_FALSE;
    
    DL(VariantClear)(&myretval);
    return S_OK;
}

STDMETHODIMP CJSProxy::dnsResolve(BSTR host, VARIANT* retval)
{
    char ipaddress[16];
    DWORD dwretval;
    DWORD dwipsize = 16;

    if (!host || !retval)
        return E_POINTER;
    // call into wininet provided functions!

    if (m_pCallout)
    {
        MAKE_ANSIPTR_FROMWIDE(szhost,host);
        dwretval = m_pCallout->ResolveHostName(szhost,ipaddress,&dwipsize); 
        if (dwretval == ERROR_SUCCESS)
        {
            retval->vt = VT_BSTR;
            retval->bstrVal = MakeWideStrFromAnsi((LPSTR)ipaddress,STR_BSTR);
        }
        else
        {
            retval->vt = VT_BOOL;
            retval->boolVal = VARIANT_FALSE;
        }
    }
    else
    {    
        retval->vt = VT_BOOL;
        retval->boolVal = VARIANT_FALSE;
    }

    return S_OK;
}

STDMETHODIMP CJSProxy::myIpAddress(VARIANT* retval)
{
    char ipaddress[16];
    DWORD dwretval;
    DWORD dwipsize = 16;

    if (!retval)
        return E_POINTER;
    // call into wininet provided functions!

    if (m_pCallout)
    {
        dwretval = m_pCallout->GetIPAddress(ipaddress,&dwipsize);
        if (dwretval == ERROR_SUCCESS)
        {
            retval->vt = VT_BSTR;
            retval->bstrVal = MakeWideStrFromAnsi((LPSTR)ipaddress,STR_BSTR);
        }
        else
        {
            retval->vt = VT_BOOL;
            retval->boolVal = VARIANT_FALSE;
        }
    }
    else
    {    
        retval->vt = VT_BOOL;
        retval->boolVal = VARIANT_FALSE;
    }

    return S_OK;
}

// Back to functions implemented here.
STDMETHODIMP CJSProxy::dnsDomainLevels(BSTR host, VARIANT* retval)
{
    WCHAR    *currentch;
    DWORD    dwlevels = 0;

    if (!host || !retval)
        return E_POINTER;

    retval->vt = VT_I4;

    // check to detemine whether this is a plain host name!
    currentch = host;
    while (*currentch != L'\0')
    {
        if (*currentch == L'.')
            dwlevels++;

        currentch++;
    }

    retval->lVal = dwlevels;

    return S_OK;
}

STDMETHODIMP CJSProxy::shExpMatch(BSTR str, BSTR shexp, VARIANT* retval)
{

    if (!str || !shexp || !retval)
        return E_POINTER;

    retval->vt = VT_BOOL;
    // convert BSTR to ansi - these macros allocate memory that is freed when they
    // go out of scope!  No need to free!
    MAKE_ANSIPTR_FROMWIDE(szstr, str);
    MAKE_ANSIPTR_FROMWIDE(szshexp, shexp);
    // Call into the regular expression matching code.
    if (match(szstr,szshexp))
        retval->boolVal = VARIANT_TRUE;
    else
        retval->boolVal = VARIANT_FALSE;

    return S_OK;
}

// These are to do last!!!.
STDMETHODIMP CJSProxy::weekdayRange(BSTR wd1, BSTR wd2, BSTR gmt, VARIANT* retval)
{
    SYSTEMTIME    systime;
    char        szday[4];
    int            today = -1;
    int            day1 = -1; // days are as follows SUN = 0; MON = 1; ...;SAT = 6.
    int            day2 = -1;  
    BOOL        bIsInRange = FALSE;

    if (!wd1)
        return E_POINTER;
    if (gmt)
        GetSystemTime(&systime);

    GetDateFormat(//LOCALE_SYSTEM_DEFAULT,
                    MAKELCID(MAKELANGID(LANG_ENGLISH,SUBLANG_ENGLISH_US),SORT_DEFAULT),
                    NULL,
                    gmt? &systime:NULL,
                    "ddd",
                    szday,
                    4);

    if (szday)
    {
        int lcv;
        //convert all chars to upper if lowercase (don't use runtimes)
        for (lcv=0;lcv<3;lcv++)
        {
            if ((short)szday[lcv] > 90)
                szday[lcv]-=32;
        }

        today = ConvertAnsiDayToInt(szday);
    }
    
    if (today == -1)
        return E_FAIL;
    
    // compare day ranges!
    if (wd2)
    {
        // These are by definition in ALL CAPS
        MAKE_ANSIPTR_FROMWIDE(szwd1, wd1);
        MAKE_ANSIPTR_FROMWIDE(szwd2, wd2);
        if (szwd1 && szwd2)
        {
            day1 = ConvertAnsiDayToInt(szwd1);
            day2 = ConvertAnsiDayToInt(szwd2);
        }

        if ((day1 == -1) || (day2 == -1))
            return E_INVALIDARG;

        if (day1 < day2)
        {
            if ((today >= day1) && (today <= day2))
                bIsInRange = TRUE;
            else
                bIsInRange = FALSE;
        }
        else if ( day1 == day2 )
        {
            if (today == day1)
            {
                bIsInRange = TRUE;
            }
            else
            {
                bIsInRange = FALSE;
            }
        }
        else
        {
            if ((today >= day1) || (today <= day2))
                bIsInRange = TRUE;
            else
                bIsInRange = FALSE;
        }

    }
    else // only one day to check!
    {
        MAKE_ANSIPTR_FROMWIDE(szwd1, wd1);
        if (lstrcmp(szday,szwd1) == 0)
            bIsInRange = TRUE;
        else
            bIsInRange = FALSE;
    }

    if (bIsInRange)
    {
        retval->vt = VT_BOOL;
        retval->boolVal = VARIANT_TRUE;
    }
    else
    {
        retval->vt = VT_BOOL;
        retval->boolVal = VARIANT_FALSE;
    }

    return S_OK;
}

STDMETHODIMP CJSProxy::dateRange(long day, BSTR month, BSTR gmt, VARIANT* retval)
{
    UNREFERENCED_PARAMETER(day);
    UNREFERENCED_PARAMETER(month);
    UNREFERENCED_PARAMETER(gmt);
    UNREFERENCED_PARAMETER(retval);
    return S_OK;
}
STDMETHODIMP CJSProxy::timeRange(long hour, long min, long sec, BSTR gmt, VARIANT* retval)
{
    UNREFERENCED_PARAMETER(hour);
    UNREFERENCED_PARAMETER(min);
    UNREFERENCED_PARAMETER(sec);
    UNREFERENCED_PARAMETER(gmt);
    UNREFERENCED_PARAMETER(retval);
    return S_OK;
}

STDMETHODIMP CJSProxy::alert(BSTR message, VARIANT* retval)
{
    if (!message)
        return E_POINTER;

    // Return true if available...not needed?
    if (retval)
    {
        retval->vt = VT_BOOL;
        retval->vt = VARIANT_FALSE;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5.1\autoproxy\dllmain.cpp ===
/********************************************************************************
/    This is the base file to the Microsoft JScript Proxy Configuration 
/    This file implements the code to provide the script site and the JSProxy psuedo
/    object for the script engine to call against.
/
/    Created        11/27/96    larrysu
/
/
/
/
/
/
/
/
/
*/

#include "dllmain.h"

CScriptSite    *g_ScriptSite = NULL;
BOOL fOleInited = FALSE;

/*******************************************************************************
*    dll initialization and destruction

********************************************************************************/
EXTERN_C
BOOL APIENTRY DllMain(HMODULE hModule,DWORD ul_reason_for_call,LPVOID lpReserved)
{
    
    switch( ul_reason_for_call ) {
    case DLL_PROCESS_ATTACH:
        DisableThreadLibraryCalls(hModule);
        break;
    case DLL_PROCESS_DETACH:        
        break;
    }
    return TRUE;
}


STDAPI_(BOOL) AUTOCONF_InternetInitializeAutoProxyDll(DWORD dwVersion, 
                                                      LPSTR lpszDownloadedTempFile,
                                                      LPSTR lpszMime,
                                                      AUTO_PROXY_HELPER_APIS *pAutoProxyCallbacks, 
                                                      LPAUTO_PROXY_EXTERN_STRUC lpExtraData)
{
    HRESULT    hr = E_FAIL;
    HANDLE    hFile = 0;
    LPSTR    szScript = NULL;
    DWORD    dwFileSize = 0;
    DWORD    dwBytesRead = 0;
    LPSTR    result;
    LPSTR   szAllocatedScript = NULL;


    if ( !fOleInited ) 
    {
#ifndef unix
        CoInitializeEx(NULL, COINIT_MULTITHREADED);
#else
        CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
#endif /* unix */
    }


    // get the script text from the downloaded file!
    // open the file

    if ( lpExtraData == NULL ||
         lpExtraData->dwStructSize != sizeof(AUTO_PROXY_EXTERN_STRUC) ||
         lpExtraData->lpszScriptBuffer == NULL )
    {
        if (!lpszDownloadedTempFile)
            return FALSE;

        hFile = CreateFile((LPCSTR)lpszDownloadedTempFile,GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);
        if (hFile == INVALID_HANDLE_VALUE)
            return FALSE;

        // Get the size
        dwFileSize = GetFileSize(hFile,NULL);
        // allocate the buffer to hold the data.
        szScript = (LPSTR) GlobalAlloc(GMEM_FIXED|GMEM_ZEROINIT,dwFileSize+1);
        szAllocatedScript = szScript;

        BOOL f = TRUE;
        // if the memory was allocated
        if (szScript)
        {
            // read the data
            f = ReadFile(hFile,(LPVOID) szScript,dwFileSize,&dwBytesRead,NULL);
        }
        CloseHandle(hFile);

        if (!f)
            goto Cleanup;
    }
    else
    {
        szScript = (LPSTR) lpExtraData->lpszScriptBuffer;
    }

    // Create a new CScriptSite object and initiate it with the autoconfig script.
    g_ScriptSite = new CScriptSite;
    if (g_ScriptSite)
        hr = g_ScriptSite->Init(pAutoProxyCallbacks, szScript);
    else
        hr = E_OUTOFMEMORY;

Cleanup:

    if ( szAllocatedScript ) 
    {
        // Free the script text
        GlobalFree(szAllocatedScript);
        szAllocatedScript = NULL;
    }

    if (SUCCEEDED(hr))
        return TRUE;
    else
        return FALSE;
}

// This function frees the script engine and destroys the script site.
EXTERN_C BOOL CALLBACK AUTOCONF_InternetDeInitializeAutoProxyDll(LPSTR lpszMime, DWORD dwReserved)
{

    // Release and destroy the CScriptSite object and initiate it with the autoconfig script.
    // DeInit the script site.
    if (g_ScriptSite)
    {
        g_ScriptSite->DeInit();
        g_ScriptSite->Release();
        g_ScriptSite = NULL;
    }

    if ( fOleInited ) 
    {
        CoUninitialize();    
    }

    return TRUE;
}

// This function is called when the host wants to run the script.
EXTERN_C BOOL CALLBACK InternetGetProxyInfo(LPCSTR lpszUrl,
                                            DWORD dwUrlLength,
                                            LPSTR lpszUrlHostName,
                                            DWORD dwUrlHostNameLength,
                                            LPSTR *lplpszProxyHostName,
                                            LPDWORD lpdwProxyHostNameLength)
{
    HRESULT    hr = S_OK;
    LPSTR    szHost;
    
    // The host passed in may be too big.  Copy it an make the 
    // HostLength + 1 position will be slammed with \0.
    szHost = (LPSTR) GlobalAlloc(GMEM_FIXED|GMEM_ZEROINIT,dwUrlHostNameLength+1);
    if (!szHost)
        return FALSE;
    if(lpszUrlHostName && !lstrcpyn(szHost,lpszUrlHostName,dwUrlHostNameLength+1))
    {
        GlobalFree(szHost);
        return FALSE;
    }

    // construct a jscript call with the passed in url and host.
    if (g_ScriptSite)
//        hr = g_ScriptSite->RunScript(lpszUrl,lpszUrlHostName,lplpszProxyHostName);
        hr = g_ScriptSite->RunScript(lpszUrl,szHost,lplpszProxyHostName);

    GlobalFree(szHost);

    if (SUCCEEDED(hr))
    {
        *lpdwProxyHostNameLength = lstrlen(*lplpszProxyHostName) +1;
        return TRUE;
    }
    else
        return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5.1\autoproxy\ipconfig.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    ipconfig.cxx

Abstract:

    CIpConfig class implementation

    Contents:
        CIpAddress::GetAddress

        CIpAddressList::Find
        CIpAddressList::Add(CIpAddress *)
        CIpAddressList::Add(DWORD, DWORD, DWORD)
        CIpAddressList::GetAddress
        CIpAddressList::ThrowOutUnfoundEntries

        CAdapterInterface::CAdapterInterface
        CAdapterInterface::~CAdapterInterface

        CIpConfig::CIpConfig
        CIpConfig::~CIpConfig
        CIpConfig::GetRouterAddress
        CIpConfig::GetDnsAddress
        CIpConfig::IsKnownIpAddress
        CIpConfig::Refresh
        (CIpConfig::GetAdapterList)
        (CIpConfig::LoadEntryPoints)
        (CIpConfig::UnloadEntryPoints)
        (CIpConfig::FindOrCreateInterface)
        (CIpConfig::FindInterface)
        (CIpConfig::ThrowOutUnfoundEntries)

        WsControl
        (WinNtWsControl)
        (OpenTcpipDriverHandle)
        (CloseTcpipDriverHandle)
        (GetEntityList)
        [InternetMapEntity]
        [InternetMapInterface]

Author:

    Richard L Firth (rfirth) 29-Oct-1996

Environment:

    Win32 user-mode DLL

Notes:

    In order to operate correctly, we require the Microsoft Winsock implementation
    (WSOCK32.DLL) and the Microsoft TCP/IP stack to be loaded

Revision History:

    29-Oct-1996 rfirth
        Created

    15-Jul-1998 arthurbi
        Resurrected from the dead

--*/

#include <wininetp.h>
#include "aproxp.h"
#include <dhcpcsdk.h>

//
// manifests
//

#define MAX_ADAPTER_DESCRIPTION_LENGTH  128 // arbitrary
//#define DEFAULT_MINIMUM_ENTITIES        MAX_TDI_ENTITIES

//
// macros
//

//
// IS_INTERESTING_ADAPTER - TRUE if the type of this adapter (IFEntry) is NOT
// loopback. Loopback (corresponding to local host) is the only one we filter
// out right now
//

#define IS_INTERESTING_ADAPTER(p)   (!((p)->if_type == IF_TYPE_LOOPBACK))
#define IS_INTERESTING_ADAPTER_NT5(p) (!((p)->Type == IF_TYPE_RFC877_X25))

//
// globals
//

const char SERVICES_KEY_NAME[] = "SYSTEM\\CurrentControlSet\\Services";

HKEY TcpipLinkageKey = NULL;//     = INVALID_HANDLE_VALUE;
HKEY ServicesKey = NULL;  //       = INVALID_HANDLE_VALUE;

BOOL CIpConfig::m_Loaded;


//
// private prototypes
//

PRIVATE
DWORD
WinNtWsControl(
    DWORD dwProtocol,
    DWORD dwRequest,
    LPVOID lpInputBuffer,
    LPDWORD lpdwInputBufferLength,
    LPVOID lpOutputBuffer,
    LPDWORD lpdwOutputBufferLength
    );

PRIVATE
DWORD
OpenTcpipDriverHandle(
    VOID
    );

PRIVATE
VOID
CloseTcpipDriverHandle(
    VOID
    );

PRIVATE
DWORD
GetEntityList(
    OUT TDIEntityID * * lplpEntities
    );

//
// private debug prototypes
//

PRIVATE
LPCSTR
InternetMapEntity(
    IN INT EntityId
    );

PRIVATE
LPCSTR
InternetMapInterface(
    IN DWORD InterfaceType
    );

PRIVATE
LPCSTR
InternetMapInterfaceOnNT5(
    IN DWORD InterfaceType
    );


//
// private data
//

//
// NTDLL info - if the platform is NT then we use the following entry points in
// NTDLL.DLL to talk to the TCP/IP device driver
//

PRIVATE VOID (* _I_RtlInitUnicodeString)(PUNICODE_STRING, PCWSTR) = NULL;
PRIVATE NTSTATUS (* _I_NtCreateFile)(PHANDLE,
                                     ACCESS_MASK,
                                     POBJECT_ATTRIBUTES,
                                     PIO_STATUS_BLOCK,
                                     PLARGE_INTEGER,
                                     ULONG,
                                     ULONG,
                                     ULONG,
                                     ULONG,
                                     PVOID,
                                     ULONG
                                     ) = NULL;
PRIVATE ULONG (* _I_RtlNtStatusToDosError)(NTSTATUS) = NULL;

PRIVATE DLL_ENTRY_POINT NtDllEntryPoints[] = {
    DLL_ENTRY_POINT_ELEMENT(RtlInitUnicodeString),
    DLL_ENTRY_POINT_ELEMENT(NtCreateFile),
    DLL_ENTRY_POINT_ELEMENT(RtlNtStatusToDosError)
};

PRIVATE DLL_INFO NtDllInfo = DLL_INFO_INIT("NTDLL.DLL", NtDllEntryPoints);

PRIVATE HANDLE TcpipDriverHandle = INVALID_HANDLE_VALUE;

//
// Iphlpapi - Ip Helper APIs only found on NT 5 and Win 98, must dynaload,
//   Used to gather information on what adapters are avaible on the machine
//

PRIVATE DWORD (PASCAL FAR * _I_GetAdaptersInfo)(PIP_ADAPTER_INFO,
                                          PULONG
                                          ) = NULL;

PRIVATE DLL_ENTRY_POINT IpHlpApiEntryPoints[] = {
    DLL_ENTRY_POINT_ELEMENT(GetAdaptersInfo)
};

PRIVATE DLL_INFO IpHlpApiDllInfo = DLL_INFO_INIT("IPHLPAPI.DLL", IpHlpApiEntryPoints);

//
// DhcpcSvc - DHCP dll, Only found on Win'98 and NT 5.  This function does almost all the
//   work for us using the native DHCP services found on these cool new OSes.
//

PRIVATE DWORD (__stdcall * _I_DhcpRequestParams)(DWORD,
                                LPVOID,
                                LPWSTR,
                                LPDHCPCAPI_CLASSID,
                                DHCPCAPI_PARAMS_ARRAY,
                                DHCPCAPI_PARAMS_ARRAY,
                                LPBYTE,
                                LPDWORD,
                                LPWSTR
                          ) = NULL;

PRIVATE DLL_ENTRY_POINT DhcpcSvcEntryPoints[] = {
    DLL_ENTRY_POINT_ELEMENT(DhcpRequestParams)
};

PRIVATE DLL_INFO DhcpcSvcDllInfo = DLL_INFO_INIT("DHCPCSVC.DLL", DhcpcSvcEntryPoints);


//
// global data
//

// none.

//
// methods
//

//
// public CIpAddress methods
//


BOOL
CIpAddress::GetAddress(
    OUT LPBYTE lpbAddress,
    IN OUT LPDWORD lpdwAddressLength
    )

/*++

Routine Description:

    Returns the IP address from this CIpAddress

Arguments:

    lpbAddress          - pointer to returned address

    lpdwAddressLength   - size of IP address

Return Value:

    BOOL
        TRUE    - address copied

        FALSE   - address not copied (buffer not large enough)

--*/

{
    if (*lpdwAddressLength >= sizeof(DWORD)) {
        *(LPDWORD)lpbAddress = m_dwIpAddress;
        *lpdwAddressLength = sizeof(DWORD);
        return TRUE;
    }
    return FALSE;
}


//
// public CIpAddressList methods
//

BOOL
CIpAddressList::IsContextInList(
    IN DWORD dwContext
    )
{
   for (CIpAddress * pEntry = m_List; pEntry != NULL; pEntry = pEntry->m_Next) {
       if (pEntry->Context() == dwContext) {
           return TRUE;
       }
   }
   return FALSE;
}




CIpAddress *
CIpAddressList::Find(
    IN DWORD dwIpAddress,
    IN DWORD dwIpMask
    )

/*++

Routine Description:

    Finds the CIpAddress object corresponding to (dwIpAddress, dwIpMask)

Arguments:

    dwIpAddress - IP address to find

    dwIpMask    - IP address mask, or INADDR_ANY (0) if we don't care

Return Value:

    CIpAddress *
        Success - pointer to found object

        Failure - NULL

--*/

{
    for (CIpAddress * pEntry = m_List; pEntry != NULL; pEntry = pEntry->m_Next) {
        if ((pEntry->IpAddress() == dwIpAddress)
        && ((dwIpMask == INADDR_ANY) || (pEntry->IpMask() == dwIpMask))) {
            break;
        }
    }
    return pEntry;
}


VOID
CIpAddressList::Add(
    IN CIpAddress * pAddress
    )

/*++

Routine Description:

    Adds an IP address entry to the list

Arguments:

    pAddress    - pointer to CIpAddress to add

Return Value:

    None.

--*/

{
    INET_ASSERT(pAddress->m_Next == NULL);

    CIpAddress * pEntry = (CIpAddress *)&m_List;

    while (pEntry->m_Next != NULL) {
        pEntry = pEntry->m_Next;
    }
    pEntry->m_Next = pAddress;
}


BOOL
CIpAddressList::Add(
    IN DWORD dwIpAddress,
    IN DWORD dwIpMask,
    IN DWORD dwContext
    )

/*++

Routine Description:

    Adds an IP address entry to the list

Arguments:

    dwIpAddress - IP address to add

    dwIpMask    - IP subnet mask

    dwContext   - unique interface context value

Return Value:

    BOOL
        TRUE    - item added

        FALSE   - out of memory

--*/

{
    CIpAddress * pIpAddress = new CIpAddress(dwIpAddress, dwIpMask, dwContext);

    if (pIpAddress != NULL) {
        Add(pIpAddress);
        return TRUE;
    }
    return FALSE;
}


BOOL
CIpAddressList::GetAddress(
    IN OUT LPDWORD lpdwIndex,
    OUT LPBYTE lpbAddress,
    IN OUT LPDWORD lpdwAddressLength
    )

/*++

Routine Description:

    Returns the *lpdwIndex'th address from the list

Arguments:

    lpdwIndex           - which address to return. Updated on output

    lpbAddress          - pointer to returned address

    lpdwAddressLength   - pointer to returned address length

Return Value:

    BOOL
        TRUE    - address returned

        FALSE   - address not returned

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Bool,
                 "CIpAddressList::GetAddress",
                 "%#x [%d], %#x, %#x [%d]",
                 lpdwIndex,
                 *lpdwIndex,
                 lpbAddress,
                 lpdwAddressLength,
                 *lpdwAddressLength
                 ));

    CIpAddress * p = m_List;

    for (DWORD i = 0; (i < *lpdwIndex) && (p != NULL); ++i) {
        p = p->m_Next;
    }

    BOOL found;

    if (p != NULL) {
        found = p->GetAddress(lpbAddress, lpdwAddressLength);
        if (found) {
            ++*lpdwIndex;
        }
    } else {
        found = FALSE;
    }

    DEBUG_LEAVE(found);

    return found;
}


PRIVATE
BOOL
CIpAddressList::ThrowOutUnfoundEntries(
    VOID
    )

/*++

Routine Description:

    Throws out (deletes) any addresses that are marked not-found

Arguments:

    None.

Return Value:

    BOOL
        TRUE    - interfaces thrown out

        FALSE   -      "     not "   "

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Bool,
                 "CIpAddressList::ThrowOutUnfoundEntries",
                 NULL
                 ));

    CIpAddress * pLast = (CIpAddress *)&m_List;
    CIpAddress * pEntry;
    BOOL bThrownOut = FALSE;

    for (pEntry = m_List; pEntry != NULL; pEntry = pEntry->m_Next) {
        if (!pEntry->IsFound()) {
            pLast->m_Next = pEntry->m_Next;
            delete pEntry;
            bThrownOut = TRUE;
            pEntry = pLast;
        } else {
            pLast = pEntry;
        }
    }

    DEBUG_LEAVE(bThrownOut);

    return bThrownOut;
}

//
// public CAdapterInterface methods
//


CAdapterInterface::CAdapterInterface(
    IN DWORD dwIndex,
    IN DWORD dwType,
    IN DWORD dwSpeed,
    IN LPSTR lpszDescription,
    IN DWORD dwDescriptionLength,
    IN LPBYTE lpPhysicalAddress,
    IN DWORD dwPhysicalAddressLength
    )

/*++

Routine Description:

    CAdapterInterface constructor

Arguments:

    dwIndex             - unique adapter interface index

    dwType              - type of interface

    dwSpeed             - speed of interface

    lpszDescription     - pointer to descriptive name of adapter

    dwDescriptionLength - length of lpszDescription

    lpPhysicalAddress   -
    dwPhysicalAddressLength -


Return Value:

    None.

--*/

{
    if ((lpszDescription != NULL) && (dwDescriptionLength != 0)) {
        m_lpszDescription = new char[dwDescriptionLength + 1];
        if (m_lpszDescription != NULL) {
            memcpy(m_lpszDescription, lpszDescription, dwDescriptionLength);
        } else {
            dwDescriptionLength = 0;
        }
    }

    if ((lpPhysicalAddress != NULL) && (dwPhysicalAddressLength != 0)) {
        m_lpPhysicalAddress = new BYTE[dwPhysicalAddressLength];
        if ( m_lpPhysicalAddress != NULL ) {
            memcpy(m_lpPhysicalAddress, lpPhysicalAddress, dwPhysicalAddressLength);
        }
        else {
            dwPhysicalAddressLength = 0;
        }
    }

    switch( dwType )
    {
        case IF_TYPE_ETHERNET:
            m_dwPhysicalAddressType  = HARDWARE_TYPE_10MB_EITHERNET;
            break;

        case IF_TYPE_TOKENRING:
        case IF_TYPE_FDDI:
            m_dwPhysicalAddressType = HARDWARE_TYPE_IEEE_802;
            break;

        case IF_TYPE_OTHER:
            m_dwPhysicalAddressType = HARDWARE_ARCNET;
            break;

        case IF_TYPE_PPP:
            m_dwPhysicalAddressType = HARDWARE_PPP;
            break;

        case IF_TYPE_IEEE1394:
            m_dwPhysicalAddressType = HARDWARE_IEEE1394;
            break;

        default:
            m_dwPhysicalAddressType = HARDWARE_ARCNET;
            break;
    }

    m_dwPhysicalAddressLength = dwPhysicalAddressLength;
    m_dwDescriptionLength = dwDescriptionLength;
    m_lpszAdapterName = NULL;
    m_dwIndex = dwIndex;
    m_dwType = dwType;
    m_dwSpeed = dwSpeed;
    m_Flags.Word = 0;
    SetFound(TRUE);
}


CAdapterInterface::~CAdapterInterface(
    VOID
    )

/*++

Routine Description:

    CAdapterInterface destructor

Arguments:

    None.

Return Value:

    None.

--*/

{
    if (m_lpszDescription != NULL) {
        delete m_lpszDescription;
    }

    if (m_lpPhysicalAddress != NULL) {
        delete m_lpPhysicalAddress;
    }

    if ( m_lpszAdapterName != NULL) {
        FREE_MEMORY(m_lpszAdapterName);
    }
}


BOOL
CAdapterInterface::DhcpDoInformNT5(
    OUT LPSTR * ppszAutoProxyUrl
    )

/*++

Routine Description:

     For a given Interface, this nifly little method uses the new wizbang NT 5/Win'98 specific API
       to do the DHCP Inform request and determine an auto-proxy Url that we can use.

     Kinda of nice when we're on NT 5, otherwise we need to pull in the kitchen sink equivlent of
       DHCP code that has been ripped off from the NT 4/Win'95 code base

Arguments:

    lpszAutoProxyUrl  - a piece of memory where we can stuff our new auto-proxy URL

    dwAutoProxyUrlLength - size of the space to store the string above

Return Value:

    BOOL
        TRUE    - successfully talked to server and got Url

        FALSE   - failed to allocate memory or failure talking to TCP/IP or failure to get an Url needed to continue

--*/

{
    DWORD   error;
    WCHAR   wszAdapterName[(MAX_ADAPTER_NAME_LENGTH + 6)];
    int     len;
    LPSTR   lpszAutoProxyUrl = NULL;

    len = MultiByteToWideChar(
        CP_ACP,
        0, // flags
        GetAdapterName(),
        -1, // assume null-terminated
        wszAdapterName,
        (MAX_ADAPTER_NAME_LENGTH + 6)
        );

    if ( len == 0 ) {
        return FALSE;  // failed to convert string
    }

    if (_I_DhcpRequestParams == NULL)
    {
        return FALSE;
    }

    DHCPCAPI_PARAMS_ARRAY   SendParams;
    DHCPCAPI_PARAMS_ARRAY   RecvParams;
    DHCPAPI_PARAMS          WpadParam;
    BYTE *                  pBuffer = NULL;
    BYTE                    Buffer[400];
    DWORD                   dwBufferSize = sizeof(Buffer);

    ZeroMemory(&WpadParam, sizeof(WpadParam));
    WpadParam.OptionId = OPTION_WPAD_URL;
    WpadParam.IsVendor = FALSE;

    SendParams.nParams = 0;
    SendParams.Params  = NULL;

    RecvParams.nParams = 1;
    RecvParams.Params  = &WpadParam;

    error = _I_DhcpRequestParams(
                DHCPCAPI_REQUEST_SYNCHRONOUS,
                NULL,
                wszAdapterName,
                NULL,
                SendParams,
                RecvParams,
                Buffer,
                &dwBufferSize,
                NULL
                );

    if (error == ERROR_MORE_DATA)
    {
        dwBufferSize += 400;

        pBuffer = new BYTE[dwBufferSize];

        if (pBuffer != NULL)
        {
            ZeroMemory(&WpadParam, sizeof(WpadParam));

            WpadParam.OptionId = OPTION_WPAD_URL;
            WpadParam.IsVendor = FALSE;

            SendParams.nParams = 0;
            SendParams.Params  = NULL;

            RecvParams.nParams = 1;
            RecvParams.Params  = &WpadParam;

            error = _I_DhcpRequestParams(
                        DHCPCAPI_REQUEST_SYNCHRONOUS,
                        NULL,
                        wszAdapterName,
                        NULL,
                        SendParams,
                        RecvParams,
                        pBuffer,
                        &dwBufferSize,
                        NULL
                        );
        }
        else
        {
            error = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    if (error == ERROR_SUCCESS && WpadParam.Data != NULL && WpadParam.nBytesData != 0)
    {
        lpszAutoProxyUrl = NewString((LPCSTR)WpadParam.Data, WpadParam.nBytesData);

        if (lpszAutoProxyUrl)
        {
            *ppszAutoProxyUrl = lpszAutoProxyUrl;
        }

    }

    if (pBuffer)
        delete [] pBuffer;

    return (lpszAutoProxyUrl != NULL);
}



BOOL
CAdapterInterface::CopyAdapterInfoToDhcpContext(
    PDHCP_CONTEXT pDhcpContext
    )
{
    memset ((void *) pDhcpContext, 0, sizeof(DHCP_CONTEXT));

    // hardware address, length, and type
    pDhcpContext->HardwareAddressType = m_dwPhysicalAddressType;
    pDhcpContext->HardwareAddress = m_lpPhysicalAddress;
    pDhcpContext->HardwareAddressLength = m_dwPhysicalAddressLength;

    if (m_IpList.m_List) {
        // Selected IpAddress, NetworkOrder. htonl
        // note: assumed to be in network order
        pDhcpContext->IpAddress = ((m_IpList.m_List)->IpAddress());
        pDhcpContext->IpInterfaceContext = ((m_IpList.m_List)->Context());
    }

    if (m_DhcpList.m_List) {
        // Selected DHCP server address. Network Order. htonl
        // note: assumed to be in network order
        pDhcpContext->DhcpServerAddress = ((m_DhcpList.m_List)->IpAddress());
    }

    pDhcpContext->ClientIdentifier.fSpecified = FALSE;
    pDhcpContext->T2Time = 0;
    // when was the last time an inform was sent?
    pDhcpContext->LastInformSent = 0;
    // seconds passed since boot.
    pDhcpContext->SecondsSinceBoot = 0;

    // the list of options to send and the list of options received
    InitializeListHead(&pDhcpContext->RecdOptionsList);
    InitializeListHead(&pDhcpContext->SendOptionsList);

    // the class this adapter belongs to

    if (  m_lpszAdapterName )
    {
        pDhcpContext->ClassId = (unsigned char *) m_lpszAdapterName;
        pDhcpContext->ClassIdLength = lstrlen(m_lpszAdapterName);
    }
    else
    {
        pDhcpContext->ClassId = NULL;
        pDhcpContext->ClassIdLength = 0;
    }

    // Message buffer to send and receive DHCP message.
    pDhcpContext->MessageBuffer = (PDHCP_MESSAGE) pDhcpContext->szMessageBuffer;
    memset(pDhcpContext->szMessageBuffer, 0, sizeof(pDhcpContext->szMessageBuffer));

    //LocalInfo = (PLOCAL_CONTEXT_INFO)((*pDhcpContext)->LocalInformation);
    //LocalInfo->IpInterfaceContext = IpInterfaceContext;
    //LocalInfo->IpInterfaceInstance = IpInterfaceInstance;
    // IpInterfaceInstance is filled in make context

    pDhcpContext->Socket = INVALID_SOCKET;
    pDhcpContext->State.Plumbed = TRUE;
    pDhcpContext->State.ServerReached = FALSE;
    pDhcpContext->State.AutonetEnabled= FALSE;
    pDhcpContext->State.HasBeenLooked = FALSE;
    pDhcpContext->State.DhcpEnabled   = FALSE;
    pDhcpContext->State.AutoMode      = FALSE;
    pDhcpContext->State.MediaState    = FALSE;
    pDhcpContext->State.MDhcp         = FALSE;
    pDhcpContext->State.PowerResumed  = FALSE;
    pDhcpContext->State.Broadcast     = FALSE;

    return TRUE;
}



//
// public CIpConfig methods
//


CIpConfig::CIpConfig(
    VOID
    )

/*++

Routine Description:

    CIpConfig constructor - initializes the object & loads the requird DLLs if
    not already loaded

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "CIpConfig::CIpConfig",
                 NULL
                 ));

    InitializeListHead(&m_List);
    m_dwNumberOfInterfaces = 0;

    DWORD error = LoadEntryPoints();

    if (error == ERROR_SUCCESS) {
#ifndef unix
        GetAdapterList();
#endif /* unix */
    }

    DEBUG_LEAVE(0);
}


CIpConfig::~CIpConfig()

/*++

Routine Description:

    CIpConfig destructor - destroys this object and unloads (or reduces the
    reference count on) the DLLs

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "CIpConfig::~CIpConfig",
                 NULL
                 ));

    while (!IsListEmpty(&m_List)) {

        PLIST_ENTRY pEntry = RemoveHeadList(&m_List);

        //
        // BUGBUG - need CONTAINING_RECORD() if m_List is not @ start of
        //          CAdapterInterface
        //

        CAdapterInterface * pInterface = (CAdapterInterface *)pEntry;

        delete pInterface;
    }

    CloseTcpipDriverHandle();

    DEBUG_LEAVE(0);
}


BOOL
CIpConfig::GetRouterAddress(
    IN LPBYTE lpbInterfaceAddress OPTIONAL,
    IN DWORD dwInterfaceAddressLength,
    IN OUT LPDWORD lpdwIndex,
    OUT LPBYTE lpbAddress,
    IN OUT LPDWORD lpdwAddressLength
    )

/*++

Routine Description:

    Returns the *lpdwIndex'th router address belonging to the interface
    corresponding to the address in lpbInterfaceAddress

Arguments:

    lpbInterfaceAddress         - pointer to interface address

    dwInterfaceAddressLength    - length of interface address

    lpdwIndex                   - index of router address to return

    lpbAddress                  - returned router address

    lpdwAddressLength           - length of router address

Return Value:

    BOOL
        TRUE    - *lpdwIndex'th router address returned for requested interface

        FALSE   - requested address not returned

--*/

{   
    UNREFERENCED_PARAMETER(lpbInterfaceAddress); 
    UNREFERENCED_PARAMETER(dwInterfaceAddressLength);
    UNREFERENCED_PARAMETER(lpdwIndex);
    UNREFERENCED_PARAMETER(lpbAddress);
    UNREFERENCED_PARAMETER(lpdwAddressLength);

    DEBUG_ENTER((DBG_SOCKETS,
                 Bool,
                 "CIpConfig::GetRouterAddress",
                 "%#x, %d, %#x [%d], %#x, %#x [%d]",
                 lpbInterfaceAddress,
                 dwInterfaceAddressLength,
                 lpdwIndex,
                 *lpdwIndex,
                 lpbAddress,
                 lpdwAddressLength,
                 *lpdwAddressLength
                 ));

    //
    // for now, we default to 1st interface
    //

    INET_ASSERT(lpbInterfaceAddress == NULL);
    INET_ASSERT(dwInterfaceAddressLength == sizeof(DWORD));

    BOOL found;

    //
    // no one uses this any more
    //

    INET_ASSERT(FALSE);

    //if (!IsListEmpty(&m_List)) {
    //    found = ((CAdapterInterface *)m_List.Flink)->m_RouterList.GetAddress(
    //                lpdwIndex,
    //                lpbAddress,
    //                lpdwAddressLength
    //                );
    //} else {
        found = FALSE;
    //}

    DEBUG_LEAVE(found);

    return found;
}


BOOL
CIpConfig::GetDnsAddress(
    IN LPBYTE lpbInterfaceAddress OPTIONAL,
    IN DWORD dwInterfaceAddressLength,
    IN OUT LPDWORD lpdwIndex,
    OUT LPBYTE lpbAddress,
    IN OUT LPDWORD lpdwAddressLength
    )

/*++

Routine Description:

    Returns the *lpdwIndex'th DNS address belonging to the interface
    corresponding to the address in lpbInterfaceAddress

Arguments:

    lpbInterfaceAddress         - pointer to interface address

    dwInterfaceAddressLength    - length of interface address

    lpdwIndex                   - index of DNS address to return

    lpbAddress                  - returned DNS address

    lpdwAddressLength           - length of DNS address

Return Value:

    BOOL
        TRUE    - *lpdwIndex'th DNS address returned for requested interface

        FALSE   - requested address not returned

--*/

{
    UNREFERENCED_PARAMETER(lpbInterfaceAddress);
    UNREFERENCED_PARAMETER(dwInterfaceAddressLength);
    DEBUG_ENTER((DBG_SOCKETS,
                 Bool,
                 "CIpConfig::GetDnsAddress",
                 "%#x, %d, %#x [%d], %#x, %#x [%d]",
                 lpbInterfaceAddress,
                 dwInterfaceAddressLength,
                 lpdwIndex,
                 *lpdwIndex,
                 lpbAddress,
                 lpdwAddressLength,
                 *lpdwAddressLength
                 ));

    //
    // for now, we only return the global DNS info
    //

    INET_ASSERT(lpbInterfaceAddress == NULL);
    INET_ASSERT(dwInterfaceAddressLength == sizeof(DWORD));

    BOOL found;

    if (!m_DnsList.IsEmpty()) {
        found = m_DnsList.GetAddress(lpdwIndex,
                                     lpbAddress,
                                     lpdwAddressLength
                                     );
    } else {
        found = FALSE;
    }

    DEBUG_LEAVE(found);

    return found;
}


BOOL
CIpConfig::IsKnownIpAddress(
    IN LPBYTE lpbInterfaceAddress OPTIONAL,
    IN DWORD dwInterfaceAddressLength,
    IN LPBYTE lpbAddress,
    IN DWORD dwAddressLength
    )

/*++

Routine Description:

    Return TRUE if lpbAddress is a known interface address

Arguments:

    lpbInterfaceAddress         - pointer to interface address

    dwInterfaceAddressLength    - length of interface address

    lpbAddress                  - pointer to address to check

    dwAddressLength             - length of address

Return Value:

    BOOL

--*/

{
    UNREFERENCED_PARAMETER(lpbInterfaceAddress);
    UNREFERENCED_PARAMETER(dwInterfaceAddressLength);
    UNREFERENCED_PARAMETER(dwAddressLength);
    DEBUG_ENTER((DBG_SOCKETS,
                 Bool,
                 "CIpConfig::IsKnownIpAddress",
                 "%#x, %d, %#x, %d",
                 lpbInterfaceAddress,
                 dwInterfaceAddressLength,
                 lpbAddress,
                 dwAddressLength
                 ));

    BOOL found = FALSE;

    for (CAdapterInterface * pEntry = (CAdapterInterface *)m_List.Flink;
         pEntry != (CAdapterInterface *)&m_List.Flink;
         pEntry = (CAdapterInterface *)pEntry->m_List.Flink) {

        if (pEntry->FindIpAddress(*(LPDWORD)lpbAddress)) {
            found = TRUE;
            break;
        }
    }

    DEBUG_LEAVE(found);

    return found;
}


BOOL
CIpConfig::Refresh(
    VOID
    )

/*++

Routine Description:

    Refreshes the interface information - re-reads the interfaces and IP
    addresses

Arguments:

    None.

Return Value:

    BOOL
        TRUE    - interfaces or IP address changed

        FALSE   - nothing changed

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Bool,
                 "CIpConfig::Refresh",
                 NULL
                 ));

    BOOL bChanged;

    GetAdapterList(&bChanged);

    if (bChanged) {
//dprintf("flushing hostent cache\n");
//        FlushHostentCache();
    }

    DEBUG_LEAVE(bChanged);

    return bChanged;
}

//
// private CIpConfig methods
//


PRIVATE
BOOL
CIpConfig::GetAdapterList(
    OUT LPBOOL lpbChanged
    )

/*++

Routine Description:

    Builds a list of interfaces corresponding to physical and logical adapters,
      Uses Win'95 and NT 4 private VxD driver/registry entry points to get this data.

Arguments:

    lpbChanged  - if present, returns interface changed state

Return Value:

    BOOL
        TRUE    - successfully built list

        FALSE   - failed to allocate memory or failure talking to TCP/IP

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Bool,
                 "CIpConfig::GetAdapterList",
                 "%#x",
                 lpbChanged
                 ));

    TCP_REQUEST_QUERY_INFORMATION_EX req;
    TDIObjectID id;
    UINT numberOfEntities;
    TDIEntityID* pEntity;
    TDIEntityID* entityList = NULL;
    IPRouteEntry* routeTable = NULL;
    LPVOID buffer = NULL;
    DWORD status;
    DWORD inputLen;
    DWORD outputLen;
    BOOL ok = FALSE;
    UINT i; // major loop index
    UINT j; // minor loop index
    BOOL bChanged = FALSE;

    //
    // default is interfaces unchanged
    //

    if (lpbChanged) {
        *lpbChanged = FALSE;
    }

    //
    // On NT 5 we override and use a different method for
    //   getting network settings.
    //

    if ( GlobalPlatformVersion5 ) {
        return GetAdapterListOnNT5();
    }

    //
    // get the list of entities supported by TCP/IP then make 2 passes on the
    // list. Pass 1 scans for IF_ENTITY's (interface entities perhaps?) which
    // describe adapter instances (physical and virtual). Once we have our list
    // of adapters, on pass 2 we look for CL_NL_ENTITY's (connection-less
    // network layer entities peut-etre?) which will give us the list of IP
    // addresses for the adapters we found in pass 1
    //

    numberOfEntities = GetEntityList(&entityList);
    if (numberOfEntities == 0) {

        INET_ASSERT(entityList == NULL);

        DEBUG_PRINT(UTIL,
                    ERROR,
                    ("GetAdapterList: failed to get entity list\n"
                    ));

        goto quit;
    }

    //
    // first off, mark all the current interfaces (if any), including current
    // IP addresses, as not found
    //

    SetNotFound();

    //
    // pass 1
    //

    for (i = 0, pEntity = entityList; i < numberOfEntities; ++i, ++pEntity) {

        DEBUG_PRINT(UTIL,
                    INFO,
                    ("Pass 1: Entity %#x (%s) Instance #%d\n",
                    pEntity->tei_entity,
                    InternetMapEntity(pEntity->tei_entity),
                    pEntity->tei_instance
                    ));

        if (pEntity->tei_entity != IF_ENTITY) {

            DEBUG_PRINT(UTIL,
                        INFO,
                        ("Entity %#x (%s) Instance #%d not IF_ENTITY - skipping\n",
                        pEntity->tei_entity,
                        InternetMapEntity(pEntity->tei_entity),
                        pEntity->tei_instance
                        ));

            continue;
        }

        //
        // IF_ENTITY: this entity/instance describes an adapter
        //

        DWORD isMib;
        BYTE info[sizeof(IFEntry) + MAX_ADAPTER_DESCRIPTION_LENGTH + 1];
        IFEntry* pIfEntry = (IFEntry*)info;
        int len;

        //
        // find out if this entity supports MIB requests
        //

        memset(&req, 0, sizeof(req));

        id.toi_entity = *pEntity;
        id.toi_class = INFO_CLASS_GENERIC;
        id.toi_type = INFO_TYPE_PROVIDER;
        id.toi_id = ENTITY_TYPE_ID;

        req.ID = id;

        inputLen = sizeof(req);
        outputLen = sizeof(isMib);

        status = WsControl(IPPROTO_TCP,
                           WSCNTL_TCPIP_QUERY_INFO,
                           (LPVOID)&req,
                           &inputLen,
                           (LPVOID)&isMib,
                           &outputLen
                           );

        //
        // BUGBUG - this returns 0 as outputLen
        //

//        if ((status != TDI_SUCCESS) || (outputLen != sizeof(isMib))) {
        if (status != TDI_SUCCESS) {

            //
            // unexpected results - bail out
            //

            DEBUG_PRINT(UTIL,
                        ERROR,
                        ("WsControl(ENTITY_TYPE_ID): status = %d, outputLen = %d\n",
                        status,
                        outputLen
                        ));

            goto error_exit;
        }
        if (isMib != IF_MIB) {

            //
            // entity doesn't support MIB requests - try another
            //

            DEBUG_PRINT(UTIL,
                        WARNING,
                        ("Entity %#x, Instance #%d doesn't support MIB (%#x)\n",
                        id.toi_entity.tei_entity,
                        id.toi_entity.tei_instance,
                        isMib
                        ));

            continue;
        }

        //
        // MIB requests supported - query the adapter info
        //

        id.toi_class = INFO_CLASS_PROTOCOL;
        id.toi_id = IF_MIB_STATS_ID;

        memset(&req, 0, sizeof(req));
        req.ID = id;

        inputLen = sizeof(req);
        outputLen = sizeof(info);

        status = WsControl(IPPROTO_TCP,
                           WSCNTL_TCPIP_QUERY_INFO,
                           (LPVOID)&req,
                           &inputLen,
                           (LPVOID)&info,
                           &outputLen
                           );
        if (status != TDI_SUCCESS) {

            //
            // unexpected results - bail out
            //

            DEBUG_PRINT(UTIL,
                        ERROR,
                        ("WsControl(IF_MIB_STATS_ID) returns %d\n",
                        status
                        ));

            goto error_exit;
        }

        //
        // we only want physical adapters
        //

        if (!IS_INTERESTING_ADAPTER(pIfEntry)) {

            DEBUG_PRINT(UTIL,
                        INFO,
                        ("ignoring adapter #%d [%s]\n",
                        pIfEntry->if_index,
                        InternetMapInterface(pIfEntry->if_type)
                        ));

            continue;
        }

        //
        // got this adapter info ok. Find or create an interface object and fill
        // in what we can
        //

        CAdapterInterface * pInterface;

        len = min(MAX_ADAPTER_ADDRESS_LENGTH, (size_t)pIfEntry->if_physaddrlen);

        pInterface = FindOrCreateInterface(pIfEntry->if_index,
                                           pIfEntry->if_type,
                                           pIfEntry->if_speed,
                                           (LPSTR)pIfEntry->if_descr,
                                           pIfEntry->if_descrlen,
                                           (LPBYTE)pIfEntry->if_physaddr,
                                           (DWORD) len
                                           );
        if (pInterface == NULL) {

            DEBUG_PRINT(UTIL,
                        ERROR,
                        ("failed to allocate memory for CAdapterInterface\n"
                        ));

            goto error_exit;
        }
    }

    //
    // pass 2
    //

    for (i = 0, pEntity = entityList; i < numberOfEntities; ++i, ++pEntity) {

        DEBUG_PRINT(UTIL,
                    INFO,
                    ("Pass 2: Entity %#x (%s) Instance %d\n",
                    pEntity->tei_entity,
                    InternetMapEntity(pEntity->tei_entity),
                    pEntity->tei_instance
                    ));

        if (pEntity->tei_entity != CL_NL_ENTITY) {

            DEBUG_PRINT(UTIL,
                        INFO,
                        ("Entity %#x (%s) Instance %d - not CL_NL_ENTITY - skipping\n",
                        pEntity->tei_entity,
                        InternetMapEntity(pEntity->tei_entity),
                        pEntity->tei_instance
                        ));

            continue;
        }

        IPSNMPInfo info;
        DWORD type;

        //
        // first off, see if this network layer entity supports IP
        //

        memset(&req, 0, sizeof(req));

        id.toi_entity = *pEntity;
        id.toi_class = INFO_CLASS_GENERIC;
        id.toi_type = INFO_TYPE_PROVIDER;
        id.toi_id = ENTITY_TYPE_ID;

        req.ID = id;

        inputLen = sizeof(req);
        outputLen = sizeof(type);

        status = WsControl(IPPROTO_TCP,
                           WSCNTL_TCPIP_QUERY_INFO,
                           (LPVOID)&req,
                           &inputLen,
                           (LPVOID)&type,
                           &outputLen
                           );

        //
        // BUGBUG - this returns 0 as outputLen
        //

//        if ((status != TDI_SUCCESS) || (outputLen != sizeof(type))) {
        if (status != TDI_SUCCESS) {

            //
            // unexpected results - bail out
            //

            DEBUG_PRINT(UTIL,
                        ERROR,
                        ("WsControl(ENTITY_TYPE_ID): status = %d, outputLen = %d\n",
                        status,
                        outputLen
                        ));

            goto error_exit;
        }
        if (type != CL_NL_IP) {

            //
            // nope, not IP - try next one
            //

            DEBUG_PRINT(UTIL,
                        INFO,
                        ("CL_NL_ENTITY #%d not CL_NL_IP - skipping\n",
                        pEntity->tei_instance
                        ));

            continue;
        }

        //
        // okay, this NL provider supports IP. Let's get them addresses: First
        // we find out how many by getting the SNMP stats and looking at the
        // number of addresses supported by this interface
        //

        memset(&req, 0, sizeof(req));

        id.toi_class = INFO_CLASS_PROTOCOL;
        id.toi_id = IP_MIB_STATS_ID;

        req.ID = id;

        inputLen = sizeof(req);
        outputLen = sizeof(info);

        status = WsControl(IPPROTO_TCP,
                           WSCNTL_TCPIP_QUERY_INFO,
                           (LPVOID)&req,
                           &inputLen,
                           (LPVOID)&info,
                           &outputLen
                           );
        if ((status != TDI_SUCCESS) || (outputLen != sizeof(info))) {

            //
            // unexpected results - bail out
            //

            DEBUG_PRINT(UTIL,
                        ERROR,
                        ("WsControl(IP_MIB_STATS_ID): status = %d, outputLen = %d\n",
                        status,
                        outputLen
                        ));

            goto error_exit;
        }

        //
        // get the IP addresses & subnet masks
        //

        if (info.ipsi_numaddr != 0) {

            //
            // this interface has some addresses. What are they?
            //

            UINT numberOfAddresses;
            IPAddrEntry* pAddr;

            outputLen = info.ipsi_numaddr * sizeof(IPAddrEntry);
            buffer = (LPVOID)ALLOCATE_MEMORY(outputLen);
            if (buffer == NULL) {

                //
                // unexpected results - bail out
                //

                DEBUG_PRINT(UTIL,
                            ERROR,
                            ("failed to allocate %d bytes\n",
                            outputLen
                            ));

                goto error_exit;
            }

            memset(&req, 0, sizeof(req));

            id.toi_id = IP_MIB_ADDRTABLE_ENTRY_ID;

            req.ID = id;

            inputLen = sizeof(req);

            status = WsControl(IPPROTO_TCP,
                               WSCNTL_TCPIP_QUERY_INFO,
                               (LPVOID)&req,
                               &inputLen,
                               (LPVOID)buffer,
                               &outputLen
                               );
            if (status != TDI_SUCCESS) {

                //
                // unexpected results - bail out
                //

                DEBUG_PRINT(UTIL,
                            ERROR,
                            ("WsControl(IP_MIB_ADDRTABLE_ENTRY_ID): status = %d, outputLen = %d\n",
                            status,
                            outputLen
                            ));

                goto error_exit;
            }

            //
            // now loop through this list of IP addresses, applying them
            // to the correct adapter
            //

            numberOfAddresses = min((UINT)(outputLen / sizeof(IPAddrEntry)),
                                    (UINT)info.ipsi_numaddr
                                    );

            DEBUG_PRINT(UTIL,
                        INFO,
                        ("%d IP addresses\n",
                        numberOfAddresses
                        ));

            pAddr = (IPAddrEntry *)buffer;
            for (j = 0; j < numberOfAddresses; ++j, ++pAddr) {

                DEBUG_PRINT(UTIL,
                            INFO,
                            ("IP address %d.%d.%d.%d, index %d, context %d\n",
                            ((LPBYTE)&pAddr->iae_addr)[0] & 0xff,
                            ((LPBYTE)&pAddr->iae_addr)[1] & 0xff,
                            ((LPBYTE)&pAddr->iae_addr)[2] & 0xff,
                            ((LPBYTE)&pAddr->iae_addr)[3] & 0xff,
                            pAddr->iae_index,
                            pAddr->iae_context
                            ));

                CAdapterInterface * pInterface = FindInterface(pAddr->iae_index);

                if (pInterface != NULL) {

                    CIpAddress * pIpAddress;

                    pIpAddress = pInterface->m_IpList.Find(pAddr->iae_addr,
                                                           pAddr->iae_mask
                                                           );
                    if (pIpAddress == NULL) {
                        pInterface->m_IpList.Add(pAddr->iae_addr,
                                                 pAddr->iae_mask,
                                                 pAddr->iae_context
                                                 );

                        //
                        // added an address - interface is changed
                        //
//dprintf("adding IP address %d.%d.%d.%d - changed\n",
//        ((LPBYTE)&pAddr->iae_addr)[0] & 0xff,
//        ((LPBYTE)&pAddr->iae_addr)[1] & 0xff,
//        ((LPBYTE)&pAddr->iae_addr)[2] & 0xff,
//        ((LPBYTE)&pAddr->iae_addr)[3] & 0xff
//        );
                        bChanged = TRUE;
                    } else {

                        INET_ASSERT(pAddr->iae_context == pIpAddress->Context());

                        pIpAddress->SetFound(TRUE);
                    }
                }
            }

            INET_ASSERT(buffer);

            FREE_MEMORY(buffer);

            buffer = NULL;
        }
    }

    //
    // add the DNS servers, read from registry or DHCP depending on platform.
    // Even if we don't get any DNS servers, we deem that this function has
    // succeeded
    //

    char dnsBuffer[1024];   // arbitrary (how many DNS entries?)
    UINT error;

    error = SockGetSingleValue(CONFIG_NAME_SERVER,
                               (LPBYTE)dnsBuffer,
                               sizeof(dnsBuffer)
                               );
    if (error == ERROR_SUCCESS) {
        //m_DnsList.Clear();

        char ipString[4 * 4];
        LPSTR p = dnsBuffer;
        DWORD buflen = (DWORD)lstrlen(dnsBuffer);

        do {
            if (SkipWhitespace(&p, &buflen)) {

                int i = 0;

                while ((*p != '\0')
                       && (*p != ',')
                       && (buflen != 0)
                       && (i < sizeof(ipString))
                       && !isspace(*p)) {
                    ipString[i++] = *p++;
                    --buflen;
                }
                ipString[i] = '\0';

                DWORD ipAddress = _I_inet_addr(ipString);

                if (IS_VALID_NON_LOOPBACK_IP_ADDRESS(ipAddress)) {

                    CIpAddress * pIpAddress;

                    pIpAddress = m_DnsList.Find(ipAddress);
                    if (pIpAddress == NULL) {
                        m_DnsList.Add(ipAddress);

                        //
                        // added a DNS address - interface is changed
                        //

//dprintf("adding DNS address %d.%d.%d.%d - changed\n",
//        ((LPBYTE)&ipAddress)[0] & 0xff,
//        ((LPBYTE)&ipAddress)[1] & 0xff,
//        ((LPBYTE)&ipAddress)[2] & 0xff,
//        ((LPBYTE)&ipAddress)[3] & 0xff
//        );
                        bChanged = TRUE;
                    } else {
                        pIpAddress->SetFound(TRUE);
                    }
                }
                while ((*p == ',') && (buflen != 0)) {
                    ++p;
                    --buflen;
                }
            } else {
                break;
            }
        } while (TRUE);
    }

    //
    // Refresh registry settings of DHCP server stuff
    //  and figure out what DHCP server we have
    //

    GetAdapterInfo();

    //
    // throw out any adapter interfaces which were not found this time. This may
    // happen if we support PnP devices that are unplugged
    //

    BOOL bThrownOut;

    bThrownOut = ThrowOutUnfoundEntries();
    if (!bChanged) {
        bChanged = bThrownOut;
    }

    INET_ASSERT(entityList != NULL);

    FREE_MEMORY(entityList);

    ok = TRUE;

    //
    // return the change state of the interfaces, if required
    //

    if (lpbChanged) {
        *lpbChanged = bChanged;
    }

quit:

    if (routeTable != NULL) {
        FREE_MEMORY(routeTable);
    }

    if (buffer != NULL) {
        FREE_MEMORY(buffer);
    }

    DEBUG_LEAVE(ok);

    return ok;

error_exit:

    //
    // here because of an error. Throw out all interfaces
    //

    SetNotFound();
    ThrowOutUnfoundEntries();

    INET_ASSERT(!ok);

    goto quit;
}



PRIVATE
BOOL
CIpConfig::GetAdapterListOnNT5(
    OUT LPBOOL lpbChanged
    )

/*++

Routine Description:

    Builds a list of interfaces corresponding to physical and logical adapters
     using the new NT 5 and Win98 APIs.

Arguments:

    lpbChanged  - if present, returns interface changed state

Return Value:

    BOOL
        TRUE    - successfully built list

        FALSE   - failed to allocate memory or failure talking to TCP/IP

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Bool,
                 "CIpConfig::GetAdapterListOnNT5",
                 "%#x",
                 lpbChanged
                 ));

    BOOL ok = FALSE;
    BOOL bChanged = FALSE;
    int len;

    PIP_ADAPTER_INFO pAdapterInfo = NULL;
    PIP_ADAPTER_INFO pAdapterInfoAllocation = NULL;
    DWORD dwError;
    ULONG uSize;

    //
    // Load the IPHLPAPI DLL, cause we need this function find adapter info on NT 5/Win98
    //

    if (_I_GetAdaptersInfo == NULL )
    {
        DEBUG_PRINT(UTIL,
            ERROR,
            ("GetAdapterListOnNT5: IPHLPAPI dll could not be found with correct entry point\n"
            ));

        goto quit;
    }

    //
    // get the list of adapters supported by TCP/IP
    //

    uSize = sizeof(IP_ADAPTER_INFO) * 5;

    pAdapterInfoAllocation = (IP_ADAPTER_INFO *) ALLOCATE_FIXED_MEMORY(uSize);

    // Alias the pAdapterInfoAllocation pointer. pAdapterInfo will be used
    // to traverse the list of adapter info records. We need the
    // pAdapterInfoAllocation pointer in order to free the memory block at
    // the end of this function.
    pAdapterInfo = pAdapterInfoAllocation;

    if (pAdapterInfo == NULL)
    {
        goto quit;
    }

    dwError = _I_GetAdaptersInfo(pAdapterInfo, &uSize);

    if (dwError == ERROR_BUFFER_OVERFLOW)
    {
        pAdapterInfoAllocation = (IP_ADAPTER_INFO *) ResizeBuffer(pAdapterInfoAllocation, uSize, FALSE);

        pAdapterInfo = pAdapterInfoAllocation;

        if (pAdapterInfo == NULL)
        {
            goto quit;
        }

        dwError = _I_GetAdaptersInfo(pAdapterInfo, &uSize);
    }

    if ( dwError != ERROR_SUCCESS )
    {

        DEBUG_PRINT(UTIL,
            ERROR,
            ("GetAdapterListOnNT5: failed to get adapters list\n"
            ));

        goto quit;
    }

    //
    // first off, mark all the current interfaces (if any), including current
    // IP addresses, as not found
    //

    SetNotFound();

    //
    // pass 1
    //

    for (; pAdapterInfo; pAdapterInfo = pAdapterInfo->Next)
    {

        DEBUG_PRINT(UTIL,
                    INFO,
                    ("Adapter Pass: [#%u] Adapter name=%s, description=%s\n",
                    pAdapterInfo->Index,
                    pAdapterInfo->AdapterName,
                    pAdapterInfo->Description
                    ));

        //
        // we only want physical adapters
        //

        if (!IS_INTERESTING_ADAPTER_NT5(pAdapterInfo)) {

            DEBUG_PRINT(UTIL,
                        INFO,
                        ("ignoring adapter #%u [%s]\n",
                        pAdapterInfo->Index,
                        InternetMapInterfaceOnNT5(pAdapterInfo->Type)
                        ));

            continue;
        }

        //
        // got this adapter info ok. Find or create an interface object and fill
        // in what we can
        //

        CAdapterInterface * pInterface;

        len = min(MAX_ADAPTER_ADDRESS_LENGTH, (size_t)pAdapterInfo->AddressLength);


        pInterface = FindOrCreateInterface(pAdapterInfo->Index,
                                           pAdapterInfo->Type,
                                           0,                   // speed
                                           pAdapterInfo->Description,
                                           lstrlen(pAdapterInfo->Description),
                                           pAdapterInfo->Address,
                                           (DWORD) len
                                           );
        if (pInterface == NULL) {

            DEBUG_PRINT(UTIL,
                        ERROR,
                        ("failed to allocate memory for CAdapterInterface\n"
                        ));

            goto error_exit;
        }

        //
        // Update the Adapter Name, this is the critical glue to make the new NT 5 DHCP Apis work,
        //   as they need this Adapter name as an ID to work.
        //

        if ( pInterface->GetAdapterName() == NULL )  {
            pInterface->SetAdapterName(pAdapterInfo->AdapterName);
        } else {
            INET_ASSERT(lstrcmpi(pInterface->GetAdapterName(), pAdapterInfo->AdapterName) == 0 );
        }

        //
        // Update the IP address found in the structure, as we're not getting anything back with this filled in.
        //

        if (  pAdapterInfo->CurrentIpAddress == NULL )
        {
            pAdapterInfo->CurrentIpAddress = &pAdapterInfo->IpAddressList;
        }
        else
        {
            INET_ASSERT(FALSE);  // want to know about this case.
        }

        //
        // Gather the IP addresses from the structure, doing all the necessary,
        //  IP string to network-ordered DWORD thingie usable for winsock.
        //
        //  BUGBUG [arthurbi] do we really need to do this anymore? As the
        //    the new NT 5 APIs can handle themselves without IP addresses...
        //


        if ( pAdapterInfo->CurrentIpAddress->IpAddress.String &&
             pAdapterInfo->CurrentIpAddress->IpMask.String )
        {
            DWORD dwAddress = _I_inet_addr(pAdapterInfo->CurrentIpAddress->IpAddress.String);
            DWORD dwMask = _I_inet_addr(pAdapterInfo->CurrentIpAddress->IpMask.String);
            DWORD dwContext = pAdapterInfo->CurrentIpAddress->Context;

            if ( dwAddress   != INADDR_NONE &&
                 dwMask      != INADDR_NONE  )
            {

                DEBUG_PRINT(UTIL,
                            INFO,
                            ("IP address %d.%d.%d.%d, index %d, context %d\n",
                            ((LPBYTE)&dwAddress)[0] & 0xff,
                            ((LPBYTE)&dwAddress)[1] & 0xff,
                            ((LPBYTE)&dwAddress)[2] & 0xff,
                            ((LPBYTE)&dwAddress)[3] & 0xff,
                            pAdapterInfo->Index,
                            dwContext
                            ));

                INET_ASSERT(pInterface != NULL);

                CIpAddress * pIpAddress;

                pIpAddress = pInterface->m_IpList.Find(dwAddress,
                                                       dwMask
                                                       );
                if (pIpAddress == NULL) {
                    pInterface->m_IpList.Add(dwAddress,
                                             dwMask,
                                             dwContext
                                             );

                    //
                    // added an address - interface is changed
                    //

                    bChanged = TRUE;
                } else {

                    INET_ASSERT(dwContext == pIpAddress->Context());

                    pIpAddress->SetFound(TRUE);
                }
            }
        }

        //
        // Gather DHCP server addresses to use, once again do we need this info on NT 5?
        //

        if ( pAdapterInfo->DhcpEnabled )
        {
            PIP_ADDR_STRING pDhcpServer;
            INET_ASSERT(pInterface != NULL);

            for ( pDhcpServer = &pAdapterInfo->DhcpServer; pDhcpServer; pDhcpServer = pDhcpServer->Next )
            {

                DWORD dwAddress = _I_inet_addr(pDhcpServer->IpAddress.String);
                DWORD dwMask = _I_inet_addr(pDhcpServer->IpMask.String);
                DWORD dwContext = pDhcpServer->Context;

                if ( dwAddress   != INADDR_NONE )
                {
                    CIpAddress * pIpAddress;

                    pInterface->SetDhcp();

                    pIpAddress = pInterface->m_DhcpList.Find(dwAddress,
                                                           dwMask
                                                           );
                    if (pIpAddress == NULL)
                    {
                        pInterface->m_DhcpList.Add(dwAddress,
                                                  dwMask,
                                                  dwContext
                                                  );

                        //
                        // added an address - interface is changed
                        //

                        bChanged = TRUE;
                    } else {

                        INET_ASSERT(dwContext == pIpAddress->Context());

                        pIpAddress->SetFound(TRUE);
                    }
                }

            }
        }
    }

    //
    // add the DNS servers, read from registry or DHCP depending on platform.
    // Even if we don't get any DNS servers, we deem that this function has
    // succeeded
    //

    char dnsBuffer[1024];   // arbitrary (how many DNS entries?)
    UINT error;

    error = SockGetSingleValue(CONFIG_NAME_SERVER,
                               (LPBYTE)dnsBuffer,
                               sizeof(dnsBuffer)
                               );
    if (error == ERROR_SUCCESS) {
        //m_DnsList.Clear();

        char ipString[4 * 4];
        LPSTR p = dnsBuffer;
        DWORD buflen = (DWORD)lstrlen(dnsBuffer);

        do {
            if (SkipWhitespace(&p, &buflen)) {

                int i = 0;

                while ((*p != '\0')
                       && (*p != ',')
                       && (buflen != 0)
                       && (i < sizeof(ipString))
                       && !isspace(*p)) {
                    ipString[i++] = *p++;
                    --buflen;
                }
                ipString[i] = '\0';

                DWORD ipAddress = _I_inet_addr(ipString);

                if (IS_VALID_NON_LOOPBACK_IP_ADDRESS(ipAddress)) {

                    CIpAddress * pIpAddress;

                    pIpAddress = m_DnsList.Find(ipAddress);
                    if (pIpAddress == NULL) {
                        m_DnsList.Add(ipAddress);

                        //
                        // added a DNS address - interface is changed
                        //

                        bChanged = TRUE;
                    } else {
                        pIpAddress->SetFound(TRUE);
                    }
                }
                while ((*p == ',') && (buflen != 0)) {
                    ++p;
                    --buflen;
                }
            } else {
                break;
            }
        } while (TRUE);
    }

    //
    // throw out any adapter interfaces which were not found this time. This may
    // happen if we support PnP devices that are unplugged
    //
    //  Do we need to still do this ???
    //

    BOOL bThrownOut;

    bThrownOut = ThrowOutUnfoundEntries();
    if (!bChanged) {
        bChanged = bThrownOut;
    }

    ok = TRUE;

    //
    // return the change state of the interfaces, if required
    //

    if (lpbChanged) {
        *lpbChanged = bChanged;
    }

quit:

    if (pAdapterInfoAllocation)
    {
        FREE_MEMORY(pAdapterInfoAllocation);
    }

    DEBUG_LEAVE(ok);

    return ok;

error_exit:

    //
    // here because of an error. Throw out all interfaces
    //

    SetNotFound();
    ThrowOutUnfoundEntries();

    INET_ASSERT(!ok);

    goto quit;
}


BOOL
CIpConfig::DoInformsOnEachInterface(
    OUT LPSTR * ppszAutoProxyUrl
    )
{
    for (CAdapterInterface * pEntry = (CAdapterInterface *)m_List.Flink;
         pEntry != (CAdapterInterface *)&m_List.Flink;
         pEntry =  (CAdapterInterface *)pEntry->m_List.Flink)
    {
        if ( pEntry->IsDhcp() )
        {
            BOOL fSuccess;

            if ( GlobalPlatformVersion5 )
            {
                fSuccess = pEntry->DhcpDoInformNT5(ppszAutoProxyUrl);
            }
            else
            {
                fSuccess = DhcpDoInform(     // send an inform packet if necessary
                        pEntry,
                        FALSE,
                        ppszAutoProxyUrl
                        );
            }

            if ( fSuccess ) {
                return TRUE;
            }
        }
    }

    return FALSE;
}


/*******************************************************************************
 *
 *  GetAdapterInfo
 *
 *  Gets a list of all adapters to which TCP/IP is bound and reads the per-
 *  adapter information that we want to display. Most of the information now
 *  comes from the TCP/IP stack itself. In order to keep the 'short' names that
 *  exist in the registry to refer to the individual adapters, we read the names
 *  from the registry then match them to the adapters returned by TCP/IP by
 *  matching the IPInterfaceContext value with the adapter which owns the IP
 *  address with that context value
 *
 *  ENTRY   nothing
 *
 *  EXIT    nothing
 *
 *  RETURNS pointer to linked list of ADAPTER_INFO structures
 *
 *  ASSUMES
 *
 ******************************************************************************/

VOID
CIpConfig::GetAdapterInfo()
{
    LPSTR* boundAdapterNames = NULL;
    DWORD err = ERROR_SUCCESS;

    if (GlobalPlatformType == PLATFORM_TYPE_WINNT)
    {
        if ( ServicesKey == NULL )
        {
            err = REGOPENKEY(HKEY_LOCAL_MACHINE,
                             SERVICES_KEY_NAME,
                             &ServicesKey
                             );
        }

        if ( err == ERROR_SUCCESS && TcpipLinkageKey == NULL )
        {
            err = REGOPENKEY(ServicesKey,
                             "Tcpip\\Linkage",
                             //"Tcpip\\Parameters\\Interfaces",
                             &TcpipLinkageKey
                             );
        }

        if (err == ERROR_SUCCESS && (NULL != (boundAdapterNames = GetBoundAdapterList(TcpipLinkageKey))))
        {
            int i;

            //
            // apply the short name to the right adapter info by comparing
            // the IPInterfaceContext value in the adapter\Parameters\Tcpip
            // section with the context values read from the stack for the
            // IP addresses
            //

            for (i = 0; boundAdapterNames[i]; ++i) {

                LPSTR name;
                DWORD context;
                HKEY key;

                name = boundAdapterNames[i];

                if (!OpenAdapterKey(KEY_TCP, name, &key)) {
                    DEBUG_PRINT(UTIL, ERROR, ("GetAdapterInfo cannot open %s\n",
                                 name ));

                    goto quit;
                }
                if (!ReadRegistryDword(key,
                                       "IPInterfaceContext",
                                       &context
                                       )) {
                    DEBUG_PRINT(UTIL, ERROR, ("GetAdapterInfo: IPInterfaceContext failed\n"));
                    goto quit;
                }
                REGCLOSEKEY(key);

                //
                // now search through the list of adapters, looking for the one
                // that has the IP address with the same context value as that
                // just read. When found, apply the short name to that adapter
                //

                for (CAdapterInterface * pEntry = (CAdapterInterface *)m_List.Flink;
                     pEntry != (CAdapterInterface *)&m_List.Flink;
                     pEntry =  (CAdapterInterface *)pEntry->m_List.Flink)
                {
                    if ( pEntry->IsContextInIPAddrList(context) )
                    {
                        pEntry->SetAdapterName(name);
                        GetDhcpServerFromDhcp(pEntry);
                        break;
                    }
                }
            }

        } else {
            DEBUG_PRINT(UTIL, ERROR, ("GetAdapterInfo failed\n"));
        }
    }
    else
    {
        //
        // Win95: search through the list of adapters, gather DHCP server names
        //  for each.
        //

        for (CAdapterInterface * pEntry = (CAdapterInterface *)m_List.Flink;
             pEntry != (CAdapterInterface *)&m_List.Flink;
             pEntry =  (CAdapterInterface *)pEntry->m_List.Flink)
        {
            GetDhcpServerFromDhcp(pEntry);
        }

    }

quit:

    if (boundAdapterNames != NULL )
    {
        FREE_MEMORY(boundAdapterNames);
    }

    return;
}



PRIVATE
DWORD
CIpConfig::LoadEntryPoints(
    VOID
    )

/*++

Routine Description:

    Loads IPHLPAPI.DLL and DHCPCSVC.DLL entry points if platform is
    Windows 2000 (or later), or NTDLL.DLL entry points if Windows NT.

Arguments:

    None.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "CIpConfig::LoadEntryPoints",
                 NULL
                 ));

    DWORD error = ERROR_SUCCESS;

    if (!m_Loaded)
    {
        if (GlobalDataInitCritSec.Lock())
        {
            if (!m_Loaded)
            {
                INET_ASSERT(GlobalPlatformType == PLATFORM_TYPE_WINNT);

                if (GlobalPlatformVersion5)
                {
                    INET_ASSERT(_I_GetAdaptersInfo == NULL);
                    
                    error = LoadDllEntryPoints(&IpHlpApiDllInfo, 0);

                    if (error == ERROR_SUCCESS)
                    {
                        error = LoadDllEntryPoints(&DhcpcSvcDllInfo, 0);
                    }

                }
                else
                {   INET_ASSERT(_I_RtlInitUnicodeString == NULL);
                    error = LoadDllEntryPoints(&NtDllInfo, 0);
                }

                m_Loaded = (error == ERROR_SUCCESS);
            }

            GlobalDataInitCritSec.Unlock();
        }
        else
        {
            error = ERROR_NOT_ENOUGH_MEMORY;
        }
    }
        
    DEBUG_LEAVE(error);

    return error;
}


DWORD
CIpConfig::UnloadEntryPoints(
    VOID
    )

/*++

Routine Description:

    Unloads NTDLL.DLL if platform is Windows NT

Arguments:

    None.

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "CIpConfig::UnloadEntryPoints",
                 NULL
                 ));

    DWORD error = ERROR_SUCCESS;

    if (m_Loaded)
    {
        if (GlobalDataInitCritSec.Lock())
        {
            if (m_Loaded)
            {
                if (GlobalPlatformVersion5)
                {
                    if (_I_GetAdaptersInfo != NULL)
                    {
                        error = UnloadDllEntryPoints(&IpHlpApiDllInfo, FALSE);
                    }

                    if (_I_DhcpRequestParams != NULL)
                    {
                        error = UnloadDllEntryPoints(&DhcpcSvcDllInfo, FALSE);
                    }
                }
                else
                {
                    error = UnloadDllEntryPoints(&NtDllInfo, FALSE);
                }

                m_Loaded = FALSE;
            }

            GlobalDataInitCritSec.Unlock();
        }
        else
        {
            error = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    DEBUG_LEAVE(error);

    return error;
}


//
// UnloadAutoProxy()
//
// Called from GlobalDataTerminate to unload IPHLPAPI.DLL & DHCPCSVC.DLL (Win2K+)
// or NTDLL.DLL (NT4) if necessary.
//
void UnloadAutoProxy()
{
    CIpConfig::UnloadEntryPoints();
}



PRIVATE
CAdapterInterface *
CIpConfig::FindOrCreateInterface(
    IN DWORD dwIndex,
    IN DWORD dwType,
    IN DWORD dwSpeed,
    IN LPSTR lpszDescription,
    IN DWORD dwDescriptionLength,
    IN LPBYTE lpPhysicalAddress,
    IN DWORD dwPhysicalAddressLength
    )

/*++

Routine Description:

    Returns a pointer to the CAdapterInterface object corresponding to dwIndex.
    If none found in the list, a new entry is created

Arguments:

    dwIndex             - unique interface identifier to find or create

    dwType              - type of adapter

    dwSpeed             - adapter media speed

    lpszDescription     - name of this interface

    dwDescriptionLength - length of the name

Return Value:

    CAdapterInterface *
        Success - pointer to found or created object

        Failure - NULL

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Pointer,
                 "CIpConfig::FindOrCreateInterface",
                 "%d, %s (%d), %d, %.*q, %d, %x, (%u)",
                 dwIndex,
                 InternetMapInterface(dwType),
                 dwType,
                 dwSpeed,
                 dwDescriptionLength,
                 lpszDescription,
                 dwDescriptionLength,
                 lpPhysicalAddress,
                 dwPhysicalAddressLength
                 ));

    CAdapterInterface * pInterface = FindInterface(dwIndex);

    if (pInterface == NULL) {
        pInterface = new CAdapterInterface(dwIndex,
                                           dwType,
                                           dwSpeed,
                                           lpszDescription,
                                           dwDescriptionLength,
                                           lpPhysicalAddress,
                                           dwPhysicalAddressLength
                                           );
        if (pInterface != NULL) {
            InsertHeadList(&m_List, &pInterface->m_List);
            ++m_dwNumberOfInterfaces;
        }
    }

    DEBUG_LEAVE(pInterface);

    return pInterface;
}


PRIVATE
CAdapterInterface *
CIpConfig::FindInterface(
    IN DWORD dwIndex
    )

/*++

Routine Description:

    Returns a pointer to the CAdapterInterface object corresponding to dwIndex

Arguments:

    dwIndex - unique interface identifier to find

Return Value:

    CAdapterInterface *
        Success - pointer to found object

        Failure - NULL

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Pointer,
                 "CIpConfig::FindInterface",
                 "%d",
                 dwIndex
                 ));

    CAdapterInterface * pInterface = NULL;

    for (PLIST_ENTRY pEntry = m_List.Flink;
        pEntry != (PLIST_ENTRY)&m_List;
        pEntry = pEntry->Flink) {

        if (((CAdapterInterface *)pEntry)->m_dwIndex == dwIndex) {
            ((CAdapterInterface *)pEntry)->SetFound(TRUE);

            //
            // ASSUMES: pEntry == &CAdapterInterface
            //

            pInterface = (CAdapterInterface *)pEntry;
            break;
        }
    }

    DEBUG_LEAVE(pInterface);

    return pInterface;
}


PRIVATE
BOOL
CIpConfig::ThrowOutUnfoundEntries(
    VOID
    )

/*++

Routine Description:

    Throws out (deletes) any entries that are marked not-found

Arguments:

    None.

Return Value:

    BOOL
        TRUE    - interfaces thrown out

        FALSE   -      "     not "   "

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Bool,
                 "CIpConfig::ThrowOutUnfoundEntries",
                 NULL
                 ));

    //
    // ASSUMES: CAdapterInterface.m_List.Flink is first element in structure
    //

    PLIST_ENTRY pPrevious = (PLIST_ENTRY)&m_List.Flink;
    PLIST_ENTRY pEntry = m_List.Flink;
    BOOL bThrownOut = FALSE;

    while (pEntry != (PLIST_ENTRY)&m_List) {

        CAdapterInterface * pInterface = (CAdapterInterface *)pEntry;

        if (!pInterface->IsFound()) {

            DEBUG_PRINT(UTIL,
                        WARNING,
                        ("adapter index %d (%q) not located in list\n",
                        pInterface->m_dwIndex,
                        pInterface->m_lpszDescription
                        ));

            RemoveEntryList(&pInterface->m_List);
            --m_dwNumberOfInterfaces;

            INET_ASSERT((int)m_dwNumberOfInterfaces >= 0);

            delete pInterface;
            bThrownOut = TRUE;
        } else {

            //
            // throw out any IP addresses
            //

            bThrownOut |= pInterface->m_IpList.ThrowOutUnfoundEntries();
            //bThrownOut |= pInterface->m_RouterList.ThrowOutUnfoundEntries();
            //bThrownOut |= pInterface->m_DnsList.ThrowOutUnfoundEntries();
            pPrevious = pEntry;
        }
        pEntry = pPrevious->Flink;
    }

    DEBUG_LEAVE(bThrownOut);

    return bThrownOut;
}

//
// public functions
//


DWORD
WsControl(
    IN DWORD dwProtocol,
    IN DWORD dwRequest,
    IN LPVOID lpInputBuffer,
    IN OUT LPDWORD lpdwInputBufferLength,
    OUT LPVOID lpOutputBuffer,
    IN OUT LPDWORD lpdwOutputBufferLength
    )

/*++

Routine Description:

    Makes device-dependent driver call based on O/S

Arguments:

    dwProtocol              - ignored

    dwRequest               - ignored

    lpInputBuffer           - pointer to request buffer

    lpdwInputBufferLength   - pointer to DWORD: IN = request buffer length

    lpOutputBuffer          - pointer to output buffer

    lpdwOutputBufferLength  - pointer to DWORD: IN = length of output buffer;
                                               OUT = length of returned data

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "WsControl",
                 "%d, %d, %#x, %#x [%d], %#x, %#x [%d]",
                 dwProtocol,
                 dwRequest,
                 lpInputBuffer,
                 lpdwInputBufferLength,
                 *lpdwInputBufferLength,
                 lpOutputBuffer,
                 lpdwOutputBufferLength,
                 *lpdwOutputBufferLength
                 ));

    DWORD error;

    if (GlobalPlatformType == PLATFORM_TYPE_WINNT)
    {
        error = WinNtWsControl(dwProtocol,
                               dwRequest,
                               lpInputBuffer,
                               lpdwInputBufferLength,
                               lpOutputBuffer,
                               lpdwOutputBufferLength
                               );
    }
    else
    {
        error = ERROR_NOT_SUPPORTED;
    }

    DEBUG_LEAVE(error);

    return error;
}

//
// private functions
//


PRIVATE
DWORD
WinNtWsControl(
    DWORD dwProtocol,
    DWORD dwRequest,
    LPVOID lpInputBuffer,
    LPDWORD lpdwInputBufferLength,
    LPVOID lpOutputBuffer,
    LPDWORD lpdwOutputBufferLength
    )

/*++

Routine Description:

    Handles WsControl() functionality on NT platform. Assumes NTDLL.DLL has
    already been loaded

Arguments:

    dwProtocol              - unused

    dwRequest               - unused

    lpInputBuffer           - contains driver request structure

    lpdwInputBufferLength   - pointer to length of InputBuffer

    lpOutputBuffer          - pointer to buffer where results written

    lpdwOutputBufferLength  - pointer to length of OutputBuffer. Updated with
                              returned data length on successful return

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "WinNtWsControl",
                 "%d, %d, %#x, %#x [%d], %#x, %#x [%d]",
                 dwProtocol,
                 dwRequest,
                 lpInputBuffer,
                 lpdwInputBufferLength,
                 *lpdwInputBufferLength,
                 lpOutputBuffer,
                 lpdwOutputBufferLength,
                 *lpdwOutputBufferLength
                 ));

    UNREFERENCED_PARAMETER(dwProtocol);
    UNREFERENCED_PARAMETER(dwRequest);

    DWORD error;

    if (TcpipDriverHandle == INVALID_HANDLE_VALUE) {
        error = OpenTcpipDriverHandle();
        if (error != ERROR_SUCCESS) {
            goto quit;
        }
    }

    DWORD bytesReturned;
    BOOL ok;

    ok = DeviceIoControl(TcpipDriverHandle,
                         IOCTL_TCP_QUERY_INFORMATION_EX,
                         lpInputBuffer,
                         *lpdwInputBufferLength,
                         lpOutputBuffer,
                         *lpdwOutputBufferLength,
                         &bytesReturned,
                         NULL
                         );
    if (!ok) {
        error = GetLastError();
    } else {
        *lpdwOutputBufferLength = bytesReturned;
        error = ERROR_SUCCESS;
    }

quit:

    DEBUG_LEAVE(error);

    return error;
}


PRIVATE
DWORD
OpenTcpipDriverHandle(
    VOID
    )

/*++

Routine Description:

    Opens handle to TCP/IP device driver

Arguments:

    None.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DWORD error = ERROR_SUCCESS;

    if (TcpipDriverHandle == INVALID_HANDLE_VALUE) {

        OBJECT_ATTRIBUTES objectAttributes;
        IO_STATUS_BLOCK iosb;
        UNICODE_STRING string;
        NTSTATUS status;

        _I_RtlInitUnicodeString(&string, DD_TCP_DEVICE_NAME);

        InitializeObjectAttributes(&objectAttributes,
                                   &string,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL
                                   );
        status = _I_NtCreateFile(&TcpipDriverHandle,
                                 SYNCHRONIZE | GENERIC_EXECUTE,
                                 &objectAttributes,
                                 &iosb,
                                 NULL,
                                 FILE_ATTRIBUTE_NORMAL,
                                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                                 FILE_OPEN_IF,
                                 FILE_SYNCHRONOUS_IO_NONALERT,
                                 NULL,
                                 0
                                 );
        if (!NT_SUCCESS(status)) {
            error = _I_RtlNtStatusToDosError(status);
        }
    }
    return error;
}


PRIVATE
VOID
CloseTcpipDriverHandle(
    VOID
    )

/*++

Routine Description:

    Closes TCP/IP device driver handle

Arguments:

    None.

Return Value:

    None.

--*/

{
    if (TcpipDriverHandle != INVALID_HANDLE_VALUE) {
        CloseHandle(TcpipDriverHandle);
        TcpipDriverHandle = INVALID_HANDLE_VALUE;
    }
}


PRIVATE
DWORD
GetEntityList(
    OUT TDIEntityID * * lplpEntities
    )

/*++

Routine Description:

    Allocates a buffer for, and retrieves, the list of entities supported by the
    TCP/IP device driver

Arguments:

    lplpEntities    - pointer to allocated returned list of entities. Caller
                      must free

Return Value:

    UINT    - number of entities returned

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Int,
                 "GetEntityList",
                 "%#x",
                 lplpEntities
                 ));

    TCP_REQUEST_QUERY_INFORMATION_EX req;

    memset(&req, 0, sizeof(req));

    req.ID.toi_entity.tei_entity = GENERIC_ENTITY;
    req.ID.toi_entity.tei_instance = 0;
    req.ID.toi_class = INFO_CLASS_GENERIC;
    req.ID.toi_type = INFO_TYPE_PROVIDER;
    req.ID.toi_id = ENTITY_LIST_ID;

    DWORD inputLen = sizeof(req);
    DWORD outputLen = sizeof(TDIEntityID) * DEFAULT_MINIMUM_ENTITIES;
    TDIEntityID * pEntity = NULL;
    DWORD status = TDI_SUCCESS;

    //
    // this is over-engineered - its very unlikely that we'll ever get >32
    // entities returned, never mind >64K's worth
    //
    // Go round this loop a maximum of 4 times - length of list shouldn't
    // change between calls. Stops us getting stuck in infinite loop if
    // something bad happens with outputLen
    //

    for (int i = 0; i < 4; ++i) {

        DWORD previousOutputLen = outputLen;

        pEntity = (TDIEntityID *)ResizeBuffer(pEntity, outputLen, FALSE);
        if (pEntity == NULL) {
            outputLen = 0;
            break;
        }

        status = WsControl(IPPROTO_TCP,
                           WSCNTL_TCPIP_QUERY_INFO,
                           (LPVOID)&req,
                           &inputLen,
                           (LPVOID)pEntity,
                           &outputLen
                           );

        //
        // TDI_SUCCESS is returned if all data is not returned: driver
        // communicates all/partial data via outputLen
        //

        if (status == TDI_SUCCESS) {

            DEBUG_PRINT(UTIL,
                        INFO,
                        ("GENERIC_ENTITY required length = %d\n",
                        outputLen
                        ));

            if (outputLen && (outputLen <= previousOutputLen)) {
                break;
            }
        } else {
            outputLen = 0;
        }
    }

    if ((status != TDI_SUCCESS) && (pEntity != NULL)) {
        ResizeBuffer(pEntity, 0, FALSE);
    }

    DEBUG_PRINT(UTIL,
                INFO,
                ("%d entities returned in %#x\n",
                (outputLen / sizeof(TDIEntityID)),
                pEntity
                ));

    *lplpEntities = pEntity;

    DEBUG_LEAVE((UINT)(outputLen / sizeof(TDIEntityID)));

    return (UINT)(outputLen / sizeof(TDIEntityID));
}

//
// private debug functions
//

#if INET_DEBUG

PRIVATE
LPCSTR
InternetMapEntity(
    IN INT EntityId
    ) {
    switch (EntityId) {
    case CO_TL_ENTITY:
        return "CO_TL_ENTITY";

    case CL_TL_ENTITY:
        return "CL_TL_ENTITY";

    case ER_ENTITY:
        return "ER_ENTITY";

    case CO_NL_ENTITY:
        return "CO_NL_ENTITY";

    case CL_NL_ENTITY:
        return "CL_NL_ENTITY";

    case AT_ENTITY:
        return "AT_ENTITY";

    case IF_ENTITY:
        return "IF_ENTITY";

    }
    return "*** UNKNOWN ENTITY ***";
}

PRIVATE
LPCSTR
InternetMapInterface(
    IN DWORD InterfaceType
    ) {
    switch (InterfaceType) {
    case IF_TYPE_OTHER:
        return "other";

    case IF_TYPE_ETHERNET:
        return "ethernet";

    case IF_TYPE_TOKENRING:
        return "token ring";

    case IF_TYPE_FDDI:
        return "FDDI";

    case IF_TYPE_PPP:
        return "PPP";

    case IF_TYPE_LOOPBACK:
        return "loopback";
    }
    return "???";
}

PRIVATE
LPCSTR
InternetMapInterfaceOnNT5(
    IN DWORD InterfaceType
    ) {
    switch (InterfaceType) {
    case IF_TYPE_OTHER:
        return "other";

    case IF_TYPE_ETHERNET_CSMACD:
        return "ethernet";

    case IF_TYPE_ISO88025_TOKENRING:
        return "token ring";

    case IF_TYPE_FDDI:
        return "FDDI";

    case IF_TYPE_PPP:
        return "PPP";

    case IF_TYPE_SOFTWARE_LOOPBACK:
        return "loopback";

    case IF_TYPE_SLIP:
        return "SLIP";

    default:
        break;
    }
    return "???";
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5.1\autoproxy\ipinfo.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-1992          **/
/********************************************************************/
/* :ts=4 */

//** IPINFO.H - IP SNMP information definitions..
//
// This file contains all of the definitions for IP that are
// related to SNMP information gathering.

#ifndef IPINFO_INCLUDED
#define IPINFO_INCLUDED


#ifndef CTE_TYPEDEFS_DEFINED
#define CTE_TYPEDEFS_DEFINED

typedef unsigned long ulong;
typedef unsigned short ushort;
typedef unsigned char uchar;
typedef unsigned int uint;

#endif // CTE_TYPEDEFS_DEFINED


typedef struct IPSNMPInfo {
        ulong           ipsi_forwarding;
        ulong           ipsi_defaultttl;
        ulong           ipsi_inreceives;
        ulong           ipsi_inhdrerrors;
        ulong           ipsi_inaddrerrors;
        ulong           ipsi_forwdatagrams;
        ulong           ipsi_inunknownprotos;
        ulong           ipsi_indiscards;
        ulong           ipsi_indelivers;
        ulong           ipsi_outrequests;
        ulong           ipsi_routingdiscards;
        ulong           ipsi_outdiscards;
        ulong           ipsi_outnoroutes;
        ulong           ipsi_reasmtimeout;
        ulong           ipsi_reasmreqds;
        ulong           ipsi_reasmoks;
        ulong           ipsi_reasmfails;
        ulong           ipsi_fragoks;
        ulong           ipsi_fragfails;
        ulong           ipsi_fragcreates;
        ulong           ipsi_numif;
        ulong           ipsi_numaddr;
        ulong           ipsi_numroutes;
} IPSNMPInfo;

typedef struct ICMPStats {
        ulong           icmps_msgs;
        ulong           icmps_errors;
        ulong           icmps_destunreachs;
        ulong           icmps_timeexcds;
        ulong           icmps_parmprobs;
        ulong           icmps_srcquenchs;
        ulong           icmps_redirects;
        ulong           icmps_echos;
        ulong           icmps_echoreps;
        ulong           icmps_timestamps;
        ulong           icmps_timestampreps;
        ulong           icmps_addrmasks;
        ulong           icmps_addrmaskreps;
} ICMPStats;

typedef struct ICMPSNMPInfo {
        ICMPStats       icsi_instats;
        ICMPStats       icsi_outstats;
} ICMPSNMPInfo;

#define IP_FORWARDING           1
#define IP_NOT_FORWARDING       2

typedef struct IPAddrEntry {
        ulong           iae_addr;
        ulong           iae_index;
        ulong           iae_mask;
        ulong           iae_bcastaddr;
        ulong           iae_reasmsize;
        ushort          iae_context;
        ushort          iae_pad;
} IPAddrEntry;

typedef struct IPRouteEntry {
        ulong           ire_dest;
        ulong           ire_index;
        ulong           ire_metric1;
        ulong           ire_metric2;
        ulong           ire_metric3;
        ulong           ire_metric4;
        ulong           ire_nexthop;
        ulong           ire_type;
        ulong           ire_proto;
        ulong           ire_age;
        ulong           ire_mask;
        ulong           ire_metric5;
        ulong           ire_context;
} IPRouteEntry;

typedef struct IPRouteEntry95 {
        ulong           ire_dest;
        ulong           ire_index;
        ulong           ire_metric1;
        ulong           ire_metric2;
        ulong           ire_metric3;
        ulong           ire_metric4;
        ulong           ire_nexthop;
        ulong           ire_type;
        ulong           ire_proto;
        ulong           ire_age;
        ulong           ire_mask;
        ulong           ire_metric5;
} IPRouteEntry95;

typedef struct AddrXlatInfo {
        ulong           axi_count;
        ulong           axi_index;
} AddrXlatInfo;

#define IRE_TYPE_OTHER          1
#define IRE_TYPE_INVALID        2
#define IRE_TYPE_DIRECT         3
#define IRE_TYPE_INDIRECT       4

#define IRE_PROTO_OTHER         1
#define IRE_PROTO_LOCAL         2
#define IRE_PROTO_NETMGMT       3
#define IRE_PROTO_ICMP          4
#define IRE_PROTO_EGP           5
#define IRE_PROTO_GGP           6
#define IRE_PROTO_HELLO         7
#define IRE_PROTO_RIP           8
#define IRE_PROTO_IS_IS         9
#define IRE_PROTO_ES_IS         10
#define IRE_PROTO_CISCO         11
#define IRE_PROTO_BBN           12
#define IRE_PROTO_OSPF          13
#define IRE_PROTO_BGP           14

#define IRE_METRIC_UNUSED       0xffffffff

#define IP_MIB_STATS_ID                                 1
#define ICMP_MIB_STATS_ID                               1

#define AT_MIB_ADDRXLAT_INFO_ID                 1
#define AT_MIB_ADDRXLAT_ENTRY_ID                0x101

#define IP_MIB_RTTABLE_ENTRY_ID                 0x101
#define IP_MIB_ADDRTABLE_ENTRY_ID               0x102

#define IP_INTFC_FLAG_P2P   1

typedef struct IPInterfaceInfo {
    ulong       iii_flags;
    ulong       iii_mtu;
    ulong       iii_speed;
    ulong       iii_addrlength;
    uchar       iii_addr[1];
} IPInterfaceInfo;

#define IP_INTFC_INFO_ID                0x103

#endif // IPINFO_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5.1\autoproxy\jsproxy.h ===
#ifndef __JSPROXY_H__
#define __JSPROXY_H__

#include <windows.h>
#include <olectl.h>
#include "utils.h"
#include "regexp.h"

#define VAL_isPlainHostName			0x01f9
#define VAL_dnsDomainIs				0x01f8
#define VAL_localHostOrDomainIs		0x020b
#define VAL_isResolvable			0x0206
#define VAL_isInNet					0x01e1
#define VAL_dnsResolve				0x01fc
#define VAL_myIpAddress				0x01e0
#define VAL_dnsDomainLevels			0x01f8
#define VAL_shExpMatch				0x0208
#define VAL_weekdayRange			0x0210
#define VAL_dateRange				0x01f0
#define VAL_timeRange				0x0201
#define VAL_alert				0x0218

#define DISPID_isPlainHostName		0x0001
#define DISPID_dnsDomainIs			0x0002
#define DISPID_localHostOrDomainIs	0x0003
#define DISPID_isResolvable			0x0004
#define DISPID_isInNet				0x0005
#define DISPID_dnsResolve			0x0006
#define DISPID_myIpAddress			0x0007
#define DISPID_dnsDomainLevels		0x0008
#define DISPID_shExpMatch			0x0009
#define DISPID_weekdayRange			0x000a
#define DISPID_dateRange			0x000b
#define DISPID_timeRange			0x000c
#define DISPID_alert				0x000d

/************************************************************************************************/
// This class implements the Dispatch interface that will allow the script engine to call the 
// auto-proxy configuration functions.  This interface does not have a typelib and does not provide type
// info.
class CJSProxy : public IDispatch
{

public:

	CJSProxy();
	~CJSProxy();
	// IUnknown Methods
	STDMETHODIMP QueryInterface(REFIID riid, PVOID *ppvObject)
	{

		if (riid == IID_IUnknown || 
            riid == IID_IDispatch)
		{
			*ppvObject = (LPVOID)(LPUNKNOWN)this;
            AddRef();
			return S_OK;
		}
		else
		{
			if (riid == IID_IDispatch)
			{
				*ppvObject = (LPVOID)(IDispatch*)this;
                AddRef();
				return S_OK;
			}
			else
			{
				*ppvObject = 0;
				return E_NOINTERFACE;
			}
		}

	}

	STDMETHODIMP_(ULONG) AddRef()
	{
		return ++m_refCount;
	}

	STDMETHODIMP_(ULONG) Release()
	{
		if (--m_refCount)
			return m_refCount;

		delete this;
		return 0;
	}

	// IDispatch Methods
    STDMETHODIMP GetTypeInfoCount(UINT* pctinfo)
	{
		*pctinfo = 0;
		return S_OK;
	}

    STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
	{
        UNREFERENCED_PARAMETER(itinfo);
        UNREFERENCED_PARAMETER(lcid);
        UNREFERENCED_PARAMETER(pptinfo);
		return TYPE_E_ELEMENTNOTFOUND;
	}

    STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR** rgszNames,UINT cNames, LCID lcid, DISPID FAR* rgdispid);

    STDMETHODIMP Invoke(
					DISPID dispidMember,
					REFIID riid,
					LCID lcid,
					WORD wFlags,
					DISPPARAMS* pdispparams,
					VARIANT* pvarResult,
					EXCEPINFO* pexcepinfo,
					UINT* puArgErr);

	//  JScript Auto-Proxy config functions.
	STDMETHODIMP isPlainHostName(BSTR host, VARIANT* retval);
	STDMETHODIMP dnsDomainIs(BSTR host,BSTR domain, VARIANT* retval);
	STDMETHODIMP localHostOrDomainIs(BSTR host,BSTR hostdom, VARIANT* retval);
	STDMETHODIMP isResolvable(BSTR host, VARIANT* retval);
	STDMETHODIMP isInNet(BSTR host, BSTR pattern, BSTR mask, VARIANT* retval);
	STDMETHODIMP dnsResolve(BSTR host, VARIANT* retval);
	STDMETHODIMP myIpAddress(VARIANT* retval);
	STDMETHODIMP dnsDomainLevels(BSTR host, VARIANT* retval);
	STDMETHODIMP shExpMatch(BSTR str, BSTR shexp, VARIANT* retval);
	STDMETHODIMP alert(BSTR message, VARIANT* retval);

	// These are to do last!!!.
	STDMETHODIMP weekdayRange(BSTR wd1, BSTR wd2, BSTR gmt, VARIANT* retval);
	STDMETHODIMP dateRange(long day, BSTR month, BSTR gmt, VARIANT* retval);
	STDMETHODIMP timeRange(long hour, long min, long sec, BSTR gmt, VARIANT* retval);
	//	ProxyConfig.bindings 

	STDMETHODIMP Init(AUTO_PROXY_HELPER_APIS* pAPHA);
	STDMETHODIMP DeInit();
	
	// JScript private members
private:
	long					m_refCount;
	BOOL					m_fDestroyable;
	BOOL					m_fInitialized;
	AUTO_PROXY_HELPER_APIS*	m_pCallout;
	LPCWSTR					m_strings[13];
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5.1\autoproxy\llinfo.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-1992          **/
/********************************************************************/
/* :ts=4 */

//** LLINFO.H - Lower layer SNMP information definitions.
//
// This file contains all of the definitions for SNMP information collected
// by layers below IP.

#ifndef	LLINFO_INCLUDED
#define	LLINFO_INCLUDED


#ifndef CTE_TYPEDEFS_DEFINED
#define CTE_TYPEDEFS_DEFINED

typedef unsigned long ulong;
typedef unsigned short ushort;
typedef unsigned char uchar;
typedef unsigned int uint;

#endif // CTE_TYPEDEFS_DEFINED


#define	IF_MIB_STATS_ID		1

#define	MAX_PHYSADDR_SIZE	8

typedef struct IPNetToMediaEntry {
	ulong			inme_index;
	ulong			inme_physaddrlen;
	uchar			inme_physaddr[MAX_PHYSADDR_SIZE];
	ulong			inme_addr;
	ulong			inme_type;
} IPNetToMediaEntry;

#define	INME_TYPE_OTHER			1
#define	INME_TYPE_INVALID		2
#define	INME_TYPE_DYNAMIC		3
#define	INME_TYPE_STATIC		4

#define	MAX_IFDESCR_LEN			256

#define	IFE_FIXED_SIZE	offsetof(struct IFEntry, if_descr)

typedef struct IFEntry {
	ulong			if_index;
	ulong			if_type;
	ulong			if_mtu;
	ulong			if_speed;
	ulong			if_physaddrlen;
	uchar			if_physaddr[MAX_PHYSADDR_SIZE];
	ulong			if_adminstatus;
	ulong			if_operstatus;
	ulong			if_lastchange;
	ulong			if_inoctets;
	ulong			if_inucastpkts;
	ulong			if_innucastpkts;
	ulong			if_indiscards;
	ulong			if_inerrors;
	ulong			if_inunknownprotos;
	ulong			if_outoctets;
	ulong			if_outucastpkts;
	ulong			if_outnucastpkts;
	ulong			if_outdiscards;
	ulong			if_outerrors;
	ulong			if_outqlen;
	ulong			if_descrlen;
	uchar			if_descr[1];
} IFEntry;

#define	IF_TYPE_OTHER	  	1
#define	IF_TYPE_ETHERNET	6
#define	IF_TYPE_TOKENRING	9
#define	IF_TYPE_FDDI		15
#define	IF_TYPE_PPP			23
#define	IF_TYPE_LOOPBACK	24
#define	IF_TYPE_SLIP		28

#define	IF_STATUS_UP		1
#define	IF_STATUS_DOWN		2
#define	IF_STATUS_TESTING	3


#endif // LLINFO_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5.1\autoproxy\optchg.h ===
//================================================================================
// Copyright (c) 1997 Microsoft Corporation
// Author: RameshV
// Description: handles the noticiations and other mechanisms for parameter
//      changes (options )
//================================================================================

#ifndef OPTCHG_H_INCLUDED
#define OPTCHG_H_INCLUDED

//================================================================================
// exported APIS
//================================================================================
DWORD                                             // win32 status
DhcpAddParamChangeRequest(                        // add a new param change notification request
    IN      LPWSTR                 AdapterName,   // for this adapter, can be NULL
    IN      LPBYTE                 ClassId,       // what class id does this belong to?
    IN      DWORD                  ClassIdLength, // how big is this class id?
    IN      LPBYTE                 OptList,       // this is the list of options of interest
    IN      DWORD                  OptListSize,   // this is the # of bytes of above
    IN      BOOL                   IsVendor,      // is this vendor specific?
    IN      DWORD                  ProcId,        // which is the calling process?
    IN      DWORD                  Descriptor,    // what is the unique descriptor in this process?
    IN      HANDLE                 Handle         // what is the handle in the calling process space?
);

DWORD                                             // win32 status
DhcpDelParamChangeRequest(                        // delete a particular request
    IN      DWORD                  ProcId,        // the process id of the caller
    IN      HANDLE                 Handle         // the handle as used by the calling process
);

DWORD                                             // win32 status
DhcpMarkParamChangeRequests(                      // find all params that are affected and mark then as pending
    IN      LPTSTR                 AdapterName,   // adapter of relevance
    IN      BYTE                   OptionId,      // the option id itself
    IN      BOOL                   IsVendor,      // is this vendor specific
    IN      LPBYTE                 ClassId        // which class --> this must be something that has been ADD-CLASSED
);

typedef DWORD (*DHCP_NOTIFY_FUNC)(                // this is the type of the fucntion that actually notifies clients of option change
    IN      DWORD                  ProcId,        // <ProcId + Descriptor> make a unique key used for finding the event
    IN      DWORD                  Descriptor     // --- on Win98, only Descriptor is really needed.
);                                                // if return value is NOT error success, we delete this request

DWORD                                             // win32 status
DhcpNotifyMarkedParamChangeRequests(              // notify pending param change requests
    IN      DHCP_NOTIFY_FUNC       NotifyHandler  // call this function for each unique id that is present
);


DWORD                                             // win32 status
DhcpNotifyClientOnParamChange(                    // notify clients
    IN      DWORD                  ProcId,        // which process called this
    IN      DWORD                  Descriptor     // unique descriptor for that process
);

DWORD                                             // win32 status
DhcpInitializeParamChangeRequests(                // initialize everything in this file
    VOID
);

VOID
DhcpCleanupParamChangeRequests(                   // unwind this module
    VOID
);

DWORD                                             // win32 status
DhcpAddParamRequestChangeRequestList(             // add to the request list the list of params registered for notifications
    IN      LPWSTR                 AdapterName,   // which adatper is this request list being requested for?
    IN      LPBYTE                 Buffer,        // buffer to add options to
    IN OUT  LPDWORD                Size,          // in: existing filled up size, out: total size filled up
    IN      LPBYTE                 ClassName,     // ClassId
    IN      DWORD                  ClassLen       // size of ClassId in bytes
);

#endif OPTCHG_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5.1\autoproxy\ntddtcp.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    ntddtcp.h

Abstract:

    This header file defines constants and types for accessing the NT
    TCP driver.

Author:

    Mike Massa (mikemas)    August 13, 1993

Revision History:

--*/

#ifndef _NTDDTCP_
#define _NTDDTCP_

//
// Device Name - this string is the name of the device.  It is the name
// that should be passed to NtCreateFile when accessing the device.
//
#define DD_TCP_DEVICE_NAME      L"\\Device\\Tcp"
#define DD_UDP_DEVICE_NAME      L"\\Device\\Udp"
#define DD_RAW_IP_DEVICE_NAME   L"\\Device\\RawIp"


//
// Security Filter Support
//
// Security filters provide a mechanism by which the transport protocol
// traffic accepted on IP interfaces may be controlled. Security filtering
// is globally enabled or disabled for all IP interfaces and transports.
// If filtering is enabled, incoming traffic is filtered based on registered
// {interface, protocol, transport value} tuples. The tuples specify
// permissible traffic. All other values will be rejected. For UDP datagrams
// and TCP connections, the transport value is the port number. For RawIP
// datagrams, the transport value is the IP protocol number. An entry exists
// in the filter database for all active interfaces and protocols in the
// system.
//
// The following ioctls may be used to access the security filter
// database. The ioctls may be issued on any TCP/IP device object. All of them
// require Administrator privilege. These ioctls do not update the registry
// parameters used to initialize security filtering when an interface is
// installed.
//
// The TCP_QUERY_SECURITY_FILTER_STATUS ioctl returns the current status of
// security filtering - enabled or disabled.
//
// The TCP_SET_SECURITY_FILTER_STATUS ioctl modifies the status of security
// filtering. Changing the filtering status does not change the contents of
// the filter database.
//
// The following ioctls manipulate the filter database. They operate the same
// whether security filtering is enabled or disabled. If filtering is disabled,
// any changes will take effect only when filtering is enabled.
//
// The TCP_ADD_SECURITY_FILTER ioctl registers an {Interface, Protocol, Value}
// tuple. The TCP_DELETE_SECURITY_FILTER ioctl deregisters an
// {Interface, Protocol, Value} tuple. The TCP_ENUMERATE_SECURITY_FILTER ioctl
// returns the list of {Interface, Protocol, Value} filters currently
// registered.
//
// Each of these ioctls takes an {Interface, Protocol, Value} tuple as an input
// parameter. Zero is a wildcard value. If the Interface or Protocol elements
// are zero, the operation applies to all interfaces or protocols, as
// appropriate. The meaning of a zero Value element depends on the ioctl.
// For an ADD, a zero Value causes all values to be permissible. For a DELETE,
// a zero Value causes all all values to be rejected. In both cases, any
// previously registered values are purged from the database. For an
// ENUMERATE, a zero Value just causes all registered values to be enumerated,
// as opposed to a specific value.
//
// For all ioctls, a return code of STATUS_INVALID_ADDRESS indicates that
// the IP address submitted in the input buffer does not correspond to
// an interface which exists in the system. A code of
// STATUS_INVALID_PARAMETER possibly indicates that the Protocol number
// submitted in the input buffer does not correspond to a transport protocol
// available in the system.
//

//
// Structures used in Security Filter IOCTLs.
//

//
// Structure contained in the input buffer of
// TCP_SET_SECURITY_FILTER_STATUS ioctls and the output buffer of
// TCP_QUERY_SECURITY_FILTER_STATUS ioctls.
//
struct tcp_security_filter_status {
    ULONG  FilteringEnabled;   // FALSE if filtering is (to be) disabled.
};                             // Any other value indicates that filtering
                               // is (to be) enabled.

typedef struct tcp_security_filter_status
                    TCP_SECURITY_FILTER_STATUS,
                   *PTCP_SECURITY_FILTER_STATUS;


//
// The TCPSecurityFilterEntry structure, defined in tcpinfo.h, is contained in
// the input buffer of TCP_[ADD|DELETE|ENUMERATE]_SECURITY_FILTER ioctls.
//

//
// The TCPSecurityFilterEnum structure, defined in tcpinfo.h, is  contained
// in the output buffer of TCP_ENUMERATE_SECURITY_FILTER ioctls. The output
// buffer passed in the ioctl must be large enough to contain at least this
// structure or the call will fail. The structure is followed immediately in
// the buffer by an array of zero or more TCPSecurityFilterEntry structures.
// The number of TCPSecurityFilterEntry structures is specified by the
// tfe_entries_returned field of the TCPSecurityFilterEnum.
//

//
// TCP/UDP/RawIP IOCTL code definitions
//

#define FSCTL_TCP_BASE     FILE_DEVICE_NETWORK

#define _TCP_CTL_CODE(function, method, access) \
            CTL_CODE(FSCTL_TCP_BASE, function, method, access)

#define IOCTL_TCP_QUERY_INFORMATION_EX  \
            _TCP_CTL_CODE(0, METHOD_NEITHER, FILE_ANY_ACCESS)

#define IOCTL_TCP_SET_INFORMATION_EX  \
            _TCP_CTL_CODE(1, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_TCP_QUERY_SECURITY_FILTER_STATUS  \
            _TCP_CTL_CODE(2, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_TCP_SET_SECURITY_FILTER_STATUS  \
            _TCP_CTL_CODE(3, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_TCP_ADD_SECURITY_FILTER  \
            _TCP_CTL_CODE(4, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_TCP_DELETE_SECURITY_FILTER  \
            _TCP_CTL_CODE(5, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_TCP_ENUMERATE_SECURITY_FILTER  \
            _TCP_CTL_CODE(6, METHOD_BUFFERED, FILE_WRITE_ACCESS)


#endif  // ifndef _NTDDTCP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5.1\autoproxy\options.h ===
//================================================================================
//  Copyright (C) Microsoft Corporation 1997.
//  Author: RameshV
//  Date: 09-Sep-97 06:20
//  Description: Manages the class-id and options information
//================================================================================

#ifndef OPTIONS_H
#define OPTIONS_H

#define MAX_DATA_LEN               255            // atmost 255 bytes for an option

typedef struct _DHCP_CLASSES {                    // common pool of class names
    LIST_ENTRY                     ClassList;     // global list of classes
    LPBYTE                         ClassName;     // name of the class
    DWORD                          ClassLen;      // # of bytes in class name
    DWORD                          RefCount;      // # of references to this
} DHCP_CLASSES, *LPDHCP_CLASSES, *PDHCP_CLASSES;

typedef struct _DHCP_OPTION  {                    // list of options
    LIST_ENTRY                     OptionList;    // the fwd/back ptrs
    BYTE                           OptionId;      // the option value
    BOOL                           IsVendor;      // is this vendor specific
    LPBYTE                         ClassName;     // the class of this option
    DWORD                          ClassLen;      // the length of above option
    time_t                         ExpiryTime;    // when this option expires
    LPBYTE                         Data;          // the data value for this option
    DWORD                          DataLen;       // the # of bytes of above
} DHCP_OPTION , *LPDHCP_OPTION , *PDHCP_OPTION ;

typedef struct _DHCP_OPTION_DEF {
    LIST_ENTRY                     OptionDefList; // list of option definitions
    BYTE                           OptionId;      // the option id
    BOOL                           IsVendor;      // is this vendor specific?
    LPBYTE                         ClassName;     // the class this belongs to
    DWORD                          ClassLen;      // the size of above in bytes

    LPWSTR                         RegSendLoc;    // where is the info about sending this out
    LPWSTR                         RegSaveLoc;    // where is this option going to be stored?
    DWORD                          RegValueType;  // as what value should this be stored?
} DHCP_OPTION_DEF, *LPDHCP_OPTION_DEF, *PDHCP_OPTION_DEF;


//================================================================================
//  exported functions classes
//================================================================================

//--------------------------------------------------------------------------------
// In all of the following functions, ClassesList is unprotected within the fn.
// Caller has to take a lock on it.
//--------------------------------------------------------------------------------
LPBYTE                                            // data bytes, or NULL (no mem)
DhcpAddClass(                                     // add a new class
    IN OUT  PLIST_ENTRY            ClassesList,   // list to add to
    IN      LPBYTE                 Data,          // input class name
    IN      DWORD                  Len            // # of bytes of above
);  // Add the new class into the list or bump up ref count if already there

DWORD                                             // status (FILE_NOT_FOUND => no such class)
DhcpDelClass(                                     // de-refernce a class
    IN OUT  PLIST_ENTRY            ClassesList,   // the list to delete off
    IN      LPBYTE                 Data,          // the data ptr
    IN      DWORD                  Len            // the # of bytes of above
);  // decrease refcount in the list and if becomes zero, free the struct

VOID                                              // always succeeds
DhcpFreeAllClasses(                               // free each elt of the list
    IN OUT  PLIST_ENTRY            ClassesList    // input list of classes
);  // free every class in the list

//--------------------------------------------------------------------------------
// In all the following functions, OptionsList is unprotected within the fn.
// Caller has to take a lock on it.
//--------------------------------------------------------------------------------

PDHCP_OPTION                                      // the reqd structure or NULL
DhcpFindOption(                                   // find a specific option
    IN OUT  PLIST_ENTRY            OptionsList,   // the list of options to search
    IN      BYTE                   OptionId,      // the option id to search for
    IN      BOOL                   IsVendor,      // is it vendor specific?
    IN      LPBYTE                 ClassName,     // is there a class associated?
    IN      DWORD                  ClassLen       // # of bytes of above parameter
);  // search for the required option in the list, return NULL if not found

DWORD                                             // status or ERROR_FILE_NOT_FOUND
DhcpDelOption(                                    // remove a particular option
    IN      PDHCP_OPTION           Option2Delete  // delete this option
);  // delete an existing option in the list, and free up space used

DWORD                                             // status
DhcpAddOption(                                    // add a new option
    IN OUT  PLIST_ENTRY            OptionsList,   // list to add to
    IN      BYTE                   OptionId,      // option id to add
    IN      BOOL                   IsVendor,      // is it vendor specific?
    IN      LPBYTE                 ClassName,     // what is the class?
    IN      DWORD                  ClassLen,      // size of above in bytes
    IN      LPBYTE                 Data,          // data for this option
    IN      DWORD                  DataLen,       // # of bytes of above
    IN      time_t                 ExpiryTime     // when the option expires
);  // replace or add new option to the list.  fail if not enough memory

VOID                                              // always succeeds
DhcpFreeAllOptions(                               // frees all the options
    IN OUT  PLIST_ENTRY            OptionsList    // input list of options
);  // free every option in the list

time_t                                            // 0 || time for next expiry (absolute)
DhcpGetExpiredOptions(                            // delete all expired options
    IN OUT  PLIST_ENTRY            OptionsList,   // list to search frm
    OUT     PLIST_ENTRY            ExpiredOptions // o/p list of expired options
);  // move expired options between lists and return timer. 0 => switch off timer.

//--------------------------------------------------------------------------------
//  In all the following functions, OptionsDefList is unprotected.  Caller has
//  to take a lock on it.
//--------------------------------------------------------------------------------

DWORD                                             // status
DhcpAddOptionDef(                                 // add a new option definition
    IN OUT  PLIST_ENTRY            OptionDefList, // input list of options to add to
    IN      BYTE                   OptionId,      // option to add
    IN      BOOL                   IsVendor,      // is it vendor specific
    IN      LPBYTE                 ClassName,     // name of class it belongs to
    IN      DWORD                  ClassLen,      // the size of above in bytes
    IN      LPWSTR                 RegSendLoc,    // where to get info about sending this out
    IN      LPWSTR                 RegSaveLoc,    // where to get info about saving this
    IN      DWORD                  ValueType      // what is the type when saving it?
);

PDHCP_OPTION_DEF                                  // NULL, or requested option def
DhcpFindOptionDef(                                // search for a particular option
    IN      PLIST_ENTRY            OptionDefList, // list to search in
    IN      BYTE                   OptionId,      // the option id to search for
    IN      BOOL                   IsVendor,      // is it vendor specific
    IN      LPBYTE                 ClassName,     // the class, if one exists
    IN      DWORD                  ClassLen       // # of bytes of class name
);

DWORD                                             // status
DhcpDelOptionDef(                                 // delete a particular option def
    IN      PLIST_ENTRY            OptionDefList, // list to delete from
    IN      BYTE                   OptionId,      // the option id to delete
    IN      BOOL                   IsVendor,      // is it vendor specific
    IN      LPBYTE                 ClassName,     // the class, if one exists
    IN      DWORD                  ClassLen       // # of bytes of class name
);

VOID
DhcpFreeAllOptionDefs(                            // free each element of a list
    IN OUT  PLIST_ENTRY            OptionDefList, // the list to free
    IN OUT  PLIST_ENTRY            ClassesList    // classes to de-ref off
);

BOOL                                              // TRUE==>found..
DhcpOptionsFindDomain(                            // find the domain name option values
    IN OUT  PDHCP_CONTEXT          DhcpContext,   // for this adapter
    OUT     LPBYTE                *Data,          // fill this ptr up
    OUT     LPDWORD                DataLen
);

#endif  OPTIONS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5.1\autoproxy\nameser.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    nameser.h

Abstract:

    Definitions for the DNS resolver and nameserver.

Author:

    Mike Massa (mikemas)           Jan 31, 1992

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     01-31-92     created

Notes:

--*/

/******************************************************************
 *
 *  SpiderTCP BIND
 *
 *  Copyright 1990  Spider Systems Limited
 *
 *  NAMESER.H
 *
 ******************************************************************/

/*
 *   /usr/projects/tcp/SCCS.rel3/rel/src/include/arpa/0/s.nameser.h
 *  @(#)nameser.h   5.3
 *
 *  Last delta created  14:06:04 3/4/91
 *  This file extracted 11:19:28 3/8/91
 *
 *  Modifications:
 *
 *      GSS 20 Jul 90   New File
 */

/*
 * Copyright (c) 1983, 1989 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that: (1) source distributions retain this entire copyright
 * notice and comment, and (2) distributions including binaries display
 * the following acknowledgement:  ``This product includes software
 * developed by the University of California, Berkeley and its contributors''
 * in the documentation or other materials provided with the distribution
 * and in all advertising materials mentioning features or use of this
 * software. Neither the name of the University nor the names of its
 * contributors may be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 *  @(#)nameser.h   5.24 (Berkeley) 6/1/90
 */

#ifndef _NAMESER_INCLUDED
#define _NAMESER_INCLUDED


/*
 * Define constants based on rfc883
 */
#define PACKETSZ    512     /* maximum packet size */
#define MAXDNAME    256     /* maximum domain name */
#define MAXCDNAME   255     /* maximum compressed domain name */
#define MAXLABEL    63      /* maximum length of domain label */
    /* Number of bytes of fixed size data in query structure */
#define QFIXEDSZ    4
    /* number of bytes of fixed size data in resource record */
#define RRFIXEDSZ   10

/*
 * Internet nameserver port number
 */
#define NAMESERVER_PORT 53

/*
 * Currently defined opcodes
 */
#define QUERY       0x0     /* standard query */
#define IQUERY      0x1     /* inverse query */
#define STATUS      0x2     /* nameserver status query */
/*#define xxx       0x3     /* 0x3 reserved */
    /* non standard */
#define UPDATEA     0x9     /* add resource record */
#define UPDATED     0xa     /* delete a specific resource record */
#define UPDATEDA    0xb     /* delete all nemed resource record */
#define UPDATEM     0xc     /* modify a specific resource record */
#define UPDATEMA    0xd     /* modify all named resource record */

#define ZONEINIT    0xe     /* initial zone transfer */
#define ZONEREF     0xf     /* incremental zone referesh */

/*
 * Currently defined response codes
 */
#ifndef NOERROR
#define NOERROR     0       /* no error */
#endif
#define FORMERR     1       /* format error */
#define SERVFAIL    2       /* server failure */
#define NXDOMAIN    3       /* non existent domain */
#define NOTIMP      4       /* not implemented */
#define REFUSED     5       /* query refused */
    /* non standard */
#define NOCHANGE    0xf     /* update failed to change db */

/*
 * Type values for resources and queries
 */
#define T_A     1       /* host address */
#define T_NS        2       /* authoritative server */
#define T_MD        3       /* mail destination */
#define T_MF        4       /* mail forwarder */
#define T_CNAME     5       /* connonical name */
#define T_SOA       6       /* start of authority zone */
#define T_MB        7       /* mailbox domain name */
#define T_MG        8       /* mail group member */
#define T_MR        9       /* mail rename name */
#define T_NULL      10      /* null resource record */
#define T_WKS       11      /* well known service */
#define T_PTR       12      /* domain name pointer */
#define T_HINFO     13      /* host information */
#define T_MINFO     14      /* mailbox information */
#define T_MX        15      /* mail routing information */
#define T_TXT       16      /* text strings */
#define T_AFSDB     18      /* AFS database servers */
    /* non standard */
#define T_UINFO     100     /* user (finger) information */
#define T_UID       101     /* user ID */
#define T_GID       102     /* group ID */
#define T_UNSPEC    103     /* Unspecified format (binary data) */
    /* Query type values which do not appear in resource records */
#define T_AXFR      252     /* transfer zone of authority */
#define T_MAILB     253     /* transfer mailbox records */
#define T_MAILA     254     /* transfer mail agent records */
#define T_ANY       255     /* wildcard match */

/*
 * Values for class field
 */

#define C_IN        1       /* the arpa internet */
#define C_CHAOS     3       /* for chaos net at MIT */
#define C_HS        4       /* for Hesiod name server at MIT */
    /* Query class values which do not appear in resource records */
#define C_ANY       255     /* wildcard match */

/*
 * Status return codes for T_UNSPEC conversion routines
 */
#define CONV_SUCCESS 0
#define CONV_OVERFLOW -1
#define CONV_BADFMT -2
#define CONV_BADCKSUM -3
#define CONV_BADBUFLEN -4

#ifndef BYTE_ORDER
#define LITTLE_ENDIAN   1234    /* least-significant byte first (vax) */
#define BIG_ENDIAN  4321    /* most-significant byte first (IBM, net) */
#define PDP_ENDIAN  3412    /* LSB first in word, MSW first in long (pdp) */

#if defined(vax) || defined(ns32000) || defined(sun386) || defined(MIPSEL) || \
    defined(BIT_ZERO_ON_RIGHT)
#define BYTE_ORDER  LITTLE_ENDIAN

#endif
#if defined(sel) || defined(pyr) || defined(mc68000) || defined(sparc) || \
    defined(is68k) || defined(tahoe) || defined(ibm032) || defined(ibm370) || \
    defined(MIPSEB) || defined(ux10) || defined (BIT_ZERO_ON_LEFT)
#define BYTE_ORDER  BIG_ENDIAN
#endif
#ifndef BYTE_ORDER      /* still not defined */
#if defined(u3b2) || defined(m68k)
#define BYTE_ORDER  BIG_ENDIAN
#endif
#if defined(i286) || defined(i386) || defined(_MIPS_) || defined(_ALPHA_) || defined(_PPC_)
#define BYTE_ORDER  LITTLE_ENDIAN
#endif
#endif /* ~BYTE_ORDER */
#endif /* BYTE_ORDER */

#ifndef BYTE_ORDER
    /* you must determine what the correct bit order is for your compiler */
    UNDEFINED_BIT_ORDER;
#endif
/*
 * Structure for query header, the order of the fields is machine and
 * compiler dependent, in our case, the bits within a byte are assignd
 * least significant first, while the order of transmition is most
 * significant first.  This requires a somewhat confusing rearrangement.
 */

typedef struct {
    unsigned short  id;     /* query identification number */
#if BYTE_ORDER == BIG_ENDIAN
            /* fields in third byte */
    unsigned char   qr:1;       /* response flag */
    unsigned char   opcode:4;   /* purpose of message */
    unsigned char   aa:1;       /* authoritive answer */
    unsigned char   tc:1;       /* truncated message */
    unsigned char   rd:1;       /* recursion desired */
            /* fields in fourth byte */
    unsigned char   ra:1;       /* recursion available */
    unsigned char   pr:1;       /* primary server required (non standard) */
    unsigned char   unused:2;   /* unused bits */
    unsigned char   rcode:4;    /* response code */
#endif
#if BYTE_ORDER == LITTLE_ENDIAN || BYTE_ORDER == PDP_ENDIAN
            /* fields in third byte */
    unsigned char   rd:1;       /* recursion desired */
    unsigned char   tc:1;       /* truncated message */
    unsigned char   aa:1;       /* authoritive answer */
    unsigned char   opcode:4;   /* purpose of message */
    unsigned char   qr:1;       /* response flag */
            /* fields in fourth byte */
    unsigned char   rcode:4;    /* response code */
    unsigned char   unused:2;   /* unused bits */
    unsigned char   pr:1;       /* primary server required (non standard) */
    unsigned char   ra:1;       /* recursion available */
#endif
            /* remaining bytes */
    unsigned short  qdcount;    /* number of question entries */
    unsigned short  ancount;    /* number of answer entries */
    unsigned short  nscount;    /* number of authority entries */
    unsigned short  arcount;    /* number of resource entries */
} HEADER;

/*
 * Defines for handling compressed domain names
 */
#define INDIR_MASK  0xc0

/*
 * Structure for passing resource records around.
 */
struct rrec {
    short           r_zone;         /* zone number */
    short           r_class;        /* class number */
    short           r_type;         /* type number */
    unsigned long   r_ttl;          /* time to live */
    int         r_size;         /* size of data area */
    char           *r_data;             /* pointer to data */
};

extern  unsigned short  _getshort(char *);
extern  unsigned long   _getlong(char *);

/*
 * Inline versions of get/put short/long.
 * Pointer is advanced; we assume that both arguments
 * are lvalues and will already be in registers.
 * cp MUST be unsigned char *.
 */
#define GETSHORT(s, cp) { \
    (s) = *(cp)++ << 8; \
    (s) |= *(cp)++; \
}

#define GETLONG(l, cp) { \
    (l) = *(cp)++ << 8; \
    (l) |= *(cp)++; (l) <<= 8; \
    (l) |= *(cp)++; (l) <<= 8; \
    (l) |= *(cp)++; \
}


#define PUTSHORT(s, cp) { \
    *(cp)++ = (s) >> 8; \
    *(cp)++ = (s); \
}

/*
 * Warning: PUTLONG destroys its first argument.
 */
#define PUTLONG(l, cp) { \
    (cp)[3] = l; \
    (cp)[2] = (l >>= 8); \
    (cp)[1] = (l >>= 8); \
    (cp)[0] = l >> 8; \
    (cp) += sizeof(unsigned long); \
}

#endif  // _NAMESER_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5.1\autoproxy\optreg.cxx ===
//--------------------------------------------------------------------------------
// Copyright (C) Micorosoft Confidential 1997
// Author: RameshV
// Description: Option related registry handling -- common between NT and VxD
//--------------------------------------------------------------------------------

#include <wininetp.h>
#include "aproxp.h"

#ifndef  OPTREG_H
#define  OPTREG_H

//--------------------------------------------------------------------------------
// function definitions
//--------------------------------------------------------------------------------

POPTION                                           // option from which more appends can occur
DhcpAppendSendOptions(                            // append all configured options
    IN OUT  PDHCP_CONTEXT          DhcpContext,   // this is the context to append for
    IN      PLIST_ENTRY            SendOptionsList,
    IN      LPBYTE                 ClassName,     // current class
    IN      DWORD                  ClassLen,      // len of above in bytes
    IN      LPBYTE                 BufStart,      // start of buffer
    IN      LPBYTE                 BufEnd,        // how far can we go in this buffer
    IN OUT  LPBYTE                 SentOptions,   // BoolArray[OPTION_END+1] to avoid repeating options
    IN OUT  LPBYTE                 VSentOptions,  // to avoid repeating vendor specific options
    IN OUT  LPBYTE                 VendorOpt,     // Buffer[OPTION_END+1] Holding Vendor specific options
    OUT     LPDWORD                VendorOptLen   // the # of bytes filled into that
);

DWORD                                             // status
DhcpDestroyOptionsList(                           // destroy a list of options, freeing up memory
    IN OUT  PLIST_ENTRY            OptionsList,   // this is the list of options to destroy
    IN      PLIST_ENTRY            ClassesList    // this is where to remove classes off
);

DWORD                                             // win32 status
DhcpClearAllOptions(                              // remove all turds from off registry
    IN OUT  PDHCP_CONTEXT          DhcpContext    // the context to clear for
);


#endif OPTREG_H

// internal private function that takes the lock on OPTIONS_LIST

DWORD                                             // status
DhcpRegClearOptDefs(                              // clear all standard options
    IN      LPTSTR                 AdapterName    // clear for this adapter
);


//
// options related lists
//


LIST_ENTRY DhcpGlobalRecvFromList;
LPSTR   DhcpGlobalClientClassInfo = NULL;


LPBYTE                                            // ptr to buf loc where more appends can occur
DhcpAppendParamRequestList(                       // append the param request list option
    IN      PDHCP_CONTEXT          DhcpContext,   // the context to append for
    IN      PLIST_ENTRY            SendOptionsList,// look thru this list
    IN      LPBYTE                 ClassName,     // which class does this belong to?
    IN      DWORD                  ClassLen,      // size of above in bytes
    IN      LPBYTE                 BufStart,      // where to start adding this option
    IN      LPBYTE                 BufEnd         // limit for this option
) {
    BYTE                           Buffer[OPTION_END+1];
    LPBYTE                         Tmp;
    DWORD                          FirstSize;
    DWORD                          Size;
    PLIST_ENTRY                    ThisEntry;
    PDHCP_OPTION                   ThisOpt;
    DWORD                          i, j;

    UNREFERENCED_PARAMETER(DhcpContext);

    Size = FirstSize = 0;
    Buffer[Size++] = OPTION_SUBNET_MASK;          // standard requested options
    Buffer[Size++] = OPTION_DOMAIN_NAME;
    Buffer[Size++] = OPTION_ROUTER_ADDRESS;
    Buffer[Size++] = OPTION_DOMAIN_NAME_SERVERS;
    Buffer[Size++] = OPTION_NETBIOS_NAME_SERVER;
    Buffer[Size++] = OPTION_NETBIOS_NODE_TYPE;
    Buffer[Size++] = OPTION_NETBIOS_SCOPE_OPTION;
    Buffer[Size++] = OPTION_VENDOR_SPEC_INFO;
    Buffer[Size++] = OPTION_USER_CLASS;
    Buffer[Size++] = OPTION_WPAD_URL;

    ThisEntry = SendOptionsList->Flink;
    while( ThisEntry != SendOptionsList ) {
        ThisOpt = CONTAINING_RECORD(ThisEntry, DHCP_OPTION, OptionList);
        ThisEntry = ThisEntry->Flink;

        if( ThisOpt->IsVendor) continue;

        if( ThisOpt->ClassLen ) {
            if( ThisOpt->ClassLen != ClassLen ) continue;
            if( ThisOpt->ClassName != ClassName )
                continue;                         // this option is not used for this client
        }

        if( OPTION_PARAMETER_REQUEST_LIST != ThisOpt->OptionId ) {
            //
            // only if the option is param_request_list do we request..
            //
            continue;
        }

        for( i = 0; i < ThisOpt->DataLen ; i ++ ) {
            for( j = 0; j < Size; j ++ )
                if( ThisOpt->Data[i] == Buffer[j] ) break;
            if( j < Size ) continue;              // option already plugged in
            Buffer[Size++] = ThisOpt->Data[i]; // add this option
        }

        if( 0 == FirstSize ) FirstSize = Size;
    }

    if( 0 == FirstSize ) FirstSize = Size;

    Tmp = BufStart;
    BufStart = (LPBYTE)DhcpAppendOption(          // now add the param request list
        (POPTION)BufStart,
        (BYTE)OPTION_PARAMETER_REQUEST_LIST,
        Buffer,
        (BYTE)Size,
        BufEnd
    );

    if( Tmp == BufStart ) {                       // did not really add the option
        BufStart = (LPBYTE)DhcpAppendOption(      // now try adding the first request we saw instead of everything
            (POPTION)BufStart,
            (BYTE)OPTION_PARAMETER_REQUEST_LIST,
            Buffer,
            (BYTE)FirstSize,
            BufEnd
        );
    }

    return BufStart;
}

POPTION                                           // option from which more appends can occur
DhcpAppendSendOptions(                            // append all configured options
    IN OUT  PDHCP_CONTEXT          DhcpContext,   // this is the context to append for
    IN      PLIST_ENTRY            SendOptionsList,
    IN      LPBYTE                 ClassName,     // current class
    IN      DWORD                  ClassLen,      // len of above in bytes
    IN      LPBYTE                 BufStart,      // start of buffer
    IN      LPBYTE                 BufEnd,        // how far can we go in this buffer
    IN OUT  LPBYTE                 SentOptions,   // BoolArray[OPTION_END+1] to avoid repeating options
    IN OUT  LPBYTE                 VSentOptions,  // to avoid repeating vendor specific options
    IN OUT  LPBYTE                 VendorOpt,     // Buffer[OPTION_END+1] Holding Vendor specific options
    OUT     LPDWORD                VendorOptLen   // the # of bytes filled into that
) {
    PLIST_ENTRY                    ThisEntry;
    PDHCP_OPTION                  ThisOpt;

    DhcpAssert(FALSE == SentOptions[OPTION_PARAMETER_REQUEST_LIST]);
    BufStart = DhcpAppendParamRequestList(
        DhcpContext,
        SendOptionsList,
        ClassName,
        ClassLen,
        BufStart,
        BufEnd
    );
    SentOptions[OPTION_PARAMETER_REQUEST_LIST] = TRUE;

    ThisEntry = SendOptionsList->Flink;
    while( ThisEntry != SendOptionsList ) {
        ThisOpt = CONTAINING_RECORD(ThisEntry, DHCP_OPTION, OptionList);
        ThisEntry = ThisEntry->Flink;

        if( ThisOpt->IsVendor ? VSentOptions[ThisOpt->OptionId] : SentOptions[ThisOpt->OptionId] )
            continue;

        // if( ThisOpt->IsVendor) continue;       // No vendor specific information this round through
        if( ThisOpt->ClassLen ) {
            if( ThisOpt->ClassLen != ClassLen ) continue;
            if( ThisOpt->ClassName != ClassName )
                continue;                         // this option is not used for this client
        }

        if( !ThisOpt->IsVendor ) {                // easy to add non-vendor spec options
            SentOptions[ThisOpt->OptionId] = TRUE;
            BufStart = (LPBYTE)DhcpAppendOption(
                (POPTION)BufStart,
                ThisOpt->OptionId,
                ThisOpt->Data,
                (BYTE)ThisOpt->DataLen,
                BufEnd
            );
        } else {                                  // ENCAPSULATE vendor specific options
            if( SentOptions[OPTION_VENDOR_SPEC_INFO] )
                continue;                         // Vendor spec info already added

            VSentOptions[ThisOpt->OptionId] = TRUE;

            if( ThisOpt->DataLen + 2 + *VendorOptLen > OPTION_END )
                continue;                         // this option overflows the buffer

            VendorOpt[(*VendorOptLen)++] = ThisOpt->OptionId;
            VendorOpt[(*VendorOptLen)++] = (BYTE)ThisOpt->DataLen;
            memcpy(&VendorOpt[*VendorOptLen], ThisOpt->Data, ThisOpt->DataLen);
            (*VendorOptLen) += ThisOpt->DataLen;
        }
    }
    return (POPTION)BufStart;
}


DWORD                                             // status
DhcpDestroyOptionsList(                           // destroy a list of options, freeing up memory
    IN OUT  PLIST_ENTRY            OptionsList,   // this is the list of options to destroy
    IN      PLIST_ENTRY            ClassesList    // this is where to remove classes off
) {
    PLIST_ENTRY                    ThisEntry;
    PDHCP_OPTION                   ThisOption;
    DWORD                          Error;
    DWORD                          LastError;

    LastError = ERROR_SUCCESS;
    while(!IsListEmpty(OptionsList) ) {           // for each element of this list
        ThisEntry  = RemoveHeadList(OptionsList);
        ThisOption = CONTAINING_RECORD(ThisEntry, DHCP_OPTION, OptionList);

        if( NULL != ThisOption->ClassName ) {     // if there is a class, deref it
            Error = DhcpDelClass(
                ClassesList,
                ThisOption->ClassName,
                ThisOption->ClassLen
            );
            if( ERROR_SUCCESS != Error ) {
                DhcpAssert( ERROR_SUCCESS == Error);
                LastError = Error;
            }
        }

        DhcpFreeMemory(ThisOption);               // now really free this
    }
    return LastError;
}

DWORD                                             // win32 status
DhcpClearAllOptions(                              // clear all the options information
    IN OUT  PDHCP_CONTEXT          DhcpContext    // the context to clear for
) {
    PLIST_ENTRY                    ThisEntry;
    PDHCP_OPTION                   ThisOption;

    //(void) DhcpRegClearOptDefs(DhcpContext->AdapterName));

    ThisEntry = DhcpContext->RecdOptionsList.Flink;
    while(ThisEntry != &DhcpContext->RecdOptionsList) {
        ThisOption = CONTAINING_RECORD(ThisEntry, DHCP_OPTION, OptionList);
        ThisEntry  = ThisEntry->Flink;

        // bug bug, need to return space?
        ThisOption->Data = NULL;
        ThisOption->DataLen = 0;

        //LocalError = DhcpMarkParamChangeRequests(
        //    DhcpContext->AdapterName,
        //    ThisOption->OptionId,
        //    ThisOption->IsVendor,
        //    ThisOption->ClassName
        //);
        DhcpAssert(ERROR_SUCCESS == LocalError);
    }
    return ERROR_SUCCESS;
}

POPTION                                           // buffer after filling option
DhcpAppendClassIdOption(                          // fill class id if exists
    IN OUT  PDHCP_CONTEXT          DhcpContext,   // the context to fillfor
    OUT     LPBYTE                 BufStart,      // start of message buffer
    IN      LPBYTE                 BufEnd         // end of message buffer
) {
    DWORD                          Size;

    Size = (DWORD)(BufEnd - BufStart);

    if( DhcpContext->ClassId ) {
        DhcpAssert(DhcpContext->ClassIdLength);
        BufStart = (LPBYTE)DhcpAppendOption(
            (POPTION)BufStart,
            OPTION_USER_CLASS,
            DhcpContext->ClassId,
            (BYTE)DhcpContext->ClassIdLength,
            BufEnd
        );
    }

    return (POPTION) BufStart;
}

LPOPTION
DhcpAppendOption(
    LPOPTION Option,
    BYTE OptionType,
    PVOID OptionValue,
    ULONG OptionLength,
    LPBYTE OptionEnd
)
/*++

Routine Description:

    This function writes a DHCP option to message buffer.

Arguments:

    Option - A pointer to a message buffer.

    OptionType - The option number to append.

    OptionValue - A pointer to the option data.

    OptionLength - The lenght, in bytes, of the option data.

    OptionEnd - End of Option Buffer.

Return Value:

    A pointer to the end of the appended option.

--*/
{
    DWORD  i;

    if ( OptionType == OPTION_END ) {

        //
        // we should alway have atleast one BYTE space in the buffer
        // to append this option.
        //

        DhcpAssert( (LPBYTE)Option < OptionEnd );


        Option->OptionType = OPTION_END;
        return( (LPOPTION) ((LPBYTE)(Option) + 1) );

    }

    if ( OptionType == OPTION_PAD ) {

        //
        // add this option only iff we have enough space in the buffer.
        //

        if(((LPBYTE)Option + 1) < (OptionEnd - 1) ) {
            Option->OptionType = OPTION_PAD;
            return( (LPOPTION) ((LPBYTE)(Option) + 1) );
        }

        DhcpPrint(("DhcpAppendOption failed to append Option "
                    "%ld, Buffer too small.\n", OptionType ));
        return Option;
    }


    //
    // add this option only iff we have enough space in the buffer.
    //

    if(((LPBYTE)Option + 2 + OptionLength) >= (OptionEnd - 1) ) {
        DhcpPrint(("DhcpAppendOption failed to append Option "
                    "%ld, Buffer too small.\n", OptionType ));
        return Option;
    }

    if( OptionLength <= 0xFF ) {
        // simple option.. no need to use OPTION_MSFT_CONTINUED
        Option->OptionType = OptionType;
        Option->OptionLength = (BYTE)OptionLength;
        memcpy( Option->OptionValue, OptionValue, OptionLength );
        return( (LPOPTION) ((LPBYTE)(Option) + Option->OptionLength + 2) );
    }

    // option size is > 0xFF --> need to continue it using multiple ones..
    // there are OptionLenght / 0xFF occurances using 0xFF+2 bytes + one
    // using 2 + (OptionLength % 0xFF ) space..

    // check to see if we have the space first..

    if( 2 + (OptionLength%0xFF) + 0x101*(OptionLength/0xFF)
        + (LPBYTE)Option >= (OptionEnd - 1) ) {
        DhcpPrint(("DhcpAppendOption failed to append Option "
                    "%ld, Buffer too small.\n", OptionType ));
        return Option;
    }

    // first finish off all chunks of 0xFF size that we can do..

    i = OptionLength/0xFF;
    while(i) {
        Option->OptionType = OptionType;
        Option->OptionLength = 0xFF;
        memcpy(Option->OptionValue, OptionValue, 0xFF);
        OptionValue = 0xFF+(LPBYTE)OptionValue;
        Option = (LPOPTION)(0x101 + (LPBYTE)Option);
        OptionType = OPTION_MSFT_CONTINUED;       // all but the first use this ...
        OptionLength -= 0xFF;
    }

    // now finish off the remaining stuff..
    DhcpAssert(OptionLength <= 0xFF);
    Option->OptionType = OPTION_MSFT_CONTINUED;
    Option->OptionLength = (BYTE)OptionLength;
    memcpy(Option->OptionValue, OptionValue, OptionLength);
    Option = (LPOPTION)(2 + OptionLength + (LPBYTE)Option);
    DhcpAssert((LPBYTE)Option < OptionEnd);

    return Option;
}


LPBYTE
DhcpAppendMagicCookie(
    LPBYTE Option,
    LPBYTE OptionEnd
    )
/*++

Routine Description:

    This routine appends magic cookie to a DHCP message.

Arguments:

    Option - A pointer to the place to append the magic cookie.

    OptionEnd - End of Option buffer.

Return Value:

    A pointer to the end of the appended cookie.

    Note : The magic cookie is :

     --------------------
    | 99 | 130 | 83 | 99 |
     --------------------

--*/
{
    DhcpAssert( (Option + 4) < (OptionEnd - 1) );
    if( (Option + 4) < (OptionEnd - 1) ) {
        *Option++ = (BYTE)DHCP_MAGIC_COOKIE_BYTE1;
        *Option++ = (BYTE)DHCP_MAGIC_COOKIE_BYTE2;
        *Option++ = (BYTE)DHCP_MAGIC_COOKIE_BYTE3;
        *Option++ = (BYTE)DHCP_MAGIC_COOKIE_BYTE4;
    }

    return( Option );
}

LPOPTION
DhcpAppendClientIDOption(
    LPOPTION Option,
    BYTE ClientHWType,
    LPBYTE ClientHWAddr,
    BYTE ClientHWAddrLength,
    LPBYTE OptionEnd

    )
/*++

Routine Description:

    This routine appends client ID option to a DHCP message.

History:
    8/26/96 Frankbee    Removed 16 byte limitation on the hardware
                        address

Arguments:

    Option - A pointer to the place to append the option request.

    ClientHWType - Client hardware type.

    ClientHWAddr - Client hardware address

    ClientHWAddrLength - Client hardware address length.

    OptionEnd - End of Option buffer.

Return Value:

    A pointer to the end of the newly appended option.

    Note : The client ID option will look like as below in the message:

     -----------------------------------------------------------------
    | OpNum | Len | HWType | HWA1 | HWA2 | .....               | HWAn |
     -----------------------------------------------------------------

--*/
{
#pragma warning(push)           // save current warning state
#pragma warning(disable : 4200) // disable 0-sized array warning

    struct _CLIENT_ID {
        BYTE    bHardwareAddressType;
        BYTE    pbHardwareAddress[0];
    } *pClientID;

#pragma warning(pop)            // restore previous warning state

    LPOPTION lpNewOption;

    pClientID = (_CLIENT_ID *) DhcpAllocateMemory( sizeof( struct _CLIENT_ID ) + ClientHWAddrLength );

    //
    // currently there is no way to indicate failure.  simply return unmodified option
    // list
    //

    if ( !pClientID )
        return Option;

    pClientID->bHardwareAddressType    = ClientHWType;
    memcpy( pClientID->pbHardwareAddress, ClientHWAddr, ClientHWAddrLength );

    lpNewOption =  DhcpAppendOption(
                         Option,
                         OPTION_CLIENT_ID,
                         (LPBYTE)pClientID,
                         (BYTE)(ClientHWAddrLength + sizeof(BYTE)),
                         OptionEnd );

    DhcpFreeMemory( pClientID );

    return lpNewOption;
}

// data locks on ClassesList must be taken before calling this function
PDHCP_CLASSES PRIVATE                             // the required classes struct
DhcpFindClass(                                    // find a specified class
    IN OUT  PLIST_ENTRY            ClassesList,   // list of classes to srch in
    IN      LPBYTE                 Data,          // non-NULL data bytes
    IN      DWORD                  Len            // # of bytes of above, > 0
) {
    PLIST_ENTRY                    ThisEntry;
    PDHCP_CLASSES                  ThisClass;

    ThisEntry = ClassesList->Flink;               // first element in list
    while( ThisEntry != ClassesList ) {           // search the full list
        ThisClass = CONTAINING_RECORD( ThisEntry, DHCP_CLASSES, ClassList );
        ThisEntry = ThisEntry->Flink;

        if( ThisClass->ClassLen == Len ) {        // lengths must match
            if( ThisClass->ClassName == Data )    // data ptrs can match OR data can match
                return ThisClass;
            if( 0 == memcmp(ThisClass->ClassName, Data, Len) )
                return ThisClass;
        }
    }
    return NULL;
}

// locks on ClassesList should be taken when using this function
LPBYTE                                            // data bytes, or NULL
DhcpAddClass(                                     // add a new class
    IN OUT  PLIST_ENTRY            ClassesList,   // list to add to
    IN      LPBYTE                 Data,          // input class name
    IN      DWORD                  Len            // # of bytes of above
) {
    PDHCP_CLASSES                  Class;
    DWORD                          MemSize;       // amt of memory reqd

    if( NULL == ClassesList ) {                   // invalid parameter
        DhcpAssert( NULL != ClassesList );
        return NULL;
    }

    if( 0 == Len || NULL == Data ) {              // invalid parameters
        DhcpAssert(0 != Len && NULL != Data );
        return NULL;
    }

    Class = DhcpFindClass(ClassesList,Data,Len);  // already there in list?
    if(NULL != Class) {                           // yes, found
        Class->RefCount++;                        // increase ref-count
        return Class->ClassName;
    }

    MemSize = sizeof(*Class)+Len;                 // amt of memory reqd
    Class = (PDHCP_CLASSES) DhcpAllocateMemory(MemSize);
    if( NULL == Class ) {                         // not enough memory
        DhcpAssert( NULL != Class);
        return NULL;
    }

    Class->ClassLen = Len;
    Class->RefCount = 1;
    Class->ClassName = ((LPBYTE)Class) + sizeof(*Class);
    memcpy(Class->ClassName, Data, Len);

    InsertHeadList(ClassesList, &Class->ClassList);

    return Class->ClassName;
}

// locks on ClassesList must be taken before calling this function
DWORD                                             // status
DhcpDelClass(                                     // de-refernce a class
    IN OUT  PLIST_ENTRY            ClassesList,   // the list to delete off
    IN      LPBYTE                 Data,          // the data ptr
    IN      DWORD                  Len            // the # of bytes of above
) {
    PDHCP_CLASSES                  Class;

    if( NULL == ClassesList ) {
        DhcpAssert( NULL != ClassesList );
        return ERROR_INVALID_PARAMETER;
    }

    if( 0 == Len || NULL == Data ) {              // invalid parameter
        DhcpAssert( 0 != Len && NULL != Data );
        return ERROR_INVALID_PARAMETER;
    }

    Class = DhcpFindClass(ClassesList,Data,Len);
    if( NULL == Class ) {                         // did not find this class?
        DhcpAssert( NULL != Class );
        return ERROR_FILE_NOT_FOUND;
    }

    Class->RefCount --;
    if( 0 == Class->RefCount ) {                  // all references removed
        RemoveEntryList( &Class->ClassList );     // remove this from the list
        DhcpFreeMemory(Class);                    // free it
    }

    return ERROR_SUCCESS;
}

// locks on ClassesList must be taken before calling this function
VOID                                              // always succeed
DhcpFreeAllClasses(                               // free each elt of the list
    IN OUT  PLIST_ENTRY            ClassesList    // input list of classes
) {
    PDHCP_CLASSES                  ThisClass;
    PLIST_ENTRY                    ThisEntry;

    if( NULL == ClassesList ) {
        DhcpAssert( NULL != ClassesList && "DhcpFreeAllClasses" );
        return ;
    }

    while( !IsListEmpty(ClassesList) ) {
        ThisEntry = RemoveHeadList(ClassesList);
        ThisClass = CONTAINING_RECORD(ThisEntry, DHCP_CLASSES, ClassList);

        if( ThisClass->RefCount ) {
            DhcpPrint(("Freeing with refcount = %ld\n", ThisClass->RefCount));
        }

        DhcpFreeMemory(ThisClass);
    }

    InitializeListHead(ClassesList);
}

//--------------------------------------------------------------------------------
// exported functions, options
//--------------------------------------------------------------------------------

// data locks need to be taken on OptionsList before calling this function
PDHCP_OPTION                                     // the reqd structure or NULL
DhcpFindOption(                                   // find a specific option
    IN OUT  PLIST_ENTRY            OptionsList,   // the list of options to search
    IN      BYTE                   OptionId,      // the option id to search for
    IN      BOOL                   IsVendor,      // is it vendor specific?
    IN      LPBYTE                 ClassName,     // is there a class associated?
    IN      DWORD                  ClassLen       // # of bytes of above parameter
) {
    PLIST_ENTRY                    ThisEntry;
    PDHCP_OPTION                  ThisOption;

    if( NULL == OptionsList ) {
        DhcpAssert( NULL != OptionsList );
        return NULL;
    }

    ThisEntry = OptionsList->Flink;
    while( ThisEntry != OptionsList ) {           // search the set of options
        ThisOption = CONTAINING_RECORD( ThisEntry, DHCP_OPTION, OptionList );
        ThisEntry  = ThisEntry->Flink;

        if( ThisOption->OptionId != OptionId ) continue;
        if( ThisOption->IsVendor != IsVendor ) continue;
        if( ThisOption->ClassLen != ClassLen ) continue;
        if( ClassLen && ThisOption->ClassName != ClassName )
            continue;                             // mismatched so far

        return ThisOption;                        // found the option
    }

    return NULL;                                  // did not find any match
}

// locks on OptionsList need to be taken before calling this function
DWORD                                             // status
DhcpDelOption(                                    // remove a particular option
    IN      PDHCP_OPTION           ThisOption     // option to delete
) {
    if( NULL == ThisOption)                       // nope, did not find this option
        return ERROR_FILE_NOT_FOUND;

    RemoveEntryList( &ThisOption->OptionList);    // found it.  remove and free
    DhcpFreeMemory(ThisOption);

    return ERROR_SUCCESS;
}

// locks on OptionsList need to be taken before calling this function
DWORD                                             // status
DhcpAddOption(                                    // add a new option
    IN OUT  PLIST_ENTRY            OptionsList,   // list to add to
    IN      BYTE                   OptionId,      // option id to add
    IN      BOOL                   IsVendor,      // is it vendor specific?
    IN      LPBYTE                 ClassName,     // what is the class?
    IN      DWORD                  ClassLen,      // size of above in bytes
    IN      LPBYTE                 Data,          // data for this option
    IN      DWORD                  DataLen,       // # of bytes of above
    IN      time_t                 ExpiryTime     // when the option expires
) {
    PDHCP_OPTION                  ThisOption;
    DWORD                          MemSize;

    if( NULL == OptionsList ) {
        DhcpAssert( NULL != OptionsList && "DhcpAddOption" );
        return ERROR_INVALID_PARAMETER;
    }

    if( 0 != ClassLen && NULL == ClassName ) {
        DhcpAssert( 0 == ClassLen || NULL != ClassName && "DhcpAddOption" );
        return ERROR_INVALID_PARAMETER;
    }

    if( 0 != DataLen && NULL == Data ) {
        DhcpAssert( 0 == DataLen || NULL != Data && "DhcpAddOption" );
        return ERROR_INVALID_PARAMETER;
    }

    MemSize = sizeof(DHCP_OPTION) + DataLen ;
    ThisOption = (PDHCP_OPTION) DhcpAllocateMemory(MemSize);
    if( NULL == ThisOption )                      // could not allocate memory
        return ERROR_NOT_ENOUGH_MEMORY;

    ThisOption->OptionId   = OptionId;
    ThisOption->IsVendor   = IsVendor;
    ThisOption->ClassName  = ClassName;
    ThisOption->ClassLen   = ClassLen;
    ThisOption->ExpiryTime = ExpiryTime;
    ThisOption->DataLen    = DataLen;
    ThisOption->Data       = ((LPBYTE)ThisOption) + sizeof(DHCP_OPTION);
    memcpy(ThisOption->Data, Data, DataLen);

    InsertHeadList( OptionsList, &ThisOption->OptionList );

    return ERROR_SUCCESS;
}



//================================================================================
//   end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5.1\autoproxy\optreg.h ===
//--------------------------------------------------------------------------------
// Copyright (C) Micorosoft Confidential 1997
// Author: RameshV
// Description: Option related registry handling -- common between NT and VxD
//--------------------------------------------------------------------------------
#ifndef  OPTREG_H
#define  OPTREG_H
//--------------------------------------------------------------------------------
// Exported functions: Caller must take locks and any lists accessed
//--------------------------------------------------------------------------------

POPTION                                           // option from which more appends can occur
DhcpAppendSendOptions(                            // append all configured options
    IN OUT  PDHCP_CONTEXT          DhcpContext,   // this is the context to append for
    IN      PLIST_ENTRY            SendOptionsList,
    IN      LPBYTE                 ClassName,     // current class
    IN      DWORD                  ClassLen,      // len of above in bytes
    IN      LPBYTE                 BufStart,      // start of buffer
    IN      LPBYTE                 BufEnd,        // how far can we go in this buffer
    IN OUT  LPBYTE                 SentOptions,   // BoolArray[OPTION_END+1] to avoid repeating options
    IN OUT  LPBYTE                 VSentOptions,  // to avoid repeating vendor specific options
    IN OUT  LPBYTE                 VendorOpt,     // Buffer[OPTION_END+1] Holding Vendor specific options
    OUT     LPDWORD                VendorOptLen   // the # of bytes filled into that
);

DWORD                                             // status
DhcpDestroyOptionsList(                           // destroy a list of options, freeing up memory
    IN OUT  PLIST_ENTRY            OptionsList,   // this is the list of options to destroy
    IN      PLIST_ENTRY            ClassesList    // this is where to remove classes off
);

DWORD                                             // win32 status
DhcpClearAllOptions(                              // remove all turds from off registry
    IN OUT  PDHCP_CONTEXT          DhcpContext    // the context to clear for
);


POPTION                                           // buffer after filling option
DhcpAppendClassIdOption(                          // fill class id if exists
    IN OUT  PDHCP_CONTEXT          DhcpContext,   // the context to fillfor
    OUT     LPBYTE                 BufStart,      // start of message buffer
    IN      LPBYTE                 BufEnd         // end of message buffer
);


#endif OPTREG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5.1\autoproxy\protocol.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    protocol.cxx

Abstract:

    This module contains the server to client protocol for DHCP.

Author:

    Manny Weiser (mannyw)  21-Oct-1992

Environment:

    User Mode - Win32

Revision History:

    Madan Appiah (madana)  21-Oct-1993

    Arthur Bierer (arthurbi) 15-July-1998
        hacked up to use with Wininet's auto-proxy detection code

--*/

#include <wininetp.h>
#include "aproxp.h"

#include "apdetect.h"

#ifndef VXD
// ping routines.. ICMP
#include <ipexport.h>
//#include <icmpif.h>
#include <icmpapi.h>
#endif

#ifdef NEWNT
extern BOOL DhcpGlobalIsService;
#endif // NEWNT

DWORD                                             // Time in seconds
DhcpCalculateWaitTime(                            // how much time to wait
    IN      DWORD                  RoundNum,      // which round is this
    OUT     DWORD                 *WaitMilliSecs  // if needed the # in milli seconds
);


POPTION
FormatDhcpInform(
    PDHCP_CONTEXT DhcpContext
);

DWORD
SendDhcpInform(
    PDHCP_CONTEXT DhcpContext,
    PDWORD TransactionId
);

DWORD                                             // status
SendInformAndGetReplies(                          // send an inform packet and collect replies
    IN      PDHCP_CONTEXT          DhcpContext,   // the context to send out of
    IN      DWORD                  nInformsToSend,// how many informs to send?
    IN      DWORD                  MaxAcksToWait, // how many acks to wait for
    OUT     DHCP_EXPECTED_OPTIONS *pExpectedOptions // list of things parsed out of request
);

VOID
DhcpExtractFullOrLiteOptions(                     // Extract some important options alone or ALL
    IN      PDHCP_CONTEXT          DhcpContext,
    IN      LPBYTE                 OptStart,      // start of the options stuff
    IN      DWORD                  MessageSize,   // # of bytes of options
    IN      BOOL                   LiteOnly,      // next struc is EXPECTED_OPTIONS and not FULL_OPTIONS
    OUT     LPVOID                 DhcpOptions,   // this is where the options would be stored
    IN OUT  PLIST_ENTRY            RecdOptions,   // if !LiteOnly this gets filled with all incoming options
    IN OUT  DWORD                 *LeaseExpiry,   // if !LiteOnly input expiry time, else output expiry time
    IN      LPBYTE                 ClassName,     // if !LiteOnly this is used to add to the option above
    IN      DWORD                  ClassLen       // if !LiteOnly this gives the # of bytes of classname
);

DWORD
SendDhcpMessage(
    PDHCP_CONTEXT DhcpContext,
    DWORD MessageLength,
    PDWORD TransactionId
    );

DWORD
OpenDhcpSocket(
    PDHCP_CONTEXT DhcpContext
    );

DWORD
GetSpecifiedDhcpMessage(
    PDHCP_CONTEXT DhcpContext,
    PDWORD BufferLength,
    DWORD TransactionId,
    DWORD TimeToWait
    );

DWORD
CloseDhcpSocket(
    PDHCP_CONTEXT DhcpContext
    );

//
// functions
//


DWORD                                             // Time in seconds
DhcpCalculateWaitTime(                            // how much time to wait
    IN      DWORD                  RoundNum,      // which round is this
    OUT     DWORD                 *WaitMilliSecs  // if needed the # in milli seconds
) {
    DWORD                          MilliSecs;
    //DWORD                          WaitTimes[4] = { 4000, 8000, 16000, 32000 };
    DWORD                          WaitTimes[4] = { 2000, 4000, 8000, 16000 };

    if( WaitMilliSecs ) *WaitMilliSecs = 0;
    if( RoundNum >= sizeof(WaitTimes)/sizeof(WaitTimes[0]) )
        return 0;

    MilliSecs = WaitTimes[RoundNum] - 1000 + ((rand()*((DWORD) 2000))/RAND_MAX);
    if( WaitMilliSecs ) *WaitMilliSecs = MilliSecs;

    return (MilliSecs + 501)/1000;
}


VOID        _inline
ConcatOption(
    IN OUT  LPBYTE                *Buf,           // input buffer to re-alloc
    IN OUT  ULONG                 *BufSize,       // input buffer size
    IN      BYTE UNALIGNED        *Data,          // data to append
    IN      ULONG                  DataSize       // how many bytes to add?
)
{
    LPBYTE                         NewBuf;
    ULONG                          NewSize;

    NewSize = (*BufSize) + DataSize;
    NewBuf = (LPBYTE) DhcpAllocateMemory(NewSize);
    if( NULL == NewBuf ) {                        // could not alloc memory?
        return;                                   // can't do much
    }

    memcpy(NewBuf, *Buf, *BufSize);               // copy existing part
    memcpy(NewBuf + *BufSize, Data, DataSize);    // copy new stuff

    if( NULL != *Buf ) DhcpFreeMemory(*Buf);      // if we alloc'ed mem, free it now
    *Buf = NewBuf;
    *BufSize = NewSize;                           // fill in new values..
}

VOID
DhcpExtractFullOrLiteOptions(                     // Extract some important options alone or ALL
    IN      PDHCP_CONTEXT          DhcpContext,   // input context
    IN      LPBYTE                 OptStart,      // start of the options stuff
    IN      DWORD                  MessageSize,   // # of bytes of options
    IN      BOOL                   LiteOnly,      // next struc is EXPECTED_OPTIONS and not FULL_OPTIONS
    OUT     LPVOID                 DhcpOptions,   // this is where the options would be stored
    IN OUT  PLIST_ENTRY            RecdOptions,   // if !LiteOnly this gets filled with all incoming options
    IN OUT  DWORD                 *LeaseExpiry,   // if !LiteOnly input expiry time, else output expiry time
    IN      LPBYTE                 ClassName,     // if !LiteOnly this is used to add to the option above
    IN      DWORD                  ClassLen       // if !LiteOnly this gives the # of bytes of classname
) {
    BYTE    UNALIGNED*             ThisOpt;
    BYTE    UNALIGNED*             NextOpt;
    BYTE    UNALIGNED*             EndOpt;
    BYTE    UNALIGNED*             MagicCookie;
    DWORD                          Size, ThisSize, UClassSize = 0;
    LPBYTE                         UClass= NULL;  // concatenation of all OPTION_USER_CLASS options
    PDHCP_EXPECTED_OPTIONS         ExpOptions;
    PDHCP_FULL_OPTIONS             FullOptions;
    BYTE                           ReqdCookie[] = {
        (BYTE)DHCP_MAGIC_COOKIE_BYTE1,
        (BYTE)DHCP_MAGIC_COOKIE_BYTE2,
        (BYTE)DHCP_MAGIC_COOKIE_BYTE3,
        (BYTE)DHCP_MAGIC_COOKIE_BYTE4
    };

    UNREFERENCED_PARAMETER(DhcpContext);
    UNREFERENCED_PARAMETER(RecdOptions);
    UNREFERENCED_PARAMETER(ClassName);
    UNREFERENCED_PARAMETER(ClassLen);
    
    EndOpt = OptStart + MessageSize;              // all options should be < EndOpt;
    ExpOptions = (PDHCP_EXPECTED_OPTIONS)DhcpOptions;
    FullOptions = (PDHCP_FULL_OPTIONS)DhcpOptions;
    RtlZeroMemory((LPBYTE)DhcpOptions, LiteOnly?sizeof(*ExpOptions):sizeof(*FullOptions));
    // if(!LiteOnly) InitializeListHead(RecdOptions); -- clear off this list for getting ALL options
    // dont clear off options... just accumulate over..

    MagicCookie = OptStart;
    if( 0 == MessageSize ) goto DropPkt;          // nothing to do in this case
    if( 0 != memcmp(MagicCookie, ReqdCookie, sizeof(ReqdCookie)) )
        goto DropPkt;                             // oops, cant handle this packet

    NextOpt = &MagicCookie[sizeof(ReqdCookie)];
    while( NextOpt < EndOpt && OPTION_END != *NextOpt ) {
        if( OPTION_PAD == *NextOpt ) {            // handle pads right away
            NextOpt++;
            continue;
        }

        ThisOpt = NextOpt;                        // take a good look at this option
        if( NextOpt + 2 >  EndOpt ) {             // goes over boundary?
            break;
        }

        NextOpt += 2 + (unsigned)ThisOpt[1];      // Option[1] holds the size of this option
        Size = ThisOpt[1];

        if( NextOpt > EndOpt ) {                  // illegal option that goes over boundary!
            break;                                // ignore the error, but dont take this option
        }

        if(!LiteOnly) do {                        // look for any OPTION_MSFT_CONTINUED ..
            if( NextOpt >= EndOpt ) break;        // no more options
            if( OPTION_MSFT_CONTINUED != NextOpt[0] ) break;
            if( NextOpt + 1 + NextOpt[1] > EndOpt ) {
                NextOpt = NULL;                   // do this so that we know to quit at the end..
                break;
            }

            NextOpt++;                            // skip opt code
            ThisSize = NextOpt[0];                // # of bytes to shift back..
            memcpy(ThisOpt+2+Size, NextOpt+1,ThisSize);
            NextOpt += ThisSize+1;
            Size += ThisSize;
        } while(1);                               // keep stringing up any "continued" options..

        if( NULL == NextOpt ) {                   // err parsing OPTION_MSFT_CONTINUED ..
            break;
        }

        if( LiteOnly ) {                          // handle the small subnet of options
            switch( ThisOpt[0] ) {                // ThisOpt[0] is OptionId, ThisOpt[1] is size
            case OPTION_MESSAGE_TYPE:
                if( ThisOpt[1] != 1 ) goto DropPkt;
                ExpOptions->MessageType = &ThisOpt[2];
                continue;
            case OPTION_SUBNET_MASK:
                if( ThisOpt[1] != sizeof(DWORD) ) goto DropPkt;
                ExpOptions->SubnetMask = (DHCP_IP_ADDRESS UNALIGNED *)&ThisOpt[2];
                continue;
            case OPTION_LEASE_TIME:
                if( ThisOpt[1] != sizeof(DWORD) ) goto DropPkt;
                ExpOptions->LeaseTime = (DHCP_IP_ADDRESS UNALIGNED *)&ThisOpt[2];
                continue;
            case OPTION_SERVER_IDENTIFIER:
                if( ThisOpt[1] != sizeof(DWORD) ) goto DropPkt;
                ExpOptions->ServerIdentifier = (DHCP_IP_ADDRESS UNALIGNED *)&ThisOpt[2];
                continue;
            case OPTION_DOMAIN_NAME:
                if( ThisOpt[1] == 0 ) goto DropPkt;
                ExpOptions->DomainName = (BYTE UNALIGNED *)&ThisOpt[2];
                ExpOptions->DomainNameSize = ThisOpt[1];
                break;
            case OPTION_WPAD_URL:
                if( ThisOpt[1] == 0 ) goto DropPkt;
                ExpOptions->WpadUrl = (BYTE UNALIGNED *)&ThisOpt[2];
                ExpOptions->WpadUrlSize = ThisOpt[1];
                break;

            default:
                continue;
            }
        } else {                                  // Handle the full set of options
            switch( ThisOpt[0] ) {
            case OPTION_MESSAGE_TYPE:
                if( Size != 1 ) goto DropPkt;
                FullOptions->MessageType = &ThisOpt[2];
                break;
            case OPTION_SUBNET_MASK:
                if( Size != sizeof(DWORD) ) goto DropPkt;
                FullOptions->SubnetMask = (DHCP_IP_ADDRESS UNALIGNED *)&ThisOpt[2];
                break;
            case OPTION_LEASE_TIME:
                if( Size != sizeof(DWORD) ) goto DropPkt;
                FullOptions->LeaseTime = (DHCP_IP_ADDRESS UNALIGNED *)&ThisOpt[2];
                break;
            case OPTION_SERVER_IDENTIFIER:
                if( Size != sizeof(DWORD) ) goto DropPkt;
                FullOptions->ServerIdentifier = (DHCP_IP_ADDRESS UNALIGNED *)&ThisOpt[2];
                break;
            case OPTION_RENEWAL_TIME:             // T1Time
                if( Size != sizeof(DWORD) ) goto DropPkt;
                FullOptions->T1Time = (DHCP_IP_ADDRESS UNALIGNED *)&ThisOpt[2];
                break;
            case OPTION_REBIND_TIME:              // T2Time
                if( Size != sizeof(DWORD) ) goto DropPkt;
                FullOptions->T2Time = (DHCP_IP_ADDRESS UNALIGNED *)&ThisOpt[2];
                break;
            case OPTION_ROUTER_ADDRESS:
                if( Size < sizeof(DWORD) || (Size % sizeof(DWORD) ) )
                    goto DropPkt;                 // There can be many router addresses
                FullOptions->GatewayAddresses = (DHCP_IP_ADDRESS UNALIGNED *)&ThisOpt[2];
                FullOptions->nGateways = Size / sizeof(DWORD);
                break;
            case OPTION_STATIC_ROUTES:
                if( Size < 2*sizeof(DWORD) || (Size % (2*sizeof(DWORD))) )
                    goto DropPkt;                 // the static routes come in pairs
                FullOptions->StaticRouteAddresses = (DHCP_IP_ADDRESS UNALIGNED *)&ThisOpt[2];
                FullOptions->nStaticRoutes = Size/(2*sizeof(DWORD));
                break;
            case OPTION_DYNDNS_BOTH:
                if( Size < 3 ) goto DropPkt;
                FullOptions->DnsFlags = (BYTE UNALIGNED *)&ThisOpt[2];
                FullOptions->DnsRcode1 = (BYTE UNALIGNED *)&ThisOpt[3];
                FullOptions->DnsRcode2 = (BYTE UNALIGNED *)&ThisOpt[3];
                break;
            case OPTION_DOMAIN_NAME:
                if( Size == 0 ) goto DropPkt;
                FullOptions->DomainName = (BYTE UNALIGNED *)&ThisOpt[2];
                FullOptions->DomainNameSize = Size;
                break;
            case OPTION_WPAD_URL:
                if( Size == 0 ) goto DropPkt;
                FullOptions->WpadUrl = (BYTE UNALIGNED *)&ThisOpt[2];
                FullOptions->WpadUrlSize = Size;
                break;
            case OPTION_DOMAIN_NAME_SERVERS:
                if( Size < sizeof(DWORD) || (Size % sizeof(DWORD) ))
                    goto DropPkt;
                FullOptions->DnsServerList = (DHCP_IP_ADDRESS UNALIGNED *)&ThisOpt[2];
                FullOptions->nDnsServers = Size / sizeof(DWORD);
                break;
            case OPTION_MESSAGE:
                if( Size == 0 ) break;      // ignore zero sized packets
                FullOptions->ServerMessage = &ThisOpt[2];
                FullOptions->ServerMessageLength = ThisOpt[1];
                break;
            case OPTION_MCAST_LEASE_START:
                if ( Size != sizeof(DATE_TIME) ) goto DropPkt;
                FullOptions->MCastLeaseStartTime = (DWORD UNALIGNED *)&ThisOpt[2];
                break;
            case OPTION_MCAST_TTL:
                if ( Size != 1 ) goto DropPkt;
                FullOptions->MCastTTL = (BYTE UNALIGNED *)&ThisOpt[2];
                break;
            case OPTION_USER_CLASS:
                if( Size <= 6) goto DropPkt;
                ConcatOption(&UClass, &UClassSize, &ThisOpt[2], Size);
                continue;                         // don't add this option yet...

            default:
                // unknowm message, nothing to do.. especially dont log this
                break;
            }

        } // if LiteOnly then else
    } // while NextOpt < EndOpt

    if( LiteOnly && LeaseExpiry ) {               // If asked to calculate lease expiration time..
        DWORD    LeaseTime;
        time_t   TimeNow, ExpirationTime;

        // BBUGBUGBUG [arthurbi] broken intensionlly, dead code.
        //if( ExpOptions->LeaseTime ) LeaseTime = _I_ntohl(*ExpOptions->LeaseTime);
        if( ExpOptions->LeaseTime ) LeaseTime = 0;
        else LeaseTime = DHCP_MINIMUM_LEASE;
        ExpirationTime = (TimeNow = time(NULL)) + (time_t)LeaseTime;
        if( ExpirationTime < TimeNow ) {
            ExpirationTime = INFINIT_TIME;
        }

        *LeaseExpiry = (DWORD)ExpirationTime ;
    }

    if( !LiteOnly && NULL != UClass ) {           // we have a user class list to pass on..
        DhcpAssert(UClassSize != 0 );             // we better have something here..
        DhcpFreeMemory(UClass); UClass = NULL;
    }

    return;

  DropPkt:
    RtlZeroMemory(DhcpOptions, LiteOnly?sizeof(ExpOptions):sizeof(FullOptions));
    if( LiteOnly && LeaseExpiry ) *LeaseExpiry = (DWORD) time(NULL) + DHCP_MINIMUM_LEASE;
    //if(!LiteOnly) DhcpFreeAllOptions(RecdOptions);// ok undo the options that we just added
    if(!LiteOnly && NULL != UClass ) DhcpFreeMemory(UClass);
}

POPTION                                           // ptr to add additional options
FormatDhcpInform(                                 // format the packet for an INFORM
    IN      PDHCP_CONTEXT          DhcpContext    // format for this context
) {
    LPOPTION option;
    LPBYTE OptionEnd;

    BYTE value;
    PDHCP_MESSAGE dhcpMessage;


    dhcpMessage = DhcpContext->MessageBuffer;
    RtlZeroMemory( dhcpMessage, DHCP_SEND_MESSAGE_SIZE );

    //
    // BUGBUG [arthurbi] - 
    // For RAS client, use broadcast bit, otherwise the router will try
    // to send as unicast to made-up RAS client hardware address, which
    // will not work.  So will this work without it?
    //

    //
    // Transaction ID is filled in during send
    //

    dhcpMessage->Operation             = BOOT_REQUEST;
    dhcpMessage->HardwareAddressType   = DhcpContext->HardwareAddressType;
    dhcpMessage->SecondsSinceBoot      = (WORD) DhcpContext->SecondsSinceBoot;
    memcpy(dhcpMessage->HardwareAddress,DhcpContext->HardwareAddress,DhcpContext->HardwareAddressLength);
    dhcpMessage->HardwareAddressLength = (BYTE)DhcpContext->HardwareAddressLength;
    dhcpMessage->ClientIpAddress       = DhcpContext->IpAddress;
    //dhcpMessage->Reserved = 0;
    //dhcpMessage->Reserved = _I_htons(DHCP_BROADCAST);
    //if ( IS_MDHCP_CTX(DhcpContext ) ) MDHCP_MESSAGE( dhcpMessage );

    option = &dhcpMessage->Option;
    OptionEnd = (LPBYTE)dhcpMessage + DHCP_SEND_MESSAGE_SIZE;

    //
    // always add magic cookie first
    //

    option = (LPOPTION) DhcpAppendMagicCookie( (LPBYTE) option, OptionEnd );

    value = DHCP_INFORM_MESSAGE;
    option = DhcpAppendOption(
        option,
        OPTION_MESSAGE_TYPE,
        &value,
        1,
        OptionEnd
    );

    //
    // BUGBUG [arthurbi], shouldn't we uncomment this?
    //

    // un comment later on
    /*option = DhcpAppendClassIdOption(
        DhcpContext,
        (LPBYTE)option,
        OptionEnd
    );*/

    return( option );
}


DWORD                                             // status
SendDhcpInform(                                   // send an inform packet after filling required options
    IN      PDHCP_CONTEXT          DhcpContext,   // sned out for this context
    IN OUT  DWORD                 *pdwXid         // use this Xid (if zero fill something and return it)
) {
    DWORD                          size;
    POPTION                        option;
    LPBYTE                         OptionEnd;
    BYTE                           SentOpt[OPTION_END+1];
    BYTE                           SentVOpt[OPTION_END+1];
    BYTE                           VendorOpt[OPTION_END+1];
    DWORD                          VendorOptSize;

    RtlZeroMemory(SentOpt, sizeof(SentOpt));      // initialize boolean arrays
    RtlZeroMemory(SentVOpt, sizeof(SentVOpt));    // so that no option is presumed sent
    VendorOptSize = 0;                            // encapsulated vendor option is empty
    option = FormatDhcpInform( DhcpContext );     // core format

    OptionEnd = (LPBYTE)(DhcpContext->MessageBuffer) + DHCP_SEND_MESSAGE_SIZE;

    if( DhcpContext->ClientIdentifier.fSpecified) // client id specified in registy
        option = DhcpAppendClientIDOption(        // ==> use this client id as option
            option,
            DhcpContext->ClientIdentifier.bType,
            DhcpContext->ClientIdentifier.pbID,
            (BYTE)DhcpContext->ClientIdentifier.cbID,
            OptionEnd
        );
    else                                          // client id was not specified
        option = DhcpAppendClientIDOption(        // ==> use hw addr as client id
            option,
            DhcpContext->HardwareAddressType,
            DhcpContext->HardwareAddress,
            (BYTE)DhcpContext->HardwareAddressLength,
            OptionEnd
        );

    {   // add hostname and comment options
        char szHostName[255];

        if ( _I_gethostname(szHostName, ARRAY_ELEMENTS(szHostName)) != SOCKET_ERROR  ) 
        {
            option = DhcpAppendOption(
                option,
                OPTION_HOST_NAME,
                (LPBYTE)szHostName,
                (BYTE)((strlen(szHostName) + 1) * sizeof(CHAR)),
                OptionEnd
            );
        }
    }

    if( NULL != DhcpGlobalClientClassInfo ) {     // if we have any info on client class..
        option = DhcpAppendOption(
            option,
            OPTION_CLIENT_CLASS_INFO,
            (LPBYTE)DhcpGlobalClientClassInfo,
            strlen(DhcpGlobalClientClassInfo),
            OptionEnd
        );
    }

    SentOpt[OPTION_MESSAGE_TYPE] = TRUE;          // these must have been added by now
    if(DhcpContext->ClassIdLength) SentOpt[OPTION_USER_CLASS] = TRUE;
    SentOpt[OPTION_CLIENT_CLASS_INFO] = TRUE;
    SentOpt[OPTION_CLIENT_ID] = TRUE;
    SentOpt[OPTION_REQUESTED_ADDRESS] = TRUE;
    SentOpt[OPTION_HOST_NAME] = TRUE;

    option = DhcpAppendSendOptions(               // append all other options we need to send
        DhcpContext,                              // for this context
        &DhcpContext->SendOptionsList,            // this is the list of options to send out
        DhcpContext->ClassId,                     // which class.
        DhcpContext->ClassIdLength,               // how many bytes are there in the class id
        (LPBYTE)option,                           // start of the buffer to add the options
        (LPBYTE)OptionEnd,                        // end of the buffer up to which we can add options
        SentOpt,                                  // this is the boolean array that marks what opt were sent
        SentVOpt,                                 // this is for vendor spec options
        VendorOpt,                                // this would contain some vendor specific options
        &VendorOptSize                            // the # of bytes of vendor options added to VendorOpt param
    );

    if( !SentOpt[OPTION_VENDOR_SPEC_INFO] && VendorOptSize && VendorOptSize <= OPTION_END )
        option = DhcpAppendOption(                // add vendor specific options if we havent already sent it
            option,
            OPTION_VENDOR_SPEC_INFO,
            VendorOpt,
            (BYTE)VendorOptSize,
            OptionEnd
        );

    option = DhcpAppendOption( option, OPTION_END, NULL, 0, OptionEnd );
    size = (DWORD)((PBYTE)option - (PBYTE)DhcpContext->MessageBuffer);

    return  SendDhcpMessage(                      // finally send the message and return
        DhcpContext,
        size,
        pdwXid
    );
}

DWORD
InitializeDhcpSocket(
    SOCKET *Socket,
    DHCP_IP_ADDRESS IpAddress
    )
/*++

Routine Description:

    This function initializes and binds a socket to the specified IP address.

Arguments:

    Socket - Returns a pointer to the initialized socket.

    IpAddress - The IP address to bind the socket to.  It is legitimate
        to bind a socket to 0.0.0.0 if the card has no current IP address.

Return Value:

    The status of the operation.

--*/
{
    DWORD error;
    DWORD closeError;
    DWORD value;
    struct sockaddr_in socketName;
    DWORD i;
    SOCKET sock;

    //
    // Sockets initialization
    //

    sock = _I_socket( PF_INET, SOCK_DGRAM, IPPROTO_UDP );

    if ( sock == INVALID_SOCKET ) {
        error = _I_WSAGetLastError();
        DhcpPrint(("socket failed, error = %ld\n", error ));
        return( error );
    }

    //
    // Make the socket share-able
    //

    value = 1;

    error = _I_setsockopt( sock, SOL_SOCKET, SO_REUSEADDR, (char FAR *)&value, sizeof(value) );
    if ( error != 0 ) {
        error = _I_WSAGetLastError();
        DhcpPrint(("setsockopt failed, err = %ld\n", error ));

        closeError = _I_closesocket( sock );
        if ( closeError != 0 ) {
            DhcpPrint(("closesocket failed, err = %d\n", closeError ));
        }
        return( error );
    }

    error = _I_setsockopt( sock, SOL_SOCKET, SO_BROADCAST, (char FAR *)&value, sizeof(value) );
    if ( error != 0 ) {
        error = _I_WSAGetLastError();
        DhcpPrint(("setsockopt failed, err = %ld\n", error ));

        closeError = _I_closesocket( sock );
        if ( closeError != 0 ) {
            DhcpPrint(("closesocket failed, err = %d\n", closeError ));
        }
        return( error );
    }

    //
    // If the IpAddress is zero, set the special socket option to make
    // stack work with zero address.
    //

    if( IpAddress == 0 ) {
        value = 1234;
        error = _I_setsockopt( sock, SOL_SOCKET, 0x8000, (char FAR *)&value, sizeof(value) );
        if ( error != 0 ) {
            error = _I_WSAGetLastError();
            DhcpPrint(("setsockopt failed, err = %ld\n", error ));

            closeError = _I_closesocket( sock );
            if ( closeError != 0 ) {
                DhcpPrint(("closesocket failed, err = %d\n", closeError ));
            }
            return( error );
        }
    }

    socketName.sin_family = PF_INET;
    socketName.sin_port = _I_htons( DHCP_CLIENT_PORT );
    socketName.sin_addr.s_addr = IpAddress;

    for ( i = 0; i < 8 ; i++ ) {
        socketName.sin_zero[i] = 0;
    }

    //
    // Bind this socket to the DHCP server port
    //

    error = _I_bind(
               sock,
               (struct sockaddr FAR *)&socketName,
               sizeof( socketName )
               );

    if ( error != 0 ) {
        error = _I_WSAGetLastError();
        DhcpPrint(("bind failed (address 0x%lx), err = %ld\n", IpAddress, error ));
        closeError = _I_closesocket( sock );
        if ( closeError != 0 ) {
            DhcpPrint(("closesocket failed, err = %d\n", closeError ));
        }
        return( error );
    }

    *Socket = sock;
    return( NO_ERROR );
}


DWORD                                             // status
SendInformAndGetReplies(                          // send an inform packet and collect replies
    IN      PDHCP_CONTEXT          DhcpContext,   // the context to send out of
    IN      DWORD                  nInformsToSend,// how many informs to send?
    IN      DWORD                  MaxAcksToWait, // how many acks to wait for
    OUT     DHCP_EXPECTED_OPTIONS *pExpectedOptions // list of things parsed out of request
) {
    time_t                         StartTime;
    time_t                         TimeNow;
    DWORD                          TimeToWait;
    DWORD                          Error;
    DWORD                          Xid;
    DWORD                          MessageSize;
    DWORD                          RoundNum;
    DWORD                          MessageCount;
    DWORD                          LeaseExpirationTime;
    DHCP_FULL_OPTIONS              FullOptions;

    DhcpPrint(("SendInformAndGetReplies entered\n"));

    if((Error = OpenDhcpSocket(DhcpContext)) != ERROR_SUCCESS) {
        DhcpPrint(("Could not open socket for this interface! (%ld)\n", Error));
        return Error;
    }

    Xid                           = 0;            // Will be generated by first SendDhcpPacket
    MessageCount                  = 0;            // total # of messages we have got

    DhcpContext->SecondsSinceBoot = 0;            // start at zero..
    for( RoundNum = 0; RoundNum < nInformsToSend;  RoundNum ++ ) {
        Error = SendDhcpInform(DhcpContext, &Xid);
        if( ERROR_SUCCESS != Error ) {
            DhcpPrint(("SendDhcpInform: %ld\n", Error));
            goto Cleanup;
        } else {
            DhcpPrint(("Sent DhcpInform\n"));
        }

        TimeToWait = DhcpCalculateWaitTime(RoundNum, NULL);
        DhcpContext->SecondsSinceBoot += TimeToWait; // do this so that next time thru it can go thru relays..
        StartTime  = time(NULL);
        while ( TRUE ) {                          // wiat for the specified wait time
            MessageSize =  DHCP_MESSAGE_SIZE;

            DhcpPrint(("Waiting for ACK[Xid=%x]: %ld seconds\n",Xid, TimeToWait));
            Error = GetSpecifiedDhcpMessage(      // try to receive an ACK
                DhcpContext,
                &MessageSize,
                Xid,
                (DWORD)TimeToWait
            );
            if ( Error == ERROR_SEM_TIMEOUT ) break;
            if( Error != ERROR_SUCCESS ) {
                DhcpPrint(("GetSpecifiedDhcpMessage: %ld\n", Error));
                goto Cleanup;
            }

            DhcpExtractFullOrLiteOptions(         // Need to see if this is an ACK
                DhcpContext,
                (LPBYTE)&DhcpContext->MessageBuffer->Option,
                MessageSize - DHCP_MESSAGE_FIXED_PART_SIZE,
                TRUE,                             // do lite extract only
                pExpectedOptions,                 // check for only expected options
                NULL,                             // unused
                &LeaseExpirationTime,
                NULL,                             // unused
                0                                 // unused
            );

            if( NULL == pExpectedOptions->MessageType ) {
                DhcpPrint(("Received no message type!\n"));
            } else if( DHCP_ACK_MESSAGE != *(pExpectedOptions->MessageType) ) {
                DhcpPrint(("Received unexpected message type: %ld\n", *(pExpectedOptions->MessageType)));
            } else if( NULL == pExpectedOptions->ServerIdentifier ) {
                DhcpPrint(("Received no server identifier, dropping inform ACK\n"));
            } else {
                MessageCount ++;
                DhcpPrint(("Received %ld ACKS so far\n", MessageCount));
                DhcpExtractFullOrLiteOptions(     // do FULL options..
                    DhcpContext,
                    (LPBYTE)&DhcpContext->MessageBuffer->Option,
                    MessageSize - DHCP_MESSAGE_FIXED_PART_SIZE,
                    FALSE,
                    &FullOptions,
                    &(DhcpContext->RecdOptionsList),
                    &LeaseExpirationTime,
                    DhcpContext->ClassId,
                    DhcpContext->ClassIdLength
                );
                if( MessageCount >= MaxAcksToWait ) goto Cleanup;
            } // if( it is an ACK and ServerId present )

            TimeNow     = time(NULL);             // Reset the time values to reflect new time
            if( TimeToWait < (DWORD) (TimeNow - StartTime) ) {
                break;                            // no more time left to wait..
            }
            TimeToWait -= (DWORD)(TimeNow - StartTime);  // recalculate time now
            StartTime   = TimeNow;                // reset start time also
        } // end of while ( TimeToWait > 0)
    } // for (RoundNum = 0; RoundNum < nInformsToSend ; RoundNum ++ )

  Cleanup:
    CloseDhcpSocket(DhcpContext);
    if( MessageCount ) Error = ERROR_SUCCESS;
    DhcpPrint(("SendInformAndGetReplies: got %d ACKS (returning %ld)\n", MessageCount,Error));
    return Error;
}

//--------------------------------------------------------------------------------
//  This function gets the options from the server using DHCP_INFORM message.
//  It picks the first ACK and then processes it.
//  It ignores any errors caused by TIME_OUTS as that only means there is no
//  server, or the server does not have this functionality.  No point giving up
//  because of that.
//--------------------------------------------------------------------------------
BOOL                                              // win32 status
DhcpDoInform(                                     // send an inform packet if necessary
    IN      CAdapterInterface *    pAdapterInterface,
    IN      BOOL                   fBroadcast,    // Do we broadcast this inform, or unicast to server?
    OUT     LPSTR *                ppszAutoProxyUrl
) {
    DHCP_CONTEXT                   StackDhcpContext;   // input context to do inform on
    PDHCP_CONTEXT                  DhcpContext = &StackDhcpContext;
    DWORD                          Error;
    DWORD                          LocalError;
    BOOL                           WasPlumbedBefore;
    time_t                         OldT2Time;
    DHCP_EXPECTED_OPTIONS          ExpectedOptions;

    if ( ! pAdapterInterface->IsDhcp() ) {
        return FALSE;
    }

    if (! pAdapterInterface->CopyAdapterInfoToDhcpContext(DhcpContext) ) {
        return FALSE;
    }
   
    // mdhcp uses INADDR_ANY so it does not have to have an ipaddress.
    if( 0 == DhcpContext->IpAddress && !IS_MDHCP_CTX( DhcpContext) ) {
        DhcpPrint(("Cannot do DhcpInform on an adapter without ip address!\n"));
        return FALSE;
    }

    // Open the socket ahead... so that things work. Tricky, else does not work!!!
    if((Error = OpenDhcpSocket(DhcpContext)) != ERROR_SUCCESS ) {
        DhcpPrint(("Could not open socket (%ld)\n", Error));
        return FALSE;
    }

    // If you always need to broadcast this message, the KLUDGE is to
    // set pContext->T2Time = 0; and pContext->fFlags &= ~DHCP_CONTEXT_FLAGS_PLUMBED
    // and that should do the trick! Safe to change the struct as it was cloned.
    OldT2Time = DhcpContext->T2Time;
    WasPlumbedBefore = IS_ADDRESS_PLUMBED(DhcpContext);
    if(fBroadcast) {
        DhcpContext->T2Time = 0; // !!!! KLUDGE.. look at SendDhcpMessage to understand this ..
        ADDRESS_UNPLUMBED(DhcpContext);
        CONNECTION_BROADCAST(DhcpContext);
    } else {
        DhcpContext->T2Time = (-1);
    }

    memset((void *) &ExpectedOptions, 0, sizeof(DHCP_EXPECTED_OPTIONS));

    Error = SendInformAndGetReplies(              // get replies on this
        DhcpContext,                              // context to send on
        2,                                        // send atmost 2 informs
        1,                                        // wait for as many as 4 packets..
        &ExpectedOptions
    );
    DhcpContext->LastInformSent = time(NULL);     // record when the last inform was sent
    DhcpContext->T2Time = OldT2Time;
    if( WasPlumbedBefore ) ADDRESS_PLUMBED(DhcpContext);

    LocalError = CloseDhcpSocket(DhcpContext);
    DhcpAssert(ERROR_SUCCESS == LocalError);

    if( ERROR_SUCCESS != Error ) {
        DhcpPrint(("DhcpDoInform:return [0x%lx]\n", Error));
    }
    else
    {
        //
        // Did we actually get a response with an URL that can be used ? 
        //

        if (ExpectedOptions.WpadUrl && ExpectedOptions.WpadUrlSize > 0)
        {
            LPSTR   lpszAutoProxyUrl = NewString(NULL, ExpectedOptions.WpadUrlSize);

            if (lpszAutoProxyUrl)
            {
                memcpy(lpszAutoProxyUrl, ExpectedOptions.WpadUrl, ExpectedOptions.WpadUrlSize);
                *ppszAutoProxyUrl = lpszAutoProxyUrl;
            }
            return (lpszAutoProxyUrl != NULL);
        }            
    }

    return FALSE;
}


DWORD
SendDhcpMessage(
    PDHCP_CONTEXT DhcpContext,
    DWORD MessageLength,
    PDWORD TransactionId
    )
/*++

Routine Description:

    This function sends a UDP message to the DHCP server specified
    in the DhcpContext.

Arguments:

    DhcpContext - A pointer to a DHCP context block.

    MessageLength - The length of the message to send.

    TransactionID - The transaction ID for this message.  If 0, the
        function generates a random ID, and returns it.

Return Value:

    The status of the operation.

--*/
{
    DWORD error;
    int i;
    struct sockaddr_in socketName;
    time_t TimeNow;
    BOOL   LockedInterface = FALSE;

    if ( *TransactionId == 0 ) {
        *TransactionId = (rand() << 16) + rand();
    }

    DhcpContext->MessageBuffer->TransactionID = *TransactionId;

    //
    // Initialize the outgoing address.
    //

    socketName.sin_family = PF_INET;
    socketName.sin_port = _I_htons( DHCP_SERVR_PORT );

    if ( IS_MDHCP_CTX(DhcpContext) ) {
        socketName.sin_addr.s_addr = DhcpContext->DhcpServerAddress;
        if ( CLASSD_NET_ADDR( DhcpContext->DhcpServerAddress ) ) {
            int   TTL = 16;
            //
            // Set TTL
            // MBUG: we need to read this from the registry.
            //
            if (_I_setsockopt(
                  DhcpContext->Socket,
                  IPPROTO_IP,
                  IP_MULTICAST_TTL,
                  (char *)&TTL,
                  sizeof((int)TTL)) == SOCKET_ERROR){

                 error = _I_WSAGetLastError();
                 DhcpPrint(("could not set MCast TTL %ld\n",error ));
                 return error;
            }

        }
    } else if( IS_ADDRESS_PLUMBED(DhcpContext) &&
               !IS_MEDIA_RECONNECTED(DhcpContext) &&    // media reconnect - braodcast
               !IS_POWER_RESUMED(DhcpContext) ) {       // power resumed - broadcast

        //
        // If we are past T2, use the broadcast address; otherwise,
        // direct this to the server.
        //

        TimeNow = time( NULL );

        // BUGBUG why did we broadcast here before ?
        if ( TimeNow > DhcpContext->T2Time && IS_CONNECTION_BROADCAST(DhcpContext)) {
            socketName.sin_addr.s_addr = (DHCP_IP_ADDRESS)(INADDR_BROADCAST);
        } else {
            socketName.sin_addr.s_addr = DhcpContext->DhcpServerAddress;
        }
    }
    else {
        socketName.sin_addr.s_addr = (DHCP_IP_ADDRESS)(INADDR_BROADCAST);
        INET_ASSERT(FALSE);
    }

    for ( i = 0; i < 8 ; i++ ) {
        socketName.sin_zero[i] = 0;
    }

    if( socketName.sin_addr.s_addr ==
            (DHCP_IP_ADDRESS)(INADDR_BROADCAST) ) {

        DWORD Error = ERROR_SUCCESS;

        //
        // BUGBUG TODO [arthurbi] This code below is needed for 
        //  Broadcasts to work.  We need to make some fancy driver
        //  calls to work...
        //

        //
        // if we broadcast a message, inform IP stack - the adapter we
        // like to send this broadcast on, otherwise it will pick up the
        // first uninitialized adapter.
        //

//        InterfaceId = DhcpContext->IpInterfaceContext;            
//
//        if( !IPSetInterface( InterfaceId ) ) {
//            // DhcpAssert( FALSE );
//            Error = ERROR_GEN_FAILURE;
//        }

//        InterfaceId = ((PLOCAL_CONTEXT_INFO)
//            DhcpContext->LocalInformation)->IpInterfaceContext;
//
//        LOCK_INTERFACE();
//        LockedInterface = TRUE;
//        Error = IPSetInterface( InterfaceId );
        // DhcpAssert( Error == ERROR_SUCCESS );

        if( ERROR_SUCCESS != Error ) {
            DhcpPrint(("IPSetInterface failed with %lx error\n", Error));
            UNLOCK_INTERFACE();
            return Error;
        }
    }

    //
    // send minimum DHCP_MIN_SEND_RECV_PK_SIZE (300) bytes, otherwise
    // bootp relay agents don't like the packet.
    //

    MessageLength = (DWORD)((MessageLength > DHCP_MIN_SEND_RECV_PK_SIZE) ?
                        MessageLength : DHCP_MIN_SEND_RECV_PK_SIZE);
    error = _I_sendto(
                DhcpContext->Socket,
                (PCHAR)DhcpContext->MessageBuffer,
                MessageLength,
                0,
                (struct sockaddr *)&socketName,
                sizeof( struct sockaddr )
                );

#ifndef VXD
    if( LockedInterface ) { UNLOCK_INTERFACE(); }
#endif  VXD

    if ( error == SOCKET_ERROR ) {
        error = _I_WSAGetLastError();
        DhcpPrint(("Send failed, error = %ld\n", error ));
    } else {
        IF_DEBUG( PROTOCOL ) {
            DhcpPrint(("Sent message to %s: \n", _I_inet_ntoa( socketName.sin_addr )));
        }

        DhcpDumpMessage( DEBUG_PROTOCOL_DUMP, DhcpContext->MessageBuffer );
        error = NO_ERROR;
    }

    return( error );
}

DWORD
OpenDhcpSocket(
    PDHCP_CONTEXT DhcpContext
    )
{

    DWORD Error;

    if ( DhcpContext->Socket != INVALID_SOCKET ) {
        return ( ERROR_SUCCESS );
    }

    //
    // create a socket for the dhcp protocol.  it's important to bind the
    // socket to the correct ip address.  There are currently three cases:
    //
    // 1.  If the interface has been autoconfigured, it already has an address,
    //     say, IP1.  If the client receives a unicast offer from a dhcp server
    //     the offer will be addressed to IP2, which is the client's new dhcp
    //     address.  If we bind the dhcp socket to IP1, the client won't be able
    //     to receive unicast responses.  So, we bind the socket to 0.0.0.0.
    //     This will allow the socket to receive a unicast datagram addressed to
    //     any address.
    //
    // 2.  If the interface in not plumbed (i.e. doesn't have an address) bind
    //     the socket to 0.0.0.0
    //
    // 3.  If the interface has been plumbed has in *not* autoconfigured, then
    //     bind to the current address.


    Error =  InitializeDhcpSocket(
                 &DhcpContext->Socket,
                 DhcpContext->IpAddress 
                 );

    if( Error != ERROR_SUCCESS ) {
        DhcpContext->Socket = INVALID_SOCKET;
        DhcpPrint((" Socket Open failed, %ld\n", Error ));
    }

    return(Error);
}

DWORD
CloseDhcpSocket(
    PDHCP_CONTEXT DhcpContext
    )
{

    DWORD Error = ERROR_SUCCESS;

    if( DhcpContext->Socket != INVALID_SOCKET ) {


        Error = _I_closesocket( DhcpContext->Socket );

        if( Error != ERROR_SUCCESS ) {
            DhcpPrint((" Socket close failed, %ld\n", Error ));
        }

        DhcpContext->Socket = INVALID_SOCKET;

        //
        // Reset the IP stack to send DHCP broadcast to first
        // uninitialized stack.
        //

        //Bool = IPResetInterface();
        //DhcpAssert( Bool == TRUE );
    }

    return( Error );
}


typedef     struct  /* anonymous */ {             // structure to hold waiting recvfroms
    LIST_ENTRY                     RecvList;      // other elements in this list
    PDHCP_CONTEXT                  Ctxt;          // which context is this wait for?
    DWORD                          InBufLen;      // what was the buffer size to recv in?
    PDWORD                         BufLen;        // how many bytes did we recvd?
    DWORD                          Xid;           // what xid is this wait for?
    time_t                         ExpTime;       // wait until what time?
    HANDLE                         WaitEvent;     // event for waiting on..
    BOOL                           Recd;          // was a packet received..?
} RECV_CTXT, *PRECV_CTXT;                         // ctxt used to recv on..

VOID
InsertInPriorityList(                             // insert in priority list according to Secs
    IN OUT  PRECV_CTXT             Ctxt,          // Secs field changed to hold offset
    IN      PLIST_ENTRY            List,
    OUT     PBOOL                  First          // adding in first location?
)
{

    if( IsListEmpty(List) ) {                     // no element in list? add this and quit
        *First = TRUE;                            // adding at head
    } else {
        *First = FALSE;                           // adding at tail..
    }

    InsertTailList( List, &Ctxt->RecvList);       // insert element..
    //LeaveCriticalSection( &DhcpGlobalRecvFromCritSect );
}

DWORD
TryReceive(                                       // try to recv pkt on 0.0.0.0 socket
    IN      SOCKET                 Socket,        // socket to recv on
    IN      LPBYTE                 Buffer,        // buffer to fill
    OUT     PDWORD                 BufLen,        // # of bytes filled in buffer
    OUT     PDWORD                 Xid,           // Xid of recd pkt
    IN      DWORD                  Secs           // # of secs to spend waiting?
)
{
    DWORD                          Error;
    struct timeval                 timeout;
    fd_set                         SockSet;
    struct sockaddr                SockName;
    int                            SockNameSize;

    FD_ZERO(&SockSet);
    FD_SET(Socket,&SockSet);

    SockNameSize = sizeof( SockName );

    timeout.tv_sec = Secs;
    timeout.tv_usec = 0;

    DhcpPrint(("Select: waiting for: %ld seconds\n", Secs));
    Error = _I_select( 0, &SockSet, NULL, NULL, &timeout );
    if( ERROR_SUCCESS == Error ) {            // timed out..
        DhcpPrint(("Recv timed out..\n"));
        return ERROR_SEM_TIMEOUT;
    }

    Error = _I_recvfrom(Socket,(char *)Buffer,*BufLen, 0, &SockName, &SockNameSize);
    if( SOCKET_ERROR == Error ) {
        Error = _I_WSAGetLastError();
        DhcpPrint(("Recv failed 0x%lx\n",Error));
    } else {
        *BufLen = Error;
        Error = ERROR_SUCCESS;
        *Xid = ((PDHCP_MESSAGE)Buffer)->TransactionID;
        DhcpPrint(("Recd msg XID: 0x%lx [Mdhcp? %s]\n", *Xid,
                   IS_MDHCP_MESSAGE(((PDHCP_MESSAGE)Buffer))?"yes":"no" ));

    }

    return Error;
}

VOID
DispatchPkt(                                      // find out any takers for Xid
    IN OUT  PRECV_CTXT             Ctxt,          // ctxt that has buffer and buflen
    IN      DWORD                  Xid            // recd Xid
)
{
    do {                                          // not a loop, just for ease of use
        LPBYTE                     Tmp;
        PLIST_ENTRY                Entry;
        PRECV_CTXT                 ThisCtxt;

        Entry = DhcpGlobalRecvFromList.Flink;
        while(Entry != &DhcpGlobalRecvFromList ) {
            ThisCtxt = CONTAINING_RECORD(Entry, RECV_CTXT, RecvList);
            Entry = Entry->Flink;

            if(Xid != ThisCtxt->Xid ) continue;   // mismatch.. nothing more todo

            // now check for same type of message and ctxt...
            if( (unsigned)IS_MDHCP_MESSAGE((Ctxt->Ctxt->MessageBuffer))
                !=
                IS_MDHCP_CTX( (ThisCtxt->Ctxt) )
            ) {
                //
                // The contexts dont match.. give up
                //
                continue;
            }

            //
            // check for same hardware address..
            //

            if( ThisCtxt->Ctxt->HardwareAddressLength != Ctxt->Ctxt->MessageBuffer->HardwareAddressLength ) {
                continue;
            }

            if( 0 != memcmp(ThisCtxt->Ctxt->HardwareAddress,
                            Ctxt->Ctxt->MessageBuffer->HardwareAddress,
                            ThisCtxt->Ctxt->HardwareAddressLength
            ) ) {
                continue;
            }

            // matched.. switch buffers to give this guy this due..

            DhcpDumpMessage(DEBUG_PROTOCOL_DUMP, (PDHCP_MESSAGE)(Ctxt->Ctxt->MessageBuffer) );

            *(ThisCtxt->BufLen) = *(Ctxt->BufLen);
            Tmp = (LPBYTE)(Ctxt->Ctxt)->MessageBuffer;
            (Ctxt->Ctxt)->MessageBuffer = (ThisCtxt->Ctxt)->MessageBuffer;
            (ThisCtxt->Ctxt)->MessageBuffer = (PDHCP_MESSAGE)Tmp;

            RemoveEntryList(&ThisCtxt->RecvList);
            InitializeListHead(&ThisCtxt->RecvList);
            DhcpAssert(FALSE == ThisCtxt->Recd);
            ThisCtxt->Recd = TRUE;
            if( 0 == SetEvent(ThisCtxt->WaitEvent) ) {
                DhcpAssert(FALSE);
            }

            break;
        }
    } while (FALSE);
    //LeaveCriticalSection(&DhcpGlobalRecvFromCritSect);
}

DWORD
ProcessRecvFromSocket(                            // wait using select and process incoming pkts
    IN OUT  PRECV_CTXT             Ctxt           // ctxt to use
)
{
    time_t                         TimeNow;
    SOCKET                         Socket;
    LPBYTE                         Buffer;
    DWORD                          Xid;
    DWORD                          Error;
    PLIST_ENTRY                    Entry;

    Socket = (Ctxt->Ctxt)->Socket;
    TimeNow = time(NULL);
    Xid = 0;

    Error = ERROR_SEM_TIMEOUT;
    while(TimeNow <= Ctxt->ExpTime ) {            // while required to wait
        Buffer = (LPBYTE)((Ctxt->Ctxt)->MessageBuffer);
        *(Ctxt->BufLen) = Ctxt->InBufLen;
        Error = TryReceive(Socket, Buffer, Ctxt->BufLen, &Xid, (DWORD)(Ctxt->ExpTime - TimeNow));
        if( ERROR_SUCCESS != Error ) {            // did not recv?
            if( WSAECONNRESET != Error ) break;   // ignore possibly spurious conn-resets..
            else {  TimeNow = time(NULL); continue; }
        }

        if( Xid == Ctxt->Xid ) break;             // this was destined for this ctxt only..

        DispatchPkt(Ctxt, Xid);
        TimeNow = time(NULL);
    }

    if( TimeNow > Ctxt->ExpTime ) {               // we timed out.
        Error = ERROR_SEM_TIMEOUT;
    }

    // now done.. so we must remove this ctxt from the list and signal first guy
    //EnterCriticalSection(&DhcpGlobalRecvFromCritSect);
    RemoveEntryList(&Ctxt->RecvList);
    CloseHandle(Ctxt->WaitEvent);
    if( !IsListEmpty(&DhcpGlobalRecvFromList)) {  // ok got an elt.. signal this.
        Entry = DhcpGlobalRecvFromList.Flink;
        Ctxt = CONTAINING_RECORD(Entry, RECV_CTXT, RecvList);
        if( 0 == SetEvent(Ctxt->WaitEvent) ) {
            DhcpAssert(FALSE);
        }
    }
    //LeaveCriticalSection(&DhcpGlobalRecvFromCritSect);

    return Error;
}

//================================================================================
//  get dhcp message with requested transaction id, but also make sure only one
//  socket is used at any given time (one socket bound to 0.0.0.0), and also
//  re-distribute message for some other thread if that is also required..
//================================================================================
DWORD
GetSpecifiedDhcpMessageEx(
    IN OUT  PDHCP_CONTEXT          DhcpContext,   // which context to recv for
    OUT     PDWORD                 BufferLength,  // how big a buffer was read?
    IN      DWORD                  Xid,           // which xid to look for?
    IN      DWORD                  TimeToWait     // how many seconds to sleep?
)
{
    RECV_CTXT                      Ctxt;          // element in list for this call to getspe..
    BOOL                           First;         // is this the first element in list?
    DWORD                          Result;

    Ctxt.Ctxt = DhcpContext;                      // fill in the context
    Ctxt.InBufLen = *BufferLength;
    Ctxt.BufLen = BufferLength;
    Ctxt.Xid = Xid;
    Ctxt.ExpTime = time(NULL) + TimeToWait;
    Ctxt.WaitEvent = CreateEvent(NULL,FALSE,FALSE,NULL);
    Ctxt.Recd = FALSE;
    if( NULL == Ctxt.WaitEvent ) {
        DhcpAssert(NULL != Ctxt.WaitEvent);
        return GetLastError();
    }

    First = FALSE;
    InsertInPriorityList(&Ctxt, &DhcpGlobalRecvFromList, &First);

    if( First ) {                                 // this *is* the first call to GetSpec..
        Result = ProcessRecvFromSocket(&Ctxt);
    } else {                                      // we wait for other calls to go thru..
        Result = WaitForSingleObject(Ctxt.WaitEvent, TimeToWait * 1000);
        //EnterCriticalSection(&DhcpGlobalRecvFromCritSect);
        if( Ctxt.Recd || WAIT_FAILED == Result || WAIT_TIMEOUT == Result ) {
            if( WAIT_FAILED == Result ) Result = GetLastError();
            else if (WAIT_TIMEOUT == Result ) Result = ERROR_SEM_TIMEOUT;
            else Result = ERROR_SUCCESS;

            RemoveEntryList(&Ctxt.RecvList);      // remove it from list
            //LeaveCriticalSection(&DhcpGlobalRecvFromCritSect);
            CloseHandle(Ctxt.WaitEvent);
            return Result;
        } else {
            DhcpAssert(WAIT_OBJECT_0 == Result && Ctxt.Recd == FALSE );
            // have not received a packet but have been woken up? must be first in line now..
            //LeaveCriticalSection(&DhcpGlobalRecvFromCritSect);
            Result = ProcessRecvFromSocket(&Ctxt);
        }
    }

    return Result;
}


#define RATIO 1
DWORD
GetSpecifiedDhcpMessage(
    PDHCP_CONTEXT DhcpContext,
    PDWORD BufferLength,
    DWORD TransactionId,
    DWORD TimeToWait
    )
/*++

Routine Description:

    This function waits TimeToWait seconds to receives the specified
    DHCP response.

Arguments:

    DhcpContext - A pointer to a DHCP context block.

    BufferLength - Returns the size of the input buffer.

    TransactionID - A filter.  Wait for a message with this TID.

    TimeToWait - Time, in milli seconds, to wait for the message.

Return Value:

    The status of the operation.  If the specified message has been
    been returned, the status is ERROR_TIMEOUT.

--*/
{
    struct sockaddr socketName;
    int socketNameSize = sizeof( socketName );
    struct timeval timeout;
    time_t startTime, now;
    DWORD error;
    DWORD actualTimeToWait;
    SOCKET clientSocket;
    fd_set readSocketSet;

    if( !IS_ADDRESS_PLUMBED(DhcpContext) ) {
        //
        // For RAS server Lease API this call won't happen as we don't have to do this nonsense
        //
        error = GetSpecifiedDhcpMessageEx(
            DhcpContext,
            BufferLength,
            TransactionId,
            TimeToWait
        );
        if( ERROR_SUCCESS == error ) {
            // received a message frm the dhcp server..
            SERVER_REACHED(DhcpContext);
        }
        return error;
    }

    startTime = time( NULL );
    actualTimeToWait = TimeToWait;

    //
    // Setup the file descriptor set for select.
    //

    clientSocket = DhcpContext->Socket;

    FD_ZERO( &readSocketSet );
    FD_SET( clientSocket, &readSocketSet );

    while ( 1 ) {

        timeout.tv_sec  = actualTimeToWait / RATIO;
        timeout.tv_usec = actualTimeToWait % RATIO;
        DhcpPrint(("Select: waiting for: %ld seconds\n", actualTimeToWait));
        error = _I_select( 0, &readSocketSet, NULL, NULL, &timeout );

        if ( error == 0 ) {

            //
            // Timeout before read data is available.
            //

            DhcpPrint(("Recv timed out\n", 0 ));
            error = ERROR_SEM_TIMEOUT;
            break;
        }

        error = _I_recvfrom(
                    clientSocket,
                    (PCHAR)DhcpContext->MessageBuffer,
                    *BufferLength,
                    0,
                    &socketName,
                    &socketNameSize
                    );

        if ( error == SOCKET_ERROR ) {
            error = _I_WSAGetLastError();
            DhcpPrint(("Recv failed, error = %ld\n", error ));

            if( WSAECONNRESET != error ) break;

            //
            // ignore connreset -- this could be caused by someone sending random ICMP port unreachable.
            //

        } else if (DhcpContext->MessageBuffer->TransactionID == TransactionId ) {
             
            DhcpPrint((  "Received Message, XID = %lx, MDhcp = %d.\n",
                            TransactionId,
                            IS_MDHCP_MESSAGE( DhcpContext->MessageBuffer) ));

            if (((unsigned)IS_MDHCP_MESSAGE( DhcpContext->MessageBuffer) == IS_MDHCP_CTX( DhcpContext))) {
                DhcpDumpMessage(DEBUG_PROTOCOL_DUMP, DhcpContext->MessageBuffer );

                *BufferLength = error;
                error = NO_ERROR;

                if( DhcpContext->MessageBuffer->HardwareAddressLength == DhcpContext->HardwareAddressLength
                    && 0 == memcmp(DhcpContext->MessageBuffer->HardwareAddress,
                                   DhcpContext->HardwareAddress,
                                   DhcpContext->HardwareAddressLength
                    )) {

                    //
                    // Transction IDs match, same type (MDHCP/DHCP), Hardware addresses match!
                    //

                    break;
                }
            }
        } else {            
            DhcpPrint(( "Received a buffer with unknown XID = %lx\n",
                         DhcpContext->MessageBuffer->TransactionID ));
        }

        //
        // We received a message, but not the one we're interested in.
        // Reset the timeout to reflect elapsed time, and wait for
        // another message.
        //
        now = time( NULL );
        actualTimeToWait = (DWORD)(TimeToWait - RATIO * (now - startTime));
        if ( (LONG)actualTimeToWait < 0 ) {
            error = ERROR_SEM_TIMEOUT;
            break;
        }
    }

    if ( ERROR_SEM_TIMEOUT != error )
    {
        //
        // a message was received from a DHCP server.  disable IP autoconfiguration.
        //

        SERVER_REACHED(DhcpContext);
    }

    return( error );
}


DWORD 
QueryWellKnownDnsName(
    OUT LPSTR * ppszAutoProxyUrl
    )
/*++

Routine Description:

    This function walks a list of standard DNS names trying to find
     an entry for "wpad.some-domain-here.org"  If it does, it constructs
     an URL that is suitable for use in auto-proxy.

Arguments:

    lpszAutoProxyUrl - Url used to return a successful auto-proxy discover

    dwAutoProxyUrlLength - length of buffer passed in above

Return Value:
        
    ERROR_SUCCESS - if we found a URL/DNS name

    ERROR_NOT_FOUND - on error

revised: joshco 7-oct-1998
  if we dont get a valid domain back, be sure and try
  the netbios name ("wpad") no trailing dot.

  revised: joshco 7-oct-1998
        use the define PROXY_AUTO_DETECT_PATH instead
        of hardcoding "wpad.dat"
        
--*/

{
#define WORK_BUFFER_SIZE 356

    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "QueryWellKnownDnsName",
                 "%x",
                 ppszAutoProxyUrl
                 ));

    char szHostDomain[WORK_BUFFER_SIZE];
    char * pszTemp = szHostDomain ;
    char *pszDot1 = NULL;
    char *pszDot2 = NULL;
    DWORD error = ERROR_NOT_FOUND;
    DWORD dwMinDomain = 2;  //  By default, assume domain is of the form: .domain-name.org

    lstrcpy(szHostDomain, "wpad.");
    pszTemp += (sizeof("wpad.") - 1);

    if ( SockGetSingleValue(CONFIG_DOMAIN,
                            (LPBYTE)pszTemp,
                            WORK_BUFFER_SIZE - sizeof("wpad.")
                            ) != ERROR_SUCCESS )
    {
        lstrcpy(szHostDomain, "wpad.");
        pszTemp = szHostDomain ;
        pszTemp += (sizeof("wpad.") - 1);
    }

    if (*pszTemp == '\0') 
    {
        // if the debug setting for no domain (netbios) or 
        // we didnt get back a valid domain, then just do the
        // netbios name.  
        // XXBUG sockgetsinglevalue returns true even if there is no domain

        INET_ASSERT(*(pszTemp  - 1 ) == '.');

        *(pszTemp - 1) = '\0';
    }

    // Now determine which form the domain name follows:
    //     domain-name.org
    //     domain-name.co.uk
    pszDot1 = &szHostDomain[lstrlen(szHostDomain)-1];

    while (pszDot1 >= szHostDomain && *pszDot1 != '.')
        pszDot1--;

    // Only check .?? endings
    if (pszDot1 >= szHostDomain && (pszDot1 + 3 == &szHostDomain[lstrlen(szHostDomain)]) )
    {
        pszDot2 = pszDot1 - 1;

        while (pszDot2 >= szHostDomain && *pszDot2 != '.')
           pszDot2--;
   
        if (pszDot2 >= szHostDomain && pszDot2 + 3 >= pszDot1)
        {
           // Domain ended in something of the form: .co.uk
           // This requires at least 3 pieces then to be considered a domain
           dwMinDomain = 3;
        }
        else if ((pszDot2 + 4) == pszDot1)
        {
            // Check domain endings of the form ending in .com.uk
            // These special 3-letter pieces also need 3 dots to be classified
            // as a domain.  Unfortunately, we can't leverage the equivalent
            // code used by cookies because there, the strings are reversed.
            static const char *s_pachSpecialDomains[] = {"COM", "EDU", "NET", "ORG", "GOV", "MIL", "INT" };

            for (int i=0; i < ARRAY_ELEMENTS(s_pachSpecialDomains); i++)
            {
                if (StrCmpNIC(pszDot2+1, s_pachSpecialDomains[i], 3) == 0)
                {
                    dwMinDomain = 3;
                    break;
                }
            }
        }
    }

    while (TRUE)
    {
        PHOSTENT lpHostent = _I_gethostbyname(szHostDomain);

        if ( lpHostent != NULL )
        {
            //
            // Found a host, extract the IP address and form an URL to use.
            //

            char *pszAddressStr;
            LPBYTE * addressList;
            struct  in_addr sin_addr;
            LPSTR lpszAutoProxyUrl;

            addressList         = (LPBYTE *)lpHostent->h_addr_list;
            *(LPDWORD)&sin_addr = *(LPDWORD)addressList[0] ;

            pszAddressStr = _I_inet_ntoa (sin_addr);

            INET_ASSERT(pszAddressStr);

            lpszAutoProxyUrl = NewString(NULL,
                                    lstrlen(pszAddressStr)
                                    + sizeof("http:///")
                                    + sizeof(PROXY_AUTO_DETECT_PATH));
            if (lpszAutoProxyUrl)
            {
                wsprintf(lpszAutoProxyUrl, "http://%s/%s", pszAddressStr, PROXY_AUTO_DETECT_PATH );
                *ppszAutoProxyUrl = lpszAutoProxyUrl;
                error = ERROR_SUCCESS;
            }
            else
            {
                error = ERROR_NOT_ENOUGH_MEMORY;
            }
            
            goto quit;
        }
        else
        {
            //
            // Did not find anything yet, reduce the domain level, 
            //  and if we're in the root domain stop and return error
            //

            DWORD dwPeriodCnt = 0, dwNewEndLength = 0;
            LPSTR lpszPeriod1 = NULL, lpszPeriod2 = NULL;

            for (pszTemp = szHostDomain; *pszTemp; pszTemp++ )
            {
                if ( *pszTemp == '.' ) {
                    dwPeriodCnt ++;
                    if ( lpszPeriod1 == NULL ) {
                        lpszPeriod1 = pszTemp;
                    }
                    else if ( lpszPeriod2 == NULL ) {
                        lpszPeriod2 = pszTemp;
                    }
                }
            }

            if ( dwPeriodCnt <= dwMinDomain) 
            {
                error = ERROR_NOT_FOUND;
                goto quit;
            }

            dwNewEndLength = lstrlen(lpszPeriod2);
            MoveMemory(lpszPeriod1, lpszPeriod2, dwNewEndLength);
            *(lpszPeriod1 + dwNewEndLength) = '\0';
        }
    }
quit:

    DEBUG_LEAVE(error);

    return error;    
}


//================================================================================
// End of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5.1\autoproxy\regexp.cpp ===
#include <wininetp.h>
#include "regexp.h"

BOOL test_match(int m, LPSTR target, int pattern[])     /* m = length of target */
{
    int    *match;
    int     i = -1;     /* Will be advanced to 0 */
    int     j = 0;      /* i = index to pattern, j = index to target */
    BOOL    fResult = FALSE;

    match = new int[INTERNET_MAX_URL_LENGTH];
    if (match == NULL)
        goto Cleanup;

advance:
    ++i;
    if (j > m)
        goto Cleanup;

    switch (pattern[i]) {
    case PAT_START:  if (j != 0) goto Cleanup; match[i] = 0; goto advance;
    case PAT_END:    if (target[j] == 0) {fResult = TRUE; goto Cleanup;} else goto retreat;
    case PAT_STAR:   match[i] = j = m; goto advance;
    case PAT_QUES:   if (j < m) goto match_one; else goto retreat;
    case PAT_AUGDOT: if (target[j] == '.') goto match_one;
             else if (target[j] == 0) goto match_zero;
             else goto retreat;
    case PAT_AUGQUES: if (target[j] && target[j] != '.')
            goto match_one; else goto match_zero;
    case PAT_AUGSTAR: if (target[j] && target[j] != '.') 
            goto match_one; else goto retreat;
    default:          if (target[j] == pattern[i])
            goto match_one; else goto retreat;
    }
match_one: match[i] = ++j; goto advance;
match_zero: match[i] = j; goto advance;

retreat:
    --i;
    switch (pattern[i]) {
    case PAT_START:  goto Cleanup;
    case PAT_END:    goto Cleanup;     /* Cannot happen */
    case PAT_STAR:   if (match[i] == match[i-1]) goto retreat;
             j = --match[i]; goto advance;
    case PAT_QUES:   goto retreat;
    case PAT_AUGDOT: goto retreat;
    case PAT_AUGQUES: if (match[i] == match[i-1]) goto retreat;
             j = --match[i]; goto advance;
    case PAT_AUGSTAR: goto retreat;
    default:          goto retreat;
    }

Cleanup:
    if (match)
        delete [] match;

    return fResult;
}

BOOL parse_pattern(LPSTR s, int pattern[])
{
    int i = 1;

    pattern[0] = PAT_START; /* Can be hard-coded into pattern[] */
    for (;;) {
    switch (*s) {
        case '*':   pattern[i] = PAT_STAR; break;
        case '?':   pattern[i] = PAT_QUES; break;
        case '^':
        switch (*++s) {
        case '.': pattern[i] = PAT_AUGDOT; break;
        case '?': pattern[i] = PAT_AUGQUES; break;
        case '*': pattern[i] = PAT_AUGSTAR; break;
        default: return FALSE;
        }
        break;
        case 0: pattern[i] = PAT_END; return TRUE;
        default:    pattern[i] = *s; break;
    }
    if (++i >= INTERNET_MAX_URL_LENGTH) return FALSE;
    ++s;
    }
}

BOOL match( LPSTR target, LPSTR regexp) 
{
    int *pattern;
    BOOL result;

    pattern = new int[INTERNET_MAX_URL_LENGTH];

    if (!target || (pattern==NULL))
        return FALSE;

    if (!parse_pattern(regexp,pattern)) 
        return FALSE;
    if (lstrlen(target) >= INTERNET_MAX_URL_LENGTH) 
        return FALSE;

    result = test_match(lstrlen(target),target,pattern);
    delete [] pattern;
    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5.1\autoproxy\regexp.h ===
#ifndef __REGEXP_H__
#define __REGEXP_H__

#include <windows.h>
#include "utils.h"

#define PAT_START	128	/* Special beginning-of-pattern marker */
#define PAT_END		129	/* Special end-of-pattern marker */
#define PAT_STAR	130	/* Zero or more of any character */
#define PAT_QUES	131	/* Exactly one of any character */
#define PAT_AUGDOT	132	/* Literal '.' or end-of-string */
#define PAT_AUGQUES	133	/* Empty string or non-'.' */
#define PAT_AUGSTAR	134	/* Single character that isn't a '.' */

BOOL test_match(int m, LPSTR target, int pattern[]);
BOOL parse_pattern(LPSTR s, int pattern[]);
BOOL match( LPSTR target, LPSTR regexp);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5.1\autoproxy\sockreg.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    sockreg.h

Abstract:

    Prototypes for sockreg.cxx

    stolen from Win95 winsock project (& modified)

Author:

    Richard L Firth (rfirth) 10-Feb-1994

Environment:

    Chicago/Snowball (i.e. Win32/Win16)

Revision History:

    10-Feb-1994 (rfirth)
        Created

--*/

//
// registry/config/ini items
//

#define CONFIG_HOSTNAME     1
#define CONFIG_DOMAIN       2
#define CONFIG_SEARCH_LIST  3
#define CONFIG_NAME_SERVER  4

//
// prototypes
//

UINT
SockGetSingleValue(
    IN UINT ParameterId,
    OUT LPBYTE Data,
    IN UINT DataLength
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5.1\autoproxy\stack.h ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: RameshV
// All dealings with the stack and other non-Dhcp components go through the API
// given here
//================================================================================

#ifndef STACK_H_INCLUDED
#define STACK_H_INCLUDED

//================================================================================
// Exported API's
//================================================================================

DWORD                                             // win32 status
DhcpClearAllStackParameters(                      // undo the effects
    IN      PDHCP_CONTEXT          DhcpContext    // the adapter to undo
);

DWORD                                             // win32 status
DhcpSetAllStackParameters(                        // set all stack details
    IN      PDHCP_CONTEXT          DhcpContext,   // the context to set stuff
    IN      PDHCP_FULL_OPTIONS     DhcpOptions    // pick up the configuration from off here
);

#endif STACK_H_INCLUDED

#ifndef SYSSTACK_H_INCLUDED
#define SYSSTACK_H_INCLUDED
//================================================================================
// imported api's
//================================================================================
DWORD                                             // return interface index or -1
DhcpIpGetIfIndex(                                 // get the IF index for this adapter
    IN      PDHCP_CONTEXT          DhcpContext    // context of adapter to get IfIndex for
);

DWORD                                             // win32 status
DhcpSetRoute(                                     // set a route with the stack
    IN      DWORD                  Dest,          // network order destination
    IN      DWORD                  DestMask,      // network order destination mask
    IN      DWORD                  IfIndex,       // interface index to route
    IN      DWORD                  NextHop,       // next hop n/w order address
    IN      BOOL                   IsLocal,       // is this a local address? (IRE_DIRECT)
    IN      BOOL                   IsDelete       // is this route being deleted?
);

#endif SYSSTACK_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5.1\autoproxy\tdiinfo.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-1993          **/
/********************************************************************/
/* :ts=4 */

//** TDIINFO.H - TDI Query/SetInfoEx definitons.
//
//	This file contains definitions for the extended TDI query and set info.
//	calls.
//

#ifndef TDI_INFO_INCLUDED
#define TDI_INFO_INCLUDED


#ifndef CTE_TYPEDEFS_DEFINED
#define CTE_TYPEDEFS_DEFINED

typedef unsigned long ulong;
typedef unsigned short ushort;
typedef unsigned char uchar;
typedef unsigned int uint;

#endif // CTE_TYPEDEFS_DEFINED


//* Structure of an entity ID.
typedef struct TDIEntityID {
	ulong		tei_entity;
	ulong		tei_instance;
} TDIEntityID;

//* Structure of an object ID.
typedef struct TDIObjectID {
	TDIEntityID	toi_entity;
	ulong		toi_class;
	ulong		toi_type;
	ulong		toi_id;
} TDIObjectID;

#define	MAX_TDI_ENTITIES			512

#define	INFO_CLASS_GENERIC			0x100
#define	INFO_CLASS_PROTOCOL			0x200
#define	INFO_CLASS_IMPLEMENTATION	0x300

#define	INFO_TYPE_PROVIDER			0x100
#define	INFO_TYPE_ADDRESS_OBJECT	0x200
#define	INFO_TYPE_CONNECTION		0x300

#define	ENTITY_LIST_ID				0

#define	GENERIC_ENTITY				0

#define	CO_TL_ENTITY				0x400
#define	CL_TL_ENTITY				0x401

#define	ER_ENTITY					0x380

#define	CO_NL_ENTITY				0x300
#define	CL_NL_ENTITY				0x301

#define	AT_ENTITY					0x280

#define	IF_ENTITY					0x200

#define	CONTEXT_SIZE				16


//* The following are IDs supported by all entities. They are of class
//	GENERIC and type PROVIDER.

#define	ENTITY_TYPE_ID				1			// The ID to get the entity
												// type. The return from this
												// type is an unsigned integer
												// (see below).


// Valid values to get back from entity type ID query.
#define	CO_TL_NBF					0x400		// Entity implements NBF prot.
#define	CO_TL_SPX					0x402		// Entity implements SPX prot.
#define	CO_TL_TCP					0x404		// Entity implements TCP prot.
#define	CO_TL_SPP					0x406		// Entity implements SPP prot.

#define	CL_TL_NBF					0x401		// CL NBF protocol.
#define	CL_TL_UDP					0x403		// Entity implements UDP.

#define	ER_ICMP						0x380		// The ICMP protocol.

#define	CL_NL_IPX					0x301		// Entity implements IPX.
#define	CL_NL_IP					0x303		// Entity implements IP.

#define	AT_ARP						0x280		// Entity implements ARP.
#define	AT_NULL						0x282		// Entity does no address
												// translation.

#define	IF_GENERIC					0x200		// Generic interface.
#define	IF_MIB						0x202		// Supports MIB-2 interface.


/*NOINC*/
//
// NT DeviceIoControl definitions for TdiExtendedInformationEx functions.
//

//
// QueryInformationEx IOCTL. The return buffer is passed as the OutputBuffer
// in the DeviceIoControl request. This structure is passed as the
// InputBuffer.
//
struct tcp_request_query_information_ex {
	TDIObjectID   ID;                     // object ID to query.
	uchar         Context[CONTEXT_SIZE];  // multi-request context. Zeroed
	                                      // for the first request.
};

typedef struct tcp_request_query_information_ex
        TCP_REQUEST_QUERY_INFORMATION_EX,
        *PTCP_REQUEST_QUERY_INFORMATION_EX;

//
// SetInformationEx IOCTL request structure. This structure is passed as the
// InputBuffer. The space allocated for the structure must be large enough
// to contain the structure and the set data buffer, which begins at the
// Buffer field. The OutputBuffer parameter in the DeviceIoControl is not used.
//
struct tcp_request_set_information_ex {
	TDIObjectID   ID;                // object ID to set.
	unsigned int  BufferSize;        // size of the set data buffer in bytes
	unsigned char Buffer[1];         // beginning of the set data buffer
};

typedef struct tcp_request_set_information_ex
               TCP_REQUEST_SET_INFORMATION_EX,
			   *PTCP_REQUEST_SET_INFORMATION_EX;


#endif // TDI_INFO_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5.1\autoproxy\tdistat.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-1993          **/
/********************************************************************/
/* :ts=4 */

//** TDISTAT.H - TDI status code definitions.
//
// This file contains the TDI status code definitions.

#ifndef NT

#define TDI_SUCCESS             0           // Success
#define TDI_NO_RESOURCES        1           // No resources.
#define TDI_ADDR_IN_USE         2           // Address already in use.
#define TDI_BAD_ADDR            3           // Address given is bad.
#define TDI_NO_FREE_ADDR        4           // No addresses available.
#define TDI_ADDR_INVALID        6           // Address object is invalid.
#define TDI_ADDR_DELETED        7           // Address object was deleted.
#define TDI_BUFFER_OVERFLOW     9           // Buffer overflowed.
#define TDI_BAD_EVENT_TYPE      10          // Bad event type.
#define TDI_BAD_OPTION          11          // Bad option or length.
#define TDI_CONN_REFUSED        14          // Connection was refused.
#define TDI_INVALID_CONNECTION  15          // Invalid connection.
#define TDI_ALREADY_ASSOCIATED  16          // Connection already associated.
#define TDI_NOT_ASSOCIATED      17          // Connection not associated.
#define TDI_CONNECTION_ACTIVE   18          // Connection is still active.
#define TDI_CONNECTION_ABORTED  19          // Connection was aborted.
#define TDI_CONNECTION_RESET    20          // Connection was reset.
#define TDI_TIMED_OUT           21          // Connection timed out.
#define TDI_GRACEFUL_DISC       22          // Received a graceful disconnect.
#define TDI_NOT_ACCEPTED        23          // Data not accepted.
#define TDI_MORE_PROCESSING     24          // More processing required.
#define TDI_INVALID_STATE       25          // TCB in an invalid state.
#define TDI_INVALID_PARAMETER   26          // An invalid parameter.
#define TDI_DEST_NET_UNREACH    27          // Destination net is unreachable.
#define TDI_DEST_HOST_UNREACH   28          // Dest. host is unreachable.
#define TDI_DEST_UNREACHABLE    TDI_DEST_HOST_UNREACH
#define TDI_DEST_PROT_UNREACH   29          // Destination protocol is
                                            // unreachable.
#define TDI_DEST_PORT_UNREACH   30          // Dest. port is unreachable.
#define TDI_INVALID_QUERY       31          // Invalid query type specified.
#define TDI_REQ_ABORTED         32          // Request was aborted for some
                                            // reason.
#define TDI_BUFFER_TOO_SMALL    33          // Buffer was too small.
#define TDI_CANCELLED           34          // The request was cancelled.
#define	TDI_BUFFER_TOO_BIG		35			// Send buffer was too big.
#define TDI_ITEM_NOT_FOUND      36          // Item not found.
#define TDI_INVALID_REQUEST     0xfe        // Invalid request.
#define TDI_PENDING             0xff        // Pending

#else

//
// Map to NT STATUS codes.
//
#define TDI_SUCCESS             STATUS_SUCCESS
#define TDI_NO_RESOURCES        STATUS_INSUFFICIENT_RESOURCES
#define TDI_ADDR_IN_USE         STATUS_ADDRESS_ALREADY_EXISTS
#define TDI_BAD_ADDR            STATUS_INVALID_ADDRESS_COMPONENT
#define TDI_NO_FREE_ADDR        STATUS_TOO_MANY_ADDRESSES
#define TDI_ADDR_INVALID        STATUS_INVALID_ADDRESS
#define TDI_ADDR_DELETED        STATUS_ADDRESS_CLOSED
#define TDI_BUFFER_OVERFLOW     STATUS_BUFFER_OVERFLOW
#define TDI_BAD_EVENT_TYPE      STATUS_INVALID_PARAMETER
#define TDI_BAD_OPTION          STATUS_INVALID_PARAMETER
#define TDI_CONN_REFUSED        STATUS_CONNECTION_REFUSED
#define TDI_INVALID_CONNECTION  STATUS_CONNECTION_INVALID
#define TDI_ALREADY_ASSOCIATED  STATUS_ADDRESS_ALREADY_ASSOCIATED
#define TDI_NOT_ASSOCIATED      STATUS_ADDRESS_NOT_ASSOCIATED
#define TDI_CONNECTION_ACTIVE   STATUS_CONNECTION_ACTIVE
#define TDI_CONNECTION_ABORTED  STATUS_CONNECTION_ABORTED
#define TDI_CONNECTION_RESET    STATUS_CONNECTION_RESET
#define TDI_TIMED_OUT           STATUS_IO_TIMEOUT
#define TDI_GRACEFUL_DISC       STATUS_GRACEFUL_DISCONNECT
#define TDI_NOT_ACCEPTED        STATUS_DATA_NOT_ACCEPTED
#define TDI_MORE_PROCESSING     STATUS_MORE_PROCESSING_REQUIRED
#define TDI_INVALID_STATE       STATUS_INVALID_DEVICE_STATE
#define TDI_INVALID_PARAMETER   STATUS_INVALID_PARAMETER
#define TDI_DEST_NET_UNREACH    STATUS_NETWORK_UNREACHABLE
#define TDI_DEST_HOST_UNREACH   STATUS_HOST_UNREACHABLE
#define TDI_DEST_UNREACHABLE    TDI_DEST_HOST_UNREACH
#define TDI_DEST_PROT_UNREACH   STATUS_PROTOCOL_UNREACHABLE
#define TDI_DEST_PORT_UNREACH   STATUS_PORT_UNREACHABLE
#define TDI_INVALID_QUERY       STATUS_INVALID_DEVICE_REQUEST
#define TDI_REQ_ABORTED         STATUS_REQUEST_ABORTED
#define TDI_BUFFER_TOO_SMALL    STATUS_BUFFER_TOO_SMALL
#define TDI_CANCELLED           STATUS_CANCELLED
#define	TDI_BUFFER_TOO_BIG		STATUS_INVALID_BUFFER_SIZE
#define TDI_INVALID_REQUEST     STATUS_INVALID_DEVICE_REQUEST
#define TDI_PENDING             STATUS_PENDING
#define TDI_ITEM_NOT_FOUND      STATUS_OBJECT_NAME_NOT_FOUND


#endif  // NT

#define	TDI_OPTION_EOL				0

#define	TDI_ADDRESS_OPTION_REUSE	1
#define	TDI_ADDRESS_OPTION_DHCP		2
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5.1\autoproxy\sockreg.cxx ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    sockreg.cxx

Abstract:

    Contains the registry/ini-file specific functions from gethost.c

    Taken from Win95 Winsock 1.1 project

    Contents:
        SockGetSingleValue
        (CheckRegistryForParameter)

Author:

    Richard L Firth (rfirth) 10-Feb-1994

Environment:

    Win32 user-mode DLL

Revision History:

    10-Feb-1994 (rfirth)
        Created

    24-Feb-2001 (ssulzer)
        Updated for WinHttp5

--*/

//
// includes
//


#include <wininetp.h>
#include "aproxp.h"



//
// manifests
//

//#define PLATFORM_TYPE_UNKNOWN       ((DWORD)(-1))
//#define PLATFORM_TYPE_WIN95         ((DWORD)(0))
//#define PLATFORM_TYPE_WINNT         ((DWORD)(1))

//#define PLATFORM_SUPPORTS_UNICODE   0x00000001
#define DEVICE_PREFIX       "\\Device\\"


//
// manifests
//

//
// macros
//

#define FSTRLEN(p)      lstrlen((LPSTR)(p))
#define FSTRCPY(p1, p2) lstrcpy((LPSTR)(p1), (LPSTR)(p2))
#define FSTRCAT(p1, p2) lstrcat((LPSTR)(p1), (LPSTR)(p2))

//
// MAP_PARAMETER_ID - returns a string corresponding to the database parameter
//
// N.B. id MUST start at 1
//

#define MAP_PARAMETER_ID(id)    ParameterNames[(id) - 1]

//
// globally available registry keys
//

extern HKEY ServicesKey;  //       = INVALID_HANDLE_VALUE;


//
// private prototypes
//

PRIVATE
UINT
CheckRegistryForParameter(
    IN UINT ParameterId,
    OUT LPBYTE Data,
    IN UINT DataLength
    );

//
// private data
//

//
// ParameterNames - the names of the registry values corresponding to the
// variables retrieved by SockGetSingleValue.
//
// N.B. These MUST be in order of the CONFIG_ manifests in sockreg.h
//

PRIVATE const LPCSTR ParameterNames[] = {
    "HostName",
    "Domain",
    "SearchList",
    "NameServer"
};

//
// functions
//

/*******************************************************************************
 *
 *  GetBoundAdapterList
 *
 *  Gets a list of names of all adapters bound to a protocol (TCP/IP). Returns
 *  a pointer to an array of pointers to strings - basically an argv list. The
 *  memory for the strings is concatenated to the array and the array is NULL
 *  terminated. If Elnkii1 and IbmTok2 are bound to TCP/IP then this function
 *  will return:
 *
 *          ---> addr of string1   \
 *               addr of string2    \
 *               NULL                > allocated as one block
 *     &string1: "Elnkii1"          /
 *     &string2: "IbmTok2"         /
 *
 *  ENTRY   BindingsSectionKey
 *              - Open registry handle to a linkage key (e.g. Tcpip\Linkage)
 *
 *  EXIT
 *
 *  RETURNS pointer to argv[] style array, or NULL
 *
 *  ASSUMES
 *
 ******************************************************************************/

LPSTR* GetBoundAdapterList(HKEY BindingsSectionKey)
{

    LPSTR* resultBuffer;

    LONG err;
    DWORD valueType;
    PBYTE valueBuffer = NULL;
    DWORD valueLength;
    LPSTR* nextResult;
    int len;
    DWORD resultLength;
    LPSTR nextValue;
    LPSTR variableData;
    DWORD numberOfBindings;

    //
    // get required size of value buffer
    //

    valueLength = 0;
    resultBuffer = NULL;

    err = RegQueryValueEx(BindingsSectionKey,
                          "Bind",
                          NULL, // reserved
                          &valueType,
                          NULL,
                          &valueLength
                          );
    if (err != ERROR_SUCCESS) {
        goto quit;
    }
    if (valueType != REG_MULTI_SZ) {
        goto quit;
    }
    if (!valueLength) {
        goto quit;
    }
    valueBuffer = (PBYTE)ALLOCATE_ZERO_MEMORY(valueLength);
    if ( valueBuffer == NULL ) {
        goto quit;
    }

    err = RegQueryValueEx(BindingsSectionKey,
                          "Bind",
                          NULL, // reserved
                          &valueType,
                          valueBuffer,
                          &valueLength
                          );
    if (err != ERROR_SUCCESS) {
        goto quit;
    }
    resultLength = sizeof(LPSTR);   // the NULL at the end of the list
    numberOfBindings = 0;
    nextValue = (LPSTR)valueBuffer;
    while (0 != (len = strlen(nextValue))) {
        resultLength += sizeof(LPSTR) + len + 1;
        if (!_strnicmp(nextValue, DEVICE_PREFIX, sizeof(DEVICE_PREFIX) - 1)) {
            resultLength -= sizeof(DEVICE_PREFIX) - 1;
        }
        nextValue += len + 1;
        ++numberOfBindings;
    }
    resultBuffer = (LPSTR*)ALLOCATE_ZERO_MEMORY(resultLength);
    if ( resultBuffer == NULL ) {
        goto quit;
    }
    nextValue = (LPSTR)valueBuffer;
    nextResult = resultBuffer;
    variableData = (LPSTR)(((LPSTR*)resultBuffer) + numberOfBindings + 1);
    while (numberOfBindings--) {

        LPSTR adapterName;

        adapterName = nextValue;
        if (!_strnicmp(adapterName, DEVICE_PREFIX, sizeof(DEVICE_PREFIX) - 1)) {
            adapterName += sizeof(DEVICE_PREFIX) - 1;
        }
        *nextResult++ = variableData;
        strcpy(variableData, adapterName);
        while (*variableData) {
            ++variableData;
        }
        ++variableData;
        while (*nextValue) {
            ++nextValue;
        }
        ++nextValue;
    }

    *nextResult = NULL;

quit:

    if ( valueBuffer != NULL )
    {
        FREE_MEMORY(valueBuffer);
    }

    return resultBuffer;
}


/*******************************************************************************
 *
 *  OpenAdapterKey
 *
 *  Opens one of the 2 per-adapter registry keys: <Adapter>\Parameters\Tcpip, or
 *  NetBT\Adapters\<Adapter>
 *
 *  ENTRY   KeyType - KEY_TCP or KEY_NBT
 *          Name    - pointer to adapter name to use
 *          Key     - pointer to returned key
 *
 *  EXIT    Key updated
 *
 *  RETURNS TRUE if success
 *
 *  ASSUMES
 *
 ******************************************************************************/

BOOL OpenAdapterKey(DWORD KeyType, LPSTR Name, PHKEY Key)
{

    LONG err;
    CHAR keyName[MAX_ADAPTER_NAME_LENGTH + sizeof("\\Parameters\\Tcpip")];

    if ((lstrlen(Name)+sizeof("\\Parameters\\Tcpip")) < ARRAY_ELEMENTS(keyName))
    {
        if (KeyType == KEY_TCP) {

            //
            // open the handle to this adapter's TCPIP parameter key
            //

            strcpy(keyName, Name);
            strcat(keyName, "\\Parameters\\Tcpip");
        } else if (KeyType == KEY_NBT) {

            //
            // open the handle to the NetBT\Adapters\<Adapter> handle
            //

            strcpy(keyName, "NetBT\\Adapters\\");
            strcat(keyName, Name);
        }
    }
    else
    {
        INET_ASSERT((lstrlen(Name)+sizeof("\\Parameters\\Tcpip")) < ARRAY_ELEMENTS(keyName));
        return FALSE;
    }

    err = REGOPENKEY(ServicesKey,
                     keyName,
                     Key
                     );


    DEBUG_PRINT( SOCKETS,
                 INFO,
                 ("RegOpenKey %s %s %s %d\n",
                 SERVICES_KEY_NAME, keyName,
                 (err != ERROR_SUCCESS )? "failed":"success",
                 GetLastError()                              ));


    return (err == ERROR_SUCCESS);
}

/*******************************************************************************
 *
 *  ReadRegistryDword
 *
 *  Reads a registry value that is stored as a DWORD
 *
 *  ENTRY   Key             - open registry key where value resides
 *          ParameterName   - name of value to read from registry
 *          Value           - pointer to returned value
 *
 *  EXIT    *Value = value read
 *
 *  RETURNS TRUE if success
 *
 *  ASSUMES
 *
 ******************************************************************************/

BOOL ReadRegistryDword(HKEY Key, LPSTR ParameterName, LPDWORD Value)
{

    LONG err;
    DWORD valueLength;
    DWORD valueType;

    valueLength = sizeof(*Value);

    err = RegQueryValueEx(Key,
                          ParameterName,
                          NULL, // reserved
                          &valueType,
                          (LPBYTE)Value,
                          &valueLength
                          );

    if(    (err         == ERROR_SUCCESS )
        && (valueType   == REG_DWORD     )
        && (valueLength == sizeof(DWORD))) {

        return 1;
    } else {
        DEBUG_PRINT(SOCKETS, INFO,
                 ("ReadRegistryDword(%s): err=%d\n", ParameterName, err ));
        return 0;
    }

}

/*******************************************************************************
 *
 *  ReadRegistryString
 *
 *  Reads a registry value that is stored as a string
 *
 *  ENTRY   Key             - open registry key
 *          ParameterName   - name of value to read from registry
 *          String          - pointer to returned string
 *          Length          - IN: length of String buffer. OUT: length of returned string
 *
 *  EXIT    String contains string read
 *
 *  RETURNS TRUE if success
 *
 *  ASSUMES
 *
 ******************************************************************************/

BOOL
ReadRegistryString(HKEY Key, LPSTR ParameterName, LPSTR String, LPDWORD Length)
{

    LONG err;
    DWORD valueType;

    *String = '\0';
    err = RegQueryValueEx(Key,
                          ParameterName,
                          NULL, // reserved
                          &valueType,
                          (LPBYTE)String,
                          Length
                          );

    if (err == ERROR_SUCCESS) {

        INET_ASSERT(valueType == REG_SZ || valueType == REG_MULTI_SZ);

        return  (*Length) > sizeof(char);

    } else {
        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("ReadRegistryString(%s): err=%d\n", ParameterName, err ));
        return 0;
    }

}



UINT
SockGetSingleValue(
    IN UINT ParameterId,
    OUT LPBYTE Data,
    IN UINT DataLength
    )

/*++

Routine Description:

    Retrieve parameter from Registry/DHCP/TCPIP

    This is what we look for and where:

        HostName:   1. HKLM\Services\CurrentControlSet\System\Vxd\MSTCP\HostName                (Win95)
                       HKLM\Services\CurrentControlSet\System\Tcpip\Parameters\Hostname         (NT)
                    2. (SYSTEM.INI:DNS.HostName)*                                               (N/A)
                    3. GetComputerName()

        DomainName: 1. HKLM\Services\CurrentControlSet\System\Vxd\MSTCP\Domain                  (Win95)
                       HKLM\Services\CurrentControlSet\System\Tcpip\Parameters\DhcpDomain       (NT)
                       HKLM\Services\CurrentControlSet\System\Tcpip\Parameters\Domain           (NT)
                    2. (SYSTEM.INI:DNS.DomainName)*                                             (N/A)
                    3. DHCP                                                                     (Win95)

        SearchList: 1. HKLM\Services\CurrentControlSet\System\Vxd\MSTCP\SearchList              (Win95)
                       HKLM\Services\CurrentControlSet\System\Tcpip\Parameters\SearchList       (NT)
                    2. (SYSTEM.INI:DNS.DNSDomains)*                                             (N/A)

        NameServer: 1. HKLM\Services\CurrentControlSet\System\Vxd\MSTCP\NameServer              (Win95)
                       HKLM\Services\CurrentControlSet\System\Tcpip\Parameters\DhcpNameServer   (NT)
                       HKLM\Services\CurrentControlSet\System\Tcpip\Parameters\NameServer       (NT)
                    2. (SYSTEM.INI:DNS.DNSServers)*                                             (N/A)
                    3. DHCP                                                                     (Win95)

        * Entries marked thus are registry backups from SYSTEM.INI until all
          keys are moved into registry or if platform is WFW 3.11 (in which
          case there is no registry)

    ASSUMES 1. Data is big enough to hold the default value (single byte for
               strings, dword for dwords)
            2. Registry is accessible from 16-bit code too

Arguments:

    ParameterId - identifier of parameter to retrieve

    Data        - pointer to untyped storage space for parameter

    DataLength  - length of data returned (in bytes)

Return Value:

    UINT
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND
                    can't locate required parameter in registry/ini/etc.

--*/

{
    UINT error = CheckRegistryForParameter(ParameterId, Data, DataLength);

    //
    // if the value was not in the registry then we must attempt to get it from
    // another place, specific to the particular variable requested
    //

    if (error != ERROR_SUCCESS) {
        if (ParameterId == CONFIG_HOSTNAME) {

            //
            // on Win32 platform we can call GetComputerName() to provide the
            // computer name, which is the default host name, if none is
            // specified elsewhere
            //

            DWORD length;

            length = DataLength;
            if (!GetComputerName((LPSTR)Data, &length)) {
                error = GetLastError();
            }
        } else if (ParameterId == CONFIG_DOMAIN) {
            if (GlobalPlatformType == PLATFORM_TYPE_WIN95) {
//                error = GetDomainNameFromDhcp(Data, DataLength);
                  INET_ASSERT(FALSE && "Not implemented on Win9x; port code from WinInet");
            }
        } else if (ParameterId == CONFIG_NAME_SERVER) {
            if (GlobalPlatformType == PLATFORM_TYPE_WIN95) {
//                error = GetDnsServerListFromDhcp(Data, DataLength);
                  INET_ASSERT(FALSE && "Not implemented on Win9x; port code from WinInet");
            }
        } else {

            //
            // the caller is requesting the domain list (or an invalid config
            // parameter value?!?). We have nowhere else to get this value -
            // return an error
            //

            error = ERROR_PATH_NOT_FOUND;
        }
    }

    IF_DEBUG(REGISTRY) {
        if (error != ERROR_SUCCESS) {
            DEBUG_PRINT(SOCKETS, INFO,
                        ("SockGetSingleValue(%s) returns %d\r",
                        MAP_PARAMETER_ID(ParameterId),
                        error
                        ));
        } else {
            DEBUG_PRINT(SOCKETS, INFO,
                        ("SockGetSingleValue(%s) returns \"%s\"\n",
                        MAP_PARAMETER_ID(ParameterId),
                        Data
                        ));
        }
    }

    return error;
}


PRIVATE
UINT
CheckRegistryForParameter(
    IN UINT ParameterId,
    OUT LPBYTE Data,
    IN UINT DataLength
    )

/*++

Routine Description:

    Retrieve parameter from registry

    ASSUMES 1. Data is big enough to hold the default value (single byte for
               strings, dword for dwords)

Arguments:

    ParameterId - identifier of parameter to retrieve

    Data        - pointer to untyped storage space for parameter

    DataLength  - length of data returned (in bytes)

Return Value:

    UINT
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND
                  ERROR_INSUFFICIENT_BUFFER

--*/

{
    HKEY key;
    LONG error = REGOPENKEY(HKEY_LOCAL_MACHINE,
                            (GlobalPlatformType == PLATFORM_TYPE_WINNT)
                            ? "System\\CurrentControlSet\\Services\\Tcpip\\Parameters"
                            : "System\\CurrentControlSet\\Services\\VxD\\MSTCP",
                            &key
                            );
    if (error == ERROR_SUCCESS) {

        char dhcpBuffer[128];   // arbitrary
        LPSTR p;
        DWORD length;
        DWORD type;
        BOOL tryDhcp;

        if (GlobalPlatformType == PLATFORM_TYPE_WINNT) {
            FSTRCPY(dhcpBuffer, "Dhcp");
            p = &dhcpBuffer[sizeof("Dhcp") - 1];
            tryDhcp = TRUE;
        } else {
            p = dhcpBuffer;
            tryDhcp = FALSE;
        }

        FSTRCPY(p, MAP_PARAMETER_ID(ParameterId));

        //
        // on NT, we look first for the manually-entered variables e.g. "Domain"
        // and if not found, we look a second time for the DHCP-configured
        // variant, e.g. "DhcpDomain"
        //

        for (int i = 0; i < 2; ++i) {

            //
            // if NT, first we try the transient key which is written to the
            // registry when we have a dial-up connection
            //

            if ((i == 0) && (GlobalPlatformType == PLATFORM_TYPE_WINNT)) {

                HKEY transientKey;

                error = REGOPENKEY(key, "Transient", &transientKey);
                if (error == ERROR_SUCCESS) {
                    length = DataLength;
                    error = RegQueryValueEx(transientKey,
                                            p,
                                            NULL,   // reserved
                                            &type,
                                            Data,
                                            &length
                                            );
                    REGCLOSEKEY(transientKey);

                    //
                    // if we succeeded in retrieving a non-empty string then
                    // we're done.
                    //
                    // We test for > 1 because the registry returns the length
                    // including the zero-terminator
                    //

                    if ((error == ERROR_SUCCESS) && (length > 1)) {
                        break;
                    }
                }
            }


            length = DataLength;
            error = RegQueryValueEx(key,
                                    p,
                                    NULL,   // reserved
                                    &type,
                                    Data,
                                    &length
                                    );

            //
            // if the key exists, but there is no value then return an error OR
            // if we didn't find the key (or value) AND NT then try for the DHCP
            // version (Note: We try for DhcpSearchList even though it doesn't
            // exist)
            //

            if ((error != ERROR_SUCCESS)
            || (length == 0)
            || ((length == 1) && (Data[0] == '\0'))) {
                if (tryDhcp) {
                    p = dhcpBuffer;
                    tryDhcp = FALSE;
                    continue;
                } else {
                    error = ERROR_PATH_NOT_FOUND;
                    break;
                }
            } else if ((UINT)length > DataLength) {
                error = ERROR_INSUFFICIENT_BUFFER;
                break;
            }
        }
        REGCLOSEKEY(key);
    }

    IF_DEBUG(REGISTRY) {
        DEBUG_PRINT(SOCKETS, INFO,
                    ("CheckRegistryForParameter(%s): returning %d\n",
                    MAP_PARAMETER_ID(ParameterId),
                    error
                    ));
    }

    return (UINT)error;
}



UINT
GetDhcpServerFromDhcp(
    IN OUT CAdapterInterface * paiInterface
    )

/*******************************************************************************
 *
 *  GetDhcpServerFromDhcp
 *
 *  Updates an CAdapterInterface with the DHCP server from the DHCP info
 *
 *  ENTRY   paiInterface - pointer to CAdapterInterface to update
 *
 *  EXIT    paiInterface - DhcpServer may be updated
 *
 *  RETURNS TRUE if AdapterInfo->DhcpServer updated
 *
 *  ASSUMES 1. AdapterInfo->Address is valid
 *
 ******************************************************************************/

{
    if ( GlobalPlatformType == PLATFORM_TYPE_WINNT )
    {
        HKEY key;

        if (paiInterface->GetAdapterName() &&
            OpenAdapterKey(KEY_TCP, paiInterface->GetAdapterName(), &key))
        {
            char dhcpServerAddress[4 * 4];
            DWORD addressLength;
            DWORD fDhcpEnabled = FALSE;

            ReadRegistryDword(key,
                              "EnableDHCP",
                              &fDhcpEnabled
                              );

            if ( fDhcpEnabled )
            {

                addressLength = sizeof(dhcpServerAddress);
                if (ReadRegistryString(key,
                                       "DhcpServer",
                                       dhcpServerAddress,
                                       &addressLength
                                       ))
                {
                    DWORD ipAddress = _I_inet_addr(dhcpServerAddress);

                    if ( IS_VALID_NON_LOOPBACK_IP_ADDRESS(ipAddress) )
                    {
                        paiInterface->AddDhcpServer(ipAddress);
                        paiInterface->SetDhcp();
                    }
                }
            }

            //ReadRegistryDword(key,
            //                  "LeaseObtainedTime",
            //                  &AdapterInfo->LeaseObtained
            //                  );

            //ReadRegistryDword(key,
            //                  "LeaseTerminatesTime",
            //                  &AdapterInfo->LeaseExpires
            //                  );


            REGCLOSEKEY(key);
            return fDhcpEnabled;
        }
    }
    else
    {
        INET_ASSERT(FALSE && "GetDhcpServerFromDhcp() not implemented on Win9x; port code from WinInet");
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5.1\autoproxy\utils.h ===
#ifndef __UTILS_H__
#define __UTILS_H__

#include <windows.h>
#include <olectl.h>
#include <shlwapi.h>

// BUGBUG - remove and include wininet.h
#include "autoprox.hxx"

/********************************************************************************************/
// ClassID and GUID helpers
HRESULT GetScriptEngineClassIDFromName(LPCSTR pszLanguage,LPSTR pszBuff,UINT cBuffSize);

/********************************************************************************************/
// String Helper functions and macros
// allocates a temporary buffer that will disappear when it goes out of scope
// NOTE: be careful of that -- make sure you use the string in the same or
// nested scope in which you created this buffer. people should not use this
// class directly.  use the macro(s) below.
//
class TempBuffer {
  public:
    TempBuffer(ULONG cBytes) {
        m_pBuf = (cBytes <= 120) ? (char *)&m_szTmpBuf : (new(char[cBytes]));
        m_fHeapAlloc = (cBytes > 120);
    }
    ~TempBuffer() {
        if (m_pBuf && m_fHeapAlloc) delete m_pBuf;
    }
    void *GetBuffer() {
        return m_pBuf;
    }

  private:
    void *m_pBuf;
    // we'll use this temp buffer for small cases.
    //
    char  m_szTmpBuf[120];
    unsigned m_fHeapAlloc:1;
};

// given and ANSI String, copy it into a wide buffer.
// be careful about scoping when using this macro!
//
// how to use the below two macros:
//
//  ...
//  LPSTR pszA;
//  pszA = MyGetAnsiStringRoutine();
//  MAKE_WIDEPTR_FROMANSI(pwsz, pszA);
//  MyUseWideStringRoutine(pwsz);
//  ...
//
// similarily for MAKE_ANSIPTR_FROMWIDE.  note that the first param does not
// have to be declared, and no clean up must be done.
//
#define MAKE_WIDEPTR_FROMANSI(ptrname, ansistr) \
    long __l##ptrname = (lstrlen(ansistr) + 1) * sizeof(WCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    MultiByteToWideChar(CP_ACP, 0, ansistr, -1, (LPWSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname); \
    LPWSTR ptrname = (LPWSTR)__TempBuffer##ptrname.GetBuffer()

#define MAKE_ANSIPTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (lstrlenW(widestr) + 1) * 2 * sizeof(char); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    WideCharToMultiByte(CP_ACP, 0, widestr, -1, (LPSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname, NULL, NULL); \
    LPSTR ptrname = (LPSTR)__TempBuffer##ptrname.GetBuffer()

LPWSTR MakeWideStrFromAnsi( LPCSTR, BYTE bType);
#define STR_BSTR   0
#define STR_OLESTR 1
#define BSTRFROMANSI(x)    (BSTR)MakeWideStrFromAnsi((LPSTR)(x), STR_BSTR)
#define OLESTRFROMANSI(x)  (LPOLESTR)MakeWideStrFromAnsi((LPSTR)(x), STR_OLESTR)

int ConvertAnsiDayToInt(LPSTR szday);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5.1\autoproxy\vdhcpapi.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    vdhcpapi.h

Abstract:

    Worker functions for VDHCP APIs.

Author:

    Madan Appiah (madana)  28-May-1994

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef VDHCPAPI_H_
#define VDHCPAPI_H_

#define DHCP_QUERY_INFO             1
#define DHCP_RENEW_IPADDRESS        2
#define DHCP_RELEASE_IPADDRESS      3

typedef struct _DHCP_NIC_INFO {
    DWORD OffsetHardwareAddress;
    DWORD HardwareLength;
    DWORD IpAddress;
    DWORD Lease;
    DWORD LeaseObtainedTime;
    DWORD LeaseExpiresTime;
    DWORD DhcpServerAddress;
    DWORD DNSServersLen;
    DWORD OffsetDNSServers;
    DWORD DomainNameLen;
    DWORD OffsetDomainName;
} DHCP_NIC_INFO, *LPDHCP_NIC_INFO;

typedef struct _DHCP_HW_INFO {
    DWORD OffsetHardwareAddress;
    DWORD HardwareLength;
} DHCP_HW_INFO, *LPDHCP_HW_INFO;

typedef struct _DHCP_QUERYINFO {
    DWORD NumNICs;
    DHCP_NIC_INFO NicInfo[1];
} DHCP_QUERYINFO, *LPDHCP_QUERYINFO;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5.1\autoproxy\wscntl.h ===
/**********************************************************************/
/**                        Microsoft Windows                         **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    wscntl.h

    Semi-public include file for the WsControl API in the Chicago/
    Snowball Windows Sockets implementation.


    FILE HISTORY:
        KeithMo     04-Feb-1994 Created.

*/


#ifndef _WSCNTL_H_
#define _WSCNTL_H_


//
//  Function prototypes.
//

DWORD
PASCAL FAR
WsControl(
	DWORD	Protocol,
	DWORD	Action,
	LPVOID	InputBuffer,
	LPDWORD	InputBufferLength,
	LPVOID	OutputBuffer,
	LPDWORD	OutputBufferLength
	);

typedef DWORD (PASCAL FAR * LPWSCONTROL)( DWORD   Protocol,
                                          DWORD   Action,
                                          LPVOID  InputBuffer,
                                          LPDWORD InputBufferLength,
                                          LPVOID  OutputBuffer,
                                          LPDWORD OutputBufferLength );


//
//  TCP/IP action codes.
//

#define WSCNTL_TCPIP_QUERY_INFO             0x00000000
#define WSCNTL_TCPIP_SET_INFO               0x00000001


#endif	// _WSCNTL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5.1\common\buffer.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    buffer.cxx

Abstract:

    Contains code to impliment a double buffering class used in SSL/PCT (secure channel)
        transactions.


Author:

    Arthur L Bierer (arthurbi) 20-March-1996

Revision History:

    20-March-1996 arthurbi
        Created

--*/

#include <wininetp.h>


BOOL
DBLBUFFER::InitBuffer(
    BOOL fDblBufferMode
    )

/*++

Routine Description:

    Allocates, and initalizes internal buffers.

Arguments:

    fDblBufferMode  - TRUE if we are to maintain to buffers,
                      FALSE if we treat the output and input buffers the same

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE, not enough memory to allocate buffers.

Comments:


--*/

{
    DEBUG_ENTER((DBG_BUFFER,
                 Bool,
                 "DBLBUFFER::InitBuffer",
                 "%B",
                 fDblBufferMode
                 ));

    INET_ASSERT(_lpBuffer == NULL);
    INET_ASSERT(_dwInitDefaultBufferSize > 0 );

    _lpBuffer = (LPBYTE)ALLOCATE_FIXED_MEMORY(_dwInitDefaultBufferSize);

    DEBUG_PRINT(API,
                INFO,
                ("allocated %d byte buffer %#x\n",
                _dwInitDefaultBufferSize,
                _lpBuffer
                ));

    BOOL success = FALSE;

    if (_lpBuffer != NULL) {

        INET_ASSERT(_dwBufferOut == 0);
        INET_ASSERT(_dwBufferIn == 0);

        _fDblBufferMode = fDblBufferMode;

        _dwBufferLength = _dwInitDefaultBufferSize ;
        _lpBufferOut = _lpBuffer + _dwBufferLength;
        _lpBufferIn      = _lpBuffer + _dwBufferLength;

        success = TRUE;
    }

    DEBUG_LEAVE(success);

    return success;
}

DWORD
DBLBUFFER::GetInputBufferRemaining(
    VOID
    )

/*++

Routine Description:

    Determines the amount of free bytes availble for reading into the input buffer.
        Will attempt to push current data to the front of the buffer, to make the
        most room in the currently allocated buffer.

Arguments:

    none.

Return Value:

    DWORD
        Number of bytes free.

Comments:

        Assumed to only be called in DblBuffer mode.

--*/


{
    DEBUG_ENTER((DBG_INET,
                 Int,
                 "DBLBUFFER::GetInputBufferRemaining",
                 NULL
                 ));


    INET_ASSERT(_lpBuffer);
    INET_ASSERT(_dwBufferOut == 0 );
    INET_ASSERT(_fDblBufferMode );


    BOOL fIsInputBufferCompressed = (_lpBufferIn == _lpBuffer);

    if ( ! fIsInputBufferCompressed )
    {
        BOOL fIsSuccess;

        fIsSuccess = CompressInputBufferUsage( ) ;

        INET_ASSERT(fIsSuccess);
    }

    INET_ASSERT(_lpBufferIn == _lpBuffer );

    DEBUG_LEAVE((DWORD) (_lpEndOfBuffer - (_dwBufferIn + _lpBuffer) ));

    return (DWORD) (_lpEndOfBuffer - (_dwBufferIn + _lpBuffer) );
}

BOOL
DBLBUFFER::CopyIn(
    IN LPBYTE lpBuffer,
    IN DWORD dwBufferSize
    )
{

    DEBUG_ENTER((DBG_INET,
                 Bool,
                 "DBLBUFFER::CopyIn",
                 "%x, %d",
                 lpBuffer,
                 dwBufferSize
                 ));


    INET_ASSERT(lpBuffer);
    INET_ASSERT(dwBufferSize > 0);

    LPBYTE pbPointer;
    DWORD  dwCurInputSize;

    //
    // Get the current input buffer size
    //

    dwCurInputSize = GetInputBufferSize();

    if ( ! ResizeBufferIfNeeded(dwBufferSize) )
    {
        DEBUG_LEAVE(FALSE);
        return FALSE;
    }

    pbPointer = GetInputBufferPointer()+dwCurInputSize;
    SetInputBufferSize(dwBufferSize+dwCurInputSize);


    CopyMemory(
        pbPointer,             // dest
        lpBuffer,              // src
        dwBufferSize           // size
        );


    DEBUG_LEAVE(TRUE);

    return TRUE;

}

BOOL
DBLBUFFER::CopyOut(
    OUT LPBYTE     lpBuffer,
    IN OUT LPDWORD lpdwBufferRemaining,
    IN OUT LPDWORD lpdwBytesReceived,
    IN OUT LPDWORD lpdwBytesRead
    )

/*++

Routine Description:

    Fills passed in buffer with the contents of the output buffer.

Arguments:

    lpBuffer                    -       Buffer to fill with output buffer bytes

        lpdwBufferRemaining -   Number of bytes remaining in Buffer to fill.

        lpdwBytesReceived       -       Number of bytes currently in Buffer to fill.

        lpdwBytesRead           -       Current total of bytes copied into Buffer to fill.

Return Value:

    BOOL
    Success - TRUE

    Failure - FALSE

Comments:


--*/

{

    DEBUG_ENTER((DBG_INET,
                 Bool,
                 "DBLBUFFER::CopyOut",
                 "%x, %u, %u, %u",
                 lpBuffer,
                 (lpdwBufferRemaining ? *lpdwBufferRemaining : 0),
                 (lpdwBytesReceived ? *lpdwBytesReceived : 0),
                 (lpdwBytesRead ? *lpdwBytesRead : 0)
                 ));


    INET_ASSERT(lpBuffer);
    INET_ASSERT(lpdwBufferRemaining);
    INET_ASSERT(lpdwBytesReceived);
    INET_ASSERT(lpdwBytesRead);

    //
    // Figure out the max number of bytes we can copy into our user's buffer
    //      We need to make sure it will fit into the user's buffer.
    //

    DWORD dwBytesToCopy = (*lpdwBufferRemaining  >= _dwBufferOut)
            ? _dwBufferOut : *lpdwBufferRemaining;


    DEBUG_PRINT(API,
                INFO,
                ("DBLBUFFER::CopyOut: Copying ( to: %x bytes-to-copy=%d )\n",
                (lpBuffer+*lpdwBytesReceived),
                dwBytesToCopy
                ));


    //
    // Transfer Data to User's buffer.
    //

    CopyMemory ((lpBuffer+*lpdwBytesReceived),
                            _lpBufferOut,
                            dwBytesToCopy);


    //
    // Update the number of bytes we copied to the user buffer
    //

    *lpdwBytesRead                  += dwBytesToCopy;
    *lpdwBytesReceived              += dwBytesToCopy;
    *lpdwBufferRemaining    -= dwBytesToCopy;

    //
    // Update Our Internal Vars
    //

    _dwBufferOut                    -= dwBytesToCopy;
    _lpBufferOut                    += dwBytesToCopy;

    UpdateVars();

    //
    // We always succeed for now !
    //

    DEBUG_LEAVE(TRUE);

    return TRUE;
}

BOOL
DBLBUFFER::CompressInputBufferUsage(
    VOID
    )
/*++

Routine Description:

        Moves the input buffer to the begining of the internal allocated buffer.
        This produces a larger block of internal free space.

Arguments:

        none.

Return Value:

    BOOL
    Success - TRUE

    Success     - FALSE, there was no need to compress the buffer.

Comments:

  Assumed to be called only if DblBufferMode is enabled.

--*/


{
    DEBUG_ENTER((DBG_INET,
                 Bool,
                 "DBLBUFFER::CompressInputBufferUsage",
                 NULL
                 ));

    BOOL bResult = FALSE;

    //
    // Maximize use of buffer by moving input data to the front
    // of the buffer.
    //

    INET_ASSERT(_lpBuffer);
    INET_ASSERT(_dwBufferOut == 0);
    INET_ASSERT(_fDblBufferMode);

    if (_lpBufferIn > _lpBuffer) {

        DEBUG_PRINT(API,
                    INFO,
                    ("compressing input buffer %d (%#x) @ %#x => %#x\n",
                    _dwBufferIn,
                    _dwBufferIn,
                    _lpBufferIn,
                    _lpBuffer
                    ));

        MoveMemory(_lpBuffer,
                   _lpBufferIn,
                   _dwBufferIn
                   );

        //
        // Input Buffer now starts at the begining of the allocated buffer
        //

        _lpBufferIn = _lpBuffer;
        bResult = TRUE;
    }

    DEBUG_LEAVE(bResult);

    return bResult;
}



BOOL
DBLBUFFER::ConcatenateOutputBufferUsage(
    IN LPBYTE lpSecondOutputBuffer,
    IN DWORD  dwSecondOutputBufferSize
    )

/*++

Routine Description:

    Combines the current output buffer with the contents of a new buffer.
    (Note: intented for use in combining decrypted data which may be seperated by
    header or trailer data)

Arguments:

    lpSecondOutputBuffer        - New Buffer to combine with internal output buffer.

    dwSecondOutputBufferSize    - Size of New Buffer in bytes.


Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE

Comments:

    If the internal buffer is sized 0, the new buffer replaces the internal buffer.
    Its assumed that the New buffer is a former input buffer turned output by
    some external operation, such as a block decryption operation.
--*/

{


    DEBUG_ENTER((DBG_INET,
                 Bool,
                 "DBLBUFFER::ConcatenateOutputBufferUsage",
                 "%x, %u",
                 lpSecondOutputBuffer,
                 dwSecondOutputBufferSize
                 ));


    //
    // Combinate Two buffers into one.
    //

    INET_ASSERT(_lpBuffer);
    INET_ASSERT(_fDblBufferMode );
    INET_ASSERT(lpSecondOutputBuffer);
    INET_ASSERT(dwSecondOutputBufferSize);

    INET_ASSERT(_lpBufferOut < _lpBufferIn );
    INET_ASSERT(lpSecondOutputBuffer >= _lpBuffer && lpSecondOutputBuffer <=_lpEndOfBuffer );



    if ( _dwBufferOut != 0 )
    {
        DEBUG_PRINT(API,
                    INFO,
                    ("DBLBUFFER::ConcatenateOutputBufferUsage: Combining new data with output buffer\n"
                    ));

        MoveMemory((_lpBufferOut+_dwBufferOut),
                   lpSecondOutputBuffer,
                   dwSecondOutputBufferSize);
        //
        // Output Buffer is now bigger ( sum of orginal + new buffer size )
        //

        _dwBufferOut += dwSecondOutputBufferSize;

    }
    else
    {
        //
        // No previous output buffer, new buffer becomes output buffer
        //

        INET_ASSERT(_lpBufferOut == _lpEndOfBuffer );

        _lpBufferOut = lpSecondOutputBuffer;
        _dwBufferOut = dwSecondOutputBufferSize;

    }

    DEBUG_LEAVE(TRUE);

    return TRUE;
}


BOOL
DBLBUFFER::ResizeBufferIfNeeded(
    IN DWORD dwAddlBufferNeeded
    )

/*++

Routine Description:

    ReSizes internal buffer space to extend size of the buffer by dwAddlBufferNeeded.
    If the additional bytes can be made availble by compressing currently stored
    into one place ( ie the start of the buffer ), the reallocation of the buffer
    will not be done.

Arguments:

    dwAddlBufferNeeded  - Number of additional bytes to resize

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE, the reallocation failed due to lack of memory.

Comments:

    Its assumed the caller will only use this function in dbl buffering mode.

 --*/

{

    DEBUG_ENTER((DBG_INET,
                 Bool,
                 "DBLBUFFER::ResizeBufferIfNeeded",
                 "%u",
                 dwAddlBufferNeeded
                 ));

    INET_ASSERT(_lpBuffer);
    INET_ASSERT(_dwBufferOut == 0 );
    INET_ASSERT(_fDblBufferMode );

    DWORD dwInputBytesFree = GetInputBufferRemaining();

    INET_ASSERT(_lpBuffer == _lpBufferIn );

    //
    // #bytes needed > #bytes left free in Buffer.
    //

    if ( dwAddlBufferNeeded > dwInputBytesFree )
    {
        HLOCAL hBuffer;

        hBuffer = (HLOCAL) _lpBuffer;

        //
        // length increases by (bytes needed - current bytes free[in old buffer])
        //

        _dwBufferLength += (dwAddlBufferNeeded - dwInputBytesFree);

        DEBUG_PRINT(API,
                    INFO,
                    ("DBLBUFFER::ResizeBufferIfNeeded: Resizing Buffer to %d, addl=%d, free=%d\n",
                    _dwBufferLength,
                    dwAddlBufferNeeded,
                    dwInputBytesFree
                    ));

        INET_ASSERT(_dwBufferLength < DBLBUFFER_MAX_SIZE);

        //
        // Do Resize, and store result
        //

        _lpBuffer = (LPBYTE)ResizeBuffer(hBuffer, _dwBufferLength, FALSE);

        DEBUG_PRINT(BUFFER,
                    INFO,
                    ("resized %#x => %#x, %d bytes\n",
                    hBuffer,
                    _lpBuffer,
                    _dwBufferLength
                    ));

        if ( ! _lpBuffer )
        {
            DEBUG_PRINT(API,
                        ERROR,
                        ("DBLBUFFER::ResizeBufferIfNeeded: Failed while Resizing, Out of Mem?\n"
                        ));

            DEBUG_LEAVE(FALSE);

            return FALSE;  // failing due to NOT_ENOUGH_MEMORY
        }

        //
        // Update ReSized Buffer pointers
        //

        _lpBufferIn = _lpBuffer;

        UpdateVars();
    }

    DEBUG_LEAVE(TRUE);

    return TRUE;
}

BOOL
DBLBUFFER::SetOutputInputBuffer(
    IN LPBYTE lpNewOutputBuffer,
    IN DWORD  dwNewOutputBufferSize,
    IN LPBYTE lpNewInputBuffer,
    IN DWORD  dwNewInputBufferSize,
    IN BOOL   fConcatenatePreviousOutput
    )

/*++

Routine Description:

    Allows caller to specify new addresses for input and output buffer.
    If fConcatenatePreviousOutput is set, SetOutputInputBuffer will combine
    the passed in output buffer with any internal output buffer.
    Also allows size changes to buffers.

Arguments:

    lpNewOutputBuffer           - New Output Buffer.

    dwNewOutputBufferSize       - Size of New Output Buffer.

    lpNewInputBuffer            - New Input Buffer.

    dwNewInputBufferSize        - New Input Buffer Size.

    fConcatenatePreviousOutput  - TRUE if we are to combine internal output buffer
                                  with (passed in) new output buffer
                                  FALSE if we are to just replace output buffer pointers.

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE

Comments:

    Assumed to be called from double buffering mode.

--*/


{

    INET_ASSERT(_lpBuffer);
    INET_ASSERT(lpNewOutputBuffer >= _lpBuffer && lpNewOutputBuffer <= _lpEndOfBuffer );
    INET_ASSERT((lpNewInputBuffer >= _lpBuffer && lpNewInputBuffer <= _lpEndOfBuffer) || dwNewInputBufferSize == 0);
    INET_ASSERT(fConcatenatePreviousOutput || _dwBufferOut == 0 );
    INET_ASSERT(_fDblBufferMode );

    DEBUG_PRINT(API,
         INFO,
         ("DBLBUFFER::SetOutputInputBuffer: Getting New Output( %x, size=%d ) New Input( %x, size=%d)\n",
         lpNewOutputBuffer,
         dwNewOutputBufferSize,
         lpNewInputBuffer,
         dwNewInputBufferSize
         ));


    if ( fConcatenatePreviousOutput )
    {
        ConcatenateOutputBufferUsage(
                    lpNewOutputBuffer,
                    dwNewOutputBufferSize
                    );
    }
    else
    {
        _lpBufferOut = lpNewOutputBuffer;
        _dwBufferOut = dwNewOutputBufferSize;
    }


    _lpBufferIn = lpNewInputBuffer;
    _dwBufferIn = dwNewInputBufferSize;

    UpdateVars();

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5.1\autoproxy\utils.cpp ===
#include <wininetp.h>
#include "utils.h"

//----------------------------------------------------------------------------
// HELPER FUNCTIONS
//----------------------------------------------------------------------------


// Function to get the coclass ClassId of a script engine given its name

HRESULT GetScriptEngineClassIDFromName(
	LPCSTR pszLanguage,
	LPSTR pszBuff,
	UINT cBuffSize)
{
	HKEY hKey = NULL;
	HKEY hKeySub;
	LONG result;
	HRESULT hr;
	LONG cClassIdLen;

	// Open \HKEY_CLASSES_ROOT\[pszLanguage]

	// LONG RegOpenKeyEx(
    //	HKEY	hKey,		// handle of open key
    //	LPCTSTR	lpSubKey,	// address of name of subkey to open
    //	DWORD	ulOptions,	// reserved
    //	REGSAM	samDesired,	// security access mask
    //	PHKEY	phkResult 	// address of handle of open key
	// );	

	result = RegOpenKeyEx(HKEY_CLASSES_ROOT, pszLanguage, 0, KEY_READ, &hKey);

	if (result != ERROR_SUCCESS) {
		hr = E_FAIL;
		goto exit;
	}

	// Make sure this object supports OLE Scripting

	result = RegOpenKeyEx(hKey, "OLEScript", 0, KEY_READ, &hKeySub);

	if (result != ERROR_SUCCESS) {
		hr = E_FAIL;
		goto exit;
	}

	RegCloseKey(hKeySub);

	// Get the class ID

	// LONG RegQueryValueEx(
    //	HKEY	hKey,			// handle of key to query
    //	LPTSTR	lpValueName,	// address of name of value to query
    //	LPDWORD	lpReserved,		// reserved
    //	LPDWORD	lpType,			// address of buffer for value type
    //	LPBYTE	lpData,			// address of data buffer
    //	LPDWORD	lpcbData	 	// address of data buffer size
    // );

	result = RegOpenKeyEx(hKey, "CLSID", 0, KEY_READ, &hKeySub);

	if (result != ERROR_SUCCESS) {
		hr = E_FAIL;
		goto exit;
	}

	cClassIdLen = cBuffSize;
	result = RegQueryValue(hKeySub, NULL, pszBuff, &cClassIdLen);

	RegCloseKey(hKeySub);

	if (result != ERROR_SUCCESS) {
		hr = E_FAIL;
		goto exit;
	}

	pszBuff[cBuffSize-1] = '\0';

	hr = S_OK;

exit:
	if (hKey) {
		RegCloseKey(hKey);
	}

	return hr;
}


//=--------------------------------------------------------------------------=
// MakeWideFromAnsi
//=--------------------------------------------------------------------------=
// given a string, make a BSTR out of it.
//
// Parameters:
//    LPSTR         - [in]
//    BYTE          - [in]
//
// Output:
//    LPWSTR        - needs to be cast to final desired result
//
// Notes:
//
LPWSTR MakeWideStrFromAnsi
(
    LPCSTR psz,
    BYTE  bType
)
{
    LPWSTR pwsz;
    int i;

    //  Because delayloaded(DL) functions are being used, need to check
    //that they are loaded.  MakeWideStrFromAnsi() is now currently
    //called only through JSProxy::Invoke, so a check not done in
    //debug mode has already been done.  This check is more to make sure
    //people don't add calls to MakeWideStrFromAnsi without having called
    //DelayLoad( &g_moduleOleAut32)
    INET_ASSERT( g_moduleOleAut32._hDllHandle != NULL);

    // arg checking.
    //
    if (!psz)
        return NULL;

    // compute the length of the required BSTR
    //
    i =  MultiByteToWideChar(CP_ACP, 0, psz, -1, NULL, 0);
    if (i <= 0) return NULL;

    // allocate the widestr, +1 for terminating null
    //
    switch (bType) {
      case STR_BSTR:
        // -1 since it'll add it's own space for a NULL terminator
        //
        pwsz = (LPWSTR) DL(SysAllocStringLen)(NULL, i - 1);
        break;
      case STR_OLESTR:
        pwsz = (LPWSTR) DL(CoTaskMemAlloc)(i * sizeof(WCHAR));
        break;
      default:
        return NULL;
                ;
    }

    if (!pwsz) return NULL;
    MultiByteToWideChar(CP_ACP, 0, psz, -1, pwsz, i);
    pwsz[i - 1] = 0;
    return pwsz;
}

int ConvertAnsiDayToInt(LPSTR szday)
{
	int today = -1;
	if (szday)  // GetDateFormat always returns mixed caps and since this comes from a Win32 API I will
	{			// assume a properly formatted string! :)
		switch (szday[0])
		{
		case 'S' :
			if (lstrcmp(szday,"SUN") == 0)
				today = 0;
			else
			{
				if (lstrcmp(szday,"SAT") == 0)	
					today = 6;
			}
			break;

		case 'M' :
			if (lstrcmp(szday,"MON") == 0)
				today = 1;
			break;

		case 'T' :
			if (lstrcmp(szday,"TUE") == 0)
				today = 2;
			else
			{
				if (lstrcmp(szday,"THU") == 0)	
				today = 4;
			}
			break;

		case 'W' :
			if (lstrcmp(szday,"WED") == 0)
				today = 3;
			break;

		case 'F' :
			if (lstrcmp(szday,"FRI") == 0)
				today = 5;
			break;
		
		}
	}
	return today;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5.1\common\caddrlst.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    caddrlst.cxx

Abstract:

    Contains CAddressList class definition

    Contents:
        CAddressList::FreeList
        CAddressList::SetList
        CAddressList::SetList
        CAddressList::SetList
        CAddressList::GetNextAddress
        CAddressList::InvalidateAddress
        CAddressList::ResolveHost
        CFsm_ResolveHost::RunSM
        (CAddressList::IPAddressToAddressList)
        (CAddressList::HostentToAddressList)
        (CAddressList::AddrInfoToAddressList)

Author:

    Richard L Firth (rfirth) 19-Apr-1997

Environment:

    Win32 user-mode DLL

Revision History:

    19-Apr-1997 rfirth
        Created

    28-Jan-1998 rfirth
        No longer randomly index address list. NT5 and Win98 are modified to
        return the address list in decreasing order of desirability by RTT/
        route

--*/

#include <wininetp.h>
#include <perfdiag.hxx>

//#define TEST_CODE

//Thread-procedure for async gethostbyname
DWORD WINAPI AsyncGetHostByName(LPVOID lpParameter);

//The destructor is called only when all refcounts have dropped to 0.
// i.e. when the INTERNET_HANDLE_OBJECT has released its reference, 
//      AND when all the GHBN threads are done.
//  At this point, we can flush the hostent cache and terminate list.
CResolverCache::~CResolverCache()
{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "CResolverCache::~CResolverCache",
                 "%#x",
                 this
                 ));

    FlushResolverCache(&_ResolverCache);
    TerminateSerializedList(&_ResolverCache);

    if (_pHandlesList)
        delete _pHandlesList;

    DEBUG_LEAVE (0);
}

CGetHostItem::~CGetHostItem()
{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "CGetHostItem::~CGetHostItem",
                 "%#x, %.100q, %B, %#x, %#x",
                 this, _lpszHostName, _fDelete, _pAlloc, _pSession
                 ));

    FREE_FIXED_MEMORY(_lpszHostName);
    if (_hThread)
        CloseHandle(_hThread);
    if (_fDelete && _pAlloc)
        FREE_FIXED_MEMORY(_pAlloc);
    if (_pSession)
        DereferenceObject(_pSession);

    DEBUG_LEAVE(0);
}

void CResolverCache::ForceEmptyAndDeleteHandlesList()
{
    INET_ASSERT(_pHandlesList);
        
    _pHandlesList->LockList();

    CListItem* pItem = _pHandlesList->GetHead();

    while(pItem)
    {
        CListItem* pNext = pItem->GetNext();

        (((CGetHostItem*)pItem)->ForceDelete());
        delete pItem;
        _pHandlesList->ReduceCount();

        pItem = pNext;
    }

    //it's not going to be reused after this, so head and tail don't have to be set to NULL
    // on _pHandlesList
    _pHandlesList->UnlockList();
}

void CResolverCache::EmptyHandlesList()
{
    if (_pHandlesList)
    {
        _pHandlesList->LockList();

        CListItem* pItem = _pHandlesList->GetHead();

        while(pItem)
        {
            CListItem* pNext = pItem->GetNext();

            (((CGetHostItem*)pItem)->WaitDelete());
            delete pItem;
            _pHandlesList->ReduceCount();

            pItem = pNext;
        }

        //it's not going to be reused after this, so head and tail don't have to be set to NULL
        // on _pHandlesList
        _pHandlesList->UnlockList();
    }
}

void CResolverCache::TrimHandlesListSize(ULONG nTrimSize)
{        
    _pHandlesList->LockList();

    if (_pHandlesList->GetCount() >= nTrimSize)
    {
        CListItem* pItem = _pHandlesList->GetHead();
        CListItem* pPrev = NULL;

        while(pItem)
        {
            CListItem* pNext = pItem->GetNext();
            
            if (((CGetHostItem*)pItem)->CanBeDeleted())
            {
                if (pPrev)
                {
                    pPrev->SetNext(pNext);
                }
                else
                {
                    //The item being removed WAS the head.
                    _pHandlesList->SetHead(pNext);
                }

                if (!pNext)
                {
                    //The item being removed WAS the tail.
                    _pHandlesList->SetTail(pPrev);
                }

                delete pItem;
                _pHandlesList->ReduceCount();
            }
            else
            {  
                pPrev = pItem;
            }
            
            pItem = pNext;
        }
    }

    _pHandlesList->UnlockList();
}

BOOL CResolverCache::AddToHandlesList(HANDLE hThread, CGetHostItem* pGetHostItem)
{
    BOOL bRetval = TRUE;

    INET_ASSERT(_pHandlesList);
    pGetHostItem->SetThreadHandle(hThread);
    
    TrimHandlesListSize();
    _pHandlesList->AddToTail(pGetHostItem);

    return bRetval;    
}

DWORD WINAPI AsyncGetHostByName(LPVOID lpParameter)
{
#ifdef WINHTTP_FOR_MSXML
    //
    // MSXML needs to initialize is thread local storage data.
    // It does not do this during DLL_THREAD_ATTACH, so our
    // worker thread must explicitly call into MSXML to initialize
    // its TLS for this thread.
    //
    InitializeMsxmlTLS();
#endif

    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "AsyncGetHostByName",
                 "%#x, %.100q",
                 lpParameter,
                 lpParameter ? ((CGetHostItem*)lpParameter)->GetHostName() : "NULL"
                 ));

    CGetHostItem* pGetHostItem = (CGetHostItem*)lpParameter;

    if (!pGetHostItem)
    {
        INET_ASSERT (FALSE);

        DEBUG_LEAVE (ERROR_NOT_ENOUGH_MEMORY);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    LPSTR lpszHostName = pGetHostItem->GetHostName();
    LPADDRINFO lpAddrInfo = NULL;
    ADDRINFO Hints;
    memset(&Hints, 0, sizeof(struct addrinfo));
    Hints.ai_flags = AI_CANONNAME;
    Hints.ai_family = PF_UNSPEC;      // Accept any protocol family.
    Hints.ai_socktype = SOCK_STREAM;  // Constrain results to stream socket.
    Hints.ai_protocol = IPPROTO_TCP;  // Constrain results to TCP.

    DWORD dwError = 0;

    if (0 == (dwError = _I_getaddrinfo(lpszHostName, NULL, &Hints, &lpAddrInfo)))
    {
        VOID* pAlloc = pGetHostItem->GetAllocPointer();
        AddResolverCacheEntry((pGetHostItem->GetResolverCache())->GetResolverCacheList(), lpszHostName, lpAddrInfo, LIVE_DEFAULT, &pAlloc, pGetHostItem->GetAllocSize());
        if (pAlloc)
        {
            //pAlloc is overwritten to NULL in CacheHostent if the memory is used,
            //we need to delete the alloced memory only if non-NULL
            pGetHostItem->SetDelete();
        }
    }

    DEBUG_LEAVE (dwError);
    return dwError;
}

DWORD AsyncGetHostByNameCleanup(LPVOID lpParameter)
{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "AsyncGetHostByNameCleanup",
                 "%#x, %.100q",
                 lpParameter,
                 lpParameter ? ((CGetHostItem*)lpParameter)->GetHostName() : "NULL"
                 ));

    CGetHostItem* pGetHostItem = (CGetHostItem*)lpParameter;

    if (!pGetHostItem)
    {
        INET_ASSERT (FALSE);

        DEBUG_LEAVE (ERROR_NOT_ENOUGH_MEMORY);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    CFsm_ResolveHost* pFsm = (CFsm_ResolveHost *)pGetHostItem->GetAllocPointer();

    if (!pFsm->TestAndSetScheduled())
    {
        pFsm->QueueWorkItem();
    }
    else
    {
        DWORD dwDummy = 0;
        
        //only release reference && cleanup
        pFsm->Dereference(&dwDummy);
    }

    delete pGetHostItem;

    DEBUG_LEAVE (ERROR_SUCCESS);
    return ERROR_SUCCESS;
}

DWORD AsyncGetHostByNameWorker(LPVOID lpParameter)
{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "AsyncGetHostByNameWorker",
                 "%#x, %.100q",
                 lpParameter,
                 lpParameter ? ((CGetHostItem*)lpParameter)->GetHostName() : "NULL"
                 ));

    CGetHostItem* pGetHostItem = (CGetHostItem*)lpParameter;

    if (!pGetHostItem)
    {
        INET_ASSERT (FALSE);

        DEBUG_LEAVE (ERROR_NOT_ENOUGH_MEMORY);
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    
    LPSTR lpszHostName = pGetHostItem->GetHostName();
    HMODULE hMod = pGetHostItem->GetModuleHandle();
    LPADDRINFO lpAddrInfo = NULL;
    ADDRINFO Hints;
    memset(&Hints, 0, sizeof(struct addrinfo));
    Hints.ai_flags = AI_CANONNAME;
    Hints.ai_family = PF_UNSPEC;      // Accept any protocol family.
    Hints.ai_socktype = SOCK_STREAM;  // Constrain results to stream socket.
    Hints.ai_protocol = IPPROTO_TCP;  // Constrain results to TCP.

    DWORD dwError = 0;

    if (0 == (dwError = _I_getaddrinfo(lpszHostName, NULL, &Hints, &lpAddrInfo)))
    {
        AddResolverCacheEntry((pGetHostItem->GetResolverCache())->GetResolverCacheList(), lpszHostName, lpAddrInfo, LIVE_DEFAULT);
    }

    dwError = AsyncGetHostByNameCleanup(lpParameter);

    DEBUG_LEAVE (dwError);
    
    if (hMod)
        FreeLibraryAndExitThread(hMod, dwError);
    
    return dwError;
}

//
// methods
//

VOID
CAddressList::FreeList(
    VOID
    )

/*++

Routine Description:

    Free address list

Arguments:

    None.

Return Value:

    None.

--*/

{
    if (m_Addresses != NULL) {
        m_Addresses = (LPRESOLVED_ADDRESS)FREE_MEMORY((HLOCAL)m_Addresses);

        INET_ASSERT(m_Addresses == NULL);

        m_AddressCount = 0;
        m_BadAddressCount = 0;
        m_CurrentAddress = 0;
    }
}


DWORD
CAddressList::SetList(
    IN DWORD dwIpAddress
    )

/*++

Routine Description:

    Sets the list contents from the IP address

Arguments:

    dwIpAddress - IP address from which to create list contents

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    if (!Acquire())
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    FreeList();

    DWORD error = IPAddressToAddressList(dwIpAddress);

    Release();

    return error;
}


DWORD
CAddressList::SetList(
    IN LPHOSTENT lpHostent
    )

/*++

Routine Description:

    Sets the list contents from the hostent

Arguments:

    lpHostent   - pointer to hostent containing resolved addresses to add

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    if (!Acquire())
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    FreeList();

    DWORD error = HostentToAddressList(lpHostent);

    Release();

    return error;
}


DWORD
CAddressList::SetList(
    IN struct addrinfo FAR *lpAddrInfo
    )

/*++

Routine Description:

    Sets the list contents from the addrinfo.  Basically just a wrapper
    around AddrInfoToAddressList() that also grabs the critical section.

Arguments:

    lpAddrInfo  - Pointer to addrinfo containing resolved addresses to add.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    if (!Acquire())
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    FreeList();

    DWORD error = AddrInfoToAddressList(lpAddrInfo);

    Release();

    return error;
}



BOOL
CAddressList::GetNextAddress(
    OUT LPDWORD lpdwResolutionId,
    IN OUT LPDWORD lpdwIndex,
    IN INTERNET_PORT nPort,
    OUT LPCSADDR_INFO lpAddressInfo
    )

/*++

Routine Description:

    Get next address to use when connecting. If we already have a preferred
    address, use that. We make a copy of the address to use in the caller's
    data space

Arguments:

    lpdwResolutionId    - used to determine whether the address list has been
                          resolved between calls

    lpdwIndex           - IN: current index tried; -1 if we want to try default
                          OUT: index of address address returned if successful

    nPort               - which port we want to connect to

    lpAddressInfo       - pointer to returned address if successful

Return Value:

    BOOL
        TRUE    - lpResolvedAddress contains resolved address to use

        FALSE   - need to (re-)resolve name

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Bool,
                 "CAddressList::GetNextAddress",
                 "%#x [%d], %#x [%d], %d, %#x",
                 lpdwResolutionId,
                 *lpdwResolutionId,
                 lpdwIndex,
                 *lpdwIndex,
                 nPort,
                 lpAddressInfo
                 ));

    PERF_ENTER(GetNextAddress);

    BOOL bOk = TRUE;

    //
    // if we tried all the addresses and failed already, re-resolve the name
    //

    if (!Acquire())
    {
        bOk = FALSE;
        goto quit;
    }

    if (m_BadAddressCount < m_AddressCount) {
        if (*lpdwIndex != (DWORD)-1) {

            INET_ASSERT(m_BadAddressCount < m_AddressCount);

            INT i = 0;

            m_CurrentAddress = *lpdwIndex;

            INET_ASSERT((m_CurrentAddress >= 0)
                        && (m_CurrentAddress < m_AddressCount));

            if ((m_CurrentAddress < 0) || (m_CurrentAddress >= m_AddressCount)) {
                m_CurrentAddress = 0;
            }
            do {
                NextAddress();
                if (++i == m_AddressCount) {
                    bOk = FALSE;
                    break;
                }
            } while (!IsCurrentAddressValid());
        }

        //
        // check to make sure this address hasn't expired
        //

        //if (!CheckHostentCacheTtl()) {
        //    bOk = FALSE;
        //}
    } else {

        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("exhausted %d addresses\n",
                    m_BadAddressCount
                    ));

        bOk = FALSE;
    }
    if (bOk) {

        DWORD dwLocalLength = LocalSockaddrLength();
        LPBYTE lpRemoteAddr = (LPBYTE)(lpAddressInfo + 1) + dwLocalLength;

        memcpy(lpAddressInfo + 1, LocalSockaddr(), dwLocalLength);
        memcpy(lpRemoteAddr, RemoteSockaddr(), RemoteSockaddrLength());
        lpAddressInfo->LocalAddr.lpSockaddr = (LPSOCKADDR)(lpAddressInfo + 1);
        lpAddressInfo->LocalAddr.iSockaddrLength = dwLocalLength;
        lpAddressInfo->RemoteAddr.lpSockaddr = (LPSOCKADDR)lpRemoteAddr;
        lpAddressInfo->RemoteAddr.iSockaddrLength = RemoteSockaddrLength();
        lpAddressInfo->iSocketType = SocketType();
        lpAddressInfo->iProtocol = Protocol();
        //
        // The port number field is in the same location in both a
        // sockaddr_in and a sockaddr_in6, so it is safe to cast the
        // sockaddr to sockaddr_in here - this works for IPv4 or IPv6.
        //
        INET_ASSERT(offsetof(SOCKADDR_IN, sin_port) ==
                    offsetof(SOCKADDR_IN6, sin6_port));

        ((LPSOCKADDR_IN)lpAddressInfo->RemoteAddr.lpSockaddr)->sin_port =
            _I_htons((unsigned short)nPort);
        *lpdwIndex = m_CurrentAddress;

        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("current address = %d.%d.%d.%d\n",
                    ((LPBYTE)RemoteSockaddr())[4] & 0xff,
                    ((LPBYTE)RemoteSockaddr())[5] & 0xff,
                    ((LPBYTE)RemoteSockaddr())[6] & 0xff,
                    ((LPBYTE)RemoteSockaddr())[7] & 0xff
                    ));

//dprintf("returning address %d.%d.%d.%d, index %d:%d\n",
//        ((LPBYTE)RemoteSockaddr())[4] & 0xff,
//        ((LPBYTE)RemoteSockaddr())[5] & 0xff,
//        ((LPBYTE)RemoteSockaddr())[6] & 0xff,
//        ((LPBYTE)RemoteSockaddr())[7] & 0xff,
//        m_ResolutionId,
//        m_CurrentAddress
//        );
    }
    *lpdwResolutionId = m_ResolutionId;

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("ResolutionId = %d, Index = %d\n",
                m_ResolutionId,
                m_CurrentAddress
                ));

    Release();

quit:
    PERF_LEAVE(GetNextAddress);

    DEBUG_LEAVE(bOk);

    return bOk;
}
	

VOID
CAddressList::InvalidateAddress(
    IN DWORD dwResolutionId,
    IN DWORD dwAddressIndex
    )

/*++

Routine Description:

    We failed to create a connection. Invalidate the address so other requests
    will try another address

Arguments:

    dwResolutionId  - used to ensure coherency of address list

    dwAddressIndex  - which address to invalidate

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 None,
                 "CAddressList::InvalidateAddress",
                 "%d, %d",
                 dwResolutionId,
                 dwAddressIndex
                 ));
//dprintf("invalidating %d.%d.%d.%d, index %d:%d\n",
//        ((LPBYTE)RemoteSockaddr())[4] & 0xff,
//        ((LPBYTE)RemoteSockaddr())[5] & 0xff,
//        ((LPBYTE)RemoteSockaddr())[6] & 0xff,
//        ((LPBYTE)RemoteSockaddr())[7] & 0xff,
//        dwResolutionId,
//        dwAddressIndex
//        );
    if (!Acquire())
        goto quit;  // just take the hit of trying again, if we can.

    //
    // only do this if the list is the same age as when the caller last tried
    // an address
    //

    if (dwResolutionId == m_ResolutionId) {

        INET_ASSERT(((INT)dwAddressIndex >= 0)
                    && ((INT)dwAddressIndex < m_AddressCount));

        if (dwAddressIndex < (DWORD)m_AddressCount) {
            m_Addresses[dwAddressIndex].IsValid = FALSE;

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("invalidated address %d.%d.%d.%d\n",
                        ((LPBYTE)RemoteSockaddr())[4] & 0xff,
                        ((LPBYTE)RemoteSockaddr())[5] & 0xff,
                        ((LPBYTE)RemoteSockaddr())[6] & 0xff,
                        ((LPBYTE)RemoteSockaddr())[7] & 0xff
                        ));

            INET_ASSERT(m_BadAddressCount <= m_AddressCount);

            if (m_BadAddressCount < m_AddressCount) {
                ++m_BadAddressCount;
                if (m_BadAddressCount < m_AddressCount) {
                    for (int i = 0;
                         !IsCurrentAddressValid() && (i < m_AddressCount);
                         ++i) {
                        NextAddress();
                    }
                }
            }
        }
    }
    Release();

quit:

    DEBUG_LEAVE(0);
}


DWORD
CAddressList::ResolveHost(
    IN LPSTR lpszHostName,
    IN OUT LPDWORD lpdwResolutionId,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Resolves host name (or (IP-)address)

    BUGBUG: Ideally, we don't want to keep hold of worker threads if we are in
            the blocking gethostbyname() call. But correctly handling this is
            difficult, so we always block the thread while we are resolving.
            For this reason, an async request being run on an app thread should
            have switched to a worker thread before calling this function.

Arguments:

    lpszHostName        - host name (or IP-address) to resolve

    lpdwResolutionId    - used to determine whether entry changed

    dwFlags             - controlling request:

                            SF_INDICATE - if set, make indications via callback

                            SF_FORCE    - if set, force (re-)resolve

Return Value:

    DWORD
        Success - ERROR_SUCCESS
                    Name successfully resolved

        Failure - ERROR_WINHTTP_NAME_NOT_RESOLVED
                    Couldn't resolve the name

                  ERROR_NOT_ENOUGH_MEMORY
                    Couldn't allocate memory for the FSM
--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "CAddressList::ResolveHost",
                 "%q, %d, %#x",
                 lpszHostName,
                 *lpdwResolutionId,
                 dwFlags
                 ));

    DWORD error;

    error = DoFsm(New CFsm_ResolveHost(lpszHostName,
                                       lpdwResolutionId,
                                       dwFlags,
                                       this
                                       ));

//quit:

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_ResolveHost::RunSM(
    IN CFsm * Fsm
    )
{
    DEBUG_ENTER((DBG_SESSION,
                 Dword,
                 "CFsm_ResolveHost::RunSM",
                 "%#x",
                 Fsm
                 ));

    CAddressList * pAddressList = (CAddressList *)Fsm->GetContext();
    CFsm_ResolveHost * stateMachine = (CFsm_ResolveHost *)Fsm;
    DWORD error;

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
        error = pAddressList->ResolveHost_Fsm(stateMachine);
        break;

    case FSM_STATE_CONTINUE:
        error = pAddressList->ResolveHost_Continue(stateMachine);
        break;
        
    case FSM_STATE_ERROR:
        error = Fsm->GetError();
        Fsm->SetDone();
        break;

    default:
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_WINHTTP_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CAddressList::ResolveHost_Continue(
    IN CFsm_ResolveHost * Fsm
    )
{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "CAddressList::ResolveHost_Continue",
                 "%#x(%q, %#x [%d], %#x)",
                 Fsm,
                 Fsm->m_lpszHostName,
                 Fsm->m_lpdwResolutionId,
                 *Fsm->m_lpdwResolutionId,
                 Fsm->m_dwFlags
                 ));

    PERF_ENTER(ResolveHost);

    //
    // restore variables from FSM object
    //

    CFsm_ResolveHost & fsm = *Fsm;
    LPSTR lpszHostName = fsm.m_lpszHostName;
    LPDWORD lpdwResolutionId = fsm.m_lpdwResolutionId;
    DWORD dwFlags = fsm.m_dwFlags;
    LPINTERNET_THREAD_INFO lpThreadInfo = fsm.GetThreadInfo();
    INTERNET_HANDLE_BASE * pHandle = fsm.GetMappedHandleObject();
    DWORD error = ERROR_SUCCESS;
    CResolverCache* pResolverCache = GetRootHandle(pHandle)->GetResolverCache();
    LPADDRINFO lpAddrInfo = NULL;
    DWORD ttl;

    UNREFERENCED_PARAMETER(lpThreadInfo); // avoid C4189 warning on free builds

    if (!Acquire())
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    //
    // if the resolution id is different then the name has already been resolved
    //

    if (*lpdwResolutionId == m_ResolutionId) 
    {
        INET_ASSERT(lpThreadInfo->IsAsyncWorkerThread
                    || !pHandle->IsAsyncHandle());

        FreeList();
        
        //
        // now try to find the name or address in the cache. If it's not in the
        // cache then resolution failed
        //
        LPRESOLVER_CACHE_ENTRY lpResolverCacheEntry;

        if (NULL != (lpResolverCacheEntry=QueryResolverCache(pResolverCache->GetResolverCacheList(), lpszHostName, NULL, &lpAddrInfo, &ttl)))
        {
            error = SetList(lpAddrInfo);
            ReleaseResolverCacheEntry(pResolverCache->GetResolverCacheList(), lpResolverCacheEntry);
            ++m_ResolutionId;
        }
        else
        {
            error = ERROR_WINHTTP_NAME_NOT_RESOLVED;
        }

        if ((error == ERROR_SUCCESS) && (dwFlags & SF_INDICATE))
        {
            //
            // inform the app that we have resolved the name
            //

            InternetIndicateStatusAddress(WINHTTP_CALLBACK_STATUS_NAME_RESOLVED,
                                          RemoteSockaddr(),
                                          RemoteSockaddrLength()
                                          );
        }
        *lpdwResolutionId = m_ResolutionId;
    }
    
    Release();
    
exit:
    fsm.SetDone();

    PERF_LEAVE(ResolveHost);

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CAddressList::ResolveHost_Fsm(
    IN CFsm_ResolveHost * Fsm
    )
{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "CAddressList::ResolveHost_Fsm",
                 "%#x(%q, %#x [%d], %#x)",
                 Fsm,
                 Fsm->m_lpszHostName,
                 Fsm->m_lpdwResolutionId,
                 *Fsm->m_lpdwResolutionId,
                 Fsm->m_dwFlags
                 ));

    PERF_ENTER(ResolveHost);

    //
    // restore variables from FSM object
    //

    CFsm_ResolveHost & fsm = *Fsm;
    LPSTR lpszHostName = fsm.m_lpszHostName;
    LPDWORD lpdwResolutionId = fsm.m_lpdwResolutionId;
    DWORD dwFlags = fsm.m_dwFlags;
    LPINTERNET_THREAD_INFO lpThreadInfo = fsm.GetThreadInfo();
    INTERNET_HANDLE_BASE * pHandle = fsm.GetMappedHandleObject();

    UNREFERENCED_PARAMETER(lpThreadInfo); // avoid C4189 warning on free builds

    INET_ASSERT (pHandle);
    
    DWORD error = ERROR_SUCCESS;
    INTERNET_HANDLE_OBJECT * pRoot = GetRootHandle(pHandle);

    INET_ASSERT (pRoot);
    
    CResolverCache* pResolverCache = pRoot->GetResolverCache();
    DWORD dwWaitTime;
    
    LPADDRINFO lpAddrInfo = NULL;
    ADDRINFO Hints;
    DWORD ttl;

    
    //
    // BUGBUG - RLF 04/23/97
    //
    // This is sub-optimal. We want to block worker FSMs and free up the worker
    // thread. Sync client threads can wait. However, since a clash is not very
    // likely, we'll block all threads for now and come up with a better
    // solution later (XTLock).
    //
    // Don't have time to implement the proper solution now
    //

    if (!Acquire())
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    //
    // if the resolution id is different then the name has already been resolved
    //

    if (*lpdwResolutionId != m_ResolutionId) 
    {
        goto done;
    }

    //
    // if we're an app thread making an async request then go async now rather
    // than risk blocking the app thread. This will be the typical scenario for
    // IE, and we care about little else
    //
    // BUGBUG - RLF 05/20/97
    //
    // We should really lock & test the cache first, but let's do that after
    // Beta2 (its perf work)
    //

    // It cannot happen that this condition be true.
    // WinHttpSendRequest would have queued an async fsm if it was async to begin with.
    INET_ASSERT(lpThreadInfo->IsAsyncWorkerThread
                || !pHandle->IsAsyncHandle());
/*
    if (!lpThreadInfo->IsAsyncWorkerThread
        && pHandle->IsAsyncHandle()
        && (fsm.GetAppContext() != NULL)) 
    {

        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("async request on app thread - jumping to hyper-drive\n"
                    ));

        error = Fsm->QueueWorkItem();
        goto done;
    }
 */
    //
    // throw out current list (if any)
    //

    FreeList();

    //
    // let the app know we are resolving the name
    //

    if (dwFlags & SF_INDICATE) 
    {
        error = InternetIndicateStatusString(WINHTTP_CALLBACK_STATUS_RESOLVING_NAME,
                                        lpszHostName,
                                        TRUE/*bCopyBuffer*/
                                        );
                                        
        //bail out if aborted before network operation.
        if (error != ERROR_SUCCESS)
        {
            INET_ASSERT(error == ERROR_WINHTTP_OPERATION_CANCELLED);
            goto done;
        }
    }

    //
    // Figure out if we're being asked to resolve a name or an address literal.
    // If getaddrinfo with the AI_NUMERICHOST flag succeeds then we were
    // given a string representation of an IPv6 or IPv4 address.  Otherwise
    // we expect getaddrinfo to return EAI_NONAME.
    //

    memset(&Hints, 0, sizeof(struct addrinfo));
    Hints.ai_flags = AI_NUMERICHOST;  // Only check for address literals.
    Hints.ai_family = PF_UNSPEC;      // Accept any protocol family.
    Hints.ai_socktype = SOCK_STREAM;  // Constrain results to stream socket.
    Hints.ai_protocol = IPPROTO_TCP;  // Constrain results to TCP.

    error = _I_getaddrinfo(lpszHostName, NULL, &Hints, &lpAddrInfo);
    if (error != EAI_NONAME) {
        if (error != 0) {
            if (error == EAI_MEMORY)
                error = ERROR_NOT_ENOUGH_MEMORY;
            else
                error = ERROR_WINHTTP_NAME_NOT_RESOLVED;
            goto quit;
        }

        // An IP address (either v4 or v6) was passed in.
        // Simply convert to address list representation and quit.
        //
        // NOTE: Previous versions of this code had a function here to
        // make sure the string didn't contain additional info that would
        // invalidate the string.  For example, "111.111.111.111 .msn.com"
        // would allow the navigation to succeed, but the cookies for
        // .msn.com would be retrievable, violating cross-domain security.
        // We no longer need this check because getaddrinfo is far pickier
        // than inetaddr was - getaddrinfo with the AI_NUMERICHOST flag set
        // will only accept a string that parses *exactly* as an IP address
        // literal.  No extra data is allowed.
        //

        error = SetList(lpAddrInfo);
        _I_freeaddrinfo(lpAddrInfo);
        goto quit;
    }
    else
    {
        INET_ASSERT (!lpAddrInfo);
    }

    //
    // 255.255.255.255 (or 65535.65535 or 16777215.255) would never work anyway
    //

    INET_ASSERT(lstrcmp(lpszHostName, "255.255.255.255"));

    //
    // now try to find the name or address in the cache. If it's not in the
    // cache then resolve it
    //

    LPRESOLVER_CACHE_ENTRY lpResolverCacheEntry;

    if (!(dwFlags & SF_FORCE)
    && (NULL != (lpResolverCacheEntry=QueryResolverCache(pResolverCache->GetResolverCacheList(), lpszHostName, NULL, &lpAddrInfo, &ttl))))
    {
        error = SetList(lpAddrInfo);
        ReleaseResolverCacheEntry(pResolverCache->GetResolverCacheList(), lpResolverCacheEntry);
        ++m_ResolutionId;
        goto quit;
    }
    
    //
    // if we call winsock getaddrinfo() then we don't get to find out the
    // time-to-live as returned by DNS, so we have to use the default value
    // (LIVE_DEFAULT)
    //
    
    dwWaitTime = GetTimeoutValue(WINHTTP_OPTION_RESOLVE_TIMEOUT);

    // if a resolve timeout is specified by the application, then honor it.
    // If anything fails in the async pathway, DON'T default to sync GHBN.
    if (dwWaitTime != INFINITE)
    {
        if (pHandle->IsAsyncHandle())
        {
            LPSTR lpszCopyHostName = NewString(lpszHostName);

            if (lpszCopyHostName)
            {
                CGetHostItem* pGetHostItem = New CGetHostItem(lpszCopyHostName, pResolverCache, pRoot, (VOID *)Fsm, 0);

                if (!pGetHostItem)
                {
                    FREE_FIXED_MEMORY(lpszCopyHostName);
                    error = ERROR_NOT_ENOUGH_MEMORY;
                    goto quit;
                }
                fsm.SetState(FSM_STATE_CONTINUE);

                //additional reference for timeout queue
                Fsm->SetTimeout(dwWaitTime);
                Fsm->Reference();
                Fsm->SetPop(FALSE);
                pRoot->Reference();
                
                Release();
                
                error = QueueTimeoutFsm(Fsm, NULL, TRUE);

                if (error != ERROR_IO_PENDING)
                {
                    //didn't succeed queueing fsm to the timeout queue

                    //delete the pGetHostItem to cleanup resources and release the session reference
                    delete pGetHostItem;

                    //remove timeout reference
                    DWORD dwDummy;
                    Fsm->Dereference(&dwDummy);
                    goto exit;
                }

                {
                    HANDLE hThread = 0;
                    DWORD dwThreadId;

                    HMODULE hMod;
                    if (NULL != (hMod = LoadLibrary(VER_ORIGINALFILENAME_STR)))
                    {
                        pGetHostItem->SetModuleHandle(hMod);

                        // create a new thread for name resolution, it will run AsyncGetHostByNameWorker
                        WRAP_REVERT_USER(CreateThread, FALSE, (NULL, 0, &AsyncGetHostByNameWorker,
                                        pGetHostItem, 0, &dwThreadId), hThread);
                        if (!hThread)
                        {
                            FreeLibrary(hMod);
                        }
                    }

                    if (!hThread)
                    {
                        //didn't succeed queueing to resolver but fsm is in timeout queue

                        //delete the pGetHostItem to cleanup resources and release the session reference
                        delete pGetHostItem;

                        if (Fsm->TestAndSetScheduled())
                        {
                            //timeout thread got to it first, so fall out and wait for scheduling from there.
                            error = ERROR_IO_PENDING;
                        }
                        else
                        {
                            error = ERROR_NOT_ENOUGH_MEMORY;
                            //nothing more to do: get cleaned up on this thread with whatever error we have.
                        }

                        goto exit;
                    }

                    // we've started the DNS resolve thread, so return IO-pending to app
                    error = ERROR_IO_PENDING;
                }

                //error = Fsm->QueueWorkItem(COMPLETION_BYTES_RESOLVER, pGetHostItem);

                //if (error != ERROR_IO_PENDING)
                //{
                //    //didn't succeed queueing to resolver but fsm is in timeout queue

                //    //delete the pGetHostItem to cleanup resources and release the session reference
                //    delete pGetHostItem;

                //    if (Fsm->TestAndSetScheduled())
                //    {
                //        //timeout thread got to it first, so fall out and wait for scheduling from there.
                //        error = ERROR_IO_PENDING;
                //    }
                //    else
                //    {
                //        //nothing more to do: get cleaned up on this thread with whatever error we have.
                //        INET_ASSERT (error != ERROR_SUCCESS);
                //    }
                //}
                goto exit;
            }
            else
            {
                error = ERROR_NOT_ENOUGH_MEMORY;
                goto quit;
            }
        }
        
        DWORD dwThreadId;
        LPSTR lpszCopyHostName = NewString(lpszHostName);
        
        if (lpszCopyHostName)
        {
#define SZ_AVG_RESOLVER_ENTRY_BYTES 512
            VOID* pAlloc = ALLOCATE_MEMORY(SZ_AVG_RESOLVER_ENTRY_BYTES);
            CGetHostItem* pGetHostItem = New CGetHostItem(lpszCopyHostName, pResolverCache, NULL, pAlloc, pAlloc?SZ_AVG_RESOLVER_ENTRY_BYTES:0);

            if (!pGetHostItem)
            {
                FREE_FIXED_MEMORY(lpszCopyHostName);
                error = ERROR_NOT_ENOUGH_MEMORY;
                goto quit;
            }
            
            HANDLE hThread = 0;

            WRAP_REVERT_USER(CreateThread, FALSE, (NULL, 0, &AsyncGetHostByName,
                            pGetHostItem, 0, &dwThreadId), hThread);

            // HANDLE hThread = CreateThread(NULL, 0, &AsyncGetHostByName,
            //                  pGetHostItem, 0, &dwThreadId);

            if (!hThread)
            {
                delete pGetHostItem;
                goto failed;
            }
            
            DWORD dwWaitResponse = WaitForSingleObject(hThread, dwWaitTime);

            if (dwWaitResponse == WAIT_OBJECT_0)
            {
                DWORD dwError;
                BOOL fRet = GetExitCodeThread(hThread, &dwError); //want to use this error?

                INET_ASSERT(dwError != STILL_ACTIVE);

                LPRESOLVER_CACHE_ENTRY lpResolverCacheEntry;
                if (fRet && !dwError
                    && (NULL != (lpResolverCacheEntry = QueryResolverCache(pResolverCache->GetResolverCacheList(), lpszCopyHostName, NULL, &lpAddrInfo, &ttl))))
                {
                    error = SetList(lpAddrInfo);
                    ReleaseResolverCacheEntry(pResolverCache->GetResolverCacheList(), lpResolverCacheEntry);
                    ++m_ResolutionId;
                }

                CloseHandle(hThread);
                delete pGetHostItem;

                DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("%q %sresolved\n",
                    lpszHostName,
                    error ? "NOT " : ""
                    ));

                TRACE_PRINT_API(SOCKETS,
                    INFO,
                    ("%q %sresolved\n",
                    lpszHostName,
                    error ? "NOT " : ""
                    ));
            }
            else //(dwWaitResponse == WAIT_TIMEOUT)
            {
                //let thread die and if it successfully resolved host, it can add to cache.
                pResolverCache->AddToHandlesList(hThread, pGetHostItem);

                if (dwWaitResponse == WAIT_TIMEOUT)
                    error = ERROR_WINHTTP_TIMEOUT;
                else
                    error = ERROR_WINHTTP_NAME_NOT_RESOLVED;

                goto quit;
            }
        } //lpszCopyHostName
    }// dwWaitTime (specified on this handle)
    else
    {
        //synchronous getaddrinfo
        Hints.ai_flags = AI_CANONNAME;  // No special treatment this time.
        error = _I_getaddrinfo(lpszHostName, NULL, &Hints, &lpAddrInfo);

        DEBUG_PRINT(SOCKETS,
            INFO,
            ("%q %sresolved\n",
            lpszHostName,
            error ? "NOT " : ""
            ));

        TRACE_PRINT_API(SOCKETS,
            INFO,
            ("%q %sresolved\n",
            lpszHostName,
            error ? "NOT " : ""
            ));

        if (error == 0) 
        {
            AddResolverCacheEntry(pResolverCache->GetResolverCacheList(), lpszHostName, lpAddrInfo, LIVE_DEFAULT);
            error = SetList(lpAddrInfo);
            ++m_ResolutionId;
        }
        else 
        {
            INET_ASSERT (!lpAddrInfo);

            if (error == EAI_MEMORY)
                error = ERROR_NOT_ENOUGH_MEMORY;
            else
                error = ERROR_WINHTTP_NAME_NOT_RESOLVED;
        }

    }
    
failed:

    if (!lpAddrInfo)
    {
        error = ERROR_WINHTTP_NAME_NOT_RESOLVED;
    }

quit:

    if ((error == ERROR_SUCCESS) && (dwFlags & SF_INDICATE)) {

        //
        // inform the app that we have resolved the name
        //

        InternetIndicateStatusAddress(WINHTTP_CALLBACK_STATUS_NAME_RESOLVED,
                                      RemoteSockaddr(),
                                      RemoteSockaddrLength()
                                      );
    }
    *lpdwResolutionId = m_ResolutionId;

done:

    Release();

exit:

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone();
        //PERF_LEAVE(ResolveHost);
    }

    PERF_LEAVE(ResolveHost);

    DEBUG_LEAVE(error);

    return error;
}

//
// private methods
//


PRIVATE
DWORD
CAddressList::IPAddressToAddressList(
    IN DWORD ipAddr
    )

/*++

Routine Description:

    Converts an IP-address to a RESOLVED_ADDRESS

Arguments:

    ipAddr  - IP address to convert

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    LPRESOLVED_ADDRESS address = (LPRESOLVED_ADDRESS)ALLOCATE_MEMORY(
                                                        sizeof(RESOLVED_ADDRESS)

                                                        //
                                                        // 1 local and 1 remote
                                                        // socket address
                                                        //

                                                        + 2 * sizeof(SOCKADDR)
                                                        );
    if (address == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    LPBYTE lpVariable;
    LPSOCKADDR_IN lpSin;

    lpVariable = (LPBYTE)address + (sizeof(RESOLVED_ADDRESS));

    //
    // For this IP address, build a CSADDR_INFO structure:
    // create a local SOCKADDR containing only the address family (AF_INET),
    // everything else is zeroed; create a remote SOCKADDR containing the
    // address family (AF_INET), zero port value and the IP address
    // presented in the arguments
    //

    address->AddrInfo.LocalAddr.lpSockaddr = (LPSOCKADDR)lpVariable;
    address->AddrInfo.LocalAddr.iSockaddrLength = sizeof(SOCKADDR);
    lpSin = (LPSOCKADDR_IN)lpVariable;
    lpVariable += sizeof(*lpSin);
    lpSin->sin_family = AF_INET;
    lpSin->sin_port = 0;
    *(LPDWORD)&lpSin->sin_addr = INADDR_ANY;
    memset(lpSin->sin_zero, 0, sizeof(lpSin->sin_zero));

    address->AddrInfo.RemoteAddr.lpSockaddr = (LPSOCKADDR)lpVariable;
    address->AddrInfo.RemoteAddr.iSockaddrLength = sizeof(SOCKADDR);
    lpSin = (LPSOCKADDR_IN)lpVariable;
    lpVariable += sizeof(*lpSin);
    lpSin->sin_family = AF_INET;
    lpSin->sin_port = 0;
    *(LPDWORD)&lpSin->sin_addr = ipAddr;
    memset(lpSin->sin_zero, 0, sizeof(lpSin->sin_zero));

    address->AddrInfo.iSocketType = SOCK_STREAM;
    address->AddrInfo.iProtocol = IPPROTO_TCP;
    address->IsValid = TRUE;

    //
    // update the object
    //

    INET_ASSERT(m_AddressCount == 0);
    INET_ASSERT(m_Addresses == NULL);

    m_AddressCount = 1;
    m_BadAddressCount = 0;
    m_Addresses = address;
    m_CurrentAddress = 0;   // only one to choose from
    return ERROR_SUCCESS;
}


PRIVATE
DWORD
CAddressList::HostentToAddressList(
    IN LPHOSTENT lpHostent
    )

/*++

Routine Description:

    Converts a HOSTENT structure to an array of RESOLVED_ADDRESSs

Arguments:

    lpHostent   - pointer to HOSTENT to convert

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    INET_ASSERT(lpHostent != NULL);

    LPBYTE * addressList = (LPBYTE *)lpHostent->h_addr_list;

    INET_ASSERT(addressList[0]);

    //
    // first off, figure out how many addresses there are in the hostent
    //

    int nAddrs;

    if (fDontUseDNSLoadBalancing) {
        nAddrs = 1;
    } else {
        for (nAddrs = 0; addressList[nAddrs] != NULL; ++nAddrs) {
            /* NOTHING */
        }
#ifdef TEST_CODE
        nAddrs = 4;
#endif
    }

    LPRESOLVED_ADDRESS addresses = (LPRESOLVED_ADDRESS)ALLOCATE_MEMORY(
                                                nAddrs * (sizeof(RESOLVED_ADDRESS)

                                                //
                                                // need 1 local and 1 remote socket
                                                // address for each
                                                //

                                                + 2 * sizeof(SOCKADDR))
                                                );
    if (addresses == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // for each IP address in the hostent, build a RESOLVED_ADDRESS structure:
    // create a local SOCKADDR containing only the address family (AF_INET),
    // everything else is zeroed; create a remote SOCKADDR containing the
    // address family (AF_INET), zero port value, and the IP address from
    // the hostent presented in the arguments
    //

    LPBYTE lpVariable = (LPBYTE)addresses + (nAddrs * sizeof(RESOLVED_ADDRESS));
    LPSOCKADDR_IN lpSin;

    for (int i = 0; i < nAddrs; ++i) {

        addresses[i].AddrInfo.LocalAddr.lpSockaddr = (LPSOCKADDR)lpVariable;
        addresses[i].AddrInfo.LocalAddr.iSockaddrLength = sizeof(SOCKADDR);
        lpSin = (LPSOCKADDR_IN)lpVariable;
        lpVariable += sizeof(*lpSin);
        lpSin->sin_family = AF_INET;
        lpSin->sin_port = 0;
        *(LPDWORD)&lpSin->sin_addr = INADDR_ANY;
        memset(lpSin->sin_zero, 0, sizeof(lpSin->sin_zero));
        addresses[i].AddrInfo.RemoteAddr.lpSockaddr = (LPSOCKADDR)lpVariable;
        addresses[i].AddrInfo.RemoteAddr.iSockaddrLength = sizeof(SOCKADDR);
        lpSin = (LPSOCKADDR_IN)lpVariable;
        lpVariable += sizeof(*lpSin);
        lpSin->sin_family = AF_INET;
        lpSin->sin_port = 0;
#ifdef TEST_CODE
        //if (i) {
            *(LPDWORD)&lpSin->sin_addr = 0x04030201;
            //*(LPDWORD)&lpSin->sin_addr = 0x1cfe379d;
        //}
#else
        *(LPDWORD)&lpSin->sin_addr = *(LPDWORD)addressList[i];
#endif
        memset(lpSin->sin_zero, 0, sizeof(lpSin->sin_zero));

        addresses[i].AddrInfo.iSocketType = SOCK_STREAM;
        addresses[i].AddrInfo.iProtocol = IPPROTO_TCP;
        addresses[i].IsValid = TRUE;
    }
#ifdef TEST_CODE
    *((LPDWORD)&((LPSOCKADDR_IN)addresses[3].AddrInfo.RemoteAddr.lpSockaddr)->sin_addr) = *(LPDWORD)addressList[0];
    //((LPSOCKADDR_IN)addresses[7].AddrInfo.RemoteAddr.lpSockaddr)->sin_addr = ((LPSOCKADDR_IN)addresses[0].AddrInfo.RemoteAddr.lpSockaddr)->sin_addr;
    //*((LPDWORD)&((LPSOCKADDR_IN)addresses[0].AddrInfo.RemoteAddr.lpSockaddr)->sin_addr) = 0x04030201;
#endif

    //
    // update the object
    //

    INET_ASSERT(m_AddressCount == 0);
    INET_ASSERT(m_Addresses == NULL);

    m_AddressCount = nAddrs;
    m_BadAddressCount = 0;
    m_Addresses = addresses;
    m_CurrentAddress = 0;
    return ERROR_SUCCESS;
}


PRIVATE
DWORD
CAddressList::AddrInfoToAddressList(
    IN struct addrinfo FAR *lpAddrInfo
    )

/*++

Routine Description:

    Converts an addrinfo structure(s) to an array of RESOLVED_ADDRESSes.

Arguments:

    lpAddrInfo  - pointer to AddrInfo chain to convert.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    INET_ASSERT(lpAddrInfo != NULL);

    struct addrinfo *lpCurrentInfo = lpAddrInfo;

    //
    // First off, figure out how many addrinfo structs are on the chain.
    // And how much memory we'll need to hold them as RESOLVED_ADDRESSes.
    // Note we also need space to hold the actual local and remote sockaddrs,
    // the RESOLVED_ADDRESS struct only contains the pointers to them.
    //

    int SpaceNeeded = 0;
    int nAddrs = 0;

    for (; lpCurrentInfo != NULL; lpCurrentInfo = lpCurrentInfo->ai_next) {

        if ((lpCurrentInfo->ai_family != PF_INET) &&
            (lpCurrentInfo->ai_family != PF_INET6)) {

            //
            // Ignore any non-internet addrsses.
            // We won't get any with the current getaddrinfo,
            // but maybe someday.
            //
            continue;
        }

        SpaceNeeded += sizeof(RESOLVED_ADDRESS) + 
            2 * lpCurrentInfo->ai_addrlen;

        nAddrs++;

        if (fDontUseDNSLoadBalancing)
            break;  // Leave after one.
    }

    //
    // Allocate enough memory to hold these as RESOLVED_ADDRESSes.
    //
    LPRESOLVED_ADDRESS addresses = (LPRESOLVED_ADDRESS)
        ALLOCATE_FIXED_MEMORY(SpaceNeeded);
    if (addresses == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // For each IP address in the chain, build a RESOLVED_ADDRESS structure:
    // create a local SOCKADDR containing only the address family,
    // everything else is zeroed; create a remote SOCKADDR containing all
    // the values from the addrinfo structure.
    //

    LPBYTE lpVariable = (LPBYTE)addresses + (nAddrs * sizeof(RESOLVED_ADDRESS));

    lpCurrentInfo = lpAddrInfo;
    for (int i = 0; i < nAddrs; lpCurrentInfo = lpCurrentInfo->ai_next) {

        if ((lpCurrentInfo->ai_family != PF_INET) &&
            (lpCurrentInfo->ai_family != PF_INET6)) {

            //
            // Ignore any non-internet addrsses.
            // We won't get any with the current getaddrinfo,
            // but maybe someday.
            //
            continue;
        }

        addresses[i].AddrInfo.LocalAddr.lpSockaddr = (LPSOCKADDR)lpVariable;
        addresses[i].AddrInfo.LocalAddr.iSockaddrLength =
            lpCurrentInfo->ai_addrlen;
        memset(lpVariable, 0, lpCurrentInfo->ai_addrlen);
        addresses[i].AddrInfo.LocalAddr.lpSockaddr->sa_family = 
            (unsigned short)lpCurrentInfo->ai_family;

        lpVariable += lpCurrentInfo->ai_addrlen;

        addresses[i].AddrInfo.RemoteAddr.lpSockaddr = (LPSOCKADDR)lpVariable;
        addresses[i].AddrInfo.RemoteAddr.iSockaddrLength =
            lpCurrentInfo->ai_addrlen;
        memcpy(lpVariable, lpCurrentInfo->ai_addr, lpCurrentInfo->ai_addrlen);

        lpVariable += lpCurrentInfo->ai_addrlen;

        addresses[i].AddrInfo.iSocketType = lpCurrentInfo->ai_socktype;
        addresses[i].AddrInfo.iProtocol = lpCurrentInfo->ai_protocol;
        addresses[i].IsValid = TRUE;

        i++;
    }

    //
    // update the object
    //

    INET_ASSERT(m_AddressCount == 0);
    INET_ASSERT(m_Addresses == NULL);

    m_AddressCount = nAddrs;
    m_BadAddressCount = 0;
    m_Addresses = addresses;
    m_CurrentAddress = 0;
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\winhttp\v5.1\common\handle.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    handle.cxx

Abstract:

    Contains functions to allocate and deallocate handle values

    Contents:
        HandleInitialize
        HandleTerminate
        AllocateHandle
        FreeHandle
        MapHandleToAddress
        DereferenceObject

Author:

    Richard L Firth (rfirth) 31-Oct-1994

Revision History:

    12-Mar-2001 rajeevd
        Gutted

    11-Jan-1996 rfirth
        Use fixed memory instead of moveable (Win95 has a bug w/ LocalUnlock)

    31-Oct-1994 rfirth
        Created
--*/

#include <wininetp.h>


//
// private prototypes
//

DEBUG_ONLY (PRIVATE void LogHandleClassSizes(); )

//
// functions
//

DWORD HandleInitialize (VOID)
{
    DEBUG_ONLY (LogHandleClassSizes(); )
    return ERROR_SUCCESS;
}


VOID HandleTerminate(VOID)
{
    // nothing to do
}


DWORD AllocateHandle (IN LPVOID Address,OUT LPHINTERNET lpHandle)
{
    HINTERNET Handle = (HINTERNET) Address;
    *lpHandle = Handle;
    return ERROR_SUCCESS;
}


DWORD FreeHandle(IN HINTERNET Handle)
{
    UNREFERENCED_PARAMETER(Handle);    
    return ERROR_SUCCESS;
}


DWORD
MapHandleToAddress(
    IN HINTERNET Handle,
    OUT LPVOID * lpAddress,
    IN BOOL Invalidate
    )

/*++

Routine Description:

    The handle object represented by Handle is referenced

    Assumes:    1. only HINTERNETs visible at the API are presented to this
                   function.
                   
Arguments:

    Handle      - handle value generated by AllocateHandle()

    lpAddress   - place to store mapped address. If the handle has been closed
                  and unmapped, NULL is returned. If the handle is still
                  mapped, even though it has been invalidated, its address will
                  be returned, and its reference count incremented

    Invalidate  - TRUE if we are invalidating t